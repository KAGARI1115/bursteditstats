diff -Nrc2 bash-2.0/.distribution bash-2.01/.distribution
*** bash-2.0/.distribution	Thu Dec 12 15:22:40 1996
--- bash-2.01/.distribution	Wed Dec 31 19:00:00 1969
***************
*** 1 ****
- 2.0
--- 0 ----
diff -Nrc2 bash-2.0/.patchlevel bash-2.01/.patchlevel
*** bash-2.0/.patchlevel	Thu Dec 12 15:22:40 1996
--- bash-2.01/.patchlevel	Wed Dec 31 19:00:00 1969
***************
*** 1 ****
- 0
--- 0 ----
diff -Nrc2 bash-2.0/AUTHORS bash-2.01/AUTHORS
*** bash-2.0/AUTHORS	Wed Dec 31 19:00:00 1969
--- bash-2.01/AUTHORS	Fri Jan  3 17:02:53 1997
***************
*** 0 ****
--- 1,408 ----
+ #
+ # Master author manifest for bash
+ #
+ # Any files appearing in the bash distribution not listed in this file
+ # were created by Chet Ramey.
+ #
+ # Filename	authors (first is original author)
+ #
+ README		Brian Fox, Chet Ramey
+ INSTALL		Brian Fox, Chet Ramey
+ COPYING		Brian Fox, Chet Ramey
+ MANIFEST	Brian Fox, Chet Ramey
+ configure	Chet Ramey
+ Makefile.in	Brian Fox, Chet Ramey
+ configure.in	Chet Ramey
+ aclocal.m4	Chet Ramey
+ config.h.top	Chet Ramey
+ config.h.bot	Chet Ramey
+ config.h.in	Chet Ramey
+ array.c		Chet Ramey
+ print_cmd.c	Brian Fox, Chet Ramey
+ general.c	Brian Fox, Chet Ramey
+ variables.c	Brian Fox, Chet Ramey
+ make_cmd.c	Brian Fox, Chet Ramey
+ copy_cmd.c	Brian Fox, Chet Ramey
+ unwind_prot.c	Brian Fox, Chet Ramey
+ dispose_cmd.c	Brian Fox, Chet Ramey
+ getcwd.c	Roland McGrath, Brian Fox, Chet Ramey
+ bashhist.c	Chet Ramey
+ hash.c		Brian Fox, Chet Ramey
+ parse.y		Brian Fox, Chet Ramey
+ subst.c		Brian Fox, Chet Ramey
+ shell.c		Brian Fox, Chet Ramey
+ sig.c		Chet Ramey
+ trap.c		Brian Fox, Chet Ramey
+ siglist.c	Brian Fox, Chet Ramey
+ version.c	Brian Fox, Chet Ramey
+ flags.c		Brian Fox, Chet Ramey
+ jobs.c		Brian Fox, Chet Ramey
+ input.c		Chet Ramey
+ mailcheck.c	Brian Fox, Chet Ramey
+ pathexp.c	Chet Ramey
+ test.c		Brian Fox, Chet Ramey
+ expr.c		Chet Ramey, Brian Fox
+ alias.c		Brian Fox, Chet Ramey
+ execute_cmd.c	Brian Fox, Chet Ramey
+ bashline.c	Brian Fox, Chet Ramey
+ braces.c	Brian Fox, Chet Ramey
+ bracecomp.c	Brian Fox, Chet Ramey, Tom Tromey
+ nojobs.c	Brian Fox, Chet Ramey
+ vprint.c	Chet Ramey
+ oslib.c		Chet Ramey
+ error.c		Brian Fox, Chet Ramey
+ xmalloc.c	Brian Fox, Chet Ramey
+ alias.h		Brian Fox, Chet Ramey
+ array.h		Chet Ramey
+ builtins.h	Brian Fox, Chet Ramey
+ parser.h	Brian Fox, Chet Ramey
+ variables.h	Brian Fox, Chet Ramey
+ machines.h	Brian Fox, Chet Ramey
+ jobs.h		Brian Fox, Chet Ramey
+ maxpath.h	Brian Fox, Chet Ramey
+ pathexp.h	Chet Ramey
+ mailcheck.h	Chet Ramey
+ filecntl.h	Brian Fox, Chet Ramey
+ hash.h		Brian Fox, Chet Ramey
+ quit.h		Brian Fox, Chet Ramey
+ flags.h		Brian Fox, Chet Ramey
+ shell.h		Brian Fox, Chet Ramey
+ bashjmp.h	Chet Ramey
+ sig.h		Chet Ramey
+ trap.h		Brian Fox, Chet Ramey
+ general.h	Brian Fox, Chet Ramey
+ unwind_prot.h	Brian Fox, Chet Ramey
+ input.h		Brian Fox, Chet Ramey
+ error.h		Brian Fox, Chet Ramey
+ command.h	Brian Fox, Chet Ramey
+ externs.h	Chet Ramey
+ siglist.h	Chet Ramey
+ subst.h		Brian Fox, Chet Ramey
+ dispose_cmd.h	Brian Fox, Chet Ramey
+ bashansi.h	Brian Fox, Chet Ramey
+ make_cmd.h	Brian Fox, Chet Ramey
+ bashhist.h	Chet Ramey
+ bashline.h	Chet Ramey
+ execute_cmd.h	Chet Ramey
+ bashtypes.h	Chet Ramey
+ bashtty.h	Chet Ramey
+ pathnames.h	Chet Ramey
+ y.tab.c		Brian Fox, Chet Ramey
+ y.tab.h		Brian Fox, Chet Ramey
+ parser-built	Brian Fox, Chet Ramey
+ posixstat.h	Brian Fox, Chet Ramey
+ stdc.h		Chet Ramey
+ ansi_stdlib.h	Brian Fox, Chet Ramey
+ memalloc.h	Chet Ramey
+ builtins/ChangeLog	Brian Fox, Chet Ramey
+ builtins/Makefile.in	Brian Fox, Chet Ramey
+ builtins/alias.def	Brian Fox, Chet Ramey
+ builtins/bind.def	Brian Fox, Chet Ramey
+ builtins/break.def	Brian Fox, Chet Ramey
+ builtins/builtin.def	Brian Fox, Chet Ramey
+ builtins/cd.def		Brian Fox, Chet Ramey
+ builtins/colon.def	Brian Fox, Chet Ramey
+ builtins/command.def	Brian Fox, Chet Ramey
+ builtins/common.c	Brian Fox, Chet Ramey
+ builtins/declare.def	Brian Fox, Chet Ramey
+ builtins/echo.def	Brian Fox, Chet Ramey
+ builtins/enable.def	Brian Fox, Chet Ramey
+ builtins/eval.def	Brian Fox, Chet Ramey
+ builtins/exec.def	Brian Fox, Chet Ramey
+ builtins/exit.def	Brian Fox, Chet Ramey
+ builtins/fc.def		Brian Fox, Chet Ramey
+ builtins/fg_bg.def	Brian Fox, Chet Ramey
+ builtins/getopt.c	Roland McGrath, Brian Fox, Chet Ramey
+ builtins/getopt.h	Roland McGrath, Brian Fox, Chet Ramey
+ builtins/getopts.def	Brian Fox, Chet Ramey
+ builtins/hash.def	Brian Fox, Chet Ramey
+ builtins/hashcom.h	Brian Fox, Chet Ramey
+ builtins/help.def	Brian Fox, Chet Ramey
+ builtins/let.def	Chet Ramey, Brian Fox
+ builtins/history.def	Brian Fox, Chet Ramey
+ builtins/jobs.def	Brian Fox, Chet Ramey
+ builtins/kill.def	Brian Fox, Chet Ramey
+ builtins/mkbuiltins.c	Brian Fox, Chet Ramey
+ builtins/pushd.def	Brian Fox, Chet Ramey
+ builtins/read.def	Brian Fox, Chet Ramey
+ builtins/reserved.def	Brian Fox, Chet Ramey
+ builtins/return.def	Brian Fox, Chet Ramey
+ builtins/set.def	Brian Fox, Chet Ramey
+ builtins/setattr.def	Brian Fox, Chet Ramey
+ builtins/shift.def	Brian Fox, Chet Ramey
+ builtins/shopt.def	Chet Ramey
+ builtins/source.def	Brian Fox, Chet Ramey
+ builtins/suspend.def	Brian Fox, Chet Ramey
+ builtins/test.def	Brian Fox, Chet Ramey
+ builtins/times.def	Brian Fox, Chet Ramey
+ builtins/trap.def	Brian Fox, Chet Ramey
+ builtins/type.def	Brian Fox, Chet Ramey
+ builtins/ulimit.def	Chet Ramey, Brian Fox
+ builtins/umask.def	Brian Fox, Chet Ramey
+ builtins/wait.def	Brian Fox, Chet Ramey
+ builtins/psize.c	Chet Ramey, Brian Fox
+ builtins/psize.sh	Chet Ramey, Brian Fox
+ builtins/inlib.def	Chet Ramey
+ builtins/bashgetopt.c	Chet Ramey
+ builtins/common.h	Chet Ramey
+ builtins/bashgetopt.h	Chet Ramey
+ lib/doc-support/texindex.c	bug-texinfo@prep.ai.mit.edu, Chet Ramey
+ lib/doc-support/Makefile.in	Chet Ramey
+ lib/doc-support/getopt.h	Roland McGrath
+ lib/doc-support/getopt.c	Roland McGrath
+ lib/doc-support/getopt1.c	Roland McGrath
+ lib/glob/ChangeLog	Brian Fox, Chet Ramey
+ lib/glob/Makefile.in	Brian Fox, Chet Ramey
+ lib/glob/fnmatch.c	Roland McGrath, Brian Fox, Chet Ramey
+ lib/glob/fnmatch.h	Roland McGrath, Brian Fox, Chet Ramey
+ lib/glob/glob.c		Richard Stallman, Roland McGrath, Brian Fox, Chet Ramey
+ lib/glob/glob.h		Chet Ramey
+ lib/glob/ndir.h		Doug Gwyn, Richard Stallman
+ lib/glob/doc/Makefile.in	Brian Fox, Chet Ramey
+ lib/glob/doc/glob.texi	Brian Fox, Chet Ramey
+ lib/malloc/Makefile.in	Chet Ramey
+ lib/malloc/alloca.c	Doug Gwyn, Richard Stallman, Brian Fox, Chet Ramey
+ lib/malloc/getpagesize.h	Brian Fox, Chet Ramey
+ lib/malloc/malloc.c	Chris Kingsley, Mike Muuss, Richard Stallman, Brian Fox, Chet Ramey
+ lib/malloc/gmalloc.c	Mike Haertel, Roland McGrath
+ lib/malloc/stub.c	Chet Ramey
+ lib/malloc/i386-alloca.s	Richard Stallman
+ lib/malloc/x386-alloca.s	Chip Salzenberg, Richard Stallman
+ lib/malloc/xmalloc.c	Brian Fox, Chet Ramey
+ lib/posixheaders/posixstat.h	Brian Fox, Chet Ramey
+ lib/posixheaders/ansi_stdlib.h	Brian Fox, Chet Ramey
+ lib/posixheaders/stdc.h	Chet Ramey
+ lib/posixheaders/memalloc.h	Chet Ramey
+ lib/posixheaders/filecntl.h	Brian Fox, Chet Ramey
+ lib/readline/Makefile.in	Brian Fox, Chet Ramey
+ lib/readline/COPYING	Brian Fox, Chet Ramey
+ lib/readline/ChangeLog	Brian Fox, Chet Ramey
+ lib/readline/readline.c	Brian Fox, Chet Ramey
+ lib/readline/vi_mode.c	Brian Fox, Chet Ramey
+ lib/readline/emacs_keymap.c	Brian Fox, Chet Ramey
+ lib/readline/vi_keymap.c	Brian Fox, Chet Ramey
+ lib/readline/funmap.c	Brian Fox, Chet Ramey
+ lib/readline/keymaps.c	Brian Fox, Chet Ramey
+ lib/readline/xmalloc.c	Brian Fox, Chet Ramey
+ lib/readline/search.c	Brian Fox, Chet Ramey
+ lib/readline/isearch.c	Brian Fox, Chet Ramey
+ lib/readline/parens.c	Brian Fox, Chet Ramey
+ lib/readline/rltty.c	Brian Fox, Chet Ramey
+ lib/readline/complete.c	Brian Fox, Chet Ramey
+ lib/readline/bind.c	Brian Fox, Chet Ramey
+ lib/readline/display.c	Brian Fox, Chet Ramey
+ lib/readline/signals.c	Brian Fox, Chet Ramey
+ lib/readline/kill.c	Brian Fox, Chet Ramey
+ lib/readline/undo.c	Brian Fox, Chet Ramey
+ lib/readline/input.c	Brian Fox, Chet Ramey
+ lib/readline/macro.c	Brian Fox, Chet Ramey
+ lib/readline/util.c	Brian Fox, Chet Ramey
+ lib/readline/callback.c	Chet Ramey
+ lib/readline/readline.h	Brian Fox, Chet Ramey
+ lib/readline/chardefs.h	Brian Fox, Chet Ramey
+ lib/readline/keymaps.h	Brian Fox, Chet Ramey
+ lib/readline/rldefs.h	Brian Fox, Chet Ramey
+ lib/readline/posixstat.h	Brian Fox, Chet Ramey
+ lib/readline/ansi_stdlib.h	Brian Fox, Chet Ramey
+ lib/readline/memalloc.h	Chet Ramey
+ lib/readline/rlconf.h	Chet Ramey
+ lib/readline/rltty.h	Chet Ramey
+ lib/readline/history.c	Brian Fox, Chet Ramey
+ lib/readline/histexpand.c	Brian Fox, Chet Ramey
+ lib/readline/histfile.c	Brian Fox, Chet Ramey
+ lib/readline/histsearch.c	Brian Fox, Chet Ramey
+ lib/readline/history.h	Brian Fox, Chet Ramey
+ lib/readline/histlib.h	Brian Fox, Chet Ramey
+ lib/readline/tilde.c	Brian Fox, Chet Ramey
+ lib/readline/tilde.h	Brian Fox, Chet Ramey
+ lib/readline/doc/texindex.c	bug-texinfo@prep.ai.mit.edu, Chet Ramey
+ lib/readline/doc/Makefile	Brian Fox, Chet Ramey
+ lib/readline/doc/rlman.texinfo	Brian Fox, Chet Ramey
+ lib/readline/doc/rltech.texinfo	Brian Fox, Chet Ramey
+ lib/readline/doc/rluser.texinfo	Brian Fox, Chet Ramey
+ lib/readline/doc/hist.texinfo	Brian Fox, Chet Ramey
+ lib/readline/doc/hstech.texinfo	Brian Fox, Chet Ramey
+ lib/readline/doc/hsuser.texinfo	Brian Fox, Chet Ramey
+ lib/readline/examples/Makefile	Brian Fox
+ lib/readline/examples/fileman.c	Brian Fox
+ lib/readline/examples/manexamp.c	Brian Fox
+ lib/readline/examples/histexamp.c	Brian Fox, Chet Ramey
+ lib/readline/examples/rltest.c	Brian Fox, Chet Ramey
+ lib/readline/examples/Inputrc	Brian Fox, Chet Ramey
+ lib/termcap/Makefile.in	David MacKenzie, Chet Ramey
+ lib/termcap/termcap.c	David MacKenzie
+ lib/termcap/termcap.h	David MacKenzie
+ lib/termcap/tparam.c	David MacKenzie
+ lib/termcap/version.c	David MacKenzie
+ lib/termcap/grot/termcap.info	David MacKenzie
+ lib/termcap/grot/termcap.info-1	David MacKenzie
+ lib/termcap/grot/termcap.info-2	David MacKenzie
+ lib/termcap/grot/termcap.info-3	David MacKenzie
+ lib/termcap/grot/termcap.info-4	David MacKenzie
+ lib/termcap/grot/NEWS	David MacKenzie
+ lib/termcap/grot/INSTALL	David MacKenzie
+ lib/termcap/grot/ChangeLog	David MacKenzie
+ lib/termcap/grot/texinfo.tex	David MacKenzie
+ lib/termcap/grot/termcap.texi	David MacKenzie
+ lib/termcap/grot/Makefile.in	David MacKenzie
+ lib/termcap/grot/configure	David MacKenzie
+ lib/termcap/grot/configure.in	David MacKenzie
+ lib/termcap/grot/COPYING	David MacKenzie
+ lib/termcap/grot/README	David MacKenzie
+ lib/tilde/ChangeLog	Brian Fox, Chet Ramey
+ lib/tilde/Makefile.in	Brian Fox, Chet Ramey
+ lib/tilde/doc/tilde.texi	Brian Fox, Chet Ramey
+ lib/tilde/doc/Makefile	Brian Fox, Chet Ramey
+ lib/tilde/tilde.c	Brian Fox, Chet Ramey
+ lib/tilde/tilde.h	Brian Fox, Chet Ramey
+ lib/tilde/memalloc.h	Brian Fox, Chet Ramey
+ CWRU/misc/open-files.c	Chet Ramey
+ CWRU/misc/sigs.c	Chet Ramey
+ CWRU/misc/pid.c		Chet Ramey
+ CWRU/misc/sigstat.c	Chet Ramey
+ CWRU/misc/bison		Chet Ramey
+ CWRU/misc/aux-machine-desc	Chet Ramey
+ CWRU/PLATFORMS		Chet Ramey
+ CWRU/README		Chet Ramey
+ CWRU/CWRU.CHANGES.051093	Chet Ramey
+ CWRU/POSIX.NOTES	Chet Ramey
+ CWRU/CWRU.CHANGES.071193	Chet Ramey
+ CWRU/CWRU.CHANGES.090393	Chet Ramey
+ doc/Makefile.in		Brian Fox, Chet Ramey
+ doc/bash.1		Chet Ramey
+ doc/builtins.1		Chet Ramey
+ doc/bash.ps		Chet Ramey
+ doc/bash.txt		Chet Ramey
+ doc/readline.3		Chet Ramey
+ doc/readline.ps		Chet Ramey
+ doc/readline.txt	Chet Ramey
+ doc/texinfo.tex		Richard Stallman
+ doc/features.texi	Brian Fox, Chet Ramey
+ doc/features.ps		Brian Fox, Chet Ramey
+ doc/features.info	Brian Fox, Chet Ramey
+ doc/features.dvi	Brian Fox, Chet Ramey
+ doc/bash_builtins.1	Chet Ramey
+ doc/bash_builtins.ps	Chet Ramey
+ doc/bash_builtins.txt	Chet Ramey
+ doc/bash_builtins.readme	Chet Ramey
+ doc/article.ms		Chet Ramey
+ doc/FAQ			Chet Ramey
+ support/cat-s		Brian Fox, Chet Ramey
+ support/mksysdefs	Brian Fox, Chet Ramey
+ support/mkversion.c	Brian Fox, Chet Ramey
+ support/mksignames.c	Brian Fox, Chet Ramey
+ support/getcppsyms.c	Brian Fox, Chet Ramey
+ support/cppmagic	Brian Fox, Chet Ramey
+ support/pagesize.sh	Chet Ramey, Brian Fox
+ support/pagesize.c	Chet Ramey, Brian Fox
+ support/bash.xbm	Brian Fox
+ support/FAQ		Brian Fox
+ support/PORTING		Brian Fox
+ support/mklinks		Brian Fox
+ support/fixlinks	Chet Ramey
+ support/mkdirs		Chet Ramey
+ support/clone-bash	Chet Ramey
+ support/bashbug.sh	Chet Ramey
+ support/mkmachtype	Chet Ramey
+ support/recho.c		Chet Ramey
+ support/config.guess	Per Bothner, Chet Ramey
+ support/config.sub	Richard Stallman, Chet Ramey
+ support/install.sh	MIT X Consortium (X11R5)
+ support/endian.c	Chet Ramey
+ support/printenv	Chet Ramey
+ examples/precedence-tester	Brian Fox, Chet Ramey
+ examples/functions/substr	Brian Fox, Chet Ramey
+ examples/functions/kshenv	Chet Ramey
+ examples/functions/autoload	Chet Ramey
+ examples/functions/csh-compat	Brian Fox, Chet Ramey
+ examples/functions/shcat	Chet Ramey
+ examples/functions/substr2	Chet Ramey
+ examples/functions/term		Chet Ramey
+ examples/functions/whatis	Chet Ramey
+ examples/functions/whence	Chet Ramey
+ examples/functions/func		Chet Ramey
+ examples/functions/dirname	Brian Fox, Noah Friedman
+ examples/functions/basename	Brian Fox, Noah Friedman
+ examples/functions/exitstat	Noah Friedman, Roland McGrath
+ examples/functions/external	Noah Friedman
+ examples/functions/fact		Brian Fox
+ examples/functions/manpage	Tom Tromey
+ examples/functions/fstty	Chet Ramey
+ examples/functions/jj.bash	Chet Ramey
+ examples/functions/notify.bash	Chet Ramey
+ examples/scripts/shprompt	Chet Ramey
+ examples/scripts/adventure.sh	Chet Ramey, Doug Gwyn
+ examples/scripts/bcsh.sh	Chris Robertson, Chet Ramey
+ examples/startup-files/Bashrc	Brian Fox
+ examples/startup-files/Bash_aliases	Brian Fox
+ examples/startup-files/Bash_profile	Brian Fox
+ examples/startup-files/bash-profile	Brian Fox
+ examples/startup-files/bashrc	Chet Ramey
+ examples/suncmd.termcap	Brian Fox, Chet Ramey
+ examples/alias-conv.sh	Brian Fox, Chet Ramey
+ tests/README    	Chet Ramey
+ tests/arith.tests	Chet Ramey
+ tests/arith.right	Chet Ramey
+ tests/array.tests	Chet Ramey
+ tests/array.right	Chet Ramey
+ tests/dollar-at.sh      Chet Ramey
+ tests/dollar-star.sh    Chet Ramey
+ tests/dollar.right      Chet Ramey
+ tests/exp-tests 	Chet Ramey
+ tests/exp.right 	Chet Ramey
+ tests/glob-test 	Chet Ramey
+ tests/glob.right        Chet Ramey
+ tests/ifs-test-1.sh     Chet Ramey
+ tests/ifs-test-2.sh     Chet Ramey
+ tests/ifs-test-3.sh     Chet Ramey
+ tests/ifs.1.right       Chet Ramey
+ tests/ifs.2.right       Chet Ramey
+ tests/ifs.3.right       Chet Ramey
+ tests/input-line.sh     Chet Ramey
+ tests/input-line.sub    Chet Ramey
+ tests/input.right       Chet Ramey
+ tests/minus-e   	Chet Ramey
+ tests/minus-e.right     Chet Ramey
+ tests/new-exp.tests     Chet Ramey
+ tests/new-exp.right     Chet Ramey
+ tests/prec.right        Chet Ramey
+ tests/precedence        Chet Ramey
+ tests/run-all   	Chet Ramey
+ tests/run-dollars       Chet Ramey
+ tests/run-exp-tests     Chet Ramey
+ tests/run-glob-test     Chet Ramey
+ tests/run-ifs-tests     Chet Ramey
+ tests/run-input-test    Chet Ramey
+ tests/run-minus-e       Chet Ramey
+ tests/run-new-exp       Chet Ramey
+ tests/run-precedence    Chet Ramey
+ tests/run-set-e-test    Chet Ramey
+ tests/run-strip 	Chet Ramey
+ tests/run-varenv        Chet Ramey
+ tests/set-e-test        Chet Ramey
+ tests/set-e.right       Chet Ramey
+ tests/strip.tests       Chet Ramey
+ tests/strip.right       Chet Ramey
+ tests/tilde-tests       Chet Ramey
+ tests/tilde.right       Chet Ramey
+ tests/varenv.right      Chet Ramey
+ tests/varenv.sh 	Chet Ramey
+ tests/misc/chld-trap.sh Chet Ramey
+ tests/misc/dot-test-1.sh        Chet Ramey
+ tests/misc/dot-test-1.sub       Chet Ramey
+ tests/misc/gotest       Chet Ramey
+ tests/misc/perf-script  Chet Ramey
+ tests/misc/redir.t1.sh  Chet Ramey
+ tests/misc/redir.t2.sh  Chet Ramey
+ tests/misc/redir.t3.sh  Chet Ramey
+ tests/misc/redir.t3.sub Chet Ramey
+ tests/misc/redir.t4.sh  Chet Ramey
+ tests/misc/run.r1.sh    Chet Ramey
+ tests/misc/run.r2.sh    Chet Ramey
+ tests/misc/run.r3.sh    Chet Ramey
+ tests/misc/sigint.t1.sh Chet Ramey
+ tests/misc/sigint.t2.sh Chet Ramey
+ tests/misc/sigint.t3.sh Chet Ramey
+ tests/misc/sigint.t4.sh Chet Ramey
+ tests/misc/test-minus-e.1       Chet Ramey
+ tests/misc/test-minus-e.2       Chet Ramey
diff -Nrc2 bash-2.0/CHANGES bash-2.01/CHANGES
*** bash-2.0/CHANGES	Sun Dec 22 18:11:43 1996
--- bash-2.01/CHANGES	Tue Jun  3 11:27:55 1997
***************
*** 1,2 ****
--- 1,400 ----
+ This document details the changes between this version, bash-2.01-release,
+ and the previous version, bash-2.01-beta2.
+ 
+ 1.  Changes to Bash
+ 
+ a.  The `distclean' target should remove the `printenv' executable if it
+     has been created.
+ 
+ b.  The test suite was changed slightly to ensure that the error messages
+     are printed in English.
+ 
+ c.  A bug that caused the shell to dump core when a filename containing a
+     `/' was passed to `hash' was fixed.
+ 
+ d.  Pathname canonicalization now leaves a leading `//' intact, as POSIX.1
+     requires.
+ 
+ e.  A memory leak when completing commands was fixed.
+ 
+ f.  A memory leak that occurred when checking the hash table for commands
+     with relative paths was fixed.
+ 
+ ------------------------------------------------------------------------------
+ This document details the changes between this version, bash-2.01-beta2,
+ and the previous version, bash-2.01-beta1.
+ 
+ 1.  Changes to Bash
+ 
+ a.  The `ulimit' builtin translates RLIM_INFINITY to the hard limit only if
+     the current (soft) limit is less than or equal to the hard limit.
+ 
+ b.  Fixed a bug that caused the bash emulation of strcasecmp to produce
+     incorrect results.
+ 
+ c.  A bug that caused memory to be freed twice when a trap handler resets
+     the trap more than once was fixed.
+ 
+ d.  A bug that caused machines where sizeof (pointer) > sizeof (int) to
+     fail (and possibly dump core) when trying to unwind-protect a null
+     pointer was fixed.
+ 
+ e.  The startup files should not be run with job control enabled.  This fix
+     allows SIGINT to once again interrupt startup file execution.
+ 
+ f.  Bash should not change the SIGPROF handler if it is set to something
+     other than SIG_DFL.
+ 
+ g.  The completion code that provides bash-specific completions for readline
+     now quotes characters that the readline code would treat as word break
+     characters if they appear in a file name.
+ 
+ h.  The completion code now correctly quotes filenames containing a `!',
+     even if the user attempted to use double quotes when attempting
+     completion.
+ 
+ i.  A bug that caused the shell to dump core when `disown' was called without
+     arguments and there was no current job was fixed.
+ 
+ j.  A construct like $((foo);bar) is now processed as a command substitution
+     rather than as a bad arithmetic substitution.
+ 
+ k.  A couple of bugs that caused `fc' to not obey the `cmdhist' and `lithist'
+     shell options when editing and re-executing a series of commands were
+     fixed.
+ 
+ l.  A fix was made to the grammar -- the list of commands between `do' and
+     `done' in the body of a `for' command should be treated the same as a
+     while loop.
+ 
+ 2.  Changes to Readline
+ 
+ a.  A couple of bugs that caused the history search functions to attempt to
+     free a NULL pointer were fixed.
+ 
+ b.  If the C library provides setlocale(3), readline does not need to look
+     at various environment variables to decide whether or not to go into
+     eight-bit mode automatically -- just check whether the current locale
+     is not `C' or `POSIX'.
+ 
+ c.  If the filename completion function finds that a directory was not closed
+     by a previous (interrupted) completion, it closes the directory with
+     closedir().
+ 
+ 3.  New Features in Bash
+ 
+ a.  New bindable readline commands:  history-and-alias-expand-line and
+     alias-expand-line.  The code was always in there, there was just no
+     way to execute it.
+ 
+ ------------------------------------------------------------------------------
+ This document details the changes between this version, bash-2.01-beta1,
+ and the previous version, bash-2.01-alpha1.
+ 
+ 1.  Changes to Bash
+ 
+ a.  Fixed a problem that could cause file descriptors used for process
+     substitution to conflict with those used explicitly in redirections.
+ 
+ b.  Made it easier to regenerate configure if the user changes configure.in.
+ 
+ c.  ${GROUPS[0]} should always be the primary group, even on systems without
+     multiple groups.
+ 
+ d.  Spelling correction is no longer enabled by default.
+ 
+ e.  Fixes to quoting problems in `bashbug'.
+ 
+ f.  OS-specific configuration changes were made for: Irix 6.
+ 
+ g.  OS-specific code changes were made for: QNX.
+ 
+ h.  A more meaningful message is now printed when the file in /tmp for a
+     here document cannot be created.
+ 
+ i.  Many changes to the shell's variable initialization code to speed
+     non-interactive startup.
+ 
+ j.  Changes to the non-job-control code so that it does not try to open
+     /dev/tty.
+ 
+ k.  The output of `set' and `export' is once again sorted, as POSIX wants.
+ 
+ l.  Fixed a problem caused by a recursive call reparsing the value of
+     $SHELLOPTS.
+ 
+ m.  The tilde code no longer calls getenv() when it's compiled as part of
+     the shell, which should eliminate problems on systems that cannot
+     redefine getenv(), like the NeXT OS.
+ 
+ n.  Fixed a problem that caused `bash -o' or `bash +o' to not list all
+     the shell options.
+ 
+ o.  Fixed `ulimit' to convert RLIM_INFINITY to the appropriate hard limit
+     only if the hard limit is greater than the current (soft) limit.
+ 
+ p.  Fixed a problem that arose when building bash in a different directory
+     than the source and y.tab.[ch] were remade with something other than
+     bison.  This came up most often on NetBSD.
+ 
+ q.  Fixed a problem with completion -- it thought that `pwd`/[TAB] indicated
+     an unfinished command completion (`/), which generated errors.
+ 
+ r.  The bash special tilde expansions (~-, ~+) are now attempted before
+     calling the standard tilde expansion code, which should eliminate the
+     problems people have been seeing with this on Solaris 2.5.1.
+ 
+ s.  Added support for <stdarg.h> to places where it was missing.
+ 
+ t.  Changed the code that reads the output of a command substitution to not
+     go through stdio.  This reduces the memory requirements and is faster.
+ 
+ u.  A number of changes to speed up export environment creation were made.
+ 
+ v.  A number of memory leaks were fixed as the result of running the test
+     scripts through Purify.
+ 
+ w.  Fixed a bug that caused subshells forked to interpret executable
+     scripts without a leading `#!' to not reinitialize the values of
+     the shell options.
+ 
+ 2.  Changes to Readline
+ 
+ a.  History library has less `#ifdef SHELL' code -- abstracted stuff out
+     into application-specific function hooks.
+ 
+ b.  Readline no longer calls getenv() if it's compiled as part of the shell,
+     which should eliminate problems on systems that cannot redefine getenv(),
+     like the NeXT OS.
+ 
+ c.  Fixed translation of ESC when `untranslating' macro values.
+ 
+ d.  The region kill operation now fixes the mark if it ends up beyond the
+     boundaries of the line after the region is deleted.
+ 
+ 3.  New Features in Bash
+ 
+ a.  New argument for `configure':  `--with-curses'.  This can be used to
+     override the selection of the termcap library on systems where it is
+     deficient.
+ 
+ ------------------------------------------------------------------------------
+ This document details the changes between this version, bash-2.01-alpha1,
+ and the previous version, bash-2.0-release.
+ 
+ 1.  Changes to Bash
+ 
+ a.  System-specific configuration changes for: FreeBSD, SunOS4, Irix,
+     MachTen, QNX 4.2, Harris Night Hawk, SunOS5.
+ 
+ b.  System-specific code changes were made for: Linux, 4.4 BSD, QNX 4.2,
+     HP-UX, AIX 4.2.
+ 
+ c.  A bug that caused the exec builtin to fail because the full pathname of
+     the command could not be found was fixed.
+ 
+ d.  The code that performs output redirections is now more resistant to
+     race conditions and possible security exploits.
+ 
+ e.  A bug that caused the shell to dump core when performing pattern
+     substitutions on variable values was fixed.
+ 
+ f.  More hosts are now recognized by the auto-configuration mechanism
+     (OpenBSD, QNX, others).
+ 
+ g.  Assignments to read-only variables that attempt to convert them to
+     arrays are now errors.
+ 
+ h.  A bug that caused shell scripts using array assignments in POSIX mode
+     to exit after the assignment was performed was fixed.
+ 
+ i.  The substring expansion code is now more careful about running off the
+     ends of the expanded variable value.
+ 
+ j.  A bug that caused completion to fail if a backquoted command substitution
+     appeared anywhere on the line was fixed.
+ 
+ k.  The `source' builtin no longer turns off history if it has been enabled
+     in a non-interactive shell.
+ 
+ l.  A bug that caused the shell to crash when `disown' was given a pid
+     instead of a job number was fixed.
+ 
+ m.  The `cd' spelling correction code will not try to change to `.' if no
+     directory entries match a single-character argument.
+ 
+ n.  A bad variable name supplied to `declare', `export', or `readonly' no
+     longer causes a non-interactive shell in POSIX mode to exit.
+ 
+ o.  Some fixes were made to the test suite to handle peculiarities of
+     various Unix versions.
+ 
+ p.  The bash completion code now quotes characters that readline would
+     treat as word breaks for completion but are not shell metacharacters.
+ 
+ q.  Bad options supplied at invocation now cause a usage message to be
+     displayed.
+ 
+ r.  Fixes were made to the code that handles DEBUG traps so that the trap
+     string is not freed inappropriately.
+ 
+ s.  Some changes were made to the bash debugger in examples/bashdb -- it
+     should be closer to working now.
+ 
+ t.  A problem that caused the default filename used for mail checking to be
+     wrong was fixed.
+ 
+ u.  A fix was made to the `echo' builtin so that NUL characters printed with
+     `echo -e' do not cause the output to be truncated.
+ 
+ v.  A fix was made to the job control code so that the shell behaves better
+     when monitor mode is enabled in a non-interactive shell.
+ 
+ w.  Bash no longer catches all of the terminating signals in a non-
+     interactive shell until a trap is set on EXIT, which should result in
+     quicker startup.
+ 
+ x.  A fix was made to the command timing code so that `time' can be used in
+     a loop.
+ 
+ y.  A fix was made to the parser so that `((cmd); cmd2)' is now parsed as
+     a nested subshell rather than strictly as an (errnoeous) arithmetic
+     command.
+ 
+ z.  A fix was made to the globbing code so that it correctly matches quoted
+     filenames beginning with a `.'.
+ 
+ aa. A bug in `fc' that caused some multi-line commands to not be stored as
+     one command in the history when they were re-executed after editing
+     (with `fc -e') was fixed.
+ 
+ bb. The `ulimit' builtin now attempts to catch some classes of integer
+     overflows.
+ 
+ cc. The command-oriented-history code no longer attempts to add `;'
+     inappropriately when a newline appears while reading a $(...) command
+     substitution.
+ 
+ dd. A bug that caused the shell to dump core when `help --' was executed
+     was fixed.
+ 
+ ee. A bug that caused the shell to crash when an unset variable appeared
+     in the body of a here document after `set -u' had been executed was
+     fixed.
+ 
+ ff. Implicit input redirections from /dev/null for asynchronous commands
+     are now handled better.
+ 
+ gg. A bug that caused the shell to fail to compile when configured with
+     `--disable-readline' was fixed.
+ 
+ hh. The globbing code should now be interruptible.
+ 
+ ii. Bash now notices when the `kill' builtin is used to send SIGCONT to a
+     stopped job and adjusts the data structures accordingly, as if `bg' had
+     been executed instead.
+ 
+ jj. A bug that caused the shell to crash when mixing calls to `getopts'
+     and `shift' on the same set of positional parameters was fixed.
+ 
+ kk. The command printing code now preserves the `-p' flag to `time'.
+ 
+ ll. The command printing code now handles here documents better when there
+     are other redirections associated with the command.
+ 
+ mm. The special glibc environment variable (NNN_GNU_nonoption_argv_flags_)
+     is no longer placed into the environment of executed commands -- users
+     of glibc had too many problems with it.
+ 
+ nn. Reorganized the code that generates signames.h.  The signal_names list
+     is now more complete but may be slightly different (SIGABRT is favored
+     over SIGIOT, for example).  The preferred signal names are those
+     listed in the POSIX.2 standard.
+ 
+ oo. `bashbug' now uses a filename shorter than 14 characters for its
+     temporary file, and asks for confirmation before sending the bug
+     report.
+ 
+ pp. A bug that caused TAB completion in vi editing mode to not be turned
+     off when `set -o posix' was executed or back on when `set +o posix'
+     was executed was fixed.
+ 
+ qq. A bug in the brace expansion code that caused brace expansions appearing
+     in new-style $(...) command substitutions to be inappropriately expanded
+     was fixed.
+ 
+ rr. A bug in the readline hook shell-expand-line that could cause memory to
+     be inappropriately freed was fixed.
+ 
+ ss. A bug that caused some arithmetic expressions containing `&&' and `||'
+     to be parsed with the wrong precedence has been fixed.
+ 
+ tt. References to unbound variables after `set -u' has been executed now
+     cause the shell to exit immediately, as they should.
+ 
+ uu. A bug that caused the shell to exit inappropriately when `set -e' had
+     been executed and a command's return status was being inverted with the
+     `!' reserved word was fixed.
+ 
+ vv. A bug that could occasionally cause the shell to crash with a
+     divide-by-zero error when timing a command was fixed.
+ 
+ ww. A bug that caused parameter pattern substitution to leave stray
+     backslashes in the replacement string when the expression is in
+     double quotes was fixed.
+ 
+ xx. The `break' and `continue' builtins now break out of all loops when an
+     invalid count argument is supplied.
+ 
+ yy. Fixed a bug that caused PATH to be set to the empty string if
+     `command -p' is executed with PATH unset.
+ 
+ zz. Fixed `kill -l signum' to print the signal name without the `SIG' prefix,
+     as POSIX specifies.
+ 
+ aaa. Fixed a bug that caused the shell to crash while setting $SHELLOPTS
+      if there were no shell options set.
+ 
+ bbb. Fixed `export -p' and `readonly -p' so that when the shell is in POSIX
+      mode, their output is as POSIX.2 specifies.
+ 
+ ccc. Fixed a bug in `readonly' so that `readonly -a avar=(...)' actually
+      creates an array variable.
+ 
+ ddd. Fixed a bug that prevented `time' from correctly timing background
+      pipelines.
+ 
+ 2.  Changes to Readline
+ 
+ a.  A bug that caused an extra newline to be printed when the cursor was on
+     an otherwise empty line was fixed.
+ 
+ b.  An instance of memory being used after it was freed was corrected.
+ 
+ c.  The redisplay code now works when the prompt is longer than the screen
+     width.
+ 
+ d.  `dump-macros' is now a bindable name, as it should have been all along.
+ 
+ e.  Non-printable characters are now expanded when displaying macros and
+     their values.
+ 
+ f.  The `dump-variables' and `dump-macros' commands now output a leading
+     newline if they're called as the result of a key sequence, rather
+     than directly by an application.
+ 
+ 3.  New Features in Bash
+ 
+ a.  There is a new builtin array variable: GROUPS, the set of groups to which
+     the user belongs.  This is used by the test suite.
+ 
+ 4.  New Features in Readline
+ 
+ a.  If a key sequence bound to `universal-argument' is read while reading a
+     numeric argument started with `universal-argument', it terminates the
+     argument but is otherwise ignored.  This provides a way to insert multiple
+     instances of a digit string, and is how GNU emacs does it.
+ 
+ ------------------------------------------------------------------------------
  This document details the changes between this version, bash-2.0-release,
  and the previous version, bash-2.0-beta3.
diff -Nrc2 bash-2.0/COMPAT bash-2.01/COMPAT
*** bash-2.0/COMPAT	Sun Dec 22 18:17:58 1996
--- bash-2.01/COMPAT	Fri Apr 11 16:58:48 1997
***************
*** 1,6 ****
  This document details the incompatibilites between this version of bash,
! bash-2.0, and the previous version, bash-1.14.  These were discovered
! by alpha and beta testers, so they will likely be encountered by a
! significant number of users.
  
  1.  Bash now uses a new quoting syntax, $"...", to do locale-specific
--- 1,6 ----
  This document details the incompatibilites between this version of bash,
! bash-2.01, and the previous widely-available version, bash-1.14.  These
! were discovered by alpha and beta testers, so they will likely be
! encountered by a significant number of users. 
  
  1.  Bash now uses a new quoting syntax, $"...", to do locale-specific
***************
*** 72,78 ****
      nolinks, hostname_completion_file, noclobber, no_exit_on_failed_exec, and
      cdable_vars.  Most of them are now implemented with the new `shopt'
!     builtin; others were already implemented by `set'.
  
- 8.  The `ulimit' builtins now sets both hard and soft limits and reports the
-     soft limit by default (when neither -H nor -S is specified).  This is
-     compatible with versions of sh and ksh that implement `ulimit'.
--- 72,103 ----
      nolinks, hostname_completion_file, noclobber, no_exit_on_failed_exec, and
      cdable_vars.  Most of them are now implemented with the new `shopt'
!     builtin; others were already implemented by `set'.  Here is a list of
!     correspondences:
! 
! 	MAIL_WARNING			shopt mailwarn
! 	notify				set -o notify
! 	history_control			HISTCONTROL
! 	command_oriented_history	shopt cmdhist
! 	glob_dot_filenames		shopt dotglob
! 	allow_null_glob_expansion	shopt nullglob
! 	nolinks				set -o physical
! 	hostname_completion_file	HOSTFILE
! 	noclobber			set -o noclobber
! 	no_exit_on_failed_exec		shopt execfail
! 	cdable_vars			shopt cdable_vars
! 
! 8. `ulimit' now sets both hard and soft limits and reports the soft limit
!     by default (when neither -H nor -S is specified).  This is compatible
!     with versions of sh and ksh that implement `ulimit'.  The bash-1.14
!     behavior of, for example,
! 
! 		ulimit -c 0
! 
!     can be obtained with
! 
! 		ulimit -S -c 0
! 
!     It may be useful to define an alias:
! 
! 		alias ulimit="ulimit -S"
  
diff -Nrc2 bash-2.0/CWRU/PLATFORMS bash-2.01/CWRU/PLATFORMS
*** bash-2.0/CWRU/PLATFORMS	Thu Nov 14 11:14:44 1996
--- bash-2.01/CWRU/PLATFORMS	Tue Mar 11 13:52:20 1997
***************
*** 7,14 ****
  SunOS 5.5
  BSDI BSD/OS 2.1
! Motorola SVR3.2
! FreeBSD 2.1.5
  AIX 4.2
  HP/UX 9.05, 10.01, 10.10, 10.20
  
  By other testers:
--- 7,17 ----
  SunOS 5.5
  BSDI BSD/OS 2.1
! FreeBSD 2.1.7
! NetBSD 1.2
  AIX 4.2
+ AIX 4.1.4
  HP/UX 9.05, 10.01, 10.10, 10.20
+ Linux 2.0.29 (libc 5.3.12)
+ Linux 2.0.4 (libc 5.3.12)
  
  By other testers:
diff -Nrc2 bash-2.0/CWRU/POSIX.NOTES bash-2.01/CWRU/POSIX.NOTES
*** bash-2.0/CWRU/POSIX.NOTES	Wed Oct  9 13:26:08 1996
--- bash-2.01/CWRU/POSIX.NOTES	Tue Mar 25 11:39:25 1997
***************
*** 78,81 ****
--- 78,84 ----
       in the shell environment after the builtin completes.
  
+  21. The `export' and `readonly' builtin commands display their output
+      in the format required by POSIX.2.
+ 
  
  There is other POSIX.2 behavior that Bash does not implement.
diff -Nrc2 bash-2.0/CWRU/changelog bash-2.01/CWRU/changelog
*** bash-2.0/CWRU/changelog	Sun Dec 22 18:16:08 1996
--- bash-2.01/CWRU/changelog	Tue Jun  3 11:27:48 1997
***************
*** 1,8399 ****
! 				    6/2
! 				    ---
! lib/readline/readline.c
! 	- fixed an off-by-one error in the kill ring reallocation code
! 	  in rl_kill_text
! 
! Makefile
! 	- replaced instances of /bin/sh with $(SHELL)
  
! Makefile, cpp-Makefile, documentation/Makefile
! 	- added a working `uninstall' target
  
! [1.14.0 FCS release made available for FTP]
  
! 				    6/3
! 				    ---
! README
! 	- added note about building with gcc, same as in Makefile
  
! documentation/Makefile
! 	- some versions of make don't understand `$*' in a regular recipe;
! 	  replace with features.dvi in the recipe for features.ps
  
- 				    6/4
- 				    ---
  subst.c
! 	- fix up the calls to string_extract_double_quoted and 
! 	  string_extract_single_quoted in char_is_quoted so the initial
! 	  value of the index is *after* the opening quote character
! 	- make sure we only return 1 from char_is_quoted if the index
! 	  into the string after a call to string_extract_double_quoted or
! 	  string_extract_single_quoted is *greater than* `eindex'
  
! lib/readline/complete.c
! 	- change the order and sense of the quoting tests in
! 	  rl_complete_internal so that the expensive char_is_quoted
! 	  is only called if `scan' actually is a word break character
  
! shell.c
! 	- fixed a typo in the test for a restricted shell
  
! builtins/exec.def
! 	- need to include flags.h
  
! 				    6/6
! 				    ---
! make_cmd.c
! 	- make sure that we don't try to walk down a null command tree
! 	  in connect_async_list (tickled by `(command &) &')
! 	- if a command has the CMD_WANT_SUBSHELL bit set in its flags,
! 	  don't even try to walk the command tree and move the `&';
! 	  just connect the command with a null command using `&'
  
! execute_cmd.c
! 	- make sure we don't try to reference a command struct without
! 	  first checking it (case '&')
  
! 				    6/7
  				    ---
! machines.h
! 	- fix a typo in the NeXT/i386 description; change the NeXT description
! 	  to #define HAVE_RESOURCE if not already defined rather than putting
! 	  -DHAVE_RESOURCE into the SYSDEP_CFLAGS
  
! 				    6/9
! 				    ---
! Makefile
! 	- make sure all of the rules that reinvoke `make' have the
! 	  `-f bash-Makefile' before the assignment statements; some
! 	  versions of make like it that way
  
! variables.c
! 	- make sure that `interactive' is set to 0 before evaluating the
! 	  string containing an exported function obtained from the
! 	  environment, so that it does not try to execute PROMPT_COMMAND
! 	  (this may not be the best fix)
! 
! 				   6/13
! 				   ----
! documentation/Makefile
! 	- make sure all of the directories exist before trying to install
! 	  doc files into them
! 
! lib/readline/history.c
! 	- add a missing O_TRUNC to the open call for writing in
! 	  history_truncate_file
  
! trap.c
! 	- run_interrupt_trap should only try to run the trap command if
! 	  the value is not IMPOSSIBLE_TRAP_HANDLER
  
! Makefile
! 	- add `realclean'
  
  lib/readline/complete.c
! 	- do the same kind of double-quoting a replacement string if the
! 	  user supplies the opening double quote as we would if we were
! 	  adding both quotes ourselves
  
! variables.c
! 	- fixed the variable initialization so that history_control/HISTCONTROL
! 	  can be inherited from a parent shell
  
! INSTALL, README, cpp-Makefile, documentation/bash.1, documentation/readline.3
! 	- ai.mit.edu -> prep.ai.mit.edu
  
! shell.c
! 	- fixed a problem with setting no_line_editing to the result of the
! 	  check for running inside emacs, thereby losing any value
! 	  initialized by the `-nolineediting' flag
  
! cpp-Makefile
! 	- `make distclean' will now remove the `installed-bash' link
  
! print_cmd.c
! 	- fixed a problem with undefined variables when HAVE_VARARGS_H is
! 	  not defined
  
! 				   6/14
  				   ----
! lib/readline/history.c
! 	- fixed an error in the csh history expansion code so that the
! 	  `-y' word designator now expands to `0-y' rather than `1-y'
  
! lib/readline/isearch.c
! 	- changed an absolute check for a character falling within the
! 	  ASCII 32-126 range (printable chars) with checks for CTRL_P
! 	  and META_CHAR and a check against the value RUBOUT
! 	- changed a `break' to a `continue' so that the first non-matching
! 	  character in the search string does not cause the search to
! 	  end abruptly
! 	- initialize prev_line_found to 0 at the top of rl_search_history
! 	  to avoid duplicate history lines being saved across searches
! 
! lib/readline/rltty.c
! 	- consolidated repeated code for setting special characters into
! 	  `SET_SPECIAL' defines
  
! lib/readline/readline.c
! 	- include <sys/ioctl.h> if VSTATUS is defined
! 	- add bindable command rl_tty_status (unbound by default)
  
! lib/readline/funmap.c
! 	- assign bindable command name `tty-status' to rl_tty_status
  
! INSTALL
! 	- add note about compiling with gcc, same text as README
  
! lib/readline/display.c
! 	- many changes and tweaks to make redisplay work better when the
! 	  prompt has invisible characters.  These changes are non-optimal
! 	  in that the prompt is redrawn more than it needs to be, but
! 	  things are a hell of a lot better than they were
! 
! 				   6/15
! 				   ----
! documentation/Makefile
! 	- make a variable NROFF that people can set to `groff -Tascii' if
! 	  they don't have real nroff
! 	- changed the suffix rules to use $<
  
! support/bashbug.sh
! 	- if rmail doesn't exist or fails, save the bug report in
! 	  ~/dead.bashbug
  
! execute_cmd.c
! 	- in setup_async_signals, only ignore SIGINT and SIGQUIT if job
! 	  control is not active.  If it is active and the job is restarted,
! 	  SIGINT remains ignored, and the now-foregrounded job is not
! 	  interruptible
  
  subst.c
! 	- fixed up a problem with char_is_quoted that caused backslash-
! 	  escaped characters to cause incorrect results
  
! tests/run-dollars, tests/dollar-at.sh, tests/dollar-star.sh
! 	- since the error messages produced by `cat' vary, changed `cat'
! 	  to `recho' and updated the correct answers file
! 
! machines.h
! 	- fixes to CRAY_STACKSEG_END definitions for different versions of
! 	  Unicos on the YMP (from Bill Jones)
! 	- Motorola SVR4 machines have getcwd() and should not undef
! 	  HAVE_GETCWD
! 	- on hpux 9.x, don't try to link with -lPW if compiling with gcc
! 	  (for alloca)
! 
! parse.y
! 	- an ugly fix for a compiler problem with structure assignment on
! 	  the cray
  
! 				   6/16
! 				   ----
! builtins/wait.def
! 	- replaced a call to sscanf with a validity check using all_digits()
! 	  and a call to atoi, since a pid_t is not necessarily an int, and
! 	  the sscanf clobbered the stack frame on systems where it is shorter
! 	  than an int (e.g., SCO)
  
! lib/readline/display.c
! 	- since META_CHAR and the other macros only work with unsigned
! 	  chars, make rl_character_len convert its argument to an unsigned
! 	  char before testing it
! 
! documentation/Makefile
! 	- use $(INSTALL_DATA) instead of $(CP) to install the man pages and
! 	  info files
! 
! cpp-Makefile
! 	- use INSTALL_PROGRAM and INSTALL_DATA to install binaries and
! 	  documentation; pass both values to installs in subdirectories
  
! 				   6/18
  				   ----
! builtins/ulimit.def
! 	- compensate for systems which define RLIMIT_OFILE instead of
! 	  RLIMIT_NOFILE, or don't provide such a compatibility define
! 	  themselves
  
! shell.c
! 	- make maybe_execute_file check for directories and print an
! 	  appropriate error message, since it's doing an fstat anyway
  
! support/mksysdefs
! 	- added support for a `-s srcdir' option so it can find
! 	  cpp-Makefile if ansi-Makefile is to be created
  
! Makefile
! 	- call mksysdefs with -s $(srcdir)
  
! jobs.c
! 	- add the magic #undef lines to avoid redefinition warnings on
! 	  SunOS 4 only
  
! 				   6/20
  				   ----
! cpp-Makefile
! 	- install `bashbug' with `make install'
  
! trap.c
! 	- make sure that `interactive' is set to 0 when running trap
! 	  commands
  
! builtins/umask.c
! 	- fixed typo in usage error message
  
! subst.c
! 	- fix process_substitute to set subshell_environment
  
! jobs.c, nojobs.c
! 	- only mess with the terminal settings for an interactive shell
! 	  that is not in a subshell environment
  
! 				   6/21
  				   ----
! lib/readline/history.h
! 	- add extern declaration of history_get
! 
! builtins/fc.def
! 	- make history replacement when using `r' or `fc -s' obey the
! 	  setting of HISTCONTROL
  
! general.c
! 	- in canonicalize_pathname, preserve a double // at the start
! 	  of an absolute pathname, since that means something special
! 	  for the network directory system
! 
! README, INSTALL
! 	- updated information about submitting bug reports
! 
! lib/readline/vi_mode.c, lib/readline/isearch.c
! 	- make sure unistd.h is included before rldefs.h, if
! 	  HAVE_UNISTD_H is defined
  
! 				   6/24
! 				   ----
! lib/readline/complete.c
! 	- add `#' to the list of characters which cause a completed filename
! 	  to be quoted
  
! execute_cmd.c
! 	- be more careful about closing pipe file descriptors in do_piping;
! 	  don't want to have `dup2(i, i); close(i);' problem
  
! lib/readline/{keymaps,readline}.h
! 	- include local copies of include files if READLINE_LIBRARY is
! 	  defined, otherwise include the `official, installed' versions
! 	  using #include <readline/xxx.h>
! 
! lib/readline/*.c
! 	- define READLINE_LIBRARY before including any files
! 	- include only `local' copies of include files using #include "xxx.h"
! 	  rather than #include <readline/xxx.h>
  
! 				   6/26
  				   ----
! execute_cmd.c
! 	- check for clobbering the bash input stream before closing a file
! 	  descriptor due to an r_close_this redirection
  
! lib/readline/history.c
! 	- made history_expand inhibit history expansion if the history
! 	  expansion char is set to 0
! 
! lib/readline/chardefs.h
! 	- moved savestring() definition to rldefs.h
! 	- changed lowercase_p, uppercase_p, to_lower, to_upper defines to
! 	  use <ctype.h> macros rather than assume ASCII
! 
! lib/readline/bind.c, general.c, general.h
! 	- use strcasecmp, strncasecmp instead of str[n]icmp if
! 	  HAVE_STRCASECMP is defined
! 
! cpp-Makefile
! 	- pass -DHAVE_STRCASECMP to builds in the libraries, primarily
! 	  readline
! 
! machines.h
! 	- add HAVE_STRCASECMP to the entries for BSD/386, NetBSD, FreeBSD,
! 	  and 4.4 BSD
  
! builtins/hash.def
! 	- add a fourth parameter to remember_filename, the initial value
! 	  of times_found (0 if we're just looking it up for `hash', 1
! 	  for the command execution code)
  
! execute_cmd.c
! 	- call remember_filename with an initial value of 1 for times_found
  
! builtins/wait.def
! 	- handle a null argument with an error message
  
! builtins/common.c
! 	- parse_and_execute now takes a third parameter: the value for
! 	  `interactive' while it is executing commands
  
! bashline.c, jobs.c, parse.y, shell.c, subst.c, trap.c, variables.c
! 	- set the new third argument to parse_and_execute appropriately
  
! builtins/eval.def, builtins/fc.def, builtins/source.def
! 	- set the new third argument to parse_and_execute appropriately
  
! builtins/help.def
! 	- changed a call to strnicmp to strncmp when trying to find what
! 	  to give help on; it seems more correct
  
! 				   6/27
  				   ----
! machines.h
! 	- cleaned up the SunOS section so it no longer relies on
! 	  HAVE_SHARED_LIBS being defined; it uses SunOS4 and SunOS5
! 	  instead
! 
! support/mksysdefs
! 	- define SYSDEF to be SunOS4 or SunOS5 depending on the output
! 	  of uname rather than looking for ld.so
! 
! 				   6/29
! 				   ----
! machines.h
! 	- minor change to the ardent titan machine description
! 	- move the ardent and stardent descriptions before the
! 	  mips riscos description
  
! print_cmd.c
! 	- ardent machines also need the extern declaration for printf
  
! make_cmd.c
! 	- connect_async_list should do its work only if the lists to be
! 	  backgrounded are connected with `;'.  This makes `;' bind tighter
! 	  than `&', so only the last job in the list is backgrounded.  All
! 	  other lists should have the entire thing put in the background
  
! parse.y
! 	- added a function `print_prompt' to take care of displaying the
! 	  prompt string if readline is not being used.  This fixes problems
! 	  with the prompt being displayed before the status of completed
! 	  jobs is printed
! 
! 				   6/30
! 				   ----
! builtins/fg_bg.def
! 	- `fg' and `bg' now print error messages if invoked when job control
! 	  is disabled
! 
! lib/readline/rltty.c
! 	- if not compiled into the shell, make get_tty_settings get and set
! 	  the window size.  This noop stops the process if it is started in
! 	  the background
  
! lib/readline/readline.c
! 	- provide a function version of savestring, if not being compiled
! 	  into the shell, since the macro has been removed from the
! 	  `public' header files
  
  lib/readline/readline.h
! 	- provide all extern function declarations without checking whether
! 	  VI_MODE or PAREN_MATCHING are defined.  It does not hurt to define
! 	  them if they are not used and not in the library, and other
! 	  applications using readline can't tell whether or not VI_MODE was
! 	  defined when the library was compiled anyway
  
! 				    7/1
! 				    ---
! machines.h
! 	- add #undef HAVE_DIRENT_H to the ardent titan description
  
! 				    7/2
! 				    ---
! lib/readline/chardefs.h
! 	- removed META_P define, renamed CTRL_P to CTRL_CHAR
  
! lib/readline/bind.c, lib/readline/isearch.c
! 	- changed instances of CTRL_P to CTRL_CHAR
  
! lib/readline/search.c
! 	- include <unistd.h> before rldefs.h, if HAVE_UNISTD_H is defined
  
! lib/readline/readline.c
! 	- declare PC, UP, and BC as extern rather than `local' to the
! 	  readline library
  
! 				    7/5
! 				    ---
! bashline.c
! 	- implement command word completion inside of command substitution
! 	  with a new function: `command_subst_completion_function'
  
! subst.c
! 	- new function to help with command subst completion: unclosed_pair
  
! lib/readline/complete.c
! 	- new variable rl_filename_quoting_desired, which can be set to 0
! 	  to inhibit the quoting of filenames after completion
  
! lib/readline/readline.h
! 	- declare rl_filename_completion_desired and
! 	  rl_filename_quoting_desired
  
! builtins/bind.def
! 	- don't save the old value of rl_outstream before initializing
! 	  readline -- it saves garbage values and screws up readline
  
! parse.y
! 	- don't have private state telling whether or not readline has
! 	  been initialized -- use bash_readline_initialized like other
! 	  functions in bashline.c
  
! lib/readline/readline.c
! 	- make the default 8-bit behavior be based on whether LC_CTYPE is
! 	  defined and its value (accept iso-8859-1 or iso_8859_1)
  
! 				    7/6
! 				    ---
! variables.c
! 	- fix up the declaration of getenv() for convex machines
  
! 				    7/7
! 				    ---
! lib/readline/readline.c
! 	- fixed up typos in the declaration of `savestring'
  
! lib/readline/history.c
! 	- fixed an off-by-one error in the ADD_CHAR macro which caused one
! 	  extra character to be overwritten, causing the gnu malloc to abort
! 	  when that one character was at the end of an allocated block
! 	- changed the ADD_STRING macro to avoid some unnecessary xreallocs
  
! lib/readline/display.c
! 	- fixed a problem with move_cursor_relative -- function now returns
! 	  immediately if it has nothing to do
! 	- fixed another problem with displaying prompts with invisible chars
! 
! lib/readline/chardefs.h
! 	- fixed the CTRL macro to be right (agree with the BSD kernel, for
! 	  example)
  
! cpp-Makefile
! 	- fixed typo in the `install' recipe
  
! 				    7/8
! 				    ---
! support/srcdir
! 	- fixed to handle srcdir when it begins with ./ or ../ to handle
! 	  $(srcdir) being a relative path better
! 
! cpp-Makefile
! 	- changed some include paths to $(BUILTIN_ABSSRC) when building in
! 	  `builtins' to handle $(srcdir) being a relative path
! 	- change the `chmod' on bashbug to turn on read and execute for all
! 	- added a couple of definitions to make it easier for a later
! 	  `configure' program
! 
! support/mksysdefs
! 	- added a -i option to specify an alternate set of directories to
! 	  search for include files
  
! lib/readline/bind.c
! 	- in rl_read_init_file, when skipping whitespace at the start of
! 	  the line, decrement `i' so that we don't jump past the start
! 	  of the next line
! 
! machines.h
! 	- SCOv4 has a `robust' opendir that checks that you're actually
! 	  opening a directory
  
! 				   7/11
! 				   ----
! lib/readline/complete.c
! 	- make sure a word break character is unquoted before using it to
! 	  separate out the current word for completing
  
! machines.h
! 	- new machine description: NetBSD on motorola m68k machines like
! 	  the hp300
! 	- undef HAVE_GETWD in the generic svr4 machine description, like
! 	  other svr4 descriptions
! 
! lib/readline/rltty.c
! 	- make sure to fflush (rl_outstream) after toggling the setting
! 	  of the keypad and meta key
! 
! portbash/libc.sh
! 	- add a test for OPENDIR_NOT_ROBUST
! 
! support/getcppsyms.c
! 	- output __svr4__ if we find __uxps__ (this makes the Fujitsu port of
! 	  SVR4 to the sparc build OK)
  
! 				   7/12
! 				   ----
! lib/readline/display.c
! 	- more display-related fixes when the prompt has invisible chars;
! 	  this time for screen updates when moving between screen lines
  
! lib/readline/readline.c, lib/readline/display.c
! 	- changes to make readline work with terminals that have auto-wrap
! 	  from Per Bothner (new function _rl_update_final, term_xn changes,
! 	  some efficiency speedups, new function space_to_eol)
  
! 				   7/13
! 				   ----
! lib/readline/display.c
! 	- after moving up screen lines using term_up in _rl_move_vert, if
! 	  the new screen line is 0, _rl_last_c_pos needs to be adjusted
! 	  to take invisible characters into account.  This was the source
! 	  of many bugs
! 
! 				   
! 				   7/14
! 				   ----
! documentation/Makefile
! 	- change instances of `groff' to `${GROFF}', GROFF is set to
! 	  `groff' by default
! 
! general.c, variables.c
! 	- moved `qsort_string_compare' from variables.c to general.c
! 
! general.h, variables.h
! 	- moved declaration of `qsort_string_compare' from variables.h
! 	  to general.h
! 
! alias.c, lib/readline/funmap.c
! 	- moved qsort auxiliary functions after their use and added
! 	  forward declarations to avoid warnings from ANSI C compilers
! 
! memalloc.h
! 	- hpux_9 needs alloca declared as `extern void *' if __STDC__
! 	  is defined
! 
! support/mksysdefs
! 	- removed HAVE_SHARED_LIBS entirely
! 	- make a call to /bin/uname -X for SCO machines to avoid running
! 	  a different uname from the $PATH
! 
! machines.h
! 	- new descriptions: Intel i860 running SVR4, Tahoe running 4.3 BSD
! 	- changed descriptions: Mips/RiscOS, DG AViiON, unknown machine
  
! jobs.c
! 	- changes to how the shell handles foreground jobs dying of SIGINT:
! 		an interactive shell using job control will no longer
! 		act as if it received a SIGINT if the foreground job
! 		dies from a SIGINT
  
! 		a non-interactive shell or shell without job control tries
! 		to differentiate between SIGINTs it has seen (in
! 		wait_sigint_handler) and a foreground job dying of a SIGINT
! 		not sent from the keyboard, and runs the normal SIGINT code
! 		only in the former case
  
! 				   7/15
! 				   ----
! support/mksysdefs
! 	- check for ${UNAME}${RELEASE} expanding to `SunOS4*' or `SunOS5*'
! 	  to set SYSDEF to SunOS4 or SunOS5, respectively.  Apparently
! 	  this does not work for Solbourne
  
! 				   7/18
! 				   ----
  
! lib/readline/rltty.c
! 	- if output is being flushed on termios systems, loop until the
! 	  FLUSHO bit is no longer set in the termios struct
  
! support/mksysdefs
! 	- added a -A flag to force creation of ansi-Makefile
  
! machines.h
! 	- new entry for Tandem machines running SVR3
  
! 				   7/19
! 				   ----
! lib/readline/rldefs.h
! 	- include <termcap.h> if HAVE_TERMCAP_H is defined
! 	- use <termio.h> stuff if HAVE_TERMIO_H is defined and _POSIX_VERSION
! 	  is not defined
  
! lib/readline/rldefs.h, lib/readline/history.c
! 	- include "config.h" if HAVE_CONFIG_H is defined
  
! lib/readline/{rldefs.h,signals.c,readline.c}
! 	- WINSIZE_IN_IOCTL_H -> GWINSZ_IN_SYS_IOCTL for compatibility with
! 	  other GNU programs
  
! lib/readline/doc/Makefile
! 	- fixed up to create the readline and history manuals in dvi and
! 	  ps format
  
! lib/readline/Makefile
! 	- changes inspired by the standalone readline-2.0 distribution
  
! 				   7/20
! 				   ----
! lib/readline/history.c
! 	- new function, history_is_stifled (), returns history_stifled
! 	- set history_state flags member in the history state functions
  
! lib/readline/history.h
! 	- reorganized the function declarations, added missing declarations
! 	- history_stifled is no longer exported by the library
! 	- added a `flags' member to the HISTORY_STATE structure
  
! bashline.c
! 	- use history_is_stifled () instead of history_stifled
  
! lib/readline/readline.c, lib/readline/vi_mode.c
! 	- filled in correct argument declarations for functions called via
! 	  keymaps (count, key)
  
! lib/readline/complete.c
! 	- efficiency improvement for compare_strings
  
! 				   7/21
! 				   ----
! examples/dirfuncs
! 	- new directory functions from ksh book, contributed by
! 	  Ken Konecki (kenk@wfg.com)
  
! machines.h
! 	- hpux_8 and hpux_9 should both #undef HAVE_ALLOCA unless gcc is
! 	  being used
  
! 				   7/22
  				   ----
! bashline.c
! 	- fixed up command_word_completion_function so that filenames with
! 	  leading tildes are completed correctly
  
! 				   7/26
! 				   ----
! builtins/read.def
! 	- if -r not given, make sure CTLESC is removed from input string
! 	  when reading \<newline>
  
! lib/readline/readline.c
! 	- new function bind_arrow_keys, which binds vt100/ansi arrow key
! 	  escape sequences after reading the termcap definition and the
! 	  inputrc file
! 	- new function rl_yank_last_arg, which does what insert-last-arg
! 	  does in bash
! 
! lib/readline/emacs_keymap.c
! 	- remove default bindings to rl_arrow_keys for M-[ and M-O
! 	- rl_yank_last_arg is now bound to `M-.' and `M-_' in
! 	  emacs_meta_keymap
  
! subst.c
! 	- when performing process substitution on systems with /dev/fd,
! 	  make sure the child clears the slot in dev_fd_list it gets
! 	  from its parent so the file descriptor does not get closed
! 	  inappropriately if reallocated by, e.g., pipe(2)
  
! bashline.c
! 	- removed insert_last_arg and the calls to bind in to `M-.' and `M-_'.
! 	  `insert-last-argument' is now bound to rl_yank_last_arg for
! 	  backwards compatibility
  
! lib/readline/funmap.c
! 	- `yank-last-arg' is now a named command for rl_yank_last_arg
  
  
! documentation/bash.1, documentation/readline.3
! 	- add description of yank-last-arg as one of the readline user
! 	  commands
  
! lib/readline/doc/rluser.texinfo
! 	- added description of yank-last-arg
  
! builtins/getopts.def
! 	- fixed a typo in the int-to-string code computing the value to set
! 	  OPTIND to: had '\0' instead of '0'
! 	- made getopts handle the case where there are more than 9 dollar
! 	  variables (where rest_of_args is non-null) correctly
  
! 				   7/28
! 				   ----
! lib/readline/display.c
! 	- fixes to the display code for single-line-display in the presence
! 	  of prompts containing invisible characters
  
! lib/readline/readline.c
! 	- if we are using horizontal scrolling and we have term_xn, decrement
! 	  the screenwidth by 1, since we won't be doing any line wrapping
  
! 				   7/31
  				   ----
  jobs.c
! 	- new variable `freeze_jobs_list' to set when changes to the jobs
! 	  list or status of jobs in the list (other than calling something
! 	  like `jobs -n') are undesirable.  This is set when execuing traps
! 	  on SIGCHLD
  
! 				    8/1
! 				    ---
! subst.c
! 	- check that `~' is unquoted before performing tilde expansion in
! 	  an assignment statement
  
! 				    8/3
! 				    ---
! bracecomp.c
! 	- keep brace completion from dumping core if there is only one
! 	  match
  
! lib/readline/chardefs.h
! 	- add a define for digit_p, which returns the value of isdigit()
  
! lib/readline/readline.c
! 	- added function equivalents for uppercase_p, lowercase_p, to_upper,
! 	  to_lower, pure_alphabetic, digit_p, and digit_value
! 	- replaced calls to numeric () with calls to digit_p, removed
! 	  definition of numeric ()
! 
! lib/readline/history.c
! 	- digit -> digit_p
! 
! lib/readline/vi_mode.c
! 	- replaced uses of the `isletter' define to use pure_alphabetic
! 	  from chartypes.h
! 	- replaced uses of `numeric' with calls to digit_p
! 	- added do...while(0) to `exchange' define
  
! 				    
! 				    8/4
! 				    ---
! execute_cmd.c
! 	- make sure execute_function saves and restores the current loop
! 	  count with unwind_protect_int
  
! documentation/features.texi
! 	- change the `Shell Command Line Options' section to `Invoking
! 	  Bash' to be closer to the GNU coding standards
  
! 				    8/5
! 				    ---
! builtins/read.def
! 	- fixed up a memory leak and made behavior correct when no
! 	  variables given and backslash escaped at least one input char
! 	- if we added CTLESC anywhere while reading the input string,
! 	  make sure we call dequote_string on each word of the input
! 	  before calling bind_variable with that string
  
! 				    8/6
! 				    ---
! lib/readline/readline.h
! 	- removed definition of rl_show_star -- the variable no longer
! 	  exists
  
! lib/readline/readline.h, lib/readline/history.h
! 	- reorganized to follow texinfo manual structure
  
! lib/readline/bind.c
! 	- rl_function_dumper is now static
! 	- rl_list_funmap names does not take any arguments
  
! builtins/bind.def
! 	- rl_list_funmap names does not take any arguments
  
! lib/readline/readline.c, lib/readline/signals.c
! 	- rl_init_argument ->_rl_init_argument
  
! lib/readline/rltty.c
! 	- remove declaration and references to output_was_flushed
  
! support/getcppsyms.c
! 	- if __uxps__ is defined, define __uxps__ and __svr4__
  
! 				    8/9
! 				    ---
! support/mkdist
! 	- added a -r option to set the `root name' of the distribution
! 	  (e.g., `bash' or `readline')
  
! 				   8/10
  				   ----
! input.c
! 	- if check_bash_input sees that default_buffered_input is about
! 	  to be the target of a redirection, but the buffered input stream
! 	  is not the current input stream (e.g. as the result of an
! 	  `eval' while in a script, change default_buffered_input to a
! 	  new fd and use a new variable `bash_input_fd_changed' to note
! 	  the change
  
! parse.y
! 	- if pop_stream sees that default_buffered_input has changed while
! 	  a buffered stream was on the save stack (because
! 	  bash_input_fd_changed is non-zero), then make the popped stream
! 	  and the corresponding buffer use the new fd
  
! test.c
! 	- fixed an off-by-one error in test_stat when testing /dev/fd/n.
  
! cpp-Makefile
! 	- add -I$(incdir) to CPPFLAGS
! 	- add `incdir = $(prefix)/include' assignment
  
! 				   8/11
  				   ----
! lib/readline/signals.c
! 	- changed some calls to signal () to call rl_set_sighandler()
! 	- call _rl_redisplay_after_sigwinch from the sigwinch handler
! 	  to do better redisplay of wrapped command lines and multi-line
! 	  prompts
  
! builtins/suspend.def
! 	- changed some calls to signal () to call set_signal_handler()
  
! lib/readline/*.c
! 	- include config.h before anything else if HAVE_CONFIG_H is defined
  
! lib/readline/readline.c
! 	- renamed rl_set_mark to _rl_set_mark_at_pos
! 	- call _rl_vi_initialize_line from rl_initialize if the current
! 	  editing mode is vi mode
! 	- only output a term_cr in crlf if term_cr is non-null
  
! lib/readline/readline.h
! 	- added declarations for rl_vi_set_mark and rl_vi_goto_mark
  
! lib/readline/readline.c, lib/readline/readline.h
! 	- added a new bindable command to set the mark, rl_set_mark
  
! lib/readline/funmap.c
! 	- new bindable function with name `set-mark', bound to rl_set_mark
! 	- new bindable vi-mode functions with names `vi-set-mark' and
! 	  `vi-goto-mark'
! 
! documentation/{bash.1,readline.3}, lib/readline/doc/rluser.texinfo
! 	- added documentation for `set-mark' (unbound)
! 
! lib/readline/vi_mode.c
! 	- new vi-command mode commands to save marks (the vi `m' command)
! 	  and go to saved marks (the ``' command)
! 	- new function _rl_vi_initialize_line called from rl_initialize
! 	  to set up the line state in vi mode.  Right now this just resets
! 	  all the marks
! 
! lib/readline/vi_keymap.c
! 	- new vi command-mode bindings to set the mark (`m') and to go to
! 	  a saved mark (``')
! 
! documentation/readline.3
! 	- added vi-set-mark and vi-goto-mark to list of key bindings for
! 	  vi command mode
  
! lib/readline/{readline.c,display.c}
! 	- renamed term_xn to _rl_term_autowrap
  
! lib/readline/display.c
! 	- new function _rl_redisplay_after_sigwinch to encapsulate the
! 	  necessary redisplay code after a SIGWINCH is received
  
! variables.c
! 	- only call find_user_command on the shell name in shell_initialize
! 	  if shell_name is not an absolute program name
! 	- call canonicalize_pathname on the full shell pathname after
! 	  calling make_absolute on it if the shell name starts with a `.'
  
! siglist.h
! 	- FreeBSD does not need a definition of sys_siglist[]
  
! 				   8/12
  				   ----
! lib/readline/rltty.c
! 	- don't try to use FLUSHO unless FLUSHO is defined
  
! cpp-Makefile
! 	- make sure to pass $(CC) to the make in the lib/malloc subdirectory
  
! lib/readline/readline.c
! 	- don't declare PC, UP, and BC as extern; it causes too many problems
  
! 				   8/13
  				   ----
! machines.h
! 	- add -DNO_SBRK_DECL to SYSDEP_CFLAGS for SVR4.2 on i386
! 
! support/mksysdefs
! 	- new variable UNAME_S for the output of `uname -s'
! 	- if uname -s does not output the same thing as uname, and uname -s
! 	  outputs UNIX_SV, then set UNAME to UNIX_SV.  Some versions of i386
! 	  SVR4.2 make `uname' equivalent to `uname -n'
  
! lib/readline/memalloc.h
! 	- removed from the library; not needed since readline does not use
! 	  alloca
  
! lib/readline/{history.c,isearch.c,search.c,rldefs.h}, lib/tilde/tilde.c
! 	- no longer include memalloc.h
  
! lib/readline/Makefile
! 	- remove dependencies on memalloc.h
  
! lib/readline/signals.c
! 	- overhauled signal handling based on ideas from Bruno Haible
! 	  (haible@ma2s2.mathematik.uni-karlsruhe.de) so that readline
! 	  saves and restores the signal mask and flags on Posix systems
! 	- don't include fcntl.h, sys/file.h, errno.h, or stdlib.h
! 	- ignore SIGALRM during rl_signal_handler like SIGINT until the
! 	  old handler is installed, on non-Posix or non-BSD systems
! 	- new define SIGHANDLER_RETURN, dependent on the value of
! 	  VOID_SIGHANDLER
! 	- use RETSIGTYPE instead of `sighandler' as the signal handler
! 	  return type; it's the name autoconf uses.  If not defined,
! 	  set up from VOID_SIGHANDLER
! 
! lib/readline/rltty.c
! 	- call control_meta_key and control_keypad from rl_deprep_terminal
! 	  before putting the terminal back into ICANON mode to avoid
! 	  messing up the tty driver
! 
! 				   8/15
! 				   ----
! cpp-Makefile
! 	- changes so that fewer -Idir arguments are passed to the make
! 	  in ./builtins
  
! 				   8/16
! 				   ----
! lib/readline/bind.c
! 	- use KEYMAP_SIZE instead of 128 in rl_invoking_keyseqs_in_map
  
! lib/readline/complete.c
! 	- qsort the array of matches omitting matches[0], which must stay
! 	  in place no matter what, even if strcmp doesn't compare unsigned
! 	  chars correctly
! 	- some fixes to the loop that prints the list of completions
! 
! lib/readline/keymaps.c
! 	- run the loop up to 127 when creating a new keymap in rl_make_keymap
! 
! input.h, general.h, lib/readline/keymaps.h, lib/readline/tilde.h
! 	- use _FUNCTION_DEF instead of __FUNCTION_DEF
! 
! lib/readline/parens.c
! 	- include "config.h" if HAVE_CONFIG_H is defined
! 	- include <sys/select.h> if HAVE_SYS_SELECT_H is defined
! 	- use HAVE_SELECT instead of FD_SET as the `configuring define';
! 	  define HAVE_SELECT if it is not already defined but FD_SET is
  
! lib/readline/readline.c, lib/readline/rltty.c
! 	- the __GO32__ include file is <pc.h>
  
! lib/tilde/tilde.c
! 	- rewrote tilde_expand_word, eliminated static u_name array in
! 	  favor of using xmalloc
  
! lib/tilde/tilde.h
! 	- use single leading underscore for file inclusion guard
  
! lib/readline/vi_mode.c
! 	- use KEYMAP_SIZE rather than a literal 127 as the loop limit when
! 	  creating the overstrike keymap
  
! support/install.sh
! 	- new file, from the make-3.71 distribution
  
! 				   8/17
! 				   ----
! lib/readline/complete.c, lib/readline/readline.h
! 	- new variable, rl_basic_quote_characters, used to see
! 	  if a word break character was a quoting character, so we can
! 	  do appropriate quoting after the completion
  
! lib/readline/parens.c
! 	- use rl_basic_quote_characters when trying to find a matching
! 	  open paren
  
! lib/readline/doc/rltech.texinfo
! 	- description of rl_basic_quote_characters
  
! 				   8/18
! 				   ----
! newversion.c
! 	- renamed to support/mkversion.c, which builds to mkversion
  
! cpp-Makefile
! 	- changed to use support/mkversion
! 	- removed instances of $< except in suffix rules -- some makes don't
! 	  handle those right
  
! lib/readline/rldefs.h
! 	- make sure to #undef HAVE_DIRENT_H on NeXT machines
  
! 				   
! 				   8/19
! 				   ----
! lib/readline/readline.h
! 	- removed some duplicate function declarations
  
! trap.h
! 	- define DEBUG_TRAP as NSIG for the last slot in trap_list
! 	- define EXIT_TRAP as 0
! 	- declare trap_list as array of unknown size, since this is just a
! 	  header file
  
! trap.c
! 	- extend trap_list and sigmodes to NSIG+1
! 	- initialize DEBUG_TRAP to do nothing; changes to functions to handle
! 	  DEBUG_TRAP
! 	- let decode_signal return OK if NSIG is given, even though this will
! 	  vary between systems, for DEBUG_TRAP
! 	- make reset_signal_handlers and restore_original_signals loop from
! 	  1 to NSIG, not 0 to NSIG
! 	- change GET_ORIGINAL_SIGNAL to try to get the original signal handler
! 	  only if `sig' is less than NSIG
! 	- restore_default_signal just frees the trap string for both EXIT_TRAP
! 	  and DEBUG_TRAP
! 	- run_debug_trap: new function to run traps on DEBUG
! 	- free_trap_command: new function to free a trap string if it is
! 	  really a command and not one of the special trap values
! 	- if a SIGINT trap resets the SIGINT trap string, free the old string
! 	- new function: set_debug_trap(char *), which will reset the DEBUG
! 	  trap string, suitable for calling from an unwind-protect handler
  
! signames.c
! 	- arrange things so that signal_names[NSIG] == "DEBUG"
  
! builtins/trap.def
! 	- make sure traps on DEBUG are printed
  
  execute_cmd.c
! 	- call run_debug_trap at the end of the `cm_simple' case in
! 	  execute_command_internal
! 	- change execute_function so that traps on DEBUG do not propagate
! 	  into the function
! 
! documentation/bash.1, documentation/features.texi
! 	- documented the new DEBUG trap
! 
! 				   8/20
! 				   ----
! shell.c, config.h
! 	- made the name of the restricted shell configurable in config.h;
! 	  the option is RESTRICTED_SHELL_NAME
  
! shell.c
! 	- if the shell is invoked as `sh', enter Posix.2 mode after running
! 	  /etc/profile and ~/.profile
! 
! builtins/read.def
! 	- added a -p option for a prompt string, which is displayed before
! 	  trying to read anything
! 
! documentation/bash.1
! 	- description of `read -p'
! 	- description of new -r and -s options to `jobs' 
  
! documentation/features.texi
! 	- description of new -r and -s options to `jobs' 
  
! jobs.c
! 	- new functions: list_running_jobs, list_stopped_jobs
! 	- list_jobs -> list_all_jobs
! 	- new function `print_job' to do the work for all of the list*jobs
! 	  functions
! 	- list_one_job type now void, calls print_job to do the work
  
! jobs.h
! 	- new declarations for list_running_jobs, list_stopped_jobs
! 	- list_one_job now void
! 	- list_jobs -> list_all_jobs
  
! builtins/jobs.def
! 	- new options: -r to print only running jobs, -s to print only
! 	  stopped jobs
  
! 				   8/22
  				   ----
! lib/readline/readline.c
! 	- don't try to expand a null prompt string
  
! subst.c
! 	- remove special handling of hostname_completion_file and
! 	  history_control; HOSTFILE and HISTCONTROL are the acceptable
! 	  names
! 	- new function sv_histignore; call if HISTIGNORE variable is
! 	  assigned to
  
! bashhist.c
! 	- new functions and declarations for handling HISTIGNORE variable
! 	  and its specifications for command lines to ignore
! 	- change maybe_add_history to call history_should_ignore if the
! 	  HISTCONTROL tests are passed
! 
! documentation/bash.1, documentation/features.texi
! 	- removed mention of history_control and hostname_completion_file
! 	- added description of HISTIGNORE
! 
! 				   8/23
! 				   ----
! array.c, array.h
! 	- promoted to the shell mainline code; the `array' subdir is now
! 	  gone
  
! variables.h
! 	- include `array.h' for the ARRAY typedef
  
! variables.c
! 	- changes to assignment() to handle array assignments a[x]=b
! 	- split off the creation of new variables into a new function:
! 	  make_new_variable
! 	- split off the construction of variable values for assignments and
! 	  bindings into a new function: make_variable_value
! 	- new function: bind_array_variable, to handle the addition of
! 	  new array variables and indices
  
! subst.c
! 	- changes to do_assignment_internal to handle a[x]=b:
! 		parse the subscript out of the name and call evalexp() on it
! 		call bind_array_variable to do the value assignment
! 	- change the printing of assignment statements when -x is in effect
! 	  to before the variable binding is attempted, so any error messages
! 	  look better
! 	- new functions for referencing indexed arrays and to find the length
! 	  of arrays or array indices
  
! 				   8/24
  				   ----
! expr.c
! 	- fixed up error reporting to use get_name_for_error if not executing
! 	  a builtin
  
  subst.c
! 	- everywhere evalexp() is called, use maybe_expand_string to expand
! 	  the expression (calls expand_string if necessary)
  
! subst.h
! 	- extern declarations for array convenience functions exported to the
! 	  rest of the shell
  
  variables.c
! 	- more new convenience array functions: make_new_array_variable and
! 	  convert_var_to_array
! 
! builtins/declare.def
! 	- additions to declare_internal to add a -a flag which makes array
! 	  variables, and the requisite semantics (declare +a does not work,
! 	  declare -a name=value does not work, etc.)
! 	- code to support the ksh-like declare a[] syntax to make array
! 	  variables
  
! builtins/setattr.def
! 	- made set_or_show_attributes understand array variables and `-a'
  
! builtins/set.def
! 	- changes to make `unset name' work, where name is an array variable
! 	- changes to make `unset name[xxx]' work
  
! 				   8/25
  				   ----
  
! lib/readline/readline.c
! 	- make sure meta characters are added to a keyboard macro as
! 	  ESC-char if we are converting meta chars to ascii
! 	- change rl_unix_word_rubout to handle repeat counts
! 	- move the check of LC_CTYPE from rl_initialize to
! 	  readline_initialize_everything, where it should have been
! 	  all along
  
! error.c
! 	- make sure <sys/types.h> is included before <fcntl.h>
  
! machines.h
! 	- new entry for Bull DPX2
  
! lib/tilde/tilde.c
! 	- include <sys/types.h> before <pwd.h>
  
! variables.c
! 	- PS1 and PS2 are no longer non-unsettable
  
! 				   8/26
  				   ----
! variables.c
! 	- PPID, UID, and EUID, since they are read-only, need not appear on
! 	  the `non-unsettable' list
! 	- PATH and IFS now have the `nounset' attribute set rather than use
! 	  a separate `non-unsettable' list
! 	- the non-unsettable list and non_unsettable() are gone
  
! variables.h
! 	- new define `non_unsettable_p' to test nounset attribute
  
! builtins/set.def
! 	- `unset' now uses non_unsettable_p to tell whether a variable can
! 	  be unset even if it's not readonly
  
! builtins/read.def
! 	- read -a arrayname will read a list of values from stdin and assign
! 	  them to the array `arrayname', splitting on " \t\n" (honoring
! 	  backslash quoting if -r is not supplied)
  
! builtins/declare.def
! 	- print values of arrays when `display -a' is invoked
  
! builtins/exit.def
! 	- remove references to `bye'
  
! 				   8/28
! 				   ----
! lib/readline/rltty.c
! 	- removed calls to control_keypad; they cause problems on some
! 	  machines and should not really be performed by an application
  
! cpp-Makefile
! 	- support for optionally linking array.o into the shell
  
! lib/glob/glob.c
! 	- when returning an error after glob_filename on the directory name
! 	  returns an error result, make sure to free `result'.  This fixes
! 	  a memory leak for names passed to glob_filename which contain
! 	  globbing characters before the first `/' but do not match any
! 	  existing files
  
! 				   8/29
! 				   ----
! execute_cmd.c
! 	- the `for' and `select' commands should expand their word lists
! 	  using expand_words_no_vars
  
! command.h, execute_cmd.c, general.c, make_cmd.c, print_cmd.c, subst.c,parse.y
! 	- changed the `dollar_present', `quoted', and `assignment' members
! 	  of WORD_DESC to a single flags word
  
! 				   8/30
  				   ----
! variables.c
! 	- make get_string_value return array[0] if called with a variable
! 	  that is an array
  
! 				   8/31
! 				   ----
! lib/readline/display.c
! 	- don't take the value of _rl_term_autowrap into account when
! 	  computing which screen line the cursor should be on; it screws
! 	  up wrapping on terminals without the `xn' capability
! 
! lib/readline/examples/rltest.c
! 	- new file, test code moved here from readline.c
! 
! documentation/features.texi, lib/readline/doc/hsuser.texinfo
! 	- fixed up printing of some of the shell options and the history
! 	  commands and modifiers
  
! subst.c
! 	- make sure $name, where `name' is an array variable, returns
! 	  ${name[0]}
  
! variables.c
! 	- convert a variable to an array even if index 0 is being assigned to,
! 	  instead of leaving it a `normal' variable
  
! 				    9/1
! 				    ---
  
! builtins/setattr.def
! 	- make sure that array variables printed by `declare' single-quote
! 	  the value after the `=' so the statement can be reused as input
  
! variables.c
! 	- make sure array variables can be exported (name=(assignments)), and
! 	  that the export code works.  The code is commented out because of
! 	  the possible confusion between an array and a regular string that
! 	  looks like an array assignment string.
  
! 				    9/2
! 				    ---
! variables.c
! 	- make sure there is an executable file with the same name as
! 	  `shell' name in the current directory before assigning it to
! 	  $BASH at startup.  If there is not, just make $BASH the login
! 	  shell name
  
! 				    9/3
  				    ---
! parse.y
! 	- removed a reduction from the `list0' production that could cause
! 	  statements which require semicolons to be allowed without error
! 	  (like before a `}' in a group command)
  
! lib/readline/display.c
! 	- new functions: _rl_save_prompt and _rl_restore_prompt to save and
! 	  restore prompt invisible character info
! 	- if the redisplay code encounters a line shorter than the old one
!           and containing invisible characters, make sure that the cursor is
! 	  at the end of the new text before calling clear_to_eol
! 	- new variable last_invisible containing the index in the prompt
! 	  string of the last invisible character.  We only have to redraw
! 	  the prompt string of _rl_last_c_pos is < last_invisible
! 	- new function _rl_make_prompt_for_search to take care of setting
! 	  up the prompt string for a non-incremental search when the prompt
! 	  contains invisible characters
! 	- fix so that a prompt string with invisible characters is not
! 	  redrawn each time through update_line (don't tputs term_cr unless
! 	  the cursor is before the last invisible character in the prompt
! 	  and will be moving past the last invisible char of the prompt
  
! lib/readline/isearch.c
! 	- call _rl_save_prompt and _rl_restore_prompt when changing the prompt
! 	  to do i-search
  
! 				    9/4
  				    ---
! lib/readline/readline.c
! 	- doing_an_undo -> _rl_doing_an_undo for use by the vi-mode code
! 	- rewrote rl_do_undo to reformat and eliminate a clumsy goto
! 	- new split the add-to-kill-ring code off into a separate function,
! 	  _rl_copy_to_kill_ring
! 	- added a new bindable function rl_copy_region_as_kill
! 	- added a new bindable function rl_kill_region
! 	- moved _rl_char_search_internal to here from vi_mode.c
! 	- new bindable function rl_char_search
! 
! lib/readline/vi_mode.c
! 	- made `.' work for the `cw' and `[Ss]' commands, which implicitly
! 	  put the editor into insertion mode after they run
! 	- split rl_vi_char_search code that actually searches for a character
! 	  into a new function, _rl_char_search_internal
! 
! lib/readline/emacs_keymap.c
! 	- bind M-= to possible-completions for ksh compatibility
! 	- bind M-* to insert-completions
! 	- bind C-x C-x to exchange-point-and-mark
! 	- bind C-] to character-search
! 	- bind C-@ to set-mark
  
! lib/readline/funmap.c
! 	- new bindable function names: exchange-point-and-mark, kill-region,
! 	  copy-region-as-kill, character-search
  
! lib/readline/readline.h
! 	- declare rl_exchange_point_and_mark, rl_copy_region_to_kill,
! 	  rl_kill_region, and rl_char_search externally
  
! documentation/{bash.1,readline.3}, lib/readline/doc/rluser.texinfo
! 	- document new exchange-point-and-mark bindable command
! 	- documented M-* default emacs-mode binding to insert-completions
! 	- documented new copy-region-as-kill and kill-region commands
! 	- documented new character search emacs-mode command
! 	- documented new binding for set-mark
! 
! lib/readline/rldefs.h
! 	- moved values for `dir' when searching for characters in the line
! 	  from vi_mode.c to here
  
! 				    9/6
  				    ---
! general.c
! 	- new function ansicstr, which decodes ANSI-C backslash-escaped
! 	  characters (with the addition of \e and \E to mean escape) and
! 	  returns a new string
  
! subst.c
! 	- new expansion $'...' which translates ANSI-C backslash escapes
! 	  in `...' and expands to the result
  
! builtins/echo.def
! 	- ifdefs for ANSI-C for \a and \v rather than just expanding to
! 	  literal ASCII values
  
! documentation/bash.1
! 	- documented new $'...' expansion
  
! 				    9/7
  				    ---
! builtins/enable.def
! 	- fixed up the help text
! 	- added a -s flag to restrict operation to Posix.2 `special' builtins
! 	- removed -all option; -a is the way to do it now
! 	- converted to use the builtin getopt
  
! builtins/common.c
! 	- changed builtin_address_internal to return a pointer to a
! 	  struct builtin, which makes it much more useful.  Changed
! 	  find_shell_builtin and builtin_address accordingly
! 	- new function find_special_builtin, which returns special builtins
! 	  ((flags & SPECIAL_BUILTIN) != 0)
  
! execute_cmd.c
! 	- in Posix.2 mode, find special builtins before shell functions
! 	  when performing command lookup
! 	- in find_user_command_internal, return NULL if there is no $PATH
! 	- in Posix.2 mode, failure of a special builtin causes a non-
! 	  interactive shell to exit
  
! variables.c
! 	- allow $PATH to be unset
  
! 				    9/8
  				    ---
! input.h
! 	- added a new `input type': st_stdin, for use when using readline,
! 	  since readline is not properly a string
  
! parse.y
! 	- surgery on the grammar:
! 		o added new `compound_list' production: a list that can end
! 		  without a newline, `;' or `&' (used in subshell commands
! 		  and case clause commands)
! 		o removed shell_command_1, folded rules into command
! 		o eliminated pattern_list_1; changed case_clause_sequence to
! 		  directly incorporate the SEMI_SEMI token (a pattern_list_1
! 		  was just a pattern_list with a trailing SEMI_SEMI)
! 		o new `for_command' and `case_command' productions
! 		o redirections -> redirection_list
! 		o newlines -> newline_list
! 		o redid the code that attaches redirections to the function
! 		  command rather than the function definition and eliminated
! 		  all of the shift/reduce conflicts
! 	- changed with_input_from_stdin in the readline case to set
! 	  bash_input.type to st_stdin
  
! print_cmd.c
! 	- a couple of changes to the way functions are printed
  
! shell.c
! 	- only execute the PROMPT_COMMAND if input is not coming from a
! 	  string (bash_input.type != st_string).  This fixes the problem
! 	  of PROMPT_COMMAND being executed by `eval' commands in an
! 	  interactive shell
  
! 				   9/12
  				   ----
! shell.c
! 	- all interactive shells SIGHUP running jobs when exiting due to
! 	  a SIGHUP, not just login shells
  
! 				   9/13
! 				   ----
! config.h, config.h.mini
! 	- changed the default primary prompt (PPROMPT) to "\s\$ "
! 	- removed the INTERACTIVE_COMMENTS define
  
! flags.c
! 	- interactive comments are now enabled by default, regardless of the
! 	  INTERACTIVE_COMMENTS define
  
! input.h
! 	- a new enum: stream_type, used in the BASH_INPUT struct
  
! parse.y
! 	- bash_input.type is now initialized to st_none
  
! bashhist.c
! 	- command_oriented_history is now the default
  
! documentation/bash.1
! 	- removed description of `nolinks' variable, updated set -P
! 	  description
! 	- removed description of `notify' variable, updated set -b
! 	  description
! 	- removed description of `noclobber' variable, updated set -C
! 	  description
  
  variables.c
! 	- IFS may now be unset
  
! builtins/read.def
! 	- now does the right thing if IFS is unset (acts as if it is
! 	  set to " \t\n")
  
  builtins/cd.def
! 	- added a new parameter to change_to_directory () which says
! 	  whether or not to follow symlinks, instead of using the
! 	  global no_symbolic_links
! 	- changed cd_builtin to accept a -P option to disable symlink
! 	  following temporarily
  
! builtins/ulimit.def
! 	- instead of using a hardcoded `long' for the return type of the
! 	  rlimit functions, use RLIMTYPE, which defaults to long
! 	- new defines string_to_rlimtype -> string_to_long and
! 	  print_rlimtype for systems which do not need `RLIMTYPE' defined
! 	  to something other than long
  
! general.c
! 	- function replacements for string_to_rlimtype and print_rlimtype
! 	  for machines which have RLIMTYPE defined in the machine description
  
! general.h
! 	- extern declarations for string_to_rlimtype and print_rlimtype
  
! shell.c
! 	- don't source file named by $ENV at script startup if act_like_sh
! 	  is turned on
  
! machines.h
! 	- new entry for amiga/netbsd
! 	- change all the netbsd entries to add -DRLIMTYPE=quad_t to
! 	  SYSDEP_CFLAGS
! 
! siglist.h
! 	- define sys_siglist as _sys_siglist on the amiga only if USGr4 is
! 	  defined
  
! print_cmd.c
! 	- change so that printf is not prototyped on LynxOS with gcc
  
! lib/readline/Makefile
! 	- changed the `installdirs' target to not fail if the directories
! 	  do not need creating
  
! lib/readline/history.c
! 	- fixed a bug in history_arg_extract which manifested itself when
! 	  !* was used after a command without arguments (e.g., pwd ; echo !*)
  
! 				   9/15
  				   ----
! subst.c
! 	- expand_word_internal should preserve the flags (other than
! 	  W_QUOTED) from the word passed as a parameter on the word it returns
! 	- expand_words_internal renamed to expand_word_list_internal
! 	- expand_word_list_internal does not perform word splitting or
! 	  globbing on words with the W_ASSIGNMENT bit set
! 	- removed special treatment of `notify', `command_oriented_history',
! 	  `history_control', and `nolinks'
! 	- rewrote some of the sv_* functions to remove or avoid calls to
! 	  sscanf, one of the most expensive C library functions
  
  variables.c
! 	- don't look for $command_oriented_history at startup, since it now
! 	  defaults to `on'
  
! general.h, general.c
! 	- new function posix_initialize to do whatever is necessary to enable
! 	  `Posix mode'
  
! shell.c, subst.c
! 	- call posix_initialize
  
! general.c
! 	- rewrote replacements for strchr, strrchr to make them faster
  
! builtins/enable.def
! 	- new -f option and necessary support to load builtins from a shared
! 	  object file on systems supporting both dlopen() and dlsym().  New
! 	  builtins loaded this way can replace existing shell builtins or
! 	  add completely new functionality
! 
! builtins.h
! 	- mkbuiltins.c creates `static_shell_builtins', which is a fixed
! 	  array, `shell_builtins' points to this array initially
! 	- extern declaration for current_builtin
  
! builtins/mkbuiltins.c
! 	- change to creat static_shell_builtins[] and declare shell_builtins
! 	  as a pointer to it
! 	- change to declare `current_builtin' in created builtins.c
! 
! builtins/source.def
! 	- print an error message and return failure if no filename argument
! 	  is supplied
  
! builtins/common.c
! 	- current_builtin is set by find_shell_builtin, find_special_builtin,
! 	  and builtin_address_internal
! 	- new function builtin_usage, which prints the contents of
! 	  current_builtin->short_doc
! 
! builtins/{bind,declare,enable,fc,getopts,hash,history,jobs,kill,read,set,
! 	  setattr,trap,ulimit,umask}.def
! 	- changed the builtins in these files to use builtin_usage() to
! 	  print usage messages
! 
! cpp-Makefile
! 	- support for the HAVE_DLOPEN and HAVE_DLSYM defines
  
! machines.h
! 	- added -ldl and -Bdynamic to the SunOS4 entry
  
! documentation/{bash.1,features.texi}
! 	- documented new enable -f option to dynamically load builtins
  
! 				   9/16
! 				   ----
! test.c
! 	- added `==' as a synonym for `='
  
! 				   9/18
! 				   ----
! bashline.c
! 	- include readline/rlconf.h so that VI_MODE is defined if
! 	  appropriate
! 
! shell.c
! 	- removed `-nobraceexpansion' option
! 
! flags.c, flags.h
! 	- added new -B flag; enabled if brace expansion is turned on
! 
! subst.c
! 	- use brace_expand instead of !no_brace_expand
! 
! builtins/set.def
! 	- change set -o braceexpand to be equivalent to set -B
! 
! parse.y
! 	- in with_input_from_stdin, do nothing if bash_input.type already
! 	  is st_stdin or if there is already a stream with type st_stdin
! 	  on the saved stream stack
! 	- new function stream_on_stack to find out if there is a saved
! 	  stream of a specified type
! 
! documentation/bash.1, documentation/features.texi
! 	- doeumented new set -B option
! 	- removed -nobraceexpansion shell startup option
! 
! 				   9/19
! 				   ----
! builtins/reserved.def
! 	- made `help select' work
! 
! cpp-Makefile
! 	- removed references to the nonexistant `load.def'
! 	- removed conditionals based on GETOPTS_BUILTIN
! 
! builtins/getopts.def
! 	- no longer $DEPENDS_ON GETOPTS_BUILTIN
! 
! config.h, config.h.mini, builtins/help.def
! 	- made the `help' builtin dependent on the HELP_BUILTIN define
! 	- removed GETOPTS_BUILTIN
! 
! builtins/mkbuiltins.c
! 	- made the `$DEPENDS_ON' clause work for reserved words and
! 	  shell control structures in reserved.def by writing out
! 	  dependencies to builtext.h even if there is no `function'
! 	- made the long_doc for each builtin and reserved word get
! 	  written out to builtins.c with #ifdef HELP_BUILTIN surrounding
! 	  the doc strings -- this makes the minimal shell much smaller
! 
! shell.c, documentation/bash.1
! 	- removed `-quiet' long option
! 
! parse.y
! 	- make sure that word splitting is not performed on the prompt
! 	  string after expanding in prompt_string_decode by calling
! 	  expand_string_unsplit instead of expand_string
! 
! lib/readline/bind.c
! 	- new readline variable `mark-directories': if set, completed
! 	  directory names have a slash appended
! 
! lib/readline/complete.c
! 	- support for `mark-directories'
! 
! documentation/{bash.1,readline.3}, lib/readline/doc/rluser.texinfo
! 	- documented the new `mark-directories' variable
! 
! builtins/bind.def
! 	- new option `-r' to remove a binding for a specified key sequence
! 	- make sure that a failure return from bind resets the keymap
! 	  correctly if a -m option was supplied
! 
! documentation/{bash.1,features.texi}
! 	- documented new bind -r option
! 
! 				   9/20
! 				   ----
! builtins/jobs.def
! 	- new `disown' builtin
! 
! documentation/{bash.1,features.texi}
! 	- documented new `disown' builtin
! 
! cpp-Makefile
! 	- removed support for `MAKE_SHELL' cpp variable
! 	- renamed endian.aux to mkendian, look for endian.c in support dir
! 	- link in array.o, alias.o, braces.o, bracecomp.o
! 	  unconditionally, rely on cpp defines in the files to exclude code
! 	- pass -DHAVE_SYS_SIGLIST if sys_siglist is defined
! 	- pass -DHAVE_GETCWD if HAVE_GETCWD is defined in machines.h
! 	- pass -DHAVE_VFPRINTF_EMUALTION through from machines.h to
! 	  compilation
! 
! array.c
! 	- don't compile in body of file unless ARRAY_VARS is defined
! 
! braces.c
! 	- don't compile in body of file unless BRACE_EXPANSION is defined
! 
! alias.c
! 	- don't compile in body of file unless ALIAS is defined
! 
! bracecomp.c
! 	- don't compile in body of file unless BRACE_EXPANSION and READLINE
! 	  are defined
! 
! bashline.c
! 	- don't compile in body of file unless READLINE is defined
! 
! bashhist.c
! 	- don't compile in body of file unless HISTORY is defined
  
! siglist.c
! 	- don't compile in body of file unless HAVE_SYS_SIGLIST is not
! 	  defined
! 
! getcwd.c
! 	- don't compile in body of file unless HAVE_GETCWD is not defined
! 
! vprint.c
! 	- don't compile in body of file unless USE_VFPRINTF_EMULATION
! 	  is defined
! 
! support/mksysdefs
! 	- for SCO machines, define SYSDEF as SCO or SCOv4
! 
! lib/readline/readline.[ch]
! 	- new function rl_push_macro_input (s), which makes s the current
! 	  macro input string
! 
! endian.c
! 	- renamed to support/endian.c
! 
! 				   9/21
  				   ----
! lib/readline/complete.c
! 	- more file types for the VISIBLE_STATS code:
! 		|	FIFOs
! 		%	character special devices
! 		#	block special devices
! 
! lib/readline/isearch.c
! 	- made RETURN an alternate search string terminator
! 
! builtins/read.def
! 	- removed use of stdio -- unbuffered stdio on a dup of fd 0 is
! 	  a big loss
! 
! builtins/set.def
! 	- new function: minus_o_option_value, returns 1, 0, or -1 given
! 	  a -o option name (-1 means a bad name)
! 	- reorganized list_minus_o_options to be more efficient
! 
! execute_cmd.c
! 	- when expanding a here document, use maybe_expand_string rather
! 	  than a simple expand_string to try a speed things up a bit
! 
! input.c
! 	- don't compile in the body of the file unless BUFFERED_INPUT
! 	  is defined in config.h
  
! 				   9/22
  				   ----
! jobs.h, siglist.h
! 	- replaced instances of Solaris with SunOS5
! 
! shell.c
! 	- changed long option parsing code so that --arg is equivalent
! 	  to -arg, when `arg' is one of the recognized multichar options
! 
! builtins/history.def
! 	- rewrote to regularize the option parsing and use internal_getopt
! 	- now allows only one of -awrn to be specified
! 	- added a new -p option that adds each of its arguments to the
! 	  end of the history list, and deletes the `history -p' history
! 	  entry
! 
! builtins/trap.def
! 	- added new -p option to display specified trap values, or all
! 	  trap values if no other arguments supplied
! 
! documentation/{bash.1,features.texi}
! 	- documented new history -p option
! 	- documented new trap -p option
  
! 				   9/25
  				   ----
! lib/readline/display.c
! 	- fixed up the calcluation of the correct cursor line number (a `+'
! 	  and `-' were transposed in the calculation of `nleft')
  
! 				   9/26
  				   ----
! general.c
! 	- moved isint() here from test.c, renamed to legal_number
! 
! general.h
! 	- extern declaration of legal_number
! 
! test.c
! 	- only compile isint() if SHELL is not defined, define it as
! 	  legal_number otherwise
  
  trap.c
! 	- use legal_number in decode_signal instead of sscanf()
! 
! builtins/common.c
! 	- moved list_sigs to here from trap.def, renamed to
! 	  display_signal_list
! 	- changed get_numeric_arg to use legal_number instead of doing
! 	  the parsing and calculation itself
! 
! builtins/common.h
! 	- extern declaration for display_signal_list
! 
! builtins/{trap.def
! 	- changed to use display_signal_list for trap -l
! 
! builtins/kill.def
! 	- changed to use display_signal_list for kill -l
! 	- added new kill -n signum option
! 
! documentation/bash.1
! 	- added description of new kill -l signame functionality
! 	- added description of new kill -n signum feature
! 	- added description of new enable -d option
! 
! builtins.h
! 	- added a char *handle member to `struct builtin' for later use
! 	- new flags value: BUILTIN_DELETED
  
! builtins/mkbuiltins.c
! 	- added code to inintialize the `handle' member to null in the
! 	  static builtin array definition
! 
! builtins/common.c
! 	- don't `find' a builtin if the BUILTIN_DELETED flag is set in the
! 	  flags word of the struct builtins array
! 
! builtins/enable.def
! 	- new option -d to remove a builtin loaded with -f, depends on
! 	  HAVE_DLCLOSE
! 
! cpp-Makefile
! 	- pass -DHAVE_DLCLOSE through from machines.h to compilation
! 
! machines.h
! 	- change SunOS4 machine description to define HAVE_DLCLOSE
! 
! 				   9/27
  				   ----
! shell.c
! 	- split shell exit code off into a separate function: exit_shell(status)
  
! builtins/exec.def
! 	- rewrote for clarity and speed and to use the builtin getopt()
! 	- added new -a, -c, and -l options
! 	- now calls exit_shell if shell_execve fails and the shell is not
! 	  interactive
  
! documentation/bash.1
! 	- documented the new options to `exec'
  
! 				   9/28
  				   ----
! builtins/exec.def
! 	- if the execve fails and the shell is not going to exit, reinitialize
! 	  traps and signals
! 	- only call end_job_control if subshell_environment != 0
! 	- exec should exit unconditionally if the execve fails and
! 	  subshell_environment != 0
! 
! subst.c
! 	- if valid_brace_expansion_word fails, make sure `temp' is set to
! 	  NULL before trying to free it after the `goto bad_substitution'
! 
! cpp-Makefile
! 	- add $(CPPFLAGS) to the compilation flags when making `mksignames'
  
! documentation/features.texi
! 	- fixed a typo in the tilde expansion section
  
! 				   9/29
  				   ----
! machines.h
! 	- DEC OSF/1 has the dlopen/dlsym/dlclose set of library functions
  
  shell.c
! 	- don't execute /etc/profile if -noprofile given
! 
! builtins/pushd.def
! 	- new file, pushd/popd/dirs split off from cd.def
! 	- replaced calls to sscanf with calls to legal_number
! 
! builtins/Makefile, cpp-Makefile
! 	- changes for pushd.def
  
! config.h, config.h.mini
! 	- ALLOW_RIGID_POSIX_COMPLIANCE is no longer used
! 
! subst.c, variables.c
! 	- GETOPTS_BUILTIN is no longer used
! 
! variables.c
! 	- if the first character of argv[0] is not a `/', search the path
! 	  and canonicalize the result to find out how to set $BASH
  
! 				   10/2
! 				   ----
! builtins/enable.def
! 	- changed enable_shell_builtin to use builtin_address_internal to find
! 	  the builtin rather than searching the list itself
! 	- list_some_builtins skips a builtin if flags & BUILTIN_DISABLED != 0
! 	- rewrote dyn_load_builtin to take a list of names to load from a
! 	  single filename
! 	- don't dlclose the shared object in dyn_unload_builtin unless its
! 	  reference count drops to 0
! 
! builtins/test.def
! 	- don't bother making new copies of everything in the argument list
! 	  when constructing the argc and argv for test_command; just make
! 	  sure not to free anything but ARGV
  
- 				   10/3
- 				   ----
  bashline.c
! 	- remove C-e binding in vi movement mode which switches into emacs
! 	  mode
! 
! general.c
! 	- make xfree only try to call free on non-null strings
! 
! 				   10/4
! 				   ----
! builtins/read.def
! 	- new `-e' option that uses readline to read the line
! 	- if one of the arguments is not a legal variable name, print an
! 	  error message and return failure
  
! builtins/reserved.def
! 	- changed the `Variables' to `variables' so `help variables' works
! 
! subst.c
! 	- set startup_state to 2 in child of command substitution to try to
! 	  avoid some unneeded forks
! 
! trap.c
! 	- removed call to reset_terminating_signals in restore_original
! 	  signals; callers are now required to take care of that themselves,
! 	  if necessary
! 
! execute_cmd.c, subst.c
! 	- added necessary calls to reset_terminating_signals before calls
! 	  to restore_original_signals
  
! execute_cmd.c
! 	- when executing a null command in a subshell, don't bother passing
! 	  a string to make_child; just pass NULL
! 	- in execute_builtin_or_function, don't add so many unwind-protects
! 	  if `subshell' == 1
! 	- in command_substitute, call cleanup_the_pipeline to discard the
! 	  old pipeline, so pipeline_pgrp does not get set to 0 in
! 	  start_pipeline, which is called by make_child via making_children
  
! jobs.c, nojobs.c
! 	- new function, ignore_tty_job_signals, to set SIGTTIN, SIGTTOU, and
! 	  SIGTSTP to SIG_IGN
! 	- new function, default_tty_job_signals, to set those signals
! 	  to SIG_DFL
! 	- new function, cleanup_the_pipeline to free up the_pipeline and
! 	  set it to NULL
! 
! 				   10/5
! 				   ----
! builtins/history.def
! 	- the history -p option is now -s (to sort of parallel the ksh
! 	  print -s option)
! 	- the -s option now combines all of its arguments into a single
! 	  string and appends the string to the history list
! 	- new history -p option to history expand each argument and print
! 	  the result without modifying the history list
! 
! documentation/bash.1, documentation/features.texi
! 	- documented the new -e option to read
! 	- documented the new history -s and -p options
! 	- documented the new cd and pwd -L options
  
! builtins/cd.def
! 	- changed cd and pwd to use internal_getopt
! 	- added the -L option to cd and pwd to follow symlinks (like if
! 	  set +P were issued)
! 
! builtins/pushd.def
! 	- added text for dirs +N and dirs -N to the dirs builtin long doc
! 	- added -v option to dirs to print dirstack one dir per line with
! 	  stack index prepended
  
! 				   10/6
  				   ----
! execute_cmd.c
! 	- split the command searching code into a new function:
! 	  search_for_command
! 	- removed a bunch of dead code from shell_execve
! 	- removed call to reset_terminating_signals when executing a function
! 	  or builtin in a subshell (either via (xxx) or xxx &)
! 	- don't add unwind protects at all in execute_function if subshell == 1
! 
! lib/readline/chardefs.h
! 	- new macro ALPHABETIC(c), returns 1 if c is a letter or digit
! 
! lib/readline/readline.c
! 	- don't call abort() in rl_change_case(); it's impolite in a
! 	  library function
! 	- new macro, SWAP, used to swap values of two integers
! 	- changed alphabetic to use ALPHABETIC, made it slightly faster
! 	- modified rl_change_case() so that word capitalization is the
! 	  same as GNU Emacs
! 
! lib/readline/search.c
! 	- in noninc_dosearch, don't reset the history positition to what
! 	  it was if we're currently in vi editing mode (as per Posix.2
! 	  `/' and `?' vi-mode editing commands)
  
! 				   10/7
  				   ----
! builtins/common.c
! 	- changed single_quote and double_quote to use char pointers
! 	  rather than string indexing
! 	- new function backslash_quote(string), which quotes special
! 	  characters in STRING using backslashes
  
! 				   10/8
! 				   ----
! alias.h
! 	- added an extern declaration for alias_expand_word
  
! parse.y
! 	- broke the alias expansion code off into a function
! 	  alias_expand_token; its return value says whether to re-read
! 	  a token or go on
! 	- changed the alias expansion code to handle aliases that expand
! 	  to nothing better
! 	- broke the code that does special-case token recognition off into
! 	  a function: special_case_tokens
! 	- used the new functions to make sure that the special-case tokens
! 	  can be the expansion of an alias
! 	- made sure that if in `posix mode' that reserved words cannot be
! 	  aliased and that all reserved words can be the values of aliases
! 	  and be recognized after expansion
  
! 				   10/10
! 				   -----
! lib/readline/complete.c
! 	- replaced #ifdef SHELL code with two new exported readline interfaces:
! 	  rl_filename_quoting_function and rl_filename_dequoting_function.
! 	  Both return a pointer to char.
! 	- new extern variable rl_filename_quote_characters, containing a list
! 	  of characters that cause a word to be quoted by the completer if
! 	  they appear in a file name
  
  bashline.c
! 	- new functions for rl_filename_quoting_function and
! 	  rl_filename_dequoting_function.
! 	- initialize rl_filename_quoting_function and rl_filename_dequoting_function
! 	  in initialize_readline
! 	- initialize rl_filename_quote_characters
! 
! lib/readline/readline.h
! 	- extern declarations for new public interfaces
! 	  rl_filename_quoting_function and rl_filename_dequoting_function
! 	- added declarations for NO_MATCH, SINGLE_MATCH, and MULT_MATCH for
! 	  use by the filename quoting functions
! 	- new extern declaration for rl_filename_quote_characters
! 
! lib/readline/history.c
! 	- made a version of single_quote be compiled in if SHELL is not
! 	  defined
! 	- the `q' and `x' modifiers are now compiled in by default, not
! 	  just if SHELL is defined
! 
! 				   10/11
! 				   -----
! subst.c
! 	- string_quote_removal was being a little overzealous in stripping
! 	  things within embedded quoted strings when `quoted' was == 1.
! 	  Only remove one level of quotes each time through the function
! 	  This fixes the problem of quotes being stripped incorrectly in
! 		var="The text \"hello\" should show up inside double quotes."
! 
! lib/readline/history.c
! 	- made the behavior of single quotes inhibiting history expansion
! 	  configurable with a variable: history_quotes_inhibit_expansion,
! 	  not just shell-specific
! 	- added a new variable: history_search_delimiter_chars, which is a
! 	  list of characters that can also delimit a history search string
! 
! lib/readline/history.h
! 	- extern declaration of history_quotes_inhibit_expansion
! 	- extern declaration of history_search_delimiter_chars
  
  bashhist.c
! 	- set history_quotes_inhibit_expansion to 1 in bash_initialize_history
! 	- initialize history_search_delimiter_chars to ";&()|<>"
! 
! lib/readline/doc/{rltech,hstech}.texinfo
! 	- documented new readline and history library interfaces
  
! parse.y
! 	- split the part of read_token that reads a single word off into
! 	  a new function: read_token_word
  
! lib/readline/chardefs.h
! 	- include <string.h> by default; only check HAVE_STRING_H if
! 	  HAVE_CONFIG_H is defined
  
- 				   10/12
- 				   -----
  parse.y
! 	- moved the `RESET' code out of read_token into reset_parser
! 	- rewrote some of decode_prompt_string to make it more efficient
! 	- rewrote more of read_token_word to make it more efficient
! 	- make shell_getc cast its result to `unsigned char' before
! 	  returning it.  This fixes the problem of \255 appearing in a
! 	  line
! 
! machines.h
! 	- new entry for m68k machines running Linux
! 
! 				   10/13
! 				   -----
! builtins/exec.def
! 	- use search_for_command rather than find_user_command to look up
! 	  the path to exec, so the hash table and temp environment are used
! 
! variables.c
! 	- don't rebuild the export environment after binding a shell
! 	  function unless that function is exported
! 	- make sure that copy_variable copies arrays correctly, using
! 	  dup_array()
! 	- in assign_in_env, only call tilde_expand if a `~' appears somewhere
! 	  in the value
! 
! execute_cmd.c
! 	- if we found $PATH in the temp environment in search_for_command,
! 	  call find_user_command_in_path instead of find_user_command, so
! 	  we don't try to search the temporary env again.  Call
! 	  find_user_command as normal if PATH is not in the temp environment
! 
! subst.c
! 	- char_is_quoted should not be compiled in if READLINE is not
! 	  defined
  
  lib/readline/complete.c
! 	- add a new external interface: Function *rl_char_is_quoted_p,
! 	  which is called to find out whether a word break character is
! 	  quoted and should be skipped over when breaking words for
! 	  the completer
! 
! lib/readline/readline.h
! 	- extern declaration for rl_char_is_quoted_p
! 
! bashline.c
! 	- initialize rl_char_is_quoted_p to char_is_quoted
! 
! lib/readline/doc/rltech.texinfo
! 	- documented rl_char_is_quoted_p
  
! lib/readline/readline.c
! 	- extend the undo records so that a `start' or `end' value of -1
! 	  means rl_point and a value of -2 means rl_end.  This is a start
! 	  to better support for undoing vi-mode commands like `C'
! 
! lib/readline/vi_mode.c
! 	- don't save what's entered in insert mode after a `C' command
! 	  for later insertion when doing a `redo'
! 
! 				   10/16
! 				   -----
! test.c
! 	- rewrote unop() to use a switch statement instead of a call to
! 	  strchr
! 	- remove #ifdef SHELL blocks by defining getuid, geteuid, getgid
! 	  and getegid as references to current_user.{uid,euid,gid,egid}
! 	  respectively
! 	- change group_member to only fetch the group list once and to use
! 	  NGROUPS_MAX or NGROUPS to find the maximum number of groups
! 
! documentation/bash.1
! 	- fixed description of ${#@} expansion
! 
! 				   10/17
! 				   -----
! support/bashbug.sh
! 	- add a `From:' line to the mail message handed to rmail
  
! 				   10/18
! 				   -----
! test.c
! 	- rewrote binary_operator for speed and clarity
! 	- removed age_of, added arithcomp(), filecomp() to support new
! 	  binary_operator
! 	- removed support for `-l string'
! 
! documentation/bash.1
! 	- removed mention of `-l string' from `test' description
! 
! 				   10/19
! 				   -----
! cpp-Makefile
! 	- pass PROGRAM as the double-quoted shell name to compilation of
! 	  shell.c and error.c
  
! 				   10/20
! 				   -----
! support/bashbug.sh
! 	- don't try to use ${word:-expansion}; ultrix sh doesn't understand it
  
! hash.c
! 	- new function: flush_hash_table (table, free_data) to delete the
! 	  contents of a given hash table.  *free_data is called to free
! 	  each item's data, if free() is inappropriate
  
  builtins/hash.def
! 	- new functions free_hashed_filenames and free_filename_data to
! 	  flush the table of hashed filenames
! 
! subst.c
! 	- change sv_path to call flush_hashed_filenames directly
! 
! variables.c
! 	- only sort arrays of variables or functions for the environment or
! 	  `set' output if `posixly_correct' is set.  sh does it; ksh does
! 	  not, and there's no real requirement to do so
! 	- rewrote delete_all_variables so it looks like flush_hash_table
! 
! trap.c
! 	- two new flag values for the `sigmodes' array: SIG_INPROGRESS,
! 	  which is set for sigmodes[sig] while a trap handler for sig
! 	  is executing, and SIG_CHANGED, which is set if a new trap
! 	  value is set when SIG_INPROGRESS is set.  This should obviate
! 	  the need to set the trap value to IMPOSSIBLE_TRAP_HANDLER while
! 	  the trap handler is executing
! 
! alias.c
! 	- rewrote delete_all_aliases so it looks like flush_hash_table
! 
! 				   10/21
! 				   -----
! alias.c
! 	- changed delete_all_aliases to call flush_hash_table directly
! 	  and use free_alias_data as the `free function' argument
! 
! variables.c
! 	- changed delete_all_variables to call flush_hash_table directly
! 
! tests/run-test, tests/test-tests
! 	- new scripts to run tests of the `test' builtin as part of the
! 	  regression test
! 
! 				   10/24
! 				   -----
! bashline.c
! 	- initialize_hostname_list needs to look for HOSTFILE first
! 	- hostname list is no longer sorted
! 	- replaced binary search in hostnames_matching with a simple
! 	  linear search
! 	- made the code that reads hostnames skip over the first word on
! 	  a line only if its first character is a digit, assuming it's
! 	  an Internet address
! 
! copy_cmd.c
! 	- removed copy_select_command; overload copy_for_command, since the
! 	  select and for command structs are exactly the same
! 
! make_cmd.c
! 	- combined make_for_command and make_select_command into a new
! 	  function, make_for_or_select
! 	- rewrote make_here_document to remove the unneeded `switch' statement
! 
! builtins/common.c, builtins/hash.def
! 	- moved remove_hashed_filename from common.c to hash.def
! 
! builtins/common.c
! 	- remove the \r from error message printed by get_working_directory
! 	- change parse_and_execute to call dispose_fd_bitmap directly then
! 	  discard the `pe_dispose' unwind-protect frame rather than running
! 	  the frame
! 
! builtins/set.def
! 	- changed how set -o options are set and retrieved, using set and get
! 	  functions to avoid all that special-case inline code
! 
! 				   10/26
! 				   -----
! test.c
! 	- added unary operator `-o', which returns true of the shell option
! 	  name given as an argument is set
! 
! lib/readline/readline.c
! 	- added a definition of set_lines_and_columns to be called if the
! 	  library is not compiled -DSHELL
! 
! shell.c
! 	- added a --verbose startup long option
! 	- renamed `--nolineediting' to `--noediting'
! 
! 				   10/27
! 				   -----
! lib/readline/util.c
! 	- new file, for readline utility functions
! 
! lib/readline/readline.c
! 	- moved a bunch of functions to util.c
! 
! subst.c
! 	- make sure set_sigint_handler is called only by the subshells doing
! 	  command and process substitution
! 
! builtins/read.def
! 	- make sure that rlbuf is initialized to null
! 
! trap.c
! 	- new flag for sigmodes[] members: SIG_IGNORED, set when signal is
! 	  ignored, even if it's special or untrappable
! 	- new function: signal_is_ignored (sig), which returns 1 if SIG
! 	  has been ignored with trap ''
! 
! builtins/trap.def
! 	- changed to use the builtin getopt
! 
! shell.c
! 	- added a check to sigint_sighandler for whether or not SIGINT has
! 	  been ignored with trap '' in an interactive shell.  This fixes
! 	  the problem with `read' being interruptible in an interactive
! 	  shell even if SIGINT is being ignored
  
! 				   11/8
  				   ----
! lib/readline/Makefile
! 	- added definition of INSTALLED_HEADERS, just in case
! 
! 				   11/11
! 				   -----
! variables.c
! 	- change assign_in_env so that it doesn't use savestring ("") to
! 	  set `value' to a dummy value; don't call strcpy if there's
! 	  nothing to copy
! 
! 				   11/15
! 				   -----
! general.h
! 	- new defines, legal_variable_starter and legal_variable_char
! 	- new define SIGRETURN(n) which encapsulates the VOID_SIGHANDLER
! 	  differences when returning from a signal handler
! 
! general.c, variables.c, subst.c, expr.c
! 	- use legal_variable_starter and legal_variable_char
! 
! shell.c, nojobs.c, trap.c, jobs.c, builtins/suspend.def
! 	- change to use SIGRETURN macro
! 
! subst.c
! 	- massive changes to clean up the code and remove unused code and
! 	  variables
! 	- expanded the ${#param} code so that all of the shell special
! 	  variables may have their length taken
  
! tests/run-tilde
! 	- new test for tilde expansion
  
  bashline.c
! 	- fix a bug in command_subst_completion_matches: make sure that
! 	  `matches' is static
  
! parse.y
! 	- don't print a prompt when not using readline if the current
! 	  input type is st_string
! 
! machines.h
! 	- add -DINT_GROUPS_ARRAY to SYSDEP_CFLAGS on ultrix
! 	- fixes to the cray machine description from Bill Jones
  
! braces.c
! 	- fixed a bug in brace_gobbler that prevented a backslash from
! 	  escaping an open brace
  
! 				   11/16
! 				   -----
! tests/braces-tests, tests/run-braces
! 	- new regression tests for brace expansion
! 
! builtins/pushd.def
! 	- new -p option for `dirs' that prints dirstack on per line
! 	  without numbers
! 
! 				   11/17
! 				   -----
! command.h
! 	- move redirection error values here from execute_cmd.c
! 	- new defines INPUT_REDIRECT and OUTPUT_REDIRECT
! 
! shell.c
! 	- make the default MAINTAINER `bash-maintainers@prep.ai.mit.edu'
! 
! execute_cmd.c
! 	- many changes to clean up the code and remove unused variables and
! 	  functions
! 	- new functions: redirection_error, find_in_path_element,
! 	  find_absolute_program
! 	- fixes to redirection error reporting, so things like exec 4<&y*
! 	  and exec 4<&$FOO are displayed correctly
! 	- removed the `lexical_scoping' code
! 
! flags.c, flags.h
! 	- removed the lexical_scoping code and variable
! 
! documentation/{bash.1,features.texi}
! 	- removed the description of the `-l' option to `set'
! 
! jobs.c
! 	- don't try to open /dev/tty to get the controlling tty, use
! 	  fd 2 like other job control shells
! 
! lib/readline/vi_mode.c
! 	- when using `d%', make sure the matching character found by
! 	  the `%' is deleted by the `d'.  Ditto for `c%'.
! 	- stub function for vi undo: rl_vi_undo.  Right now it just
! 	  calls rl_undo_command
! 
! lib/readline/vi_keymap.c
! 	- change to call rl_vi_undo instead of rl_undo_command
! 
! lib/readline/readline.h
! 	- extern declaration for rl_vi_undo
! 
! 				   11/21
! 				   -----
! execute_cmd.c
! 	- fix to print_select_list to avoid a possible divide-by-zero error
! 	  and subsequent core dump
! 	- fix to execute_select_command to just return 0 if there is no
! 	  select list
! 
! parse.y
! 	- remove `in' from the list of tokens that cannot take trailing
! 	  semicolons
! 
! builtins/read.def
! 	- make sure that leading IFS whitespace is removed before calling
! 	  get_word_from_string the first time.  This matters when IFS is
! 	  not " \t\n" but non-null
! 	- make sure the array code uses IFS to split the input string
! 	  before assigning it to the array
! 
! 				   11/22
! 				   -----
! parse.y
! 	- make sure that if \nnn expands to CTLESC or CTLNUL, the char
! 	  is protected by a CTLESC
! 	- new variable `promptvars', which, if non-zero, causes all the
! 	  variable expansions to be performed in decode_prompt_string.
! 	  If zero, only quote removal is performed.
! 
! builtins/source.def
! 	- new variable: `source_uses_path', set to 1 by default.  If
! 	  non-zero, the `.' builtin uses $PATH to find the script to
! 	  source
! 
! builtins/getopt.h
! 	- cut out everything not needed by bash
! 
! builtins/getopt.c
! 	- cut out everything not needed by bash
! 
! builtins/getopts.def
! 	- removed the call to getopt_set_posix_option_order, which is no
! 	  longer necessary
! 
! execute_cmd.c
! 	- split the code that writes out here documents to files out into
! 	  a separate function
! 
! 				   11/23
! 				   -----
! builtins/getopt.c, builtins/getopt.h, builtins/getopts.def, subst.c
! 	- prefix all of the getopt variables and functions with `sh_'
! 	  (that is, optind becomes sh_optind and getopt becomes sh_getopt)
! 	  to avoid confusion with a system's getopt(3) implementation
! 
! subst.c
! 	- new functions: parameter_brace_substring and verify_substring_values
! 	  and changes to expand_word_internal to support the ksh-93
! 	  ${var:exp1:exp2} substring syntax
! 
! documentation/bash.1
! 	- documented the new ${var:exp1[:exp2]} syntax
! 
! 				   11/25
! 				   -----
! builtins/setattr.def
! 	- don't allow readonly -n at all
! 
! array.c
! 	- split array_to_string into two parts; a new function
! 	  array_to_string_internal does the real work
! 	- new function array_subrange () to return a subset of the elements
! 	  in an array
! 
! subst.c
! 	- augmented the substring code to handle the positional parameters
! 	  and array variables
! 	- made quote_list and dequote_list return their WORD_LIST *
! 	  arguments so they can be used like
! 
! 		z = string_list ((quoted ? quote_list (l) : l), xxx);
! 
! 	- augmented the ${xxx} expansion code to do indirect variable
! 	  references if the first character of the variable name is `!'
! 
! tests/new-exp.tests
! 	- added regression tests for substring expansion
! 	- added regression tests for indirect variable references
! 
! 				   11/28
! 				   -----
! builtins/set.def
! 	- added set -o hashfunc and set -o onecmd, synonyms for set -h
! 	  and set -t, respectively
! 
! builtins/shift.def
! 	- changed shift so that the positional parameters are not changed
! 	  if the argument is > $# (this is ksh and Posix.2, unlike sh)
! 
! documentation/bash.1
! 	- documented true behavior of `shift'
! 
! lib/readline/kill.c
! 	- split the kill ring management code and the kill commands out
! 	  from readline.c into this file
! 
! lib/readline/undo.c
! 	- split the code that does undoing out of readline.c into this file
! 
! shell.c
! 	- force the shell to exit with status 127 if a longjmp back to
! 	  run_one_command occurs with bash -c
! 	- force the last command exit status to 1 if a
! 	  longjmp (top_level, DISCARD) is performed
! 
! builtins/read.def
! 	- don't throw away partial lines after reading EOF
! 
! subst.c
! 	- command substitution should not inherit the -e flag
! 
! builtins/source.def
! 	- make sure to set the exit status correctly when in posix mode
! 	  and the filename argument to `.' does not exist
! 
! 				   11/29
! 				   -----
! lib/readline/input.c
! 	- split the input buffering and character input code out of
! 	  readline.c to here
! 
! lib/readline/macro.c
! 	- moved the keyboard macro management code to here from readline.c
! 
! lib/readline/readline.c
! 	- removed the STATIC_MALLOC code
! 
! lib/readline/rltty.c
! 	- return -1 in POSIX get_tty_settings if tcgetattr returns -1 and
! 	  errno != EINTR, even if output is being flushed
! 
! 				   12/1
! 				   ----
! machines.h
! 	- fixes to the hpux_8 and hpux_9 machine descriptions
! 
! trap.c
! 	- make run_exit_trap return the right exit status
! 	  (last_command_exit_value)
! 	- run_exit_trap no longer preserves the value of last_command_exit_value
! 	  around the execution of the trap commands
! 	- run_exit_trap now turns off SIG_TRAPPED and sets SIG_INPROGRESS
! 	  and will not try to run anything if SIG_INPROGRESS is set
! 
! trap.h
! 	- change definition for run_exit_trap
! 
! shell.c
! 	- call run_exit_trap only if trap[0] is set and not ignored
! 
! builtins/exit.def
! 	- make sure we only source the .bash_logout file once, even if it
! 	  contains a call to `exit'
! 
! execute_cmd.c
! 	- if we run an exit trap in a (...) user subshell, allow it to
! 	  override the exit status of the subshell
! 
! lib/readline/readline.c
! 	- made rl_delete_text bounds check its `to' argument, and limit
! 	  it at rl_end
! 
! lib/readline/vi_mode.c
! 	- make rl_vi_subst call `rl_delete_text' directly for the `s'
! 	  command
! 
! support/mksysdefs
! 	- define a new variable for the sysdefs.h file for ISC machines:
! 	  ISC_release, which can be ISC_2, ISC_3, or ISC_4
! 
! machines.h
! 	- don't `#undef' HAVE_GETCWD on ISC 4.x machines
! 	- `#undef' HAVE_RESOURCE on ISC 4.x machines
! 
! support/mkversion.c
! 	- include "posixstat.h" rather than <sys/stat.h> for the benefit
! 	  of ISC machines
! 
! 				   12/5
! 				   ----
! lib/readline/complete.c
! 	- changed username_completion_function so that a null username
! 	  generates a list of all users as possible completions
! 
! lib/readline/readline.h
! 	- added definitions for STREQ, STREQN
! 
! lib/readline/{search.c,isearch.c,kill.c}
! 	- removed private definitions of STREQ, STREQN
! 
! execute_cmd.c
! 	- in find_user_command_internal, just return a copy of the pathname
! 	  passed as an argument if there is no PATH
! 
! 				   12/6
! 				   ----
! siglist.h
! 	- NetBSD 1.0 does not need a define for strsignal()
! 
! 				   12/8
! 				   ----
! subst.c
! 	- removed assignment_name, word_list_quote_removal, word_quote_removal,
! 	  and sub_append_number -- unused functions
! 	- removed some unexecuted code from expand_word_internal
! 
! 				   12/9
! 				   ----
! execute_cmd.c
! 	- if PATH is set to the empty string, find executables in the
! 	  current directory
! 
! shell.c, parse.y, trap.c
! 	- before setting the SIGINT sighandler unconditionally to one of
! 	  sigint_sighandler or termination_unwind_protect, check that it
! 	  is not ignored.  Now trap '' 2 really sets the SIGINT signal
! 	  handler to SIG_IGN. [In 1.14.3]
! 
! trap.c
! 	- rewrote set_sigint_handler to use SIG_IGNORED rather than checking
! 	  against IGNORE_SIG
! 	- changed ignore_signal, run_exit_trap, maybe_call_trap_handler, and
! 	  run_trap_internal to check SIG_IGNORED
! 
! shell.c
! 	- removed the check for signal_is_ignored(SIGINT) in sigint_sighandler
! 
! 				   12/11
! 				   -----
! sig.c, sig.h
! 	- new files, moved signal-related definitions and code here from
! 	  shell.c, general.h, general.c, jobs.c, jobs.h, externs.h
! 
! unwind_prot.c, shell.h, nojobs.c
! 	- include sig.h
! 
! 				   12/12
! 				   -----
! jobs.c
! 	- only break out of loops if SIGTSTP was used to stop a job in the
! 	  loop, the shell is currently interactive, and job control is on.
! 	  SIGSTOP does not break loops. [In 1.14.3]
! 
! 				   12/13
! 				   -----
! expr.c
! 	- bases < 2 or > 36 are now accepted without silently being reset
! 	  to 10
! 
! braces.c
! 	- make sure array_concat copies the array it returns if one of
! 	  the arguments is null [In 1.14.3]
! 
! 				   12/14
! 				   -----
! subst.c
! 	- split the ${...} expansion code out into a separate function,
! 	  static char *parameter_brace_expand()
! 	- changes to array_value so that any variable can be referred to
! 	  as an array with an integer subscript.  The value will be
! 	  returned if a non-array variable is referred to as ${var[0]};
! 	  if the subscript is > 0 a null string is returned
! 
! 				   12/15
! 				   -----
! machines.h
! 	- fixes to freebsd description for FreeBSD 2 [In 1.14.3]
! 
! support/bashbug.sh
! 	- changed to use /usr/lib/sendmail if present or /usr/sbin/sendmail
! 	  if present, defaulting to rmail [In 1.14.3]
! 
! bashhist.c
! 	- HISTFILESIZE now controls how large the history file is after
! 	  it is written.  After saving the shell history, sv_histfilesize
! 	  will truncate it if necessary.  history -w can override this.
! 
! documentation/bash.1
! 	- documented change to treatment of HISTSIZE when saving history
! 
! lib/malloc/malloc.c
! 	- removed the calls to sigsetmask() in malloc().  This should
! 	  result in a speed improvement
! 
! 				   12/19
! 				   -----
! builtins/enable.def
! 	- don't allow -f or -d in a restricted shell
! 
! builtins/alias.def
! 	- rewrote alias and unalias to use the internal getopt
! 	- added -p option to print the alias list to alias
! 	- fixed up the documentation for `alias'
! 
! documentation/{bash.1,features.texi}
! 	- updated the documentation for `alias'
! 	- updated the documentation for $_
! 
! array.c,array.h
! 	- new function `empty_array (ARRAY *a)' removes all of the
! 	  elements in a without destroying the array variable in
! 	  preparation for overwriting it.  Used by read -a.
! 
! builtins/read.def
! 	- call empty_array() before assigning list of values with read -a
! 	- changed dispose_array to use empty_array to destroy the
! 	  array elements
! 
! variables.c
! 	- set $_ to argv[0] at variable initialization time
! 
! 				   12/20
! 				   -----
! subst.c
! 	- broke the pattern removal code into a few separate functions:
! 	  getpatspec to get the pattern specifier, getpattern to do the
! 	  necessary word expansions and return the pattern to be matched
! 	- new function: parameter_list_remove_pattern(), which implements
! 	  the ${param[#%][[%#]]pattern} where param is `@' or `*'
! 
! documentation/bash.1
! 	- documented new pattern removal functionality for the positional
! 	  paramters
! 
! general.c
! 	- new function strsub (s, pat, rep, gflag) replaces PAT with REP
! 	  in S.  All occurrences are replaced if GFLAG != 0; the first is
! 	  replaced otherwise
! 	- changed strindex() to avoid multiple calls to strnicmp by
! 	  checking first character of the string
! 
! builtins/fc.def
! 	- changed to use builtin_getopt with a check for fc numbers as
! 	  arguments
! 	- some code rearranging for efficiency and clarity
! 	- fc_dosubs now just calls strsub(); fc_replace is gone
! 
! 				   12/21
! 				   -----
! subst.c
! 	- new function, match_pattern, which matches a shell globbing
! 	  pattern anywhere in a string and returns the boundaries of the
! 	  match
! 
! lib/readline/readline.h
! 	- declarations for rl_insert_command and rl_backward_char_search
! 
! lib/readline/readline.c
! 	- new function rl_insert_comment, no longer vi-mode-specific
! 	- new function rl_backward_char_search
! 
! lib/readline/bind.c
! 	- comment-begin now sets the comment char for emacs and vi modes
! 	- variable holding the value is now _rl_comment_begin
! 
! lib/readline/vi_mode.c
! 	- move the `comment-begin' stuff to readline.c and bind.c
! 
! lib/readline/funmap.c
! 	- vi-comment is now insert-comment
! 	- new bindable command character-search-backward
! 
! lib/readline/vi_mode.c
! 	- command mode `#' now invokes rl_insert_comment
! 
! lib/readline/emacs_keymap.c
! 	- M-# now bound to insert-comment
! 	- M-space now bound to set-mark
! 	- M-^] now bound to character-search-backward
! 
! bashline.c
! 	- posix_readline_initialize now calls rl_variable_bind to set the
! 	  value of comment-begin rather than directly modifying
! 	  _rl_comment_begin
! 
! documentation/{bash.1,readline.3}, lib/readline/doc/rluser.texinfo
! 	- added description of new bindable `insert-comment' command
! 	- documented new M-space emacs mode binding
! 	- documented new character-search-backward command and default
! 	  emacs mode binding to M-C-]
! 
! shell.c
! 	- only call posix_initialize if posixly_correct is set
! 
! 				   12/22
! 				   -----
! cpp-Makefile
! 	- make $(Program) depend on $(srcdir)/.distribution, for the
! 	  benefit of systems where `make' does not have VPATH support
! 	  [In 1.14.3]
! 
! jobs.c
! 	- if a foreground job is killed by SIGINT while job control is
! 	  active, print a newline to compensate for the kernel printing
! 	  ^C without one [in 1.14.3]
! 
! bashline.c
! 	- make sure bashline_reinitialize resets rl_completion_entry_function
! 	  to NULL, as the comment says it should [In 1.14.3]
! 
! 				   12/23
! 				   -----
! test.c
! 	- fix a problem that caused core dumps if a `)' was missing in a
! 	  parenthesized expression [In 1.14.3]
! 
! jobs.c
! 	- broke the code the manages the manipulation of the job table and
! 	  process status out of flush_child into a new function waitchld()
! 	- flush_child now just calls waitchld() with a parameter that tells
! 	  it not to block
! 	- wait_for calls waitchld() with the pid it's looking for and tells
! 	  it to block (don't call it with WNOHANG)
! 	- cleaned up wait_for considerably -- turned the wait_loop: label
! 	  stuff into a do-while loop and removed the setting of job status
! 	  (that's now done only by waitchld).  wait_for now calls
! 	  waitchld continuously until the job it is interested in is
! 	  marked JDEAD.
! 
! 				   12/28
! 				   -----
! subst.c
! 	- fixed expand_word_internal so that any word that expands into
! 	  nothing and contains a double-quoted $@ is removed, like sh
! 	  and ksh
! 	- new function: expand_string_for_rhs, which calls expand_word_internal
! 	  with a variable that lets it find out whether or not a $@ appeared
! 	  in the WORD in ${paramOPword} when expanding it, so that "$@"
! 	  and various other things are handled correctly on the rhs
! 	- added params for parameter_brace_expand to tell expand_word_internal
! 	  if a quoted $@ was processed as part of the rhs (or even the lhs);
! 	  these new params are passed along to parameter_brace_expand_rhs
! 	- pass the right value of quoted to parameter_brace_expand_rhs from
! 	  parameter_brace_expand.  expand_string_for_rhs doesn't need to know
! 	  whether the brace expression is quoted
! 
! 				   12/31
! 				   -----
! support/printenv
! 	- now an official part of the distribution, moved from CWRU/misc
! 	  [in 1.14.3]
! 
! cpp-Makefile
! 	- copy support/printenv into the `tests' directory when making tests
! 	  [in 1.14.3]
! 	- change to understand GCC_STANDARD [in 1.14.3]
! 
! support/bashbug.sh
! 	- fixed a typo that caused it to not parse correctly [in 1.14.3]
! 
! machines.h
! 	- define GCC_STANDARD if the standard `cc' is gcc and you don't want
! 	  to use the compiler named `gcc' for some reason [in 1.14.3]
! 
! 				    1/2
! 				    ---
! general.h
! 	- added FS_DIRECTORY to the list of flags that file_status returns
! 
! execute_cmd.c
! 	- changed find_in_path_element to return null if the flags argument
! 	  specifies FS_EXEC_ONLY and the file is not executable
! 	- return FS_DIRECTORY from file_status if the argument specifies a
! 	  directory
! 	- new function, is_directory (char *), which returns non-zero if the
! 	  filename argument is a directory
! 
! execute_cmd.h
! 	- extern declaration for is_directory
! 
! flags.c, flags.h
! 	- hashing_disabled and locate_commands_in_functions were removed,
! 	  hashing_enabled added
! 
! execute_cmd.c, builtins/common.c. builtins/hash.def
! 	- use hashing_enabled instead of hashing_disabled, and reverse
! 	  the sense of tests of it
! 
! documentation/bash.1, documentation/features.texi
! 	- changed description of `set -h/set -o hashcmds', removed
! 	  set -d/set -o nohash
! 
! bashline.c
! 	- changed command_word_completion_function to return matches if names
! 	  are directories as well as if they are executable files
! 
! support/mksysdefs
! 	- look for `ranlib' in $PATH before searching the file system;
! 	  look in /usr/gnu/bin for it; default to `:' if not found
! 
! general.c
! 	- change ansicstr to accept a second argument telling it whether to
! 	  recognize \c and to pass back a non-zero value in it if \c is
! 	  seen
! 
! general.h
! 	- changed extern declaration of ansicstr
! 
! subst.c
! 	- call ansicstr with an extra argument
! 
! 				    1/3
! 				    ---
! builtins/echo.def
! 	- rewrote to use ansicstr() with the new argument
! 
! 				    1/4
! 				    ---
! trap.c
! 	- changed instances of signal() to set_signal_handler() [in 1.14.4]
! 	- combined reset_signals and restore_signals into a single function,
! 	  since they were essentially identical
! 
! subst.c
! 	- if set -u is set, references to the positional parameters now
! 	  generate errors if that parameter is not set [in 1.14.4]
! 
! lib/*/Makefile, builtins/Makefile
! 	- since RANLIB can be just `ranlib', just try to run it without
! 	  checking that the file exists [in 1.14.4]
! 
! builtins/set.def
! 	- changed `hashcmds' to `hashall'
! 
! documentation/{bash.1,features.texi}
! 	- changed `hashcmds' to `hashall'
! 
! 				    1/5
! 				    ---
! trap.c
! 	- make the loop that restores signal handlers run from signal 0 to
! 	  make sure user subshells don't inherit traps on `exit' (to fix
! 	  for 1.14.3, change restore_original_signals so that the loop
! 	  starts from 0) [in 1.14.4]
! 
! variables.c
! 	- don't import exported function definitions at startup if the
! 	  shell is restricted
! 
! builtins/source.def
! 	- don't allow use of pathname arguments containing `/' in a
! 	  restricted shell
! 
! execute_cmd.c
! 	- when a shell is spawned to execute a shell script without a
! 	  #! line, turn off the -r flag if the shell is restricted
! 
! shell.c
! 	- added a new long option `--restricted'
! 
! documentation/bash.1
! 	- added a section on the restricted shell, and documented the
! 	  new `--restricted' long invocation option
! 
! 				    1/7
! 				    ---
! shell.c
! 	- when using bash -c command, make run_one_command return
! 	  last_command_exit_value if a throw_to_top_level with value
! 	  EXITPROG occurs [in 1.14.4]
! 
! print_cmd.c
! 	- make sure to initialize arg_index in the non-varargs implementation
! 	  of cprintf [in 1.14.4]
! 
! jobs.c
! 	- don't try to change the state of the SIGCHLD handler before
! 	  calling waitchld() from wait_for, since SIGCHLD is blocked
! 	  while this code is executing [in 1.14.4]
! 
! 				   1/11
! 				   ----
! lib/readline/rltty.c
! 	- call control_keypad iff the value of a new variable,
! 	  _rl_enable_keypad, is non-zero
! 
! lib/readline/bind.c
! 	- new readline variable `enable-keypad' to control whether readline
! 	  tries to manipulate the application keypad
! 
! documentation/{bash.1,readline.3}, lib/readline/doc/rluser.texinfo
! 	- documented new `enable-keypad' variable
! 
! 				   1/12
! 				   ----
! lib/readline/search.c
! 	- make sure to call rl_unix_word_rubout and rl_unix_line_discard
! 	  with the correct arguments [in 1.14.4]
! 
! make_cmd.h
! 	- make sure make_select_command is declared even if SELECT_COMMAND
! 	  is not defined
! 
! parse.y
! 	- make sure the \[ and \] escape sequences are not recognized if
! 	  READLINE is not defined [in 1.14.4]
! 
! config.h
! 	- make sure HISTORY is defined if READLINE is; code moved here
! 	  from bashhist.c [in 1.14.4]
! 
! bashhist.c
! 	- removed check for READLINE being defined without HISTORY; now
! 	  in config.h
! 	- new function, bash_history_reinit
! 
! flags.h, flags.c, builtins/set.def
! 	- the -H/-o histexpand flag should be compiled into the shell
! 	  only if BANG_HISTORY is defined [in 1.14.4]
! 
! subst.c
! 	- don't include sv_histchars unless BANG_HISTORY is defined
! 	  [in 1.14.4]
! 	- if QUOTED is true in parameter_brace_expand_rhs, pre-process the
! 	  word on the rhs of the parameter expansion by a call to
! 	  string_extract_double_quoted with the STRIPDQ parameter set to 1
! 	- new arg for string_extract_double_quoted; causes it to strip
! 	  double quotes and alter its backslash handling behavior; designed
! 	  to be called from parameter_brace_expand_rhs
! 	- changed all other instances of string_extract_double_quoted to
! 	  call it with STRIPDQ set to 0, to get old behavior
! 
! shell.c
! 	- call bash_history_reinit rather than manipulating history
! 	  variables directly
! 
! variables.c
! 	- don't auto-export $BASH [in 1.14.4]
! 
! tests/rhs-exp.tests
! 	- new test script to check for behavior fixed by changes to
! 	  string_extract_double_quoted and parameter_brace_expand_rhs
! 
! parse.y
! 	- `for' and `select' must now take non-empty lists between
! 	  `in' and `;'
! 
! 				   1/16
! 				   ----
! subst.c
! 	- fixed string_quote_removal to do double-quoted string processing
! 	  itself rather than call string_extract_double_quoted, which
! 	  assumes that a call to expand_word_internal or the equivalent
! 	  will follow immediately and leaves some backslashes in place,
! 	  inappropriately for quote removal
! 
! 				   1/23
! 				   ----
! subst.c
! 	- make sure to set `temp' to NULL after it's freed by sub_append_string
! 	  in expand_word_internal to keep it from pointing to newly-allocated
! 	  memory that will be subsequently freed, causing a `memory freed
! 	  twice' error [in 1.14.4]
! 
! trap.c
! 	- handle the EXIT_TRAP specially in reset_or_restore_signal_handlers,
! 	  since in both cases we simply want to free up the trap string and
! 	  mark the signal as not trapped
! 
! shell.h
! 	- added \n to the list of characters in slashify_in_double_quotes
! 
! 				   1/26
! 				   ----
! subst.c
! 	- make string_extract_single_quoted and string_extract_double_quoted
! 	  `inline'
! 	- new function skip_single_quoted, used when we used to call
! 	  string_extract_single_quoted and just throw the returned string
! 	  away
! 	- new function skip_double_quoted for the same purpose
! 
! 				   1/28
! 				   ----
! subst.c
! 	- fixed expand_word_internal so that if an assignment word
! 	  is expanded, no word splitting is performed [in 1.14.4]
! 
! builtins/ulimit.def
! 	- some systems lack RLIMIT_CPU; so `#ifdef' its use [in 1.14.4]
! 	- some versions of cpp expand parameters like \n if `n' is an
! 	  argument to the macro; change `n' to `num' in the definition
! 	  of print_rlimtype to compensate [in 1.14.4]
! 
! builtins/read.def
! 	- make sure the read loop sets `saw_escape' to note that an
! 	  escape character was read if CTLESC or CTLNUL is read [in 1.14.4]
! 
! shell.c, sig.c
! 	- only test interactive_shell before calling maybe_save_shell_history
! 	  [in 1.14.4]
! shell.c
! 	- include <locale.h> if HAVE_LOCALE_H is defined
! 	- call setlocale(LC_ALL, "") at the beginning of main() if
! 	  either _POSIX_VERSION or HAVE_SETLOCALE is defined
! 
! support/mksysdefs
! 	- look for <locale.h>, define HAVE_LOCALE_H if found
! 
! cpp-Makefile
! 	- pass HAVE_LOCALE_H through from sysdefs.h to the build process
! 
! bashhist.c
! 	- remove test against interactive_shell in maybe_save_shell_history
! 	  [in 1.14.4]
! 
! variables.c
! 	- moved definition of DEFAULT_MAIL_PATH to config.h
! 
! config.h, config.h.mini
! 	- now has definition of DEFAULT_MAIL_PATH [in 1.14.4]
! 	- changed default value of PATH to
! 	  `/usr/gnu/bin:/usr/local/bin:/usr/ucb:/bin:/usr/bin:.'
! 	  [in 1.14.4]
! 
! documentation/bash.1
! 	- updated the example of the default path in the description of
! 	  the PATH variable
! 
! lib/readline/readline.c
! 	- set up a table of `legal' LC_CTYPE values and match the value of
! 	  $LC_CTYPE against it when deciding whether or not to default to
! 	  eight-bit input and output
! 	- check for LC_ALL, LC_CTYPE, and LANG, in that order, for names to
! 	  check against the legal_lc_ctype_values table
! 
! lib/readline/bind.c
! 	- moved strindex, stricmp, and strnicmp to lib/readline/util.c, 
! 	  added _rl_ prefix to names
! 	- some miscellaneous code cleanups and speedups
! 
! lib/readline/rldefs.h
! 	- define _POSIX_VDISABLE as _SVR4_VDISABLE if there is a define
! 	  for the latter and not the former [in 1.14.4]
! 	- moved defining _rl_stricmp and _rl_strnicmp as strcasecmp and
! 	  strncasecmp, respectively, here from bind.c, since the functions
! 	  are now defined in util.c and used in two files
! 
! builtins/common.c
! 	- removed the \n case in double_quote, so a backslash is not added
! 	  before an existing newline.  The \<newline> pair is removed by
! 	  the parser before anything else in the shell gets hold of it
! 	  except within single quotes [in 1.14.4]
! 
! 				   1/30
! 				   ----
! general.c
! 	- make sure the string index in canonicalize_pathname never goes
! 	  < 0 (it can, in some cases, result in `start' being -1, and `i'
! 	  being set to that) [in 1.14.4]
! 
! 				    2/1
! 				    ---
! execute_cmd.c
! 	- fix a typo in a call to `access' in AFS-specific code [in 1.14.4]
! 
! 				    2/3
! 				    ---
! builtins/shopt.def
! 	- finally added new `shopt' builtin
! 
! builtins/umask.def
! 	- converted to use builtin_getopt
! 
! bashhist.c
! 	- support for storing literal newlines in the history list when
! 	  command_oriented_history is enabled, rather than using semicolons
! 
! builtins/Makefile
! 	- changed rule to make a .o file from a .def file to remove the
! 	  .c file if the compilation fails
! 
! 				    2/6
! 				    ---
! bashhist.c
! 	- added new variable `force_append_history' that will force the
! 	  history list to be appended to the history file at shell exit
! 	- new function, maybe_append_history, to append any history lines
! 	  from the current session to the history file.  Used by history -a
! 
! builtins/bind.def
! 	- changed the `-d' option to -p
! 
! builtins/set.def
! 	- added `allenv' as a -o synonym for `set -k'.  Now all of the
! 	  single-letter shell options have -o equivalents
! 
! builtins/shopt.def
! 	- added -p option to display shell options, like other builtins
! 	- added `interactive_comments' as a shell option, like set -o
! 
! builtins/bind.def, builtins/history.def, builtins/enable.def
! 	- changed use of multiple variables to hold option flag settings to
! 	  one variable with bits representing flag values
! 
! documentation/bash.1, documentation/features.texi
! 	- changed the description of the `bind' builtin for the new -p option
! 	- changed the description of the `set' builtin for the new
! 	  `-o allenv' option
! 	- updated the description of the `shopt' builtin
! 
! builtins/history.def
! 	- changed -a option to use maybe_append_history
! 
! subst.c
! 	- changed the substring/subarray code to make negative offsets
! 	  count backwards from the end of the string or array
! 
! builtins/bashgetopt.c
! 	- added option modifiers `;' (argument is optional) and `#'
! 	  (argument is optional, but if present must be numeric)
! 
! builtins/hash.def
! 	- converted to use builtin_getopt
! 	- broke code out into a new function: add_hashed_command
! 
! 				    2/7
! 				    ---
! builtins/getopt.c
! 	- changed to save state to avoid relying on `nextchar' staying the
! 	  same across calls to sh_getopt [in 1.14.4]
! 	- added a function to restore `nextchar' from this saved state
! 	  [in 1.14.4]
! 	- removed some dead code
! 
! builtins/getopts.def
! 	- call function to restore sh_getopt state when parsing explicitly
! 	  supplied arguments rather than the positional parameters [in 1.14.4]
! 
! lib/readline/vi_mode.c
! 	- fixed an off-by-one error in _rl_vi_done_inserting that put the
! 	  \0 in vi_insert_buf at offset `len' instead of `len - 1'
! 
! lib/readline/complete.c
! 	- print_filename now filters out control characters and displays
! 	  them in printable format, rather than relying on the tty driver
! 	  to do the right thing [in 1.14.4]
! 
! 				    2/8
! 				    ---
! lib/posixheaders/stdc.h
! 	- test for each special keyword being defined individually, rather
! 	  than just testing on `const' [in 1.14.4]
! 
! lib/readline/util.c
! 	- new function _rl_abort_internal; rl_abort just calls this
! 
! nojobs.c
! 	- include error.h for extern function definitions [in 1.14.4]
! 
! builtins/ulimit.def
! 	- include <unistd.h> if HAVE_UNISTD_H is defined
! 	- use HAVE_LIMITS_H to decide whether or not to include <limits.h>
! 
! variables.c, subst.c, builtins/set.def
! 	- removed special handling of `noclobber' variable
! 
! builtins/set.def
! 	- new function set_shellopts to set up the $SHELLOPTS variable
! 	  based on the values of the set -o options; `set' calls this
! 	  function whenever one of the options is changed
! 	- new function parse_shellopts to take the value of SHELLOPTS and
! 	  turn on each option found therein
! 	- new function initialize_shell_options to parse any inherited
! 	  value of $SHELLOPTS and set up $SHELLOPTS
! 
! shell.c
! 	- call initialize_shell_options at the end of shell_initialize()
! 
! execute_cmd.c, general.c
! 	- moved extract_colon_unit from execute_cmd.c to general.c
! 
! execute_cmd.h, general.h
! 	- moved extern declaration of extract_colon_unit from
! 	  execute_cmd.h to general.h
! 
! documentation/{bash.1,features.texi}
! 	- documented SHELLOPTS
! 
! 				   2/18
! 				   ----
! builtins/{shopt,pushd,jobs,umask}.def
! 	- removed the `longjobs', `longdirs', `pushd_home' and `symbolic_umask'
! 	  options
! 
! lib/readline/{histexpand,histsearch,histfile}.c, lib/readline/histlib.h
! 	- new files, split off from old history library history.c
! 
! lib/readline/history.c, lib/readline/history.h
! 	- new function clear_history() to clear the history list
! 
! lib/readline/doc/hstech.texinfo
! 	- documented clear_history ()
! 
! builtins/pushd.def
! 	- new function clear_directory_stack() to delete all elements of
! 	  the dir stack
! 	- new -c option for `dirs' to clear directory stack
! 	- new function get_dirstack_index for dirs -N and dirs +N to use
! 	- new function get_dirstack_element(i, dir) for use by other parts of
! 	  the shell that want the functionality of dirs -N and dirs +N
! 	  (dir is 1 for dirs +N, -1 for dirs -N)
! 	- new function set_dirstack_element(i, dir, val) for use by other
! 	  parts of the shell to change values in the dirstack (dir is -1
! 	  for dirs -N, +1 for dirs +N).  Used when assigning to $DIRSTACK.
! 
! builtins/history.def
! 	- new -c option to clear the history list
! 
! documentation/bash.1, documentation/features.texi
! 	- removed no-longer-valid shopt options
! 	- documented new dirs -c option
! 	- documented new history -c option
! 	- documented new \T and \H prompt escape sequences
! 	- documented new $DIRSTACK dynamic array variable
! 	- documented the new expand-glob and list-glob readline commands
! 
! variables.c
! 	- set PS4 to its default value of `+ ', so that unsetting it will
! 	  disable the tracing characters [in 1.14.4]
! 	- new framework for dynamic array variables -- each place an
! 	  array index is assigned to, a test is made.  if a dynamic
! 	  assignment function exists, it is called with args `self',
! 	  the index being assigned to, and the new value
! 	- new variable `$DIRSTACK', a dynamic array variable that holds
! 	  the current contents of the directory stack.  You can even
! 	  change the stack by assigning to thie variable
! 
! shell.c
! 	- changed indirection_level_string to return the null string if
! 	  $PS4 is unset or null [in 1.14.4]
! 
! parse.y
! 	- new \H prompt escape for hostname up to first `.'; changed \h
! 	  to return full hostname (like \w/\W)
! 	- new \T prompt escape for 12-hour time
! 
! bashline.c
! 	- new readline functions to expand glob patterns and insert or
! 	  list the expansions (special completion functions)
! 
! 
! 				   2/20
! 				   ----
! builtins/pushd.def
! 	- new code for `pushd -n' and `popd -n' to inhibit cd when
! 	  adding or removing directories from the stack
! 	- broke functionality off into separate functions for use by the
! 	  $DIRSTACK manipulation functions
! 
! 				   2/21
! 				   ----
! lib/readline/kill.c
! 	- new functions to copy words to the kill ring, backward or
! 	  forward
! 
! lib/readline/readline.h
! 	- extern declarations for rl_copy_{backward,forward}_word
! 
! 
! lib/readline/funmap.c
! 	- new bindable readline commands: copy-backward-word and
! 	  copy-forward-word to copy portions of the line to the kill
! 	  ring without deleting them
! 
! documentation/{bash.1,readline.3}, lib/readline/doc/hsuser.texinfo
! 	- documented the new copy-backward-word and copy-forward-word
! 	  readline commands
! 
! mailcheck.c, config.h
! 	- the declaration of DEFAULT_MAIL_PATH is now only in config.h
! 	  and used by mailcheck.c and variables.c.  There is no need to
! 	  use DEFAULT_MAIL_PATH_LEN; `sizeof' does the job [in 1.14.4]
! 
! 				   2/22
! 				   ----
! support/mksysdefs
! 	- changes to fix `RELEASE' if it ends up being set to the empty string
! 	  [in 1.14.4]
! 	- check for amdahl UTS [in 1.14.4]
! 	- check for SGI Irix version 6.x [in 1.14.4]
! 
! machines.h
! 	- new entry for Amdahl UTS [in 1.14.4]
! 	- changes to the SGI entry for Irix 6.x [in 1.14.4]
! 
! 				   2/23
! 				   ----
! machines.h
! 	- changes for BSD/OS 2.0 (M_OS now set to `BSD_OS') [in 1.14.4]
! 
! support/mksysdefs
! 	- change to recognize BSD/OS 2.0 and set SYSDEF to BSDI2 [in 1.14.4]
! 
! siglist.h
! 	- don't declare sys_siglist on BSD/OS 2.0 [in 1.14.4]
! 
! 				   2/24
! 				   ----
! parse.y
! 	- if reset_parser is called while the prompt command is being
! 	  executed because of a syntax error in $PROMPT_COMMAND, an
! 	  infinite loop results.  set token_to_read back to 0 at the
! 	  end of execute_prompt_command to stop the looping [in 1.14.4]
! 
! 				   2/25
! 				   ----
! mailcheck.h
! 	- new header file for mail-checking and related definitions
! 	- declaration of DEFAULT_MAIL_PATH is now here
! 
! mailcheck.c
! 	- new function, make_default_mailpath, which constructs a default
! 	  $MAILPATH string from DEFAULT_MAIL_PATH [in 1.14.4]
! 	- change remember_mail_dates to call make_default_mailpath
! 	  [in 1.14.4]
! 
! externs.h
! 	- moved function declarations for functions in mailcheck.c to
! 	  mailcheck.h
! 
! variables.c
! 	- change initialize_shell_variables to call make_default_mailpath
! 	  [in 1.14.4]
! 	- removed some unneeded variables in initialize_shell_variables
! 
! 				   2/26
! 				   ----
! lib/readline/callback.c
! 	- new file with readline callback function interface
! 
! lib/readline/rlconf.h
! 	- new READLINE_CALLBACKS define for the readline callback code to
! 	  be compiled in and available
! 
! lib/readline/readline.c
! 	- broke readline_internal into three functions: readline_internal_setup,
! 	  readline_internal_charloop, and readline_internal_teardown
! 	- changes for READLINE_CALLBACKS
! 
! lib/readline/readline.h
! 	- extern declarations for the readline callback code
! 
! cpp-Makefile
! 	- added lib/readline/callback.c to the list of readline files
! 
! lib/readline/input.c
! 	- added a layer of indirection to allow the user to specify the
! 	  function that reads a character from rl_instream.  The variable
! 	  name is rl_getc_function, set by default to rl_getc
! 
! 				   2/27
! 				   ----
! lib/readline/display.c
! 	- added a variable rl_redisplay_function to allow an application-
! 	  specified redisplay function, for those apps that want to control
! 	  redisplay
! 
! lib/readline/readline.c
! 	- extern declarations for rl_getc_function and rl_redisplay_function
! 
! lib/readline/{readline,display,isearch,search,parens}.c
! 	- changed to call through rl_redisplay_function rather than
! 	  rl_redisplay directly
! 
! parse.y
! 	- try to avoid some work in reset_readline_prompt and prompt_again
! 	  if the prompt is the empty or null string [in 1.14.4]
! 
! lib/readline/readline.c
! 	- call rl_expand_prompt unconditionally [in 1.14.4]
! 
! lib/readline/display.c
! 	- short-circuit out of rl_expand_prompt if the prompt string is null
! 	  after clearing out the saved local prompt values.  This allows
! 	  $PS2 to be set to "" [in 1.14.4]
! 
! lib/readline/doc/rltech.texinfo
! 	- documented the callback code and functions
! 	- documented rl_getc_function and rl_redisplay_function
! 
! lib/readline/{callback,readline,rltty,signals}.c
! 	- added layer of indirction for terminal prep and deprep, with
! 	  rl_term_prep_function and rl_term_deprep_function.  These are
! 	  set by default to rl_prep_terminal and rl_deprep_terminal,
! 	  respectively
! 
! lib/readline/readline.h
! 	- make rl_term_prep_function and rl_term_deprep_function available
! 	  to callers
! 
! 				    3/1
! 				    ---
! lib/readline/complete.c
! 	- broke the (long, complicated) rl_complete_internal code into a
! 	  number of separate functions:
! 
! 		find_completion_word
! 		gen_completion_matches
! 		remove_duplicate_matches
! 		display_matches
! 		insert_text
! 		insert_match
! 		append_to_match
! 		insert_all_matches
! 
! 	- made some efficiency improvments to filename_completion_function
! 	- the completion ignore function is now called no matter what type
! 	  of completion is being performed (as it should have been all along)
! 
! lib/readline/rldefs.h
! 	- use #defines for the possible values ORed into `found_quote' by
! 	  the completion code
! 
! 				    3/2
! 				    ---
! make_cmd.c, general.c
! 	- moved make_word_array from make_cmd.c to general.c, renamed to
! 	  word_list_to_argv, extended it to optionally not malloc all of
! 	  the strings and to reserve space at the start of the array
! 
! execute_cmd.c
! 	- changed to use word_list_to_argv, not mallocing space for the
! 	  strings
! 
! builtins/common.c, builtins/common.h
! 	- new function make_builtin_argv, which uses word_list_to_argv
! 	  and reserves 1 slot at the beginning for the command name
! 
! builtins/exec.def
! 	- changed to use word_list_to_argv
! 
! builtins/{getopts,test}.def
! 	- changed to use make_builtin_argv
! 
! subst.c
! 	- new function match_pattern_char, to see if the first char of
! 	  a string has a chance to match a given pattern (test against
! 	  the first char of the pattern); used by match_pattern in the
! 	  MATCH_ANY case
! 
! 				    3/3
! 				    ---
! jobs.c
! 	- renamed flush_child to sigchld to capture the functionality better
! 
! array.c
! 	- new function array_pat_subst, to do pattern substitution on each
! 	  element in an array
! 
! array.h
! 	- extern declaration for array_pat_subst
! 
! subst.c
! 	- new function pat_subst to do pattern matching and substitution on
! 	  a string
! 	- new function parameter_brace_pat_subst to implement
! 	  ${v/[/]pat[/sub]}; calls pat_subst for simple vars,
! 	  pos_params_pat_subst to do substitution on the positional params,
! 	  and array_pat_subst for things like ${v[@]/p/r}
! 
! subst.h
! 	- extern declaration for pat_subst so array.c can find it
! 
! 				    3/6
! 				    ---
! parse.y
! 	- <>filename now dups filename to file descriptor 0 for both input
! 	  and output even when not in posix.2 mode
! 
! bashline.c
! 	- add the globbing characters to the list of characters that need
! 	  to be quoted by filename completion
! 
! jobs.h
! 	- new convenience macros:
! 		RUNNING, STOPPED, DEADJOB - to test a job's state
! 		IS_FOREGROUND, IS_NOTIFIED, IS_JOBCONTROL - flags
! 
! jobs.c, builtins/{kill,fg_bg}.def
! 	- changed to use new jobs.h macros
! 
! 				    3/7
! 				    ---
! array.c, array.h
! 	- new function dup_array_subrange(a, s, e) to make a new array
! 	  out of the elements of array A between S and E, inclusive
! 	- add `quoted' parameters to array_subrange and array_pat_subst
! 	  to preserve proper quoting of elements when expanding things
! 	  like "${av[@]/xx/yy}"
! 	- new function array_quote to quote the members of an array like
! 	  the functions in subst.c
! 
! subst.c
! 	- pass the quoted flag to array_subrange and array_pat_subst
! 	- quote_string is no longer static
! 
! subst.h
! 	- extern declaration for quote_string
! 
! builtins/hash.def
! 	- added a -p pathname option to specify a pathname for the command
! 	  name to be hashed.  With -p, no path search is performed.
! 
! lib/readline/histexpand.c
! 	- broke history_tokenize off into history_tokenize_internal and
! 	  added two arguments: a character index and a word index.  If
! 	  the char index is >= 0, the word index will be modified to point
! 	  into the returned array of strings to the word surrounding that
! 	  particular character index
! 	- new function history_find_word(line, ind) to return the word 
! 	  containing the character at index IND in LINE
! 	- new variable search_match, found by history_find_word, to hold the
! 	  word last matched by a !?string? search
! 	- corrected a problem with the `%' modifier: it should insert the
! 	  word last matched, not the last search string
! 
! 				    3/8
! 				    ---
! cpp-Makefile
! 	- changed INSTALL_PROGRAM and INSTALL_DATA to use support/install.sh
! 	- changed `install' target to not explicitly save the old version of
! 	  bash in `bash.old'; let install take care of it
! 
! shell.c
! 	- new static variable `running_under_emacs', set to 1 if the
! 	  variable `EMACS' is in the startup environment, and to 2 if
! 	  we're running under the `eterm' terminal emulator
! 	- send an escape sequence to eterm if running_under_emacs is 2
! 	  after executing any $PROMPT_COMMAND to tell it the current
! 	  directory
! 
! 				    3/9
! 				    ---
! builtins/ulimit.def
! 	- made getting -u work for systems that have a MAXUPRC define.
! 	  it still cannot be set without RLIMIT_NPROC
! 
! shell.c
! 	- include trap.h for sig definitions
! 
! builtins/common.h, subst.h, general.h, externs.h
! 	- more extern function declarations
! 
! bashhist.c
! 	- new function, bash_history_disable(), to turn off history and
! 	  history expansion
! 	- bash_history_disable now sets history_expansion_inhibited
! 
! bashline.h
! 	- new file with extern declarations from bashline.c
! 
! parse.y, bashhist.c, builtins/bind.def, subst.c, sig.c
! 	- include bashline.h
! 
! 				   3/10
! 				   ----
! lib/glob/glob.h
! 	- new file with extern declarations for local glob library
! 
! shell.c
! 	- include glob.h, mailcheck.h
! 
! cpp-Makefile
! 	- changes to dependencies due to mailcheck.h, bashline.h, glob.h
! 
! 				   3/13
! 				   ----
! execute_cmd.c
! 	- new function execute_connection to execute commands of type
! 	  cm_connection
! 	- new function execute_pipeline, to execute pipelines
! 
! lib/readline/rltty.c
! 	- add a `tty' argument to the set_winsize function/macro, the
! 	  non-shell version needs it
! 
! 				   3/14
! 				   ----
! parse.y
! 	- added \a (bell) and \e (escape) prompt string escape sequences
! 
! 				   3/16
! 				   ----
! lib/readline/display.c
! 	- fixed bug in update_line that caused stray characters to be left on
! 	  lines after the first if characters are deleted so that the first
! 	  line becomes exactly as long as the screen width [in 1.14.4]
! 
! lib/readline/doc-support
! 	- brought in the GNU getopt because texindex needs it
! 
! documentation/Makefile
! 	- adopted the BSD convention of a suffix of `.0' for formatted
! 	  manual pages
! 
! 				   3/17
! 				   ----
! support/inpath
! 	- a script to find out if a particular command name appears in
! 	  a directory in $PATH [in 1.14.4]
! 
! support/mksysdefs
! 	- changed to use inpath to find `ranlib' [in 1.14.4]
! 
! 				   3/18
! 				   ----
! bashline.c
! 	- include bashline.h
! 	- removed the DYNAMIC_HISTORY_COMPLETION define; that code is now
! 	  included unconditionally
! 	- renamed ETCHOSTS to DEFAULT_HOSTS_FILE; moved definition to
! 	  bashline.h
! 	- moved definition of BRACE_COMPLETION to config.h
! 
! config.h
! 	- conditional definition of BRACE_COMPLETION is now here
! 
! pathnames.h
! 	- new file with defines that are absolute pathnames
! 
! shell.h
! 	- include pathnames.h
! 
! mailcheck.h
! 	- def of DEFAULT_MAIL_PATH now moved to pathnames.h
! 
! shell.c
! 	- def of SYS_PROFILE moved to pathnames.h
! 
! alias.h
! 	- removed a bunch of extra definitions
! 
! lib/readline/{vi_mode.c,bind.c}
! 	- removed superfluous STATIC_MALLOC code
! 
! variables.c
! 	- removed SHADOWED_ENV code
! 
! 				   3/20
! 				   ----
! machines.h
! 	- don't define USG or USGr3 for linux machines [in 1.14.4]
! 	- change REVERSED_SETVBUF_ARGS to SETVBUF_REVERSED for autoconf
! 	  compatibility
! 
! shell.c
! 	- change REVERSED_SETVBUF_ARGS to SETVBUF_REVERSED for autoconf
! 	  compatibility
! 
! support/mksysdefs, maxpath.h
! 	- change HAVE_SYS_PARAM to HAVE_SYS_PARAM_H for autoconf
! 	  compatibility
! 
! support/mksysdefs, jobs.h
! 	- use HAVE_SYS_WAIT_H
! 
! machines.h, error.c
! 	- change HAVE_VFPRINTF to HAVE_VPRINTF for autoconf compatibility
! 
! test.c
! 	- replace UID_T and GID_T with GETGROUPS_T, the size of the elements
! 	  of the array returned by getgroups
! 
! general.c
! 	- define HAVE_KILLPG if killpg() is present; compile in a replacement
! 	  killpg if not
! 
! machines.h, jobs.c
! 	- change BSD_GETPGRP to HAVE_BSD_PGRP
! 
! sig.c
! 	- don't call initialize_siglist if HAVE_SYS_SIGLIST is defined, no
! 	  longer use INITIALIZE_SIGLIST
! 
! machines.h, lib/malloc/malloc.c
! 	- change NO_SBRK_DECL to SBRK_DECLARED
! 
! 				   3/22
! 				   ----
! machines.h
! 	- BSD/OS 2.0 does not need INT_GROUPS_ARRAY in SYSDEP_CFLAGS
! 
! lib/readline/rldefs.h
! 	- don't check `Linux'; just include <termcap.h> if HAVE_TERMCAP_H
! 	  is defined
! 
! builtins/command.def
! 	- changed get_standard_path to use HAVE_CONFSTR 
! 
! execute_cmd.c
! 	- execute_simple_command no longer uses alloca
! 	- don't check RISC6000 anymore when deciding whether to use
! 	  #pragma alloca
! 
! execute_cmd.c, shell.c
! 	- check for ultrix instead of Ultrix when calling alloca(0)
! 
! jobs.h
! 	- check HAVE_UNISTD_H to see whether to declare fork, getpid,
! 	  and getpgrp
! 
! builtins/common.c
! 	- include <signal.h> for NSIG
! 
! sig.h
! 	- don't define SIGABRT as SIGIOT unless SIGIOT is defined
! 
! jobs.c
! 	- check for ultrix instead of Ultrix
! 
! 				   3/23
! 				   ----
! general.c, general.h
! 	- new function check_dev_tty, which makes sure we can open
! 	  /dev/tty
! 
! shell.c
! 	- call check_dev_tty instead of having the code inline
! 
! posixstat.h
! 	- removed references to isc386
! 
! general.h
! 	- code to define one of TERMIOS_TTY_DRIVER, TERMIO_TTY_DRIVER,
! 	  or NEW_TTY_DRIVER
! 
! jobs.c, nojobs.c
! 	- use the general.h code to define the tty driver types
! 
! 				   3/24
! 				   ----
! builtins/declare.def
! 	- new -p option to display variables and their values and attributes
! 	  `declare -p xxx' displays attribs and value of var `xxx'
! 
! builtins/setattr.def
! 	- new function to display the attributes and value of a particular
! 	  variable; used by set_or_show_attributes
! 	- new function to look up a variable by name and show that name's
! 	  attributes and value
! 
! builtins/common.c
! 	- declarations for new functions in setattr.def
! 
! variables.c
! 	- don't set a default value for MAILPATH in initialize_shell_variables;
! 	  let remember_mail_dates take care of it [in 1.14.4]
! 
! mailcheck.c
! 	- fixed an off-by-one bug in make_default_mailpath [in 1.14.4]
! 
! 				   3/28
! 				   ----
! [changes for autoconf-generated config files]
! 
! lib/malloc/malloc.c
! 	- use HAVE_GETPAGESIZE, HAVE_BSD_SIGNALS, HAVE_POSIX_SIGNALS
! 
! trap.c
! 	- remove tests for USG and USGr4
! 	- test on HAVE_POSIX_SIGNALS rather than _POSIX_VERSION
! 	- use MUST_REINSTALL_SIGHANDLERS define to decide whether trap_handler
! 	  should call signal again
! 
! getcwd.c
! 	- redid the directory includes for autoconf compatibility
! 	- use HAVE_LSTAT instead of testing for S_ISLNK
! 	- use STRUCT_DIRENT_HAS_D_INO
! 	- include memalloc.h for alloca define
! 
! general.h
! 	- cleaned up strchr, strrchr definitions
! 	- removed tests against USG
! 	- use HAVE_MEMMOVE instead of MEMMOVE_MISSING
! 
! jobs.c
! 	- use HAVE_WAIT3, MUST_REINSTALL_SIGHANDLERS, GETPGRP_VOID
! 
! mailcheck.h
! 	- removed definition of DEFAULT_MAIL_DIRECTORY; now set by
! 	  autoconf in config.h
! 
! shell.c
! 	- remove checks on USG, just check for HAVE_GETPW_DECLS
! 	- use C_ALLOCA define
! 	- redid the isnetconn() code using HAVE_SYS_SOCKET_H,
! 	  HAVE_GETPEERNAME, SVR4 and SVR4_2
! 
! general.c
! 	- use HAVE_KILLPG, HAVE_RESTARTABLE_SYSCALLS, HAVE_UNAME,
! 	  ULIMIT_MAXFDS, HAVE_TIMEVAL, HAVE_TIMES
! 
! lib/readline/rldefs.h
! 	- redid the tty driver definitions using HAVE_TERMIOS_H, etc.
! 	- don't define anything having to do with signal type
! 
! lib/glob/glob.c
! 	- redid the DIRENT defines and includes
! 	- redid other includes to remove dependencies on USG and system
! 	  type (e.g., NeXT)
! 
! builtins/times.def
! 	- changed to use HAVE_GETRUSAGE, HAVE_TIMEVAL, HAVE_TIMES, and
! 	  the autoconf way to include <sys/time.h> and <time.h>
! 
! builtins/ulimit.def
! 	- changed to use HAVE_GETRLIMIT
! 	- removed test of USG being defined
! 
! siglist.h
! 	- changed to use SYS_SIGLIST_DECLARED, HAVE_UNDER_SYS_SIGLIST, and
! 	  HAVE_STRSIGNAL
! 
! print_cmd.c
! 	- use PRINTF_DECLARED
! 
! builtins/command.def
! 	- use HAVE_CONFSTR along with _CS_PATH to get the standard path
! 
! execute_cmd.c
! 	- only compile in execute_shell_script if HAVE_HASH_BANG_EXEC is not
! 	  defined
! 
! nojobs.c
! 	- use HAVE_SIGINTERRUPT, HAVE_KILLPG, HAVE_POSIX_SIGNALS,
! 	  MUST_REINSTALL_SIGHANDLERS, HAVE_WAITPID, *_TTY_DRIVER defines
! 
! test.c
! 	- set up a new `getmaxgroups' define, moving the code out of inline
! 	- eliminate use of GETGROUPS_T
! 
! variables.c
! 	- use CAN_REDEFINE_GETENV
! 
! sig.c, sig.h
! 	- use HAVE_POSIX_SIGNALS, MUST_REINSTALL_SIGHANDLERS
! 
! pathnames.h
! 	- removed the default mail directory defines; now set by autoconf
! 
! oslib.c
! 	- new file, functions from general.c that are unix-version variable
! 
! general.h
! 	- slightly changed function declarations for use by oslib.c
! 
! support/bashbug.sh
! 	- changed @xxx@ to !xxx! for sed substitutions to avoid conflicts
! 	  with autoconf substitutions in the Makefile
! 	- added MACHTYPE variable
! 
! mailcheck.c
! 	- changed DEFAULT_MAIL_PATH to DEFAULT_MAIL_DIRECTORY, since that
! 	  more clearly defines its function
! 
! lib/readline/rltty.h
! 	- new file, to include the correct tty driver #include file
! 
! lib/readline/rltty.c
! 	- include rltty.h
! 
! lib/malloc/malloc.c
! 	- make systems with Posix signals block all signals while malloc
! 	  is executing
! 
! 				   3/29
! 				   ----
! input.c
! 	- use off_t as the type of a seek offset, rather that int or long
! 
! variables.c, oslib.c
! 	- moved `getenv' from variables.c to oslib.c
! 
! 				   3/31
! 				   ----
! sig.c, sig.h
! 	- new function, jump_to_top_level, which just calls longjmp with
! 	  top_level as an argument -- here to isolate calls to longjmp
! 
! subst.c
! 	- replaced calls to longjmp with jump_to_top_level
! 
! bashjmp.h
! 	- new file with setjmp/longjmp defines and declarations
! 
! shell.h, nojobs.c
! 	- include bashjmp.h in place of setjmp.h
! 
! shell.c, sig.c, execute_cmd.c, unwind_prot.h, expr.c,
! builtins/{return,source}.def
! 	- change to use new defs in bashjmp.h
! 
! subst.c
! 	- make sure PAT and REP in pattern substitution are run through
! 	  expand_string_unsplit
! 
! builtins/set.def
! 	- don't try to blindly dereference the value returned by
! 	  find_flags in set_shellopts
! 
! 				    4/2
! 				    ---
! aclocal.m4, config.h.in, config.h.top, config.h.bot, configure.in,
! support/install.sh, support/config.guess, support/config.sub
! 	- new files for (now official) autoconf-based configuration
! 
! Makefile.in, builtins/Makefile.in,
! lib/{doc-support,malloc,glob,termcap,tilde,readline}/Makefile.in
! 	- new Makefiles for autoconf
! 
! [additionally, all source files now include config.h]
! 
! 				    4/3
! 				    ---
! array.c, array.h
! 	- index_t --> arrayind_t, because some systems define index_t in
! 	  <sys/types.h>
! 
! 				    4/4
! 				    ---
! aclocal.m4
! 	- fix test for broken dup2
! 
! lib/*/Makefile.in
! 	- make all object files depend on $(BUILD_DIR)/config.h
! 
! 				    4/5
! 				    ---
! array.c
! 	- fixed problems in empty_array: need to reset max_index
! 	  and max_size, and remove the links in the element chain
! 	  after freeing them
! 
! jobs.c
! 	- new functions to save an array of status values for each
! 	  foreground job that exits (degenerate case is to have a
! 	  single-process job exit and have a 1-element array)
! 	- new function to set a shell array variable `PIPESTATUS'
! 	  which holds the status values from each member of the
! 	  last-executed pipeline that spawned children
! 
! documentation/bash.1
! 	- documented $PIPESTATUS
! 
! 				    4/6
! 				    ---
! configure.in
! 	- added new --with-afs argument to #define AFS for execute_cmd.c
! 
! 				   4/10
! 				   ----
! builtins/ulimit.def
! 	- use sysconf(_SC_CHILD_MAX) to find the maximum number of child
! 	  proceeses per user if HAVE_SYSCONF and _SC_CHILD_MAX are both
! 	  defined and RLIMIT_NPROC is not
! 
! 				   4/12
! 				   ----
! lib/readline/undo.c
! 	- new variable, local to library, to keep track of the number of
! 	  `open' undo groups (UNDO_BEGIN without corresponding UNDO_END)
! 	- new function _rl_fix_last_undo_of_type to modify start and end
! 	  bounds of last undo record of a specified type
! 
! lib/readline/vi_mode.c
! 	- _rl_vi_done_inserting now calls rl_end_undo_group if the count
! 	  of unclosed groups is > 0
! 	- fixed rl_vi_change_to to save an undo record when redoing and
! 	  to fix the buffer corruption when doing `u' undo after a `.'
! 	  redo of `C'
! 
! 				   4/13
! 				   ----
! unwind_prot.h
! 	- changed to use a union { char *s; int i; } when unwind-protecting
! 	  integers to force correct alignment on machines where ints and
! 	  pointers differ in size
! 
! lib/readline/readline.c
! 	- new variable Keymap rl_executing_keymap, which is set to the
! 	  keymap the last function was invoked out of
! 
! lib/readline/bind.c
! 	- new variable Keymap rl_binding_keymap, which is set to the last
! 	  keymap a function and key sequence were bound in
! 
! 				   4/17
! 				   ----
! general.c
! 	- removed xmalloc, xrealloc, xfree to xmalloc.c
! 
! lib/malloc/Makefile.in
! 	- MALLOC and ALLOCA are both set by autoconf
! 	- need to provide some empty stub file to make up the library
! 	  in case neither malloc.c and alloca.c are compiled into the
! 	  shell
! 
! lib/malloc/gmalloc.c
! 	- new file, GNU libc malloc code
! 
! Makefile.in
! 	- new source file, xmalloc.c, new object file, xmalloc.o
! 
! general.h
! 	- changed type of size argument to xmalloc, xrealloc to `size_t'
! 
! configure.in
! 	- changes for new argument `--with-glibc-malloc' that includes
! 	  gmalloc.o in libmalloc.a
! 
! 				   4/18
! 				   ----
! xmalloc.c
! 	- if malloc or realloc return null, report in the error message
! 	  how many bytes have been allocated
! 
! lib/readline/display.c
! 	- changed redisplay code to use an array of positions in the visible
! 	  and invisible lines at which to break lines instead of simply
! 	  calculating based on the screenwidth and number of invisible
! 	  characters.  In the future, this will allow newlines embedded in
! 	  the lines to display to be handled better
! 
! [Bash-1.14.4 released to net]
! 
! 				   4/19
! 				   ----
! lib/readline/signals.c
! 	- changed last call to signal() to call rl_set_sighandler()
! 
! 				   4/20
! 				   ----
! lib/readline/display.c
! 	- changed some ascii-specific code to use CTRL_CHAR and UNCTRL
! 	- finished up the changes that keep an array of line breaks
! 
! shell.h
! 	- moved #define constants for parameter pattern substitution here
! 	  from subst.c
! 
! subst.c
! 	- changed the pattern substitution functions to take a `flags'
! 	  parameter, which subsumes the match type, global replacement
! 	  flag, and quoted variables
! 	- changed the pattern substitution functions to handle the `#'
! 	  and `%' match qualifiers, which anchor the match at the
! 	  beginning and end of the string, respectively
! 
! shell.c
! 	- moved the code that turns off privileged mode into a function
! 	  named `disable_priv_mode'
! 	- if the shell is running setuid or setgid and `-p' is not
! 	  supplied, turn off privileged mode and reset the effective
! 	  uid/gid
! 
! 				   4/21
! 				   ----
! subst.c
! 	- added a `quoted' paramter to parameter_brace_remove_pattern;
! 	  Posix.2 says that the pattern is parsed differently if the
! 	  entire expression is double-quoted
! 	- `getpattern' now takes a second argument, `quoted'
! 	- fixed `getpattern' to correctly handles a pattern spec when
! 	  the whole expression is double-quoted.  Posix.2 says that
! 	  quote characters inside the pattern spec don't quote any
! 	  special pattern chars if the whole thing is double-quoted.
! 	  For example, the `*' in "${foo#'*'}" is not quoted, and the
! 	  single quotes must appear literally.
! 
! Makefile.in
! 	- add `documentation' as a dependency of `.made'
! 
! 				   4/24
! 				   ----
! Makefile.in
! 	- added `installdirs' target that makes bindir, infodir, mandir,
! 	  and man3dir [in 1.14.5 cpp-Makefile]
! 
! 				   4/25
! 				   ----
! builtins/fc.def
! 	- fixed problem with `fc -l' that occurred when fewer than 16 lines
! 	  were in the history list [in 1.14.5]
! 
! 				    5/1
! 				    ---
! Makefile.in, {builtins,documentation}/Makefile.in, lib/*/Makefile.in
! 	- fixed up the various `clean' targets to agree with Gnu coding
! 	  standards
! 
! 				    5/2
! 				    ---
! lib/readline/complete.c
! 	- made insert_all_matches correctly quote each of the filenames
! 	  inserted into the line, if necessary
! 
! config.h.top
! 	- surround definitions of DEFAULT_PATH_VALUE and STANDARD_UTILS_PATH
! 	  with #ifndef/#endif to allow them to be overridden from the command
! 	  line
! 
! builtins/set.def
! 	- changed set -o allenv to set -o keyword for ksh88 compatibility
! 
! documentation/{bash.1,features.texi}
! 	- changed set -o allenv to set -o keyword
! 
! builtins/setattr.def
! 	- added a `nodefs' attribute to set_or_show_attributes,
! 	  show_var_attributes, and show_name_attributes to inhibit printing
! 	  of definition as well as name
! 
! builtins/declare.def
! 	- changed calls to set_or_show_attributes, and show_var_attributes
! 	  accordingly
! 
! 				    5/3
! 				    ---
! Makefile.in
! 	- LIBPATH -> LIBSUBDIR
! 
! 				    5/4
! 				    ---
! lib/readline/bind.c
! 	- renamed readline variable meta-flag to be input-meta
! 
! documentation/bash.1, lib/readline/doc/rluser.texinfo
! 	- changed meta-flag to input-meta
! 
! documentation/Makefile.in
! 	- use groff -Tascii to convert .1 -> .0
! 
! subst.c
! 	- new function, strip_trailing_ifs_whitespace, does the obvious
! 
! builtins/read.def
! 	- call strip_trailing_ifs_whitespace before assigning last
! 	  variable to remainder of input string [in 1.14.5]
! 
! 				    5/5
! 				    ---
! builtins/hashcom.h
! 	- changed check_dot member of the PATH_DATA struct to flags, and
! 	  added a HASH_CHKDOT define to replace the check_dot semantics
! 	- add HASH_RELPATH define for flags value
! 
! builtins/hash.def, builtins/common.c
! 	- instead of xxx->check_dot, use (xxx->flags & HASH_CHKDOT)
! 
! builtins/hash.def
! 	- if the full pathname to which a command is being hashed does
! 	  not begin with a `/', set the HASH_RELPATH flag for it
! 
! builtins/common.c
! 	- if a hashed filename as HASH_RELPATH set, check ./filename,
! 	  returning null if that filename is not executable
! 
! execute_cmd.c, general.c, execute_cmd.h, general.h
! 	- moved same_file and check_binary_file from execute_cmd.c to
! 	  general.c
! 
! hashlib.c, Makefile.in
! 	- renamed hash.c to hashlib.c
! 
! hashlib.h, Makefile.in, builtins/Makefile.in, alias.h, variables.h,
! execute_cmd.c, hashlib.c, builtins/hashcom.h
! 	- renamed hash.h to hashlib.h
! 
! variables.c, alias.c
! 	- removed inclusion of `hash.h'; header files already include
! 	  correct file
! 
! Makefile.in
! 	- new rule to remake all the Makefiles (`make Makefiles')
! 	- more changes to adhere to GNU coding standards for the various
! 	  flavors of `clean' targets
! 
! 				    5/8
! 				    ---
! documentation/Makefile.in
! 	- use `texi2dvi' to make dvi files rather than tex and texindex
! 	  [in 1.14.5]
! 	- don't install `bash_builtins.1' [in 1.14.5]
! 
! Makefile.in
! 	- removed instances of doc-support/texindex
! 
! 				    5/9
! 				    ---
! make_cmd.c
! 	- new function make_bare_word, to make a WORD_DESC from a string but
! 	  not to set any of its flags
! 	- broke make_word into make_bare_word and make_word_flags
! 	- fixed a bug in make_word_flags to make backslash-quoting a quoting
! 	  character work right to not set the W_QUOTED flags
! 
! subst.c, array.c, execute_cmd.c
! 	- call make_bare_word instead of make_word in situations where we
! 	  don't want the flags set inadvertently
! 
! 				   5/11
! 				   ----
! subst.c
! 	- removed special handling of $POSIX_PEDANTIC
! 
! 				   5/12
! 				   ----
! shell.c
! 	- broke the code that fetches the uids and gids into a new
! 	  function, uidget()
! 
! subst.c
! 	- EUID and UID are no longer handled specially, since they're
! 	  readonly
! 	- removed sv_uids function
! 	- merge sv_histfilesize into sv_histsize
! 
! variables.c
! 	- instead of calling sv_uids from initialize_shell_variables,
! 	  call uidset() instead
! 	- sv_uids -> uidset with mods to make it faster and avoid an
! 	  extra call to free, malloc, and itos
! 
! bashhist.c
! 	- call sv_histsize instead of sv_histfilesize
! 
! 				   5/13
! 				   ----
! pathexp.c
! 	- moved setup_ignore_patterns here from bashline.c, so GLOBIGNORE
! 	  works even when readline is compiled out of the shell
! 	- changed the ignore data structure to a `struct ignorevar',
! 	  defined in pathexp.h
! 	- added functions to implement GLOBIGNORE
! 
! bashline.c
! 	- setup_ignore_patterns now in pathexp.c
! 	- renamed _ignore_names to ignore_completion_names
! 
! subst.c
! 	- new function sv_globignore to be called when GLOBIGNORE changes
! 	  value
! 
! documentation/{bash.1,features.texi}
! 	- documented GLOBIGNORE
! 
! 				   5/15
! 				   ----
! documentation/texinfo.tex
! 	- upgraded to version 2.145 from autoconf-2.3 distribution
! 
! 				   5/16
! 				   ----
! lib/readline/display.c
! 	- delicate surgery on rl_redisplay, update_line, and _rl_update_final
! 	  to convert to using the line breaks array instead of assuming that
! 	  lines wrap because they're too long and using absolute buffer
! 	  positioning calculated from the screen width.  Now the `lithist'
! 	  shopt option works right
! 
! lib/readline/complete.c
! 	- make sure insert_match doesn't double an opening quote character
! 	  after make_quoted_replacement adds an opening quote [in 1.14.5]
! 	- make sure append_match doesn't double a closing quote character
! 	  [in 1.14.5]
! 
! quit.h
! 	- new macros: SETINTERRUPT, CLRINTERRUPT, ADDINTERRUPT, DELINTERRUPT
! 	  to manipulate the value of interrupt_state
! 
! trap.c, sig.c, jobs.c
! 	- changes to use the new macros from quit.h
! 
! jobs.c
! 	- make an a job that exits due to SIGINT make the shell act as if
! 	  it received the interrupt itself, but only if SIGINT is not
! 	  trapped [in 1.14.5]
! 
! 				   5/18
! 				   ----
! builtins/common.c
! 	- fix up find_hashed_filename and the HASH_RELPATH code.  still need
! 	  to use `shopt -s checkhash' to check the hashed pathnames.  could
! 	  fix this up more to make that unnecessary in the HASH_RELPATH case
! 
! subst.c
! 	- new function get_array_value that does array subscripting for
! 	  things like aa[1], for use by other parts of the shell like the
! 	  expression evaluator
! 
! expr.c
! 	- changes to make things like $(( aa[1] + aa[2])) work without
! 	  using ${aa[1]}
! 
! bashhist.c
! 	- converted the HISTIGNORE code to use the `struct ignorevar'
! 	  framework, with a callback function histignore_item_func to
! 	  set the HIGN_EXPAND flag if needed
! 
! pathexp.c
! 	- made the `globignore' variable static
! 	- redid the code that removes ignored names from the `names' array
! 	  in ignore_globbed_names to make it more efficient
! 
! bashline.c
! 	- made the `fignore' variable static
! 
! 				   5/20
! 				   ----
! Makefile.in
! 	- made the `distclean' target remove the Makefiles in subdirectories
! 	  created by autoconf
! 
! 				   5/22
! 				   ----
! builtins/command.def
! 	- don't allow `command -p' if the shell is restricted
! 
! documentation/bash.1
! 	- documented the restriction on command -p for rbash
! 
! 				   5/23
! 				   ----
! aclocal.m4
! 	- add a new macro BASH_CHECK_TYPE, based on AC_CHECK_TYPE, that
! 	  allows the caller to specify the header files to be included
! 	  in the test program and provides for a default value to be
! 	  defined if the type is found in the system files
! 
! configure.in
! 	- check for getrusage and gettimeofday functions/syscalls
! 	- use BASH_CHECK_TYPE to check for clock_t in sys/types.h and
! 	  sys/times.h
! 	- use BASH_CHECK_TYPE to check for sigset_t instead of a special
! 	  BASH_TYPE_SIGSET_T
! 	- use BASH_CHECK_TYPE to check for quad_t instead of BASH_QUAD_T
! 	- new argument --enable-command-timing to compile in the `time'
! 	  reserved word and command timing
! 
! general.c
! 	- print_time_in_hz takes a `clock_t', not a `time_t'
! 
! execute_cmd.c
! 	- support for timing pipelines with a new function time_command
! 	- execute_command_internal calls time_command if it is passed a
! 	  command with the CMD_TIME_PIPELINE bit set in command->flags
! 	- new functions difftimeval and addtimeval to do arithmetic on
! 	  timeval structs with overflow
! 
! parse.y
! 	- new production: pipeline_command, used by list1 and simple_list1
! 	- pipeline_command includes rules to handle `!' and time
! 	- code to recognize `time' as a reserved word
! 
! print_cmd.c
! 	- new code to print `time ' before a command if the CMD_TIME_PIPELINE
! 	  flag bit is turned on
! 
! builtins/test.def
! 	- added description of string1 < string2 and string1 > string2 to
! 	  the long doc
! 
! test.c
! 	- added `<' and `>' string binary operators
! 
! documentation/bash.1
! 	- documented the `time' reserved word and command timing
! 	- documented the new test `<' and `>' binary operators
! 
! documentation/features.texi
! 	- documented the `time' reserved word and command timing
! 	- added more to the section detailing the differences between bash
! 	  and sh
! 	- added descriptions of LINENO and ENV to the Ksh variables section
! 	- added description of echo to bash builtins section
! 	- added PPID, BASH, SHLVL to the Bash variables section
! 
! subst.c
! 	- added a `quoted' parameter to extract_dollar_brace_string; changed
! 	  all calls to it
! 
! 				   5/24
! 				   ----
! builtins/let.def
! 	- wrote code for an `exp' builtin that treats all of its arguments
! 	  as an expression, concatenates them like `eval', and runs the
! 	  expression evaluator
! 
! expr.c
! 	- added code to do the Posix.2 conditional operator: expr?expr:expr
! 	- added a `noeval' flag to suppress evaluation.  currently it only
! 	  suppresses assignment
! 	- added code to the && and || functions so that evaluation is
! 	  suppressed in the part of the statement that is not supposed to
! 	  be executed (a && b: set noeval if a is false; a || b; set
! 	  noeval if a is true)
! 
! 				   5/25
! 				   ----
! documentation/{bash.1,features.texi}
! 	- documented new `expr?expr:expr' conditional expression syntax
! 	  now arithmetic evaluation is Posix.2-conformant
! 
! lib/readline/readline.c
! 	- added several more locale names to the list of legal $LANG
! 	  values
! 
! subst.c
! 	- fixed a bug in parameter_brace_patsub: when replacing a string 
! 	  with nothing, rep was set to "", and the code attempted to
! 	  free "", which the GNU malloc upchucked on
! 
! bashhist.c
! 	- just add a line to the history if command_oriented_history is
! 	  set to 1 and the current line in the command is > 1; don't
! 	  even bother checking history_ignore
! 
! parse.y
! 	- new variable `two_tokens_ago' to remember the token read before
! 	  `token_before_that'
! 	- fix to history_delimiting_chars to make sure that no semicolon
! 	  is added after `()' (assume its a function definition), but that
! 	  a semicolon is added after other `)' (assume its a parenthesized
! 	  command)
! 
! 				   5/31
! 				   ----
! tests/run-all
! 	- put `.' first in $PATH and don't export ENV
! 	- set THIS_SH to ../bash if it's unset
! 
! lib/readline/complete.c
! 	- only try to find a word break character in rl_complete_internal
! 	  if we hit the end of the input string and found_quote == 0
! 	  (the opening quote could have been the last character in the
! 	  string)
! 
! 				    6/2
! 				    ---
! subst.c
! 	- changed make_quoted_char to return CTLNUL\0 if passed a \0
! 	  (this is what quote_string does, too) [in 1.14.5]
! 	- changed list_string to use make_quoted_char when adding a quoted
! 	  null argument due to a null field when ifs != ' \t\n'
! 	- added an `expandpat' argument to getpattern, which tells it to
! 	  call string_extract_double_quoted if the pattern expression is
! 	  double-quoted, and changed all calls to initially pass `1' as
! 	  its value
! 
! jobs.c
! 	- changed start_job so that an attempt to start a job marked as
! 	  JDEAD elicits an error message [in 1.14.5]
! 
! Makefile.in
! 	- fixed `distclean' target so that it removes Makefiles in subdirs
! 	  *after* descending into them to do submakes (!)
! 	- fixed `realclean' target to remove everything that distclean does
! 
! 				    6/5
! 				    ---
! builtins/declare.def
! 	- fixed a typo that made `declare +r var' turn off read-only status
! 	  for a variable [in 1.14.5]
! 	- added -p option to short doc and long doc
! 	- added code to allow `declare -f -options name' to set and unset
! 	  attributes for the named functions.  Only when no other options
! 	  are supplied will the named and value of the function be displayed
! 	  [in 1.14.5]
! 
! variables.h
! 	- new SETVARATTR macro to set or unset attributes for a specific
! 	  SHELL_VAR *
! 
! builtins/setattr.def
! 	- use SETVARATTR
! 
! 				    6/7
! 				    ---
! execute_cmd.c
! 	- moved the retrieval of $PS3 inside the loop in execute_select_command
! 	  so that PS3 can be modified in the select command's body
! 	  [in 1.14.5]
! 
! execute_cmd.c
! 	- changed execute_builtin and execute_function to not set
! 	  builtin_env and function_env, respectively, to NULL if there is
! 	  no temporary env.  This makes the temp env persist across calls
! 	  to functions from other functions [in 1.14.5]
! 
! configure.in
! 	- Linux needs LOCAL_LDFLAGS set to -rdynamic
! 
! 				    6/8
! 				    ---
! general.c
! 	- canonicalize_pathname should not attempt to interpret backslash
! 	  quoting `/', since Unix doesn't really allow it [in 1.14.5]
! 
! bashline.c
! 	- added `\', `!', and `)' to the list of characters which
! 	  cause filenames to be quoted
! 	- changed bash_quote_filename to use any of the three shell
! 	  quoting styles based on the value of a variable,
! 	  completion_quoting_style
! 	- if *qcp is not 0 when passed to bash_quote_filename, adjust the
! 	  type of completion we're doing based on its value (i.e.,
! 	  *qcp == '"' forces double quoting, *qcp == '\'' forces single)
! 	- bash_quote_filename now leaves the quotes intact in the filename
! 	  it returns.  The readline completion code takes care of avoiding
! 	  doubled open quotes
! 	- if a filename containing a `!' is passed to bash_quote_filename
! 	  without an opening quote character, and we are performing history
! 	  expansion, use single quoting as the quoting style
! 
! bashhist.c
! 	- changed bash_history_disable to not call bash_history_reinit(0),
! 	  but do what it needs to directly
! 	- new function bash_history_enable
! 	- make history_expansion_inhibited exist only if BANG_HISTORY
! 	  is defined
! 
! bashhist.h
! 	- extern declaration for bash_history_enable
! 
! lib/readline/complete.c
! 	- make make_quoted_replacement set should_quote to 1 if the quote
! 	  character is `'' as well as if it's `"'
! 
! test.c
! 	- added the csh-like `=~' and `!~' pattern-matching binary operators
! 	  which match the string on the lhs against the shell pattern on
! 	  the rhs.  PATTERN_MATCHING must be defined for this to work; it is
! 	  undefined and undocumented by default
! 
! jobs.c
! 	- broke the code that gets the new window size and sets $LINES and
! 	  $COLUMNS out of sigwinch_sighandler into a new function,
! 	  get_window_size, which sigwinch_sighandler calls
! 
! 				   6/12
! 				   ----
! parse.y
! 	- new function, pop_expansion, to remove the top string on the
! 	  expanded token stack
! 	- renamed save_expansion to push_expansion
! 
! lib/readline/complete.c
! 	- fixed a bug in find_completion_word that tested found_quote
! 	  instead of quote_char when trying to decide if we have an unclosed
! 	  quoted string [in 1.14.6]
! 
! 				   6/26
! 				   ----
! subst.c
! 	- fixed expand_word_internal to remove all traces of $*, even if
! 	  it's quoted, if there are no positional parameters and there are
! 	  other characters in the expansion
! 
! bashline.c
! 	- don't attempt hostname completion if multiple consecutive `@'
! 	  characters appear
! 
! 				   6/27
! 				   ----
! shell.c
! 	- initialize top_level early, and exit if a longjmp sends us there
! 	  before we reinitialize
! 
! subst.c
! 	- more fixes to expansion of quoted $* when no positional parameters
! 	- broke the code that assigns a value to an array element (and parses
! 	  the array element reference) into a new function,
! 	  do_array_element_assignment
! 
! builtins/read.def
! 	- new function, bind_read_variable, to allow binding simple variables
! 	  and array elements to strings read (uses do_array_element_assignment)
! 	- changed occurrences of bind_variable to bind_read_variable where
! 	  it matters
! 
! variables.c
! 	- tentative change to bind_variable to make x=y the same as x[0]=y
! 	  if x is already an array variable.  This works for `read' as well.
! 	  This is what ksh does.
! 
! 				   6/28
! 				   ----
! alias.h
! 	- added a `flags' member to the ASSOC struct and renamed it to
! 	  `alias_t'
! 
! alias.c, bashline.c, builtins/alias.def, builtins/type.def
! 	- changed ASSOC to alias_t
! 
! alias.c
! 	- changed add_alias to set the AL_EXPANDNEXT flag when the alias is
! 	  inserted into the hash table
! 
! parse.y
! 	- added a third parameter to push_string: a pointer to the alias_t
! 	  that is being expanded
! 	- push_string marks the alias it's passed as being expanded
! 	  (AL_BEINGEXPANDED)
! 	- pop_string marks the alias being popped as no longer being
! 	  expanded
! 	- changed shell_getc to defer popping an alias expansion until
! 	  the parser has had a chance to catch up, since the parser reads
! 	  ahead and would cause the expansion to be popped before it
! 	  fully parsed the expanded string
! 	- changed alias_expand_word to check the AL_BEINGEXPANDED flag
! 	  instead of the expanded_token_stack when checking whether an
! 	  alias is already being expanded
! 
! oslib.c
! 	- make the definition of bzero be surrounded by #ifdef HAVE_BZERO
! 	  rather than lumping it in with bcopy
! 
! configure.in
! 	- add a test for bzero
! 
! config.h.in
! 	- add a template for HAVE_BZERO
! 
! 				    7/3
! 				    ---
! builtins/set.def
! 	- added new meaning for `set +o' without options, as per the latest
! 	  draft of Posix.2.  It means to list -o options as a series of set
! 	  commands to recreate the current settings
! 
! documentation/bash.1
! 	- augmented description of the `set' builtin
! 
! 				    7/6
! 				    ---
! jobs.c
! 	- make sure that temp_handler is not set to SIG_DFL before calling
! 	  it from waitchld
! 
! builtins/cd.def
! 	- rewrote cd_builtin to make the code flow clearer
! 	- broke full directory name construction out into a separate
! 	  function: mkpath
! 	- cd_builtin now tests that a directory constructed from a $CDPATH
! 	  entry is actually a directory before trying to chdir to it
! 	- added an error message if $HOME is not set
! 	- added a descriptive error message if `cd -' used and OLDPWD unset
! 	- changed the error messages to use builtin_error, not file_error
! 	- moved the code at the bind_and_exit label into a function,
! 	  bindpwd (no_symlinks)
! 	- Posix.2 says that when using $CDPATH, the resultant value of PWD
! 	  should have no symlinks
! 
! 				    7/7
! 				    ---
! input.c
! 	- if fd_to_buffered_stream fails in some way and returns a NULL
! 	  buffered stream, with_input_from_buffered_stream uses a function
! 	  that does nothing but return EOF as the `getter'.  This keeps
! 	  the shell from crashing if invoked with fd 0 closed
! 
! subst.c
! 	- made the `quoted' parameter to expand_word_internal into a flags
! 	  word with flag values defined in shell.h.  Each place where
! 	  `quoted' is tested for a non-zero value was changed to test
! 	  (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) != 0 instead
! 
! mailcheck.c, shell.c, parse.y
! 	- change calls to the expand_string* functions to pass an explicit
! 	  Q_DOUBLE_QUOTES where appropriate
! 
! 				    7/9
! 				    ---
! subst.c
! 	- getpattern now passes Q_NOQUOTE to expand_word_internal, indicating
! 	  that quotes in the pattern spec are not to be treated specially
! 
! 				   7/12
! 				   ----
! jobs.c
! 	- fixed up the MUST_UNBLOCK_CHILD code in wait_for so that it now
! 	  unblocks all signals and sets the signal handler for SIGCHLD to
! 	  SIG_DFL.  pre-v4 SCO machines seem to require this [in 1.14.5]
! 
! [Bash-1.14.5 released to net 7/16]
! 
! 				   7/17
! 				   ----
! documentation/features.texi
! 	- changed the Bourne Shell builtins section to have the same format
! 	  as the bash builtins section, with usage synopses
! 	- added a section on the restricted shell
! 
! 				   7/18
! 				   ----
! documentation/features.texi
! 	- changed the name of this document to the Bash Reference Manual
! 	- added sections on POSIX mode and restricted shell
! 
! lib/readline/doc/hsuser.texinfo
! 	- added the text from the bash manual page about the bash history
! 	  facilities if BashFeatures is set
! 
! 				   7/19
! 				   ----
! documentation/features.texi
! 	- added more stuff to the bash basics section
! 
! lib/readline/doc/rluser.texinfo
! 	- added a sample inputrc file
! 
! 				   7/20
! 				   ----
! documentation/features.texi
! 	- added section on shell expansions to bash basics section
! 
! builtins/Makefile.in, lib/glob/Makefile.in, lib/malloc/Makefile.in,
! lib/readline/Makefile.in, lib/termcap/Makefile.in, lib/tilde/Makefile.in
! 	- ar is now called with flags `cr' when building libraries
! 
! 				   7/21
! 				   ----
! lib/readline/complete.c
! 	- fixed a bug in find_completion_word that resulted in the found_quote
! 	  flag and the delimiter character not being passed back to the
! 	  caller (tested (*fp) instead of (fp) before assigning found_quote;
! 	  similarly for dp).  With this fix, the filename dequoting function
! 	  is properly called
! 
! 				   7/25
! 				   ----
! general.c
! 	- renamed bash_tilde_expand to bash_tilde_expansion_failure_hook
! 	- new function, bash_tilde_expand, that just sets interrupt_immediately
! 	  and calls tilde_expand, returning what tilde_expand returns
! 
! subst.c, general.c, shell.c, execute_cmd.c, variables.c, bashline.c,
! builtins/cd.def
! 	- changed calls to tilde_expand to calls to bash_tilde_expand instead
! 
! 				   7/27
! 				   ----
! builtins/set.def
! 	- added a -o history option to enable and disable command history
! 	  saving.  This uses bash_history_enable() and bash_history_disable()
! 	  It's keyed off of remember_on_history.  With this, shell scripts 
! 	  can use the command history
! 
! bashhist.c
! 	- bash_history_enable now calls sv_history_control and sv_histignore
! 
! builtins/fc.def
! 	- if history_list() returns a null pointer, immediately return
! 	  [in 1.14.6]
! 
! documentation/{bash.1,features.texi}, lib/readline/doc/hsuser.texinfo
! 	- added a description of the `set -o history' option and changed
! 	  text to refer to it rather than strictly interactive shells
! 
! 				    8/1
! 				    ---
! variables.c
! 	- new builtin variable $HOSTNAME, initialized to current_host_name
! 	  as set in shell.c
! 
! documentation/bash.1, documentation/features.texi
! 	- documented $HOSTNAME
! 
! 				    8/3
! 				    ---
! support/texi2html
! 	- new program, a texinfo-html converter
! 
! documentation/Makefile.in
! 	- added directives to produce features.html from features.texi
! 
! MANIFEST.doc
! 	- added features.html and features_toc.html to the doc distribution
! 
! 				   8/10
! 				   ----
! lib/readline/bind.c
! 	- new functions rl_variable_dumper and rl_dump_variables to print
! 	  readline variables and their values to rl_outstream
! 	- new functions rl_get_keymap_name and rl_get_keymap_name_from_edit_mode
! 	  to get the name of the current keymap for the variable dumper
! 
! lib/readline/readline.h
! 	- extern declarations for rl_variable_dumper, rl_dump_variables, and
! 	  rl_get_keymap_name
! 
! builtins/bind.def
! 	- added -V flag to print variable names and bindings
! 	- added -P flag to print variable names and bindings in the syntax
! 	  of the inputrc file
! 
! lib/readline/funmap.c
! 	- added new bindable `dump-variables' readline command
! 
! documentation/{bash.{1,html},readline.3,features.html},
! lib/readline/doc/rluser.texinfo
! 	- documented new `dump-variables' readline command
! 
! documentation/{bash.{1,html},features.{texi,html}
! 	- documented new bind -P and -V options
! 
! documentation/bashbug.1
! 	- new manual page
! 
! documentation/Makefile.in
! 	- changes to build and install bashbug.1
! 
! 				   8/15
! 				   ----
! print_cmd.c
! 	- new function `xprintf' that just calls vfprintf(stdout, ...)
! 	  to avoid having to declare printf
! 
! parse.y
! 	- slight change in how read_token_word computes `all_digits'
! 
! 				   8/21
! 				   ----
! 
! subst.c
! 	- new function dequote_escapes to remove CTLESC escaping
! 	  CTLESC and CTLNUL in a string, returning a new string
! 
! 				   8/25
! 				   ----
! shell.c
! 	- execute the file SYS_BASHRC for interactive shells if SYS_BASHRC
! 	  is defined, before executing ~/.bashrc
! 
! config.h.top
! 	- add a dummy commented definition for SYS_BASHRC, defaulting to
! 	  /etc/bash.bashrc
! 
! lib/readline/input.c
! 	- added code to call select() in rl_gather_tyi() and return
! 	  immediately if it indicates that there is nothing to read on
! 	  the readline input fd (#ifdef HAVE_SELECT)
! 
! lib/posixheaders/posixdir.h
! 	- new file to localize the <dirent.h>/<sys/dir.h> and dirent/direct
! 	  mess
! 
! posixdir.h, lib/readline/posixdir.h
! 	- symlinks to lib/posixheaders/posixdir.h
! 
! lib/readline/rldefs.h
! 	- removed the posix dir includes and defines
! 
! lib/readline/complete.c, getcwd.c
! 	- include posixdir.h rather than having the code inline
! 
! builtins/cd.def
! 	- new code to do spelling correction on the directory name
! 	  modified from patch sent by Neil Russell (caret@c-side.com)
! 
! 				   8/29
! 				   ----
! builtins/shopt.def
! 	- new option `cdspell' to toggle cd directory name spelling
! 	  correction
! 
! documentation/{bash.{1,html},features.texi}
! 	- documented new shopt `cdspell' option
! 
! 				    9/5
! 				    ---
! subst.c
! 	- $'' should expand to the same thing as '' (a quoted null string)
! 
! shell.h
! 	- changed CTLNUL to '\177'; some scripts use ^B for things like IFS
! 	  [in 1.14.6]
! 
! 				    9/7
! 				    ---
! support/config.guess
! 	- added code to identify a PPC running Solaris 2
! 
! doc
! 	- new directory replacing documentation
! 
! Makefile.in, MANIFEST, MANIFEST.doc, configure.in
! 	- replaced `documentation' with `doc'
! 
! 				    9/8
! 				    ---
! lib/readline/display.c
! 	- fixed the code in _rl_update_final that decides whether or not the
! 	  cursor is at character position 0 on an otherwise-empty line and
! 	  adjusts _rl_vis_botlin accordingly
! 
! 				   9/13
! 				   ----
! general.c
! 	- fixed canonicalize_pathname to make sure that intermediate
! 	  results correspond to directories before blindly chopping
! 	  off the last component when we see a `..'.  This fixes the
! 	  `cd ../.../..' being equivalent to `cd ..' problem
! 
! subst.c
! 	- fixed make_named_pipe so that mkfifo is called with mode 0600
! 	  for security reasons [in 1.14.6]
! 	- changed the /dev/fd version of add_fifo_list to zero out new
! 	  entries to the fifo_list when it resizes it larger [in 1.14.6]
! 	- changed make_dev_fd_filename to use DEV_FD_PREFIX
! 
! aclocal.m4
! 	- changed BASH_HAVE_DEV_FD to check for /proc/self/fd and define
! 	  DEV_FD_PREFIX to either "/dev/fd/" or "/proc/self/fd/" as
! 	  appropriate
! 
! 				   9/14
! 				   ----
! lib/readline/display.c
! 	- when displaying the first line of a multiline prompt, make sure
! 	  that the final \n is followed by a \r (outputting one if necessary)
! 	  so that we know we are starting at column 0
! 
! variables.h
! 	- new attribute: att_local
! 
! variables.c
! 	- changed make_local_variable to set the att_local attribute
! 	- changed makunbound to just make variables marked as `local' in
! 	  the current context invisible.  This makes the local variable
! 	  persist throughout the function even if it is unset, so a
! 	  subsequent assignment preserves the `local' attribute
! 	- changed kill_all_local_variables to unset the att_local attribute
! 	  before calling makunbound
! 
! 				   9/18
! 				   ----
! lib/readline/complete.c
! 	- make sure the cursor is on the last line of a possibly-multiple-
! 	  line command line before listing the completions in
! 	  display_matches
! 
! 				   9/19
! 				   ----
! braces.c
! 	- fixed the non-SHELL case in brace_gobbler so the loop exits when
! 	  it should
! 
! lib/readline/bind.c, lib/readline/readline.h
! 	- added functions to dump key sequences bound to macros and their
! 	  values
! 
! builtins/bind.def
! 	- added -S and -s options to dump the readline macros and their values
! 	- changed the options so that -p and -P dump functions, -v and -V
! 	  dump variables, and -s and -S dump macros (s for string)
! 
! doc/{bash.{1,html},readline.3,features.texi}, lib/readline/doc/rluser.texinfo
! 	- added documentation for the new `bind' options
! 	- added documentation for the new readline functions to dump macros
! 	  and the key sequences that output them
! 
! 				   9/22
! 				   ----
! print_cmd.c
! 	- new function xtrace_print_word_list (WORD_LIST *) to print the
! 	  words of a simple command when set -x is on.  This prints ''
! 	  when it encounters an empty string
! 
! externs.h
! 	- new extern declaration for xtrace_print_word_list
! 
! execute_cmd.c
! 	- call xtrace_print_word_list in execute_simple_command
! 
! 				   9/25
! 				   ----
! builtins/getopts.def
! 	- make sure that the loop counter stops at 10 when stepping through
! 	  the dollar_vars array to count the number of positional parameters
! 	  [in 1.14.6]
! 
! 				   9/30
! 				   ----
! lib/readline/histsearch.c
! 	- fixed history_search_internal to bail immediately if it gets a
! 	  null or empty search string.  This fixes the !? core dumps.
! 	  [in 1.14.6]
! 
! 				   10/3
! 				   ----
! lib/readline/histexpand.c
! 	- if there is a null string given with a !? search specifier, use
! 	  a previous search string if one exists, else fail immediately
! 
! trap.c
! 	- made run_exit_trap preserve $? around the call to execute the
! 	  trap string, unless the trap string contains an `exit'
! 	  command, in which case it can set the shell's exit status
! 	  [in 1.14.6]
! 
! 	  In other words:
! 
! 		touch /tmp/z
! 		trap 'rm /tmp/z ; exit 5' 0
! 		exit 1
! 
! 	  exits with status 5; while
! 
! 		touch /tmp/z
! 		trap 'rm /tmp/z' 0
! 		exit 1
! 
! 	  exits with status 1
! 
! subst.c, parse.y
! 	- moved the $'...' code from subst.c to parse.y, more like ksh
! 	  does it
! 
! doc/bash.1, doc/bash.html, doc/features.texi
! 	- moved the description of $'...' from the expansion section to
! 	  the quoting section
! 
! 				   10/4
! 				   ----
! command.h
! 	- added a `line' member to the function struct for the source line
! 	  the function definition starts on
! 
! make_cmd.c
! 	- initialize the `line' member in Function_def to 0
! 	- make_function_def takes a third parameter telling which line the
! 	  function definition started on and a fourth telling which line
! 	  the function body started on
! 
! make_cmd.h
! 	- changed prototype for make_function_def
! 
! parse.y
! 	- new variable `function_dstart', set by read_token and read_token_word
! 	  to keep track of where a function definition begins
! 	- new variable `function_bstart' to keep track of where function
! 	  body begins
! 	- pass function_dstart and function_bstart to make_function_def
! 	- new function strtrans to do the $"..." locale-specific translation
! 	  of `...'
! 	- call strtrans() to translate $"string".  The translated string is
! 	  double-quoted
! 
! doc/bash.{1,html}
! 	- updated the description of LINENO now that line numbers within
! 	  functions are correct
! 
! configure.in
! 	- look for the `gettext' library function
! 
! config.h.in
! 	- define HAVE_GETTEXT if gettext(3) exists in a findable library
! 
! 				   10/5
! 				   ----
! builtins/common.c
! 	- changed backslash_quote so that `#' is only quoted at the start
! 	  of a word
! 	- new function contains_shell_metas returns 1 if the argument
! 	  string contains one or more shell meta-characters that require
! 	  quoting
! 
! builtins/common.h
! 	- extern declaration for contains_shell_metas
! 
! print_cmd.c
! 	- changed xtrace_print_word_list to print words containing
! 	  shell metacharacters within single quotes
! 
! lib/termcap
! 	- upgraded to GNU termcap version 1.3
! 
! 				   10/9
! 				   ----
! lib/readline/readline.c
! 	- call setlocale(LC_CTYPE, ...) after finding a legal value for
! 	  one of LC_ALL, LC_CTYPE, or LANG
! 
! 				   10/11
! 				   -----
! lib/readline/search.c
! 	- make rl_history_search_internal just do previous-history or
! 	  next-history as appropriate when given a null search string
! 	  (rl_point == 0)
! 
! 				   10/24
! 				   -----
! subst.c
! 	- fixed an off-by-one error in char_is_quoted that skipped a
! 	  characters after calling skip_single_quoted or skip_double_quoted
! 	  [in 1.14.6]
! 	- fixed an off-by-one error in string_extract_verbatim so it
! 	  leaves *sindex at the separator character if the separator
! 	  character is "'" [in 1.14.6]
! 
! 				   10/27
! 				   -----
! parse.y
! 	- in CHECK_FOR_RESERVED_WORD, make sure that reading a `}'
! 	  decrements open_brace_awaiting_satisfaction if it is non-zero
! 	  [in 1.14.6]
! 
! shell.c
! 	- don't run the shell startup files if the shell is running
! 	  setuid
! 	- don't source $ENV if the shell is running setuid
! 
! variables.c
! 	- new parameter to initialize_shell_variables: no_functions.  If
! 	  non-zero, don't import functions from the environment
! 
! variables.h
! 	- change to function prototype for initialize_shell_variables
! 
! lib/readline/complete.c
! 	- fix for the code that decides whether or not a char is quoted for
! 	  applications that don't supply a value for rl_char_is_quoted_p
! 	- fixed insert_match to not remove a user-supplied opening quote
! 	  character if make_quoted_replacement does not return a string
! 	  beginning with that quote character
! 
! 				   11/2
! 				   ----
! general.c
! 	- new function ungetc_with_restart that handles the local buffering
! 	  [in 1.14.6]
! 
! parse.y
! 	- changed yy_stream_unget to call ungetc_with_restart if the OS
! 	  does not have restartable syscalls [in 1.14.6]
! 
! 				   11/3
! 				   ----
! bashline.c
! 	- rewrote _ignore_completion_names to actually free and remove
! 	  names from the array if more than one names in the array
! 	  passed is acceptable, instead of just bailing [in 1.14.6]
! 
! 				   11/7
! 				   ----
! bashline.c
! 	- if no matches are acceptable to _ignore_completion_names,
! 	  free the entries in NAMES, set NAMES[0] == 0, and let the
! 	  caller clean up [in 1.14.6]
! 	- fixed a problem with backslash-quoted characters in
! 	  bash_dequote_filename that caused the character after the
! 	  backslash to be interpreted
! 	- bash_dequote_filename now takes a quote_char parameter that,
! 	  if non-zero, gives the quote character (`'' or `"') that
! 	  delimits the filename.  Used to initialize the quoting state
! 
! lib/readline/complete.c
! 	- if the completion ignore function returns with MATCHES == 0
! 	  or MATCHES[0] == 0, ring the bell and quit the completion
! 	  attempt [in 1.14.6]
! 	- pass quote_char to gen_completion_matches so it can pass it
! 	  along to the app-specific filename dequoting function
! 	- have gen_completion_matches pass quote_char to whatever function
! 	  is pointed to by rl_filename_dequoting_function
! 
! pathexp.c
! 	- rewrote ignore_globbed_names to be more like _ignore_completion_names
! 
! lib/readline/doc/rltech.texinfo
! 	- updated documentation for rl_filename_dequoting_function
! 
! 				   11/10
! 				   -----
! subst.c
! 	- fixed remove_quoted_nulls so that it is now a full function that
! 	  removes unquoted CTLNUL chars from the string it is passed
! 	  [in 1.14.6]
! 	- fixed expand_word_internal to avoid generating some unneeded
! 	  quoted nulls (if the string is partially quoted, note that we
! 	  have seen a quoted null and add one if the rest of the string
! 	  doesn't expand to anything)
! 
! 				   11/13
! 				   -----
! variables.c
! 	- bind HOSTTYPE, OSTYPE, and HOSTNAME unconditionally
! 
! pathexp.c
! 	- new function quote_globbing_chars, adds `\' before globbing
! 	  chars in its string argument, returns new string
! 
! pathexp.h
! 	- extern declaration for quote_globbing_chars
! 
! bashhist.c
! 	- if the previous line contains globbing chars, run it through
! 	  quote_globbing_chars before trying to match.  This affects
! 	  only HISTIGNORE patterns containing `&'
! 
! 				   11/14
! 				   -----
! bashhist.c
! 	- if the history line to be added contains globbing chars, quote
! 	  them with backslashes by calling quote_globbing_chars in
! 	  history_should_ignore before comparing them against the
! 	  patterns in HISTIGNORE
! 
! bashline.c
! 	- make sure that we erase the current readline line after running
! 	  fc on it and executing the resultant commands in
! 	  vi_edit_and_execute_command, so the original readline line
! 	  doesn't get returned [in 1.14.6]
! 
! jobs.h
! 	- added a new job listing format: JLIST_NONINTERACTIVE -- like
! 	  JLIST_LONG, but does not print the job number
! 
! jobs.c
! 	- added code to pretty_print_job to handle JLIST_NONINTERACTIVE
! 	- call notify_and_cleanup() from wait_for even if the shell is
! 	  running a script (interactive_shell == 0)
! 	- changed notify_and_cleanup to call notify_of_job_status if
! 	  interactive or interactive_shell == 0, so scripts report
! 	  about jobs they run
! 	- changed notify_of_job_status to call pretty_print_job with a
! 	  JLIST_NONINTERACTIVE format if interactive_shell is 0 and a
! 	  job is marked JDEAD, after printing the script name and line
! 	  number.  This message is printed only if the job dies due to
! 	  a fatal signal
! 
! support/mkversion.c
! 	- added support for a `-status status' argument to set the
! 	  `release status' of the shell (alpha, beta, or release).  It
! 	  defines `RELSTATUS' in version.h and changes the definition
! 	  of SCCSVERSION, if present
! 
! Makefile.in
! 	- set a RELSTATUS variable that is included when printing the build
! 	  message and passed to mkversion with the -status option
! 	- make RELSTATUS one of the variables sed sets when it creates
! 	  bashbug from support/bashbug.sh
! 
! version.c
! 	- added a `release_status' variable that's set to RELSTATUS if
! 	  it's defined
! 
! support/bashbug.sh
! 	- added the `RELSTATUS' variable to the report with heading
! 	  `Release Status'
! 	- set the bug address to chet@po.cwru.edu if the release status
! 	  is `alpha' or `beta'
! 
! 				   11/15
! 				   -----
! 
! shell.c, execute_cmd.c
! 	- new variable expand_aliases to control alias expansion.  For now,
! 	  this is set to the same value as interactive_shell when that is
! 	  set
! 
! parse.y
! 	- perform alias expansion if expand_aliases is non-zero rather than
! 	  checking the value of interactive_shell
! 
! 				   11/16
! 				   -----
! builtins/shopt.def
! 	- new option `expand_aliases' to control the value of expand_aliases
! 
! doc/bash.1, doc/bash.html
! 	- updated the description of `shopt' with the `expand_aliases' option
! 
! 				   11/28
! 				   -----
! bashline.c
! 	- if there is only one completion in _ignore_completion_names, see
! 	  if it is acceptable and return right away [in 1.14.6]
! 
! configure.in
! 	- change to define WAITPID_BROKEN on SCO 3.2v5
! 
! 				   12/6
! 				   ----
! parse.y
! 	- call prompt_again in read_token_word if a newline is read in an
! 	  interactive shell and bash_input.type is either st_stdin or
! 	  st_stream
! 	- remove superfluous call to reset_readline_prompt in yy_readline_get
! 
! 				   12/7
! 				   ----
! parse.y
! 	- combine delimiters, delimiter_depth, and delimiter_space into a
! 	  single structure of type `struct dstack'
! 	- replace all references to delimiter* with dstack.delimiter*
! 	- include parser.h for struct dstack
! 	- new define pop_delimiter(), analogous to push_delimiter
! 	- current_delimiter, push_delimiter, and pop_delimiter defines now
! 	  include the delimiter stack struct as the first parameter
! 
! parser.h
! 	- now includes definition of struct dstack
! 
! bashline.c
! 	- include parser.h for struct dstack
! 	- refer to dstack.delimiter_depth instead of delimiter_depth
! 
! 				   12/12
! 				   -----
! execute_cmd.c
! 	- before doing a longjmp(subshell_top_level,...) when executing a
! 	  shell script without a leading #!, set history_lines_this_session
! 	  to 0 to forget about the history and not save it on an exec
! 	  (we don't free the memory with clear_history(), though -- that
! 	  would slow bash down)
! 
! 				   12/14
! 				   -----
! jobs.c, nojobs.c
! 	- cause the sigwinch handling code to be compiled into the shell
! 	  even if READLINE is defined
! 	- new functions: set_sigwinch_handler and unset_sigwith_handler
! 	  to enable and disable catching of SIGWINCH and adjusting $LINES
! 	  and $COLUMNS
! 	- changed initialize_job_signals to install a signal handler for
! 	  SIGWINCH with set_sigwinch_handler
! 
! jobs.h
! 	- extern declarations for set_sigwinch_handler and
! 	  unset_sigwinch_handler
! 
! 				   12/20
! 				   -----
! doc/bash.{1,html}, doc/readline.3, lib/readline/doc/rluser.texinfo
! 	- documented the readline `visible-stats' variable
! 
! 				   12/21
! 				   -----
! trap.c
! 	- new global variable `running_trap' incremented and decremented
! 	  around running a trap command in _run_trap_internal
! 
! execute_cmd.c
! 	- new variable currently_executing_command, set to the COMMAND *
! 	  currently being processed by execute_command_internal, unless a
! 	  trap command is being run (running_trap != 0)
! 	- new function executing_line_number, which returns the line number
! 	  of the currently executing command (which may not be the same as
! 	  line_number)
! 	- don't run the debug trap if it was not set before the current
! 	  simple command was executed, since we don't want to run it after
! 	  the trap command that sets the DEBUG trap
! 
! variables.c
! 	- new function assign_lineno, to assign a value to line_number
! 	  when LINENO is set
! 	- changed get_lineno to call executing_line_number() rather than
! 	  returning line_number
! 
! parse.y
! 	- new argument for push_stream telling it whether or not to reset
! 	  line_number to 0
! 
! builtins/common.c
! 	- change to parse_and_execute to call push_stream with an argument
! 
! 				   12/29
! 				   -----
! subst.c
! 	- set subshell_environment in command_substitute and process_substitute
! 	  for the child process
! 
! 				    1/2
! 				    ---
! trap.c
! 	- made decode_signal recognize signal names case insensitively
! 
! shell.c
! 	- make the shell exit on a longjmp (DISCARD, ...) if
! 	  subshell_environment is non-zero
! 
! 				   1/16
! 				   ----
! lib/readline/histexpand.c
! 	- let the `!' in ${!xxx} pass through without error
! 
! shell.c
! 	- new --help long option
! 	- new function show_shell_usage() for use by --help
! 
! 				   1/19
! 				   ----
! parse.y
! 	- changes to shell_getc to make sure that lines consisting of only a
! 	  newline get added to the history correctly when they are part of
! 	  a quoted string
! 
! 				   1/24
! 				   ----
! aclocal.m4, configure.in
! 	- added a check for -lsocket (and -lnsl) to fix solaris problems
! 	  with isnetconn()
! 
! shell.c
! 	- rearranged the code in isnetconn to check for a socket using
! 	  getpeername() first, before any SVR4 or SVR4.2-specific checks
! 	- added checks for ttys (isatty) and FIFOs (S_ISFIFO) to the
! 	  SVR4/SVR4.2 case of isnetconn()
! 
! general.h
! 	- new macro RESIZE_MALLOCED_BUFFER to check and see whether there
! 	  is enough room in a string to add a given number of characters
! 	  and to resize it if there is not
! 
! 				   1/25
! 				   ----
! parse.y, general.c, subst.c, bashhist.c, alias.c, array.c, variables.c
! 	- use RESIZE_MALLOCED_BUFFER where appropriate
! 
! 				   1/26
! 				   ----
! support/config.{guess,sub}
! 	- merged in latest changes from GNU master copies
! 
! 				   1/30
! 				   ----
! 
! jobs.c
! 	- make sure to freeze the jobs list when calling a trap handler
! 	  for SIGINT
! 	- added code to waitchld() so that a SIGINT trap handler is called
! 	  if the shell is running a shell script and a SIGINT is received
! 	  while waiting for a foreground job, even if that job does not
! 	  die from the SIGINT
! 
! jobs.c, nojobs.c
! 	- make get_tty_state reset $LINES and $COLUMNS after each process
! 	  exits if the variable `check_window_size' is non-zero
! 
! builtins/shopt.def
! 	- new variable `checkwinsize', which controls the value of
! 	  check_window_size
! 
! doc/{bash.{1,html},features.texi}
! 	- updated description of `shopt' to include `checkwinsize'
! 
! execute_cmd.c, lib/readline,complete.c
! 	- some changes from the GNU WIN32 project for the bash port to
! 	  Windows NT and Windows 95
! 
! bashwait.h
! 	- new file, with `union wait' defines from jobs.h
! 
! jobs.h
! 	- include `bashwait.h' if <sys/wait.h> is not present and
! 	  _POSIX_VERSION is not defined
! 	- removed define of pid_t for non-Posix systems; now provided by
! 	  autoconf in config.h
! 
! 				   1/31
! 				   ----
! parse.y
! 	- new temporary delimiter stack, used when decoding prompt strings.
! 	  This is needed so command substitutions in the prompt strings
! 	  (especially PS2) don't screw up the parser's quoting state
! 
! lib/readline/complete.c
! 	- new variable for readline library users:
! 	  rl_completion_append_character.  The value of this variable is
! 	  the character appended to a completion when it occurs at the
! 	  end of a line.  Setting it to '\0' causes nothing to be
! 	  appended.
! 
! lib/readline/readline.h
! 	- declaration for rl_completion_append_character
! 
! lib/readline/doc/rltech.texinfo
! 	- documented rl_completion_append_character as int variable available
! 	  to library users
! 
! subst.c
! 	- new code for maintaining a string array saying which words in the
! 	  output of expand_word_list_internal are the result of globbing
! 
! variables.c
! 	- new function put_gnu_argv_flags_into_env (pid, flags_string)
! 	  to put Roland's GNU getopt helper variable into the export_env
! 
! execute_cmd.c
! 	- in execute_disk_command, after forking the child, put the GNU
! 	  getopt helper environment variable into the child's export_env
! 
! unwind_prot.c
! 	- changed unwind_protect_var and restore_variable to do the
! 	  bcopy of the variable's value if it's shorter than the size of
! 	  an int, as well as if it's longer.  This keeps stray data
! 	  from being copied if a short is being unwind-protected
! 
! unwind_prot.h
! 	- new define, unwind_protect_short, to protect variables smaller
! 	  than an int
! 
! jobs.c
! 	- in the code that handles SIGCHLD traps, call unwind_protect_short
! 	  if that is the size of a pid_t (for last_made_pid)
! 
! 				    2/5
! 				    ---
! Makefile.in
! 	- only try make distclean in HIST_LIBDIR if Makefile exists -- could
! 	  have already been removed if HIST_LIBDIR is the same as RL_LIBDIR
! 
! general.c
! 	- make canonicalize_pathname be more careful about what it checks
! 	  for being a directory name when processing a full pathname
! 
! Makefile.in, configure.in, doc/Makefile.in
! 	- small changes to get bash to build better in a directory not the
! 	  source directory
! 
! 				   2/12
! 				   ----
! Makefile.in
! 	- added `install-strip' target
! 
! 				   2/14
! 				   ----
! doc/bash.{1,html}, doc/features.texi
! 	- documented the `--verbose' startup option
! 
! lib/readline/complete.c
! 	- fix to gen_completion_matches to fix a memory leak
! 	- fix to rl_complete_internal to fix a memory leak
! 
! 				   2/15
! 				   ----
! bashwait.h
! 	- changed to use WORDS_BIGENDIAN instead of LITTLE_ENDIAN or
! 	  BIG_ENDIAN
! 
! configure.in, config.h.in
! 	- call AC_C_BIGENDIAN, define WORDS_BIGENDIAN
! 
! Makefile.in
! 	- remove all references to mkendian.c, mkendian, and bash_endian.h
! 	- added a `symlinks' target that just runs support/fixlinks
! 
! MANIFEST
! 	- mkendian.c is no longer in the distribution
! 
! 				   2/16
! 				   ----
! execute_cmd.c
! 	- include <sys/times.h> if HAVE_SYS_TIMES_H and HAVE_TIMES are
! 	  defined
! 
! bashline.c
! 	- fix to bash_directory_completion_hook to compensate for
! 	  canonicalize_pathname returning NULL
! 
! variables.c
! 	- fix to initialize_shell_variables to compensate for
! 	  canonicalize_pathname returning NULL
! 
! 				   2/22
! 				   ----
! tests/test-tests, tests/test.right
! 	- changes to avoid writing in the source directory -- all temp files
! 	  are created in /tmp
! 
! [First alpha release at Thu Feb 22 15:59:51 EST 1996]
! 
! 				   2/23
! 				   ----
! lib/readline/rldefs.h
! 	- work around SVR4.2 bug including <sys/ptem.h> and <termios.h>
! 
! lib/readline/chardefs.h
! 	- fix to CTRL_CHAR macro for chars > 128 on systems with signed
! 	  characters
! 
! builtins/ulimit.def
! 	- protect more of the RLIMIT_* defines with checks
! 	- new macro RETINVALID() to set errno and return the correct
! 	  value for an invalid request
! 
! doc/Makefile.in
! 	- add a definition for INSTALL, set by autoconf
! 
! 				   2/26
! 				   ----
! support/bashbug.sh
! 	- if USER is unset, assign it the value of $LOGNAME or `whoami`
! 
! Makefile.in,{lib/*,doc,builtins}/Makefile.in
! 	- use `test' instead of `[' to conform to GNU coding standards
! 	- `incdir' -> `includedir' as per latest GNU coding standards
! 
! lib/readline/Makefile.in, lib/glob/Makefile.in
! 	- use $(srcdir)/ instead of $(srcdir) in the CSOURCES variable
! 
! general.h
! 	- new define, FS_NODIRS, to not find directory names when searching
! 	  $PATH
! 
! execute_cmd.c
! 	- fix to find_in_path_element so it does not return directories
! 	- executable_file() no longer returns directories as executable
! 
! 				   2/27
! 				   ----
! jobs.h
! 	- new flag value: J_NOHUP
! 
! jobs.c
! 	- new function: nohup_job(job).  Sets J_NOHUP flag for specified
! 	  job
! 	- change hangup_all_jobs so that jobs marked J_NOHUP are not
! 	  sent SIGHUP.  If stopped, the job still gets SIGCONT.
! 	- changed calls to report_error to call internal_error, which will
! 	  not exit the shell
! 	- changed FIND_CHILD define to call internal_error, restore the
! 	  SIGINT handler, set termination_state to 127 and return, rather
! 	  than aborting the shell
! 
! builtins/jobs.def
! 	- new option for disown: `-h'.  Marks the specified jobs J_NOHUP.
! 
! doc/{bash.{1,html},features.texi}
! 	- added description of `disown -h'
! 
! jobs.c, nojobs.c
! 	- include some files needed for struct winsize by SCO
! 
! lib/readline/input.c
! 	- added some #ifdefs to avoid including <sys/time.h> on systems
! 	  with select but without <sys/select.h>
! 
! configure.in
! 	- check for <stdarg.h>, define HAVE_STDARG_H in config.h if found
! 
! config.h.bot
! 	- define USE_VARARGS and either PREFER_STDARG or PREFER_VARARGS
! 	  if one of <stdarg.h> or <varargs.h> is present
! 
! aclocal.m4
! 	- moved default mail directory check here from configure.in, macro
! 	  name is BASH_DEFAULT_MAIL_DIR
! 	- rewrote BASH_CHECK_DEV_FD to cache the value
! 	- minor fixes from Bruno Haible
! 
! shell.c
! 	- no longer includes <varargs.h>
! 
! builtins/Makefile.in
! 	- add -I$(topdir)/builtins to list of includes
! 
! execute_cmd.c, lib/glob/glob.c
! 	- include memalloc.h for correct alloca definitions
! 
! error.[ch], print_cmd.c, builtins/common.[ch]
! 	- changes to include new ANSI-C stdargs code if PREFER_STDARG is
! 	  defined
! 
! 				   2/28
! 				   ----
! aclocal.m4
! 	- more minor fixes from Andreas Schwab
! 
! doc/Makefile.in
! 	- change TEXINPUTS makefile variables to TEXINPUTDIR to avoid
! 	  conflict with shell variable of the same name
! 
! builtins/pushd.def
! 	- fix to avoid a bad call to free after a call to
! 	  polite_directory_format does not change its argument string
! 
! lib/readline/bind.c
! 	- fixes to _rl_macro_dumper_internal so that it prints whatever
! 	  prefix it's passed, if any
! 
! 				   2/29
! 				   ----
! Makefile.in
! 	- slight change to the rule for `stamp-h': it should be created by
! 	  running `config.status', not explicitly by the makefile rule
! 
! builtins/Makefile.in
! 	- replace `..' in the dependencies with `$(topdir)'
! 	- replace `.' in the dependencies with `$(srcdir)'
! 
! 				    3/1
! 				    ---
! Makefile.in
! 	- add a rule to build builtins/builtext.h for the benefit of
! 	  deficient makes like the SunOS one
! 
! variables.c
! 	- fix to assign_in_env so that values in the environment are
! 	  properly null-terminated
! 
! builtins/Makefile.in
! 	- added dependencies for object files made from .c files in this
! 	  directory: common.o, getopt.o, bashgetopt.o.  SunOS /bin/make
! 	  doesn't seem to be able to handle anything else
! 
! support/mkclone
! 	- new script to replace clone-bash that works from MANIFEST to link
! 	  only those files contained in a distribution
! 
! support/mkversion.c
! 	- change so that it doesn't try to get `.build' from the source
! 	  directory when that's different from the build directory
! 
! 				    3/4
! 				    ---
! bashjmp.h
! 	- #undef setjmp and longjmp before redefining them as sigsetjmp and
! 	  siglongjmp, respectively
! 
! bashhist.c
! 	- fixed an uninitialized variable problem in expand_histignore_pattern
! 
! builtins/set.def
! 	- used `on_or_off' where `value' was needed in minus_o_option_commands
! 
! builtins/common.h
! 	- added extern declaration for set_var_attribute
! 
! print_cmd.c
! 	- include `bashansi.h' instead of just string.h or strings.h
! 
! builtins/*.def, builtins/common.c
! 	- include `../bashansi.h' where appropriate
! 
! parse.y
! 	- fixed a parenthesization problem in alias_expand_token
! 
! general.h
! 	- added extern declaration for `ungetc_with_restart'
! 
! lib/readline/readline.c
! 	- renamed LibraryVersion to rl_library_version, made it extern,
! 	  assigned `2.1' to it
! 
! lib/readline/readline.h
! 	- extern declaration for `rl_library_version'
! 
! lib/readline/doc/rltech.texinfo
! 	- added description of `rl_library_version'
! 
! lib/glob/glob.c
! 	- changed call to sprintf in glob_dir_to_array to a couple of
! 	  calls to strcpy, since we keep the length of the first string
! 	  we copy
! 
! 				    3/7
! 				    ---
! aclocal.m4
! 	- added new macro `BASH_FUNC_LSTAT' to check for lstat on Linux,
! 	  which defines it as an inline function in <sys/stat.h>
! 
! configure.in
! 	- call BASH_FUNC_LSTAT if $ac_cv_func_lstat has value `no'
! 
! 				    3/8
! 				    ---
! parse.y
! 	- changed the occurrences of `list' in the if command productions
! 	  to use `compound_list' instead
! 
! 				   3/11
! 				   ----
! parse.y
! 	- changed the occurrences of `list' in the while and until command
! 	  productions to use `compound_list'
! 
! lib/readline/complete.c
! 	- fix to filename_completion_function -- off-by-one error when
! 	  expand-tilde is enabled and a filename to be completed begins
! 	  with `~/'
! 
! 				   3/12
! 				   ----
! builtins/cd.def
! 	- made the POSIX.2 behavior of PWD not containing symlinks after
! 	  using $CDPATH part of `posix mode', not default shell behavior
! 
! lib/readline/display.c
! 	- fix to update_line to handle update problems when using
! 	  horizontal scroll mode.  This is a dumb update solution -- it
! 	  should use a better one
! 
! 				   3/14
! 				   ----
! examples/functions/csh-compat
! 	- replaced the defintion for `alias' with a better one posted to
! 	  usenet by Mohit Aron <aron@cs.rice.edu>
! 
! 				   3/15
! 				   ----
! jobs.c
! 	- fix to wait_for_background_pids to keep `wait' from hanging
! 
! 				   3/19
! 				   ----
! lib/readline/input.c
! 	- new function `_rl_input_available()' returns > 0 if there is
! 	  input available on the readline input file descriptor.  Only
! 	  works if select(2) or FIONREAD are available
! 
! lib/readline/isearch.c
! 	- slight change to the isearch termination behavior -- ESC still
! 	  terminates the search, but if there is pending input or if input
! 	  arrives within 0.1 seconds (on systems with select(2)) it is
! 	  used as a prefix character with rl_execute_next
! 
! shell.c
! 	- the GNU coding standards say to write the output generated by
! 	  the --help command line option to stdout, not stderr
! 	- show_shell_version now takes an `extended' option that displays
! 	  copyright information if non-zero
! 	- show_shell_version now prints the value of `MACHTYPE' by default
! 	- the `--version' option now causes the shell to exit successfully
! 	  after printing the extended version information
! 
! externs.h
! 	- changed prototype for show_shell_version
! 
! shell.c, bashline.c, builtins/help.def
! 	- changed calls to show_shell_version to add appropriate argument
! 
! Makefile.in
! 	- pass a `MACHTYPE' define to the compiler
! 
! 				   3/22
! 				   ----
! general.c
! 	- changed print_timeval() and print_time_in_hz() to output three
! 	  fractional digits after the decimal point
! 
! examples/loadables/sleep.c
! 	- changed to an implementation that will sleep fractional portions
! 	  of seconds if select() is available
! 
! 				   3/25
! 				   ----
! builtins/shopt.def
! 	- fixes to shopt -o from Andreas Schwab.  Use FLAG_ON/FLAG_OFF
! 	  instead of SETOPT/UNSETOPT
! 
! 				   3/26
! 				   ----
! Makefile.in, builtins/Makefile.in
! 	- use `@includedir@' instead of `@incdir' for autoconf 2.9
! 
! Makefile.in
! 	- the `info', `dvi', and `ps' targets do not depend on `texindex'
! 	- add a `dist' target that just prints a message describing how
! 	  distributions are constructed
! 
! support/mkdirs
! 	- replace uses of [...] with `test'
! 
! 				   3/28
! 				   ----
! parse.y
! 	- fix for a problem with \@ prompt expansion from Tim Mooney
! 
! jobs.c
! 	- broke the code that prints a pipeline out into a separate
! 	  function: print_pipeline().  This gets called by
! 	  pretty_print_job and can be used for debugging
! 	- two new functions to save and restore the_pipeline around calls
! 	  to make_child that you don't want to disturb the current pipeline,
! 	  for example in process substitution
! 
! subst.c
! 	- changed process_substitute to call save_pipeline and
! 	  restore_pipeline in the appropriate places
! 
! 				   3/29
! 				   ----
! general.c
! 	- ansicstr now takes an additional parameter, the length of the
! 	  string to be translated.  It's the second paramter.
! 
! builtins/echo.def
! 	- changed call to ansicstr to pass strlen(list->word->word)
! 
! parse.y
! 	- redid the $'...' expansion so it works like it's supposed to:
! 	  the quoted strings may appear anywhere in a token, and multiple
! 	  ansi-c quoted strings may appear in a token
! 	- redid the $"..." expansion so it works like it's supposed to
! 
! tests/nquote.{tests,right}, tests/run-nquote
! 	- tests for the $'...' and $"..." quoting stuff -- simple-minded
! 
! subst.c
! 	- on systems without /dev/fd, open the named pipe for a `reading
! 	  in child' process substitution (>(...)) with O_NONBLOCK
! 
! lib/posixheaders/filecntl.h
! 	- add code to make sure the O_NONBLOCK is defined to O_NDELAY if
! 	  it is present and O_NONBLOCK is not defined by <fcntl.h>
! 
! general.c
! 	- don't bother handling both O_NONBLOCK and O_NDELAY in
! 	  unset_nodelay_mode, since filecntl.h defines O_NONBLOCK as
! 	  O_NDELAY for non-Posix systems
! 
! 				    4/1
! 				    ---
! lib/readline/funmap.c
! 	- made `vi-fetch-history' a bindable command name
! 
! doc/readline.3
! 	- many cleanups, updated the list of default bindings 
! 
! 				    4/4
! 				    ---
! doc/bash.1, doc/readline.3
! 	- fixed up use of \-; now it is not used unless the text is being
! 	  printed in bold or italic
! 
! configure.in, config.h.in
! 	- add a configuration option, --enable-usg-echo-default, to turn
! 	  on DEFAULT_ECHO_TO_USG and make `echo' expand backslash-escaped
! 	  characters by default
! 
! 				    4/8
! 				    ---
! parse.y
! 	- another small change to localeexpand to handle backslash-escaped
! 	  double quotes in the double-quoted string
! 
! 				    4/9
! 				    ---
! shell.c
! 	- add the value of MACHTYPE to the text output by `--help'
! 
! 				   4/11
! 				   ----
! parse.y
! 	- more changes to the $"..." and $'...' code to move it into
! 	  read_token
! 	- don't try to check token[token_index - 1] unless token_index
! 	  is greater than 0
! 
! 				   4/12
! 				   ----
! trap.c
! 	- new function run_trap_cleanup to clean up after _run_trap_internal
! 	  in the event that parse_and_execute does not return normally
! 	  (e.g., if a `return' is executed in the trap command)
! 	- set running_trap to the number of the signal whose trap is being
! 	  run plus one in _run_trap_internal
! 
! trap.h
! 	- extern declaration for run_trap_cleanup
! 
! jobs.c
! 	- new function `unfreeze_jobs_list' to set freeze_jobs_list back to 0.
! 	  called from parse_and_execute_cleanup so a `return' while running
! 	  an interrupt trap does not leave the jobs list frozen
! 
! jobs.h
! 	- new extern declaration for unfreeze_jobs_list
! 
! builtins/common.c
! 	- if running_trap is non-zero in parse_and_execute_cleanup, indicating
! 	  that parse_and_execute was running a trap command when it got a
! 	  `return', call run_trap_cleanup (running_trap - 1)
! 	- parse_and_execute_cleanup now calls unfreeze_jobs_list
! 
! 				   4/16
! 				   ----
! Makefile.in
! 	- don't try to make `doc' as a dependency of `install'
! 
! doc/Makefile.in
! 	- make `info' a dependency of `install' to make sure the info
! 	  document is present and up to date before installing it
! 	- make the `install' target install the documents with a $(srcdir)/
! 	  prefix in case we're building in another directory
! 
! lib/glob/glob.c
! 	- fixed an off-by-one error in glob_dir_to_array
! 
! shell.c
! 	- removed an extra increment of arg_index when setting up the
! 	  arguments for -c command
! 
! 				   4/17
! 				   ----
! pathexp.c
! 	- made quote_globbing_chars backslash-quote backslashes as well as
! 	  `?*[]'; changed it to be a little faster
! 
! bashhist.c
! 	- call quote_globbing_chars to quote backslashes in the previous
! 	  history line even if no other globbing chars are present.  This
! 	  is done only if we're matching against a HISTIGNORE pattern of `&'
! 	- don't bother quoting globbing characters in the current history
! 	  line in history_should_ignore -- fnmatch ignores special chars in
! 	  its `string' argument
! 
! [bash-2.0-alpha2 frozen]
! 
! 				   4/18
! 				   ----
! command.h
! 	- new flag value for a word: W_NOSPLIT.  A word with this bit set
! 	  in its flags will not have word splitting performed
! 
! parse.y
! 	- turn on the W_NOSPLIT flags for assignment statements appearing
! 	  where an assignment statement is acceptable (words that would
! 	  return ASSIGNMENT_WORD rather than WORD).  This means that, for
! 	  the time being, assignment statement arguments to builtins like
! 	  `declare' or `alias' will be split unless they are quoted
! 
! subst.c
! 	- don't split a word in expand_word_internal if the W_NOSPLIT flag
! 	  is set, rather than checking W_ASSIGNMENT; do the same thing in
! 	  expand_word_list_internal
! 
! builtins.h
! 	- a new flag, ASSIGNMENT_BUILTIN, indicating that this builtin takes
! 	  assignment statements as arguments
! 	- rearranged the values of the builtin flags, so the BUILTIN_* flags
! 	  come first, then the *_BUILTIN flags
! 
! builtins/makebuiltins.c
! 	- added code for an array of `assignment builtins' -- builtins that
! 	  take assignment statements as arguments -- and to add the
! 	  ASSIGNMENT_BUILTIN flag for those builtins
! 
! execute_cmd.c
! 	- added a hack function `fix_assignment_words', which checks the
! 	  first word of a builtin command to see if it is a builtin that
! 	  has the ASSIGNMENT_BUILTIN flag set, and adds W_NOSPLIT to the
! 	  flags for all words with the W_ASSIGNMENT bit set.  This means
! 	  that word splitting is not done for any of the assignment
! 	  statements in commands like `declare z=$a'
! 
! 				   4/19
! 				   ----
! execute_cmd.c
! 	- fixed a memory-freed-twice error in find_in_path_element
! 
! lib/readline/rltty.c
! 	- include <sys/ioctl.h> if GWINSZ_IN_SYS_IOCTL is defined and
! 	  SHELL is not defined
! 
! lib/readline/input.c
! 	- changed a stray HAVE_FIONREAD to FIONREAD
! 	- include <sys/ioctl.h> if FIONREAD_IN_SYS_IOCTL is defined
! 
! aclocal.m4
! 	- new macro, BASH_HAVE_FIONREAD, to check for a #define of
! 	  FIONREAD in <sys/ioctl.h> or one of the files it includes;
! 	  defines FIONREAD_IN_SYS_IOCTL if present
! 
! config.h.in
! 	- new line for FIONREAD_IN_SYS_IOCTL
! 
! configure.in
! 	- call BASH_HAVE_FIONREAD
! 
! 				   4/22
! 				   ----
! builtins/cd.def
! 	- fixed a memory-freed-twice error in mkpath()
! 
! jobs.c
! 	- don't print a job termination message for a non-interactive shell
! 	  with startup_state == 2 (those shells are started to run commands
! 	  when bash is invoked with `-c command')
! 
! 				   4/23
! 				   ----
! general.h
! 	- definition for a `generic pointer' type PTR_T -- `void *' on ANSI
! 	  C systems, `char *' otherwise
! 
! jobs.h
! 	- new members of job struct: `j_cleanup', a function to call when the
! 	  job is marked JDEAD, and `cleanarg', argument to pass to j_cleanup
! 
! jobs.c
! 	- initialize j_cleanup and cleanarg to NULL in stop_pipeline
! 	- call j_cleanup from waitchld() when a job is marked JDEAD
! 
! test.c
! 	- fixed binop() so it recognizes `<' and `>' as binary operators
! 	- fixed a bug in binary_operator so `<' works correctly
! 
! tests/test-tests
! 	- fixed the tests so they no longer rely on the modes of files in
! 	  the file system to test -u, -g, -r, -x, -w, and so on, except
! 	  for a few `standard' files like /dev/tty and /dev/null
! 	- added tests for string < string and string > string
! 
! xmalloc.c
! 	- include <unistd.h> if HAVE_UNISTD_H is defined for a prototype
! 	  for sbrk
! 	- add an extern declaration for sbrk if SBRK_DECLARED is not defined
! 	- use PTR_T to cast the return value of sbrk() when finding out where
! 	  the break is and how many bytes of memory have been allocated
! 
! lib/malloc/malloc.c
! 	- added code to write 0xcf into memory as it's freed, to uncover
! 	  callers that try to refer to freed memory, and writes 0xdf into
! 	  newly-allocated memory, to uncover callers that assume something
! 	  about new allocations (e.g., that newmem[0] == 0)
! 
! lib/malloc/gmalloc.c
! 	- latest version from GNU sources
! 
! 				   4/25
! 				   ----
! doc/bash.1
! 	- changed the description of `unset' to include a description of
! 	  the `-v' option
! 
! parse.y
! 	- fixed a problem with conversion to 12-hour time in
! 	  decode_prompt_string that made 12:00pm show up as 00:00pm
! 
! 				   4/26
! 				   ----
! builtins/common.c, subst.c
! 	- a couple of fixes from Andreas Schwab
! 
! configure.in
! 	- set up the minimal configuration after checking for
! 	  --enable-minimal-config with AC_ARG_ENABLE, before checking any
! 	  of the other options, instead of after checking all options.
! 	  This makes `--enable-minimal-config --enable-prompt-string-decoding'
! 	  work as documented
! 	- changed AC_PREREQ to require autoconf version 2.8 or higher
! 	- added some code to disable gnu malloc by default on the systems
! 	  listed in NOTES
! 	- set MALLOC_SRC to have the $(ALLOC_LIBSRC)/ prefix to avoid having
! 	  a directory in the dependencies when making without the gnu
! 	  malloc
! 
! lib/malloc/Makefile.in
! 	- make gmalloc.o depend on $(BUILD_DIR)/config.h
! 
! 				   4/30
! 				   ----
! COMPAT
! 	- new file listing user-visible incompatibilites between bash-1.14
! 	  and bash-2.0
! 
! parse.y
! 	- new prompt expansions, \v (version) and \V (version + patchlevel)
! 
! config.h.top
! 	- the default value of PS1 is now '\s-\v\$ '
! 
! doc/{bash.{1,html},features.texi}
! 	- added descriptions of \v and \V prompt expansions
! 	- changed default value of PS1
! 
! Makefile.in
! 	- added dependencies on config.h.top for files that use definitions
! 	  included there
! 
! builtins/exec.def
! 	- removed reference to `no_exit_on_failed_exec' from the help text
! 
! 				    5/3
! 				    ---
! builtins/cd.def
! 	- fixed a typo in fix from 4/22
! 
! 				    5/7
! 				    ---
! builtins/common.c
! 	- new function `no_options (WORD_LIST *)' to be called by builtins
! 	  that do not take options to check for options and -?.  It returns
! 	  0 on success, non-zero if an unwanted option is supplied
! 
! builtins/common.h
! 	- extern declaration for no_options
! 
! builtins/return.def
! 	- corrected the error message to include returning from a sourced
! 	  script
! 
! builtins/{getopts,eval,wait,source,fg_bg,help}.def
! 	- changed the following builtins to either call no_options or test
! 	  explicitly for options and return EX_USAGE if any are found:
! 
! 		getopts eval wait source . fg bg help
! 
! builtins/help.def
! 	- error messages are now printed using builtin_error
! 
! 				    5/8
! 				    ---
! builtins/jobs.def
! 	- fixed an unitialized variable problem
! 
! tests/more-exp.tests
! 	- added additional tests for IFS problem uncovered by `iffe'
! 
! 				    5/9
! 				    ---
! lib/malloc/Makefile.in
! 	- use $(ALLOCA_SOURCE) instead of $< in rule that builds alloca.o.
! 	  Some makes don't expand the $< in non-suffix rules
! 
! lib/readline/rldefs.h
! 	- fix workaround for SVR4.2 bug
! 
! shell.c
! 	- even though SVR4.2 has getpeername(), isnetconn() should not use it
! 
! maxpath.h
! 	- rework to make sure PATH_MAX and NAME_MAX are defined, and remove
! 	  the BUILDING_MAKEFILE code
! 
! general.c, parse.y, oslib.c, jobs.c, builtins/common.c, builtins/cd.def
! 	- change uses of MAXPATHLEN to PATH_MAX
! 
! examples/loadables/{{log,base,dir}name,tty,pathchk,tee}.c
! 	- new loadable builtins:
! 
! 		logname basename dirname tty pathchk tee
! 
! configuure.in, config.h.in
! 	- look for tzset(3), define HAVE_TZSET if found
! 
! subst.c
! 	- new special variable function, sv_tz, which calls tzset when
! 	  TZ is changed, if tzset(3) exists and the shell is compiled
! 	  to do prompt string decoding
! 
! subst.h
! 	- extern declaration for sv_tz
! 
! 				   5/10
! 				   ----
! builtins/echo.def
! 	- only call printf if the string to print is non-null
! 	- add an fflush(stdout) after the printf call to work around a
! 	  bug in SunOS 5.5
! 
! 				   5/16
! 				   ----
! shell.c
! 	- moved some variable declarations out of this file to more
! 	  logical places
! 
! support/config.guess
! 	- small fixes from rfg@monkeys.com
! 
! version.c
! 	- moved functions for getting, setting, and displaying shell version
! 	  information here from shell.c
! 
! general.c
! 	- moved set_lines_and_columns to variables.c
! 	- moved getc_with_restart and ungetc_with_restart to input.c
! 	- new function argv_to_word_list(), converts an array of strings
! 	  into a WORD_LIST
! 	- renamed find_name_in_list to find_name_in_array to match rest
! 	  of functions that operate on arrays of strings
! 
! configure.in, Makefile.in, jobs.c, nojobs.c
! 	- changes so that jobs.c no longer includes nojobs.c, and the correct
! 	  object file (jobs.o or nojobs.o) is selected by configure
! 	  and substituted into the Makefile
! 
! list.c
! 	- new file, list manipulation functions from general.c
! 
! externs.h, general.h
! 	- moved extern declarations for functions defined in oslib.c and
! 	  list.c to externs.h from general.h
! 
! 				   5/17
! 				   ----
! locale.c
! 	- new file, with locale code from parse.y and shell.c
! 
! shell.c
! 	- don't turn off job control if act_like_sh is set
! 	- if an unknown option is supplied at startup or if -c is
! 	  supplied without an argument, exit with EX_USAGE
! 	- call posix_initialize after parsing all the options, to
! 	  catch `bash -o posix'
! 	- new functions: init_interactive(), init_noninteractive()
! 	- exit with EX_NOTFOUND if a script argument is not found
! 	- exit with EX_NOINPUT if a script file cannot be opened for
! 	  some reason
! 
! shell.h
! 	- new define for EX_NOINPUT exit status (126)
! 
! 				   5/18
! 				   ----
! lib/readline/bind.c
! 	- fixed _rl_get_keyname() so that it properly handles C-\ and outputs
! 	  it as \C-\\ and C-" as \C-\".  This fixes the improper binding
! 	  commands written by `bind -p' that caused weird things to happen
! 	  when people used the output of `bind -p' as a start for their
! 	  own inputrc files
! 	- new function _rl_init_file_error to print error messages encountered
! 	  while parsing the inputrc file
! 	- print out an error message if parsing an inputrc line and no closing
! 	  double quote is found for a key binding
! 
! lib/readline/complete.c
! 	- in rl_complete_internal, if the completion function results in
! 	  multiple matches, but none match up to even the first character, 
! 	  use what the user typed in (which is presumably a glob pattern
! 	  that expanded into multiple files) as matches[0].  This makes
! 	  things like show-all-if-ambiguous work right, too
! 
! oslib.c
! 	- if we are providing our own version of getenv(), provide a function
! 	  _getenv() as well, which just calls getenv()
! 
! builtins/ulimit.def
! 	- #define _KERNEL before including <sys/resource.h> if HPUX is
! 	  defined.  This makes the full set of limits available on hpux
! 	  version 8 and above
! 
! bashline.c
! 	- new function, enable_hostname_completion, sets up readline to
! 	  perform or not perform hostname completion.  Hostname completion
! 	  is on by default.
! 	- don't attempt hostname completion in attempt_shell_completion()
! 	  unless perform_hostname_completion is set
! 
! builtins/shopt.def
! 	- add a `set_func' member to the shopt options structure, to provide
! 	  a hook for those variables that require a little more than just
! 	  toggling a variable on or off
! 	- new shopt variable `hostcomplete', turns hostname completion on and
! 	  off
! 
! doc/{bash.{1,html},features.texi}
! 	- added description of new shopt `hostcomplete' variable
! 
! 				   5/21
! 				   ----
! sig.c
! 	- don't try to save the shell history in termination_unwind_protect
! 	  if we're dying due to SIGABRT
! 
! bashhist.c
! 	- new functions: last_history_entry (static), last_history_line
! 
! bashhist.h
! 	- extern declarations for new functions in bashhist.c
! 
! error.c
! 	- have programming_error() report the last command in the history
! 	  before aborting
! 
! builtins/fc.def
! 	- if the editor returns a non-zero exit status when using `fc -e',
! 	  return immediately without trying to execute the commands, as
! 	  per Posix.2, 5.12.2
! 	- when using `fc -s', echo the command to be executed to stderr,
! 	  not stdout
! 
! lib/readline/terminal.c
! 	- new file, with all code related to termcap/terminfo
! 
! lib/readline/{readline,rltty,display,util}.c
! 	- moved functions dealing with termcap to terminal.c
! 
! lib/readline/readline.c
! 	- readline_initialize_everything now calls _rl_enable_meta_key()
! 	  to turn on the meta key, based on the value of _rl_enable_meta
! 	  (on by default)
! 
! lib/readline/rltty.c
! 	- do not enable and disable the meta key each time readline is
! 	  called; do it once at initialization
! 
! 				   5/23
! 				   ----
! bashhist.c
! 	- when `hist_verify' is set, call re_edit with the expanded line,
! 	  not the original one, and do not print the results of the
! 	  expansion before re-editing
! 
! 				   5/24
! 				   ----
! support/config.guess
! 	- recognize linux/sparc
! 
! configure.in
! 	- don't use GNU malloc on linux/sparc
! 
! variables.c
! 	- initialize a new $MACHTYPE variable to the value of MACHTYPE as
! 	  set by autoconf
! 
! doc/{bash.{1,html},features.texi}
! 	- documented $MACHTYPE
! 
! 				   5/30
! 				   ----
! builtins/ulimit.def
! 	- allow the max vm size to be set via setrlimit() if RLIMIT_VMEM
! 	  is defined
! 
! 				   5/31
! 				   ----
! shell.h
! 	- changed EX_USAGE to 258, EX_BADUSAGE is now 2
! 	- added a number of execution failure statuses, so that builtins
! 	  can indicate various failures.  All are greater than 256, so
! 	  they cannot be returned by other utilities
! 
! execute_cmd.c
! 	- new function, builtin_status(), to translate the new return
! 	  status codes to something the shell can export
! 	- changed execute_simple_command to call builtin_status after
! 	  execute_builtin_or_function to translate error codes if a
! 	  builtin is invoked.  If a function or regular builtin is
! 	  invoked, all return values greater than EX_SHERRBASE get
! 	  translated to EXECUTION_FAILURE, with the exception that
! 	  EX_USAGE gets translated to EX_BADUSAGE.  If a special
! 	  builtin failed with a status > EX_SHERRBASE, special_builtin_failed
! 	  is set to cause the shell to exit in POSIX mode
! 	- changed execute_builtin_or_function to return EX_REDIRFAIL if
! 	  redirections fail
! 	- changed execute_subshell_builtin_or_function to translate
! 	  EX_USAGE to EX_BADUSAGE if a builtin is executed
! 	- set this_command_name to NULL in execute_for_command before binding
! 	  each member of the word list to the loop variable, to avoid
! 	  garbled error messages if the variable has the integer attribute
! 
! builtins/{set,unset}.def
! 	- return EX_USAGE instead of EXECUTION_FAILURE if a bad option is
! 	  supplied
! 
! builtins/source.def
! 	- return EX_USAGE instead of EXECUTION_FAILURE if the required
! 	  filename argument is missing
! 
! builtins/setattr.def
! 	- return EX_BADASSIGN if any assignment statements given as arguments
! 	  to readonly, export, etc. return failures (assignment to
! 	  non-identifier, assignment to readonly variable)
! 
! builtins/declare.def
! 	- don't allow `declare var=value' to assign value to a readonly
! 	  variable
! 
! lib/readline/rldefs.h
! 	- include <stdarg.h> if we're going to be using stdarg instead of
! 	  varargs
! 
! lib/readline/display.c
! 	- added `stdarg' version of rl_message
! 
! lib/readline/readline.h
! 	- changed extern declaration for rl_message to be in ANSI-C format
! 	  if __STDC__ is defined and we're using stdarg
! 
! variables.c
! 	- make sure this_command_name is set to null before calling
! 	  make_variable_value in assign_array_var_from_string so any
! 	  error messages are not garbled
! 
! 				    6/2
! 				    ---
! builtins/common.c
! 	- don't execute the command in parse_and_execute if -n has been
! 	  enabled and the shell is not interactive
! 	- include flags.h for read_but_dont_execute
! 
! [bash-2.0-alpha3 released]
! 
! 				    6/5
! 				    ---
! subst.c
! 	- array_length_reference and parameter_brace_expand_length now
! 	  return -1 on errors
! 	- parameter_brace_expand now returns &expand_param_error if
! 	  paramter_brace_expand_length returns something < 0
! 
! variables.c
! 	- assign_in_env now checks for assignments to readonly shell
! 	  variables and disallows them
! 
! 				    6/6
! 				    ---
! xmalloc.c
! 	- only do pointer arithmetic on pointers cast to (char *), since
! 	  it's not required that compilers support arithmetic on void *
! 
! shell.c
! 	- make sure <sys/socket.h> is included with the same conditions
! 	  used to call getpeername(2) in isnetconn()
! 
! parse.y
! 	- added a new function, paren_match, to parse the contents of $(...)
! 	  constructs.  This function correctly handles embedded quoted
! 	  strings, embedded command substitutions, embedded command
! 	  substitutions with embedded quoted strings, etc.  The implementation
! 	  is much closer to that described in POSIX.2, section 3.6.3.
! 	- changed read_token_word to call paren_match where appropriate
! 
! subst.c
! 	- rewrote extract_delimited_string so that it correctly understands
! 	  quoted strings inside command substitutions, a la paren_match
! 	  in parse.y.  Corrected the description of the function's output
! 	  in the code.  extract_delimited_string is now very recursive, and
! 	  does not try to do everything in one pass without recursion
! 
! 				    6/7
! 				    ---
! test.c
! 	- fixed three_arguments() to test the second argument for a valid
! 	  binary operator before checking whether or not the first argument
! 	  is `!'.  This is what POSIX.2 says to do.
! 
! lib/malloc/malloc.c
! 	- don't compile in the memory scrambling code (#define MEMSCRAMBLE)
! 	  if NO_MEMSCRAMBLE is defined.
! 
! configure.in
! 	- define NO_MEMSCRAMBLE in LOCAL_CFLAGS for SCO 3.2v[45]
! 
! 				    6/9
! 				    ---
! parse.y
! 	- renamed paren_match to parse_matched_pair
! 	- call parse_matched_pair to parse <(...) and >(...) constructs,
! 	  since those should be treated the same as $(...) for the purposes
! 	  of matching parens and skipping embedded quoted strings
! 
! 				   6/13
! 				   ----
! parse.y
! 	- augmented parse_matched_pair
! 		o fixed up backslash quoting and CTLESC handling after
! 		  backslashes
! 		o match pairs of ${...} and $[...] inside double-quoted
! 		  strings or `` strings
! 		o keep track of line number quoted string starts on for
! 		  better error messages
! 		o push and pop delimiters when parsing quoted strings
! 		  inside $(...), ${...}, and $[...] for use by the
! 		  history code
! 		o set EOF_Reached to 1 if we get an EOF before finding the
! 		  match closer
! 	- rewrote read_token_word from scratch to use parse_matched_pair:
! 		o shell quote characters use parse_matched_pair to find
! 		  the matching quote
! 		o fixed up backslash parsing code
! 		o compound array assignments use parse_matched_pair
! 		o corrected all_digits and dollar_present computations, so,
! 		  for instance, 2''>/dev/null is no longer accepted as
! 		  identical to 2>/dev/null
! 		o converted ${...} parsing to use parse_matched_pair
! 		o removed printing of error messages about unmatched quotes;
! 		  now handled by parse_matched_pair
! 		o converted $'...' and $"..." to use parse_matched_pair
! 		o removed all of the delimited_xxx and dollar_xxx variables
! 		  and embedded_quoted_string
! 	- modified report_syntax_error to regularize error messages:
! 		o non-interactive shells and interactive shells running
! 		  scripts with `.' now always report line numbers
! 		o unexpected EOF is always reported when EOF_Reached is true
! 		o non-interactive shells no longer duplicate the script name
! 		  in error messages (e.g., `./z3: ./z3: line 3: syntax error')
! 
! bashline.c
! 	- make sure `newnames' is freed in _ignore_completion_names
! 
! lib/readline/complete.c
! 	- don't insert the first match on TAB completion in
! 	  rl_complete_internal() if matches[0] is the empty string --
! 	  that will overwrite whatever the user has typed, if dequoting
! 	  what the user typed results in the empty string
! 
! execute_cmd.c
! 	- include <limits.h> if HAVE_LIMITS_H is defined for ARG_MAX
! 	- only put the special environment variable for GNU getopt into
! 	  the environment if ARG_MAX exceeds 10240
! 
! subst.c
! 	- rewrote extract_dollar_brace_string so that it fully obeys
! 	  the POSIX.2 rules for finding the closing `}' and uses
! 	  skip_{single,double}_quoted rather than trying to do it with
! 	  inline delimiters
! 	- removed the INC_NEST and DEC_NEST defines
! 
! 				   6/14
! 				   ----
! jobs.c
! 	- don't print status messages for background jobs that complete
! 	  successfully when running shell scripts
! 
! builtins/shopt.def
! 	- when using shopt -o as a synonym for set -o, make sure $SHELLOPTS
! 	  is updated
! 	- make sure to update $SHELLOPTS when using shopt to set or unset
! 	  interactive comments
! 
! execute_cmd.c
! 	- fixed find_in_path_element to not return non-executable files
! 	  when FS_EXEC_PREFERRED is one of the flags, after saving such
! 	  a file as file_to_lose_on (fix from william@nscs.fast.net)
! 
! 				   6/17
! 				   ----
! lib/readline/complete.c
! 	- after printing possible completions, all lines of a multi-line
! 	  prompt are redisplayed using rl_forced_update_display()
! 
! subst.c
! 	- in expand_word_internal, only do tilde expansion on words where
! 	  (flags & (W_ASSIGNMENT|W_QUOTED)) == W_ASSIGNMENT (unquoted
! 	  assignment statements) and contain unquoted `=~' or `:~', and
! 	  only if posixly_correct is off.  POSIX.2 says that only the
! 	  assignments preceding the command name should be tilde-expanded.
! 
! 				   6/18
! 				   ----
! support/config.guess
! 	- recognize the new Pyramid DC-OSx as `mips-pyramid-sysv4'
! 
! configure.in
! 	- set LOCAL_CFLAGS to -Xa for mips-pyramid-sysv4 as per
! 	  Peter Chubb
! 
! subst.c
! 	- variable assignment errors when there is not a command name
! 	  after the assignments now causes a non-interactive shell to 
! 	  exit in POSIX.2 mode
! 
! execute_cmd.c
! 	- if the iteration variable in a for statement is a read-only
! 	  variable, a variable assignment error occurs.  This causes
! 	  non-interactive shells to exit in posix mode, and a failure
! 	  status to be returned for other non-interactive shells and
! 	  interactive shells
! 	- if the selection variable in a select statement is a read-only
! 	  variable, a variable assignment error occurs, with the same
! 	  consequences as a for statement variable assignment error
! 
! doc/bashref.*
! 	- renamed features.* to bashref.*, since that more accurately
! 	  reflects the current contents
! 
! 				   6/19
! 				   ----
! test.c
! 	- changed three_arguments() to do one-argument tests on $1 and
! 	  $3 and return the appropriate values if -a or -o is given as
! 	  the second argument
! 	- changed three_arguments() to perform a one-argument test on
! 	  $2 if $1 == '(' and $3 == ')' and return that result
! 	- make sure test_stat translates /dev/fd/xx to DEV_FD_PREFIX/xx
! 	  so /dev/fd/0 always means the same thing, even on linux,
! 	  which uses /proc/self/fd
! 
! aclocal.m4
! 	- added a check for libncurses in BASH_CHECK_LIB_TERMCAP
! 
! configure.in
! 	- added an initial message saying we're configuring for bash-2.0
! 
! lib/glob/fnmatch.c
! 	- made a small change to fnmatch() to fix a bug matching patterns
! 	  with multiple consecutive `*'s
! 
! 				   6/20
! 				   ----
! parse.y
! 	- inhibit history expansion when calling pre_process_line() from
! 	  shell_getc() if the current delimiter is a single quote, even
! 	  if we're on a different line than the opening quote
! 	- make sure read_a_line prints a prompt if we're interactive and
! 	  not using readline, and make sure we call clearerr() if we
! 	  get EOF when interactive and not using readline
! 
! bashhist.c
! 	- new function history_expansion_p(char *) returns 1 if the string
! 	  passed contains the history expansion or history substitution
! 	  characters
! 	- pre_process_line() now calls history_expansion_p and calls
! 	  the history expansion code only if that returns 1
! 
! 				   6/26
! 				   ----
! lib/readline/isearch.c
! 	- swap the behavior of ^J and ^M when i-searching.  ^J now terminates
! 	  the search without accepting the line.  ^M terminates the search
! 	  and accepts the line, executing the command
! 
! examples/loadables/sprintf.c
! 	- new `sprintf' builtin: sprintf var format [args...]
! 
! lib/readline/readline.c
! 	- added a line in _rl_dispatch that sets _rl_suppress_redisplay if
! 	  the function is rl_insert and there is input available
! 
! 				   6/27
! 				   ----
! builtins/getopts.def
! 	- new function, getopts_bind_variable(), used when assigning a value
! 	  to the user-supplied variable passed to getopts().  It makes sure
! 	  that that variable name is legal and prints an error message if it
! 	  is not
! 
! builtins/getopt.c
! 	- don't increment sh_optind until after we've checked whether or not
! 	  the current option character appears in the list of options passed
! 	  to getopts by the user
! 
! 				   6/28
! 				   ----
! variables.c
! 	- added a new parameter to print_var_value: QUOTE.  If it's non-zero
! 	  and the variable's value contains shell metacharacters, quote the
! 	  value so it can be read back in
! 
! variables.h
! 	- changed extern declaration for print_var_value
! 
! siglist.h
! 	- if SYS_SIGLIST_DECLARED is not defined, but HAVE_UNDER_SYS_SIGLIST
! 	  is, only declare sys_siglist as extern char *sys_siglist[] if
! 	  sys_siglist is not `#define'd
! 
! parse.y
! 	- make sure a reserved word is acceptable before returning `}' as
! 	  a token from special_case_tokens, even if the token read so far
! 	  is "}"
! 	- make reset_parser set allow_open_brace to 0
! 
! 				    7/1
! 				    ---
! test.c
! 	- fixed binop to not try to read s[3] if s[2] == '\0'.  There are
! 	  no one-character binary operators that begin with `-'
! 
! variables.c
! 	- fixed kill_all_local_variables to do nothing if variable_context
! 	  is >= local_variable_stack_size (indicating that we do have some
! 	  local variables, but not at this level of function nesting, and
! 	  we are beyond the end of the array allocated the last time we
! 	  had local variables)
! 
! 				    7/2
! 				    ---
! execute_cmd.c
! 	- non-interactive shells in posix mode should exit if the variable
! 	  in a for command is not a valid identifier.  This should really
! 	  be caught by the parser
! 	- non-interactive shells in posix mode should exit if a function
! 	  name is not a valid identifier.  This should also be caught by
! 	  the parser
! 
! 				    7/3
! 				    ---
! jobs.c
! 	- non-interactive shells should ignore stopped children, so
! 	  waitchld() should set waitpid_flags to WUNTRACED only if the
! 	  shell is interactive and it's not a subshell environment
! 
! lib/readline/signals.c
! 	- if not being compiled as part of the shell, readline should
! 	  catch SIGTERM and clean up
! 
! shell.c
! 	- change to isnetconn: on Solaris 2.5, getpeername() can return
! 	  EINVAL rather than ENOTSOCK if the fd passed as the first
! 	  argument is not a socket
! 
! 				    7/5
! 				    ---
! lib/readline/complete.c
! 	- new variable, available to library users, to inhibit completion
! 	  and cause the completion character to be inserted into the
! 	  line with self-insert: rl_inhibit_completion.  Set to 0 by default.
! 
! lib/readline/readline.h
! 	- extern declaration for rl_inhibit_completion
! 
! lib/readline/doc/rltech.texinfo
! 	- documented rl_inhibit_completion
! 
! lib/readline/bind.c
! 	- new readline user variable: disable-completion.  This provides
! 	  users a way to toggle the value of rl_inhibit_completion
! 
! doc/{bash.{1,html},readline.3}, lib/readline/doc/rluser.texinfo
! 	- documented disable-completion variable
! 
! lib/readline/doc/Makefile
! 	- added `html' target to create html from rlman.texinfo and
! 	  hist.texinfo
! 
! 				    7/8
! 				    ---
! builtins/cd.def
! 	- only try cd spelling correction if the shell is currently
! 	  interactive, regardless of value of `cdspell' option
! 
! lib/posixheaders/alloca.h
! 	- AIX 4.2 needs `#pragma alloca' if gcc is not being used
! 
! 				    7/9
! 				    ---
! builtins/getopts.def
! 	- return EXECUTION_FAILURE from getopts if it's trying to assign
! 	  to a read-only variable
! 	- reset sh_badopt to zero in getopts_reset()
! 
! builtins/getopt.c
! 	- new variable, sh_badopt, set to 1 if we find an illegal option
! 	- do the increment of sh_optind if sh_badopt is non-zero and we're
! 	  at the end of the option string at the beginning of sh_getopt().
! 	  The increment is deferred until the next call so $OPTIND is
! 	  correct
! 
! builtins/getopt.h
! 	- extern declaration of sh_badopt
! 
! 				   7/10
! 				   ----
! Makefile.in
! 	- don't pass ALLOCA_SOURCE or ALLOCA_OBJECT to the make in lib/malloc
! 	- don't make libmalloc.a depend on ALLOCA_DEP -- it causes some
! 	  compilers to build alloca.o in the top directory, and if ALLOCA
! 	  is not defined, makes the malloc library depend on a directory
! 
! aclocal.m4
! 	- some small changes to make the output look better
! 
! memalloc.h
! 	- made some small changes suggested by the autoconf documentation
! 
! 				   7/11
! 				   ----
! parse.y
! 	- swapped meanings of \h and \H in prompt_string_decode for
! 	  bash-1.14.6 compatibility
! 
! doc/{bash.{1,html},bashref.texi}
! 	- updated prompt string decoding section with swap of \h and \H
! 
! general.c
! 	- print_timeval and print_time_in_hz now accept a FILE * as the
! 	  first argument, so `times' can print to stdout while `time'
! 	  prints to stderr
! 
! execute_cmd.c
! 	- changed time_command to print the timing statistics to stderr
! 
! builtins/times.def
! 	- added the FILE * argument to the calls to print_timeval and
! 	  print_time_in_hz
! 
! support/texi2html
! 	- upgraded to version 1.50
! 
! error.c
! 	- include bashhist.h if HISTORY is defined for declarations of
! 	  last_history_line() and remember_on_history
! 
! lib/glob/glob.c
! 	- add a `#pragma alloca' as the first thing in the file if we're
! 	  not using gcc and _AIX is defined
! 
! lib/posixheaders/memalloc.h
! 	- remove the `#pragma alloca' stuff; it is done in the C source
! 	  files now, to avoid problems with other AIX header file
! 	  declarations
! 
! 				   7/12
! 				   ----
! lib/readline/rltty.c
! 	- some changes to work around AIX 4.2 bugs (sometimes OPOST is unset
! 	  in termios, sometimes FLUSHO is inexplicably set in termios, etc.)
! 
! 				   7/15
! 				   ----
! lib/readline/rltty.c
! 	- make SETATTR use TCSADRAIN on POSIX machines.  This setting is
! 	  supposed to be used for changes that affect output
! 
! [bash-2.0-alpha4 released]
! 
! 				   7/16
! 				   ----
! trap.c
! 	- changed reset_or_restore_signal_handlers to honor traps before
! 	  special signals, so that `trap "" 2' works right and causes
! 	  children to ignore SIGINT
! 
! locale.c
! 	- added lc_all variable to track the value of LC_ALL
! 	- added new functions: set_default_locale_vars, set_locale_var,
! 	  set_lang, get_locale_var, removed get_current_messages_locale
! 
! subst.h
! 	- added extern declaration for sv_locale
! 
! subst.c
! 	- LC_ALL, LC_CTYPE, LC_MESSAGES, and LANG are now special variables;
! 	  sv_locale() is called when they are assigned a value
! 
! shell.c
! 	- call set_default_locale_vars after initializing the shell variables
! 	  in main(), so LC_CTYPE and LC_MESSAGES (if present) have values
! 	- shell.c does not need to include <locale.h>
! 
! general.c
! 	- changed print_timeval and print_time_in_hz to format their output
! 	  as Posix.2 specifies for `time -p' if the new POSIX_TIME argument
! 	  is non-zero
! 
! parse.y
! 	- new grammar production: timespec, to handle `time' and `time -p'
! 	- change to special_case_tokens so that -p after `time' returns
! 	  TIMEOPT
! 
! execute_cmd.c
! 	- set posix_time in time_command if the command's flags include
! 	  CMD_TIME_POSIX
! 	- call print_timeval and print_time_in_hz with posix_time as
! 	  the new third argument
! 	- use a space to separate the word (`real') and the time if we're
! 	  in posix mode.  This is what POSIX.2 defines for `time -p'
! 
! builtins/times.def
! 	- call print_timeval and print_time_in_hz with 0 as the new third
! 	  argument
! 
! command.h
! 	- new flag: CMD_TIME_POSIX, used to handle `time -p'
! 
! doc/{bash.{1,html},bashref.texi}
! 	- documented `time -p'
! 
! 				   7/17
! 				   ----
! support/mkversion.c
! 	- include `config.h' before any other include files
! 
! parse.y
! 	- initialize was_dollar to 0 in parse_matched_pair
! 
! configure.in
! 	- removed duplicate check for <sys/file.h> from call to
! 	  AC_HAVE_HEADERS
! 
! sig.c
! 	- include siglist.h so we can find out if it defines HAVE_SYS_SIGLIST
! 
! siglist.h
! 	- define HAVE_SYS_SIGLIST if we end up defining sys_siglist as
! 	  _sys_siglist (Solaris 2.[45])
! 
! siglist.c
! 	- include "siglist.h" before testing whether or not HAVE_SYS_SIGLIST
! 	  is defined; it may be defined in there (Solaris 2.[45])
! 
! 				   7/19
! 				   ----
! examples/misc/alias-conv.sh
! 	- updated, now uses code from examples/functions/csh-compat to do
! 	  the alias conversion, uses `command' builtin in functions it
! 	  creates, does some substitution of csh special variables to
! 	  bash equivalents
! 
! examples/misc/cshtobash
! 	- a more ambitious script that attempts to convert csh aliases,
! 	  environment variables, and local variables to bash equivalents
! 
! 				   7/22
! 				   ----
! bashline.c
! 	- added `:' to the set of completion word break characters so that
! 	  individual directories in $PATH assignments can be completed
! 
! aclocal.m4
! 	- added a new macro, BASH_CC_WORKS, that aborts configuration if
! 	  ${CC} can't compile a simple program successfully
! 
! configure.in
! 	- call BASH_CC_WORKS before doing anything else
! 
! 				   7/23
! 				   ----
! execute_cmd.c
! 	- fixed select_query to print the prompt ($PS3) to stderr
! 
! support/bashbug.sh
! 	- workaround for bug in SunOS 5.x /bin/sh that causes it to
! 	  not ignore interrupts while waiting for a foreground process
! 	  to exit
! 
! 				   7/24
! 				   ----
! general.c
! 	- added new functions to decompose `timeval's and `clock_t's into
! 	  seconds and thousandths of seconds:  timeval_to_secs and
! 	  clock_t_to_secs
! 	- changed print_timeval and print_time_in_hz to call timeval_to_secs
! 	  and clock_t_to_secs, respectively
! 	- removed no-longer-used third argument for print_timeval and
! 	  print_time_in_hz -- `time' output is now done in execute_cmd.c
! 
! general.h
! 	- new extern declarations for timeval_to_secs and clock_t_to_secs
! 
! builtins/times.def
! 	- changed calls to print_timeval and print_time_in_hz, removing the
! 	  no-longer-used third argument
! 
! execute_cmd.c
! 	- changed the way time_command prints its output:  it now interprets
! 	  a format string, replacing several escape sequences prefixed with
! 	  a `%' with the real, user, and system times.  There are options in
! 	  the format string to ask for the `long' format that `times' uses
! 	  as well as to specify the number of places after the decimal point,
! 	  and whether to output fractional seconds at all
! 	- time_command now uses the value of the `TIMEFORMAT' variable, if
! 	  present, to format the timing output.  This is flexible enough to
! 	  encompass the bash default, posix `time -p', BSD, and SV time
! 	  formats
! 
! 				   7/25
! 				   ----
! Makefile.in
! 	- `make clean' should delete the files listed in $(CREATED_SUPPORT);
! 	  `make mostlyclean' should not
! 
! doc/{bash.{1,html},bashref.texi}
! 	- fixed an error in the description of the effect that setting and
! 	  unsetting GLOBIGNORE has on the setting of the `dotglob' option
! 
! doc/bashref.texi
! 	- updated the section listing the major differences between bash
! 	  and the SVR4.2 shell
! 
! lib/readline/readline.c
! 	- removed the setting of _rl_suppress_redisplay, since it doesn't
! 	  really do anything yet
! 
! oslib.c
! 	- new function get_clk_tck (void), returns the value of _SC_CLK_TCK
! 	  if sysconf(3) is available, otherwise returns the value of
! 	  CLOCKS_PER_SEC (default 60)
! 
! general.c
! 	- moved CLOCKS_PER_SEC defines to oslib.c
! 	- changed clock_t_to_secs to call get_clk_tck once to get the
! 	  right value to use
! 
! externs.h
! 	- extern declaration for get_clk_tck
! 
! execute_cmd.c
! 	- changed print_formatted_time so that a `%' at the end of the string
! 	  is output literally
! 	- changed print_formatted_time to output a newline after the
! 	  translated format string, so it does not need to be included in
! 	  the format
! 	- changed BASH_TIMEFORMAT (the default time format) to have a leading
! 	  newline to match ksh93
! 
! configure.in
! 	- use `shlicc2' on BSD/OS machines
! 
! 				   7/26
! 				   ----
! doc/bash.html
! 	- major overhaul, cleaned up text, corrected some minor HTML errors
! 
! variables.c
! 	- call sv_optind and sv_opterr to initialize the getopts stuff in
! 	  initialize_shell_variables
! 
! 				   7/29
! 				   ----
! shell.c
! 	- don't let maybe_execute_file try to read files that are not
! 	  `regular files'
! 
! 				   7/30
! 				   ----
! parse.y
! 	- cast `string' in yy_string_get() to unsigned char * to avoid
! 	  sign extension bugs.  For example, bash -c $'ls\377who'
! 
! 
! builtins/reserved.def
! 	- add help text for the `time' reserved word
! 	- deleted description of `HISTCONTROL'
! 	- added descriptions for HISTIGNORE, PWD, HOSTNAME, GLOBIGNORE,
! 	  MACHTYPE
! 
! 				   7/31
! 				   ----
! builtins/common.c
! 	- parse_and_execute saves and restores the line number around
! 	  calls, and resets it to 0 when pushing the string onto the
! 	  input stack
! 
! parse.y
! 	- added code that parses `` within a double-quoted string as a
! 	  single word
! 
! 				    8/6
! 				    ---
! configure.in, config.h.in
! 	- look for `textdomain' as well as `gettext' for internationalization
! 
! locale.c
! 	- when LC_MESSAGES is set, call textdomain as well as setlocale
! 	- new variable `default_domain', used to track the value of
! 	  $TEXTDOMAIN
! 
! subst.c	
! 	- call sv_locale when TEXTDOMAIN changes
! 
! 				    8/7
! 				    ---
! error.c
! 	- new function, sys_error(), which prints a formatted string followed
! 	  by a colon and strerror(errno) to stderr
! 
! error.h
! 	- extern declaration for sys_error
! 
! jobs.c, nojobs.c, input.c, execute_cmd.c, subst.c
! 	- changes to use sys_error()
! 
! [many files]
! 	- changes to many of the literal strings in the code for consistency
! 	  and easier potential translation
! 
! 				    8/8
! 				    ---
! parse.y
! 	- new function debug_parser(int) to toggle the value of yydebug
! 	  if YYDEBUG != 0
! 
! 				    8/9
! 				    ---
! oslib.c
! 	- don't use CLOCKS_PER_SEC, just try to get CLK_TCK (60 by default)
! 
! bashline.c
! 	- set saved_history_line_to_use to -1 when it's not going to be used
! 	  rather than 0.  A value of 0 can be confused with the first
! 	  history line
! 
! builtins/evalstring.c
! 	- moved parse_and_execute and auxiliary functions here from
! 	  builtins/common.c
! 
! builtins/evalfile.c
! 	- moved maybe_execute_file here from shell.c
! 
! Makefile.in, builtins/Makefile.in
! 	- changes necessitated by the new files
! 
! 				   8/12
! 				   ----
! builtins/common.c
! 	- fixed an off-by-one bug in single_quote that could make bash
! 	  run off the end of a string if it consisted entirely of single
! 	  quotes
! 
! 				   8/13
! 				   ----
! shell.c
! 	- moved code from main() to a new function: open_shell_script
! 	- don't try to fclose(default_input) if BUFFERED_INPUT is defined
! 	- moved argument binding code out of two places in main() and
! 	  open_shell_script() to a new function: bind_args().  This takes
! 	  an additional argument telling whether to bind starting at $0
! 	  or $1
! 	- moved the code that calls the with_input_from_* functions into
! 	  a new function: set_bash_input
! 	- moved the normal shell command-line option parsing code out of
! 	  main() into a new function: parse_shell_options
! 	- moved the long option parsing code out of main() into a new
! 	  function: parse_long_options()
! 
! general.c
! 	- new function: move_to_high_fd(fd), which tries to move FD to a
! 	  file descriptor close to the allowed maximum, returning the new
! 	  fd and closing the old one (or returning the old one if something
! 	  goes wrong)
! 
! general.h
! 	- new extern declaration for move_to_high_fd
! 
! variables.c
! 	- moved indirection_level_string() here from shell.c
! 
! jobs.c
! 	- change initialize_jobs to use move_to_high_fd() instead of the
! 	  inline code to do the same thing
! 
! 				   8/14
! 				   ----
! lib/readline/readline.c
! 	- add `en_US.ISO8859-1' to the list of legal LANG values that turns
! 	  on readline's 8-bit mode
! 
! 				   8/15
! 				   ----
! builtins/evalfile.c
! 	- combined source_file and maybe_execute_file into a new function
! 	  _evalfile(fname, flags), where the flags select the appropriate
! 	  behavior
! 
! eval.c
! 	- moved the functions that perform the read-eval loop here from
! 	  shell.c
! 
! execute_cmd.c
! 	- changed CPU calculation for printing timing statistics using
! 	  ideas and code from Deven Corzine (deven@ties.org)
! 
! eval.c, builtins/evalstring.c
! 	- make sure we dispose of global_command if set -n is on and the
! 	  shell is not interactive
! 
! 				   8/16
! 				   ----
! variables.c
! 	- make a new array variable, BASH_VERSINFO, with version information:
! 
! 		BASH_VERSINFO[0] = release	(2)
! 		BASH_VERSINFO[1] = version	(00)
! 		BASH_VERSINFO[2] = patch level	(0)
! 		BASH_VERSINFO[3] = build version (1058)
! 		BASH_VERSINFO[4] = release status (beta1)
! 		BASH_VERSINFO[5] = $MACHTYPE	(sparc-sun-sunos4.1.4)
! 
! doc/{bash.{1,html},bashref.texi}
! 	- Documented BASH_VERSINFO
! 
! configure.in, config.h.in
! 	- look for bindtextdomain(), set HAVE_BINDTEXTDOMAIN if found
! 
! subst.c
! 	- call sv_locale if TEXTDOMAINDIR is set or changes
! 
! locale.c
! 	- handle TEXTDOMAINDIR in set_locale_var; call bindtextdomain if
! 	  it is present
! 
! tests/array.tests
! 	- added calls to egrep to filter out BASH_VERSINFO and PIPESTATUS,
! 	  which can vary from system to system
! 
! 				   8/19
! 				   ----
! shell.c
! 	- moved line_buffer_stream from here to oslib.c, made it into a
! 	  replacement for setlinebuf() if that is not available
! 
! externs.h
! 	- extern declaration for setlinebuf()
! 
! lib/readline/input.c
! 	- in rl_gather_tyi, punt if chars_avail < 0 after checking input fd
! 
! 				   8/20
! 				   ----
! builtins/suspend.def
! 	- send SIGSTOP instead of SIGTSTP
! 
! 				   8/21
! 				   ----
! builtins/colon.def
! 	- added true and false as builtins (undocumented)
! 
! CWRU/POSIX.NOTES, doc/bashref.texi
! 	- note that process substitution is not available in posix mode
! 
! bashintl.h
! 	- new header file for internationalization, included by locale.c
! 
! 				   8/22
! 				   ----
! subst.c
! 	- in command_substitute, set istring to NULL before trying to
! 	  make the pipe, so if that fails, the code at error_exit:
! 	  doesn't try to free it
! 
! execute_cmd.c
! 	- when executing a shell script without a leading `#!' internally,
! 	  and the shell is not interactive, close the fd to the script
! 	  we're reading.  If this is called by the exec builtin, the shell
! 	  will not have forked, and the fd will not have been closed, even
! 	  though it's marked close-on-exec
! 	- if subshell_argv is non-null, free its members (except 0) and
! 	  subshell_argv in shell_execve before reassigning it
! 	- dispose of currently_executing_command before jumping back to
! 	  subshell_top_level
! 
! builtins/hash.def
! 	- use a sentinel variable so we only initialize the hash table
! 	  once in initialize_filename_hashing
! 
! shell.c
! 	- don't flush the filename hash table in shell_reinitialize
! 	- free dollar_vars[0] in set_shell_name before assigning it
! 	- don't fetch the current hostname more than once
! 	- don't fetch the current user information more than once unless
! 	  the uid changes
! 
! parse.y
! 	- initialize_bash_input should free bash_input.name if it is
! 	  non-null before zeroing it
! 
! 				   8/23
! 				   ----
! aclocal.m4
! 	- changed BASH_CHECK_SOCKLIB:  if -lsocket is present, check for
! 	  and cache the existence of -lnsl.  Define LIBS appropriately
! 	  based on the values of the cache variables rather than relying
! 	  on the autoconf tests to do it
! 
! 				   8/26
! 				   ----
! parse.y
! 	- fix up yy_readline_get and yy_stream_get to fix the sign
! 	  extension problem
! 
! shell.c
! 	- move the setjmp(top_level) that catches early SIGINTs to the
! 	  first statement in main()
! 
! Makefile.in
! 	- added a `strip' target to strip the binary
! 
! [bash-2.0-beta1 frozen]
! 
! 				   8/27
! 				   ----
! parse.y
! 	- replaced several static state variables with a single flags word:
! 	  parser_state
! 
! 				   8/28
! 				   ----
! parse.y
! 	- in read_token_word, combined the ${...} case with the other
! 	  expansion cases -- the code was identical
! 	- added code to handle ksh-style ((...)) -- equivalent to
! 	  `let "..."'.  In fact, the above construct is translated internally
! 	  into `let "..."', so error messages output by the evaluator
! 	  will contain `let'
! 
! expr.c
! 	- changed evalerror to call internal_error so the name of the
! 	  shell script is prefixed to the message, if necessary
! 
! Makefile.in
! 	- changed RELSTATUS to `beta2'
! 
! tests/{arith,new-exp}.{tests,right}
! 	- changed the expected error message because of the change in format
! 	  of the arithmetic evaluation error messages in expr.c
! 
! builtins/pushd.def
! 	- changed pushd_builtin so `pushd -' is equivalent to `pushd $OLDPWD'
! 
! externs.h
! 	- changed the extern declaration for setlinebuf() to avoid having
! 	  to include stdio.h before externs.h everywhere
! 
! 				   8/29
! 				   ----
! error.c
! 	- new function, parser_error, for use by parts of the parser that
! 	  don't want to call report_syntax_error
! 
! error.h
! 	- extern declaration for parser_error
! 
! parse.y
! 	- changed some parts of the parser to use parser_error
! 	- made the ((...)) code #ifdef'd on DPAREN_ARITHMETIC
! 
! shell.c
! 	- added a line to the --help output saying to use `bashbug' to
! 	  report bugs
! 
! configure.in
! 	- added new option: --enable-dparen-arithmetic; it controls
! 	  the DPAREN_ARITHMETIC define in config.h
! 	- changed $host_os check for SCO to only enable -DWAITPID_BROKEN
! 	  for sco3.2v5; all other SCO versions enable -DMUST_UNBLOCK_CHILD
! 
! config.h.in
! 	- added line for DPAREN_ARITHMETIC, modified by configure
! 
! doc/{bash.{1,html},bashref.texi}
! 	- documented new ((...)) command and new configuration option
! 
! execute_cmd.c
! 	- shell_execve should not try to close default_buffered_input unless
! 	  it is >= 0.  Other code that closes it and deallocates the buffer
! 	  should set default_buffered_input to -1
! 
! 				   8/30
! 				   ----
! configure.in
! 	- more changes to LOCAL_CFLAGS for sco machines
! 
! error.c
! 	- changed parser_error to handle all cases of the shell being
! 	  interactive, not interactive, reading from a script, and reading
! 	  from some other file
! 
! parse.y
! 	- changed report_syntax_error to call parser_error for consistent
! 	  messages
! 
! dispose_cmd.c
! 	- change dispose_command to use programming_error instead of
! 	  report_error
! 
! execute_cmd.c, input.c, general.c
! 	- changed calls to report_error to internal_error, since we don't
! 	  want to possibly exit in any of those cases
! 
! 				    9/3
! 				    ---
! input.c
! 	- changed the `localbuf' type to `unsigned char'
! 
! parse.y
! 	- changed yy_stream_get to use feof to test for end of file when
! 	  not using getc_with_restart
! 
! 				    9/6
! 				    ---
! config.h.top
! 	- added a commented-out define for SYS_BASH_LOGOUT, which is a
! 	  system-wide .bash_logout file, run when a login shell exits
! 	- added /sbin to STANDARD_UTILS_PATH
! 
! builtins/exit.def
! 	- added support for SYS_BASH_LOGOUT
! 
! 				   9/10
! 				   ----
! lib/readline/{{chardefs,histlib}.h,{bind,histexpand,readline,util,vi_mode}.c}
! 	- changed to_upper to _rl_to_upper and to_lower to _rl_to_lower
! 	- changed digit_value to _rl_digit_value
! 	- changed digit_p to _rl_digit_p
! 	- changed uppercase_p and lowercase_p to _rl_uppercase_p and
! 	  _rl_lowercase_p respectively
! 	- changed pure_alphabetic to _rl_pure_alphabetic
! 
! support/zecho.c
! 	- new file, implements a bare-bones echo (no -n, no \-escapes),
! 	  to be used by tests
! 
! tests/rhs-exp.tests
! 	- changed calls to echo to use recho to avoid errors when bash is
! 	  configured with --enable-usg-echo-default
! 
! tests/more-exp.tests
! 	- changed some calls to echo to use zecho to avoid errors when bash
! 	  is configured with --enable-usg-echo-default
! 
! 				   9/11
! 				   ----
! lib/readline/histexpand.c
! 	- fixed a possible off-by-one error in history_expand_internal when
! 	  deciding whether or not to reallocate `result'
! 
! expr.c
! 	- fixed expcond() so that an assignment may be supplied as the
! 	  token after the `?'
! 	- illegal bases now cause an evaluation error
! 	- multiple base specifications now cause an evaluation error
! 
! tests/arith.tests
! 	- added more tests for conditional operator and associativity
! 
! tests/{run-heredoc,heredoc.{tests,right}}
! 	- new set of tests for here-documents
! 
! builtins/common.c
! 	- print out the name returned by get_name_for_error in
! 	  builtin_error()
! 
! subst.c
! 	- set this_command_name to NULL before processing command-line
! 	  assignment statements so arithmetic evaluation errors don't
! 	  print garbage
! 	- according to POSIX.2, echo ${foo?$x} should print the expanded
! 	  value of $x, even when it doesn't expand into anything
! 
! 				   9/12
! 				   ----
! shell.c
! 	- changed the execution of startup files so that $ENV is never
! 	  run by a non-interactive shell and an interactive shell begun
! 	  as `sh' reads and executes $ENV, as posix specifies
! 
! doc/{bash.{1,html},bashref.texi}
! 	- updated description of startup file behavior
! 
! doc/Makefile.in
! 	- make sure references to bashref.texi are preceded by $(srcdir)/
! 	  so we can build the documentation in another directory just by
! 	  typing `make'; e.g. after giving configure the --srcdir option
! 
! subst.c
! 	- change to array_remove_pattern to avoid evaluating the `param'
! 	  part of the ${param#word} spec twice when doing things like
! 	  echo ${A[x=(i+=1)]#${A[y=(i+=2)]}}
! 
! 				   9/13
! 				   ----
! builtins/bashgetopt.c
! 	- fixed a problem with `;' option specifier (optional argument)
! 
! support/config.{sub,guess}
! 	- added cases to recognize CRAY C90 and T90
! 
! builtins/ulimit.def
! 	- rewritten almost from scratch to use internal_getopt and to not
! 	  mask the return value from getrlimit/setrlimit, and to make it
! 	  easier to maintain
! 	- added `-l' option for systems with RLIMIT_MEMLOCK (4.4 BSD)
! 
! doc/{bash.{1,html},bashref.texi}
! 	- documented new `-l' option to `ulimit'
! 
! 				   9/24
! 				   ----
! parse.y
! 	- added `in' to the list of tokens that should not be followed by
! 	  a semicolon when combining history lines
! 	- removed the special-case code in history_delimiting_chars that
! 	  tried to be smart about `()'
! 
! 				   9/25
! 				   ----
! print_cmd.c
! 	- fixes to print_group_command from Andreas Schwab
! 	- rewrote indent() to use a single malloced string for the spaces
! 	  to print, rather than calling cprintf multiple times
! 
! shell.c
! 	- make sure to set the strings in current_user to NULL after freeing
! 	  their contents in uidget().
! 
! parse.y
! 	- make sure decode_prompt_string quotes the values inserted by the
! 	  \w and \W escape sequences using backslashes if the string will be
! 	  expanded later because promptvars is set
! 
! support/mkdirs
! 	- removed leading `^' from regular expressions to be matched by
! 	  `expr' on the advice of meyering@appaloosa.asic.sc.ti.com
! 
! 				   9/26
! 				   ----
! parse.y
! 	- added a few more possible flag values for parser_state
! 	- changed history_delimiting_chars to not add a semicolon after a
! 	  right paren if we're parsing a case statement
! 
! 				   9/27
! 				   ----
! builtins/ulimit.def
! 	- a few minor cleanups
! 
! 				   10/1
! 				   ----
! builtins/trap.def
! 	- make sure first_arg is non-empty before calling signal_object_p()
! 
! [bash-2.0-beta2 frozen]
! 
! 				   10/2
! 				   ----
! bashintl.h
! 	- if we have setlocale(), but don't have a definition for LC_ALL,
! 	  undefine HAVE_SETLOCALE
! 
! configure.in
! 	- set LOCAL_LDFLAGS on AIX 4.2 to allow dynamic loading of builtins
! 
! builtins/enable.def
! 	- use correct flags for AIX 4.2 in dlopen call if _AIX is defined
! 
! examples/loadables/Makefile
! 	- add sample commands for AIX 4.2
! 
! 				   10/3
! 				   ----
! variables.c
! 	- new functions: merge_temporary_env(), merge_builtin_env(), to
! 	  take temporary_env and builtin_env, respectively, and create
! 	  shell variables from them
! 
! variables.h
! 	- new extern declarations for merge_temporary_env() and
! 	  merge_builtin_env()
! 
! execute_cmd.c
! 	- if variable assignments preceds a posix special builtin, and the
! 	  shell is in posix mode, those assignments should persist in the
! 	  shell environment after the builtin completes
! 
! doc/bashref.texi
! 	- modified description of what's changed by posix mode to include
! 	  the persistance of assignment statements preceding special builtins
! 
! doc/mkposix
! 	- new script to create CWRU/POSIX.NOTES directly from the `Bash
! 	  POSIX Mode' node of bashref.texi, like INSTALL is created
! 
! 				   10/4
! 				   ----
! lib/{malloc,glob,readline}/Makefile.in, builtins/Makefile.in
! 	- don't have autoconf substitute LOCAL_CFLAGS into the CFLAGS
! 	  assignment so people on SCO 3.2v[45] can still build with
! 	  NO_MEMSCRAMBLE even when they run `make CFLAGS=...'
! 
! test.c
! 	- renamed eaccess() to test_eaccess() to avoid conflict with SCO
! 
! config.h.bot
! 	- #undef HAVE_GETCWD if GETCWD_BROKEN is defined, so we use the
! 	  replacement in getcwd.c
! 
! general.c
! 	- fixed a small memory leak in full_pathname that occurs if
! 	  getcwd() returns NULL
! 
! oslib.c
! 	- new constant string variable: bash_getcwd_errstr, to use when
! 	  getcwd() returns NULL
! 
! {general,jobs}.c, parse.y, builtins/{cd.def,common.c}
! 	- change calls to getwd() to use getcwd() instead
! 
! general.c, builtins/common.c, builtins/cd.def
! 	- changed error behavior when getcwd() returns NULL to use
! 	  bash_getcwd_errstr, sys_error(), and strerror(errno) where
! 	  appropriate
! 
! sig.c
! 	- change a couple of calls to signal to set_signal_handler
! 
! aclocal.m4
! 	- added definitions of _popen and _pclose to the BASH_FUNC_GETCWD
! 	  macro
! 
! configure.in
! 	- added -DPATH_MAX=1024 to LOCAL_CFLAGS for sco3.2v[45] on the
! 	  advice of <grog@lemis.de>
! 	- removed check for getwd(3)
! 
! externs.h
! 	- removed extern declaration for getwd(), added extern declaration
! 	  for getcwd() if HAVE_GETCWD is not defined
! 
! oslib.c
! 	- removed definition of getwd(); it is no longer used
! 
! lib/readline/rltty.c
! 	- changed SETATTR macro for SCO POSIX systems to call tcsetattr
! 	  with TCSANOW, on advice of <wbader@nacs.fast.net>
! 
! 				   10/7
! 				   ----
! support/mkdirs
! 	- slight change to work around a bug in the HP-UX `expr'
! 
! 				   10/8
! 				   ----
! lib/readline/vi_mode.c
! 	- changes so that the text inserted with an `i' command is available
! 	  to be reinserted with `.'
! 
! examples/functions/autoload.v2
! 	- new implementation: uses arrays, keeps a list of autoloaded
! 	  functions, allows autoloaded functions to be removed, allows
! 	  autoloaded functions to be listed
! 
! execute_cmd.c
! 	- when freeing the members of subshell_argv in shell_execve(), free
! 	  only the members up to subshell_argc
! 
! 				   10/9
! 				   ----
! configure.in
! 	- replaced calls to AC_HAVE_FUNCS with AC_CHECK_FUNCS
! 	- replaced calls to AC_FUNC_CHECK with AC_CHECK_FUNC
! 	- replaced calls to AC_HAVE_HEADERS with AC_CHECK_HEADERS
! 	- added additional code to check for libintl.{a,so} for the
! 	  internationalization functions if bindtextdomain is not found
! 	  in libc
! 	- define HAVE_WAIT3 if AC_FUNC_CHECK(wait3,...) succeeds, rather
! 	  than HAVE_FUNC_WAIT3, which is not used in the source
! 	- added a call to AC_FUNC_STRCOLL to check for the presence of a
! 	  working strcoll(3)
! 
! config.h.in
! 	- removed HAVE_FUNC_WAIT3
! 	- added HAVE_STRCOLL
! 
! variables.c, stringlib.c
! 	- move sort_char_array from variables.c to stringlib.c
! 
! variables.h, externs.h
! 	- move extern declaration of sort_char_array from variables.h to
! 	  externs.h
! 
! variables.c
! 	- don't sort the exported environment, even when we're not in
! 	  posix mode
! 
! stringlib.c
! 	- changed qsort_string_compare to use strcoll(3) if it is available
! 	  (HAVE_STRCOLL is defined).  This means that the results of glob
! 	  expansions are now sorted in the per-locale collation order
! 
! locale.c
! 	- track the value of $LC_COLLATE and call setlocale(LC_COLLATE,...)
! 	  when it changes.  Also, set its default value
! 
! subst.c
! 	- LC_COLLATE is now a special variable; call sv_locale when it is
! 	  assigned to or unset
! 
! lib/readline/util.c
! 	- move compare_strings here from complete.c; renamed it
! 	  _rl_qsort_string_compare; made it use strcoll(3) if it's
! 	  available; made it global so other library files can use it
! 
! lib/readline/complete.c
! 	- use _rl_qsort_string_compare instead of static compare_strings.
! 	  This means that completions are now sorted in a locale-specific
! 	  collation order
! 
! lib/readline/funmap.c
! 	- removed static declaration of qsort_string_compare; qsort now
! 	  uses _rl_qsort_string_compare instead
! 
! oslib.c
! 	- rewrote stricmp, strnicmp; renamed them strcasecmp and
! 	  strncasecmp, since they're only compiled in if HAVE_STRCASECMP
! 	  is not defined
! 
! externs.h
! 	- removed extern declarations of strnicmp, stricmp, replacing them
! 	  with declarations of strcasecmp and strncasecmp if HAVE_STRCASECMP
! 	  is not defined; removed #defines of stricmp and strnicmp to
! 	  strcasecmp and strncasecmp
! 
! trap.c
! 	- changed calls to stricmp to direct calls to strcasecmp
! 
! Makefile.in
! 	- bumped RELSTATUS to `beta3'
! 
! doc/bash.{1,html}
! 	- added mention of LC_COLLATE
! 
! doc/bashref.texi
! 	- removed item about sorting environment from the section on posix
! 	  mode
! 
! 				   10/16
! 				   -----
! subst.c
! 	- fixed array_length_reference to return 0 for an unbound variable
! 	  and 1 for a variable that is not an array
! 
! examples/scripts.v2/cdhist.bash
! 	- package with functions to replace cd and maintain a cd directory
! 	  stack
! 
! examples/scripts.v2/pmtop
! 	- a `poor man's top' for SunOS 4.x and BSD
! 
! examples/scripts.v2/bashrand
! 	- a script to return a random number within a specified range, with
! 	  an optional seed
! 
! examples/scripts/zprintf
! 	- printf(1) replacement that uses gawk to do the output
! 
! doc/{bash.{1,html},bashref.texi}, lib/readline/doc/hsuser.texinfo
! 	- several small corrections
! 
! 				   10/17
! 				   -----
! variables.c
! 	- changed the calls to list_string_with_quotes and then
! 	  expand_words_no_vars in assign_array_var_from_string to a single
! 	  call to expand_string.  This behaves more rationally, and closer
! 	  to ksh93
! 
! subst.c
! 	- commented out list_string_with_quotes -- it is no longer used
! 
! lib/readline/terminal.c
! 	- new function, _rl_set_screen_size(int rows, int cols), to set
! 	  readline's idea of the screen size
! 
! jobs.c, nojobs.c
! 	- make sure that window size changes are propagated back down to
! 	  the readline code, by calling _rl_set_screen_size with the
! 	  new sizes.  This happens when bash gets a SIGWINCH or if
! 	  `checkwinsize' is set with `shopt'
! 
! 				   10/18
! 				   -----
! support/config.guess
! 	- added code to recognize the various NetBSD ports
! 
! lib/readline/signals.c
! 	- don't install a handler for SIGALRM if the containing application
! 	  has installed a handler with SA_RESTART as part of the flags.
! 	  This is in effect, obviously, only for systems with POSIX signals.
! 
! subst.c
! 	- make parameter_brace_expand_length expand variables in a double-
! 	  quoted environment so it takes spaces in the variable value into
! 	  account
! 
! 				   10/21
! 				   -----
! command.h
! 	- flags for possible values of subshell_environment telling what
! 	  caused the subshell
! 
! builtins/command.def
! 	- the `command' builtin should not be setting CMD_NO_FORK at all;
! 	  it doesn't know enough about the execution context to do so
! 
! execute_cmd.c, subst.c
! 	- set subshell_environment to one of the values in command.h rather
! 	  than to `1', so we know what kind of subshell it is (just for
! 	  informational purposes; nothing actually uses this yet)
! 
! 
! 				   10/22
! 				   -----
! execute_cmd.c
! 	- just return EXECUTION_SUCCESS immediately in execute_command_internal
! 	  if read_but_dont_execute is set
! 
! 				   10/23
! 				   -----
! general.c
! 	- fixed check_dev_tty to return immediately if ttyname() returns NULL
! 
! builtins/suspend.def
! 	- SIGSTOP cannot be caught, so there's no reason to try to do so
! 
! examples/loadables/{finfo,pathchk,print}.c
! 	- minor fixes
! 
! pathexp.c
! 	- fix to off-by-one error in setup_ignore_patterns
! 
! jobs.c
! 	- try to set the tty pgrp to our pgrp if we change our pgrp to our
! 	  pid and become a process group leader.  If it doesn't work,
! 	  reset our pgrp to what it was originally and disable job control
! 
! aclocal.m4
! 	- new test, BASH_STRUCT_TERMIO_LDISC, to test for a c_line member
! 	  of struct termio
! 
! config.h.in
! 	- add a new preprocessor variable, TERMIO_LDISC, undefined by default
! 
! configure.in
! 	- call BASH_STRUCT_TERMIO_LDISC after BASH_STRUCT_TERMIOS_LDISC
! 
! 				   10/25
! 				   -----
! lib/readline/terminal.c
! 	- increased the size of the termcap buffers to 4096
! 
! 				   10/29
! 				   -----
! parse.y
! 	- include memalloc.h for uses of alloca that the code in the
! 	  generated bison parser does not catch (e.g., HP-UX 10.10)
! 
! aclocal.m4
! 	- new test, BASH_KERNEL_RLIMIT_CHECK, to check whether a given
! 	  HP-UX machine needs _KERNEL defined for the RLIMIT_* defines in
! 	  <sys/resource.h> (9.05, 10.01 yes, 10.10,10.20 no)
! 
! configure.in
! 	- call BASH_KERNEL_RLIMIT_CHECK if $host_os begins with `hpux'
! 
! config.h.in
! 	- new #undef for RLIMIT_NEEDS_KERNEL
! 
! builtins/ulimit.def
! 	- only define _KERNEL before including <sys/resource.h> if HPUX
! 	  and RLIMIT_NEEDS_KERNEL are both defined
! 
! [bash-2.0-beta3 frozen]
! 
! 				   11/1
! 				   ----
! locale.c
! 	- if setting LC_ALL to a null value (as is done when `unset LC_ALL'
! 	  is run), call setlocale() to set LC_ALL back to default_locale
! 
! lib/readline/readline.c
! 	- moved i18n code from here to nls.c
! 
! lib/readline/Makefile.in, Makefile.in
! 	- new readline library member, nls.c
! 
! lib/readline/nls.c
! 	- new file, with internationalization code from readline.c (such as
! 	  it is)
! 	- updated legal_lang_values to just contain a list of codesets
! 	- added code modified from a diff sent by Ulrich Drepper
! 	  <drepper@cygnus.com> to parse a locale specification and isolate
! 	  and normalize the codeset part, for checking against the values
! 	  in legal_lang_values
! 
! 				   11/4
! 				   ----
! builtins/setattr.def, locale.c, aclocal.m4, oslib.c
! 	- minor cleanups
! 
! 				   11/5
! 				   ----
! lib/readline/complete.c, test.c, trap.c
! 	- more minor cleanups
! 
! 				   11/6
! 				   ----
! parse.y
! 	- added a `flags' parameter to parse_matched_pair, currently unused
! 
! 				   11/7
! 				   ----
! configure.in, config.h.in
! 	- add a check for time_t, defaulting to `long' if it's not
! 	  defined in <sys/types.h>
! 
! builtins/fc.def
! 	- use `time_t *' instead of `long *' in call to time()
! 
! 				   11/8
! 				   ----
! configure.in
! 	- removed check for getpwent in libsun.a; it's not necessary for
! 	  recent versions of irix (irix[56].?)
! 
! 				   11/11
! 				   -----
! test.c
! 	- used `&&' where `||' was needed when testing if HAVE_LSTAT and
! 	  S_IFLNK are both defined
! 
! [bash-2.0-beta3 net release version frozen]
! 
! 				   11/12
! 				   -----
! builtins/getopt.c
! 	- when sh_getopt detects that a required argument is not present,
! 	  set sh_optarg to "" so that getopts does the right thing
! 
! 				   11/15
! 				   -----
! builtins/ulimit.c
! 	- made the default (without -H or -S) report the soft limit and set
! 	  both soft and hard limits (like sh and ksh)
! 
! expr.c
! 	- changed the maximum base in base#num constants to 64, implemented
! 	  just like ksh93
! 
! doc/{bash.{1,html},bashref.texi}
! 	- updated description of ulimit builtin to new behavior when
! 	  neither -H nor -S is supplied
! 	- updated arithmetic evaluation section with new maximum base and
! 	  explanation of how numbers between 10 and 63 are represented
! 
! lib/readline/vi_mode.c
! 	- in rl_vi_done_inserting, don't try to save the text entered while
! 	  in insert mode unless rl_undo_list is non-null (indicating that
! 	  there was actually some text to be saved)
! 
! 				   11/19
! 				   -----
! lib/readline/tcap.h
! 	- new file, for termcap library definitions.  Uses <termcap.h> if
! 	  it is available
! 
! lib/readline/rldefs.h
! 	- remove inclusion of termcap.h; now included in tcap.h
! 
! lib/readline/{terminal,display,readline}.c
! 	- include tcap.h
! 
! lib/readline/Makefile.in
! 	- update dependencies to include tcap.h
! 
! 				   11/21
! 				   -----
! lib/readline/complete.c
! 	- broke the code that computes the lcd of the list of completion
! 	  matches out into a separate function, compute_lcd_of_matches()
! 
! lib/readline/complete.c
! 	- call compute_lcd_of_matches after calling the application-specific
! 	  completion ignore function, since it may have eliminated some
! 	  names from the match list
! 
! builtins/cd.def
! 	- replaced instances of MAXNAMLEN in the spelling correction code
! 	  with PATH_MAX
! 
! lib/readline/terminal.c
! 	- new termcap capabilities: kh (sent by Home key) and kH (sent by
! 	  End key) automatically bound to beginning-of-line and end-of-line
! 	  respectively in emacs_standard and vi_movement maps
! 
! mailcheck.c
! 	- fix to remember_mail_dates so any message following the
! 	  filename is saved correctly
! 
! 				   11/22
! 				   -----
! lib/readline/bind.c
! 	- fixed extern declaration of _rl_parsing_coditionalized_out
! 	  to match declaration in readline.c
! 
! 				   11/25
! 				   -----
! doc/{bash.{1,html},bashref.texi}
! 	- fixed a gross documentation error in the description of
! 	  ${parameter:offset:length} (offset and length were transposed)
! 	- slight changes to the description of output redirection
! 
! subst.c
! 	- new function, quoted_substring, to return substrings of variables
! 	  when the expression is within double quotes and the value has
! 	  CTLESC characters embedded within it.  Called by
! 	  parameter_brace_substring
! 	- get_var_and_type should return VT_POSPARMS if `*' is passed as
! 	  the variable name
! 	- added a new first parameter for pos_params -- the variable name
! 	- changed pos_params to obey the rules for "$*" wrt using the
! 	  first character of IFS as the separator in the result
! 	- if an unquoted $* or $@ is expanded, call quote_escapes on the
! 	  result to protect any special characters from inadvertently
! 	  causing quoting
! 
! 				   12/3
! 				   ----
! builtins/ulimit.def
! 	- corrected a misspelling of `unlimited'
! 	- added support for linux RLIMIT_AS resource limit for -v option
! 	  and changed the block multiplier to 1024 if we have RLIMIT_VMEM
! 	  or RLIMIT_AS
! 
! 				   12/5
! 				   ----
! lib/readline/readline.c
! 	- fix rl_insert to handle a count of exactly 1024
! 
! shell.c
! 	- new function: unbind_args(), which removes all the positional
! 	  parameters.  Just calls remember_args(NULL, 1)
! 
! execute_cmd.c
! 	- call unbind_args when executing a subshell, after setting up
! 	  subshell_argX
! 
! bashintl.h
! 	- include <libintl.h> if HAVE_LIBINTL_H defined
! 
! config.h.in
! 	- add HAVE_LIBINTL_H define
! 
! configure.in
! 	- add call to AC_CHECK_HEADERS for libintl.h
! 
! doc/Makefile.in
! 	- added infodir and various mandir defines for completeness
! 
! Makefile.in
! 	- changed some of the *dir defines to use the autoconf values
! 	  (e.g., bindir = @bindir@)
! 	- changed manroot to mandir, removed old mandir and manext variables
! 	- added `manpfx' variable; should be either `man' or `cat'
! 
! 				   12/6
! 				   ----
! lib/readline/readline.c
! 	- fixed rl_digit_loop so it once again displays the argument count
! 	  as it's being entered (added calls to _rl_save_prompt and
! 	  _rl_restore_prompt)
! 
! 				   12/7
! 				   ----
! support/config.guess
! 	- recognize netbsd/vax
! 	- recognize openbsd on all supported platforms
! 	- recognize tenon's machten running on powerpc and macintosh
! 
! 				   12/9
! 				   ----
! support/config.guess
! 	- added all sorts of systems from config.guess distributed with
! 	  autoconf-2.12
! 
! 				   12/10
! 				   -----
! subst.c
! 	- new function quoted_strchr(); does the same thing as strchr but
! 	  honors shell backslash and CTLESC quoting conventions
! 	- parameter_brace_patsub now calls quoted_strchr
! 
! 				   12/11
! 				   -----
! shell.c
! 	- if the shell is named `-su', run the normal login shell startup
! 	  files, even if the shell is not interactive.  This handles the
! 	  case of `su - username -c command' compatibly
! 
! lib/readline/readline.c
! 	- minor change to rl_digit_loop so that M-- and M--1 are equivalent,
! 	  as the prompt for digit arguments has always implied
! 
! lib/malloc/malloc.c
! 	- added definitions of calloc() and cfree(), compiled in unless
! 	  NO_CALLOC is defined to cpp
! 
! 
! 				   12/16
! 				   -----
! parse.y
! 	- protect uses of history_expansion_inhibited with #ifdef
! 	  BANG_HISTORY
! 
! [bash-2.0-release candidate frozen]
! 
! builtins/common.c
! 	- changed backslash_quote to quote a tilde if it's the first
! 	  character in the string
! 
! 				   12/17
! 				   -----
! aclocal.m4
! 	- changed BASH_CC_WORKS to provide a cross-compiling default for
! 	  better error messages
! 
! configure.in
! 	- generated configure using autoconf-2.12
! 	- changed the default value of CFLAGS to `-g -O2'
! 
! 				   12/18
! 				   -----
! aclocal.m4
! 	- look for /var/spool/mail before /usr/spool/mail when checking
! 	  for the default mail directory
! 
! jobs.c, builtins/shopt.def
! 	- fixed a couple of `macro replacement within a string literal'
! 	  problems
! 
! Makefile.in
! 	- removed `realclean' target
! 
! shell.c
! 	- changed the first line ouput by bash --version to conform to
! 	  the latest GNU coding standards (replace space between version
! 	  and machtype with a hyphen)
! 
! 				   12/19
! 				   -----
! execute_cmd.c
! 	- when looking at the debug trap in execute_function and
! 	  execute_command_internal, make sure it's trapped and not
! 	  ignored before trying to save the value of the trap string
! 
! 				   12/20
! 				   -----
! trap.c
! 	- changed set_signal and ignore_signal to handle EXIT_TRAP and
! 	  DEBUG_TRAP specially, so we don't try to fetch signal handlers
! 	  or do other unnecessary things
! 
! 				   12/22
! 				   -----
! builtins/ulimit.def
! 	- if the current euid is not 0, and we're trying to set the hard
! 	  limit of a resource to RLIM_INFINITY, set it to the current hard
! 	  limit to avoid error messages
! 
! builtins/read.def
! 	- fix for bug that caused core dump if line read had leading white
! 	  space and IFS was set to ''
  
! [bash-2.0-release frozen]
--- 1,1719 ----
! 				12/23/1996
! 				----------
! [bash-2.0 released]
  
! 				   12/27
! 				   -----
! configure.in
! 	- don't automatically use GNU malloc on FreeBSD, the builtin one
! 	  is supposed to be better (but doesn't have the debugging hooks)
  
! builtins/exec.def
! 	- check that full_pathname(command) doesn't return NULL because of
! 	  inaccessible parent directories
  
! support/config.sub
! 	- recognize OpenBSD
  
! execute_cmd.c
! 	- broke the code that opens a file for output redirection when in
! 	  noclobber mode out into a separate function: noclobber_open().
! 	  This tries to avoid race conditions and file replacement between
! 	  stat(2) and open(2)
  
  subst.c
! 	- make sure pat_subst does not run off the end of its return
! 	  string when copying the unmatched portion of the input string
  
! 				   12/30
! 				   -----
! doc/Makefile.in
! 	- don't install readline.3 by default
  
! lib/tilde/tilde.c
! 	- removed an unnecessary check for string[i] being non-null in
! 	  tilde_find_suffix
  
! 				   12/31
! 				   -----
! support/config.{sub,guess}
! 	- merged in changes from config.sub in autoconf-2.12 distribution
  
! lib/readline/readline.c
! 	- in rl_newline, only call _rl_vi_done_inserting and _rl_vi_reset_last
! 	  if readline is currently in vi mode
  
! lib/readline/display.c
! 	- corrected a misuse of inv_lbreaks where vis_lbreaks was wanted in
! 	  the code that decides whether the cursor is at the beginning of
! 	  an otherwise-empty line
  
! 				    1/2
  				    ---
! support/bashbug.sh
! 	- fixed a typo, thanks to eggert@twinsun.com
  
! aclocal.m4
! 	- new test, BASH_STRUCT_DIRENT_D_FILENO, testing for d_fileno member
! 	  of struct dirent
  
! configure.in
! 	- call BASH_STRUCT_DIRENT_D_FILENO
  
! config.h.in
! 	- new #define for STRUCT_DIRENT_HAS_D_FILENO
  
! lib/posixheaders/posixdir.h
! 	- only define d_fileno as d_ino if STRUCT_DIRENT_HAS_D_INO is defined
! 	  and STRUCT_DIRENT_HAS_D_FILENO is not defined.  This fixed the
! 	  problem of compiling getcwd.c on SunOS4.1.4 with cc
  
+ 				    1/3
+ 				    ---
  lib/readline/complete.c
! 	- fix a memory-used-after-freed bug reported by Andreas Schwab
  
! configure.in
! 	- call BASH_CHECK_SOCKLIB only if getpeername is not found in libc
! 	  (ac_cv_func_getpeername = no)
  
! 				   1/13
! 				   ----
  
! builtins/getopt.h
! 	- change #define guard to _SH_GETOPT_H to avoid similar guards in
! 	  /usr/include/getopt.h (Dec OSF/1 4.x, for example)
  
! variables.h
! 	- fix assign_array_from_string so that it rejects attempts to assign
! 	  to readonly variables
  
! subst.c
! 	- fix verify_substring_values to handle offsets that are past the
! 	  end or before the beginning (in the case of a negative offset)
! 	  of the expanded variable value
  
! 				   1/14
  				   ----
! bashline.c
! 	- fix a problem where any completion after a `cmd` command
! 	  substitution would inappropriately attempt command completion,
! 	  even if the previous command substitution was correctly closed
  
! builtins/evalstring.c
! 	- unwind_protect remember_on_history even if the shell is not
! 	  interactive, since history can now be used in scripts, and
! 	  `source' will turn off interactive_shell before calling
! 	  parse_and_execute
  
! jobs.c
! 	- new function get_job_by_pid(pid, block) to translate a pid to
! 	  a job number.  The block argument says whether or not to block
! 	  SIGCHLD
  
! jobs.h
! 	- new extern declaration for get_job_by_pid
  
! builtins/jobs.def
! 	- call get_job_by_pid if an argument appears to be a pid rather
! 	  than a jobspec
  
! configure.in
! 	- configure --without-gnu-malloc automatically on MachTen 4.x
  
! builtins/cd.def
! 	- change to mindist() so that a best guess of `.' returns 3,
! 	  which means not reasonable
  
! lib/posixheaders/memalloc.h
! 	- changed hpux_9 to __hpux, since the new config stuff doesn't
! 	  define hpux_9
  
  subst.c
! 	- fix parameter_brace_patsub to handle null patterns (doesn't
! 	  do anything)
  
! oslib.c
! 	- slight change to bzero replacement
  
! support/bashbug.sh
! 	- changed TEMP to be /tmp/bbug.$$ as a sop to systems with 14-char
! 	  file names
  
! doc/bashref.texi
! 	- add note to POSIX Mode section that the output of `set' when
! 	  invoked without arguments is sorted when in POSIX mode
  
! 				   1/15
  				   ----
! support/recho.c
! 	- a couple of changes prompted by a `gcc -Wall'
  
! subst.c
! 	- changed ASSIGN_RETURN macro to use the do...while(0) idiom to
! 	  avoid problems with its multiple statements
  
! builtins/setattr.def
! 	- a bad identifier given to readonly or export without an assignment
! 	  statement (e.g. `readonly a[5]') is an error, but not an assignment
! 	  error (i.e., return EXECUTION_FAILURE rather than EX_BADASSIGN)
! 
! tests/{{array,new-exp}.,tilde-}tests
! 	- added `set +o posix' at the beginning to disable POSIX mode, which
! 	  causes some of the tests to fail.  Some systems (e.g. LINUX-FT),
! 	  set POSIXLY_CORRECT by default
  
! tests/test-tests
! 	- added a warning if $UID is 0 to the effect that the test suite
! 	  should not be run as root
! 	- worked around the `noread' and `nowrite' tests failing when run
! 	  as root
  
! test.c
! 	- began removing the remains of the STANDALONE code, since test is
! 	  included in GNU shellutils
  
! 				   1/16
  				   ----
! lib/readline/{readline,display}.c
! 	- a couple of slight changes to build on Win95 using djgpp (reported
! 	  by x-aes@telelogic.se)
! 
! Makefile.in
! 	- changed TERMCAP_LIBDIR to TERM_LIBDIR, so building the termcap
! 	  library (if necessary) should work now
! 
! bashline.c
! 	- new function: quote_word_break_characters(), to backslash-quote 
! 	  characters in a filename that the readline completion code would
! 	  treat as word breaks
! 	- change bash_quote_filename to call quote_word_break_characters if
! 	  the completion quoting style says to use backslashes
! 	- add `:' to rl_filename_quote_characters, since it's part of
! 	  filename_word_break_characters
! 
! lib/posixheaders/posixjmp.h
! 	- new file, with half of bashjmp.h
! 	- posixjmp.h and lib/readline/posixjmp.h are symlinks to this file
  
! bashjmp.h
! 	- include "posixjmp.h" for possible redefinitions of setjmp/longjmp
! 	  and procenv_t
  
! 				   1/17
! 				   ----
! shell.c
! 	- bad options now cause the standard shell usage message (a subset
! 	  of what `bash --help' prints) to be displayed on stderr
  
! trap.c
! 	- don't free the trap command for a DEBUG trap in
! 	  restore_default_signal if SIG_INPROGRESS is set -- there's already
! 	  a pointer saved to the old value in _run_trap_internal.  This
! 	  makes bashdb run better, too
  
! examples/bashdb/bashdb.{pre,fns}
! 	- a couple of minor fixes; it actually has a chance of working now
  
! 				   1/21
  				   ----
! config.h.in
! 	- add a define for <dlfcn.h>, HAVE_DLFCN_H
  
! configure.in
! 	- look for <dlfcn.h>, define HAVE_DLFCN_H if found
  
! builtins/enable.def
! 	- include <dlfcn.h> only if HAVE_DLFCN_H is defined
  
! lib/readline/display.c
! 	- renamed clear_to_eol to _rl_clear_to_eol and made it global, so
! 	  other library files (readline.c) can use it
! 	- new function _rl_clear_screen, to clear the screen with the right
! 	  termcap escape sequence
  
! lib/readline/readline.c
! 	- call _rl_clear_to_eol and _rl_clear_screen instead of using tputs
! 	- extern declarations for _rl_clear_to_eol and _rl_clear_screen
  
! 				   1/22
  				   ----
! mailcheck.c
! 	- fixed a problem in make_default_mailpath() where a slash was not
! 	  added between the default mail directory and the username
  
! 				   1/23
! 				   ----
! stringlib.c
! 	- added a fourth parameter to ansicstr: the length of the returned
! 	  string
  
! externs.h
! 	- changed declaration of ansicstr
  
! parse.y
! 	- changed call to ansicstr -- saves a call to strlen
  
! builtins/echo.def
! 	- changed call to ansicstr
! 	- if do_v9 is non-zero, use putchar to output the string instead
! 	  of printf, since there may be embedded NULL characters
! 
! doc/{bash.1,bashref.texi}, builtins/trap.def
! 	- modified the `trap' documentation to make it clearer that trap
! 	  takes multiple signal specs as arguments
! 
! jobs.c, nojobs.c, jobs.h
! 	- renamed initialize_jobs to initialize_job_control, added an
! 	  argument (force)
! 
! jobs.c
! 	- set shell_tty to fileno(stderr) in initialize_job_control if
! 	  the shell is not interactive.  This fixes the problem of bad
! 	  tty pgrps when monitor mode is turned on in a non-interactive
! 	  shell
  
! sig.c
! 	- made initialize_terminating_signals do only that; moved the rest
! 	  of the code that used to be there into a new function:
! 	  initialize_shell_signals, which calls initialize_terminating_signals
! 	  if the shell is interactive
! 	- initialize_terminating_signals is now extern
! 	- made reset_terminating_signals return immediately if
! 	  termsigs_intitialized is zero, meaning that
! 	  initialize_terminating_signals has not been called
  
! sig.h
! 	- new extern declaration for initialize_terminating_signals
  
! trap.c
! 	- call initialize_terminating_signals from set_signal if sig is
! 	  EXIT_TRAP and the shell is not interactive.  Since the terminating
! 	  signals do not need to be initialized until a trap on exit is
! 	  set, not doing that at startup should result in a speed increase
! 	  for scripts
  
! execute_cmd.c
! 	- save and restore command->flags in time_command, so you can use
! 	  `time command' in a loop
  
! 				   1/24
  				   ----
! lib/readline/display.c
! 	- fix redisplay code to wrap correctly if the prompt is longer than
! 	  the screen width (reported by bos@Eng.Sun.COM)
  
! lib/readline/undo.c
! 	- don't include <setjmp.h>, it's not needed
  
! lib/readline/{util,readline}.c
! 	- include "posixjmp.h" instead of <setjmp.h>
! 	- readline_top_level is now a `procenv_t' instead of a `jmp_buf'
! 	  (now readline uses the correct posix semantics for preserving
! 	  the signal mask and other things across longjmp)
! 
! parse.y
! 	- fixes to push_string/pop_string to make them more general -- they
! 	  now can be used generally, instead of having to be associated
! 	  with an alias being expanded
! 	- fixes to the parser so that it parses (( ls abc; ls def); ls ghi)
! 	  as a nested subshell command for backwards compatibility.  Broke
! 	  the double-paren expression parsing off into a new function:
! 	  parse_arith_cmd, called from read_token when a `((' is seen.  If
! 	  it looks like an arithmetic command, return `let' and set things
! 	  up so that the expression is returned as a double-quoted string
! 	  by the next call to read_token.  If it's a nested subshell, push
! 	  the text we parsed onto the list of strings for later consumption
! 	  and return `('
  
! lib/glob/glob.c
! 	- fix glob_vector so it doesn't short-circuit checking a filename if
! 	  it starts with a `.' and the pattern starts with `\.' (if
! 	  noglob_dot_filenames is set).  This makes `".junk2"*' match
! 	  `.junk2.txt' correctly
  
! 				   1/27
! 				   ----
! support/bashbug.sh
! 	- ask for confirmation before sending the bug report
! 
! builtins/fc.def
! 	- when editing and re-executing a multiline command, make sure
! 	  current_command_line_count is initialized and then incremented
! 	  for each line read from the file so that the lines added to
! 	  the history list by fc_replhist and fc_addhist obey the `lithist'
! 	  and `cmdhist' shopt options.  Reported by tibbitts@pb.seflin.org
  
+ 				   1/28
+ 				   ----
  lib/readline/readline.h
! 	- added a couple of extern declarations for variables described in
! 	  the documentation but heretofore undeclared
  
! builtins/ulimit.def
! 	- try to catch some classes of integer overflows before calling
! 	  set_limit
  
! 				   1/29
! 				   ----
! parse.y
! 	- push and pop a `(' delimiter while parsing a $(...) construct, so
! 	  the history code doesn't try to inappropriately add a `;' when
! 	  a newline appears in the `...'
  
! aclocal.m4
! 	- new macro, BASH_STRUCT_WINSIZE, which looks for `struct winsize'
! 	  in <sys/ioctl.h> (or one of the files it includes)
  
! configure.in
! 	- call BASH_STRUCT_WINSIZE
! 	- slightly reorganized the calls to bash-specific macros
  
! config.h.in
! 	- add an `#undef STRUCT_WINSIZE_IN_SYS_IOCTL'
  
! jobs.c, nojobs.c
! 	- only look in sys/ptem.h for struct winsize if
! 	  STRUCT_WINSIZE_IN_SYS_IOCTL is not defined to cpp
  
! 				   1/30
! 				   ----
! .{distribution,patchlevel}
! 	- renamed to _{distribution,patchlevel}
  
! configure.in
! 	- create a variable BASHVERS, from the contents of _distribution,
! 	  and a variable BASHPATCH, from the contents of _patchlevel,
! 	  (using m4 magic so we don't have to distribute .distribution
! 	  and .patchlevel) and substitute them into Makefile.in
  
! Makefile.in
! 	- use Version and PatchLevel variables instead of the contents of
! 	  .distribution and .patchlevel, respectively.  These are set by
! 	  configure
! 	- removed `.machine' from targets and dependencies
  
! support/mkversion.sh
! 	- new shell script to handle updating version.h, replaces mkversion.c
! 	  (which is now overkill)
  
! support/mkdist
! 	- don't bother with writing .distribution and .patchlevel files,
! 	  since they're no longer distributed
  
! support/mknewvers.sh
! 	- simple bash script to make new version files.  It can increment
! 	  the major or minor version numbers or patchlevel, or take a
! 	  completely new version number (e.g., 2.01) as an argument
  
! doc/Makefile.in
! 	- added support for the `install-info' command to update the info
! 	  directory file after installing bash.info
  
! 				   1/31
! 				   ----
! builtins/help.def
! 	- fix core dump with `help --'
  
! susbt.c
! 	- make call_expand_word_internal obey the convention that if
! 	  expand_word_internal returns &expand_word_{fatal,error}, then
! 	  w->word has already been freed
! 	- return &expand_word_fatal from expand_word_internal if the shell
! 	  is not interactive and `set -u' has been executed
  
! test.c, general.c
! 	- moved group_member from test.c to general.c
  
! externs.h, general.h
! 	- moved extern declaration of group_member from externs.h to general.h
  
! general.c
! 	- broke the code that initializes the group array out into a new
! 	  function, initialize_group_array()
! 	- initialize_group_array() now initializes an array even if the OS
! 	  does not have getgroups().  If it does not, an array with one
! 	  element (the real gid) is created
! 	- call sysconf(_SC_NGROUPS_MAX) if sysconf is available and
! 	  _SC_NGROUPS_MAX is defined
! 	- new function, char **get_group_list(int *), to return an array
! 	  of strings made from the groups list
! 
! variables.c
! 	- new dynamic array variable: GROUPS, expands to the group set as
! 	  obtained with getgroups() (or whatever initialize_group_array()
! 	  makes)
  
! doc/{bash.{1,html},bashref.texi}
! 	- added description of GROUPS variable
  
! test/test-tests
! 	- before modifying the setgid bit on /tmp/setgid, try to change its
! 	  group to ${GROUPS[0]} 
  
! 				    2/3
! 				    ---
! aclocal.m4
! 	- new autconf macro, BASH_MISC_SPEED_T, to see if speed_t is defined
! 	  in <sys/types.h>
  
! configure.in
! 	- call BASH_MISC_SPEED_T
  
! config.h.in
! 	- add `#undef SPEED_T_IN_SYS_TYPES'
  
! lib/readline/tcap.h
! 	- include `rltty.h' if HAVE_TERMCAP_H and __linux__ are defined, but
! 	  SPEED_T_IN_SYS_STYPES is not, before including <termcap.h>
  
! support/mksignames.c, siglist.c
! 	- add support for 4.4 BSD SIGLOST
  
! support/config.guess
! 	- add support for recognizing QNX based on `uname' output
  
! Makefile.in
! 	- make sure recho and zecho are compiled with the same set of CC
! 	  options as the rest of the sources
  
! lib/readline/bind.c
! 	- change calls to rl_generic_bind to cast the third argument to
! 	  (char *) where necessary
  
! command.h
! 	- two new flags: CMD_AMPERSAND (currently unused), and CMD_STDIN_REDIR,
! 	  which means that this command should have its standard input
! 	  redirected from /dev/null if there are not any explicit redirections
! 	  to stdin
! 
! execute_cmd.c
! 	- a redirection of type r_inputa_direction is no longer added at the
! 	  beginning of the redirection chain for an async command;
! 	  CMD_STDIN_REDIR is set in the flags instead
! 	- new function: stdin_redirects: returns the number of redirections to
! 	  stdin in a chain of redirections
! 	- new functions: async_redirect_stdin() to open /dev/null and make it
! 	  file descriptor 0
! 	- changes to make CMD_STDIN_REDIR propagate to all of the necessary
! 	  functions (like execute_simple_command)
! 	- execute_disk command now takes the flags from simple_command rather
! 	  than just the CMD_NO_FORK flag as its last argument
! 	- various places after make_child is executed (in the child) check for
! 	  CMD_STDIN_REDIRECT (and no stdin redirections or piping) and call
! 	  async_redirect_stdin
! 	- stdin_redir is now global
  
! eval.c
! 	- set stdin_redir to 0 just before calling execute_command so it
! 	  gets reset to a known value and doesn't persist across commands
  
! 				    2/4
! 				    ---
! builtins/ulimit.def
! 	- add a stub function for ulimit(2) on systems without HAVE_RESOURCE
! 	  or HAVE_ULIMIT that just sets errno to EINVAL and returns -1 --
! 	  QNX is one such system
  
! bashhist.c
! 	- pre_process_line needs to protect all occurrences of hist_verify
! 	  with #ifdef READLINE
  
! builtins/shopt.def
! 	- hist_verify needs to be protected with #ifdef READLINE, not
! 	  #ifdef HISTORY
  
! 				    2/5
! 				    ---
! support/config.{guess,sub}, configure.in
! 	- chages to better support the Harris Night Hawk
  
! [many files]
! 	- changes for things pointed out by gcc -Wall
  
! lib/glob/Makefile.in
! 	- make sure -DSHELL is included in CCFLAGS so that globbing is
! 	  interruptible
  
! lib/malloc/malloc.c
! 	- extern declaration for botch: if botch is #defined, it should be
! 	  the name of a void function
  
! configure.in,Makefile.in,builtins/Makefile.in,
! lib/{glob,malloc,readline,tilde}/Makefile.in
! 	- add a LOCAL_DEFS variable, substituted from configure into the
! 	  various Makefiles.  It's set to -DSHELL, so that define gets
! 	  passed to all sub-makes without doing anything special
  
! lib/readline/readline.c
! 	- change to rl_digit_loop to make it compatible with GNU emacs:
! 	  if a key bound to `universal-argument' is read after reading
! 	  some digits, it terminates the argument but is otherwise
! 	  ignored.  This is how people can insert repeated digits
  
! doc/{bash.{1,html},readline.3}, lib/readline/doc/rluser.texinfo
! 	- changed description of `universal-argument' to describe how
! 	  to terminate a numeric argument
  
! 				    2/6
! 				    ---
! jobs.c
! 	- changed kill_pid to diddle the job and process data structures
! 	  if we're sending SIGCONT to a stopped job with `kill' so that
! 	  the shell knows the job is running again.  ksh93 does this
  
! 				    2/7
! 				    ---
! unwind_prot.c
! 	- changed bcopy to FASTCOPY
  
! builtins/enable.def
! 	- changed pointer arithmetic in delete_builtin to just subtract
! 	  the head of the builtins list (shell_builtins) from a pointer
! 	  to the builtin to be deleted (b) to find its index in the list
! 	  on ANSI C systems
  
! 				   2/10
  				   ----
! lib/readline/bind.c
! 	- when using old-style keynames to bind to a new-style macro,
! 	  pass an array of type (unsigned char *) to rl_macro_bind
  
! builtins/getopt.c
! 	- change sh_getopt to return EOF if nextchar is empty or NULL
! 	  and sh_optind is greater than argc.  This can happen if a
! 	  script mixes calls to `getopts' with calls to `shift'
  
! 				   2/11
! 				   ----
! print_cmd.c
! 	- fixed make_command_string_internal so that commands with the
! 	  CMD_TIME_POSIX flag set print `time -p' instead of `time'
! 	- changed print_redirection_list so the here documents are
! 	  printed after all the other redirections, and followed by a
! 	  newline (rather than a possible semicolon)
! 	- added a new variable, was_heredoc, to avoid adding a semicolon
! 	  at the beginning of an empty line after printing the heredoc
! 	  ending delimiter
  
! execute_cmd.c
! 	- don't put the gnu_argv_flags into the environment any more; it's
! 	  proven to be a bad idea
  
! configure.in
! 	- set LOCAL_CFLAGS to `-DSunOS5' on Solaris 5.5[.x]
  
! builtins/echo.def
! 	- only call fflush() after printing each word on SunOS 5.5, since
! 	  that's the system with the bug that prompted its inclusion in
! 	  the first place
! 
! support/mksignames.c
! 	- added support for more system-specific signals from AIX 4.2,
! 	  changed initialization order so that system-specific signals
! 	  are done first, before the common signals
  
+ 				   2/12
+ 				   ----
+ execute_cmd.c
+ 	- broke the code that creates a file containing the text of a
+ 	  here document out into a separate function: here_doc_to_fd
+ 	- create the temp file used for a here document with mode 600
+ 	- open the temp file used for a here document with O_EXCL
  
! shell.h
! 	- changed the uid members of struct user_info to be of type uid_t
! 	  and the gid members to be of type gid_t
  
! parse.y
! 	- changed the type of the `type' argument to init_yy_io() to be
! 	  `enum stream_type', since that's what's always passed
  
! input.h
! 	- changed the function prototype for init_yy_io so the third arg is
! 	  type `enum stream_type'
  
! externs.h
! 	- added a prototype for getcwd, if HAVE_GETCWD is not defined
  
! builtins/umask.def
! 	- changed all variables that are used as arguments to or save the
! 	  return value from umask(2) to be of type mode_t
! 	- changed print_symbolic_umask to take an argument of type mode_t
  
! 				   2/13
  				   ----
  jobs.c
! 	- if old_sigint_handler is set to SIG_DFL, as it will be in a script
! 	  without a trap on SIGINT installed, call termination_unwind_protect()
! 	  directly from waitchld()
  
! 				   2/14
! 				   ----
! configure.in
! 	- added a section before the call to BASH_CHECK_LIB_TERMCAP to
! 	  set a variable prefer_curses on some systems (AIX, for one)
  
! aclocal.m4
! 	- in BASH_CHECK_LIB_TERMCAP, don't return -ltermcap if $prefer_curses
! 	  is non-empty
  
! lib/readline/Makefile.in
! 	- redid the dependencies
  
! 				   2/17
! 				   ----
! hashlib.c, getcwd.c
! 	- include `bashansi.h' instead of stdlib.h and string.h
  
! error.c, siglist.c, xmalloc.c, builtins/{common,evalfile,mkbuiltins,psize}.c,
! builtins/{exec,exit,fg_bg,hash,history}.def
! 	- include `bashtypes.h' instead of directly including <sys/types.h> 
  
! builtins/fc.def
! 	- include ../bashtypes.h and ../posixstat.h instead of bashtypes.h
! 	  and posixstat.h
  
! builtins/mkbuiltins.c
! 	- include ../posixstat.h instead of <sys/stat.h>
  
! general.h
! 	- include `bashtypes.h' if RLIMTYPE is defined, so we can fetch
! 	  a definition of quad_t (or whatever) from <sys/types.h> before
! 	  using it in a function prototype
  
! Makefile.in, builtins/Makefile.in
! 	- updated dependencies
  
! 				   2/18
! 				   ----
! builtins/set.def
! 	- new function, set_posix_mode, called when `set [-+]o posix'
! 	  or `shopt -[su] -o posix' is executed.  It sets or unsets
! 	  $POSIXLY_CORRECT and calls sv_strict_posix
  
! subst.c
! 	- in sv_strict_posix, call posix_readline_initialize only if
! 	  the shell is interactive (interactive_shell != 0)
  
! shell.c
! 	- if we are acting like `sh', call posix_readline_initialize
! 	  if the shell is interactive
! 	- moved the code that does posix.2 mode initialization after
! 	  interactive_shell is set, and call posix_readline_initialize
! 	  if interactive_shell is non-zero
  
! bashwait.h
! 	- renamed to unionwait.h, since that is what it defines
  
! posixwait.h
! 	- moved the POSIX 1003.1 job control defines here from jobs.h
  
! jobs.h
! 	- include `posixwait.h'
  
! 				   2/19
  				   ----
! braces.c
! 	- if SHELL is defined, pass the contents of new-style command
! 	  substitution through without expanding brace constructs between
! 	  the parens -- let the subshell do it
  
! subst.c
! 	- when brace-expanding words, preserve the flags (word->flags) if
! 	  brace expansion does not change the word.  This fixes the problem
! 	  of things like
  
! 		 local -a avar=( ${PATH//: } );
  
! bashline.c
! 	- have shell_expand_line pass a copy of rl_line_buffer to expand_string
! 	  in case there are substitution errors and the string gets freed
  
! 				   2/20
  				   ----
! expr.c
! 	- make sure that expland and explor set `lasttok' to LAND and LOR,
! 	  respectively, if they parse `&&' or `||'.  This makes the
! 	  precedence code work right
  
! subst.c
! 	- changes so that non-interactive shells exit immediately when a
! 	  parameter that is unset is referenced after `set -u' has been
! 	  executed causes the shell to exit immediately
  
! 				   2/21
! 				   ----
! flags.c
! 	- if `set -r' is executed, call maybe_make_restricted so that $PATH
! 	  and $SHELL are made read-only
  
! execute_cmd.c
! 	- if `set -e' has been executed, and we're inverting a pipeline's
! 	  return status with `!', set CMD_IGNORE_RETURN so a failing
! 	  command does not inadvertently cause the shell to exit before
! 	  the exit status can be inverted.  This is probably only a problem
! 	  with the `eval' builtin.
  
! 				   2/24
! 				   ----
! builtins/hash.def
! 	- add a missing argument of 0 to add_hashed_command
  
! builtins/kill.def
! 	- job identifiers can be used in non-interactive shells as long as
! 	  job control has been turned on with `set -m'
  
! jobs.c
! 	- we want to be notified of stopped jobs if job_control is non-zero,
! 	  even if the shell is not interactive
  
! execute_cmd.c
! 	- make sure shell_execve returns EX_NOTFOUND if execve fails and
! 	  errno is set to ENOENT
! 	- makes sure execute_builtin saves the temporary environment to
! 	  builtin_env for the `eval' builtin, since it can destroy the
! 	  temporary environment when it calls parse_and_execute
  
! bashhist.c
! 	- new variable: hist_last_line_added, set to 1 if the last command
! 	  line was added to the history successfully as a separate entry.
! 	  Used by `history' and `fc'
  
! 				   2/25
! 				   ----
! trap.c
! 	- save line number before executing trap command, because
! 	  parse_and_execute resets it to 1 and the trap command might
! 	  want it
  
! execute_cmd.c
! 	- change to executing_line_number to return trap_line_number if
! 	  the shell is currently running a trap
  
! 				   2/26
  				   ----
! execute_cmd.c
! 	- change to time_command so that a `real' value of 0 does not
! 	  cause a divide-by-zero error when computing cpu percentage
! 
! lib/readline/signals.c
! 	- if MUST_REINSTALL_SIGHANDLERS is defined, reinstall the SIGWINCH
! 	  handler in rl_handle_sigwinch
  
! builtins/set.def
! 	- `unset' now rejects attempts to unset names that are not valid
! 	  shell identifiers as errors
! 	- add a description of `-o history' option to help text
  
! subst.c
! 	- in parameter_brace_patsub, we want backslash removal done on
! 	  the replacement if (mflags & MATCH_QUOTED), since the code
! 	  in expand_word_internal will not do it.  We need to call
! 	  expand_string_unsplit directly, since maybe_expand_string does
! 	  not do the right thing
  
! 				   2/28
  				   ----
! execute_cmd.c
! 	- if execute_for_command finds that the iteration variable is readonly,
! 	  decrement loop_level before returning
  
! builtins/break.def
! 	- if the break count is <= 0, display an error message and break out
! 	  of all loops
  
! builtins/command.def
! 	- if PATH is unset, and we're using command -p, we don't want PATH
! 	  to be set to the empty string when `command' completes
  
! builtins/common.c
! 	- POSIX.2 says `kill -l signum' prints the signal name without the
! 	  leading `SIG' prefix, so check for this_shell_builtin == kill_builtin
! 	  in display_signal_list
  
! builtins/getopts.def
! 	- when invoked without any arguments, `getopts' now prints a usage
! 	  message
  
! 				    3/3
! 				    ---
! builtins/common.c
! 	- add a second argument to get_numeric_arg: if non-zero, the shell
! 	  exits on a bad argument; if not, the shell jumps to top_level
! 	  with a DISCARD argument, which aborts the current command
  
! builtins/{break,exit,history,return,shift}.def
! 	- change calls to get_numeric_argument
  
! lib/readline/funmap.c
! 	- add `dump-macros' to list of bindable names
  
! lib/readline/readline.h
! 	- added extern declaration for rl_prompt (it was apparently missing)
  
! lib/readline/readline.c
! 	- new internal function, _rl_init_line_state, which sets rl_point
! 	  and rl_end to 0, sets the_line to point to _rl_line_buffer, and
! 	  clears the line
  
! lib/readline/callback.c
! 	- if a user's callback function does not clear the line, clear it
! 	  for him by calling _rl_init_line_state
  
! 				    3/4
! 				    ---
! alias.c
! 	- made the readline support functions #ifdef READLINE, so they're
! 	  not compiled into the shell unless readline is
  
! lib/readline/bind.c
! 	- new function _rl_untranslate_macro_value, to expand meta-prefixes
! 	  and other special characters in a macro value for printing by
! 	  _rl_macro_dumper_internal
! 	- call _rl_untranslate_macro_value in _rl_macro_dumper_internal to
! 	  get a printable version of the macro value
  
! lib/readline/readline.c
! 	- new variable, rl_dispatching, set to 1 when we call a function
! 	  from _rl_dispatch
  
! lib/readline/readline.h
! 	- extern declaration for rl_dispatching
  
! lib/readline/complete.c
! 	- make sure S_ISCHR and S_ISBLK are defined before using them
  
! lib/readline/terminal.c
! 	- add a new #define NEED_EXTERN_PC.  Define this if the termcap
! 	  or curses libraries need `extern' before declarations of PC,
! 	  BC, and UP
! 
! lib/readline/{readline,terminal,histfile}.c
! 	- changes to compile on OS/2 with OS/2 `EMX' port of gcc, originally
! 	  sent by ilya@math.ohio-state.edu
  
! builtins/set.def
! 	- fixed a bug in set_shellopts that caused the shell to crash if
! 	  there were no shell options set
  
! 				    3/5
! 				    ---
! configure.in,Makefile.in
! 	- choose run-all or run-minimal as the test script based on whether
! 	  the --enable-minimal-config option was given to configure
  
! builtins/setattr.def
! 	- fixed `export -p' and `readonly -p' so that they output `export'
! 	  or `readonly' when in POSIX mode, as POSIX.2 specifies
  
! 				    3/6
! 				    ---
! builtins/setattr.def
! 	- make `readonly -a var=(...)' work just like `declare -ar var=(...)',
! 	  since the two logically mean the same
! 	- `readonly -f' and `export -f' don't print the function definition
! 	  for each readonly or exported function, respectively, when in
! 	  POSIX mode
  
! jobs.c, nojobs.c
! 	- don't report status for processes killed by SIGPIPE if
! 	  DONT_REPORT_SIGPIPE is defined
  
! config.h.top
! 	- added a commented-out define for DONT_REPORT_SIGPIPE
  
  execute_cmd.c
! 	- `time' can now be used to time background pipelines, and reports
! 	  the timing statistics when the pipeline completes
  
! [bash-2.01-alpha1 frozen]
  
! 				   3/12
! 				   ----
! subst.c
! 	- move the parent end of the pipe file descriptor used for process
! 	  substitution to a high, unused file descriptor to avoid clashes
! 	  with redirections performed explicitly by a script
  
! configure.in
! 	- added a `--with-curses' argument so curses can be forcibly chosen
! 	  over libtermcap (some Unix versions ship lousy termcap databases)
  
! support/mkconffiles
! 	- new script to create _distribution and _patchlevel from values
! 	  contained in `configure'
  
! doc/bashref.texi
! 	- updated installation instructions
  
! 				   3/13
  				   ----
! general.c
! 	- if `getgroups' returns 0, make sure we add the primary group id
! 	  as GROUPS[0].
! 	- if we have getgroups, and the primary gid is not in the array
! 	  getgroups returns, add it as group_array[0] and shuffle everything
! 	  up one element.  This ensures that current_user.gid == group_array[0]
! 	  all the time
! 
! tests/builtins.tests
! 	- changes to avoid stray variables in environment when the shell
! 	  version of printenv is used with bash as /bin/sh, running the
! 	  `exec -c' tests.
  
! 				   3/14
! 				   ----
! builtins/cd.def
! 	- spelling correction is no longer enabled by default
  
! support/bashbug.sh
! 	- if the shell's release status is alpha or beta, offer the option
! 	  of sending the bug report to the bash-testers mailing list as
! 	  well as to chet
  
! 				   3/17
! 				   ----
! configure.in
! 	- configure --without-gnu-malloc by default on *-sgi-irix6* because
! 	  their code needs 8-byte alignment
  
! support/bashbug.sh
! 	- ``' needs to be quoted with a backslash in double-quoted strings
  
! aclocal.m4
! 	- slight changes to the strcoll test, since AIX 4.2 returns -1, 0, or
! 	  1 from strcmp(3) but a numeric collation order difference from
! 	  strcoll(3)
  
! 				   3/18
  				   ----
! command.h
! 	- new redirection error code:  HEREDOC_REDIRECT
! 
! execute_cmd.c
! 	- return HEREDOC_REDIRECT from do_redirection_internal when
! 	  here_document_to_fd cannot create the temp file for a here document
! 	- changed redirection_error to print a meaningful message when
! 	  here document temp file creation fails (HEREDOC_REDIRECT)
  
+ 				   3/19
+ 				   ----
  subst.c
! 	- changes to match_pattern_char: return 1 if the first char of the
! 	  pattern is `?' only if the string is non-null; just return 1 if
! 	  the first char of the pattern is `[' and the string is non-empty
! 	  rather than try to re-implement the brace matching code from fnmatch
  
! lib/glob/fnmatch.c
! 	- some changes from glibc-2.0.1 posix/fnmatch.c
  
+ 				   3/21
+ 				   ----
  variables.c
! 	- only do the initialization of `ignoreeof' if the shell is
! 	  interactive
! 	- reset values of $SHLVL > 1000 to 1 in adjust_shell_level, and
! 	  don't call itos, since we don't need its generality
! 	- new function, initialize_shell_level, just calls adjust_shell_level
! 	  with argument of 1.  If $SHLVL is unset, adjust_shell_level will
! 	  deal with it correctly
! 	- change initialize_shell_variables to not malloc a copy of each
! 	  environment variable, just keep two pointers into the env string:
! 	  one for the name, one for the value
! 	- broke the code that computes the value of $BASH out into a separate
! 	  function: get_bash_name
! 	- get_bash_name special-cases shell_name with a `./' prefix when
! 	  initializing $BASH
! 	- new function: set_home_var, sets $HOME to current_user.home_dir if
! 	  it's not already set, calling get_current_user_info if
! 	  current_user.home_dir is NULL
! 	- new function: set_shell_var, sets $SHELL to current_user.shell if
! 	  it's not already set, calling get_current_user_info if
! 	  current_user.shell is NULL
! 	- changed places that reference information in current_user to check
! 	  for NULL values of the member they're interested in and call
! 	  get_current_user_info if necessary
! 
! shell.c
! 	- moved the code that sets up the information in current_user that
! 	  comes from the password file into a new function,
! 	  get_current_user_info
! 	- shell_initialize calls get_current_user_info only if the shell is
! 	  interactive
  
! externs.h
! 	- new extern declaration for get_current_user_info(), so variables.c
! 	  can use it
  
! 				   3/24
! 				   ----
! lib/tilde/tilde.c
! 	- if SHELL is defined, user the current_user struct info to find
! 	  the user's home directory rather than calling getpwuid
  
! 				   3/25
  				   ----
+ nojobs.c
+ 	- don't try to open /dev/tty when getting or setting the tty state
+ 	  and window size; use shell_tty instead
+ 	- initialize shell_tty to standard error in initialize_job_control
+ 	- only fetch the tty state initially if the shell is interactive
  
! general.c
! 	- open /dev/tty with the O_NONBLOCK flag
  
! variables.c
! 	- changed all_vars so that it sorts its output all the time, not
! 	  just when in POSIX mode.  This means that the output of `set'
! 	  and `export' will be sorted
  
! builtins/set.def
! 	- in initialize_shell_options, only call parse_shellopts if we
! 	  inherited $SHELLOPTS from the environment
! 	- make sure we call parse_shellopts from initialize_shell_options
! 	  with a copy of the value of SHELLOPTS, in case one of the functions
! 	  called while setting one of the variables modifies $SHELLOPTS
  
! lib/readline/readline.c
! 	- make sure that digit arguments don't change the state of
! 	  rl_last_func
! 
! support/printenv.c
! 	- new file, printenv(1) clone, used to avoid environment variables
! 	  that might be set automatically when using printenv.sh
  
! lib/tilde/tilde.c
! 	- if SHELL is defined, don't call getenv to get the value of $HOME,
! 	  call get_string_value () directly
  
! 				   3/26
  				   ----
! lib/readline/histexpand.c
! 	- abstracted the `#ifdef SHELL' stuff that checked for special cases
! 	  that should not be history expanded ([!...], ${!...}) into a call
! 	  to a function that is the value of the
! 	  new history_inhibit_expansion_function variable
  
! lib/readline/history.h
! 	- extern declaration for history_inhibit_expansion_function
  
! bashhist.c
! 	- new function, bash_history_inhibit_expansion, which checks for
! 	  the special cases in which history expansion should be inhibited
! 	- changes to the various history initialization functions to
! 	  set history_inhibit_expansion_function
  
! lib/readline/doc/hstech.texinfo
! 	- documented history_inhibit_expansion_function
  
! lib/readline/shell.c
! 	- new file, containing versions of the functions that are provided
! 	  by bash when readline is linked as part of bash
! 	- new function: get_env_value().  If SHELL is defined, this calls
! 	  get_string_value().  If SHELL is not defined, this calls getenv()
  
! lib/readline/histexpand.c
! 	- moved single_quote() to shell.c
  
! lib/readline/util.c
! 	- moved savestring() to shell.c
  
! lib/readline/terminal.c
! 	- moved set_lines_and_columns() to shell.c
  
! lib/readline/Makefile.in, Makefile.in
! 	- added shell.c and shell.o to the appropriate variables that contain
! 	  the files comprising the readline and history libraries
  
! lib/readline/signals.c
! 	- introduced two new cpp defines:  HANDLE_JOB_SIGNALS and
! 	  HANDLE_SIGTERM.  When HANDLE_JOB_SIGNALS is defined, SIGTSTP,
! 	  SIGTTIN, and SIGTTOU are caught and handled.  When HANDLE_SIGTERM
! 	  is defined, SIGTERM is caught and handled.  These are both
! 	  defined automatically if SHELL is not defined
! 
! lib/readline/{bind,histfile,nls,readline,terminal}.c
! 	- call get_env_value instead of getenv().  This should remove the
! 	  dependency on being able to redefine getenv() in oslib.c
  
! shell.c
! 	- added a missing argument of -1 to the call to list_minus_o_opts.
! 	  Now `bash -o' lists all options, not just random ones depending
! 	  on what's on the stack
  
! 				   3/28
  				   ----
! builtins/ulimit.def
! 	- change RLIM_INFINITY to the hard limit only if the hard limit is
! 	  greater than the current (soft) limit
  
! hashlib.c
! 	- return immediately from flush_hash_table if the hash table passed
! 	  is NULL
  
! 				    4/1
! 				    ---
! shell.c
! 	- remove call to initialize_filename_hashing -- initialize the hash
! 	  table the first time a hashed command has to be remembered
  
! hashcmd.c
! 	- new file, with functions to perform filename hashing and lookup
! 	  taken from builtins/hash.def and builtins/common.c
! 	- change to remember_filename -- call initialize_filename_hashing
! 	  if hashing_initialized is 0
! 
! hashcmd.h
! 	- new file, mostly from builtins/hashcom.h, with extern function
! 	  declarations added
  
! execute_cmd.c, builtins/{hash,type}.def
! 	- include hashcmd.h for hash function and type definitions
  
! builtins/{common.{c,h},hash.def}
! 	- moved hashing functions and declarations to hashcmd.c/hashcmd.h
  
! Makefile.in, builtins/Makefile.in
! 	- changed source and object file definitions and dependencies because
! 	  of addition of hashcmd.h and hashcmd.c
  
! builtins/hash.def
! 	- return immediately from print_hashed_commands if hashed_commands
! 	  is empty, indicating that the hash table has not been initialized
  
! 				    4/2
  				    ---
! lib/readline/bind.c
! 	- fixed translation of ESC in rl_untranslate_keyseq and
! 	  rl_untranslate_macro_value
  
! lib/readline/{readline,kill}.c
! 	- added an argument to _rl_fix_point telling it whether or not to
! 	  fix up the mark also; changed calls to _rl_fix_point to add the
! 	  appropriate argument
  
! Makefile.in
! 	- changed the substitution delimiter in the `sed' commands that
! 	  create bashbug from `:' to `%' to avoid conflicts with options
! 	  containing `:'
  
! 				    4/3
  				    ---
! print_cmd.c
! 	- made the initial value and the default growth value for the
! 	  printed command somewhat smaller -- we don't really need to
! 	  allocate 4096 bytes for the printed command
! 	- added stdarg support to xprintf if PREFER_STDARG is defined
  
! stringlib.c
! 	- changed strip_trailing to take the index of the last character
! 	  as the second argument, saving a (useless) call to strlen, since
! 	  the caller already knows where the end of the string is
  
! subst.c
! 	- change call to strip_trailing in command_substitute to add the
! 	  new second argument
  
! externs.h
! 	- changed extern declaration for strip_trailing
  
! 				    4/4
  				    ---
! Makefile.in, configure.in, lib/malloc/Makefile.in
! 	- changed the strategy for picking which `malloc' to include by
! 	  having configure define a `malloc target' and the Makefile in
! 	  lib/malloc implementing rules for that target
  
! 				    4/5
! 				    ---
! Makefile.in
! 	- slightly changed the rules for remaking `parser-built':  it is
! 	  now a copy of y.tab.h, updated only when the contents of y.tab.h
! 	  change
! 	- everything that used to depend on y.tab.h now depends on
! 	  parser-built
  
! 				    4/6
! 				    ---
! execute_cmd.c, print_cmd.c
! 	- use #include <y.tab.h> so we pick up y.tab.h from the build
! 	  directory instead of the source directory if it happens to be
! 	  recreated in the build directory
  
! 				    4/7
! 				    ---
! bashline.c
! 	- fixed another problem with `pwd`/[TAB] thinking that the `/
! 	  started an unclosed command substitution, generating errors
  
! 				    4/8
  				    ---
! general.c
! 	- renamed bash_tilde_expansion_failure_hook to be
! 	  bash_special_tilde_expansions, since that more accurately reflects
! 	  its function
! 	- changed tilde_initialize so that there is no failure hook -- the
! 	  special expansions are handled first with the preexpansion hook
  
! lib/tilde/tilde.c
! 	- new variable: tilde_expansion_preexpansion_hook -- if non-null, it
! 	  points to a function that is called before standard tilde expansion
! 	  is attempted
  
! lib/tilde/tilde.h
! 	- extern declaration for tilde_expansion_preexpansion_hook
  
! doc/{bash.{1,html},bashref.texi}
! 	- added optional open paren to description of `case' command syntax
  
! 				    4/9
  				    ---
! variables.c
! 	- on qnx, set and export a variable `NODE' which contains the QNX
! 	  `node id'
  
! general.c
! 	- QNX system can now handle pathnames with a leading `//'
  
! configure.in
! 	- added `-Dqnx' to LOCAL_CFLAGS on QNX machines
  
! lib/malloc/getpagesize.h
! 	- some systems need sysconf(_SC_PAGE_SIZE) to obtain the page size;
! 	  added code to check for it
  
! 				   4/10
  				   ----
! print_cmd.c
! 	- include the prototype for cprintf only if PREFER_STDARG is defined,
! 	  otherwise just have a K&R-style forward function declaration
  
! hashlib.h
! 	- reduced the default number of buckets in a hash table to 53
  
! lib/tilde/tilde.c
! 	- prime the result string in tilde_expand by allocating a new string
! 	  that's as long as the input string (+16 if a tilde appears in
! 	  the string to be expanded).  This should reduce the number of
! 	  reallocs
  
! subst.c
! 	- broke the code that reads the output of a command substitution
! 	  through the pipe to the subshell out into a separate function:
! 	  read_comsub().  This does not use stdio, but rather reads
! 	  directly from the pipe into a local 128-character buffer
  
! 				   4/11
! 				   ----
! execute_cmd.c
! 	- some systems need both <sys/time.h> and <time.h>, so include both
! 	  if it's possible, otherwise include <sys/time.h> (if present)
  
! lib/readline/rl{tty,defs}.h
! 	- moved includes of <sys/stream.h>, <sys/ptem.h>, etc. to rltty.h
  
! lib/readline/terminal.c
! 	- include rltty.h after rldefs.h
  
  variables.c
! 	- changes to make environment creation faster and use less memory
! 	  (fewer malloc/free calls, too):
  
! 		o two new variables: export_env_index (how many environment
! 		  strings are in export_env) and export_env_size (the
! 		  number of slots for strings allocated in export_env)
! 		o added new function add_to_export_env, since adding the
! 		  exported shell variables and shell functions does not
! 		  need to search the export_env for a definition to supersede
! 		  (we just cleared it out!)
! 		o renamed add_or_supersede to add_or_supersede_exported_var,
! 		  since it always works on export_env, and changed the second
! 		  argument to a flag saying whether or not to allocate a new
! 		  copy of the string placed into the environment
! 		o changed calls to add_or_supersede to the new
! 		  add_or_supersede_exported_var with the appropriate flags
! 		o don't free and reallocate export_env in maybe_make_export_env,
! 		  just free the strings and start anew
! 		o prime the size of export_env from the total number of shell
! 		  variables and shell functions -- this will always be enough
! 		  for the exported shell functions and variables, and big
! 		  enough most of the time for the entire environment
  
  builtins/cd.def
! 	- efficiency hack in bindpwd():  if PWD is exported, we will have to
! 	  rebuild the entire exported environment after every time we change
! 	  directories.  What we do is see if array_needs_making changes value
! 	  from 0 to 1 after bind_variable ("PWD", dirname) is called, and
! 	  that PWD is exported.  If that happens, we just replace the value
! 	  of PWD in the exported environment with a call to
! 	  add_or_supersede_exported_var
! 
! bashline.c, parse.y
! 	- check calls to pre_process_line to make a fresh copy of the line
! 	  if pre_process_line returns what it was passed, in preparation
! 	  for future changes
  
! bashhist.c
! 	- pre_process_line now returns its argument if it did not make
! 	  any changes to it
  
! alias.c
! 	- free the bucket entry holding the alias to be removed in
! 	  remove_alias, as well as the data
  
! 				   4/14
! 				   ----
! unwind_prot.c
! 	- if an unwind-protect frame is being discarded, and its cleanup
! 	  function is `restore_variable', the `arg' member points to a
! 	  SAVED_VAR that must be freed.  This change is made in
! 	  remove_unwind_protect_internal and unwind_frame_discard_internal
! 
! parse.y
! 	- need to free memory allocated by parse_arith_cmd if it is an
! 	  arithmetic command, after using it to make a new word
! 
! subst.c
! 	- fixed some memory leaks caused by not freeing the argument to
! 	  make_bare_word, which duplicates its string argument
! 	- need to dispose list generated by list_rest_of_args in
! 	  paramter_list_remove_pattern
! 	- make sure the return value from getpattern() is freed
! 	- make sure array_value_internal always returns newly-allocated
! 	  memory
! 	- get_var_and_type returns a new type: VT_ARRAYMEMBER if the
! 	  string passed is of the form var[index]
! 	- make sure parameter_brace_substring frees the memory allocated
! 	  by get_var_and_type if verify_substring_values returns 0
! 
! hashlib.c, hashlib.h
! 	- new function, dispose_hash_table (table), which frees the
! 	  table's bucket array and the table itself
  
! alias.c
! 	- call dispose_hash_table from delete_all_aliases instead of just
! 	  freeing the table
! 
! pathexp.c
! 	- make sure to free `newnames' (but *not* its contents) before
! 	  returning from ignore_globbed_names
  
! builtins/exec.def
! 	- make sure the argv created to pass to shell_execve is freed if
! 	  the execve fails and we're not exiting on failed execs
  
! expr.c
! 	- broke evalexp into two functions: evalexp, which sets up the
! 	  jmp_buf that errors jump to, and subexpr, which does the
! 	  evaluation and pushing and popping of contexts
! 	- readtok now calls subexpr to evaluate subexpressions in
! 	  parentheses
! 	- evalexp now takes an additional paramter, a pointer to an int.
! 	  If the expression contains errors, the location to which this
! 	  points gets 0, otherwise it gets 1 to show that the value
! 	  returned may be used.  This plugs up memory leaks that were
! 	  the result of evalexp() longjmping back to top_level
! 	- fixed a memory leak: expr_stack[0] was not being freed
  
! externs.h
! 	- changed extern declaration for evalexp
  
! variables.c, subst.c, builtins/let.def
! 	- changed calls to evalexp appropriately.  They either cause a
! 	  longjmp (top_level, DISCARD) (which is what the old stuff in
! 	  expr.c did) or are handled by returning an appropriate error
! 	  value (e.g., &expand_word_error in subst.c)
  
! 				   4/16
  				   ----
! shell.c
! 	- make sure to free dollar_vars[0] before assigning it the first
! 	  argument following `-c command'
  
  variables.c
! 	- if unsetting a local variable with a previous context, make sure	
! 	  to free the hash table element used to store the local variable
  
! lib/readline/terminal.c
! 	- rearrange the includes so <sys/ioctl.h> is included before rltty.h,
! 	  as it is in rltty.c
  
! 				   4/17
! 				   ----
! flags.c
! 	- new function: reset_shell_flags, which resets all of the flags
! 	  back to their initial values
  
! flags.h
! 	- extern declaration for reset_shell_flags
  
! builtins/set.def
! 	- new function: reset_shell_options, which resets all of the -o
! 	  options that are not also shell flags back to their initial values
  
! builtins/shopt.def
! 	- new function: reset_shopt_options, which resets all of the shopt
! 	  options that are not also shell flags or -o options back to their
! 	  initial values
  
! builtins/common.h
! 	- extern declarations for reset_shell_options and reset_shopt_options
  
! execute_cmd.c
! 	- broke the code that reinitializes things when an executable script
! 	  without a leading `#!' is found out into a new function:
! 	  initialize_subshell
! 	- initialize_subshell now calls the reset_* functions that reset the
! 	  shell flags and options
  
! general.c, general.h
! 	- move_to_high_fd now takes a third argument: the highest fd at which
! 	  to start looking.  If that's less than 20, the maximum number of
! 	  open files as returned by getdtablesize() is used (which is what
! 	  it did before this)
  
! jobs.c, shell.c, subst.c
! 	- changed calls to move_to_high_fd appropriately
  
! [bash-2.01-beta1 frozen]
  
! 				   4/18
  				   ----
! general.c
! 	- itos now uses a local char buffer to do its conversion, but still
! 	  returns newly-allocated memory
  
! 				   4/21
  				   ----
! variables.c
! 	- be a little more careful when checking for backwards-compatibility
! 	  with exported function definitions
  
! 				   4/22
  				   ----
! builtins/ulimit.def
! 	- translate RLIM_INFINITY to limit.rlim_max if the current limit is
! 	  less than or equal to the hard limit, not just strictly less than
! 	  (the change of 3/28 was too drastic)
  
! 				   4/23
  				   ----
! oslib.c
! 	- fixed definition of to_lower on machines without strcasecmp
  
  trap.c
! 	- don't free the trap command in change_signal if the SIG_INPROGRESS
! 	  is set in the signal's flags -- it will cause memory to be freed
! 	  twice if a trap command resets the signal handler more than once,
! 	  and _run_trap_internal keeps a pointer to the trap command so it
! 	  can free it, so there will be no leaks
  
! 				   4/24
  				   ----
! aclocal.m4,configure.in
! 	- removed BASH_CC_WORKS, since AC_PROG_CC now has the functionality
  
! shell.c, externs.h
! 	- get_current_user_info is now a void function
  
! bashline.c
! 	- alias_expand_line_internal was removed
! 	- new function, alias_expand_line, performs alias expansion on
! 	  rl_line_buffer and either replaces rl_line_buffer or signals
! 	  an error
! 	- new bindable commands: alias-expand-line and
! 	  history-and-alias-expand-line, available if ALIAS is defined
  
! 				   4/25
  				   ----
! Makefile.in, lib/malloc/malloc.c
! 	- changed the define that turns on malloc range checking from
! 	  `rcheck' to `RCHECK'
  
! lib/readline/isearch.c
! 	- fixed a couple of places where rl_search_history would try to
! 	  free a NULL pointer
  
! 				   4/29
  				   ----
! unwind_prot.c
! 	- fixed a problem with saving a variable that is a null pointer
! 	  in unwind_protect_var.  It happens only on machines where the
! 	  size of a pointer is not the size of an int.  The old FASTCOPY
! 	  code would copy the eight bytes at memory location zero, which
! 	  did not necessarily make a null pointer
  
+ 				   4/30
+ 				   ----
  shell.c
! 	- run_startup_files should turn off job control, since the startup
! 	  files should be run without job control enabled -- this makes
! 	  SIGINT interrupt startup file execution again
! 	- if we get a SIGINT or other longjmp to top_level while executing
! 	  the startup files, re-enable job control for interactive shells
! 	  before setting locally_skip_execution
  
! 				    5/2
! 				    ---
! lib/readline/nls.c
! 	- if we have setlocale(3), don't bother with checking the
! 	  environment variables for valid values; just use setlocale()
! 	  to set the locale categories from the environment variables
! 	  directly and go into eight-bit mode if the current locale is
! 	  not C or POSIX
  
! 				    5/5
! 				    ---
! sig.c
! 	- make sure that the handler for SIGPROF is not changed if it has
! 	  been set to something other than SIG_IGN or SIG_DFL -- this makes
! 	  profiling work after the terminating signals have been initialized
  
  bashline.c
! 	- if a filename containing `!' is completed, and the user has started
! 	  the string with a `"', change the completion style to backslash-	
! 	  quoting, since there's no way to use `!' with double quotes (this
! 	  requires more changes to readline to really work right)
  
! 				    5/6
! 				    ---
! lib/readline/complete.c
! 	- changes to make_quoted_replacement, insert_all_matches, and
! 	  insert_match and their callers to allow the application-specific
! 	  filename quoting function to change the quote character (e.g., for
! 	  bash to change a filename containing a `!' and started with a
! 	  double quote by the user into a filename with the `!' quoted by
! 	  a backslas and no double quote)
  
! 				    5/8
! 				    ---
! jobs.c
! 	- new function: nohup_all_jobs(), calls nohup_job for each entry in
! 	  the jobs list
! 	- delete_all_jobs is now global
  
! jobs.h
! 	- new extern declarations for delete_all_jobs() and nohup_all_jobs()
  
! builtins/jobs.def
! 	- `disown' without any jobspec arguments means the current job.  Fix
! 	  a core dump printing the error message when there is no current job
  
! 				   5/12
  				   ----
! subst.c
! 	- process an expansion like $((foo); bar) as a command substitution,
! 	  not as an arithmetic expansion.  An arithmetic expansion must have
! 	  a closing `))'
  
! 				   5/14
  				   ----
! builtins/evalstring.c
! 	- the third argument to parse_and_execute() is now a flags word.
! 	  The caller can control the value of `interactive' and whether
! 	  or not history is disabled while parse_and_execute() runs
  
! builtins/common.h
! 	- new #defines for the flag values for parse_and_execute()
  
! {bashline,jobs,shell,subst,trap,variables}.c, parse.y, builtins/evalfile.c,
! builtins/{eval,fc}.def
! 	- changed calls to parse_and_execute appropriately
  
! builtins/evalfile.c
! 	- if _evalfile() is passed FEVAL_HISTORY as part of the flags arg,
! 	  don't pass SEVAL_NOHIST to parse_and_execute
! 	- new function: fc_execute_file, which sets FEVAL_HISTORY in the
! 	  flags argument to _evalfile()
  
  bashline.c
! 	- call bash_add_history instead of add_history from
! 	  vi_edit_and_execute_command so the bash state variables get
! 	  updated properly.  This keeps the `v' command from operating
! 	  on an empty command when the history list is stifled
  
  bashhist.c
! 	- bash_add_history is now global
  
! bashhist.h
! 	- extern declaration for bash_add_history
  
! builtins/fc.def
! 	- call fc_execute_file instead of maybe_execute_file in the
! 	  edit-and-re-execute case (fc -e ...)
! 	- don't manually insert the commands from the file created by `fc -e'
! 	  into the history list, just set remember_on_history and let
! 	  fc_execute_file take care of telling parse_and_execute to do the
! 	  right thing.  This makes compound commands and the `cmdhist'
! 	  and `lithist' settings work better.  This supersedes the fix of
! 	  1/27.  This was reported again by rchen@fractal.eng.yale.edu.
  
  parse.y
! 	- the body of a `for' command (the commands between do...done or
! 	  {...}) should be a `compound_list' instead of a `list'.  Problem
! 	  reported by cpg@research.bell-labs.com
  
+ 				   5/19
+ 				   ----
  lib/readline/complete.c
! 	- in filename_completion_function, if we find that the directory
! 	  pointer (return value from opendir(3)), is not null when state
! 	  is 0 (indicating that this is the first time the completion
! 	  function has been called for the current completion), call
! 	  closedir on it, assuming that it was left open by a previous
! 	  (interrupted) completion
  
! [bash-2.01-beta2 frozen]
  
! 				   5/27
! 				   ----
! Makefile.in
! 	- make sure that `make distclean' (and other clean targets) remove
! 	  the `printenv' executable
  
! tests/execscript, tests/redir.tests
! 	- make sure to set LANG=C and LC_ALL=C so the messages show up in
! 	  English
  
! tests/run-func
! 	- add a warning about exported functions in the environment
  
+ 				   5/29
+ 				   ----
  builtins/hash.def
! 	- if one of the arguments passed to `hash' is an absolute pathname,
! 	  just continue the loop, don't do list=list->next first.  This
! 	  fixes the `hash a/b' -> core dump bug
  
! 				   5/30
  				   ----
! general.c
! 	- change canonicalize_pathname to leave a leading `/' alone, as
! 	  POSIX requires
  
! 				    6/2
! 				    ---
! support/xenix-link.sh
! 	- shell script for linking bash under Xenix
  
+ 				    6/3
+ 				    ---
  bashline.c
! 	- fixed a memory leak in command_word_completion_function, courtesy
! 	  of a.pfaller@pop.gun.de
  
! hashcmd.c
! 	- fixed find_hashed_filename to always return a newly-allocated
! 	  string
  
! execute_cmd.c
! 	- since find_hashed_filename returns newly-allocated memory, don't
! 	  call savestring() on it, and free it if the data is stale (in
! 	  search_for_command()).  Another memory leak fixed courtesy of
! 	  a.pfaller@pop.gun.de
  
! builtins/type.def
! 	- free the value returned by find_hashed_filename
  
! [bash-2.01-release frozen]
diff -Nrc2 bash-2.0/INSTALL bash-2.01/INSTALL
*** bash-2.0/INSTALL	Tue Sep 10 12:08:07 1996
--- bash-2.01/INSTALL	Fri Apr 25 14:16:16 1997
***************
*** 2,6 ****
  ==================
  
! These are generic installation instructions for Bash.
  
  The `configure' shell script attempts to guess correct values for
--- 2,6 ----
  ==================
  
! These are installation instructions for Bash.
  
  The `configure' shell script attempts to guess correct values for
***************
*** 25,29 ****
  called Autoconf.  You only need `configure.in' if you want to change it
  or regenerate `configure' using a newer version of Autoconf.  If you do
! this, make sure you are using Autoconf version 2.9 or newer.
  
  The simplest way to compile Bash is:
--- 25,37 ----
  called Autoconf.  You only need `configure.in' if you want to change it
  or regenerate `configure' using a newer version of Autoconf.  If you do
! this, make sure you are using Autoconf version 2.10 or newer.
! 
! If you need to change `configure.in' or regenerate `configure', you
! will need to create two files: `_distribution' and `_patchlevel'.
! `_distribution' should contain the major and minor version numbers of
! the Bash distribution, for example `2.01'.  `_patchlevel' should
! contain the patch level of the Bash distribution, `0' for example.  The
! script `support/mkconffiles' has been provided to automate the creation
! of these files.
  
  The simplest way to compile Bash is:
***************
*** 180,190 ****
  the Bash `configure' recognizes.
  
! `--with-gnu-malloc'
!      Use the GNU version of `malloc' in `lib/malloc/malloc.c'.  This is
!      not the same `malloc' that appears in GNU libc, but an older
!      version derived from the 4.2 BSD `malloc'.  This `malloc' is very
!      fast, but wastes a lot of space.  This option is enabled by
!      default.  The `NOTES' file contains a list of systems for which
!      this should be turned off.
  
  `--with-glibc-malloc'
--- 188,198 ----
  the Bash `configure' recognizes.
  
! `--with-afs'
!      Define if you are using the Andrew File System from Transarc.
! 
! `--with-curses'
!      Use the curses library instead of the termcap library.  This should
!      be supplied if your system has an inadequate or incomplete termcap
!      database.
  
  `--with-glibc-malloc'
***************
*** 193,198 ****
       considerably less space.
  
! `--with-afs'
!      Define if you are using the Andrew File System from Transarc.
  
  `--with-purify'
--- 201,212 ----
       considerably less space.
  
! `--with-gnu-malloc'
!      Use the GNU version of `malloc' in `lib/malloc/malloc.c'.  This is
!      not the same `malloc' that appears in GNU libc, but an older
!      version derived from the 4.2 BSD `malloc'.  This `malloc' is very
!      fast, but wastes a lot of space.  This option is enabled by
!      default.  The `NOTES' file contains a list of systems for which
!      this should be turned off, and `configure' disables this option
!      automatically for a number of systems.
  
  `--with-purify'
***************
*** 212,241 ****
  does not provide the necessary support.
  
- `--enable-job-control'
-      This enables job control features, if the OS supports them.
- 
  `--enable-alias'
       Allow alias expansion and include the `alias' and `unalias'
       builtins.
  
! `--enable-readline'
!      Include support for command-line editing and history with the Bash
!      version of the Readline library.
! 
! `--enable-history'
!      Include command history and the `fc' and `history' builtin
!      commands.
  
  `--enable-bang-history'
       Include support for `csh'-like history substitution.
  
  `--enable-directory-stack'
       Include support for a `csh'-like directory stack and the `pushd',
       `popd', and `dirs' builtins.
  
! `--enable-restricted'
!      Include support for a "restricted shell".  If this is enabled,
!      Bash, when called as `rbash', enters a restricted mode.  See *Note
!      The Restricted Shell::, for a description of restricted mode.
  
  `--enable-process-substitution'
--- 226,271 ----
  does not provide the necessary support.
  
  `--enable-alias'
       Allow alias expansion and include the `alias' and `unalias'
       builtins.
  
! `--enable-array-variables'
!      Include support for one-dimensional array shell variables.
  
  `--enable-bang-history'
       Include support for `csh'-like history substitution.
  
+ `--enable-brace-expansion'
+      Include `csh'-like brace expansion ( `b{a,b}c' ==> `bac bbc' ).
+ 
+ `--enable-command-timing'
+      Include support for recognizing `time' as a reserved word and for
+      displaying timing statistics for the pipeline following `time'.
+      This allows pipelines as well as shell builtins and functions to
+      be timed.
+ 
  `--enable-directory-stack'
       Include support for a `csh'-like directory stack and the `pushd',
       `popd', and `dirs' builtins.
  
! `--enable-disabled-builtins'
!      Allow builtin commands to be invoked via `builtin xxx' even after
!      `xxx' has been disabled using `enable -n xxx'.  See *Note Bash
!      Builtins::, for details of the `builtin' and `enable' builtin
!      commands.
! 
! `--enable-dparen-arithmetic'
!      Include support for the `ksh' `((...))' command.
! 
! `--enable-help-builtin'
!      Include the `help' builtin, which displays help on shell builtins
!      and variables.
! 
! `--enable-history'
!      Include command history and the `fc' and `history' builtin
!      commands.
! 
! `--enable-job-control'
!      This enables job control features, if the OS supports them.
  
  `--enable-process-substitution'
***************
*** 248,279 ****
       strings.
  
  `--enable-select'
       Include the `ksh' `select' builtin, which allows the generation of
       simple menus.
- 
- `--enable-help-builtin'
-      Include the `help' builtin, which displays help on shell builtins
-      and variables.
- 
- `--enable-array-variables'
-      Include support for one-dimensional array shell variables.
- 
- `--enable-dparen-arithmetic'
-      Include support for the `ksh' `((...))' command.
- 
- `--enable-brace-expansion'
-      Include `csh'-like brace expansion ( `b{a,b}c' ==> `bac bbc' ).
- 
- `--enable-disabled-builtins'
-      Allow builtin commands to be invoked via `builtin xxx' even after
-      `xxx' has been disabled using `enable -n xxx'.  See *Note Bash
-      Builtins::, for details of the `builtin' and `enable' builtin
-      commands.
- 
- `--enable-command-timing'
-      Include support for recognizing `time' as a reserved word and for
-      displaying timing statistics for the pipeline following `time'.
-      This allows pipelines as well as shell builtins and functions to
-      be timed.
  
  `--enable-usg-echo-default'
--- 278,293 ----
       strings.
  
+ `--enable-readline'
+      Include support for command-line editing and history with the Bash
+      version of the Readline library.
+ 
+ `--enable-restricted'
+      Include support for a "restricted shell".  If this is enabled,
+      Bash, when called as `rbash', enters a restricted mode.  See *Note
+      The Restricted Shell::, for a description of restricted mode.
+ 
  `--enable-select'
       Include the `ksh' `select' builtin, which allows the generation of
       simple menus.
  
  `--enable-usg-echo-default'
diff -Nrc2 bash-2.0/MANIFEST bash-2.01/MANIFEST
*** bash-2.0/MANIFEST	Thu Dec 12 16:06:47 1996
--- bash-2.01/MANIFEST	Mon Jun  2 16:35:37 1997
***************
*** 41,44 ****
--- 41,45 ----
  NOTES		f
  README		f
+ AUTHORS		f
  configure.in	f
  configure	f
***************
*** 63,66 ****
--- 64,68 ----
  getcwd.c	f
  bashhist.c	f
+ hashcmd.c	f
  hashlib.c	f
  parse.y		f
***************
*** 113,120 ****
  subst.h		f
  dispose_cmd.h	f
  bashansi.h	f
  bashtty.h	f
  bashjmp.h	f
- bashwait.h	f
  bashintl.h	f
  make_cmd.h	f
--- 115,122 ----
  subst.h		f
  dispose_cmd.h	f
+ hashcmd.h	f
  bashansi.h	f
  bashtty.h	f
  bashjmp.h	f
  bashintl.h	f
  make_cmd.h	f
***************
*** 126,130 ****
--- 128,135 ----
  y.tab.h		f
  posixdir.h	f
+ posixjmp.h	f
  posixstat.h	f
+ posixwait.h	f
+ unionwait.h	f
  stdc.h		f
  ansi_stdlib.h	f
***************
*** 155,159 ****
  builtins/getopts.def	f
  builtins/hash.def	f
- builtins/hashcom.h	f
  builtins/help.def	f
  builtins/let.def	f
--- 160,163 ----
***************
*** 204,207 ****
--- 208,212 ----
  lib/malloc/x386-alloca.s	f
  lib/posixheaders/posixdir.h	f
+ lib/posixheaders/posixjmp.h	f
  lib/posixheaders/posixstat.h	f
  lib/posixheaders/ansi_stdlib.h	f
***************
*** 241,244 ****
--- 246,250 ----
  lib/readline/callback.c	f
  lib/readline/nls.c	f
+ lib/readline/shell.c	f
  lib/readline/tilde.c	f
  lib/readline/tilde.h	f
***************
*** 253,256 ****
--- 259,263 ----
  lib/readline/chardefs.h	f
  lib/readline/posixdir.h	f
+ lib/readline/posixjmp.h	f
  lib/readline/posixstat.h	f
  lib/readline/ansi_stdlib.h	f
***************
*** 267,270 ****
--- 274,278 ----
  lib/readline/examples/histexamp.c	f
  lib/readline/examples/rltest.c	f
+ lib/readline/examples/rl.c	f
  lib/readline/examples/Inputrc	f
  lib/termcap/Makefile.in	f
***************
*** 319,327 ****
  support/config.guess	f
  support/config.sub	f
! support/printenv	f	755
  support/bash.xbm	f
  support/mkclone		f	755
  support/mkdirs		f	755
! support/mkversion.c	f
  support/mksignames.c	f
  support/bashbug.sh	f
--- 327,337 ----
  support/config.guess	f
  support/config.sub	f
! support/printenv.sh	f	755
! support/printenv.c	f
  support/bash.xbm	f
  support/mkclone		f	755
+ support/mkconffiles	f	755
  support/mkdirs		f	755
! support/mkversion.sh	f	755
  support/mksignames.c	f
  support/bashbug.sh	f
***************
*** 333,336 ****
--- 343,347 ----
  support/texi2dvi	f
  support/texi2html	f
+ support/xenix-link.sh	f	755
  examples/bashdb/PERMISSION	f
  examples/bashdb/README	f
***************
*** 387,390 ****
--- 398,402 ----
  examples/functions/repeat2	f
  examples/functions/lowercase	f
+ examples/functions/xalias.bash	f
  examples/scripts/shprompt	f
  examples/scripts/adventure.sh	f
***************
*** 394,398 ****
--- 406,412 ----
  examples/scripts/nohup.bash	f
  examples/scripts/vtree2		f
+ examples/scripts/vtree3		f
  examples/scripts/scrollbar	f
+ examples/scripts/spin.bash	f
  examples/scripts/zprintf	f
  examples/startup-files/README	f
***************
*** 413,425 ****
--- 427,472 ----
  tests/braces-tests	f
  tests/braces.right	f
+ tests/builtins.tests	f
+ tests/builtins.right	f
+ tests/builtins.sub1	f
+ tests/source.sub1	f
+ tests/source.sub2	f
+ tests/source.sub3	f
+ tests/source.sub4	f
+ tests/dirstack.tests	f
+ tests/dirstack.right	f
  tests/dollar-at.sh	f
  tests/dollar-star.sh	f
  tests/dollar.right	f
+ tests/errors.tests	f
+ tests/errors.right	f
+ tests/execscript	f
+ tests/execscript.right	f
+ tests/execscript.sub	f	755
+ tests/execscript.sub2	f
+ tests/execscript.sub3	f
+ tests/execscript.sub4	f
  tests/exp-tests		f
  tests/exp.right		f
+ tests/func.tests	f
+ tests/func.right	f
+ tests/getopts.tests	f
+ tests/getopts.right	f
+ tests/getopts.sub1	f
+ tests/getopts.sub2	f
+ tests/getopts.sub3	f
+ tests/getopts.sub4	f
+ tests/getopts.sub5	f
+ tests/getopts.sub6	f
+ tests/getopts.sub7	f
  tests/glob-test		f
  tests/glob.right	f
  tests/heredoc.tests	f
  tests/heredoc.right	f
+ tests/histexpand.tests	f
+ tests/histexpand.right	f
+ tests/history.tests	f
+ tests/history.right	f
+ tests/history.list	f
  tests/ifs-test-1.sh	f
  tests/ifs-test-2.sh	f
***************
*** 431,439 ****
  tests/input-line.sub	f
  tests/input.right	f
! tests/minus-e		f
! tests/minus-e.right	f
  tests/more-exp.tests	f
  tests/more-exp.right	f
  tests/new-exp.tests	f
  tests/new-exp.right	f
  tests/nquote.tests	f
--- 478,487 ----
  tests/input-line.sub	f
  tests/input.right	f
! tests/jobs.tests	f
! tests/jobs.right	f
  tests/more-exp.tests	f
  tests/more-exp.right	f
  tests/new-exp.tests	f
+ tests/new-exp.sub1	f
  tests/new-exp.right	f
  tests/nquote.tests	f
***************
*** 447,463 ****
  tests/read.tests	f
  tests/read.right	f
  tests/rhs-exp.tests	f
  tests/rhs-exp.right	f
  tests/run-all		f
  tests/run-arith		f
  tests/run-array		f
  tests/run-braces	f
  tests/run-dollars	f
  tests/run-exp-tests	f
  tests/run-glob-test	f
  tests/run-heredoc	f
  tests/run-ifs-tests	f
  tests/run-input-test	f
! tests/run-minus-e	f
  tests/run-more-exp	f
  tests/run-new-exp	f
--- 495,531 ----
  tests/read.tests	f
  tests/read.right	f
+ tests/redir.tests	f
+ tests/redir.right	f
+ tests/redir1.sub	f
+ tests/redir2.sub	f
+ tests/redir3.sub	f
+ tests/redir3.in1	f
+ tests/redir3.in2	f
+ tests/redir4.sub	f
+ tests/redir4.in1	f
  tests/rhs-exp.tests	f
  tests/rhs-exp.right	f
+ tests/rsh.tests		f
+ tests/rsh.right		f
  tests/run-all		f
+ tests/run-minimal	f
  tests/run-arith		f
  tests/run-array		f
  tests/run-braces	f
+ tests/run-builtins	f
+ tests/run-dirstack	f
  tests/run-dollars	f
+ tests/run-errors	f
+ tests/run-execscript	f
  tests/run-exp-tests	f
+ tests/run-func		f
+ tests/run-getopts	f
  tests/run-glob-test	f
  tests/run-heredoc	f
+ tests/run-histexpand	f
+ tests/run-history	f
  tests/run-ifs-tests	f
  tests/run-input-test	f
! tests/run-jobs		f
  tests/run-more-exp	f
  tests/run-new-exp	f
***************
*** 467,475 ****
--- 535,547 ----
  tests/run-quote		f
  tests/run-read		f
+ tests/run-redir		f
  tests/run-rhs-exp	f
+ tests/run-rsh		f
  tests/run-set-e-test	f
  tests/run-strip		f
  tests/run-test		f
  tests/run-tilde		f
+ tests/run-trap		f
+ tests/run-type		f
  tests/run-varenv	f
  tests/set-e-test	f
***************
*** 481,499 ****
  tests/tilde-tests	f
  tests/tilde.right	f
  tests/varenv.right	f
  tests/varenv.sh		f
! tests/misc/chld-trap.sh	f
! tests/misc/dot-test-1.sh	f
! tests/misc/dot-test-1.sub	f
! tests/misc/gotest		f
  tests/misc/perf-script		f
- tests/misc/redir.t1.sh		f
  tests/misc/redir.t2.sh		f
- tests/misc/redir.t3.sh		f
- tests/misc/redir.t3.sub		f
- tests/misc/redir.t4.sh		f
- tests/misc/run.r1.sh	f
  tests/misc/run.r2.sh	f
- tests/misc/run.r3.sh	f
  tests/misc/sigint.t1.sh		f
  tests/misc/sigint.t2.sh		f
--- 553,569 ----
  tests/tilde-tests	f
  tests/tilde.right	f
+ tests/trap.tests	f
+ tests/trap.right	f
+ tests/trap.sub1		f	755
+ tests/type.tests	f
+ tests/type.right	f
  tests/varenv.right	f
  tests/varenv.sh		f
! tests/version		f
! tests/version.mini	f
! tests/misc/haertel.perftest	f
  tests/misc/perf-script		f
  tests/misc/redir.t2.sh		f
  tests/misc/run.r2.sh	f
  tests/misc/sigint.t1.sh		f
  tests/misc/sigint.t2.sh		f
diff -Nrc2 bash-2.0/Makefile.in bash-2.01/Makefile.in
*** bash-2.0/Makefile.in	Wed Dec 18 14:57:21 1996
--- bash-2.01/Makefile.in	Wed May 28 13:34:27 1997
***************
*** 1,2 ****
--- 1,4 ----
+ # Makefile for bash-2.01, version 2.32
+ #
  # Make sure the first target in the makefile is the right one
  all: .made
***************
*** 40,43 ****
--- 42,47 ----
  COMPRESS_EXT = .gz
  
+ TESTSCRIPT = @TESTSCRIPT@
+ 
  #If you have purify, and want to use it, uncomment this definition or
  # run the make as `make PURIFY=purify'
***************
*** 51,62 ****
  	$(CC) $(CCFLAGS) -c $<
  
! # The name of this program.
  Program = bash
  Machine = @host_cpu@
  OS = @host_os@
  MACHTYPE = @host@
  
- RELSTATUS = release
- 
  THIS_SH = $(BUILD_DIR)/$(Program)
  
--- 55,68 ----
  	$(CC) $(CCFLAGS) -c $<
  
! # The name of this program and some version information.
  Program = bash
+ Version = @BASHVERS@
+ PatchLevel = @BASHPATCH@
+ RELSTATUS = release
+ 
  Machine = @host_cpu@
  OS = @host_os@
  MACHTYPE = @host@
  
  THIS_SH = $(BUILD_DIR)/$(Program)
  
***************
*** 65,73 ****
  PROFILE_FLAGS=
  
- # set to alloca.o if we are using the C alloca in lib/malloc
- ALLOCA = @ALLOCA@
- ALLOCA_SOURCE = @ALLOCA_SOURCE@
- ALLOCA_OBJECT = @ALLOCA_OBJECT@
- 
  # The GNU coding standards don't recognize the possibility that
  # other information besides optimization and debugging might be
--- 71,74 ----
***************
*** 76,79 ****
--- 77,81 ----
  LOCAL_CFLAGS = @LOCAL_CFLAGS@
  DEFS = @DEFS@
+ LOCAL_DEFS = @LOCAL_DEFS@
  LOCAL_LIBS = @LOCAL_LIBS@
  LIBS = $(BUILTINS_LIB) $(LIBRARIES) $(LOCAL_LIBS) @LIBS@
***************
*** 83,87 ****
  SYSTEM_FLAGS = -DPROGRAM='"$(Program)"' -DHOSTTYPE='"$(Machine)"' -DOSTYPE='"$(OS)"' -DMACHTYPE='"$(MACHTYPE)"'
  
! CCFLAGS	= $(PROFILE_FLAGS) $(SYSTEM_FLAGS) -DSHELL \
  	  $(DEFS) $(LOCAL_CFLAGS) $(CPPFLAGS) $(INCLUDES) $(CFLAGS)
  
--- 85,89 ----
  SYSTEM_FLAGS = -DPROGRAM='"$(Program)"' -DHOSTTYPE='"$(Machine)"' -DOSTYPE='"$(OS)"' -DMACHTYPE='"$(MACHTYPE)"'
  
! CCFLAGS	= $(PROFILE_FLAGS) $(SYSTEM_FLAGS) $(LOCAL_DEFS) \
  	  $(DEFS) $(LOCAL_CFLAGS) $(CPPFLAGS) $(INCLUDES) $(CFLAGS)
  
***************
*** 133,136 ****
--- 135,139 ----
  		  $(RL_LIBSRC)/terminal.c $(RL_LIBSRC)/nls.c \
  		  $(RL_LIBSRC)/input.c $(RL_LIBSRC)/xmalloc.c \
+ 		  $(RL_LIBSRC)/shell.c \
  		  $(RL_LIBSRC)/histexpand.c $(RL_LIBSRC)/history.c \
  		  $(RL_LIBSRC)/histsearch.c $(RL_LIBSRC)/histfile.c
***************
*** 146,149 ****
--- 149,153 ----
  		  $(RL_LIBDIR)/macro.o $(RL_LIBDIR)/input.o \
  		  $(RL_LIBDIR)/terminal.o $(RL_LIBDIR)/callback.o \
+ 		  $(RL_LIBDIR)/shell.o \
  		  $(RL_LIBDIR)/history.o $(RL_LIBDIR)/histexpand.o \
  		  $(RL_LIBDIR)/histsearch.o $(RL_LIBDIR)/histfile.o
***************
*** 161,167 ****
  HISTORY_SOURCE	= $(HIST_LIBSRC)/history.c $(HIST_LIBSRC)/histexpand.c \
  		  $(HIST_LIBSRC)/histsearch.c $(HIST_LIBSRC)/histfile.c \
  		  $(HIST_LIBSRC)/history.h $(HIST_LIBSRC)/histlib.h
  HISTORY_OBJ	= $(HIST_LIBDIR)/history.o $(HIST_LIBDIR)/histexpand.o \
! 		  $(HIST_LIBDIR)/histsearch.o $(HIST_LIBDIR)/histfile.o
  
  # You only need termcap (or curses) if you are linking with GNU Readline.
--- 165,173 ----
  HISTORY_SOURCE	= $(HIST_LIBSRC)/history.c $(HIST_LIBSRC)/histexpand.c \
  		  $(HIST_LIBSRC)/histsearch.c $(HIST_LIBSRC)/histfile.c \
+ 		  $(HIST_LIBSRC)/shell.c \
  		  $(HIST_LIBSRC)/history.h $(HIST_LIBSRC)/histlib.h
  HISTORY_OBJ	= $(HIST_LIBDIR)/history.o $(HIST_LIBDIR)/histexpand.o \
! 		  $(HIST_LIBDIR)/histsearch.o $(HIST_LIBDIR)/histfile.o \
! 		  $(HIST_LIBDIR)/shell.o
  
  # You only need termcap (or curses) if you are linking with GNU Readline.
***************
*** 205,217 ****
  
  # Our malloc.
  ALLOC_LIBSRC = $(LIBSRC)/malloc
  ALLOC_LIBDIR = $(dot)/$(LIBSUBDIR)/malloc
  ALLOC_ABSSRC = ${topdir}/$(ALLOC_LIBDIR)
  
- ALLOCA_DEP = $(ALLOC_LIBDIR)/@ALLOCA@
- 
- MALLOC_OBJ = $(ALLOC_LIBDIR)/@MALLOC@
  MALLOC_SRC = @MALLOC_SRC@
! MALLOC_CFLAGS = -Drcheck -Dbotch=programming_error
  
  MALLOC_LIB     = -lmalloc
--- 211,226 ----
  
  # Our malloc.
+ MALLOC_TARGET = @MALLOC_TARGET@
+ 
+ # set to alloca.o if we are using the C alloca in lib/malloc
+ ALLOCA = @ALLOCA@
+ 
  ALLOC_LIBSRC = $(LIBSRC)/malloc
  ALLOC_LIBDIR = $(dot)/$(LIBSUBDIR)/malloc
  ALLOC_ABSSRC = ${topdir}/$(ALLOC_LIBDIR)
  
  MALLOC_SRC = @MALLOC_SRC@
! MALLOC_SOURCE = ${ALLOC_LIBSRC}/${MALLOC_SRC}
! MALLOC_CFLAGS = -DRCHECK -Dbotch=programming_error
  
  MALLOC_LIB     = -lmalloc
***************
*** 222,230 ****
  ALLOC_HEADERS = $(ALLOC_LIBSRC)/getpagesize.h
  
! $(MALLOC_LIBRARY): $(MALLOC_SRC)
! 		@$(RM) $@
  		@(cd $(ALLOC_LIBDIR) && \
  		 $(MAKE) $(MFLAGS) \
! 		 MALLOC_CFLAGS="$(MALLOC_CFLAGS)" libmalloc.a ) || exit 1
  
  BASHPOSIX_LIB     = $(LIBSRC)/posixheaders
--- 231,238 ----
  ALLOC_HEADERS = $(ALLOC_LIBSRC)/getpagesize.h
  
! $(MALLOC_LIBRARY):	${MALLOC_SOURCE}
  		@(cd $(ALLOC_LIBDIR) && \
  		 $(MAKE) $(MFLAGS) \
! 		 MALLOC_CFLAGS="$(MALLOC_CFLAGS)" ${MALLOC_TARGET} ) || exit 1
  
  BASHPOSIX_LIB     = $(LIBSRC)/posixheaders
***************
*** 248,263 ****
  CSOURCES = shell.c eval.c parse.y general.c make_cmd.c print_cmd.c y.tab.c \
  	   dispose_cmd.c execute_cmd.c variables.c $(GLOBC) version.c \
! 	   expr.c copy_cmd.c flags.c subst.c hashlib.c mailcheck.c \
! 	   test.c trap.c jobs.c nojobs.c $(ALLOC_FILES) braces.c \
  	   vprint.c input.c bashhist.c array.c sig.c pathexp.c oslib.c \
! 	   unwind_prot.c siglist.c getcwd.c $(RL_SUPPORT_SRC) error.c \
  	   list.c stringlib.c locale.c xmalloc.c
  
! HSOURCES = shell.h flags.h trap.h hashlib.h jobs.h builtins.h alias.c y.tab.h \
  	   general.h variables.h config.h $(ALLOC_HEADERS) alias.h maxpath.h \
! 	   quit.h posixstat.h filecntl.h unwind_prot.h \
  	   command.h input.h error.h bashansi.h dispose_cmd.h make_cmd.h \
  	   subst.h externs.h siglist.h bashhist.h bashline.h bashtypes.h \
! 	   array.h sig.h mailcheck.h bashtty.h
  
  SOURCES	 = $(CSOURCES) $(HSOURCES) $(BUILTIN_DEFS)
--- 256,273 ----
  CSOURCES = shell.c eval.c parse.y general.c make_cmd.c print_cmd.c y.tab.c \
  	   dispose_cmd.c execute_cmd.c variables.c $(GLOBC) version.c \
! 	   expr.c copy_cmd.c flags.c subst.c hashcmd.c hashlib.c mailcheck.c \
! 	   test.c trap.c alias.c jobs.c nojobs.c $(ALLOC_FILES) braces.c \
  	   vprint.c input.c bashhist.c array.c sig.c pathexp.c oslib.c \
! 	   unwind_prot.c siglist.c getcwd.c bashline.c bracecomp.c error.c \
  	   list.c stringlib.c locale.c xmalloc.c
  
! HSOURCES = shell.h flags.h trap.h hashcmd.h hashlib.h jobs.h builtins.h \
  	   general.h variables.h config.h $(ALLOC_HEADERS) alias.h maxpath.h \
! 	   quit.h posixdir.h posixstat.h filecntl.h unwind_prot.h ansi_stdlib.h \
  	   command.h input.h error.h bashansi.h dispose_cmd.h make_cmd.h \
  	   subst.h externs.h siglist.h bashhist.h bashline.h bashtypes.h \
! 	   array.h sig.h mailcheck.h bashtty.h bashintl.h bashjmp.h ${GRAM_H} \
! 	   posixwait.h execute_cmd.h memalloc.h parser.h pathexp.h pathnames.h \
! 	   posixjmp.h stdc.h unionwait.h $(BASHPOSIX_SUPPORT)
  
  SOURCES	 = $(CSOURCES) $(HSOURCES) $(BUILTIN_DEFS)
***************
*** 269,274 ****
  OBJECTS	 = shell.o eval.o y.tab.o general.o make_cmd.o print_cmd.o $(GLOBO) \
  	   dispose_cmd.o execute_cmd.o variables.o copy_cmd.o error.o \
! 	   expr.o flags.o $(JOBS_O) subst.o hashlib.o mailcheck.o test.o \
! 	   trap.o input.o unwind_prot.o pathexp.o sig.o version.o \
  	   alias.o array.o braces.o bracecomp.o bashhist.o bashline.o \
  	   getcwd.o siglist.o vprint.o oslib.o list.o stringlib.o \
--- 279,284 ----
  OBJECTS	 = shell.o eval.o y.tab.o general.o make_cmd.o print_cmd.o $(GLOBO) \
  	   dispose_cmd.o execute_cmd.o variables.o copy_cmd.o error.o \
! 	   expr.o flags.o $(JOBS_O) subst.o hashcmd.o hashlib.o mailcheck.o \
! 	   trap.o input.o unwind_prot.o pathexp.o sig.o test.o version.o \
  	   alias.o array.o braces.o bracecomp.o bashhist.o bashline.o \
  	   getcwd.o siglist.o vprint.o oslib.o list.o stringlib.o \
***************
*** 297,302 ****
  BUILTIN_C_SRC  = $(DEFSRC)/mkbuiltins.c $(DEFSRC)/common.c \
  		 $(DEFSRC)/evalstring.c $(DEFSRC)/evalfile.c \
! 		 $(DEFSRC)/bashgetopt.c $(GETOPT_SOURCE) \
! 		 $(DEFSRC)/hashcom.h 
  BUILTIN_C_OBJ  = $(DEFDIR)/common.o $(DEFDIR)/evalstring.o \
  		 $(DEFDIR)/evalfile.o $(DEFDIR)/bashgetopt.o
--- 307,311 ----
  BUILTIN_C_SRC  = $(DEFSRC)/mkbuiltins.c $(DEFSRC)/common.c \
  		 $(DEFSRC)/evalstring.c $(DEFSRC)/evalfile.c \
! 		 $(DEFSRC)/bashgetopt.c $(GETOPT_SOURCE)
  BUILTIN_C_OBJ  = $(DEFDIR)/common.o $(DEFDIR)/evalstring.o \
  		 $(DEFDIR)/evalfile.o $(DEFDIR)/bashgetopt.o
***************
*** 318,322 ****
  PSIZE_SOURCE	= $(DEFSRC)/psize.sh $(DEFSRC)/psize.c
  
! BUILTINS_LIBRARY = builtins/libbuiltins.a
  BUILTINS_LIB = -lbuiltins
  BUILTINS_LDFLAGS = -L$(DEFDIR)
--- 327,331 ----
  PSIZE_SOURCE	= $(DEFSRC)/psize.sh $(DEFSRC)/psize.c
  
! BUILTINS_LIBRARY = $(DEFDIR)/libbuiltins.a
  BUILTINS_LIB = -lbuiltins
  BUILTINS_LDFLAGS = -L$(DEFDIR)
***************
*** 325,337 ****
  # Documentation for the shell.
  DOCSRC = $(srcdir)/doc
! DOCDIR = ./doc
  
  SIGNAMES_SUPPORT = $(SUPPORT_SRC)mksignames.c
  
  SUPPORT_SRC = $(srcdir)/support/
! SDIR = ./support/
  
! CREATED_SUPPORT = signames.h recho zecho tests/recho tests/zecho \
! 		  tests/printenv mksignames mkversion 
  CREATED_CONFIGURE = config.h config.cache config.status config.log \
  		    stamp-h
--- 334,347 ----
  # Documentation for the shell.
  DOCSRC = $(srcdir)/doc
! DOCDIR = $(dot)/doc
  
  SIGNAMES_SUPPORT = $(SUPPORT_SRC)mksignames.c
  
  SUPPORT_SRC = $(srcdir)/support/
! SDIR = $(dot)/support/
  
! TESTS_SUPPORT = recho zecho printenv
! CREATED_SUPPORT = signames.h recho zecho printenv tests/recho tests/zecho \
! 		  tests/printenv mksignames 
  CREATED_CONFIGURE = config.h config.cache config.status config.log \
  		    stamp-h
***************
*** 345,351 ****
  
  .made: $(Program) bashbug
! 	cp .machine .made
  
! $(Program):  .build $(OBJECTS) $(BUILTINS_DEP) $(LIBDEP) $(srcdir)/.distribution
  	$(RM) $@
  	$(PURIFY) $(CC) $(LDFLAGS) $(BUILTINS_LDFLAGS) $(LIBRARY_LDFLAGS) -o $(Program) $(OBJECTS) $(LIBS)
--- 355,361 ----
  
  .made: $(Program) bashbug
! 	@echo "$(Program) last made for a $(Machine) running $(OS)" >.made
  
! $(Program):  .build $(OBJECTS) $(BUILTINS_DEP) $(LIBDEP)
  	$(RM) $@
  	$(PURIFY) $(CC) $(LDFLAGS) $(BUILTINS_LDFLAGS) $(LIBRARY_LDFLAGS) -o $(Program) $(OBJECTS) $(LIBS)
***************
*** 353,374 ****
  	size $(Program)
  
! .build:	$(SOURCES) config.h Makefile mkversion version.h .machine
  	@echo
  	@echo "	  ***********************************************************"
  	@echo "	  *                                                         *"
! 	@echo "	  * Making Bash-`cat $(srcdir)/.distribution`.`cat $(srcdir)/.patchlevel`-$(RELSTATUS) for a $(Machine) running $(OS)"
  	@echo "	  *                                                         *"
  	@echo "	  ***********************************************************"
  	@echo
  
! .machine: $(SOURCES) config.h Makefile mkversion version.h
! 	@echo "$(Program) last made for a $(Machine) running $(OS)" >.machine
! 
! bashbug: $(SUPPORT_SRC)bashbug.sh mkversion config.h Makefile
! 	@sed -e "s:!MACHINE!:$(Machine):" -e "s:!OS!:$(OS):" \
! 	     -e "s:!CFLAGS!:$(CCFLAGS):" -e "s:!CC!:$(CC):" \
! 	     -e "s:!RELEASE!:`cat $(srcdir)/.distribution`:" \
! 	     -e "s:!PATCHLEVEL!:`cat $(srcdir)/.patchlevel`:" \
! 	     -e "s:!MACHTYPE!:$(MACHTYPE):" -e "s:!RELSTATUS!:$(RELSTATUS):" \
  	     $(SUPPORT_SRC)bashbug.sh > $@
  	@chmod a+rx bashbug
--- 363,380 ----
  	size $(Program)
  
! .build:	$(SOURCES) config.h Makefile version.h
  	@echo
  	@echo "	  ***********************************************************"
  	@echo "	  *                                                         *"
! 	@echo "	  * Making Bash-$(Version).$(PatchLevel)-$(RELSTATUS) for a $(Machine) running $(OS)"
  	@echo "	  *                                                         *"
  	@echo "	  ***********************************************************"
  	@echo
  
! bashbug: $(SUPPORT_SRC)bashbug.sh config.h Makefile
! 	@sed -e "s%!MACHINE!%$(Machine)%" -e "s%!OS!%$(OS)%" \
! 	     -e "s%!CFLAGS!%$(CCFLAGS)%" -e "s%!CC!%$(CC)%" \
! 	     -e "s%!RELEASE!%$(Version)%" -e "s%!PATCHLEVEL!%$(PatchLevel)%" \
! 	     -e "s%!MACHTYPE!%$(MACHTYPE)%" -e "s%!RELSTATUS!%$(RELSTATUS)%" \
  	     $(SUPPORT_SRC)bashbug.sh > $@
  	@chmod a+rx bashbug
***************
*** 379,395 ****
  	size $(Program)
  
! version.h:  $(SOURCES) config.h Makefile mkversion .patchlevel .distribution
! 	if ./mkversion -dir $(srcdir) -build -status $(RELSTATUS); then mv -f newversion.h version.h; fi
  
  # old rules
! y.tab.o: y.tab.c parser-built
! y.tab.c: parser-built
! y.tab.h: parser-built
! parser-built:	parse.y command.h stdc.h input.h
! 	$(RM) $@
! 	-if test -f y.tab.h; then mv -f y.tab.h old-y.tab.h; fi
  	$(YACC) -d $(srcdir)/parse.y
! 	-if cmp -s old-y.tab.h y.tab.h; then mv old-y.tab.h y.tab.h; fi
! 	touch $@
  
  # experimental new rules - work with GNU make but not BSD (or OSF) make
--- 385,403 ----
  	size $(Program)
  
! version.h:  $(SOURCES) config.h Makefile 
! 	if $(SHELL) $(SUPPORT_SRC)mkversion.sh -b -s $(RELSTATUS) -d $(Version) -p $(PatchLevel) -o newversion.h; \
! 	then mv newversion.h version.h; fi;
  
  # old rules
! GRAM_H = parser-built
! y.tab.o: y.tab.c ${GRAM_H} command.h stdc.h input.h
! ${GRAM_H}:	y.tab.h
! 	@-if test -f y.tab.h ; then \
! 		cmp -s $@ y.tab.h 2>/dev/null || cp -p y.tab.h $@; \
! 	fi
! y.tab.c y.tab.h: parse.y
! #	-if test -f y.tab.h; then mv -f y.tab.h old-y.tab.h; fi
  	$(YACC) -d $(srcdir)/parse.y
! #	-if cmp -s old-y.tab.h y.tab.h; then mv old-y.tab.h y.tab.h; else cp -p y.tab.h ${GRAM_H}; fi
  
  # experimental new rules - work with GNU make but not BSD (or OSF) make
***************
*** 403,407 ****
  	@echo making $@ in ${RL_LIBDIR}
  	@(cd ${RL_LIBDIR} && \
! 		$(MAKE) $(MFLAGS) APP_CFLAGS=-DSHELL libreadline.a) || exit 1
  
  $(HISTORY_LIBRARY): config.h $(HISTORY_SOURCE)
--- 411,415 ----
  	@echo making $@ in ${RL_LIBDIR}
  	@(cd ${RL_LIBDIR} && \
! 		$(MAKE) $(MFLAGS) libreadline.a) || exit 1
  
  $(HISTORY_LIBRARY): config.h $(HISTORY_SOURCE)
***************
*** 421,426 ****
  
  $(TERMCAP_LIBRARY): config.h ${TERMCAP_SOURCE}
! 	@echo making $@ in ${TERMCAP_LIBDIR}	
! 	@(cd ${TERMCAP_LIBDIR} && \
  		$(MAKE) $(MFLAGS) libtermcap.a) || exit 1
  
--- 429,434 ----
  
  $(TERMCAP_LIBRARY): config.h ${TERMCAP_SOURCE}
! 	@echo making $@ in ${TERM_LIBDIR}	
! 	@(cd ${TERM_LIBDIR} && \
  		$(MAKE) $(MFLAGS) libtermcap.a) || exit 1
  
***************
*** 436,446 ****
  
  # these require special rules to circumvent make builtin rules
! builtins/common.o:	$(BUILTIN_SRCDIR)/common.c
  	@(cd $(DEFDIR) && $(MAKE) $(MFLAGS) common.o) || exit 1
  
! builtins/bashgetopt.o:	$(BUILTIN_SRCDIR)/bashgetopt.c
  	@(cd $(DEFDIR) && $(MAKE) $(MFLAGS) bashgetopt.o) || exit 1
  
! builtins/builtext.h: $(BUILTIN_DEFS)
  	@(cd $(DEFDIR) && $(MAKE) $(MFLAGS) builtext.h ) || exit 1
  
--- 444,454 ----
  
  # these require special rules to circumvent make builtin rules
! ${DEFDIR}/common.o:	$(BUILTIN_SRCDIR)/common.c
  	@(cd $(DEFDIR) && $(MAKE) $(MFLAGS) common.o) || exit 1
  
! ${DEFDIR}/bashgetopt.o:	$(BUILTIN_SRCDIR)/bashgetopt.c
  	@(cd $(DEFDIR) && $(MAKE) $(MFLAGS) bashgetopt.o) || exit 1
  
! ${DEFDIR}/builtext.h: $(BUILTIN_DEFS)
  	@(cd $(DEFDIR) && $(MAKE) $(MFLAGS) builtext.h ) || exit 1
  
***************
*** 448,453 ****
  # `Automatic Remaking' in GNU Autoconf documentation.
  
! Makefile:	config.status $(srcdir)/Makefile.in
! 	CONFIG_FILES=$@ CONFIG_HEADERS= $(SHELL) ./config.status
  
  Makefiles makefiles:	config.status $(srcdir)/Makefile.in
--- 456,461 ----
  # `Automatic Remaking' in GNU Autoconf documentation.
  
! Makefile makefile:	config.status $(srcdir)/Makefile.in
! 	CONFIG_FILES=Makefile CONFIG_HEADERS= $(SHELL) ./config.status
  
  Makefiles makefiles:	config.status $(srcdir)/Makefile.in
***************
*** 468,479 ****
  #	cd $(srcdir) && autoconf
  
! mkversion:	$(SUPPORT_SRC)mkversion.c
! 	$(CC) $(CCFLAGS) -I.. -o $@ $(SUPPORT_SRC)mkversion.c
! 
! newversion:	mkversion
! 	$(RM) .build
! 	./mkversion -dir $(srcdir) -dist
! 	mv -f newversion.h version.h
! 	$(MAKE) -f $(srcdir)/Makefile $(MFLAGS) srcdir=$(srcdir)
  
  doc documentation:  force
--- 476,484 ----
  #	cd $(srcdir) && autoconf
  
! #newversion:	mkversion
! #	$(RM) .build
! #	./mkversion -dir $(srcdir) -dist
! #	mv -f newversion.h version.h
! #	$(MAKE) -f $(srcdir)/Makefile $(MFLAGS) srcdir=$(srcdir)
  
  doc documentation:  force
***************
*** 520,524 ****
  basic-clean:
  	$(RM) $(OBJECTS) $(Program) bashbug
! 	$(RM) .build .made .machine version.h
  
  clean:	basic-clean
--- 525,529 ----
  basic-clean:
  	$(RM) $(OBJECTS) $(Program) bashbug
! 	$(RM) .build .made version.h
  
  clean:	basic-clean
***************
*** 558,562 ****
  	@echo This command is intended for maintainers to use.
  	@echo It deletes files that may require special tools to rebuild.
! 	$(RM) y.tab.c y.tab.h parser-built tags TAGS
  	( cd $(DOCDIR) && $(MAKE) $(MFLAGS) $@ )
  	( cd builtins && $(MAKE) $(MFLAGS) $@ )
--- 563,567 ----
  	@echo This command is intended for maintainers to use.
  	@echo It deletes files that may require special tools to rebuild.
! 	$(RM) y.tab.c y.tab.h parser-built.h tags TAGS
  	( cd $(DOCDIR) && $(MAKE) $(MFLAGS) $@ )
  	( cd builtins && $(MAKE) $(MFLAGS) $@ )
***************
*** 571,584 ****
  
  recho:		$(SUPPORT_SRC)recho.c
! 	@$(CC) -o $@ $(SUPPORT_SRC)recho.c
  
  zecho:		$(SUPPORT_SRC)zecho.c
! 	@$(CC) -o $@ $(SUPPORT_SRC)zecho.c
  
! tests check:		force $(Program) recho zecho
  	@-test -d tests || mkdir tests
! 	@cp recho zecho $(SUPPORT_SRC)printenv tests
  	@( cd $(srcdir)/tests && \
! 		PATH=$$PATH:$(BUILD_DIR)/tests THIS_SH=$(THIS_SH) sh run-all )
  
  symlinks:
--- 576,592 ----
  
  recho:		$(SUPPORT_SRC)recho.c
! 	@$(CC) $(CCFLAGS) -o $@ $(SUPPORT_SRC)recho.c
  
  zecho:		$(SUPPORT_SRC)zecho.c
! 	@$(CC) $(CCFLAGS) -o $@ $(SUPPORT_SRC)zecho.c
! 
! printenv:		$(SUPPORT_SRC)printenv.c
! 	@$(CC) $(CCFLAGS) -o $@ $(SUPPORT_SRC)printenv.c
  
! test tests check:		force $(Program) $(TESTS_SUPPORT)
  	@-test -d tests || mkdir tests
! 	@cp $(TESTS_SUPPORT) tests
  	@( cd $(srcdir)/tests && \
! 		PATH=$$PATH:$(BUILD_DIR)/tests THIS_SH=$(THIS_SH) sh ${TESTSCRIPT} )
  
  symlinks:
***************
*** 588,594 ****
  	@echo Bash distributions are created using $(srcdir)/support/mkdist.
  	@echo Here is a sample of the necessary commands:
! 	@echo $(Program) $(srcdir)/support/mkdist -m $(srcdir)/MANIFEST -s $(srcdir) -r ${Program} `cat $(srcdir)/.distribution`
! 	@echo tar cf $(Program)-`cat $(srcdir)/.distribution`.tar ${Program}-`cat $(srcdir)/.distribution`
! 	@echo gzip $(Program)-`cat $(srcdir)/.distribution`.tar
  
  ############################ DEPENDENCIES ###############################
--- 596,607 ----
  	@echo Bash distributions are created using $(srcdir)/support/mkdist.
  	@echo Here is a sample of the necessary commands:
! 	@echo $(Program) $(srcdir)/support/mkdist -m $(srcdir)/MANIFEST -s $(srcdir) -r ${Program} $(Version)
! 	@echo tar cf $(Program)-$(Version).tar ${Program}-$(Version)
! 	@echo gzip $(Program)-$(Version).tar
! 
! depend:	depends
! 
! sdepend: force
! 	$(Program) $(SUPPORT_SRC)mkdep -c ${CC} -- ${CCFLAGS} ${CSOURCES}
  
  ############################ DEPENDENCIES ###############################
***************
*** 602,736 ****
  nojobs.o: config.h.top
  execute_cmd.o: config.h.top
- builtins/break.o: config.h.top
- builtins/common.o: config.h.top
- builtins/echo.o: config.h.top
  variables.o: config.h.top
  builtins/command.o: config.h.top
! 
! copy_cmd.o: shell.h bashjmp.h sig.h command.h stdc.h hashlib.h
! copy_cmd.o: general.h variables.h config.h memalloc.h quit.h
! copy_cmd.o: dispose_cmd.h make_cmd.h subst.h externs.h
! dispose_cmd.o: shell.h bashjmp.h sig.h command.h stdc.h
! dispose_cmd.o: general.h variables.h config.h memalloc.h quit.h
! dispose_cmd.o: dispose_cmd.h make_cmd.h subst.h externs.h
! error.o: error.h
! execute_cmd.o: shell.h bashjmp.h sig.h command.h stdc.h y.tab.h posixstat.h
! execute_cmd.o: general.h variables.h config.h memalloc.h quit.h hashlib.h jobs.h
! execute_cmd.o: unwind_prot.h siglist.h builtins/builtext.h config.h flags.h
! execute_cmd.o: dispose_cmd.h make_cmd.h subst.h externs.h bashtypes.h
! execute_cmd.o: pathexp.h
! expr.o: shell.h bashjmp.h sig.h command.h stdc.h hashlib.h
! expr.o: general.h variables.h config.h memalloc.h quit.h
! expr.o: dispose_cmd.h make_cmd.h subst.h externs.h
! flags.o: flags.h stdc.h config.h memalloc.h general.h quit.h
! general.o: shell.h bashjmp.h sig.h command.h stdc.h maxpath.h
! general.o: general.h variables.h config.h memalloc.h quit.h unwind_prot.h
! general.o: dispose_cmd.h make_cmd.h subst.h externs.h stdc.h
! getcwd.o: config.h config.h.bot bashtypes.h maxpath.h posixstat.h
! hashlib.o: shell.h bashjmp.h sig.h command.h stdc.h hashlib.h
! hashlib.o: general.h variables.h config.h memalloc.h quit.h
! hashlib.o: dispose_cmd.h make_cmd.h subst.h externs.h stdc.h
! jobs.o: shell.h bashjmp.h sig.h command.h stdc.h hashlib.h trap.h jobs.h 
! jobs.o: general.h variables.h config.h memalloc.h quit.h bashtty.h siglist.h
! jobs.o: dispose_cmd.h make_cmd.h subst.h externs.h builtins/builtext.h
! jobs.o: unwind_prot.h
! mailcheck.o: posixstat.h maxpath.h variables.h
! mailcheck.o: hashlib.h quit.h mailcheck.h
! make_cmd.o: shell.h bashjmp.h sig.h command.h stdc.h flags.h input.h 
! make_cmd.o: general.h variables.h config.h memalloc.h quit.h bashtypes.h
! make_cmd.o: dispose_cmd.h make_cmd.h subst.h externs.h
! y.tab.o: shell.h bashjmp.h sig.h command.h stdc.h flags.h maxpath.h alias.h
! y.tab.o: general.h variables.h config.h memalloc.h quit.h mailcheck.h parser.h
! y.tab.o: dispose_cmd.h make_cmd.h subst.h externs.h bashtypes.h bashline.h
! y.tab.o: builtins/builtext.h
! print_cmd.o: shell.h bashjmp.h sig.h command.h stdc.h y.tab.h
! print_cmd.o: general.h variables.h config.h memalloc.h quit.h
! print_cmd.o: dispose_cmd.h make_cmd.h subst.h externs.h unwind_prot.h
! shell.o: shell.h bashjmp.h sig.h command.h stdc.h flags.h stdc.h
! shell.o: general.h variables.h config.h memalloc.h quit.h
! shell.o: dispose_cmd.h make_cmd.h subst.h externs.h mailcheck.h
! shell.o: posixstat.h filecntl.h jobs.h input.h
! subst.o: shell.h bashjmp.h sig.h command.h stdc.h flags.h jobs.h siglist.h
! subst.o: general.h variables.h config.h memalloc.h quit.h bashtypes.h
! subst.o: dispose_cmd.h make_cmd.h subst.h externs.h execute_cmd.h
! subst.o: ${DEFSRC}/getopt.h pathexp.h bashline.h
! pathexp.o: config.h shell.h bashjmp.h command.h stdc.h general.h
! pathexp.o: error.h variables.h quit.h maxpath.h unwind_prot.h dispose_cmd.h
  pathexp.o: make_cmd.h subst.h sig.h pathnames.h externs.h
  pathexp.o: $(GLOB_LIBSRC)/glob.h $(GLOB_LIBSRC)/fnmatch.h
! test.o: posixstat.h
! trap.o: trap.h shell.h bashjmp.h sig.h command.h stdc.h hashlib.h unwind_prot.h
! trap.o: general.h variables.h config.h memalloc.h quit.h signames.h
! trap.o: dispose_cmd.h make_cmd.h subst.h externs.h
! unwind_prot.o: config.h memalloc.h general.h unwind_prot.h sig.h
! variables.o: shell.h bashjmp.h sig.h command.h stdc.h hashlib.h flags.h
! variables.o: config.h memalloc.h general.h variables.h quit.h mailcheck.h
! variables.o: execute_cmd.h dispose_cmd.h make_cmd.h subst.h externs.h
! sig.o: shell.h bashjmp.h sig.h command.h stdc.h hashlib.h flags.h
! sig.o: config.h memalloc.h general.h variables.h quit.h
! sig.o: bashtypes.h jobs.h bashline.h unwind_prot.h
  version.o: version.h .build
! oslib.o: config.h bashtypes.h posixstat.h filecntl.h bashansi.h maxpath.h
! oslib.o: shell.h bashjmp.h sig.h command.h stdc.h mailcheck.h
! oslib.o: general.h error.h variables.h quit.h unwind_prot.h dispose_cmd.h
! oslib.o: make_cmd.h subst.h pathnames.h externs.h
! xmalloc.o: config.h ansi_stdlib.h general.h error.h
  
! eval.o: config.h bashansi.h shell.h trap.h flags.h builtins/common.h
! eval.o: input.h execute_cmd.h
! eval.o: bashjmp.h command.h general.h error.h variables.h quit.h
! eval.o: maxpath.h unwind_prot.h dispose_cmd.h make_cmd.h subst.h
! eval.o: sig.h pathnames.h externs.h
! 
! locale.o: bashintl.h bashansi.h config.h bashtypes.h shell.h
! locale.o: bashjmp.h command.h general.h error.h variables.h quit.h
! locale.o: maxpath.h unwind_prot.h dispose_cmd.h make_cmd.h subst.h
! locale.o: sig.h pathnames.h externs.h
! 
! 
! alias.o: ansi_stdlib.h
! bashline.o: ansi_stdlib.h
! variables.o: ansi_stdlib.h
! shell.o: ansi_stdlib.h
! error.o: ansi_stdlib.h
! hash.o: ansi_stdlib.h
! signames.o: ansi_stdlib.h
! expr.o: ansi_stdlib.h
! general.o: ansi_stdlib.h
! input.o: ansi_stdlib.h
! 
! jobs.o: jobs.c
! nojobs.o: nojobs.c
! 
! array.o: general.h shell.h bashjmp.h sig.h variables.h quit.h config.h
! array.o: command.h error.h maxpath.h unwind_prot.h dispose_cmd.h memalloc.h
! array.o: make_cmd.h subst.h externs.h
! array.o: array.h stdc.h $(DEFSRC)/common.h
! 
! braces.o: general.h shell.h bashjmp.h sig.h variables.h quit.h config.h
! braces.o: dispose_cmd.h make_cmd.h subst.h externs.h memalloc.h
! braces.o: maxpath.h unwind_prot.h command.h stdc.h
  
! bracecomp.o: bracecomp.c
! bracecomp.o: shell.h bashjmp.h sig.h command.h hashlib.h builtins.h general.h
  bracecomp.o: quit.h alias.h config.h  variables.h
  bracecomp.o: dispose_cmd.h make_cmd.h subst.h externs.h stdc.h
- bracecomp.o: $(RL_LIBSRC)/readline.h
  
! bashline.o: shell.h bashjmp.h sig.h command.h stdc.h hashlib.h builtins.h
! bashline.o: general.h variables.h config.h memalloc.h quit.h alias.h
! bashline.o: dispose_cmd.h make_cmd.h subst.h externs.h config.h bashline.h
! bashline.o: $(GLOB_LIBSRC)/glob.h pathexp.h execute_cmd.h
! 
! bashhist.o: config.h bashansi.h posixstat.h filecntl.h parser.h
! bashhist.o: shell.h bashjmp.h sig.h command.h stdc.h hashlib.h builtins.h
! bashhist.o: general.h variables.h memalloc.h quit.h alias.h execute_cmd.h
! bashhist.o: dispose_cmd.h make_cmd.h subst.h externs.h flags.h
  
! bashline.o: $(RL_LIBSRC)/chardefs.h $(RL_LIBSRC)/readline.h
  bashline.o: $(RL_LIBSRC)/keymaps.h
! y.tab.o: $(RL_LIBSRC)/keymaps.h $(RL_LIBSRC)/chardefs.h
! y.tab.o: $(RL_LIBSRC)/readline.h
  
  subst.o: $(HIST_LIBSRC)/history.h
  bashline.o: $(HIST_LIBSRC)/history.h
--- 615,845 ----
  nojobs.o: config.h.top
  execute_cmd.o: config.h.top
  variables.o: config.h.top
  builtins/command.o: config.h.top
! builtins/common.o: config.h.top
! builtins/break.o: config.h.top
! builtins/echo.o: config.h.top
! builtins/evalstring.o: config.h.top
! builtins/exit.o: config.h.top
! builtins/kill.o: config.h.top
! 
! # shell basics
! copy_cmd.o: shell.h config.h bashjmp.h posixjmp.h command.h stdc.h error.h
! copy_cmd.o: general.h bashtypes.h variables.h array.h hashlib.h
! copy_cmd.o: quit.h maxpath.h unwind_prot.h dispose_cmd.h
! copy_cmd.o: make_cmd.h subst.h sig.h pathnames.h externs.h
! dispose_cmd.o: bashansi.h ansi_stdlib.h
! dispose_cmd.o: shell.h config.h bashjmp.h posixjmp.h command.h stdc.h
! dispose_cmd.o: error.h general.h bashtypes.h variables.h array.h hashlib.h
! dispose_cmd.o: quit.h maxpath.h unwind_prot.h dispose_cmd.h
! dispose_cmd.o: make_cmd.h subst.h sig.h pathnames.h externs.h
! getcwd.o: config.h bashtypes.h bashansi.h
! getcwd.o: maxpath.h posixstat.h posixdir.h memalloc.h
! error.o: config.h bashtypes.h bashansi.h ansi_stdlib.h flags.h stdc.h error.h
! error.o: command.h general.h externs.h input.h bashhist.h
! eval.o: config.h bashansi.h ansi_stdlib.h trap.h flags.h ${DEFSRC}/common.h
! eval.o: shell.h config.h bashjmp.h posixjmp.h command.h stdc.h error.h
! eval.o: general.h bashtypes.h variables.h array.h hashlib.h
! eval.o: quit.h maxpath.h unwind_prot.h dispose_cmd.h
! eval.o: make_cmd.h subst.h sig.h pathnames.h externs.h
! eval.o: input.h execute_cmd.h
! execute_cmd.o: config.h bashtypes.h filecntl.h posixstat.h bashansi.h ansi_stdlib.h
! execute_cmd.o: shell.h config.h bashjmp.h posixjmp.h command.h stdc.h error.h
! execute_cmd.o: general.h bashtypes.h variables.h array.h hashlib.h
! execute_cmd.o: quit.h maxpath.h unwind_prot.h dispose_cmd.h
! execute_cmd.o: make_cmd.h subst.h sig.h pathnames.h externs.h
! execute_cmd.o: memalloc.h ${GRAM_H} flags.h builtins.h jobs.h quit.h siglist.h
! execute_cmd.o: execute_cmd.h trap.h pathexp.h $(DEFSRC)/common.h
! execute_cmd.o: ${DEFDIR}/builtext.h ${GLOB_LIBSRC}/fnmatch.h
! expr.o: config.h bashansi.h ansi_stdlib.h
! expr.o: shell.h config.h bashjmp.h posixjmp.h command.h stdc.h error.h
! expr.o: general.h bashtypes.h variables.h array.h hashlib.h
! expr.o: quit.h maxpath.h unwind_prot.h dispose_cmd.h
! expr.o: make_cmd.h subst.h sig.h pathnames.h externs.h
! flags.o: config.h flags.h
! flags.o: shell.h config.h bashjmp.h posixjmp.h command.h stdc.h error.h
! flags.o: general.h bashtypes.h variables.h array.h hashlib.h
! flags.o: quit.h maxpath.h unwind_prot.h dispose_cmd.h
! flags.o: make_cmd.h subst.h sig.h pathnames.h externs.h
! general.o: config.h bashtypes.h posixstat.h filecntl.h bashansi.h ansi_stdlib.h
! general.o: shell.h config.h bashjmp.h posixjmp.h command.h stdc.h error.h
! general.o: general.h bashtypes.h variables.h array.h hashlib.h
! general.o: quit.h maxpath.h unwind_prot.h dispose_cmd.h
! general.o: make_cmd.h subst.h sig.h pathnames.h externs.h
! general.o: maxpath.h
! hashcmd.o: config.h posixstat.h bashtypes.h bashansi.h ansi_stdlib.h
! hashcmd.o: shell.h config.h bashjmp.h posixjmp.h command.h stdc.h error.h
! hashcmd.o: general.h bashtypes.h variables.h array.h hashcmd.h
! hashcmd.o: execute_cmd.h stdc.h
! hashlib.o: config.h bashansi.h ansi_stdlib.h
! hashlib.o: shell.h config.h bashjmp.h posixjmp.h command.h stdc.h error.h
! hashlib.o: general.h bashtypes.h variables.h array.h hashlib.h
! hashlib.o: quit.h maxpath.h unwind_prot.h dispose_cmd.h
! hashlib.o: make_cmd.h subst.h sig.h pathnames.h externs.h
! input.o: config.h bashtypes.h filecntl.h posixstat.h bashansi.h ansi_stdlib.h
! input.o: command.h stdc.h general.h input.h error.h externs.h
! list.o: shell.h config.h bashjmp.h posixjmp.h command.h stdc.h error.h
! list.o: general.h bashtypes.h variables.h array.h hashlib.h
! list.o: quit.h maxpath.h unwind_prot.h dispose_cmd.h
! list.o: make_cmd.h subst.h sig.h pathnames.h externs.h
! locale.o: config.h bashtypes.h bashintl.h bashansi.h ansi_stdlib.h
! locale.o: shell.h config.h bashjmp.h posixjmp.h command.h stdc.h error.h
! locale.o: general.h bashtypes.h variables.h array.h hashlib.h
! locale.o: quit.h maxpath.h unwind_prot.h dispose_cmd.h
! locale.o: make_cmd.h subst.h sig.h pathnames.h externs.h
! mailcheck.o: config.h bashtypes.h posixstat.h bashansi.h ansi_stdlib.h
! mailcheck.o: shell.h config.h bashjmp.h posixjmp.h command.h stdc.h error.h
! mailcheck.o: general.h bashtypes.h variables.h array.h hashlib.h
! mailcheck.o: quit.h maxpath.h unwind_prot.h dispose_cmd.h
! mailcheck.o: make_cmd.h subst.h sig.h pathnames.h externs.h
! mailcheck.o: execute_cmd.h mailcheck.h
! make_cmd.o: config.h bashtypes.h filecntl.h bashansi.h
! make_cmd.o: command.h stdc.h general.h error.h flags.h make_cmd.h
! make_cmd.o: variables.h array.h hashlib.h subst.h input.h externs.h
! make_cmd.o: jobs.h quit.h siglist.h
! oslib.o: config.h bashtypes.h posixstat.h filecntl.h bashansi.h maxpath.h
! oslib.o: shell.h config.h bashjmp.h posixjmp.h command.h stdc.h error.h
! oslib.o: general.h bashtypes.h variables.h array.h hashlib.h
! oslib.o: quit.h maxpath.h unwind_prot.h dispose_cmd.h
! oslib.o: make_cmd.h subst.h sig.h pathnames.h externs.h
! y.tab.o: config.h bashtypes.h bashansi.h ansi_stdlib.h memalloc.h
! y.tab.o: shell.h config.h bashjmp.h posixjmp.h command.h stdc.h error.h
! y.tab.o: general.h bashtypes.h variables.h array.h hashlib.h
! y.tab.o: quit.h maxpath.h unwind_prot.h dispose_cmd.h
! y.tab.o: make_cmd.h subst.h sig.h pathnames.h externs.h
! y.tab.o: trap.h flags.h parser.h input.h mailcheck.h $(DEFSRC)/common.h
! y.tab.o: $(DEFDIR)/builtext.h bashline.h bashhist.h jobs.h siglist.h alias.h
! pathexp.o: config.h bashtypes.h bashansi.h ansi_stdlib.h
! pathexp.o: shell.h config.h bashjmp.h posixjmp.h command.h stdc.h error.h
! pathexp.o: general.h bashtypes.h variables.h array.h hashlib.h
! pathexp.o: quit.h maxpath.h unwind_prot.h dispose_cmd.h
  pathexp.o: make_cmd.h subst.h sig.h pathnames.h externs.h
+ pathexp.o: pathexp.h flags.h 
  pathexp.o: $(GLOB_LIBSRC)/glob.h $(GLOB_LIBSRC)/fnmatch.h
! print_cmd.o: config.h bashansi.h ansi_stdlib.h
! print_cmd.o: shell.h config.h bashjmp.h posixjmp.h command.h stdc.h error.h
! print_cmd.o: general.h bashtypes.h variables.h array.h hashlib.h
! print_cmd.o: quit.h maxpath.h unwind_prot.h dispose_cmd.h
! print_cmd.o: make_cmd.h subst.h sig.h pathnames.h externs.h
! print_cmd.o: ${GRAM_H} $(DEFSRC)/common.h
! shell.o: config.h bashtypes.h posixstat.h bashansi.h ansi_stdlib.h filecntl.h
! shell.o: shell.h config.h bashjmp.h posixjmp.h command.h stdc.h error.h
! shell.o: general.h bashtypes.h variables.h array.h hashlib.h
! shell.o: quit.h maxpath.h unwind_prot.h dispose_cmd.h
! shell.o: make_cmd.h subst.h sig.h pathnames.h externs.h
! shell.o: flags.h trap.h mailcheck.h builtins.h $(DEFSRC)/common.h
! shell.o: jobs.h siglist.h input.h execute_cmd.h bashhist.h
! shell.o: ${GLOB_LIBSRC}/fnmatch.h
! sig.o: config.h bashtypes.h
! sig.o: shell.h config.h bashjmp.h posixjmp.h command.h stdc.h error.h
! sig.o: general.h bashtypes.h variables.h array.h hashlib.h
! sig.o: quit.h maxpath.h unwind_prot.h dispose_cmd.h
! sig.o: make_cmd.h subst.h sig.h pathnames.h externs.h
! sig.o: jobs.h siglist.h trap.h $(DEFSRC)/common.h bashline.h bashhist.h
! siglist.o: config.h bashtypes.h siglist.h trap.h
! stringlib.o: bashtypes.h
! stringlib.o: shell.h config.h bashjmp.h posixjmp.h command.h stdc.h error.h
! stringlib.o: general.h bashtypes.h variables.h array.h hashlib.h
! stringlib.o: quit.h maxpath.h unwind_prot.h dispose_cmd.h
! stringlib.o: make_cmd.h subst.h sig.h pathnames.h externs.h
! subst.o: config.h bashtypes.h bashansi.h ansi_stdlib.h posixstat.h
! subst.o: shell.h config.h bashjmp.h posixjmp.h command.h stdc.h error.h
! subst.o: general.h bashtypes.h variables.h array.h hashlib.h
! subst.o: quit.h maxpath.h unwind_prot.h dispose_cmd.h
! subst.o: make_cmd.h subst.h sig.h pathnames.h externs.h
! subst.o: flags.h jobs.h siglist.h execute_cmd.h filecntl.h trap.h pathexp.h
! subst.o: mailcheck.h input.h $(DEFSRC)/getopt.h $(DEFSRC)/common.h
! subst.o: bashline.h bashhist.h ${GLOB_LIBSRC}/fnmatch.h
! test.o: bashtypes.h posixstat.h filecntl.h
! test.o: shell.h config.h bashjmp.h posixjmp.h command.h stdc.h error.h
! test.o: general.h bashtypes.h variables.h array.h hashlib.h
! test.o: quit.h maxpath.h unwind_prot.h dispose_cmd.h
! test.o: make_cmd.h subst.h sig.h pathnames.h externs.h
! test.o: ${DEFSRC}/common.h
! trap.o: config.h bashtypes.h trap.h bashansi.h ansi_stdlib.h
! trap.o: shell.h config.h bashjmp.h posixjmp.h command.h stdc.h error.h
! trap.o: general.h bashtypes.h variables.h array.h hashlib.h
! trap.o: quit.h maxpath.h unwind_prot.h dispose_cmd.h
! trap.o: make_cmd.h subst.h sig.h pathnames.h externs.h
! trap.o: signames.h $(DEFSRC)/common.h
! unwind_prot.o: config.h bashtypes.h bashansi.h ansi_stdlib.h command.h stdc.h
! unwind_prot.o: general.h unwind_prot.h quit.h sig.h
! variables.o: config.h bashtypes.h posixstat.h bashansi.h ansi_stdlib.h
! variables.o: shell.h config.h bashjmp.h posixjmp.h command.h stdc.h error.h
! variables.o: general.h bashtypes.h variables.h array.h hashlib.h
! variables.o: quit.h maxpath.h unwind_prot.h dispose_cmd.h
! variables.o: make_cmd.h subst.h sig.h pathnames.h externs.h
! varibales.o: flags.h execute_cmd.h mailcheck.h input.h $(DEFSRC)/common.h
! variables.o: bashhist.h
  version.o: version.h .build
! vprint.o: config.h
! xmalloc.o: config.h bashtypes.h ansi_stdlib.h error.h
  
! # job control
  
! jobs.o: config.h bashtypes.h trap.h filecntl.h input.h bashtty.h
! jobs.o: bashansi.h ansi_stdlib.h
! jobs.o: shell.h config.h bashjmp.h posixjmp.h command.h stdc.h error.h
! jobs.o: general.h bashtypes.h variables.h array.h hashlib.h
! jobs.o: quit.h maxpath.h unwind_prot.h dispose_cmd.h
! jobs.o: make_cmd.h subst.h sig.h pathnames.h externs.h
! jobs.o: jobs.h flags.h $(DEFSRC)/common.h $(DEFDIR)/builtext.h
! nojobs.o: config.h bashtypes.h filecntl.h bashjmp.h posixjmp.h
! nojobs.o: command.h stdc.h general.h jobs.h quit.h siglist.h externs.h
! nojobs.o: sig.h error.h bashtty.h input.h
! 
! # shell features that may be compiled in
! 
! array.o: config.h bashansi.h ansi_stdlib.h
! array.o: shell.h config.h bashjmp.h posixjmp.h command.h stdc.h error.h
! array.o: general.h bashtypes.h variables.h array.h hashlib.h
! array.o: quit.h maxpath.h unwind_prot.h dispose_cmd.h
! array.o: make_cmd.h subst.h sig.h pathnames.h externs.h
! array.o: $(DEFSRC)/common.h
! braces.o: config.h bashansi.h ansi_stdlib.h
! braces.o: shell.h config.h bashjmp.h posixjmp.h command.h stdc.h error.h
! braces.o: general.h bashtypes.h variables.h array.h hashlib.h
! braces.o: quit.h maxpath.h unwind_prot.h dispose_cmd.h
! braces.o: make_cmd.h subst.h sig.h pathnames.h externs.h
! alias.o: config.h bashansi.h ansi_stdlib.h command.h stdc.h
! alias.o: general.h bashtypes.h externs.h alias.h
! 
! # library support files
! 
! bashhist.o: config.h bashtypes.h bashansi.h ansi_stdlib.h posixstat.h
! bashhist.o: filecntl.h
! bashhist.o: shell.h config.h bashjmp.h posixjmp.h command.h stdc.h error.h
! bashhist.o: general.h bashtypes.h variables.h array.h hashlib.h
! bashhist.o: quit.h maxpath.h unwind_prot.h dispose_cmd.h
! bashhist.o: make_cmd.h subst.h sig.h pathnames.h externs.h
! bashhist.o: flags.h input.h parser.h pathexp.h $(DEFSRC)/common.h bashline.h
! bashhist.o: $(GLOB_LIBSRC)/fnmatch.h
! bashline.o: config.h bashtypes.h posixstat.h bashansi.h ansi_stdlib.h
! bashline.o: shell.h config.h bashjmp.h posixjmp.h command.h stdc.h error.h
! bashline.o: general.h bashtypes.h variables.h array.h hashlib.h
! bashline.o: quit.h maxpath.h unwind_prot.h dispose_cmd.h
! bashline.o: make_cmd.h subst.h sig.h pathnames.h externs.h
! bashline.o: builtins.h bashhist.h bashline.h execute_cmd.h pathexp.h
! bashline.o: $(DEFSRC)/common.h $(GLOB_LIBSRC)/glob.h alias.h
! bracecomp.o: config.h bashansi.h ansi_stdlib.h
! bracecomp.o: shell.h config.h bashjmp.h posixjmp.h command.h stdc.h error.h
! bracecomp.o: general.h bashtypes.h variables.h array.h hashlib.h
! bracecomp.o: quit.h maxpath.h unwind_prot.h dispose_cmd.h
! bracecomp.o: make_cmd.h subst.h sig.h pathnames.h externs.h
! bracecomp.o: shell.h bashjmp.h posixjmp.h sig.h command.h hashlib.h builtins.h general.h
  bracecomp.o: quit.h alias.h config.h  variables.h
  bracecomp.o: dispose_cmd.h make_cmd.h subst.h externs.h stdc.h
  
! # library dependencies
  
! bashline.o: $(RL_LIBSRC)/rlconf.h
  bashline.o: $(RL_LIBSRC)/keymaps.h
! bashline.o: $(RL_LIBSRC)/chardefs.h $(RL_LIBSRC)/readline.h
! bracecomp.o: $(RL_LIBSRC)/keymaps.h $(RL_LIBSRC)/chardefs.h
! bracecomp.o: $(RL_LIBSRC)/readline.h
! y.tab.o: $(RL_LIBSRC)/keymaps.h $(RL_LIBSRC)/chardefs.h $(RL_LIBSRC)/readline.h
! subst.o: $(RL_LIBSRC)/keymaps.h $(RL_LIBSRC)/chardefs.h $(RL_LIBSRC)/readline.h
  
+ shell.o: $(HIST_LIBSRC)/history.h
  subst.o: $(HIST_LIBSRC)/history.h
  bashline.o: $(HIST_LIBSRC)/history.h
***************
*** 738,745 ****
  y.tab.o: $(HIST_LIBSRC)/history.h
  
- subst.o: $(GLOB_LIBSRC)/fnmatch.h
- execute_cmd.o: $(GLOB_LIBSRC)/fnmatch.h
- bashhist.o: $(GLOB_LIBSRC)/fnmatch.h
- 
  execute_cmd.o: $(TILDE_LIBSRC)/tilde.h
  general.o: $(TILDE_LIBSRC)/tilde.h
--- 847,850 ----
***************
*** 749,893 ****
  variables.o: $(TILDE_LIBSRC)/tilde.h
  
! builtins/common.o: shell.h bashjmp.h sig.h command.h config.h memalloc.h
! builtins/common.o: variables.h input.h $(DEFSRC)/hashcom.h siglist.h
  builtins/common.o: quit.h unwind_prot.h maxpath.h jobs.h builtins.h
  builtins/common.o: dispose_cmd.h make_cmd.h subst.h externs.h bashhist.h
! builtins/common.o: execute_cmd.h stdc.h general.h error.h unwind_prot.h
  builtins/alias.o: command.h config.h memalloc.h error.h general.h maxpath.h
  builtins/alias.o: quit.h $(DEFSRC)/common.h
! builtins/alias.o: shell.h bashjmp.h sig.h command.h stdc.h unwind_prot.h
  builtins/alias.o: dispose_cmd.h make_cmd.h subst.h externs.h variables.h 
  builtins/bind.o: command.h config.h memalloc.h error.h general.h maxpath.h
  builtins/bind.o: dispose_cmd.h make_cmd.h subst.h externs.h stdc.h
! builtins/bind.o: shell.h bashjmp.h sig.h unwind_prot.h variables.h quit.h
  builtins/bind.o: $(DEFSRC)/bashgetopt.h
  builtins/break.o: command.h config.h memalloc.h error.h general.h maxpath.h
! builtins/break.o: shell.h bashjmp.h sig.h unwind_prot.h variables.h quit.h
  builtins/break.o: dispose_cmd.h make_cmd.h subst.h externs.h stdc.h
  builtins/builtin.o: command.h config.h memalloc.h error.h general.h maxpath.h
  builtins/builtin.o: quit.h $(DEFSRC)/common.h
! builtins/builtin.o: shell.h bashjmp.h sig.h unwind_prot.h variables.h 
  builtins/builtin.o: dispose_cmd.h make_cmd.h subst.h externs.h stdc.h
  builtins/cd.o: command.h config.h memalloc.h error.h general.h maxpath.h
! builtins/cd.o: shell.h bashjmp.h sig.h unwind_prot.h variables.h
  builtins/cd.o: dispose_cmd.h make_cmd.h subst.h externs.h stdc.h
  builtins/cd.o: $(DEFSRC)/common.h quit.h 
  builtins/command.o: command.h config.h memalloc.h error.h general.h maxpath.h
  builtins/command.o: quit.h $(DEFSRC)/bashgetopt.h
! builtins/command.o: shell.h bashjmp.h sig.h unwind_prot.h variables.h 
  builtins/command.o: dispose_cmd.h make_cmd.h subst.h externs.h stdc.h
  builtins/declare.o: command.h config.h memalloc.h error.h general.h maxpath.h
! builtins/declare.o: shell.h bashjmp.h sig.h unwind_prot.h variables.h quit.h
  builtins/declare.o: dispose_cmd.h make_cmd.h subst.h externs.h stdc.h
  builtins/echo.o: command.h config.h memalloc.h error.h general.h maxpath.h
! builtins/echo.o: shell.h bashjmp.h sig.h unwind_prot.h variables.h quit.h
  builtins/echo.o: dispose_cmd.h make_cmd.h subst.h externs.h stdc.h
  builtins/enable.o: command.h config.h memalloc.h error.h general.h maxpath.h
! builtins/enable.o: shell.h bashjmp.h sig.h unwind_prot.h variables.h quit.h
  builtins/enable.o: dispose_cmd.h make_cmd.h subst.h externs.h stdc.h
  builtins/eval.o: command.h config.h memalloc.h error.h general.h maxpath.h
! builtins/eval.o: shell.h bashjmp.h sig.h unwind_prot.h variables.h quit.h 
  builtins/eval.o: dispose_cmd.h make_cmd.h subst.h externs.h stdc.h
  builtins/exec.o: command.h config.h memalloc.h error.h general.h maxpath.h
! builtins/exec.o: shell.h bashjmp.h sig.h unwind_prot.h variables.h
  builtins/exec.o: dispose_cmd.h make_cmd.h subst.h externs.h execute_cmd.h
  builtins/exec.o: flags.h quit.h $(DEFSRC)/common.h stdc.h
  builtins/exit.o: command.h config.h memalloc.h error.h general.h maxpath.h
! builtins/exit.o: shell.h bashjmp.h sig.h unwind_prot.h variables.h quit.h
  builtins/exit.o: dispose_cmd.h make_cmd.h subst.h externs.h stdc.h
! builtins/fc.o: builtins.h command.h stdc.h 
  builtins/fc.o: command.h config.h memalloc.h error.h general.h maxpath.h
! builtins/fc.o: flags.h unwind_prot.h variables.h shell.h bashjmp.h sig.h 
  builtins/fc.o: dispose_cmd.h make_cmd.h subst.h externs.h stdc.h quit.h 
  builtins/fc.o: $(DEFSRC)/bashgetopt.h bashhist.h
  builtins/fg_bg.o: command.h config.h memalloc.h error.h general.h maxpath.h
! builtins/fg_bg.o: shell.h bashjmp.h sig.h unwind_prot.h variables.h quit.h
  builtins/fg_bg.o: dispose_cmd.h make_cmd.h subst.h externs.h stdc.h
  builtins/getopts.o: command.h config.h memalloc.h error.h general.h maxpath.h
! builtins/getopts.o: shell.h bashjmp.h sig.h unwind_prot.h variables.h quit.h 
  builtins/getopts.o: dispose_cmd.h make_cmd.h subst.h externs.h stdc.h
  builtins/hash.o: builtins.h command.h execute_cmd.h stdc.h $(DEFSRC)/common.h
  builtins/hash.o: command.h config.h memalloc.h error.h general.h maxpath.h
! builtins/hash.o: shell.h bashjmp.h sig.h unwind_prot.h variables.h quit.h 
  builtins/help.o: command.h config.h memalloc.h error.h general.h maxpath.h
  builtins/help.o: dispose_cmd.h make_cmd.h subst.h externs.h stdc.h
! builtins/help.o: shell.h bashjmp.h sig.h unwind_prot.h variables.h quit.h
  builtins/help.o: $(GLOB_LIBSRC)/glob.h
  builtins/history.o: command.h config.h memalloc.h error.h general.h maxpath.h
  builtins/history.o: quit.h dispose_cmd.h make_cmd.h subst.h externs.h stdc.h
! builtins/history.o: filecntl.h shell.h bashjmp.h sig.h unwind_prot.h
  builtins/history.o: bashhist.h variables.h 
  builtins/inlib.o: command.h config.h memalloc.h error.h general.h maxpath.h
! builtins/inlib.o: shell.h bashjmp.h sig.h unwind_prot.h variables.h quit.h 
  builtins/inlib.o: dispose_cmd.h make_cmd.h subst.h externs.h stdc.h
  builtins/jobs.o: command.h config.h memalloc.h error.h general.h maxpath.h
  builtins/jobs.o: quit.h $(DEFSRC)/bashgetopt.h
! builtins/jobs.o: shell.h bashjmp.h sig.h unwind_prot.h variables.h 
  builtins/jobs.o: dispose_cmd.h make_cmd.h subst.h externs.h stdc.h
  builtins/kill.o: command.h config.h memalloc.h error.h general.h maxpath.h
  builtins/kill.o: quit.h dispose_cmd.h make_cmd.h subst.h externs.h stdc.h
! builtins/kill.o: shell.h bashjmp.h sig.h trap.h unwind_prot.h variables.h 
  builtins/let.o: command.h config.h memalloc.h error.h general.h maxpath.h
  builtins/let.o: quit.h dispose_cmd.h make_cmd.h subst.h externs.h stdc.h
! builtins/let.o: shell.h bashjmp.h sig.h unwind_prot.h variables.h 
  builtins/pushd.o: command.h config.h memalloc.h error.h general.h maxpath.h
  builtins/pushd.o: quit.h dispose_cmd.h make_cmd.h subst.h externs.h stdc.h
! builtins/pushd.o: shell.h bashjmp.h sig.h unwind_prot.h variables.h
  builtins/pushd.o: $(DEFSRC)/common.h
  builtins/read.o: command.h config.h memalloc.h error.h general.h maxpath.h
  builtins/read.o: quit.h dispose_cmd.h make_cmd.h subst.h externs.h stdc.h
! builtins/read.o: shell.h bashjmp.h sig.h unwind_prot.h variables.h 
  builtins/return.o: command.h config.h memalloc.h error.h general.h maxpath.h
  builtins/return.o: quit.h dispose_cmd.h make_cmd.h subst.h externs.h stdc.h
! builtins/return.o: shell.h bashjmp.h sig.h unwind_prot.h variables.h 
  builtins/set.o: command.h config.h memalloc.h error.h general.h maxpath.h
  builtins/set.o: quit.h dispose_cmd.h make_cmd.h subst.h externs.h stdc.h
! builtins/set.o: shell.h bashjmp.h sig.h unwind_prot.h variables.h flags.h
  builtins/setattr.o: command.h config.h memalloc.h error.h general.h maxpath.h
  builtins/setattr.o: quit.h $(DEFSRC)/common.h $(DEFSRC)/bashgetopt.h
! builtins/setattr.o: shell.h bashjmp.h sig.h unwind_prot.h variables.h 
  builtins/setattr.o: dispose_cmd.h make_cmd.h subst.h externs.h stdc.h
  builtins/shift.o: command.h config.h memalloc.h error.h general.h maxpath.h
  builtins/shift.o: quit.h dispose_cmd.h make_cmd.h subst.h externs.h stdc.h
! builtins/shift.o: shell.h bashjmp.h sig.h unwind_prot.h variables.h 
  builtins/shift.o: dispose_cmd.h make_cmd.h subst.h externs.h stdc.h
  builtins/source.o: command.h config.h memalloc.h error.h general.h maxpath.h
  builtins/source.o: quit.h dispose_cmd.h make_cmd.h subst.h externs.h stdc.h
! builtins/source.o: shell.h bashjmp.h sig.h unwind_prot.h variables.h 
  builtins/suspend.o: command.h config.h memalloc.h error.h general.h maxpath.h
  builtins/suspend.o: quit.h dispose_cmd.h make_cmd.h subst.h externs.h stdc.h
! builtins/suspend.o: shell.h bashjmp.h sig.h unwind_prot.h variables.h 
  builtins/test.o: command.h config.h memalloc.h error.h general.h maxpath.h
  builtins/test.o: quit.h dispose_cmd.h make_cmd.h subst.h externs.h stdc.h
! builtins/test.o: shell.h bashjmp.h sig.h unwind_prot.h variables.h 
  builtins/times.o: command.h config.h memalloc.h error.h general.h maxpath.h
  builtins/times.o: quit.h dispose_cmd.h make_cmd.h subst.h externs.h stdc.h
! builtins/times.o: shell.h bashjmp.h sig.h unwind_prot.h variables.h 
  builtins/trap.o: command.h config.h memalloc.h error.h general.h maxpath.h
  builtins/trap.o: quit.h $(DEFSRC)/common.h
! builtins/trap.o: shell.h bashjmp.h sig.h unwind_prot.h variables.h 
  builtins/trap.o: dispose_cmd.h make_cmd.h subst.h externs.h stdc.h
  builtins/type.o: command.h config.h memalloc.h error.h general.h maxpath.h
  builtins/type.o: quit.h $(DEFSRC)/common.h execute_cmd.h
! builtins/type.o: shell.h bashjmp.h sig.h unwind_prot.h variables.h
  builtins/type.o: dispose_cmd.h make_cmd.h subst.h externs.h stdc.h
  builtins/ulimit.o: command.h config.h memalloc.h error.h general.h maxpath.h
  builtins/ulimit.o: quit.h dispose_cmd.h make_cmd.h subst.h externs.h stdc.h
! builtins/ulimit.o: shell.h bashjmp.h sig.h unwind_prot.h variables.h 
  builtins/umask.o: command.h config.h memalloc.h error.h general.h maxpath.h
  builtins/umask.o: quit.h dispose_cmd.h make_cmd.h subst.h externs.h stdc.h
! builtins/umask.o: shell.h bashjmp.h sig.h unwind_prot.h variables.h 
  builtins/wait.o: command.h config.h memalloc.h error.h general.h maxpath.h
  builtins/wait.o: quit.h dispose_cmd.h make_cmd.h subst.h externs.h stdc.h
! builtins/wait.o: shell.h bashjmp.h sig.h unwind_prot.h variables.h
! builtins/shopt.o: command.h config.h memalloc.h error.h general.h
! builtins/shopt.o: quit.h dispose_cmd.h make_cmd.h subst.h externs.h
! builtins/shopt.o: shell.h bashjmp.h unwind_prot.h variables.h maxpath.h
! builtins/shopt.o: $(DEFSRC)/common.h $(DEFSRC)/bashgetopt.h
! 
! builtins/bashgetopt.o: bashansi.h ansi_stdlib.h
! builtins/mkbuiltins.o: bashansi.h ansi_stdlib.h
! builtins/fc.o: bashansi.h ansi_stdlib.h
  
  builtins/bind.o: $(RL_LIBSRC)/chardefs.h $(RL_LIBSRC)/readline.h
  builtins/bind.o: $(RL_LIBSRC)/keymaps.h
--- 854,1033 ----
  variables.o: $(TILDE_LIBSRC)/tilde.h
  
! # XXX - dependencies checked through here
! 
! # builtin c sources
! builtins/bashgetopt.o: config.h bashansi.h ansi_stdlib.h
! builtins/bashgetopt.o: shell.h config.h bashjmp.h command.h general.h error.h
! builtins/bashgetopt.o: variables.h quit.h maxpath.h unwind_prot.h dispose_cmd.h
! builtins/bashgetopt.o: make_cmd.h subst.h sig.h pathnames.h externs.h
! builtins/bashgetopt.o: $(DEFSRC)/common.h
! builtins/common.o: bashtypes.h posixstat.h bashansi.h ansi_stdlib.h
! builtins/common.o: shell.h config.h bashjmp.h posixjmp.h sig.h command.h
! builtins/common.o: memalloc.h variables.h input.h siglist.h
  builtins/common.o: quit.h unwind_prot.h maxpath.h jobs.h builtins.h
  builtins/common.o: dispose_cmd.h make_cmd.h subst.h externs.h bashhist.h
! builtins/common.o: execute_cmd.h stdc.h general.h error.h pathnames.h
! builtins/common.o: ${DEFDIR}/builtext.h
! builtins/evalfile.o: bashtypes.h posixstat.h filecntl.h bashansi.h ansi_stdlib.h
! builtins/evalfile.o: shell.h config.h bashjmp.h command.h general.h error.h
! builtins/evalfile.o: variables.h quit.h maxpath.h unwind_prot.h dispose_cmd.h
! builtins/evalfile.o: make_cmd.h subst.h sig.h pathnames.h externs.h
! builtins/evalfile.o: jobs.h builtins.h flags.h input.h execute_cmd.h
! builtins/evalfile.o: bashhist.h $(DEFSRC)/common.h
! builtins/evalstring.o: config.h bashansi.h ansi_stdlib.h
! builtins/evalstring.o: shell.h bashjmp.h posixjmp.h sig.h command.h siglist.h
! builtins/evalstring.o: memalloc.h variables.h input.h
! builtins/evalstring.o: quit.h unwind_prot.h maxpath.h jobs.h builtins.h
! builtins/evalstring.o: dispose_cmd.h make_cmd.h subst.h externs.h 
! builtins/evalstring.o: jobs.h builtins.h flags.h input.h execute_cmd.h
! builtins/evalstring.o: bashhist.h $(DEFSRC)/common.h
! builtins/getopt.o: config.h memalloc.h
! builtins/getopt.o: shell.h bashjmp.h command.h general.h error.h
! builtins/getopt.o: variables.h quit.h maxpath.h unwind_prot.h dispose_cmd.h
! builtins/getopt.o: make_cmd.h subst.h sig.h pathnames.h externs.h
! builtins/getopt.o: $(DEFSRC)/getopt.h
! builtins/mkbuiltins.o: config.h bashtypes.h posixstat.h filecntl.h
! builtins/mkbuiltins.o: bashansi.h ansi_stdlib.h
! 
! # builtin def files
  builtins/alias.o: command.h config.h memalloc.h error.h general.h maxpath.h
  builtins/alias.o: quit.h $(DEFSRC)/common.h
! builtins/alias.o: shell.h bashjmp.h posixjmp.h sig.h command.h stdc.h unwind_prot.h
  builtins/alias.o: dispose_cmd.h make_cmd.h subst.h externs.h variables.h 
  builtins/bind.o: command.h config.h memalloc.h error.h general.h maxpath.h
  builtins/bind.o: dispose_cmd.h make_cmd.h subst.h externs.h stdc.h
! builtins/bind.o: shell.h bashjmp.h posixjmp.h sig.h unwind_prot.h variables.h quit.h
  builtins/bind.o: $(DEFSRC)/bashgetopt.h
  builtins/break.o: command.h config.h memalloc.h error.h general.h maxpath.h
! builtins/break.o: shell.h bashjmp.h posixjmp.h sig.h unwind_prot.h variables.h quit.h
  builtins/break.o: dispose_cmd.h make_cmd.h subst.h externs.h stdc.h
  builtins/builtin.o: command.h config.h memalloc.h error.h general.h maxpath.h
  builtins/builtin.o: quit.h $(DEFSRC)/common.h
! builtins/builtin.o: shell.h bashjmp.h posixjmp.h sig.h unwind_prot.h variables.h 
  builtins/builtin.o: dispose_cmd.h make_cmd.h subst.h externs.h stdc.h
  builtins/cd.o: command.h config.h memalloc.h error.h general.h maxpath.h
! builtins/cd.o: shell.h bashjmp.h posixjmp.h sig.h unwind_prot.h variables.h
  builtins/cd.o: dispose_cmd.h make_cmd.h subst.h externs.h stdc.h
  builtins/cd.o: $(DEFSRC)/common.h quit.h 
  builtins/command.o: command.h config.h memalloc.h error.h general.h maxpath.h
  builtins/command.o: quit.h $(DEFSRC)/bashgetopt.h
! builtins/command.o: shell.h bashjmp.h posixjmp.h sig.h unwind_prot.h variables.h 
  builtins/command.o: dispose_cmd.h make_cmd.h subst.h externs.h stdc.h
  builtins/declare.o: command.h config.h memalloc.h error.h general.h maxpath.h
! builtins/declare.o: shell.h bashjmp.h posixjmp.h sig.h unwind_prot.h variables.h quit.h
  builtins/declare.o: dispose_cmd.h make_cmd.h subst.h externs.h stdc.h
  builtins/echo.o: command.h config.h memalloc.h error.h general.h maxpath.h
! builtins/echo.o: shell.h bashjmp.h posixjmp.h sig.h unwind_prot.h variables.h quit.h
  builtins/echo.o: dispose_cmd.h make_cmd.h subst.h externs.h stdc.h
  builtins/enable.o: command.h config.h memalloc.h error.h general.h maxpath.h
! builtins/enable.o: shell.h bashjmp.h posixjmp.h sig.h unwind_prot.h variables.h quit.h
  builtins/enable.o: dispose_cmd.h make_cmd.h subst.h externs.h stdc.h
  builtins/eval.o: command.h config.h memalloc.h error.h general.h maxpath.h
! builtins/eval.o: shell.h bashjmp.h posixjmp.h sig.h unwind_prot.h variables.h quit.h 
  builtins/eval.o: dispose_cmd.h make_cmd.h subst.h externs.h stdc.h
+ builtins/exec.o: bashtypes.h
  builtins/exec.o: command.h config.h memalloc.h error.h general.h maxpath.h
! builtins/exec.o: shell.h bashjmp.h posixjmp.h sig.h unwind_prot.h variables.h
  builtins/exec.o: dispose_cmd.h make_cmd.h subst.h externs.h execute_cmd.h
  builtins/exec.o: flags.h quit.h $(DEFSRC)/common.h stdc.h
+ builtins/exit.o: bashtypes.h
  builtins/exit.o: command.h config.h memalloc.h error.h general.h maxpath.h
! builtins/exit.o: shell.h bashjmp.h posixjmp.h sig.h unwind_prot.h variables.h quit.h
  builtins/exit.o: dispose_cmd.h make_cmd.h subst.h externs.h stdc.h
! builtins/fc.o: bashtypes.h posixstat.h
! builtins/fc.o: bashansi.h ansi_stdlib.h builtins.h command.h stdc.h 
  builtins/fc.o: command.h config.h memalloc.h error.h general.h maxpath.h
! builtins/fc.o: flags.h unwind_prot.h variables.h shell.h bashjmp.h posixjmp.h sig.h 
  builtins/fc.o: dispose_cmd.h make_cmd.h subst.h externs.h stdc.h quit.h 
  builtins/fc.o: $(DEFSRC)/bashgetopt.h bashhist.h
+ builtins/fg_bg.o: bashtypes.h
  builtins/fg_bg.o: command.h config.h memalloc.h error.h general.h maxpath.h
! builtins/fg_bg.o: shell.h bashjmp.h posixjmp.h sig.h unwind_prot.h variables.h quit.h
  builtins/fg_bg.o: dispose_cmd.h make_cmd.h subst.h externs.h stdc.h
  builtins/getopts.o: command.h config.h memalloc.h error.h general.h maxpath.h
! builtins/getopts.o: shell.h bashjmp.h posixjmp.h sig.h unwind_prot.h variables.h quit.h 
  builtins/getopts.o: dispose_cmd.h make_cmd.h subst.h externs.h stdc.h
+ builtins/hash.o: bashtypes.h
  builtins/hash.o: builtins.h command.h execute_cmd.h stdc.h $(DEFSRC)/common.h
  builtins/hash.o: command.h config.h memalloc.h error.h general.h maxpath.h
! builtins/hash.o: shell.h bashjmp.h posixjmp.h sig.h unwind_prot.h variables.h quit.h 
  builtins/help.o: command.h config.h memalloc.h error.h general.h maxpath.h
  builtins/help.o: dispose_cmd.h make_cmd.h subst.h externs.h stdc.h
! builtins/help.o: shell.h bashjmp.h posixjmp.h sig.h unwind_prot.h variables.h quit.h
  builtins/help.o: $(GLOB_LIBSRC)/glob.h
+ builtins/history.o: bashtypes.h
  builtins/history.o: command.h config.h memalloc.h error.h general.h maxpath.h
  builtins/history.o: quit.h dispose_cmd.h make_cmd.h subst.h externs.h stdc.h
! builtins/history.o: filecntl.h shell.h bashjmp.h posixjmp.h sig.h unwind_prot.h
  builtins/history.o: bashhist.h variables.h 
  builtins/inlib.o: command.h config.h memalloc.h error.h general.h maxpath.h
! builtins/inlib.o: shell.h bashjmp.h posixjmp.h sig.h unwind_prot.h variables.h quit.h 
  builtins/inlib.o: dispose_cmd.h make_cmd.h subst.h externs.h stdc.h
  builtins/jobs.o: command.h config.h memalloc.h error.h general.h maxpath.h
  builtins/jobs.o: quit.h $(DEFSRC)/bashgetopt.h
! builtins/jobs.o: shell.h bashjmp.h posixjmp.h sig.h unwind_prot.h variables.h 
  builtins/jobs.o: dispose_cmd.h make_cmd.h subst.h externs.h stdc.h
  builtins/kill.o: command.h config.h memalloc.h error.h general.h maxpath.h
  builtins/kill.o: quit.h dispose_cmd.h make_cmd.h subst.h externs.h stdc.h
! builtins/kill.o: shell.h bashjmp.h posixjmp.h sig.h trap.h unwind_prot.h variables.h 
  builtins/let.o: command.h config.h memalloc.h error.h general.h maxpath.h
  builtins/let.o: quit.h dispose_cmd.h make_cmd.h subst.h externs.h stdc.h
! builtins/let.o: shell.h bashjmp.h posixjmp.h sig.h unwind_prot.h variables.h 
  builtins/pushd.o: command.h config.h memalloc.h error.h general.h maxpath.h
  builtins/pushd.o: quit.h dispose_cmd.h make_cmd.h subst.h externs.h stdc.h
! builtins/pushd.o: shell.h bashjmp.h posixjmp.h sig.h unwind_prot.h variables.h
  builtins/pushd.o: $(DEFSRC)/common.h
  builtins/read.o: command.h config.h memalloc.h error.h general.h maxpath.h
  builtins/read.o: quit.h dispose_cmd.h make_cmd.h subst.h externs.h stdc.h
! builtins/read.o: shell.h bashjmp.h posixjmp.h sig.h unwind_prot.h variables.h 
  builtins/return.o: command.h config.h memalloc.h error.h general.h maxpath.h
  builtins/return.o: quit.h dispose_cmd.h make_cmd.h subst.h externs.h stdc.h
! builtins/return.o: shell.h bashjmp.h posixjmp.h sig.h unwind_prot.h variables.h 
  builtins/set.o: command.h config.h memalloc.h error.h general.h maxpath.h
  builtins/set.o: quit.h dispose_cmd.h make_cmd.h subst.h externs.h stdc.h
! builtins/set.o: shell.h bashjmp.h posixjmp.h sig.h unwind_prot.h variables.h flags.h
  builtins/setattr.o: command.h config.h memalloc.h error.h general.h maxpath.h
  builtins/setattr.o: quit.h $(DEFSRC)/common.h $(DEFSRC)/bashgetopt.h
! builtins/setattr.o: shell.h bashjmp.h posixjmp.h sig.h unwind_prot.h variables.h 
  builtins/setattr.o: dispose_cmd.h make_cmd.h subst.h externs.h stdc.h
  builtins/shift.o: command.h config.h memalloc.h error.h general.h maxpath.h
  builtins/shift.o: quit.h dispose_cmd.h make_cmd.h subst.h externs.h stdc.h
! builtins/shift.o: shell.h bashjmp.h posixjmp.h sig.h unwind_prot.h variables.h 
  builtins/shift.o: dispose_cmd.h make_cmd.h subst.h externs.h stdc.h
+ builtins/shopt.o: command.h config.h memalloc.h error.h general.h
+ builtins/shopt.o: quit.h dispose_cmd.h make_cmd.h subst.h externs.h
+ builtins/shopt.o: shell.h bashjmp.h posixjmp.h unwind_prot.h variables.h maxpath.h
+ builtins/shopt.o: $(DEFSRC)/common.h $(DEFSRC)/bashgetopt.h
  builtins/source.o: command.h config.h memalloc.h error.h general.h maxpath.h
  builtins/source.o: quit.h dispose_cmd.h make_cmd.h subst.h externs.h stdc.h
! builtins/source.o: shell.h bashjmp.h posixjmp.h sig.h unwind_prot.h variables.h 
  builtins/suspend.o: command.h config.h memalloc.h error.h general.h maxpath.h
  builtins/suspend.o: quit.h dispose_cmd.h make_cmd.h subst.h externs.h stdc.h
! builtins/suspend.o: shell.h bashjmp.h posixjmp.h sig.h unwind_prot.h variables.h 
  builtins/test.o: command.h config.h memalloc.h error.h general.h maxpath.h
  builtins/test.o: quit.h dispose_cmd.h make_cmd.h subst.h externs.h stdc.h
! builtins/test.o: shell.h bashjmp.h posixjmp.h sig.h unwind_prot.h variables.h 
  builtins/times.o: command.h config.h memalloc.h error.h general.h maxpath.h
  builtins/times.o: quit.h dispose_cmd.h make_cmd.h subst.h externs.h stdc.h
! builtins/times.o: shell.h bashjmp.h posixjmp.h sig.h unwind_prot.h variables.h 
  builtins/trap.o: command.h config.h memalloc.h error.h general.h maxpath.h
  builtins/trap.o: quit.h $(DEFSRC)/common.h
! builtins/trap.o: shell.h bashjmp.h posixjmp.h sig.h unwind_prot.h variables.h 
  builtins/trap.o: dispose_cmd.h make_cmd.h subst.h externs.h stdc.h
  builtins/type.o: command.h config.h memalloc.h error.h general.h maxpath.h
  builtins/type.o: quit.h $(DEFSRC)/common.h execute_cmd.h
! builtins/type.o: shell.h bashjmp.h posixjmp.h sig.h unwind_prot.h variables.h
  builtins/type.o: dispose_cmd.h make_cmd.h subst.h externs.h stdc.h
  builtins/ulimit.o: command.h config.h memalloc.h error.h general.h maxpath.h
  builtins/ulimit.o: quit.h dispose_cmd.h make_cmd.h subst.h externs.h stdc.h
! builtins/ulimit.o: shell.h bashjmp.h posixjmp.h sig.h unwind_prot.h variables.h 
  builtins/umask.o: command.h config.h memalloc.h error.h general.h maxpath.h
  builtins/umask.o: quit.h dispose_cmd.h make_cmd.h subst.h externs.h stdc.h
! builtins/umask.o: shell.h bashjmp.h posixjmp.h sig.h unwind_prot.h variables.h 
  builtins/wait.o: command.h config.h memalloc.h error.h general.h maxpath.h
  builtins/wait.o: quit.h dispose_cmd.h make_cmd.h subst.h externs.h stdc.h
! builtins/wait.o: shell.h bashjmp.h posixjmp.h sig.h unwind_prot.h variables.h
  
+ # builtin library dependencies
  builtins/bind.o: $(RL_LIBSRC)/chardefs.h $(RL_LIBSRC)/readline.h
  builtins/bind.o: $(RL_LIBSRC)/keymaps.h
diff -Nrc2 bash-2.0/NEWS bash-2.01/NEWS
*** bash-2.0/NEWS	Thu Dec 12 11:18:28 1996
--- bash-2.01/NEWS	Wed Feb 12 12:12:47 1997
***************
*** 1,2 ****
--- 1,19 ----
+ This is a terse description of the new features added to bash-2.01 since
+ the release of bash-2.0.  As always, the manual page (doc/bash.1) is the
+ place to look for complete descriptions.
+ 
+ 1. New Features in Bash
+ 
+ a.  There is a new builtin array variable: GROUPS, the set of groups to which
+     the user belongs.  This is used by the test suite.
+ 
+ 2.  New Features in Readline
+ 
+ a.  If a key sequence bound to `universal-argument' is read while reading a
+     numeric argument started with `universal-argument', it terminates the
+     argument but is otherwise ignored.  This provides a way to insert multiple
+     instances of a digit string, and is how GNU emacs does it.
+ 
+ -------------------------------------------------------------------------------
  This is a terse description of the new features added to bash-2.0 since
  the release of bash-1.14.7.  As always, the manual page (doc/bash.1) is
diff -Nrc2 bash-2.0/NOTES bash-2.01/NOTES
*** bash-2.0/NOTES	Tue Dec 17 14:45:56 1996
--- bash-2.01/NOTES	Fri Apr 11 17:00:00 1997
***************
*** 1,4 ****
! Platform-Specific Configuration Notes
! =====================================
  
  1.  configure --without-gnu-malloc on:
--- 1,4 ----
! Platform-Specific Configuration and Operation Notes
! ===================================================
  
  1.  configure --without-gnu-malloc on:
***************
*** 11,15 ****
  	all machines running SunOS YP code: SunOS4, SunOS5, HP/UX
  
! 	linux (optional)
  
  	QNX 4.2
--- 11,15 ----
  	all machines running SunOS YP code: SunOS4, SunOS5, HP/UX
  
! 	linux (optional, but don't do it if you're using Doug Lea's malloc)
  
  	QNX 4.2
***************
*** 33,42 ****
  3.  Bash cannot be built in a directory separate from the source directory
      using configure --srcdir=... unless the version of `make' you're using
!     does $VPATH handling right.  The SunOS make, for one, does not seem to
!     do it right.  The script support/mkclone can be used to create a
!     `build tree' using symlinks to get around this.
! 
! 4.  I've had reports that username completion does not work on IRIX 5.3
!     when linking with -lnsl.  This is only a problem when you're running
!     NIS.  Editing the Makefile after configure runs and removing the
!     `-lnsl' from the assignment to `LIBS' fixes the problem.
--- 33,139 ----
  3.  Bash cannot be built in a directory separate from the source directory
      using configure --srcdir=... unless the version of `make' you're using
!     does $VPATH handling right.  The script support/mkclone can be used to
!     create a `build tree' using symlinks to get around this.
! 
! 4.  I've had reports that username completion (as well as tilde expansion
!     and \u prompt expansion) does not work on IRIX 5.3 when linking with
!     -lnsl.  This is only a problem when you're running NIS, since
!     apparently -lnsl supports only /etc/passwd and not the NIS functions
!     for retrieving usernames and passwords.  Editing the Makefile after
!     configure runs and removing the `-lnsl' from the assignment to `LIBS'
!     fixes the problem.
! 
! 5.  There is a problem with Red Hat Linux's `makewhatis' script.
!     Running `makewhatis' with bash-2.0 results in error messages
!     like this:
! 
!     /usr/sbin/makewhatis: cd: manpath: No such file or directory
!     /usr/sbin/makewhatis: manpath/whatis: No such file or directory
!     chmod: manpath/whatis: No such file or directory
!     /usr/sbin/makewhatis: cd: catpath: No such file or directory
!     /usr/sbin/makewhatis: catpath/whatis: No such file or directory
!     chmod: catpath/whatis: No such file or directory
! 
!     The problem is with `makewhatis'.  Red Hat (and possibly other
!     Linux distributors) uses a construct like this in the code:
! 
!         eval path=$"$pages"path
! 
!     to do indirect variable expansion.  This `happened to work' in
!     bash-1.14 and previous versions, but that was more an accident
!     of implementation than anything else -- it was never supported
!     and certainly is not portable.
! 
!     Bash-2.0 has a new feature that gives a new meaning to $"...".
!     This is explained more completely in item 1 in the COMPAT file.
! 
!     The three lines in the `makewhatis' script that need to be changed
!     look like this:
! 
!              eval $topath=$"$topath":$name
!     [...]
!        eval path=$"$pages"path
!     [...]
!     eval path=$"$pages"path
! 
!     The portable way to write this code is
! 
!              eval $topath="\$$topath":$name
!        eval path="\$$pages"path
!     eval path="\$$pages"path
! 
!     You could also experiment with another new bash feature: ${!var}.
!     This does indirect variable expansion, making the use of eval
!     unnecessary.
! 
! 6.  There is a problem with syslogd on many Linux distributions (Red Hat
!     and Slackware are two that I have received reports about).  syslogd
!     sends a SIGINT to its parent process, which is waiting for the daemon
!     to finish its initialization.  The parent process then dies due to
!     the SIGINT, and bash reports it, causing unexpected console output
!     while the system is booting that looks something like
! 
! 	starting daemons: syslogd/etc/rc.d/rc.M: line 29: 38 Interrupt ${NET}/syslogd
! 
!     Bash-2.0 reports events such as processes dying in scripts due to
!     signals when the standard output is a tty.  Bash-1.14.x and previous
!     versions did not report such events.
! 
!     This should probably be reported as a bug to whatever Linux distributor
!     people see the problem on.  In my opinion, syslogd should be changed to
!     use some other method of communication, or the wrapper function (which
!     appeared to be `daemon' when I looked at it some time ago) or script
!     (which appeared to be `syslog') should catch SIGINT, since it's an
!     expected event, and exit cleanly.
! 
! 7.  Several people have reported that `dip' (a program for SLIP/PPP
!     on Linux) does not work with bash-2.0 installed as /bin/sh.
! 
!     I don't run any Linux boxes myself, and do not have the dip
!     code handy to look at, but the `problem' with bash-2.0, as
!     it has been related to me, is that bash requires the `-p'
!     option to be supplied at invocation if it is to run setuid
!     or setgid. 
! 
!     This means, among other things, that setuid or setgid programs
!     which call system(3) (a horrendously bad practice in any case)
!     relinquish their setuid/setgid status in the child that's forked
!     to execute /bin/sh. 
! 
!     The following is an *unofficial* patch to bash-2.0 that causes it
!     to not require `-p' to run setuid or setgid if invoked as `sh'.
!     It has been reported to work on Linux.  It will make your system
!     vulnerable to bogus system(3) calls in setuid executables.
! 
! --- ../bash-2.0.orig/shell.c    Wed Dec 18 14:16:30 1996
! +++ shell.c     Fri Mar  7 13:12:03 1997
! @@ -347,7 +347,7 @@
!    if (posixly_correct)
!      posix_initialize (posixly_correct);
! 
! -  if (running_setuid && privileged_mode == 0)
! +  if (running_setuid && privileged_mode == 0 && act_like_sh == 0)
!      disable_priv_mode ();
! 
!    /* Need to get the argument to a -c option processed in the
! 
diff -Nrc2 bash-2.0/README bash-2.01/README
*** bash-2.0/README	Tue Jun 18 12:34:27 1996
--- bash-2.01/README	Wed Feb 12 14:00:37 1997
***************
*** 2,6 ****
  ============
  
! This is GNU Bash, version 2.0.  Bash is the GNU Project's Bourne
  Again SHell, a complete implementation of the POSIX.2 shell spec,
  but also with interactive command line editing, job control on
--- 2,6 ----
  ============
  
! This is GNU Bash, version 2.01.  Bash is the GNU Project's Bourne
  Again SHell, a complete implementation of the POSIX.2 shell spec,
  but also with interactive command line editing, job control on
***************
*** 8,14 ****
  substitution and brace expansion, and a slew of other features. 
  For more information on the features of Bash that are new to this
! type of shell, see the file `doc/features.texi'.  There is also a
! large man page.  The manual page is the definitive description of
! the shell's features. 
  
  See the file CWRU/POSIX.NOTES for a discussion of how Bash differs
--- 8,14 ----
  substitution and brace expansion, and a slew of other features. 
  For more information on the features of Bash that are new to this
! type of shell, see the file `doc/bashref.texi'.  There is also a
! large Unix-style man page.  The man page is the definitive description
! of the shell's features. 
  
  See the file CWRU/POSIX.NOTES for a discussion of how Bash differs
***************
*** 16,25 ****
  
  There are some user-visible incompatibilities between this version
! of Bash and the previous version, bash-1.14.  For details, see the
! file COMPAT.
  
  Bash is free software, distributed under the terms of the GNU Public
  License, version 2.  For more information, see the file COPYING.
  
  To compile Bash, try typing `./configure', then `make'.  Bash
  auto-configures the build process, so no further intervention
--- 16,29 ----
  
  There are some user-visible incompatibilities between this version
! of Bash and the previous widely-distributed version, bash-1.14.
! For details, see the file COMPAT.  The NEWS file tersely lists
! features that are new in this release. 
  
  Bash is free software, distributed under the terms of the GNU Public
  License, version 2.  For more information, see the file COPYING.
  
+ A number of frequently-asked questions are answered in the file
+ `doc/FAQ'.
+ 
  To compile Bash, try typing `./configure', then `make'.  Bash
  auto-configures the build process, so no further intervention
***************
*** 40,49 ****
  If you are a csh user and wish to convert your csh aliases to Bash
  aliases, you may wish to use the script `examples/misc/alias-conv.sh'
! as a starting point.
  
  Reporting Bugs
  ==============
  
! Bug reports for 2.0 should be sent to:
  
  	bug-bash@prep.ai.mit.edu
--- 44,54 ----
  If you are a csh user and wish to convert your csh aliases to Bash
  aliases, you may wish to use the script `examples/misc/alias-conv.sh'
! as a starting point.  The script `examples/misc/cshtobash' is a
! more ambitious script that attempts to do a more complete job.
  
  Reporting Bugs
  ==============
  
! Bug reports for bash-2.01 should be sent to:
  
  	bug-bash@prep.ai.mit.edu
***************
*** 53,65 ****
  
  The discussion list `bug-bash@prep.ai.mit.edu' often contains
! information about new ports of Bash, or discussions of new
! features or behavior changes that people would like.  This
! mailing list is also available as a usenet newsgroup:
! gnu.bash.bug. 
! 
! When you send a bug report to bug-bash@prep.ai.mit.edu, please include:
! 
! 	* the version number of Bash
! 	* the machine and OS that it is running on (see .machine or .made)
  	* a list of the compilation flags or the contents of `config.h', if
  	  appropriate
--- 58,74 ----
  
  The discussion list `bug-bash@prep.ai.mit.edu' often contains
! information about new ports of Bash, or discussions of new features or
! behavior changes that people would like.  This mailing list is also
! available as a usenet newsgroup: gnu.bash.bug. 
! 
! When you send a bug report, please use the `bashbug' program that is
! built at the same time as bash.  If bash fails to build, try building
! bashbug directly with `make bashbug'.  If you cannot build `bashbug',
! please send mail to bug-bash@prep.ai.mit.edu with the following
! information:
! 
! 	* the version number and release status of Bash (e.g., 2.01-release)
! 	* the machine and OS that it is running on (look at the file
! 	  `.made' in the bash build directory)
  	* a list of the compilation flags or the contents of `config.h', if
  	  appropriate
***************
*** 70,75 ****
  The `bashbug' program includes much of this automatically.
  
! If you would like to contact the Bash maintainers directly, send mail to
! bash-maintainers@prep.ai.mit.edu.
  
  While the Bash maintainers do not promise to fix all bugs, we would
--- 79,84 ----
  The `bashbug' program includes much of this automatically.
  
! If you would like to contact the Bash maintainers directly, send mail
! to bash-maintainers@prep.ai.mit.edu. 
  
  While the Bash maintainers do not promise to fix all bugs, we would
diff -Nrc2 bash-2.0/aclocal.m4 bash-2.01/aclocal.m4
*** bash-2.0/aclocal.m4	Wed Dec 18 13:20:21 1996
--- bash-2.01/aclocal.m4	Wed May 21 11:30:45 1997
***************
*** 4,21 ****
  dnl Some derived from PDKSH 5.1.3 autoconf tests
  dnl
- dnl check whether cc can create executables
- dnl
- AC_DEFUN(BASH_CC_WORKS,
- [AC_CACHE_CHECK(whether CC works at all, bash_cv_prog_cc_works,	
- 	[AC_TRY_RUN([main() { exit(0); }],
- 		bash_cv_prog_cc_works=yes, bash_cv_prog_cc_works=no,
- 		bash_cv_prog_cc_works=no)
- 	]
- )
- if test "$bash_cv_prog_cc_works" = "no"; then
- AC_MSG_ERROR([Installation or configuration problem: C compiler cannot create executables])
- fi
- ])
- 
  dnl
  dnl Check if dup2() does not clear the close on exec flag
--- 4,7 ----
***************
*** 498,502 ****
  TERMCAP_LIB="./lib/termcap/libtermcap.a"
  TERMCAP_DEP="./lib/termcap/libtermcap.a"
! elif test $bash_cv_termcap_lib = libtermcap; then
  TERMCAP_LIB=-ltermcap
  TERMCAP_DEP=
--- 484,488 ----
  TERMCAP_LIB="./lib/termcap/libtermcap.a"
  TERMCAP_DEP="./lib/termcap/libtermcap.a"
! elif test $bash_cv_termcap_lib = libtermcap && test -z "$prefer_curses"; then
  TERMCAP_LIB=-ltermcap
  TERMCAP_DEP=
***************
*** 605,608 ****
--- 591,627 ----
  ])
  
+ AC_DEFUN(BASH_STRUCT_DIRENT_D_FILENO,
+ [AC_REQUIRE([AC_HEADER_DIRENT])
+ AC_MSG_CHECKING(if struct dirent has a d_fileno member)
+ AC_CACHE_VAL(bash_cv_dirent_has_d_fileno,
+ [AC_TRY_COMPILE([
+ #include <stdio.h>
+ #include <sys/types.h>
+ #ifdef HAVE_UNISTD_H
+ # include <unistd.h>
+ #endif /* HAVE_UNISTD_H */
+ #if defined(HAVE_DIRENT_H)
+ # include <dirent.h>
+ #else
+ # define dirent direct
+ # ifdef HAVE_SYS_NDIR_H
+ #  include <sys/ndir.h>
+ # endif /* SYSNDIR */
+ # ifdef HAVE_SYS_DIR_H
+ #  include <sys/dir.h>
+ # endif /* SYSDIR */
+ # ifdef HAVE_NDIR_H
+ #  include <ndir.h>
+ # endif
+ #endif /* HAVE_DIRENT_H */
+ ],[
+ struct dirent d; int z; z = d.d_fileno;
+ ], bash_cv_dirent_has_d_fileno=yes, bash_cv_dirent_has_d_fileno=no)])
+ AC_MSG_RESULT($bash_cv_dirent_has_d_fileno)
+ if test $bash_cv_dirent_has_d_fileno = yes; then
+ AC_DEFINE(STRUCT_DIRENT_HAS_D_FILENO)
+ fi
+ ])
+ 
  AC_DEFUN(BASH_REINSTALL_SIGHANDLERS,
  [AC_REQUIRE([AC_TYPE_SIGNAL])
***************
*** 835,838 ****
--- 854,869 ----
  ])
  
+ AC_DEFUN(BASH_STRUCT_WINSIZE,
+ [AC_MSG_CHECKING(for struct winsize in sys/ioctl.h)
+ AC_CACHE_VAL(bash_cv_struct_winsize_in_ioctl,
+ [AC_TRY_COMPILE([#include <sys/types.h>
+ #include <sys/ioctl.h>], [struct winsize x;],
+   bash_cv_struct_winsize_in_ioctl=yes,bash_cv_struct_winsize_in_ioctl=no)])
+ AC_MSG_RESULT($bash_cv_struct_winsize_in_ioctl)
+ if test $bash_cv_struct_winsize_in_ioctl = yes; then   
+ AC_DEFINE(STRUCT_WINSIZE_IN_SYS_IOCTL)
+ fi
+ ])
+ 
  AC_DEFUN(BASH_HAVE_TIOCSTAT,
  [AC_MSG_CHECKING(for TIOCSTAT in sys/ioctl.h)
***************
*** 859,862 ****
--- 890,910 ----
  ])
  
+ dnl
+ dnl See if speed_t is declared in <sys/types.h>.  Some versions of linux
+ dnl require a definition of speed_t each time <termcap.h> is included,
+ dnl but you can only get speed_t if you include <termios.h> (on some
+ dnl versions) or <sys/types.h> (on others).
+ dnl
+ AC_DEFUN(BASH_MISC_SPEED_T,
+ [AC_MSG_CHECKING(for speed_t in sys/types.h)
+ AC_CACHE_VAL(bash_cv_speed_t_in_sys_types,
+ [AC_TRY_COMPILE([#include <sys/types.h>], [speed_t x;],
+   bash_cv_speed_t_in_sys_types=yes,bash_cv_speed_t_in_sys_types=no)])
+ AC_MSG_RESULT($bash_cv_speed_t_in_sys_types)
+ if test $bash_cv_speed_t_in_sys_types = yes; then   
+ AC_DEFINE(SPEED_T_IN_SYS_TYPES)
+ fi
+ ])
+ 
  AC_DEFUN(BASH_CHECK_GETPW_FUNCS,
  [AC_MSG_CHECKING(whether programs are able to redeclare getpw functions)
***************
*** 893,896 ****
--- 941,951 ----
  ])
  
+ dnl
+ dnl Check for the presence of getpeername (the only networking function
+ dnl bash currently requires) in libsocket.  If libsocket is present,
+ dnl check for libnsl and add it to LIBS if it's there, since most
+ dnl systems with libsocket require linking with libnsl as well.
+ dnl This should only be called if getpeername was not found in libc.
+ dnl
  AC_DEFUN(BASH_CHECK_SOCKLIB,
  [
***************
*** 990,993 ****
--- 1045,1096 ----
  if test $bash_cv_kernel_rlimit = yes; then
  AC_DEFINE(RLIMIT_NEEDS_KERNEL)
+ fi
+ ])
+ 
+ AC_DEFUN(BASH_FUNC_STRCOLL,
+ [
+ AC_MSG_CHECKING(whether or not strcoll and strcmp differ)
+ AC_CACHE_VAL(bash_cv_func_strcoll_broken,
+ [AC_TRY_RUN([
+ #include <stdio.h>
+ #if defined (HAVE_LOCALE_H)
+ #include <locale.h>
+ #endif
+ 
+ main(c, v)
+ int     c;
+ char    *v[];
+ {
+         int     r1, r2;
+         char    *deflocale, *defcoll;
+ 
+ #ifdef HAVE_SETLOCALE
+         deflocale = setlocale(LC_ALL, "");
+ 	defcoll = setlocale(LC_COLLATE, "");
+ #endif
+ 
+ #ifdef HAVE_STRCOLL
+ 	/* These two values are taken from tests/glob-test. */
+         r1 = strcoll("abd", "aXd");
+ #else
+ 	r1 = 0;
+ #endif
+         r2 = strcmp("abd", "aXd");
+ 
+ 	/* These two should both be greater than 0.  It is permissible for
+ 	   a system to return different values, as long as the sign is the
+ 	   same. */
+ 
+         /* Exit with 1 (failure) if these two values are both > 0, since
+ 	   this tests whether strcoll(3) is broken with respect to strcmp(3)
+ 	   in the default locale. */
+ 	exit (r1 > 0 && r2 > 0);
+ }
+ ], bash_cv_func_strcoll_broken=yes, bash_cv_func_strcoll_broken=no,
+    AC_MSG_ERROR(cannot check strcoll if cross compiling))
+ ])
+ AC_MSG_RESULT($bash_cv_func_strcoll_broken)
+ if test $bash_cv_func_strcoll_broken = yes; then
+ AC_DEFINE(STRCOLL_BROKEN)
  fi
  ])
diff -Nrc2 bash-2.0/alias.c bash-2.01/alias.c
*** bash-2.0/alias.c	Wed Nov 20 11:35:16 1996
--- bash-2.01/alias.c	Mon Apr 14 15:58:00 1997
***************
*** 152,155 ****
--- 152,156 ----
        free_alias_data (elt->data);
        free (elt->key);		/* alias name */
+       free (elt);		/* XXX */
        return (aliases->nentries);
      }
***************
*** 165,169 ****
  
    flush_hash_table (aliases, free_alias_data);
!   free (aliases);
    aliases = (HASH_TABLE *)NULL;
  }
--- 166,170 ----
  
    flush_hash_table (aliases, free_alias_data);
!   dispose_hash_table (aliases);
    aliases = (HASH_TABLE *)NULL;
  }
***************
*** 248,251 ****
--- 249,256 ----
  }
  
+ /* Readline support functions -- expand all aliases in a line. */
+ 
+ #if defined (READLINE)
+ 
  /* Return non-zero if CHARACTER is a member of the class of characters
     that are self-delimiting in the shell (this really means that these
***************
*** 530,532 ****
--- 535,538 ----
      }
  }
+ #endif /* READLINE */
  #endif /* ALIAS */
diff -Nrc2 bash-2.0/array.c bash-2.01/array.c
*** bash-2.0/array.c	Mon Jul 22 14:36:17 1996
--- bash-2.01/array.c	Wed Feb 26 17:01:36 1997
***************
*** 18,21 ****
--- 18,23 ----
  
  #include <stdio.h>
+ #include "bashansi.h"
+ 
  #include "shell.h"
  #include "array.h"
***************
*** 124,127 ****
--- 126,130 ----
  }
  
+ #ifdef INCLUDE_UNUSED
  /*
   * Make and return a new array composed of the elements in array A from
***************
*** 147,150 ****
--- 150,154 ----
  	return a;
  }
+ #endif
  
  ARRAY_ELEMENT *
***************
*** 393,396 ****
--- 397,401 ----
  #endif
  
+ #if defined (INCLUDE_UNUSED) || defined (TEST_ARRAY)
  /*
   * Return an array consisting of elements in S, separated by SEP
***************
*** 411,414 ****
--- 416,420 ----
  	return (a);
  }
+ #endif
  
  /* Convenience routines for the shell to translate to and from the form used
***************
*** 550,554 ****
  	array_add_element(a, 42, "forty-two");
  	print_array(a);
! 	s = array_to_string (a, " ");
  	printf("s = %s\n", s);
  	copy_of_a = string_to_array(s, " ");
--- 556,560 ----
  	array_add_element(a, 42, "forty-two");
  	print_array(a);
! 	s = array_to_string (a, " ", 0);
  	printf("s = %s\n", s);
  	copy_of_a = string_to_array(s, " ");
***************
*** 564,568 ****
  	array_add_element(a, 16, "sixteen");
  	print_array(a);
! 	s = array_to_string (a, " ");
  	printf("s = %s\n", s);
  	copy_of_a = string_to_array(s, " ");
--- 570,574 ----
  	array_add_element(a, 16, "sixteen");
  	print_array(a);
! 	s = array_to_string (a, " ", 0);
  	printf("s = %s\n", s);
  	copy_of_a = string_to_array(s, " ");
***************
*** 577,581 ****
  	array_add_element(a, 134, "");
  	print_array(a);
! 	s = array_to_string (a, ":");
  	printf("s = %s\n", s);
  	copy_of_a = string_to_array(s, ":");
--- 583,587 ----
  	array_add_element(a, 134, "");
  	print_array(a);
! 	s = array_to_string (a, ":", 0);
  	printf("s = %s\n", s);
  	copy_of_a = string_to_array(s, ":");
***************
*** 587,593 ****
  	new_a = copy_array(a);
  	print_array(new_a);
! 	s = array_to_string (new_a, ":");
  	printf("s = %s\n", s);
! 	copy_of_a = string_to_array(s, ":");
  	printf("copy_of_a:");
  	print_array(copy_of_a);
--- 593,599 ----
  	new_a = copy_array(a);
  	print_array(new_a);
! 	s = array_to_string (new_a, ":", 0);
  	printf("s = %s\n", s);
! 	copy_of_a = string_to_array(s, ":", 0);
  	printf("copy_of_a:");
  	print_array(copy_of_a);
diff -Nrc2 bash-2.0/bashhist.c bash-2.01/bashhist.c
*** bash-2.0/bashhist.c	Mon Jul 22 14:36:24 1996
--- bash-2.01/bashhist.c	Wed May 14 14:08:52 1997
***************
*** 33,36 ****
--- 33,37 ----
  #include "posixstat.h"
  #include "filecntl.h"
+ 
  #include "shell.h"
  #include "flags.h"
***************
*** 39,42 ****
--- 40,44 ----
  #include "pathexp.h"	/* for the struct ignorevar stuff */
  #include "builtins/common.h"
+ 
  #include <readline/history.h>
  #include <glob/fnmatch.h>
***************
*** 50,53 ****
--- 52,57 ----
  #endif
  
+ extern int glob_pattern_p ();
+ 
  static int histignore_item_func ();
  
***************
*** 125,128 ****
--- 129,137 ----
  int history_control;
  
+ /* Set to 1 if the last command was added to the history list successfully
+    as a separate history entry; set to 0 if the line was ignored or added
+    to a previous entry as part of command-oriented-history processing. */
+ int hist_last_line_added;
+ 
  #if defined (READLINE)
  /* If non-zero, and readline is being used, the user is offered the
***************
*** 134,138 ****
     instead and let the user further edit and confirm with a newline. */
  int hist_verify;
! #endif
  
  /* Variables declared in other files used here. */
--- 143,148 ----
     instead and let the user further edit and confirm with a newline. */
  int hist_verify;
! 
! #endif /* READLINE */
  
  /* Variables declared in other files used here. */
***************
*** 145,152 ****
  extern char *history_delimiting_chars ();
  extern void maybe_add_history ();	/* forward declaration */
  
- static void bash_add_history ();
  static int history_should_ignore ();
  
  void
  bash_initialize_history ()
--- 155,182 ----
  extern char *history_delimiting_chars ();
  extern void maybe_add_history ();	/* forward declaration */
+ extern void bash_add_history ();	/* forward declaration */
  
  static int history_should_ignore ();
  
+ /* Is the history expansion starting at string[i] one that should not
+    be expanded? */
+ static int
+ bash_history_inhibit_expansion (string, i)
+      char *string;
+      int i;
+ {
+   /* The shell uses ! as a pattern negation character in globbing [...]
+      expressions, so let those pass without expansion. */
+   if (i > 0 && (string[i - 1] == '[') && member (']', string + i + 1))
+     return (1);
+   /* The shell uses ! as the indirect expansion character, so let those
+      expansions pass as well. */
+   else if (i > 1 && string[i - 1] == '{' && string[i - 2] == '$' &&
+ 	     member ('}', string + i + 1))
+     return (1);
+   else
+     return (0);
+ }
+ 
  void
  bash_initialize_history ()
***************
*** 154,157 ****
--- 184,188 ----
    history_quotes_inhibit_expansion = 1;
    history_search_delimiter_chars = ";&()|<>";
+   history_inhibit_expansion_function = bash_history_inhibit_expansion;
  }
  
***************
*** 165,168 ****
--- 196,200 ----
  #endif
    remember_on_history = interact != 0;
+   history_inhibit_expansion_function = bash_history_inhibit_expansion;
  }
  
***************
*** 183,186 ****
--- 215,219 ----
    history_expansion_inhibited = 0;
  #endif
+   history_inhibit_expansion_function = bash_history_inhibit_expansion;
    sv_history_control ("HISTCONTROL");
    sv_histignore ("HISTIGNORE");
***************
*** 212,215 ****
--- 245,249 ----
  }
  
+ #ifdef INCLUDE_UNUSED
  /* Write the existing history out to the history file. */
  void
***************
*** 234,237 ****
--- 268,272 ----
      }
  }
+ #endif
  
  int
***************
*** 366,370 ****
--- 401,409 ----
  	      if (expanded < 0)
  		internal_error (history_value);
+ #if defined (READLINE)
  	      else if (hist_verify == 0)
+ #else
+ 	      else
+ #endif
  		fprintf (stderr, "%s\n", history_value);
  	    }
***************
*** 404,409 ****
--- 443,450 ----
      maybe_add_history (return_value);
  
+ #if 0
    if (expanded == 0)
      return_value = savestring (line);
+ #endif
  
    return (return_value);
***************
*** 418,422 ****
    HIST_ENTRY *temp;
  
!   should_add = 0;
  
    /* Don't use the value of history_control to affect the second
--- 459,463 ----
    HIST_ENTRY *temp;
  
!   should_add = hist_last_line_added = 0;
  
    /* Don't use the value of history_control to affect the second
***************
*** 462,466 ****
     complete parser construct, append LINE to the last history line instead
     of adding it as a new line. */
! static void
  bash_add_history (line)
       char *line;
--- 503,507 ----
     complete parser construct, append LINE to the last history line instead
     of adding it as a new line. */
! void
  bash_add_history (line)
       char *line;
***************
*** 513,516 ****
--- 554,558 ----
    if (add_it)
      {
+       hist_last_line_added = 1;
        add_history (line);
        history_lines_this_session++;
diff -Nrc2 bash-2.0/bashhist.h bash-2.01/bashhist.h
*** bash-2.0/bashhist.h	Tue May 21 14:44:01 1996
--- bash-2.01/bashhist.h	Wed May 14 14:03:53 1997
***************
*** 28,31 ****
--- 28,32 ----
  extern int history_control;
  extern int command_oriented_history;
+ extern int hist_last_line_added;
  
  #  if defined (BANG_HISTORY)
***************
*** 44,47 ****
--- 45,49 ----
  extern int history_number ();
  extern void maybe_add_history ();
+ extern void bash_add_history ();
  
  extern void setup_history_ignore ();
diff -Nrc2 bash-2.0/bashjmp.h bash-2.01/bashjmp.h
*** bash-2.0/bashjmp.h	Mon Mar  4 10:59:28 1996
--- bash-2.01/bashjmp.h	Thu Jan 16 13:53:08 1997
***************
*** 4,20 ****
  #define _BASHJMP_H_
  
! #include <setjmp.h>
! 
! /* This *must* be included *after* config.h */
! 
! #if defined (HAVE_POSIX_SIGSETJMP)
! #  define procenv_t	sigjmp_buf
! #  undef setjmp
! #  define setjmp(x)	sigsetjmp((x), 1)
! #  undef longjmp
! #  define longjmp(x, n)	siglongjmp((x), (n))
! #else
! #  define procenv_t	jmp_buf
! #endif
  
  extern procenv_t	top_level;
--- 4,8 ----
  #define _BASHJMP_H_
  
! #include "posixjmp.h"
  
  extern procenv_t	top_level;
diff -Nrc2 bash-2.0/bashline.c bash-2.01/bashline.c
*** bash-2.0/bashline.c	Wed Nov 20 11:37:19 1996
--- bash-2.01/bashline.c	Tue Jun  3 11:14:09 1997
***************
*** 57,60 ****
--- 57,65 ----
  static void display_shell_version (), operate_and_get_next ();
  static void history_expand_line (), bash_ignore_filenames ();
+ #ifdef ALIAS
+ static void alias_expand_line ();
+ #endif
+ static void history_and_alias_expand_line ();
+ static void cleanup_expansion_error (), set_up_new_line ();
  
  /* Helper functions for Readline. */
***************
*** 195,198 ****
--- 200,208 ----
    rl_bind_key_in_map ('^', (Function *)history_expand_line, emacs_meta_keymap);
  
+ #ifdef ALIAS
+   rl_add_defun ("alias-expand-line", (Function *)alias_expand_line, -1);
+   rl_add_defun ("history-and-alias-expand-line", (Function *)history_and_alias_expand_line, -1);
+ #endif
+ 
    /* Backwards compatibility. */
    rl_add_defun ("insert-last-argument", rl_yank_last_arg, -1);
***************
*** 286,290 ****
  
    /* characters that need to be quoted when appearing in filenames. */
!   rl_filename_quote_characters = " \t\n\\\"'@<>=;|&()#$`?*[!";
    rl_filename_quoting_function = bash_quote_filename;
    rl_filename_dequoting_function = bash_dequote_filename;
--- 296,300 ----
  
    /* characters that need to be quoted when appearing in filenames. */
!   rl_filename_quote_characters = " \t\n\\\"'@<>=;|&()#$`?*[!:";
    rl_filename_quoting_function = bash_quote_filename;
    rl_filename_dequoting_function = bash_dequote_filename;
***************
*** 593,603 ****
  	 it's supposed to deal with the command before the `fc'). */
        using_history ();
!       add_history (rl_line_buffer);
!       add_history ("");
        history_lines_this_session++;
        using_history ();
        command = savestring (VI_EDIT_COMMAND);
      }
!   parse_and_execute (command, "v", -1);
    rl_line_buffer[0] = '\0';	/* XXX */
  }
--- 603,613 ----
  	 it's supposed to deal with the command before the `fc'). */
        using_history ();
!       bash_add_history (rl_line_buffer);
!       bash_add_history ("");
        history_lines_this_session++;
        using_history ();
        command = savestring (VI_EDIT_COMMAND);
      }
!   parse_and_execute (command, "v", SEVAL_NOHIST);
    rl_line_buffer[0] = '\0';	/* XXX */
  }
***************
*** 689,694 ****
      }
  
!   /* Special handling for command substitution. */
!   if (*text == '`' && unclosed_pair (rl_line_buffer, start, "`"))
      matches = completion_matches (text, command_subst_completion_function);
  
--- 699,714 ----
      }
  
!   /* Check that we haven't incorrectly flagged a closed command substitution
!      as indicating we're in a command position. */
!   if (in_command_position && rl_line_buffer[ti] == '`' && *text != '`' && 
! 	unclosed_pair (rl_line_buffer, 0, "`") == 0)
!     in_command_position = 0;
! 
!   /* Special handling for command substitution.  If *TEXT is a backquote,
!      it can be the start or end of an old-style command substitution, or
!      unmatched.  If it's unmatched, both calls to unclosed_pair will
!      succeed.  */
!   if (*text == '`' && unclosed_pair (rl_line_buffer, start, "`") &&
! 	unclosed_pair (rl_line_buffer, end, "`"))
      matches = completion_matches (text, command_subst_completion_function);
  
***************
*** 929,933 ****
    else
      {
!       int match;
        char *temp;
  
--- 949,953 ----
    else
      {
!       int match, freetemp;
        char *temp;
  
***************
*** 949,952 ****
--- 969,973 ----
  	  else
  	    temp = savestring (val);
+ 	  freetemp = 1;
  	}
        else
***************
*** 957,966 ****
  	    {
  	      temp++;
! 	      match = strncmp (temp, hint, hint_len) == 0;
  	      if (match)
  		temp = savestring (temp);
  	    }
  	  else
! 	    match = 0;
  	}
  
--- 978,987 ----
  	    {
  	      temp++;
! 	      freetemp = match = strncmp (temp, hint, hint_len) == 0;
  	      if (match)
  		temp = savestring (temp);
  	    }
  	  else
! 	    freetemp = match = 0;
  	}
  
***************
*** 975,978 ****
--- 996,1001 ----
        else
  	{
+ 	  if (freetemp)
+ 	    free (temp);
  	  free (val);
  	  goto inner;
***************
*** 981,984 ****
--- 1004,1008 ----
  }
  
+ /* Completion inside an unterminated command substitution. */
  static char *
  command_subst_completion_function (text, state)
***************
*** 1149,1165 ****
  
    new_line = pre_process_line (line, 0, 0);
!   return new_line;
  }
  
  #if defined (ALIAS)
! /* Perform alias expansion on LINE and return the new line. */
! static char *
! alias_expand_line_internal (line)
!      char *line;
  {
!   char *alias_line;
  
!   alias_line = alias_expand (line);
!   return alias_line;
  }
  #endif
--- 1173,1193 ----
  
    new_line = pre_process_line (line, 0, 0);
!   return (new_line == line) ? savestring (line) : new_line;
  }
  
  #if defined (ALIAS)
! /* Expand aliases in the current readline line. */
! static void
! alias_expand_line (ignore)
!      int ignore;
  {
!   char *new_line;
! 
!   new_line = alias_expand (rl_line_buffer);
  
!   if (new_line)
!     set_up_new_line (new_line);
!   else
!     cleanup_expansion_error ();
  }
  #endif
***************
*** 1174,1178 ****
    fprintf (rl_outstream, "\r\n");
    to_free = pre_process_line (rl_line_buffer, 1, 0);
!   free (to_free);
    putc ('\r', rl_outstream);
    rl_forced_update_display ();
--- 1202,1207 ----
    fprintf (rl_outstream, "\r\n");
    to_free = pre_process_line (rl_line_buffer, 1, 0);
!   if (to_free != rl_line_buffer)
!     free (to_free);
    putc ('\r', rl_outstream);
    rl_forced_update_display ();
***************
*** 1245,1248 ****
--- 1274,1279 ----
  
    new_line = pre_process_line (rl_line_buffer, 0, 0);
+   if (new_line == rl_line_buffer)
+     new_line = savestring (new_line);
  
  #if defined (ALIAS)
***************
*** 1273,1276 ****
--- 1304,1309 ----
  
    new_line = pre_process_line (rl_line_buffer, 0, 0);
+   if (new_line == rl_line_buffer)
+     new_line = savestring (new_line);
  
  #if defined (ALIAS)
***************
*** 1297,1301 ****
        /* If there is variable expansion to perform, do that as a separate
  	 operation to be undone. */
!       expanded_string = expand_string (rl_line_buffer, 0);
        if (expanded_string == 0)
  	{
--- 1330,1336 ----
        /* If there is variable expansion to perform, do that as a separate
  	 operation to be undone. */
!       new_line = savestring (rl_line_buffer);
!       expanded_string = expand_string (new_line, 0);
!       FREE (new_line);
        if (expanded_string == 0)
  	{
***************
*** 1863,1867 ****
  }
  
! /* Quote a filename using double quotes. */
  static char *
  bash_quote_filename (s, rtype, qcp)
--- 1898,1939 ----
  }
  
! /* Quote characters that the readline completion code would treat as
!    word break characters with backslashes.  Pass backslash-quoted
!    characters through without examination. */
! static char *
! quote_word_break_chars (text)
!      char *text;
! {
!   char *ret, *r, *s;
!   int l;
! 
!   l = strlen (text);
!   ret = xmalloc ((2 * l) + 1);
!   for (s = text, r = ret; *s; s++)
!     {
!       /* Pass backslash-quoted characters through, including the backslash. */
!       if (*s == '\\')
! 	{
! 	  *r++ = '\\';
! 	  *r++ = *++s;
! 	  if (*s == '\0')
! 	    break;
! 	  continue;
! 	}
!       /* OK, we have an unquoted character.  Check its presence in
! 	 rl_completer_word_break_characters. */
!       if (strchr (rl_completer_word_break_characters, *s))
!         *r++ = '\\';
!       *r++ = *s;
!     }
!   *r = '\0';
!   return ret;
! }
! 
! /* Quote a filename using double quotes, single quotes, or backslashes
!    depending on the value of completion_quoting_style.  If we're
!    completing using backslashes, we need to quote some additional
!    characters (those that readline treats as word breaks), so we call
!    quote_word_break_chars on the result. */
  static char *
  bash_quote_filename (s, rtype, qcp)
***************
*** 1897,1900 ****
--- 1969,1979 ----
  	   history_expansion_inhibited == 0 && strchr (mtext, '!'))
      cs = COMPLETE_BSQUOTE;
+ 
+   if (*qcp == '"' && history_expansion && cs == COMPLETE_DQUOTE &&
+         history_expansion_inhibited == 0 && strchr (mtext, '!'))
+     {
+       cs = COMPLETE_BSQUOTE;
+       *qcp = '\0';
+     }
  #endif
  
***************
*** 1914,1917 ****
--- 1993,2005 ----
    if (mtext != s)
      free (mtext);
+ 
+   /* We may need to quote additional characters: those that readline treats
+      as word breaks that are not quoted by backslash_quote. */
+   if (rtext && cs == COMPLETE_BSQUOTE)
+     {
+       mtext = quote_word_break_chars (rtext);
+       free (rtext);
+       rtext = mtext;
+     }
  
    /* Leave the opening quote intact.  The readline completion code takes
diff -Nrc2 bash-2.0/bashwait.h bash-2.01/bashwait.h
*** bash-2.0/bashwait.h	Thu Feb 15 14:27:53 1996
--- bash-2.01/bashwait.h	Wed Dec 31 19:00:00 1969
***************
*** 1,98 ****
- /* bashwait.h -- definitions for using a `union wait' on systems without
-    one. */
- 
- /* Copyright (C) 1996 Free Software Foundation, Inc.
- 
-    This file is part of GNU Bash, the Bourne Again SHell.
- 
-    Bash is free software; you can redistribute it and/or modify it under
-    the terms of the GNU General Public License as published by the Free
-    Software Foundation; either version 2, or (at your option) any later
-    version.
- 
-    Bash is distributed in the hope that it will be useful, but WITHOUT ANY
-    WARRANTY; without even the implied warranty of MERCHANTABILITY or
-    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-    for more details.
- 
-    You should have received a copy of the GNU General Public License along
-    with Bash; see the file COPYING.  If not, write to the Free Software
-    Foundation, 675 Mass Ave, Cambridge, MA 02139, USA. */
- 
- #ifndef _BASH_WAIT_H
- #define _BASH_WAIT_H
- 
- #if !defined (WORDS_BIGENDIAN)
- union wait
-   {
-     int	w_status;		/* used in syscall */
- 
-     /* Terminated process status. */
-     struct
-       {
- 	unsigned short
- 	  w_Termsig  : 7,	/* termination signal */
- 	  w_Coredump : 1,	/* core dump indicator */
- 	  w_Retcode  : 8,	/* exit code if w_termsig==0 */
- 	  w_Fill1    : 16;	/* high 16 bits unused */
-       } w_T;
- 
-     /* Stopped process status.  Returned
-        only for traced children unless requested
-        with the WUNTRACED option bit. */
-     struct
-       {
- 	unsigned short
- 	  w_Stopval : 8,	/* == W_STOPPED if stopped */
- 	  w_Stopsig : 8,	/* actually zero on XENIX */
- 	  w_Fill2   : 16;	/* high 16 bits unused */
-       } w_S;
-   };
- 
- #else  /* WORDS_BIGENDIAN */
- 
- /* This is for big-endian machines like the IBM RT, HP 9000, or Sun-3 */
- 
- union wait
-   {
-     int	w_status;		/* used in syscall */
- 
-     /* Terminated process status. */
-     struct
-       {
- 	unsigned short w_Fill1    : 16;	/* high 16 bits unused */
- 	unsigned       w_Retcode  : 8;	/* exit code if w_termsig==0 */
- 	unsigned       w_Coredump : 1;	/* core dump indicator */
- 	unsigned       w_Termsig  : 7;	/* termination signal */
-       } w_T;
- 
-     /* Stopped process status.  Returned
-        only for traced children unless requested
-        with the WUNTRACED option bit. */
-     struct
-       {
- 	unsigned short w_Fill2   : 16;	/* high 16 bits unused */
- 	unsigned       w_Stopsig : 8;	/* signal that stopped us */
- 	unsigned       w_Stopval : 8;	/* == W_STOPPED if stopped */
-       } w_S;
-   };
- 
- #endif /* WORDS_BIGENDIAN */
- 
- #define w_termsig  w_T.w_Termsig
- #define w_coredump w_T.w_Coredump
- #define w_retcode  w_T.w_Retcode
- #define w_stopval  w_S.w_Stopval
- #define w_stopsig  w_S.w_Stopsig
- 
- #define WSTOPPED       0177
- #define WIFSTOPPED(x)  ((x).w_stopval == WSTOPPED)
- #define WIFEXITED(x)   ((x).w_stopval != WSTOPPED && (x).w_termsig == 0)
- #define WIFSIGNALED(x) ((x).w_stopval != WSTOPPED && (x).w_termsig != 0)
- 
- #define WTERMSIG(x)    ((x).w_termsig)
- #define WSTOPSIG(x)    ((x).w_stopsig)
- #define WEXITSTATUS(x) ((x).w_retcode)
- #define WIFCORED(x)    ((x).w_coredump)
- 
- #endif /* _BASH_WAIT_H */
--- 0 ----
diff -Nrc2 bash-2.0/bracecomp.c bash-2.01/bracecomp.c
*** bash-2.0/bracecomp.c	Thu Jan 25 13:26:46 1996
--- bash-2.01/bracecomp.c	Wed Feb  5 11:39:23 1997
***************
*** 32,40 ****
  #endif
  
! #if defined (HAVE_STRING_H)
! #  include <string.h>
! #else /* !HAVE_STRING_H */
! #  include <strings.h>
! #endif /* !HAVE_STRING_H */
  
  #include "shell.h"
--- 32,36 ----
  #endif
  
! #include "bashansi.h"
  
  #include "shell.h"
***************
*** 104,108 ****
  	  result_size += 1;
  	  result = xrealloc (result, result_size);
! 	  strcpy (result, "{");
  	  flag++;
  	}
--- 100,104 ----
  	  result_size += 1;
  	  result = xrealloc (result, result_size);
! 	  result[0] = '{'; result[1] = '\0';
  	  flag++;
  	}
diff -Nrc2 bash-2.0/braces.c bash-2.01/braces.c
*** bash-2.0/braces.c	Wed Aug  7 16:01:13 1996
--- bash-2.01/braces.c	Wed Feb 19 11:12:08 1997
***************
*** 29,37 ****
  #endif
  
! #if defined (HAVE_STRING_H)
! #  include <string.h>
! #else /* !HAVE_STRING_H */
! #  include <strings.h>
! #endif /* !HAVE_STRING_H */
  
  #if defined (SHELL)
--- 29,33 ----
  #endif
  
! #include "bashansi.h"
  
  #if defined (SHELL)
***************
*** 42,45 ****
--- 38,45 ----
  #define brace_whitespace(c) (!(c) || (c) == ' ' || (c) == '\t' || (c) == '\n')
  
+ #if defined (SHELL)
+ extern char *extract_command_subst ();
+ #endif
+ 
  /* Basic idea:
  
***************
*** 211,214 ****
--- 211,218 ----
  {
    register int i, c, quoted, level, pass_next;
+ #if defined (SHELL)
+   int si;
+   char *t;
+ #endif
  
    level = quoted = pass_next = 0;
***************
*** 242,245 ****
--- 246,261 ----
  	  continue;
  	}
+ 
+ #if defined (SHELL)
+       /* Pass new-style command substitutions through unchanged. */
+       if (c == '$' && text[i+1] == '(')			/* ) */
+ 	{
+ 	  si = i + 2;
+ 	  t = extract_command_subst (text, &si);
+ 	  i = si;
+ 	  free (t);
+ 	  continue;
+ 	}
+ #endif
  
        if (c == satisfy && level == 0 && quoted == 0)
diff -Nrc2 bash-2.0/builtins/Makefile.in bash-2.01/builtins/Makefile.in
*** bash-2.0/builtins/Makefile.in	Fri Oct  4 10:24:22 1996
--- bash-2.01/builtins/Makefile.in	Tue Apr  1 13:00:42 1997
***************
*** 1,10 ****
  # This Makefile for building libbuiltins.a is in -*- text -*- for Emacs.
  #
- MKBUILTINS = mkbuiltins
- RANLIB = @RANLIB@
- CFLAGS = @CFLAGS@
- LOCAL_CFLAGS = @LOCAL_CFLAGS@
- CPPFLAGS = @CPPFLAGS@
  SHELL = /bin/sh
  CC = @CC@
  AR = @AR@
--- 1,6 ----
  # This Makefile for building libbuiltins.a is in -*- text -*- for Emacs.
  #
  SHELL = /bin/sh
+ RANLIB = @RANLIB@
  CC = @CC@
  AR = @AR@
***************
*** 12,17 ****
  CP = cp
  
- LIBS = @LIBS@
- 
  srcdir = @srcdir@
  VPATH = .:@srcdir@
--- 8,11 ----
***************
*** 19,28 ****
  includedir = @includedir@
  
  DEFS = @DEFS@
  
  INCLUDES = -I. -I.. -I$(topdir) -I$(topdir)/lib -I$(srcdir)
  
! CCFLAGS = $(DEFS) $(SYSTEM_FLAGS) $(CPPFLAGS) ${INCLUDES} $(LOCAL_CFLAGS) $(CFLAGS)
  
  DIRECTDEFINE = -D $(srcdir)
  
--- 13,30 ----
  includedir = @includedir@
  
+ PROFILE_FLAGS =
+ CFLAGS = @CFLAGS@
+ LOCAL_CFLAGS = @LOCAL_CFLAGS@
+ CPPFLAGS = @CPPFLAGS@
  DEFS = @DEFS@
+ LOCAL_DEFS = @LOCAL_DEFS@
+ LIBS = @LIBS@
  
  INCLUDES = -I. -I.. -I$(topdir) -I$(topdir)/lib -I$(srcdir)
  
! CCFLAGS = ${PROFILE_FLAGS} $(DEFS) $(LOCAL_DEFS) $(SYSTEM_FLAGS) $(CPPFLAGS) \
! 	  ${INCLUDES} $(LOCAL_CFLAGS) $(CFLAGS)
  
+ MKBUILTINS = mkbuiltins
  DIRECTDEFINE = -D $(srcdir)
  
***************
*** 159,169 ****
  reserved.o: reserved.def
  
! common.o: $(topdir)/shell.h $(topdir)/command.h ../config.h
! common.o: $(topdir)/memalloc.h $(topdir)/general.h
! common.o: $(topdir)/variables.h $(topdir)/input.h $(srcdir)/hashcom.h
! common.o: $(topdir)/bashhist.h $(topdir)/quit.h  $(topdir)/unwind_prot.h
! common.o: $(topdir)/maxpath.h $(topdir)/jobs.h $(topdir)/builtins.h
! common.o: $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h $(topdir)/subst.h
! common.o: $(topdir)/execute_cmd.h $(topdir)/error.h $(topdir)/externs.h
  alias.o: $(topdir)/command.h ../config.h $(topdir)/memalloc.h
  alias.o: $(topdir)/error.h $(topdir)/general.h $(topdir)/maxpath.h
--- 161,215 ----
  reserved.o: reserved.def
  
! # C files
! bashgetopt.o: ../config.h $(topdir)/bashansi.h $(topdir)/ansi_stdlib.h
! bashgetopt.o: $(topdir)/shell.h $(topdir)/bashjmp.h
! bashgetopt.o: $(topdir)/command.h $(topdir)/general.h $(topdir)/error.h
! bashgetopt.o: $(topdir)/variables.h $(topdir)/quit.h $(topdir)/maxpath.h
! bashgetopt.o: $(topdir)/unwind_prot.h $(topdir)/dispose_cmd.h
! bashgetopt.o: $(topdir)/make_cmd.h $(topdir)/subst.h $(topdir)/sig.h
! bashgetopt.o: $(topdir)/pathnames.h $(topdir)/externs.h $(srcdir)/common.h
! common.o: $(topdir)/bashtypes.h $(topdir)/posixstat.h $(topdir)/bashansi.h $(topdir)/ansi_stdlib.h
! common.o: $(topdir)/shell.h ../config.h $(topdir)/bashjmp.h $(topdir)/posixjmp.h
! common.o: $(topdir)/sig.h $(topdir)/command.h
! common.o: $(topdir)/general.h $(topdir)/stdc.h $(topdir)/memalloc.h
! common.o: $(topdir)/variables.h $(topdir)/input.h
! common.o: $(topdir)/siglist.h $(topdir)/bashhist.h $(topdir)/quit.h
! common.o: $(topdir)/unwind_prot.h $(topdir)/maxpath.h $(topdir)/jobs.h
! common.o: $(topdir)/builtins.h $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h
! common.o: $(topdir)/subst.h $(topdir)/execute_cmd.h $(topdir)/error.h
! common.o: $(topdir)/externs.h $(topdir)/pathnames.h ./builtext.h
! evalfile.o: $(topdir)/bashtypes.h $(topdir)/posixstat.h $(topdir)/filecntl.h
! evalfile.o: $(topdir)/bashansi.h $(topdir)/ansi_stdlib.h
! evalfile.o: $(topdir)/shell.h ../config.h $(topdir)/bashjmp.h
! evalfile.o: $(topdir)/command.h $(topdir)/general.h $(topdir)/error.h
! evalfile.o: $(topdir)/variables.h $(topdir)/quit.h $(topdir)/maxpath.h
! evalfile.o: $(topdir)/unwind_prot.h $(topdir)/dispose_cmd.h
! evalfile.o: $(topdir)/make_cmd.h $(topdir)/subst.h $(topdir)/sig.h
! evalfile.o: $(topdir)/pathnames.h $(topdir)/externs.h
! evalfile.o: $(topdir)/jobs.h $(topdir)/builtins.h $(topdir)/flags.h
! evalfile.o: $(topdir)/input.h $(topdir)/execute_cmd.h
! evalfile.o: $(topdir)/bashhist.h $(srcdir)/common.h
! evalstring.o: ../config.h $(topdir)/bashansi.h $(topdir)/ansi_stdlib.h
! evalstring.o: $(topdir)/shell.h $(topdir)/bashjmp.h $(topdir)/posixjmp.h
! evalstring.o: $(topdir)/sig.h $(topdir)/command.h $(topdir)/siglist.h
! evalstring.o: $(topdir)/memalloc.h $(topdir)/variables.h $(topdir)/input.h
! evalstring.o: $(topdir)/quit.h $(topdir)/unwind_prot.h
! evalstring.o: $(topdir)/maxpath.h $(topdir)/jobs.h $(topdir)/builtins.h
! evalstring.o: $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h $(topdir)/subst.h
! evalstring.o: $(topdir)/externs.h $(topdir)/jobs.h $(topdir)/builtins.h
! evalstring.o: $(topdir)/flags.h $(topdir)/input.h $(topdir)/execute_cmd.h
! evalstring.o: $(topdir)/bashhist.h $(srcdir)/common.h
! getopt.o: ../config.h $(topdir)/memalloc.h
! getopt.o: $(topdir)/shell.h $(topdir)/bashjmp.h $(topdir)/command.h
! getopt.o: $(topdir)/general.h $(topdir)/error.h $(topdir)/variables.h
! getopt.o: $(topdir)/quit.h $(topdir)/maxpath.h $(topdir)/unwind_prot.h
! getopt.o: $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h $(topdir)/subst.h
! getopt.o: $(topdir)/sig.h $(topdir)/pathnames.h $(topdir)/externs.h
! getopt.o: $(srcdir)/getopt.h
! mkbuiltins.o: ../config.h $(topdir)/bashtypes.h $(topdir)/posixstat.h
! mkbuiltins.o: $(topdir)/filecntl.h
! mkbuiltins.o: $(topdir)/bashansi.h $(topdir)/ansi_stdlib.h
! 
! # def files
  alias.o: $(topdir)/command.h ../config.h $(topdir)/memalloc.h
  alias.o: $(topdir)/error.h $(topdir)/general.h $(topdir)/maxpath.h
***************
*** 218,221 ****
--- 264,268 ----
  eval.o: $(topdir)/shell.h $(topdir)/unwind_prot.h $(topdir)/variables.h
  eval.o: $(topdir)/maxpath.h
+ exec.o: $(topdir)/bashtypes.h
  exec.o: $(topdir)/command.h ../config.h $(topdir)/memalloc.h
  exec.o: $(topdir)/error.h $(topdir)/general.h
***************
*** 224,227 ****
--- 271,275 ----
  exec.o: $(topdir)/shell.h $(topdir)/unwind_prot.h $(topdir)/variables.h
  exec.o: $(srcdir)/common.h $(topdir)/execute_cmd.h $(topdir)/maxpath.h
+ exit.o: $(topdir)/bashtypes.h
  exit.o: $(topdir)/command.h ../config.h $(topdir)/memalloc.h
  exit.o: $(topdir)/error.h $(topdir)/general.h
***************
*** 229,233 ****
  exit.o: $(topdir)/subst.h $(topdir)/externs.h
  exit.o: $(topdir)/shell.h $(topdir)/unwind_prot.h $(topdir)/variables.h
! exit.o: $(topdir)/maxpath.h
  fc.o: $(topdir)/builtins.h $(topdir)/command.h $(srcdir)/bashgetopt.h
  fc.o: $(topdir)/bashhist.h
--- 277,282 ----
  exit.o: $(topdir)/subst.h $(topdir)/externs.h
  exit.o: $(topdir)/shell.h $(topdir)/unwind_prot.h $(topdir)/variables.h
! exit.o: $(topdir)/maxpath.h ./builtext.h
! fc.o: $(topdir)/bashtypes.h $(topdir)/posixstat.h
  fc.o: $(topdir)/builtins.h $(topdir)/command.h $(srcdir)/bashgetopt.h
  fc.o: $(topdir)/bashhist.h
***************
*** 237,240 ****
--- 286,291 ----
  fc.o: $(topdir)/subst.h $(topdir)/externs.h $(topdir)/shell.h
  fc.o: $(topdir)/flags.h $(topdir)/unwind_prot.h $(topdir)/variables.h
+ fc.o: $(topdir)/bashansi.h $(topdir)/ansi_stdlib.h
+ fg_bg.o: $(topdir)/bashtypes.h
  fg_bg.o: $(topdir)/command.h ../config.h $(topdir)/memalloc.h
  fg_bg.o: $(topdir)/error.h $(topdir)/general.h
***************
*** 258,261 ****
--- 309,313 ----
  help.o: $(topdir)/subst.h $(topdir)/externs.h $(topdir)/maxpath.h
  help.o: $(topdir)/shell.h $(topdir)/unwind_prot.h $(topdir)/variables.h
+ history.o: $(topdir)/bashtypes.h
  history.o: $(topdir)/command.h ../config.h $(topdir)/memalloc.h
  history.o: $(topdir)/error.h $(topdir)/general.h
***************
*** 289,293 ****
  pushd.o: $(topdir)/subst.h $(topdir)/externs.h
  pushd.o: $(topdir)/shell.h $(topdir)/unwind_prot.h $(topdir)/variables.h
! pushd.o: $(topdir)/maxpath.h $(srcdir)/common.h
  read.o: $(topdir)/command.h ../config.h $(topdir)/memalloc.h
  read.o: $(topdir)/error.h $(topdir)/general.h
--- 341,345 ----
  pushd.o: $(topdir)/subst.h $(topdir)/externs.h
  pushd.o: $(topdir)/shell.h $(topdir)/unwind_prot.h $(topdir)/variables.h
! pushd.o: $(topdir)/maxpath.h $(srcdir)/common.h ./builtext.h
  read.o: $(topdir)/command.h ../config.h $(topdir)/memalloc.h
  read.o: $(topdir)/error.h $(topdir)/general.h
***************
*** 346,350 ****
  type.o: $(topdir)/quit.h $(srcdir)/common.h $(topdir)/maxpath.h
  type.o: $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h $(topdir)/subst.h
! type.o: $(topdir)/externs.h
  type.o: $(topdir)/shell.h $(topdir)/unwind_prot.h $(topdir)/variables.h 
  ulimit.o: $(topdir)/command.h ../config.h $(topdir)/memalloc.h
--- 398,402 ----
  type.o: $(topdir)/quit.h $(srcdir)/common.h $(topdir)/maxpath.h
  type.o: $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h $(topdir)/subst.h
! type.o: $(topdir)/externs.h $(topdir)/hashcmd.h
  type.o: $(topdir)/shell.h $(topdir)/unwind_prot.h $(topdir)/variables.h 
  ulimit.o: $(topdir)/command.h ../config.h $(topdir)/memalloc.h
***************
*** 369,375 ****
  shopt.o: $(topdir)/shell.h $(topdir)/unwind_prot.h $(topdir)/variables.h
  shopt.o: $(srcdir)/common.h $(srcdir)/bashgetopt.h
- bashgetopt.o: $(topdir)/bashansi.h $(topdir)/ansi_stdlib.h
- mkbuiltins.o: $(topdir)/bashansi.h $(topdir)/ansi_stdlib.h
- fc.o: $(topdir)/bashansi.h $(topdir)/ansi_stdlib.h
  
  #bind.o: $(RL_LIBSRC)chardefs.h $(RL_LIBSRC)readline.h $(RL_LIBSRC)keymaps.h
--- 421,424 ----
diff -Nrc2 bash-2.0/builtins/alias.def bash-2.01/builtins/alias.def
*** bash-2.0/builtins/alias.def	Wed Jun 28 14:54:46 1995
--- bash-2.01/builtins/alias.def	Wed Feb  5 11:41:59 1997
***************
*** 41,44 ****
--- 41,46 ----
  #endif
  
+ #  include "../bashansi.h"
+ 
  #  include <stdio.h>
  #  include "../shell.h"
diff -Nrc2 bash-2.0/builtins/break.def bash-2.01/builtins/break.def
*** bash-2.0/builtins/break.def	Wed Aug  7 15:34:48 1996
--- bash-2.01/builtins/break.def	Mon Mar  3 12:46:46 1997
***************
*** 58,68 ****
    int newbreak;
  
!   if (!check_loop_level ())
      return (EXECUTION_FAILURE);
  
!   newbreak = get_numeric_arg (list);
  
    if (newbreak <= 0)
!     return (EXECUTION_FAILURE);
  
    if (newbreak > loop_level)
--- 58,72 ----
    int newbreak;
  
!   if (check_loop_level () == 0)
      return (EXECUTION_FAILURE);
  
!   newbreak = get_numeric_arg (list, 1);
  
    if (newbreak <= 0)
!     {
!       builtin_error ("loop count must be > 0");
!       breaking = loop_level;
!       return (EXECUTION_FAILURE);
!     }
  
    if (newbreak > loop_level)
***************
*** 89,99 ****
    int newcont;
  
!   if (!check_loop_level ())
      return (EXECUTION_FAILURE);
  
!   newcont = get_numeric_arg (list);
  
    if (newcont <= 0)
!     return (EXECUTION_FAILURE);
  
    if (newcont > loop_level)
--- 93,107 ----
    int newcont;
  
!   if (check_loop_level () == 0)
      return (EXECUTION_FAILURE);
  
!   newcont = get_numeric_arg (list, 1);
  
    if (newcont <= 0)
!     {
!       builtin_error ("loop count must be > 0");
!       breaking = loop_level;
!       return (EXECUTION_FAILURE);
!     }
  
    if (newcont > loop_level)
***************
*** 111,115 ****
  {
  #if defined (BREAK_COMPLAINS)
!   if (!loop_level)
      builtin_error ("only meaningful in a `for', `while', or `until' loop");
  #endif /* BREAK_COMPLAINS */
--- 119,123 ----
  {
  #if defined (BREAK_COMPLAINS)
!   if (loop_level == 0)
      builtin_error ("only meaningful in a `for', `while', or `until' loop");
  #endif /* BREAK_COMPLAINS */
diff -Nrc2 bash-2.0/builtins/cd.def bash-2.01/builtins/cd.def
*** bash-2.0/builtins/cd.def	Thu Dec  5 10:45:30 1996
--- bash-2.01/builtins/cd.def	Fri Apr 11 12:55:47 1997
***************
*** 50,53 ****
--- 50,54 ----
  
  extern int posixly_correct, interactive;
+ extern int array_needs_making;
  extern char *bash_getcwd_errstr;
  
***************
*** 56,60 ****
  static char *cdspell ();
  static int spname (), mindist (), spdist ();
! int cdspelling = 1;
  
  int cdable_vars;
--- 57,63 ----
  static char *cdspell ();
  static int spname (), mindist (), spdist ();
! 
! /* Change this to 1 to get cd spelling correction by default. */
! int cdspelling = 0;
  
  int cdable_vars;
***************
*** 119,124 ****
       int no_symlinks;
  {
!   char *dirname;
!   int old_symlinks;
  
    if (no_symlinks)
--- 122,128 ----
       int no_symlinks;
  {
!   char *dirname, *pwdvar;
!   int old_symlinks, old_anm;
!   SHELL_VAR *tvar;
  
    if (no_symlinks)
***************
*** 133,137 ****
  
    bind_variable ("OLDPWD", get_string_value ("PWD"));
!   bind_variable ("PWD", dirname);
  
    FREE (dirname);
--- 137,156 ----
  
    bind_variable ("OLDPWD", get_string_value ("PWD"));
! 
!   old_anm = array_needs_making;
!   tvar = bind_variable ("PWD", dirname);
!   /* This is an efficiency hack.  If PWD is exported, we will need to
!      remake the exported environment every time we change directories.
!      If there is no other reason to make the exported environment, just
!      update PWD in place and mark the exported environment as no longer
!      needing a remake. */
!   if (old_anm == 0 && array_needs_making && exported_p (tvar))
!     {
!       pwdvar = xmalloc (strlen (dirname) + 5);	/* 5 = "PWD" + '=' + '\0' */
!       strcpy (pwdvar, "PWD=");
!       strcpy (pwdvar + 4, dirname);
!       add_or_supercede_exported_var (pwdvar, 0);
!       array_needs_making = 0;
!     }
  
    FREE (dirname);
***************
*** 548,551 ****
--- 567,573 ----
    (void)closedir(fd);
  
+   /* Don't return `.' */
+   if (best[0] == '.' && best[1] == '\0')
+     dist = 3;
    return dist;
  }
diff -Nrc2 bash-2.0/builtins/command.def bash-2.01/builtins/command.def
*** bash-2.0/builtins/command.def	Mon Oct 21 14:07:05 1996
--- bash-2.01/builtins/command.def	Fri Feb 28 12:59:26 1997
***************
*** 118,128 ****
      {      
        old_path = get_string_value ("PATH");
        if (old_path)
  	old_path = savestring (old_path);
-       else
- 	{
- 	  old_path = xmalloc (1);
- 	  old_path[0] = '\0';
- 	}
        add_unwind_protect ((Function *)restore_path, old_path);
  
--- 118,125 ----
      {      
        old_path = get_string_value ("PATH");
+       /* If old_path is NULL, $PATH is unset.  If so, we want to make sure
+ 	 it's unset after this command completes. */
        if (old_path)
  	old_path = savestring (old_path);
        add_unwind_protect ((Function *)restore_path, old_path);
  
***************
*** 163,168 ****
       char *var;
  {
!   bind_variable ("PATH", var);
!   free (var);
  }
  
--- 160,170 ----
       char *var;
  {
!   if (var)
!     {
!       bind_variable ("PATH", var);
!       free (var);
!     }
!   else
!     unbind_variable ("PATH");
  }
  
diff -Nrc2 bash-2.0/builtins/common.c bash-2.01/builtins/common.c
*** bash-2.0/builtins/common.c	Wed Nov 20 11:55:08 1996
--- bash-2.01/builtins/common.c	Tue Apr  1 12:24:44 1997
***************
*** 24,28 ****
  
  #include <stdio.h>
! #include <sys/types.h>
  #include "../posixstat.h"
  #include <signal.h>
--- 24,28 ----
  
  #include <stdio.h>
! #include "../bashtypes.h"
  #include "../posixstat.h"
  #include <signal.h>
***************
*** 46,52 ****
  #include "../execute_cmd.h"
  #include "../trap.h"
- #include "hashcom.h"
  #include "bashgetopt.h"
  #include "common.h"
  #include <tilde/tilde.h>
  
--- 46,52 ----
  #include "../execute_cmd.h"
  #include "../trap.h"
  #include "bashgetopt.h"
  #include "common.h"
+ #include "builtext.h"
  #include <tilde/tilde.h>
  
***************
*** 60,71 ****
  extern int last_command_exit_value;
  extern int running_trap;
- extern int hashing_enabled;
  extern int variable_context;
  extern int posixly_correct;
  extern char *this_command_name, *shell_name;
  extern COMMAND *global_command;
- extern HASH_TABLE *hashed_filenames;
  extern char *bash_getcwd_errstr;
  
  /* **************************************************************** */
  /*								    */
--- 60,73 ----
  extern int last_command_exit_value;
  extern int running_trap;
  extern int variable_context;
  extern int posixly_correct;
  extern char *this_command_name, *shell_name;
  extern COMMAND *global_command;
  extern char *bash_getcwd_errstr;
  
+ /* Used by some builtins and the mainline code. */
+ Function *last_shell_builtin = (Function *)NULL;
+ Function *this_shell_builtin = (Function *)NULL;
+ 
  /* **************************************************************** */
  /*								    */
***************
*** 318,325 ****
     that wants it.  LIST is the word list that the arg is to come from.
     Accept only the numeric argument; report an error if other arguments
!    follow. */
  int
! get_numeric_arg (list)
       WORD_LIST *list;
  {
    long count = 1;
--- 320,330 ----
     that wants it.  LIST is the word list that the arg is to come from.
     Accept only the numeric argument; report an error if other arguments
!    follow.  If FATAL is true, call throw_to_top_level, which exits the
!    shell; if not, call jump_to_top_level (DISCARD), which aborts the
!    current command. */
  int
! get_numeric_arg (list, fatal)
       WORD_LIST *list;
+      int fatal;
  {
    long count = 1;
***************
*** 333,337 ****
  	{
  	  builtin_error ("bad non-numeric arg `%s'", list->word->word);
! 	  throw_to_top_level ();
  	}
        no_args (list->next);
--- 338,345 ----
  	{
  	  builtin_error ("bad non-numeric arg `%s'", list->word->word);
! 	  if (fatal)
! 	    throw_to_top_level ();
! 	  else
! 	    jump_to_top_level (DISCARD);
  	}
        no_args (list->next);
***************
*** 363,440 ****
  /* **************************************************************** */
  /*								    */
- /*		 	Command name hashing			    */
- /*								    */
- /* **************************************************************** */
- 
- /* Return the full pathname that FILENAME hashes to.  If FILENAME
-    is hashed, but (data->flags & HASH_CHKDOT) is non-zero, check
-    ./FILENAME and return that if it is executable. */
- char *
- find_hashed_filename (filename)
-      char *filename;
- {
-   register BUCKET_CONTENTS *item;
-   char *path, *dotted_filename, *tail;
-   int same;
- 
-   if (hashing_enabled == 0)
-     return ((char *)NULL);
- 
-   item = find_hash_item (filename, hashed_filenames);
- 
-   if (item == NULL)
-     return ((char *)NULL);
- 
-   /* If this filename is hashed, but `.' comes before it in the path,
-      see if ./filename is executable.  If the hashed value is not an
-      absolute pathname, see if ./`hashed-value' exists. */
-   path = pathdata(item)->path;
-   if (pathdata(item)->flags & (HASH_CHKDOT|HASH_RELPATH))
-     {
-       tail = (pathdata(item)->flags & HASH_RELPATH) ? path : filename;
-       dotted_filename = xmalloc (3 + strlen (tail));
-       dotted_filename[0] = '.'; dotted_filename[1] = '/';
-       strcpy (dotted_filename + 2, tail);
- 
-       if (executable_file (dotted_filename))
- 	return (dotted_filename);
- 
-       free (dotted_filename);
- 
- #if 0
-       if (pathdata(item)->flags & HASH_RELPATH)
- 	return ((char *)NULL);
- #endif
- 
-       /* Watch out.  If this file was hashed to "./filename", and
- 	 "./filename" is not executable, then return NULL. */
- 
-       /* Since we already know "./filename" is not executable, what
- 	 we're really interested in is whether or not the `path'
- 	 portion of the hashed filename is equivalent to the current
- 	 directory, but only if it starts with a `.'.  (This catches
- 	 ./. and so on.)  same_file () tests general Unix file
- 	 equivalence -- same device and inode. */
-       if (*path == '.')
- 	{
- 	  same = 0;
- 	  tail = (char *)strrchr (path, '/');
- 
- 	  if (tail)
- 	    {
- 	      *tail = '\0';
- 	      same = same_file (".", path, (struct stat *)NULL, (struct stat *)NULL);
- 	      *tail = '/';
- 	    }
- 
- 	  return same ? (char *)NULL : path;
- 	}
-     }
- 
-   return (path);
- }
- 
- /* **************************************************************** */
- /*								    */
  /*	     Manipulating the current working directory		    */
  /*								    */
--- 371,374 ----
***************
*** 636,640 ****
--- 570,580 ----
  	      continue;
  	    }
+ #if defined (JOB_CONTROL)
+ 	  /* POSIX.2 says that `kill -l signum' prints the signal name without
+ 	     the `SIG' prefix. */
+ 	  printf ("%s\n", (this_shell_builtin == kill_builtin) ? name + 3 : name);
+ #else
  	  printf ("%s\n", name);
+ #endif
  	}
        else
***************
*** 853,856 ****
--- 793,799 ----
  	  break;
  	case '#':				/* comment char */
+ #if 0
+ 	case '~':				/* tilde expansion */
+ #endif
  	  if (s == string)
  	    *r++ = '\\';
diff -Nrc2 bash-2.0/builtins/common.h bash-2.01/builtins/common.h
*** bash-2.0/builtins/common.h	Fri Aug  9 13:58:07 1996
--- bash-2.01/builtins/common.h	Wed May 14 12:56:35 1997
***************
*** 26,29 ****
--- 26,34 ----
  #define ISOPTION(s, c)	(s[0] == '-' && !s[2] && s[1] == c)
  
+ /* Flag values for parse_and_execute () */
+ #define SEVAL_NONINT	0x01
+ #define SEVAL_INTERACT	0x02
+ #define SEVAL_NOHIST	0x04
+ 
  extern void builtin_error __P((const char *, ...));
  extern void builtin_usage ();
***************
*** 70,80 ****
  extern int contains_shell_metas ();
  
- /* Functions from hash.def */
- extern void initialize_filename_hashing ();
- extern void flush_hashed_filenames ();
- extern char *find_hashed_filename ();
- extern void remove_hashed_filename ();
- extern void remember_filename ();
- 
  /* Functions from set.def */
  extern void initialize_shell_options ();
--- 75,78 ----
***************
*** 82,85 ****
--- 80,87 ----
  extern int set_minus_o_option ();
  extern int minus_o_option_value ();
+ extern void reset_shell_options ();
+ 
+ /* Functions from shopt.def */
+ extern void reset_shopt_options ();
  
  /* Functions from type.def */
diff -Nrc2 bash-2.0/builtins/declare.def bash-2.01/builtins/declare.def
*** bash-2.0/builtins/declare.def	Thu Aug  8 12:40:32 1996
--- bash-2.01/builtins/declare.def	Mon Apr 14 16:56:42 1997
***************
*** 269,273 ****
  	  if (offset)	/* declare -f [-rix] foo=bar */
  	    {
! 	      builtin_error ("Can't use `-f' to make functions");
  	      return (EXECUTION_FAILURE);
  	    }
--- 269,274 ----
  	  if (offset)	/* declare -f [-rix] foo=bar */
  	    {
! 	      builtin_error ("cannot use `-f' to make functions");
! 	      free (name);
  	      return (EXECUTION_FAILURE);
  	    }
diff -Nrc2 bash-2.0/builtins/echo.def bash-2.01/builtins/echo.def
*** bash-2.0/builtins/echo.def	Tue May 21 10:57:39 1996
--- bash-2.01/builtins/echo.def	Tue Feb 11 13:00:21 1997
***************
*** 27,30 ****
--- 27,32 ----
  #endif
  
+ #include "../bashansi.h"
+ 
  #include <stdio.h>
  #include "../shell.h"
***************
*** 73,78 ****
       WORD_LIST *list;
  {
!   int display_return, do_v9, i;
!   char *temp;
  
  #if defined (DEFAULT_ECHO_TO_USG)
--- 75,80 ----
       WORD_LIST *list;
  {
!   int display_return, do_v9, i, len;
!   char *temp, *s;
  
  #if defined (DEFAULT_ECHO_TO_USG)
***************
*** 131,141 ****
    while (list)
      {
!       i = 0;
!       temp = do_v9 ? ansicstr (list->word->word, STRLEN (list->word->word), &i)
  		   : list->word->word;
        if (temp)
  	{
! 	  printf ("%s", temp);
  	  fflush (stdout);	/* Fix for bug in SunOS 5.5 printf(3) */
  	}
        if (do_v9 && temp)
--- 133,151 ----
    while (list)
      {
!       i = len = 0;
!       temp = do_v9 ? ansicstr (list->word->word, STRLEN (list->word->word), &i, &len)
  		   : list->word->word;
        if (temp)
  	{
! 	  if (do_v9)
! 	    {
! 	      for (s = temp; len > 0; len--)
! 		putchar (*s++);
! 	    }
! 	  else	    
! 	    printf ("%s", temp);
! #if defined (SunOS5)
  	  fflush (stdout);	/* Fix for bug in SunOS 5.5 printf(3) */
+ #endif
  	}
        if (do_v9 && temp)
diff -Nrc2 bash-2.0/builtins/enable.def bash-2.01/builtins/enable.def
*** bash-2.0/builtins/enable.def	Wed Oct  2 14:47:05 1996
--- bash-2.01/builtins/enable.def	Fri Feb  7 14:05:00 1997
***************
*** 239,243 ****
  
  #if defined (HAVE_DLOPEN) && defined (HAVE_DLSYM)
! #include <dlfcn.h>
  
  static int
--- 239,246 ----
  
  #if defined (HAVE_DLOPEN) && defined (HAVE_DLSYM)
! 
! #if defined (HAVE_DLFCN_H)
! #  include <dlfcn.h>
! #endif
  
  static int
***************
*** 360,364 ****
--- 363,371 ----
  
    /* XXX - funky pointer arithmetic - XXX */
+ #ifdef __STDC__
+   ind = b - shell_builtins;
+ #else
    ind = ((int)b - (int)shell_builtins) / sizeof (struct builtin);
+ #endif
    size = num_shell_builtins * sizeof (struct builtin);
    new_shell_builtins = (struct builtin *)xmalloc (size);
diff -Nrc2 bash-2.0/builtins/eval.def bash-2.01/builtins/eval.def
*** bash-2.0/builtins/eval.def	Tue May  7 12:52:17 1996
--- bash-2.01/builtins/eval.def	Wed May 14 13:15:34 1997
***************
*** 35,40 ****
  #include "../shell.h"
  #include "bashgetopt.h"
! 
! extern int parse_and_execute ();
  
  /* Parse the string that these words make, and execute the command found. */
--- 35,39 ----
  #include "../shell.h"
  #include "bashgetopt.h"
! #include "common.h"
  
  /* Parse the string that these words make, and execute the command found. */
***************
*** 47,50 ****
  
    /* Note that parse_and_execute () frees the string it is passed. */
!   return (list ? parse_and_execute (string_list (list), "eval", -1) : EXECUTION_SUCCESS);
  }
--- 46,49 ----
  
    /* Note that parse_and_execute () frees the string it is passed. */
!   return (list ? parse_and_execute (string_list (list), "eval", SEVAL_NOHIST) : EXECUTION_SUCCESS);
  }
diff -Nrc2 bash-2.0/builtins/evalfile.c bash-2.01/builtins/evalfile.c
*** bash-2.0/builtins/evalfile.c	Thu Aug 15 12:30:11 1996
--- bash-2.01/builtins/evalfile.c	Wed May 14 13:41:47 1997
***************
*** 23,27 ****
  #endif
  
! #include <sys/types.h>
  #include "../posixstat.h"
  #include "../filecntl.h"
--- 23,27 ----
  #endif
  
! #include "../bashtypes.h"
  #include "../posixstat.h"
  #include "../filecntl.h"
***************
*** 56,59 ****
--- 56,60 ----
  #define FEVAL_NONINT		0x008
  #define FEVAL_LONGJMP		0x010
+ #define FEVAL_HISTORY		0x020
  
  extern int interactive, interactive_shell, posixly_correct;
***************
*** 72,76 ****
    volatile int old_interactive;
    procenv_t old_return_catch;
!   int return_val, fd, result;
    char *string;
    struct stat finfo;
--- 73,77 ----
    volatile int old_interactive;
    procenv_t old_return_catch;
!   int return_val, fd, result, pflags;
    char *string;
    struct stat finfo;
***************
*** 152,155 ****
--- 153,159 ----
    sourcelevel++;
  
+   /* set the flags to be passed to parse_and_execute */
+   pflags = (flags & FEVAL_HISTORY) ? 0 : SEVAL_NOHIST;
+ 
    if (flags & FEVAL_BUILTIN)
      result = EXECUTION_SUCCESS;
***************
*** 165,169 ****
      }
    else
!     result = parse_and_execute (string, filename, -1);
  
    if (flags & FEVAL_UNWINDPROT)
--- 169,173 ----
      }
    else
!     result = parse_and_execute (string, filename, pflags);
  
    if (flags & FEVAL_UNWINDPROT)
***************
*** 197,200 ****
--- 201,218 ----
    return result;
  }
+ 
+ #if defined (HISTORY)
+ int
+ fc_execute_file (filename)
+      char *filename;
+ {
+   int flags;
+ 
+   /* We want these commands to show up in the history list if
+      remember_on_history is set. */
+   flags = FEVAL_ENOENTOK|FEVAL_HISTORY;
+   return (_evalfile (filename, flags));
+ }
+ #endif /* HISTORY */
  
  int
diff -Nrc2 bash-2.0/builtins/evalstring.c bash-2.01/builtins/evalstring.c
*** bash-2.0/builtins/evalstring.c	Thu Aug 15 16:44:46 1996
--- bash-2.01/builtins/evalstring.c	Wed May 14 13:01:31 1997
***************
*** 41,44 ****
--- 41,46 ----
  #include "common.h"
  
+ extern void run_trap_cleanup ();
+ 
  extern int interactive, interactive_shell;
  extern int indirection_level, startup_state, subshell_environment;
***************
*** 63,74 ****
  
  /* Parse and execute the commands in STRING.  Returns whatever
!    execute_command () returns.  This frees STRING.  INTERACT is
!    the new value for `interactive' while the commands are being
!    executed.  A value of -1 means don't change it. */
  int
! parse_and_execute (string, from_file, interact)
       char *string;
       char *from_file;
!      int interact;
  {
    int code;
--- 65,81 ----
  
  /* Parse and execute the commands in STRING.  Returns whatever
!    execute_command () returns.  This frees STRING.  FLAGS is a
!    flags word; look in common.h for the possible values.  Actions
!    are:
!    	(flags & SEVAL_NONINT) -> interactive = 0;
!    	(flags & SEVAL_INTERACT) -> interactive = 1;
!    	(flags & SEVAL_NOHIST) -> call bash_history_disable ()
! */
! 
  int
! parse_and_execute (string, from_file, flags)
       char *string;
       char *from_file;
!      int flags;
  {
    int code;
***************
*** 84,98 ****
    unwind_protect_int (indirection_level);
    unwind_protect_int (line_number);
!   if (interact != -1 && interactive != interact)
      unwind_protect_int (interactive);
  
  #if defined (HISTORY)
    if (interactive_shell)
      {
-       unwind_protect_int (remember_on_history);
- #  if defined (BANG_HISTORY)
        unwind_protect_int (history_expansion_inhibited);
- #  endif /* BANG_HISTORY */
      }
  #endif /* HISTORY */
  
--- 91,105 ----
    unwind_protect_int (indirection_level);
    unwind_protect_int (line_number);
!   if (flags & (SEVAL_NONINT|SEVAL_INTERACT))
      unwind_protect_int (interactive);
  
  #if defined (HISTORY)
+   unwind_protect_int (remember_on_history);	/* can be used in scripts */
+ #  if defined (BANG_HISTORY)
    if (interactive_shell)
      {
        unwind_protect_int (history_expansion_inhibited);
      }
+ #  endif /* BANG_HISTORY */
  #endif /* HISTORY */
  
***************
*** 105,113 ****
    push_stream (1);	/* reset the line number */
    indirection_level++;
!   if (interact != -1)
!     interactive = interact;
  
  #if defined (HISTORY)
!   bash_history_disable ();
  #endif /* HISTORY */
  
--- 112,121 ----
    push_stream (1);	/* reset the line number */
    indirection_level++;
!   if (flags & (SEVAL_NONINT|SEVAL_INTERACT))
!     interactive = (flags & SEVAL_NONINT) ? 0 : 1;
  
  #if defined (HISTORY)
!   if (flags & SEVAL_NOHIST)
!     bash_history_disable ();
  #endif /* HISTORY */
  
***************
*** 178,181 ****
--- 186,190 ----
  	      begin_unwind_frame ("pe_dispose");
  	      add_unwind_protect (dispose_fd_bitmap, bitmap);
+ 	      add_unwind_protect (dispose_command, command);	/* XXX */
  
  	      global_command = (COMMAND *)NULL;
diff -Nrc2 bash-2.0/builtins/exec.def bash-2.01/builtins/exec.def
*** bash-2.0/builtins/exec.def	Thu Aug 22 14:21:42 1996
--- bash-2.01/builtins/exec.def	Mon Apr 14 16:40:00 1997
***************
*** 37,41 ****
  #include <config.h>
  
! #include <sys/types.h>
  #include "../posixstat.h"
  #include <signal.h>
--- 37,41 ----
  #include <config.h>
  
! #include "../bashtypes.h"
  #include "../posixstat.h"
  #include <signal.h>
***************
*** 66,70 ****
  #endif /* !errno */
  
! extern int interactive, subshell_environment;
  extern REDIRECT *redirection_undo_list;
  
--- 66,70 ----
  #endif /* !errno */
  
! extern int interactive, interactive_shell, subshell_environment;
  extern REDIRECT *redirection_undo_list;
  
***************
*** 91,95 ****
    int exit_value = EXECUTION_FAILURE;
    int cleanenv, login, opt;
!   char *argv0, *command, **args, **env, *newname;
  
    cleanenv = login = 0;
--- 91,95 ----
    int exit_value = EXECUTION_FAILURE;
    int cleanenv, login, opt;
!   char *argv0, *command, **args, **env, *newname, *com2;
  
    cleanenv = login = 0;
***************
*** 144,148 ****
      }
  
!   command = full_pathname (command);
  
    if (argv0)
--- 144,154 ----
      }
  
!   com2 = full_pathname (command);
!   if (com2)
!     {
!       if (command != args[0])
! 	free (command);
!       command = com2;
!     }
  
    if (argv0)
***************
*** 173,177 ****
  
  #if defined (HISTORY)
!   maybe_save_shell_history ();
  #endif /* HISTORY */
  
--- 179,184 ----
  
  #if defined (HISTORY)
!   if (interactive_shell && subshell_environment == 0)
!     maybe_save_shell_history ();
  #endif /* HISTORY */
  
***************
*** 201,204 ****
--- 208,214 ----
    if (subshell_environment || (interactive == 0 && no_exit_on_failed_exec == 0))
      exit_shell (exit_value);
+ 
+   if (args)
+     free_array (args);
  
    initialize_traps ();
diff -Nrc2 bash-2.0/builtins/exit.def bash-2.01/builtins/exit.def
*** bash-2.0/builtins/exit.def	Fri Sep  6 11:15:21 1996
--- bash-2.01/builtins/exit.def	Thu Mar  6 10:51:44 1997
***************
*** 31,35 ****
  #include <config.h>
  
! #include <sys/types.h>
  #include <stdio.h>
  
--- 31,35 ----
  #include <config.h>
  
! #include "../bashtypes.h"
  #include <stdio.h>
  
***************
*** 46,49 ****
--- 46,51 ----
  extern int interactive, login_shell;
  extern int last_command_exit_value;
+ extern Function *this_shell_builtin;
+ extern Function *last_shell_builtin;
  
  static int exit_or_logout ();
***************
*** 83,90 ****
  }
  
- /* Clean up work for exiting or logging out. */
- Function *last_shell_builtin = (Function *)NULL;
- Function *this_shell_builtin = (Function *)NULL;
- 
  static int
  exit_or_logout (list)
--- 85,88 ----
***************
*** 122,126 ****
    /* Get return value if present.  This means that you can type
       `logout 5' to a shell, and it returns 5. */
!   exit_value = list ? get_numeric_arg (list) : last_command_exit_value;
  
    /* Run our `~/.bash_logout' file if it exists, and this is a login shell. */
--- 120,124 ----
    /* Get return value if present.  This means that you can type
       `logout 5' to a shell, and it returns 5. */
!   exit_value = list ? get_numeric_arg (list, 1) : last_command_exit_value;
  
    /* Run our `~/.bash_logout' file if it exists, and this is a login shell. */
diff -Nrc2 bash-2.0/builtins/fc.def bash-2.01/builtins/fc.def
*** bash-2.0/builtins/fc.def	Thu Nov  7 11:10:19 1996
--- bash-2.01/builtins/fc.def	Wed May 14 14:24:09 1997
***************
*** 51,56 ****
  #if defined (HISTORY)
  #include <sys/param.h>
! #include "bashtypes.h"
! #include "posixstat.h"
  #include <sys/file.h>
  
--- 51,56 ----
  #if defined (HISTORY)
  #include <sys/param.h>
! #include "../bashtypes.h"
! #include "../posixstat.h"
  #include <sys/file.h>
  
***************
*** 78,84 ****
--- 78,88 ----
  
  extern int echo_input_at_read;
+ extern int current_command_line_count;
+ extern int literal_history;
  
  extern int unlink ();
  
+ extern int fc_execute_file ();
+ 
  /* **************************************************************** */
  /*								    */
***************
*** 253,257 ****
        fprintf (stderr, "%s\n", command);
        fc_replhist (command);	/* replace `fc -s' with command */
!       return (parse_and_execute (command, "fc", -1));
      }
  
--- 257,261 ----
        fprintf (stderr, "%s\n", command);
        fc_replhist (command);	/* replace `fc -s' with command */
!       return (parse_and_execute (command, "fc", SEVAL_NOHIST));
      }
  
***************
*** 267,273 ****
       the time we get to this point.  This just skips over that command
       and makes the last command that this deals with be the last command
!      the user entered before the fc. */
  
!   last_hist = i - 2;
  
    if (list)
--- 271,279 ----
       the time we get to this point.  This just skips over that command
       and makes the last command that this deals with be the last command
!      the user entered before the fc.  We need to check whether the
!      line was actually added (HISTIGNORE may have caused it to not be),
!      so we check hist_last_line_added. */
  
!   last_hist = i - 1 - hist_last_line_added;
  
    if (list)
***************
*** 318,321 ****
--- 324,328 ----
      {
        numbering = 0;
+       /* XXX - this is raceable */
        sprintf (fn, "/tmp/bash%d", (int)time ((time_t *) 0) + (int)getpid ());
  
***************
*** 355,359 ****
        sprintf (command, "%s %s", FC_EDIT_COMMAND, fn);
      }
!   retval = parse_and_execute (command, "fc", -1);
    if (retval != EXECUTION_SUCCESS)
      {
--- 362,366 ----
        sprintf (command, "%s %s", FC_EDIT_COMMAND, fn);
      }
!   retval = parse_and_execute (command, "fc", SEVAL_NOHIST);
    if (retval != EXECUTION_SUCCESS)
      {
***************
*** 376,383 ****
    first = 1;
  
    /* First, write the commands to the history file.  This will not happen
       when we call parse_and_execute, since parse_and_execute disables
       the command line history while it executes. */
!      
    while ((line = fc_readline (stream)) != NULL)
      {
--- 383,398 ----
    first = 1;
  
+ #if 1
+   /* Make sure parse_and_execute doesn't turn this off, even though a
+      call to parse_and_execute farther up the function call stack (e.g.,
+      if this is called by vi_edit_and_execute_command) may have already
+      called bash_history_disable. */
+   remember_on_history = 1;
+ #else
    /* First, write the commands to the history file.  This will not happen
       when we call parse_and_execute, since parse_and_execute disables
       the command line history while it executes. */
! 
!   opt = current_command_line_count;
    while ((line = fc_readline (stream)) != NULL)
      {
***************
*** 391,404 ****
  	{
  	  first = 0;
  	  fc_replhist (line);
  	}
        else
! 	fc_addhist (line);
  
        free (line);
      }
    fclose (stream);
  
!   /* Turn on the `v' flag while maybe_execute_file runs so the commands
       will be echoed as they are read by the parser. */
    begin_unwind_frame ("fc builtin");
--- 406,432 ----
  	{
  	  first = 0;
+ 	  /* If we retrieved only one command from the history file, but we
+ 	     read multiple lines from the edited file, and literal_history
+ 	     has been set by `shopt', we assume that it was a compound
+ 	     command stored with embedded newlines.  In this case, we want
+ 	     the history code to store it as one command again. */
+ 	  if (literal_history && histbeg == histend)
+ 	    current_command_line_count = 1;
  	  fc_replhist (line);
  	}
        else
! 	{
! 	  if (literal_history && histbeg == histend)
! 	    current_command_line_count++;
! 	  fc_addhist (line);
! 	}
  
        free (line);
      }
    fclose (stream);
+   current_command_line_count = opt;
+ #endif
  
!   /* Turn on the `v' flag while fc_execute_file runs so the commands
       will be echoed as they are read by the parser. */
    begin_unwind_frame ("fc builtin");
***************
*** 407,411 ****
    echo_input_at_read = 1;
      
!   retval = maybe_execute_file (fn, 0);
  
    run_unwind_frame ("fc builtin");
--- 435,439 ----
    echo_input_at_read = 1;
      
!   retval = fc_execute_file (fn);
  
    run_unwind_frame ("fc builtin");
***************
*** 448,453 ****
       the time we get to this point.  This just skips over that command
       and makes the last command that this deals with be the last command
!      the user entered before the fc. */
!   i -= 2;
  
    /* No specification defaults to most recent command. */
--- 476,483 ----
       the time we get to this point.  This just skips over that command
       and makes the last command that this deals with be the last command
!      the user entered before the fc.  We need to check whether the
!      line was actually added (HISTIGNORE may have caused it to not be),
!      so we check hist_last_line_added. */
!   i -= 1 + hist_last_line_added;
  
    /* No specification defaults to most recent command. */
diff -Nrc2 bash-2.0/builtins/fg_bg.def bash-2.01/builtins/fg_bg.def
*** bash-2.0/builtins/fg_bg.def	Wed Sep 25 10:50:36 1996
--- bash-2.01/builtins/fg_bg.def	Mon Feb 17 14:34:05 1997
***************
*** 33,37 ****
  #include <config.h>
  
! #include <sys/types.h>
  #include <signal.h>
  
--- 33,37 ----
  #include <config.h>
  
! #include "../bashtypes.h"
  #include <signal.h>
  
diff -Nrc2 bash-2.0/builtins/getopt.c bash-2.01/builtins/getopt.c
*** bash-2.0/builtins/getopt.c	Tue Nov 12 16:48:18 1996
--- bash-2.01/builtins/getopt.c	Thu Mar  6 15:54:53 1997
***************
*** 116,120 ****
    sh_optarg = 0;
  
!   if (sh_optind > argc || sh_optind < 0)
      {
        sh_optind = argc;
--- 116,120 ----
    sh_optarg = 0;
  
!   if (sh_optind >= argc || sh_optind < 0)	/* XXX was sh_optind > argc */
      {
        sh_optind = argc;
***************
*** 145,149 ****
      {
        /* If we have done all the ARGV-elements, stop the scan. */
!       if (sh_optind == argc)
  	return EOF;
  
--- 145,149 ----
      {
        /* If we have done all the ARGV-elements, stop the scan. */
!       if (sh_optind >= argc)
  	return EOF;
  
diff -Nrc2 bash-2.0/builtins/getopt.h bash-2.01/builtins/getopt.h
*** bash-2.0/builtins/getopt.h	Tue Jul  9 13:10:08 1996
--- bash-2.01/builtins/getopt.h	Mon Jan 13 16:20:38 1997
***************
*** 18,23 ****
  /* XXX THIS HAS BEEN MODIFIED FOR INCORPORATION INTO BASH XXX */
  
! #ifndef _GETOPT_H
! #define _GETOPT_H 1
  
  /* For communication from `getopt' to the caller.
--- 18,23 ----
  /* XXX THIS HAS BEEN MODIFIED FOR INCORPORATION INTO BASH XXX */
  
! #ifndef _SH_GETOPT_H
! #define _SH_GETOPT_H 1
  
  /* For communication from `getopt' to the caller.
***************
*** 58,60 ****
  extern void sh_getopt_restore_state ();
  
! #endif /* _GETOPT_H */
--- 58,60 ----
  extern void sh_getopt_restore_state ();
  
! #endif /* _SH_GETOPT_H */
diff -Nrc2 bash-2.0/builtins/getopts.def bash-2.01/builtins/getopts.def
*** bash-2.0/builtins/getopts.def	Thu Aug  8 12:41:04 1996
--- bash-2.01/builtins/getopts.def	Fri Feb 28 15:54:28 1997
***************
*** 293,297 ****
  
    if (list == 0)
!     return EXECUTION_FAILURE;
  
    reset_internal_getopt ();
--- 293,300 ----
  
    if (list == 0)
!     {
!       builtin_usage ();
!       return EX_USAGE;
!     }
  
    reset_internal_getopt ();
diff -Nrc2 bash-2.0/builtins/hash.def bash-2.01/builtins/hash.def
*** bash-2.0/builtins/hash.def	Thu Aug 22 11:23:57 1996
--- bash-2.01/builtins/hash.def	Thu May 29 09:51:24 1997
***************
*** 34,40 ****
  #include <config.h>
  
- #include <sys/types.h>
- #include "../posixstat.h"
- 
  #include <stdio.h>
  
--- 34,37 ----
***************
*** 47,53 ****
  #include "../shell.h"
  #include "../builtins.h"
- #include "../flags.h"
  #include "../execute_cmd.h"
! #include "hashcom.h"
  #include "common.h"
  #include "bashgetopt.h"
--- 44,50 ----
  #include "../shell.h"
  #include "../builtins.h"
  #include "../execute_cmd.h"
! #include "../flags.h"
! #include "../hashcmd.h"
  #include "common.h"
  #include "bashgetopt.h"
***************
*** 59,110 ****
  static int print_hashed_commands ();
  
- static int hashing_initialized = 0;
- 
- HASH_TABLE *hashed_filenames;
- 
- void
- initialize_filename_hashing ()
- {
-   if (hashing_initialized == 0)
-     {
-       hashed_filenames = make_hash_table (FILENAME_HASH_BUCKETS);
-       hashing_initialized = 1;
-     }
- }
- 
- static void
- free_filename_data (data)
-      char *data;
- {
-   free (((PATH_DATA *)data)->path);
-   free (data);
- }
- 
- void
- flush_hashed_filenames ()
- {
-   flush_hash_table (hashed_filenames, free_filename_data);
- }
- 
- /* Remove FILENAME from the table of hashed commands. */
- void
- remove_hashed_filename (filename)
-      char *filename;
- {
-   register BUCKET_CONTENTS *item;
- 
-   if (hashing_enabled == 0)
-     return;
- 
-   item = remove_hash_item (filename, hashed_filenames);
-   if (item)
-     {
-       if (item->data)
- 	free_filename_data (item->data);
-       free (item->key);
-       free (item);
-     }
- }
- 
  /* Print statistics on the current state of hashed commands.  If LIST is
     not empty, then rehash (or hash in the first place) the specified
--- 56,59 ----
***************
*** 162,215 ****
        if (pathname)
  	remember_filename (word, pathname, 0, 0);
!       else
! 	{
! 	  if (absolute_program (word))
! 	    {
! 	      list = list->next;
! 	      continue;
! 	    }
! 
! 	  if (add_hashed_command (word))
! 	    opt = EXECUTION_FAILURE;
! 	}
      }
  
    fflush (stdout);
- 
    return (opt);
  }
  
- /* Place FILENAME (key) and FULL_PATHNAME (data->path) into the
-    hash table.  CHECK_DOT if non-null is for future calls to
-    find_hashed_filename (); it means that this file was found
-    in a directory in $PATH that is not an absolute pathname.
-    FOUND is the initial value for times_found. */
- void
- remember_filename (filename, full_pathname, check_dot, found)
-      char *filename, *full_pathname;
-      int check_dot, found;
- {
-   register BUCKET_CONTENTS *item;
- 
-   if (hashing_enabled == 0)
-     return;
- 
-   item = add_hash_item (filename, hashed_filenames);
-   if (item->data)
-     free (pathdata(item)->path);
-   else
-     {
-       item->key = savestring (filename);
-       item->data = xmalloc (sizeof (PATH_DATA));
-     }
-   pathdata(item)->path = savestring (full_pathname);
-   pathdata(item)->flags = 0;
-   if (check_dot)
-     pathdata(item)->flags |= HASH_CHKDOT;
-   if (*full_pathname != '/')
-     pathdata(item)->flags |= HASH_RELPATH;
-   item->times_found = found;
- }
- 
  static int
  add_hashed_command (word, quiet)
--- 111,124 ----
        if (pathname)
  	remember_filename (word, pathname, 0, 0);
!       else if (absolute_program (word))
! 	continue;
!       else if (add_hashed_command (word, 0))
! 	opt = EXECUTION_FAILURE;
      }
  
    fflush (stdout);
    return (opt);
  }
  
  static int
  add_hashed_command (word, quiet)
***************
*** 244,247 ****
--- 153,159 ----
    BUCKET_CONTENTS *item_list;
    int bucket, any_printed;
+ 
+   if (hashed_filenames == 0)
+     return (0);
  
    for (bucket = any_printed = 0; bucket < hashed_filenames->nbuckets; bucket++)
diff -Nrc2 bash-2.0/builtins/hashcom.h bash-2.01/builtins/hashcom.h
*** bash-2.0/builtins/hashcom.h	Fri May  5 16:57:21 1995
--- bash-2.01/builtins/hashcom.h	Wed Dec 31 19:00:00 1969
***************
*** 1,35 ****
- /* hashcom.h - Common defines for hashing filenames. */
- 
- /* Copyright (C) 1993 Free Software Foundation, Inc.
- 
-    This file is part of GNU Bash, the Bourne Again SHell.
- 
-    Bash is free software; you can redistribute it and/or modify it under
-    the terms of the GNU General Public License as published by the Free
-    Software Foundation; either version 2, or (at your option) any later
-    version.
- 
-    Bash is distributed in the hope that it will be useful, but WITHOUT ANY
-    WARRANTY; without even the implied warranty of MERCHANTABILITY or
-    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-    for more details.
- 
-    You should have received a copy of the GNU General Public License along
-    with Bash; see the file COPYING.  If not, write to the Free Software
-    Foundation, 675 Mass Ave, Cambridge, MA 02139, USA. */
- 
- #include "../hashlib.h"
- 
- #define FILENAME_HASH_BUCKETS 631
- 
- extern HASH_TABLE *hashed_filenames;
- 
- typedef struct {
-   char *path;		/* The full pathname of the file. */
-   int flags;
- } PATH_DATA;
- 
- #define HASH_RELPATH	0x01	/* this filename is a relative pathname. */
- #define HASH_CHKDOT	0x02	/* check `.' since it was earlier in $PATH */
- 
- #define pathdata(x) ((PATH_DATA *)(x)->data)
--- 0 ----
diff -Nrc2 bash-2.0/builtins/help.def bash-2.01/builtins/help.def
*** bash-2.0/builtins/help.def	Tue May  7 13:25:37 1996
--- bash-2.01/builtins/help.def	Wed Feb  5 12:18:38 1997
***************
*** 47,51 ****
  #include <glob/glob.h>
  
! static void show_builtin_command_help ();
  
  /* Print out a list of the known functions in the shell, and what they do.
--- 47,54 ----
  #include <glob/glob.h>
  
! extern void builtin_error ();
! extern void builtin_usage ();
! 
! static  void show_builtin_command_help ();
  
  /* Print out a list of the known functions in the shell, and what they do.
***************
*** 60,70 ****
    int plen, match_found;
  
-   if (list == 0)
-     {
-       show_shell_version (0);
-       show_builtin_command_help ();
-       return (EXECUTION_SUCCESS);
-     }
- 
    /* Placeholder for future options. */
    reset_internal_getopt ();
--- 63,66 ----
***************
*** 79,82 ****
--- 75,85 ----
      }
    list = loptend;
+ 
+   if (list == 0)
+     {
+       show_shell_version (0);
+       show_builtin_command_help ();
+       return (EXECUTION_SUCCESS);
+     }
  
    /* We should consider making `help bash' do something. */
diff -Nrc2 bash-2.0/builtins/history.def bash-2.01/builtins/history.def
*** bash-2.0/builtins/history.def	Mon Mar  4 15:36:37 1996
--- bash-2.01/builtins/history.def	Mon Mar  3 12:47:07 1997
***************
*** 46,50 ****
  
  #if defined (HISTORY)
! #include <sys/types.h>
  #include <sys/file.h>
  #include "../posixstat.h"
--- 46,50 ----
  
  #if defined (HISTORY)
! #include "../bashtypes.h"
  #include <sys/file.h>
  #include "../posixstat.h"
***************
*** 194,198 ****
      {
        limited = 1;
!       limit = get_numeric_arg (list);
      }
    else
--- 194,198 ----
      {
        limited = 1;
!       limit = get_numeric_arg (list, 0);
      }
    else
***************
*** 260,264 ****
    char *s;
  
!   if (delete_last_history () == 0)
      return;
    s = string_list (list);
--- 260,264 ----
    char *s;
  
!   if (hist_last_line_added && delete_last_history () == 0)
      return;
    s = string_list (list);
***************
*** 275,279 ****
    int r, result;
  
!   if (delete_last_history () == 0)
      return EXECUTION_FAILURE;
    result = EXECUTION_SUCCESS;
--- 275,279 ----
    int r, result;
  
!   if (hist_last_line_added && delete_last_history () == 0)
      return EXECUTION_FAILURE;
    result = EXECUTION_SUCCESS;
diff -Nrc2 bash-2.0/builtins/jobs.def bash-2.01/builtins/jobs.def
*** bash-2.0/builtins/jobs.def	Wed May  8 19:20:16 1996
--- bash-2.01/builtins/jobs.def	Thu May  8 15:10:02 1997
***************
*** 238,249 ****
    retval = EXECUTION_SUCCESS;
  
    do
      {
        BLOCK_CHILD (set, oset);
!       job = get_job_spec (list);
  
        if (job == NO_JOB || jobs == 0 || jobs[job] == 0)
  	{
! 	  builtin_error ("no such job %s", list->word->word);
  	  retval = EXECUTION_FAILURE;
  	}
--- 238,263 ----
    retval = EXECUTION_SUCCESS;
  
+ #if 0
+   /* For the future `disown -a' */
+   if (list == 0)
+     {
+       if (nohup_only)
+ 	nohup_all_jobs ();
+       else
+ 	delete_all_jobs ();
+       return (EXECUTION_SUCCESS);
+     }
+ #endif
+ 
    do
      {
        BLOCK_CHILD (set, oset);
!       job = (list && all_digits(list->word->word))
! 		? get_job_by_pid (atoi(list->word->word), 0)
! 		: get_job_spec (list);
  
        if (job == NO_JOB || jobs == 0 || jobs[job] == 0)
  	{
! 	  builtin_error ("%s: no such job", list ? list->word->word : "current");
  	  retval = EXECUTION_FAILURE;
  	}
***************
*** 258,261 ****
--- 272,276 ----
      }
    while (list);
+ 
    return (retval);
  }
diff -Nrc2 bash-2.0/builtins/kill.def bash-2.01/builtins/kill.def
*** bash-2.0/builtins/kill.def	Wed Aug 28 15:54:18 1996
--- bash-2.01/builtins/kill.def	Mon Feb 24 16:08:33 1997
***************
*** 57,60 ****
--- 57,61 ----
  #if defined (JOB_CONTROL)
  extern int interactive;
+ extern int job_control;
  extern int posixly_correct;
  
***************
*** 167,171 ****
  	  CONTINUE_OR_FAIL;
  	}
!       else if (interactive)
  	/* Posix.2 says you can kill without job control active (4.32.4) */
  	{			/* Must be a job spec.  Check it out. */
--- 168,172 ----
  	  CONTINUE_OR_FAIL;
  	}
!       else if (interactive || job_control)
  	/* Posix.2 says you can kill without job control active (4.32.4) */
  	{			/* Must be a job spec.  Check it out. */
diff -Nrc2 bash-2.0/builtins/let.def bash-2.01/builtins/let.def
*** bash-2.0/builtins/let.def	Thu Aug  8 12:15:22 1996
--- bash-2.01/builtins/let.def	Tue Apr 15 14:30:59 1997
***************
*** 76,79 ****
--- 76,80 ----
  {
    long ret;
+   int expok;
  
    if (list == 0)
***************
*** 84,92 ****
  
    for (; list; list = list->next)
!     ret = evalexp (list->word->word);
  
    return ((ret == 0L) ? EXECUTION_FAILURE : EXECUTION_SUCCESS);
  }
  
  int
  exp_builtin (list)
--- 85,98 ----
  
    for (; list; list = list->next)
!     {
!       ret = evalexp (list->word->word, &expok);
!       if (expok == 0)
! 	return (EXECUTION_FAILURE);
!     }
  
    return ((ret == 0L) ? EXECUTION_FAILURE : EXECUTION_SUCCESS);
  }
  
+ #ifdef INCLUDE_UNUSED
  int
  exp_builtin (list)
***************
*** 94,98 ****
  {
    char *exp;
!   int ret;
  
    if (list == 0)
--- 100,104 ----
  {
    char *exp;
!   int ret, expok;
  
    if (list == 0)
***************
*** 103,108 ****
  
    exp = string_list (list);
!   ret = evalexp (exp);
!   free (exp);
!   return ((ret == 0L) ? EXECUTION_FAILURE : EXECUTION_SUCCESS);
  }
--- 109,115 ----
  
    exp = string_list (list);
!   ret = evalexp (exp, &expok);
!   (void)free (exp);
!   return (((ret == 0L) || (expok == 0)) ? EXECUTION_FAILURE : EXECUTION_SUCCESS);
  }
+ #endif
diff -Nrc2 bash-2.0/builtins/mkbuiltins.c bash-2.01/builtins/mkbuiltins.c
*** bash-2.0/builtins/mkbuiltins.c	Tue Sep 24 14:42:32 1996
--- bash-2.01/builtins/mkbuiltins.c	Mon Feb 17 14:57:12 1997
***************
*** 26,35 ****
  #endif
  
! #include "../bashansi.h"
! #include "../config.h"
! #include <stdio.h>
! #include <sys/types.h>
  #include <sys/file.h>
! #include <sys/stat.h>
  #include "../filecntl.h"
  
--- 26,32 ----
  #endif
  
! #include "../bashtypes.h"
  #include <sys/file.h>
! #include "../posixstat.h"
  #include "../filecntl.h"
  
***************
*** 38,46 ****
  #endif /* HAVE_UNISTD_H */
  
! #if defined (HAVE_STRING_H)
! #  include <string.h>
! #else /* !HAVE_STRING_H */
! #  include <strings.h>
! #endif /* !HAVE_STRING_H */
  
  #define DOCFILE "builtins.texi"
--- 35,40 ----
  #endif /* HAVE_UNISTD_H */
  
! #include "../bashansi.h"
! #include <stdio.h>
  
  #define DOCFILE "builtins.texi"
***************
*** 352,358 ****
  
  #if defined (HAVE_BCOPY)
!   bcopy (&element, &(array->array[array->sindex]), array->width);
    array->sindex++;
!   bzero (&(array->array[array->sindex]), array->width);
  #else
    array->array[array->sindex++] = element;
--- 346,352 ----
  
  #if defined (HAVE_BCOPY)
!   bcopy (&element, (char *) &(array->array[array->sindex]), array->width);
    array->sindex++;
!   bzero ((char *) &(array->array[array->sindex]), array->width);
  #else
    array->array[array->sindex++] = element;
diff -Nrc2 bash-2.0/builtins/psize.c bash-2.01/builtins/psize.c
*** bash-2.0/builtins/psize.c	Mon Mar 27 14:36:59 1995
--- bash-2.01/builtins/psize.c	Mon Feb 17 14:35:30 1997
***************
*** 29,33 ****
  
  #include <stdio.h>
! #include <sys/types.h>
  #include <signal.h>
  #include <errno.h>
--- 29,33 ----
  
  #include <stdio.h>
! #include "../bashtypes.h"
  #include <signal.h>
  #include <errno.h>
***************
*** 48,51 ****
--- 48,52 ----
  }
  
+ int
  main (argc, argv)
       int argc;
***************
*** 67,69 ****
--- 68,71 ----
        nw += n;
      }
+   return (0);
  }
diff -Nrc2 bash-2.0/builtins/pushd.def bash-2.01/builtins/pushd.def
*** bash-2.0/builtins/pushd.def	Wed Aug 28 16:06:44 1996
--- bash-2.01/builtins/pushd.def	Tue Apr 15 11:28:10 1997
***************
*** 31,38 ****
  
  +N	Rotates the stack so that the Nth directory (counting
! 	from the left of the list shown by `dirs') is at the top.
  
  -N	Rotates the stack so that the Nth directory (counting
! 	from the right) is at the top.
  
  -n	suppress the normal change of directory when adding directories
--- 31,40 ----
  
  +N	Rotates the stack so that the Nth directory (counting
! 	from the left of the list shown by `dirs', starting with
! 	zero) is at the top.
  
  -N	Rotates the stack so that the Nth directory (counting
! 	from the right of the list shown by `dirs', starting with
! 	zero) is at the top.
  
  -n	suppress the normal change of directory when adding directories
***************
*** 258,261 ****
--- 260,265 ----
        add_dirstack_element ((flags & NOCD) ? savestring (list->word->word) : current_directory);
        dirs_builtin ((WORD_LIST *)NULL);
+       if (flags & NOCD)
+ 	free (current_directory);
        return (EXECUTION_SUCCESS);
      }
***************
*** 278,282 ****
--- 282,288 ----
    int flags;
    char direction;
+   char *which_word;
  
+   which_word = (char *)NULL;
    for (flags = 0, which = 0L, direction = '+'; list; list = list->next)
      {
***************
*** 298,301 ****
--- 304,308 ----
  	      return (EXECUTION_FAILURE);
  	    }
+ 	  which_word = list->word->word;
  	}
        else if (*list->word->word == '-')
***************
*** 311,315 ****
    if (which > directory_list_offset || (directory_list_offset == 0 && which == 0))
      {
!       pushd_error (directory_list_offset, list ? list->word->word : "");
        return (EXECUTION_FAILURE);
      }
--- 318,322 ----
    if (which > directory_list_offset || (directory_list_offset == 0 && which == 0))
      {
!       pushd_error (directory_list_offset, which_word ? which_word : "");
        return (EXECUTION_FAILURE);
      }
diff -Nrc2 bash-2.0/builtins/read.def bash-2.01/builtins/read.def
*** bash-2.0/builtins/read.def	Sun Dec 22 17:53:31 1996
--- bash-2.01/builtins/read.def	Thu Feb 27 12:19:01 1997
***************
*** 165,169 ****
  	  if (rlbuf && rlbuf[rlind] == '\0')
  	    {
! 	      free (rlbuf);
  	      rlbuf = (char *)0;
  	    }
--- 165,169 ----
  	  if (rlbuf && rlbuf[rlind] == '\0')
  	    {
! 	      xfree (rlbuf);
  	      rlbuf = (char *)0;
  	    }
***************
*** 248,258 ****
  	  dispose_words (alist);
  	}
!       free (input_string);
        return (retval);
      }
  #endif /* ARRAY_VARS */ 
  
!   if (!list)
      {
        if (saw_escape)
  	{
--- 248,273 ----
  	  dispose_words (alist);
  	}
!       xfree (input_string);
        return (retval);
      }
  #endif /* ARRAY_VARS */ 
  
!   /* If there are no variables, save the text of the line read to the
!      variable $REPLY.  ksh93 strips leading and trailing IFS whitespace,
!      so that `read x ; echo "$x"' and `read ; echo "$REPLY"' behave the
!      same way, but I believe that the difference in behaviors is useful
!      enough to not do it.  Without the bash behavior, there is no way
!      to read a line completely without interpretation or modification.
!      If you disagree, change the occurrences of `#if 0' to `#if 1' below. */
!   if (list == 0)
      {
+ #if 0
+       orig_input_string = input_string;
+       for (t = input_string; ifs_chars && *ifs_chars && spctabnl(*t) && issep(*t); t++)
+ 	;
+       input_string = t;
+       input_string = strip_trailing_ifs_whitespace (input_string, ifs_chars, saw_escape);
+ #endif
+ 
        if (saw_escape)
  	{
***************
*** 264,268 ****
--- 279,287 ----
  	var = bind_variable ("REPLY", input_string);
        var->attributes &= ~att_invisible;
+ #if 0
+       free (orig_input_string);
+ #else
        free (input_string);
+ #endif
        return (retval);
      }
diff -Nrc2 bash-2.0/builtins/return.def bash-2.01/builtins/return.def
*** bash-2.0/builtins/return.def	Wed Aug 21 13:20:19 1996
--- bash-2.01/builtins/return.def	Mon Mar  3 12:47:20 1997
***************
*** 49,53 ****
       WORD_LIST *list;
  {
!   return_catch_value = list ? get_numeric_arg (list) : last_command_exit_value;
  
    if (return_catch_flag)
--- 49,53 ----
       WORD_LIST *list;
  {
!   return_catch_value = list ? get_numeric_arg (list, 1) : last_command_exit_value;
  
    if (return_catch_flag)
diff -Nrc2 bash-2.0/builtins/set.def bash-2.01/builtins/set.def
*** bash-2.0/builtins/set.def	Tue Dec 10 16:13:00 1996
--- bash-2.01/builtins/set.def	Fri Apr 25 10:57:03 1997
***************
*** 79,82 ****
--- 79,85 ----
              histexpand   same as -H
  #endif /* BANG_HISTORY */
+ #if defined (HISTORY)
+             history      enable command history
+ #endif
              ignoreeof    the shell will not exit upon reading EOF
              interactive-comments
***************
*** 111,120 ****
      -B  the shell will perform brace expansion
  #endif /* BRACE_EXPANSION */
  #if defined (BANG_HISTORY)
      -H  Enable ! style history substitution.  This flag is on
          by default.
  #endif /* BANG_HISTORY */
-     -C  If set, disallow existing regular files to be overwritten
-         by redirection of output.
      -P  If set, do not follow symbolic links when executing commands
          such as cd which change the current directory.
--- 114,123 ----
      -B  the shell will perform brace expansion
  #endif /* BRACE_EXPANSION */
+     -C  If set, disallow existing regular files to be overwritten
+         by redirection of output.
  #if defined (BANG_HISTORY)
      -H  Enable ! style history substitution.  This flag is on
          by default.
  #endif /* BANG_HISTORY */
      -P  If set, do not follow symbolic links when executing commands
          such as cd which change the current directory.
***************
*** 128,131 ****
--- 131,135 ----
  
  static int set_ignoreeof ();
+ static int set_posix_mode ();
  
  #if defined (READLINE)
***************
*** 184,188 ****
    { "ignoreeof", &ignoreeof, set_ignoreeof, (Function *)NULL },
    { "interactive-comments", &interactive_comments, (Function *)NULL, (Function *)NULL },
!   { "posix", &posixly_correct, (Function *)NULL, (Function *)NULL },
  #if defined (READLINE)
    { "emacs", (int *)NULL, set_edit_mode, get_edit_mode },
--- 188,192 ----
    { "ignoreeof", &ignoreeof, set_ignoreeof, (Function *)NULL },
    { "interactive-comments", &interactive_comments, (Function *)NULL, (Function *)NULL },
!   { "posix", &posixly_correct, set_posix_mode, (Function *)NULL },
  #if defined (READLINE)
    { "emacs", (int *)NULL, set_edit_mode, get_edit_mode },
***************
*** 284,287 ****
--- 288,305 ----
  }
  
+ static int
+ set_posix_mode (on_or_off, option_name)
+      int on_or_off;
+      char *option_name;
+ {
+   posixly_correct = on_or_off == FLAG_ON;
+   if (posixly_correct == 0)
+     unbind_variable ("POSIXLY_CORRECT");
+   else
+     bind_variable ("POSIXLY_CORRECT", "y");
+   sv_strict_posix ("POSIXLY_CORRECT");
+   return (0);
+ }
+ 
  #if defined (READLINE)
  /* Magic.  This code `knows' how readline handles rl_editing_mode. */
***************
*** 436,440 ****
  	value[vptr++] = ':';
        }
!   value[--vptr] = '\0';		/* cut off trailing colon */
  
    v = find_variable ("SHELLOPTS");
--- 454,460 ----
  	value[vptr++] = ':';
        }
!   if (vptr)
!     vptr--;			/* cut off trailing colon */
!   value[vptr] = '\0';
  
    v = find_variable ("SHELLOPTS");
***************
*** 466,473 ****
  {
    char *temp;
  
    /* set up any shell options we may have inherited. */
!   if (temp = get_string_value ("SHELLOPTS"))
!     parse_shellopts (temp);
  
    /* Set up the $SHELLOPTS variable. */
--- 486,502 ----
  {
    char *temp;
+   SHELL_VAR *var;
  
+   var = find_variable ("SHELLOPTS");
    /* set up any shell options we may have inherited. */
!   if (var && imported_p (var))
!     {
!       temp = (array_p (var)) ? (char *)NULL : savestring (value_cell (var));
!       if (temp)
! 	{
! 	  parse_shellopts (temp);
! 	  free (temp);
! 	}
!     }
  
    /* Set up the $SHELLOPTS variable. */
***************
*** 475,478 ****
--- 504,517 ----
  }
  
+ /* Reset the values of the -o options that are not also shell flags. */
+ void
+ reset_shell_options ()
+ {
+ #if defined (HISTORY)
+   remember_on_history = 1;
+ #endif
+   ignoreeof = posixly_correct = 0;
+ }
+ 
  /* Set some flags from the word values in the input list.  If LIST is empty,
     then print out the values of the variables instead.  If LIST contains
***************
*** 691,694 ****
--- 730,739 ----
  	}
  #endif
+ 
+       if (legal_identifier (name) == 0)
+         {
+           builtin_error ("`%s': not a valid identifier", name);
+           NEXT_VARIABLE ();
+         }
  
        var = unset_function ? find_function (name) : find_variable (name);
diff -Nrc2 bash-2.0/builtins/setattr.def bash-2.01/builtins/setattr.def
*** bash-2.0/builtins/setattr.def	Mon Nov  4 10:37:36 1996
--- bash-2.01/builtins/setattr.def	Thu Mar  6 11:06:57 1997
***************
*** 35,40 ****
--- 35,49 ----
  #include "bashgetopt.h"
  
+ extern int posixly_correct;
  extern int array_needs_making;
  extern char *this_command_name;
+ extern Function *this_shell_builtin;
+ 
+ #ifdef ARRAY_VARS
+ extern int declare_builtin ();
+ #endif
+ 
+ #define READONLY_OR_EXPORT \
+   (this_shell_builtin == readonly_builtin || this_shell_builtin == export_builtin)
  
  $BUILTIN export
***************
*** 95,98 ****
--- 104,111 ----
    int assign, undo, functions_only, arrays_only, any_failed, assign_error, opt;
    char *name;
+ #if defined (ARRAY_VARS)
+   WORD_LIST *nlist, *tlist;
+   WORD_DESC *w;
+ #endif
  
    undo = functions_only = arrays_only = any_failed = assign_error = 0;
***************
*** 160,164 ****
  	    {
  	      builtin_error ("`%s': not a valid identifier", name);
! 	      assign_error++;
  	      list = list->next;
  	      continue;
--- 173,180 ----
  	    {
  	      builtin_error ("`%s': not a valid identifier", name);
! 	      if (assign)
! 		assign_error++;
! 	      else
! 		any_failed++;
  	      list = list->next;
  	      continue;
***************
*** 168,171 ****
--- 184,205 ----
  	    {
  	      name[assign] = '=';
+ #if defined (ARRAY_VARS)
+ 	      /* Let's try something here.  Turn readonly -a xxx=yyy into
+ 		 declare -ra xxx=yyy and see what that gets us. */
+ 	      if (arrays_only)
+ 		{
+ 		  tlist = list->next;
+ 		  list->next = (WORD_LIST *)NULL;
+ 		  w = make_word ("-ra");
+ 		  nlist = make_word_list (w, list);
+ 		  opt = declare_builtin (nlist);
+ 		  if (opt != EXECUTION_SUCCESS)
+ 		    assign_error++;
+ 		  list->next = tlist;
+ 		  dispose_word (w);
+ 		  free (nlist);
+ 		}
+ 	      else
+ #endif
  	      /* This word has already been expanded once with command
  		 and parameter expansion.  Call do_assignment_no_expand (),
***************
*** 213,217 ****
  #endif
  	      if ((var->attributes & attribute) && invisible_p (var) == 0)
! 		show_var_attributes (var, nodefs);
  	    }
  	  free (variable_list);
--- 247,251 ----
  #endif
  	      if ((var->attributes & attribute) && invisible_p (var) == 0)
! 		show_var_attributes (var, READONLY_OR_EXPORT, nodefs);
  	    }
  	  free (variable_list);
***************
*** 224,231 ****
  }
  
  int
! show_var_attributes (var, nodefs)
       SHELL_VAR *var;
!      int nodefs;
  {
    char flags[6], *x;
--- 258,271 ----
  }
  
+ /* Show the attributes for shell variable VAR.  If NODEFS is non-zero,
+    don't show function definitions along with the name.  If PATTR is
+    non-zero, it indicates we're being called from `export' or `readonly'.
+    In POSIX mode, this prints the name of the calling builtin (`export'
+    or `readonly') instead of `declare', and doesn't print function defs
+    when called by `export' or `readonly'. */
  int
! show_var_attributes (var, pattr, nodefs)
       SHELL_VAR *var;
!      int pattr, nodefs;
  {
    char flags[6], *x;
***************
*** 234,257 ****
    i = 0;
  
  #if defined (ARRAY_VARS)
!   if (array_p (var))
!     flags[i++] = 'a';
  #endif
  
!   if (function_p (var))
!     flags[i++] = 'f';
  
!   if (integer_p (var))
!     flags[i++] = 'i';
  
!   if (readonly_p (var))
!     flags[i++] = 'r';
  
!   if (exported_p (var))
!     flags[i++] = 'x';
  
    flags[i] = '\0';
  
!   printf ("declare -%s ", i ? flags : "-");
  
  #if defined (ARRAY_VARS)
--- 274,316 ----
    i = 0;
  
+   /* pattr == 0 means we are called from `declare'. */
+   if (pattr == 0 || posixly_correct == 0)
+     {
  #if defined (ARRAY_VARS)
!       if (array_p (var))
! 	flags[i++] = 'a';
  #endif
  
!       if (function_p (var))
!         flags[i++] = 'f';
  
!       if (integer_p (var))
!         flags[i++] = 'i';
  
!       if (readonly_p (var))
!         flags[i++] = 'r';
  
!       if (exported_p (var))
!         flags[i++] = 'x';
!     }
!   else
!     {
! #if defined (ARRAY_VARS)
!       if (array_p (var))
! 	flags[i++] = 'a';
! #endif
! 
!       if (function_p (var))
!         flags[i++] = 'f';
!     }
  
    flags[i] = '\0';
  
!   if (pattr == 0 || posixly_correct == 0)
!     printf ("declare -%s ", i ? flags : "-");
!   else if (i)
!     printf ("%s -%s ", this_command_name, flags);
!   else
!     printf ("%s ", this_command_name);
  
  #if defined (ARRAY_VARS)
***************
*** 260,264 ****
    else
  #endif
!   if (nodefs)
      printf ("%s\n", var->name);
    else if (function_p (var))
--- 319,325 ----
    else
  #endif
!   /* force `readline' and `export' to not print out function definitions
!      when in POSIX mode. */
!   if (nodefs || (function_p (var) && pattr != 0 && posixly_correct))
      printf ("%s\n", var->name);
    else if (function_p (var))
***************
*** 286,290 ****
    if (var && invisible_p (var) == 0)
      {
!       show_var_attributes (var, nodefs);
        return (0);
      }
--- 347,351 ----
    if (var && invisible_p (var) == 0)
      {
!       show_var_attributes (var, READONLY_OR_EXPORT, nodefs);
        return (0);
      }
diff -Nrc2 bash-2.0/builtins/shift.def bash-2.01/builtins/shift.def
*** bash-2.0/builtins/shift.def	Mon Mar  4 15:44:55 1996
--- bash-2.01/builtins/shift.def	Mon Mar  3 12:47:26 1997
***************
*** 54,58 ****
    WORD_LIST *temp;
  
!   times = get_numeric_arg (list);
  
    if (times == 0)
--- 54,58 ----
    WORD_LIST *temp;
  
!   times = get_numeric_arg (list, 0);
  
    if (times == 0)
diff -Nrc2 bash-2.0/builtins/shopt.def bash-2.01/builtins/shopt.def
*** bash-2.0/builtins/shopt.def	Wed Dec 18 14:44:09 1996
--- bash-2.01/builtins/shopt.def	Thu Apr 17 10:13:23 1997
***************
*** 62,74 ****
  
  #if defined (HISTORY)
! extern int hist_verify, literal_history, command_oriented_history;
  extern int force_append_history;
  #endif
  
  #if defined (READLINE)
! extern int history_reediting, perform_hostname_completion;
  extern void enable_hostname_completion ();
  #endif
  
  static int set_interactive_comments ();
  
--- 62,76 ----
  
  #if defined (HISTORY)
! extern int literal_history, command_oriented_history;
  extern int force_append_history;
  #endif
  
  #if defined (READLINE)
! extern int hist_verify, history_reediting, perform_hostname_completion;
  extern void enable_hostname_completion ();
  #endif
  
+ extern void set_shellopts ();
+ 
  static int set_interactive_comments ();
  
***************
*** 93,99 ****
  #if defined (HISTORY)
    { "histappend", &force_append_history, (Function *)NULL },
-   { "histverify", &hist_verify, (Function *)NULL },
  #endif
  #if defined (READLINE)
    { "hostcomplete", &perform_hostname_completion, (Function *)enable_hostname_completion },
  #endif
--- 95,101 ----
  #if defined (HISTORY)
    { "histappend", &force_append_history, (Function *)NULL },
  #endif
  #if defined (READLINE)
+   { "histverify", &hist_verify, (Function *)NULL },
    { "hostcomplete", &perform_hostname_completion, (Function *)enable_hostname_completion },
  #endif
***************
*** 177,180 ****
--- 179,205 ----
      rval = list_some_shopts ((flags & SFLAG) ? SETOPT : UNSETOPT, flags & QFLAG);
    return (rval);
+ }
+ 
+ /* Reset the options managed by `shopt' to the values they would have at
+    shell startup. */
+ void
+ reset_shopt_options ()
+ {
+   allow_null_glob_expansion = glob_dot_filenames = 0;
+   cdable_vars = mail_warning = 0;
+   no_exit_on_failed_exec = print_shift_error = 0;
+   check_hashed_filenames = cdspelling = expand_aliases = check_window_size = 0;
+ 
+   source_uses_path = promptvars = 1;
+ 
+ #if defined (HISTORY)
+   literal_history = force_append_history = 0;
+   command_oriented_history = 1;
+ #endif
+ 
+ #if defined (READLINE)
+   hist_verify = history_reediting = 0;
+   perform_hostname_completion = 1;
+ #endif
  }
  
diff -Nrc2 bash-2.0/builtins/suspend.def bash-2.01/builtins/suspend.def
*** bash-2.0/builtins/suspend.def	Wed Oct 23 10:59:13 1996
--- bash-2.01/builtins/suspend.def	Wed Feb  5 11:49:32 1997
***************
*** 47,51 ****
  extern int job_control;
  
! static SigHandler *old_cont, *old_stop;
  
  /* Continue handler. */
--- 47,54 ----
  extern int job_control;
  
! static SigHandler *old_cont;
! #if 0
! static SigHandler *old_stop;
! #endif
  
  /* Continue handler. */
diff -Nrc2 bash-2.0/builtins/trap.def bash-2.01/builtins/trap.def
*** bash-2.0/builtins/trap.def	Tue Oct  1 13:16:48 1996
--- bash-2.01/builtins/trap.def	Tue Apr 22 14:02:25 1997
***************
*** 24,38 ****
  $BUILTIN trap
  $FUNCTION trap_builtin
! $SHORT_DOC trap [arg] [signal_spec] or trap -l
  The command ARG is to be read and executed when the shell receives
  signal(s) SIGNAL_SPEC.  If ARG is absent all specified signals are
  reset to their original values.  If ARG is the null string each
  SIGNAL_SPEC is ignored by the shell and by the commands it invokes.
! If SIGNAL_SPEC is EXIT (0) the command ARG is executed on exit from
! the shell.  If SIGNAL_SPEC is DEBUG, ARG is executed after every
  command.  If ARG is `-p' then the trap commands associated with
  each SIGNAL_SPEC are displayed.  If no arguments are supplied or if
  only `-p' is given, trap prints the list of commands associated with
! each signal number.  SIGNAL_SPEC is either a signal name in <signal.h>
  or a signal number.  `trap -l' prints a list of signal names and their
  corresponding numbers.  Note that a signal can be sent to the shell
--- 24,38 ----
  $BUILTIN trap
  $FUNCTION trap_builtin
! $SHORT_DOC trap [arg] [signal_spec ...] or trap -l
  The command ARG is to be read and executed when the shell receives
  signal(s) SIGNAL_SPEC.  If ARG is absent all specified signals are
  reset to their original values.  If ARG is the null string each
  SIGNAL_SPEC is ignored by the shell and by the commands it invokes.
! If a SIGNAL_SPEC is EXIT (0) the command ARG is executed on exit from
! the shell.  If a SIGNAL_SPEC is DEBUG, ARG is executed after every
  command.  If ARG is `-p' then the trap commands associated with
  each SIGNAL_SPEC are displayed.  If no arguments are supplied or if
  only `-p' is given, trap prints the list of commands associated with
! each signal number.  Each SIGNAL_SPEC is either a signal name in <signal.h>
  or a signal number.  `trap -l' prints a list of signal names and their
  corresponding numbers.  Note that a signal can be sent to the shell
***************
*** 116,120 ****
        operation = SET;
        first_arg = list->word->word;
!       if (first_arg && *first_arg && signal_object_p (first_arg))
  	operation = REVERT;
        else
--- 116,121 ----
        operation = SET;
        first_arg = list->word->word;
!       if (first_arg && *first_arg && (*first_arg != '-' || first_arg[1]) &&
! 		signal_object_p (first_arg))
  	operation = REVERT;
        else
diff -Nrc2 bash-2.0/builtins/type.def bash-2.01/builtins/type.def
*** bash-2.0/builtins/type.def	Wed Aug  7 15:52:20 1996
--- bash-2.01/builtins/type.def	Tue Jun  3 11:21:51 1997
***************
*** 58,61 ****
--- 58,62 ----
  #include "../shell.h"
  #include "../execute_cmd.h"
+ #include "../hashcmd.h"
  
  #if defined (ALIAS)
***************
*** 308,311 ****
--- 309,313 ----
  	    printf ("%s\n", full_path);
  
+ 	  free (full_path);
  	  return (1);
  	}
diff -Nrc2 bash-2.0/builtins/ulimit.def bash-2.01/builtins/ulimit.def
*** bash-2.0/builtins/ulimit.def	Sun Dec 22 17:18:30 1996
--- bash-2.01/builtins/ulimit.def	Tue Apr 22 16:37:55 1997
***************
*** 36,40 ****
      -d	the maximum size of a process's data segment
      -f	the maximum size of files created by the shell
!     -l  the maximum size a process may lock into memory
      -m	the maximum resident set size
      -n	the maximum number of open file descriptors
--- 36,40 ----
      -d	the maximum size of a process's data segment
      -f	the maximum size of files created by the shell
!     -l	the maximum size a process may lock into memory
      -m	the maximum resident set size
      -n	the maximum number of open file descriptors
***************
*** 216,219 ****
--- 216,230 ----
  static int cmdlistsz;
  
+ #if !defined (HAVE_RESOURCE) && !defined (HAVE_ULIMIT)
+ long
+ ulimit (cmd, newlim)
+      int cmd;
+      long newlim;
+ {
+   errno = EINVAL;
+   return -1;
+ }
+ #endif /* !HAVE_RESOURCE && !HAVE_ULIMIT */
+ 
  static int
  _findlim (opt)
***************
*** 369,372 ****
--- 380,389 ----
    real_limit = limit * block_factor;
  
+   if (real_limit < 0 || (real_limit == 0 && limit != 0))
+     {
+       builtin_error ("limit out of range: %d", limit);
+       return (EXECUTION_FAILURE);
+     }
+ 
    if (set_limit (limind, real_limit, mode) < 0)
      {
***************
*** 445,448 ****
--- 462,468 ----
  #if !defined (HAVE_RESOURCE)
  	return (ulimit (2, newlim / 512L));
+ #else
+ 	errno = EINVAL;
+ 	return -1;
  #endif
  
***************
*** 463,468 ****
        if (getrlimit (limits[ind].parameter, &limit) < 0)
  	return -1;
!       val = (current_user.euid != 0 && newlim == RLIM_INFINITY)
! 		? limit.rlim_max : newlim;
        if (mode & LIMIT_SOFT)
  	limit.rlim_cur = val;
--- 483,489 ----
        if (getrlimit (limits[ind].parameter, &limit) < 0)
  	return -1;
!       val = (current_user.euid != 0 && newlim == RLIM_INFINITY &&
! 	       (limit.rlim_cur <= limit.rlim_max))
! 		 ? limit.rlim_max : newlim;
        if (mode & LIMIT_SOFT)
  	limit.rlim_cur = val;
diff -Nrc2 bash-2.0/builtins/umask.def bash-2.01/builtins/umask.def
*** bash-2.0/builtins/umask.def	Thu Aug  8 12:25:36 1996
--- bash-2.01/builtins/umask.def	Fri Feb 28 13:54:59 1997
***************
*** 65,68 ****
--- 65,69 ----
  {
    int print_symbolically, opt, umask_value;
+   mode_t umask_arg;
  
    print_symbolically = 0;
***************
*** 106,122 ****
  	    return (EXECUTION_FAILURE);
  	}
!       umask (umask_value);
        if (print_symbolically)
! 	print_symbolic_umask (umask_value);
      }
    else				/* Display the UMASK for this user. */
      {
!       umask_value = umask (022);
!       umask (umask_value);
  
        if (print_symbolically)
! 	print_symbolic_umask (umask_value);
        else
! 	printf ("%03o\n", umask_value);
      }
  
--- 107,124 ----
  	    return (EXECUTION_FAILURE);
  	}
!       umask_arg = (mode_t)umask_value;
!       umask (umask_arg);
        if (print_symbolically)
! 	print_symbolic_umask (umask_arg);
      }
    else				/* Display the UMASK for this user. */
      {
!       umask_arg = umask (022);
!       umask (umask_arg);
  
        if (print_symbolically)
! 	print_symbolic_umask (umask_arg);
        else
! 	printf ("%03o\n", umask_arg);
      }
  
***************
*** 129,133 ****
  static void
  print_symbolic_umask (um)
!      int um;
  {
    char ubits[4], gbits[4], obits[4];		/* u=rwx,g=rwx,o=rwx */
--- 131,135 ----
  static void
  print_symbolic_umask (um)
!      mode_t um;
  {
    char ubits[4], gbits[4], obits[4];		/* u=rwx,g=rwx,o=rwx */
***************
*** 268,274 ****
--- 270,279 ----
  	        break;
  
+ #if 0
+ 	      /* No other values are possible. */
  	      default:
  	      	builtin_error ("bad symbolic mode operator: %c", op);
  	      	return (-1);
+ #endif
  	    }
  
diff -Nrc2 bash-2.0/builtins/wait.def bash-2.01/builtins/wait.def
*** bash-2.0/builtins/wait.def	Wed Aug 28 15:54:57 1996
--- bash-2.01/builtins/wait.def	Thu Feb 20 15:20:00 1997
***************
*** 51,57 ****
--- 51,60 ----
  #endif
  
+ #include "../bashansi.h"
+ 
  #include "../shell.h"
  #include "../jobs.h"
  #include "common.h"
+ #include "bashgetopt.h"
  
  extern int interrupt_immediately;
***************
*** 72,75 ****
--- 75,80 ----
    if (no_options (list))
      return (EX_USAGE);
+   if (list != loptend)
+     list = loptend;
  
    begin_unwind_frame ("wait_builtin");
diff -Nrc2 bash-2.0/command.h bash-2.01/command.h
*** bash-2.0/command.h	Mon Oct 21 13:52:23 1996
--- bash-2.01/command.h	Tue Mar 18 15:39:24 1997
***************
*** 38,41 ****
--- 38,42 ----
  #define NOCLOBBER_REDIRECT  -2
  #define RESTRICTED_REDIRECT -3	/* can only happen in restricted shells. */
+ #define HEREDOC_REDIRECT    -4  /* here-doc temp file can't be created */
  
  #define OUTPUT_REDIRECT(ri) \
***************
*** 122,125 ****
--- 123,128 ----
  #define CMD_TIME_PIPELINE  0x80 /* Time a pipeline */
  #define CMD_TIME_POSIX	   0x100 /* time -p; use POSIX.2 time output spec. */
+ #define CMD_AMPERSAND	   0x200 /* command & */
+ #define CMD_STDIN_REDIR	   0x400 /* async command needs implicit </dev/null */
  
  /* What a command looks like. */
diff -Nrc2 bash-2.0/config.h.bot bash-2.01/config.h.bot
*** bash-2.0/config.h.bot	Fri Oct  4 12:31:29 1996
--- bash-2.01/config.h.bot	Mon Mar 10 15:14:19 1997
***************
*** 62,63 ****
--- 62,67 ----
  #  endif
  #endif
+ 
+ #if defined (STRCOLL_BROKEN)
+ #  undef HAVE_STRCOLL
+ #endif
diff -Nrc2 bash-2.0/config.h.in bash-2.01/config.h.in
*** bash-2.0/config.h.in	Thu Dec  5 11:17:09 1996
--- bash-2.01/config.h.in	Mon Mar 10 15:18:16 1997
***************
*** 301,304 ****
--- 301,310 ----
  #undef STRUCT_DIRENT_HAS_D_INO
  
+ #undef STRUCT_DIRENT_HAS_D_FILENO
+ 
+ #undef STRUCT_WINSIZE_IN_SYS_IOCTL
+ 
+ #undef SPEED_T_IN_SYS_TYPES
+ 
  #undef CAN_REDEFINE_GETENV
  
***************
*** 416,419 ****
--- 422,428 ----
  #undef HAVE_DIRENT_H
  
+ /* Define if you have the <dlfcn.h> header file.  */
+ #undef HAVE_DLFCN_H
+ 
  /* Define if you have the <limits.h> header file.  */
  #undef HAVE_LIMITS_H
***************
*** 501,505 ****
--- 510,518 ----
  #undef RLIMIT_NEEDS_KERNEL
  
+ /* Do strcoll(3) and strcmp(3) give different results in the default locale? */
+ #undef STRCOLL_BROKEN
+ 
  #include "config.h.bot"
  
  #endif /* _CONFIG_H_ */
+ 
diff -Nrc2 bash-2.0/config.h.top bash-2.01/config.h.top
*** bash-2.0/config.h.top	Fri Sep  6 11:27:52 1996
--- bash-2.01/config.h.top	Thu Mar  6 11:38:39 1997
***************
*** 28,31 ****
--- 28,35 ----
  #define V9_ECHO
  
+ /* Define DONT_REPORT_SIGPIPE if you don't want to see `Broken pipe' messages
+    when a job like `cat jobs.c | exit 1' is executed. */
+ /* #define DONT_REPORT_SIGPIPE */
+ 
  /* The default value of the PATH variable. */
  #ifndef DEFAULT_PATH_VALUE
diff -Nrc2 bash-2.0/configure bash-2.01/configure
*** bash-2.0/configure	Wed Dec 18 15:01:41 1996
--- bash-2.01/configure	Wed May 21 11:31:21 1997
***************
*** 1,5 ****
  #! /bin/sh
  
! # From configure.in for Bash 2.0, version 1.14, from autoconf version 2.12
  
  
--- 1,11 ----
  #! /bin/sh
  
! # From configure.in for Bash 2.01, version 1.26, from autoconf version 2.12
! 
! 
! 
! 
! 
! 
  
  
***************
*** 81,125 ****
  # Any additions from configure.in:
  ac_help="$ac_help
! --with-gnu-malloc	use the GNU version of malloc"
  ac_help="$ac_help
  --with-glibc-malloc	use the GNU C library version of malloc"
  ac_help="$ac_help
! --with-purify		configure to postprocess with purify"
  ac_help="$ac_help
! --with-afs		if you are running AFS"
  ac_help="$ac_help
! --enable-minimal-config	a minimal sh-like configuration"
  ac_help="$ac_help
! --enable-job-control	enable job control features"
  ac_help="$ac_help
  --enable-alias		enable shell aliases"
  ac_help="$ac_help
! --enable-readline	turn on command line editing"
! ac_help="$ac_help
! --enable-history	turn on command history"
  ac_help="$ac_help
  --enable-bang-history	turn on csh-style history substitution"
  ac_help="$ac_help
! --enable-directory-stack	enable builtins pushd/popd/dirs"
  ac_help="$ac_help
! --enable-restricted	enable a restricted shell"
  ac_help="$ac_help
! --enable-process-substitution	enable process substitution"
  ac_help="$ac_help
! --enable-prompt-string-decoding	turn on escape character decoding in prompts"
  ac_help="$ac_help
! --enable-select		include select command"
  ac_help="$ac_help
  --enable-help-builtin	include the help builtin"
  ac_help="$ac_help
! --enable-array-variables	include shell array variables"
  ac_help="$ac_help
! --enable-dparen-arithmetic	include ((...)) command"
  ac_help="$ac_help
! --enable-brace-expansion	include brace expansion"
  ac_help="$ac_help
! --enable-disabled-builtins	allow disabled builtins to still be invoked"
  ac_help="$ac_help
! --enable-command-timing	enable the time reserved word and command timing"
  ac_help="$ac_help
  --enable-usg-echo-default	make the echo builtin expand escape sequences by default"
--- 87,135 ----
  # Any additions from configure.in:
  ac_help="$ac_help
! --with-afs		if you are running AFS"
! ac_help="$ac_help
! --with-curses		use the curses library instead of the termcap library"
  ac_help="$ac_help
  --with-glibc-malloc	use the GNU C library version of malloc"
  ac_help="$ac_help
! --with-gnu-malloc	use the GNU version of malloc"
  ac_help="$ac_help
! --with-purecov		configure to postprocess with pure coverage"
  ac_help="$ac_help
! --with-purify		configure to postprocess with purify"
  ac_help="$ac_help
! --enable-minimal-config	a minimal sh-like configuration"
  ac_help="$ac_help
  --enable-alias		enable shell aliases"
  ac_help="$ac_help
! --enable-array-variables	include shell array variables"
  ac_help="$ac_help
  --enable-bang-history	turn on csh-style history substitution"
  ac_help="$ac_help
! --enable-brace-expansion	include brace expansion"
  ac_help="$ac_help
! --enable-command-timing	enable the time reserved word and command timing"
  ac_help="$ac_help
! --enable-directory-stack	enable builtins pushd/popd/dirs"
  ac_help="$ac_help
! --enable-disabled-builtins	allow disabled builtins to still be invoked"
  ac_help="$ac_help
! --enable-dparen-arithmetic	include ((...)) command"
  ac_help="$ac_help
  --enable-help-builtin	include the help builtin"
  ac_help="$ac_help
! --enable-history	turn on command history"
  ac_help="$ac_help
! --enable-job-control	enable job control features"
  ac_help="$ac_help
! --enable-process-substitution	enable process substitution"
  ac_help="$ac_help
! --enable-prompt-string-decoding	turn on escape character decoding in prompts"
  ac_help="$ac_help
! --enable-readline	turn on command line editing"
! ac_help="$ac_help
! --enable-restricted	enable a restricted shell"
! ac_help="$ac_help
! --enable-select		include select command"
  ac_help="$ac_help
  --enable-usg-echo-default	make the echo builtin expand escape sequences by default"
***************
*** 662,666 ****
  
  echo $ac_n "checking host system type""... $ac_c" 1>&6
! echo "configure:665: checking host system type" >&5
  
  host_alias=$host
--- 672,676 ----
  
  echo $ac_n "checking host system type""... $ac_c" 1>&6
! echo "configure:675: checking host system type" >&5
  
  host_alias=$host
***************
*** 686,690 ****
--- 696,702 ----
  opt_glibc_malloc=no
  opt_purify=no
+ opt_purecov=no
  opt_afs=no
+ opt_curses=no
  
  case "${host_cpu}-${host_os}" in
***************
*** 694,709 ****
  sparc-svr4*)	opt_gnu_malloc=no ;;	# sparc SVR4, SVR4.2
  sparc-netbsd*)	opt_gnu_malloc=no ;;	# needs 8-byte alignment
  sparc-linux*)	opt_gnu_malloc=no ;;	# sparc running linux; requires ELF
  *-aix*)		opt_gnu_malloc=no ;;	# AIX machines
  *-nextstep*)	opt_gnu_malloc=no ;;	# NeXT machines running NeXTstep
  *-dgux*)	opt_gnu_malloc=no ;;	# DG/UX machines
! *-qnx)		opt_gnu_malloc=no ;;	# QNX 4.2
  *-bsdi2.1)	opt_gnu_malloc=no ; : ${CC:=shlicc2} ;; # for loadable builtins
  esac
  
! # Check whether --with-gnu-malloc or --without-gnu-malloc was given.
! if test "${with_gnu_malloc+set}" = set; then
!   withval="$with_gnu_malloc"
!   opt_gnu_malloc=$withval
  fi
  
--- 706,730 ----
  sparc-svr4*)	opt_gnu_malloc=no ;;	# sparc SVR4, SVR4.2
  sparc-netbsd*)	opt_gnu_malloc=no ;;	# needs 8-byte alignment
+ *-sgi-irix6*)	opt_gnu_malloc=no ;;	# needs 8-byte alignment
  sparc-linux*)	opt_gnu_malloc=no ;;	# sparc running linux; requires ELF
+ *-freebsd*)	opt_gnu_malloc=no ;;	# they claim it's better
  *-aix*)		opt_gnu_malloc=no ;;	# AIX machines
  *-nextstep*)	opt_gnu_malloc=no ;;	# NeXT machines running NeXTstep
  *-dgux*)	opt_gnu_malloc=no ;;	# DG/UX machines
! *-qnx*)		opt_gnu_malloc=no ;;	# QNX 4.2
! *-machten4)	opt_gnu_malloc=no ;;	# MachTen 4.x
  *-bsdi2.1)	opt_gnu_malloc=no ; : ${CC:=shlicc2} ;; # for loadable builtins
  esac
  
! # Check whether --with-afs or --without-afs was given.
! if test "${with_afs+set}" = set; then
!   withval="$with_afs"
!   opt_afs=$withval
! fi
! 
! # Check whether --with-curses or --without-curses was given.
! if test "${with_curses+set}" = set; then
!   withval="$with_curses"
!   opt_curses=$withval
  fi
  
***************
*** 714,717 ****
--- 735,750 ----
  fi
  
+ # Check whether --with-gnu-malloc or --without-gnu-malloc was given.
+ if test "${with_gnu_malloc+set}" = set; then
+   withval="$with_gnu_malloc"
+   opt_gnu_malloc=$withval
+ fi
+ 
+ # Check whether --with-purecov or --without-purecov was given.
+ if test "${with_purecov+set}" = set; then
+   withval="$with_purecov"
+   opt_purecov=$withval
+ fi
+ 
  # Check whether --with-purify or --without-purify was given.
  if test "${with_purify+set}" = set; then
***************
*** 720,744 ****
  fi
  
- # Check whether --with-afs or --without-afs was given.
- if test "${with_afs+set}" = set; then
-   withval="$with_afs"
-   opt_afs=$withval
- fi
- 
  
  if test "$opt_glibc_malloc" = yes; then 
! 	MALLOC=gmalloc.o MALLOC_SRC='$(ALLOC_LIBSRC)/gmalloc.c'
  elif test "$opt_gnu_malloc" = yes; then
! 	MALLOC=malloc.o MALLOC_SRC='$(ALLOC_LIBSRC)/malloc.c'
  else
! 	MALLOC= MALLOC_SRC=
  fi
  
  if test "$opt_purify" = yes; then
! 	PURIFY=purify
  else
  	PURIFY=
  fi
  
  if test "$opt_afs" = yes; then
  	cat >> confdefs.h <<\EOF
--- 753,778 ----
  fi
  
  
  if test "$opt_glibc_malloc" = yes; then 
! 	MALLOC_TARGET=gmalloc
! 	MALLOC_SRC=gmalloc.c
  elif test "$opt_gnu_malloc" = yes; then
! 	MALLOC_TARGET=malloc
! 	MALLOC_SRC=malloc.c
  else
! 	MALLOC_TARGET=stubmalloc
! 	MALLOC_SRC=stub.c
  fi
  
  if test "$opt_purify" = yes; then
! 	PURIFY="purify "
  else
  	PURIFY=
  fi
  
+ if test "$opt_purecov" = yes; then
+ 	PURIFY="${PURIFY}purecov"
+ fi
+ 
  if test "$opt_afs" = yes; then
  	cat >> confdefs.h <<\EOF
***************
*** 748,751 ****
--- 782,789 ----
  fi
  
+ if test "$opt_curses" = yes; then
+ 	prefer_curses=yes
+ fi
+ 
  opt_minimal_config=no
  
***************
*** 783,792 ****
  fi
  
- # Check whether --enable-job-control or --disable-job-control was given.
- if test "${enable_job_control+set}" = set; then
-   enableval="$enable_job_control"
-   opt_job_control=$enableval
- fi
- 
  # Check whether --enable-alias or --disable-alias was given.
  if test "${enable_alias+set}" = set; then
--- 821,824 ----
***************
*** 795,808 ****
  fi
  
! # Check whether --enable-readline or --disable-readline was given.
! if test "${enable_readline+set}" = set; then
!   enableval="$enable_readline"
!   opt_readline=$enableval
! fi
! 
! # Check whether --enable-history or --disable-history was given.
! if test "${enable_history+set}" = set; then
!   enableval="$enable_history"
!   opt_history=$enableval
  fi
  
--- 827,834 ----
  fi
  
! # Check whether --enable-array-variables or --disable-array-variables was given.
! if test "${enable_array_variables+set}" = set; then
!   enableval="$enable_array_variables"
!   opt_array_variables=$enableval
  fi
  
***************
*** 813,844 ****
  fi
  
! # Check whether --enable-directory-stack or --disable-directory-stack was given.
! if test "${enable_directory_stack+set}" = set; then
!   enableval="$enable_directory_stack"
!   opt_dirstack=$enableval
  fi
  
! # Check whether --enable-restricted or --disable-restricted was given.
! if test "${enable_restricted+set}" = set; then
!   enableval="$enable_restricted"
!   opt_restricted=$enableval
  fi
  
! # Check whether --enable-process-substitution or --disable-process-substitution was given.
! if test "${enable_process_substitution+set}" = set; then
!   enableval="$enable_process_substitution"
!   opt_process_subst=$enableval
  fi
  
! # Check whether --enable-prompt-string-decoding or --disable-prompt-string-decoding was given.
! if test "${enable_prompt_string_decoding+set}" = set; then
!   enableval="$enable_prompt_string_decoding"
!   opt_prompt_decoding=$enableval
  fi
  
! # Check whether --enable-select or --disable-select was given.
! if test "${enable_select+set}" = set; then
!   enableval="$enable_select"
!   opt_select=$enableval
  fi
  
--- 839,870 ----
  fi
  
! # Check whether --enable-brace-expansion or --disable-brace-expansion was given.
! if test "${enable_brace_expansion+set}" = set; then
!   enableval="$enable_brace_expansion"
!   opt_brace_expansion=$enableval
  fi
  
! # Check whether --enable-command-timing or --disable-command-timing was given.
! if test "${enable_command_timing+set}" = set; then
!   enableval="$enable_command_timing"
!   opt_command_timing=$enableval
  fi
  
! # Check whether --enable-directory-stack or --disable-directory-stack was given.
! if test "${enable_directory_stack+set}" = set; then
!   enableval="$enable_directory_stack"
!   opt_dirstack=$enableval
  fi
  
! # Check whether --enable-disabled-builtins or --disable-disabled-builtins was given.
! if test "${enable_disabled_builtins+set}" = set; then
!   enableval="$enable_disabled_builtins"
!   opt_disabled_builtins=$enableval
  fi
  
! # Check whether --enable-dparen-arithmetic or --disable-dparen-arithmetic was given.
! if test "${enable_dparen_arithmetic+set}" = set; then
!   enableval="$enable_dparen_arithmetic"
!   opt_dparen_arith=$enableval
  fi
  
***************
*** 849,880 ****
  fi
  
! # Check whether --enable-array-variables or --disable-array-variables was given.
! if test "${enable_array_variables+set}" = set; then
!   enableval="$enable_array_variables"
!   opt_array_variables=$enableval
  fi
  
! # Check whether --enable-dparen-arithmetic or --disable-dparen-arithmetic was given.
! if test "${enable_dparen_arithmetic+set}" = set; then
!   enableval="$enable_dparen_arithmetic"
!   opt_dparen_arith=$enableval
  fi
  
! # Check whether --enable-brace-expansion or --disable-brace-expansion was given.
! if test "${enable_brace_expansion+set}" = set; then
!   enableval="$enable_brace_expansion"
!   opt_brace_expansion=$enableval
  fi
  
! # Check whether --enable-disabled-builtins or --disable-disabled-builtins was given.
! if test "${enable_disabled_builtins+set}" = set; then
!   enableval="$enable_disabled_builtins"
!   opt_disabled_builtins=$enableval
  fi
  
! # Check whether --enable-command-timing or --disable-command-timing was given.
! if test "${enable_command_timing+set}" = set; then
!   enableval="$enable_command_timing"
!   opt_command_timing=$enableval
  fi
  
--- 875,918 ----
  fi
  
! # Check whether --enable-history or --disable-history was given.
! if test "${enable_history+set}" = set; then
!   enableval="$enable_history"
!   opt_history=$enableval
  fi
  
! # Check whether --enable-job-control or --disable-job-control was given.
! if test "${enable_job_control+set}" = set; then
!   enableval="$enable_job_control"
!   opt_job_control=$enableval
  fi
  
! # Check whether --enable-process-substitution or --disable-process-substitution was given.
! if test "${enable_process_substitution+set}" = set; then
!   enableval="$enable_process_substitution"
!   opt_process_subst=$enableval
  fi
  
! # Check whether --enable-prompt-string-decoding or --disable-prompt-string-decoding was given.
! if test "${enable_prompt_string_decoding+set}" = set; then
!   enableval="$enable_prompt_string_decoding"
!   opt_prompt_decoding=$enableval
  fi
  
! # Check whether --enable-readline or --disable-readline was given.
! if test "${enable_readline+set}" = set; then
!   enableval="$enable_readline"
!   opt_readline=$enableval
! fi
! 
! # Check whether --enable-restricted or --disable-restricted was given.
! if test "${enable_restricted+set}" = set; then
!   enableval="$enable_restricted"
!   opt_restricted=$enableval
! fi
! 
! # Check whether --enable-select or --disable-select was given.
! if test "${enable_select+set}" = set; then
!   enableval="$enable_select"
!   opt_select=$enableval
  fi
  
***************
*** 996,999 ****
--- 1034,1044 ----
  fi
  
+ if test "$opt_minimal_config" = yes; then
+ 	TESTSCRIPT=run-minimal
+ else
+ 	TESTSCRIPT=run-all
+ fi
+ 
+ 
  
  
***************
*** 1004,1013 ****
  
  
! echo "Beginning configuration for bash-2.0"
  
  # Extract the first word of "gcc", so it can be a program name with args.
  set dummy gcc; ac_word=$2
  echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
! echo "configure:1012: checking for $ac_word" >&5
  if eval "test \"`echo '$''{'ac_cv_prog_CC'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
--- 1049,1061 ----
  
  
! BASHVERS=2.01
! BASHPATCH=0
! 
! echo "Beginning configuration for bash-$BASHVERS"
  
  # Extract the first word of "gcc", so it can be a program name with args.
  set dummy gcc; ac_word=$2
  echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
! echo "configure:1060: checking for $ac_word" >&5
  if eval "test \"`echo '$''{'ac_cv_prog_CC'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
***************
*** 1038,1042 ****
  set dummy cc; ac_word=$2
  echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
! echo "configure:1041: checking for $ac_word" >&5
  if eval "test \"`echo '$''{'ac_cv_prog_CC'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
--- 1086,1090 ----
  set dummy cc; ac_word=$2
  echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
! echo "configure:1089: checking for $ac_word" >&5
  if eval "test \"`echo '$''{'ac_cv_prog_CC'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
***************
*** 1086,1090 ****
  
  echo $ac_n "checking whether the C compiler ($CC $CFLAGS $LDFLAGS) works""... $ac_c" 1>&6
! echo "configure:1089: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) works" >&5
  
  ac_ext=c
--- 1134,1138 ----
  
  echo $ac_n "checking whether the C compiler ($CC $CFLAGS $LDFLAGS) works""... $ac_c" 1>&6
! echo "configure:1137: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) works" >&5
  
  ac_ext=c
***************
*** 1096,1104 ****
  
  cat > conftest.$ac_ext <<EOF
! #line 1099 "configure"
  #include "confdefs.h"
  main(){return(0);}
  EOF
! if { (eval echo configure:1103: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
    ac_cv_prog_cc_works=yes
    # If we can't run a trivial program, we are probably using a cross compiler.
--- 1144,1152 ----
  
  cat > conftest.$ac_ext <<EOF
! #line 1147 "configure"
  #include "confdefs.h"
  main(){return(0);}
  EOF
! if { (eval echo configure:1151: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
    ac_cv_prog_cc_works=yes
    # If we can't run a trivial program, we are probably using a cross compiler.
***************
*** 1120,1129 ****
  fi
  echo $ac_n "checking whether the C compiler ($CC $CFLAGS $LDFLAGS) is a cross-compiler""... $ac_c" 1>&6
! echo "configure:1123: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) is a cross-compiler" >&5
  echo "$ac_t""$ac_cv_prog_cc_cross" 1>&6
  cross_compiling=$ac_cv_prog_cc_cross
  
  echo $ac_n "checking whether we are using GNU C""... $ac_c" 1>&6
! echo "configure:1128: checking whether we are using GNU C" >&5
  if eval "test \"`echo '$''{'ac_cv_prog_gcc'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
--- 1168,1177 ----
  fi
  echo $ac_n "checking whether the C compiler ($CC $CFLAGS $LDFLAGS) is a cross-compiler""... $ac_c" 1>&6
! echo "configure:1171: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) is a cross-compiler" >&5
  echo "$ac_t""$ac_cv_prog_cc_cross" 1>&6
  cross_compiling=$ac_cv_prog_cc_cross
  
  echo $ac_n "checking whether we are using GNU C""... $ac_c" 1>&6
! echo "configure:1176: checking whether we are using GNU C" >&5
  if eval "test \"`echo '$''{'ac_cv_prog_gcc'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
***************
*** 1134,1138 ****
  #endif
  EOF
! if { ac_try='${CC-cc} -E conftest.c'; { (eval echo configure:1137: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }; } | egrep yes >/dev/null 2>&1; then
    ac_cv_prog_gcc=yes
  else
--- 1182,1186 ----
  #endif
  EOF
! if { ac_try='${CC-cc} -E conftest.c'; { (eval echo configure:1185: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }; } | egrep yes >/dev/null 2>&1; then
    ac_cv_prog_gcc=yes
  else
***************
*** 1149,1153 ****
    CFLAGS=
    echo $ac_n "checking whether ${CC-cc} accepts -g""... $ac_c" 1>&6
! echo "configure:1152: checking whether ${CC-cc} accepts -g" >&5
  if eval "test \"`echo '$''{'ac_cv_prog_cc_g'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
--- 1197,1201 ----
    CFLAGS=
    echo $ac_n "checking whether ${CC-cc} accepts -g""... $ac_c" 1>&6
! echo "configure:1200: checking whether ${CC-cc} accepts -g" >&5
  if eval "test \"`echo '$''{'ac_cv_prog_cc_g'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
***************
*** 1177,1181 ****
  
  echo $ac_n "checking for POSIXized ISC""... $ac_c" 1>&6
! echo "configure:1180: checking for POSIXized ISC" >&5
  if test -d /etc/conf/kconfig.d &&
    grep _POSIX_VERSION /usr/include/sys/unistd.h >/dev/null 2>&1
--- 1225,1229 ----
  
  echo $ac_n "checking for POSIXized ISC""... $ac_c" 1>&6
! echo "configure:1228: checking for POSIXized ISC" >&5
  if test -d /etc/conf/kconfig.d &&
    grep _POSIX_VERSION /usr/include/sys/unistd.h >/dev/null 2>&1
***************
*** 1198,1202 ****
  
  echo $ac_n "checking how to run the C preprocessor""... $ac_c" 1>&6
! echo "configure:1201: checking how to run the C preprocessor" >&5
  # On Suns, sometimes $CPP names a directory.
  if test -n "$CPP" && test -d "$CPP"; then
--- 1246,1250 ----
  
  echo $ac_n "checking how to run the C preprocessor""... $ac_c" 1>&6
! echo "configure:1249: checking how to run the C preprocessor" >&5
  # On Suns, sometimes $CPP names a directory.
  if test -n "$CPP" && test -d "$CPP"; then
***************
*** 1213,1217 ****
    # not just through cpp.
    cat > conftest.$ac_ext <<EOF
! #line 1216 "configure"
  #include "confdefs.h"
  #include <assert.h>
--- 1261,1265 ----
    # not just through cpp.
    cat > conftest.$ac_ext <<EOF
! #line 1264 "configure"
  #include "confdefs.h"
  #include <assert.h>
***************
*** 1219,1223 ****
  EOF
  ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
! { (eval echo configure:1222: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
  ac_err=`grep -v '^ *+' conftest.out`
  if test -z "$ac_err"; then
--- 1267,1271 ----
  EOF
  ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
! { (eval echo configure:1270: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
  ac_err=`grep -v '^ *+' conftest.out`
  if test -z "$ac_err"; then
***************
*** 1230,1234 ****
    CPP="${CC-cc} -E -traditional-cpp"
    cat > conftest.$ac_ext <<EOF
! #line 1233 "configure"
  #include "confdefs.h"
  #include <assert.h>
--- 1278,1282 ----
    CPP="${CC-cc} -E -traditional-cpp"
    cat > conftest.$ac_ext <<EOF
! #line 1281 "configure"
  #include "confdefs.h"
  #include <assert.h>
***************
*** 1236,1240 ****
  EOF
  ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
! { (eval echo configure:1239: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
  ac_err=`grep -v '^ *+' conftest.out`
  if test -z "$ac_err"; then
--- 1284,1288 ----
  EOF
  ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
! { (eval echo configure:1287: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
  ac_err=`grep -v '^ *+' conftest.out`
  if test -z "$ac_err"; then
***************
*** 1260,1274 ****
  ac_safe=`echo "minix/config.h" | sed 'y%./+-%__p_%'`
  echo $ac_n "checking for minix/config.h""... $ac_c" 1>&6
! echo "configure:1263: checking for minix/config.h" >&5
  if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 1268 "configure"
  #include "confdefs.h"
  #include <minix/config.h>
  EOF
  ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
! { (eval echo configure:1273: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
  ac_err=`grep -v '^ *+' conftest.out`
  if test -z "$ac_err"; then
--- 1308,1322 ----
  ac_safe=`echo "minix/config.h" | sed 'y%./+-%__p_%'`
  echo $ac_n "checking for minix/config.h""... $ac_c" 1>&6
! echo "configure:1311: checking for minix/config.h" >&5
  if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 1316 "configure"
  #include "confdefs.h"
  #include <minix/config.h>
  EOF
  ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
! { (eval echo configure:1321: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
  ac_err=`grep -v '^ *+' conftest.out`
  if test -z "$ac_err"; then
***************
*** 1308,1346 ****
  
  
- echo $ac_n "checking whether CC works at all""... $ac_c" 1>&6
- echo "configure:1312: checking whether CC works at all" >&5
- if eval "test \"`echo '$''{'bash_cv_prog_cc_works'+set}'`\" = set"; then
-   echo $ac_n "(cached) $ac_c" 1>&6
- else
-   if test "$cross_compiling" = yes; then
-   bash_cv_prog_cc_works=no
- else
-   cat > conftest.$ac_ext <<EOF
- #line 1320 "configure"
- #include "confdefs.h"
- main() { exit(0); }
- EOF
- if { (eval echo configure:1324: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
- then
-   bash_cv_prog_cc_works=yes
- else
-   echo "configure: failed program was:" >&5
-   cat conftest.$ac_ext >&5
-   rm -fr conftest*
-   bash_cv_prog_cc_works=no
- fi
- rm -fr conftest*
- fi
- 
- 	
- 
- fi
- 
- echo "$ac_t""$bash_cv_prog_cc_works" 1>&6
- if test "$bash_cv_prog_cc_works" = "no"; then
- { echo "configure: error: Installation or configuration problem: C compiler cannot create executables" 1>&2; exit 1; }
- fi
- 
- 
  test -z "$CFLAGS" && CFLAGS=-g auto_cflags=1
  
--- 1356,1359 ----
***************
*** 1353,1357 ****
  if test $ac_cv_prog_gcc = yes; then
      echo $ac_n "checking whether ${CC-cc} needs -traditional""... $ac_c" 1>&6
! echo "configure:1356: checking whether ${CC-cc} needs -traditional" >&5
  if eval "test \"`echo '$''{'ac_cv_prog_gcc_traditional'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
--- 1366,1370 ----
  if test $ac_cv_prog_gcc = yes; then
      echo $ac_n "checking whether ${CC-cc} needs -traditional""... $ac_c" 1>&6
! echo "configure:1369: checking whether ${CC-cc} needs -traditional" >&5
  if eval "test \"`echo '$''{'ac_cv_prog_gcc_traditional'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
***************
*** 1359,1363 ****
      ac_pattern="Autoconf.*'x'"
    cat > conftest.$ac_ext <<EOF
! #line 1362 "configure"
  #include "confdefs.h"
  #include <sgtty.h>
--- 1372,1376 ----
      ac_pattern="Autoconf.*'x'"
    cat > conftest.$ac_ext <<EOF
! #line 1375 "configure"
  #include "confdefs.h"
  #include <sgtty.h>
***************
*** 1377,1381 ****
    if test $ac_cv_prog_gcc_traditional = no; then
      cat > conftest.$ac_ext <<EOF
! #line 1380 "configure"
  #include "confdefs.h"
  #include <termio.h>
--- 1390,1394 ----
    if test $ac_cv_prog_gcc_traditional = no; then
      cat > conftest.$ac_ext <<EOF
! #line 1393 "configure"
  #include "confdefs.h"
  #include <termio.h>
***************
*** 1410,1414 ****
  # ./install, which can be erroneously created by make from ./install.sh.
  echo $ac_n "checking for a BSD compatible install""... $ac_c" 1>&6
! echo "configure:1413: checking for a BSD compatible install" >&5
  if test -z "$INSTALL"; then
  if eval "test \"`echo '$''{'ac_cv_path_install'+set}'`\" = set"; then
--- 1423,1427 ----
  # ./install, which can be erroneously created by make from ./install.sh.
  echo $ac_n "checking for a BSD compatible install""... $ac_c" 1>&6
! echo "configure:1426: checking for a BSD compatible install" >&5
  if test -z "$INSTALL"; then
  if eval "test \"`echo '$''{'ac_cv_path_install'+set}'`\" = set"; then
***************
*** 1462,1466 ****
  set dummy ar; ac_word=$2
  echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
! echo "configure:1465: checking for $ac_word" >&5
  if eval "test \"`echo '$''{'ac_cv_prog_AR'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
--- 1475,1479 ----
  set dummy ar; ac_word=$2
  echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
! echo "configure:1478: checking for $ac_word" >&5
  if eval "test \"`echo '$''{'ac_cv_prog_AR'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
***************
*** 1490,1494 ****
  set dummy ranlib; ac_word=$2
  echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
! echo "configure:1493: checking for $ac_word" >&5
  if eval "test \"`echo '$''{'ac_cv_prog_RANLIB'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
--- 1503,1507 ----
  set dummy ranlib; ac_word=$2
  echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
! echo "configure:1506: checking for $ac_word" >&5
  if eval "test \"`echo '$''{'ac_cv_prog_RANLIB'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
***************
*** 1521,1525 ****
  set dummy $ac_prog; ac_word=$2
  echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
! echo "configure:1524: checking for $ac_word" >&5
  if eval "test \"`echo '$''{'ac_cv_prog_YACC'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
--- 1534,1538 ----
  set dummy $ac_prog; ac_word=$2
  echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
! echo "configure:1537: checking for $ac_word" >&5
  if eval "test \"`echo '$''{'ac_cv_prog_YACC'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
***************
*** 1551,1555 ****
  
  echo $ac_n "checking whether ${MAKE-make} sets \${MAKE}""... $ac_c" 1>&6
! echo "configure:1554: checking whether ${MAKE-make} sets \${MAKE}" >&5
  set dummy ${MAKE-make}; ac_make=`echo "$2" | sed 'y%./+-%__p_%'`
  if eval "test \"`echo '$''{'ac_cv_prog_make_${ac_make}_set'+set}'`\" = set"; then
--- 1564,1568 ----
  
  echo $ac_n "checking whether ${MAKE-make} sets \${MAKE}""... $ac_c" 1>&6
! echo "configure:1567: checking whether ${MAKE-make} sets \${MAKE}" >&5
  set dummy ${MAKE-make}; ac_make=`echo "$2" | sed 'y%./+-%__p_%'`
  if eval "test \"`echo '$''{'ac_cv_prog_make_${ac_make}_set'+set}'`\" = set"; then
***************
*** 1581,1590 ****
  # for constant arguments.  Useless!
  echo $ac_n "checking for working alloca.h""... $ac_c" 1>&6
! echo "configure:1584: checking for working alloca.h" >&5
  if eval "test \"`echo '$''{'ac_cv_header_alloca_h'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 1589 "configure"
  #include "confdefs.h"
  #include <alloca.h>
--- 1594,1603 ----
  # for constant arguments.  Useless!
  echo $ac_n "checking for working alloca.h""... $ac_c" 1>&6
! echo "configure:1597: checking for working alloca.h" >&5
  if eval "test \"`echo '$''{'ac_cv_header_alloca_h'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 1602 "configure"
  #include "confdefs.h"
  #include <alloca.h>
***************
*** 1593,1597 ****
  ; return 0; }
  EOF
! if { (eval echo configure:1596: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
    rm -rf conftest*
    ac_cv_header_alloca_h=yes
--- 1606,1610 ----
  ; return 0; }
  EOF
! if { (eval echo configure:1609: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
    rm -rf conftest*
    ac_cv_header_alloca_h=yes
***************
*** 1614,1623 ****
  
  echo $ac_n "checking for alloca""... $ac_c" 1>&6
! echo "configure:1617: checking for alloca" >&5
  if eval "test \"`echo '$''{'ac_cv_func_alloca_works'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 1622 "configure"
  #include "confdefs.h"
  
--- 1627,1636 ----
  
  echo $ac_n "checking for alloca""... $ac_c" 1>&6
! echo "configure:1630: checking for alloca" >&5
  if eval "test \"`echo '$''{'ac_cv_func_alloca_works'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 1635 "configure"
  #include "confdefs.h"
  
***************
*** 1642,1646 ****
  ; return 0; }
  EOF
! if { (eval echo configure:1645: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
    rm -rf conftest*
    ac_cv_func_alloca_works=yes
--- 1655,1659 ----
  ; return 0; }
  EOF
! if { (eval echo configure:1658: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
    rm -rf conftest*
    ac_cv_func_alloca_works=yes
***************
*** 1674,1683 ****
  
  echo $ac_n "checking whether alloca needs Cray hooks""... $ac_c" 1>&6
! echo "configure:1677: checking whether alloca needs Cray hooks" >&5
  if eval "test \"`echo '$''{'ac_cv_os_cray'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 1682 "configure"
  #include "confdefs.h"
  #if defined(CRAY) && ! defined(CRAY2)
--- 1687,1696 ----
  
  echo $ac_n "checking whether alloca needs Cray hooks""... $ac_c" 1>&6
! echo "configure:1690: checking whether alloca needs Cray hooks" >&5
  if eval "test \"`echo '$''{'ac_cv_os_cray'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 1695 "configure"
  #include "confdefs.h"
  #if defined(CRAY) && ! defined(CRAY2)
***************
*** 1704,1713 ****
  for ac_func in _getb67 GETB67 getb67; do
    echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
! echo "configure:1707: checking for $ac_func" >&5
  if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 1712 "configure"
  #include "confdefs.h"
  /* System header to define __stub macros and hopefully few prototypes,
--- 1717,1726 ----
  for ac_func in _getb67 GETB67 getb67; do
    echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
! echo "configure:1720: checking for $ac_func" >&5
  if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 1725 "configure"
  #include "confdefs.h"
  /* System header to define __stub macros and hopefully few prototypes,
***************
*** 1732,1736 ****
  ; return 0; }
  EOF
! if { (eval echo configure:1735: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
    rm -rf conftest*
    eval "ac_cv_func_$ac_func=yes"
--- 1745,1749 ----
  ; return 0; }
  EOF
! if { (eval echo configure:1748: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
    rm -rf conftest*
    eval "ac_cv_func_$ac_func=yes"
***************
*** 1759,1763 ****
  
  echo $ac_n "checking stack direction for C alloca""... $ac_c" 1>&6
! echo "configure:1762: checking stack direction for C alloca" >&5
  if eval "test \"`echo '$''{'ac_cv_c_stack_direction'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
--- 1772,1776 ----
  
  echo $ac_n "checking stack direction for C alloca""... $ac_c" 1>&6
! echo "configure:1775: checking stack direction for C alloca" >&5
  if eval "test \"`echo '$''{'ac_cv_c_stack_direction'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
***************
*** 1767,1771 ****
  else
    cat > conftest.$ac_ext <<EOF
! #line 1770 "configure"
  #include "confdefs.h"
  find_stack_direction ()
--- 1780,1784 ----
  else
    cat > conftest.$ac_ext <<EOF
! #line 1783 "configure"
  #include "confdefs.h"
  find_stack_direction ()
***************
*** 1786,1790 ****
  }
  EOF
! if { (eval echo configure:1789: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
  then
    ac_cv_c_stack_direction=1
--- 1799,1803 ----
  }
  EOF
! if { (eval echo configure:1802: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
  then
    ac_cv_c_stack_direction=1
***************
*** 1808,1812 ****
  
  echo $ac_n "checking whether getpgrp takes no argument""... $ac_c" 1>&6
! echo "configure:1811: checking whether getpgrp takes no argument" >&5
  if eval "test \"`echo '$''{'ac_cv_func_getpgrp_void'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
--- 1821,1825 ----
  
  echo $ac_n "checking whether getpgrp takes no argument""... $ac_c" 1>&6
! echo "configure:1824: checking whether getpgrp takes no argument" >&5
  if eval "test \"`echo '$''{'ac_cv_func_getpgrp_void'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
***************
*** 1816,1820 ****
  else
    cat > conftest.$ac_ext <<EOF
! #line 1819 "configure"
  #include "confdefs.h"
  
--- 1829,1833 ----
  else
    cat > conftest.$ac_ext <<EOF
! #line 1832 "configure"
  #include "confdefs.h"
  
***************
*** 1871,1875 ****
  
  EOF
! if { (eval echo configure:1874: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
  then
    ac_cv_func_getpgrp_void=yes
--- 1884,1888 ----
  
  EOF
! if { (eval echo configure:1887: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
  then
    ac_cv_func_getpgrp_void=yes
***************
*** 1895,1899 ****
  
  echo $ac_n "checking whether setvbuf arguments are reversed""... $ac_c" 1>&6
! echo "configure:1898: checking whether setvbuf arguments are reversed" >&5
  if eval "test \"`echo '$''{'ac_cv_func_setvbuf_reversed'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
--- 1908,1912 ----
  
  echo $ac_n "checking whether setvbuf arguments are reversed""... $ac_c" 1>&6
! echo "configure:1911: checking whether setvbuf arguments are reversed" >&5
  if eval "test \"`echo '$''{'ac_cv_func_setvbuf_reversed'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
***************
*** 1903,1907 ****
  else
    cat > conftest.$ac_ext <<EOF
! #line 1906 "configure"
  #include "confdefs.h"
  #include <stdio.h>
--- 1916,1920 ----
  else
    cat > conftest.$ac_ext <<EOF
! #line 1919 "configure"
  #include "confdefs.h"
  #include <stdio.h>
***************
*** 1917,1921 ****
  }
  EOF
! if { (eval echo configure:1920: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
  then
    ac_cv_func_setvbuf_reversed=yes
--- 1930,1934 ----
  }
  EOF
! if { (eval echo configure:1933: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
  then
    ac_cv_func_setvbuf_reversed=yes
***************
*** 1941,1950 ****
  
  echo $ac_n "checking for vprintf""... $ac_c" 1>&6
! echo "configure:1944: checking for vprintf" >&5
  if eval "test \"`echo '$''{'ac_cv_func_vprintf'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 1949 "configure"
  #include "confdefs.h"
  /* System header to define __stub macros and hopefully few prototypes,
--- 1954,1963 ----
  
  echo $ac_n "checking for vprintf""... $ac_c" 1>&6
! echo "configure:1957: checking for vprintf" >&5
  if eval "test \"`echo '$''{'ac_cv_func_vprintf'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 1962 "configure"
  #include "confdefs.h"
  /* System header to define __stub macros and hopefully few prototypes,
***************
*** 1969,1973 ****
  ; return 0; }
  EOF
! if { (eval echo configure:1972: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
    rm -rf conftest*
    eval "ac_cv_func_vprintf=yes"
--- 1982,1986 ----
  ; return 0; }
  EOF
! if { (eval echo configure:1985: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
    rm -rf conftest*
    eval "ac_cv_func_vprintf=yes"
***************
*** 1993,2002 ****
  if test "$ac_cv_func_vprintf" != yes; then
  echo $ac_n "checking for _doprnt""... $ac_c" 1>&6
! echo "configure:1996: checking for _doprnt" >&5
  if eval "test \"`echo '$''{'ac_cv_func__doprnt'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 2001 "configure"
  #include "confdefs.h"
  /* System header to define __stub macros and hopefully few prototypes,
--- 2006,2015 ----
  if test "$ac_cv_func_vprintf" != yes; then
  echo $ac_n "checking for _doprnt""... $ac_c" 1>&6
! echo "configure:2009: checking for _doprnt" >&5
  if eval "test \"`echo '$''{'ac_cv_func__doprnt'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 2014 "configure"
  #include "confdefs.h"
  /* System header to define __stub macros and hopefully few prototypes,
***************
*** 2021,2025 ****
  ; return 0; }
  EOF
! if { (eval echo configure:2024: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
    rm -rf conftest*
    eval "ac_cv_func__doprnt=yes"
--- 2034,2038 ----
  ; return 0; }
  EOF
! if { (eval echo configure:2037: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
    rm -rf conftest*
    eval "ac_cv_func__doprnt=yes"
***************
*** 2046,2050 ****
  
  echo $ac_n "checking for wait3 that fills in rusage""... $ac_c" 1>&6
! echo "configure:2049: checking for wait3 that fills in rusage" >&5
  if eval "test \"`echo '$''{'ac_cv_func_wait3_rusage'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
--- 2059,2063 ----
  
  echo $ac_n "checking for wait3 that fills in rusage""... $ac_c" 1>&6
! echo "configure:2062: checking for wait3 that fills in rusage" >&5
  if eval "test \"`echo '$''{'ac_cv_func_wait3_rusage'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
***************
*** 2054,2058 ****
  else
    cat > conftest.$ac_ext <<EOF
! #line 2057 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
--- 2067,2071 ----
  else
    cat > conftest.$ac_ext <<EOF
! #line 2070 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
***************
*** 2085,2089 ****
  }
  EOF
! if { (eval echo configure:2088: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
  then
    ac_cv_func_wait3_rusage=yes
--- 2098,2102 ----
  }
  EOF
! if { (eval echo configure:2101: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
  then
    ac_cv_func_wait3_rusage=yes
***************
*** 2108,2112 ****
  
  echo $ac_n "checking for working strcoll""... $ac_c" 1>&6
! echo "configure:2111: checking for working strcoll" >&5
  if eval "test \"`echo '$''{'ac_cv_func_strcoll_works'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
--- 2121,2125 ----
  
  echo $ac_n "checking for working strcoll""... $ac_c" 1>&6
! echo "configure:2124: checking for working strcoll" >&5
  if eval "test \"`echo '$''{'ac_cv_func_strcoll_works'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
***************
*** 2116,2120 ****
  else
    cat > conftest.$ac_ext <<EOF
! #line 2119 "configure"
  #include "confdefs.h"
  #include <string.h>
--- 2129,2133 ----
  else
    cat > conftest.$ac_ext <<EOF
! #line 2132 "configure"
  #include "confdefs.h"
  #include <string.h>
***************
*** 2126,2130 ****
  }
  EOF
! if { (eval echo configure:2129: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
  then
    ac_cv_func_strcoll_works=yes
--- 2139,2143 ----
  }
  EOF
! if { (eval echo configure:2142: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
  then
    ac_cv_func_strcoll_works=yes
***************
*** 2151,2157 ****
  if test "$ac_cv_func_vprintf" = no; then
      echo $ac_n "checking for declaration of vprintf in stdio.h""... $ac_c" 1>&6
! echo "configure:2154: checking for declaration of vprintf in stdio.h" >&5
      cat > conftest.$ac_ext <<EOF
! #line 2156 "configure"
  #include "confdefs.h"
  #include <stdio.h>
--- 2164,2170 ----
  if test "$ac_cv_func_vprintf" = no; then
      echo $ac_n "checking for declaration of vprintf in stdio.h""... $ac_c" 1>&6
! echo "configure:2167: checking for declaration of vprintf in stdio.h" >&5
      cat > conftest.$ac_ext <<EOF
! #line 2169 "configure"
  #include "confdefs.h"
  #include <stdio.h>
***************
*** 2174,2183 ****
  
  echo $ac_n "checking return type of signal handlers""... $ac_c" 1>&6
! echo "configure:2177: checking return type of signal handlers" >&5
  if eval "test \"`echo '$''{'ac_cv_type_signal'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 2182 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
--- 2187,2196 ----
  
  echo $ac_n "checking return type of signal handlers""... $ac_c" 1>&6
! echo "configure:2190: checking return type of signal handlers" >&5
  if eval "test \"`echo '$''{'ac_cv_type_signal'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 2195 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
***************
*** 2196,2200 ****
  ; return 0; }
  EOF
! if { (eval echo configure:2199: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
    rm -rf conftest*
    ac_cv_type_signal=void
--- 2209,2213 ----
  ; return 0; }
  EOF
! if { (eval echo configure:2212: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
    rm -rf conftest*
    ac_cv_type_signal=void
***************
*** 2216,2225 ****
  
  echo $ac_n "checking for __setostype""... $ac_c" 1>&6
! echo "configure:2219: checking for __setostype" >&5
  if eval "test \"`echo '$''{'ac_cv_func___setostype'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 2224 "configure"
  #include "confdefs.h"
  /* System header to define __stub macros and hopefully few prototypes,
--- 2229,2238 ----
  
  echo $ac_n "checking for __setostype""... $ac_c" 1>&6
! echo "configure:2232: checking for __setostype" >&5
  if eval "test \"`echo '$''{'ac_cv_func___setostype'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 2237 "configure"
  #include "confdefs.h"
  /* System header to define __stub macros and hopefully few prototypes,
***************
*** 2244,2248 ****
  ; return 0; }
  EOF
! if { (eval echo configure:2247: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
    rm -rf conftest*
    eval "ac_cv_func___setostype=yes"
--- 2257,2261 ----
  ; return 0; }
  EOF
! if { (eval echo configure:2260: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
    rm -rf conftest*
    eval "ac_cv_func___setostype=yes"
***************
*** 2267,2276 ****
  
  echo $ac_n "checking for wait3""... $ac_c" 1>&6
! echo "configure:2270: checking for wait3" >&5
  if eval "test \"`echo '$''{'ac_cv_func_wait3'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 2275 "configure"
  #include "confdefs.h"
  /* System header to define __stub macros and hopefully few prototypes,
--- 2280,2289 ----
  
  echo $ac_n "checking for wait3""... $ac_c" 1>&6
! echo "configure:2283: checking for wait3" >&5
  if eval "test \"`echo '$''{'ac_cv_func_wait3'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 2288 "configure"
  #include "confdefs.h"
  /* System header to define __stub macros and hopefully few prototypes,
***************
*** 2295,2299 ****
  ; return 0; }
  EOF
! if { (eval echo configure:2298: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
    rm -rf conftest*
    eval "ac_cv_func_wait3=yes"
--- 2308,2312 ----
  ; return 0; }
  EOF
! if { (eval echo configure:2311: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
    rm -rf conftest*
    eval "ac_cv_func_wait3=yes"
***************
*** 2319,2328 ****
  
  echo $ac_n "checking for mkfifo""... $ac_c" 1>&6
! echo "configure:2322: checking for mkfifo" >&5
  if eval "test \"`echo '$''{'ac_cv_func_mkfifo'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 2327 "configure"
  #include "confdefs.h"
  /* System header to define __stub macros and hopefully few prototypes,
--- 2332,2341 ----
  
  echo $ac_n "checking for mkfifo""... $ac_c" 1>&6
! echo "configure:2335: checking for mkfifo" >&5
  if eval "test \"`echo '$''{'ac_cv_func_mkfifo'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 2340 "configure"
  #include "confdefs.h"
  /* System header to define __stub macros and hopefully few prototypes,
***************
*** 2347,2351 ****
  ; return 0; }
  EOF
! if { (eval echo configure:2350: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
    rm -rf conftest*
    eval "ac_cv_func_mkfifo=yes"
--- 2360,2364 ----
  ; return 0; }
  EOF
! if { (eval echo configure:2363: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
    rm -rf conftest*
    eval "ac_cv_func_mkfifo=yes"
***************
*** 2379,2388 ****
  do
  echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
! echo "configure:2382: checking for $ac_func" >&5
  if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 2387 "configure"
  #include "confdefs.h"
  /* System header to define __stub macros and hopefully few prototypes,
--- 2392,2401 ----
  do
  echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
! echo "configure:2395: checking for $ac_func" >&5
  if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 2400 "configure"
  #include "confdefs.h"
  /* System header to define __stub macros and hopefully few prototypes,
***************
*** 2407,2411 ****
  ; return 0; }
  EOF
! if { (eval echo configure:2410: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
    rm -rf conftest*
    eval "ac_cv_func_$ac_func=yes"
--- 2420,2424 ----
  ; return 0; }
  EOF
! if { (eval echo configure:2423: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
    rm -rf conftest*
    eval "ac_cv_func_$ac_func=yes"
***************
*** 2437,2446 ****
  do
  echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
! echo "configure:2440: checking for $ac_func" >&5
  if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 2445 "configure"
  #include "confdefs.h"
  /* System header to define __stub macros and hopefully few prototypes,
--- 2450,2459 ----
  do
  echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
! echo "configure:2453: checking for $ac_func" >&5
  if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 2458 "configure"
  #include "confdefs.h"
  /* System header to define __stub macros and hopefully few prototypes,
***************
*** 2465,2469 ****
  ; return 0; }
  EOF
! if { (eval echo configure:2468: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
    rm -rf conftest*
    eval "ac_cv_func_$ac_func=yes"
--- 2478,2482 ----
  ; return 0; }
  EOF
! if { (eval echo configure:2481: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
    rm -rf conftest*
    eval "ac_cv_func_$ac_func=yes"
***************
*** 2494,2508 ****
  ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
  echo $ac_n "checking for $ac_hdr""... $ac_c" 1>&6
! echo "configure:2497: checking for $ac_hdr" >&5
  if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 2502 "configure"
  #include "confdefs.h"
  #include <$ac_hdr>
  EOF
  ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
! { (eval echo configure:2507: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
  ac_err=`grep -v '^ *+' conftest.out`
  if test -z "$ac_err"; then
--- 2507,2521 ----
  ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
  echo $ac_n "checking for $ac_hdr""... $ac_c" 1>&6
! echo "configure:2510: checking for $ac_hdr" >&5
  if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 2515 "configure"
  #include "confdefs.h"
  #include <$ac_hdr>
  EOF
  ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
! { (eval echo configure:2520: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
  ac_err=`grep -v '^ *+' conftest.out`
  if test -z "$ac_err"; then
***************
*** 2533,2542 ****
  do
  echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
! echo "configure:2536: checking for $ac_func" >&5
  if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 2541 "configure"
  #include "confdefs.h"
  /* System header to define __stub macros and hopefully few prototypes,
--- 2546,2555 ----
  do
  echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
! echo "configure:2549: checking for $ac_func" >&5
  if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 2554 "configure"
  #include "confdefs.h"
  /* System header to define __stub macros and hopefully few prototypes,
***************
*** 2561,2565 ****
  ; return 0; }
  EOF
! if { (eval echo configure:2564: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
    rm -rf conftest*
    eval "ac_cv_func_$ac_func=yes"
--- 2574,2578 ----
  ; return 0; }
  EOF
! if { (eval echo configure:2577: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
    rm -rf conftest*
    eval "ac_cv_func_$ac_func=yes"
***************
*** 2588,2592 ****
  if test "$ac_cv_func_bindtextdomain" = "no"; then
      echo $ac_n "checking for bindtextdomain in -lintl""... $ac_c" 1>&6
! echo "configure:2591: checking for bindtextdomain in -lintl" >&5
  ac_lib_var=`echo intl'_'bindtextdomain | sed 'y%./+-%__p_%'`
  if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
--- 2601,2605 ----
  if test "$ac_cv_func_bindtextdomain" = "no"; then
      echo $ac_n "checking for bindtextdomain in -lintl""... $ac_c" 1>&6
! echo "configure:2604: checking for bindtextdomain in -lintl" >&5
  ac_lib_var=`echo intl'_'bindtextdomain | sed 'y%./+-%__p_%'`
  if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
***************
*** 2596,2600 ****
  LIBS="-lintl  $LIBS"
  cat > conftest.$ac_ext <<EOF
! #line 2599 "configure"
  #include "confdefs.h"
  /* Override any gcc2 internal prototype to avoid an error.  */
--- 2609,2613 ----
  LIBS="-lintl  $LIBS"
  cat > conftest.$ac_ext <<EOF
! #line 2612 "configure"
  #include "confdefs.h"
  /* Override any gcc2 internal prototype to avoid an error.  */
***************
*** 2607,2611 ****
  ; return 0; }
  EOF
! if { (eval echo configure:2610: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
    rm -rf conftest*
    eval "ac_cv_lib_$ac_lib_var=yes"
--- 2620,2624 ----
  ; return 0; }
  EOF
! if { (eval echo configure:2623: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
    rm -rf conftest*
    eval "ac_cv_lib_$ac_lib_var=yes"
***************
*** 2638,2647 ****
  do
  echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
! echo "configure:2641: checking for $ac_func" >&5
  if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 2646 "configure"
  #include "confdefs.h"
  /* System header to define __stub macros and hopefully few prototypes,
--- 2651,2660 ----
  do
  echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
! echo "configure:2654: checking for $ac_func" >&5
  if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 2659 "configure"
  #include "confdefs.h"
  /* System header to define __stub macros and hopefully few prototypes,
***************
*** 2666,2670 ****
  ; return 0; }
  EOF
! if { (eval echo configure:2669: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
    rm -rf conftest*
    eval "ac_cv_func_$ac_func=yes"
--- 2679,2683 ----
  ; return 0; }
  EOF
! if { (eval echo configure:2682: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
    rm -rf conftest*
    eval "ac_cv_func_$ac_func=yes"
***************
*** 2694,2698 ****
  
  echo $ac_n "checking for dlopen in -ldl""... $ac_c" 1>&6
! echo "configure:2697: checking for dlopen in -ldl" >&5
  ac_lib_var=`echo dl'_'dlopen | sed 'y%./+-%__p_%'`
  if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
--- 2707,2711 ----
  
  echo $ac_n "checking for dlopen in -ldl""... $ac_c" 1>&6
! echo "configure:2710: checking for dlopen in -ldl" >&5
  ac_lib_var=`echo dl'_'dlopen | sed 'y%./+-%__p_%'`
  if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
***************
*** 2702,2706 ****
  LIBS="-ldl  $LIBS"
  cat > conftest.$ac_ext <<EOF
! #line 2705 "configure"
  #include "confdefs.h"
  /* Override any gcc2 internal prototype to avoid an error.  */
--- 2715,2719 ----
  LIBS="-ldl  $LIBS"
  cat > conftest.$ac_ext <<EOF
! #line 2718 "configure"
  #include "confdefs.h"
  /* Override any gcc2 internal prototype to avoid an error.  */
***************
*** 2713,2717 ****
  ; return 0; }
  EOF
! if { (eval echo configure:2716: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
    rm -rf conftest*
    eval "ac_cv_lib_$ac_lib_var=yes"
--- 2726,2730 ----
  ; return 0; }
  EOF
! if { (eval echo configure:2729: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
    rm -rf conftest*
    eval "ac_cv_lib_$ac_lib_var=yes"
***************
*** 2743,2752 ****
  do
  echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
! echo "configure:2746: checking for $ac_func" >&5
  if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 2751 "configure"
  #include "confdefs.h"
  /* System header to define __stub macros and hopefully few prototypes,
--- 2756,2765 ----
  do
  echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
! echo "configure:2759: checking for $ac_func" >&5
  if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 2764 "configure"
  #include "confdefs.h"
  /* System header to define __stub macros and hopefully few prototypes,
***************
*** 2771,2775 ****
  ; return 0; }
  EOF
! if { (eval echo configure:2774: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
    rm -rf conftest*
    eval "ac_cv_func_$ac_func=yes"
--- 2784,2788 ----
  ; return 0; }
  EOF
! if { (eval echo configure:2787: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
    rm -rf conftest*
    eval "ac_cv_func_$ac_func=yes"
***************
*** 2797,2806 ****
  
  echo $ac_n "checking for sys_siglist declaration in signal.h or unistd.h""... $ac_c" 1>&6
! echo "configure:2800: checking for sys_siglist declaration in signal.h or unistd.h" >&5
  if eval "test \"`echo '$''{'ac_cv_decl_sys_siglist'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 2805 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
--- 2810,2819 ----
  
  echo $ac_n "checking for sys_siglist declaration in signal.h or unistd.h""... $ac_c" 1>&6
! echo "configure:2813: checking for sys_siglist declaration in signal.h or unistd.h" >&5
  if eval "test \"`echo '$''{'ac_cv_decl_sys_siglist'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 2818 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
***************
*** 2814,2818 ****
  ; return 0; }
  EOF
! if { (eval echo configure:2817: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
    rm -rf conftest*
    ac_cv_decl_sys_siglist=yes
--- 2827,2831 ----
  ; return 0; }
  EOF
! if { (eval echo configure:2830: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
    rm -rf conftest*
    ac_cv_decl_sys_siglist=yes
***************
*** 2840,2849 ****
  ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
  echo $ac_n "checking for $ac_hdr that defines DIR""... $ac_c" 1>&6
! echo "configure:2843: checking for $ac_hdr that defines DIR" >&5
  if eval "test \"`echo '$''{'ac_cv_header_dirent_$ac_safe'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 2848 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
--- 2853,2862 ----
  ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
  echo $ac_n "checking for $ac_hdr that defines DIR""... $ac_c" 1>&6
! echo "configure:2856: checking for $ac_hdr that defines DIR" >&5
  if eval "test \"`echo '$''{'ac_cv_header_dirent_$ac_safe'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 2861 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
***************
*** 2853,2857 ****
  ; return 0; }
  EOF
! if { (eval echo configure:2856: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
    rm -rf conftest*
    eval "ac_cv_header_dirent_$ac_safe=yes"
--- 2866,2870 ----
  ; return 0; }
  EOF
! if { (eval echo configure:2869: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
    rm -rf conftest*
    eval "ac_cv_header_dirent_$ac_safe=yes"
***************
*** 2878,2882 ****
  if test $ac_header_dirent = dirent.h; then
  echo $ac_n "checking for opendir in -ldir""... $ac_c" 1>&6
! echo "configure:2881: checking for opendir in -ldir" >&5
  ac_lib_var=`echo dir'_'opendir | sed 'y%./+-%__p_%'`
  if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
--- 2891,2895 ----
  if test $ac_header_dirent = dirent.h; then
  echo $ac_n "checking for opendir in -ldir""... $ac_c" 1>&6
! echo "configure:2894: checking for opendir in -ldir" >&5
  ac_lib_var=`echo dir'_'opendir | sed 'y%./+-%__p_%'`
  if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
***************
*** 2886,2890 ****
  LIBS="-ldir  $LIBS"
  cat > conftest.$ac_ext <<EOF
! #line 2889 "configure"
  #include "confdefs.h"
  /* Override any gcc2 internal prototype to avoid an error.  */
--- 2899,2903 ----
  LIBS="-ldir  $LIBS"
  cat > conftest.$ac_ext <<EOF
! #line 2902 "configure"
  #include "confdefs.h"
  /* Override any gcc2 internal prototype to avoid an error.  */
***************
*** 2897,2901 ****
  ; return 0; }
  EOF
! if { (eval echo configure:2900: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
    rm -rf conftest*
    eval "ac_cv_lib_$ac_lib_var=yes"
--- 2910,2914 ----
  ; return 0; }
  EOF
! if { (eval echo configure:2913: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
    rm -rf conftest*
    eval "ac_cv_lib_$ac_lib_var=yes"
***************
*** 2919,2923 ****
  else
  echo $ac_n "checking for opendir in -lx""... $ac_c" 1>&6
! echo "configure:2922: checking for opendir in -lx" >&5
  ac_lib_var=`echo x'_'opendir | sed 'y%./+-%__p_%'`
  if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
--- 2932,2936 ----
  else
  echo $ac_n "checking for opendir in -lx""... $ac_c" 1>&6
! echo "configure:2935: checking for opendir in -lx" >&5
  ac_lib_var=`echo x'_'opendir | sed 'y%./+-%__p_%'`
  if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
***************
*** 2927,2931 ****
  LIBS="-lx  $LIBS"
  cat > conftest.$ac_ext <<EOF
! #line 2930 "configure"
  #include "confdefs.h"
  /* Override any gcc2 internal prototype to avoid an error.  */
--- 2940,2944 ----
  LIBS="-lx  $LIBS"
  cat > conftest.$ac_ext <<EOF
! #line 2943 "configure"
  #include "confdefs.h"
  /* Override any gcc2 internal prototype to avoid an error.  */
***************
*** 2938,2942 ****
  ; return 0; }
  EOF
! if { (eval echo configure:2941: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
    rm -rf conftest*
    eval "ac_cv_lib_$ac_lib_var=yes"
--- 2951,2955 ----
  ; return 0; }
  EOF
! if { (eval echo configure:2954: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
    rm -rf conftest*
    eval "ac_cv_lib_$ac_lib_var=yes"
***************
*** 2961,2970 ****
  
  echo $ac_n "checking whether time.h and sys/time.h may both be included""... $ac_c" 1>&6
! echo "configure:2964: checking whether time.h and sys/time.h may both be included" >&5
  if eval "test \"`echo '$''{'ac_cv_header_time'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 2969 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
--- 2974,2983 ----
  
  echo $ac_n "checking whether time.h and sys/time.h may both be included""... $ac_c" 1>&6
! echo "configure:2977: checking whether time.h and sys/time.h may both be included" >&5
  if eval "test \"`echo '$''{'ac_cv_header_time'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 2982 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
***************
*** 2975,2979 ****
  ; return 0; }
  EOF
! if { (eval echo configure:2978: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
    rm -rf conftest*
    ac_cv_header_time=yes
--- 2988,2992 ----
  ; return 0; }
  EOF
! if { (eval echo configure:2991: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
    rm -rf conftest*
    ac_cv_header_time=yes
***************
*** 2997,3015 ****
  
  for ac_hdr in unistd.h stdlib.h stdarg.h varargs.h limits.h string.h \
! 		 memory.h locale.h termcap.h termio.h termios.h
  do
  ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
  echo $ac_n "checking for $ac_hdr""... $ac_c" 1>&6
! echo "configure:3004: checking for $ac_hdr" >&5
  if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 3009 "configure"
  #include "confdefs.h"
  #include <$ac_hdr>
  EOF
  ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
! { (eval echo configure:3014: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
  ac_err=`grep -v '^ *+' conftest.out`
  if test -z "$ac_err"; then
--- 3010,3028 ----
  
  for ac_hdr in unistd.h stdlib.h stdarg.h varargs.h limits.h string.h \
! 		 memory.h locale.h termcap.h termio.h termios.h dlfcn.h
  do
  ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
  echo $ac_n "checking for $ac_hdr""... $ac_c" 1>&6
! echo "configure:3017: checking for $ac_hdr" >&5
  if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 3022 "configure"
  #include "confdefs.h"
  #include <$ac_hdr>
  EOF
  ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
! { (eval echo configure:3027: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
  ac_err=`grep -v '^ *+' conftest.out`
  if test -z "$ac_err"; then
***************
*** 3043,3057 ****
  ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
  echo $ac_n "checking for $ac_hdr""... $ac_c" 1>&6
! echo "configure:3046: checking for $ac_hdr" >&5
  if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 3051 "configure"
  #include "confdefs.h"
  #include <$ac_hdr>
  EOF
  ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
! { (eval echo configure:3056: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
  ac_err=`grep -v '^ *+' conftest.out`
  if test -z "$ac_err"; then
--- 3056,3070 ----
  ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
  echo $ac_n "checking for $ac_hdr""... $ac_c" 1>&6
! echo "configure:3059: checking for $ac_hdr" >&5
  if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 3064 "configure"
  #include "confdefs.h"
  #include <$ac_hdr>
  EOF
  ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
! { (eval echo configure:3069: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
  ac_err=`grep -v '^ *+' conftest.out`
  if test -z "$ac_err"; then
***************
*** 3080,3089 ****
  
  
! 
  if test "X$bash_cv_have_socklib" = "X"; then
  _bash_needmsg=
  else
  echo $ac_n "checking for socket library""... $ac_c" 1>&6
! echo "configure:3088: checking for socket library" >&5
  _bash_needmsg=yes
  fi
--- 3093,3103 ----
  
  
! if test "$ac_cv_func_getpeername" = no; then
! 	
  if test "X$bash_cv_have_socklib" = "X"; then
  _bash_needmsg=
  else
  echo $ac_n "checking for socket library""... $ac_c" 1>&6
! echo "configure:3102: checking for socket library" >&5
  _bash_needmsg=yes
  fi
***************
*** 3092,3096 ****
  else
    echo $ac_n "checking for getpeername in -lsocket""... $ac_c" 1>&6
! echo "configure:3095: checking for getpeername in -lsocket" >&5
  ac_lib_var=`echo socket'_'getpeername | sed 'y%./+-%__p_%'`
  if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
--- 3106,3110 ----
  else
    echo $ac_n "checking for getpeername in -lsocket""... $ac_c" 1>&6
! echo "configure:3109: checking for getpeername in -lsocket" >&5
  ac_lib_var=`echo socket'_'getpeername | sed 'y%./+-%__p_%'`
  if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
***************
*** 3100,3104 ****
  LIBS="-lsocket -lnsl $LIBS"
  cat > conftest.$ac_ext <<EOF
! #line 3103 "configure"
  #include "confdefs.h"
  /* Override any gcc2 internal prototype to avoid an error.  */
--- 3114,3118 ----
  LIBS="-lsocket -lnsl $LIBS"
  cat > conftest.$ac_ext <<EOF
! #line 3117 "configure"
  #include "confdefs.h"
  /* Override any gcc2 internal prototype to avoid an error.  */
***************
*** 3111,3115 ****
  ; return 0; }
  EOF
! if { (eval echo configure:3114: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
    rm -rf conftest*
    eval "ac_cv_lib_$ac_lib_var=yes"
--- 3125,3129 ----
  ; return 0; }
  EOF
! if { (eval echo configure:3128: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
    rm -rf conftest*
    eval "ac_cv_lib_$ac_lib_var=yes"
***************
*** 3144,3148 ****
    else
      echo $ac_n "checking for libnsl""... $ac_c" 1>&6
! echo "configure:3147: checking for libnsl" >&5
      _bash_needmsg=yes
    fi
--- 3158,3162 ----
    else
      echo $ac_n "checking for libnsl""... $ac_c" 1>&6
! echo "configure:3161: checking for libnsl" >&5
      _bash_needmsg=yes
    fi
***************
*** 3151,3155 ****
  else
    echo $ac_n "checking for t_open in -lnsl""... $ac_c" 1>&6
! echo "configure:3154: checking for t_open in -lnsl" >&5
  ac_lib_var=`echo nsl'_'t_open | sed 'y%./+-%__p_%'`
  if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
--- 3165,3169 ----
  else
    echo $ac_n "checking for t_open in -lnsl""... $ac_c" 1>&6
! echo "configure:3168: checking for t_open in -lnsl" >&5
  ac_lib_var=`echo nsl'_'t_open | sed 'y%./+-%__p_%'`
  if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
***************
*** 3159,3163 ****
  LIBS="-lnsl  $LIBS"
  cat > conftest.$ac_ext <<EOF
! #line 3162 "configure"
  #include "confdefs.h"
  /* Override any gcc2 internal prototype to avoid an error.  */
--- 3173,3177 ----
  LIBS="-lnsl  $LIBS"
  cat > conftest.$ac_ext <<EOF
! #line 3176 "configure"
  #include "confdefs.h"
  /* Override any gcc2 internal prototype to avoid an error.  */
***************
*** 3170,3174 ****
  ; return 0; }
  EOF
! if { (eval echo configure:3173: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
    rm -rf conftest*
    eval "ac_cv_lib_$ac_lib_var=yes"
--- 3184,3188 ----
  ; return 0; }
  EOF
! if { (eval echo configure:3187: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
    rm -rf conftest*
    eval "ac_cv_lib_$ac_lib_var=yes"
***************
*** 3212,3223 ****
  fi
  
  
  echo $ac_n "checking for uid_t in sys/types.h""... $ac_c" 1>&6
! echo "configure:3217: checking for uid_t in sys/types.h" >&5
  if eval "test \"`echo '$''{'ac_cv_type_uid_t'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 3222 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
--- 3226,3238 ----
  fi
  
+ fi
  
  echo $ac_n "checking for uid_t in sys/types.h""... $ac_c" 1>&6
! echo "configure:3232: checking for uid_t in sys/types.h" >&5
  if eval "test \"`echo '$''{'ac_cv_type_uid_t'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 3237 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
***************
*** 3248,3252 ****
  
  echo $ac_n "checking type of array argument to getgroups""... $ac_c" 1>&6
! echo "configure:3251: checking type of array argument to getgroups" >&5
  if eval "test \"`echo '$''{'ac_cv_type_getgroups'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
--- 3263,3267 ----
  
  echo $ac_n "checking type of array argument to getgroups""... $ac_c" 1>&6
! echo "configure:3266: checking type of array argument to getgroups" >&5
  if eval "test \"`echo '$''{'ac_cv_type_getgroups'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
***************
*** 3256,3260 ****
  else
    cat > conftest.$ac_ext <<EOF
! #line 3259 "configure"
  #include "confdefs.h"
  
--- 3271,3275 ----
  else
    cat > conftest.$ac_ext <<EOF
! #line 3274 "configure"
  #include "confdefs.h"
  
***************
*** 3281,3285 ****
  
  EOF
! if { (eval echo configure:3284: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
  then
      ac_cv_type_getgroups=gid_t
--- 3296,3300 ----
  
  EOF
! if { (eval echo configure:3299: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
  then
      ac_cv_type_getgroups=gid_t
***************
*** 3295,3299 ****
  if test $ac_cv_type_getgroups = cross; then
          cat > conftest.$ac_ext <<EOF
! #line 3298 "configure"
  #include "confdefs.h"
  #include <unistd.h>
--- 3310,3314 ----
  if test $ac_cv_type_getgroups = cross; then
          cat > conftest.$ac_ext <<EOF
! #line 3313 "configure"
  #include "confdefs.h"
  #include <unistd.h>
***************
*** 3319,3328 ****
  
  echo $ac_n "checking for ANSI C header files""... $ac_c" 1>&6
! echo "configure:3322: checking for ANSI C header files" >&5
  if eval "test \"`echo '$''{'ac_cv_header_stdc'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 3327 "configure"
  #include "confdefs.h"
  #include <stdlib.h>
--- 3334,3343 ----
  
  echo $ac_n "checking for ANSI C header files""... $ac_c" 1>&6
! echo "configure:3337: checking for ANSI C header files" >&5
  if eval "test \"`echo '$''{'ac_cv_header_stdc'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 3342 "configure"
  #include "confdefs.h"
  #include <stdlib.h>
***************
*** 3332,3336 ****
  EOF
  ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
! { (eval echo configure:3335: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
  ac_err=`grep -v '^ *+' conftest.out`
  if test -z "$ac_err"; then
--- 3347,3351 ----
  EOF
  ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
! { (eval echo configure:3350: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
  ac_err=`grep -v '^ *+' conftest.out`
  if test -z "$ac_err"; then
***************
*** 3349,3353 ****
    # SunOS 4.x string.h does not declare mem*, contrary to ANSI.
  cat > conftest.$ac_ext <<EOF
! #line 3352 "configure"
  #include "confdefs.h"
  #include <string.h>
--- 3364,3368 ----
    # SunOS 4.x string.h does not declare mem*, contrary to ANSI.
  cat > conftest.$ac_ext <<EOF
! #line 3367 "configure"
  #include "confdefs.h"
  #include <string.h>
***************
*** 3367,3371 ****
    # ISC 2.0.2 stdlib.h does not declare free, contrary to ANSI.
  cat > conftest.$ac_ext <<EOF
! #line 3370 "configure"
  #include "confdefs.h"
  #include <stdlib.h>
--- 3382,3386 ----
    # ISC 2.0.2 stdlib.h does not declare free, contrary to ANSI.
  cat > conftest.$ac_ext <<EOF
! #line 3385 "configure"
  #include "confdefs.h"
  #include <stdlib.h>
***************
*** 3388,3392 ****
  else
    cat > conftest.$ac_ext <<EOF
! #line 3391 "configure"
  #include "confdefs.h"
  #include <ctype.h>
--- 3403,3407 ----
  else
    cat > conftest.$ac_ext <<EOF
! #line 3406 "configure"
  #include "confdefs.h"
  #include <ctype.h>
***************
*** 3399,3403 ****
  
  EOF
! if { (eval echo configure:3402: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
  then
    :
--- 3414,3418 ----
  
  EOF
! if { (eval echo configure:3417: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
  then
    :
***************
*** 3423,3432 ****
  
  echo $ac_n "checking for off_t""... $ac_c" 1>&6
! echo "configure:3426: checking for off_t" >&5
  if eval "test \"`echo '$''{'ac_cv_type_off_t'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 3431 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
--- 3438,3447 ----
  
  echo $ac_n "checking for off_t""... $ac_c" 1>&6
! echo "configure:3441: checking for off_t" >&5
  if eval "test \"`echo '$''{'ac_cv_type_off_t'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 3446 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
***************
*** 3456,3465 ****
  
  echo $ac_n "checking for mode_t""... $ac_c" 1>&6
! echo "configure:3459: checking for mode_t" >&5
  if eval "test \"`echo '$''{'ac_cv_type_mode_t'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 3464 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
--- 3471,3480 ----
  
  echo $ac_n "checking for mode_t""... $ac_c" 1>&6
! echo "configure:3474: checking for mode_t" >&5
  if eval "test \"`echo '$''{'ac_cv_type_mode_t'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 3479 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
***************
*** 3489,3498 ****
  
  echo $ac_n "checking for uid_t in sys/types.h""... $ac_c" 1>&6
! echo "configure:3492: checking for uid_t in sys/types.h" >&5
  if eval "test \"`echo '$''{'ac_cv_type_uid_t'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 3497 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
--- 3504,3513 ----
  
  echo $ac_n "checking for uid_t in sys/types.h""... $ac_c" 1>&6
! echo "configure:3507: checking for uid_t in sys/types.h" >&5
  if eval "test \"`echo '$''{'ac_cv_type_uid_t'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 3512 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
***************
*** 3523,3532 ****
  
  echo $ac_n "checking for pid_t""... $ac_c" 1>&6
! echo "configure:3526: checking for pid_t" >&5
  if eval "test \"`echo '$''{'ac_cv_type_pid_t'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 3531 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
--- 3538,3547 ----
  
  echo $ac_n "checking for pid_t""... $ac_c" 1>&6
! echo "configure:3541: checking for pid_t" >&5
  if eval "test \"`echo '$''{'ac_cv_type_pid_t'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 3546 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
***************
*** 3556,3565 ****
  
  echo $ac_n "checking for size_t""... $ac_c" 1>&6
! echo "configure:3559: checking for size_t" >&5
  if eval "test \"`echo '$''{'ac_cv_type_size_t'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 3564 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
--- 3571,3580 ----
  
  echo $ac_n "checking for size_t""... $ac_c" 1>&6
! echo "configure:3574: checking for size_t" >&5
  if eval "test \"`echo '$''{'ac_cv_type_size_t'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 3579 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
***************
*** 3589,3598 ****
  
  echo $ac_n "checking for time_t""... $ac_c" 1>&6
! echo "configure:3592: checking for time_t" >&5
  if eval "test \"`echo '$''{'ac_cv_type_time_t'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 3597 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
--- 3604,3613 ----
  
  echo $ac_n "checking for time_t""... $ac_c" 1>&6
! echo "configure:3607: checking for time_t" >&5
  if eval "test \"`echo '$''{'ac_cv_type_time_t'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 3612 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
***************
*** 3623,3632 ****
  
  echo $ac_n "checking return type of signal handlers""... $ac_c" 1>&6
! echo "configure:3626: checking return type of signal handlers" >&5
  if eval "test \"`echo '$''{'ac_cv_type_signal'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 3631 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
--- 3638,3647 ----
  
  echo $ac_n "checking return type of signal handlers""... $ac_c" 1>&6
! echo "configure:3641: checking return type of signal handlers" >&5
  if eval "test \"`echo '$''{'ac_cv_type_signal'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 3646 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
***************
*** 3645,3649 ****
  ; return 0; }
  EOF
! if { (eval echo configure:3648: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
    rm -rf conftest*
    ac_cv_type_signal=void
--- 3660,3664 ----
  ; return 0; }
  EOF
! if { (eval echo configure:3663: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
    rm -rf conftest*
    ac_cv_type_signal=void
***************
*** 3665,3674 ****
  
  echo $ac_n "checking whether stat file-mode macros are broken""... $ac_c" 1>&6
! echo "configure:3668: checking whether stat file-mode macros are broken" >&5
  if eval "test \"`echo '$''{'ac_cv_header_stat_broken'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 3673 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
--- 3680,3689 ----
  
  echo $ac_n "checking whether stat file-mode macros are broken""... $ac_c" 1>&6
! echo "configure:3683: checking whether stat file-mode macros are broken" >&5
  if eval "test \"`echo '$''{'ac_cv_header_stat_broken'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 3688 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
***************
*** 3721,3725 ****
  
  cat > conftest.$ac_ext <<EOF
! #line 3724 "configure"
  #include "confdefs.h"
  #include <sys/time.h>
--- 3736,3740 ----
  
  cat > conftest.$ac_ext <<EOF
! #line 3739 "configure"
  #include "confdefs.h"
  #include <sys/time.h>
***************
*** 3734,3738 ****
  if test -z "$bash_cv_struct_timeval"; then
  cat > conftest.$ac_ext <<EOF
! #line 3737 "configure"
  #include "confdefs.h"
  #include <time.h>
--- 3749,3753 ----
  if test -z "$bash_cv_struct_timeval"; then
  cat > conftest.$ac_ext <<EOF
! #line 3752 "configure"
  #include "confdefs.h"
  #include <time.h>
***************
*** 3757,3761 ****
  
  echo $ac_n "checking whether byte ordering is bigendian""... $ac_c" 1>&6
! echo "configure:3760: checking whether byte ordering is bigendian" >&5
  if eval "test \"`echo '$''{'ac_cv_c_bigendian'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
--- 3772,3776 ----
  
  echo $ac_n "checking whether byte ordering is bigendian""... $ac_c" 1>&6
! echo "configure:3775: checking whether byte ordering is bigendian" >&5
  if eval "test \"`echo '$''{'ac_cv_c_bigendian'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
***************
*** 3764,3768 ****
  # See if sys/param.h defines the BYTE_ORDER macro.
  cat > conftest.$ac_ext <<EOF
! #line 3767 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
--- 3779,3783 ----
  # See if sys/param.h defines the BYTE_ORDER macro.
  cat > conftest.$ac_ext <<EOF
! #line 3782 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
***************
*** 3775,3783 ****
  ; return 0; }
  EOF
! if { (eval echo configure:3778: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
    rm -rf conftest*
    # It does; now see whether it defined to BIG_ENDIAN or not.
  cat > conftest.$ac_ext <<EOF
! #line 3782 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
--- 3790,3798 ----
  ; return 0; }
  EOF
! if { (eval echo configure:3793: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
    rm -rf conftest*
    # It does; now see whether it defined to BIG_ENDIAN or not.
  cat > conftest.$ac_ext <<EOF
! #line 3797 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
***************
*** 3790,3794 ****
  ; return 0; }
  EOF
! if { (eval echo configure:3793: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
    rm -rf conftest*
    ac_cv_c_bigendian=yes
--- 3805,3809 ----
  ; return 0; }
  EOF
! if { (eval echo configure:3808: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
    rm -rf conftest*
    ac_cv_c_bigendian=yes
***************
*** 3810,3814 ****
  else
    cat > conftest.$ac_ext <<EOF
! #line 3813 "configure"
  #include "confdefs.h"
  main () {
--- 3825,3829 ----
  else
    cat > conftest.$ac_ext <<EOF
! #line 3828 "configure"
  #include "confdefs.h"
  main () {
***************
*** 3823,3827 ****
  }
  EOF
! if { (eval echo configure:3826: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
  then
    ac_cv_c_bigendian=no
--- 3838,3842 ----
  }
  EOF
! if { (eval echo configure:3841: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
  then
    ac_cv_c_bigendian=no
***************
*** 3850,3854 ****
  ac_msg="whether #! works in shell scripts"
  echo $ac_n "checking $ac_msg""... $ac_c" 1>&6
! echo "configure:3853: checking $ac_msg" >&5
  if eval "test \"`echo '$''{'ac_cv_sys_interpreter'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
--- 3865,3869 ----
  ac_msg="whether #! works in shell scripts"
  echo $ac_n "checking $ac_msg""... $ac_c" 1>&6
! echo "configure:3868: checking $ac_msg" >&5
  if eval "test \"`echo '$''{'ac_cv_sys_interpreter'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
***************
*** 3876,3880 ****
  fi
  echo $ac_n "checking for restartable system calls""... $ac_c" 1>&6
! echo "configure:3879: checking for restartable system calls" >&5
  if eval "test \"`echo '$''{'ac_cv_sys_restartable_syscalls'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
--- 3891,3895 ----
  fi
  echo $ac_n "checking for restartable system calls""... $ac_c" 1>&6
! echo "configure:3894: checking for restartable system calls" >&5
  if eval "test \"`echo '$''{'ac_cv_sys_restartable_syscalls'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
***************
*** 3884,3888 ****
  else
    cat > conftest.$ac_ext <<EOF
! #line 3887 "configure"
  #include "confdefs.h"
  /* Exit 0 (true) if wait returns something other than -1,
--- 3899,3903 ----
  else
    cat > conftest.$ac_ext <<EOF
! #line 3902 "configure"
  #include "confdefs.h"
  /* Exit 0 (true) if wait returns something other than -1,
***************
*** 3902,3906 ****
  
  EOF
! if { (eval echo configure:3905: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
  then
    ac_cv_sys_restartable_syscalls=yes
--- 3917,3921 ----
  
  EOF
! if { (eval echo configure:3920: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
  then
    ac_cv_sys_restartable_syscalls=yes
***************
*** 3927,3936 ****
  if test "$ac_cv_func_lstat" = "no"; then
  echo $ac_n "checking for lstat""... $ac_c" 1>&6
! echo "configure:3930: checking for lstat" >&5
  if eval "test \"`echo '$''{'bash_cv_func_lstat'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 3935 "configure"
  #include "confdefs.h"
  
--- 3942,3951 ----
  if test "$ac_cv_func_lstat" = "no"; then
  echo $ac_n "checking for lstat""... $ac_c" 1>&6
! echo "configure:3945: checking for lstat" >&5
  if eval "test \"`echo '$''{'bash_cv_func_lstat'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 3950 "configure"
  #include "confdefs.h"
  
***************
*** 3942,3946 ****
  ; return 0; }
  EOF
! if { (eval echo configure:3945: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
    rm -rf conftest*
    bash_cv_func_lstat=yes
--- 3957,3961 ----
  ; return 0; }
  EOF
! if { (eval echo configure:3960: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
    rm -rf conftest*
    bash_cv_func_lstat=yes
***************
*** 3965,3969 ****
  
  echo $ac_n "checking if dup2 fails to clear the close-on-exec flag""... $ac_c" 1>&6
! echo "configure:3968: checking if dup2 fails to clear the close-on-exec flag" >&5
  if eval "test \"`echo '$''{'bash_cv_dup2_broken'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
--- 3980,3984 ----
  
  echo $ac_n "checking if dup2 fails to clear the close-on-exec flag""... $ac_c" 1>&6
! echo "configure:3983: checking if dup2 fails to clear the close-on-exec flag" >&5
  if eval "test \"`echo '$''{'bash_cv_dup2_broken'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
***************
*** 3973,3977 ****
  else
    cat > conftest.$ac_ext <<EOF
! #line 3976 "configure"
  #include "confdefs.h"
  
--- 3988,3992 ----
  else
    cat > conftest.$ac_ext <<EOF
! #line 3991 "configure"
  #include "confdefs.h"
  
***************
*** 3993,3997 ****
  
  EOF
! if { (eval echo configure:3996: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
  then
    bash_cv_dup2_broken=yes
--- 4008,4012 ----
  
  EOF
! if { (eval echo configure:4011: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
  then
    bash_cv_dup2_broken=yes
***************
*** 4018,4022 ****
  
  echo $ac_n "checking whether pgrps need synchronization""... $ac_c" 1>&6
! echo "configure:4021: checking whether pgrps need synchronization" >&5
  if eval "test \"`echo '$''{'bash_cv_pgrp_pipe'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
--- 4033,4037 ----
  
  echo $ac_n "checking whether pgrps need synchronization""... $ac_c" 1>&6
! echo "configure:4036: checking whether pgrps need synchronization" >&5
  if eval "test \"`echo '$''{'bash_cv_pgrp_pipe'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
***************
*** 4026,4030 ****
  else
    cat > conftest.$ac_ext <<EOF
! #line 4029 "configure"
  #include "confdefs.h"
  
--- 4041,4045 ----
  else
    cat > conftest.$ac_ext <<EOF
! #line 4044 "configure"
  #include "confdefs.h"
  
***************
*** 4078,4082 ****
  
  EOF
! if { (eval echo configure:4081: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
  then
    bash_cv_pgrp_pipe=no
--- 4093,4097 ----
  
  EOF
! if { (eval echo configure:4096: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
  then
    bash_cv_pgrp_pipe=no
***************
*** 4101,4141 ****
  fi
  
! echo $ac_n "checking for sys_errlist and sys_nerr""... $ac_c" 1>&6
! echo "configure:4105: checking for sys_errlist and sys_nerr" >&5
! if eval "test \"`echo '$''{'bash_cv_sys_errlist'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 4110 "configure"
  #include "confdefs.h"
! #include <errno.h>
  int main() {
! extern char *sys_errlist[];
!  extern int sys_nerr;
!  char *msg = sys_errlist[sys_nerr - 1];
  ; return 0; }
  EOF
! if { (eval echo configure:4119: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
    rm -rf conftest*
!   bash_cv_sys_errlist=yes
  else
    echo "configure: failed program was:" >&5
    cat conftest.$ac_ext >&5
    rm -rf conftest*
!   bash_cv_sys_errlist=no
! fi
! rm -f conftest*
! fi
! echo "$ac_t""$bash_cv_sys_errlist" 1>&6
! if test $bash_cv_sys_errlist = yes; then
! cat >> confdefs.h <<\EOF
! #define HAVE_SYS_ERRLIST 1
! EOF
! 
! fi
! 
  
  echo $ac_n "checking for sys_siglist in system C library""... $ac_c" 1>&6
! echo "configure:4140: checking for sys_siglist in system C library" >&5
  if eval "test \"`echo '$''{'bash_cv_sys_siglist'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
--- 4116,4257 ----
  fi
  
! 
! echo $ac_n "checking for type of signal functions""... $ac_c" 1>&6
! echo "configure:4121: checking for type of signal functions" >&5
! if eval "test \"`echo '$''{'bash_cv_signal_vintage'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
+   
    cat > conftest.$ac_ext <<EOF
! #line 4127 "configure"
  #include "confdefs.h"
! #include <signal.h>
  int main() {
! 
!     sigset_t ss;
!     struct sigaction sa;
!     sigemptyset(&ss); sigsuspend(&ss);
!     sigaction(SIGINT, &sa, (struct sigaction *) 0);
!     sigprocmask(SIG_BLOCK, &ss, (sigset_t *) 0);
!   
  ; return 0; }
  EOF
! if { (eval echo configure:4140: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
    rm -rf conftest*
!   bash_cv_signal_vintage=posix
  else
    echo "configure: failed program was:" >&5
    cat conftest.$ac_ext >&5
    rm -rf conftest*
!   
!     cat > conftest.$ac_ext <<EOF
! #line 4149 "configure"
! #include "confdefs.h"
! #include <signal.h>
! int main() {
! 
! 	int mask = sigmask(SIGINT);
! 	sigsetmask(mask); sigblock(mask); sigpause(mask);
!     
! ; return 0; }
! EOF
! if { (eval echo configure:4159: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
!   rm -rf conftest*
!   bash_cv_signal_vintage=4.2bsd
! else
!   echo "configure: failed program was:" >&5
!   cat conftest.$ac_ext >&5
!   rm -rf conftest*
!   
!       cat > conftest.$ac_ext <<EOF
! #line 4168 "configure"
! #include "confdefs.h"
! 
! 	#include <signal.h>
! 	RETSIGTYPE foo() { }
! int main() {
! 
! 		int mask = sigmask(SIGINT);
! 		sigset(SIGINT, foo); sigrelse(SIGINT);
! 		sighold(SIGINT); sigpause(SIGINT);
!         
! ; return 0; }
! EOF
! if { (eval echo configure:4181: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
!   rm -rf conftest*
!   bash_cv_signal_vintage=svr3
! else
!   echo "configure: failed program was:" >&5
!   cat conftest.$ac_ext >&5
!   rm -rf conftest*
!   bash_cv_signal_vintage=v7
!     
! fi
! rm -f conftest*
!   
! fi
! rm -f conftest*
! 
! fi
! rm -f conftest*
! 
! fi
! 
! echo "$ac_t""$bash_cv_signal_vintage" 1>&6
! if test "$bash_cv_signal_vintage" = posix; then
! cat >> confdefs.h <<\EOF
! #define HAVE_POSIX_SIGNALS 1
! EOF
! 
! elif test "$bash_cv_signal_vintage" = "4.2bsd"; then
! cat >> confdefs.h <<\EOF
! #define HAVE_BSD_SIGNALS 1
! EOF
! 
! elif test "$bash_cv_signal_vintage" = svr3; then
! cat >> confdefs.h <<\EOF
! #define HAVE_USG_SIGHOLD 1
! EOF
! 
! fi
! 
! 
! echo $ac_n "checking for sys_errlist and sys_nerr""... $ac_c" 1>&6
! echo "configure:4221: checking for sys_errlist and sys_nerr" >&5
! if eval "test \"`echo '$''{'bash_cv_sys_errlist'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
! else
!   cat > conftest.$ac_ext <<EOF
! #line 4226 "configure"
! #include "confdefs.h"
! #include <errno.h>
! int main() {
! extern char *sys_errlist[];
!  extern int sys_nerr;
!  char *msg = sys_errlist[sys_nerr - 1];
! ; return 0; }
! EOF
! if { (eval echo configure:4235: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
!   rm -rf conftest*
!   bash_cv_sys_errlist=yes
! else
!   echo "configure: failed program was:" >&5
!   cat conftest.$ac_ext >&5
!   rm -rf conftest*
!   bash_cv_sys_errlist=no
! fi
! rm -f conftest*
! fi
! echo "$ac_t""$bash_cv_sys_errlist" 1>&6
! if test $bash_cv_sys_errlist = yes; then
! cat >> confdefs.h <<\EOF
! #define HAVE_SYS_ERRLIST 1
! EOF
! 
! fi
! 
  
  echo $ac_n "checking for sys_siglist in system C library""... $ac_c" 1>&6
! echo "configure:4256: checking for sys_siglist in system C library" >&5
  if eval "test \"`echo '$''{'bash_cv_sys_siglist'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
***************
*** 4145,4149 ****
  else
    cat > conftest.$ac_ext <<EOF
! #line 4148 "configure"
  #include "confdefs.h"
  
--- 4261,4265 ----
  else
    cat > conftest.$ac_ext <<EOF
! #line 4264 "configure"
  #include "confdefs.h"
  
***************
*** 4162,4166 ****
  }
  EOF
! if { (eval echo configure:4165: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
  then
    bash_cv_sys_siglist=yes
--- 4278,4282 ----
  }
  EOF
! if { (eval echo configure:4281: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
  then
    bash_cv_sys_siglist=yes
***************
*** 4184,4188 ****
  
  echo $ac_n "checking for _sys_siglist in system C library""... $ac_c" 1>&6
! echo "configure:4187: checking for _sys_siglist in system C library" >&5
  if eval "test \"`echo '$''{'bash_cv_under_sys_siglist'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
--- 4300,4304 ----
  
  echo $ac_n "checking for _sys_siglist in system C library""... $ac_c" 1>&6
! echo "configure:4303: checking for _sys_siglist in system C library" >&5
  if eval "test \"`echo '$''{'bash_cv_under_sys_siglist'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
***************
*** 4192,4196 ****
  else
    cat > conftest.$ac_ext <<EOF
! #line 4195 "configure"
  #include "confdefs.h"
  
--- 4308,4312 ----
  else
    cat > conftest.$ac_ext <<EOF
! #line 4311 "configure"
  #include "confdefs.h"
  
***************
*** 4209,4213 ****
  }
  EOF
! if { (eval echo configure:4212: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
  then
    bash_cv_under_sys_siglist=yes
--- 4325,4329 ----
  }
  EOF
! if { (eval echo configure:4328: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
  then
    bash_cv_under_sys_siglist=yes
***************
*** 4231,4340 ****
  
  
- echo $ac_n "checking for type of signal functions""... $ac_c" 1>&6
- echo "configure:4235: checking for type of signal functions" >&5
- if eval "test \"`echo '$''{'bash_cv_signal_vintage'+set}'`\" = set"; then
-   echo $ac_n "(cached) $ac_c" 1>&6
- else
-   
-   cat > conftest.$ac_ext <<EOF
- #line 4241 "configure"
- #include "confdefs.h"
- #include <signal.h>
- int main() {
- 
-     sigset_t ss;
-     struct sigaction sa;
-     sigemptyset(&ss); sigsuspend(&ss);
-     sigaction(SIGINT, &sa, (struct sigaction *) 0);
-     sigprocmask(SIG_BLOCK, &ss, (sigset_t *) 0);
-   
- ; return 0; }
- EOF
- if { (eval echo configure:4254: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
-   rm -rf conftest*
-   bash_cv_signal_vintage=posix
- else
-   echo "configure: failed program was:" >&5
-   cat conftest.$ac_ext >&5
-   rm -rf conftest*
-   
-     cat > conftest.$ac_ext <<EOF
- #line 4263 "configure"
- #include "confdefs.h"
- #include <signal.h>
- int main() {
- 
- 	int mask = sigmask(SIGINT);
- 	sigsetmask(mask); sigblock(mask); sigpause(mask);
-     
- ; return 0; }
- EOF
- if { (eval echo configure:4273: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
-   rm -rf conftest*
-   bash_cv_signal_vintage=4.2bsd
- else
-   echo "configure: failed program was:" >&5
-   cat conftest.$ac_ext >&5
-   rm -rf conftest*
-   
-       cat > conftest.$ac_ext <<EOF
- #line 4282 "configure"
- #include "confdefs.h"
- 
- 	#include <signal.h>
- 	RETSIGTYPE foo() { }
- int main() {
- 
- 		int mask = sigmask(SIGINT);
- 		sigset(SIGINT, foo); sigrelse(SIGINT);
- 		sighold(SIGINT); sigpause(SIGINT);
-         
- ; return 0; }
- EOF
- if { (eval echo configure:4295: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
-   rm -rf conftest*
-   bash_cv_signal_vintage=svr3
- else
-   echo "configure: failed program was:" >&5
-   cat conftest.$ac_ext >&5
-   rm -rf conftest*
-   bash_cv_signal_vintage=v7
-     
- fi
- rm -f conftest*
-   
- fi
- rm -f conftest*
- 
- fi
- rm -f conftest*
- 
- fi
- 
- echo "$ac_t""$bash_cv_signal_vintage" 1>&6
- if test "$bash_cv_signal_vintage" = posix; then
- cat >> confdefs.h <<\EOF
- #define HAVE_POSIX_SIGNALS 1
- EOF
- 
- elif test "$bash_cv_signal_vintage" = "4.2bsd"; then
- cat >> confdefs.h <<\EOF
- #define HAVE_BSD_SIGNALS 1
- EOF
- 
- elif test "$bash_cv_signal_vintage" = svr3; then
- cat >> confdefs.h <<\EOF
- #define HAVE_USG_SIGHOLD 1
- EOF
- 
- fi
- 
  echo $ac_n "checking whether signal handlers are of type void""... $ac_c" 1>&6
! echo "configure:4334: checking whether signal handlers are of type void" >&5
  if eval "test \"`echo '$''{'bash_cv_void_sighandler'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 4339 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
--- 4347,4357 ----
  
  
  echo $ac_n "checking whether signal handlers are of type void""... $ac_c" 1>&6
! echo "configure:4351: checking whether signal handlers are of type void" >&5
  if eval "test \"`echo '$''{'bash_cv_void_sighandler'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 4356 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
***************
*** 4351,4355 ****
  ; return 0; }
  EOF
! if { (eval echo configure:4354: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
    rm -rf conftest*
    bash_cv_void_sighandler=yes
--- 4368,4372 ----
  ; return 0; }
  EOF
! if { (eval echo configure:4371: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
    rm -rf conftest*
    bash_cv_void_sighandler=yes
***************
*** 4371,4380 ****
  
  echo $ac_n "checking for clock_t""... $ac_c" 1>&6
! echo "configure:4374: checking for clock_t" >&5
  if eval "test \"`echo '$''{'bash_cv_type_clock_t'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 4379 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
--- 4388,4397 ----
  
  echo $ac_n "checking for clock_t""... $ac_c" 1>&6
! echo "configure:4391: checking for clock_t" >&5
  if eval "test \"`echo '$''{'bash_cv_type_clock_t'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 4396 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
***************
*** 4407,4416 ****
  
  echo $ac_n "checking for sigset_t""... $ac_c" 1>&6
! echo "configure:4410: checking for sigset_t" >&5
  if eval "test \"`echo '$''{'bash_cv_type_sigset_t'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 4415 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
--- 4424,4433 ----
  
  echo $ac_n "checking for sigset_t""... $ac_c" 1>&6
! echo "configure:4427: checking for sigset_t" >&5
  if eval "test \"`echo '$''{'bash_cv_type_sigset_t'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 4432 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
***************
*** 4443,4452 ****
  
  echo $ac_n "checking for quad_t""... $ac_c" 1>&6
! echo "configure:4446: checking for quad_t" >&5
  if eval "test \"`echo '$''{'bash_cv_type_quad_t'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 4451 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
--- 4460,4469 ----
  
  echo $ac_n "checking for quad_t""... $ac_c" 1>&6
! echo "configure:4463: checking for quad_t" >&5
  if eval "test \"`echo '$''{'bash_cv_type_quad_t'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 4468 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
***************
*** 4484,4493 ****
  
  echo $ac_n "checking for size and type of struct rlimit fields""... $ac_c" 1>&6
! echo "configure:4487: checking for size and type of struct rlimit fields" >&5
  if eval "test \"`echo '$''{'bash_cv_type_rlimit'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 4492 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
--- 4501,4510 ----
  
  echo $ac_n "checking for size and type of struct rlimit fields""... $ac_c" 1>&6
! echo "configure:4504: checking for size and type of struct rlimit fields" >&5
  if eval "test \"`echo '$''{'bash_cv_type_rlimit'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 4509 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
***************
*** 4496,4500 ****
  ; return 0; }
  EOF
! if { (eval echo configure:4499: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
    rm -rf conftest*
    bash_cv_type_rlimit=rlim_t
--- 4513,4517 ----
  ; return 0; }
  EOF
! if { (eval echo configure:4516: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
    rm -rf conftest*
    bash_cv_type_rlimit=rlim_t
***************
*** 4508,4512 ****
  else
    cat > conftest.$ac_ext <<EOF
! #line 4511 "configure"
  #include "confdefs.h"
  
--- 4525,4529 ----
  else
    cat > conftest.$ac_ext <<EOF
! #line 4528 "configure"
  #include "confdefs.h"
  
***************
*** 4524,4528 ****
  }
  EOF
! if { (eval echo configure:4527: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
  then
    bash_cv_type_rlimit=quad_t
--- 4541,4545 ----
  }
  EOF
! if { (eval echo configure:4544: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
  then
    bash_cv_type_rlimit=quad_t
***************
*** 4554,4564 ****
  fi
  
  echo $ac_n "checking for a c_line member of struct termios""... $ac_c" 1>&6
! echo "configure:4558: checking for a c_line member of struct termios" >&5
  if eval "test \"`echo '$''{'bash_cv_termios_ldisc'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 4563 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
--- 4571,4582 ----
  fi
  
+ 
  echo $ac_n "checking for a c_line member of struct termios""... $ac_c" 1>&6
! echo "configure:4576: checking for a c_line member of struct termios" >&5
  if eval "test \"`echo '$''{'bash_cv_termios_ldisc'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 4581 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
***************
*** 4568,4572 ****
  ; return 0; }
  EOF
! if { (eval echo configure:4571: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
    rm -rf conftest*
    bash_cv_termios_ldisc=yes
--- 4586,4590 ----
  ; return 0; }
  EOF
! if { (eval echo configure:4589: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
    rm -rf conftest*
    bash_cv_termios_ldisc=yes
***************
*** 4588,4597 ****
  
  echo $ac_n "checking for a c_line member of struct termio""... $ac_c" 1>&6
! echo "configure:4591: checking for a c_line member of struct termio" >&5
  if eval "test \"`echo '$''{'bash_cv_termio_ldisc'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 4596 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
--- 4606,4615 ----
  
  echo $ac_n "checking for a c_line member of struct termio""... $ac_c" 1>&6
! echo "configure:4609: checking for a c_line member of struct termio" >&5
  if eval "test \"`echo '$''{'bash_cv_termio_ldisc'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 4614 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
***************
*** 4601,4605 ****
  ; return 0; }
  EOF
! if { (eval echo configure:4604: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
    rm -rf conftest*
    bash_cv_termio_ldisc=yes
--- 4619,4623 ----
  ; return 0; }
  EOF
! if { (eval echo configure:4622: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
    rm -rf conftest*
    bash_cv_termio_ldisc=yes
***************
*** 4622,4631 ****
  
  echo $ac_n "checking if struct dirent has a d_ino member""... $ac_c" 1>&6
! echo "configure:4625: checking if struct dirent has a d_ino member" >&5
  if eval "test \"`echo '$''{'bash_cv_dirent_has_dino'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 4630 "configure"
  #include "confdefs.h"
  
--- 4640,4649 ----
  
  echo $ac_n "checking if struct dirent has a d_ino member""... $ac_c" 1>&6
! echo "configure:4643: checking if struct dirent has a d_ino member" >&5
  if eval "test \"`echo '$''{'bash_cv_dirent_has_dino'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 4648 "configure"
  #include "confdefs.h"
  
***************
*** 4656,4660 ****
  ; return 0; }
  EOF
! if { (eval echo configure:4659: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
    rm -rf conftest*
    bash_cv_dirent_has_dino=yes
--- 4674,4678 ----
  ; return 0; }
  EOF
! if { (eval echo configure:4677: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
    rm -rf conftest*
    bash_cv_dirent_has_dino=yes
***************
*** 4676,4686 ****
  fi
  
  echo $ac_n "checking for the existance of strsignal""... $ac_c" 1>&6
! echo "configure:4680: checking for the existance of strsignal" >&5
  if eval "test \"`echo '$''{'bash_cv_have_strsignal'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 4685 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
--- 4694,4795 ----
  fi
  
+ 
+ echo $ac_n "checking if struct dirent has a d_fileno member""... $ac_c" 1>&6
+ echo "configure:4699: checking if struct dirent has a d_fileno member" >&5
+ if eval "test \"`echo '$''{'bash_cv_dirent_has_d_fileno'+set}'`\" = set"; then
+   echo $ac_n "(cached) $ac_c" 1>&6
+ else
+   cat > conftest.$ac_ext <<EOF
+ #line 4704 "configure"
+ #include "confdefs.h"
+ 
+ #include <stdio.h>
+ #include <sys/types.h>
+ #ifdef HAVE_UNISTD_H
+ # include <unistd.h>
+ #endif /* HAVE_UNISTD_H */
+ #if defined(HAVE_DIRENT_H)
+ # include <dirent.h>
+ #else
+ # define dirent direct
+ # ifdef HAVE_SYS_NDIR_H
+ #  include <sys/ndir.h>
+ # endif /* SYSNDIR */
+ # ifdef HAVE_SYS_DIR_H
+ #  include <sys/dir.h>
+ # endif /* SYSDIR */
+ # ifdef HAVE_NDIR_H
+ #  include <ndir.h>
+ # endif
+ #endif /* HAVE_DIRENT_H */
+ 
+ int main() {
+ 
+ struct dirent d; int z; z = d.d_fileno;
+ 
+ ; return 0; }
+ EOF
+ if { (eval echo configure:4733: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+   rm -rf conftest*
+   bash_cv_dirent_has_d_fileno=yes
+ else
+   echo "configure: failed program was:" >&5
+   cat conftest.$ac_ext >&5
+   rm -rf conftest*
+   bash_cv_dirent_has_d_fileno=no
+ fi
+ rm -f conftest*
+ fi
+ 
+ echo "$ac_t""$bash_cv_dirent_has_d_fileno" 1>&6
+ if test $bash_cv_dirent_has_d_fileno = yes; then
+ cat >> confdefs.h <<\EOF
+ #define STRUCT_DIRENT_HAS_D_FILENO 1
+ EOF
+ 
+ fi
+ 
+ echo $ac_n "checking for struct winsize in sys/ioctl.h""... $ac_c" 1>&6
+ echo "configure:4754: checking for struct winsize in sys/ioctl.h" >&5
+ if eval "test \"`echo '$''{'bash_cv_struct_winsize_in_ioctl'+set}'`\" = set"; then
+   echo $ac_n "(cached) $ac_c" 1>&6
+ else
+   cat > conftest.$ac_ext <<EOF
+ #line 4759 "configure"
+ #include "confdefs.h"
+ #include <sys/types.h>
+ #include <sys/ioctl.h>
+ int main() {
+ struct winsize x;
+ ; return 0; }
+ EOF
+ if { (eval echo configure:4767: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+   rm -rf conftest*
+   bash_cv_struct_winsize_in_ioctl=yes
+ else
+   echo "configure: failed program was:" >&5
+   cat conftest.$ac_ext >&5
+   rm -rf conftest*
+   bash_cv_struct_winsize_in_ioctl=no
+ fi
+ rm -f conftest*
+ fi
+ 
+ echo "$ac_t""$bash_cv_struct_winsize_in_ioctl" 1>&6
+ if test $bash_cv_struct_winsize_in_ioctl = yes; then   
+ cat >> confdefs.h <<\EOF
+ #define STRUCT_WINSIZE_IN_SYS_IOCTL 1
+ EOF
+ 
+ fi
+ 
+ 
  echo $ac_n "checking for the existance of strsignal""... $ac_c" 1>&6
! echo "configure:4789: checking for the existance of strsignal" >&5
  if eval "test \"`echo '$''{'bash_cv_have_strsignal'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 4794 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
***************
*** 4690,4694 ****
  ; return 0; }
  EOF
! if { (eval echo configure:4693: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
    rm -rf conftest*
    bash_cv_have_strsignal=yes
--- 4799,4803 ----
  ; return 0; }
  EOF
! if { (eval echo configure:4802: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
    rm -rf conftest*
    bash_cv_have_strsignal=yes
***************
*** 4711,4715 ****
  
  echo $ac_n "checking if opendir() opens non-directories""... $ac_c" 1>&6
! echo "configure:4714: checking if opendir() opens non-directories" >&5
  if eval "test \"`echo '$''{'bash_cv_opendir_not_robust'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
--- 4820,4824 ----
  
  echo $ac_n "checking if opendir() opens non-directories""... $ac_c" 1>&6
! echo "configure:4823: checking if opendir() opens non-directories" >&5
  if eval "test \"`echo '$''{'bash_cv_opendir_not_robust'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
***************
*** 4719,4723 ****
  else
    cat > conftest.$ac_ext <<EOF
! #line 4722 "configure"
  #include "confdefs.h"
  
--- 4828,4832 ----
  else
    cat > conftest.$ac_ext <<EOF
! #line 4831 "configure"
  #include "confdefs.h"
  
***************
*** 4755,4759 ****
  }
  EOF
! if { (eval echo configure:4758: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
  then
    bash_cv_opendir_not_robust=yes
--- 4864,4868 ----
  }
  EOF
! if { (eval echo configure:4867: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
  then
    bash_cv_opendir_not_robust=yes
***************
*** 4778,4782 ****
  
  echo $ac_n "checking for declaration of printf in <stdio.h>""... $ac_c" 1>&6
! echo "configure:4781: checking for declaration of printf in <stdio.h>" >&5
  if eval "test \"`echo '$''{'bash_cv_printf_declared'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
--- 4887,4891 ----
  
  echo $ac_n "checking for declaration of printf in <stdio.h>""... $ac_c" 1>&6
! echo "configure:4890: checking for declaration of printf in <stdio.h>" >&5
  if eval "test \"`echo '$''{'bash_cv_printf_declared'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
***************
*** 4786,4790 ****
  else
    cat > conftest.$ac_ext <<EOF
! #line 4789 "configure"
  #include "confdefs.h"
  
--- 4895,4899 ----
  else
    cat > conftest.$ac_ext <<EOF
! #line 4898 "configure"
  #include "confdefs.h"
  
***************
*** 4803,4807 ****
  
  EOF
! if { (eval echo configure:4806: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
  then
    bash_cv_printf_declared=yes
--- 4912,4916 ----
  
  EOF
! if { (eval echo configure:4915: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
  then
    bash_cv_printf_declared=yes
***************
*** 4826,4830 ****
  
  echo $ac_n "checking whether ulimit can substitute for getdtablesize""... $ac_c" 1>&6
! echo "configure:4829: checking whether ulimit can substitute for getdtablesize" >&5
  if eval "test \"`echo '$''{'bash_cv_ulimit_maxfds'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
--- 4935,4939 ----
  
  echo $ac_n "checking whether ulimit can substitute for getdtablesize""... $ac_c" 1>&6
! echo "configure:4938: checking whether ulimit can substitute for getdtablesize" >&5
  if eval "test \"`echo '$''{'bash_cv_ulimit_maxfds'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
***************
*** 4834,4838 ****
  else
    cat > conftest.$ac_ext <<EOF
! #line 4837 "configure"
  #include "confdefs.h"
  
--- 4943,4947 ----
  else
    cat > conftest.$ac_ext <<EOF
! #line 4946 "configure"
  #include "confdefs.h"
  
***************
*** 4844,4848 ****
  
  EOF
! if { (eval echo configure:4847: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
  then
    bash_cv_ulimit_maxfds=yes
--- 4953,4957 ----
  
  EOF
! if { (eval echo configure:4956: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
  then
    bash_cv_ulimit_maxfds=yes
***************
*** 4867,4871 ****
  
  echo $ac_n "checking to see if getenv can be redefined""... $ac_c" 1>&6
! echo "configure:4870: checking to see if getenv can be redefined" >&5
  if eval "test \"`echo '$''{'bash_cv_getenv_redef'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
--- 4976,4980 ----
  
  echo $ac_n "checking to see if getenv can be redefined""... $ac_c" 1>&6
! echo "configure:4979: checking to see if getenv can be redefined" >&5
  if eval "test \"`echo '$''{'bash_cv_getenv_redef'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
***************
*** 4875,4879 ****
  else
    cat > conftest.$ac_ext <<EOF
! #line 4878 "configure"
  #include "confdefs.h"
  
--- 4984,4988 ----
  else
    cat > conftest.$ac_ext <<EOF
! #line 4987 "configure"
  #include "confdefs.h"
  
***************
*** 4910,4914 ****
  
  EOF
! if { (eval echo configure:4913: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
  then
    bash_cv_getenv_redef=yes
--- 5019,5023 ----
  
  EOF
! if { (eval echo configure:5022: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
  then
    bash_cv_getenv_redef=yes
***************
*** 4933,4937 ****
  
  echo $ac_n "checking if getcwd() calls popen()""... $ac_c" 1>&6
! echo "configure:4936: checking if getcwd() calls popen()" >&5
  if eval "test \"`echo '$''{'bash_cv_getcwd_calls_popen'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
--- 5042,5046 ----
  
  echo $ac_n "checking if getcwd() calls popen()""... $ac_c" 1>&6
! echo "configure:5045: checking if getcwd() calls popen()" >&5
  if eval "test \"`echo '$''{'bash_cv_getcwd_calls_popen'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
***************
*** 4941,4945 ****
  else
    cat > conftest.$ac_ext <<EOF
! #line 4944 "configure"
  #include "confdefs.h"
  
--- 5050,5054 ----
  else
    cat > conftest.$ac_ext <<EOF
! #line 5053 "configure"
  #include "confdefs.h"
  
***************
*** 4996,5000 ****
  
  EOF
! if { (eval echo configure:4999: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
  then
    bash_cv_getcwd_calls_popen=no
--- 5105,5109 ----
  
  EOF
! if { (eval echo configure:5108: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
  then
    bash_cv_getcwd_calls_popen=no
***************
*** 5019,5028 ****
  
  echo $ac_n "checking for declaration of sbrk in <unistd.h>""... $ac_c" 1>&6
! echo "configure:5022: checking for declaration of sbrk in <unistd.h>" >&5
  if eval "test \"`echo '$''{'bash_cv_sbrk_declared'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 5027 "configure"
  #include "confdefs.h"
  #include <unistd.h>
--- 5128,5137 ----
  
  echo $ac_n "checking for declaration of sbrk in <unistd.h>""... $ac_c" 1>&6
! echo "configure:5131: checking for declaration of sbrk in <unistd.h>" >&5
  if eval "test \"`echo '$''{'bash_cv_sbrk_declared'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 5136 "configure"
  #include "confdefs.h"
  #include <unistd.h>
***************
*** 5050,5054 ****
  
  echo $ac_n "checking for presence of POSIX-style sigsetjmp/siglongjmp""... $ac_c" 1>&6
! echo "configure:5053: checking for presence of POSIX-style sigsetjmp/siglongjmp" >&5
  if eval "test \"`echo '$''{'bash_cv_func_sigsetjmp'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
--- 5159,5163 ----
  
  echo $ac_n "checking for presence of POSIX-style sigsetjmp/siglongjmp""... $ac_c" 1>&6
! echo "configure:5162: checking for presence of POSIX-style sigsetjmp/siglongjmp" >&5
  if eval "test \"`echo '$''{'bash_cv_func_sigsetjmp'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
***************
*** 5058,5062 ****
  else
    cat > conftest.$ac_ext <<EOF
! #line 5061 "configure"
  #include "confdefs.h"
  
--- 5167,5171 ----
  else
    cat > conftest.$ac_ext <<EOF
! #line 5170 "configure"
  #include "confdefs.h"
  
***************
*** 5099,5103 ****
  }
  EOF
! if { (eval echo configure:5102: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
  then
    bash_cv_func_sigsetjmp=present
--- 5208,5212 ----
  }
  EOF
! if { (eval echo configure:5211: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
  then
    bash_cv_func_sigsetjmp=present
***************
*** 5123,5129 ****
  
  
  
  echo $ac_n "checking if signal handlers must be reinstalled when invoked""... $ac_c" 1>&6
! echo "configure:5128: checking if signal handlers must be reinstalled when invoked" >&5
  if eval "test \"`echo '$''{'bash_cv_must_reinstall_sighandlers'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
--- 5232,5311 ----
  
  
+ echo $ac_n "checking whether or not strcoll and strcmp differ""... $ac_c" 1>&6
+ echo "configure:5236: checking whether or not strcoll and strcmp differ" >&5
+ if eval "test \"`echo '$''{'bash_cv_func_strcoll_broken'+set}'`\" = set"; then
+   echo $ac_n "(cached) $ac_c" 1>&6
+ else
+   if test "$cross_compiling" = yes; then
+   { echo "configure: error: cannot check strcoll if cross compiling" 1>&2; exit 1; }
+ else
+   cat > conftest.$ac_ext <<EOF
+ #line 5244 "configure"
+ #include "confdefs.h"
+ 
+ #include <stdio.h>
+ #if defined (HAVE_LOCALE_H)
+ #include <locale.h>
+ #endif
+ 
+ main(c, v)
+ int     c;
+ char    *v[];
+ {
+         int     r1, r2;
+         char    *deflocale, *defcoll;
+ 
+ #ifdef HAVE_SETLOCALE
+         deflocale = setlocale(LC_ALL, "");
+ 	defcoll = setlocale(LC_COLLATE, "");
+ #endif
+ 
+ #ifdef HAVE_STRCOLL
+ 	/* These two values are taken from tests/glob-test. */
+         r1 = strcoll("abd", "aXd");
+ #else
+ 	r1 = 0;
+ #endif
+         r2 = strcmp("abd", "aXd");
+ 
+ 	/* These two should both be greater than 0.  It is permissible for
+ 	   a system to return different values, as long as the sign is the
+ 	   same. */
+ 
+         /* Exit with 1 (failure) if these two values are both > 0, since
+ 	   this tests whether strcoll(3) is broken with respect to strcmp(3)
+ 	   in the default locale. */
+ 	exit (r1 > 0 && r2 > 0);
+ }
+ 
+ EOF
+ if { (eval echo configure:5283: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
+ then
+   bash_cv_func_strcoll_broken=yes
+ else
+   echo "configure: failed program was:" >&5
+   cat conftest.$ac_ext >&5
+   rm -fr conftest*
+   bash_cv_func_strcoll_broken=no
+ fi
+ rm -fr conftest*
+ fi
+ 
+ 
+ fi
+ 
+ echo "$ac_t""$bash_cv_func_strcoll_broken" 1>&6
+ if test $bash_cv_func_strcoll_broken = yes; then
+ cat >> confdefs.h <<\EOF
+ #define STRCOLL_BROKEN 1
+ EOF
+ 
+ fi
+ 
+ 
+ 
  
  echo $ac_n "checking if signal handlers must be reinstalled when invoked""... $ac_c" 1>&6
! echo "configure:5310: checking if signal handlers must be reinstalled when invoked" >&5
  if eval "test \"`echo '$''{'bash_cv_must_reinstall_sighandlers'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
***************
*** 5133,5137 ****
  else
    cat > conftest.$ac_ext <<EOF
! #line 5136 "configure"
  #include "confdefs.h"
  
--- 5315,5319 ----
  else
    cat > conftest.$ac_ext <<EOF
! #line 5318 "configure"
  #include "confdefs.h"
  
***************
*** 5180,5184 ****
  
  EOF
! if { (eval echo configure:5183: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
  then
    bash_cv_must_reinstall_sighandlers=no
--- 5362,5366 ----
  
  EOF
! if { (eval echo configure:5365: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
  then
    bash_cv_must_reinstall_sighandlers=no
***************
*** 5204,5208 ****
  
  echo $ac_n "checking for presence of necessary job control definitions""... $ac_c" 1>&6
! echo "configure:5207: checking for presence of necessary job control definitions" >&5
  if eval "test \"`echo '$''{'bash_cv_job_control_missing'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
--- 5386,5390 ----
  
  echo $ac_n "checking for presence of necessary job control definitions""... $ac_c" 1>&6
! echo "configure:5389: checking for presence of necessary job control definitions" >&5
  if eval "test \"`echo '$''{'bash_cv_job_control_missing'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
***************
*** 5212,5216 ****
  else
    cat > conftest.$ac_ext <<EOF
! #line 5215 "configure"
  #include "confdefs.h"
  
--- 5394,5398 ----
  else
    cat > conftest.$ac_ext <<EOF
! #line 5397 "configure"
  #include "confdefs.h"
  
***************
*** 5259,5263 ****
  }
  EOF
! if { (eval echo configure:5262: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
  then
    bash_cv_job_control_missing=present
--- 5441,5445 ----
  }
  EOF
! if { (eval echo configure:5444: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
  then
    bash_cv_job_control_missing=present
***************
*** 5283,5287 ****
  
  echo $ac_n "checking for presence of named pipes""... $ac_c" 1>&6
! echo "configure:5286: checking for presence of named pipes" >&5
  if eval "test \"`echo '$''{'bash_cv_sys_named_pipes'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
--- 5465,5469 ----
  
  echo $ac_n "checking for presence of named pipes""... $ac_c" 1>&6
! echo "configure:5468: checking for presence of named pipes" >&5
  if eval "test \"`echo '$''{'bash_cv_sys_named_pipes'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
***************
*** 5291,5295 ****
  else
    cat > conftest.$ac_ext <<EOF
! #line 5294 "configure"
  #include "confdefs.h"
  
--- 5473,5477 ----
  else
    cat > conftest.$ac_ext <<EOF
! #line 5476 "configure"
  #include "confdefs.h"
  
***************
*** 5325,5329 ****
  }
  EOF
! if { (eval echo configure:5328: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
  then
    bash_cv_sys_named_pipes=present
--- 5507,5511 ----
  }
  EOF
! if { (eval echo configure:5510: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
  then
    bash_cv_sys_named_pipes=present
***************
*** 5348,5358 ****
  fi
  
  echo $ac_n "checking for TIOCGWINSZ in sys/ioctl.h""... $ac_c" 1>&6
! echo "configure:5352: checking for TIOCGWINSZ in sys/ioctl.h" >&5
  if eval "test \"`echo '$''{'bash_cv_tiocgwinsz_in_ioctl'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 5357 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
--- 5530,5541 ----
  fi
  
+ 
  echo $ac_n "checking for TIOCGWINSZ in sys/ioctl.h""... $ac_c" 1>&6
! echo "configure:5535: checking for TIOCGWINSZ in sys/ioctl.h" >&5
  if eval "test \"`echo '$''{'bash_cv_tiocgwinsz_in_ioctl'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 5540 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
***************
*** 5362,5366 ****
  ; return 0; }
  EOF
! if { (eval echo configure:5365: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
    rm -rf conftest*
    bash_cv_tiocgwinsz_in_ioctl=yes
--- 5545,5549 ----
  ; return 0; }
  EOF
! if { (eval echo configure:5548: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
    rm -rf conftest*
    bash_cv_tiocgwinsz_in_ioctl=yes
***************
*** 5383,5392 ****
  
  echo $ac_n "checking for TIOCSTAT in sys/ioctl.h""... $ac_c" 1>&6
! echo "configure:5386: checking for TIOCSTAT in sys/ioctl.h" >&5
  if eval "test \"`echo '$''{'bash_cv_tiocstat_in_ioctl'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 5391 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
--- 5566,5575 ----
  
  echo $ac_n "checking for TIOCSTAT in sys/ioctl.h""... $ac_c" 1>&6
! echo "configure:5569: checking for TIOCSTAT in sys/ioctl.h" >&5
  if eval "test \"`echo '$''{'bash_cv_tiocstat_in_ioctl'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 5574 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
***************
*** 5396,5400 ****
  ; return 0; }
  EOF
! if { (eval echo configure:5399: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
    rm -rf conftest*
    bash_cv_tiocstat_in_ioctl=yes
--- 5579,5583 ----
  ; return 0; }
  EOF
! if { (eval echo configure:5582: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
    rm -rf conftest*
    bash_cv_tiocstat_in_ioctl=yes
***************
*** 5417,5426 ****
  
  echo $ac_n "checking for FIONREAD in sys/ioctl.h""... $ac_c" 1>&6
! echo "configure:5420: checking for FIONREAD in sys/ioctl.h" >&5
  if eval "test \"`echo '$''{'bash_cv_fionread_in_ioctl'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 5425 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
--- 5600,5609 ----
  
  echo $ac_n "checking for FIONREAD in sys/ioctl.h""... $ac_c" 1>&6
! echo "configure:5603: checking for FIONREAD in sys/ioctl.h" >&5
  if eval "test \"`echo '$''{'bash_cv_fionread_in_ioctl'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 5608 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
***************
*** 5430,5434 ****
  ; return 0; }
  EOF
! if { (eval echo configure:5433: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
    rm -rf conftest*
    bash_cv_fionread_in_ioctl=yes
--- 5613,5617 ----
  ; return 0; }
  EOF
! if { (eval echo configure:5616: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
    rm -rf conftest*
    bash_cv_fionread_in_ioctl=yes
***************
*** 5450,5460 ****
  fi
  
  echo $ac_n "checking whether programs are able to redeclare getpw functions""... $ac_c" 1>&6
! echo "configure:5454: checking whether programs are able to redeclare getpw functions" >&5
  if eval "test \"`echo '$''{'bash_cv_can_redecl_getpw'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 5459 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
--- 5633,5677 ----
  fi
  
+ 
+ echo $ac_n "checking for speed_t in sys/types.h""... $ac_c" 1>&6
+ echo "configure:5638: checking for speed_t in sys/types.h" >&5
+ if eval "test \"`echo '$''{'bash_cv_speed_t_in_sys_types'+set}'`\" = set"; then
+   echo $ac_n "(cached) $ac_c" 1>&6
+ else
+   cat > conftest.$ac_ext <<EOF
+ #line 5643 "configure"
+ #include "confdefs.h"
+ #include <sys/types.h>
+ int main() {
+ speed_t x;
+ ; return 0; }
+ EOF
+ if { (eval echo configure:5650: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+   rm -rf conftest*
+   bash_cv_speed_t_in_sys_types=yes
+ else
+   echo "configure: failed program was:" >&5
+   cat conftest.$ac_ext >&5
+   rm -rf conftest*
+   bash_cv_speed_t_in_sys_types=no
+ fi
+ rm -f conftest*
+ fi
+ 
+ echo "$ac_t""$bash_cv_speed_t_in_sys_types" 1>&6
+ if test $bash_cv_speed_t_in_sys_types = yes; then   
+ cat >> confdefs.h <<\EOF
+ #define SPEED_T_IN_SYS_TYPES 1
+ EOF
+ 
+ fi
+ 
  echo $ac_n "checking whether programs are able to redeclare getpw functions""... $ac_c" 1>&6
! echo "configure:5671: checking whether programs are able to redeclare getpw functions" >&5
  if eval "test \"`echo '$''{'bash_cv_can_redecl_getpw'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 5676 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
***************
*** 5465,5469 ****
  ; return 0; }
  EOF
! if { (eval echo configure:5468: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
    rm -rf conftest*
    bash_cv_can_redecl_getpw=yes
--- 5682,5686 ----
  ; return 0; }
  EOF
! if { (eval echo configure:5685: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
    rm -rf conftest*
    bash_cv_can_redecl_getpw=yes
***************
*** 5485,5533 ****
  fi
  
- echo $ac_n "checking whether /dev/fd is available""... $ac_c" 1>&6
- echo "configure:5489: checking whether /dev/fd is available" >&5
- if eval "test \"`echo '$''{'bash_cv_dev_fd'+set}'`\" = set"; then
-   echo $ac_n "(cached) $ac_c" 1>&6
- else
-   if test -d /dev/fd  && test -r /dev/fd/0; then
-    bash_cv_dev_fd=standard
-  elif test -d /proc/self/fd && test -r /proc/self/fd/0; then
-    bash_cv_dev_fd=whacky
-  else
-    bash_cv_dev_fd=absent
-  fi
- 
- fi
- 
- echo "$ac_t""$bash_cv_dev_fd" 1>&6
- if test $bash_cv_dev_fd = "standard"; then
-   cat >> confdefs.h <<\EOF
- #define HAVE_DEV_FD 1
- EOF
- 
-   cat >> confdefs.h <<\EOF
- #define DEV_FD_PREFIX "/dev/fd/"
- EOF
- 
- elif test $bash_cv_dev_fd = "whacky"; then
-   cat >> confdefs.h <<\EOF
- #define HAVE_DEV_FD 1
- EOF
- 
-   cat >> confdefs.h <<\EOF
- #define DEV_FD_PREFIX "/proc/self/fd/"
- EOF
- 
- fi
- 
  
  case "$host_os" in
  hpux*)	echo $ac_n "checking whether $host_os needs _KERNEL for RLIMIT defines""... $ac_c" 1>&6
! echo "configure:5527: checking whether $host_os needs _KERNEL for RLIMIT defines" >&5
  if eval "test \"`echo '$''{'bash_cv_kernel_rlimit'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 5532 "configure"
  #include "confdefs.h"
  
--- 5702,5714 ----
  fi
  
  
  case "$host_os" in
  hpux*)	echo $ac_n "checking whether $host_os needs _KERNEL for RLIMIT defines""... $ac_c" 1>&6
! echo "configure:5708: checking whether $host_os needs _KERNEL for RLIMIT defines" >&5
  if eval "test \"`echo '$''{'bash_cv_kernel_rlimit'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 5713 "configure"
  #include "confdefs.h"
  
***************
*** 5542,5546 ****
  ; return 0; }
  EOF
! if { (eval echo configure:5545: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
    rm -rf conftest*
    bash_cv_kernel_rlimit=no
--- 5723,5727 ----
  ; return 0; }
  EOF
! if { (eval echo configure:5726: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
    rm -rf conftest*
    bash_cv_kernel_rlimit=no
***************
*** 5550,5554 ****
    rm -rf conftest*
    cat > conftest.$ac_ext <<EOF
! #line 5553 "configure"
  #include "confdefs.h"
  
--- 5731,5735 ----
    rm -rf conftest*
    cat > conftest.$ac_ext <<EOF
! #line 5734 "configure"
  #include "confdefs.h"
  
***************
*** 5565,5569 ****
  ; return 0; }
  EOF
! if { (eval echo configure:5568: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
    rm -rf conftest*
    bash_cv_kernel_rlimit=yes
--- 5746,5750 ----
  ; return 0; }
  EOF
! if { (eval echo configure:5749: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
    rm -rf conftest*
    bash_cv_kernel_rlimit=yes
***************
*** 5591,5594 ****
--- 5772,5778 ----
  
  if test "$opt_readline" = yes; then
+ case "$host_os" in
+ aix*)	prefer_curses=yes ;;
+ esac
  
  if test "X$bash_cv_termcap_lib" = "X"; then
***************
*** 5596,5600 ****
  else
  echo $ac_n "checking which library has the termcap functions""... $ac_c" 1>&6
! echo "configure:5599: checking which library has the termcap functions" >&5
  _bash_needmsg=
  fi
--- 5780,5784 ----
  else
  echo $ac_n "checking which library has the termcap functions""... $ac_c" 1>&6
! echo "configure:5783: checking which library has the termcap functions" >&5
  _bash_needmsg=
  fi
***************
*** 5603,5607 ****
  else
    echo $ac_n "checking for tgetent in -ltermcap""... $ac_c" 1>&6
! echo "configure:5606: checking for tgetent in -ltermcap" >&5
  ac_lib_var=`echo termcap'_'tgetent | sed 'y%./+-%__p_%'`
  if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
--- 5787,5791 ----
  else
    echo $ac_n "checking for tgetent in -ltermcap""... $ac_c" 1>&6
! echo "configure:5790: checking for tgetent in -ltermcap" >&5
  ac_lib_var=`echo termcap'_'tgetent | sed 'y%./+-%__p_%'`
  if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
***************
*** 5611,5615 ****
  LIBS="-ltermcap  $LIBS"
  cat > conftest.$ac_ext <<EOF
! #line 5614 "configure"
  #include "confdefs.h"
  /* Override any gcc2 internal prototype to avoid an error.  */
--- 5795,5799 ----
  LIBS="-ltermcap  $LIBS"
  cat > conftest.$ac_ext <<EOF
! #line 5798 "configure"
  #include "confdefs.h"
  /* Override any gcc2 internal prototype to avoid an error.  */
***************
*** 5622,5626 ****
  ; return 0; }
  EOF
! if { (eval echo configure:5625: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
    rm -rf conftest*
    eval "ac_cv_lib_$ac_lib_var=yes"
--- 5806,5810 ----
  ; return 0; }
  EOF
! if { (eval echo configure:5809: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
    rm -rf conftest*
    eval "ac_cv_lib_$ac_lib_var=yes"
***************
*** 5641,5645 ****
    echo "$ac_t""no" 1>&6
  echo $ac_n "checking for tgetent in -lcurses""... $ac_c" 1>&6
! echo "configure:5644: checking for tgetent in -lcurses" >&5
  ac_lib_var=`echo curses'_'tgetent | sed 'y%./+-%__p_%'`
  if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
--- 5825,5829 ----
    echo "$ac_t""no" 1>&6
  echo $ac_n "checking for tgetent in -lcurses""... $ac_c" 1>&6
! echo "configure:5828: checking for tgetent in -lcurses" >&5
  ac_lib_var=`echo curses'_'tgetent | sed 'y%./+-%__p_%'`
  if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
***************
*** 5649,5653 ****
  LIBS="-lcurses  $LIBS"
  cat > conftest.$ac_ext <<EOF
! #line 5652 "configure"
  #include "confdefs.h"
  /* Override any gcc2 internal prototype to avoid an error.  */
--- 5833,5837 ----
  LIBS="-lcurses  $LIBS"
  cat > conftest.$ac_ext <<EOF
! #line 5836 "configure"
  #include "confdefs.h"
  /* Override any gcc2 internal prototype to avoid an error.  */
***************
*** 5660,5664 ****
  ; return 0; }
  EOF
! if { (eval echo configure:5663: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
    rm -rf conftest*
    eval "ac_cv_lib_$ac_lib_var=yes"
--- 5844,5848 ----
  ; return 0; }
  EOF
! if { (eval echo configure:5847: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
    rm -rf conftest*
    eval "ac_cv_lib_$ac_lib_var=yes"
***************
*** 5679,5683 ****
    echo "$ac_t""no" 1>&6
  echo $ac_n "checking for tgetent in -lncurses""... $ac_c" 1>&6
! echo "configure:5682: checking for tgetent in -lncurses" >&5
  ac_lib_var=`echo ncurses'_'tgetent | sed 'y%./+-%__p_%'`
  if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
--- 5863,5867 ----
    echo "$ac_t""no" 1>&6
  echo $ac_n "checking for tgetent in -lncurses""... $ac_c" 1>&6
! echo "configure:5866: checking for tgetent in -lncurses" >&5
  ac_lib_var=`echo ncurses'_'tgetent | sed 'y%./+-%__p_%'`
  if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
***************
*** 5687,5691 ****
  LIBS="-lncurses  $LIBS"
  cat > conftest.$ac_ext <<EOF
! #line 5690 "configure"
  #include "confdefs.h"
  /* Override any gcc2 internal prototype to avoid an error.  */
--- 5871,5875 ----
  LIBS="-lncurses  $LIBS"
  cat > conftest.$ac_ext <<EOF
! #line 5874 "configure"
  #include "confdefs.h"
  /* Override any gcc2 internal prototype to avoid an error.  */
***************
*** 5698,5702 ****
  ; return 0; }
  EOF
! if { (eval echo configure:5701: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
    rm -rf conftest*
    eval "ac_cv_lib_$ac_lib_var=yes"
--- 5882,5886 ----
  ; return 0; }
  EOF
! if { (eval echo configure:5885: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
    rm -rf conftest*
    eval "ac_cv_lib_$ac_lib_var=yes"
***************
*** 5727,5731 ****
  if test "X$_bash_needmsg" = "Xyes"; then
  echo $ac_n "checking which library has the termcap functions""... $ac_c" 1>&6
! echo "configure:5730: checking which library has the termcap functions" >&5
  fi
  echo "$ac_t""using $bash_cv_termcap_lib" 1>&6
--- 5911,5915 ----
  if test "X$_bash_needmsg" = "Xyes"; then
  echo $ac_n "checking which library has the termcap functions""... $ac_c" 1>&6
! echo "configure:5914: checking which library has the termcap functions" >&5
  fi
  echo "$ac_t""using $bash_cv_termcap_lib" 1>&6
***************
*** 5734,5738 ****
  TERMCAP_LIB="./lib/termcap/libtermcap.a"
  TERMCAP_DEP="./lib/termcap/libtermcap.a"
! elif test $bash_cv_termcap_lib = libtermcap; then
  TERMCAP_LIB=-ltermcap
  TERMCAP_DEP=
--- 5918,5922 ----
  TERMCAP_LIB="./lib/termcap/libtermcap.a"
  TERMCAP_DEP="./lib/termcap/libtermcap.a"
! elif test $bash_cv_termcap_lib = libtermcap && test -z "$prefer_curses"; then
  TERMCAP_LIB=-ltermcap
  TERMCAP_DEP=
***************
*** 5749,5754 ****
  
  
  echo $ac_n "checking for default mail directory""... $ac_c" 1>&6
! echo "configure:5753: checking for default mail directory" >&5
  if eval "test \"`echo '$''{'bash_cv_mail_dir'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
--- 5933,5974 ----
  
  
+ echo $ac_n "checking whether /dev/fd is available""... $ac_c" 1>&6
+ echo "configure:5937: checking whether /dev/fd is available" >&5
+ if eval "test \"`echo '$''{'bash_cv_dev_fd'+set}'`\" = set"; then
+   echo $ac_n "(cached) $ac_c" 1>&6
+ else
+   if test -d /dev/fd  && test -r /dev/fd/0; then
+    bash_cv_dev_fd=standard
+  elif test -d /proc/self/fd && test -r /proc/self/fd/0; then
+    bash_cv_dev_fd=whacky
+  else
+    bash_cv_dev_fd=absent
+  fi
+ 
+ fi
+ 
+ echo "$ac_t""$bash_cv_dev_fd" 1>&6
+ if test $bash_cv_dev_fd = "standard"; then
+   cat >> confdefs.h <<\EOF
+ #define HAVE_DEV_FD 1
+ EOF
+ 
+   cat >> confdefs.h <<\EOF
+ #define DEV_FD_PREFIX "/dev/fd/"
+ EOF
+ 
+ elif test $bash_cv_dev_fd = "whacky"; then
+   cat >> confdefs.h <<\EOF
+ #define HAVE_DEV_FD 1
+ EOF
+ 
+   cat >> confdefs.h <<\EOF
+ #define DEV_FD_PREFIX "/proc/self/fd/"
+ EOF
+ 
+ fi
+ 
  echo $ac_n "checking for default mail directory""... $ac_c" 1>&6
! echo "configure:5973: checking for default mail directory" >&5
  if eval "test \"`echo '$''{'bash_cv_mail_dir'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
***************
*** 5814,5817 ****
--- 6034,6040 ----
  
  
+ LOCAL_DEFS=-DSHELL
+ 
+ 
  case "$host_os" in
  sysv4.2)	cat >> confdefs.h <<\EOF
***************
*** 5833,5839 ****
  sco3.2v4*)	LOCAL_CFLAGS="-DMUST_UNBLOCK_CHLD -DNO_MEMSCRAMBLE -DPATH_MAX=1024" ;;
  sco3.2*)	LOCAL_CFLAGS=-DMUST_UNBLOCK_CHLD ;;
! sunos4*)	LOCAL_CFLAGS=-DSunOS4;;
! linux*)		LOCAL_LDFLAGS=-rdynamic ;;	# allow dynamic loading
! aix4.2*)	LOCAL_LDFLAGS="-bexpall -brtl";;# allow dynamic loading
  esac
  
--- 6056,6065 ----
  sco3.2v4*)	LOCAL_CFLAGS="-DMUST_UNBLOCK_CHLD -DNO_MEMSCRAMBLE -DPATH_MAX=1024" ;;
  sco3.2*)	LOCAL_CFLAGS=-DMUST_UNBLOCK_CHLD ;;
! sunos4*)	LOCAL_CFLAGS=-DSunOS4 ;;
! solaris2.5*)	LOCAL_CFLAGS=-DSunOS5 ;;
! linux*)		LOCAL_LDFLAGS=-rdynamic ;;	 # allow dynamic loading
! aix4.2*)	LOCAL_LDFLAGS="-bexpall -brtl" ;;# allow dynamic loading
! *qnx*)		LOCAL_CFLAGS="-Dqnx -F -3s" LOCAL_LDFLAGS="-3s -lunix -lncurses" ;;
! powerux)	LOCAL_LIBS="-lgen" ;;
  esac
  
***************
*** 5882,5885 ****
--- 6108,6115 ----
  
  
+ 
+ #AC_SUBST(ALLOCA_SOURCE)
+ #AC_SUBST(ALLOCA_OBJECT)
+ 
  trap '' 1 2 15
  cat > confcache <<\EOF
***************
*** 6020,6025 ****
  s%@host_vendor@%$host_vendor%g
  s%@host_os@%$host_os%g
  s%@PURIFY@%$PURIFY%g
! s%@MALLOC@%$MALLOC%g
  s%@MALLOC_SRC@%$MALLOC_SRC%g
  s%@READLINE_LIB@%$READLINE_LIB%g
--- 6250,6256 ----
  s%@host_vendor@%$host_vendor%g
  s%@host_os@%$host_os%g
+ s%@TESTSCRIPT@%$TESTSCRIPT%g
  s%@PURIFY@%$PURIFY%g
! s%@MALLOC_TARGET@%$MALLOC_TARGET%g
  s%@MALLOC_SRC@%$MALLOC_SRC%g
  s%@READLINE_LIB@%$READLINE_LIB%g
***************
*** 6041,6049 ****
  s%@incdir@%$incdir%g
  s%@BUILD_DIR@%$BUILD_DIR%g
  s%@LOCAL_LIBS@%$LOCAL_LIBS%g
  s%@LOCAL_CFLAGS@%$LOCAL_CFLAGS%g
  s%@LOCAL_LDFLAGS@%$LOCAL_LDFLAGS%g
! s%@ALLOCA_SOURCE@%$ALLOCA_SOURCE%g
! s%@ALLOCA_OBJECT@%$ALLOCA_OBJECT%g
  
  CEOF
--- 6272,6281 ----
  s%@incdir@%$incdir%g
  s%@BUILD_DIR@%$BUILD_DIR%g
+ s%@BASHVERS@%$BASHVERS%g
+ s%@BASHPATCH@%$BASHPATCH%g
  s%@LOCAL_LIBS@%$LOCAL_LIBS%g
  s%@LOCAL_CFLAGS@%$LOCAL_CFLAGS%g
  s%@LOCAL_LDFLAGS@%$LOCAL_LDFLAGS%g
! s%@LOCAL_DEFS@%$LOCAL_DEFS%g
  
  CEOF
diff -Nrc2 bash-2.0/configure.in bash-2.01/configure.in
*** bash-2.0/configure.in	Tue Dec 17 12:49:09 1996
--- bash-2.01/configure.in	Thu Apr 24 09:05:20 1997
***************
*** 1,4 ****
  dnl
! dnl Configure script for bash-2.0
  dnl
  dnl report bugs to chet@po.cwru.edu
--- 1,4 ----
  dnl
! dnl Configure script for bash-2.01
  dnl
  dnl report bugs to chet@po.cwru.edu
***************
*** 6,10 ****
  dnl Process this file with autoconf to produce a configure script.
  dnl checks for version info
! AC_REVISION([for Bash 2.0, version 1.14, from autoconf version] AC_ACVERSION)dnl
  
  AC_INIT(shell.h)
--- 6,11 ----
  dnl Process this file with autoconf to produce a configure script.
  dnl checks for version info
! 
! AC_REVISION([for Bash 2.01, version 1.26, from autoconf version] AC_ACVERSION)dnl
  
  AC_INIT(shell.h)
***************
*** 12,16 ****
  
  dnl make sure we are using a recent autoconf version
! AC_PREREQ(2.8)
  
  dnl where to find install.sh, config.sub, and config.guess
--- 13,17 ----
  
  dnl make sure we are using a recent autoconf version
! AC_PREREQ(2.10)
  
  dnl where to find install.sh, config.sub, and config.guess
***************
*** 25,29 ****
--- 26,32 ----
  opt_glibc_malloc=no
  opt_purify=no
+ opt_purecov=no
  opt_afs=no
+ opt_curses=no
  
  dnl some systems should be configured without gnu malloc by default
***************
*** 36,44 ****
  sparc-svr4*)	opt_gnu_malloc=no ;;	# sparc SVR4, SVR4.2
  sparc-netbsd*)	opt_gnu_malloc=no ;;	# needs 8-byte alignment
  sparc-linux*)	opt_gnu_malloc=no ;;	# sparc running linux; requires ELF
  *-aix*)		opt_gnu_malloc=no ;;	# AIX machines
  *-nextstep*)	opt_gnu_malloc=no ;;	# NeXT machines running NeXTstep
  *-dgux*)	opt_gnu_malloc=no ;;	# DG/UX machines
! *-qnx)		opt_gnu_malloc=no ;;	# QNX 4.2
  *-bsdi2.1)	opt_gnu_malloc=no ; : ${CC:=shlicc2} ;; # for loadable builtins
  esac
--- 39,50 ----
  sparc-svr4*)	opt_gnu_malloc=no ;;	# sparc SVR4, SVR4.2
  sparc-netbsd*)	opt_gnu_malloc=no ;;	# needs 8-byte alignment
+ *-sgi-irix6*)	opt_gnu_malloc=no ;;	# needs 8-byte alignment
  sparc-linux*)	opt_gnu_malloc=no ;;	# sparc running linux; requires ELF
+ *-freebsd*)	opt_gnu_malloc=no ;;	# they claim it's better
  *-aix*)		opt_gnu_malloc=no ;;	# AIX machines
  *-nextstep*)	opt_gnu_malloc=no ;;	# NeXT machines running NeXTstep
  *-dgux*)	opt_gnu_malloc=no ;;	# DG/UX machines
! *-qnx*)		opt_gnu_malloc=no ;;	# QNX 4.2
! *-machten4)	opt_gnu_malloc=no ;;	# MachTen 4.x
  *-bsdi2.1)	opt_gnu_malloc=no ; : ${CC:=shlicc2} ;; # for loadable builtins
  esac
***************
*** 46,73 ****
  dnl arguments to configure
  dnl packages
! AC_ARG_WITH(gnu-malloc, --with-gnu-malloc	use the GNU version of malloc,opt_gnu_malloc=$withval)
  AC_ARG_WITH(glibc-malloc, --with-glibc-malloc	use the GNU C library version of malloc,opt_glibc_malloc=$withval)
  AC_ARG_WITH(purify, --with-purify		configure to postprocess with purify, opt_purify=$withval)
- AC_ARG_WITH(afs, --with-afs		if you are running AFS, opt_afs=$withval)
  
  dnl test for glibc malloc first because it can override the default
  if test "$opt_glibc_malloc" = yes; then 
! 	MALLOC=gmalloc.o MALLOC_SRC='$(ALLOC_LIBSRC)/gmalloc.c'
  elif test "$opt_gnu_malloc" = yes; then
! 	MALLOC=malloc.o MALLOC_SRC='$(ALLOC_LIBSRC)/malloc.c'
  else
! 	MALLOC= MALLOC_SRC=
  fi
  
  if test "$opt_purify" = yes; then
! 	PURIFY=purify
  else
  	PURIFY=
  fi
  
  if test "$opt_afs" = yes; then
  	AC_DEFINE(AFS)
  fi
  
  dnl optional shell features in config.h.in
  opt_minimal_config=no
--- 52,92 ----
  dnl arguments to configure
  dnl packages
! AC_ARG_WITH(afs, --with-afs		if you are running AFS, opt_afs=$withval)
! AC_ARG_WITH(curses, --with-curses		use the curses library instead of the termcap library,opt_curses=$withval)
  AC_ARG_WITH(glibc-malloc, --with-glibc-malloc	use the GNU C library version of malloc,opt_glibc_malloc=$withval)
+ AC_ARG_WITH(gnu-malloc, --with-gnu-malloc	use the GNU version of malloc,opt_gnu_malloc=$withval)
+ AC_ARG_WITH(purecov, --with-purecov		configure to postprocess with pure coverage, opt_purecov=$withval)
  AC_ARG_WITH(purify, --with-purify		configure to postprocess with purify, opt_purify=$withval)
  
  dnl test for glibc malloc first because it can override the default
  if test "$opt_glibc_malloc" = yes; then 
! 	MALLOC_TARGET=gmalloc
! 	MALLOC_SRC=gmalloc.c
  elif test "$opt_gnu_malloc" = yes; then
! 	MALLOC_TARGET=malloc
! 	MALLOC_SRC=malloc.c
  else
! 	MALLOC_TARGET=stubmalloc
! 	MALLOC_SRC=stub.c
  fi
  
  if test "$opt_purify" = yes; then
! 	PURIFY="purify "
  else
  	PURIFY=
  fi
  
+ if test "$opt_purecov" = yes; then
+ 	PURIFY="${PURIFY}purecov"
+ fi
+ 
  if test "$opt_afs" = yes; then
  	AC_DEFINE(AFS)
  fi
  
+ if test "$opt_curses" = yes; then
+ 	prefer_curses=yes
+ fi
+ 
  dnl optional shell features in config.h.in
  opt_minimal_config=no
***************
*** 104,123 ****
  fi
  
- AC_ARG_ENABLE(job-control, --enable-job-control	enable job control features, opt_job_control=$enableval)
  AC_ARG_ENABLE(alias, --enable-alias		enable shell aliases, opt_alias=$enableval)
! AC_ARG_ENABLE(readline, --enable-readline	turn on command line editing, opt_readline=$enableval)
! AC_ARG_ENABLE(history, --enable-history	turn on command history, opt_history=$enableval)
  AC_ARG_ENABLE(bang-history, --enable-bang-history	turn on csh-style history substitution, opt_bang_history=$enableval)
  AC_ARG_ENABLE(directory-stack, --enable-directory-stack	enable builtins pushd/popd/dirs, opt_dirstack=$enableval)
! AC_ARG_ENABLE(restricted, --enable-restricted	enable a restricted shell, opt_restricted=$enableval)
  AC_ARG_ENABLE(process-substitution, --enable-process-substitution	enable process substitution, opt_process_subst=$enableval)
  AC_ARG_ENABLE(prompt-string-decoding, --enable-prompt-string-decoding	turn on escape character decoding in prompts, opt_prompt_decoding=$enableval)
  AC_ARG_ENABLE(select, --enable-select		include select command, opt_select=$enableval)
- AC_ARG_ENABLE(help-builtin, --enable-help-builtin	include the help builtin, opt_help=$enableval)
- AC_ARG_ENABLE(array-variables, --enable-array-variables	include shell array variables, opt_array_variables=$enableval)
- AC_ARG_ENABLE(dparen-arithmetic, [--enable-dparen-arithmetic	include ((...)) command], opt_dparen_arith=$enableval)
- AC_ARG_ENABLE(brace-expansion, --enable-brace-expansion	include brace expansion, opt_brace_expansion=$enableval)
- AC_ARG_ENABLE(disabled-builtins, --enable-disabled-builtins	allow disabled builtins to still be invoked, opt_disabled_builtins=$enableval)
- AC_ARG_ENABLE(command-timing, --enable-command-timing	enable the time reserved word and command timing, opt_command_timing=$enableval)
  AC_ARG_ENABLE(usg-echo-default, --enable-usg-echo-default	make the echo builtin expand escape sequences by default, opt_usg_echo=$enableval)
  
--- 123,142 ----
  fi
  
  AC_ARG_ENABLE(alias, --enable-alias		enable shell aliases, opt_alias=$enableval)
! AC_ARG_ENABLE(array-variables, --enable-array-variables	include shell array variables, opt_array_variables=$enableval)
  AC_ARG_ENABLE(bang-history, --enable-bang-history	turn on csh-style history substitution, opt_bang_history=$enableval)
+ AC_ARG_ENABLE(brace-expansion, --enable-brace-expansion	include brace expansion, opt_brace_expansion=$enableval)
+ AC_ARG_ENABLE(command-timing, --enable-command-timing	enable the time reserved word and command timing, opt_command_timing=$enableval)
  AC_ARG_ENABLE(directory-stack, --enable-directory-stack	enable builtins pushd/popd/dirs, opt_dirstack=$enableval)
! AC_ARG_ENABLE(disabled-builtins, --enable-disabled-builtins	allow disabled builtins to still be invoked, opt_disabled_builtins=$enableval)
! AC_ARG_ENABLE(dparen-arithmetic, [--enable-dparen-arithmetic	include ((...)) command], opt_dparen_arith=$enableval)
! AC_ARG_ENABLE(help-builtin, --enable-help-builtin	include the help builtin, opt_help=$enableval)
! AC_ARG_ENABLE(history, --enable-history	turn on command history, opt_history=$enableval)
! AC_ARG_ENABLE(job-control, --enable-job-control	enable job control features, opt_job_control=$enableval)
  AC_ARG_ENABLE(process-substitution, --enable-process-substitution	enable process substitution, opt_process_subst=$enableval)
  AC_ARG_ENABLE(prompt-string-decoding, --enable-prompt-string-decoding	turn on escape character decoding in prompts, opt_prompt_decoding=$enableval)
+ AC_ARG_ENABLE(readline, --enable-readline	turn on command line editing, opt_readline=$enableval)
+ AC_ARG_ENABLE(restricted, --enable-restricted	enable a restricted shell, opt_restricted=$enableval)
  AC_ARG_ENABLE(select, --enable-select		include select command, opt_select=$enableval)
  AC_ARG_ENABLE(usg-echo-default, --enable-usg-echo-default	make the echo builtin expand escape sequences by default, opt_usg_echo=$enableval)
  
***************
*** 185,191 ****
  fi
  
  dnl now substitute in the values generated by arguments
  AC_SUBST(PURIFY)
! AC_SUBST(MALLOC)
  AC_SUBST(MALLOC_SRC)
  AC_SUBST(READLINE_LIB)
--- 204,217 ----
  fi
  
+ if test "$opt_minimal_config" = yes; then
+ 	TESTSCRIPT=run-minimal
+ else
+ 	TESTSCRIPT=run-all
+ fi
+ 
  dnl now substitute in the values generated by arguments
+ AC_SUBST(TESTSCRIPT)
  AC_SUBST(PURIFY)
! AC_SUBST(MALLOC_TARGET)
  AC_SUBST(MALLOC_SRC)
  AC_SUBST(READLINE_LIB)
***************
*** 194,198 ****
  AC_SUBST(HISTORY_DEP)
  
! echo "Beginning configuration for bash-2.0"
  
  dnl compilation checks
--- 220,231 ----
  AC_SUBST(HISTORY_DEP)
  
! dnl Use GNU m4 macros to get the distribution and patchlevel information
! dnl into configure without requiring the files to be distributed
! [BASHVERS=]dnl
! esyscmd(cat _distribution)dnl
! [BASHPATCH=]dnl
! esyscmd(cat _patchlevel)dnl
! 
! echo "Beginning configuration for bash-$BASHVERS"
  
  dnl compilation checks
***************
*** 201,207 ****
  AC_MINIX
  
- dnl See whether cc works at all
- BASH_CC_WORKS
- 
  dnl We want these before the checks, so the checks can modify their values.
  test -z "$CFLAGS" && CFLAGS=-g auto_cflags=1
--- 234,237 ----
***************
*** 286,290 ****
  
  AC_CHECK_HEADERS(unistd.h stdlib.h stdarg.h varargs.h limits.h string.h \
! 		 memory.h locale.h termcap.h termio.h termios.h)
  AC_CHECK_HEADERS(sys/ptem.h sys/pte.h sys/stream.h sys/select.h sys/file.h \
  		 sys/resource.h sys/param.h sys/socket.h \
--- 316,320 ----
  
  AC_CHECK_HEADERS(unistd.h stdlib.h stdarg.h varargs.h limits.h string.h \
! 		 memory.h locale.h termcap.h termio.h termios.h dlfcn.h)
  AC_CHECK_HEADERS(sys/ptem.h sys/pte.h sys/stream.h sys/select.h sys/file.h \
  		 sys/resource.h sys/param.h sys/socket.h \
***************
*** 294,298 ****
  dnl this is reportedly no longer necessary for irix[56].?
  dnl AC_CHECK_LIB(sun, getpwent)
! BASH_CHECK_SOCKLIB
  
  dnl system types
--- 324,331 ----
  dnl this is reportedly no longer necessary for irix[56].?
  dnl AC_CHECK_LIB(sun, getpwent)
! dnl check for getpeername in the socket library only if it's not in libc
! if test "$ac_cv_func_getpeername" = no; then
! 	BASH_CHECK_SOCKLIB
! fi
  
  dnl system types
***************
*** 333,342 ****
  fi
  
  BASH_DUP2_CLOEXEC_CHECK
  BASH_PGRP_SYNC
  BASH_SYS_ERRLIST
  BASH_SYS_SIGLIST
  BASH_UNDER_SYS_SIGLIST
! BASH_SIGNAL_CHECK
  BASH_TYPE_SIGHANDLER
  BASH_CHECK_TYPE(clock_t, [#include <sys/times.h>], long)
--- 366,380 ----
  fi
  
+ dnl behavior of system calls and library functions
  BASH_DUP2_CLOEXEC_CHECK
  BASH_PGRP_SYNC
+ BASH_SIGNAL_CHECK
+ 
+ dnl checking for the presence of certain library symbols
  BASH_SYS_ERRLIST
  BASH_SYS_SIGLIST
  BASH_UNDER_SYS_SIGLIST
! 
! dnl various system types
  BASH_TYPE_SIGHANDLER
  BASH_CHECK_TYPE(clock_t, [#include <sys/times.h>], long)
***************
*** 344,350 ****
--- 382,394 ----
  BASH_CHECK_TYPE(quad_t, , long, HAVE_QUAD_T)
  BASH_RLIMIT_TYPE
+ 
+ dnl presence and contents of structures used by system calls
  BASH_STRUCT_TERMIOS_LDISC
  BASH_STRUCT_TERMIO_LDISC
  BASH_STRUCT_DIRENT_D_INO
+ BASH_STRUCT_DIRENT_D_FILENO
+ BASH_STRUCT_WINSIZE
+ 
+ dnl presence and behavior of C library functions
  BASH_FUNC_STRSIGNAL
  BASH_FUNC_OPENDIR_CHECK
***************
*** 355,367 ****
  BASH_FUNC_SBRK_DECLARED
  BASH_FUNC_POSIX_SETJMP
  BASH_REINSTALL_SIGHANDLERS
  BASH_JOB_CONTROL_MISSING
  BASH_SYS_NAMED_PIPES
  BASH_HAVE_TIOCGWINSZ
  BASH_HAVE_TIOCSTAT
  BASH_HAVE_FIONREAD
  BASH_CHECK_GETPW_FUNCS
- BASH_CHECK_DEV_FD
  
  case "$host_os" in
  hpux*)	BASH_KERNEL_RLIMIT_CHECK ;;
--- 399,419 ----
  BASH_FUNC_SBRK_DECLARED
  BASH_FUNC_POSIX_SETJMP
+ BASH_FUNC_STRCOLL
+ 
+ dnl presence and behavior of OS functions
  BASH_REINSTALL_SIGHANDLERS
  BASH_JOB_CONTROL_MISSING
  BASH_SYS_NAMED_PIPES
+ 
+ dnl presence of certain CPP defines
  BASH_HAVE_TIOCGWINSZ
  BASH_HAVE_TIOCSTAT
  BASH_HAVE_FIONREAD
+ 
+ dnl miscellaneous
+ BASH_MISC_SPEED_T
  BASH_CHECK_GETPW_FUNCS
  
+ dnl special checks
  case "$host_os" in
  hpux*)	BASH_KERNEL_RLIMIT_CHECK ;;
***************
*** 369,372 ****
--- 421,428 ----
  
  if test "$opt_readline" = yes; then
+ dnl yuck
+ case "$host_os" in
+ aix*)	prefer_curses=yes ;;
+ esac
  BASH_CHECK_LIB_TERMCAP
  fi
***************
*** 374,378 ****
  AC_SUBST(TERMCAP_DEP)
  
! dnl special checks
  BASH_DEFAULT_MAIL_DIR
  
--- 430,434 ----
  AC_SUBST(TERMCAP_DEP)
  
! BASH_CHECK_DEV_FD
  BASH_DEFAULT_MAIL_DIR
  
***************
*** 390,393 ****
--- 446,454 ----
  AC_SUBST(JOBS_O)
  
+ dnl Defines that we want to propagate to the Makefiles in subdirectories,
+ dnl like glob and readline
+ 
+ LOCAL_DEFS=-DSHELL
+ 
  dnl use this section to possibly define more cpp variables, specify local
  dnl libraries, and specify any additional local cc flags
***************
*** 405,411 ****
  sco3.2v4*)	LOCAL_CFLAGS="-DMUST_UNBLOCK_CHLD -DNO_MEMSCRAMBLE -DPATH_MAX=1024" ;;
  sco3.2*)	LOCAL_CFLAGS=-DMUST_UNBLOCK_CHLD ;;
! sunos4*)	LOCAL_CFLAGS=-DSunOS4;;
! linux*)		LOCAL_LDFLAGS=-rdynamic ;;	# allow dynamic loading
! aix4.2*)	LOCAL_LDFLAGS="-bexpall -brtl";;# allow dynamic loading
  esac
  
--- 466,475 ----
  sco3.2v4*)	LOCAL_CFLAGS="-DMUST_UNBLOCK_CHLD -DNO_MEMSCRAMBLE -DPATH_MAX=1024" ;;
  sco3.2*)	LOCAL_CFLAGS=-DMUST_UNBLOCK_CHLD ;;
! sunos4*)	LOCAL_CFLAGS=-DSunOS4 ;;
! solaris2.5*)	LOCAL_CFLAGS=-DSunOS5 ;;
! linux*)		LOCAL_LDFLAGS=-rdynamic ;;	 # allow dynamic loading
! aix4.2*)	LOCAL_LDFLAGS="-bexpall -brtl" ;;# allow dynamic loading
! *qnx*)		LOCAL_CFLAGS="-Dqnx -F -3s" LOCAL_LDFLAGS="-3s -lunix -lncurses" ;;
! powerux)	LOCAL_LIBS="-lgen" ;;
  esac
  
***************
*** 444,447 ****
--- 508,514 ----
  AC_SUBST(AR)
  
+ AC_SUBST(BASHVERS)
+ AC_SUBST(BASHPATCH)
+ 
  AC_SUBST(host_cpu)
  AC_SUBST(host_os)
***************
*** 450,456 ****
  AC_SUBST(LOCAL_CFLAGS)
  AC_SUBST(LOCAL_LDFLAGS)
  
! AC_SUBST(ALLOCA_SOURCE)
! AC_SUBST(ALLOCA_OBJECT)
  
  AC_OUTPUT([Makefile builtins/Makefile lib/readline/Makefile lib/glob/Makefile \
--- 517,524 ----
  AC_SUBST(LOCAL_CFLAGS)
  AC_SUBST(LOCAL_LDFLAGS)
+ AC_SUBST(LOCAL_DEFS)
  
! #AC_SUBST(ALLOCA_SOURCE)
! #AC_SUBST(ALLOCA_OBJECT)
  
  AC_OUTPUT([Makefile builtins/Makefile lib/readline/Makefile lib/glob/Makefile \
diff -Nrc2 bash-2.0/copy_cmd.c bash-2.01/copy_cmd.c
*** bash-2.0/copy_cmd.c	Mon Jul 22 14:42:57 1996
--- bash-2.01/copy_cmd.c	Mon Feb 17 14:24:15 1997
***************
*** 29,38 ****
  #endif
  
- #if defined (HAVE_STRING_H)
- #  include <string.h>
- #else /* !HAVE_STRING_H */
- #  include <strings.h>
- #endif /* !HAVE_STRING_H */
- 
  #include "shell.h"
  
--- 29,32 ----
***************
*** 119,122 ****
--- 113,120 ----
      case r_duplicating_output_word:
        new_redirect->redirectee.filename = copy_word (redirect->redirectee.filename);
+       break;
+     case r_duplicating_input:
+     case r_duplicating_output:
+     case r_close_this:
        break;
      }
diff -Nrc2 bash-2.0/dispose_cmd.c bash-2.01/dispose_cmd.c
*** bash-2.0/dispose_cmd.c	Wed Nov 20 11:17:25 1996
--- bash-2.01/dispose_cmd.c	Tue Feb 25 12:17:14 1997
***************
*** 176,180 ****
  }
  
! /* How to dispose of an array of pointers to char. */
  void
  dispose_word_array (array)
--- 176,182 ----
  }
  
! #ifdef INCLUDE_UNUSED
! /* How to dispose of an array of pointers to char.  This is identical to
!    free_array in stringlib.c. */
  void
  dispose_word_array (array)
***************
*** 183,186 ****
--- 185,191 ----
    register int count;
  
+   if (array == 0)
+     return;
+ 
    for (count = 0; array[count]; count++)
      free (array[count]);
***************
*** 188,191 ****
--- 193,197 ----
    free (array);
  }
+ #endif
  
  /* How to dispose of an list of redirections.  A REDIRECT. */
diff -Nrc2 bash-2.0/doc/FAQ bash-2.01/doc/FAQ
*** bash-2.0/doc/FAQ	Mon Dec 23 12:02:34 1996
--- bash-2.01/doc/FAQ	Thu Jun  5 10:59:13 1997
***************
*** 1,3 ****
! This is the Bash FAQ, version 2.1, for Bash version 2.0.
  
  This document contains a set of frequently-asked questions concerning
--- 1,3 ----
! This is the Bash FAQ, version 2.5, for Bash version 2.01.
  
  This document contains a set of frequently-asked questions concerning
***************
*** 25,57 ****
  3) Where can I get it?
  4) On what machines will bash run?
! 5) How can I build bash with gcc?
! 6) How can I make bash my login shell?
! 7) I just changed my login shell to bash, and now I can't FTP into my
     machine.  Why not?
! 8) What's the `POSIX 1003.2 standard'?
! 9) What is the bash `posix mode'?
  
  Section B:  The latest version
  
! 10) What's new in version 2.0?
! 11) Are there any user-visible incompatibilities between bash-2.0 and
      bash-1.14.7?
  
  Section C:  Differences from other Unix shells
  
! 12) How does bash differ from sh, the Bourne shell?
! 13) How does bash differ from the Korn shell, version ksh88?
! 14) Which new features in ksh-93 are not in bash, and which are?
  
  Section D:  Why does bash do some things differently than other Unix shells?
  
! 15) Why does bash run a different version of `command' than
      `which command' says it will?
! 16) Why doesn't bash treat brace expansions exactly like csh?
! 17) Why doesn't bash have csh variable modifiers?
! 18) How can I make my csh aliases work when I convert to bash?
! 19) How can I pipe standard output and standard error from one command to
      another, like csh does with `|&'?
! 20) Now that I've converted from ksh to bash, are there equivalents to
      ksh features like autoloaded functions and the `whence' command?
  
--- 25,58 ----
  3) Where can I get it?
  4) On what machines will bash run?
! 5) Will bash run on operating systems other than Unix?
! 6) How can I build bash with gcc?
! 7) How can I make bash my login shell?
! 8) I just changed my login shell to bash, and now I can't FTP into my
     machine.  Why not?
! 9) What's the `POSIX 1003.2 standard'?
! 10) What is the bash `posix mode'?
  
  Section B:  The latest version
  
! 11) What's new in version 2.01?
! 12) Are there any user-visible incompatibilities between bash-2.01 and
      bash-1.14.7?
  
  Section C:  Differences from other Unix shells
  
! 13) How does bash differ from sh, the Bourne shell?
! 14) How does bash differ from the Korn shell, version ksh88?
! 15) Which new features in ksh-93 are not in bash, and which are?
  
  Section D:  Why does bash do some things differently than other Unix shells?
  
! 16) Why does bash run a different version of `command' than
      `which command' says it will?
! 17) Why doesn't bash treat brace expansions exactly like csh?
! 18) Why doesn't bash have csh variable modifiers?
! 19) How can I make my csh aliases work when I convert to bash?
! 20) How can I pipe standard output and standard error from one command to
      another, like csh does with `|&'?
! 21) Now that I've converted from ksh to bash, are there equivalents to
      ksh features like autoloaded functions and the `whence' command?
  
***************
*** 59,99 ****
              things the way it does?
  
! 21) Why is the bash builtin `test' slightly different from /bin/test?
! 22) Why does bash sometimes say `Broken pipe'?
! 23) How can I get bash to read and display eight-bit characters?
! 24) How do I write a function `x' to replace builtin command `x', but
      still invoke the command from within the function?
! 25) When I have terminal escape sequences in my prompt, why does bash
      wrap lines at the wrong column?
! 26) How can I find the value of a shell variable whose name is the value
      of another shell variable?
! 27) If I pipe the output of a command into `read variable', why doesn't
      the output show up in $variable when the read command finishes?
! 28) I have a bunch of shell scripts that use backslash-escaped characters
      in arguments to `echo'.  Bash doesn't interpret these characters.  Why
      not, and how can I make it understand them?
! 29) Why doesn't a while or for loop get suspended when I type ^Z?
! 30) How can I make the bash `time' reserved word print timing output that
      looks like the output from my system's /usr/bin/time?
  
  Section F:  Things to watch out for on certain Unix versions
  
! 31) Why can't I use command line editing in my `cmdtool'?
! 32) I built bash on Solaris 2.  Why do globbing expansions and filename
      completion chop off the first few characters of each filename?
! 33) Why does bash dump core after I interrupt username completion or
      `~user' tilde expansion on a machine running NIS?
! 34) I'm running SVR4.2.  Why is the line erased every time I type `@'?
! 35) Why does bash report syntax errors when my C News scripts use a
      redirection before a subshell command?
  
  Section G:  Where do I go from here?
  
! 36) How do I report bugs in bash, and where should I look for fixes and
      advice?
! 37) What kind of bash documentation is there?
! 38) What's coming in future versions?
! 39) What's on the bash `wish list'?
! 40) When will the next release appear?
  
  ----------
--- 60,100 ----
              things the way it does?
  
! 22) Why is the bash builtin `test' slightly different from /bin/test?
! 23) Why does bash sometimes say `Broken pipe'?
! 24) How can I get bash to read and display eight-bit characters?
! 25) How do I write a function `x' to replace builtin command `x', but
      still invoke the command from within the function?
! 26) When I have terminal escape sequences in my prompt, why does bash
      wrap lines at the wrong column?
! 27) How can I find the value of a shell variable whose name is the value
      of another shell variable?
! 28) If I pipe the output of a command into `read variable', why doesn't
      the output show up in $variable when the read command finishes?
! 29) I have a bunch of shell scripts that use backslash-escaped characters
      in arguments to `echo'.  Bash doesn't interpret these characters.  Why
      not, and how can I make it understand them?
! 30) Why doesn't a while or for loop get suspended when I type ^Z?
! 31) How can I make the bash `time' reserved word print timing output that
      looks like the output from my system's /usr/bin/time?
  
  Section F:  Things to watch out for on certain Unix versions
  
! 32) Why can't I use command line editing in my `cmdtool'?
! 33) I built bash on Solaris 2.  Why do globbing expansions and filename
      completion chop off the first few characters of each filename?
! 34) Why does bash dump core after I interrupt username completion or
      `~user' tilde expansion on a machine running NIS?
! 35) I'm running SVR4.2.  Why is the line erased every time I type `@'?
! 36) Why does bash report syntax errors when my C News scripts use a
      redirection before a subshell command?
  
  Section G:  Where do I go from here?
  
! 37) How do I report bugs in bash, and where should I look for fixes and
      advice?
! 38) What kind of bash documentation is there?
! 39) What's coming in future versions?
! 40) What's on the bash `wish list'?
! 41) When will the next release appear?
  
  ----------
***************
*** 120,124 ****
  2)  What's the latest version?
  
! The latest version is 2.0, first made available on December 23, 1996.
  
  3)  Where can I get it?
--- 121,125 ----
  2)  What's the latest version?
  
! The latest version is 2.01, first made available on June 6, 1997.
  
  3)  Where can I get it?
***************
*** 128,140 ****
  latest version is also available for FTP from slc2.ins.cwru.edu,
  the maintainer's machine.  The following URLs tell how to get
! version 2.0:
  
! ftp://prep.ai.mit.edu/pub/gnu/bash-2.0.tar.gz
! ftp://slc2.ins.cwru.edu/pub/dist/bash-2.0.tar.gz
  
  Formatted versions of the documentation are available with the URLs:
  
! ftp://prep.ai.mit.edu/pub/gnu/bash-doc-2.0.tar.gz
! ftp://slc2.ins.cwru.edu/pub/dist/bash-doc-2.0.tar.gz
  
  4)  On what machines will bash run?
--- 129,141 ----
  latest version is also available for FTP from slc2.ins.cwru.edu,
  the maintainer's machine.  The following URLs tell how to get
! version 2.01:
  
! ftp://prep.ai.mit.edu/pub/gnu/bash-2.01.tar.gz
! ftp://slc2.ins.cwru.edu/pub/dist/bash-2.01.tar.gz
  
  Formatted versions of the documentation are available with the URLs:
  
! ftp://prep.ai.mit.edu/pub/gnu/bash-doc-2.01.tar.gz
! ftp://slc2.ins.cwru.edu/pub/dist/bash-doc-2.01.tar.gz
  
  4)  On what machines will bash run?
***************
*** 148,157 ****
  More information appears in the file `INSTALL' in the distribution.
  
! 5) How can I build bash with gcc? 
  
  Bash configures to use gcc by default if it is available.  Read the
  file INSTALL in the distribution for more information.
  
! 6)  How can I make bash my login shell?
  
  Some machines let you use `chsh' to change your login shell.  Other
--- 149,195 ----
  More information appears in the file `INSTALL' in the distribution.
  
! 5) Will bash run on operating systems other than Unix?
! 
! Configuration specifics for Unix-like systems such as QNX and
! LynxOS are included in the distribution.  Previous versions of
! bash have been ported to Minix, but I don't believe anyone has
! built bash-2.x on Minix yet.
! 
! Bash has been ported to versions of Windows implementing the Win32
! programming interface.  This includes Windows 95 and Windows NT.
! The port was done by Cygnus Solutions as part of their GNU-Win32
! project.  For more information about the project, look at the URL
! 
! http://www.cygnus.com/misc/gnu-win32
! 
! Cygnus has ported bash-1.14.7.  Maybe someday they (or I) will port
! bash-2.01 (or later) to the GNU-Win32 environment.
! 
! D. J. Delorie has ported bash-1.14.7 to run under MS-DOS, as part of
! the DJGPP project.  For more information on the project, see
! 
! http://www.delorie.com/djgpp/
! 
! I picked up a binary of bash-1.14.7 that is purported to work with
! the DJGPP V2 environment from
! 
! ftp://ftp.simtel.net/pub/simtelnet/gnu/djgpp/v2gnu/bsh1147b.zip
! 
! The corresponding source is
! 
! ftp://ftp.simtel.net/pub/simtelnet/gnu/djgpp/v2gnu/bsh1147s.zip
! 
! A port of bash-1.12 is available for OS/2 from
! 
! ftp://hobbes.nmsu.edu/os2/unix/bash_112.zip
! 
! I haven't looked at it.
! 
! 6) How can I build bash with gcc? 
  
  Bash configures to use gcc by default if it is available.  Read the
  file INSTALL in the distribution for more information.
  
! 7)  How can I make bash my login shell?
  
  Some machines let you use `chsh' to change your login shell.  Other
***************
*** 183,198 ****
  to ensure that bash is exec'd only when the csh is interactive.
  
! If your login shell is sh or ksh, you have to do two things.  First, add
! a line similar to the above to ~/.profile:
  
! 	[ -f /usr/gnu/bin/bash ] && exec /usr/gnu/bin/bash --login
! 
! Next, create an empty file in your home directory named `.bash_profile'.
  The existence of this file will prevent the exec'd bash from trying to
  read ~/.profile, and re-execing itself over and over again.  ~/.bash_profile
! is the file bash tries to read initialization commands from when it is
! invoked as a login shell.
  
! 7) I just changed my login shell to bash, and now I can't FTP into my
     machine.  Why not?
  
--- 221,241 ----
  to ensure that bash is exec'd only when the csh is interactive.
  
! If your login shell is sh or ksh, you have to do two things.
  
! First, create an empty file in your home directory named `.bash_profile'.
  The existence of this file will prevent the exec'd bash from trying to
  read ~/.profile, and re-execing itself over and over again.  ~/.bash_profile
! is the first file bash tries to read initialization commands from when
! it is invoked as a login shell.
! 
! Next, add a line similar to the above to ~/.profile:
! 
!         [ -f /usr/gnu/bin/bash ] && exec /usr/gnu/bin/bash --login
  
! This will cause login shells to replace themselves with bash running as
! a login shell.  Once you have this working, you can copy your initialization
! code from ~/.profile to ~/.bash_profile.
! 
! 8) I just changed my login shell to bash, and now I can't FTP into my
     machine.  Why not?
  
***************
*** 204,208 ****
  such as `uucp' and `news' from using FTP. 
  
! 8)  What's the `POSIX 1003.2 standard'?
  
  POSIX is a name originally coined by Richard Stallman for a
--- 247,251 ----
  such as `uucp' and `news' from using FTP. 
  
! 9)  What's the `POSIX 1003.2 standard'?
  
  POSIX is a name originally coined by Richard Stallman for a
***************
*** 239,243 ****
  objections.
  
! 9)  What is the bash `posix mode'?
  
  Although bash is an implementation of the POSIX.2 shell
--- 282,286 ----
  objections.
  
! 10)  What is the bash `posix mode'?
  
  Although bash is an implementation of the POSIX.2 shell
***************
*** 256,263 ****
  Section B:  The latest version
  
! 10) What's new in version 2.0?
  
! This version contains extensive changes and new features.  Here's a
! short list:
  
  new `time' reserved word to time pipelines, shell builtins, and
--- 299,312 ----
  Section B:  The latest version
  
! 11) What's new in version 2.01?
! 
! Bash-2.01 contains only a few new features.
! 
! new `GROUPS' builtin array variable containing the user's group list
! new bindable readline commands: history-and-alias-expand-line and
! 	alias-expand-line
  
! Bash-2.0 contains extensive changes and new features from bash-1.14.7.
! Here's a short list:
  
  new `time' reserved word to time pipelines, shell builtins, and
***************
*** 296,308 ****
  test suite greatly expanded
  
! 11) Are there any user-visible incompatibilities between bash-2.0 and
      bash-1.14.7?
  
! There are a few incompatibilities between version 1.14.7 and version 2.0.
! They are detailed in the file COMPAT in the bash-2.0 distribution.
  
  Section C:  Differences from other Unix shells
  
! 12) How does bash differ from sh, the Bourne shell?
  
  This is a non-comprehensive list of features that differentiate bash
--- 345,357 ----
  test suite greatly expanded
  
! 12) Are there any user-visible incompatibilities between bash-2.01 and
      bash-1.14.7?
  
! There are a few incompatibilities between version 1.14.7 and version 2.01.
! They are detailed in the file COMPAT in the bash-2.01 distribution.
  
  Section C:  Differences from other Unix shells
  
! 13) How does bash differ from sh, the Bourne shell?
  
  This is a non-comprehensive list of features that differentiate bash
***************
*** 371,375 ****
  	`newgrp' builtin
  	turns on job control if called as `jsh'
- 	ulimit attempts to set both soft & hard limits if -S/-H not given
  	$TIMEOUT (like bash $TMOUT)
  	`^' is a synonym for `|'
--- 420,423 ----
***************
*** 387,395 ****
  	bash allows multiple option arguments when invoked (e.g. -x -v);
  		sh allows only a single option argument (`sh -x -v' attempts
! 		to open a file named `-v', and, on SunOS 4.1.4, dumps core)
  	sh exits a script if any builtin fails; bash exits only if one of
  		the POSIX.2 `special' builtins fails
  
! 13)  How does bash differ from the Korn shell, version ksh88?
  
  Things bash has or uses that ksh88 does not:
--- 435,444 ----
  	bash allows multiple option arguments when invoked (e.g. -x -v);
  		sh allows only a single option argument (`sh -x -v' attempts
! 		to open a file named `-v', and, on SunOS 4.1.4, dumps core.
! 		On Solaris 2, sh goes into an infinite loop.)
  	sh exits a script if any builtin fails; bash exits only if one of
  		the POSIX.2 `special' builtins fails
  
! 14)  How does bash differ from the Korn shell, version ksh88?
  
  Things bash has or uses that ksh88 does not:
***************
*** 439,443 ****
  Implementation differences:
  	ksh runs last command of a pipeline in parent shell context
- 	ksh ulimit sets hard and soft limits by default
  	bash has brace expansion by default (ksh88 compile-time option)
  	bash has fixed startup file for all interactive shells; ksh reads $ENV
--- 488,491 ----
***************
*** 445,451 ****
  	bash command search finds functions before builtins
  
! 14)  Which new features in ksh-93 are not in bash, and which are?
  
! New things in ksh-93 not in bash-2.0:
  	associative arrays
  	floating point arithmetic
--- 493,499 ----
  	bash command search finds functions before builtins
  
! 15)  Which new features in ksh-93 are not in bash, and which are?
  
! New things in ksh-93 not in bash-2.01:
  	associative arrays
  	floating point arithmetic
***************
*** 467,475 ****
  	read -t/-d
  	`.' can execute shell functions
- 	ENV processed only for interactive shells
  
! New things in ksh-93 present in bash-2.0:
  	?: arithmetic operator
! 	expansions: ${!param}, ${param:len[:offset]}, ${param/pat[/str]}
  	compound array assignment
  	the `!' reserved word
--- 515,522 ----
  	read -t/-d
  	`.' can execute shell functions
  
! New things in ksh-93 present in bash-2.01:
  	?: arithmetic operator
! 	expansions: ${!param}, ${param:offset[:len]}, ${param/pat[/str]}
  	compound array assignment
  	the `!' reserved word
***************
*** 489,496 ****
  	command and arithmetic substitution performed on PS1, PS4, and ENV
  	command name completion
  
  Section D:  Why does bash do some things differently than other Unix shells?
  
! 15) Why does bash run a different version of `command' than
      `which command' says it will?
  
--- 536,544 ----
  	command and arithmetic substitution performed on PS1, PS4, and ENV
  	command name completion
+ 	ENV processed only for interactive shells
  
  Section D:  Why does bash do some things differently than other Unix shells?
  
! 16) Why does bash run a different version of `command' than
      `which command' says it will?
  
***************
*** 501,505 ****
  that your bash environment differs from your csh environment. 
  
! 16) Why doesn't bash treat brace expansions exactly like csh?
  
  The only difference between bash and csh brace expansion is that
--- 549,553 ----
  that your bash environment differs from your csh environment. 
  
! 17) Why doesn't bash treat brace expansions exactly like csh?
  
  The only difference between bash and csh brace expansion is that
***************
*** 512,516 ****
  Bash, ksh, zsh, and pd-ksh all implement brace expansion this way. 
  
! 17) Why doesn't bash have csh variable modifiers?
  
  Posix has specified a more powerful, albeit somewhat more cryptic,
--- 560,564 ----
  Bash, ksh, zsh, and pd-ksh all implement brace expansion this way. 
  
! 18) Why doesn't bash have csh variable modifiers?
  
  Posix has specified a more powerful, albeit somewhat more cryptic,
***************
*** 567,571 ****
  
  
! 18) How can I make my csh aliases work when I convert to bash?
  
  Bash uses a different syntax to support aliases than csh does. 
--- 615,619 ----
  
  
! 19) How can I make my csh aliases work when I convert to bash?
  
  Bash uses a different syntax to support aliases than csh does. 
***************
*** 610,614 ****
  environment. 
  
! 19) How can I pipe standard output and standard error from one command to
      another, like csh does with `|&'?
  
--- 658,662 ----
  environment. 
  
! 20) How can I pipe standard output and standard error from one command to
      another, like csh does with `|&'?
  
***************
*** 620,624 ****
  descriptor 2.
  
! 20) Now that I've converted from ksh to bash, are there equivalents to
      ksh features like autoloaded functions and the `whence' command?
  
--- 668,672 ----
  descriptor 2.
  
! 21) Now that I've converted from ksh to bash, are there equivalents to
      ksh features like autoloaded functions and the `whence' command?
  
***************
*** 643,647 ****
  	    things the way it does?
  
! 21) Why is the bash builtin `test' slightly different from /bin/test?
  
  The specific example used here is [ ! x -o x ], which is false.
--- 691,695 ----
  	    things the way it does?
  
! 22) Why is the bash builtin `test' slightly different from /bin/test?
  
  The specific example used here is [ ! x -o x ], which is false.
***************
*** 672,676 ****
  As you can see, the test becomes (not (x or x)), which is false.
  
! 22) Why does bash sometimes say `Broken pipe'?
  
  If a sequence of commands appears in a pipeline, and one of the
--- 720,724 ----
  As you can see, the test becomes (not (x or x)), which is false.
  
! 23) Why does bash sometimes say `Broken pipe'?
  
  If a sequence of commands appears in a pipeline, and one of the
***************
*** 687,691 ****
  SIGPIPE. 
  
! 23) How can I get bash to read and display eight-bit characters?
  
  This is a process requiring several steps.
--- 735,739 ----
  SIGPIPE. 
  
! 24) How can I get bash to read and display eight-bit characters?
  
  This is a process requiring several steps.
***************
*** 721,725 ****
  in ~/.inputrc.
  
! 24) How do I write a function `x' to replace builtin command `x', but
      still invoke the command from within the function?
  
--- 769,773 ----
  in ~/.inputrc.
  
! 25) How do I write a function `x' to replace builtin command `x', but
      still invoke the command from within the function?
  
***************
*** 742,746 ****
  the version above is marginally more efficient. 
  
! 25) When I have terminal escape sequences in my prompt, why does bash
      wrap lines at the wrong column?
  
--- 790,794 ----
  the version above is marginally more efficient. 
  
! 26) When I have terminal escape sequences in my prompt, why does bash
      wrap lines at the wrong column?
  
***************
*** 758,765 ****
  and the \] escape to signal the end of such a sequence. 
  
! 26) How can I find the value of a shell variable whose name is the value
      of another shell variable?
  
! Bash-2.0 supports this directly.  You can use 
  
  	${!var}
--- 806,813 ----
  and the \] escape to signal the end of such a sequence. 
  
! 27) How can I find the value of a shell variable whose name is the value
      of another shell variable?
  
! Bash-2.01 supports this directly.  You can use 
  
  	${!var}
***************
*** 783,787 ****
  The expansion of the quoted portions of this expression will be
  deferred until `eval' runs, while the `$#' will be expanded
! before `eval' is executed.  In bash-2.0,
  
  	echo ${!#}
--- 831,835 ----
  The expansion of the quoted portions of this expression will be
  deferred until `eval' runs, while the `$#' will be expanded
! before `eval' is executed.  In bash-2.01,
  
  	echo ${!#}
***************
*** 789,793 ****
  does the same thing.
  
! 27) If I pipe the output of a command into `read variable', why doesn't
      the output show up in $variable when the read command finishes?
  
--- 837,841 ----
  does the same thing.
  
! 28) If I pipe the output of a command into `read variable', why doesn't
      the output show up in $variable when the read command finishes?
  
***************
*** 845,849 ****
  set $IFS to a different value.
  
! 28) I have a bunch of shell scripts that use backslash-escaped characters
      in arguments to `echo'.  Bash doesn't interpret these characters.  Why
      not, and how can I make it understand them?
--- 893,897 ----
  set $IFS to a different value.
  
! 29) I have a bunch of shell scripts that use backslash-escaped characters
      in arguments to `echo'.  Bash doesn't interpret these characters.  Why
      not, and how can I make it understand them?
***************
*** 865,869 ****
  type `make tests' to fail.
  
! 29) Why doesn't a while or for loop get suspended when I type ^Z?
  
  This is a consequence of how job control works on Unix.  The only
--- 913,917 ----
  type `make tests' to fail.
  
! 30) Why doesn't a while or for loop get suspended when I type ^Z?
  
  This is a consequence of how job control works on Unix.  The only
***************
*** 880,884 ****
  may be stopped (and subsequently restarted) as a single unit.
  
! 30) How can I make the bash `time' reserved word print timing output that
      looks like the output from my system's /usr/bin/time?
  
--- 928,932 ----
  may be stopped (and subsequently restarted) as a single unit.
  
! 31) How can I make the bash `time' reserved word print timing output that
      looks like the output from my system's /usr/bin/time?
  
***************
*** 914,918 ****
  Section F:  Things to watch out for on certain Unix versions
  
! 31) Why can't I use command line editing in my `cmdtool'?
  
  The problem is `cmdtool' and bash fighting over the input.  When
--- 962,966 ----
  Section F:  Things to watch out for on certain Unix versions
  
! 32) Why can't I use command line editing in my `cmdtool'?
  
  The problem is `cmdtool' and bash fighting over the input.  When
***************
*** 942,946 ****
  in your bashrc file.
  
! 32) I built bash on Solaris 2.  Why do globbing expansions and filename
      completion chop off the first few characters of each filename?
  
--- 990,994 ----
  in your bashrc file.
  
! 33) I built bash on Solaris 2.  Why do globbing expansions and filename
      completion chop off the first few characters of each filename?
  
***************
*** 962,966 ****
  /usr/ucb.
  
! 33) Why does bash dump core after I interrupt username completion or
      `~user' tilde expansion on a machine running NIS?
  
--- 1010,1014 ----
  /usr/ucb.
  
! 34) Why does bash dump core after I interrupt username completion or
      `~user' tilde expansion on a machine running NIS?
  
***************
*** 985,989 ****
  the C library malloc and avoid the problem.
  
! 34) I'm running SVR4.2.  Why is the line erased every time I type `@'?
  
  The `@' character is the default `line kill' character in most
--- 1033,1037 ----
  the C library malloc and avoid the problem.
  
! 35) I'm running SVR4.2.  Why is the line erased every time I type `@'?
  
  The `@' character is the default `line kill' character in most
***************
*** 996,1000 ****
  where the `^' and `U' can be two separate characters.
  
! 35) Why does bash report syntax errors when my C News scripts use a
      redirection before a subshell command?
  
--- 1044,1048 ----
  where the `^' and `U' can be two separate characters.
  
! 36) Why does bash report syntax errors when my C News scripts use a
      redirection before a subshell command?
  
***************
*** 1008,1012 ****
  `compound commands'.  A redirection may only follow a compound command.
  
! The file CWRU/sh-redir-hack in the bash-2.0 distribution is an
  (unofficial) patch to parse.y that will modify the grammar to
  support this construct.  It will not apply with `patch'; you must
--- 1056,1060 ----
  `compound commands'.  A redirection may only follow a compound command.
  
! The file CWRU/sh-redir-hack in the bash-2.01 distribution is an
  (unofficial) patch to parse.y that will modify the grammar to
  support this construct.  It will not apply with `patch'; you must
***************
*** 1017,1021 ****
  Section G:  Where do I go from here?
  
! 36) How do I report bugs in bash, and where should I look for fixes and
      advice?
  
--- 1065,1069 ----
  Section G:  Where do I go from here?
  
! 37) How do I report bugs in bash, and where should I look for fixes and
      advice?
  
***************
*** 1035,1039 ****
  bash-maintainers@prep.ai.mit.edu.
  
! 37) What kind of bash documentation is there?
  
  First, look in the doc directory in the bash distribution.  It should
--- 1083,1087 ----
  bash-maintainers@prep.ai.mit.edu.
  
! 38) What kind of bash documentation is there?
  
  First, look in the doc directory in the bash distribution.  It should
***************
*** 1057,1073 ****
  Cameron Newham and Bill Rosenblatt have written a book on bash, published
  by O'Reilly and Associates.  The book is based on Bill Rosenblatt's Korn
! Shell book.  The title is ``Learning the Bash Shell''.  The ISBN number is
! 1-56592-147-X.  Look for it in fine bookstores near you.  This book covers
! bash-1.14, but has an appendix describing some of the new features in
! bash-2.0. 
  
! 38) What's coming in future versions?
  
  These are features I plan to include in a future version of bash.
  
  POSIX.2-style globbing character classes ([:alpha:], [:alnum:], etc.)
! a bash debugger (an incomplete, untested version is included with bash-2.0)
  
! 39) What's on the bash `wish list' for future versions?
  
  These are features that may or may not appear in a future version of bash.
--- 1105,1125 ----
  Cameron Newham and Bill Rosenblatt have written a book on bash, published
  by O'Reilly and Associates.  The book is based on Bill Rosenblatt's Korn
! Shell book.  The title is ``Learning the Bash Shell'', and the ISBN number
! is 1-56592-147-X.  Look for it in fine bookstores near you.  This book
! covers bash-1.14, but has an appendix describing some of the new features
! in bash-2.0.  There are rumors of a second edition of this book, describing
! bash-2.0 (and 2.01).  I do not know what ORA's publication schedule for
! this edition is.
  
! 39) What's coming in future versions?
  
  These are features I plan to include in a future version of bash.
  
  POSIX.2-style globbing character classes ([:alpha:], [:alnum:], etc.)
! POSIX.2-style globbing equivalence classes
! POSIX.2-style globbing collating symbols
! a bash debugger (a minimally-tested version is included with bash-2.01)
  
! 40) What's on the bash `wish list' for future versions?
  
  These are features that may or may not appear in a future version of bash.
***************
*** 1085,1089 ****
  arithmetic ++ and -- prefix and postfix operators
  
! 40) When will the next release appear?
  
  The next version will appear sometime in 1997.  Never make predictions.
--- 1137,1141 ----
  arithmetic ++ and -- prefix and postfix operators
  
! 41) When will the next release appear?
  
  The next version will appear sometime in 1997.  Never make predictions.
diff -Nrc2 bash-2.0/doc/Makefile.in bash-2.01/doc/Makefile.in
*** bash-2.0/doc/Makefile.in	Wed Dec 18 15:27:36 1996
--- bash-2.01/doc/Makefile.in	Thu Jan 30 16:12:33 1997
***************
*** 149,160 ****
  	-$(INSTALL_DATA) $(srcdir)/bash.1 $(man1dir)/bash.${man1ext}
  	-$(INSTALL_DATA) $(srcdir)/bashbug.1 $(man1dir)/bashbug.${man1ext}
! 	-$(INSTALL_DATA) $(srcdir)/readline.3 $(man3dir)/readline.${man3ext}
! 	-$(INSTALL_DATA) $(srcdir)/bashref.info $(infodir)/bash.info
  # uncomment the next line to install the builtins man page
  #	$(INSTALL_DATA) builtins.1 $(man1dir)/bash_builtins.${man1ext}
  
  uninstall:
! 	$(RM) $(man1dir)/bash.${man1ext} $(man1dir)/bashbug.${man1ext}
! 	$(RM) $(man3dir)/readline.${man3ext} $(infodir)/bash.info
  
  # for use by chet
--- 149,166 ----
  	-$(INSTALL_DATA) $(srcdir)/bash.1 $(man1dir)/bash.${man1ext}
  	-$(INSTALL_DATA) $(srcdir)/bashbug.1 $(man1dir)/bashbug.${man1ext}
! # uncomment the next line to install the readline man page
! #	-$(INSTALL_DATA) $(srcdir)/readline.3 $(man3dir)/readline.${man3ext}
  # uncomment the next line to install the builtins man page
  #	$(INSTALL_DATA) builtins.1 $(man1dir)/bash_builtins.${man1ext}
+ 	-$(INSTALL_DATA) $(srcdir)/bashref.info $(infodir)/bash.info
+ # run install-info if it is present to update the info directory
+ 	if $(SHELL) -c 'install-info --version' >/dev/null 2>&1; then \
+ 		install-info --dir-file=$(infodir)/dir $(infodir)/bash.info; \
+ 	else true; fi
  
  uninstall:
! 	-$(RM) $(man1dir)/bash.${man1ext} $(man1dir)/bashbug.${man1ext}
! 	-$(RM) $(man3dir)/readline.${man3ext}
! 	$(RM) $(infodir)/bash.info
  
  # for use by chet
diff -Nrc2 bash-2.0/doc/bash.1 bash-2.01/doc/bash.1
*** bash-2.0/doc/bash.1	Mon Nov 25 15:45:21 1996
--- bash-2.01/doc/bash.1	Mon May 19 12:56:34 1997
***************
*** 7,15 ****
  .\"	chet@ins.CWRU.Edu
  .\"
! .\"	Last Change: Mon Nov 25 15:36:20 EST 1996
  .\"
  .\" bash_builtins, strip all but Built-Ins section
  .if \n(zZ=1 .ig zZ
! .TH BASH 1 "1996 Nov 25" GNU
  .\"
  .\" There's some problem with having a `@'
--- 7,15 ----
  .\"	chet@ins.CWRU.Edu
  .\"
! .\"	Last Change: Mon May 19 12:45:24 EDT 1997
  .\"
  .\" bash_builtins, strip all but Built-Ins section
  .if \n(zZ=1 .ig zZ
! .TH BASH 1 "1997 May 19" GNU
  .\"
  .\" There's some problem with having a `@'
***************
*** 257,262 ****
  When
  .B bash
! is invoked as a login shell, it first reads and executes commands
! from the file \fI/etc/profile\fP, if that file exists.
  After reading that file, it looks for \fI~/.bash_profile\fP,
  \fI~/.bash_login\fP, and \fI~/.profile\fP, in that order, and reads
--- 257,263 ----
  When
  .B bash
! is invoked as an interactive login shell, it first reads and
! executes commands from the file \fI/etc/profile\fP, if that
! file exists.
  After reading that file, it looks for \fI~/.bash_profile\fP,
  \fI~/.bash_login\fP, and \fI~/.profile\fP, in that order, and reads
***************
*** 624,628 ****
  or zero if no commands were executed.
  .TP
! \fBcase\fP \fIword\fP \fBin\fP [ \fIpattern\fP [ \fB|\fP \fIpattern\fP ] \
  ... ) \fIlist\fP ;; ] ... \fBesac\fP
  A \fBcase\fP command first expands \fIword\fP, and tries to match
--- 625,629 ----
  or zero if no commands were executed.
  .TP
! \fBcase\fP \fIword\fP \fBin\fP [ ( \fIpattern\fP [ \fB|\fP \fIpattern\fP ] \
  ... ) \fIlist\fP ;; ] ... \fBesac\fP
  A \fBcase\fP command first expands \fIword\fP, and tries to match
***************
*** 903,907 ****
  .SM
  .B IFS
! is null or unset, the parameters are separated by spaces.
  .TP
  .B @
--- 904,912 ----
  .SM
  .B IFS
! is unset, the parameters are separated by spaces.
! If
! .SM
! .B IFS
! is null, the parameters are joined without intervening separators.
  .TP
  .B @
***************
*** 1000,1003 ****
--- 1005,1012 ----
  shell startup.
  .TP
+ .B GROUPS
+ An array variable containing the list of groups of which the current
+ user is a member.
+ .TP
  .B BASH
  Expands to the full file name used to invoke this instance of
***************
*** 1222,1226 ****
  ``.:~:/usr''.
  .TP
! .B ENV
  If this parameter is set when \fBbash\fP is executing a shell script,
  its value is interpreted as a filename containing commands to
--- 1231,1235 ----
  ``.:~:/usr''.
  .TP
! .B BASH_ENV
  If this parameter is set when \fBbash\fP is executing a shell script,
  its value is interpreted as a filename containing commands to
***************
*** 1229,1233 ****
  The value of
  .SM
! .B ENV
  is subjected to parameter expansion, command substitution, and arithmetic
  expansion before being interpreted as a file name.
--- 1238,1242 ----
  The value of
  .SM
! .B BASH_ENV
  is subjected to parameter expansion, command substitution, and arithmetic
  expansion before being interpreted as a file name.
***************
*** 3131,3135 ****
  This is the library that handles reading input when using an interactive
  shell, unless the
! .B \-noediting
  option is given at shell invocation.
  By default, the line editing commands are similar to those of emacs.
--- 3140,3144 ----
  This is the library that handles reading input when using an interactive
  shell, unless the
! .B \-\-noediting
  option is given at shell invocation.
  By default, the line editing commands are similar to those of emacs.
***************
*** 3669,3677 ****
  .TP
  .B history\-expand\-line (M\-^)
! Perform history expansion on the current line.  See
  .SM
  .B HISTORY EXPANSION
  below for a description of history expansion.
  .TP
  .B insert\-last\-argument (M\-.\^, M\-_\^)
  A synonym for \fByank\-last\-arg\fP.
--- 3678,3697 ----
  .TP
  .B history\-expand\-line (M\-^)
! Perform history expansion on the current line.
! See
  .SM
  .B HISTORY EXPANSION
  below for a description of history expansion.
  .TP
+ .B alias\-expand\-line
+ Perform alias expansion on the current line.
+ See
+ .SM
+ .B ALIASES
+ above for a description of alias expansion.
+ .TP
+ .B history\-and\-alias\-expand\-line
+ Perform history and alias expansion on the current line.
+ .TP
  .B insert\-last\-argument (M\-.\^, M\-_\^)
  A synonym for \fByank\-last\-arg\fP.
***************
*** 3795,3801 ****
  .TP
  .B universal\-argument
! Each time this is executed, the argument count is multiplied by four.
  The argument count is initially one, so executing this function the
! first time makes the argument count four.
  .PD
  .SS Completing
--- 3815,3830 ----
  .TP
  .B universal\-argument
! This is another way to specify an argument.
! If this command is followed by one or more digits, optionally with a
! leading minus sign, those digits define the argument.
! If the command is followed by digits, executing
! .B universal\-argument
! again ends the numeric argument, but is otherwise ignored.
! As a special case, if this command is immediately followed by a
! character that is neither a digit or minus sign, the argument count
! for the next command is multiplied by four.
  The argument count is initially one, so executing this function the
! first time makes the argument count four, a second time makes the
! argument count sixteen, and so on.
  .PD
  .SS Completing
***************
*** 3981,3985 ****
  .SH HISTORY
  When the
! .B -o history
  option to the
  .B set
--- 4010,4014 ----
  .SH HISTORY
  When the
! .B \-o history
  option to the
  .B set
***************
*** 5495,5504 ****
  Rotates the stack so that the \fIn\fPth directory
  (counting from the left of the list shown by
! .BR dirs )
  is at the top.
  .TP
  \fB\-\fP\fIn\fP
  Rotates the stack so that the \fIn\fPth directory
! (counting from the right) is at the top.
  .TP
  .B \-n
--- 5524,5536 ----
  Rotates the stack so that the \fIn\fPth directory
  (counting from the left of the list shown by
! .BR dirs ,
! starting with zero)
  is at the top.
  .TP
  \fB\-\fP\fIn\fP
  Rotates the stack so that the \fIn\fPth directory
! (counting from the right of the list shown by
! .BR dirs ,
! starting with zero) is at the top.
  .TP
  .B \-n
***************
*** 6007,6011 ****
  If a correction is found, the corrected file name is printed,
  and the command proceeds.
! This option is enabled by default, but is only used by interactive shells.
  .TP 8
  .B checkhash
--- 6039,6043 ----
  If a correction is found, the corrected file name is printed,
  and the command proceeds.
! This option is only used by interactive shells.
  .TP 8
  .B checkhash
***************
*** 6304,6308 ****
  for processes run from the shell.  The return status is 0.
  .TP
! \fBtrap\fP [\fB\-lp\fP] [\fIarg\fP] [\fIsigspec\fP]
  The command
  .I arg
--- 6336,6340 ----
  for processes run from the shell.  The return status is 0.
  .TP
! \fBtrap\fP [\fB\-lp\fP] [\fIarg\fP] [\fIsigspec\fP ...]
  The command
  .I arg
***************
*** 6316,6324 ****
  all specified signals are
  reset to their original values (the values they had
! upon entrance to the shell).  If 
  .I arg
! is the null string this
! signal is ignored by the shell and by the
! commands it invokes.
  If
  .I arg
--- 6348,6357 ----
  all specified signals are
  reset to their original values (the values they had
! upon entrance to the shell).
! If 
  .I arg
! is the null string the signal specified by each
! .I sigspec
! is ignored by the shell and by the commands it invokes.
  If
  .I arg
***************
*** 6334,6340 ****
  .B trap
  prints the list of commands associated with each signal number.
  .I sigspec
  is either
! a signal name defined in <\fIsignal.h\fP>, or a signal number.  If
  .I sigspec
  is
--- 6367,6375 ----
  .B trap
  prints the list of commands associated with each signal number.
+ Each
  .I sigspec
  is either
! a signal name defined in <\fIsignal.h\fP>, or a signal number.
! If a
  .I sigspec
  is
***************
*** 6343,6347 ****
  (0) the command
  .I arg
! is executed on exit from the shell.  If
  .I sigspec
  is
--- 6378,6382 ----
  (0) the command
  .I arg
! is executed on exit from the shell.  If a
  .I sigspec
  is
***************
*** 6360,6364 ****
  Signals ignored upon entry to the shell cannot be trapped or reset.
  Trapped signals are reset to their original values in a child
! process when it is created.  The return status is false if any
  .I sigspec
  is invalid; otherwise
--- 6395,6400 ----
  Signals ignored upon entry to the shell cannot be trapped or reset.
  Trapped signals are reset to their original values in a child
! process when it is created.
! The return status is false if any
  .I sigspec
  is invalid; otherwise
***************
*** 6724,6729 ****
  .I bashbug
  command to submit a bug report.
! If you have a fix, you are welcome to mail that
! as well!
  Suggestions and `philosophical' bug reports may be mailed
  to \fPbug-bash\fP@\fIprep.ai.MIT.Edu\fP or posted to the Usenet
--- 6760,6764 ----
  .I bashbug
  command to submit a bug report.
! If you have a fix, you are encouraged to mail that as well!
  Suggestions and `philosophical' bug reports may be mailed
  to \fPbug-bash\fP@\fIprep.ai.MIT.Edu\fP or posted to the Usenet
diff -Nrc2 bash-2.0/doc/bashref.info bash-2.01/doc/bashref.info
*** bash-2.0/doc/bashref.info	Wed Dec 18 17:06:05 1996
--- bash-2.01/doc/bashref.info	Mon May 19 12:57:34 1997
***************
*** 5,11 ****
  the Bash shell.
  
! This is Edition 2.0, last updated 25 November 1996,
  of `The GNU Bash Reference Manual',
! for `Bash', Version 2.0.
  
  Copyright (C) 1991, 1993, 1996 Free Software Foundation, Inc.
--- 5,11 ----
  the Bash shell.
  
! This is Edition 2.0, last updated 19 May 1997,
  of `The GNU Bash Reference Manual',
! for `Bash', Version 2.01.
  
  Copyright (C) 1991, 1993, 1996 Free Software Foundation, Inc.
***************
*** 34,39 ****
  the Bash shell.
  
!    This is Edition 2.0, last updated 25 November 1996, of `The GNU Bash
! Reference Manual', for `Bash', Version 2.0.
  
     Copyright (C) 1991, 1993, 1996 Free Software Foundation, Inc.
--- 34,39 ----
  the Bash shell.
  
!    This is Edition 2.0, last updated 19 May 1997, of `The GNU Bash
! Reference Manual', for `Bash', Version 2.01.
  
     Copyright (C) 1991, 1993, 1996 Free Software Foundation, Inc.
***************
*** 206,211 ****
  
  `job control'
!      A mechanism by which users can selectively start and stop execution
!      of processes.
  
  `metacharacter'
--- 206,211 ----
  
  `job control'
!      A mechanism by which users can selectively stop (suspend) and
!      restart (resume) execution of processes.
  
  `metacharacter'
***************
*** 613,617 ****
       The syntax of the `case' command is:
  
!           `case WORD in [PATTERN [| PATTERN]...) COMMANDS ;;]... esac'
  
       Selectively execute COMMANDS based upon WORD matching PATTERN.
--- 613,617 ----
       The syntax of the `case' command is:
  
!           `case WORD in [ ( PATTERN [| PATTERN]...) COMMANDS ;;]... esac'
  
       Selectively execute COMMANDS based upon WORD matching PATTERN.
***************
*** 635,639 ****
  
       The EXPRESSION is evaluated according to the rules described below
!      ((*note Arithmetic Evaluation::.).  If the value of the expression
       is non-zero, the return status is 0; otherwise the return status
       is 1.  This is exactly equivalent to
--- 635,639 ----
  
       The EXPRESSION is evaluated according to the rules described below
!      (*note Arithmetic Evaluation::.).  If the value of the expression
       is non-zero, the return status is 0; otherwise the return status
       is 1.  This is exactly equivalent to
***************
*** 674,679 ****
  braces are `reserved words', so they must be separated from the LIST by
  `blank's.  The parentheses are `operators', and are recognized as
! separate tokens by the shell even if they are not separated from `list'
! by whitespace.
  
     The exit status of both of these constructs is the exit status of
--- 674,679 ----
  braces are `reserved words', so they must be separated from the LIST by
  `blank's.  The parentheses are `operators', and are recognized as
! separate tokens by the shell even if they are not separated from the
! LIST by whitespace.
  
     The exit status of both of these constructs is the exit status of
***************
*** 702,706 ****
     When a function is executed, the arguments to the function become
  the positional parameters during its execution (*note Positional
! Parameters::.).  The special parameter `#' that gives the number of
  positional parameters is updated to reflect the change.  Positional
  parameter `0' is unchanged.
--- 702,706 ----
     When a function is executed, the arguments to the function become
  the positional parameters during its execution (*note Positional
! Parameters::.).  The special parameter `#' that expands to the number of
  positional parameters is updated to reflect the change.  Positional
  parameter `0' is unchanged.
***************
*** 784,789 ****
       of the `IFS' special variable.  That is, `"$*"' is equivalent to
       `"$1C$2C..."', where C is the first character of the value of the
!      `IFS' variable.  If `IFS' is null or unset, the parameters are
!      separated by spaces.
  
  `@'
--- 784,790 ----
       of the `IFS' special variable.  That is, `"$*"' is equivalent to
       `"$1C$2C..."', where C is the first character of the value of the
!      `IFS' variable.  If `IFS' is unset, the parameters are separated
!      by spaces.  If `IFS' is null, the parameters are joined without
!      intervening separators.
  
  `@'
***************
*** 881,885 ****
  change the number of words of the expansion; other expansions expand a
  single word to a single word.  The only exceptions to this are the
! expansions of `"$@"' (*note Special Parameters::.) and `"${[@]}"'
  (*note Arrays::.).
  
--- 882,886 ----
  change the number of words of the expansion; other expansions expand a
  single word to a single word.  The only exceptions to this are the
! expansions of `"$@"' (*note Special Parameters::.) and `"${NAME[@]}"'
  (*note Arrays::.).
  
***************
*** 908,914 ****
  of variable indirection is introduced.  Bash uses the value of the
  variable formed from the rest of PARAMETER as the name of the variable;
! this variable is then expanded and that value used in the rest of the
! substitution, rather than the value of PARAMETER itself.  This is known
! as `indirect expansion'.
  
     In each of the cases below, WORD is subject to tilde expansion,
--- 909,915 ----
  of variable indirection is introduced.  Bash uses the value of the
  variable formed from the rest of PARAMETER as the name of the variable;
! this variable is then expanded and that value is used in the rest of
! the substitution, rather than the value of PARAMETER itself.  This is
! known as `indirect expansion'.
  
     In each of the cases below, WORD is subject to tilde expansion,
***************
*** 1655,1672 ****
  
  `trap'
!           trap [-lp] [ARG] [SIGSPEC]
       The commands in ARG are to be read and executed when the shell
       receives signal SIGSPEC.  If ARG is absent or equal to `-', all
       specified signals are reset to the values they had when the shell
!      was started.  If ARG is the null string, then SIGSPEC is ignored by
!      the shell and commands it invokes.  If ARG is `-p', the shell
!      displays the trap commands associated with each SIGSPEC.  If no
!      arguments are supplied, or only `-p' is given, `trap' prints the
!      list of commands associated with each signal number.  SIGSPEC is
!      either a signal name such as `SIGINT' or a signal number.  If
!      SIGSPEC is `0' or `EXIT', ARG is executed when the shell exits.
!      If SIGSPEC is `DEBUG', the command ARG is executed after every
!      simple command.  The `-l' option causes the shell to print a list
!      of signal names and their corresponding numbers.
  
       Signals ignored upon entry to the shell cannot be trapped or reset.
--- 1656,1674 ----
  
  `trap'
!           trap [-lp] [ARG] [SIGSPEC ...]
       The commands in ARG are to be read and executed when the shell
       receives signal SIGSPEC.  If ARG is absent or equal to `-', all
       specified signals are reset to the values they had when the shell
!      was started.  If ARG is the null string, then the signal specified
!      by each SIGSPEC is ignored by the shell and commands it invokes.
!      If ARG is `-p', the shell displays the trap commands associated
!      with each SIGSPEC.  If no arguments are supplied, or only `-p' is
!      given, `trap' prints the list of commands associated with each
!      signal number.  Each SIGSPEC is either a signal name such as
!      `SIGINT' (with or without the `SIG' prefix) or a signal number.
!      If a SIGSPEC is `0' or `EXIT', ARG is executed when the shell
!      exits.  If a SIGSPEC is `DEBUG', the command ARG is executed after
!      every simple command.  The `-l' option causes the shell to print a
!      list of signal names and their corresponding numbers.
  
       Signals ignored upon entry to the shell cannot be trapped or reset.
***************
*** 1827,1831 ****
  in a script (*note Locale Translation::.).
  
!    The expansion `${var:'LENGTH`[:'OFFSET`]}', which expands to the
  substring of `var''s value of length LENGTH, optionally beginning at
  OFFSET, is present (*note Shell Parameter Expansion::.).
--- 1829,1833 ----
  in a script (*note Locale Translation::.).
  
!    The expansion `${var:'OFFSET`[:'LENGTH`]}', which expands to the
  substring of `var''s value of length LENGTH, optionally beginning at
  OFFSET, is present (*note Shell Parameter Expansion::.).
***************
*** 1843,1850 ****
  
     Bash automatically assigns variables that provide information about
! the current user (`UID' and `EUID'), the current host (`HOSTTYPE',
! `OSTYPE', `MACHTYPE', and `HOSTNAME'), and the instance of Bash that is
! running (`BASH', `BASH_VERSION', and `BASH_VERSINFO'.  *Note Bash
! Variables::, for details.
  
     The `IFS' variable is used to split only the results of expansion,
--- 1845,1852 ----
  
     Bash automatically assigns variables that provide information about
! the current user (`UID', `EUID', and `GROUPS'), the current host
! (`HOSTTYPE', `OSTYPE', `MACHTYPE', and `HOSTNAME'), and the instance of
! Bash that is running (`BASH', `BASH_VERSION', and `BASH_VERSINFO'.
! *Note Bash Variables::, for details.
  
     The `IFS' variable is used to split only the results of expansion,
***************
*** 1859,1865 ****
  
     Variable assignments preceding commands affect only that command,
! even builtins and functions.  In `sh', all variable assignments
! preceding commands are global unless the command is executed from the
! file system.
  
     Bash performs filename expansion on filenames specified as operands
--- 1861,1867 ----
  
     Variable assignments preceding commands affect only that command,
! even builtins and functions (*note Environment::.).  In `sh', all
! variable assignments preceding commands are global unless the command
! is executed from the file system.
  
     Bash performs filename expansion on filenames specified as operands
***************
*** 1933,1946 ****
  simultaneously.
  
!    The Bash `cd' and `pwd' builtins each take `-L' and `-P' builtins to
! switch between logical and physical modes.
  
     The Bash `type' builtin is more extensive and gives more information
! about the names it finds.
  
     Bash implements a `csh'-like directory stack, and provides the
! `pushd', `popd', and `dirs' builtins to manipulate it.  Bash also makes
! the directory stack visible as the value of the `DIRSTACK' shell
! variable.
  
     The Bash restricted mode is more useful (*note The Restricted
--- 1935,1949 ----
  simultaneously.
  
!    The Bash `cd' and `pwd' builtins (*note Bourne Shell Builtins::.)
! each take `-L' and `-P' builtins to switch between logical and physical
! modes.
  
     The Bash `type' builtin is more extensive and gives more information
! about the names it finds (*note Bash Builtins::.).
  
     Bash implements a `csh'-like directory stack, and provides the
! `pushd', `popd', and `dirs' builtins to manipulate it (*note C Shell
! Builtins::.).  Bash also makes the directory stack visible as the value
! of the `DIRSTACK' shell variable.
  
     The Bash restricted mode is more useful (*note The Restricted
***************
*** 1980,1987 ****
       function call), the shell misbehaves badly.
  
!    * In a questionable attempt at security, the SVR4.2 shell will alter
!      its real and effective UID and GID if they are less than some
!      threshold value, commonly 100.  This can lead to unexpected
!      results.
  
     * The SVR4.2 shell does not allow users to trap `SIGALRM' or
--- 1983,1990 ----
       function call), the shell misbehaves badly.
  
!    * In a questionable attempt at security, the SVR4.2 shell, when
!      invoked without the `-p' option, will alter its real and effective
!      UID and GID if they are less than some magic threshold value,
!      commonly 100.  This can lead to unexpected results.
  
     * The SVR4.2 shell does not allow users to trap `SIGALRM' or
***************
*** 2000,2004 ****
     * The SVR4.2 shell exits a script if any builtin fails; Bash exits a
       script only if one of the POSIX.2 special builtins fails, and only
!      for certain failures, as enumerated in the `POSIX.2' standard.
  
     * The SVR4.2 shell behaves differently when invoked as `jsh' (it
--- 2003,2007 ----
     * The SVR4.2 shell exits a script if any builtin fails; Bash exits a
       script only if one of the POSIX.2 special builtins fails, and only
!      for certain failures, as enumerated in the POSIX.2 standard.
  
     * The SVR4.2 shell behaves differently when invoked as `jsh' (it
***************
*** 2109,2119 ****
      `+N'
            Brings the Nth directory (counting from the left of the list
!           printed by `dirs') to the top of the list by rotating the
!           stack.
  
      `-N'
            Brings the Nth directory (counting from the right of the list
!           printed by `dirs') to the top of the list by rotating the
!           stack.
  
      `-n'
--- 2112,2122 ----
      `+N'
            Brings the Nth directory (counting from the left of the list
!           printed by `dirs', starting with zero) to the top of the list
!           by rotating the stack.
  
      `-N'
            Brings the Nth directory (counting from the right of the list
!           printed by `dirs', starting with zero) to the top of the list
!           by rotating the stack.
  
      `-n'
***************
*** 2289,2296 ****
  
     Bash also has adopted command timing from the Korn shell.  If the
! `time' reserved word precedes a pipeline or simple command, timing
! statistics for the pipeline are displayed when it completes.  The
! statistics currently consist of elapsed (wall-clock) time and user and
! system time consumed by the command's execution.
  
     The use of `time' as a reserved word permits the timing of shell
--- 2292,2299 ----
  
     Bash also has adopted command timing from the Korn shell.  If the
! `time' reserved word precedes a pipeline, which may consist of a single
! command, timing statistics for the pipeline are displayed when it
! completes.  The statistics currently consist of elapsed (wall-clock)
! time and user and system time consumed by the command's execution.
  
     The use of `time' as a reserved word permits the timing of shell
***************
*** 2390,2399 ****
       executing.
  
- `ENV'
-      If this variable is set when Bash is invoked to execute a shell
-      script, its value is expanded and used as the name of a startup
-      file to read before executing the script.  *Note Bash Startup
-      Files::.
- 
  `FCEDIT'
       The editor used as a default by the `fc' builtin command.
--- 2393,2396 ----
***************
*** 2610,2624 ****
  ==================
  
!    This section describs how bash executes its startup files.  If any
! of the files exist but cannot be read, bash reports an error.  Tildes
  are expanded in file names as described above under Tilde Expansion
  (*note Tilde Expansion::.).
  
!    When Bash is invoked as a login shell, it first reads and executes
! commands from the file `/etc/profile', if that file exists.  After
! reading that file, it looks for `~/.bash_profile', `~/.bash_login', and
! `~/.profile', in that order, and reads and executes commands from the
! first one that exists and is readable.  The `--noprofile' option may be
! used when the shell is started to inhibit this behavior.
  
     When a login shell exits, Bash reads and executes commands from the
--- 2607,2622 ----
  ==================
  
!    This section describs how Bash executes its startup files.  If any
! of the files exist but cannot be read, Bash reports an error.  Tildes
  are expanded in file names as described above under Tilde Expansion
  (*note Tilde Expansion::.).
  
!    When Bash is invoked as an interactive login shell, it first reads
! and executes commands from the file `/etc/profile', if that file exists.
! After reading that file, it looks for `~/.bash_profile',
! `~/.bash_login', and `~/.profile', in that order, and reads and
! executes commands from the first one that exists and is readable.  The
! `--noprofile' option may be used when the shell is started to inhibit
! this behavior.
  
     When a login shell exits, Bash reads and executes commands from the
***************
*** 2668,2672 ****
  mode, the `ENV' variable is expanded and commands are read and executed
  from the file whose name is the expanded value.  No other startup files
! are read.  This is done by both interactive and non-interactive shells.
  
     Bash attempts to determine when it is being run by the remote shell
--- 2666,2670 ----
  mode, the `ENV' variable is expanded and commands are read and executed
  from the file whose name is the expanded value.  No other startup files
! are read.  This is done by interactive shells only.
  
     Bash attempts to determine when it is being run by the remote shell
***************
*** 2700,2703 ****
--- 2698,2709 ----
       fi
  
+    Alternatively, you may test the value of the `-' special parameter.
+ It contains `i' when the shell is interactive.  For example:
+ 
+      case "$-" in
+      *i*)	echo This shell is interactive ;;
+      *)	echo This shell is not interactive ;;
+      esac
+ 
  
  File: bashref.info,  Node: Bash Builtins,  Next: The Set Builtin,  Prev: Is This Shell Interactive?,  Up: Bash Features
***************
*** 2765,2771 ****
  `builtin'
            builtin [SHELL-BUILTIN [ARGS]]
!      Run a shell builtin.  This is useful when you wish to rename a
!      shell builtin to be a function, but need the functionality of the
!      builtin within the function itself.
  
  `command'
--- 2771,2777 ----
  `builtin'
            builtin [SHELL-BUILTIN [ARGS]]
!      Run a shell builtin.  This is useful when you wish to define a
!      shell function with the same name as a shell builtin, but need the
!      functionality of the builtin within the function itself.
  
  `command'
***************
*** 2975,2979 ****
            character too many.  If a correction is found, the corrected
            path is printed, and the command proceeds.  This option is
!           enabled by default, but is only used by interactive shells.
  
      `checkhash'
--- 2981,2985 ----
            character too many.  If a correction is found, the corrected
            path is printed, and the command proceeds.  This option is
!           only used by interactive shells.
  
      `checkhash'
***************
*** 3019,3023 ****
            If set, and Readline is being used, Bash will attempt to
            perform hostname completion when a word beginning with `@' is
!           being completed (*note Commands For Completion::.).
  
      `interactive_comments'
--- 3025,3030 ----
            If set, and Readline is being used, Bash will attempt to
            perform hostname completion when a word beginning with `@' is
!           being completed (*note Commands For Completion::.).  This
!           option is enabled by default.
  
      `interactive_comments'
***************
*** 3250,3257 ****
  
      `-p'
!           Turn on privileged mode.  In this mode, the `$ENV' file is
!           not processed, and shell functions are not inherited from the
!           environment.  This is enabled automatically on startup if the
!           effective user (group) id is not equal to the real user
            (group) id.  Turning this option off causes the effective user
            and group ids to be set to the real user and group ids.
--- 3257,3264 ----
  
      `-p'
!           Turn on privileged mode.  In this mode, the `$BASH_ENV' file
!           is not processed, and shell functions are not inherited from
!           the environment.  This is enabled automatically on startup if
!           the effective user (group) id is not equal to the real user
            (group) id.  Turning this option off causes the effective user
            and group ids to be set to the real user and group ids.
***************
*** 3485,3488 ****
--- 3492,3501 ----
  normally treat them specially.
  
+ `BASH_ENV'
+      If this variable is set when Bash is invoked to execute a shell
+      script, its value is expanded and used as the name of a startup
+      file to read before executing the script.  *Note Bash Startup
+      Files::.
+ 
  `TIMEFORMAT'
       The value of this parameter is used as a format string specifying
***************
*** 3519,3525 ****
  
       If this variable is not set, bash acts as if it had the value
!      `$'\nreal\t%3lR\nuser\t%3lU\nsys\t%3lS''.  If the value is null,
!      no timing information is displayed.  A trailing newline is added
!      when the format string is displayed.
  
  `HISTCONTROL'
--- 3532,3538 ----
  
       If this variable is not set, bash acts as if it had the value
!           `$'\nreal\t%3lR\nuser\t%3lU\nsys\t%3lS''.
!      If the value is null, no timing information is displayed.  A
!      trailing newline is added when the format string is displayed.
  
  `HISTCONTROL'
***************
*** 3604,3607 ****
--- 3617,3624 ----
       The numeric effective user id of the current user.
  
+ `GROUPS'
+      An array variable containing the list of groups of which the
+      current user is a member.
+ 
  `PPID'
       The process id of the shell's parent process.
***************
*** 3692,3697 ****
  `SHLVL'
       Incremented by one each time a new instance of Bash is started.
!      This is intended to be an account of how deeply your Bash shells
!      are nested.
  
  `OPTERR'
--- 3709,3714 ----
  `SHLVL'
       Incremented by one each time a new instance of Bash is started.
!      This is intended to be a count of how deeply your Bash shells are
!      nested.
  
  `OPTERR'
***************
*** 3707,3713 ****
       variable specifying a locale category.
  
  `LC_MESSAGES'
       This variable determines the locale used to translate double-quoted
!      strings preceded by a `$'.
  
  `IGNOREEOF'
--- 3724,3734 ----
       variable specifying a locale category.
  
+ `LC_COLLATE'
+      This variable determines the collation order used when sorting the
+      results of filename expansion (*note Filename Expansion::.).
+ 
  `LC_MESSAGES'
       This variable determines the locale used to translate double-quoted
!      strings preceded by a `$' (*note Locale Translation::.).
  
  `IGNOREEOF'
***************
*** 4111,4114 ****
--- 4132,4138 ----
       in the shell environment after the builtin completes.
  
+  21. The `export' and `readonly' builtin commands display their output
+      in the format required by POSIX.2.
+ 
  
     There is other POSIX.2 behavior that Bash does not implement.
***************
*** 4265,4272 ****
            kill -l [SIGSPEC]
       Send a signal specified by SIGSPEC or SIGNUM to the process named
!      by JOBSPEC.  SIGSPEC is either a signal name such as `SIGINT' or a
!      signal number; SIGNUM is a signal number.  If SIGSPEC and SIGNUM
!      are not present, `SIGTERM' is used.  The `-l' option lists the
!      signal names, or the signal name corresponding to SIGSPEC.
  
  `wait'
--- 4289,4297 ----
            kill -l [SIGSPEC]
       Send a signal specified by SIGSPEC or SIGNUM to the process named
!      by JOBSPEC.  SIGSPEC is either a signal name such as `SIGINT'
!      (with or without the `SIG' prefix) or a signal number; SIGNUM is a
!      signal number.  If SIGSPEC and SIGNUM are not present, `SIGTERM'
!      is used.  The `-l' option lists the signal names, or the signal
!      name corresponding to SIGSPEC.
  
  `wait'
***************
*** 4305,4314 ****
       job control.  If this variable exists then single word simple
       commands without redirects are treated as candidates for resumption
!      of an existing job.  There is no ambiguity allowed; if you have
!      more than one job beginning with the string that you have typed,
!      then the most recently accessed job will be selected.  The name of
!      a stopped job, in this context, is the command line used to start
!      it.  If this variable is set to the value `exact', the string
!      supplied must match the name of a stopped job exactly; if set to
       `substring', the string supplied needs to match a substring of the
       name of a stopped job.  The `substring' value provides
--- 4330,4339 ----
       job control.  If this variable exists then single word simple
       commands without redirects are treated as candidates for resumption
!      of an existing job.  There is no ambiguity allowed; if there is
!      more than one job beginning with the string typed, then the most
!      recently accessed job will be selected.  The name of a stopped
!      job, in this context, is the command line used to start it.  If
!      this variable is set to the value `exact', the string supplied
!      must match the name of a stopped job exactly; if set to
       `substring', the string supplied needs to match a substring of the
       name of a stopped job.  The `substring' value provides
***************
*** 5095,5123 ****
       # Arrow keys in keypad mode
       #
!      #"\M-OD"        backward-char
!      #"\M-OC"        forward-char
!      #"\M-OA"        previous-history
!      #"\M-OB"        next-history
       #
       # Arrow keys in ANSI mode
       #
!      "\M-[D"        backward-char
!      "\M-[C"        forward-char
!      "\M-[A"        previous-history
!      "\M-[B"        next-history
       #
       # Arrow keys in 8 bit keypad mode
       #
!      #"\M-\C-OD"       backward-char
!      #"\M-\C-OC"       forward-char
!      #"\M-\C-OA"       previous-history
!      #"\M-\C-OB"       next-history
       #
       # Arrow keys in 8 bit ANSI mode
       #
!      #"\M-\C-[D"       backward-char
!      #"\M-\C-[C"       forward-char
!      #"\M-\C-[A"       previous-history
!      #"\M-\C-[B"       next-history
       
       C-q: quoted-insert
--- 5120,5148 ----
       # Arrow keys in keypad mode
       #
!      #"\M-OD":        backward-char
!      #"\M-OC":        forward-char
!      #"\M-OA":        previous-history
!      #"\M-OB":        next-history
       #
       # Arrow keys in ANSI mode
       #
!      "\M-[D":        backward-char
!      "\M-[C":        forward-char
!      "\M-[A":        previous-history
!      "\M-[B":        next-history
       #
       # Arrow keys in 8 bit keypad mode
       #
!      #"\M-\C-OD":       backward-char
!      #"\M-\C-OC":       forward-char
!      #"\M-\C-OA":       previous-history
!      #"\M-\C-OB":       next-history
       #
       # Arrow keys in 8 bit ANSI mode
       #
!      #"\M-\C-[D":       backward-char
!      #"\M-\C-[C":       forward-char
!      #"\M-\C-[A":       previous-history
!      #"\M-\C-[B":       next-history
       
       C-q: quoted-insert
***************
*** 5411,5418 ****
  
  `universal-argument ()'
!      Each time this is executed, the argument count is multiplied by
!      four.  The argument count is initially one, so executing this
!      function the first time makes the argument count four.  By
!      default, this is not bound to a key.
  
  
--- 5436,5450 ----
  
  `universal-argument ()'
!      This is another way to specify an argument.  If this command is
!      followed by one or more digits, optionally with a leading minus
!      sign, those digits define the argument.  If the command is
!      followed by digits, executing `universal-argument' again ends the
!      numeric argument, but is otherwise ignored.  As a special case, if
!      this command is immediately followed by a character that is
!      neither a digit or minus sign, the argument count for the next
!      command is multiplied by four.  The argument count is initially
!      one, so executing this function the first time makes the argument
!      count four, a second time makes the argument count sixteen, and so
!      on.  By default, this is not bound to a key.
  
  
***************
*** 5607,5610 ****
--- 5639,5648 ----
       Perform history expansion on the current line.
  
+ `alias-expand-line'
+      Perform alias expansion on the current line (*note Aliases::.).
+ 
+ `history-and-alias-expand-line'
+      Perform history and alias expansion on the current line.
+ 
  `insert-last-argument (M-., M-_)'
       A synonym for `yank-last-arg'.
***************
*** 5653,5657 ****
  * Menu:
  
! * Basic Installation::	Generic installation instructions.
  
  * Compilers and Options::	How to set special options for various
--- 5691,5695 ----
  * Menu:
  
! * Basic Installation::	Installation instructions.
  
  * Compilers and Options::	How to set special options for various
***************
*** 5680,5684 ****
  ==================
  
!    These are generic installation instructions for Bash.
  
     The `configure' shell script attempts to guess correct values for
--- 5718,5722 ----
  ==================
  
!    These are installation instructions for Bash.
  
     The `configure' shell script attempts to guess correct values for
***************
*** 5703,5707 ****
  called Autoconf.  You only need `configure.in' if you want to change it
  or regenerate `configure' using a newer version of Autoconf.  If you do
! this, make sure you are using Autoconf version 2.9 or newer.
  
     The simplest way to compile Bash is:
--- 5741,5753 ----
  called Autoconf.  You only need `configure.in' if you want to change it
  or regenerate `configure' using a newer version of Autoconf.  If you do
! this, make sure you are using Autoconf version 2.10 or newer.
! 
!    If you need to change `configure.in' or regenerate `configure', you
! will need to create two files: `_distribution' and `_patchlevel'.
! `_distribution' should contain the major and minor version numbers of
! the Bash distribution, for example `2.01'.  `_patchlevel' should
! contain the patch level of the Bash distribution, `0' for example.  The
! script `support/mkconffiles' has been provided to automate the creation
! of these files.
  
     The simplest way to compile Bash is:
***************
*** 5881,5891 ****
  that the Bash `configure' recognizes.
  
! `--with-gnu-malloc'
!      Use the GNU version of `malloc' in `lib/malloc/malloc.c'.  This is
!      not the same `malloc' that appears in GNU libc, but an older
!      version derived from the 4.2 BSD `malloc'.  This `malloc' is very
!      fast, but wastes a lot of space.  This option is enabled by
!      default.  The `NOTES' file contains a list of systems for which
!      this should be turned off.
  
  `--with-glibc-malloc'
--- 5927,5937 ----
  that the Bash `configure' recognizes.
  
! `--with-afs'
!      Define if you are using the Andrew File System from Transarc.
! 
! `--with-curses'
!      Use the curses library instead of the termcap library.  This should
!      be supplied if your system has an inadequate or incomplete termcap
!      database.
  
  `--with-glibc-malloc'
***************
*** 5894,5899 ****
       considerably less space.
  
! `--with-afs'
!      Define if you are using the Andrew File System from Transarc.
  
  `--with-purify'
--- 5940,5951 ----
       considerably less space.
  
! `--with-gnu-malloc'
!      Use the GNU version of `malloc' in `lib/malloc/malloc.c'.  This is
!      not the same `malloc' that appears in GNU libc, but an older
!      version derived from the 4.2 BSD `malloc'.  This `malloc' is very
!      fast, but wastes a lot of space.  This option is enabled by
!      default.  The `NOTES' file contains a list of systems for which
!      this should be turned off, and `configure' disables this option
!      automatically for a number of systems.
  
  `--with-purify'
***************
*** 5913,5942 ****
  does not provide the necessary support.
  
- `--enable-job-control'
-      This enables job control features, if the OS supports them.
- 
  `--enable-alias'
       Allow alias expansion and include the `alias' and `unalias'
       builtins.
  
! `--enable-readline'
!      Include support for command-line editing and history with the Bash
!      version of the Readline library.
! 
! `--enable-history'
!      Include command history and the `fc' and `history' builtin
!      commands.
  
  `--enable-bang-history'
       Include support for `csh'-like history substitution.
  
  `--enable-directory-stack'
       Include support for a `csh'-like directory stack and the `pushd',
       `popd', and `dirs' builtins.
  
! `--enable-restricted'
!      Include support for a "restricted shell".  If this is enabled,
!      Bash, when called as `rbash', enters a restricted mode.  See *Note
!      The Restricted Shell::, for a description of restricted mode.
  
  `--enable-process-substitution'
--- 5965,6010 ----
  does not provide the necessary support.
  
  `--enable-alias'
       Allow alias expansion and include the `alias' and `unalias'
       builtins.
  
! `--enable-array-variables'
!      Include support for one-dimensional array shell variables.
  
  `--enable-bang-history'
       Include support for `csh'-like history substitution.
  
+ `--enable-brace-expansion'
+      Include `csh'-like brace expansion ( `b{a,b}c' ==> `bac bbc' ).
+ 
+ `--enable-command-timing'
+      Include support for recognizing `time' as a reserved word and for
+      displaying timing statistics for the pipeline following `time'.
+      This allows pipelines as well as shell builtins and functions to
+      be timed.
+ 
  `--enable-directory-stack'
       Include support for a `csh'-like directory stack and the `pushd',
       `popd', and `dirs' builtins.
  
! `--enable-disabled-builtins'
!      Allow builtin commands to be invoked via `builtin xxx' even after
!      `xxx' has been disabled using `enable -n xxx'.  See *Note Bash
!      Builtins::, for details of the `builtin' and `enable' builtin
!      commands.
! 
! `--enable-dparen-arithmetic'
!      Include support for the `ksh' `((...))' command.
! 
! `--enable-help-builtin'
!      Include the `help' builtin, which displays help on shell builtins
!      and variables.
! 
! `--enable-history'
!      Include command history and the `fc' and `history' builtin
!      commands.
! 
! `--enable-job-control'
!      This enables job control features, if the OS supports them.
  
  `--enable-process-substitution'
***************
*** 5949,5981 ****
       strings.
  
  `--enable-select'
       Include the `ksh' `select' builtin, which allows the generation of
       simple menus.
  
- `--enable-help-builtin'
-      Include the `help' builtin, which displays help on shell builtins
-      and variables.
- 
- `--enable-array-variables'
-      Include support for one-dimensional array shell variables.
- 
- `--enable-dparen-arithmetic'
-      Include support for the `ksh' `((...))' command.
- 
- `--enable-brace-expansion'
-      Include `csh'-like brace expansion ( `b{a,b}c' ==> `bac bbc' ).
- 
- `--enable-disabled-builtins'
-      Allow builtin commands to be invoked via `builtin xxx' even after
-      `xxx' has been disabled using `enable -n xxx'.  See *Note Bash
-      Builtins::, for details of the `builtin' and `enable' builtin
-      commands.
- 
- `--enable-command-timing'
-      Include support for recognizing `time' as a reserved word and for
-      displaying timing statistics for the pipeline following `time'.
-      This allows pipelines as well as shell builtins and functions to
-      be timed.
- 
  `--enable-usg-echo-default'
       Make the `echo' builtin expand backslash-escaped characters by
--- 6017,6033 ----
       strings.
  
+ `--enable-readline'
+      Include support for command-line editing and history with the Bash
+      version of the Readline library.
+ 
+ `--enable-restricted'
+      Include support for a "restricted shell".  If this is enabled,
+      Bash, when called as `rbash', enters a restricted mode.  See *Note
+      The Restricted Shell::, for a description of restricted mode.
+ 
  `--enable-select'
       Include the `ksh' `select' builtin, which allows the generation of
       simple menus.
  
  `--enable-usg-echo-default'
       Make the `echo' builtin expand backslash-escaped characters by
***************
*** 6001,6005 ****
     Once you have determined that a bug actually exists, use the
  `bashbug' command to submit a bug report.  If you have a fix, you are
! welcome to mail that as well!  Suggestions and `philosophical' bug
  reports may be mailed to `bug-bash@prep.ai.MIT.Edu' or posted to the
  Usenet newsgroup `gnu.bash.bug'.
--- 6053,6057 ----
     Once you have determined that a bug actually exists, use the
  `bashbug' command to submit a bug report.  If you have a fix, you are
! encouraged to mail that as well!  Suggestions and `philosophical' bug
  reports may be mailed to `bug-bash@prep.ai.MIT.Edu' or posted to the
  Usenet newsgroup `gnu.bash.bug'.
***************
*** 6133,6136 ****
--- 6185,6189 ----
  * auto_resume:                          Job Control Variables.
  * BASH:                                 Bash Variables.
+ * BASH_ENV:                             Bash Variables.
  * BASH_VERSINFO:                        Bash Variables.
  * BASH_VERSION:                         Bash Variables.
***************
*** 6144,6148 ****
  * editing-mode:                         Readline Init File Syntax.
  * enable-keypad:                        Readline Init File Syntax.
- * ENV:                                  Korn Shell Variables.
  * EUID:                                 Bash Variables.
  * expand-tilde:                         Readline Init File Syntax.
--- 6197,6200 ----
***************
*** 6150,6153 ****
--- 6202,6206 ----
  * FIGNORE:                              Bash Variables.
  * GLOBIGNORE:                           Bash Variables.
+ * GROUPS:                               Bash Variables.
  * histchars:                            Bash Variables.
  * HISTCMD:                              Bash Variables.
***************
*** 6170,6173 ****
--- 6223,6227 ----
  * LANG:                                 Bash Variables.
  * LC_ALL:                               Bash Variables.
+ * LC_COLLATE:                           Bash Variables.
  * LC_MESSAGES:                          Bash Variables.
  * LINENO:                               Korn Shell Variables.
***************
*** 6392,6513 ****
  
  Tag Table:
! Node: Top1009
! Node: Introduction3117
! Node: What is Bash?3342
! Node: What is a shell?4426
! Node: Definitions6307
! Node: Basic Shell Features8947
! Node: Shell Syntax10468
! Node: Shell Operation10758
! Node: Quoting11992
! Node: Escape Character13027
! Node: Single Quotes13458
! Node: Double Quotes13787
! Node: ANSI-C Quoting14483
! Node: Locale Translation15215
! Node: Comments15636
! Node: Simple Commands16160
! Node: Pipelines16749
! Node: Lists17820
! Node: Looping Constructs19095
! Node: Conditional Constructs20272
! Node: Command Grouping22337
! Node: Shell Functions23721
! Node: Shell Parameters25489
! Node: Positional Parameters26812
! Node: Special Parameters27506
! Node: Shell Expansions29998
! Node: Shell Parameter Expansion31998
! Node: Command Substitution38003
! Node: Process Substitution39003
! Node: Word Splitting39909
! Node: Filename Expansion41361
! Node: Quote Removal43727
! Node: Redirections44013
! Node: Executing Commands49754
! Node: Command Search and Execution50209
! Node: Environment51943
! Node: Exit Status53579
! Node: Signals54596
! Node: Shell Scripts55807
! Node: Bourne Shell Features57676
! Node: Bourne Shell Builtins58346
! Node: Bourne Shell Variables66619
! Node: Other Bourne Shell Features68156
! Node: Major Differences From The Bourne Shell68913
! Node: Csh Features79111
! Node: Brace Expansion80029
! Node: Tilde Expansion81584
! Node: C Shell Builtins82216
! Node: C Shell Variables86732
! Node: Korn Shell Features87140
! Node: Korn Shell Constructs87868
! Node: Korn Shell Builtins89562
! Node: Korn Shell Variables91720
! Node: Aliases93505
! Node: Alias Builtins95969
! Node: Bash Features96585
! Node: Invoking Bash97576
! Node: Bash Startup Files101441
! Node: Is This Shell Interactive?105024
! Node: Bash Builtins105755
! Node: The Set Builtin121569
! Node: Bash Conditional Expressions126939
! Node: Bash Variables131590
! Node: Shell Arithmetic141103
! Node: Arithmetic Evaluation141571
! Node: Arithmetic Expansion143601
! Node: Arithmetic Builtins144405
! Node: Arrays144876
! Node: Printing a Prompt147903
! Node: The Restricted Shell149501
! Node: Bash POSIX Mode150731
! Node: Job Control154303
! Node: Job Control Basics154768
! Node: Job Control Builtins158911
! Node: Job Control Variables161794
! Node: Using History Interactively162955
! Node: Bash History Facilities163544
! Node: History Interaction165942
! Node: Event Designators168504
! Node: Word Designators169427
! Node: Modifiers170676
! Node: Command Line Editing171993
! Node: Introduction and Notation172653
! Node: Readline Interaction173661
! Node: Readline Bare Essentials174849
! Node: Readline Movement Commands176378
! Node: Readline Killing Commands177268
! Node: Readline Arguments178970
! Node: Searching179943
! Node: Readline Init File181579
! Node: Readline Init File Syntax182635
! Node: Conditional Init Constructs190424
! Node: Sample Init File192705
! Node: Bindable Readline Commands195722
! Node: Commands For Moving196472
! Node: Commands For History197319
! Node: Commands For Text199992
! Node: Commands For Killing201734
! Node: Numeric Arguments203760
! Node: Commands For Completion204386
! Node: Keyboard Macros207348
! Node: Miscellaneous Commands207906
! Node: Readline vi Mode211937
! Node: Installing Bash212813
! Node: Basic Installation213890
! Node: Compilers and Options216389
! Node: Compiling For Multiple Architectures217123
! Node: Installation Names218780
! Node: Specifying the System Type219502
! Node: Sharing Defaults220213
! Node: Operation Controls220878
! Node: Optional Features221783
! Node: Reporting Bugs226408
! Node: Builtin Index227485
! Node: Reserved Word Index230898
! Node: Variable Index232206
! Node: Function Index237285
! Node: Concept Index241643
  
  End Tag Table
--- 6446,6567 ----
  
  Tag Table:
! Node: Top1005
! Node: Introduction3109
! Node: What is Bash?3334
! Node: What is a shell?4418
! Node: Definitions6299
! Node: Basic Shell Features8960
! Node: Shell Syntax10481
! Node: Shell Operation10771
! Node: Quoting12005
! Node: Escape Character13040
! Node: Single Quotes13471
! Node: Double Quotes13800
! Node: ANSI-C Quoting14496
! Node: Locale Translation15228
! Node: Comments15649
! Node: Simple Commands16173
! Node: Pipelines16762
! Node: Lists17833
! Node: Looping Constructs19108
! Node: Conditional Constructs20285
! Node: Command Grouping22352
! Node: Shell Functions23738
! Node: Shell Parameters25511
! Node: Positional Parameters26834
! Node: Special Parameters27528
! Node: Shell Expansions30094
! Node: Shell Parameter Expansion32098
! Node: Command Substitution38106
! Node: Process Substitution39106
! Node: Word Splitting40012
! Node: Filename Expansion41464
! Node: Quote Removal43830
! Node: Redirections44116
! Node: Executing Commands49857
! Node: Command Search and Execution50312
! Node: Environment52046
! Node: Exit Status53682
! Node: Signals54699
! Node: Shell Scripts55910
! Node: Bourne Shell Features57779
! Node: Bourne Shell Builtins58449
! Node: Bourne Shell Variables66803
! Node: Other Bourne Shell Features68340
! Node: Major Differences From The Bourne Shell69097
! Node: Csh Features79457
! Node: Brace Expansion80375
! Node: Tilde Expansion81930
! Node: C Shell Builtins82562
! Node: C Shell Variables87118
! Node: Korn Shell Features87526
! Node: Korn Shell Constructs88254
! Node: Korn Shell Builtins89969
! Node: Korn Shell Variables92127
! Node: Aliases93686
! Node: Alias Builtins96150
! Node: Bash Features96766
! Node: Invoking Bash97757
! Node: Bash Startup Files101622
! Node: Is This Shell Interactive?105197
! Node: Bash Builtins106180
! Node: The Set Builtin122035
! Node: Bash Conditional Expressions127410
! Node: Bash Variables132061
! Node: Shell Arithmetic142095
! Node: Arithmetic Evaluation142563
! Node: Arithmetic Expansion144593
! Node: Arithmetic Builtins145397
! Node: Arrays145868
! Node: Printing a Prompt148895
! Node: The Restricted Shell150493
! Node: Bash POSIX Mode151723
! Node: Job Control155407
! Node: Job Control Basics155872
! Node: Job Control Builtins160015
! Node: Job Control Variables162938
! Node: Using History Interactively164085
! Node: Bash History Facilities164674
! Node: History Interaction167072
! Node: Event Designators169634
! Node: Word Designators170557
! Node: Modifiers171806
! Node: Command Line Editing173123
! Node: Introduction and Notation173783
! Node: Readline Interaction174791
! Node: Readline Bare Essentials175979
! Node: Readline Movement Commands177508
! Node: Readline Killing Commands178398
! Node: Readline Arguments180100
! Node: Searching181073
! Node: Readline Init File182709
! Node: Readline Init File Syntax183765
! Node: Conditional Init Constructs191554
! Node: Sample Init File193835
! Node: Bindable Readline Commands196868
! Node: Commands For Moving197618
! Node: Commands For History198465
! Node: Commands For Text201138
! Node: Commands For Killing202880
! Node: Numeric Arguments204906
! Node: Commands For Completion206030
! Node: Keyboard Macros208992
! Node: Miscellaneous Commands209550
! Node: Readline vi Mode213766
! Node: Installing Bash214642
! Node: Basic Installation215711
! Node: Compilers and Options218636
! Node: Compiling For Multiple Architectures219370
! Node: Installation Names221027
! Node: Specifying the System Type221749
! Node: Sharing Defaults222460
! Node: Operation Controls223125
! Node: Optional Features224030
! Node: Reporting Bugs228913
! Node: Builtin Index229993
! Node: Reserved Word Index233406
! Node: Variable Index234714
! Node: Function Index239899
! Node: Concept Index244257
  
  End Tag Table
diff -Nrc2 bash-2.0/doc/bashref.texi bash-2.01/doc/bashref.texi
*** bash-2.0/doc/bashref.texi	Tue Dec 17 10:24:15 1996
--- bash-2.01/doc/bashref.texi	Mon May 19 12:56:04 1997
***************
*** 6,16 ****
  
  @ignore
! last change: Mon Nov 25 11:47:06 EST 1996
  @end ignore
  
  @set EDITION 2.0
! @set VERSION 2.0
! @set UPDATED 25 November 1996
! @set UPDATE-MONTH November 1996
  
  @iftex
--- 6,16 ----
  
  @ignore
! last change: Mon May 19 12:55:22 EDT 1997
  @end ignore
  
  @set EDITION 2.0
! @set VERSION 2.01
! @set UPDATED 19 May 1997
! @set UPDATE-MONTH May 1997
  
  @iftex
***************
*** 273,278 ****
  @item job control
  @cindex job control
! A mechanism by which users can selectively start and stop execution
! of processes.
  
  @item metacharacter
--- 273,278 ----
  @item job control
  @cindex job control
! A mechanism by which users can selectively stop (suspend) and restart
! (resume) execution of processes.
  
  @item metacharacter
***************
*** 718,722 ****
  
  @example
! @code{case @var{word} in [@var{pattern} [| @var{pattern}]@dots{}) @var{commands} ;;]@dots{} esac}
  @end example
  
--- 718,722 ----
  
  @example
! @code{case @var{word} in [ ( @var{pattern} [| @var{pattern}]@dots{}) @var{commands} ;;]@dots{} esac}
  @end example
  
***************
*** 745,749 ****
  
  The @var{expression} is evaluated according to the rules described
! below ((@pxref{Arithmetic Evaluation}).
  If the value of the expression is non-zero, the return status is 0;
  otherwise the return status is 1.  This is exactly equivalent to
--- 745,749 ----
  
  The @var{expression} is evaluated according to the rules described
! below (@pxref{Arithmetic Evaluation}).
  If the value of the expression is non-zero, the return status is 0;
  otherwise the return status is 1.  This is exactly equivalent to
***************
*** 795,799 ****
  by @code{blank}s.  The parentheses are @code{operators}, and are
  recognized as separate tokens by the shell even if they are not separated
! from @code{list} by whitespace.
  
  The exit status of both of these constructs is the exit status of
--- 795,799 ----
  by @code{blank}s.  The parentheses are @code{operators}, and are
  recognized as separate tokens by the shell even if they are not separated
! from the @var{list} by whitespace.
  
  The exit status of both of these constructs is the exit status of
***************
*** 826,833 ****
  function become the positional parameters
  during its execution (@pxref{Positional Parameters}).
! The special parameter
! @samp{#} that gives the number of positional parameters
! is updated to reflect the change.  Positional parameter @code{0}
! is unchanged.
  
  If the builtin command @code{return}
--- 826,832 ----
  function become the positional parameters
  during its execution (@pxref{Positional Parameters}).
! The special parameter @samp{#} that expands to the number of
! positional parameters is updated to reflect the change.
! Positional parameter @code{0} is unchanged.
  
  If the builtin command @code{return}
***************
*** 920,925 ****
  to @code{"$1@var{c}$2@var{c}@dots{}"}, where @var{c}
  is the first character of the value of the @code{IFS}
! variable.  If @code{IFS}
! is null or unset, the parameters are separated by spaces.
  
  @item @@
--- 919,927 ----
  to @code{"$1@var{c}$2@var{c}@dots{}"}, where @var{c}
  is the first character of the value of the @code{IFS}
! variable.
! If @code{IFS} is unset, the parameters are separated by spaces.
! If @code{IFS} is null, the parameters are joined without intervening
! separators.
! 
  
  @item @@
***************
*** 1021,1025 ****
  expand a single word to a single word.
  The only exceptions to this are the expansions of
! @code{"$@@"} (@pxref{Special Parameters}) and @code{"$@{[@@]@}"}
  (@pxref{Arrays}).
  
--- 1023,1027 ----
  expand a single word to a single word.
  The only exceptions to this are the expansions of
! @code{"$@@"} (@pxref{Special Parameters}) and @code{"$@{@var{name}[@@]@}"}
  (@pxref{Arrays}).
  
***************
*** 1051,1055 ****
  Bash uses the value of the variable formed from the rest of
  @var{parameter} as the name of the variable; this variable is then
! expanded and that value used in the rest of the substitution, rather
  than the value of @var{parameter} itself.
  This is known as @code{indirect expansion}.
--- 1053,1057 ----
  Bash uses the value of the variable formed from the rest of
  @var{parameter} as the name of the variable; this variable is then
! expanded and that value is used in the rest of the substitution, rather
  than the value of @var{parameter} itself.
  This is known as @code{indirect expansion}.
***************
*** 1954,1958 ****
  @btindex trap
  @example
! trap [-lp] [@var{arg}] [@var{sigspec}]
  @end example
  The commands in @var{arg} are to be read and executed when the
--- 1956,1960 ----
  @btindex trap
  @example
! trap [-lp] [@var{arg}] [@var{sigspec} @dots{}]
  @end example
  The commands in @var{arg} are to be read and executed when the
***************
*** 1960,1972 ****
  equal to @samp{-}, all specified signals are reset to the values
  they had when the shell was started.
! If @var{arg} is the null string, then @var{sigspec} is ignored by
! the shell and commands it invokes.
  If @var{arg} is @samp{-p}, the shell displays the trap commands
  associated with each @var{sigspec}.  If no arguments are supplied, or
  only @samp{-p} is given, @code{trap} prints the list of commands
! associated with each signal number.  @var{sigspec} is either a signal
! name such as @code{SIGINT} or a signal number.  If @var{sigspec} is
! @code{0} or @code{EXIT}, @var{arg} is executed when the shell exits.
! If @var{sigspec} is @code{DEBUG}, the command @var{arg} is executed
  after every simple command.
  The @samp{-l} option causes the shell to print a list of signal names
--- 1962,1976 ----
  equal to @samp{-}, all specified signals are reset to the values
  they had when the shell was started.
! If @var{arg} is the null string, then the signal specified by
! each @var{sigspec} is ignored by the shell and commands it invokes.
  If @var{arg} is @samp{-p}, the shell displays the trap commands
  associated with each @var{sigspec}.  If no arguments are supplied, or
  only @samp{-p} is given, @code{trap} prints the list of commands
! associated with each signal number.
! Each @var{sigspec} is either a signal name such as @code{SIGINT} (with
! or without the @code{SIG} prefix) or a signal number.
! If a @var{sigspec}
! is @code{0} or @code{EXIT}, @var{arg} is executed when the shell exits.
! If a @var{sigspec} is @code{DEBUG}, the command @var{arg} is executed
  after every simple command.
  The @samp{-l} option causes the shell to print a list of signal names
***************
*** 2137,2141 ****
  (@pxref{Locale Translation}).
  
! The expansion @code{$@{var:}@var{length}@code{[:}@var{offset}@code{]@}},
  which expands to the substring of @code{var}'s value of length
  @var{length}, optionally beginning at @var{offset}, is present
--- 2141,2145 ----
  (@pxref{Locale Translation}).
  
! The expansion @code{$@{var:}@var{offset}@code{[:}@var{length}@code{]@}},
  which expands to the substring of @code{var}'s value of length
  @var{length}, optionally beginning at @var{offset}, is present
***************
*** 2156,2160 ****
  
  Bash automatically assigns variables that provide information about the
! current user (@code{UID} and @code{EUID}), the current host
  (@code{HOSTTYPE}, @code{OSTYPE}, @code{MACHTYPE}, and @code{HOSTNAME}),
  and the instance of Bash that is running (@code{BASH},
--- 2160,2164 ----
  
  Bash automatically assigns variables that provide information about the
! current user (@code{UID}, @code{EUID}, and @code{GROUPS}), the current host
  (@code{HOSTTYPE}, @code{OSTYPE}, @code{MACHTYPE}, and @code{HOSTNAME}),
  and the instance of Bash that is running (@code{BASH},
***************
*** 2173,2177 ****
  
  Variable assignments preceding commands affect only that command, even
! builtins and functions.  In @code{sh}, all variable assignments 
  preceding commands are global unless the command is executed from the
  file system.
--- 2177,2182 ----
  
  Variable assignments preceding commands affect only that command, even
! builtins and functions (@pxref{Environment}).
! In @code{sh}, all variable assignments 
  preceding commands are global unless the command is executed from the
  file system.
***************
*** 2250,2261 ****
  and values simultaneously.
  
! The Bash @code{cd} and @code{pwd} builtins each take @samp{-L} and
! @samp{-P} builtins to switch between logical and physical modes.
  
  The Bash @code{type} builtin is more extensive and gives more information
! about the names it finds.
  
  Bash implements a @code{csh}-like directory stack, and provides the
! @code{pushd}, @code{popd}, and @code{dirs} builtins to manipulate it.
  Bash also makes the directory stack visible as the value of the
  @code{DIRSTACK} shell variable.
--- 2255,2268 ----
  and values simultaneously.
  
! The Bash @code{cd} and @code{pwd} builtins (@pxref{Bourne Shell Builtins})
! each take @samp{-L} and @samp{-P} builtins to switch between logical and
! physical modes.
  
  The Bash @code{type} builtin is more extensive and gives more information
! about the names it finds (@pxref{Bash Builtins}).
  
  Bash implements a @code{csh}-like directory stack, and provides the
! @code{pushd}, @code{popd}, and @code{dirs} builtins to manipulate it
! (@pxref{C Shell Builtins}).
  Bash also makes the directory stack visible as the value of the
  @code{DIRSTACK} shell variable.
***************
*** 2305,2312 ****
  
  @item
! In a questionable attempt at security, the @sc{SVR4.2} shell
! will alter its real
  and effective @sc{UID} and @sc{GID} if they are less than some
! threshold value, commonly 100.  This can lead to unexpected results.
  
  @item
--- 2312,2320 ----
  
  @item
! In a questionable attempt at security, the @sc{SVR4.2} shell,
! when invoked without the @samp{-p} option, will alter its real
  and effective @sc{UID} and @sc{GID} if they are less than some
! magic threshold value, commonly 100.
! This can lead to unexpected results.
  
  @item
***************
*** 2331,2335 ****
  The @sc{SVR4.2} shell exits a script if any builtin fails; Bash exits
  a script only if one of the @sc{POSIX.2} special builtins fails, and
! only for certain failures, as enumerated in the @code{POSIX.2} standard.
  
  @item 
--- 2339,2343 ----
  The @sc{SVR4.2} shell exits a script if any builtin fails; Bash exits
  a script only if one of the @sc{POSIX.2} special builtins fails, and
! only for certain failures, as enumerated in the @sc{POSIX.2} standard.
  
  @item 
***************
*** 2455,2464 ****
  @item +@var{N}
  Brings the @var{N}th directory (counting from the left of the
! list printed by @code{dirs}) to the top of the list by rotating
! the stack.
  @item -@var{N}
  Brings the @var{N}th directory (counting from the right of the
! list printed by @code{dirs}) to the top of the list by rotating
! the stack.
  @item -n
  Suppresses the normal change of directory when adding directories
--- 2463,2472 ----
  @item +@var{N}
  Brings the @var{N}th directory (counting from the left of the
! list printed by @code{dirs}, starting with zero) to the top of
! the list by rotating the stack.
  @item -@var{N}
  Brings the @var{N}th directory (counting from the right of the
! list printed by @code{dirs}, starting with zero) to the top of
! the list by rotating the stack.
  @item -n
  Suppresses the normal change of directory when adding directories
***************
*** 2645,2650 ****
  
  Bash also has adopted command timing from the Korn shell.  If the
! @code{time} reserved word precedes a pipeline or simple command,
! timing statistics for the pipeline are displayed when it completes.
  The statistics currently consist of elapsed (wall-clock) time and
  user and system time consumed by the command's execution.
--- 2653,2659 ----
  
  Bash also has adopted command timing from the Korn shell.  If the
! @code{time} reserved word precedes a pipeline, which may consist
! of a single command, timing statistics for the pipeline are displayed
! when it completes.
  The statistics currently consist of elapsed (wall-clock) time and
  user and system time consumed by the command's execution.
***************
*** 2752,2760 ****
  The line number in the script or shell function currently executing.
  
- @item ENV
- If this variable is set when Bash is invoked to execute a shell
- script, its value is expanded and used as the name of a startup file
- to read before executing the script.  @xref{Bash Startup Files}.
- 
  @item FCEDIT
  The editor used as a default by the @code{fc} builtin command.
--- 2761,2764 ----
***************
*** 2993,3002 ****
  @cindex startup files
  
! This section describs how bash executes its startup files.
! If any of the files exist but cannot be read, bash reports an error.
  Tildes are expanded in file names as described above under
  Tilde Expansion (@pxref{Tilde Expansion}).
  
! When Bash is invoked as a login shell, it first reads and
  executes commands from the file @file{/etc/profile}, if that file exists.
  After reading that file, it looks for @file{~/.bash_profile},
--- 2997,3006 ----
  @cindex startup files
  
! This section describs how Bash executes its startup files.
! If any of the files exist but cannot be read, Bash reports an error.
  Tildes are expanded in file names as described above under
  Tilde Expansion (@pxref{Tilde Expansion}).
  
! When Bash is invoked as an interactive login shell, it first reads and
  executes commands from the file @file{/etc/profile}, if that file exists.
  After reading that file, it looks for @file{~/.bash_profile},
***************
*** 3060,3064 ****
  and executed from the file whose name is the expanded value.
  No other startup files are read.
! This is done by both interactive and non-interactive shells.
  
  Bash attempts to determine when it is being run by the remote shell
--- 3064,3068 ----
  and executed from the file whose name is the expanded value.
  No other startup files are read.
! This is done by interactive shells only.
  
  Bash attempts to determine when it is being run by the remote shell
***************
*** 3094,3097 ****
--- 3098,3111 ----
  @end example
  
+ Alternatively, you may test the value of the @samp{-} special parameter.
+ It contains @code{i} when the shell is interactive.  For example:
+ 
+ @example
+ case "$-" in
+ *i*)	echo This shell is interactive ;;
+ *)	echo This shell is not interactive ;;
+ esac
+ @end example
+ 
  @node Bash Builtins
  @section Bash Builtin Commands
***************
*** 3174,3180 ****
  builtin [@var{shell-builtin} [@var{args}]]
  @end example
! Run a shell builtin.  This is useful when you wish to rename a
! shell builtin to be a function, but need the functionality of the
! builtin within the function itself.
  
  @item command
--- 3188,3194 ----
  builtin [@var{shell-builtin} [@var{args}]]
  @end example
! Run a shell builtin.  This is useful when you wish to define a
! shell function with the same name as a shell builtin, but need the
! functionality of the builtin within the function itself.
  
  @item command
***************
*** 3424,3428 ****
  If a correction is found, the corrected path is printed,
  and the command proceeds.
! This option is enabled by default, but is only used by interactive shells.
  
  @item checkhash
--- 3438,3442 ----
  If a correction is found, the corrected path is printed,
  and the command proceeds.
! This option is only used by interactive shells.
  
  @item checkhash
***************
*** 3471,3475 ****
  If set, and Readline is being used, Bash will attempt to perform
  hostname completion when a word beginning with @samp{@@} is being
! completed (@pxref{Commands For Completion}).
  
  @item interactive_comments
--- 3485,3490 ----
  If set, and Readline is being used, Bash will attempt to perform
  hostname completion when a word beginning with @samp{@@} is being
! completed (@pxref{Commands For Completion}).  This option is enabled
! by default.
  
  @item interactive_comments
***************
*** 3719,3723 ****
  @item -p
  Turn on privileged mode.
! In this mode, the @code{$ENV}
  file is not processed, and shell functions
  are not inherited from the environment.  This is enabled automatically
--- 3734,3738 ----
  @item -p
  Turn on privileged mode.
! In this mode, the @code{$BASH_ENV}
  file is not processed, and shell functions
  are not inherited from the environment.  This is enabled automatically
***************
*** 3963,3966 ****
--- 3978,3986 ----
  @vtable @code
  
+ @item BASH_ENV
+ If this variable is set when Bash is invoked to execute a shell
+ script, its value is expanded and used as the name of a startup file
+ to read before executing the script.  @xref{Bash Startup Files}.
+ 
  @item TIMEFORMAT
  The value of this parameter is used as a format string specifying
***************
*** 4003,4007 ****
--- 4023,4029 ----
  
  If this variable is not set, bash acts as if it had the value
+ @example
  @code{$'\nreal\t%3lR\nuser\t%3lU\nsys\t%3lS'}.
+ @end example
  If the value is null, no timing information is displayed.
  A trailing newline is added when the format string is displayed.
***************
*** 4087,4090 ****
--- 4109,4116 ----
  The numeric effective user id of the current user.
  
+ @item GROUPS
+ An array variable containing the list of groups of which the current    
+ user is a member.
+ 
  @item PPID
  The process id of the shell's parent process.
***************
*** 4185,4189 ****
  @item SHLVL
  Incremented by one each time a new instance of Bash is started.  This is
! intended to be an account of how deeply your Bash shells are nested.
  
  @item OPTERR
--- 4211,4215 ----
  @item SHLVL
  Incremented by one each time a new instance of Bash is started.  This is
! intended to be a count of how deeply your Bash shells are nested.
  
  @item OPTERR
***************
*** 4199,4205 ****
  @code{LC_} variable specifying a locale category.
  
  @item LC_MESSAGES
  This variable determines the locale used to translate double-quoted
! strings preceded by a @samp{$}.
  
  @item IGNOREEOF
--- 4225,4235 ----
  @code{LC_} variable specifying a locale category.
  
+ @item LC_COLLATE
+ This variable determines the collation order used when sorting the
+ results of filename expansion (@pxref{Filename Expansion}).
+ 
  @item LC_MESSAGES
  This variable determines the locale used to translate double-quoted
! strings preceded by a @samp{$} (@pxref{Locale Translation}).
  
  @item IGNOREEOF
***************
*** 4609,4620 ****
  the command name, and so on.
  
- @ignore
- @item
- The environment passed to executed commands is not sorted.  Neither is
- the output of @code{set}.  This is not strictly Posix.2 behavior, but
- @code{sh} does it this way.  @code{ksh} does not.  It's not necessary to
- sort the environment; no program should rely on it being sorted.
- @end ignore
- 
  @item
  If the @code{cd} builtin finds a directory to change to
--- 4639,4642 ----
***************
*** 4642,4645 ****
--- 4664,4671 ----
  persist in the shell environment after the builtin completes.
  
+ @item
+ The @code{export} and @code{readonly} builtin commands display their
+ output in the format required by @sc{POSIX.2}.
+ 
  @end enumerate
  
***************
*** 4827,4833 ****
  @end example
  Send a signal specified by @var{sigspec} or @var{signum} to the process
! named by @var{jobspec}.  @var{sigspec} is either a signal name such as
! @code{SIGINT} or a signal number; @var{signum} is a signal number.  If
! @var{sigspec} and @var{signum} are not present, @code{SIGTERM} is used.
  The @samp{-l} option lists the signal names, or the signal name
  corresponding to @var{sigspec}.
--- 4853,4860 ----
  @end example
  Send a signal specified by @var{sigspec} or @var{signum} to the process
! named by @var{jobspec}.
! @var{sigspec} is either a signal name such as @code{SIGINT} (with or without
! the @code{SIG} prefix) or a signal number; @var{signum} is a signal number.
! If @var{sigspec} and @var{signum} are not present, @code{SIGTERM} is used.
  The @samp{-l} option lists the signal names, or the signal name
  corresponding to @var{sigspec}.
***************
*** 4879,4884 ****
  job control.  If this variable exists then single word simple
  commands without redirects are treated as candidates for resumption
! of an existing job.  There is no ambiguity allowed; if you have
! more than one job beginning with the string that you have typed, then
  the most recently accessed job will be selected.
  The name of a stopped job, in this context, is the command line
--- 4906,4911 ----
  job control.  If this variable exists then single word simple
  commands without redirects are treated as candidates for resumption
! of an existing job.  There is no ambiguity allowed; if there is
! more than one job beginning with the string typed, then
  the most recently accessed job will be selected.
  The name of a stopped job, in this context, is the command line
***************
*** 4913,4917 ****
  
  @menu
! * Basic Installation::	Generic installation instructions.
  
  * Compilers and Options::	How to set special options for various
--- 4940,4944 ----
  
  @menu
! * Basic Installation::	Installation instructions.
  
  * Compilers and Options::	How to set special options for various
***************
*** 4942,4946 ****
  @cindex Bash configuration
  
! These are generic installation instructions for Bash.
  
  The @code{configure} shell script attempts to guess correct
--- 4969,4973 ----
  @cindex Bash configuration
  
! These are installation instructions for Bash.
  
  The @code{configure} shell script attempts to guess correct
***************
*** 4970,4975 ****
  @file{configure.in} if you want to change it or regenerate
  @code{configure} using a newer version of Autoconf.  If
! you do this, make sure you are using Autoconf version 2.9 or
! newer. 
  
  The simplest way to compile Bash is:
--- 4997,5011 ----
  @file{configure.in} if you want to change it or regenerate
  @code{configure} using a newer version of Autoconf.  If
! you do this, make sure you are using Autoconf version 2.10 or
! newer.
! 
! If you need to change @file{configure.in} or regenerate
! @code{configure}, you will need to create two files: 
! @file{_distribution} and @file{_patchlevel}.  @file{_distribution}
! should contain the major and minor version numbers of the Bash
! distribution, for example @samp{2.01}.  @file{_patchlevel} should
! contain the patch level of the Bash distribution, @samp{0} for
! example.  The script @file{support/mkconffiles} has been provided
! to automate the creation of these files.
  
  The simplest way to compile Bash is:
***************
*** 5154,5157 ****
--- 5190,5206 ----
  
  @table @code
+ @item --with-afs
+ Define if you are using the Andrew File System from Transarc.
+ 
+ @item --with-curses
+ Use the curses library instead of the termcap library.  This should
+ be supplied if your system has an inadequate or incomplete termcap
+ database.
+ 
+ @item --with-glibc-malloc
+ Use the @sc{GNU} libc version of @code{malloc} in
+ @file{lib/malloc/gmalloc.c}.  This is somewhat slower than the
+ default @code{malloc}, but wastes considerably less space. 
+ 
  @item --with-gnu-malloc
  Use the @sc{GNU} version of
***************
*** 5161,5173 ****
  very fast, but wastes a lot of space.  This option is enabled by
  default.  The @file{NOTES} file contains a list of systems for
! which this should be turned off. 
! 
! @item --with-glibc-malloc
! Use the @sc{GNU} libc version of @code{malloc} in
! @file{lib/malloc/gmalloc.c}.  This is somewhat slower than the
! default @code{malloc}, but wastes considerably less space. 
! 
! @item --with-afs
! Define if you are using the Andrew File System from Transarc.
  
  @item --with-purify
--- 5210,5215 ----
  very fast, but wastes a lot of space.  This option is enabled by
  default.  The @file{NOTES} file contains a list of systems for
! which this should be turned off, and @code{configure} disables this
! option automatically for a number of systems.
  
  @item --with-purify
***************
*** 5191,5220 ****
  
  @table @code
- @item --enable-job-control
- This enables job control features, if the @sc{OS} supports them.
- 
  @item --enable-alias
  Allow alias expansion and include the @code{alias} and @code{unalias}
  builtins.
  
! @item --enable-readline
! Include support for command-line editing and history with the Bash
! version of the Readline library.
! 
! @item --enable-history
! Include command history and the @code{fc} and @code{history}
! builtin commands.
  
  @item --enable-bang-history
  Include support for @code{csh}-like history substitution.
  
  @item --enable-directory-stack
  Include support for a @code{csh}-like directory stack and the
  @code{pushd}, @code{popd}, and @code{dirs} builtins.
  
! @item --enable-restricted
! Include support for a @dfn{restricted shell}.  If this is enabled, Bash,
! when called as @code{rbash}, enters a restricted mode.  See
! @ref{The Restricted Shell}, for a description of restricted mode.
  
  @item --enable-process-substitution
--- 5233,5278 ----
  
  @table @code
  @item --enable-alias
  Allow alias expansion and include the @code{alias} and @code{unalias}
  builtins.
  
! @item --enable-array-variables
! Include support for one-dimensional array shell variables.
  
  @item --enable-bang-history
  Include support for @code{csh}-like history substitution.
  
+ @item --enable-brace-expansion
+ Include @code{csh}-like brace expansion
+ ( @code{b@{a,b@}c} @expansion{} @code{bac bbc} ).
+ 
+ @item --enable-command-timing
+ Include support for recognizing @code{time} as a reserved word and for
+ displaying timing statistics for the pipeline following @code{time}.  This
+ allows pipelines as well as shell builtins and functions to be timed.
+ 
  @item --enable-directory-stack
  Include support for a @code{csh}-like directory stack and the
  @code{pushd}, @code{popd}, and @code{dirs} builtins.
  
! @item --enable-disabled-builtins
! Allow builtin commands to be invoked via @samp{builtin xxx}
! even after @code{xxx} has been disabled using @samp{enable -n xxx}.
! See @ref{Bash Builtins}, for details of the @code{builtin} and
! @code{enable} builtin commands.
! 
! @item --enable-dparen-arithmetic
! Include support for the @code{ksh} @code{((@dots{}))} command.
! 
! @item --enable-help-builtin
! Include the @code{help} builtin, which displays help on shell builtins and
! variables.
! 
! @item --enable-history
! Include command history and the @code{fc} and @code{history}
! builtin commands.
! 
! @item --enable-job-control
! This enables job control features, if the @sc{OS} supports them.
  
  @item --enable-process-substitution
***************
*** 5227,5259 ****
  strings.
  
  @item --enable-select
  Include the @code{ksh} @code{select} builtin, which allows the
  generation of simple menus.
  
- @item --enable-help-builtin
- Include the @code{help} builtin, which displays help on shell builtins and
- variables.
- 
- @item --enable-array-variables
- Include support for one-dimensional array shell variables.
- 
- @item --enable-dparen-arithmetic
- Include support for the @code{ksh} @code{((@dots{}))} command.
- 
- @item --enable-brace-expansion
- Include @code{csh}-like brace expansion
- ( @code{b@{a,b@}c} @expansion{} @code{bac bbc} ).
- 
- @item --enable-disabled-builtins
- Allow builtin commands to be invoked via @samp{builtin xxx}
- even after @code{xxx} has been disabled using @samp{enable -n xxx}.
- See @ref{Bash Builtins}, for details of the @code{builtin} and
- @code{enable} builtin commands.
- 
- @item --enable-command-timing
- Include support for recognizing @code{time} as a reserved word and for
- displaying timing statistics for the pipeline following @code{time}.  This
- allows pipelines as well as shell builtins and functions to be timed.
- 
  @item --enable-usg-echo-default
  Make the @code{echo} builtin expand backslash-escaped characters by default,
--- 5285,5301 ----
  strings.
  
+ @item --enable-readline
+ Include support for command-line editing and history with the Bash
+ version of the Readline library.
+ 
+ @item --enable-restricted
+ Include support for a @dfn{restricted shell}.  If this is enabled, Bash,
+ when called as @code{rbash}, enters a restricted mode.  See
+ @ref{The Restricted Shell}, for a description of restricted mode.
+ 
  @item --enable-select
  Include the @code{ksh} @code{select} builtin, which allows the
  generation of simple menus.
  
  @item --enable-usg-echo-default
  Make the @code{echo} builtin expand backslash-escaped characters by default,
***************
*** 5281,5285 ****
  Once you have determined that a bug actually exists, use the
  @code{bashbug} command to submit a bug report.
! If you have a fix, you are welcome to mail that as well!
  Suggestions and `philosophical' bug reports may be mailed
  to @code{bug-bash@@prep.ai.MIT.Edu} or posted to the Usenet
--- 5323,5327 ----
  Once you have determined that a bug actually exists, use the
  @code{bashbug} command to submit a bug report.
! If you have a fix, you are encouraged to mail that as well!
  Suggestions and `philosophical' bug reports may be mailed
  to @code{bug-bash@@prep.ai.MIT.Edu} or posted to the Usenet
diff -Nrc2 bash-2.0/doc/readline.3 bash-2.01/doc/readline.3
*** bash-2.0/doc/readline.3	Mon Jul  8 13:46:57 1996
--- bash-2.01/doc/readline.3	Wed Feb  5 14:14:01 1997
***************
*** 7,13 ****
  .\"	chet@ins.CWRU.Edu
  .\"
! .\"	Last Change: Mon Jul  8 13:07:48 EDT 1996
  .\"
! .TH READLINE 3 "1996 July 8" GNU
  .\"
  .\" File Name macro.  This used to be `.PN', for Path Name,
--- 7,13 ----
  .\"	chet@ins.CWRU.Edu
  .\"
! .\"	Last Change: Wed Feb  5 14:13:22 EST 1997
  .\"
! .TH READLINE 3 "1997 Feb 5" GNU
  .\"
  .\" File Name macro.  This used to be `.PN', for Path Name,
***************
*** 683,689 ****
  .TP
  .B universal\-argument
! Each time this is executed, the argument count is multiplied by four.
  The argument count is initially one, so executing this function the
! first time makes the argument count four.
  .PD
  .SS Completing
--- 683,698 ----
  .TP
  .B universal\-argument
! This is another way to specify an argument.
! If this command is followed by one or more digits, optionally with a
! leading minus sign, those digits define the argument.
! If the command is followed by digits, executing
! .B universal\-argument
! again ends the numeric argument, but is otherwise ignored.
! As a special case, if this command is immediately followed by a
! character that is neither a digit or minus sign, the argument count
! for the next command is multiplied by four.
  The argument count is initially one, so executing this function the
! first time makes the argument count four, a second time makes the
! argument count sixteen, and so on.
  .PD
  .SS Completing
diff -Nrc2 bash-2.0/error.c bash-2.01/error.c
*** bash-2.0/error.c	Wed Nov 20 11:20:54 1996
--- bash-2.01/error.c	Tue Mar 18 15:15:55 1997
***************
*** 20,25 ****
  #include "config.h"
  
! #include <stdio.h>
! #include <sys/types.h>
  #include <fcntl.h>
  
--- 20,24 ----
  #include "config.h"
  
! #include "bashtypes.h"
  #include <fcntl.h>
  
***************
*** 36,39 ****
--- 35,40 ----
  #endif
  
+ #include <stdio.h>
+ 
  #include <errno.h>
  #if !defined (errno)
***************
*** 235,239 ****
  #endif
  
!   fprintf (stderr, "Tell %s to fix this someday.\n", the_current_maintainer);
    fprintf (stderr, "Stopping myself...");
    fflush (stderr);
--- 236,240 ----
  #endif
  
!   fprintf (stderr, "Report this to %s\n", the_current_maintainer);
    fprintf (stderr, "Stopping myself...");
    fflush (stderr);
diff -Nrc2 bash-2.0/eval.c bash-2.01/eval.c
*** bash-2.0/eval.c	Thu Aug 15 16:44:02 1996
--- bash-2.01/eval.c	Wed Feb  5 13:27:39 1997
***************
*** 44,48 ****
  extern int indirection_level, interactive, interactive_shell;
  extern int subshell_environment, running_under_emacs;
! extern int last_command_exit_value;
  extern int need_here_doc;
  extern int current_command_number, current_command_line_count, line_number;
--- 44,48 ----
  extern int indirection_level, interactive, interactive_shell;
  extern int subshell_environment, running_under_emacs;
! extern int last_command_exit_value, stdin_redir;
  extern int need_here_doc;
  extern int current_command_number, current_command_line_count, line_number;
***************
*** 129,132 ****
--- 129,133 ----
  
  	      executing = 1;
+ 	      stdin_redir = 0;
  	      execute_command (current_command);
  
diff -Nrc2 bash-2.0/examples/bashdb/bashdb bash-2.01/examples/bashdb/bashdb
*** bash-2.0/examples/bashdb/bashdb	Fri Jul 28 09:51:38 1995
--- bash-2.01/examples/bashdb/bashdb	Fri Jan 17 16:23:12 1997
***************
*** 26,29 ****
  
  cat $_libdir/bashdb.pre $_guineapig > $_dbgfile
! exec bash $_dbgfile $_guineapig $_tmpdir $_libdir "$@"
  # end of bashdb
--- 26,33 ----
  
  cat $_libdir/bashdb.pre $_guineapig > $_dbgfile
! if [ -f "$BASH" ]; then
! 	exec $BASH $_dbgfile $_guineapig $_tmpdir $_libdir "$@"
! else
! 	exec bash $_dbgfile $_guineapig $_tmpdir $_libdir "$@"
! fi
  # end of bashdb
diff -Nrc2 bash-2.0/examples/bashdb/bashdb.fns bash-2.01/examples/bashdb/bashdb.fns
*** bash-2.0/examples/bashdb/bashdb.fns	Fri Jul  5 12:00:30 1996
--- bash-2.01/examples/bashdb/bashdb.fns	Wed Jan 22 12:43:48 1997
***************
*** 14,17 ****
--- 14,18 ----
  		_msg "$PS4, line $_curline: ${_lines[$(($_curline-$_firstline+1))]}"
  
+ 
  	# if in step mode, decrement counter
  	let " $_steps >= 0" && let _steps="$_steps - 1"
***************
*** 88,92 ****
  		return 1
  	fi
! 	echo "${curline}" | egrep -s "(${linebp%\|})" >/dev/null 2>&1
  	return $?
  }
--- 89,93 ----
  		return 1
  	fi
! 	echo "${_curline}" | egrep "(${_linebp%\|})" >/dev/null 2>&1
  	return $?
  }
***************
*** 96,104 ****
  _at_stringbp() {
  	local l;
  	if [ -z "$_stringbp" ]; then
  		return 1;
  	fi
  	l=${_lines[$_curline-$_firstline+1]}
! 	echo "${l} | egrep -s "*(${stringbp%\|})*" >/dev/null 2>&1
  	return $?
  }
--- 97,106 ----
  _at_stringbp() {
  	local l;
+ 
  	if [ -z "$_stringbp" ]; then
  		return 1;
  	fi
  	l=${_lines[$_curline-$_firstline+1]}
! 	echo "${l}" | egrep "*(${_stringbp%\|})*" >/dev/null 2>&1
  	return $?
  }
***************
*** 133,139 ****
  _listbp() {
  	_msg "Breakpoints at lines:"
! 	_msg "$(echo $_linebp | tr '|' ' ')"
  	_msg "Breakpoints at strings:"
! 	_msg "$(echo $_stringbp | tr '|' ' ')"
  	_msg "Break on condition:"
  	_msg "$_brcond"
--- 135,141 ----
  _listbp() {
  	_msg "Breakpoints at lines:"
! 	_msg "${_linebp//\|/ }"
  	_msg "Breakpoints at strings:"
! 	_msg "${_stringbp//\|/ }"
  	_msg "Break on condition:"
  	_msg "$_brcond"
diff -Nrc2 bash-2.0/examples/bashdb/bashdb.pre bash-2.01/examples/bashdb/bashdb.pre
*** bash-2.0/examples/bashdb/bashdb.pre	Fri Jul 28 09:52:11 1995
--- bash-2.01/examples/bashdb/bashdb.pre	Fri Jan 17 16:35:24 1997
***************
*** 12,16 ****
  
  # prompt for trace line
! PS4=$1
  
  _dbgfile=$0
--- 12,16 ----
  
  # prompt for trace line
! PS4="${1}"
  
  _dbgfile=$0
diff -Nrc2 bash-2.0/examples/functions/xalias.bash bash-2.01/examples/functions/xalias.bash
*** bash-2.0/examples/functions/xalias.bash	Wed Dec 31 19:00:00 1969
--- bash-2.01/examples/functions/xalias.bash	Thu Mar 14 15:39:06 1996
***************
*** 0 ****
--- 1,21 ----
+ # xalias - convert csh alias commands to bash functions
+ # from Mohit Aron <aron@cs.rice.edu>
+ # posted to usenet as <4i5p17$bnu@larry.rice.edu>
+ function xalias ()
+ {
+ 	if [ "x$2" = "x" ] 
+ 	then
+ 		declare -f $1
+ 	else
+ 		echo $2 | egrep -q '(\!|#)'
+ 		if [ $? -eq 0 ]
+ 		then
+ 			comm=$(echo $2 | sed  's/\\!\*/\"$\@\"/g
+ 					       s/\\!:\([1-9]\)/\"$\1\"/g
+ 				               s/#/\\#/g')
+ 		else
+ 			comm="$2 \"\$@\""
+ 		fi
+ 		eval function $1 \(\) "{" command "$comm"  "; }"
+ 	fi
+ }
diff -Nrc2 bash-2.0/examples/loadables/pushd.c bash-2.01/examples/loadables/pushd.c
*** bash-2.0/examples/loadables/pushd.c	Wed Aug 28 16:12:34 1996
--- bash-2.01/examples/loadables/pushd.c	Wed Apr 16 14:22:39 1997
***************
*** 167,170 ****
--- 167,172 ----
        add_dirstack_element ((flags & NOCD) ? savestring (list->word->word) : current_directory);
        dirs_builtin ((WORD_LIST *)NULL);
+       if (flags & NOCD)
+ 	free (current_directory);
        return (EXECUTION_SUCCESS);
      }
***************
*** 187,191 ****
--- 189,195 ----
    int flags;
    char direction;
+   char *which_word;
  
+   which_word = (char *)NULL;
    for (flags = 0, which = 0L, direction = '+'; list; list = list->next)
      {
***************
*** 207,210 ****
--- 211,215 ----
  	      return (EXECUTION_FAILURE);
  	    }
+ 	  which_word = list->word->word;
  	}
        else if (*list->word->word == '-')
***************
*** 220,224 ****
    if (which > directory_list_offset || (directory_list_offset == 0 && which == 0))
      {
!       pushd_error (directory_list_offset, list ? list->word->word : "");
        return (EXECUTION_FAILURE);
      }
--- 225,229 ----
    if (which > directory_list_offset || (directory_list_offset == 0 && which == 0))
      {
!       pushd_error (directory_list_offset, which_word ? which_word : "");
        return (EXECUTION_FAILURE);
      }
***************
*** 539,546 ****
    "",
    "+N   Rotates the stack so that the Nth directory (counting",
!   "     from the left of the list shown by `dirs') is at the top.",
    "",
    "-N   Rotates the stack so that the Nth directory (counting",
!   "     from the right) is at the top.",
    "",
    "-n   suppress the normal change of directory when adding directories",
--- 544,553 ----
    "",
    "+N   Rotates the stack so that the Nth directory (counting",
!   "     from the left of the list shown by `dirs', starting with"
!   "     zero) is at the top.",
    "",
    "-N   Rotates the stack so that the Nth directory (counting",
!   "     from the right of the list shown by `dirs', starting with" 
!   "     zero) is at the top.",
    "",
    "-n   suppress the normal change of directory when adding directories",
diff -Nrc2 bash-2.0/examples/scripts/spin.bash bash-2.01/examples/scripts/spin.bash
*** bash-2.0/examples/scripts/spin.bash	Wed Dec 31 19:00:00 1969
--- bash-2.01/examples/scripts/spin.bash	Tue Apr  1 16:56:15 1997
***************
*** 0 ****
--- 1,21 ----
+ #!/bin/bash
+ #
+ # spin.bash -- provide a `spinning wheel' to show progress
+ #
+ # Chet Ramey
+ # chet@po.cwru.edu
+ #
+ bs=$'\b'
+  
+ chars="|${bs} \\${bs} -${bs} /${bs}"
+  
+ # Infinite loop for demo. purposes
+ while :
+ do
+     for letter in $chars
+     do
+         echo -n ${letter}
+     done
+ done
+ 
+ exit 0
diff -Nrc2 bash-2.0/examples/scripts/vtree2 bash-2.01/examples/scripts/vtree2
*** bash-2.0/examples/scripts/vtree2	Fri Mar 29 12:02:31 1996
--- bash-2.01/examples/scripts/vtree2	Mon May 12 16:24:26 1997
***************
*** 7,10 ****
--- 7,11 ----
  #
  # Original posted to Usenet sometime in February, 1996
+ # I believe that the original author is Brian S. Hiles <bsh29256@atc.fhda.edu>
  #
  usage()
***************
*** 33,40 ****
  
  	du $andfiles | sort +1f | sed \
! 		's/\([^	]*\)	\(.*\)/\2  (\1)/
! 		'"s#^$1##"'
! 		s#[^/]*/\([^/]*\)$#|____\1#
! 		s#[^/]*/#|    #g'
  	
  	[ $# -gt 1 ] && echo 
--- 34,41 ----
  
  	du $andfiles | sort +1f | sed \
! 		-e 's/\([^	]*\)	\(.*\)/\2  (\1)/' \
! 		-e "s#^$1##" \
! 		-e 's#[^/]*/\([^/]*\)$#|____\1#' \
! 		-e 's#[^/]*/#|    #g'
  	
  	[ $# -gt 1 ] && echo 
diff -Nrc2 bash-2.0/examples/scripts/vtree3 bash-2.01/examples/scripts/vtree3
*** bash-2.0/examples/scripts/vtree3	Wed Dec 31 19:00:00 1969
--- bash-2.01/examples/scripts/vtree3	Mon Dec 16 17:23:57 1996
***************
*** 0 ****
--- 1,99 ----
+ #!/bin/ksh
+ #
+ # Name: dirtree
+ # Programmer:
+ #            Hemant T. Shah
+ #            Life Insurance Data Processing
+ #            July 12 1994
+ #
+ # Description:
+ #  Print directory tree structure as follows:
+ #   |___Mail
+ #     |___scheduler
+ #     |___cics_scripts
+ #     |___tar_msdos
+ #     |___awk
+ #     |___attributes
+ #   |___tmp
+ #   |___News
+ #     |___dosscsi
+ #     |___FAQ_xterminal
+ #     |___shell_history.Z
+ #     |___FAQ_AIX
+ #     |___aix_ftp_site
+ #     |___hp_software
+ #   |___dnload
+ #     |___telnet.h
+ #     |___msdos
+ #     |___tnetd.tar.Z
+ #     |___aix
+ #     |___hp
+ #   |___xkey.c
+ #
+ # Conversion to bash v2 syntax done by Chet Ramey
+ #	- removed command substitutions calling `basename'
+ #
+ 
+ ProgramName=${0##*/}
+ Path="."
+ ShowAll=1
+ ShowDir=0
+ 
+ 
+ ExpandDirectory()
+ {
+ local object   # Local variable
+ 
+ cd "$1"
+ 
+ for object in $PWD/.??* $PWD/*
+ do
+    if [ -d $object ];  # It is a directory
+    then
+       echo "${indent}|___${object##*/}/"
+       indent="${indent}!   "   # Add to indentation
+       if [ -x $object ];
+       then
+          ExpandDirectory $object
+       fi
+       indent=${indent%????}    # Remove from indentation
+    elif [ -e $object ]; then
+       if (( ShowAll == 1 ));
+       then
+          echo "${indent}|___${object##*/}"
+       fi
+    fi
+ done
+ 
+ }
+ 
+ usage()
+ {
+ 	echo -e "Usage: $ProgramName [-h] [-f] [-d] [path] "
+ 	echo -e "\t-h       ... display this help message."
+ 	echo -e "\t-f path  ... shows all files and directories below path (default)."
+ 	echo -e "\t-d path  ... shows all directories only below path."
+ }
+ 
+ while getopts "fd" opt
+ do
+ 	case $opt in
+ 	f) ShowAll=1 ;;
+ 	d) ShowDir=1 ;;
+ 	*) usage ; exit 2;;
+ 	esac
+ done
+ 
+ shift $(( $OPTIND - 1 ))
+ 
+ Path=${1:-.}
+ 
+ if [ ! -d "$Path" ]; then
+ 	echo "$0: error: specified path is not a directory." >&2
+ 	exit 1
+ fi
+ 
+ 
+ 
+ echo "!$Path/"
+ ExpandDirectory $Path
diff -Nrc2 bash-2.0/execute_cmd.c bash-2.01/execute_cmd.c
*** bash-2.0/execute_cmd.c	Thu Dec 19 16:22:32 1996
--- bash-2.01/execute_cmd.c	Tue Jun  3 11:20:30 1997
***************
*** 41,46 ****
  #endif
  
! #if defined (HAVE_SYS_TIME_H)
  #  include <sys/time.h>
  #endif
  
--- 41,56 ----
  #endif
  
! /* Some systems require this, mostly for the definition of `struct timezone'.
!    For example, Dynix/ptx has that definition in <time.h> rather than
!    sys/time.h */
! #if defined (TIME_WITH_SYS_TIME)
  #  include <sys/time.h>
+ #  include <time.h>
+ #else
+ #  if defined (HAVE_SYS_TIME_H)
+ #    include <sys/time.h>
+ #  else 
+ #    include <time.h>
+ #  endif
  #endif
  
***************
*** 63,67 ****
  #include "memalloc.h"
  #include "shell.h"
! #include "y.tab.h"
  #include "flags.h"
  #include "builtins.h"
--- 73,77 ----
  #include "memalloc.h"
  #include "shell.h"
! #include <y.tab.h>	/* use <...> so we pick it up from the build directory */
  #include "flags.h"
  #include "builtins.h"
***************
*** 71,74 ****
--- 81,85 ----
  #include "trap.h"
  #include "pathexp.h"
+ #include "hashcmd.h"
  
  #include "builtins/common.h"
***************
*** 93,97 ****
  extern int executing, breaking, continuing, loop_level;
  extern int interactive, interactive_shell, login_shell, expand_aliases;
! extern int parse_and_execute_level, running_trap;
  extern int command_string_index, variable_context, line_number;
  extern int dot_found_in_search;
--- 104,108 ----
  extern int executing, breaking, continuing, loop_level;
  extern int interactive, interactive_shell, login_shell, expand_aliases;
! extern int parse_and_execute_level, running_trap, trap_line_number;
  extern int command_string_index, variable_context, line_number;
  extern int dot_found_in_search;
***************
*** 122,126 ****
--- 133,139 ----
  static int execute_select_command ();
  #endif
+ #if defined (COMMAND_TIMING)
  static int time_command ();
+ #endif
  static int execute_case_command ();
  static int execute_while_command (), execute_until_command ();
***************
*** 139,144 ****
  static int function_line_number;
  
! /* Set to 1 if fd 0 was the subject of redirection to a subshell. */
! static int stdin_redir;
  
  /* The name of the command that is currently being executed.
--- 152,158 ----
  static int function_line_number;
  
! /* Set to 1 if fd 0 was the subject of redirection to a subshell.  Global
!    so that reader_loop can set it to zero before executing a command. */
! int stdin_redir;
  
  /* The name of the command that is currently being executed.
***************
*** 151,156 ****
--- 165,177 ----
  
  static int special_builtin_failed;
+ 
+ /* Spare redirector used when translating [N]>&WORD or [N]<&WORD to a new
+    redirection and when creating the redirection undo list. */
  static REDIRECTEE rd;
  
+ /* Set to errno when a here document cannot be created for some reason.
+    Used to print a reasonable error message. */
+ static int heredoc_errno;
+ 
  /* The file name which we would try to execute, except that it isn't
     possible to execute it.  This is the first file that matches the
***************
*** 187,191 ****
  struct fd_bitmap *current_fds_to_close = (struct fd_bitmap *)NULL;
  
! #define FD_BITMAP_DEFAULT_SIZE 32
  /* Functions to allocate and deallocate the structures used to pass
     information from the shell to its children about file descriptors
--- 208,213 ----
  struct fd_bitmap *current_fds_to_close = (struct fd_bitmap *)NULL;
  
! #define FD_BITMAP_DEFAULT_SIZE 32L
! 
  /* Functions to allocate and deallocate the structures used to pass
     information from the shell to its children about file descriptors
***************
*** 243,247 ****
         currently_executing_command->type == cm_simple)
      return currently_executing_command->value.Simple->line;
!   return line_number;
  }
  
--- 265,272 ----
         currently_executing_command->type == cm_simple)
      return currently_executing_command->value.Simple->line;
!   else if (running_trap)
!     return trap_line_number;
!   else
!     return line_number;
  }
  
***************
*** 360,363 ****
--- 385,438 ----
  }
  
+ static int
+ stdin_redirects (redirs)
+      REDIRECT *redirs;
+ {
+   REDIRECT *rp;
+   int n;
+ 
+   for (n = 0, rp = redirs; rp; rp = rp->next)
+     switch (rp->instruction)
+       {
+       case r_input_direction:
+       case r_inputa_direction:
+       case r_input_output:
+       case r_reading_until:
+       case r_deblank_reading_until:
+ 	n++;
+         break;
+       case r_duplicating_input:
+       case r_duplicating_input_word:
+       case r_close_this:
+ 	n += (rp->redirector == 0);
+         break;
+       case r_output_direction:
+       case r_appending_to:
+       case r_duplicating_output:
+       case r_err_and_out:
+       case r_output_force:
+       case r_duplicating_output_word:
+ 	break;
+       }
+ 
+   return n;
+ }
+ 
+ 
+ static void
+ async_redirect_stdin ()
+ {
+   int fd;
+ 
+   fd = open ("/dev/null", O_RDONLY);
+   if (fd > 0)
+     {
+       dup2 (fd, 0);
+       close (fd);
+     }
+   else if (fd < 0)
+     internal_error ("cannot redirect standard input from /dev/null: %s", strerror (errno));
+ }
+ 
  #define DESCRIBE_PID(pid) do { if (interactive) describe_pid (pid); } while (0)
  
***************
*** 383,387 ****
  {
    int exec_result, invert, ignore_return, was_debug_trap;
!   REDIRECT *my_undo_list, *exec_undo_list, *rp;
    pid_t last_pid;
  
--- 458,462 ----
  {
    int exec_result, invert, ignore_return, was_debug_trap;
!   REDIRECT *my_undo_list, *exec_undo_list;
    pid_t last_pid;
  
***************
*** 394,408 ****
      currently_executing_command = command;
  
- #if defined (COMMAND_TIMING)
-   if (command->flags & CMD_TIME_PIPELINE)
-     {
-       exec_result = time_command (command, asynchronous, pipe_in, pipe_out, fds_to_close);
-       if (running_trap == 0)
- 	currently_executing_command = (COMMAND *)NULL;
-       return (exec_result);
-     }
- #endif /* COMMAND_TIMING */
- 
    invert = (command->flags & CMD_INVERT_RETURN) != 0;
    exec_result = EXECUTION_SUCCESS;
  
--- 469,480 ----
      currently_executing_command = command;
  
    invert = (command->flags & CMD_INVERT_RETURN) != 0;
+ 
+   /* If we're inverting the return value and `set -e' has been executed,
+      we don't want a failing command to inadvertently cause the shell
+      to exit. */
+   if (exit_immediately_on_error && invert)	/* XXX */
+     command->flags |= CMD_IGNORE_RETURN;	/* XXX */
+ 
    exec_result = EXECUTION_SUCCESS;
  
***************
*** 423,427 ****
        if (paren_pid == 0)
  	{
! 	  int user_subshell, return_code, function_value;
  
  	  user_subshell = (command->flags & CMD_WANT_SUBSHELL) != 0;
--- 495,503 ----
        if (paren_pid == 0)
  	{
! 	  int user_subshell, return_code, function_value, should_redir_stdin;
! 
! 	  should_redir_stdin = (asynchronous && (command->flags & CMD_STDIN_REDIR) &&
! 				  pipe_in == NO_PIPE &&
! 				  stdin_redirects (command->redirects) == 0);
  
  	  user_subshell = (command->flags & CMD_WANT_SUBSHELL) != 0;
***************
*** 486,506 ****
  	  if (user_subshell)
  	    {
! 	      for (rp = command->redirects; rp; rp = rp->next)
! 		switch (rp->instruction)
! 		  {
! 		  case r_input_direction:
! 		  case r_inputa_direction:
! 		  case r_input_output:
! 		  case r_reading_until:
! 		  case r_deblank_reading_until:
! 		    stdin_redir++;
! 		    break;
! 		  case r_duplicating_input:
! 		  case r_duplicating_input_word:
! 		  case r_close_this:
! 		    stdin_redir += (rp->redirector == 0);
! 		    break;
! 		  }
! 
  	      restore_default_signal (0);
  	    }
--- 562,566 ----
  	  if (user_subshell)
  	    {
! 	      stdin_redir = stdin_redirects (command->redirects);
  	      restore_default_signal (0);
  	    }
***************
*** 509,512 ****
--- 569,578 ----
  	    close_fd_bitmap (fds_to_close);
  
+ 	  /* If this is an asynchronous command (command &), we want to
+ 	     redirect the standard input from /dev/null in the absence of
+ 	     any specific redirection involving stdin. */
+ 	  if (should_redir_stdin && stdin_redir == 0)
+ 	    async_redirect_stdin ();
+ 
  	  /* Do redirections, then dispose of them before recursive call. */
  	  if (command->redirects)
***************
*** 590,593 ****
--- 656,680 ----
      }
  
+ #if defined (COMMAND_TIMING)
+   if (command->flags & CMD_TIME_PIPELINE)
+     {
+       if (asynchronous)
+ 	{
+ 	  command->flags |= CMD_FORCE_SUBSHELL;
+ 	  exec_result = execute_command_internal (command, 1, pipe_in, pipe_out, fds_to_close);
+ 	}
+       else
+ 	{
+ 	  exec_result = time_command (command, asynchronous, pipe_in, pipe_out, fds_to_close);
+ 	  if (running_trap == 0)
+ 	    currently_executing_command = (COMMAND *)NULL;
+ 	}
+       return (exec_result);
+     }
+ #endif /* COMMAND_TIMING */
+ 
+   if (shell_control_structure (command->type) && command->redirects)
+     stdin_redir = stdin_redirects (command->redirects);
+ 
    /* Handle WHILE FOR CASE etc. with redirections.  (Also '&' input
       redirection.)  */
***************
*** 643,646 ****
--- 730,735 ----
  	if (ignore_return && command->value.Simple)
  	  command->value.Simple->flags |= CMD_IGNORE_RETURN;
+ 	if (command->flags & CMD_STDIN_REDIR)
+ 	  command->value.Simple->flags |= CMD_STDIN_REDIR;
  	exec_result =
  	  execute_simple_command (command->value.Simple, pipe_in, pipe_out,
***************
*** 886,890 ****
      }
  
!   return (t1.tv_sec / t2.tv_sec);
  }  
  #endif /* HAVE_GETRUSAGE && HAVE_GETTIMEOFDAY */
--- 975,979 ----
      }
  
!   return ((t2.tv_sec == 0) ? 0 : t1.tv_sec / t2.tv_sec);
  }  
  #endif /* HAVE_GETRUSAGE && HAVE_GETTIMEOFDAY */
***************
*** 1059,1063 ****
       struct fd_bitmap *fds_to_close;
  {
!   int rv, posix_time;
    long rs, us, ss;
    int rsf, usf, ssf;
--- 1148,1152 ----
       struct fd_bitmap *fds_to_close;
  {
!   int rv, posix_time, old_flags;
    long rs, us, ss;
    int rsf, usf, ssf;
***************
*** 1089,1094 ****
--- 1178,1185 ----
    posix_time = (command->flags & CMD_TIME_POSIX);
  
+   old_flags = command->flags;
    command->flags &= ~(CMD_TIME_PIPELINE|CMD_TIME_POSIX);
    rv = execute_command_internal (command, asynchronous, pipe_in, pipe_out, fds_to_close);
+   command->flags = old_flags;
  
  #if defined (HAVE_GETRUSAGE) && defined (HAVE_GETTIMEOFDAY)
***************
*** 1122,1126 ****
    clock_t_to_secs (sys, &ss, &ssf);
  
!   cpu = ((user + sys) * 10000) / real;
  
  #  else
--- 1213,1217 ----
    clock_t_to_secs (sys, &ss, &ssf);
  
!   cpu = (real == 0) ? 0 : ((user + sys) * 10000) / real;
  
  #  else
***************
*** 1260,1264 ****
       struct fd_bitmap *fds_to_close;
  {
!   REDIRECT *tr, *tl, *rp;
    COMMAND *tc, *second;
    int ignore_return, exec_result;
--- 1351,1358 ----
       struct fd_bitmap *fds_to_close;
  {
! #if 0
!   REDIRECT *tr, *tl;
! #endif
!   REDIRECT *rp;
    COMMAND *tc, *second;
    int ignore_return, exec_result;
***************
*** 1276,1281 ****
        rp = tc->redirects;
  
!       if (ignore_return && tc)
  	tc->flags |= CMD_IGNORE_RETURN;
  
        /* If this shell was compiled without job control support, if
--- 1370,1376 ----
        rp = tc->redirects;
  
!       if (ignore_return)
  	tc->flags |= CMD_IGNORE_RETURN;
+       tc->flags |= CMD_AMPERSAND;
  
        /* If this shell was compiled without job control support, if
***************
*** 1290,1307 ****
  #endif /* JOB_CONTROL */
  	{
  	  rd.filename = make_bare_word ("/dev/null");
  	  tr = make_redirection (0, r_inputa_direction, rd);
  	  tr->next = tc->redirects;
  	  tc->redirects = tr;
  	}
  
        exec_result = execute_command_internal (tc, 1, pipe_in, pipe_out, fds_to_close);
  
! #if defined (JOB_CONTROL)
!       if ((!interactive_shell || subshell_environment || !job_control) && !stdin_redir)
! #else
!       if (!stdin_redir)
! #endif /* JOB_CONTROL */
  	{
  	  /* Remove the redirection we added above.  It matters,
  	     especially for loops, which call execute_command ()
--- 1385,1402 ----
  #endif /* JOB_CONTROL */
  	{
+ #if 0
  	  rd.filename = make_bare_word ("/dev/null");
  	  tr = make_redirection (0, r_inputa_direction, rd);
  	  tr->next = tc->redirects;
  	  tc->redirects = tr;
+ #endif
+ 	  tc->flags |= CMD_STDIN_REDIR;
  	}
  
        exec_result = execute_command_internal (tc, 1, pipe_in, pipe_out, fds_to_close);
  
!       if (tc->flags & CMD_STDIN_REDIR)
  	{
+ #if 0
  	  /* Remove the redirection we added above.  It matters,
  	     especially for loops, which call execute_command ()
***************
*** 1317,1320 ****
--- 1412,1417 ----
  	  tl->next = (REDIRECT *)NULL;
  	  dispose_redirects (tr);
+ #endif
+ 	  tc->flags &= ~CMD_STDIN_REDIR;
  	}
  
***************
*** 1474,1477 ****
--- 1571,1575 ----
  	    {
  	      run_unwind_frame ("for");
+ 	      loop_level--;
  	      return (EXECUTION_FAILURE);
  	    }
***************
*** 2077,2081 ****
    print_simple_command (simple_command);
    command_line = xmalloc (1 + strlen (the_printed_command));
!   strcpy (command_line, the_printed_command);
  
    first_word_quoted =
--- 2175,2179 ----
    print_simple_command (simple_command);
    command_line = xmalloc (1 + strlen (the_printed_command));
!   strcpy (command_line, the_printed_command);	/* XXX memory leak on errors */
  
    first_word_quoted =
***************
*** 2240,2244 ****
  
  	      if (async)
! 		setup_async_signals ();
  
  	      execute_subshell_builtin_or_function
--- 2338,2348 ----
  
  	      if (async)
! 		{
! 		  if ((simple_command->flags & CMD_STDIN_REDIR) &&
! 			pipe_in == NO_PIPE &&
! 			(stdin_redirects (simple_command->redirects) == 0))
! 		    async_redirect_stdin ();
! 		  setup_async_signals ();
! 		}
  
  	      execute_subshell_builtin_or_function
***************
*** 2290,2294 ****
    execute_disk_command (words, simple_command->redirects, command_line,
  			pipe_in, pipe_out, async, fds_to_close,
! 			(simple_command->flags & CMD_NO_FORK));
  
   return_result:
--- 2394,2398 ----
    execute_disk_command (words, simple_command->redirects, command_line,
  			pipe_in, pipe_out, async, fds_to_close,
! 			simple_command->flags);
  
   return_result:
***************
*** 2331,2335 ****
       int flags, subshell;
  {
!   int old_e_flag, result;
  
    old_e_flag = exit_immediately_on_error;
--- 2435,2439 ----
       int flags, subshell;
  {
!   int old_e_flag, result, eval_unwind;
  
    old_e_flag = exit_immediately_on_error;
***************
*** 2345,2354 ****
        unwind_protect_int (exit_immediately_on_error);
        exit_immediately_on_error = 0;
      }
  
    /* The temporary environment for a builtin is supposed to apply to
       all commands executed by that builtin.  Currently, this is a
!      problem only with the `source' builtin. */
!   if (builtin == source_builtin)
      {
        if (subshell == 0)
--- 2449,2461 ----
        unwind_protect_int (exit_immediately_on_error);
        exit_immediately_on_error = 0;
+       eval_unwind = 1;
      }
+   else
+     eval_unwind = 0;
  
    /* The temporary environment for a builtin is supposed to apply to
       all commands executed by that builtin.  Currently, this is a
!      problem only with the `source' and `eval' builtins. */
!   if (builtin == source_builtin || builtin == eval_builtin)
      {
        if (subshell == 0)
***************
*** 2370,2378 ****
    result = ((*builtin) (words->next));
  
!   if (subshell == 0 && builtin == source_builtin)
      {
!       /* In POSIX mode, if any variable assignments precede the `.' builtin,
! 	 they persist after the builtin completes, since `.' is a special
! 	 builtin. */
        if (posixly_correct && builtin_env)
  	merge_builtin_env ();
--- 2477,2485 ----
    result = ((*builtin) (words->next));
  
!   if (subshell == 0 && (builtin == source_builtin || builtin == eval_builtin))
      {
!       /* In POSIX mode, if any variable assignments precede the `.' or
! 	 `eval' builtin, they persist after the builtin completes, since `.'
! 	 and `eval' are special builtins. */
        if (posixly_correct && builtin_env)
  	merge_builtin_env ();
***************
*** 2381,2385 ****
      }
  
!   if (subshell == 0 && builtin == eval_builtin && (flags & CMD_IGNORE_RETURN))
      {
        exit_immediately_on_error += old_e_flag;
--- 2488,2492 ----
      }
  
!   if (eval_unwind)
      {
        exit_immediately_on_error += old_e_flag;
***************
*** 2426,2429 ****
--- 2533,2537 ----
  	  debug_trap = savestring (debug_trap);
  	  add_unwind_protect (set_debug_trap, debug_trap);
+ 	  /* XXX - small memory leak here -- hard to fix */
  	}
        restore_default_signal (DEBUG_TRAP);
***************
*** 2653,2657 ****
  static void
  execute_disk_command (words, redirects, command_line, pipe_in, pipe_out,
! 		      async, fds_to_close, nofork)
       WORD_LIST *words;
       REDIRECT *redirects;
--- 2761,2765 ----
  static void
  execute_disk_command (words, redirects, command_line, pipe_in, pipe_out,
! 		      async, fds_to_close, cmdflags)
       WORD_LIST *words;
       REDIRECT *redirects;
***************
*** 2659,2667 ****
       int pipe_in, pipe_out, async;
       struct fd_bitmap *fds_to_close;
!      int nofork;	/* Don't fork, just exec, if no pipes */
  {
    char *pathname, *command, **args;
    int pid;
  
    pathname = words->word->word;
  
--- 2767,2777 ----
       int pipe_in, pipe_out, async;
       struct fd_bitmap *fds_to_close;
!      int cmdflags;
  {
    char *pathname, *command, **args;
+   int nofork;
    int pid;
  
+   nofork = (cmdflags & CMD_NO_FORK);  /* Don't fork, just exec, if no pipes */
    pathname = words->word->word;
  
***************
*** 2697,2704 ****
--- 2807,2817 ----
        int old_interactive;
  
+ #if 0
+       /* This has been disabled for the time being. */
  #if !defined (ARG_MAX) || ARG_MAX >= 10240
        if (posixly_correct == 0)
  	put_gnu_argv_flags_into_env ((int)getpid (), glob_argv_flags);
  #endif
+ #endif
  
        /* Cancel traps, in trap.c. */
***************
*** 2709,2713 ****
           in asynchronous children. */
        if (async)
! 	setup_async_signals ();
  
        do_piping (pipe_in, pipe_out);
--- 2822,2832 ----
           in asynchronous children. */
        if (async)
! 	{
! 	  if ((cmdflags & CMD_STDIN_REDIR) &&
! 		pipe_in == NO_PIPE &&
! 		(stdin_redirects (redirects) == 0))
! 	    async_redirect_stdin ();
! 	  setup_async_signals ();
! 	}
  
        do_piping (pipe_in, pipe_out);
***************
*** 2846,2849 ****
--- 2965,3010 ----
  #endif /* !HAVE_HASH_BANG_EXEC */
  
+ static void
+ initialize_subshell ()
+ {
+ #if defined (ALIAS)
+   /* Forget about any aliases that we knew of.  We are in a subshell. */
+   delete_all_aliases ();
+ #endif /* ALIAS */
+ 
+ #if defined (HISTORY)
+   /* Forget about the history lines we have read.  This is a non-interactive
+      subshell. */
+   history_lines_this_session = 0;
+ #endif
+ 
+ #if defined (JOB_CONTROL)
+   /* Forget about the way job control was working. We are in a subshell. */
+   without_job_control ();
+   set_sigchld_handler ();
+ #endif /* JOB_CONTROL */
+ 
+   /* Reset the values of the shell flags and options. */
+   reset_shell_flags ();
+   reset_shell_options ();
+   reset_shopt_options ();
+ 
+   /* If we're not interactive, close the file descriptor from which we're
+      reading the current shell script. */
+ #if defined (BUFFERED_INPUT)
+   if (interactive_shell == 0 && default_buffered_input >= 0)
+     {
+       close_buffered_fd (default_buffered_input);
+       default_buffered_input = bash_input.location.buffered_fd = -1;
+     }
+ #else
+   if (interactive_shell == 0 && default_input)
+     {
+       fclose (default_input);
+       default_input = (FILE *)NULL;
+     }
+ #endif
+ }
+ 
  #if defined (HAVE_SETOSTYPE) && defined (_POSIX_SOURCE)
  #  define SETOSTYPE(x)	__setostype(x)
***************
*** 2878,2882 ****
  	  file_error (command);
  	}
!       return (EX_NOEXEC);	/* XXX Posix.2 says that exit status is 126 */
      }
  
--- 3039,3043 ----
  	  file_error (command);
  	}
!       return ((i == ENOENT) ? EX_NOTFOUND : EX_NOEXEC);	/* XXX Posix.2 says that exit status is 126 */
      }
  
***************
*** 2919,2960 ****
      }
  
!   larray = array_len (args) + 1;
! 
! #if defined (ALIAS)
!   /* Forget about any aliases that we knew of.  We are in a subshell. */
!   delete_all_aliases ();
! #endif /* ALIAS */
! 
! #if defined (HISTORY)
!   /* Forget about the history lines we have read.  This is a non-interactive
!      subshell. */
!   history_lines_this_session = 0;
! #endif
! 
! #if defined (JOB_CONTROL)
!   /* Forget about the way job control was working. We are in a subshell. */
!   without_job_control ();
!   set_sigchld_handler ();
! #endif /* JOB_CONTROL */
! 
!   /* If we're not interactive, close the file descriptor from which we're
!      reading the current shell script. */
! #if defined (BUFFERED_INPUT)
!   if (interactive_shell == 0 && default_buffered_input >= 0)
!     {
!       close_buffered_fd (default_buffered_input);
!       default_buffered_input = bash_input.location.buffered_fd = -1;
!     }
! #else
!   if (interactive_shell == 0 && default_input)
!     {
!       fclose (default_input);
!       default_input = (FILE *)NULL;
!     }
! #endif
  
    set_sigint_handler ();
  
    /* Insert the name of this shell into the argument list. */
    args = (char **)xrealloc ((char *)args, (1 + larray) * sizeof (char *));
  
--- 3080,3089 ----
      }
  
!   initialize_subshell ();
  
    set_sigint_handler ();
  
    /* Insert the name of this shell into the argument list. */
+   larray = array_len (args) + 1;
    args = (char **)xrealloc ((char *)args, (1 + larray) * sizeof (char *));
  
***************
*** 3022,3025 ****
--- 3151,3155 ----
  }
  
+ #if defined (INCLUDE_UNUSED)
  #if defined (PROCESS_SUBSTITUTION)
  void
***************
*** 3036,3039 ****
--- 3166,3170 ----
  }
  #endif /* PROCESS_SUBSTITUTION */
+ #endif
  
  static void
***************
*** 3116,3119 ****
--- 3247,3254 ----
  #endif /* RESTRICTED_SHELL */
  
+     case HEREDOC_REDIRECT:
+       internal_error ("cannot create temp file for here document: %s", strerror (heredoc_errno));
+       break;
+ 
      default:
        internal_error ("%s: %s", filename, strerror (error));
***************
*** 3211,3214 ****
--- 3346,3352 ----
  }
  
+ /* Write the text of the here document pointed to by REDIRECTEE to the file
+    descriptor FD, which is already open to a temp file.  Return 0 if the
+    write is successful, otherwise return errno. */
  static int
  write_here_document (fd, redirectee)
***************
*** 3280,3284 ****
  }
  
! /* Do the specific redirection requested.  Returns errno in case of error.
     If FOR_REAL is zero, then just do whatever is neccessary to produce the
     appropriate side effects.   REMEMBERING, if non-zero, says to remember
--- 3418,3532 ----
  }
  
! /* Create a temporary file holding the text of the here document pointed to
!    by REDIRECTEE, and return a file descriptor open for reading to the temp
!    file.  Return -1 on any error, and make sure errno is set appropriately. */
! static int
! here_document_to_fd (redirectee)
!      WORD_DESC *redirectee;
! {
!   char filename[24];
!   int r, fd;
! 
!   /* Make the filename for the temp file. */
!   sprintf (filename, "/tmp/t%d-sh", (int)time ((time_t *) 0) + (int)getpid ());
! 
!   /* Make sure we open it exclusively. */
!   fd = open (filename, O_TRUNC | O_WRONLY | O_CREAT | O_EXCL, 0600);
!   if (fd < 0)
!     return (fd);
! 
!   errno = r = 0;		/* XXX */
!   /* write_here_document returns 0 on success, errno on failure. */
!   if (redirectee->word)
!     r = write_here_document (fd, redirectee);
! 
!   close (fd);
!   if (r)
!     {
!       unlink (filename);
!       errno = r;
!       return (-1);
!     }
! 
!   /* XXX - this is raceable */
!   /* Make the document really temporary.  Also make it the input. */
!   fd = open (filename, O_RDONLY, 0600);
! 
!   if (fd < 0)
!     {
!       r = errno;
!       unlink (filename);
!       errno = r;
!       return -1;
!     }
! 
!   if (unlink (filename) < 0)
!     {
!       r = errno;
!       close (fd);
!       errno = r;
!       return (-1);
!     }
! 
!   return (fd);
! }
! 
! /* Open FILENAME with FLAGS in noclobber mode, hopefully avoiding most
!    race conditions and avoiding the problem where the file is replaced
!    between the stat(2) and open(2). */
! static int
! noclobber_open (filename, flags, ri)
!      char *filename;
!      int flags;
!      enum r_instruction ri;
! {
!   int r, fd;
!   struct stat finfo, finfo2;
! 
!   /* If the file exists and is a regular file, return an error
!      immediately. */
!   r = stat (filename, &finfo);
!   if (r == 0 && (S_ISREG (finfo.st_mode)))
!     return (NOCLOBBER_REDIRECT);
! 
!   /* If the file was not present (r != 0), make sure we open it
!      exclusively so that if it is created before we open it, our open
!      will fail.  Make sure that we do not truncate an existing file.
!      Note that we don't turn on O_EXCL unless the stat failed -- if
!      the file was not a regular file, we leave O_EXCL off. */
!   flags &= ~O_TRUNC;
!   if (r != 0)
!     {
!       fd = open (filename, flags|O_EXCL, 0666);
!       return ((fd < 0 && errno == EEXIST) ? NOCLOBBER_REDIRECT : fd);
!     }
!   fd = open (filename, flags, 0666);
! 
!   /* If the open failed, return the file descriptor right away. */
!   if (fd < 0)
!     return (errno == EEXIST ? NOCLOBBER_REDIRECT : fd);
! 
!   /* OK, the open succeeded, but the file may have been changed from a
!      non-regular file to a regular file between the stat and the open.
!      We are assuming that the O_EXCL open handles the case where FILENAME
!      did not exist and is symlinked to an existing file between the stat
!      and open. */
! 
!   /* If we can open it and fstat the file descriptor, and neither check
!      revealed that it was a regular file, and the file has not been replaced,
!      return the file descriptor. */
!   if ((fstat (fd, &finfo2) == 0) && (S_ISREG (finfo2.st_mode) == 0) &&
!       r == 0 && (S_ISREG (finfo.st_mode) == 0) &&
!       same_file (filename, filename, &finfo, &finfo2))
!     return fd;
! 
!   /* The file has been replaced.  badness. */
!   close (fd);  
!   errno = EEXIST;
!   return (NOCLOBBER_REDIRECT);
! }
! 
! /* Do the specific redirection requested.  Returns errno or one of the
!    special redirection errors (*_REDIRECT) in case of error, 0 on success.
     If FOR_REAL is zero, then just do whatever is neccessary to produce the
     appropriate side effects.   REMEMBERING, if non-zero, says to remember
***************
*** 3295,3299 ****
    enum r_instruction ri;
    REDIRECT *new_redirect;
-   struct stat finfo;
  
    redirectee = redirect->redirectee.filename;
--- 3543,3546 ----
***************
*** 3403,3425 ****
  
        /* If we are in noclobber mode, you are not allowed to overwrite
! 	 existing files.  Check first. */
        if (noclobber && OUTPUT_REDIRECT (ri))
  	{
! 	  r = stat (redirectee_word, &finfo);
! 
! 	  if (r == 0 && (S_ISREG (finfo.st_mode)))
! 	    {
! 	      free (redirectee_word);
! 	      return (NOCLOBBER_REDIRECT);
! 	    }
! 
! 	  /* If the file was not present, make sure we open it exclusively
! 	     so that if it is created before we open it, our open will fail. */
! 	  if (r != 0)
! 	    redirect->flags |= O_EXCL;
! 
! 	  fd = open (redirectee_word, redirect->flags, 0666);
! 
! 	  if (fd < 0 && errno == EEXIST)
  	    {
  	      free (redirectee_word);
--- 3650,3658 ----
  
        /* If we are in noclobber mode, you are not allowed to overwrite
! 	 existing files.  Check before opening. */
        if (noclobber && OUTPUT_REDIRECT (ri))
  	{
! 	  fd = noclobber_open (redirectee_word, redirect->flags, ri);
! 	  if (fd == NOCLOBBER_REDIRECT)
  	    {
  	      free (redirectee_word);
***************
*** 3508,3539 ****
        if (redirectee)
  	{
! 	  char filename[24];
! 
! 	  /* Make the filename for the temp file. */
! 	  sprintf (filename, "/tmp/t%d-sh", (int)getpid ());
  
- 	  fd = open (filename, O_TRUNC | O_WRONLY | O_CREAT, 0666);
  	  if (fd < 0)
- 	    return (errno);
- 
- 	  errno = r = 0;		/* XXX */
- 	  if (redirectee->word)
- 	    r = write_here_document (fd, redirectee);
- 
- 	  close (fd);
- 	  if (r)
- 	    return (r);
- 
- 	  /* Make the document really temporary.  Also make it the input. */
- 	  fd = open (filename, O_RDONLY, 0666);
- 
- 	  if (fd < 0)
- 	    return (errno);
- 
- 	  if (unlink (filename) < 0)
  	    {
! 	      r = errno;
! 	      close (fd);
! 	      return (r);
  	    }
  
--- 3741,3750 ----
        if (redirectee)
  	{
! 	  fd = here_document_to_fd (redirectee);
  
  	  if (fd < 0)
  	    {
! 	      heredoc_errno = errno;
! 	      return (HEREDOC_REDIRECT);
  	    }
  
***************
*** 3623,3626 ****
--- 3834,3841 ----
  	}
        break;
+ 
+     case r_duplicating_input_word:
+     case r_duplicating_output_word:
+       break;
      }
    return (0);
***************
*** 3716,3720 ****
  {
    struct stat finfo;
-   static int user_id = -1;
  
    /* Determine whether this file exists or not. */
--- 3931,3934 ----
***************
*** 3740,3749 ****
       only other criteria is that the file has an execute bit set that
       we can use. */
-   if (user_id == -1)
-     user_id = current_user.euid;
  
    /* Root only requires execute permission for any of owner, group or
       others to be able to exec a file. */
!   if (user_id == 0)
      {
        int bits;
--- 3954,3961 ----
       only other criteria is that the file has an execute bit set that
       we can use. */
  
    /* Root only requires execute permission for any of owner, group or
       others to be able to exec a file. */
!   if (current_user.euid == (uid_t)0)
      {
        int bits;
***************
*** 3758,3762 ****
  
    /* If we are the owner of the file, the owner execute bit applies. */
!   if (user_id == finfo.st_uid && X_BIT (u_mode_bits (finfo.st_mode)))
      return (FS_EXISTS | FS_EXECABLE);
  
--- 3970,3974 ----
  
    /* If we are the owner of the file, the owner execute bit applies. */
!   if (current_user.euid == finfo.st_uid && X_BIT (u_mode_bits (finfo.st_mode)))
      return (FS_EXISTS | FS_EXECABLE);
  
***************
*** 3891,3894 ****
--- 4103,4109 ----
  }
  
+ /* Look for PATHNAME in $PATH.  Returns either the hashed command
+    corresponding to PATHNAME or the first instance of PATHNAME found
+    in $PATH.  Returns a newly-allocated string. */
  char *
  search_for_command (pathname)
***************
*** 3922,3925 ****
--- 4137,4141 ----
  	{
  	  remove_hashed_filename (pathname);
+ 	  free (hashed_file);
  	  hashed_file = (char *)NULL;
  	}
***************
*** 3927,3931 ****
  
    if (hashed_file)
!     command = savestring (hashed_file);
    else if (absolute_program (pathname))
      /* A command containing a slash is not looked up in PATH or saved in
--- 4143,4147 ----
  
    if (hashed_file)
!     command = hashed_file;
    else if (absolute_program (pathname))
      /* A command containing a slash is not looked up in PATH or saved in
diff -Nrc2 bash-2.0/expr.c bash-2.01/expr.c
*** bash-2.0/expr.c	Fri Nov 15 13:44:59 1996
--- bash-2.01/expr.c	Thu Apr 24 16:16:18 1997
***************
*** 131,135 ****
  
  static void	readtok ();	/* lexical analyzer */
! static long	expassign (), exp0 (), exp1 (), exp2 (), exp3 (),
  		exp4 (), exp5 (), expshift (), expland (), explor (),
  		expband (), expbor (), expbxor (), expcond ();
--- 131,135 ----
  
  static void	readtok ();	/* lexical analyzer */
! static long	subexpr (), expassign (), exp0 (), exp1 (), exp2 (), exp3 (),
  		exp4 (), exp5 (), expshift (), expland (), explor (),
  		expband (), expbor (), expbxor (), expcond ();
***************
*** 159,164 ****
    EXPR_CONTEXT *context;
  
-   context = (EXPR_CONTEXT *)xmalloc (sizeof (EXPR_CONTEXT));
- 
    if (expr_depth >= MAX_EXPR_RECURSION_LEVEL)
      evalerror ("expression recursion level exceeded");
--- 159,162 ----
***************
*** 171,174 ****
--- 169,174 ----
      }
  
+   context = (EXPR_CONTEXT *)xmalloc (sizeof (EXPR_CONTEXT));
+ 
    context->curtok = curtok;
    context->lasttok = lasttok;
***************
*** 200,204 ****
  }
  
! /* Evaluate EXPR, and return the arithmetic result.
  
     The `while' loop after the longjmp is caught relies on the above
--- 200,208 ----
  }
  
! /* Evaluate EXPR, and return the arithmetic result.  If VALIDP is
!    non-null, a zero is stored into the location to which it points
!    if the expression is invalid, non-zero otherwise.  If a non-zero
!    value is returned in *VALIDP, the return value of evalexp() may
!    be used.
  
     The `while' loop after the longjmp is caught relies on the above
***************
*** 210,239 ****
     any of the expr_depth[0] stuff. */
  long
! evalexp (expr)
       char *expr;
  {
!   long val = 0L;
    procenv_t old_evalbuf;
!   char *p;
! 
!   for (p = expr; p && *p && cr_whitespace (*p); p++)
!     ;
  
!   if (p == NULL || *p == '\0')
!     return (0);
  
    /* Save the value of evalbuf to protect it around possible recursive
       calls to evalexp (). */
    COPY_PROCENV (evalbuf, old_evalbuf);
  
    if (setjmp (evalbuf))
      {
!       if (tokstr)		/* Clean up local allocation. */
! 	free (tokstr);
! 
!       if (expression)
! 	free (expression);
  
!       while (--expr_depth)
  	{
  	  if (expr_stack[expr_depth]->tokstr)
--- 214,241 ----
     any of the expr_depth[0] stuff. */
  long
! evalexp (expr, validp)
       char *expr;
+      int *validp;
  {
!   long val;
! #if 0
    procenv_t old_evalbuf;
! #endif
  
!   val = 0L;
  
+ #if 0
    /* Save the value of evalbuf to protect it around possible recursive
       calls to evalexp (). */
    COPY_PROCENV (evalbuf, old_evalbuf);
+ #endif
  
    if (setjmp (evalbuf))
      {
!       FREE (tokstr);
!       FREE (expression);
!       tokstr = expression = (char *)NULL;
  
!       while (--expr_depth > 0)
  	{
  	  if (expr_stack[expr_depth]->tokstr)
***************
*** 242,249 ****
  	  if (expr_stack[expr_depth]->expression)
  	    free (expr_stack[expr_depth]->expression);
  	}
!       jump_to_top_level (DISCARD);
      }
  
    pushexp ();
    curtok = lasttok = 0;
--- 244,284 ----
  	  if (expr_stack[expr_depth]->expression)
  	    free (expr_stack[expr_depth]->expression);
+ 
+ 	  free (expr_stack[expr_depth]);
  	}
!       free (expr_stack[expr_depth]);	/* free the allocated EXPR_CONTEXT */
! 
!       if (validp)
! 	*validp = 0;
!       return (0L);
      }
  
+   val = subexpr (expr);
+ 
+ #if 0
+   /* Restore the value of evalbuf so that any subsequent longjmp calls
+      will have a valid location to jump to. */
+   COPY_PROCENV (old_evalbuf, evalbuf);
+ #endif
+ 
+   if (validp)
+     *validp = 1;
+ 
+   return (val);
+ }
+ 
+ static long
+ subexpr (expr)
+      char *expr;
+ {
+   long val;
+   char *p;
+ 
+   for (p = expr; p && *p && cr_whitespace (*p); p++)
+     ;
+ 
+   if (p == NULL || *p == '\0')
+     return (0L);
+ 
    pushexp ();
    curtok = lasttok = 0;
***************
*** 252,256 ****
  
    tokstr = (char *)NULL;
!   tokval = 0l;
  
    readtok ();
--- 287,291 ----
  
    tokstr = (char *)NULL;
!   tokval = 0L;
  
    readtok ();
***************
*** 261,276 ****
      evalerror ("syntax error in expression");
  
!   if (tokstr)
!     free (tokstr);
!   if (expression)
!     free (expression);
  
    popexp ();
  
!   /* Restore the value of evalbuf so that any subsequent longjmp calls
!      will have a valid location to jump to. */
!   COPY_PROCENV (old_evalbuf, evalbuf);
! 
!   return (val);
  }
  
--- 296,305 ----
      evalerror ("syntax error in expression");
  
!   FREE (tokstr);
!   FREE (expression);
  
    popexp ();
  
!   return val;
  }
  
***************
*** 363,366 ****
--- 392,396 ----
  	      break;
  	    default:
+ 	      free (lhs);
  	      evalerror ("bug: bad expassign token");
  	      break;
***************
*** 374,378 ****
        free (rhs);
        free (lhs);
!       free (tokstr);
        tokstr = (char *)NULL;		/* For freeing on errors. */
      }
--- 404,408 ----
        free (rhs);
        free (lhs);
!       FREE (tokstr);
        tokstr = (char *)NULL;		/* For freeing on errors. */
      }
***************
*** 385,388 ****
--- 415,421 ----
  {
    long cval, val1, val2, rval;
+   int set_noeval;
+ 
+   set_noeval = 0;
    rval = cval = explor ();
    if (curtok == QUES)		/* found conditional expr */
***************
*** 392,396 ****
  	evalerror ("expression expected");
        if (cval == 0)
! 	noeval++;
  #if 0
        val1 = explor ();
--- 425,432 ----
  	evalerror ("expression expected");
        if (cval == 0)
! 	{
! 	  set_noeval = 1;
! 	  noeval++;
! 	}
  #if 0
        val1 = explor ();
***************
*** 398,402 ****
        val1 = expassign ();
  #endif
!       if (cval == 0)
          noeval--;
        if (curtok != COL)
--- 434,438 ----
        val1 = expassign ();
  #endif
!       if (set_noeval)
          noeval--;
        if (curtok != COL)
***************
*** 405,412 ****
        if (curtok == 0)
  	evalerror ("expression expected");
        if (cval)
!         noeval++;
        val2 = explor ();
!       if (cval)
          noeval--;
        rval = cval ? val1 : val2;
--- 441,452 ----
        if (curtok == 0)
  	evalerror ("expression expected");
+       set_noeval = 0;
        if (cval)
!  	{
!  	  set_noeval = 1;
! 	  noeval++;
!  	}
        val2 = explor ();
!       if (set_noeval)
          noeval--;
        rval = cval ? val1 : val2;
***************
*** 421,424 ****
--- 461,465 ----
  {
    register long val1, val2;
+   int set_noeval;
  
    val1 = expland ();
***************
*** 426,436 ****
    while (curtok == LOR)
      {
!       readtok ();
        if (val1 != 0)
! 	noeval++;
        val2 = expland ();
!       if (val1 != 0)
  	noeval--;
        val1 = val1 || val2;
      }
  
--- 467,482 ----
    while (curtok == LOR)
      {
!       set_noeval = 0;
        if (val1 != 0)
! 	{
! 	  noeval++;
! 	  set_noeval = 1;
! 	}
!       readtok ();
        val2 = expland ();
!       if (set_noeval)
  	noeval--;
        val1 = val1 || val2;
+       lasttok = LOR;
      }
  
***************
*** 443,446 ****
--- 489,493 ----
  {
    register long val1, val2;
+   int set_noeval;
  
    val1 = expbor ();
***************
*** 448,458 ****
    while (curtok == LAND)
      {
!       readtok ();
        if (val1 == 0)
! 	noeval++;
        val2 = expbor ();
!       if (val1 == 0)
  	noeval--;
        val1 = val1 && val2;
      }
  
--- 495,510 ----
    while (curtok == LAND)
      {
!       set_noeval = 0;
        if (val1 == 0)
! 	{
! 	  set_noeval = 1;
! 	  noeval++;
! 	}
!       readtok ();
        val2 = expbor ();
!       if (set_noeval)
  	noeval--;
        val1 = val1 && val2;
+       lasttok = LAND;
      }
  
***************
*** 557,561 ****
        else if (op == LT)
  	val1 = val1 < val2;
!       else if (op == GT)
  	val1 = val1 > val2;
      }
--- 609,613 ----
        else if (op == LT)
  	val1 = val1 < val2;
!       else			/* (op == GT) */
  	val1 = val1 > val2;
      }
***************
*** 763,767 ****
  #endif
  
!       tokval = (value && *value) ? evalexp (value) : 0;
  
        *cp = c;
--- 815,824 ----
  #endif
  
!       tokval = (value && *value) ? subexpr (value) : 0;
! 
! #if defined (ARRAY_VARS)
!       if (e == ']')
! 	FREE (value);	/* get_array_value returns newly-allocated memory */
! #endif
  
        *cp = c;
***************
*** 961,964 ****
--- 1018,1022 ----
    register int i;
    long v;
+   int expok;
  
    if (setjmp (top_level))
***************
*** 967,972 ****
    for (i = 1; i < argc; i++)
      {
!       v = evalexp (argv[i]);
!       printf ("'%s' -> %ld\n", argv[i], v);
      }
    exit (0);
--- 1025,1033 ----
    for (i = 1; i < argc; i++)
      {
!       v = evalexp (argv[i], &expok);
!       if (expok == 0)
!         fprintf (stderr, "%s: expression error\n", argv[i]);
!       else
!         printf ("'%s' -> %ld\n", argv[i], v);
      }
    exit (0);
diff -Nrc2 bash-2.0/externs.h bash-2.01/externs.h
*** bash-2.0/externs.h	Wed Oct  9 12:48:21 1996
--- bash-2.01/externs.h	Thu Apr 24 11:40:01 1997
***************
*** 28,36 ****
  
  /* Functions from expr.c. */
! extern long evalexp __P((char *));
  
  /* Functions from getcwd.c */
  #if !defined (HAVE_GETCWD)
! extern char *getcwd ();
  #endif
  
--- 28,36 ----
  
  /* Functions from expr.c. */
! extern long evalexp __P((char *, int *));
  
  /* Functions from getcwd.c */
  #if !defined (HAVE_GETCWD)
! extern char *getcwd __P((char *, size_t));
  #endif
  
***************
*** 46,49 ****
--- 46,50 ----
  extern int exit_shell __P((int));
  extern void disable_priv_mode __P((void));
+ extern void unbind_args __P((void));
  
  #if defined (RESTRICTED_SHELL)
***************
*** 51,54 ****
--- 52,57 ----
  #endif
  
+ extern void get_current_user_info __P((void));
+ 
  /* Functions from eval.c. */
  extern int reader_loop __P((void));
***************
*** 57,61 ****
  
  /* Functions from test.c. */
- extern int group_member ();
  extern int test_command ();
  
--- 60,63 ----
***************
*** 116,120 ****
  
  /* Declarations for functions defined in stringlib.c */
! extern char *ansicstr __P((char *, int, int *));
  extern int find_name_in_array __P((char *, char **));
  extern int array_len __P((char **));
--- 118,122 ----
  
  /* Declarations for functions defined in stringlib.c */
! extern char *ansicstr __P((char *, int, int *, int *));
  extern int find_name_in_array __P((char *, char **));
  extern int array_len __P((char **));
***************
*** 129,133 ****
  extern char *strsub __P((char *, char *, char *, int));
  extern void strip_leading __P((char *));
! extern void strip_trailing __P((char *, int));
  extern char *strindex __P((char *, char *));
  extern void xbcopy __P((char *, char *, int));
--- 131,135 ----
  extern char *strsub __P((char *, char *, char *, int));
  extern void strip_leading __P((char *));
! extern void strip_trailing __P((char *, int, int));
  extern char *strindex __P((char *, char *));
  extern void xbcopy __P((char *, char *, int));
diff -Nrc2 bash-2.0/flags.c bash-2.01/flags.c
*** bash-2.0/flags.c	Mon Jul 22 14:42:59 1996
--- bash-2.01/flags.c	Thu Apr 17 09:51:17 1997
***************
*** 33,36 ****
--- 33,40 ----
  #endif
  
+ #if defined (RESTRICTED_SHELL)
+ extern char *shell_name;
+ #endif
+ 
  /* **************************************************************** */
  /*								    */
***************
*** 239,248 ****
  #if defined (JOB_CONTROL)
      case 'm':
!       set_job_control (on_or_off == '-');
        break;
  #endif /* JOB_CONTROL */
  
      case 'p':
!       if (on_or_off == '+')
  	disable_priv_mode ();
  
--- 243,266 ----
  #if defined (JOB_CONTROL)
      case 'm':
!       set_job_control (on_or_off == FLAG_ON);
        break;
  #endif /* JOB_CONTROL */
  
+ #if defined (RESTRICTED_SHELL)
+     case 'r':
+       if (on_or_off == FLAG_ON)
+         maybe_make_restricted (shell_name);
+       break;
+ #endif
+ 
+ #if defined (BANG_HISTORY)
+     case 'H':
+       if (on_or_off == FLAG_ON)
+ 	bash_initialize_history ();
+       break;
+ #endif
+ 
      case 'p':
!       if (on_or_off == FLAG_OFF)
  	disable_priv_mode ();
  
***************
*** 268,270 ****
--- 286,316 ----
    temp[string_index] = '\0';
    return (temp);
+ }
+ 
+ void
+ reset_shell_flags ()
+ {
+   mark_modified_vars = exit_immediately_on_error = disallow_filename_globbing = 0;
+   place_keywords_in_env = read_but_dont_execute = just_one_command = 0;
+   noclobber = unbound_vars_is_error = echo_input_at_read = 0;
+   echo_command_at_execute = jobs_m_flag = forced_interactive = 0;
+   no_symbolic_links = no_invisible_vars = privileged_mode = 0;
+ 
+   hashing_enabled = interactive_comments = 1;
+ 
+ #if defined (JOB_CONTROL)
+   asynchronous_notification = 0;
+ #endif
+ 
+ #if defined (BANG_HISTORY)
+   history_expansion = 1;
+ #endif
+ 
+ #if defined (BRACE_EXPANSION)
+   brace_expansion = 1;
+ #endif
+ 
+ #if defined (RESTRICTED_SHELL)
+   restricted = 0;
+ #endif
  }
diff -Nrc2 bash-2.0/flags.h bash-2.01/flags.h
*** bash-2.0/flags.h	Tue Mar 28 13:24:14 1995
--- bash-2.01/flags.h	Thu Apr 17 09:51:35 1997
***************
*** 67,70 ****
--- 67,71 ----
  extern int change_flag __P((int, int));
  extern char *which_set_flags __P((void));
+ extern void reset_shell_flags __P((void));
  
  /* A macro for efficiency. */
diff -Nrc2 bash-2.0/general.c bash-2.01/general.c
*** bash-2.0/general.c	Wed Oct 23 10:57:35 1996
--- bash-2.01/general.c	Fri May 30 15:18:26 1997
***************
*** 90,99 ****
       int i;
  {
!   char *buf, *p, *ret;
    int negative = 0;
    unsigned int ui;
  
-   buf = xmalloc (MAX_INT_LEN);
- 
    if (i < 0)
      {
--- 90,97 ----
       int i;
  {
!   char buf[MAX_INT_LEN], *p, *ret;
    int negative = 0;
    unsigned int ui;
  
    if (i < 0)
      {
***************
*** 115,119 ****
  
    ret = savestring (p + 1);
-   free (buf);
    return (ret);
  }
--- 113,116 ----
***************
*** 440,444 ****
    char *tty;
  
!   tty_fd = open ("/dev/tty", O_RDWR);
  
    if (tty_fd < 0)
--- 437,441 ----
    char *tty;
  
!   tty_fd = open ("/dev/tty", O_RDWR|O_NONBLOCK);
  
    if (tty_fd < 0)
***************
*** 447,451 ****
        if (tty == 0)
  	return;
!       tty_fd = open (tty, O_RDWR);
      }
    close (tty_fd);
--- 444,448 ----
        if (tty == 0)
  	return;
!       tty_fd = open (tty, O_RDWR|O_NONBLOCK);
      }
    close (tty_fd);
***************
*** 483,498 ****
     redirection and causing us extra work.  If CHECK_NEW is non-zero,
     we check whether or not the file descriptors are in use before
!    duplicating FD onto them. */
  int
! move_to_high_fd (fd, check_new)
!      int fd, check_new;
  {
    int script_fd, nfds, ignore;
  
!   nfds = getdtablesize ();
!   if (nfds <= 0)
!     nfds = 20;
!   if (nfds > 256)
!     nfds = 256;
  
    for (nfds--; check_new && nfds > 3; nfds--)
--- 480,502 ----
     redirection and causing us extra work.  If CHECK_NEW is non-zero,
     we check whether or not the file descriptors are in use before
!    duplicating FD onto them.  MAXFD says where to start checking the
!    file descriptors.  If it's less than 20, we get the maximum value
!    available from getdtablesize(2). */
  int
! move_to_high_fd (fd, check_new, maxfd)
!      int fd, check_new, maxfd;
  {
    int script_fd, nfds, ignore;
  
!   if (maxfd < 20)
!     {
!       nfds = getdtablesize ();
!       if (nfds <= 0)
! 	nfds = 20;
!       if (nfds > 256)
! 	nfds = 256;
!     }
!   else
!     nfds = maxfd;
  
    for (nfds--; check_new && nfds > 3; nfds--)
***************
*** 608,616 ****
  	i++;
  
! #if !defined (apollo)
        if ((start + 1) != i)
  #else
        if ((start + 1) != i && (start != 0 || i != 2))
! #endif /* apollo */
  	{
  	  strcpy (result + start + 1, result + i);
--- 612,621 ----
  	i++;
  
! #if 0
        if ((start + 1) != i)
  #else
+       /* Leave a leading `//' alone, as POSIX requires. */
        if ((start + 1) != i && (start != 0 || i != 2))
! #endif
  	{
  	  strcpy (result + start + 1, result + i);
***************
*** 710,718 ****
    int result_len;
  
!   if (!dot_path || *string == '/')
      result = savestring (string);
    else
      {
!       if (dot_path && dot_path[0])
  	{
  	  result_len = strlen (dot_path);
--- 715,723 ----
    int result_len;
  
!   if (dot_path == 0 || *string == '/')
      result = savestring (string);
    else
      {
!       if (dot_path[0])
  	{
  	  result_len = strlen (dot_path);
***************
*** 802,805 ****
--- 807,811 ----
    disposer = file;
  
+   /* XXX - this should probably be just PATH_MAX or PATH_MAX + 1 */
    current_dir = xmalloc (2 + PATH_MAX + strlen (file));
    if (getcwd (current_dir, PATH_MAX) == 0)
***************
*** 907,913 ****
  /* If tilde_expand hasn't been able to expand the text, perhaps it
     is a special shell expansion.  This function is installed as the
!    tilde_expansion_failure_hook.  It knows how to expand ~- and ~+. */
  static char *
! bash_tilde_expansion_failure_hook (text)
       char *text;
  {
--- 913,919 ----
  /* If tilde_expand hasn't been able to expand the text, perhaps it
     is a special shell expansion.  This function is installed as the
!    tilde_expansion_preexpansion_hook.  It knows how to expand ~- and ~+. */
  static char *
! bash_special_tilde_expansions (text)
       char *text;
  {
***************
*** 918,924 ****
      {
        if (*text == '+')
!         result = get_string_value ("PWD");
        else if (*text == '-')
!         result = get_string_value ("OLDPWD");
      }
  
--- 924,930 ----
      {
        if (*text == '+')
! 	result = get_string_value ("PWD");
        else if (*text == '-')
! 	result = get_string_value ("OLDPWD");
      }
  
***************
*** 934,939 ****
    static int times_called = 0;
  
!   /* Tell the tilde expander that we want a crack if it fails. */
!   tilde_expansion_failure_hook = (CPFunction *)bash_tilde_expansion_failure_hook;
  
    /* Tell the tilde expander about special strings which start a tilde
--- 940,945 ----
    static int times_called = 0;
  
!   /* Tell the tilde expander that we want a crack first. */
!   tilde_expansion_preexpansion_hook = (CPFunction *)bash_special_tilde_expansions;
  
    /* Tell the tilde expander about special strings which start a tilde
***************
*** 967,969 ****
--- 973,1107 ----
    interrupt_immediately = old_immed;
    return (ret);
+ }
+ 
+ /* **************************************************************** */
+ /*								    */
+ /*	  Functions to manipulate and search the group list	    */
+ /*								    */
+ /* **************************************************************** */
+ 
+ static int ngroups, maxgroups;
+ 
+ /* The set of groups that this user is a member of. */
+ static GETGROUPS_T *group_array = (GETGROUPS_T *)NULL;
+ 
+ #if !defined (NOGROUP)
+ #  define NOGROUP (gid_t) -1
+ #endif
+ 
+ #if defined (HAVE_SYSCONF) && defined (_SC_NGROUPS_MAX)
+ #  define getmaxgroups() sysconf(_SC_NGROUPS_MAX)
+ #else
+ #  if defined (NGROUPS_MAX)
+ #    define getmaxgroups() NGROUPS_MAX
+ #  else /* !NGROUPS_MAX */
+ #    if defined (NGROUPS)
+ #      define getmaxgroups() NGROUPS
+ #    else /* !NGROUPS */
+ #      define getmaxgroups() 64
+ #    endif /* !NGROUPS */
+ #  endif /* !NGROUPS_MAX */
+ #endif /* !HAVE_SYSCONF || !SC_NGROUPS_MAX */
+ 
+ static void
+ initialize_group_array ()
+ {
+   register int i;
+ 
+   if (maxgroups == 0)
+     maxgroups = getmaxgroups ();
+ 
+   ngroups = 0;
+   group_array = (GETGROUPS_T *)xrealloc (group_array, maxgroups * sizeof (GETGROUPS_T));
+ 
+ #if defined (HAVE_GETGROUPS)
+   ngroups = getgroups (maxgroups, group_array);
+ #endif
+ 
+   /* If getgroups returns nothing, or the OS does not support getgroups(),
+      make sure the groups array includes at least the current gid. */
+   if (ngroups == 0)
+     {
+       group_array[0] = current_user.gid;
+       ngroups = 1;
+     }
+ 
+   /* If the primary group is not in the groups array, add it as group_array[0]
+      and shuffle everything else up 1, if there's room. */
+   for (i = 0; i < ngroups; i++)
+     if (current_user.gid == (gid_t)group_array[i])
+       break;
+   if (i == ngroups && ngroups < maxgroups)
+     {
+       for (i = ngroups; i > 0; i--)
+         group_array[i] = group_array[i - 1];
+       group_array[0] = current_user.gid;
+       ngroups++;
+     }
+ }
+ 
+ /* Return non-zero if GID is one that we have in our groups list. */
+ int
+ group_member (gid)
+      gid_t gid;
+ {
+ #if defined (HAVE_GETGROUPS)
+   register int i;
+ #endif
+ 
+   /* Short-circuit if possible, maybe saving a call to getgroups(). */
+   if (gid == current_user.gid || gid == current_user.egid)
+     return (1);
+ 
+ #if defined (HAVE_GETGROUPS)
+   if (ngroups == 0)
+     initialize_group_array ();
+ 
+   /* In case of error, the user loses. */
+   if (ngroups <= 0)
+     return (0);
+ 
+   /* Search through the list looking for GID. */
+   for (i = 0; i < ngroups; i++)
+     if (gid == (gid_t)group_array[i])
+       return (1);
+ #endif
+ 
+   return (0);
+ }
+ 
+ char **
+ get_group_list (ngp)
+      int *ngp;
+ {
+   static char **group_vector = (char **)NULL;
+   register int i;
+   char *nbuf;
+ 
+   if (group_vector)
+     {
+       if (ngp)
+ 	*ngp = ngroups;
+       return group_vector;
+     }
+ 
+   if (ngroups == 0)
+     initialize_group_array ();
+ 
+   if (ngroups <= 0)
+     {
+       if (ngp)
+ 	*ngp = 0;
+       return (char **)NULL;
+     }
+ 
+   group_vector = (char **)xmalloc (ngroups * sizeof (char *));
+   for (i = 0; i < ngroups; i++)
+     {
+       nbuf = itos ((int)group_array[i]);
+       group_vector[i] = nbuf;
+     }
+   if (ngp)
+     *ngp = ngroups;
+   return group_vector;
  }
diff -Nrc2 bash-2.0/general.h bash-2.01/general.h
*** bash-2.0/general.h	Tue Aug 13 16:41:36 1996
--- bash-2.01/general.h	Thu Apr 17 13:57:12 1997
***************
*** 24,27 ****
--- 24,35 ----
  #include "stdc.h"
  
+ #include "bashtypes.h"
+ 
+ #if defined (HAVE_STRING_H)
+ #  include <string.h>
+ #else
+ #  include <strings.h>
+ #endif /* !HAVE_STRING_H */
+ 
  /* Generic pointer type. */
  #if defined (__STDC__)
***************
*** 40,49 ****
  #endif /* !NULL */
  
- #if defined (HAVE_STRING_H)
- #  include <string.h>
- #else
- #  include <strings.h>
- #endif /* !HAVE_STRING_H */
- 
  #define pointer_to_int(x) (int)((long)(x))
  
--- 48,51 ----
***************
*** 198,202 ****
  extern void check_dev_tty __P((void));
  extern int same_file ();	/* too many problems with prototype */
! extern int move_to_high_fd __P((int, int));
  extern int check_binary_file __P((unsigned char *, int));
  
--- 200,204 ----
  extern void check_dev_tty __P((void));
  extern int same_file ();	/* too many problems with prototype */
! extern int move_to_high_fd __P((int, int, int));
  extern int check_binary_file __P((unsigned char *, int));
  
***************
*** 213,216 ****
--- 215,225 ----
  extern void tilde_initialize __P((void));
  extern char *bash_tilde_expand __P((char *));
+ 
+ #if defined (__STDC__) && defined (gid_t)
+ extern int group_member __P((int));
+ #else
+ extern int group_member __P((gid_t));
+ #endif
+ extern char **get_group_list __P((int *));
  
  #endif	/* _GENERAL_H_ */
diff -Nrc2 bash-2.0/getcwd.c bash-2.01/getcwd.c
*** bash-2.0/getcwd.c	Fri Aug 25 16:39:45 1995
--- bash-2.01/getcwd.c	Mon Feb 17 14:25:30 1997
***************
*** 39,53 ****
  #include "memalloc.h"
  
! #if defined (HAVE_STDLIB_H)
! #  include <stdlib.h>
! #else
! #  include "ansi_stdlib.h"
! #endif /* !HAVE_STDLIB_H */
! 
! #if defined (HAVE_STRING_H)
! #  include <string.h>
! #else
! #  include <strings.h>
! #endif /* !HAVE_STRING_H */
  
  #if !defined (errno)
--- 39,43 ----
  #include "memalloc.h"
  
! #include "bashansi.h"
  
  #if !defined (errno)
diff -Nrc2 bash-2.0/hashcmd.c bash-2.01/hashcmd.c
*** bash-2.0/hashcmd.c	Wed Dec 31 19:00:00 1969
--- bash-2.01/hashcmd.c	Tue Jun  3 11:19:23 1997
***************
*** 0 ****
--- 1,191 ----
+ /* hashcmd.c - functions for managing a hash table mapping command names to
+ 	       full pathnames. */
+ 
+ /* Copyright (C) 1997 Free Software Foundation, Inc.
+ 
+    This file is part of GNU Bash, the Bourne Again SHell.
+ 
+     Bash is free software; you can redistribute it and/or modify it under
+     the terms of the GNU General Public License as published by the Free
+     Software Foundation; either version 1, or (at your option) any later
+     version.
+ 
+     Bash is distributed in the hope that it will be useful, but WITHOUT ANY
+     WARRANTY; without even the implied warranty of MERCHANTABILITY or
+     FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+     for more details.
+ 
+     You should have received a copy of the GNU General Public License along
+     with Bash; see the file COPYING.  If not, write to the Free Software
+     Foundation, 675 Mass Ave, Cambridge, MA 02139, USA. */
+ 
+ #include <config.h>
+ 
+ #include "bashtypes.h"
+ #include "posixstat.h"
+ 
+ #if defined (HAVE_UNISTD_H)
+ #  include <unistd.h>
+ #endif
+ 
+ #include "bashansi.h"
+ 
+ #include "shell.h"
+ #include "execute_cmd.h"
+ #include "hashcmd.h"
+ 
+ extern int hashing_enabled;
+ 
+ static int hashing_initialized = 0;
+ 
+ HASH_TABLE *hashed_filenames;
+ 
+ void
+ initialize_filename_hashing ()
+ {
+   if (hashing_initialized == 0)
+     {
+       hashed_filenames = make_hash_table (FILENAME_HASH_BUCKETS);
+       hashing_initialized = 1;
+     }
+ }
+ 
+ static void
+ free_filename_data (data)
+      char *data;
+ {
+   free (((PATH_DATA *)data)->path);
+   free (data);
+ }
+ 
+ void
+ flush_hashed_filenames ()
+ {
+   if (hashed_filenames)
+     flush_hash_table (hashed_filenames, free_filename_data);
+ }
+ 
+ /* Remove FILENAME from the table of hashed commands. */
+ void
+ remove_hashed_filename (filename)
+      char *filename;
+ {
+   register BUCKET_CONTENTS *item;
+ 
+   if (hashing_enabled == 0 || hashed_filenames == 0)
+     return;
+ 
+   item = remove_hash_item (filename, hashed_filenames);
+   if (item)
+     {
+       if (item->data)
+ 	free_filename_data (item->data);
+       free (item->key);
+       free (item);
+     }
+ }
+ 
+ /* Place FILENAME (key) and FULL_PATHNAME (data->path) into the
+    hash table.  CHECK_DOT if non-null is for future calls to
+    find_hashed_filename (); it means that this file was found
+    in a directory in $PATH that is not an absolute pathname.
+    FOUND is the initial value for times_found. */
+ void
+ remember_filename (filename, full_pathname, check_dot, found)
+      char *filename, *full_pathname;
+      int check_dot, found;
+ {
+   register BUCKET_CONTENTS *item;
+ 
+   if (hashing_enabled == 0)
+     return;
+ 
+   if (hashed_filenames == 0 || hashing_initialized == 0)
+     initialize_filename_hashing ();
+ 
+   item = add_hash_item (filename, hashed_filenames);
+   if (item->data)
+     free (pathdata(item)->path);
+   else
+     {
+       item->key = savestring (filename);
+       item->data = xmalloc (sizeof (PATH_DATA));
+     }
+   pathdata(item)->path = savestring (full_pathname);
+   pathdata(item)->flags = 0;
+   if (check_dot)
+     pathdata(item)->flags |= HASH_CHKDOT;
+   if (*full_pathname != '/')
+     pathdata(item)->flags |= HASH_RELPATH;
+   item->times_found = found;
+ }
+ 
+ /* Return the full pathname that FILENAME hashes to.  If FILENAME
+    is hashed, but (data->flags & HASH_CHKDOT) is non-zero, check
+    ./FILENAME and return that if it is executable.  This always
+    returns a newly-allocated string; the caller is responsible
+    for freeing it. */
+ char *
+ find_hashed_filename (filename)
+      char *filename;
+ {
+   register BUCKET_CONTENTS *item;
+   char *path, *dotted_filename, *tail;
+   int same;
+ 
+   if (hashing_enabled == 0 || hashed_filenames == 0)
+     return ((char *)NULL);
+ 
+   item = find_hash_item (filename, hashed_filenames);
+ 
+   if (item == NULL)
+     return ((char *)NULL);
+ 
+   /* If this filename is hashed, but `.' comes before it in the path,
+      see if ./filename is executable.  If the hashed value is not an
+      absolute pathname, see if ./`hashed-value' exists. */
+   path = pathdata(item)->path;
+   if (pathdata(item)->flags & (HASH_CHKDOT|HASH_RELPATH))
+     {
+       tail = (pathdata(item)->flags & HASH_RELPATH) ? path : filename;
+       dotted_filename = xmalloc (3 + strlen (tail));
+       dotted_filename[0] = '.'; dotted_filename[1] = '/';
+       strcpy (dotted_filename + 2, tail);
+ 
+       if (executable_file (dotted_filename))
+ 	return (dotted_filename);
+ 
+       free (dotted_filename);
+ 
+ #if 0
+       if (pathdata(item)->flags & HASH_RELPATH)
+ 	return ((char *)NULL);
+ #endif
+ 
+       /* Watch out.  If this file was hashed to "./filename", and
+ 	 "./filename" is not executable, then return NULL. */
+ 
+       /* Since we already know "./filename" is not executable, what
+ 	 we're really interested in is whether or not the `path'
+ 	 portion of the hashed filename is equivalent to the current
+ 	 directory, but only if it starts with a `.'.  (This catches
+ 	 ./. and so on.)  same_file () tests general Unix file
+ 	 equivalence -- same device and inode. */
+       if (*path == '.')
+ 	{
+ 	  same = 0;
+ 	  tail = (char *)strrchr (path, '/');
+ 
+ 	  if (tail)
+ 	    {
+ 	      *tail = '\0';
+ 	      same = same_file (".", path, (struct stat *)NULL, (struct stat *)NULL);
+ 	      *tail = '/';
+ 	    }
+ 
+ 	  return same ? (char *)NULL : savestring (path);
+ 	}
+     }
+ 
+   return (savestring (path));
+ }
diff -Nrc2 bash-2.0/hashcmd.h bash-2.01/hashcmd.h
*** bash-2.0/hashcmd.h	Wed Dec 31 19:00:00 1969
--- bash-2.01/hashcmd.h	Tue Apr  1 12:22:45 1997
***************
*** 0 ****
--- 1,41 ----
+ /* hashcmd.h - Common defines for hashing filenames. */
+ 
+ /* Copyright (C) 1993 Free Software Foundation, Inc.
+ 
+    This file is part of GNU Bash, the Bourne Again SHell.
+ 
+    Bash is free software; you can redistribute it and/or modify it under
+    the terms of the GNU General Public License as published by the Free
+    Software Foundation; either version 2, or (at your option) any later
+    version.
+ 
+    Bash is distributed in the hope that it will be useful, but WITHOUT ANY
+    WARRANTY; without even the implied warranty of MERCHANTABILITY or
+    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+    for more details.
+ 
+    You should have received a copy of the GNU General Public License along
+    with Bash; see the file COPYING.  If not, write to the Free Software
+    Foundation, 675 Mass Ave, Cambridge, MA 02139, USA. */
+ 
+ #include "hashlib.h"
+ 
+ #define FILENAME_HASH_BUCKETS 631
+ 
+ extern HASH_TABLE *hashed_filenames;
+ 
+ typedef struct {
+   char *path;		/* The full pathname of the file. */
+   int flags;
+ } PATH_DATA;
+ 
+ #define HASH_RELPATH	0x01	/* this filename is a relative pathname. */
+ #define HASH_CHKDOT	0x02	/* check `.' since it was earlier in $PATH */
+ 
+ #define pathdata(x) ((PATH_DATA *)(x)->data)
+ 
+ extern void initialize_filename_hashing ();
+ extern void flush_hashed_filenames ();
+ extern void remove_hashed_filename ();
+ extern void remember_filename ();
+ extern char *find_hashed_filename ();
diff -Nrc2 bash-2.0/hashlib.c bash-2.01/hashlib.c
*** bash-2.0/hashlib.c	Thu Aug 22 11:25:27 1996
--- bash-2.01/hashlib.c	Mon Apr 14 16:07:02 1997
***************
*** 21,35 ****
  #include "config.h"
  
! #if defined (HAVE_STRING_H)
! #  include <string.h>
! #else /* !HAVE_STRING_H */
! #  include <strings.h>
! #endif /* !HAVE_STRING_H */
! 
! #if defined (HAVE_STDLIB_H)
! #  include <stdlib.h>
! #else
! #  include "ansi_stdlib.h"
! #endif /* HAVE_STDLIB_H */
  
  #if defined (HAVE_UNISTD_H)
--- 21,25 ----
  #include "config.h"
  
! #include "bashansi.h"
  
  #if defined (HAVE_UNISTD_H)
***************
*** 37,40 ****
--- 27,32 ----
  #endif
  
+ #include <stdio.h>
+ 
  #include "shell.h"
  #include "hashlib.h"
***************
*** 202,205 ****
--- 194,200 ----
    register BUCKET_CONTENTS *bucket, *item;
  
+   if (table == 0)
+     return;
+ 
    for (i = 0; i < table->nbuckets; i++)
      {
***************
*** 222,225 ****
--- 217,229 ----
  }
  
+ /* Free the hash table pointed to by TABLE. */
+ void
+ dispose_hash_table (table)
+      HASH_TABLE *table;
+ {
+   free (table->bucket_array);
+   free (table);
+ }
+ 
  /* Return the bucket_contents list of bucket BUCKET in TABLE.  If
     TABLE doesn't have BUCKET buckets, return NULL. */
***************
*** 236,239 ****
--- 240,271 ----
  }
  
+ /* #ifdef DEBUG */
+ print_table_stats (table, name)
+      HASH_TABLE *table;
+      char *name;
+ {
+   register int slot, bcount;
+   register BUCKET_CONTENTS *bc;
+ 
+   if (name == 0)
+     name = "unknown hash table";
+ 
+   fprintf (stderr, "%s: %d buckets; %d items\n", name, table->nbuckets, table->nentries);
+ 
+   /* Print out a count of how many strings hashed to each bucket, so we can
+      see how even the distribution is. */
+   for (slot = 0; slot < table->nbuckets; slot++)
+     {
+       bc = get_hash_bucket (slot, table);
+ 
+       fprintf (stderr, "\tslot %3d: ", slot);
+       for (bcount = 0; bc; bc = bc->next)
+         bcount++;
+ 
+       fprintf (stderr, "%d\n", bcount);
+     }
+ }
+ /* #endif */
+ 
  #ifdef TEST_HASHING
  
***************
*** 285,307 ****
      }
  
!   printf ("You have entered %d (%d) items.  The distribution is:\n",
! 	  table->nentries, count);
! 
!   /* Print out a count of how many strings hashed to each bucket, so we can
!      see how even the distribution is. */
!   for (count = 0; count < table->nbuckets; count++)
!     {
!       int bcount;
!       register BUCKET_CONTENTS *list = get_hash_bucket (count, table);
! 
!       printf ("slot %3d: ", count);
!       bcount = 0;
! 
!       for (bcount = 0; list; list = list->next)
!         bcount++;
! 
!       printf ("%d\n", bcount);
!     }
!     exit (0);
  }
  
--- 317,322 ----
      }
  
!   print_table_stats (table, "hash test");
!   exit (0);
  }
  
diff -Nrc2 bash-2.0/hashlib.h bash-2.01/hashlib.h
*** bash-2.0/hashlib.h	Fri May  5 16:59:36 1995
--- bash-2.01/hashlib.h	Mon Apr 14 15:56:36 1997
***************
*** 42,45 ****
--- 42,46 ----
  extern BUCKET_CONTENTS *get_hash_bucket ();
  extern void flush_hash_table ();
+ extern void dispose_hash_table ();
  
  /* Redefine the function as a macro for speed. */
***************
*** 50,54 ****
  
  /* Default number of buckets in the hash table. */
! #define DEFAULT_HASH_BUCKETS 107
  
  #if !defined (NULL)
--- 51,55 ----
  
  /* Default number of buckets in the hash table. */
! #define DEFAULT_HASH_BUCKETS 53	/* was 107 */
  
  #if !defined (NULL)
diff -Nrc2 bash-2.0/input.h bash-2.01/input.h
*** bash-2.0/input.h	Thu May 16 12:10:38 1996
--- bash-2.01/input.h	Wed Feb 12 15:20:09 1997
***************
*** 81,85 ****
  /* Functions from parse.y. */
  extern void initialize_bash_input __P((void));
! extern void init_yy_io __P((Function *, Function *, int, char *, INPUT_STREAM));
  extern void with_input_from_stdin __P((void));
  extern void with_input_from_string __P((char *, char *));
--- 81,85 ----
  /* Functions from parse.y. */
  extern void initialize_bash_input __P((void));
! extern void init_yy_io __P((Function *, Function *, enum stream_type, char *, INPUT_STREAM));
  extern void with_input_from_stdin __P((void));
  extern void with_input_from_string __P((char *, char *));
diff -Nrc2 bash-2.0/jobs.c bash-2.01/jobs.c
*** bash-2.0/jobs.c	Wed Dec 18 14:42:56 1996
--- bash-2.01/jobs.c	Wed May 14 13:04:04 1997
***************
*** 84,95 ****
  #endif /* hpux && !TERMIOS_TTY_DRIVER */
  
  /* For struct winsize on SCO */
  /*   sys/ptem.h has winsize but needs mblk_t from sys/stream.h */
! #if defined (HAVE_SYS_PTEM_H) && defined (TIOCGWINSZ) && defined (SIGWINCH)
! #  if defined (HAVE_SYS_STREAM_H)
! #    include <sys/stream.h>
! #  endif
! #  include <sys/ptem.h>
! #endif
  
  #include "bashansi.h"
--- 84,97 ----
  #endif /* hpux && !TERMIOS_TTY_DRIVER */
  
+ #if !defined (STRUCT_WINSIZE_IN_SYS_IOCTL)
  /* For struct winsize on SCO */
  /*   sys/ptem.h has winsize but needs mblk_t from sys/stream.h */
! #  if defined (HAVE_SYS_PTEM_H) && defined (TIOCGWINSZ) && defined (SIGWINCH)
! #    if defined (HAVE_SYS_STREAM_H)
! #      include <sys/stream.h>
! #    endif
! #    include <sys/ptem.h>
! #  endif /* HAVE_SYS_PTEM_H && TIOCGWINSZ && SIGWINCH */
! #endif /* !STRUCT_WINSIZE_IN_SYS_IOCTL */
  
  #include "bashansi.h"
***************
*** 147,150 ****
--- 149,156 ----
  #define JOB_SLOTS 8
  
+ #if defined (READLINE)
+ extern void _rl_set_screen_size ();
+ #endif
+ 
  /* Variables used here but defined in other files. */
  extern int interactive, interactive_shell, asynchronous_notification;
***************
*** 578,583 ****
    register JOB *temp;
  
!   temp = jobs[job_index];
!   if (temp)
      temp->flags |= J_NOHUP;
  }
--- 584,588 ----
    register JOB *temp;
  
!   if (temp = jobs[job_index])
      temp->flags |= J_NOHUP;
  }
***************
*** 809,812 ****
--- 814,836 ----
  }
  
+ /* Find a job given a PID.  If BLOCK is non-zero, block SIGCHLD as
+    required by find_job. */
+ int
+ get_job_by_pid (pid, block)
+      pid_t pid;
+      int block;
+ {
+   int job;
+   sigset_t set, oset;
+ 
+   if (block)
+     BLOCK_CHILD (set, oset);
+   job = find_job (pid);
+   if (block)
+     UNBLOCK_CHILD (oset);
+ 
+   return job;
+ }
+ 
  /* Print descriptive information about the job with leader pid PID. */
  void
***************
*** 1347,1352 ****
  set_tty_state ()
  {
!   int tty = input_tty ();
  
    if (tty != -1)
      {
--- 1371,1377 ----
  set_tty_state ()
  {
!   int tty;
  
+   tty = input_tty ();
    if (tty != -1)
      {
***************
*** 1895,1898 ****
--- 1920,1946 ----
  }
  
+ /* Set up the job structures so we know the job and its processes are
+    all running. */
+ static void
+ set_job_running (job)
+      int job;
+ {
+   register PROCESS *p;
+ 
+   /* Each member of the pipeline is now running. */
+   p = jobs[job]->pipe;
+ 
+   do
+     {
+       if (WIFSTOPPED (p->status))
+ 	p->running = 1;
+       p = p->next;
+     }
+   while (p != jobs[job]->pipe);
+ 
+   /* This means that the job is running. */
+   JOBSTATE (job) = JRUNNING;
+ }
+ 
  /* Start a job.  FOREGROUND if non-zero says to do that.  Otherwise,
     start the job in the background.  JOB is a zero-based index into
***************
*** 1972,1990 ****
    /* Run the job. */
    if (already_running == 0)
!     {
!       /* Each member of the pipeline is now running. */
!       p = jobs[job]->pipe;
! 
!       do
! 	{
! 	  if (WIFSTOPPED (p->status))
! 	    p->running = 1;
! 	  p = p->next;
! 	}
!       while (p != jobs[job]->pipe);
! 
!       /* This means that the job is running. */
!       JOBSTATE (job) = JRUNNING;
!     }
  
    /* Save the tty settings before we start the job in the foreground. */
--- 2020,2024 ----
    /* Run the job. */
    if (already_running == 0)
!     set_job_running (job);
  
    /* Save the tty settings before we start the job in the foreground. */
***************
*** 2072,2075 ****
--- 2106,2117 ----
  	      if (p && STOPPED (job) && (sig == SIGTERM || sig == SIGHUP))
  		killpg (jobs[job]->pgrp, SIGCONT);
+ 	      /* If we're continuing a stopped job via kill rather than bg or
+ 		 fg, emulate the `bg' behavior. */
+ 	      if (p && STOPPED (job) && (sig == SIGCONT))
+ 		{
+ 		  set_job_running (job);
+ 		  jobs[job]->flags &= ~J_FOREGROUND;
+ 		  jobs[job]->flags |= J_NOTIFIED;
+ 		}
  	    }
  	}
***************
*** 2120,2126 ****
    do
      {
!       /* We don't want to be notified about jobs stopping if we're not
!          interactive. */
!       waitpid_flags = (interactive_shell && subshell_environment == 0)
  			? WUNTRACED
  			: 0;
--- 2162,2168 ----
    do
      {
!       /* We don't want to be notified about jobs stopping if job control
!          is not active.  XXX - was interactive_shell instead of job_control */
!       waitpid_flags = (job_control && subshell_environment == 0)
  			? WUNTRACED
  			: 0;
***************
*** 2157,2160 ****
--- 2199,2203 ----
  
        job = find_job (pid);
+   
        if (job == NO_JOB)
          continue;
***************
*** 2271,2279 ****
  		  /* wait_sigint_handler () has already seen SIGINT and
  		     allowed the wait builtin to jump out.  We need to
! 		     call the original SIGINT handler. */
  		  SigHandler *temp_handler;
  		  temp_handler = old_sigint_handler;
  		  restore_sigint_handler ();
! 		  if (temp_handler != SIG_IGN)
  		    (*temp_handler) (SIGINT);
  		}
--- 2314,2326 ----
  		  /* wait_sigint_handler () has already seen SIGINT and
  		     allowed the wait builtin to jump out.  We need to
! 		     call the original SIGINT handler, if necessary.  If
! 		     the original handler is SIG_DFL, we need to resend
! 		     the signal to ourselves. */
  		  SigHandler *temp_handler;
  		  temp_handler = old_sigint_handler;
  		  restore_sigint_handler ();
! 		  if (temp_handler == SIG_DFL)
! 		    termination_unwind_protect (SIGINT);
! 		  else if (temp_handler != SIG_IGN)
  		    (*temp_handler) (SIGINT);
  		}
***************
*** 2326,2330 ****
  	{
  	  interrupt_immediately = 1;
! 	  parse_and_execute (savestring (trap_command), "trap", -1);
  	}
  
--- 2373,2377 ----
  	{
  	  interrupt_immediately = 1;
! 	  parse_and_execute (savestring (trap_command), "trap", SEVAL_NOHIST);
  	}
  
***************
*** 2382,2386 ****
  	  /* Print info on jobs that are running in the background,
  	     and on foreground jobs that were killed by anything
! 	     except SIGINT. */
  	  switch (JOBSTATE (job))
  	    {
--- 2429,2433 ----
  	  /* Print info on jobs that are running in the background,
  	     and on foreground jobs that were killed by anything
! 	     except SIGINT (and possibly SIGPIPE). */
  	  switch (JOBSTATE (job))
  	    {
***************
*** 2394,2398 ****
--- 2441,2449 ----
  	      else if (IS_FOREGROUND (job))
  		{
+ #if !defined (DONT_REPORT_SIGPIPE)
  		  if (termsig && WIFSIGNALED (s) && termsig != SIGINT)
+ #else
+ 		  if (termsig && WIFSIGNALED (s) && termsig != SIGINT && termsig != SIGPIPE)
+ #endif
  		    {
  		      fprintf (stderr, "%s", strsignal (termsig));
***************
*** 2442,2446 ****
  /* Initialize the job control mechanism, and set up the tty stuff. */
  int
! initialize_jobs ()
  {
    shell_pgrp = getpgid (0);
--- 2493,2498 ----
  /* Initialize the job control mechanism, and set up the tty stuff. */
  int
! initialize_job_control (force)
!      int force;
  {
    shell_pgrp = getpgid (0);
***************
*** 2448,2452 ****
    if (shell_pgrp == -1)
      {
!       sys_error ("initialize_jobs: getpgrp failed");
        exit (1);
      }
--- 2500,2504 ----
    if (shell_pgrp == -1)
      {
!       sys_error ("initialize_job_control: getpgrp failed");
        exit (1);
      }
***************
*** 2457,2460 ****
--- 2509,2513 ----
        job_control = 0;
        original_pgrp = NO_PID;
+       shell_tty = fileno (stderr);
      }
    else
***************
*** 2465,2469 ****
        shell_tty = dup (fileno (stderr));	/* fd 2 */
  
!       shell_tty = move_to_high_fd (shell_tty, 1);
  
        /* Compensate for a bug in systems that compiled the BSD
--- 2518,2522 ----
        shell_tty = dup (fileno (stderr));	/* fd 2 */
  
!       shell_tty = move_to_high_fd (shell_tty, 1, -1);
  
        /* Compensate for a bug in systems that compiled the BSD
***************
*** 2493,2497 ****
        if (set_new_line_discipline (shell_tty) < 0)
  	{
! 	  sys_error ("initialize_jobs: line discipline");
  	  job_control = 0;
  	}
--- 2546,2550 ----
        if (set_new_line_discipline (shell_tty) < 0)
  	{
! 	  sys_error ("initialize_job_control: line discipline");
  	  job_control = 0;
  	}
***************
*** 2503,2507 ****
  	  if ((original_pgrp != shell_pgrp) && (setpgid (0, shell_pgrp) < 0))
  	    {
! 	      sys_error ("initialize_jobs: setpgid");
  	      shell_pgrp = original_pgrp;
  	    }
--- 2556,2560 ----
  	  if ((original_pgrp != shell_pgrp) && (setpgid (0, shell_pgrp) < 0))
  	    {
! 	      sys_error ("initialize_job_control: setpgid");
  	      shell_pgrp = original_pgrp;
  	    }
***************
*** 2634,2637 ****
--- 2687,2691 ----
  #endif /* MUST_REINSTALL_SIGHANDLERS */
    get_new_window_size (1);
+   SIGRETURN (0);
  }
  #else
***************
*** 2751,2755 ****
     when they start executing (forking subshells for parenthesized execution
     and functions with pipes are the two that spring to mind). */
! static void
  delete_all_jobs ()
  {
--- 2805,2809 ----
     when they start executing (forking subshells for parenthesized execution
     and functions with pipes are the two that spring to mind). */
! void
  delete_all_jobs ()
  {
***************
*** 2774,2777 ****
--- 2828,2851 ----
  }
  
+ /* Mark all jobs in the job array so that they don't get a SIGHUP when the
+    shell gets one. */
+ void
+ nohup_all_jobs ()
+ {
+   register int i;
+   sigset_t set, oset;
+ 
+   BLOCK_CHILD (set, oset);
+ 
+   if (job_slots)
+     {
+       for (i = 0; i < job_slots; i++)
+ 	if (jobs[i])
+ 	  nohup_job (i);
+     }
+ 
+   UNBLOCK_CHILD (oset);
+ }
+ 
  /* Mark all dead jobs as notified, so delete_job () cleans them out
     of the job table properly. */
***************
*** 2851,2855 ****
    if (shell_tty != -1)
      close (shell_tty);
!   initialize_jobs ();
  }
  
--- 2925,2929 ----
    if (shell_tty != -1)
      close (shell_tty);
!   initialize_job_control (0);
  }
  
diff -Nrc2 bash-2.0/jobs.h bash-2.01/jobs.h
*** bash-2.0/jobs.h	Tue Apr 23 12:28:55 1996
--- bash-2.01/jobs.h	Thu May  8 14:55:27 1997
***************
*** 27,30 ****
--- 27,32 ----
  #include "stdc.h"
  
+ #include "posixwait.h"
+ 
  /* Defines controlling the fashion in which jobs are listed. */
  #define JLIST_STANDARD       0
***************
*** 34,116 ****
  #define JLIST_NONINTERACTIVE 4
  
- /* If _POSIX_VERSION is not defined, we assume that <sys/wait.h> defines
-    a `union wait' and various macros used to manipulate it.  Look in
-    bashwait.h for the things we expect to find. */
- #if defined (HAVE_SYS_WAIT_H)
- #  include <sys/wait.h>
- #else /* !HAVE_SYS_WAIT_H */
- #  if !defined (_POSIX_VERSION)
- #    include "bashwait.h"
- #  endif
- #endif  /* !HAVE_SYS_WAIT_H */
- 
- /* How to get the status of a job.  For Posix, this is just an
-    int, but for other systems we have to crack the union wait. */
- #if !defined (_POSIX_VERSION)
- typedef union wait WAIT;
- #  define WSTATUS(t)  (t.w_status)
- #else /* _POSIX_VERSION */
- typedef int WAIT;
- #  define WSTATUS(t)  (t)
- #endif /* _POSIX_VERSION */
- 
- /* Make sure that parameters to wait3 are defined. */
- #if !defined (WNOHANG)
- #  define WNOHANG 1
- #  define WUNTRACED 2
- #endif /* WNOHANG */
- 
- /* More Posix P1003.1 definitions.  In the POSIX versions, the parameter is
-    passed as an `int', in the non-POSIX version, as `union wait'. */
- #if defined (_POSIX_VERSION)
- 
- #  if !defined (WSTOPSIG)
- #    define WSTOPSIG(s)       ((s) >> 8)
- #  endif /* !WSTOPSIG */
- 
- #  if !defined (WTERMSIG)
- #    define WTERMSIG(s)	      ((s) & 0177)
- #  endif /* !WTERMSIG */
- 
- #  if !defined (WEXITSTATUS)
- #    define WEXITSTATUS(s)    ((s) >> 8)
- #  endif /* !WEXITSTATUS */
- 
- #  if !defined (WIFSTOPPED)
- #    define WIFSTOPPED(s)     (((s) & 0177) == 0177)
- #  endif /* !WIFSTOPPED */
- 
- #  if !defined (WIFEXITED)
- #    define WIFEXITED(s)      (((s) & 0377) == 0)
- #  endif /* !WIFEXITED */
- 
- #  if !defined (WIFSIGNALED)
- #    define WIFSIGNALED(s)    (!WIFSTOPPED(s) && !WIFEXITED(s))
- #  endif /* !WIFSIGNALED */
- 
- #  if !defined (WIFCORED)
- #    define WIFCORED(s)       ((s) & 0200)
- #  endif /* !WIFCORED */
- 
- #else /* !_POSIX_VERSION */
- 
- #  if !defined (WSTOPSIG)
- #    define WSTOPSIG(s)	      ((s).w_stopsig)
- #  endif /* !WSTOPSIG */
- 
- #  if !defined (WTERMSIG)
- #    define WTERMSIG(s)	      ((s).w_termsig)
- #  endif /* !WTERMSIG */
- 
- #  if !defined (WEXITSTATUS)
- #    define WEXITSTATUS(s)    ((s).w_retcode)
- #  endif /* !WEXITSTATUS */
- 
- #  if !defined (WIFCORED)
- #    define WIFCORED(s)       ((s).w_coredump)
- #  endif /* !WIFCORED */
- 
- #endif /* !_POSIX_VERSION */
- 
  /* I looked it up.  For pretty_print_job ().  The real answer is 24. */
  #define LONGEST_SIGNAL_DESC 24
--- 36,39 ----
***************
*** 187,192 ****
--- 110,118 ----
  extern void start_pipeline __P((void));
  extern int stop_pipeline __P((int, COMMAND *));
+ 
  extern void delete_job __P((int));
  extern void nohup_job __P((int));
+ extern void delete_all_jobs __P((void));
+ extern void nohup_all_jobs __P((void));
  
  extern void terminate_current_pipeline __P((void));
***************
*** 196,201 ****
--- 122,129 ----
  
  #if defined (__STDC__) && defined (pid_t)
+ extern int get_job_by_pid __P((int, int));
  extern void describe_pid __P((int));
  #else
+ extern int get_job_by_pid __P((pid_t, int));
  extern void describe_pid __P((pid_t));
  #endif
***************
*** 219,223 ****
  extern int start_job __P((int, int));
  extern int kill_pid __P((pid_t, int, int));
! extern int initialize_jobs __P((void));
  extern void initialize_job_signals __P((void));
  extern int give_terminal_to __P((pid_t));
--- 147,151 ----
  extern int start_job __P((int, int));
  extern int kill_pid __P((pid_t, int, int));
! extern int initialize_job_control __P((int));
  extern void initialize_job_signals __P((void));
  extern int give_terminal_to __P((pid_t));
diff -Nrc2 bash-2.0/lib/glob/Makefile.in bash-2.01/lib/glob/Makefile.in
*** bash-2.0/lib/glob/Makefile.in	Fri Oct  4 11:02:34 1996
--- bash-2.01/lib/glob/Makefile.in	Tue Feb 18 11:11:59 1997
***************
*** 27,34 ****
  
  DEFS = @DEFS@
  
  INCLUDES = -I. -I../.. -I$(topdir) -I$(topdir)/lib
  
! CCFLAGS = $(DEFS) $(CPPFLAGS) ${INCLUDES} $(LOCAL_CFLAGS) $(CFLAGS)
  
  # Here is a rule for making .o files from .c files that doesn't force
--- 27,35 ----
  
  DEFS = @DEFS@
+ LOCAL_DEFS = @LOCAL_DEFS@
  
  INCLUDES = -I. -I../.. -I$(topdir) -I$(topdir)/lib
  
! CCFLAGS = $(DEFS) $(LOCAL_DEFS) $(CPPFLAGS) ${INCLUDES} $(LOCAL_CFLAGS) $(CFLAGS)
  
  # Here is a rule for making .o files from .c files that doesn't force
***************
*** 100,105 ****
  ######################################################################
  
! fnmatch.o: fnmatch.c fnmatch.h
! 
  fnmatch.o: $(BUILD_DIR)/config.h
  glob.o: $(BUILD_DIR)/config.h
--- 101,109 ----
  ######################################################################
  
! fnmatch.o: fnmatch.h
  fnmatch.o: $(BUILD_DIR)/config.h
+ 
  glob.o: $(BUILD_DIR)/config.h
+ glob.o: $(topdir)/bashtypes.h $(topdir)/ansi_stdlib.h $(topdir)/bashansi.h
+ glob.o: $(topdir)/posixstat.h $(topdir)/memalloc.h
+ glob.o: fnmatch.h
diff -Nrc2 bash-2.0/lib/glob/fnmatch.c bash-2.01/lib/glob/fnmatch.c
*** bash-2.0/lib/glob/fnmatch.c	Wed Jun 19 16:24:43 1996
--- bash-2.01/lib/glob/fnmatch.c	Thu Mar 27 08:49:03 1997
***************
*** 51,57 ****
--- 51,61 ----
  	    return (FNM_NOMATCH);
  	  else if ((flags & FNM_PATHNAME) && *n == '/')
+ 	    /* If we are matching a pathname, `?' can never match a `/'. */
  	    return (FNM_NOMATCH);
  	  else if ((flags & FNM_PERIOD) && *n == '.' &&
  		   (n == string || ((flags & FNM_PATHNAME) && n[-1] == '/')))
+ 	    /* `?' cannot match a `.' if it is the first character of the
+ 	       string or if it is the first character following a slash and
+ 	       we are matching a pathname. */
  	    return (FNM_NOMATCH);
  	  break;
***************
*** 59,63 ****
  	case '\\':
  	  if (!(flags & FNM_NOESCAPE))
! 	    c = *p++;
  	  if (*n != c)
  	    return (FNM_NOMATCH);
--- 63,71 ----
  	case '\\':
  	  if (!(flags & FNM_NOESCAPE))
! 	    {
! 	      c = *p++;
! 	      if (c == '\0')
! 		return (FNM_NOMATCH);
! 	    }
  	  if (*n != c)
  	    return (FNM_NOMATCH);
***************
*** 67,79 ****
  	  if ((flags & FNM_PERIOD) && *n == '.' &&
  	      (n == string || ((flags & FNM_PATHNAME) && n[-1] == '/')))
  	    return (FNM_NOMATCH);
  
  	  for (c = *p++; c == '?' || c == '*'; c = *p++)
  	    {
! 	      if (((flags & FNM_PATHNAME) && *n == '/') ||
! 		  (c == '?' && *n == '\0'))
  		return (FNM_NOMATCH);
! 	      if (c == '?')
! 		n++;
  	    }
  
--- 75,99 ----
  	  if ((flags & FNM_PERIOD) && *n == '.' &&
  	      (n == string || ((flags & FNM_PATHNAME) && n[-1] == '/')))
+ 	    /* `*' cannot match a `.' if it is the first character of the
+ 	       string or if it is the first character following a slash and
+ 	       we are matching a pathname. */
  	    return (FNM_NOMATCH);
  
+ 	  /* Collapse multiple consecutive, `*' and `?', but make sure that
+ 	     one character of the string is consumed for each `?'. */
  	  for (c = *p++; c == '?' || c == '*'; c = *p++)
  	    {
! 	      if ((flags & FNM_PATHNAME) && *n == '/')
! 		/* A slash does not match a wildcard under FNM_PATHNAME. */
  		return (FNM_NOMATCH);
! 	      else if (c == '?')
! 		{
! 		  if (*n == '\0')
! 		    return (FNM_NOMATCH);
! 		  /* One character of the string is consumed in matching
! 		     this ? wildcard, so *??? won't match if there are
! 		     fewer than three characters. */
! 		  n++;
! 		}
  	    }
  
***************
*** 81,87 ****
--- 101,110 ----
  	    return (0);
  
+ 	  /* General case, use recursion. */
  	  {
  	    char c1 = (!(flags & FNM_NOESCAPE) && c == '\\') ? *p : c;
  	    for (--p; *n != '\0'; ++n)
+ 	      /* Only call fnmatch if the first character indicates a
+ 		 possible match. */
  	      if ((c == '[' || *n == c1) &&
  		  fnmatch (p, n, flags & ~FNM_PERIOD) == 0)
***************
*** 98,111 ****
  	      return (FNM_NOMATCH);
  
  	    if ((flags & FNM_PERIOD) && *n == '.' &&
  		(n == string || ((flags & FNM_PATHNAME) && n[-1] == '/')))
  	      return (FNM_NOMATCH);
  
! 	    /* Make sure there is a closing `]'.  If there isn't, the `['
! 	       is just a character to be matched. */
  	    {
  	      register char *np;
  
! 	      for (np = p; np && *np && *np != ']'; np++);
  
  	      if (np && !*np)
--- 121,142 ----
  	      return (FNM_NOMATCH);
  
+ 	    /* A character class cannot match a `.' if it is the first
+ 	       character of the string or if it is the first character
+ 	       following a slash and we are matching a pathname. */
  	    if ((flags & FNM_PERIOD) && *n == '.' &&
  		(n == string || ((flags & FNM_PATHNAME) && n[-1] == '/')))
  	      return (FNM_NOMATCH);
  
! 	    /* POSIX.2 2.8.3.1.2 says: `An expression containing a `[' that
! 	       is not preceded by a backslash and is not part of a bracket
! 	       expression produces undefined results.'  This implementation
! 	       treats the `[' as just a character to be matched if there is
! 	       not a closing `]'.  This code will have to be changed when
! 	       POSIX.2 character classes are implemented. */
  	    {
  	      register char *np;
  
! 	      for (np = p; np && *np && *np != ']'; np++)
! 		;
  
  	      if (np && !*np)
***************
*** 113,117 ****
  		  if (*n != '[')
  		    return (FNM_NOMATCH);
! 		  goto next_char;
  		}
  	    }
--- 144,148 ----
  		  if (*n != '[')
  		    return (FNM_NOMATCH);
! 		  break;
  		}
  	    }
***************
*** 124,131 ****
  	    for (;;)
  	      {
! 		register char cstart = c, cend = c;
  
  		if (!(flags & FNM_NOESCAPE) && c == '\\')
! 		  cstart = cend = *p++;
  
  		if (c == '\0')
--- 155,170 ----
  	    for (;;)
  	      {
! 		register char cstart, cend;
! 
! 		/* Initialize cstart and cend in case `-' is the last
! 		   character of the pattern. */
! 		cstart = cend = c;
  
  		if (!(flags & FNM_NOESCAPE) && c == '\\')
! 		  {
! 		    if (*p == '\0')
! 		      return FNM_NOMATCH;
! 		    cstart = cend = *p++;
! 		  }
  
  		if (c == '\0')
***************
*** 139,142 ****
--- 178,184 ----
  		  return (FNM_NOMATCH);
  
+ 		/* This introduces a range, unless the `-' is the last
+ 		   character of the class.  Find the end of the range
+ 		   and move past it. */
  		if (c == '-' && *p != ']')
  		  {
***************
*** 146,149 ****
--- 188,192 ----
  		    if (cend == '\0')
  		      return (FNM_NOMATCH);
+ 
  		    c = *p++;
  		  }
***************
*** 157,162 ****
  	    if (!not)
  	      return (FNM_NOMATCH);
- 
- 	  next_char:
  	    break;
  
--- 200,203 ----
***************
*** 171,176 ****
  		c = *p++;
  		if (!(flags & FNM_NOESCAPE) && c == '\\')
! 		  /* 1003.2d11 is unclear if this is right.  %%% */
! 		  ++p;
  	      }
  	    if (not)
--- 212,221 ----
  		c = *p++;
  		if (!(flags & FNM_NOESCAPE) && c == '\\')
! 		  {
! 		    if (*p == '\0')
! 		      return FNM_NOMATCH;
! 		    /* XXX 1003.2d11 is unclear if this is right. */
! 		    ++p;
! 		  }
  	      }
  	    if (not)
diff -Nrc2 bash-2.0/lib/glob/glob.c bash-2.01/lib/glob/glob.c
*** bash-2.0/lib/glob/glob.c	Thu Jul 11 14:09:52 1996
--- bash-2.01/lib/glob/glob.c	Thu Feb 13 11:58:09 1997
***************
*** 104,107 ****
--- 104,109 ----
  
  #if defined (SHELL)
+ extern void throw_to_top_level ();
+ 
  extern int interrupt_state;
  #endif /* SHELL */
***************
*** 266,270 ****
  
        /* If a dot must be explicity matched, check to see if they do. */
!       if (noglob_dot_filenames && dp->d_name[0] == '.' && pat[0] != '.')
  	continue;
  
--- 268,273 ----
  
        /* If a dot must be explicity matched, check to see if they do. */
!       if (noglob_dot_filenames && dp->d_name[0] == '.' && pat[0] != '.' &&
! 	    (pat[0] != '\\' || pat[1] != '.'))
  	continue;
  
***************
*** 296,300 ****
--- 299,305 ----
  
    /* Have we run out of memory?	 */
+ #if defined (SHELL)
   lost:
+ #endif
    if (lose)
      {
diff -Nrc2 bash-2.0/lib/malloc/Makefile.in bash-2.01/lib/malloc/Makefile.in
*** bash-2.0/lib/malloc/Makefile.in	Fri Oct  4 09:55:24 1996
--- bash-2.01/lib/malloc/Makefile.in	Tue May 13 14:07:54 1997
***************
*** 18,21 ****
--- 18,23 ----
  MV = mv
  
+ PROFILE_FLAGS = 
+ 
  CFLAGS = @CFLAGS@
  LOCAL_CFLAGS = @LOCAL_CFLAGS@
***************
*** 24,31 ****
  
  DEFS = @DEFS@
  
  INCLUDES = -I. -I../.. -I$(topdir) -I$(topdir)/lib
  
! CCFLAGS = ${INCLUDES} $(DEFS) $(LOCAL_CFLAGS) $(CFLAGS) $(MALLOC_CFLAGS) $(CPPFLAGS)
  
  .c.o:
--- 26,35 ----
  
  DEFS = @DEFS@
+ LOCAL_DEFS = @LOCAL_DEFS@
  
  INCLUDES = -I. -I../.. -I$(topdir) -I$(topdir)/lib
  
! CCFLAGS = ${PROFILE_FLAGS} ${INCLUDES} $(DEFS) $(LOCAL_DEFS) $(LOCAL_CFLAGS) \
! 	  $(CFLAGS) $(MALLOC_CFLAGS) $(CPPFLAGS)
  
  .c.o:
***************
*** 36,39 ****
--- 40,46 ----
  
  MALLOC_SOURCE = malloc.c
+ GMALLOC_SOURCE = gmalloc.c
+ NMALLOC_SOURCE = nmalloc.c
+ STUB_SOURCE = stub.c
  
  ALLOCA_SOURCE = alloca.c
***************
*** 44,53 ****
  ALLOCA = @ALLOCA@
  
! libmalloc.a:	$(MALLOC) $(ALLOCA) stub.o
! 	$(RM) $@
! 	$(AR) cr $@ $(MALLOC) $(ALLOCA) stub.o
! 	-test -n "$(RANLIB)" && $(RANLIB) $@
! 
! malloc.o: malloc.c getpagesize.h
  
  alloca.o:	$(ALLOCA_SOURCE)
--- 51,94 ----
  ALLOCA = @ALLOCA@
  
! MALLOC_OBJS = malloc.o $(ALLOCA) stub.o
! GMALLOC_OBJS = gmalloc.o $(ALLOCA) stub.o
! NMALLOC_OBJS = nmalloc.o $(ALLOCA) stub.o
! NMALLOC2_OBJS = nmalloc2.o $(ALLOCA) stub.o
! NGMALLOC_OBJS = ngmalloc.o $(ALLOCA) stub.o
! STUB_OBJS = $(ALLOCA) stub.o
! 
! .PHONY:		malloc gmalloc stubmalloc nmalloc ngmalloc nmalloc2
! 
! all:		malloc
! 
! malloc: ${MALLOC_OBJS}
! 	${RM} libmalloc.a
! 	${AR} cr libmalloc.a ${MALLOC_OBJS}
! 	-test -n "$(RANLIB)" && $(RANLIB) libmalloc.a
! 
! nmalloc: ${NMALLOC_OBJS}
! 	${RM} libmalloc.a
! 	${AR} cr libmalloc.a ${NMALLOC_OBJS}
! 	-test -n "$(RANLIB)" && $(RANLIB) libmalloc.a
! 
! nmalloc2: ${NMALLOC2_OBJS}
! 	${RM} libmalloc.a
! 	${AR} cr libmalloc.a ${NMALLOC2_OBJS}
! 	-test -n "$(RANLIB)" && $(RANLIB) libmalloc.a
! 
! gmalloc: ${GMALLOC_OBJS}
! 	${RM} libmalloc.a
! 	${AR} cr libmalloc.a ${GMALLOC_OBJS}
! 	-test -n "$(RANLIB)" && $(RANLIB) libmalloc.a
! 
! ngmalloc: ${NGMALLOC_OBJS}
! 	${RM} libmalloc.a
! 	${AR} cr libmalloc.a ${NGMALLOC_OBJS}
! 	-test -n "$(RANLIB)" && $(RANLIB) libmalloc.a
! 
! stubmalloc: ${STUB_OBJS}
! 	${RM} libmalloc.a
! 	${AR} cr libmalloc.a ${STUB_OBJS}
! 	-test -n "$(RANLIB)" && $(RANLIB) libmalloc.a
  
  alloca.o:	$(ALLOCA_SOURCE)
***************
*** 63,68 ****
  	$(RM) Makefile
  
  alloca.o: $(BUILD_DIR)/config.h
! malloc.o: $(BUILD_DIR)/config.h
! xmalloc.o: $(BUILD_DIR)/config.h
  gmalloc.o: $(BUILD_DIR)/config.h
--- 104,114 ----
  	$(RM) Makefile
  
+ malloc.o: malloc.c
+ gmalloc.o: gmalloc.c
+ 
  alloca.o: $(BUILD_DIR)/config.h
! malloc.o: $(BUILD_DIR)/config.h $(topdir)/bashtypes.h getpagesize.h
! nmalloc.o: $(BUILD_DIR)/config.h $(topdir)/bashtypes.h getpagesize.h
! nmalloc2.o: $(BUILD_DIR)/config.h $(topdir)/bashtypes.h getpagesize.h
! xmalloc.o: $(BUILD_DIR)/config.h $(topdir)/ansi_stdlib.h
  gmalloc.o: $(BUILD_DIR)/config.h
diff -Nrc2 bash-2.0/lib/malloc/getpagesize.h bash-2.01/lib/malloc/getpagesize.h
*** bash-2.0/lib/malloc/getpagesize.h	Wed Sep 30 12:04:05 1992
--- bash-2.01/lib/malloc/getpagesize.h	Thu Apr 17 10:52:22 1997
***************
*** 20,23 ****
--- 20,27 ----
  #  if defined (_SC_PAGESIZE)
  #    define getpagesize() sysconf(_SC_PAGESIZE)
+ #  else
+ #    if defined (_SC_PAGE_SIZE)
+ #      define getpagesize() sysconf(_SC_PAGE_SIZE)
+ #    endif /* _SC_PAGE_SIZE */
  #  endif /* _SC_PAGESIZE */
  #endif
diff -Nrc2 bash-2.0/lib/malloc/malloc.c bash-2.01/lib/malloc/malloc.c
*** bash-2.0/lib/malloc/malloc.c	Wed Dec 11 13:17:17 1996
--- bash-2.01/lib/malloc/malloc.c	Fri Apr 25 11:47:20 1997
***************
*** 75,79 ****
  
  /* Determine which kind of system this is.  */
! #include <sys/types.h>
  #include <signal.h>
  
--- 75,83 ----
  
  /* Determine which kind of system this is.  */
! #if defined (SHELL)
! #  include "bashtypes.h"
! #else
! #  include <sys/types.h>
! #endif
  #include <signal.h>
  
***************
*** 94,97 ****
--- 98,115 ----
  #endif
  
+ #if __GNUC__ > 1
+ #  define FASTCOPY(s, d, n)  __builtin_memcpy (d, s, n)
+ #else /* !__GNUC__ */
+ #  if !defined (HAVE_BCOPY)
+ #    if !defined (HAVE_MEMMOVE)
+ #      define FASTCOPY(s, d, n)  memcpy (d, s, n)
+ #    else
+ #      define FASTCOPY(s, d, n)  memmove (d, s, n)
+ #    endif /* !HAVE_MEMMOVE */
+ #  else /* HAVE_BCOPY */
+ #    define FASTCOPY(s, d, n)  bcopy (s, d, n)
+ #  endif /* HAVE_BCOPY */
+ #endif /* !__GNUC__ */
+ 
  #if !defined (NULL)
  #  define NULL 0
***************
*** 139,146 ****
  /* Remainder are valid only when block is allocated */
  	unsigned short mh_size;	/* size, if < 0x10000 */
! #ifdef rcheck
  	unsigned int mh_nbytes;	/* number of bytes allocated */
  	int      mh_magic4;	/* should be == MAGIC4 */
! #endif /* rcheck */
  };
  
--- 157,164 ----
  /* Remainder are valid only when block is allocated */
  	unsigned short mh_size;	/* size, if < 0x10000 */
! #ifdef RCHECK
  	unsigned int mh_nbytes;	/* number of bytes allocated */
  	int      mh_magic4;	/* should be == MAGIC4 */
! #endif /* RCHECK */
  };
  
***************
*** 155,162 ****
    (*(struct mhead **) (sizeof (char *) + (char *) (a)))
  
! #ifdef rcheck
  #  include <stdio.h>
  #  if !defined (botch)
  #    define botch(x) abort ()
  #  endif /* botch */
  
--- 173,182 ----
    (*(struct mhead **) (sizeof (char *) + (char *) (a)))
  
! #ifdef RCHECK
  #  include <stdio.h>
  #  if !defined (botch)
  #    define botch(x) abort ()
+ #  else
+ extern void botch();
  #  endif /* botch */
  
***************
*** 179,186 ****
  #  define ASSERT(p) if (!(p)) botch(__STRING(p)); else
  #  define EXTRA  4		/* 4 bytes extra for MAGIC1s */
! #else /* !rcheck */
  #  define ASSERT(p)
  #  define EXTRA  0
! #endif /* rcheck */
  
  /* nextf[i] is free list of blocks of size 2**(i + 3)  */
--- 199,206 ----
  #  define ASSERT(p) if (!(p)) botch(__STRING(p)); else
  #  define EXTRA  4		/* 4 bytes extra for MAGIC1s */
! #else /* !RCHECK */
  #  define ASSERT(p)
  #  define EXTRA  0
! #endif /* RCHECK */
  
  /* nextf[i] is free list of blocks of size 2**(i + 3)  */
***************
*** 442,454 ****
    /* and bomb out on the NEXT allocate of this size block */
    if (p -> mh_alloc != ISFREE || p -> mh_index != nunits)
! #ifdef rcheck
      botch ("block on free list clobbered");
! #else /* not rcheck */
      abort ();
! #endif /* not rcheck */
  
    /* Fill in the info, and if range checking, set up the magic numbers */
    p -> mh_alloc = ISALLOC;
! #ifdef rcheck
    p -> mh_nbytes = n;
    p -> mh_magic4 = MAGIC4;
--- 462,474 ----
    /* and bomb out on the NEXT allocate of this size block */
    if (p -> mh_alloc != ISFREE || p -> mh_index != nunits)
! #ifdef RCHECK
      botch ("block on free list clobbered");
! #else /* not RCHECK */
      abort ();
! #endif /* not RCHECK */
  
    /* Fill in the info, and if range checking, set up the magic numbers */
    p -> mh_alloc = ISALLOC;
! #ifdef RCHECK
    p -> mh_nbytes = n;
    p -> mh_magic4 = MAGIC4;
***************
*** 458,464 ****
      *m++ = MAGIC1, *m++ = MAGIC1, *m++ = MAGIC1, *m = MAGIC1;
    }
! #else /* not rcheck */
    p -> mh_size = n;
! #endif /* not rcheck */
  #ifdef MEMSCRAMBLE
    zmemset ((char *)(p + 1), 0xdf, n);	/* scramble previous contents */
--- 478,484 ----
      *m++ = MAGIC1, *m++ = MAGIC1, *m++ = MAGIC1, *m = MAGIC1;
    }
! #else /* not RCHECK */
    p -> mh_size = n;
! #endif /* not RCHECK */
  #ifdef MEMSCRAMBLE
    zmemset ((char *)(p + 1), 0xdf, n);	/* scramble previous contents */
***************
*** 486,500 ****
      if (p -> mh_alloc == ISMEMALIGN)
        {
! #ifdef rcheck
  	ap -= p->mh_nbytes;
  #endif
  	p = (struct mhead *) ap - 1;
        }
  
! #ifndef rcheck
      if (p -> mh_alloc != ISALLOC)
        abort ();
  
! #else /* rcheck */
      if (p -> mh_alloc != ISALLOC)
        {
--- 506,522 ----
      if (p -> mh_alloc == ISMEMALIGN)
        {
! #ifdef RCHECK
  	ap -= p->mh_nbytes;
+ #else
+ 	ap -= p->mh_size;	/* XXX */
  #endif
  	p = (struct mhead *) ap - 1;
        }
  
! #ifndef RCHECK
      if (p -> mh_alloc != ISALLOC)
        abort ();
  
! #else /* RCHECK */
      if (p -> mh_alloc != ISALLOC)
        {
***************
*** 509,513 ****
      ASSERT (*ap++ == MAGIC1); ASSERT (*ap++ == MAGIC1);
      ASSERT (*ap++ == MAGIC1); ASSERT (*ap   == MAGIC1);
! #endif /* rcheck */
    }
  #ifdef MEMSCRAMBLE
--- 531,535 ----
      ASSERT (*ap++ == MAGIC1); ASSERT (*ap++ == MAGIC1);
      ASSERT (*ap++ == MAGIC1); ASSERT (*ap   == MAGIC1);
! #endif /* RCHECK */
    }
  #ifdef MEMSCRAMBLE
***************
*** 515,523 ****
      register int n;
      
! #ifdef rcheck
      n = p->mh_nbytes;
! #else /* not rcheck */
      n = p->mh_size;
! #endif /* not rcheck */
      zmemset (mem, 0xcf, n);
    }
--- 537,545 ----
      register int n;
      
! #ifdef RCHECK
      n = p->mh_nbytes;
! #else /* not RCHECK */
      n = p->mh_size;
! #endif /* not RCHECK */
      zmemset (mem, 0xcf, n);
    }
***************
*** 558,562 ****
    nunits = p -> mh_index;
    ASSERT (p -> mh_alloc == ISALLOC);
! #ifdef rcheck
    ASSERT (p -> mh_magic4 == MAGIC4);
    {
--- 580,584 ----
    nunits = p -> mh_index;
    ASSERT (p -> mh_alloc == ISALLOC);
! #ifdef RCHECK
    ASSERT (p -> mh_magic4 == MAGIC4);
    {
***************
*** 565,574 ****
      ASSERT (*m++ == MAGIC1); ASSERT (*m   == MAGIC1);
    }
! #else /* not rcheck */
    if (p -> mh_index >= 13)
      tocopy = (1 << (p -> mh_index + 3)) - sizeof *p;
    else
      tocopy = p -> mh_size;
! #endif /* not rcheck */
  
    /* See if desired size rounds to same power of 2 as actual size. */
--- 587,596 ----
      ASSERT (*m++ == MAGIC1); ASSERT (*m   == MAGIC1);
    }
! #else /* not RCHECK */
    if (p -> mh_index >= 13)
      tocopy = (1 << (p -> mh_index + 3)) - sizeof *p;
    else
      tocopy = p -> mh_size;
! #endif /* not RCHECK */
  
    /* See if desired size rounds to same power of 2 as actual size. */
***************
*** 578,582 ****
    if (nbytes > (4 << nunits) && nbytes <= (8 << nunits))
      {
! #ifdef rcheck
        register char *m = mem + tocopy;
        *m++ = 0;  *m++ = 0;  *m++ = 0;  *m++ = 0;
--- 600,604 ----
    if (nbytes > (4 << nunits) && nbytes <= (8 << nunits))
      {
! #ifdef RCHECK
        register char *m = mem + tocopy;
        *m++ = 0;  *m++ = 0;  *m++ = 0;  *m++ = 0;
***************
*** 584,590 ****
        m = mem + n;
        *m++ = MAGIC1;  *m++ = MAGIC1;  *m++ = MAGIC1;  *m++ = MAGIC1;
! #else /* not rcheck */
        p -> mh_size = n;
! #endif /* not rcheck */
        return mem;
      }
--- 606,612 ----
        m = mem + n;
        *m++ = MAGIC1;  *m++ = MAGIC1;  *m++ = MAGIC1;  *m++ = MAGIC1;
! #else /* not RCHECK */
        p -> mh_size = n;
! #endif /* not RCHECK */
        return mem;
      }
***************
*** 597,601 ****
      if ((new = malloc (n)) == 0)
        return 0;
!     bcopy (mem, new, tocopy);
      free (mem);
      return new;
--- 619,623 ----
      if ((new = malloc (n)) == 0)
        return 0;
!     FASTCOPY (mem, new, tocopy);
      free (mem);
      return new;
diff -Nrc2 bash-2.0/lib/posixheaders/memalloc.h bash-2.01/lib/posixheaders/memalloc.h
*** bash-2.0/lib/posixheaders/memalloc.h	Fri Jul 12 13:26:44 1996
--- bash-2.01/lib/posixheaders/memalloc.h	Tue Jan 14 16:13:50 1997
***************
*** 46,50 ****
  #    endif /* !IBMESA */
  #  else  /* !HAVE_ALLOCA_H */
! #    if defined (hpux_9) && defined (__STDC__) && !defined (alloca)
  extern void *alloca ();
  #    else
--- 46,50 ----
  #    endif /* !IBMESA */
  #  else  /* !HAVE_ALLOCA_H */
! #    if defined (__hpux) && defined (__STDC__) && !defined (alloca)
  extern void *alloca ();
  #    else
***************
*** 52,56 ****
  extern char *alloca ();
  #      endif /* !alloca */
! #    endif /* !hpux_9 || !__STDC__ && !alloca */
  #  endif /* !HAVE_ALLOCA_H */
  #endif /* !__GNUC__ */
--- 52,56 ----
  extern char *alloca ();
  #      endif /* !alloca */
! #    endif /* !__hpux || !__STDC__ && !alloca */
  #  endif /* !HAVE_ALLOCA_H */
  #endif /* !__GNUC__ */
diff -Nrc2 bash-2.0/lib/posixheaders/posixdir.h bash-2.01/lib/posixheaders/posixdir.h
*** bash-2.0/lib/posixheaders/posixdir.h	Fri Aug 25 16:35:48 1995
--- bash-2.01/lib/posixheaders/posixdir.h	Thu Jan  2 14:10:32 1997
***************
*** 43,47 ****
  #endif /* !HAVE_DIRENT_H */
  
! #if defined (STRUCT_DIRENT_HAS_D_INO)
  #  define d_fileno d_ino
  #endif
--- 43,47 ----
  #endif /* !HAVE_DIRENT_H */
  
! #if defined (STRUCT_DIRENT_HAS_D_INO) && !defined (STRUCT_DIRENT_HAS_D_FILENO)
  #  define d_fileno d_ino
  #endif
diff -Nrc2 bash-2.0/lib/posixheaders/posixjmp.h bash-2.01/lib/posixheaders/posixjmp.h
*** bash-2.0/lib/posixheaders/posixjmp.h	Wed Dec 31 19:00:00 1969
--- bash-2.01/lib/posixheaders/posixjmp.h	Thu Jan 16 13:54:33 1997
***************
*** 0 ****
--- 1,20 ----
+ /* posixjmp.h -- wrapper for setjmp.h with changes for POSIX systems. */
+ 
+ #ifndef _POSIXJMP_H_
+ #define _POSIXJMP_H_
+ 
+ #include <setjmp.h>
+ 
+ /* This *must* be included *after* config.h */
+ 
+ #if defined (HAVE_POSIX_SIGSETJMP)
+ #  define procenv_t	sigjmp_buf
+ #  undef setjmp
+ #  define setjmp(x)	sigsetjmp((x), 1)
+ #  undef longjmp
+ #  define longjmp(x, n)	siglongjmp((x), (n))
+ #else
+ #  define procenv_t	jmp_buf
+ #endif
+ 
+ #endif /* _POSIXJMP_H_ */
diff -Nrc2 bash-2.0/lib/readline/Makefile.in bash-2.01/lib/readline/Makefile.in
*** bash-2.0/lib/readline/Makefile.in	Mon Nov 25 12:40:21 1996
--- bash-2.01/lib/readline/Makefile.in	Mon Jun  2 16:33:41 1997
***************
*** 1,7 ****
! ## -*- text -*- ####################################################
! #								   #
! # Makefile for the GNU Readline and History Libraries.		   #
! #								   #
! ####################################################################
  
  srcdir = @srcdir@
--- 1,7 ----
! ## -*- text -*- #############################################################
! #								            #
! # Makefile for the Bash versions of the GNU Readline and History Libraries. #
! #								            #
! #############################################################################
  
  srcdir = @srcdir@
***************
*** 21,25 ****
  MV = mv
  
! # See the file STANDALONE for the -D defines that readline understands
  
  CFLAGS = @CFLAGS@
--- 21,29 ----
  MV = mv
  
! SHELL = /bin/sh
! 
! # Programs to make tags files.
! ETAGS = etags -tw
! CTAGS = ctags -tw
  
  CFLAGS = @CFLAGS@
***************
*** 29,39 ****
  
  DEFS = @DEFS@
  
  INCLUDES = -I. -I$(BUILD_DIR) -I$(topdir) -I$(topdir)/lib
  
! CCFLAGS = $(DEFS) $(APP_CFLAGS) $(CPPFLAGS) ${INCLUDES} $(LOCAL_CFLAGS) $(CFLAGS)
  
- # Here is a rule for making .o files from .c files that doesn't force
- # the type of the machine (like -sun3) into the flags.
  .c.o:
  	$(CC) -c $(CCFLAGS) $<
--- 33,42 ----
  
  DEFS = @DEFS@
+ LOCAL_DEFS = @LOCAL_DEFS@
  
  INCLUDES = -I. -I$(BUILD_DIR) -I$(topdir) -I$(topdir)/lib
  
! CCFLAGS = $(DEFS) $(LOCAL_DEFS) $(APP_CFLAGS) $(CPPFLAGS) ${INCLUDES} $(LOCAL_CFLAGS) $(CFLAGS)
  
  .c.o:
  	$(CC) -c $(CCFLAGS) $<
***************
*** 51,68 ****
  	   $(srcdir)/callback.c $(srcdir)/terminal.c $(srcdir)/xmalloc.c \
  	   $(srcdir)/history.c $(srcdir)/histsearch.c $(srcdir)/histexpand.c \
! 	   $(srcdir)/histfile.c $(srcdir)/nls.c \
! 	   $(srcdir)/tilde.c \
  
  # The header files for this library.
  HSOURCES = readline.h rldefs.h chardefs.h keymaps.h history.h histlib.h \
! 	   posixstat.h tilde.h rlconf.h tcap.h
  
! HISTOBJ = history.o histexpand.o histfile.o histsearch.o
! TILDEOBJ= tilde.o
  OBJECTS = readline.o vi_mode.o funmap.o keymaps.o parens.o search.o \
  	  rltty.o complete.o bind.o isearch.o display.o signals.o \
  	  util.o kill.o undo.o macro.o input.o callback.o terminal.o \
! 	  nls.o xmalloc.o \
! 	  $(HISTOBJ) $(TILDEOBJ)
  
  # The texinfo files which document this library.
--- 54,71 ----
  	   $(srcdir)/callback.c $(srcdir)/terminal.c $(srcdir)/xmalloc.c \
  	   $(srcdir)/history.c $(srcdir)/histsearch.c $(srcdir)/histexpand.c \
! 	   $(srcdir)/histfile.c $(srcdir)/nls.c $(srcdir)/search.c \
! 	   $(srcdir)/shell.c $(srcdir)/tilde.c
  
  # The header files for this library.
  HSOURCES = readline.h rldefs.h chardefs.h keymaps.h history.h histlib.h \
! 	   posixstat.h posixdir.h posixjmp.h tilde.h rlconf.h rltty.h \
! 	   ansi_stdlib.h tcap.h
  
! HISTOBJ = history.o histexpand.o histfile.o histsearch.o shell.o
! TILDEOBJ = tilde.o
  OBJECTS = readline.o vi_mode.o funmap.o keymaps.o parens.o search.o \
  	  rltty.o complete.o bind.o isearch.o display.o signals.o \
  	  util.o kill.o undo.o macro.o input.o callback.o terminal.o \
! 	  nls.o $(HISTOBJ) $(TILDEOBJ) xmalloc.o
  
  # The texinfo files which document this library.
***************
*** 85,94 ****
  
  libreadline.a: $(OBJECTS)
! 	$(RM) -f $@
  	$(AR) cr $@ $(OBJECTS)
  	-test -n "$(RANLIB)" && $(RANLIB) $@
  
  libhistory.a: $(HISTOBJ) xmalloc.o
! 	$(RM) -f $@
  	$(AR) cr $@ $(HISTOBJ) xmalloc.o
  	-test -n "$(RANLIB)" && $(RANLIB) $@
--- 88,97 ----
  
  libreadline.a: $(OBJECTS)
! 	$(RM) $@
  	$(AR) cr $@ $(OBJECTS)
  	-test -n "$(RANLIB)" && $(RANLIB) $@
  
  libhistory.a: $(HISTOBJ) xmalloc.o
! 	$(RM) $@
  	$(AR) cr $@ $(HISTOBJ) xmalloc.o
  	-test -n "$(RANLIB)" && $(RANLIB) $@
***************
*** 100,133 ****
  force:
  
! # The rule for 'includes' is written funny so that the if statement
! # always returns TRUE unless there really was an error installing the
! # include files.
! install: installdirs libreadline.a
! 	for file in $(INSTALLED_HEADERS) ; do \
! 		$(INSTALL_DATA) $(srcdir)/$$file $(includedir)/readline ; \
! 	done
! 	-${MV} $(libdir)/libreadline.a $(libdir)/libreadline.old
! 	${INSTALL_DATA} libreadline.a $(libdir)/libreadline.a
! 	-test -n "$(RANLIB)" && $(RANLIB) -t $(bindir)/libreadline.a
! 
! installdirs:	$(topdir)/support/mkdirs
! 	$(SHELL) $(topdir)/support/mkdirs $(includedir) \
! 		$(includedir)/readline $(libdir) $(infodir) $(man3dir)
  
  uninstall:
! 	cd $(includedir)/readline && ${RM} -f ${INSTALLED_HEADERS}
! 	cd $(libdir) && ${RM} -f libreadline.a libreadline.old
! 
! tags:	force
! 	etags $(CSOURCES) $(HSOURCES)
  
  TAGS:	force
! 	ctags -x $(CSOURCES) $(HSOURCES) > $@
  
! readline: readline.h rldefs.h chardefs.h
! readline: $(OBJECTS)
! 	$(CC) $(CFLAGS) $(CPPFLAGS) $(READLINE_DEFINES) \
! 	  $(LOCAL_INCLUDES) -DTEST -o readline readline.c vi_mode.o funmap.o \
! 	  keymaps.o -ltermcap
  
  clean:	force
--- 103,117 ----
  force:
  
! install:
! 	@echo "This version of the readline library should not be installed."
  
  uninstall:
! 	@echo "This version of the readline library should not be installed."
  
  TAGS:	force
! 	$(ETAGS) $(CSOURCES) $(HSOURCES)
  
! tags:	force
! 	$(CTAGS) $(CSOURCES) $(HSOURCES)
  
  clean:	force
***************
*** 135,192 ****
  	-( cd doc && $(MAKE) $(MFLAGS) $@ )
  
! distclean realclean maintainer-clean: clean
  	-( cd doc && $(MAKE) $(MFLAGS) $@ )
- 	$(RM) Makefile
  
! mostlyclean: clean
  	-( cd doc && $(MAKE) $(MFLAGS) $@ )
  
  # Dependencies
! readline.o: readline.c readline.h rldefs.h rlconf.h chardefs.h tcap.h
! readline.o: keymaps.h history.h
! vi_mode.o: rldefs.h rlconf.h readline.h history.h
! funmap.o: funmap.c readline.h rlconf.h
! keymaps.o: keymaps.c emacs_keymap.c vi_keymap.c keymaps.h chardefs.h rlconf.h
! history.o: history.h histlib.h
  histexpand.o: history.h histlib.h
! histsearch.o: history.h histlib.h
  histfile.o: history.h histlib.h
! isearch.o: readline.h history.h
! search.o: readline.h history.h
! display.o: readline.h history.h rldefs.h rlconf.h tcap.h
! complete.o: readline.h rldefs.h rlconf.h posixdir.h posixstat.h
! rltty.o: rldefs.h rlconf.h readline.h rltty.h
! bind.o: rldefs.h rlconf.h readline.h history.h
! signals.o: rldefs.h rlconf.h readline.h history.h
! parens.o: readline.h
! kill.o: rldefs.h rlconf.h readline.h history.h
! macro.o: rldefs.h rlconf.h readline.h history.h
! undo.o: rldefs.h rlconf.h readline.h history.h
! input.o: rldefs.h rlconf.h readline.h history.h
! callback.o: rlconf.h rldefs.h readline.h
! terminal.o: rlconf.h rldefs.h readline.h tcap.h history.h
! 
! bind.o: $(BUILD_DIR)/config.h
! callback.o: $(BUILD_DIR)/config.h
! complete.o: $(BUILD_DIR)/config.h
! display.o: $(BUILD_DIR)/config.h
! funmap.o: $(BUILD_DIR)/config.h
! histexpand.o: $(BUILD_DIR)/config.h
! histfile.o: $(BUILD_DIR)/config.h
! history.o: $(BUILD_DIR)/config.h
! histsearch.o: $(BUILD_DIR)/config.h
! input.o: $(BUILD_DIR)/config.h
! isearch.o: $(BUILD_DIR)/config.h
! keymaps.o: $(BUILD_DIR)/config.h
! kill.o: $(BUILD_DIR)/config.h
! macro.o: $(BUILD_DIR)/config.h
! parens.o: $(BUILD_DIR)/config.h
! readline.o: $(BUILD_DIR)/config.h
! rltty.o: $(BUILD_DIR)/config.h
! search.o: $(BUILD_DIR)/config.h
! signals.o: $(BUILD_DIR)/config.h
! tilde.o: $(BUILD_DIR)/config.h
! undo.o: $(BUILD_DIR)/config.h
! util.o: $(BUILD_DIR)/config.h
! vi_mode.o: $(BUILD_DIR)/config.h
! xmalloc.o: $(BUILD_DIR)/config.h
--- 119,214 ----
  	-( cd doc && $(MAKE) $(MFLAGS) $@ )
  
! mostlyclean: clean
  	-( cd doc && $(MAKE) $(MFLAGS) $@ )
  
! distclean maintainer-clean: clean
  	-( cd doc && $(MAKE) $(MFLAGS) $@ )
+ 	$(RM) Makefile
+ 	$(RM) TAGS tags
  
  # Dependencies
! bind.o: ansi_stdlib.h posixstat.h
! bind.o: rldefs.h ${BUILD_DIR}/config.h rlconf.h
! bind.o: readline.h keymaps.h chardefs.h tilde.h
! bind.o: history.h
! callback.o: rlconf.h
! callback.o: rldefs.h ${BUILD_DIR}/config.h rlconf.h
! callback.o: readline.h keymaps.h chardefs.h tilde.h
! complete.o: ansi_stdlib.h posixdir.h posixstat.h
! complete.o: rldefs.h ${BUILD_DIR}/config.h rlconf.h
! complete.o: readline.h keymaps.h chardefs.h tilde.h
! display.o: ansi_stdlib.h posixstat.h
! display.o: rldefs.h ${BUILD_DIR}/config.h rlconf.h
! display.o: tcap.h
! display.o: readline.h keymaps.h chardefs.h tilde.h
! display.o: history.h
! funmap.o: readline.h keymaps.h chardefs.h tilde.h
! funmap.o: rlconf.h ansi_stdlib.h
! funmap.o: ${BUILD_DIR}/config.h
! histexpand.o: ansi_stdlib.h
  histexpand.o: history.h histlib.h
! histexpand.o: ${BUILD_DIR}/config.h
! histfile.o: ansi_stdlib.h
  histfile.o: history.h histlib.h
! histfile.o: ${BUILD_DIR}/config.h
! history.o: ansi_stdlib.h
! history.o: history.h histlib.h
! history.o: ${BUILD_DIR}/config.h
! histsearch.o: ansi_stdlib.h
! histsearch.o: history.h histlib.h
! histsearch.o: ${BUILD_DIR}/config.h
! input.o: ansi_stdlib.h
! input.o: rldefs.h ${BUILD_DIR}/config.h rlconf.h
! input.o: readline.h keymaps.h chardefs.h tilde.h
! isearch.o: rldefs.h ${BUILD_DIR}/config.h rlconf.h
! isearch.o: readline.h keymaps.h chardefs.h tilde.h
! isearch.o: ansi_stdlib.h history.h
! keymaps.o: emacs_keymap.c vi_keymap.c
! keymaps.o: keymaps.h chardefs.h rlconf.h ansi_stdlib.h
! keymaps.o: readline.h keymaps.h chardefs.h tilde.h
! keymaps.o: ${BUILD_DIR}/config.h
! kill.o: ansi_stdlib.h
! kill.o: rldefs.h ${BUILD_DIR}/config.h rlconf.h
! kill.o: readline.h keymaps.h chardefs.h tilde.h
! kill.o: history.h
! macro.o: ansi_stdlib.h
! macro.o: rldefs.h ${BUILD_DIR}/config.h rlconf.h
! macro.o: readline.h keymaps.h chardefs.h tilde.h
! macro.o: history.h
! nls.o: ansi_stdlib.h
! nls.o: rldefs.h ${BUILD_DIR}/config.h rlconf.h
! parens.o: rlconf.h
! parens.o: ${BUILD_DIR}/config.h
! parens.o: readline.h keymaps.h chardefs.h tilde.h
! readline.o: readline.h keymaps.h chardefs.h tilde.h
! readline.o: rldefs.h ${BUILD_DIR}/config.h rlconf.h
! readline.o: history.h
! readline.o: posixstat.h ansi_stdlib.h posixjmp.h
! rltty.o: rldefs.h ${BUILD_DIR}/config.h rlconf.h
! rltty.o: rltty.h
! rltty.o: readline.h keymaps.h chardefs.h tilde.h
! search.o: rldefs.h ${BUILD_DIR}/config.h rlconf.h
! search.o: readline.h keymaps.h chardefs.h tilde.h
! search.o: ansi_stdlib.h history.h
! signals.o: rldefs.h ${BUILD_DIR}/config.h rlconf.h
! signals.o: readline.h keymaps.h chardefs.h tilde.h
! signals.o: history.h
! terminal.o: rldefs.h ${BUILD_DIR}/config.h rlconf.h
! terminal.o: tcap.h
! terminal.o: readline.h keymaps.h chardefs.h tilde.h
! terminal.o: history.h
! tilde.o: ansi_stdlib.h
! tilde.o: ${BUILD_DIR}/config.h
! tilde.o: tilde.h
! undo.o: ansi_stdlib.h
! undo.o: rldefs.h ${BUILD_DIR}/config.h rlconf.h
! undo.o: readline.h keymaps.h chardefs.h tilde.h
! undo.o: history.h
! util.o: posixjmp.h ansi_stdlib.h
! util.o: rldefs.h ${BUILD_DIR}/config.h rlconf.h
! util.o: readline.h keymaps.h chardefs.h tilde.h
! vi_mode.o: rldefs.h ${BUILD_DIR}/config.h rlconf.h
! vi_mode.o: readline.h keymaps.h chardefs.h tilde.h
! vi_mode.o: history.h ansi_stdlib.h
! xmalloc.o: ${BUILD_DIR}/config.h
! xmalloc.o: ansi_stdlib.h
diff -Nrc2 bash-2.0/lib/readline/bind.c bash-2.01/lib/readline/bind.c
*** bash-2.0/lib/readline/bind.c	Fri Nov 22 17:34:02 1996
--- bash-2.01/lib/readline/bind.c	Wed Apr  2 12:11:45 1997
***************
*** 90,98 ****
--- 90,103 ----
  extern char *possible_control_prefixes[], *possible_meta_prefixes[];
  
+ /* Functions imported from funmap.c */
  extern char **rl_funmap_names ();
  extern int rl_add_funmap_entry ();
  
+ /* Functions imported from util.c */
  extern char *_rl_strindex ();
  
+ /* Functions imported from shell.c */
+ extern char *get_env_value ();
+ 
  /* Variables exported by this file. */
  Keymap rl_binding_keymap;
***************
*** 203,207 ****
       Keymap map;
  {
!   return (rl_generic_bind (ISFUNC, keyseq, function, map));
  }
  
--- 208,212 ----
       Keymap map;
  {
!   return (rl_generic_bind (ISFUNC, keyseq, (char *)function, map));
  }
  
***************
*** 382,386 ****
        kseq[i++] = 'C';
        kseq[i++] = '-';
!       c = UNCTRL (c);
      }
    else if (c == RUBOUT)
--- 387,391 ----
        kseq[i++] = 'C';
        kseq[i++] = '-';
!       c = _rl_to_lower (UNCTRL (c));
      }
    else if (c == RUBOUT)
***************
*** 395,399 ****
      {
        kseq[i++] = '\\';
!       kseq[i++] = 'e';
      }
    else if (c == '\\' || c == '"')
--- 400,404 ----
      {
        kseq[i++] = '\\';
!       c = 'e';
      }
    else if (c == '\\' || c == '"')
***************
*** 407,410 ****
--- 412,462 ----
  }
  
+ static char *
+ _rl_untranslate_macro_value (seq)
+      char *seq;
+ {
+   char *ret, *r, *s;
+   int c;
+ 
+   r = ret = xmalloc (7 * strlen (seq) + 1);
+   for (s = seq; *s; s++)
+     {
+       c = *s;
+       if (META_CHAR (c))
+ 	{
+ 	  *r++ = '\\';
+ 	  *r++ = 'M';
+ 	  *r++ = '-';
+ 	  c = UNMETA (c);
+ 	}
+       else if (CTRL_CHAR (c) && c != ESC)
+ 	{
+ 	  *r++ = '\\';
+ 	  *r++ = 'C';
+ 	  *r++ = '-';
+ 	  c = _rl_to_lower (UNCTRL (c));
+ 	}
+       else if (c == RUBOUT)
+  	{
+  	  *r++ = '\\';
+  	  *r++ = 'C';
+  	  *r++ = '-';
+  	  c = '?';
+  	}
+ 
+       if (c == ESC)
+ 	{
+ 	  *r++ = '\\';
+ 	  c = 'e';
+ 	}
+       else if (c == '\\' || c == '"')
+ 	*r++ = '\\';
+ 
+       *r++ = (unsigned char)c;
+     }
+   *r = '\0';
+   return ret;
+ }
+ 
  /* Return a pointer to the function that STRING represents.
     If STRING doesn't have a matching function, then a NULL pointer
***************
*** 524,528 ****
        filename = last_readline_init_file;
        if (filename == 0)
!         filename = getenv ("INPUTRC");
        if (filename == 0)
  	filename = DEFAULT_INPUTRC;
--- 576,580 ----
        filename = last_readline_init_file;
        if (filename == 0)
!         filename = get_env_value ("INPUTRC");
        if (filename == 0)
  	filename = DEFAULT_INPUTRC;
***************
*** 991,1002 ****
    if (*funname == '\'' || *funname == '"')
      {
!       char seq[2];
        int fl = strlen (funname);
  
!       seq[0] = key; seq[1] = '\0';
        if (fl && funname[fl - 1] == *funname)
  	funname[fl - 1] = '\0';
  
!       rl_macro_bind (seq, &funname[1], _rl_keymap);
      }
  #if defined (PREFIX_META_HACK)
--- 1043,1054 ----
    if (*funname == '\'' || *funname == '"')
      {
!       unsigned char useq[2];
        int fl = strlen (funname);
  
!       useq[0] = key; useq[1] = '\0';
        if (fl && funname[fl - 1] == *funname)
  	funname[fl - 1] = '\0';
  
!       rl_macro_bind (useq, &funname[1], _rl_keymap);
      }
  #if defined (PREFIX_META_HACK)
***************
*** 1529,1532 ****
--- 1581,1586 ----
       int count, key;
  {
+   if (rl_dispatching)
+     fprintf (rl_outstream, "\r\n");
    rl_function_dumper (rl_explicit_arg);
    rl_on_new_line ();
***************
*** 1550,1554 ****
--- 1604,1612 ----
  	case ISMACR:
  	  keyname = _rl_get_keyname (key);
+ #if 0
  	  out = (char *)map[key].function;
+ #else
+ 	  out = _rl_untranslate_macro_value ((char *)map[key].function);
+ #endif
  	  if (print_readably)
  	    fprintf (rl_outstream, "\"%s%s\": \"%s\"\n", prefix ? prefix : "",
***************
*** 1560,1563 ****
--- 1618,1624 ----
  							out ? out : "");
  	  free (keyname);
+ #if 1
+ 	  free (out);
+ #endif
  	  break;
  	case ISFUNC:
***************
*** 1605,1608 ****
--- 1666,1671 ----
       int count, key;
  {
+   if (rl_dispatching)
+     fprintf (rl_outstream, "\r\n");
    rl_macro_dumper (rl_explicit_arg);
    rl_on_new_line ();
***************
*** 1675,1678 ****
--- 1738,1743 ----
       int count, key;
  {
+   if (rl_dispatching)
+     fprintf (rl_outstream, "\r\n");
    rl_variable_dumper (rl_explicit_arg);
    rl_on_new_line ();
diff -Nrc2 bash-2.0/lib/readline/callback.c bash-2.01/lib/readline/callback.c
*** bash-2.0/lib/readline/callback.c	Fri Oct 27 13:34:05 1995
--- bash-2.01/lib/readline/callback.c	Mon Mar  3 16:04:40 1997
***************
*** 40,43 ****
--- 40,44 ----
  extern char *readline_internal_teardown ();
  extern int readline_internal_char ();
+ extern void _rl_init_line_state ();
  
  extern int _rl_meta_flag;
***************
*** 120,123 ****
--- 121,128 ----
        in_handler = 0;
        (*rl_linefunc) (line);
+ 
+     /* If the user did not clear out the line, do it for him. */
+     if (rl_line_buffer[0])
+       _rl_init_line_state ();
  
      /* Redisplay the prompt if readline_handler_{install,remove} not called. */
diff -Nrc2 bash-2.0/lib/readline/complete.c bash-2.01/lib/readline/complete.c
*** bash-2.0/lib/readline/complete.c	Fri Nov 22 13:25:09 1996
--- bash-2.01/lib/readline/complete.c	Mon May 19 12:09:05 1997
***************
*** 26,30 ****
  #endif
  
- #include <stdio.h>
  #include <sys/types.h>
  #include <fcntl.h>
--- 26,29 ----
***************
*** 43,46 ****
--- 42,47 ----
  #endif /* HAVE_STDLIB_H */
  
+ #include <stdio.h>
+ 
  #include <errno.h>
  #if !defined (errno)
***************
*** 138,142 ****
  
  /* Pointer to the generator function for completion_matches ().
!    NULL means to use filename_entry_function (), the default filename
     completer. */
  Function *rl_completion_entry_function = (Function *)NULL;
--- 139,143 ----
  
  /* Pointer to the generator function for completion_matches ().
!    NULL means to use filename_completion_function (), the default filename
     completer. */
  Function *rl_completion_entry_function = (Function *)NULL;
***************
*** 762,771 ****
  
  static char *
! make_quoted_replacement (match, mtype, quote_char)
       char *match;
!      int mtype, quote_char;
  {
    int should_quote, do_replace;
!   char *replacement, qc;
  
    /* If we are doing completion on quoted substrings, and any matches
--- 763,773 ----
  
  static char *
! make_quoted_replacement (match, mtype, qc)
       char *match;
!      int mtype;
!      char *qc;	/* Pointer to quoting character, if any */
  {
    int should_quote, do_replace;
!   char *replacement;
  
    /* If we are doing completion on quoted substrings, and any matches
***************
*** 785,792 ****
    if (should_quote)
  #if defined (SHELL)
!     should_quote = should_quote && (!quote_char || quote_char == '"' || quote_char == '\'');
! #else
!     should_quote = should_quote && !quote_char;
! #endif
  
    if (should_quote)
--- 787,794 ----
    if (should_quote)
  #if defined (SHELL)
!     should_quote = should_quote && (!qc || !*qc || *qc == '"' || *qc == '\'');
! #else /* !SHELL */
!     should_quote = should_quote && (!qc || !*qc);
! #endif /* !SHELL */
  
    if (should_quote)
***************
*** 798,813 ****
  
        do_replace = should_quote ? mtype : NO_MATCH;
!       if (do_replace != NO_MATCH)
! 	{
! 	  /* Quote the replacement, since we found an embedded
! 	     word break character in a potential match. */
! 	  if (rl_filename_quoting_function)
! 	    {
! 	      qc = quote_char;	/* must pass a (char *) to quoting function */
! 	      replacement = (*rl_filename_quoting_function)
! 				(match, do_replace, &qc);
! 	      quote_char = qc;
! 	    }
! 	}
      }
    return (replacement);
--- 800,807 ----
  
        do_replace = should_quote ? mtype : NO_MATCH;
!       /* Quote the replacement, since we found an embedded
! 	 word break character in a potential match. */
!       if (do_replace != NO_MATCH && rl_filename_quoting_function)
! 	replacement = (*rl_filename_quoting_function) (match, do_replace, qc);
      }
    return (replacement);
***************
*** 815,825 ****
  
  static void
! insert_match (match, start, mtype, quote_char)
       char *match;
!      int start, mtype, quote_char;
  {
    char *replacement;
  
!   replacement = make_quoted_replacement (match, mtype, quote_char);
  
    /* Now insert the match. */
--- 809,822 ----
  
  static void
! insert_match (match, start, mtype, qc)
       char *match;
!      int start, mtype;
!      char *qc;
  {
    char *replacement;
+   char oqc;
  
!   oqc = qc ? *qc : '\0';
!   replacement = make_quoted_replacement (match, mtype, qc);
  
    /* Now insert the match. */
***************
*** 827,832 ****
      {
        /* Don't double an opening quote character. */
!       if (quote_char && start && rl_line_buffer[start - 1] == quote_char &&
! 	    replacement[0] == quote_char)
  	start--;
        insert_text (replacement, start, rl_point - 1);
--- 824,834 ----
      {
        /* Don't double an opening quote character. */
!       if (qc && *qc && start && rl_line_buffer[start - 1] == *qc &&
! 	    replacement[0] == *qc)
! 	start--;
!       /* If make_quoted_replacement changed the quoting character, remove
! 	 the opening quote and insert the (fully-quoted) replacement. */
!       else if (qc && (*qc != oqc) && start && rl_line_buffer[start - 1] == oqc &&
! 	    replacement[0] != oqc)
  	start--;
        insert_text (replacement, start, rl_point - 1);
***************
*** 883,889 ****
  
  static void
! insert_all_matches (matches, point, quote_char)
       char **matches;
!      int point, quote_char;
  {
    int i;
--- 885,892 ----
  
  static void
! insert_all_matches (matches, point, qc)
       char **matches;
!      int point;
!      char *qc;
  {
    int i;
***************
*** 893,897 ****
    /* remove any opening quote character; make_quoted_replacement will add
       it back. */
!   if (quote_char && point && rl_line_buffer[point - 1] == quote_char)
      point--;
    rl_delete_text (point, rl_point);
--- 896,900 ----
    /* remove any opening quote character; make_quoted_replacement will add
       it back. */
!   if (qc && *qc && point && rl_line_buffer[point - 1] == *qc)
      point--;
    rl_delete_text (point, rl_point);
***************
*** 902,906 ****
        for (i = 1; matches[i]; i++)
  	{
! 	  rp = make_quoted_replacement (matches[i], SINGLE_MATCH, quote_char);
  	  rl_insert_text (rp);
  	  rl_insert_text (" ");
--- 905,909 ----
        for (i = 1; matches[i]; i++)
  	{
! 	  rp = make_quoted_replacement (matches[i], SINGLE_MATCH, qc);
  	  rl_insert_text (rp);
  	  rl_insert_text (" ");
***************
*** 911,915 ****
    else
      {
!       rp = make_quoted_replacement (matches[0], SINGLE_MATCH, quote_char);
        rl_insert_text (rp);
        rl_insert_text (" ");
--- 914,918 ----
    else
      {
!       rp = make_quoted_replacement (matches[0], SINGLE_MATCH, qc);
        rl_insert_text (rp);
        rl_insert_text (" ");
***************
*** 965,969 ****
    text = rl_copy_text (start, end);
    matches = gen_completion_matches (text, start, end, our_func, found_quote, quote_char);
-   free (text);
  
    if (matches == 0)
--- 968,971 ----
***************
*** 971,974 ****
--- 973,977 ----
        ding ();
        FREE (saved_line_buffer);
+       free (text);
        return 0;
      }
***************
*** 999,1002 ****
--- 1002,1006 ----
  	  ding ();
  	  FREE (saved_line_buffer);
+ 	  FREE (text);
  	  return 0;
          }
***************
*** 1014,1017 ****
--- 1018,1022 ----
  	}
      }
+   free (text);
  
    switch (what_to_do)
***************
*** 1021,1025 ****
        /* Insert the first match with proper quoting. */
        if (*matches[0])
! 	insert_match (matches[0], start, matches[1] ? MULT_MATCH : SINGLE_MATCH, quote_char);
  
        /* If there are more matches, ring the bell to indicate.
--- 1026,1030 ----
        /* Insert the first match with proper quoting. */
        if (*matches[0])
! 	insert_match (matches[0], start, matches[1] ? MULT_MATCH : SINGLE_MATCH, &quote_char);
  
        /* If there are more matches, ring the bell to indicate.
***************
*** 1047,1051 ****
  
      case '*':
!       insert_all_matches (matches, start, quote_char);
        break;
  
--- 1052,1056 ----
  
      case '*':
!       insert_all_matches (matches, start, &quote_char);
        break;
  
***************
*** 1103,1110 ****
--- 1108,1119 ----
    if (S_ISDIR (finfo.st_mode))
      character = '/';
+ #if defined (S_ISCHR)
    else if (S_ISCHR (finfo.st_mode))
      character = '%';
+ #endif /* S_ISCHR */
+ #if defined (S_ISBLK)
    else if (S_ISBLK (finfo.st_mode))
      character = '#';
+ #endif /* S_ISBLK */
  #if defined (S_ISLNK)
    else if (S_ISLNK (finfo.st_mode))
***************
*** 1322,1326 ****
       char *text;
  {
!   static DIR *directory;
    static char *filename = (char *)NULL;
    static char *dirname = (char *)NULL;
--- 1331,1335 ----
       char *text;
  {
!   static DIR *directory = (DIR *)NULL;
    static char *filename = (char *)NULL;
    static char *dirname = (char *)NULL;
***************
*** 1334,1337 ****
--- 1343,1353 ----
    if (state == 0)
      {
+       /* If we were interrupted before closing the directory or reading
+ 	 all of its contents, close it. */
+       if (directory)
+ 	{
+ 	  closedir (directory);
+ 	  directory = (DIR *)NULL;
+ 	}
        FREE (dirname);
        FREE (filename);
diff -Nrc2 bash-2.0/lib/readline/display.c bash-2.01/lib/readline/display.c
*** bash-2.0/lib/readline/display.c	Wed Nov 20 11:58:24 1996
--- bash-2.01/lib/readline/display.c	Wed Mar  5 16:37:32 1997
***************
*** 26,30 ****
  #endif
  
- #include <stdio.h>
  #include <sys/types.h>
  
--- 26,29 ----
***************
*** 33,36 ****
--- 32,37 ----
  #endif /* HAVE_UNISTD_H */
  
+ #include "posixstat.h"
+ 
  #if defined (HAVE_STDLIB_H)
  #  include <stdlib.h>
***************
*** 39,43 ****
  #endif /* HAVE_STDLIB_H */
  
! #include "posixstat.h"
  
  /* System-specific feature definitions and include files. */
--- 40,49 ----
  #endif /* HAVE_STDLIB_H */
  
! #include <stdio.h>
! 
! #if defined (__GO32__)
! #  include <go32.h>
! #  include <pc.h>
! #endif /* __GO32__ */
  
  /* System-specific feature definitions and include files. */
***************
*** 70,74 ****
  extern int _rl_backspace ();
  
! extern char *term_clreol, *term_im, *term_ic,  *term_ei, *term_DC;
  extern char *term_up, *term_dc, *term_cr, *term_IC;
  extern int screenheight, screenwidth, screenchars;
--- 76,81 ----
  extern int _rl_backspace ();
  
! extern char *term_clreol, *term_clrpag;
! extern char *term_im, *term_ic,  *term_ei, *term_DC;
  extern char *term_up, *term_dc, *term_cr, *term_IC;
  extern int screenheight, screenwidth, screenchars;
***************
*** 79,84 ****
  void _rl_move_cursor_relative (), _rl_output_some_chars ();
  void _rl_move_vert ();
  
! static void update_line (), clear_to_eol (), space_to_eol ();
  static void delete_chars (), insert_some_chars ();
  static void cr ();
--- 86,92 ----
  void _rl_move_cursor_relative (), _rl_output_some_chars ();
  void _rl_move_vert ();
+ void _rl_clear_to_eol (), _rl_clear_screen ();
  
! static void update_line (), space_to_eol ();
  static void delete_chars (), insert_some_chars ();
  static void cr ();
***************
*** 303,307 ****
    register char *line;
    int c_pos, inv_botlin, lb_botlin, lb_linenum;
!   int newlines, lpos;
    char *prompt_this_line;
  
--- 311,315 ----
    register char *line;
    int c_pos, inv_botlin, lb_botlin, lb_linenum;
!   int newlines, lpos, temp;
    char *prompt_this_line;
  
***************
*** 406,411 ****
    /* inv_lbreaks[i] is where line i starts in the buffer. */
    inv_lbreaks[newlines = 0] = 0;
  
!   for (in = 0, lpos = out - wrap_offset; in < rl_end; in++)
      {
        c = (unsigned char)rl_line_buffer[in];
--- 414,430 ----
    /* inv_lbreaks[i] is where line i starts in the buffer. */
    inv_lbreaks[newlines = 0] = 0;
+   lpos = out - wrap_offset;
+ 
+   /* XXX - what if lpos is already >= screenwidth before we start drawing the
+      contents of the command line? */
+   while (lpos >= screenwidth)
+     {
+       temp = ((newlines + 1) * screenwidth) - ((newlines == 0) ? wrap_offset : 0);
+       inv_lbreaks[++newlines] = temp;
+       lpos -= screenwidth;
+     }
  
!   lb_linenum = 0;
!   for (in = 0; in < rl_end; in++)
      {
        c = (unsigned char)rl_line_buffer[in];
***************
*** 433,438 ****
  	      if (lpos + 4 >= screenwidth)
  		{
- 		  register int temp;
- 
  		  temp = screenwidth - lpos;
  		  inv_lbreaks[++newlines] = out + temp;
--- 452,455 ----
***************
*** 558,562 ****
  		  nleft = screenwidth + wrap_offset - _rl_last_c_pos;
  		  if (nleft)
! 		    clear_to_eol (nleft);
  		}
  
--- 575,579 ----
  		  nleft = screenwidth + wrap_offset - _rl_last_c_pos;
  		  if (nleft)
! 		    _rl_clear_to_eol (nleft);
  		}
  
***************
*** 576,580 ****
  		  _rl_move_vert (linenum);
  		  _rl_move_cursor_relative (0, tt);
! 		  clear_to_eol
  		    ((linenum == _rl_vis_botlin) ? strlen (tt) : screenwidth);
  		}
--- 593,597 ----
  		  _rl_move_vert (linenum);
  		  _rl_move_cursor_relative (0, tt);
! 		  _rl_clear_to_eol
  		    ((linenum == _rl_vis_botlin) ? strlen (tt) : screenwidth);
  		}
***************
*** 711,715 ****
  	    {
  	      nleft = screenwidth - t;
! 	      clear_to_eol (nleft);
  	    }
  	  visible_first_line_len = out - lmargin - M_OFFSET (lmargin, wrap_offset);
--- 728,732 ----
  	    {
  	      nleft = screenwidth - t;
! 	      _rl_clear_to_eol (nleft);
  	    }
  	  visible_first_line_len = out - lmargin - M_OFFSET (lmargin, wrap_offset);
***************
*** 963,967 ****
  	    space_to_eol (lendiff);
  	  else
! 	    clear_to_eol (lendiff);
  	}
      }
--- 980,984 ----
  	    space_to_eol (lendiff);
  	  else
! 	    _rl_clear_to_eol (lendiff);
  	}
      }
***************
*** 1294,1307 ****
  /* Clear to the end of the line.  COUNT is the minimum
     number of character spaces to clear, */
! static void
! clear_to_eol (count)
       int count;
  {
  #if !defined (__GO32__)
    if (term_clreol)
!     {
!       tputs (term_clreol, 1, _rl_output_character_function);
!     }
!   else
  #endif /* !__GO32__ */
      space_to_eol (count);
--- 1311,1322 ----
  /* Clear to the end of the line.  COUNT is the minimum
     number of character spaces to clear, */
! void
! _rl_clear_to_eol (count)
       int count;
  {
  #if !defined (__GO32__)
    if (term_clreol)
!     tputs (term_clreol, 1, _rl_output_character_function);
!   else if (count)
  #endif /* !__GO32__ */
      space_to_eol (count);
***************
*** 1322,1325 ****
--- 1337,1351 ----
  }
  
+ void
+ _rl_clear_screen ()
+ {
+ #if !defined (__GO32__)
+   if (term_clrpag)
+     tputs (term_clrpag, 1, _rl_output_character_function);
+   else
+ #endif /* !__GO32__ */
+     crlf ();
+ }
+ 
  /* Insert COUNT characters from STRING to the output stream. */
  static void
***************
*** 1421,1425 ****
       compensate so we don't print an extra CRLF. */
    if (_rl_vis_botlin && _rl_last_c_pos == 0 &&
! 	visible_line[inv_lbreaks[_rl_vis_botlin]+1] == 0)
      {
        _rl_vis_botlin--;
--- 1447,1451 ----
       compensate so we don't print an extra CRLF. */
    if (_rl_vis_botlin && _rl_last_c_pos == 0 &&
! 	visible_line[vis_lbreaks[_rl_vis_botlin]] == 0)
      {
        _rl_vis_botlin--;
***************
*** 1433,1437 ****
        last_line = &visible_line[inv_lbreaks[_rl_vis_botlin]];
        _rl_move_cursor_relative (screenwidth - 1, last_line);
!       clear_to_eol (0);
        putc (last_line[screenwidth - 1], rl_outstream);
      }
--- 1459,1463 ----
        last_line = &visible_line[inv_lbreaks[_rl_vis_botlin]];
        _rl_move_cursor_relative (screenwidth - 1, last_line);
!       _rl_clear_to_eol (0);
        putc (last_line[screenwidth - 1], rl_outstream);
      }
diff -Nrc2 bash-2.0/lib/readline/doc/Makefile bash-2.01/lib/readline/doc/Makefile
*** bash-2.0/lib/readline/doc/Makefile	Tue Dec  3 16:46:14 1996
--- bash-2.01/lib/readline/doc/Makefile	Wed Jan 29 13:47:09 1997
***************
*** 1,8 ****
  # This makefile for Readline library documentation is in -*- text -*- mode.
  # Emacs likes it that way.
- TEXI2DVI = texi2dvi
- 
  RM = rm -f
  
  INSTALL_DATA = cp
  infodir = /usr/local/info
--- 1,12 ----
  # This makefile for Readline library documentation is in -*- text -*- mode.
  # Emacs likes it that way.
  RM = rm -f
  
+ MAKEINFO    = makeinfo
+ TEXI2DVI    = texi2dvi
+ TEXI2HTML   = texi2html
+ QUIETPS     = #set this to -q to shut up dvips
+ DVIPS       = dvips -D 300 $(QUIETPS) -o $@     # tricky
+ 
  INSTALL_DATA = cp
  infodir = /usr/local/info
***************
*** 16,20 ****
  HTMLOBJ = readline.html history.html
  
! all: info dvi html
  
  readline.dvi: $(RLSRC)
--- 20,25 ----
  HTMLOBJ = readline.html history.html
  
! all: info dvi html ps
! nodvi: info html
  
  readline.dvi: $(RLSRC)
***************
*** 23,27 ****
  
  readline.info: $(RLSRC)
! 	makeinfo --no-split -o $@ rlman.texinfo
  
  history.dvi: ${HISTSRC}
--- 28,32 ----
  
  readline.info: $(RLSRC)
! 	$(MAKEINFO) --no-split -o $@ rlman.texinfo
  
  history.dvi: ${HISTSRC}
***************
*** 30,52 ****
  
  history.info: ${HISTSRC}
! 	makeinfo --no-split -o $@ hist.texinfo
  
  readline.ps:	readline.dvi
! 	dvips -D 300 -o $@ readline.dvi
  
  history.ps:	history.dvi
! 	dvips -D 300 -o $@ history.dvi
  
  readline.html:	${RLSRC}
! 	texi2html rlman.texinfo
  	sed -e 's:rlman.html:readline.html:' -e 's:rlman_toc.html:readline_toc.html:' rlman.html > readline.html
  	sed -e 's:rlman.html:readline.html:' -e 's:rlman_toc.html:readline_toc.html:' rlman_toc.html > readline_toc.html
! 	rm -f rlman.html rlman_toc.html
  
  history.html:	${HISTSRC}
! 	texi2html hist.texinfo
  	sed -e 's:hist.html:history.html:' -e 's:hist_toc.html:history_toc.html:' hist.html > history.html
  	sed -e 's:hist.html:history.html:' -e 's:hist_toc.html:history_toc.html:' hist_toc.html > history_toc.html
! 	rm -f hist.html hist_toc.html
  
  info:	$(INFOOBJ)
--- 35,59 ----
  
  history.info: ${HISTSRC}
! 	$(MAKEINFO) --no-split -o $@ hist.texinfo
  
  readline.ps:	readline.dvi
! 	$(RM) $@
! 	$(DVIPS) readline.dvi
  
  history.ps:	history.dvi
! 	$(RM) $@
! 	$(DVIPS) history.dvi
  
  readline.html:	${RLSRC}
! 	$(TEXI2HTML) rlman.texinfo
  	sed -e 's:rlman.html:readline.html:' -e 's:rlman_toc.html:readline_toc.html:' rlman.html > readline.html
  	sed -e 's:rlman.html:readline.html:' -e 's:rlman_toc.html:readline_toc.html:' rlman_toc.html > readline_toc.html
! 	$(RM) rlman.html rlman_toc.html
  
  history.html:	${HISTSRC}
! 	$(TEXI2HTML) hist.texinfo
  	sed -e 's:hist.html:history.html:' -e 's:hist_toc.html:history_toc.html:' hist.html > history.html
  	sed -e 's:hist.html:history.html:' -e 's:hist_toc.html:history_toc.html:' hist_toc.html > history_toc.html
! 	$(RM) hist.html hist_toc.html
  
  info:	$(INFOOBJ)
diff -Nrc2 bash-2.0/lib/readline/doc/hstech.texinfo bash-2.01/lib/readline/doc/hstech.texinfo
*** bash-2.0/lib/readline/doc/hstech.texinfo	Wed Mar 20 15:12:56 1996
--- bash-2.01/lib/readline/doc/hstech.texinfo	Wed Mar 26 13:05:56 1997
***************
*** 416,419 ****
--- 416,430 ----
  @end deftypevar
  
+ @deftypevar {Function *} history_inhibit_expansion_function
+ This should be set to the address of a function that takes two arguments:
+ a @code{char *} (@var{string}) and an integer index into that string (@var{i}).
+ It should return a non-zero value if the history expansion starting at
+ @var{string[i]} should not be performed; zero if the expansion should
+ be done.
+ It is intended for use by applications like Bash that use the history
+ expansion character for additional purposes.
+ By default, this variable is set to NULL.
+ @end deftypevar
+ 
  @node History Programming Example
  @section History Programming Example
diff -Nrc2 bash-2.0/lib/readline/doc/rltech.texinfo bash-2.01/lib/readline/doc/rltech.texinfo
*** bash-2.0/lib/readline/doc/rltech.texinfo	Fri Jul  5 12:33:03 1996
--- bash-2.01/lib/readline/doc/rltech.texinfo	Mon Mar  3 16:23:25 1997
***************
*** 313,317 ****
  @end deftypevar
  
! @deftypevar {Function *} rl_redisplay_function
  If non-zero, @code{readline} will call indirectly through this pointer
  to update the display with the current contents of the editing buffer.
--- 313,317 ----
  @end deftypevar
  
! @deftypevar {VFunction *} rl_redisplay_function
  If non-zero, @code{readline} will call indirectly through this pointer
  to update the display with the current contents of the editing buffer.
***************
*** 418,421 ****
--- 418,426 ----
  @end deftypefun
  
+ @deftypefun {char *} rl_get_keymap_name (Keymap keymap)
+ Return the name matching @var{keymap}.  @var{name} is one which would
+ be supplied in a @code{set keymap} inputrc line (@pxref{Readline Init File}).
+ @end deftypefun
+ 
  @node Binding Keys
  @subsection Binding Keys
***************
*** 577,581 ****
  @subsection Redisplay
  
! @deftypefun int rl_redisplay ()
  Change what's displayed on the screen to reflect the current contents
  of @code{rl_line_buffer}.
--- 582,586 ----
  @subsection Redisplay
  
! @deftypefun void rl_redisplay ()
  Change what's displayed on the screen to reflect the current contents
  of @code{rl_line_buffer}.
***************
*** 651,654 ****
--- 656,664 ----
  @end deftypefun
  
+ @deftypefun rl_extend_line_buffer (int len)
+ Ensure that @code{rl_line_buffer} has enough space to hold @var{len}
+ characters, possibly reallocating it if necessary.
+ @end deftypefun
+ 
  @deftypefun int rl_initialize ()
  Initialize or re-initialize Readline's internal state.
***************
*** 871,875 ****
  ()}.  If the value of @code{rl_completion_entry_function} is
  @code{(Function *)NULL} then the default filename generator function,
! @code{filename_entry_function ()}, is used.
  @end deftypevar
  
--- 881,885 ----
  ()}.  If the value of @code{rl_completion_entry_function} is
  @code{(Function *)NULL} then the default filename generator function,
! @code{filename_completion_function ()}, is used.
  @end deftypevar
  
***************
*** 1070,1074 ****
  
  @deftypevar int rl_inhibit_completion
! If this variable is non-zero, completion is inhibited.  The completion
  character will be inserted as any other bound to @code{self-insert}.
  @end deftypevar
--- 1080,1084 ----
  
  @deftypevar int rl_inhibit_completion
! If this variable is non-zero, completion is inhibit<ed.  The completion
  character will be inserted as any other bound to @code{self-insert}.
  @end deftypevar
diff -Nrc2 bash-2.0/lib/readline/doc/rluser.texinfo bash-2.01/lib/readline/doc/rluser.texinfo
*** bash-2.0/lib/readline/doc/rluser.texinfo	Mon Jul  8 14:48:40 1996
--- bash-2.01/lib/readline/doc/rluser.texinfo	Mon May 19 12:56:22 1997
***************
*** 606,634 ****
  # Arrow keys in keypad mode
  #
! #"\M-OD"        backward-char
! #"\M-OC"        forward-char
! #"\M-OA"        previous-history
! #"\M-OB"        next-history
  #
  # Arrow keys in ANSI mode
  #
! "\M-[D"        backward-char
! "\M-[C"        forward-char
! "\M-[A"        previous-history
! "\M-[B"        next-history
  #
  # Arrow keys in 8 bit keypad mode
  #
! #"\M-\C-OD"       backward-char
! #"\M-\C-OC"       forward-char
! #"\M-\C-OA"       previous-history
! #"\M-\C-OB"       next-history
  #
  # Arrow keys in 8 bit ANSI mode
  #
! #"\M-\C-[D"       backward-char
! #"\M-\C-[C"       forward-char
! #"\M-\C-[A"       previous-history
! #"\M-\C-[B"       next-history
  
  C-q: quoted-insert
--- 606,634 ----
  # Arrow keys in keypad mode
  #
! #"\M-OD":        backward-char
! #"\M-OC":        forward-char
! #"\M-OA":        previous-history
! #"\M-OB":        next-history
  #
  # Arrow keys in ANSI mode
  #
! "\M-[D":        backward-char
! "\M-[C":        forward-char
! "\M-[A":        previous-history
! "\M-[B":        next-history
  #
  # Arrow keys in 8 bit keypad mode
  #
! #"\M-\C-OD":       backward-char
! #"\M-\C-OC":       forward-char
! #"\M-\C-OA":       previous-history
! #"\M-\C-OB":       next-history
  #
  # Arrow keys in 8 bit ANSI mode
  #
! #"\M-\C-[D":       backward-char
! #"\M-\C-[C":       forward-char
! #"\M-\C-[A":       previous-history
! #"\M-\C-[B":       next-history
  
  C-q: quoted-insert
***************
*** 922,929 ****
  
  @item universal-argument ()
! Each time this is executed, the argument count is multiplied by four.
  The argument count is initially one, so executing this function the
! first time makes the argument count four.  By default, this is not
! bound to a key.
  @end ftable
  
--- 922,937 ----
  
  @item universal-argument ()
! This is another way to specify an argument.
! If this command is followed by one or more digits, optionally with a
! leading minus sign, those digits define the argument.
! If the command is followed by digits, executing @code{universal-argument}
! again ends the numeric argument, but is otherwise ignored.
! As a special case, if this command is immediately followed by a
! character that is neither a digit or minus sign, the argument count
! for the next command is multiplied by four.
  The argument count is initially one, so executing this function the
! first time makes the argument count four, a second time makes the
! argument count sixteen, and so on.
! By default, this is not bound to a key.
  @end ftable
  
***************
*** 1122,1125 ****
--- 1130,1139 ----
  @item history-expand-line (M-^)
  Perform history expansion on the current line.
+ 
+ @item alias-expand-line
+ Perform alias expansion on the current line (@pxref{Aliases}).
+ 
+ @item history-and-alias-expand-line
+ Perform history and alias expansion on the current line.
  
  @item insert-last-argument (M-., M-_)
diff -Nrc2 bash-2.0/lib/readline/examples/Makefile bash-2.01/lib/readline/examples/Makefile
*** bash-2.0/lib/readline/examples/Makefile	Wed Aug 31 13:59:35 1994
--- bash-2.01/lib/readline/examples/Makefile	Tue Jan 28 13:41:01 1997
***************
*** 1,5 ****
  # This is the Makefile for the examples subdirectory of readline. -*- text -*-
  #
! EXECUTABLES = fileman rltest
  CFLAGS  = -g -I../.. -I..
  LDFLAGS = -g -L..
--- 1,5 ----
  # This is the Makefile for the examples subdirectory of readline. -*- text -*-
  #
! EXECUTABLES = fileman rltest rl
  CFLAGS  = -g -I../.. -I..
  LDFLAGS = -g -L..
***************
*** 10,13 ****
--- 10,17 ----
  all: $(EXECUTABLES)
  
+ 
+ rl: rl.o
+ 	$(CC) $(LDFLAGS) -o $@ rl.o -lreadline -ltermcap
+ 
  fileman: fileman.o
  	$(CC) $(LDFLAGS) -o $@ fileman.o -lreadline -ltermcap
***************
*** 18,19 ****
--- 22,24 ----
  fileman.o: fileman.c
  rltest.o: rltest.c
+ rl.o: rl.c
diff -Nrc2 bash-2.0/lib/readline/examples/fileman.c bash-2.01/lib/readline/examples/fileman.c
*** bash-2.0/lib/readline/examples/fileman.c	Wed Jan 31 12:52:14 1996
--- bash-2.01/lib/readline/examples/fileman.c	Wed Jan 29 12:03:11 1997
***************
*** 2,14 ****
     GNU Readline library.  This application interactively allows users
     to manipulate files and their modes. */
  
- #include <stdio.h>
  #include <sys/types.h>
  #include <sys/file.h>
  #include <sys/stat.h>
- #include <sys/errno.h>
  
! #include <readline/readline.h>
! #include <readline/history.h>
  
  extern char *getwd ();
--- 2,37 ----
     GNU Readline library.  This application interactively allows users
     to manipulate files and their modes. */
+ /*
+  * Remove the next line if you're compiling this against an installed
+  * libreadline.a
+  */
+ #define READLINE_LIBRARY
+ 
+ #ifdef HAVE_CONFIG_H
+ #include <config.h>
+ #endif
  
  #include <sys/types.h>
+ #ifdef HAVE_SYS_FILE_H
  #include <sys/file.h>
+ #endif
  #include <sys/stat.h>
  
! #include <stdio.h>
! #include <errno.h>
! 
! #if defined (HAVE_STRING_H)
! #  include <string.h>
! #else /* !HAVE_STRING_H */
! #  include <strings.h>
! #endif /* !HAVE_STRING_H */
! 
! #ifdef READLINE_LIBRARY
! #  include "readline.h"
! #  include "history.h"
! #else
! #  include <readline/readline.h>
! #  include <readline/history.h>
! #endif
  
  extern char *getwd ();
***************
*** 55,59 ****
  char *
  dupstr (s)
!      int s;
  {
    char *r;
--- 78,82 ----
  char *
  dupstr (s)
!      char *s;
  {
    char *r;
***************
*** 305,309 ****
    printf ("Statistics for `%s':\n", arg);
  
!   printf ("%s has %d link%s, and is %d byte%s in length.\n", arg,
            finfo.st_nlink,
            (finfo.st_nlink == 1) ? "" : "s",
--- 328,333 ----
    printf ("Statistics for `%s':\n", arg);
  
!   printf ("%s has %d link%s, and is %d byte%s in length.\n",
! 	  arg,
            finfo.st_nlink,
            (finfo.st_nlink == 1) ? "" : "s",
diff -Nrc2 bash-2.0/lib/readline/examples/rl.c bash-2.01/lib/readline/examples/rl.c
*** bash-2.0/lib/readline/examples/rl.c	Wed Dec 31 19:00:00 1969
--- bash-2.01/lib/readline/examples/rl.c	Wed Jan 29 11:54:31 1997
***************
*** 0 ****
--- 1,115 ----
+ /*
+  * rl - command-line interface to read a line from the standard input
+  *      (or another fd) using readline.
+  *
+  * usage: rl [-p prompt] [-u unit] [-d default]
+  */
+ 
+ /*
+  * Remove the next line if you're compiling this against an installed
+  * libreadline.a
+  */
+ #define READLINE_LIBRARY
+ 
+ #if defined (HAVE_CONFIG_H)
+ #include <config.h>
+ #endif
+ 
+ #include <stdio.h>
+ #include <sys/types.h>
+ #include "posixstat.h"
+ #include "readline.h"
+ #include "history.h"
+ 
+ extern int optind;
+ extern char *optarg;
+ 
+ extern char *strrchr();
+ 
+ static char *progname;
+ static char *deftext;
+ 
+ static int
+ set_deftext ()
+ {
+   if (deftext)
+     {
+       rl_insert_text (deftext);
+       deftext = (char *)NULL;
+       rl_startup_hook = (Function *)NULL;
+     }
+ }
+ 
+ usage()
+ {
+   fprintf (stderr, "%s: usage: %s [-p prompt] [-u unit] [-d default]\n",
+ 		progname, progname);
+ }
+ 
+ main (argc, argv)
+      int argc;
+      char **argv;
+ {
+   char *temp, *prompt;
+   struct stat sb;
+   int done, opt, fd;
+   FILE *ifp;
+ 
+   progname = strrchr(argv[0], '/');
+   if (progname == 0)
+     progname = argv[0];
+   else
+     progname++;
+ 
+   /* defaults */
+   prompt = "readline$ ";
+   fd = 0;
+   deftext = (char *)0;
+ 
+   while ((opt = getopt(argc, argv, "p:u:d:")) != EOF)
+     {
+       switch (opt)
+ 	{
+ 	case 'p':
+ 	  prompt = optarg;
+ 	  break;
+ 	case 'u':
+ 	  fd = atoi(optarg);
+ 	  if (fd < 0)
+ 	    {
+ 	      fprintf (stderr, "%s: bad file descriptor `%s'\n", progname, optarg);
+ 	      exit (2);
+ 	    }
+ 	  break;
+ 	case 'd':
+ 	  deftext = optarg;
+ 	  break;
+ 	default:
+ 	  usage ();
+ 	  exit (2);
+ 	}
+     }
+ 
+   if (fd != 0)
+     {
+       if (fstat (fd, &sb) < 0)
+ 	{
+ 	  fprintf (stderr, "%s: %d: bad file descriptor\n", progname, fd);
+ 	  exit (1);
+ 	}
+       ifp = fdopen (fd, "r");
+       rl_instream = ifp;
+     }
+ 
+   if (deftext && *deftext)
+     rl_startup_hook = set_deftext;
+ 
+   temp = readline (prompt);
+ 
+   /* Test for EOF. */
+   if (temp == 0)
+     exit (1);
+ 
+   puts (temp);
+   exit (0);
+ }
diff -Nrc2 bash-2.0/lib/readline/examples/rltest.c bash-2.01/lib/readline/examples/rltest.c
*** bash-2.0/lib/readline/examples/rltest.c	Wed Aug 31 14:00:52 1994
--- bash-2.01/lib/readline/examples/rltest.c	Wed Jan 29 11:54:28 1997
***************
*** 5,12 ****
  /* **************************************************************** */
  
  #include <stdio.h>
  #include <sys/types.h>
! #include "../readline.h"
! #include "../history.h"
  
  main ()
--- 5,22 ----
  /* **************************************************************** */
  
+ /*
+  * Remove the next line if you're compiling this against an installed
+  * libreadline.a
+  */
+ #define READLINE_LIBRARY
+ 
+ #if defined (HAVE_CONFIG_H)
+ #include <config.h>
+ #endif
+ 
  #include <stdio.h>
  #include <sys/types.h>
! #include "readline.h"
! #include "history.h"
  
  main ()
diff -Nrc2 bash-2.0/lib/readline/funmap.c bash-2.01/lib/readline/funmap.c
*** bash-2.0/lib/readline/funmap.c	Wed Oct  9 12:09:18 1996
--- bash-2.01/lib/readline/funmap.c	Mon Mar  3 15:50:48 1997
***************
*** 77,80 ****
--- 77,81 ----
    { "downcase-word", rl_downcase_word },
    { "dump-functions", rl_dump_functions },
+   { "dump-macros", rl_dump_macros },
    { "dump-variables", rl_dump_variables },
    { "emacs-editing-mode", rl_emacs_editing_mode },
diff -Nrc2 bash-2.0/lib/readline/histexpand.c bash-2.01/lib/readline/histexpand.c
*** bash-2.0/lib/readline/histexpand.c	Fri Oct 25 14:37:45 1996
--- bash-2.01/lib/readline/histexpand.c	Wed Mar 26 13:17:27 1997
***************
*** 60,68 ****
  extern int history_offset;
  
- #if defined (SHELL)
  extern char *single_quote ();
- #else
- static char *single_quote ();
- #endif /* !SHELL */
  static char *quote_breaks ();
  
--- 60,64 ----
***************
*** 92,95 ****
--- 88,95 ----
  int history_quotes_inhibit_expansion = 0;
  
+ /* If set, this points to a function that is called to verify that a
+    particular history expansion should be performed. */
+ Function *history_inhibit_expansion_function;
+ 
  /* **************************************************************** */
  /*								    */
***************
*** 290,325 ****
  }
  
- #if !defined (SHELL)
- /* Does shell-like quoting using single quotes. */
- static char *
- single_quote (string)
-      char *string;
- {
-   register int c;
-   char *result, *r, *s;
- 
-   result = (char *)xmalloc (3 + (3 * strlen (string)));
-   r = result;
-   *r++ = '\'';
- 
-   for (s = string; s && (c = *s); s++)
-     {
-       *r++ = c;
- 
-       if (c == '\'')
- 	{
- 	  *r++ = '\\';	/* insert escaped single quote */
- 	  *r++ = '\'';
- 	  *r++ = '\'';	/* start new quoted string */
- 	}
-     }
- 
-   *r++ = '\'';
-   *r = '\0';
- 
-   return (result);
- }
- #endif /* !SHELL */
- 
  static char *
  quote_breaks (s)
--- 290,293 ----
***************
*** 889,905 ****
  	      if (!cc || member (cc, history_no_expand_chars))
  		continue;
! #if defined (SHELL)
! 	      /* The shell uses ! as a pattern negation character
! 		 in globbing [...] expressions, so let those pass
! 		 without expansion. */
! 	      else if (i > 0 && (string[i - 1] == '[') &&
! 		       member (']', string + i + 1))
! 		continue;
! 	      /* The shell uses ! as the indirect expansion character, so
! 		 let those expansions pass as well. */
! 	      else if (i > 1 && string[i - 1] == '{' && string[i - 2] == '$' &&
! 		       member ('}', string + i + 1))
  		continue;
- #endif /* SHELL */
  	      else
  		break;
--- 857,868 ----
  	      if (!cc || member (cc, history_no_expand_chars))
  		continue;
! 	      /* If the calling application has set
! 		 history_inhibit_expansion_function to a function that checks
! 		 for special cases that should not be history expanded,
! 		 call the function and skip the expansion if it returns a
! 		 non-zero value. */
! 	      else if (history_inhibit_expansion_function &&
! 			(*history_inhibit_expansion_function) (string, i))
  		continue;
  	      else
  		break;
diff -Nrc2 bash-2.0/lib/readline/histfile.c bash-2.01/lib/readline/histfile.c
*** bash-2.0/lib/readline/histfile.c	Mon Mar 27 14:56:04 1995
--- bash-2.01/lib/readline/histfile.c	Wed Mar 26 14:20:19 1997
***************
*** 53,56 ****
--- 53,66 ----
  #endif /* !HAVE_STRING_H */
  
+ #if defined (__EMX__)
+ #  ifndef O_BINARY
+ #    define O_BINARY 0
+ #  endif
+ #else /* !__EMX__ */
+    /* If we're not compiling for __EMX__, we don't want this at all.  Ever. */
+ #  undef O_BINARY
+ #  define O_BINARY 0
+ #endif /* !__EMX__ */
+ 
  #include <errno.h>
  #if !defined (errno)
***************
*** 61,64 ****
--- 71,77 ----
  #include "histlib.h"
  
+ /* Functions imported from shell.c */
+ extern char *get_env_value ();
+ 
  extern char *xmalloc (), *xrealloc ();
  
***************
*** 78,82 ****
      return (return_val);
    
!   home = getenv ("HOME");
  
    if (home == 0)
--- 91,95 ----
      return (return_val);
    
!   home = get_env_value ("HOME");
  
    if (home == 0)
***************
*** 122,126 ****
  
    input = history_filename (filename);
!   file = open (input, O_RDONLY, 0666);
  
    if ((file < 0) || (fstat (file, &finfo) == -1))
--- 135,139 ----
  
    input = history_filename (filename);
!   file = open (input, O_RDONLY|O_BINARY, 0666);
  
    if ((file < 0) || (fstat (file, &finfo) == -1))
***************
*** 195,203 ****
    register int i;
    int file, chars_read;
!   char *buffer = (char *)NULL, *filename;
    struct stat finfo;
  
    filename = history_filename (fname);
!   file = open (filename, O_RDONLY, 0666);
  
    if (file == -1 || fstat (file, &finfo) == -1)
--- 208,217 ----
    register int i;
    int file, chars_read;
!   char *buffer, *filename;
    struct stat finfo;
  
+   buffer = (char *)NULL;
    filename = history_filename (fname);
!   file = open (filename, O_RDONLY|O_BINARY, 0666);
  
    if (file == -1 || fstat (file, &finfo) == -1)
***************
*** 233,237 ****
    /* Write only if there are more lines in the file than we want to
       truncate to. */
!   if (i && ((file = open (filename, O_WRONLY|O_TRUNC, 0666)) != -1))
      {
        write (file, buffer + i, finfo.st_size - i);
--- 247,251 ----
    /* Write only if there are more lines in the file than we want to
       truncate to. */
!   if (i && ((file = open (filename, O_WRONLY|O_TRUNC|O_BINARY, 0666)) != -1))
      {
        write (file, buffer + i, finfo.st_size - i);
***************
*** 256,263 ****
  {
    register int i;
!   char *output = history_filename (filename);
    int file, mode;
  
!   mode = overwrite ? O_WRONLY | O_CREAT | O_TRUNC : O_WRONLY | O_APPEND;
  
    if ((file = open (output, mode, 0666)) == -1)
--- 270,278 ----
  {
    register int i;
!   char *output;
    int file, mode;
  
!   mode = overwrite ? O_WRONLY|O_CREAT|O_TRUNC|O_BINARY : O_WRONLY|O_APPEND|O_BINARY;
!   output = history_filename (filename);
  
    if ((file = open (output, mode, 0666)) == -1)
diff -Nrc2 bash-2.0/lib/readline/history.h bash-2.01/lib/readline/history.h
*** bash-2.0/lib/readline/history.h	Wed Mar 29 15:58:58 1995
--- bash-2.01/lib/readline/history.h	Wed Mar 26 11:57:22 1997
***************
*** 23,26 ****
--- 23,34 ----
  #define _HISTORY_H_
  
+ #if !defined (_FUNCTION_DEF)
+ #  define _FUNCTION_DEF
+ typedef int Function ();
+ typedef void VFunction ();
+ typedef char *CPFunction ();
+ typedef char **CPPFunction ();
+ #endif
+ 
  /* The structure used to store a history entry. */
  typedef struct _hist_entry {
***************
*** 207,210 ****
--- 215,223 ----
  extern char *history_search_delimiter_chars;
  extern int history_quotes_inhibit_expansion;
+ 
+ /* If set, this function is called to decide whether or not a particular
+    history expansion should be treated as a special case for the calling
+    application and not expanded. */
+ extern Function *history_inhibit_expansion_function;
  
  #endif /* !_HISTORY_H_ */
diff -Nrc2 bash-2.0/lib/readline/isearch.c bash-2.01/lib/readline/isearch.c
*** bash-2.0/lib/readline/isearch.c	Mon Jul  8 13:29:39 1996
--- bash-2.01/lib/readline/isearch.c	Fri Apr 25 15:35:14 1997
***************
*** 31,34 ****
--- 31,36 ----
  #endif
  
+ #include <sys/types.h>
+ 
  #include <stdio.h>
  
***************
*** 37,41 ****
  #endif
  
! #include <sys/types.h>
  
  #include "rldefs.h"
--- 39,47 ----
  #endif
  
! #if defined (HAVE_STDLIB_H)
! #  include <stdlib.h>
! #else
! #  include "ansi_stdlib.h"
! #endif
  
  #include "rldefs.h"
***************
*** 288,292 ****
  	  _rl_restore_prompt();
  	  rl_clear_message ();
! 	  free (allocated_line);
  	  free (lines);
  	  return 0;
--- 294,299 ----
  	  _rl_restore_prompt();
  	  rl_clear_message ();
! 	  if (allocated_line)
! 	    free (allocated_line);
  	  free (lines);
  	  return 0;
***************
*** 404,408 ****
    rl_clear_message ();
  
!   free (allocated_line);
    free (lines);
  
--- 411,416 ----
    rl_clear_message ();
  
!   if (allocated_line)
!     free (allocated_line);
    free (lines);
  
diff -Nrc2 bash-2.0/lib/readline/kill.c bash-2.01/lib/readline/kill.c
*** bash-2.0/lib/readline/kill.c	Thu Jun 27 17:19:58 1996
--- bash-2.01/lib/readline/kill.c	Wed Apr  2 15:20:55 1997
***************
*** 54,57 ****
--- 54,58 ----
  extern void _rl_init_argument ();
  extern int _rl_set_mark_at_pos ();
+ extern void _rl_fix_point ();
  extern void _rl_abort_internal ();
  
***************
*** 385,389 ****
       int count, ignore;
  {
!   return (region_kill_internal (1));
  }
  
--- 386,394 ----
       int count, ignore;
  {
!   int r;
! 
!   r = region_kill_internal (1);
!   _rl_fix_point (1);
!   return r;
  }
  
***************
*** 522,526 ****
    if (rl_editing_mode == vi_mode)
      {
!       rl_vi_append_mode ();
        rl_insert_text (" ");
      }
--- 527,531 ----
    if (rl_editing_mode == vi_mode)
      {
!       rl_vi_append_mode (1, ignore);
        rl_insert_text (" ");
      }
diff -Nrc2 bash-2.0/lib/readline/nls.c bash-2.01/lib/readline/nls.c
*** bash-2.0/lib/readline/nls.c	Fri Nov  1 13:43:20 1996
--- bash-2.01/lib/readline/nls.c	Fri May  2 12:05:47 1997
***************
*** 26,29 ****
--- 26,31 ----
  #endif
  
+ #include <sys/types.h>
+ 
  #if defined (HAVE_UNISTD_H)
  #  include <unistd.h>
***************
*** 47,51 ****
  extern int _rl_output_meta_chars;
  extern int _rl_meta_flag;
!     
  /* A list of legal values for the LANG or LC_CTYPE environment variables.
     If a locale name in this list is the value for the LC_ALL, LC_CTYPE,
--- 49,57 ----
  extern int _rl_output_meta_chars;
  extern int _rl_meta_flag;
! 
! /* Functions imported from shell.c */
! extern char *get_env_value ();
! 
! #if !defined (HAVE_SETLOCALE)    
  /* A list of legal values for the LANG or LC_CTYPE environment variables.
     If a locale name in this list is the value for the LC_ALL, LC_CTYPE,
***************
*** 70,73 ****
--- 76,80 ----
  static char *normalize_codeset ();
  static char *find_codeset ();
+ #endif /* !HAVE_SETLOCALE */
  
  /* Check for LC_ALL, LC_CTYPE, and LANG and use the first with a value
***************
*** 77,86 ****
  _rl_init_eightbit ()
  {
    char *lspec, *t;
    int i;
  
!   lspec = getenv ("LC_ALL");
!   if (lspec == 0) lspec = getenv ("LC_CTYPE");
!   if (lspec == 0) lspec = getenv ("LANG");
    if (lspec == 0 || (t = normalize_codeset (lspec)) == 0)
      return (0);
--- 84,114 ----
  _rl_init_eightbit ()
  {
+ /* If we have setlocale(3), just check the current LC_CTYPE category
+    value, and go into eight-bit mode if it's not C or POSIX. */
+ #if defined (HAVE_SETLOCALE)
+   char *t;
+ 
+   /* Set the LC_CTYPE locale category from environment variables. */
+   t = setlocale (LC_CTYPE, "");
+   if (t && *t && (t[0] != 'C' || t[1]) && (STREQ (t, "POSIX") == 0))
+     {
+       _rl_meta_flag = 1;
+       _rl_convert_meta_chars_to_ascii = 0;
+       _rl_output_meta_chars = 1;
+       return (1);
+     }
+   else
+     return (0);
+ 
+ #else /* !HAVE_SETLOCALE */
    char *lspec, *t;
    int i;
  
!   /* We don't have setlocale.  Finesse it.  Check the environment for the
!      appropriate variables and set eight-bit mode if they have the right
!      values. */
!   lspec = get_env_value ("LC_ALL");
!   if (lspec == 0) lspec = get_env_value ("LC_CTYPE");
!   if (lspec == 0) lspec = get_env_value ("LANG");
    if (lspec == 0 || (t = normalize_codeset (lspec)) == 0)
      return (0);
***************
*** 91,103 ****
  	_rl_convert_meta_chars_to_ascii = 0;
  	_rl_output_meta_chars = 1;
- #if defined (HAVE_SETLOCALE)
- 	setlocale (LC_CTYPE, lspec);
- #endif
  	break;
        }
    free (t);
    return (legal_lang_values[i] ? 1 : 0);
  }
  
  static char *
  normalize_codeset (codeset)
--- 119,131 ----
  	_rl_convert_meta_chars_to_ascii = 0;
  	_rl_output_meta_chars = 1;
  	break;
        }
    free (t);
    return (legal_lang_values[i] ? 1 : 0);
+ 
+ #endif /* !HAVE_SETLOCALE */
  }
  
+ #if !defined (HAVE_SETLOCALE)
  static char *
  normalize_codeset (codeset)
***************
*** 197,198 ****
--- 225,227 ----
    return result;
  }
+ #endif /* !HAVE_SETLOCALE */
diff -Nrc2 bash-2.0/lib/readline/posixdir.h bash-2.01/lib/readline/posixdir.h
*** bash-2.0/lib/readline/posixdir.h	Fri Aug 25 16:35:48 1995
--- bash-2.01/lib/readline/posixdir.h	Thu Jan  2 14:10:32 1997
***************
*** 43,47 ****
  #endif /* !HAVE_DIRENT_H */
  
! #if defined (STRUCT_DIRENT_HAS_D_INO)
  #  define d_fileno d_ino
  #endif
--- 43,47 ----
  #endif /* !HAVE_DIRENT_H */
  
! #if defined (STRUCT_DIRENT_HAS_D_INO) && !defined (STRUCT_DIRENT_HAS_D_FILENO)
  #  define d_fileno d_ino
  #endif
diff -Nrc2 bash-2.0/lib/readline/posixjmp.h bash-2.01/lib/readline/posixjmp.h
*** bash-2.0/lib/readline/posixjmp.h	Wed Dec 31 19:00:00 1969
--- bash-2.01/lib/readline/posixjmp.h	Thu Jan 16 13:54:33 1997
***************
*** 0 ****
--- 1,20 ----
+ /* posixjmp.h -- wrapper for setjmp.h with changes for POSIX systems. */
+ 
+ #ifndef _POSIXJMP_H_
+ #define _POSIXJMP_H_
+ 
+ #include <setjmp.h>
+ 
+ /* This *must* be included *after* config.h */
+ 
+ #if defined (HAVE_POSIX_SIGSETJMP)
+ #  define procenv_t	sigjmp_buf
+ #  undef setjmp
+ #  define setjmp(x)	sigsetjmp((x), 1)
+ #  undef longjmp
+ #  define longjmp(x, n)	siglongjmp((x), (n))
+ #else
+ #  define procenv_t	jmp_buf
+ #endif
+ 
+ #endif /* _POSIXJMP_H_ */
diff -Nrc2 bash-2.0/lib/readline/readline.c bash-2.01/lib/readline/readline.c
*** bash-2.0/lib/readline/readline.c	Wed Dec 11 12:16:06 1996
--- bash-2.01/lib/readline/readline.c	Wed Apr  2 15:22:39 1997
***************
*** 50,59 ****
  #include <signal.h>
  #include <stdio.h>
! #include <setjmp.h>
  
  /* System-specific feature definitions and include files. */
  #include "rldefs.h"
  
! #include "tcap.h"
  
  /* Some standard library routines. */
--- 50,62 ----
  #include <signal.h>
  #include <stdio.h>
! #include "posixjmp.h"
  
  /* System-specific feature definitions and include files. */
  #include "rldefs.h"
  
! #if defined (__EMX__)
! #  define INCL_DOSPROCESS
! #  include <os2.h>
! #endif /* __EMX__ */
  
  /* Some standard library routines. */
***************
*** 61,64 ****
--- 64,72 ----
  #include "history.h"
  
+ #ifndef RL_LIBRARY_VERSION
+ #  define RL_LIBRARY_VERSION "2.1-bash"
+ #endif
+ 
+ /* Evaluates its arguments multiple times. */
  #define SWAP(s, e)  do { int t; t = s; s = e; e = t; } while (0)
  
***************
*** 76,80 ****
  extern int _rl_enable_meta;
  extern int _rl_term_autowrap;
- extern char *term_backspace, *term_clreol, *term_clrpag;
  extern int screenwidth, screenheight, screenchars;
  
--- 84,87 ----
***************
*** 100,106 ****
--- 107,121 ----
  extern int _rl_init_eightbit ();
  
+ /* Functions imported from shell.c */
+ extern char *get_env_value ();
+ 
  /* External redisplay functions and variables from display.c */
  extern void _rl_move_vert ();
  extern void _rl_update_final ();
+ extern void _rl_clear_to_eol ();
+ extern void _rl_clear_screen ();
+ 
+ extern void _rl_save_prompt ();
+ extern void _rl_restore_prompt ();
  
  extern void _rl_erase_at_end_of_line ();
***************
*** 154,157 ****
--- 169,173 ----
  
  #if defined (__GO32__)
+ #  include <go32.h>
  #  include <pc.h>
  #  undef HANDLE_SIGNALS
***************
*** 166,170 ****
  /* **************************************************************** */
  
! char *rl_library_version = "2.1";
  
  /* A pointer to the keymap that is currently in use.
--- 182,186 ----
  /* **************************************************************** */
  
! char *rl_library_version = RL_LIBRARY_VERSION;
  
  /* A pointer to the keymap that is currently in use.
***************
*** 175,178 ****
--- 191,199 ----
  int rl_editing_mode = emacs_mode;
  
+ /* Non-zero if we called this function from _rl_dispatch().  It's present
+    so functions can find out whether they were called from a key binding
+    or directly from an application. */
+ int rl_dispatching;
+ 
  /* Non-zero if the previous command was a kill command. */
  int _rl_last_command_was_kill = 0;
***************
*** 209,213 ****
  
  /* Top level environment for readline_internal (). */
! jmp_buf readline_top_level;
  
  /* The streams we interact with. */
--- 230,234 ----
  
  /* Top level environment for readline_internal (). */
! procenv_t readline_top_level;
  
  /* The streams we interact with. */
***************
*** 361,365 ****
  #if defined (VI_MODE)
        if (rl_editing_mode == vi_mode)
! 	rl_vi_insertion_mode ();
  #endif /* VI_MODE */
      }
--- 382,386 ----
  #if defined (VI_MODE)
        if (rl_editing_mode == vi_mode)
! 	rl_vi_insertion_mode (1, 0);
  #endif /* VI_MODE */
      }
***************
*** 499,502 ****
--- 520,531 ----
  
  void
+ _rl_init_line_state ()
+ {
+   rl_point = rl_end = 0;
+   the_line = rl_line_buffer;
+   the_line[0] = 0;
+ }
+ 
+ void
  _rl_set_the_line ()
  {
***************
*** 552,561 ****
  #endif
  
  	  r = (*map[key].function)(rl_numeric_arg * rl_arg_sign, key);
  
  	  /* If we have input pending, then the last command was a prefix
  	     command.  Don't change the state of rl_last_func.  Otherwise,
  	     remember the last command executed in this variable. */
! 	  if (!rl_pending_input)
  	    rl_last_func = map[key].function;
  	}
--- 581,592 ----
  #endif
  
+ 	  rl_dispatching = 1;
  	  r = (*map[key].function)(rl_numeric_arg * rl_arg_sign, key);
+ 	  rl_dispatching = 0;
  
  	  /* If we have input pending, then the last command was a prefix
  	     command.  Don't change the state of rl_last_func.  Otherwise,
  	     remember the last command executed in this variable. */
! 	  if (!rl_pending_input && map[key].function != rl_digit_argument)
  	    rl_last_func = map[key].function;
  	}
***************
*** 604,608 ****
  /* **************************************************************** */
  
! /* Initliaze readline (and terminal if not already). */
  int
  rl_initialize ()
--- 635,639 ----
  /* **************************************************************** */
  
! /* Initialize readline (and terminal if not already). */
  int
  rl_initialize ()
***************
*** 617,623 ****
  
    /* Initalize the current line information. */
!   rl_point = rl_end = 0;
!   the_line = rl_line_buffer;
!   the_line[0] = 0;
  
    /* We aren't done yet.  We haven't even gotten started yet! */
--- 648,652 ----
  
    /* Initalize the current line information. */
!   _rl_init_line_state ();
  
    /* We aren't done yet.  We haven't even gotten started yet! */
***************
*** 644,653 ****
  }
  
  /* Initialize the entire state of the world. */
  static void
  readline_initialize_everything ()
  {
    /* Find out if we are running in Emacs. */
!   running_in_emacs = getenv ("EMACS") != (char *)0;
  
    /* Set up input and output if they are not already set up. */
--- 673,711 ----
  }
  
+ #if defined (__EMX__)
+ static void
+ _emx_build_environ ()
+ {
+   TIB *tibp;
+   PIB *pibp;
+   char *t, **tp;
+   int c;
+ 
+   DosGetInfoBlocks (&tibp, &pibp);
+   t = pibp->pib_pchenv;
+   for (c = 1; *t; c++)
+     t += strlen (t) + 1;
+   tp = environ = (char **)xmalloc ((c + 1) * sizeof (char *));
+   t = pibp->pib_pchenv;
+   while (*t)
+     {
+       *tp++ = t;
+       t += strlen (t) + 1;
+     }
+   *tp = 0;
+ }
+ #endif /* __EMX__ */
+ 
  /* Initialize the entire state of the world. */
  static void
  readline_initialize_everything ()
  {
+ #if defined (__EMX__)
+   if (environ == 0)
+     _emx_build_environ ();
+ #endif
+ 
    /* Find out if we are running in Emacs. */
!   running_in_emacs = get_env_value ("EMACS") != (char *)0;
  
    /* Set up input and output if they are not already set up. */
***************
*** 665,669 ****
  
    /* Allocate data structures. */
!   if (!rl_line_buffer)
      rl_line_buffer = xmalloc (rl_line_buffer_len = DEFAULT_BUFFER_SIZE);
  
--- 723,727 ----
  
    /* Allocate data structures. */
!   if (rl_line_buffer == 0)
      rl_line_buffer = xmalloc (rl_line_buffer_len = DEFAULT_BUFFER_SIZE);
  
***************
*** 774,782 ****
  rl_digit_loop ()
  {
!   int key, c, sawminus;
  
    _rl_save_prompt ();
  
!   sawminus = 0;
    while (1)
      {
--- 832,840 ----
  rl_digit_loop ()
  {
!   int key, c, sawminus, sawdigits;
  
    _rl_save_prompt ();
  
!   sawminus = sawdigits = 0;
    while (1)
      {
***************
*** 784,811 ****
        key = c = rl_read_key ();
  
        if (_rl_keymap[c].type == ISFUNC &&
  	  _rl_keymap[c].function == rl_universal_argument)
  	{
! 	  rl_numeric_arg *= 4;
! 	  continue;
! 	}
!       c = UNMETA (c);
!       if (_rl_digit_p (c))
! 	{
! 	  rl_numeric_arg = rl_explicit_arg ? (rl_numeric_arg * 10) + c - '0' : c - '0';
! 	  rl_explicit_arg = 1;
! 	}
!       else
! 	{
! 	  if (c == '-' && rl_explicit_arg == 0)
  	    {
! 	      rl_numeric_arg = sawminus = 1;
! 	      rl_arg_sign = -1;
  	    }
  	  else
  	    {
! 	      /* Make M-- command equivalent to M--1 command. */
! 	      if (sawminus && rl_numeric_arg == 1 && rl_explicit_arg == 0)
! 		rl_explicit_arg = 1;
  	      _rl_restore_prompt ();
  	      rl_clear_message ();
--- 842,858 ----
        key = c = rl_read_key ();
  
+       /* If we see a key bound to `universal-argument' after seeing digits,
+ 	 it ends the argument but is otherwise ignored. */
        if (_rl_keymap[c].type == ISFUNC &&
  	  _rl_keymap[c].function == rl_universal_argument)
  	{
! 	  if (sawdigits == 0)
  	    {
! 	      rl_numeric_arg *= 4;
! 	      continue;
  	    }
  	  else
  	    {
! 	      key = rl_read_key ();
  	      _rl_restore_prompt ();
  	      rl_clear_message ();
***************
*** 813,816 ****
--- 860,885 ----
  	    }
  	}
+ 
+       c = UNMETA (c);
+ 
+       if (_rl_digit_p (c))
+ 	{
+ 	  rl_numeric_arg = rl_explicit_arg ? (rl_numeric_arg * 10) + c - '0' : c - '0';
+ 	  sawdigits = rl_explicit_arg = 1;
+ 	}
+       else if (c == '-' && rl_explicit_arg == 0)
+ 	{
+ 	  rl_numeric_arg = sawminus = 1;
+ 	  rl_arg_sign = -1;
+ 	}
+       else
+ 	{
+ 	  /* Make M-- command equivalent to M--1 command. */
+ 	  if (sawminus && rl_numeric_arg == 1 && rl_explicit_arg == 0)
+ 	    rl_explicit_arg = 1;
+ 	  _rl_restore_prompt ();
+ 	  rl_clear_message ();
+ 	  return (_rl_dispatch (key, _rl_keymap));
+ 	}
      }
  
***************
*** 937,940 ****
--- 1006,1031 ----
  }
  
+ /* Fix up point so that it is within the line boundaries after killing
+    text.  If FIX_MARK_TOO is non-zero, the mark is forced within line
+    boundaries also. */
+ 
+ #define _RL_FIX_POINT(x) \
+ 	do { \
+ 	if (x > rl_end) \
+ 	  x = rl_end; \
+ 	else if (x < 0) \
+ 	  x = 0; \
+ 	} while (0)
+ 
+ void
+ _rl_fix_point (fix_mark_too)
+      int fix_mark_too;
+ {
+   _RL_FIX_POINT (rl_point);
+   if (fix_mark_too)
+     _RL_FIX_POINT (rl_mark);
+ }
+ #undef _RL_FIX_POINT
+ 
  /* **************************************************************** */
  /*								    */
***************
*** 1154,1159 ****
    }
  #else /* !__GO32__ */
!   if (term_clreol)
!     tputs (term_clreol, 1, _rl_output_character_function);
  #endif /* !__GO32__ */
  
--- 1245,1249 ----
    }
  #else /* !__GO32__ */
!   _rl_clear_to_eol (0);		/* arg of 0 means to not use spaces */
  #endif /* !__GO32__ */
  
***************
*** 1177,1187 ****
      }
  
! #if !defined (__GO32__)
!   if (term_clrpag)
!     tputs (term_clrpag, 1, _rl_output_character_function);
!   else
! #endif /* !__GO32__ */
!     crlf ();
! 
    rl_forced_update_display ();
    rl_display_fixed = 1;
--- 1267,1271 ----
      }
  
!   _rl_clear_screen ();		/* calls termcap function to clear screen */
    rl_forced_update_display ();
    rl_display_fixed = 1;
***************
*** 1322,1327 ****
  
  #if defined (VI_MODE)
!   _rl_vi_done_inserting ();
!   _rl_vi_reset_last ();
  #endif /* VI_MODE */
  
--- 1406,1414 ----
  
  #if defined (VI_MODE)
!   if (rl_editing_mode == vi_mode)
!     {
!       _rl_vi_done_inserting ();
!       _rl_vi_reset_last ();
!     }
  #endif /* VI_MODE */
  
***************
*** 1633,1640 ****
  
    rl_point += count;
!   if (rl_point > rl_end)
!     rl_point = rl_end;
!   else if (rl_point < 0)
!     rl_point = 0;
    rl_insert_text (dummy);
  
--- 1720,1724 ----
  
    rl_point += count;
!   _rl_fix_point (0);
    rl_insert_text (dummy);
  
***************
*** 1989,1993 ****
  #if defined (VI_MODE)
    rl_editing_mode = vi_mode;
!   rl_vi_insertion_mode ();
  #endif /* VI_MODE */
    return 0;
--- 2073,2077 ----
  #if defined (VI_MODE)
    rl_editing_mode = vi_mode;
!   rl_vi_insertion_mode (1, key);
  #endif /* VI_MODE */
    return 0;
diff -Nrc2 bash-2.0/lib/readline/readline.h bash-2.01/lib/readline/readline.h
*** bash-2.0/lib/readline/readline.h	Fri Jul  5 12:31:52 1996
--- bash-2.01/lib/readline/readline.h	Tue Mar  4 12:47:29 1997
***************
*** 103,107 ****
  
  /* Things for vi mode. Not available unless readline is compiled -DVI_MODE. */
! extern int rl_vi_check (), rl_vi_textmod_command ();
  extern int
    rl_vi_undo (), rl_vi_redo (), rl_vi_tilde_expand (),
--- 103,107 ----
  
  /* Things for vi mode. Not available unless readline is compiled -DVI_MODE. */
! extern int rl_vi_check ();
  extern int
    rl_vi_undo (), rl_vi_redo (), rl_vi_tilde_expand (),
***************
*** 237,240 ****
--- 237,244 ----
  extern char *rl_readline_name;
  
+ /* The prompt readline uses.  This is set from the argument to
+    readline (), and should not be assigned to directly. */
+ extern char *rl_prompt;
+ 
  /* The line buffer that is in use. */
  extern char *rl_line_buffer;
***************
*** 249,252 ****
--- 253,261 ----
  extern int rl_pending_input;
  
+ /* Non-zero if we called this function from _rl_dispatch().  It's present
+    so functions can find out whether they were called from a key binding
+    or directly from an application. */
+ int rl_dispatching;
+ 
  /* The name of the terminal to use. */
  extern char *rl_terminal_name;
***************
*** 370,373 ****
--- 379,390 ----
     default is a space.  Nothing is added if this is '\0'. */
  extern int rl_completion_append_character;
+ 
+ /* Up to this many items will be displayed in response to a
+    possible-completions call.  After that, we ask the user if she
+    is sure she wants to see them all.  The default value is 100. */
+ extern int rl_completion_query_items;
+ 
+ /* If non-zero, then disallow duplicates in the matches. */
+ extern int rl_ignore_completion_duplicates;
  
  /* If this is non-zero, completion is (temporarily) inhibited, and the
diff -Nrc2 bash-2.0/lib/readline/rldefs.h bash-2.01/lib/readline/rldefs.h
*** bash-2.0/lib/readline/rldefs.h	Thu Nov 21 08:54:05 1996
--- bash-2.01/lib/readline/rldefs.h	Fri Apr 11 13:18:28 1997
***************
*** 41,55 ****
  #endif
  
- #if defined (HAVE_SYS_STREAM_H)
- #  include <sys/stream.h>
- #endif /* HAVE_SYS_STREAM_H */
- #if defined (HAVE_SYS_PTEM_H)
- #  include <sys/ptem.h>
- #  define _IO_PTEM_H		/* work around SVR4.2 1.1.4 bug */
- #endif /* HAVE_SYS_PTEM_H */
- #if defined (HAVE_SYS_PTE_H)
- #  include <sys/pte.h>
- #endif /* HAVE_SYS_PTE_H */
- 
  /* Posix macro to check file in statbuf for directory-ness.
     This requires that <sys/stat.h> be included before this test. */
--- 41,44 ----
diff -Nrc2 bash-2.0/lib/readline/rltty.c bash-2.01/lib/readline/rltty.c
*** bash-2.0/lib/readline/rltty.c	Fri Oct  4 15:19:27 1996
--- bash-2.01/lib/readline/rltty.c	Thu Feb  6 09:14:13 1997
***************
*** 54,57 ****
--- 54,59 ----
  extern int _rl_enable_keypad, _rl_enable_meta;
  
+ extern void _rl_control_keypad ();
+ 
  #if defined (__GO32__)
  #  include <pc.h>
diff -Nrc2 bash-2.0/lib/readline/rltty.h bash-2.01/lib/readline/rltty.h
*** bash-2.0/lib/readline/rltty.h	Wed Mar 29 17:02:45 1995
--- bash-2.01/lib/readline/rltty.h	Fri Apr 11 13:19:09 1997
***************
*** 43,46 ****
--- 43,58 ----
  #endif
  
+ /* Stuff for `struct winsize' on various systems. */
+ #if defined (HAVE_SYS_STREAM_H)
+ #  include <sys/stream.h>
+ #endif /* HAVE_SYS_STREAM_H */
+ #if defined (HAVE_SYS_PTEM_H)
+ #  include <sys/ptem.h>
+ #  define _IO_PTEM_H		/* work around SVR4.2 1.1.4 bug */
+ #endif /* HAVE_SYS_PTEM_H */
+ #if defined (HAVE_SYS_PTE_H)
+ #  include <sys/pte.h>
+ #endif /* HAVE_SYS_PTE_H */
+ 
  /* Define _POSIX_VDISABLE if we are not using the `new' tty driver and
     it is not already defined.  It is used both to determine if a
diff -Nrc2 bash-2.0/lib/readline/search.c bash-2.01/lib/readline/search.c
*** bash-2.0/lib/readline/search.c	Thu Jun 27 17:21:45 1996
--- bash-2.01/lib/readline/search.c	Thu Mar  6 16:26:16 1997
***************
*** 34,42 ****
  #endif
  
  #include "rldefs.h"
  #include "readline.h"
  #include "history.h"
  
! #define abs(x)		(((x) > 0) ? (x) : -(x))
  
  extern char *xmalloc (), *xrealloc ();
--- 34,51 ----
  #endif
  
+ #if defined (HAVE_STDLIB_H)
+ #  include <stdlib.h>
+ #else
+ #  include "ansi_stdlib.h"
+ #endif
+ 
  #include "rldefs.h"
  #include "readline.h"
  #include "history.h"
  
! #ifdef abs
! #  undef abs
! #endif
! #define abs(x)		(((x) >= 0) ? (x) : -(x))
  
  extern char *xmalloc (), *xrealloc ();
diff -Nrc2 bash-2.0/lib/readline/shell.c bash-2.01/lib/readline/shell.c
*** bash-2.0/lib/readline/shell.c	Wed Dec 31 19:00:00 1969
--- bash-2.01/lib/readline/shell.c	Wed Apr 16 15:35:33 1997
***************
*** 0 ****
--- 1,129 ----
+ /* shell.c -- readline utility functions that are normally provided by
+ 	      bash when readline is linked as part of the shell. */
+ 
+ /* Copyright (C) 1997 Free Software Foundation, Inc.
+ 
+    This file is part of the GNU Readline Library, a library for
+    reading lines of text with interactive input and history editing.
+ 
+    The GNU Readline Library is free software; you can redistribute it
+    and/or modify it under the terms of the GNU General Public License
+    as published by the Free Software Foundation; either version 1, or
+    (at your option) any later version.
+ 
+    The GNU Readline Library is distributed in the hope that it will be
+    useful, but WITHOUT ANY WARRANTY; without even the implied warranty
+    of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+ 
+    The GNU General Public License is often shipped with GNU software, and
+    is generally kept in a file called COPYING or LICENSE.  If you do not
+    have a copy of the license, write to the Free Software Foundation,
+    675 Mass Ave, Cambridge, MA 02139, USA. */
+ #define READLINE_LIBRARY
+ 
+ #if defined (HAVE_CONFIG_H)
+ #  include <config.h>
+ #endif
+ 
+ #if defined (HAVE_UNISTD_H)
+ #  include <unistd.h>
+ #endif /* HAVE_UNISTD_H */
+ 
+ #if defined (HAVE_STDLIB_H)
+ #  include <stdlib.h>
+ #else
+ #  include "ansi_stdlib.h"
+ #endif /* HAVE_STDLIB_H */
+ 
+ extern char *xmalloc (), *xrealloc ();
+ 
+ #if !defined (SHELL)
+ 
+ #ifdef savestring
+ #undef savestring
+ #endif
+ 
+ /* Backwards compatibility, now that savestring has been removed from
+    all `public' readline header files. */
+ char *
+ savestring (s)
+      char *s;
+ {
+   return ((char *)strcpy (xmalloc (1 + (int)strlen (s)), (s)));
+ }
+ 
+ /* Does shell-like quoting using single quotes. */
+ char *
+ single_quote (string)
+      char *string;
+ {
+   register int c;
+   char *result, *r, *s;
+ 
+   result = (char *)xmalloc (3 + (3 * strlen (string)));
+   r = result;
+   *r++ = '\'';
+ 
+   for (s = string; s && (c = *s); s++)
+     {
+       *r++ = c;
+ 
+       if (c == '\'')
+ 	{
+ 	  *r++ = '\\';	/* insert escaped single quote */
+ 	  *r++ = '\'';
+ 	  *r++ = '\'';	/* start new quoted string */
+ 	}
+     }
+ 
+   *r++ = '\'';
+   *r = '\0';
+ 
+   return (result);
+ }
+ 
+ /* Set the environment variables LINES and COLUMNS to lines and cols,
+    respectively. */
+ void
+ set_lines_and_columns (lines, cols)
+      int lines, cols;
+ {
+   char *b;
+ 
+ #if defined (HAVE_PUTENV)
+   b = xmalloc (24);
+   sprintf (b, "LINES=%d", lines);
+   putenv (b);
+   b = xmalloc (24);
+   sprintf (b, "COLUMNS=%d", cols);
+   putenv (b);
+ #else /* !HAVE_PUTENV */
+ #  if defined (HAVE_SETENV)
+   b = xmalloc (8);
+   sprintf (b, "%d", lines);
+   setenv ("LINES", b, 1);
+   b = xmalloc (8);
+   sprintf (b, "%d", cols);
+   setenv ("COLUMNS", b, 1);
+ #  endif /* HAVE_SETENV */
+ #endif /* !HAVE_PUTENV */
+ }
+ 
+ char *
+ get_env_value (varname)
+      char *varname;
+ {
+   return ((char *)getenv (varname));
+ }
+ 
+ #else /* SHELL */
+ extern char *get_string_value ();
+ 
+ char *
+ get_env_value (varname)
+      char *varname;
+ {
+   return get_string_value (varname);
+ }	
+ #endif /* SHELL */
diff -Nrc2 bash-2.0/lib/readline/signals.c bash-2.01/lib/readline/signals.c
*** bash-2.0/lib/readline/signals.c	Fri Oct 18 16:47:47 1996
--- bash-2.01/lib/readline/signals.c	Wed Mar 26 13:47:06 1997
***************
*** 88,91 ****
--- 88,99 ----
  /* **************************************************************** */
  
+ /* If we're not being compiled as part of bash, initialize handlers for
+    and catch the job control signals (SIGTTIN, SIGTTOU, SIGTSTP) and
+    SIGTERM. */
+ #if !defined (SHELL)
+ #  define HANDLE_JOB_SIGNALS
+ #  define HANDLE_SIGTERM
+ #endif /* !SHELL */
+ 
  #if defined (HAVE_POSIX_SIGNALS)
  typedef struct sigaction sighandler_cxt;
***************
*** 98,104 ****
  static sighandler_cxt old_int, old_alrm;
  
! #if !defined (SHELL)
! static sighandler_cxt old_tstp, old_ttou, old_ttin, old_term;
! #endif /* !SHELL */
  
  #if defined (SIGWINCH)
--- 106,116 ----
  static sighandler_cxt old_int, old_alrm;
  
! #if defined (HANDLE_JOB_SIGNALS)
! static sighandler_cxt old_tstp, old_ttou, old_ttin;
! #endif /* HANDLE_JOB_SIGNALS */
! 
! #if defined (HANDLE_SIGTERM)
! static sighandler_cxt old_term;
! #endif
  
  #if defined (SIGWINCH)
***************
*** 117,121 ****
  #  if defined (HAVE_BSD_SIGNALS)
    long omask;
! #  endif /* HAVE_BSD_SIGNALS */
  #endif /* !HAVE_POSIX_SIGNALS */
  
--- 129,135 ----
  #  if defined (HAVE_BSD_SIGNALS)
    long omask;
! #  else /* !HAVE_BSD_SIGNALS */
!   sighandler_cxt dummy_cxt;	/* needed for rl_set_sighandler call */
! #  endif /* !HAVE_BSD_SIGNALS */
  #endif /* !HAVE_POSIX_SIGNALS */
  
***************
*** 124,128 ****
       handler, ignore it until rl_clear_signals resets the catcher. */
    if (sig == SIGINT || sig == SIGALRM)
!     rl_set_sighandler (sig, SIG_IGN, (sighandler_cxt *)NULL);
  #endif /* !HAVE_BSD_SIGNALS && !HAVE_POSIX_SIGNALS */
  
--- 138,142 ----
       handler, ignore it until rl_clear_signals resets the catcher. */
    if (sig == SIGINT || sig == SIGALRM)
!     rl_set_sighandler (sig, SIG_IGN, &dummy_cxt);
  #endif /* !HAVE_BSD_SIGNALS && !HAVE_POSIX_SIGNALS */
  
***************
*** 189,192 ****
--- 203,216 ----
    SigHandler *oh;
  
+ #if defined (MUST_REINSTALL_SIGHANDLERS)
+   sighandler_cxt dummy_winch;
+ 
+   /* We don't want to change old_winch -- it holds the state of SIGWINCH
+      disposition set by the calling application.  We need this state
+      because we call the application's SIGWINCH handler after updating
+      our own idea of the screen size. */
+   rl_set_sighandler (SIGWINCH, rl_handle_sigwinch, &dummy_winch);
+ #endif
+ 
    if (readline_echoing_p)
      {
***************
*** 266,270 ****
  #endif /* HAVE_POSIX_SIGNALS */
  
! #if !defined (SHELL)
  
  #if defined (SIGTSTP)
--- 290,294 ----
  #endif /* HAVE_POSIX_SIGNALS */
  
! #if defined (HANDLE_JOB_SIGNALS)
  
  #if defined (SIGTSTP)
***************
*** 287,293 ****
  #endif /* SIGTTOU */
  
    /* Handle SIGTERM if we're not being compiled as part of bash. */
    rl_set_sighandler (SIGTERM, rl_signal_handler, &old_term);
! #endif /* !SHELL */
  
  #if defined (SIGWINCH)
--- 311,320 ----
  #endif /* SIGTTOU */
  
+ #endif /* HANDLE_JOB_SIGNALS */
+ 
+ #if defined (HANDLE_SIGTERM)
    /* Handle SIGTERM if we're not being compiled as part of bash. */
    rl_set_sighandler (SIGTERM, rl_signal_handler, &old_term);
! #endif /* HANDLE_SIGTERM */
  
  #if defined (SIGWINCH)
***************
*** 310,314 ****
    rl_sigaction (SIGALRM, &old_alrm, &dummy);
  
! #if !defined (SHELL)
  
  #if defined (SIGTSTP)
--- 337,341 ----
    rl_sigaction (SIGALRM, &old_alrm, &dummy);
  
! #if defined (HANDLE_JOB_SIGNALS)
  
  #if defined (SIGTSTP)
***************
*** 321,327 ****
  #endif /* SIGTTOU */
  
!   rl_sigaction (SIGTERM, &old_term, &dummy);
  
! #endif /* !SHELL */
  
  #if defined (SIGWINCH)
--- 348,356 ----
  #endif /* SIGTTOU */
  
! #endif /* HANDLE_JOB_SIGNALS */
  
! #if defined (HANDLE_SIGTERM)
!   rl_sigaction (SIGTERM, &old_term, &dummy);
! #endif /* HANDLE_SIGTERM */
  
  #if defined (SIGWINCH)
diff -Nrc2 bash-2.0/lib/readline/tcap.h bash-2.01/lib/readline/tcap.h
*** bash-2.0/lib/readline/tcap.h	Tue Nov 19 13:42:37 1996
--- bash-2.01/lib/readline/tcap.h	Mon Feb  3 10:11:36 1997
***************
*** 30,33 ****
--- 30,36 ----
  
  #if defined (HAVE_TERMCAP_H)
+ #  if defined (__linux__) && !defined (SPEED_T_IN_SYS_TYPES)
+ #    include "rltty.h"
+ #  endif
  #  include <termcap.h>
  #else
diff -Nrc2 bash-2.0/lib/readline/terminal.c bash-2.01/lib/readline/terminal.c
*** bash-2.0/lib/readline/terminal.c	Thu Nov 21 13:01:39 1996
--- bash-2.01/lib/readline/terminal.c	Wed Apr 16 16:28:12 1997
***************
*** 54,62 ****
  #include "rldefs.h"
  
! #include "tcap.h"
! 
! #if defined (GWINSZ_IN_SYS_IOCTL)
  #  include <sys/ioctl.h>
! #endif /* GWINSZ_IN_SYS_IOCTL */
  
  /* Some standard library routines. */
--- 54,63 ----
  #include "rldefs.h"
  
! #if defined (GWINSZ_IN_SYS_IOCTL) && !defined (TIOCGWINSZ)
  #  include <sys/ioctl.h>
! #endif /* GWINSZ_IN_SYS_IOCTL && !TIOCGWINSZ */
! 
! #include "rltty.h"
! #include "tcap.h"
  
  /* Some standard library routines. */
***************
*** 70,73 ****
--- 71,81 ----
  extern Keymap _rl_keymap;
  
+ /* Functions imported from bind.c */
+ extern void _rl_bind_if_unbound ();
+ 
+ /* Functions imported from shell.c */
+ extern void set_lines_and_columns ();
+ extern char *get_env_value ();
+ 
  /* **************************************************************** */
  /*								    */
***************
*** 85,90 ****
  
  #if !defined (__linux__)
! /* If this causes problems, add back the `extern'. */
! /*extern*/ char PC, *BC, *UP;
  #endif /* __linux__ */
  
--- 93,100 ----
  
  #if !defined (__linux__)
! #  if defined (__EMX__) || defined (NEED_EXTERN_PC)
! extern 
! #  endif /* __EMX__ || NEED_EXTERN_PC */
! char PC, *BC, *UP;
  #endif /* __linux__ */
  
***************
*** 140,182 ****
  int _rl_enable_meta = 1;
  
- /* Re-initialize the terminal considering that the TERM/TERMCAP variable
-    has changed. */
- int
- rl_reset_terminal (terminal_name)
-      char *terminal_name;
- {
-   _rl_init_terminal_io (terminal_name);
-   return 0;
- }
- 
- #if !defined (SHELL)
- static void
- set_lines_and_columns (lines, cols)
-      int lines, cols;
- {
-   char *b;
- 
- #if defined (HAVE_PUTENV)
-   b = xmalloc (24);
-   sprintf (b, "LINES=%d", lines);
-   putenv (b);
-   b = xmalloc (24);
-   sprintf (b, "COLUMNS=%d", cols);
-   putenv (b);
- #else /* !HAVE_PUTENV */
- #  if defined (HAVE_SETENV)
-   b = xmalloc (8);
-   sprintf (b, "%d", lines);
-   setenv ("LINES", b, 1);
-   b = xmalloc (8);
-   sprintf (b, "%d", cols);
-   setenv ("COLUMNS", b, 1);
- #  endif /* HAVE_SETENV */
- #endif /* !HAVE_PUTENV */
- }
- #else /* SHELL */
- extern void set_lines_and_columns ();
- #endif /* SHELL */
- 
  /* Get readline's idea of the screen size.  TTY is a file descriptor open
     to the terminal.  If IGNORE_ENV is true, we do not pay attention to the
--- 150,153 ----
***************
*** 191,194 ****
--- 162,168 ----
    struct winsize window_size;
  #endif /* TIOCGWINSZ */
+ #if defined (__EMX__)
+   int sz[2];
+ #endif
  
  #if defined (TIOCGWINSZ)
***************
*** 200,208 ****
  #endif /* TIOCGWINSZ */
  
    /* Environment variable COLUMNS overrides setting of "co" if IGNORE_ENV
       is unset. */
    if (screenwidth <= 0)
      {
!       if (ignore_env == 0 && (ss = getenv ("COLUMNS")))
  	screenwidth = atoi (ss);
  
--- 174,188 ----
  #endif /* TIOCGWINSZ */
  
+ #if defined (__EMX__)
+   _scrsize (sz);
+   screenwidth = sz[0];
+   screenheight = sz[1];
+ #endif
+ 
    /* Environment variable COLUMNS overrides setting of "co" if IGNORE_ENV
       is unset. */
    if (screenwidth <= 0)
      {
!       if (ignore_env == 0 && (ss = get_env_value ("COLUMNS")))
  	screenwidth = atoi (ss);
  
***************
*** 215,219 ****
    if (screenheight <= 0)
      {
!       if (ignore_env == 0 && (ss = getenv ("LINES")))
  	screenheight = atoi (ss);
  
--- 195,199 ----
    if (screenheight <= 0)
      {
!       if (ignore_env == 0 && (ss = get_env_value ("LINES")))
  	screenheight = atoi (ss);
  
***************
*** 335,339 ****
    Keymap xkeymap;
  
!   term = terminal_name ? terminal_name : getenv ("TERM");
  
    if (term_string_buffer == 0)
--- 315,319 ----
    Keymap xkeymap;
  
!   term = terminal_name ? terminal_name : get_env_value ("TERM");
  
    if (term_string_buffer == 0)
***************
*** 444,447 ****
--- 424,437 ----
  }
  
+ /* Re-initialize the terminal considering that the TERM/TERMCAP variable
+    has changed. */
+ int
+ rl_reset_terminal (terminal_name)
+      char *terminal_name;
+ {
+   _rl_init_terminal_io (terminal_name);
+   return 0;
+ }
+ 
  /* A function for the use of tputs () */
  int
***************
*** 537,541 ****
  }
  
! int
  _rl_enable_meta_key ()
  {
--- 527,531 ----
  }
  
! void
  _rl_enable_meta_key ()
  {
diff -Nrc2 bash-2.0/lib/readline/tilde.c bash-2.01/lib/readline/tilde.c
*** bash-2.0/lib/readline/tilde.c	Wed Aug  7 15:56:56 1996
--- bash-2.01/lib/readline/tilde.c	Thu Apr 10 14:54:41 1997
***************
*** 24,27 ****
--- 24,31 ----
  #endif
  
+ #if defined (HAVE_UNISTD_H)
+ #  include <unistd.h>
+ #endif
+ 
  #if defined (HAVE_STRING_H)
  #  include <string.h>
***************
*** 41,44 ****
--- 45,52 ----
  #include "tilde.h"
  
+ #ifdef SHELL
+ #include "shell.h"
+ #endif
+ 
  #if !defined (HAVE_GETPW_DECLS)
  extern struct passwd *getpwuid (), *getpwnam ();
***************
*** 79,82 ****
--- 87,96 ----
    { " ", "\n", (char *)NULL };
  
+ /* If non-null, this contains the address of a function that the application
+    wants called before trying the standard tilde expansions.  The function
+    is called with the text sans tilde, and returns a malloc()'ed string
+    which is the expansion, or a NULL pointer if the expansion fails. */
+ CPFunction *tilde_expansion_preexpansion_hook = (CPFunction *)NULL;
+ 
  /* If non-null, this contains the address of a function to call if the
     standard meaning for expanding a tilde fails.  The function is called
***************
*** 109,113 ****
    *len = 0;
  
!   if (!*string || *string == '~')
      return (0);
  
--- 123,127 ----
    *len = 0;
  
!   if (*string == '\0' || *string == '~')
      return (0);
  
***************
*** 136,146 ****
  {
    register int i, j, string_len;
!   register char **suffixes = tilde_additional_suffixes;
  
    string_len = strlen (string);
  
    for (i = 0; i < string_len; i++)
      {
!       if (string[i] == '/' || !string[i])
  	break;
  
--- 150,161 ----
  {
    register int i, j, string_len;
!   register char **suffixes;
  
+   suffixes = tilde_additional_suffixes;
    string_len = strlen (string);
  
    for (i = 0; i < string_len; i++)
      {
!       if (string[i] == '/' /* || !string[i] */)
  	break;
  
***************
*** 154,157 ****
--- 169,181 ----
  }
  
+ #if !defined (SHELL)
+ static char *
+ get_string_value (varname)
+      char *varname;
+ {
+   return ((char *)getenv (varname));
+ }
+ #endif
+ 
  /* Return a new string which is the result of tilde expanding STRING. */
  char *
***************
*** 159,167 ****
       char *string;
  {
!   char *result, *tilde_expand_word ();
    int result_size, result_index;
  
!   result_size = result_index = 0;
!   result = (char *)NULL;
  
    /* Scan through STRING expanding tildes as we come to them. */
--- 183,194 ----
       char *string;
  {
!   char *result;
    int result_size, result_index;
  
!   result_index = result_size = 0;
!   if (result = strchr (string, '~'))
!     result = xmalloc (result_size = (strlen (string) + 16));
!   else
!     result = xmalloc (result_size = strlen (string));
  
    /* Scan through STRING expanding tildes as we come to them. */
***************
*** 216,310 ****
  }
  
  /* Do the work of tilde expansion on FILENAME.  FILENAME starts with a
!    tilde.  If there is no expansion, call tilde_expansion_failure_hook. */
  char *
  tilde_expand_word (filename)
       char *filename;
  {
!   char *dirname;
!   char *temp_name;
  
!   if (filename == (char *)0)
      return ((char *)NULL);
  
!   dirname = savestring (filename);
  
!   if (*dirname != '~')
!     return (dirname);
! 
!   if (!dirname[1] || dirname[1] == '/')
      {
!       /* Prepend $HOME to the rest of the string. */
!       char *temp_home = (char *)getenv ("HOME");
!       int home_len;
  
        /* If there is no HOME variable, look up the directory in
  	 the password database. */
!       if (!temp_home)
! 	{
! 	  struct passwd *entry;
! 
! 	  entry = getpwuid (getuid ());
! 	  if (entry)
! 	    temp_home = entry->pw_dir;
! 	}
  
!       home_len = temp_home ? strlen (temp_home) : 0;
!       temp_name = xmalloc (1 + strlen (dirname + 1) + home_len);
! 			     
!       if (temp_home)
! 	strcpy (temp_name, temp_home);
!       strcpy (temp_name + home_len, dirname + 1);
!       free (dirname);
!       dirname = temp_name;
      }
!   else
      {
!       char *username;
!       struct passwd *user_entry;
!       int i, len;
! 
!       username = xmalloc (strlen (dirname));
!       for (i = 1; dirname[i] && dirname[i] != '/'; i++)
! 	username[i - 1] = dirname[i];
!       username[i - 1] = '\0';
  
!       if ((user_entry = getpwnam (username)) == (struct passwd *)0)
  	{
! 	  /* If the calling program has a special syntax for
! 	     expanding tildes, and we couldn't find a standard
! 	     expansion, then let them try. */
! 	  if (tilde_expansion_failure_hook)
  	    {
! 	      char *expansion;
! 
! 	      expansion = (*tilde_expansion_failure_hook) (username);
! 
! 	      if (expansion)
! 		{
! 		  len = strlen (expansion);
! 		  temp_name = xmalloc (1 + len + strlen (dirname + i));
! 		  strcpy (temp_name, expansion);
! 		  strcpy (temp_name + len, dirname + i);
! 		  free (expansion);
! 		  free (dirname);
! 		  dirname = temp_name;
! 		}
  	    }
- 	  /* We shouldn't report errors. */
- 	}
-       else
- 	{
- 	  len = strlen (user_entry->pw_dir);
- 	  temp_name = xmalloc (1 + len + strlen (dirname + i));
- 	  strcpy (temp_name, user_entry->pw_dir);
- 	  strcpy (temp_name + len, dirname + i);
- 	  free (dirname);
- 	  dirname = temp_name;
  	}
-       endpwent ();
        free (username);
      }
  
    return (dirname);
  }
--- 243,383 ----
  }
  
+ /* Take FNAME and return the tilde prefix we want expanded.  If LENP is
+    non-null, the index of the end of the prefix into FNAME is returned in
+    the location it points to. */
+ static char *
+ isolate_tilde_prefix (fname, lenp)
+      char *fname;
+      int *lenp;
+ {
+   char *ret;
+   int i;
+ 
+   ret = xmalloc (strlen (fname));
+   for (i = 1; fname[i] && fname[i] != '/'; i++)
+     ret[i - 1] = fname[i];
+   ret[i - 1] = '\0';
+   if (lenp)
+     *lenp = i;
+   return ret;
+ }
+ 
+ /* Return a string that is PREFIX concatenated with SUFFIX starting at
+    SUFFIND. */
+ static char *
+ glue_prefix_and_suffix (prefix, suffix, suffind)
+      char *prefix, *suffix;
+      int suffind;
+ {
+   char *ret;
+   int plen, slen;
+ 
+   plen = (prefix && *prefix) ? strlen (prefix) : 0;
+   slen = strlen (suffix + suffind);
+   ret = xmalloc (plen + slen + 1);
+   if (prefix && *prefix)
+     strcpy (ret, prefix);
+   strcpy (ret + plen, suffix + suffind);
+   return ret;
+ }
+ 
+ static char *
+ get_home_dir ()
+ {
+   char *home_dir;
+ 
+ #ifdef SHELL
+   home_dir = (char *)NULL;
+   if (current_user.home_dir == 0)
+     get_current_user_info ();
+   home_dir = current_user.home_dir;
+ #else
+   struct passwd *entry;
+ 
+   home_dir = (char *)NULL;
+   entry = getpwuid (getuid ());
+   if (entry)
+     home_dir = entry->pw_dir;
+ #endif
+   return (home_dir);
+ }
+ 
  /* Do the work of tilde expansion on FILENAME.  FILENAME starts with a
!    tilde.  If there is no expansion, call tilde_expansion_failure_hook.
!    This always returns a newly-allocated string, never static storage. */
  char *
  tilde_expand_word (filename)
       char *filename;
  {
!   char *dirname, *expansion, *username;
!   int user_len;
!   struct passwd *user_entry;
  
!   if (filename == 0)
      return ((char *)NULL);
  
!   if (*filename != '~')
!     return (savestring (filename));
  
!   /* A leading `~/' or a bare `~' is *always* translated to the value of
!      $HOME or the home directory of the current user, regardless of any
!      preexpansion hook. */
!   if (filename[1] == '\0' || filename[1] == '/')
      {
!       /* Prefix $HOME to the rest of the string. */
!       expansion = get_string_value ("HOME");
  
        /* If there is no HOME variable, look up the directory in
  	 the password database. */
!       if (expansion == 0)
! 	expansion = get_home_dir ();
  
!       return (glue_prefix_and_suffix (expansion, filename, 1));
      }
! 
!   username = isolate_tilde_prefix (filename, &user_len);
! 
!   if (tilde_expansion_preexpansion_hook)
      {
!       expansion = (*tilde_expansion_preexpansion_hook) (username);
!       if (expansion)
! 	{
! 	  dirname = glue_prefix_and_suffix (expansion, filename, user_len);
! 	  free (username);
! 	  free (expansion);
! 	  return (dirname);
! 	}
!     }
  
!   /* No preexpansion hook, or the preexpansion hook failed.  Look in the
!      password database. */
!   dirname = (char *)NULL;
!   user_entry = getpwnam (username);
!   if (user_entry == 0)
!     {
!       /* If the calling program has a special syntax for expanding tildes,
! 	 and we couldn't find a standard expansion, then let them try. */
!       if (tilde_expansion_failure_hook)
  	{
! 	  expansion = (*tilde_expansion_failure_hook) (username);
! 	  if (expansion)
  	    {
! 	      dirname = glue_prefix_and_suffix (expansion, filename, user_len);
! 	      free (expansion);
  	    }
  	}
        free (username);
+       /* If we don't have a failure hook, or if the failure hook did not
+ 	 expand the tilde, return a copy of what we were passed. */
+       if (dirname == 0)
+ 	dirname = savestring (filename);
+     }
+   else
+     {
+       free (username);
+       dirname = glue_prefix_and_suffix (user_entry->pw_dir, filename, user_len);
      }
  
+   endpwent ();
    return (dirname);
  }
diff -Nrc2 bash-2.0/lib/readline/tilde.h bash-2.01/lib/readline/tilde.h
*** bash-2.0/lib/readline/tilde.h	Wed Mar 29 16:00:30 1995
--- bash-2.01/lib/readline/tilde.h	Tue Apr  8 14:08:15 1997
***************
*** 34,37 ****
--- 34,43 ----
  #endif /* _FUNCTION_DEF */
  
+ /* If non-null, this contains the address of a function that the application
+    wants called before trying the standard tilde expansions.  The function
+    is called with the text sans tilde, and returns a malloc()'ed string
+    which is the expansion, or a NULL pointer if the expansion fails. */
+ extern CPFunction *tilde_expansion_preexpansion_hook;
+ 
  /* If non-null, this contains the address of a function to call if the
     standard meaning for expanding a tilde fails.  The function is called
diff -Nrc2 bash-2.0/lib/readline/undo.c bash-2.01/lib/readline/undo.c
*** bash-2.0/lib/readline/undo.c	Wed Apr 12 15:17:47 1995
--- bash-2.01/lib/readline/undo.c	Fri Jan 24 12:51:09 1997
***************
*** 39,43 ****
  #endif /* HAVE_STDLIB_H */
  
- #include <setjmp.h>
  #include <stdio.h>
  
--- 39,42 ----
diff -Nrc2 bash-2.0/lib/readline/util.c bash-2.01/lib/readline/util.c
*** bash-2.0/lib/readline/util.c	Wed Oct  9 12:11:39 1996
--- bash-2.01/lib/readline/util.c	Wed Mar 26 13:16:40 1997
***************
*** 26,34 ****
  #endif
  
- #include <stdio.h>
  #include <sys/types.h>
  #include <fcntl.h>
! #include <setjmp.h>
! #include <ctype.h>
  
  #if defined (HAVE_UNISTD_H)
--- 26,32 ----
  #endif
  
  #include <sys/types.h>
  #include <fcntl.h>
! #include "posixjmp.h"
  
  #if defined (HAVE_UNISTD_H)
***************
*** 42,45 ****
--- 40,46 ----
  #endif /* HAVE_STDLIB_H */
  
+ #include <stdio.h>
+ #include <ctype.h>
+ 
  /* System-specific feature definitions and include files. */
  #include "rldefs.h"
***************
*** 56,60 ****
  /* Pseudo-globals imported from readline.c */
  extern int readline_echoing_p;
! extern jmp_buf readline_top_level;
  extern int rl_line_buffer_len;
  extern Function *rl_last_func;
--- 57,61 ----
  /* Pseudo-globals imported from readline.c */
  extern int readline_echoing_p;
! extern procenv_t readline_top_level;
  extern int rl_line_buffer_len;
  extern Function *rl_last_func;
***************
*** 243,260 ****
  #endif
  }
- 
- #if !defined (SHELL)
- #ifdef savestring
- #undef savestring
- #endif
- /* Backwards compatibility, now that savestring has been removed from
-    all `public' readline header files. */
- char *
- savestring (s)
-      char *s;
- {
-   return ((char *)strcpy (xmalloc (1 + (int)strlen (s)), (s)));
- }
- #endif /* !SHELL */
  
  /* Function equivalents for the macros defined in chartypes.h. */
--- 244,247 ----
diff -Nrc2 bash-2.0/lib/tilde/Makefile.in bash-2.01/lib/tilde/Makefile.in
*** bash-2.0/lib/tilde/Makefile.in	Mon Feb 26 15:33:28 1996
--- bash-2.01/lib/tilde/Makefile.in	Tue Feb 18 11:15:23 1997
***************
*** 21,33 ****
  MV = mv
  
! CFLAGS = @CFLAGS@ @LOCAL_CFLAGS@
  CPPFLAGS = @CPPFLAGS@
  LDFLAGS = @LDFLAGS@ @LOCAL_LDFLAGS@
  
  DEFS = @DEFS@
  
  INCLUDES = -I. -I../.. -I$(topdir) -I$(topdir)/lib
  
! CCFLAGS = $(CFLAGS) $(DEFS) $(CPPFLAGS) ${INCLUDES}
  
  .c.o:
--- 21,35 ----
  MV = mv
  
! CFLAGS = @CFLAGS@
! LOCAL_CFLAGS = @LOCAL_CFLAGS@
  CPPFLAGS = @CPPFLAGS@
  LDFLAGS = @LDFLAGS@ @LOCAL_LDFLAGS@
  
  DEFS = @DEFS@
+ LOCAL_DEFS = @LOCAL_DEFS@
  
  INCLUDES = -I. -I../.. -I$(topdir) -I$(topdir)/lib
  
! CCFLAGS = $(DEFS) $(LOCAL_DEFS) $(CPPFLAGS) ${INCLUDES} $(LOCAL_CFLAGS) $(CFLAGS)
  
  .c.o:
***************
*** 95,98 ****
  ######################################################################
  
! tilde.o: tilde.h tilde.c
  tilde.o: $(BUILD_DIR)/config.h
--- 97,100 ----
  ######################################################################
  
! tilde.o: tilde.h $(topdir)/ansi_stdlib.h
  tilde.o: $(BUILD_DIR)/config.h
diff -Nrc2 bash-2.0/lib/tilde/tilde.c bash-2.01/lib/tilde/tilde.c
*** bash-2.0/lib/tilde/tilde.c	Wed Aug  7 15:56:56 1996
--- bash-2.01/lib/tilde/tilde.c	Thu Apr 10 14:54:41 1997
***************
*** 24,27 ****
--- 24,31 ----
  #endif
  
+ #if defined (HAVE_UNISTD_H)
+ #  include <unistd.h>
+ #endif
+ 
  #if defined (HAVE_STRING_H)
  #  include <string.h>
***************
*** 41,44 ****
--- 45,52 ----
  #include "tilde.h"
  
+ #ifdef SHELL
+ #include "shell.h"
+ #endif
+ 
  #if !defined (HAVE_GETPW_DECLS)
  extern struct passwd *getpwuid (), *getpwnam ();
***************
*** 79,82 ****
--- 87,96 ----
    { " ", "\n", (char *)NULL };
  
+ /* If non-null, this contains the address of a function that the application
+    wants called before trying the standard tilde expansions.  The function
+    is called with the text sans tilde, and returns a malloc()'ed string
+    which is the expansion, or a NULL pointer if the expansion fails. */
+ CPFunction *tilde_expansion_preexpansion_hook = (CPFunction *)NULL;
+ 
  /* If non-null, this contains the address of a function to call if the
     standard meaning for expanding a tilde fails.  The function is called
***************
*** 109,113 ****
    *len = 0;
  
!   if (!*string || *string == '~')
      return (0);
  
--- 123,127 ----
    *len = 0;
  
!   if (*string == '\0' || *string == '~')
      return (0);
  
***************
*** 136,146 ****
  {
    register int i, j, string_len;
!   register char **suffixes = tilde_additional_suffixes;
  
    string_len = strlen (string);
  
    for (i = 0; i < string_len; i++)
      {
!       if (string[i] == '/' || !string[i])
  	break;
  
--- 150,161 ----
  {
    register int i, j, string_len;
!   register char **suffixes;
  
+   suffixes = tilde_additional_suffixes;
    string_len = strlen (string);
  
    for (i = 0; i < string_len; i++)
      {
!       if (string[i] == '/' /* || !string[i] */)
  	break;
  
***************
*** 154,157 ****
--- 169,181 ----
  }
  
+ #if !defined (SHELL)
+ static char *
+ get_string_value (varname)
+      char *varname;
+ {
+   return ((char *)getenv (varname));
+ }
+ #endif
+ 
  /* Return a new string which is the result of tilde expanding STRING. */
  char *
***************
*** 159,167 ****
       char *string;
  {
!   char *result, *tilde_expand_word ();
    int result_size, result_index;
  
!   result_size = result_index = 0;
!   result = (char *)NULL;
  
    /* Scan through STRING expanding tildes as we come to them. */
--- 183,194 ----
       char *string;
  {
!   char *result;
    int result_size, result_index;
  
!   result_index = result_size = 0;
!   if (result = strchr (string, '~'))
!     result = xmalloc (result_size = (strlen (string) + 16));
!   else
!     result = xmalloc (result_size = strlen (string));
  
    /* Scan through STRING expanding tildes as we come to them. */
***************
*** 216,310 ****
  }
  
  /* Do the work of tilde expansion on FILENAME.  FILENAME starts with a
!    tilde.  If there is no expansion, call tilde_expansion_failure_hook. */
  char *
  tilde_expand_word (filename)
       char *filename;
  {
!   char *dirname;
!   char *temp_name;
  
!   if (filename == (char *)0)
      return ((char *)NULL);
  
!   dirname = savestring (filename);
  
!   if (*dirname != '~')
!     return (dirname);
! 
!   if (!dirname[1] || dirname[1] == '/')
      {
!       /* Prepend $HOME to the rest of the string. */
!       char *temp_home = (char *)getenv ("HOME");
!       int home_len;
  
        /* If there is no HOME variable, look up the directory in
  	 the password database. */
!       if (!temp_home)
! 	{
! 	  struct passwd *entry;
! 
! 	  entry = getpwuid (getuid ());
! 	  if (entry)
! 	    temp_home = entry->pw_dir;
! 	}
  
!       home_len = temp_home ? strlen (temp_home) : 0;
!       temp_name = xmalloc (1 + strlen (dirname + 1) + home_len);
! 			     
!       if (temp_home)
! 	strcpy (temp_name, temp_home);
!       strcpy (temp_name + home_len, dirname + 1);
!       free (dirname);
!       dirname = temp_name;
      }
!   else
      {
!       char *username;
!       struct passwd *user_entry;
!       int i, len;
! 
!       username = xmalloc (strlen (dirname));
!       for (i = 1; dirname[i] && dirname[i] != '/'; i++)
! 	username[i - 1] = dirname[i];
!       username[i - 1] = '\0';
  
!       if ((user_entry = getpwnam (username)) == (struct passwd *)0)
  	{
! 	  /* If the calling program has a special syntax for
! 	     expanding tildes, and we couldn't find a standard
! 	     expansion, then let them try. */
! 	  if (tilde_expansion_failure_hook)
  	    {
! 	      char *expansion;
! 
! 	      expansion = (*tilde_expansion_failure_hook) (username);
! 
! 	      if (expansion)
! 		{
! 		  len = strlen (expansion);
! 		  temp_name = xmalloc (1 + len + strlen (dirname + i));
! 		  strcpy (temp_name, expansion);
! 		  strcpy (temp_name + len, dirname + i);
! 		  free (expansion);
! 		  free (dirname);
! 		  dirname = temp_name;
! 		}
  	    }
- 	  /* We shouldn't report errors. */
- 	}
-       else
- 	{
- 	  len = strlen (user_entry->pw_dir);
- 	  temp_name = xmalloc (1 + len + strlen (dirname + i));
- 	  strcpy (temp_name, user_entry->pw_dir);
- 	  strcpy (temp_name + len, dirname + i);
- 	  free (dirname);
- 	  dirname = temp_name;
  	}
-       endpwent ();
        free (username);
      }
  
    return (dirname);
  }
--- 243,383 ----
  }
  
+ /* Take FNAME and return the tilde prefix we want expanded.  If LENP is
+    non-null, the index of the end of the prefix into FNAME is returned in
+    the location it points to. */
+ static char *
+ isolate_tilde_prefix (fname, lenp)
+      char *fname;
+      int *lenp;
+ {
+   char *ret;
+   int i;
+ 
+   ret = xmalloc (strlen (fname));
+   for (i = 1; fname[i] && fname[i] != '/'; i++)
+     ret[i - 1] = fname[i];
+   ret[i - 1] = '\0';
+   if (lenp)
+     *lenp = i;
+   return ret;
+ }
+ 
+ /* Return a string that is PREFIX concatenated with SUFFIX starting at
+    SUFFIND. */
+ static char *
+ glue_prefix_and_suffix (prefix, suffix, suffind)
+      char *prefix, *suffix;
+      int suffind;
+ {
+   char *ret;
+   int plen, slen;
+ 
+   plen = (prefix && *prefix) ? strlen (prefix) : 0;
+   slen = strlen (suffix + suffind);
+   ret = xmalloc (plen + slen + 1);
+   if (prefix && *prefix)
+     strcpy (ret, prefix);
+   strcpy (ret + plen, suffix + suffind);
+   return ret;
+ }
+ 
+ static char *
+ get_home_dir ()
+ {
+   char *home_dir;
+ 
+ #ifdef SHELL
+   home_dir = (char *)NULL;
+   if (current_user.home_dir == 0)
+     get_current_user_info ();
+   home_dir = current_user.home_dir;
+ #else
+   struct passwd *entry;
+ 
+   home_dir = (char *)NULL;
+   entry = getpwuid (getuid ());
+   if (entry)
+     home_dir = entry->pw_dir;
+ #endif
+   return (home_dir);
+ }
+ 
  /* Do the work of tilde expansion on FILENAME.  FILENAME starts with a
!    tilde.  If there is no expansion, call tilde_expansion_failure_hook.
!    This always returns a newly-allocated string, never static storage. */
  char *
  tilde_expand_word (filename)
       char *filename;
  {
!   char *dirname, *expansion, *username;
!   int user_len;
!   struct passwd *user_entry;
  
!   if (filename == 0)
      return ((char *)NULL);
  
!   if (*filename != '~')
!     return (savestring (filename));
  
!   /* A leading `~/' or a bare `~' is *always* translated to the value of
!      $HOME or the home directory of the current user, regardless of any
!      preexpansion hook. */
!   if (filename[1] == '\0' || filename[1] == '/')
      {
!       /* Prefix $HOME to the rest of the string. */
!       expansion = get_string_value ("HOME");
  
        /* If there is no HOME variable, look up the directory in
  	 the password database. */
!       if (expansion == 0)
! 	expansion = get_home_dir ();
  
!       return (glue_prefix_and_suffix (expansion, filename, 1));
      }
! 
!   username = isolate_tilde_prefix (filename, &user_len);
! 
!   if (tilde_expansion_preexpansion_hook)
      {
!       expansion = (*tilde_expansion_preexpansion_hook) (username);
!       if (expansion)
! 	{
! 	  dirname = glue_prefix_and_suffix (expansion, filename, user_len);
! 	  free (username);
! 	  free (expansion);
! 	  return (dirname);
! 	}
!     }
  
!   /* No preexpansion hook, or the preexpansion hook failed.  Look in the
!      password database. */
!   dirname = (char *)NULL;
!   user_entry = getpwnam (username);
!   if (user_entry == 0)
!     {
!       /* If the calling program has a special syntax for expanding tildes,
! 	 and we couldn't find a standard expansion, then let them try. */
!       if (tilde_expansion_failure_hook)
  	{
! 	  expansion = (*tilde_expansion_failure_hook) (username);
! 	  if (expansion)
  	    {
! 	      dirname = glue_prefix_and_suffix (expansion, filename, user_len);
! 	      free (expansion);
  	    }
  	}
        free (username);
+       /* If we don't have a failure hook, or if the failure hook did not
+ 	 expand the tilde, return a copy of what we were passed. */
+       if (dirname == 0)
+ 	dirname = savestring (filename);
+     }
+   else
+     {
+       free (username);
+       dirname = glue_prefix_and_suffix (user_entry->pw_dir, filename, user_len);
      }
  
+   endpwent ();
    return (dirname);
  }
diff -Nrc2 bash-2.0/lib/tilde/tilde.h bash-2.01/lib/tilde/tilde.h
*** bash-2.0/lib/tilde/tilde.h	Wed Mar 29 16:00:30 1995
--- bash-2.01/lib/tilde/tilde.h	Tue Apr  8 14:08:15 1997
***************
*** 34,37 ****
--- 34,43 ----
  #endif /* _FUNCTION_DEF */
  
+ /* If non-null, this contains the address of a function that the application
+    wants called before trying the standard tilde expansions.  The function
+    is called with the text sans tilde, and returns a malloc()'ed string
+    which is the expansion, or a NULL pointer if the expansion fails. */
+ extern CPFunction *tilde_expansion_preexpansion_hook;
+ 
  /* If non-null, this contains the address of a function to call if the
     standard meaning for expanding a tilde fails.  The function is called
diff -Nrc2 bash-2.0/list.c bash-2.01/list.c
*** bash-2.0/list.c	Thu May 16 13:45:45 1996
--- bash-2.01/list.c	Thu Feb 27 10:20:13 1997
***************
*** 97,100 ****
--- 97,101 ----
  }
  
+ #ifdef INCLUDE_UNUSED
  /* Delete the element of LIST which satisfies the predicate function COMPARER.
     Returns the element that was deleted, so you can dispose of it, or -1 if
***************
*** 127,128 ****
--- 128,130 ----
    return ((GENERIC_LIST *)&global_error_list);
  }
+ #endif
diff -Nrc2 bash-2.0/mailcheck.c bash-2.01/mailcheck.c
*** bash-2.0/mailcheck.c	Fri Nov 22 10:06:05 1996
--- bash-2.01/mailcheck.c	Wed Jan 22 10:44:47 1997
***************
*** 292,298 ****
    char *mp;
  
!   mp = xmalloc (1 + sizeof (DEFAULT_MAIL_DIRECTORY) + strlen (current_user.user_name));
    strcpy (mp, DEFAULT_MAIL_DIRECTORY);
!   strcpy (mp + sizeof (DEFAULT_MAIL_DIRECTORY) - 1, current_user.user_name);
    return (mp);
  }
--- 292,299 ----
    char *mp;
  
!   mp = xmalloc (2 + sizeof (DEFAULT_MAIL_DIRECTORY) + strlen (current_user.user_name));
    strcpy (mp, DEFAULT_MAIL_DIRECTORY);
!   mp[sizeof(DEFAULT_MAIL_DIRECTORY) - 1] = '/';
!   strcpy (mp + sizeof (DEFAULT_MAIL_DIRECTORY), current_user.user_name);
    return (mp);
  }
diff -Nrc2 bash-2.0/make_cmd.c bash-2.01/make_cmd.c
*** bash-2.0/make_cmd.c	Wed Aug  7 15:22:18 1996
--- bash-2.01/make_cmd.c	Tue Mar  4 10:58:04 1997
***************
*** 101,104 ****
--- 101,105 ----
  }
  
+ #ifdef INCLUDE_UNUSED
  WORD_DESC *
  make_word_from_token (token)
***************
*** 112,115 ****
--- 113,117 ----
    return (make_word (tokenizer));
  }
+ #endif
  
  WORD_LIST *
***************
*** 467,488 ****
      {
  
!     case r_output_direction:	/* >foo */
!     case r_output_force:	/* >| foo */
        temp->flags = O_TRUNC | O_WRONLY | O_CREAT;
        break;
  
!     case r_input_direction:	/* <foo */
!     case r_inputa_direction:	/* foo & makes this. */
!       temp->flags = O_RDONLY;
        break;
  
!     case r_appending_to:	/* >>foo */
!       temp->flags = O_APPEND | O_WRONLY | O_CREAT;
        break;
  
!     case r_deblank_reading_until: /* <<-foo */
!     case r_reading_until:	/* << foo */
        break;
  
      case r_close_this:			/* <&- */
      case r_duplicating_input:		/* 1<&2 */
--- 469,493 ----
      {
  
!     case r_output_direction:		/* >foo */
!     case r_output_force:		/* >| foo */
!     case r_err_and_out:			/* command &>filename */
        temp->flags = O_TRUNC | O_WRONLY | O_CREAT;
        break;
  
!     case r_appending_to:		/* >>foo */
!       temp->flags = O_APPEND | O_WRONLY | O_CREAT;
        break;
  
!     case r_input_direction:		/* <foo */
!     case r_inputa_direction:		/* foo & makes this. */
!       temp->flags = O_RDONLY;
        break;
  
!     case r_input_output:		/* <>foo */
!       temp->flags = O_RDWR | O_CREAT;
        break;
  
+     case r_deblank_reading_until: 	/* <<-foo */
+     case r_reading_until:		/* << foo */
      case r_close_this:			/* <&- */
      case r_duplicating_input:		/* 1<&2 */
***************
*** 490,501 ****
      case r_duplicating_input_word:	/* 1<&$foo */
      case r_duplicating_output_word:	/* 1>&$foo */
-       break;
- 
-     case r_err_and_out:		/* command &>filename */
-       temp->flags = O_TRUNC | O_WRONLY | O_CREAT;
-       break;
- 
-     case r_input_output:
-       temp->flags = O_RDWR | O_CREAT;
        break;
  
--- 495,498 ----
diff -Nrc2 bash-2.0/memalloc.h bash-2.01/memalloc.h
*** bash-2.0/memalloc.h	Fri Jul 12 13:26:44 1996
--- bash-2.01/memalloc.h	Tue Jan 14 16:13:50 1997
***************
*** 46,50 ****
  #    endif /* !IBMESA */
  #  else  /* !HAVE_ALLOCA_H */
! #    if defined (hpux_9) && defined (__STDC__) && !defined (alloca)
  extern void *alloca ();
  #    else
--- 46,50 ----
  #    endif /* !IBMESA */
  #  else  /* !HAVE_ALLOCA_H */
! #    if defined (__hpux) && defined (__STDC__) && !defined (alloca)
  extern void *alloca ();
  #    else
***************
*** 52,56 ****
  extern char *alloca ();
  #      endif /* !alloca */
! #    endif /* !hpux_9 || !__STDC__ && !alloca */
  #  endif /* !HAVE_ALLOCA_H */
  #endif /* !__GNUC__ */
--- 52,56 ----
  extern char *alloca ();
  #      endif /* !alloca */
! #    endif /* !__hpux || !__STDC__ && !alloca */
  #  endif /* !HAVE_ALLOCA_H */
  #endif /* !__GNUC__ */
diff -Nrc2 bash-2.0/nojobs.c bash-2.01/nojobs.c
*** bash-2.0/nojobs.c	Mon Oct 21 14:12:42 1996
--- bash-2.01/nojobs.c	Tue Mar 25 10:53:50 1997
***************
*** 59,70 ****
  #endif /* TERMIOS_TTY_DRIVER */
  
  /* For struct winsize on SCO */
  /*   sys/ptem.h has winsize but needs mblk_t from sys/stream.h */
! #if defined (HAVE_SYS_PTEM_H) && defined (TIOCGWINSZ) && defined (SIGWINCH)
! #  if defined (HAVE_SYS_STREAM_H)
! #    include <sys/stream.h>
! #  endif
! #  include <sys/ptem.h>
! #endif
  
  #if defined (_POSIX_VERSION) || !defined (HAVE_KILLPG)
--- 59,72 ----
  #endif /* TERMIOS_TTY_DRIVER */
  
+ #if !defined (STRUCT_WINSIZE_IN_SYS_IOCTL)
  /* For struct winsize on SCO */
  /*   sys/ptem.h has winsize but needs mblk_t from sys/stream.h */
! #  if defined (HAVE_SYS_PTEM_H) && defined (TIOCGWINSZ) && defined (SIGWINCH)
! #    if defined (HAVE_SYS_STREAM_H)
! #      include <sys/stream.h>
! #    endif
! #    include <sys/ptem.h>
! #  endif /* HAVE_SYS_PTEM_H && TIOCGWINSZ && SIGWINCH */
! #endif /* !STRUCT_WINSIZE_IN_SYS_IOCTL */
  
  #if defined (_POSIX_VERSION) || !defined (HAVE_KILLPG)
***************
*** 82,89 ****
--- 84,98 ----
  #endif /* !HAVE_WAITPID */
  
+ /* Return the fd from which we are actually getting input. */
+ #define input_tty() (shell_tty != -1) ? shell_tty : fileno (stderr)
+ 
  #if !defined (errno)
  extern int errno;
  #endif /* !errno */
  
+ #if defined (READLINE)
+ extern void _rl_set_screen_size (); 
+ #endif    
+ 
  extern int interactive, interactive_shell, login_shell;
  extern int subshell_environment;
***************
*** 99,102 ****
--- 108,114 ----
  int already_making_children = 0;
  
+ /* The controlling tty for this shell. */
+ int shell_tty = -1;
+ 
  /* If this is non-zero, $LINES and $COLUMNS are reset after every process
     exits from get_tty_state(). */
***************
*** 224,230 ****
  
  /* Initialize the job control mechanism, and set up the tty stuff. */
! initialize_jobs ()
  {
!   get_tty_state ();
  }
  
--- 236,246 ----
  
  /* Initialize the job control mechanism, and set up the tty stuff. */
! initialize_job_control (force)
!      int force;
  {
!   shell_tty = fileno (stderr);
! 
!   if (interactive)
!     get_tty_state ();
  }
  
***************
*** 239,243 ****
    int tty;
  
!   tty = open ("/dev/tty", O_RDONLY);
    if (tty >= 0 && (ioctl (tty, TIOCGWINSZ, &win) == 0) &&
        win.ws_row > 0 && win.ws_col > 0)
--- 255,259 ----
    int tty;
  
!   tty = input_tty ();
    if (tty >= 0 && (ioctl (tty, TIOCGWINSZ, &win) == 0) &&
        win.ws_row > 0 && win.ws_col > 0)
***************
*** 251,255 ****
  #endif
      }
-   close (tty);
  }
  
--- 267,270 ----
***************
*** 579,584 ****
      return_val = WEXITSTATUS (status);
  
!   if (!WIFSTOPPED (status) && WIFSIGNALED (status) &&
!       (WTERMSIG (status) != SIGINT))
      {
        fprintf (stderr, "%s", strsignal (WTERMSIG (status)));
--- 594,604 ----
      return_val = WEXITSTATUS (status);
  
! #if !defined (DONT_REPORT_SIGPIPE)
!   if ((WIFSTOPPED (status) == 0) && WIFSIGNALED (status) &&
! 	(WTERMSIG (status) != SIGINT))
! #else
!   if ((WIFSTOPPED (status) == 0) && WIFSIGNALED (status) &&
! 	(WTERMSIG (status) != SIGINT) && (WTERMSIG (status) != SIGPIPE))
! #endif
      {
        fprintf (stderr, "%s", strsignal (WTERMSIG (status)));
***************
*** 635,639 ****
    int tty;
  
!   tty = open ("/dev/tty", O_RDONLY);
    if (tty != -1)
      {
--- 655,659 ----
    int tty;
  
!   tty = input_tty ();
    if (tty != -1)
      {
***************
*** 647,651 ****
  #  endif
  #endif
-       close (tty);
        got_tty_state = 1;
        if (check_window_size)
--- 667,670 ----
***************
*** 659,670 ****
    int tty;
  
!   tty = open ("/dev/tty", O_RDONLY);
    if (tty != -1)
      {
        if (got_tty_state == 0)
! 	{
! 	  close (tty);
! 	  return;
! 	}
  #if defined (TERMIOS_TTY_DRIVER)
        tcsetattr (tty, TCSADRAIN, &shell_tty_info);
--- 678,687 ----
    int tty;
  
!   tty = input_tty ();
    if (tty != -1)
      {
        if (got_tty_state == 0)
! 	return;
! 
  #if defined (TERMIOS_TTY_DRIVER)
        tcsetattr (tty, TCSADRAIN, &shell_tty_info);
***************
*** 676,680 ****
  #  endif
  #endif
-       close (tty);
      }
  }
--- 693,696 ----
***************
*** 698,701 ****
--- 714,728 ----
  {
    already_making_children = 1;
+ }
+ 
+ int
+ get_job_by_pid (pid, block)
+      pid_t pid;
+      int block;
+ {
+   int i;
+ 
+   i = find_index_by_pid (pid);
+   return ((i == NO_PID) ? PROC_BAD : i);
  }
  
diff -Nrc2 bash-2.0/oslib.c bash-2.01/oslib.c
*** bash-2.0/oslib.c	Mon Nov  4 16:55:59 1996
--- bash-2.01/oslib.c	Wed Apr 23 10:23:25 1997
***************
*** 106,110 ****
  
  #if !defined (to_lower)
! #  define to_lower(c) (islower(c) ? (c) : toupper(c))
  #endif /* to_lower */
  
--- 106,110 ----
  
  #if !defined (to_lower)
! #  define to_lower(c) (islower(c) ? (c) : tolower(c))
  #endif /* to_lower */
  
***************
*** 281,287 ****
  {
    register int i;
  
!   for (i = 0; i < n; i++)
!     s[i] = '\0';
  }
  #endif
--- 281,288 ----
  {
    register int i;
+   register char *r;
  
!   for (i = 0, r = s; i < n; i++)
!     *r++ = '\0';
  }
  #endif
diff -Nrc2 bash-2.0/parse.y bash-2.01/parse.y
*** bash-2.0/parse.y	Mon Dec 16 10:51:13 1996
--- bash-2.01/parse.y	Wed May 14 15:00:17 1997
***************
*** 103,106 ****
--- 103,107 ----
  static int read_token ();
  static int yylex ();
+ static int parse_arith_cmd ();
  static int read_token_word ();
  static void discard_parser_constructs ();
***************
*** 109,115 ****
--- 110,120 ----
  static void handle_eof_input_unit ();
  static void prompt_again ();
+ #if 0
  static void reset_readline_prompt ();
+ #endif
  static void print_prompt ();
  
+ extern int yyerror ();
+ 
  /* Default prompt strings */
  char *primary_prompt = PPROMPT;
***************
*** 479,493 ****
  	;
  
! for_command:	FOR WORD newline_list DO list DONE
  			{ $$ = make_for_command ($2, add_string_to_list ("\"$@\"", (WORD_LIST *)NULL), $5); }
! 	|	FOR WORD newline_list '{' list '}'
  			{ $$ = make_for_command ($2, add_string_to_list ("$@", (WORD_LIST *)NULL), $5); }
! 	|	FOR WORD ';' newline_list DO list DONE
  			{ $$ = make_for_command ($2, add_string_to_list ("\"$@\"", (WORD_LIST *)NULL), $6); }
! 	|	FOR WORD ';' newline_list '{' list '}'
  			{ $$ = make_for_command ($2, add_string_to_list ("\"$@\"", (WORD_LIST *)NULL), $6); }
! 	|	FOR WORD newline_list IN word_list list_terminator newline_list DO list DONE
  			{ $$ = make_for_command ($2, REVERSE_LIST ($5, WORD_LIST *), $9); }
! 	|	FOR WORD newline_list IN word_list list_terminator newline_list '{' list '}'
  			{ $$ = make_for_command ($2, REVERSE_LIST ($5, WORD_LIST *), $9); }
  	;
--- 484,498 ----
  	;
  
! for_command:	FOR WORD newline_list DO compound_list DONE
  			{ $$ = make_for_command ($2, add_string_to_list ("\"$@\"", (WORD_LIST *)NULL), $5); }
! 	|	FOR WORD newline_list '{' compound_list '}'
  			{ $$ = make_for_command ($2, add_string_to_list ("$@", (WORD_LIST *)NULL), $5); }
! 	|	FOR WORD ';' newline_list DO compound_list DONE
  			{ $$ = make_for_command ($2, add_string_to_list ("\"$@\"", (WORD_LIST *)NULL), $6); }
! 	|	FOR WORD ';' newline_list '{' compound_list '}'
  			{ $$ = make_for_command ($2, add_string_to_list ("\"$@\"", (WORD_LIST *)NULL), $6); }
! 	|	FOR WORD newline_list IN word_list list_terminator newline_list DO compound_list DONE
  			{ $$ = make_for_command ($2, REVERSE_LIST ($5, WORD_LIST *), $9); }
! 	|	FOR WORD newline_list IN word_list list_terminator newline_list '{' compound_list '}'
  			{ $$ = make_for_command ($2, REVERSE_LIST ($5, WORD_LIST *), $9); }
  	;
***************
*** 746,749 ****
--- 751,755 ----
  /* Initial size to allocate for tokens, and the
     amount to grow them by. */
+ #define TOKEN_DEFAULT_INITIAL_SIZE 496
  #define TOKEN_DEFAULT_GROW_SIZE 512
  
***************
*** 827,831 ****
  init_yy_io (get, unget, type, name, location)
       Function *get, *unget;
!      int type;
       char *name;
       INPUT_STREAM location;
--- 833,837 ----
  init_yy_io (get, unget, type, name, location)
       Function *get, *unget;
!      enum stream_type type;
       char *name;
       INPUT_STREAM location;
***************
*** 1223,1227 ****
    pushed_string_list = temp;
  
!   ap->flags |= AL_BEINGEXPANDED;
  
    shell_input_line = s;
--- 1229,1234 ----
    pushed_string_list = temp;
  
!   if (ap)
!     ap->flags |= AL_BEINGEXPANDED;
  
    shell_input_line = s;
***************
*** 1257,1261 ****
    pushed_string_list = pushed_string_list->next;
  
!   t->expander->flags &= ~AL_BEINGEXPANDED;
  
    free ((char *)t);
--- 1264,1269 ----
    pushed_string_list = pushed_string_list->next;
  
!   if (t->expander)
!     t->expander->flags &= ~AL_BEINGEXPANDED;
  
    free ((char *)t);
***************
*** 1540,1555 ****
  	  history_expansion_inhibited = old_hist;
  #  endif
! 
! 	  free (shell_input_line);
! 	  shell_input_line = expansions;
! 	  shell_input_line_len = shell_input_line ?
! 				 strlen (shell_input_line) :
! 				 0;
! 	  if (!shell_input_line_len)
! 	    current_command_line_count--;
! 
! 	  /* We have to force the xrealloc below because we don't know the
! 	     true allocated size of shell_input_line anymore. */
! 	  shell_input_line_size = shell_input_line_len;
  	}
        /* XXX - this is grotesque */
--- 1548,1564 ----
  	  history_expansion_inhibited = old_hist;
  #  endif
! 	  if (expansions != shell_input_line)
! 	    {
! 	      free (shell_input_line);
! 	      shell_input_line = expansions;
! 	      shell_input_line_len = shell_input_line ?
! 					strlen (shell_input_line) : 0;
! 	      if (!shell_input_line_len)
! 		current_command_line_count--;
! 
! 	      /* We have to force the xrealloc below because we don't know
! 	         the true allocated size of shell_input_line anymore. */
! 	      shell_input_line_size = shell_input_line_len;
! 	    }
  	}
        /* XXX - this is grotesque */
***************
*** 1686,1690 ****
      last_lastarg = savestring (last_lastarg);
  
!   parse_and_execute (savestring (command), "PROMPT_COMMAND", 0);
  
    last_shell_builtin = temp_last;
--- 1695,1699 ----
      last_lastarg = savestring (last_lastarg);
  
!   parse_and_execute (savestring (command), "PROMPT_COMMAND", SEVAL_NONINT|SEVAL_NOHIST);
  
    last_shell_builtin = temp_last;
***************
*** 1977,1981 ****
        result = token_to_read;
        if (token_to_read == WORD || token_to_read == ASSIGNMENT_WORD)
! 	yylval.word = word_desc_to_read;
        token_to_read = 0;
        return (result);
--- 1986,1993 ----
        result = token_to_read;
        if (token_to_read == WORD || token_to_read == ASSIGNMENT_WORD)
! 	{
! 	  yylval.word = word_desc_to_read;
! 	  word_desc_to_read = (WORD_DESC *)NULL;
! 	}
        token_to_read = 0;
        return (result);
***************
*** 2067,2073 ****
  	      if (reserved_word_acceptable (last_read_token))
  		{
! 		  parser_state |= PST_DBLPAREN;
! 		  yylval.word = make_word ("let");
! 		  return (WORD);	  
  		}
  	      break;
--- 2079,2105 ----
  	      if (reserved_word_acceptable (last_read_token))
  		{
! 		  int cmdtyp, sline;
! 		  char *wval;
! 
! 		  sline = line_number;
! 		  cmdtyp = parse_arith_cmd (&wval);
! 		  if (cmdtyp == 1)	/* arithmetic command */
! 		    {
! 		      word_desc_to_read = make_word (wval);
! 		      word_desc_to_read->flags = W_QUOTED;
! 		      token_to_read = WORD;
! 		      free (wval);
! 		      yylval.word = make_word ("let");
! 		      return (WORD);
! 		    }
! 		  else if (cmdtyp == 0)	/* nested subshell */
! 		    {
! 		      push_string (wval, 0, (alias_t *)NULL);
! 		      if ((parser_state & PST_CASEPAT) == 0)
! 			parser_state |= PST_SUBSHELL;
! 		      return (character);
! 		    }
! 		  else			/* ERROR */
! 		    return -1;
  		}
  	      break;
***************
*** 2285,2288 ****
--- 2317,2366 ----
  }
  
+ #if defined (DPAREN_ARITHMETIC)
+ /* We've seen a `(('.  Look for the matching `))'.  If we get it, return 1.
+    If not, assume it's a nested subshell for backwards compatibility and
+    return 0.  In any case, put the characters we've consumed into a locally-
+    allocated buffer and make *ep point to that buffer.  Return -1 on an
+    error, for example EOF. */
+ static int
+ parse_arith_cmd (ep)
+      char **ep;
+ {
+   int exp_lineno, rval, c;
+   char *ttok, *token;
+   int ttoklen;
+ 
+   exp_lineno = line_number;
+   ttok = parse_matched_pair (0, '(', ')', &ttoklen, 0);
+   rval = 1;
+   if (ttok == &matched_pair_error)
+     return -1;
+   /* Check that the next character is the closing right paren.  If
+      not, this is a syntax error. ( */
+   if ((c = shell_getc (0)) != ')')
+     rval = 0;
+ 
+   token = xmalloc(ttoklen + 4);
+ 
+   /* (( ... )) -> "..." */
+   token[0] = (rval == 1) ? '"' : '(';
+   strncpy (token + 1, ttok, ttoklen - 1);	/* don't copy the final `)' */
+   if (rval == 1)
+     {
+       token[ttoklen] = '"';
+       token[ttoklen+1] = '\0';
+     }
+   else
+     {
+       token[ttoklen] = ')';
+       token[ttoklen+1] = c;
+       token[ttoklen+2] = '\0';
+     }
+   *ep = token;
+   FREE (ttok);
+   return rval;
+ }
+ #endif /* DPAREN_ARITHMETIC */
+ 
  static int
  read_token_word (character)
***************
*** 2314,2322 ****
    int ttoklen, ttranslen;
  
!   if (token_buffer_size < TOKEN_DEFAULT_GROW_SIZE)
!     {
!       FREE (token);
!       token = xmalloc (token_buffer_size = TOKEN_DEFAULT_GROW_SIZE);
!     }
  
    token_index = 0;
--- 2392,2397 ----
    int ttoklen, ttranslen;
  
!   if (token_buffer_size < TOKEN_DEFAULT_INITIAL_SIZE)
!     token = xrealloc (token, token_buffer_size = TOKEN_DEFAULT_INITIAL_SIZE);
  
    token_index = 0;
***************
*** 2364,2406 ****
  	}
  
- #if defined (DPAREN_ARITHMETIC)
-       /* Parse a ksh-style ((...)) expression. */
-       if (parser_state & PST_DBLPAREN)
- 	{
- 	  int exp_lineno;
- 
- 	  /* If we've already consumed a right paren that should be part of
- 	     the expression, push it back so the paren matching code won't
- 	     return prematurely. */
- 	  if (character == '(')		/* ) */
- 	    shell_ungetc (character);
- 	  exp_lineno = line_number;
- 	  ttok = parse_matched_pair (0, '(', ')', &ttoklen, 0);
- 	  parser_state &= ~PST_DBLPAREN;
- 	  if (ttok == &matched_pair_error)
- 	    return -1;
- 	  /* Check that the next character is the closing right paren.  If
- 	     not, this is a syntax error. ( */
- 	  if (shell_getc (0) != ')')
- 	    {
- 	      FREE (ttok);	/* ( */
- 	      parser_error (exp_lineno, "missing closing `)' for arithmetic expression");
- 	      return -1;
- 	    }
- 	  RESIZE_MALLOCED_BUFFER (token, token_index, ttoklen + 4,
- 				  token_buffer_size, TOKEN_DEFAULT_GROW_SIZE);
- 	  token[token_index++] = '"';
- 	  if (character != '(')		/* ) */
- 	    token[token_index++] = character;
- 	  strncpy (token + token_index, ttok, ttoklen - 1);
- 	  token_index += ttoklen - 1;
- 	  token[token_index++] = '"';
- 	  FREE (ttok);
- 	  dollar_present = all_digits = 0;
- 	  quoted = 1;
- 	  goto got_token;
- 	}
- #endif /* DPAREN_ARITHMETIC */
- 
        /* Parse a matched pair of quote characters. */
        if (shellquote (character))
--- 2439,2442 ----
***************
*** 2439,2443 ****
  	        ttok = parse_matched_pair (cd, '{', '}', &ttoklen, 0);
  	      else if (peek_char == '(')		/* ) */
! 		ttok = parse_matched_pair (cd, '(', ')', &ttoklen, 0);
  	      else
  		ttok = parse_matched_pair (cd, '[', ']', &ttoklen, 0);
--- 2475,2488 ----
  	        ttok = parse_matched_pair (cd, '{', '}', &ttoklen, 0);
  	      else if (peek_char == '(')		/* ) */
! 		{
! 		  /* XXX - push and pop the `(' as a delimiter for use by
! 		     the command-oriented-history code.  This way newlines
! 		     appearing in the $(...) string get added to the
! 		     history literally rather than causing a possibly-
! 		     incorrect `;' to be added. */
! 		  push_delimiter (dstack, peek_char);
! 		  ttok = parse_matched_pair (cd, '(', ')', &ttoklen, 0);
! 		  pop_delimiter (dstack);
! 		}
  	      else
  		ttok = parse_matched_pair (cd, '[', ']', &ttoklen, 0);
***************
*** 2637,2644 ****
    if (*temp)
      {
!       t = ansicstr (temp, tlen, (int *)NULL);
        free (temp);
-       if (lenp)
- 	*lenp = strlen (t);
        return (t);
      }
--- 2682,2687 ----
    if (*temp)
      {
!       t = ansicstr (temp, tlen, (int *)NULL, lenp);
        free (temp);
        return (t);
      }
***************
*** 2894,2898 ****
  	\]	end a sequence of non-printing chars
  */
! #define PROMPT_GROWTH 50
  char *
  decode_prompt_string (string)
--- 2937,2941 ----
  	\]	end a sequence of non-printing chars
  */
! #define PROMPT_GROWTH 48
  char *
  decode_prompt_string (string)
diff -Nrc2 bash-2.0/parser-built bash-2.01/parser-built
*** bash-2.0/parser-built	Mon Dec 16 11:46:23 1996
--- bash-2.01/parser-built	Tue Jul 16 15:53:19 1996
***************
*** 0 ****
--- 1,45 ----
+ typedef union {
+   WORD_DESC *word;		/* the word that we read. */
+   int number;			/* the number that we read. */
+   WORD_LIST *word_list;
+   COMMAND *command;
+   REDIRECT *redirect;
+   ELEMENT element;
+   PATTERN_LIST *pattern;
+ } YYSTYPE;
+ #define	IF	258
+ #define	THEN	259
+ #define	ELSE	260
+ #define	ELIF	261
+ #define	FI	262
+ #define	CASE	263
+ #define	ESAC	264
+ #define	FOR	265
+ #define	SELECT	266
+ #define	WHILE	267
+ #define	UNTIL	268
+ #define	DO	269
+ #define	DONE	270
+ #define	FUNCTION	271
+ #define	IN	272
+ #define	BANG	273
+ #define	TIME	274
+ #define	TIMEOPT	275
+ #define	WORD	276
+ #define	ASSIGNMENT_WORD	277
+ #define	NUMBER	278
+ #define	AND_AND	279
+ #define	OR_OR	280
+ #define	GREATER_GREATER	281
+ #define	LESS_LESS	282
+ #define	LESS_AND	283
+ #define	GREATER_AND	284
+ #define	SEMI_SEMI	285
+ #define	LESS_LESS_MINUS	286
+ #define	AND_GREATER	287
+ #define	LESS_GREATER	288
+ #define	GREATER_BAR	289
+ #define	yacc_EOF	290
+ 
+ 
+ extern YYSTYPE yylval;
diff -Nrc2 bash-2.0/pathexp.c bash-2.01/pathexp.c
*** bash-2.0/pathexp.c	Wed Oct 23 11:55:12 1996
--- bash-2.01/pathexp.c	Mon Apr 14 16:15:21 1997
***************
*** 286,289 ****
--- 286,290 ----
      names[n] = newnames[n];
    names[n] = (char *)NULL;
+   free (newnames);
  }
  
diff -Nrc2 bash-2.0/posixdir.h bash-2.01/posixdir.h
*** bash-2.0/posixdir.h	Fri Aug 25 16:35:48 1995
--- bash-2.01/posixdir.h	Thu Jan  2 14:10:32 1997
***************
*** 43,47 ****
  #endif /* !HAVE_DIRENT_H */
  
! #if defined (STRUCT_DIRENT_HAS_D_INO)
  #  define d_fileno d_ino
  #endif
--- 43,47 ----
  #endif /* !HAVE_DIRENT_H */
  
! #if defined (STRUCT_DIRENT_HAS_D_INO) && !defined (STRUCT_DIRENT_HAS_D_FILENO)
  #  define d_fileno d_ino
  #endif
diff -Nrc2 bash-2.0/posixjmp.h bash-2.01/posixjmp.h
*** bash-2.0/posixjmp.h	Wed Dec 31 19:00:00 1969
--- bash-2.01/posixjmp.h	Thu Jan 16 13:54:33 1997
***************
*** 0 ****
--- 1,20 ----
+ /* posixjmp.h -- wrapper for setjmp.h with changes for POSIX systems. */
+ 
+ #ifndef _POSIXJMP_H_
+ #define _POSIXJMP_H_
+ 
+ #include <setjmp.h>
+ 
+ /* This *must* be included *after* config.h */
+ 
+ #if defined (HAVE_POSIX_SIGSETJMP)
+ #  define procenv_t	sigjmp_buf
+ #  undef setjmp
+ #  define setjmp(x)	sigsetjmp((x), 1)
+ #  undef longjmp
+ #  define longjmp(x, n)	siglongjmp((x), (n))
+ #else
+ #  define procenv_t	jmp_buf
+ #endif
+ 
+ #endif /* _POSIXJMP_H_ */
diff -Nrc2 bash-2.0/posixwait.h bash-2.01/posixwait.h
*** bash-2.0/posixwait.h	Wed Dec 31 19:00:00 1969
--- bash-2.01/posixwait.h	Tue Feb 18 17:24:59 1997
***************
*** 0 ****
--- 1,103 ----
+ /* posixwait.h -- job control definitions from POSIX 1003.1 */
+ 
+ /* Copyright (C) 1997 Free Software Foundation, Inc.
+ 
+    This file is part of GNU Bash, the Bourne Again SHell.
+ 
+    Bash is free software; you can redistribute it and/or modify it under
+    the terms of the GNU General Public License as published by the Free
+    Software Foundation; either version 2, or (at your option) any later
+    version.
+ 
+    Bash is distributed in the hope that it will be useful, but WITHOUT ANY
+    WARRANTY; without even the implied warranty of MERCHANTABILITY or
+    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+    for more details.
+ 
+    You should have received a copy of the GNU General Public License along
+    with Bash; see the file COPYING.  If not, write to the Free Software
+    Foundation, 675 Mass Ave, Cambridge, MA 02139, USA. */
+ 
+ #if !defined (_POSIXWAIT_H_)
+ #  define _POSIXWAIT_H_
+ 
+ /* If _POSIX_VERSION is not defined, we assume that <sys/wait.h> defines
+    a `union wait' and various macros used to manipulate it.  Look in
+    unionwait.h for the things we expect to find. */
+ #if defined (HAVE_SYS_WAIT_H)
+ #  include <sys/wait.h>
+ #else /* !HAVE_SYS_WAIT_H */
+ #  if !defined (_POSIX_VERSION)
+ #    include "unionwait.h"
+ #  endif
+ #endif  /* !HAVE_SYS_WAIT_H */
+ 
+ /* How to get the status of a job.  For Posix, this is just an
+    int, but for other systems we have to crack the union wait. */
+ #if !defined (_POSIX_VERSION)
+ typedef union wait WAIT;
+ #  define WSTATUS(t)  (t.w_status)
+ #else /* _POSIX_VERSION */
+ typedef int WAIT;
+ #  define WSTATUS(t)  (t)
+ #endif /* _POSIX_VERSION */
+ 
+ /* Make sure that parameters to wait3 are defined. */
+ #if !defined (WNOHANG)
+ #  define WNOHANG 1
+ #  define WUNTRACED 2
+ #endif /* WNOHANG */
+ 
+ /* More Posix P1003.1 definitions.  In the POSIX versions, the parameter is
+    passed as an `int', in the non-POSIX version, as `union wait'. */
+ #if defined (_POSIX_VERSION)
+ 
+ #  if !defined (WSTOPSIG)
+ #    define WSTOPSIG(s)       ((s) >> 8)
+ #  endif /* !WSTOPSIG */
+ 
+ #  if !defined (WTERMSIG)
+ #    define WTERMSIG(s)	      ((s) & 0177)
+ #  endif /* !WTERMSIG */
+ 
+ #  if !defined (WEXITSTATUS)
+ #    define WEXITSTATUS(s)    ((s) >> 8)
+ #  endif /* !WEXITSTATUS */
+ 
+ #  if !defined (WIFSTOPPED)
+ #    define WIFSTOPPED(s)     (((s) & 0177) == 0177)
+ #  endif /* !WIFSTOPPED */
+ 
+ #  if !defined (WIFEXITED)
+ #    define WIFEXITED(s)      (((s) & 0377) == 0)
+ #  endif /* !WIFEXITED */
+ 
+ #  if !defined (WIFSIGNALED)
+ #    define WIFSIGNALED(s)    (!WIFSTOPPED(s) && !WIFEXITED(s))
+ #  endif /* !WIFSIGNALED */
+ 
+ #  if !defined (WIFCORED)
+ #    define WIFCORED(s)       ((s) & 0200)
+ #  endif /* !WIFCORED */
+ 
+ #else /* !_POSIX_VERSION */
+ 
+ #  if !defined (WSTOPSIG)
+ #    define WSTOPSIG(s)	      ((s).w_stopsig)
+ #  endif /* !WSTOPSIG */
+ 
+ #  if !defined (WTERMSIG)
+ #    define WTERMSIG(s)	      ((s).w_termsig)
+ #  endif /* !WTERMSIG */
+ 
+ #  if !defined (WEXITSTATUS)
+ #    define WEXITSTATUS(s)    ((s).w_retcode)
+ #  endif /* !WEXITSTATUS */
+ 
+ #  if !defined (WIFCORED)
+ #    define WIFCORED(s)       ((s).w_coredump)
+ #  endif /* !WIFCORED */
+ 
+ #endif /* !_POSIX_VERSION */
+ 
+ #endif /* !_POSIXWAIT_H_ */
diff -Nrc2 bash-2.0/print_cmd.c bash-2.01/print_cmd.c
*** bash-2.0/print_cmd.c	Mon Oct 21 14:07:55 1996
--- bash-2.01/print_cmd.c	Thu Apr 10 09:30:23 1997
***************
*** 37,41 ****
  
  #include "shell.h"
! #include "y.tab.h"
  #include "stdc.h"
  #include "builtins/common.h"
--- 37,41 ----
  
  #include "shell.h"
! #include <y.tab.h>	/* use <...> so we pick it up from the build directory */
  #include "stdc.h"
  #include "builtins/common.h"
***************
*** 48,52 ****
--- 48,56 ----
  static int indentation_amount = 4;
  
+ #if defined (PREFER_STDARG)
  static void cprintf __P((char *, ...));
+ #else
+ static void cprintf ();
+ #endif
  
  static void newline (), indent (), the_printed_command_resize ();
***************
*** 72,76 ****
  static void print_function_def ();
  
! #define PRINTED_COMMAND_GROW_SIZE 1024
  
  char *the_printed_command = (char *)NULL;
--- 76,81 ----
  static void print_function_def ();
  
! #define PRINTED_COMMAND_INITIAL_SIZE 64
! #define PRINTED_COMMAND_GROW_SIZE 128
  
  char *the_printed_command = (char *)NULL;
***************
*** 81,84 ****
--- 86,90 ----
  static int inside_function_def;
  static int skip_this_indent;
+ static int was_heredoc;
  
  /* The depth of the group commands that we are currently printing.  This
***************
*** 103,107 ****
       COMMAND *command;
  {
!   command_string_index = 0;
    make_command_string_internal (command);
    return (the_printed_command);
--- 109,113 ----
       COMMAND *command;
  {
!   command_string_index = was_heredoc = 0;
    make_command_string_internal (command);
    return (the_printed_command);
***************
*** 126,130 ****
  
        if (command->flags & CMD_TIME_PIPELINE)
! 	cprintf ("time ");
  
        if (command->flags & CMD_INVERT_RETURN)
--- 132,140 ----
  
        if (command->flags & CMD_TIME_PIPELINE)
! 	{
! 	  cprintf ("time ");
! 	  if (command->flags & CMD_TIME_POSIX)
! 	    cprintf ("-p ");
! 	}
  
        if (command->flags & CMD_INVERT_RETURN)
***************
*** 196,200 ****
  
  	    case ';':
! 	      cprintf (";");
  
  	      if (inside_function_def)
--- 206,213 ----
  
  	    case ';':
! 	      if (was_heredoc == 0)
! 		cprintf (";");
! 	      else
! 		was_heredoc = 0;
  
  	      if (inside_function_def)
***************
*** 459,469 ****
       REDIRECT *redirects;
  {
    while (redirects)
      {
!       print_redirection (redirects);
        redirects = redirects->next;
        if (redirects)
  	cprintf (" ");
      }
  }
  
--- 472,518 ----
       REDIRECT *redirects;
  {
+   REDIRECT *heredocs, *hdtail, *newredir;
+ 
+   heredocs = (REDIRECT *)NULL;
+   hdtail = heredocs;
+ 
+   was_heredoc = 0;
    while (redirects)
      {
!       /* Defer printing the here documents until we've printed the
! 	 rest of the redirections. */
!       if (redirects->instruction == r_reading_until || redirects->instruction == r_deblank_reading_until)
! 	{
! 	  newredir = copy_redirect (redirects);
! 	  newredir->next = (REDIRECT *)NULL;
! 	  if (heredocs)
! 	    {
! 	      hdtail->next = newredir;
! 	      hdtail = newredir;
! 	    }
! 	  else
! 	    hdtail = heredocs = newredir;
! 	}
!       else
! 	print_redirection (redirects);
! 
        redirects = redirects->next;
        if (redirects)
  	cprintf (" ");
      }
+ 
+   /* Now that we've printed all the other redirections (on one line),
+      print the here documents. */
+   if (heredocs)
+     {
+       cprintf (" "); 
+       for (hdtail = heredocs; hdtail; hdtail = hdtail->next)
+         {
+ 	  print_redirection (hdtail);
+ 	  cprintf ("\n");
+         }
+       dispose_redirects (heredocs);
+       was_heredoc = 1;
+     }
  }
  
***************
*** 472,479 ****
       REDIRECT *redirect;
  {
!   int kill_leading = 0;
!   int redirector = redirect->redirector;
!   WORD_DESC *redirectee = redirect->redirectee.filename;
!   int redir_fd = redirect->redirectee.dest;
  
    switch (redirect->instruction)
--- 521,531 ----
       REDIRECT *redirect;
  {
!   int kill_leading, redirector, redir_fd;
!   WORD_DESC *redirectee;
! 
!   kill_leading = 0;
!   redirectee = redirect->redirectee.filename;
!   redirector = redirect->redirector;
!   redir_fd = redirect->redirectee.dest;
  
    switch (redirect->instruction)
***************
*** 606,610 ****
    old_indent = indentation;
    old_amount = indentation_amount;
!   command_string_index = 0;
  
    if (name && *name)
--- 658,662 ----
    old_indent = indentation;
    old_amount = indentation_amount;
!   command_string_index = was_heredoc = 0;
  
    if (name && *name)
***************
*** 862,868 ****
       int length;
  {
!   if (!the_printed_command)
      {
!       the_printed_command_size = length + 1;
        the_printed_command = xmalloc (the_printed_command_size);
        command_string_index = 0;
--- 914,920 ----
       int length;
  {
!   if (the_printed_command == 0)
      {
!       the_printed_command_size = (length + PRINTED_COMMAND_INITIAL_SIZE - 1) & ~(PRINTED_COMMAND_INITIAL_SIZE - 1);
        the_printed_command = xmalloc (the_printed_command_size);
        command_string_index = 0;
***************
*** 872,877 ****
--- 924,934 ----
        int new;
        new = command_string_index + length + 1;
+ #if 1
+       /* Round up to the next multiple of PRINTED_COMMAND_GROW_SIZE. */
+       new = (new + PRINTED_COMMAND_GROW_SIZE - 1) & ~(PRINTED_COMMAND_GROW_SIZE - 1);
+ #else
        new = new + 2 * PRINTED_COMMAND_GROW_SIZE - 1;
        new -= new % PRINTED_COMMAND_GROW_SIZE;
+ #endif
        the_printed_command_size = new;
        the_printed_command = xrealloc (the_printed_command, the_printed_command_size);
***************
*** 882,893 ****
  
  static void
! xprintf (va_alist)
       va_dcl
  {
    va_list args;
-   char *format;
  
    va_start (args);
!   format = va_arg (args, char *);
    vfprintf (stdout, format, args);
    va_end (args);
--- 939,958 ----
  
  static void
! #if defined (PREFER_STDARG)
! xprintf (const char *format, ...)
! #else
! xprintf (format, va_alist)
!      const char *format;
       va_dcl
+ #endif
  {
    va_list args;
  
+ #if defined (PREFER_STDARG)
+   va_start (args, format);
+ #else
    va_start (args);
! #endif
! 
    vfprintf (stdout, format, args);
    va_end (args);
diff -Nrc2 bash-2.0/shell.c bash-2.01/shell.c
*** bash-2.0/shell.c	Wed Dec 18 15:16:50 1996
--- bash-2.01/shell.c	Wed May 14 13:04:28 1997
***************
*** 319,323 ****
    if (want_initial_help)
      {
!       show_shell_usage (stdout);
        exit (EXECUTION_SUCCESS);
      }
--- 319,323 ----
    if (want_initial_help)
      {
!       show_shell_usage (stdout, 1);
        exit (EXECUTION_SUCCESS);
      }
***************
*** 343,351 ****
      read_but_dont_execute = 1;
  
-   /* If we're in a strict Posix.2 mode, turn on interactive comments and
-      other Posix.2 things. */
-   if (posixly_correct)
-     posix_initialize (posixly_correct);
- 
    if (running_setuid && privileged_mode == 0)
      disable_priv_mode ();
--- 343,346 ----
***************
*** 401,404 ****
--- 396,410 ----
  #endif /* CLOSE_FDS_AT_LOGIN */
  
+   /* If we're in a strict Posix.2 mode, turn on interactive comments and
+      other Posix.2 things. */
+   if (posixly_correct)
+     {
+       posix_initialize (posixly_correct);
+ #if defined (READLINE)
+       if (interactive_shell)
+ 	posix_readline_initialize (posixly_correct);
+ #endif
+     }
+ 
    /* From here on in, the shell must be a normal functioning shell.
       Variables from the environment are expected to be set, etc. */
***************
*** 429,433 ****
  	exit_shell (last_command_exit_value);
        else
! 	locally_skip_execution++;
      }
  
--- 435,445 ----
  	exit_shell (last_command_exit_value);
        else
! 	{
! #if defined (JOB_CONTROL)
! 	  /* Reset job control, since run_startup_files turned it off. */
! 	  set_job_control (interactive_shell);
! #endif
! 	  locally_skip_execution++;
! 	}
      }
  
***************
*** 453,457 ****
    /* If we are invoked as `sh', turn on Posix mode. */
    if (act_like_sh)
!     posix_initialize (posixly_correct = 1);
  
  #if defined (RESTRICTED_SHELL)
--- 465,475 ----
    /* If we are invoked as `sh', turn on Posix mode. */
    if (act_like_sh)
!     {
!       posix_initialize (posixly_correct = 1);
! #if defined (READLINE)
!       if (interactive_shell)
!         posix_readline_initialize (posixly_correct);
! #endif
!     }
  
  #if defined (RESTRICTED_SHELL)
***************
*** 569,572 ****
--- 587,591 ----
  	    {
  	      report_error ("%s: unrecognized option", argv[arg_index]);
+ 	      show_shell_usage (stderr, 0);
  	      exit (EX_USAGE);
  	    }
***************
*** 622,626 ****
  	      if (o_option == 0)
  		{
! 		  list_minus_o_opts ();
  		  break;
  		}
--- 641,645 ----
  	      if (o_option == 0)
  		{
! 		  list_minus_o_opts (-1);
  		  break;
  		}
***************
*** 638,641 ****
--- 657,661 ----
  		{
  		  report_error ("%c%c: unrecognized option", on_or_off, arg_character);
+ 		  show_shell_usage (stderr, 0);
  		  exit (EX_USAGE);
  		}
***************
*** 731,734 ****
--- 751,758 ----
  run_startup_files ()
  {
+ #if defined (JOB_CONTROL)
+   int old_job_control;
+ #endif
+ 
    /* get the rshd case out of the way first. */
    if (interactive_shell == 0 && no_rc == 0 && login_shell == 0 &&
***************
*** 754,757 ****
--- 778,786 ----
      }
  
+ #if defined (JOB_CONTROL)
+   /* Startup files should be run without job control enabled. */
+   old_job_control = set_job_control (0);
+ #endif
+ 
    /* Interactive shell or `-su' shell. */
    if (posixly_correct == 0)		  /* bash, sh */
***************
*** 792,795 ****
--- 821,828 ----
          execute_env_file (get_string_value ("ENV"));
      }
+ 
+ #if defined (JOB_CONTROL)
+   set_job_control (old_job_control);
+ #endif
  }
  
***************
*** 881,885 ****
  	}
      }
!    return (parse_and_execute (savestring (command), "-c", -1));
  }
  #endif /* ONESHOT */
--- 914,918 ----
  	}
      }
!    return (parse_and_execute (savestring (command), "-c", SEVAL_NOHIST));
  }
  #endif /* ONESHOT */
***************
*** 903,906 ****
--- 936,940 ----
  	     becomes $0, and the rest of the arguments become $1...$n */
  	  shell_name = savestring (args->word->word);
+ 	  FREE (dollar_vars[0]);
  	  dollar_vars[0] = savestring (args->word->word);
  	  remember_args (args->next, 1);
***************
*** 925,932 ****
       char *script_name;
  {
!   int fd;
    char *filename, *path_filename;
    unsigned char sample[80];
    int sample_len;
  
    free (dollar_vars[0]);
--- 959,967 ----
       char *script_name;
  {
!   int fd, e;
    char *filename, *path_filename;
    unsigned char sample[80];
    int sample_len;
+   struct stat sb;
  
    free (dollar_vars[0]);
***************
*** 937,940 ****
--- 972,976 ----
    if ((fd < 0) && (errno == ENOENT) && (absolute_program (filename) == 0))
      {
+       e = errno;
        /* If it's not in the current directory, try looking through PATH
  	 for it. */
***************
*** 946,954 ****
  	  fd = open (filename, O_RDONLY);
  	}
      }
  
    if (fd < 0)
      {
!       int e = errno;
        file_error (filename);
        exit ((e == ENOENT) ? EX_NOTFOUND : EX_NOINPUT);
--- 982,992 ----
  	  fd = open (filename, O_RDONLY);
  	}
+       else
+ 	errno = e;
      }
  
    if (fd < 0)
      {
!       e = errno;
        file_error (filename);
        exit ((e == ENOENT) ? EX_NOTFOUND : EX_NOINPUT);
***************
*** 962,966 ****
  	 and report an error and exit if it is. */
        sample_len = read (fd, sample, sizeof (sample));
!       if (sample_len > 0 && (check_binary_file (sample, sample_len)))
  	{
  	  internal_error ("%s: cannot execute binary file", filename);
--- 1000,1016 ----
  	 and report an error and exit if it is. */
        sample_len = read (fd, sample, sizeof (sample));
!       if (sample_len < 0)
! 	{
! 	  e = errno;
! 	  if ((fstat (fd, &sb) == 0) && S_ISDIR (sb.st_mode))
! 	    internal_error ("%s: is a directory", filename);
!           else
! 	    {
! 	      errno = e;
! 	      file_error (filename);
! 	    }
! 	  exit (EX_NOEXEC);
! 	}
!       else if (sample_len > 0 && (check_binary_file (sample, sample_len)))
  	{
  	  internal_error ("%s: cannot execute binary file", filename);
***************
*** 973,976 ****
--- 1023,1028 ----
  #if defined (BUFFERED_INPUT)
    default_buffered_input = fd;
+ #  if 0
+   /* This is never executed. */
    if (default_buffered_input == -1)
      {
***************
*** 978,981 ****
--- 1030,1034 ----
        exit (EX_NOTFOUND);
      }
+ #  endif
    SET_CLOSE_ON_EXEC (default_buffered_input);
  #else /* !BUFFERED_INPUT */
***************
*** 983,987 ****
       large one, in the hopes that any descriptors used by the script will
        not match with ours. */
!   fd = move_to_high_fd (fd, 0);
  
    default_input = fdopen (fd, "r");
--- 1036,1040 ----
       large one, in the hopes that any descriptors used by the script will
        not match with ours. */
!   fd = move_to_high_fd (fd, 0, -1);
  
    default_input = fdopen (fd, "r");
***************
*** 999,1002 ****
--- 1052,1056 ----
  
    if (interactive_shell == 0 || isatty (fd) == 0)
+     /* XXX - does this really need to be called again here? */
      init_noninteractive ();
    else
***************
*** 1103,1106 ****
--- 1157,1187 ----
  }
  
+ void
+ get_current_user_info ()
+ {
+   struct passwd *entry;
+ 
+   /* Don't fetch this more than once. */
+   if (current_user.user_name == 0)
+     {
+       entry = getpwuid (current_user.uid);
+       if (entry)
+ 	{
+ 	  current_user.user_name = savestring (entry->pw_name);
+ 	  current_user.shell = (entry->pw_shell && entry->pw_shell[0])
+ 				? savestring (entry->pw_shell)
+ 				: savestring ("/bin/sh");
+ 	  current_user.home_dir = savestring (entry->pw_dir);
+ 	}
+       else
+ 	{
+ 	  current_user.user_name = savestring ("I have no name!");
+ 	  current_user.shell = savestring ("/bin/sh");
+ 	  current_user.home_dir = savestring ("/");
+ 	}
+       endpwent ();
+     }
+ }
+ 
  /* Do whatever is necessary to initialize the shell.
     Put new initializations in here. */
***************
*** 1108,1112 ****
  shell_initialize ()
  {
-   struct passwd *entry;
    char hostname[256];
  
--- 1189,1192 ----
***************
*** 1129,1133 ****
    if (current_host_name == 0)
      {
!       /* Initialize current_user.name and current_host_name. */
        if (gethostname (hostname, 255) < 0)
  	current_host_name = "??host??";
--- 1209,1213 ----
    if (current_host_name == 0)
      {
!       /* Initialize current_host_name. */
        if (gethostname (hostname, 255) < 0)
  	current_host_name = "??host??";
***************
*** 1136,1159 ****
      }
  
!   /* Don't fetch this more than once. */
!   if (current_user.user_name == 0)
!     {
!       entry = getpwuid (current_user.uid);
!       if (entry)
! 	{
! 	  current_user.user_name = savestring (entry->pw_name);
! 	  current_user.shell = (entry->pw_shell && entry->pw_shell[0])
! 				? savestring (entry->pw_shell)
! 				: savestring ("/bin/sh");
! 	  current_user.home_dir = savestring (entry->pw_dir);
! 	}
!       else
! 	{
! 	  current_user.user_name = savestring ("I have no name!");
! 	  current_user.shell = savestring ("/bin/sh");
! 	  current_user.home_dir = savestring ("/");
! 	}
!       endpwent ();
!     }
  
    /* Initialize our interface to the tilde expander. */
--- 1216,1224 ----
      }
  
!   /* Initialize the stuff in current_user that comes from the password
!      file.  We don't need to do this right away if the shell is not
!      interactive. */
!   if (interactive_shell)
!     get_current_user_info ();
  
    /* Initialize our interface to the tilde expander. */
***************
*** 1169,1177 ****
  #endif
  
    /* Initialize filename hash tables. */
    initialize_filename_hashing ();
  
    /* Initialize the data structures for storing and running jobs. */
!   initialize_jobs ();
  
    /* Initialize input streams to null. */
--- 1234,1244 ----
  #endif
  
+ #if 0
    /* Initialize filename hash tables. */
    initialize_filename_hashing ();
+ #endif
  
    /* Initialize the data structures for storing and running jobs. */
!   initialize_job_control (0);
  
    /* Initialize input streams to null. */
***************
*** 1231,1241 ****
  
  static void
! show_shell_usage (fp)
       FILE *fp;
  {
    int i;
    char *set_opts, *s, *t;
  
!   fprintf (fp, "GNU bash, version %s-(%s)\n", shell_version_string (), MACHTYPE);
    fprintf (fp, "Usage:\t%s [GNU long option] [option] ...\n\t%s [GNU long option] [option] script-file ...\n",
  	     shell_name, shell_name);
--- 1298,1310 ----
  
  static void
! show_shell_usage (fp, extra)
       FILE *fp;
+      int extra;
  {
    int i;
    char *set_opts, *s, *t;
  
!   if (extra)
!     fprintf (fp, "GNU bash, version %s-(%s)\n", shell_version_string (), MACHTYPE);
    fprintf (fp, "Usage:\t%s [GNU long option] [option] ...\n\t%s [GNU long option] [option] script-file ...\n",
  	     shell_name, shell_name);
***************
*** 1264,1270 ****
      }
  
!   fprintf (fp, "Type `%s -c \"help set\"' for more information about shell options.\n", shell_name);
!   fprintf (fp, "Type `%s -c help' for more information about shell builtin commands.\n", shell_name);
!   fprintf (fp, "Use the `bashbug' command to report bugs.\n");
  }
  
--- 1333,1342 ----
      }
  
!   if (extra)
!     {
!       fprintf (fp, "Type `%s -c \"help set\"' for more information about shell options.\n", shell_name);
!       fprintf (fp, "Type `%s -c help' for more information about shell builtin commands.\n", shell_name);
!       fprintf (fp, "Use the `bashbug' command to report bugs.\n");
!     }
  }
  
diff -Nrc2 bash-2.0/shell.h bash-2.01/shell.h
*** bash-2.0/shell.h	Fri May 31 11:09:12 1996
--- bash-2.01/shell.h	Wed Feb 12 15:13:17 1997
***************
*** 117,122 ****
  /* Information about the current user. */
  struct user_info {
!   int uid, euid;
!   int gid, egid;
    char *user_name;
    char *shell;		/* shell from the password file */
--- 117,122 ----
  /* Information about the current user. */
  struct user_info {
!   uid_t uid, euid;
!   gid_t gid, egid;
    char *user_name;
    char *shell;		/* shell from the password file */
diff -Nrc2 bash-2.0/sig.c bash-2.01/sig.c
*** bash-2.0/sig.c	Fri Oct  4 13:00:39 1996
--- bash-2.01/sig.c	Mon May  5 11:25:57 1997
***************
*** 69,78 ****
  int interrupt_immediately = 0;
  
! static void initialize_terminating_signals ();
  
  void
  initialize_signals ()
  {
!   initialize_terminating_signals ();
    initialize_job_signals ();
  #if !defined (HAVE_SYS_SIGLIST) && !defined (HAVE_STRSIGNAL)
--- 69,78 ----
  int interrupt_immediately = 0;
  
! static void initialize_shell_signals ();
  
  void
  initialize_signals ()
  {
!   initialize_shell_signals ();
    initialize_job_signals ();
  #if !defined (HAVE_SYS_SIGLIST) && !defined (HAVE_STRSIGNAL)
***************
*** 84,88 ****
  reinitialize_signals ()
  {
!   initialize_terminating_signals ();
    initialize_job_signals ();
  }
--- 84,88 ----
  reinitialize_signals ()
  {
!   initialize_shell_signals (1);
    initialize_job_signals ();
  }
***************
*** 192,201 ****
  #define XHANDLER(x) (terminating_signals[x].orig_handler)
  
  /* Initialize signals that will terminate the shell to do some
!    unwind protection. */
! static void
  initialize_terminating_signals ()
  {
    register int i;
  
    /* The following code is to avoid an expensive call to
--- 192,210 ----
  #define XHANDLER(x) (terminating_signals[x].orig_handler)
  
+ static int termsigs_initialized = 0;
+ 
  /* Initialize signals that will terminate the shell to do some
!    unwind protection.  For non-interactive shells, we only call
!    this when a trap is defined for EXIT (0). */
! void
  initialize_terminating_signals ()
  {
    register int i;
+ #if defined (HAVE_POSIX_SIGNALS)
+   struct sigaction act, oact;
+ #endif
+ 
+   if (termsigs_initialized)
+     return;
  
    /* The following code is to avoid an expensive call to
***************
*** 204,209 ****
       on non-Posix systems for each signal in terminating_signals. */
  #if defined (HAVE_POSIX_SIGNALS)
-   struct sigaction act, oact;
- 
    act.sa_handler = termination_unwind_protect;
    act.sa_flags = 0;
--- 213,216 ----
***************
*** 215,226 ****
      {
        sigaction (XSIG (i), &act, &oact);
!       terminating_signals[i].orig_handler = oact.sa_handler;
        /* Don't do anything with signals that are ignored at shell entry
  	 if the shell is not interactive. */
!       if (!interactive_shell && oact.sa_handler == SIG_IGN)
          {
  	  sigaction (XSIG (i), &oact, &act);
  	  set_signal_ignored (XSIG (i));
          }
      }
  
--- 222,235 ----
      {
        sigaction (XSIG (i), &act, &oact);
!       XHANDLER(i) = oact.sa_handler;
        /* Don't do anything with signals that are ignored at shell entry
  	 if the shell is not interactive. */
!       if (!interactive_shell && XHANDLER (i) == SIG_IGN)
          {
  	  sigaction (XSIG (i), &oact, &act);
  	  set_signal_ignored (XSIG (i));
          }
+       if (XSIG (i) == SIGPROF && XHANDLER (i) != SIG_DFL && XHANDLER (i) != SIG_IGN)
+         sigaction (XSIG (i), &oact, (struct sigaction *)NULL);
      }
  
***************
*** 229,245 ****
    for (i = 0; i < TERMSIGS_LENGTH; i++)
      {
!       terminating_signals[i].orig_handler =
! 	signal (XSIG (i), termination_unwind_protect);
        /* Don't do anything with signals that are ignored at shell entry
  	 if the shell is not interactive. */
!       if (!interactive_shell && terminating_signals[i].orig_handler == SIG_IGN)
  	{
            signal (XSIG (i), SIG_IGN);
            set_signal_ignored (XSIG (i));
  	}
      }
  
  #endif /* !HAVE_POSIX_SIGNALS */
  
  #if defined (JOB_CONTROL) || defined (HAVE_POSIX_SIGNALS)
    /* All shells use the signal mask they inherit, and pass it along
--- 238,264 ----
    for (i = 0; i < TERMSIGS_LENGTH; i++)
      {
!       XHANDLER(i) = signal (XSIG (i), termination_unwind_protect);
        /* Don't do anything with signals that are ignored at shell entry
  	 if the shell is not interactive. */
!       if (!interactive_shell && XHANDLER (i) == SIG_IGN)
  	{
            signal (XSIG (i), SIG_IGN);
            set_signal_ignored (XSIG (i));
  	}
+       if (XSIG (i) == SIGPROF && XHANDLER (i) != SIG_DFL && XHANDLER (i) != SIG_IGN)
+         signal (XSIG (i), XHANDLER (i));
      }
  
  #endif /* !HAVE_POSIX_SIGNALS */
  
+   termsigs_initialized = 1;
+ }
+ 
+ static void
+ initialize_shell_signals ()
+ {
+   if (interactive)
+     initialize_terminating_signals ();
+ 
  #if defined (JOB_CONTROL) || defined (HAVE_POSIX_SIGNALS)
    /* All shells use the signal mask they inherit, and pass it along
***************
*** 264,271 ****
  {
    register int i;
- 
  #if defined (HAVE_POSIX_SIGNALS)
    struct sigaction act;
  
    act.sa_flags = 0;
    sigemptyset (&act.sa_mask);
--- 283,294 ----
  {
    register int i;
  #if defined (HAVE_POSIX_SIGNALS)
    struct sigaction act;
+ #endif
  
+   if (termsigs_initialized == 0)
+     return;
+ 
+ #if defined (HAVE_POSIX_SIGNALS)
    act.sa_flags = 0;
    sigemptyset (&act.sa_mask);
diff -Nrc2 bash-2.0/sig.h bash-2.01/sig.h
*** bash-2.0/sig.h	Fri Mar 31 11:02:46 1995
--- bash-2.01/sig.h	Thu Jan 23 13:25:06 1997
***************
*** 112,115 ****
--- 112,116 ----
  extern void initialize_signals __P((void));
  extern void reinitialize_signals __P((void));
+ extern void initialize_terminating_signals __P((void));
  extern void reset_terminating_signals __P((void));
  extern void throw_to_top_level __P((void));
diff -Nrc2 bash-2.0/siglist.c bash-2.01/siglist.c
*** bash-2.0/siglist.c	Mon Jul 22 14:43:05 1996
--- bash-2.01/siglist.c	Mon Feb 17 14:28:07 1997
***************
*** 24,28 ****
  
  #include <stdio.h>
! #include <sys/types.h>
  #include <signal.h>
  
--- 24,28 ----
  
  #include <stdio.h>
! #include "bashtypes.h"
  #include <signal.h>
  
***************
*** 209,212 ****
--- 209,216 ----
  #if defined (SIGSOUND)
    sys_siglist[SIGSOUND] = "HFT sound sequence has completed";
+ #endif
+ 
+ #if defined (SIGINFO)
+   sys_siglist[SIGINFO] = "Information request";
  #endif
  
diff -Nrc2 bash-2.0/stringlib.c bash-2.01/stringlib.c
*** bash-2.0/stringlib.c	Fri Oct 25 13:10:25 1996
--- bash-2.01/stringlib.c	Thu Apr  3 14:44:10 1997
***************
*** 44,50 ****
     returning.  LEN is the length of STRING. */
  char *
! ansicstr (string, len, sawc)
       char *string;
!      int len, *sawc;
  {
    int c;
--- 44,50 ----
     returning.  LEN is the length of STRING. */
  char *
! ansicstr (string, len, sawc, rlen)
       char *string;
!      int len, *sawc, *rlen;
  {
    int c;
***************
*** 94,97 ****
--- 94,99 ----
  		  *sawc = 1;
  		  *r = '\0';
+ 		  if (rlen)
+ 		    *rlen = r - ret;
  		  return ret;
  		}
***************
*** 102,105 ****
--- 104,109 ----
      }
    *r = '\0';
+   if (rlen)
+     *rlen = r - ret;
    return ret;
  }
***************
*** 308,311 ****
--- 312,316 ----
  }
  
+ #ifdef INCLUDE_UNUSED
  /* Remove all leading whitespace from STRING.  This includes
     newlines.  STRING should be terminated with a zero. */
***************
*** 326,329 ****
--- 331,335 ----
      }
  }
+ #endif
  
  /* Remove all trailing whitespace from STRING.  This includes
***************
*** 331,340 ****
     are removed.  STRING should be terminated with a zero. */
  void
! strip_trailing (string, newlines_only)
       char *string;
       int newlines_only;
  {
-   int len = strlen (string) - 1;
- 
    while (len >= 0)
      {
--- 337,345 ----
     are removed.  STRING should be terminated with a zero. */
  void
! strip_trailing (string, len, newlines_only)
       char *string;
+      int len;
       int newlines_only;
  {
    while (len >= 0)
      {
diff -Nrc2 bash-2.0/subst.c bash-2.01/subst.c
*** bash-2.0/subst.c	Tue Dec 10 17:14:33 1996
--- bash-2.01/subst.c	Wed May 14 13:05:11 1997
***************
*** 44,47 ****
--- 44,51 ----
  #include "mailcheck.h"
  
+ #if !defined (HAVE_RESTARTABLE_SYSCALLS)	/* for getc_with_restart */
+ #include "input.h"
+ #endif
+ 
  #include "builtins/getopt.h"
  #include "builtins/common.h"
***************
*** 66,69 ****
--- 70,74 ----
  
  /* The size that strings change by. */
+ #define DEFAULT_INITIAL_ARRAY_SIZE 112
  #define DEFAULT_ARRAY_SIZE 128
  
***************
*** 72,75 ****
--- 77,81 ----
  #define VT_POSPARMS	1
  #define VT_ARRAYVAR	2
+ #define VT_ARRAYMEMBER	3
  
  /* Flags for quoted_strchr */
***************
*** 275,278 ****
--- 281,285 ----
  }
  
+ #ifdef INCLUDE_UNUSED
  static char *
  dequote_escapes (string)
***************
*** 296,299 ****
--- 303,307 ----
    return result;
  }
+ #endif
  
  /* Extract a substring from STRING, starting at SINDEX and ending with
***************
*** 1474,1477 ****
--- 1482,1509 ----
  }
  
+ static inline char *
+ expand_string_to_string (string, quoted, func)
+      char *string;
+      int quoted;
+      WORD_LIST *(*func)();
+ {
+   WORD_LIST *list;
+   char *ret;
+ 
+   if (string == 0 || *string == '\0')
+     return ((char *)NULL);
+ 
+   list = (*func) (string, quoted);
+   if (list)
+     {
+       ret = string_list (list);
+       dispose_words (list);
+     }
+   else
+     ret = (char *)NULL;
+ 
+   return (ret);
+ }
+ 
  #if defined (ARRAY_VARS)
  SHELL_VAR *
***************
*** 1560,1564 ****
  
    if (value == 0)
!     value = savestring ("");
  
    if (echo_command_at_execute)
--- 1592,1599 ----
  
    if (value == 0)
!     {
!       value = xmalloc (1);
!       value[0] = '\0';
!     }
  
    if (echo_command_at_execute)
***************
*** 1570,1574 ****
      fprintf (stderr, "%s%s=%s\n", indirection_level_string (), name, value);
  
! #define ASSIGN_RETURN(r)	FREE (value); free (name); return (r);
  
  #if defined (ARRAY_VARS)
--- 1605,1609 ----
      fprintf (stderr, "%s%s=%s\n", indirection_level_string (), name, value);
  
! #define ASSIGN_RETURN(r)	do { FREE (value); free (name); return (r); } while (0)
  
  #if defined (ARRAY_VARS)
***************
*** 1735,1741 ****
    result = expand_word_internal (w, q, c, e);
    if (result == &expand_word_error)
!     jump_to_top_level (DISCARD);
    else if (result == &expand_word_fatal)
      jump_to_top_level (FORCE_EOF);
    else
      return (result);
--- 1770,1783 ----
    result = expand_word_internal (w, q, c, e);
    if (result == &expand_word_error)
!     {
!       /* By convention, each time this error is returned, w->word has
! 	 already been freed. */
!       w->word = (char *)NULL;
!       jump_to_top_level (DISCARD);
!       /* NOTREACHED */
!     }
    else if (result == &expand_word_fatal)
      jump_to_top_level (FORCE_EOF);
+     /* NOTREACHED */
    else
      return (result);
***************
*** 1755,1759 ****
      return ((WORD_LIST *)NULL);
  
!   bzero (&td, sizeof (td));
    td.word = string;
    tresult = call_expand_word_internal (&td, quoted, (int *)NULL, (int *)NULL);
--- 1797,1801 ----
      return ((WORD_LIST *)NULL);
  
!   bzero ((char *)&td, sizeof (td));
    td.word = string;
    tresult = call_expand_word_internal (&td, quoted, (int *)NULL, (int *)NULL);
***************
*** 1826,1830 ****
      return (WORD_LIST *)NULL;
  
!   bzero (&td, sizeof (td));
    td.word = string;
    tresult = call_expand_word_internal (&td, quoted, dollar_at_p, has_dollar_at);
--- 1868,1872 ----
      return (WORD_LIST *)NULL;
  
!   bzero ((char *)&td, sizeof (td));
    td.word = string;
    tresult = call_expand_word_internal (&td, quoted, dollar_at_p, has_dollar_at);
***************
*** 2080,2086 ****
       char *pat, *string;
  {
    register char *np;
    int neg;
!   char c, c1;
  
    if (*string == 0)
--- 2122,2131 ----
       char *pat, *string;
  {
+ #if 0
    register char *np;
    int neg;
!   char c1;
! #endif
!   char c;
  
    if (*string == 0)
***************
*** 2094,2100 ****
--- 2139,2147 ----
        return (*string == *pat);
      case '?':
+       return (*string != '\0');
      case '*':
        return (1);
      case '[':
+ #if 0
        for (np = pat; *np != ']'; np++);
        if (*np == 0)
***************
*** 2114,2117 ****
--- 2161,2167 ----
  	  pat += 2;
  	}
+ #else
+       return (*string != '\0');
+ #endif
      }
  }
***************
*** 2399,2403 ****
    char *ret;
  
!   ret = xmalloc (16);
    sprintf (ret, "%s%d", DEV_FD_PREFIX, fd);
    add_fifo_list (fd);
--- 2449,2453 ----
    char *ret;
  
!   ret = xmalloc (sizeof (DEV_FD_PREFIX) + 4);
    sprintf (ret, "%s%d", DEV_FD_PREFIX, fd);
    add_fifo_list (fd);
***************
*** 2450,2453 ****
--- 2500,2507 ----
    parent_pipe_fd = fildes[open_for_read_in_child];
    child_pipe_fd = fildes[1 - open_for_read_in_child];
+   /* Move the parent end of the pipe to some high file descriptor, to
+      avoid clashes with FDs used by the script. */
+   parent_pipe_fd = move_to_high_fd (parent_pipe_fd, 1, 64);
+ 
    pathname = make_dev_fd_filename (parent_pipe_fd);
  #endif /* HAVE_DEV_FD */
***************
*** 2561,2565 ****
  #endif /* HAVE_DEV_FD */
  
!   result = parse_and_execute (string, "process substitution", 0);
  
  #if !defined (HAVE_DEV_FD)
--- 2615,2619 ----
  #endif /* HAVE_DEV_FD */
  
!   result = parse_and_execute (string, "process substitution", (SEVAL_NONINT|SEVAL_NOHIST));
  
  #if !defined (HAVE_DEV_FD)
***************
*** 2573,2576 ****
--- 2627,2699 ----
  #endif /* PROCESS_SUBSTITUTION */
  
+ static char *
+ read_comsub (fd, quoted)
+      int fd, quoted;
+ {
+   char *istring, buf[128], *bufp;
+   int bufn, istring_index, istring_size, c;
+ 
+   istring = (char *)NULL;
+   istring_index = istring_size = bufn = 0;
+ 
+   /* Read the output of the command through the pipe. */
+   while (1)
+     {
+       if (fd < 0)
+         break;
+       if (--bufn <= 0)
+ 	{
+ 	  while ((bufn = read (fd, buf, sizeof(buf))) < 0 && errno == EINTR)
+ 	    ;
+ 	  if (bufn <= 0) 
+ 	    break;
+ 	  bufp = buf;
+ 	}
+       c = *bufp++;
+ 
+       /* Add the character to ISTRING, possibly after resizing it. */
+       RESIZE_MALLOCED_BUFFER (istring, istring_index, 2, istring_size, DEFAULT_ARRAY_SIZE);
+ 
+       if ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) || c == CTLESC || c == CTLNUL)
+ 	istring[istring_index++] = CTLESC;
+ 
+       istring[istring_index++] = c;
+     }
+ 
+   if (istring)
+     istring[istring_index] = '\0';
+ 
+   /* If we read no output, just return now and save ourselves some
+      trouble. */
+   if (istring_index == 0)
+     {
+       FREE (istring);
+       return (char *)NULL;
+     }
+ 
+   /* Strip trailing newlines from the output of the command. */
+   if (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES))
+     {
+       while (istring_index > 0)
+ 	{
+ 	  if (istring[istring_index - 1] == '\n')
+ 	    {
+ 	      --istring_index;
+ 
+ 	      /* If the newline was quoted, remove the quoting char. */
+ 	      if (istring[istring_index - 1] == CTLESC)
+ 		--istring_index;
+ 	    }
+ 	  else
+ 	    break;
+ 	}
+       istring[istring_index] = '\0';
+     }
+   else
+     strip_trailing (istring, istring_index - 1, 1);
+ 
+   return istring;
+ }
+ 
  /* Perform command substitution on STRING.  This returns a string,
     possibly quoted. */
***************
*** 2582,2589 ****
    pid_t pid, old_pid, old_pipeline_pgrp;
    char *istring;
!   int istring_index, istring_size, c, result, fildes[2];
!   FILE *istream;
  
-   istring_index = istring_size = 0;
    istring = (char *)NULL;
  
--- 2705,2710 ----
    pid_t pid, old_pid, old_pipeline_pgrp;
    char *istring;
!   int result, fildes[2];
  
    istring = (char *)NULL;
  
***************
*** 2679,2688 ****
  	exit (EXECUTION_FAILURE);
        else
! 	exit (parse_and_execute (string, "command substitution", -1));
      }
    else
      {
-       istream = fdopen (fildes[0], "r");
- 
  #if defined (JOB_CONTROL) && defined (PGRP_PIPE)
        close_pgrp_pipe ();
--- 2800,2807 ----
  	exit (EXECUTION_FAILURE);
        else
! 	exit (parse_and_execute (string, "command substitution", SEVAL_NOHIST));
      }
    else
      {
  #if defined (JOB_CONTROL) && defined (PGRP_PIPE)
        close_pgrp_pipe ();
***************
*** 2691,2725 ****
        close (fildes[1]);
  
!       if (istream == 0)
! 	{
! 	  sys_error ("cannot reopen pipe to command substitution (fd %d)", fildes[0]);
! 	  goto error_exit;
! 	}
! 
!       /* Read the output of the command through the pipe. */
!       while (1)
! 	{
! #if !defined (HAVE_RESTARTABLE_SYSCALLS)
! 	  c = getc_with_restart (istream);
! #else
! 	  c = getc (istream);
! #endif /* HAVE_RESTARTABLE_SYSCALLS */
! 
! 	  if (c == EOF)
! 	    break;
! 
! 	  /* Add the character to ISTRING, possibly after resizing it. */
! 	  RESIZE_MALLOCED_BUFFER (istring, istring_index, 2, istring_size, DEFAULT_ARRAY_SIZE);
! 
! 	  if ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) || c == CTLESC || c == CTLNUL)
! 	    istring[istring_index++] = CTLESC;
! 
! 	  istring[istring_index++] = c;
! 	}
! 
!       if (istring)
! 	istring[istring_index] = '\0';
  
-       fclose (istream);
        close (fildes[0]);
  
--- 2810,2815 ----
        close (fildes[1]);
  
!       istring = read_comsub (fildes[0], quoted);
  
        close (fildes[0]);
  
***************
*** 2741,2770 ****
  #endif /* JOB_CONTROL */
  
-       /* If we read no output, just return now and save ourselves some
- 	 trouble. */
-       if (istring_index == 0)
- 	goto error_exit;
- 
-       /* Strip trailing newlines from the output of the command. */
-       if (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES))
- 	{
- 	  while (istring_index > 0)
- 	    {
- 	      if (istring[istring_index - 1] == '\n')
- 		{
- 		  --istring_index;
- 
- 		  /* If the newline was quoted, remove the quoting char. */
- 		  if (istring[istring_index - 1] == CTLESC)
- 		    --istring_index;
- 		}
- 	      else
- 		break;
- 	    }
- 	  istring[istring_index] = '\0';
- 	}
-       else
- 	strip_trailing (istring, 1);
- 
        return (istring);
      }
--- 2831,2834 ----
***************
*** 2875,2878 ****
--- 2939,2943 ----
        tword = remove_pattern (l->word->word, pattern, patspec);
        w = make_bare_word (tword);
+       free (tword);
        new = make_word_list (w, new);
      }
***************
*** 2894,2898 ****
  {
    int patspec;
!   char *pattern;
  
    patspec = getpatspec (c, value);
--- 2959,2964 ----
  {
    int patspec;
!   char *pattern, *ret;
!   WORD_LIST *list;
  
    patspec = getpatspec (c, value);
***************
*** 2902,2906 ****
    pattern = getpattern (value, quoted, 1);
  
!   return (list_remove_pattern (list_rest_of_args (), pattern, patspec, type, quoted));
  }
  
--- 2968,2976 ----
    pattern = getpattern (value, quoted, 1);
  
!   list = list_rest_of_args ();
!   ret = list_remove_pattern (list, pattern, patspec, type, quoted);
!   dispose_words (list);
!   FREE (pattern);
!   return (ret);
  }
  
***************
*** 2934,2937 ****
--- 3004,3008 ----
          {
            report_error ("%s: bad array subscript", aspec);
+           FREE (pattern);
            return ((char *)NULL);
          }
***************
*** 2949,2952 ****
--- 3020,3024 ----
  	{
  	  report_error ("%s: bad array subscript", aspec);
+ 	  FREE (pattern);
  	  return ((char *)NULL);
  	}
***************
*** 2960,2965 ****
  #endif
        if (ret)
! 	quote_escapes (ret);
      }
    return ret;
  }
--- 3032,3043 ----
  #endif
        if (ret)
! 	{
! 	  t = quote_escapes (ret);
! 	  free (ret);
! 	  ret = t;
! 	}
      }
+ 
+   FREE (pattern);
    return ret;
  }
***************
*** 2999,3003 ****
  {
    char *exp, *t;
!   int val;
  
    exp = xmalloc (len);
--- 3077,3081 ----
  {
    char *exp, *t;
!   int val, expok;
  
    exp = xmalloc (len);
***************
*** 3006,3012 ****
    t = maybe_expand_string (exp, 0, expand_string);
    this_command_name = (char *)NULL;
!   val = evalexp (t);
    free (t);
    free (exp);
    return val;
  }
--- 3084,3092 ----
    t = maybe_expand_string (exp, 0, expand_string);
    this_command_name = (char *)NULL;
!   val = evalexp (t, &expok);
    free (t);
    free (exp);
+   if (expok == 0)
+     jump_to_top_level (DISCARD);
    return val;
  }
***************
*** 3086,3090 ****
  	}
        if (array_p (var) == 0)
!         return (ind == 0 ? value_cell (var) : (char *)NULL);
        retval = array_reference (array_cell (var), ind);
        if (retval)
--- 3166,3170 ----
  	}
        if (array_p (var) == 0)
!         return (ind == 0 ? savestring (value_cell (var)) : (char *)NULL);
        retval = array_reference (array_cell (var), ind);
        if (retval)
***************
*** 3434,3438 ****
  {
    char *t, *temp1;
!   int len;
  #if defined (ARRAY_VARS)
   ARRAY *a;
--- 3514,3518 ----
  {
    char *t, *temp1;
!   int len, expok;
  #if defined (ARRAY_VARS)
   ARRAY *a;
***************
*** 3442,3452 ****
    if (t)
      *t = '\0';
!   temp1 = maybe_expand_string (substr, 1, expand_string);
!   *e1p = evalexp (temp1);
    free (temp1);
  
    switch (vtype)
      {
      case VT_VARIABLE:
        len = strlen (value);
        break;
--- 3522,3535 ----
    if (t)
      *t = '\0';
!   temp1 = maybe_expand_string (substr, Q_DOUBLE_QUOTES, expand_string);
!   *e1p = evalexp (temp1, &expok);
    free (temp1);
+   if (expok == 0)
+     return (0);
  
    switch (vtype)
      {
      case VT_VARIABLE:
+     case VT_ARRAYMEMBER:
        len = strlen (value);
        break;
***************
*** 3465,3475 ****
      *e1p += len;
  
    if (t)
      {
        t++;
!       temp1 = maybe_expand_string (t, 1, expand_string);
        t[-1] = ':';
!       *e2p = evalexp (temp1);
        free (temp1);
        if (*e2p < 0)
          {
--- 3548,3563 ----
      *e1p += len;
  
+   if (*e1p >= len || *e1p < 0)
+     return (0);
+ 
    if (t)
      {
        t++;
!       temp1 = maybe_expand_string (t, Q_DOUBLE_QUOTES, expand_string);
        t[-1] = ':';
!       *e2p = evalexp (temp1, &expok);
        free (temp1);
+       if (expok == 0)
+         return (0);
        if (*e2p < 0)
          {
***************
*** 3548,3552 ****
        if (v && array_p (v))
  	{
! 	  if (temp[0] == '@' && temp[1] == ']')
  	    {
  	      vtype = VT_ARRAYVAR;
--- 3636,3640 ----
        if (v && array_p (v))
  	{
! 	  if ((temp[0] == '@' || temp[0] == '*') && temp[1] == ']')
  	    {
  	      vtype = VT_ARRAYVAR;
***************
*** 3555,3559 ****
  	  else
  	    {
! 	      vtype = VT_VARIABLE;
  	      *valp = array_value (varname, 1);
  	    }
--- 3643,3647 ----
  	  else
  	    {
! 	      vtype = VT_ARRAYMEMBER;
  	      *valp = array_value (varname, 1);
  	    }
***************
*** 3599,3607 ****
  
    if (verify_substring_values (val, substr, vtype, &e1, &e2) == 0)
!     return (&expand_param_error);
  
    switch (vtype)
      {
      case VT_VARIABLE:
        temp = quoted ? quoted_substring (value, e1, e2) : substring (value, e1, e2);
        break;
--- 3687,3700 ----
  
    if (verify_substring_values (val, substr, vtype, &e1, &e2) == 0)
!     {
!       if (val && vtype == VT_ARRAYMEMBER)
! 	free (val);
!       return (&expand_param_error);
!     }
  
    switch (vtype)
      {
      case VT_VARIABLE:
+     case VT_ARRAYMEMBER:
        temp = quoted ? quoted_substring (value, e1, e2) : substring (value, e1, e2);
        break;
***************
*** 3660,3664 ****
    /* Now copy the unmatched portion of the input string */
    if (*str)
!     strcpy (ret + rptr, str);
    else
      ret[rptr] = '\0';
--- 3753,3760 ----
    /* Now copy the unmatched portion of the input string */
    if (*str)
!     {
!       RESIZE_MALLOCED_BUFFER (ret, rptr, STRLEN(str) + 1, rsize, 64);
!       strcpy (ret + rptr, str);
!     }
    else
      ret[rptr] = '\0';
***************
*** 3737,3749 ****
    pat = maybe_expand_string (patsub, quoted, expand_string_unsplit);
    if (rep)
!     rep = maybe_expand_string (rep, quoted, expand_string_unsplit);
  
    p = pat;
!   if (pat[0] == '#')
      {
        mflags |= MATCH_BEG;
        p++;
      }
!   else if (pat[0] == '%')
      {
        mflags |= MATCH_END;
--- 3833,3850 ----
    pat = maybe_expand_string (patsub, quoted, expand_string_unsplit);
    if (rep)
!     {
!       if ((mflags & MATCH_QUOTED) == 0)
! 	rep = maybe_expand_string (rep, quoted, expand_string_unsplit);
!       else
!         rep = expand_string_to_string (rep, quoted, expand_string_unsplit);
!     }
  
    p = pat;
!   if (pat && pat[0] == '#')
      {
        mflags |= MATCH_BEG;
        p++;
      }
!   else if (pat && pat[0] == '%')
      {
        mflags |= MATCH_END;
***************
*** 3759,3762 ****
--- 3860,3864 ----
      {
      case VT_VARIABLE:
+     case VT_ARRAYMEMBER:
        temp = pat_subst (val, p, rep, mflags);
        break;
***************
*** 3771,3774 ****
--- 3873,3879 ----
      }
  
+   if (val && v && array_p (v) && vtype == VT_ARRAYMEMBER)
+     free (val);
+ 
    FREE (pat);
    FREE (rep);
***************
*** 4007,4011 ****
  	  free (name);
  	  last_command_exit_value = EXECUTION_FAILURE;
! 	  return &expand_param_error;
  	}
        break;
--- 4112,4116 ----
  	  free (name);
  	  last_command_exit_value = EXECUTION_FAILURE;
! 	  return (interactive_shell ? &expand_param_error : &expand_param_fatal);
  	}
        break;
***************
*** 4148,4156 ****
    int had_quoted_null;
  
    register int c;		/* Current character. */
    int number;			/* Temporary number value. */
    int t_index;			/* For calls to string_extract_xxx. */
  
!   istring = xmalloc (istring_size = DEFAULT_ARRAY_SIZE);
    istring[istring_index = 0] = '\0';
  
--- 4253,4263 ----
    int had_quoted_null;
  
+   int expok;
+ 
    register int c;		/* Current character. */
    int number;			/* Temporary number value. */
    int t_index;			/* For calls to string_extract_xxx. */
  
!   istring = xmalloc (istring_size = DEFAULT_INITIAL_ARRAY_SIZE);
    istring[istring_index = 0] = '\0';
  
***************
*** 4252,4256 ****
  		  free (istring);
  		  last_command_exit_value = EXECUTION_FAILURE;
! 		  return (&expand_word_error);
  		}
  	      temp = temp1 ? savestring (temp1) : (char *)NULL;
--- 4359,4363 ----
  		  free (istring);
  		  last_command_exit_value = EXECUTION_FAILURE;
! 		  return (interactive_shell ? &expand_word_error : &expand_word_fatal);
  		}
  	      temp = temp1 ? savestring (temp1) : (char *)NULL;
***************
*** 4405,4413 ****
  		  if (temp1[t_index] != ')')
  		    {
  		      report_error ("%s: bad arithmetic substitution", temp);
  		      free (temp);
  		      free (string);
  		      free (istring);
! 		      return &expand_word_error;
  		    }
  
--- 4512,4524 ----
  		  if (temp1[t_index] != ')')
  		    {
+ #if 0
  		      report_error ("%s: bad arithmetic substitution", temp);
  		      free (temp);
  		      free (string);
  		      free (istring);
! 		      return (&expand_word_error);
! #else
! 		      goto comsub;
! #endif
  		    }
  
***************
*** 4416,4430 ****
  
  		  /* Expand variables found inside the expression. */
! 		  temp1 = maybe_expand_string (temp1, 1, expand_string);
  
  		  /* No error messages. */
  		  this_command_name = (char *)NULL;
! 		  number = evalexp (temp1);
  		  free (temp);
  		  free (temp1);
! 
  		  goto add_number;
  		}
  
  	      temp1 = command_substitute (temp, quoted);
  	      FREE (temp);
--- 4527,4547 ----
  
  		  /* Expand variables found inside the expression. */
! 		  temp1 = maybe_expand_string (temp1, Q_DOUBLE_QUOTES, expand_string);
  
  		  /* No error messages. */
  		  this_command_name = (char *)NULL;
! 		  number = evalexp (temp1, &expok);
  		  free (temp);
  		  free (temp1);
! 		  if (expok == 0)
! 		    {
! 		      free (string);
! 		      free (istring);
! 		      return (&expand_word_error);
! 		    }
  		  goto add_number;
  		}
  
+ 	comsub:
  	      temp1 = command_substitute (temp, quoted);
  	      FREE (temp);
***************
*** 4441,4452 ****
  
  	       /* Do initial variable expansion. */
! 	      temp1 = maybe_expand_string (temp, 1, expand_string);
  
  	      /* No error messages. */
  	      this_command_name = (char *)NULL;
! 	      number = evalexp (temp1);
  	      free (temp1);
  	      free (temp);
! 
  	      goto add_number;
  
--- 4558,4574 ----
  
  	       /* Do initial variable expansion. */
! 	      temp1 = maybe_expand_string (temp, Q_DOUBLE_QUOTES, expand_string);
  
  	      /* No error messages. */
  	      this_command_name = (char *)NULL;
! 	      number = evalexp (temp1, &expok);
  	      free (temp1);
  	      free (temp);
! 	      if (expok == 0)
! 		{
! 		  free (string);
! 		  free (istring);
! 		  return (&expand_word_error);
! 		}
  	      goto add_number;
  
***************
*** 4505,4509 ****
  	      last_command_exit_value = EXECUTION_FAILURE;
  	      free (istring);
! 	      return &expand_word_error;
  	    }
  	  break;		/* End case '$': */
--- 4627,4633 ----
  	      last_command_exit_value = EXECUTION_FAILURE;
  	      free (istring);
! 	      return ((unbound_vars_is_error && interactive_shell == 0)
! 			? &expand_word_fatal
! 			: &expand_word_error);
  	    }
  	  break;		/* End case '$': */
***************
*** 4896,4899 ****
--- 5020,5024 ----
    t = string_quote_removal (word->word, quoted);
    w = make_bare_word (t);
+   free (t);
    return (w);
  }
***************
*** 5229,5232 ****
--- 5354,5358 ----
        register char **expansions;
        WORD_LIST *braces;
+       WORD_DESC *w;
        int eindex;
  
***************
*** 5248,5252 ****
  	      for (eindex = 0; temp_string = expansions[eindex]; eindex++)
  		{
! 		  braces = make_word_list (make_word (temp_string), braces);
  		  free (expansions[eindex]);
  		}
--- 5374,5384 ----
  	      for (eindex = 0; temp_string = expansions[eindex]; eindex++)
  		{
! 		  w = make_word (temp_string);
! 		  /* If brace expansion didn't change the word, preserve
! 		     the flags.  We may want to preserve the flags
! 		     unconditionally someday -- XXX */
! 		  if (STREQ (temp_string, tlist->word->word))
! 		    w->flags = tlist->word->flags;
! 		  braces = make_word_list (w, braces);
  		  free (expansions[eindex]);
  		}
***************
*** 5307,5311 ****
  	  /* Dispose our copy of the original list. */
  	  dispose_words (orig_list);
! 	  /* Dispose the  new list we're building. */
  	  dispose_words (new_list);
  
--- 5439,5443 ----
  	  /* Dispose our copy of the original list. */
  	  dispose_words (orig_list);
! 	  /* Dispose the new list we're building. */
  	  dispose_words (new_list);
  
***************
*** 5373,5379 ****
  	      next = tlist->next;
  
! 	      /* If the word isn't quoted and there is an unquoted pattern
! 		 matching character in the word, then glob it. */
  	      if ((tlist->word->flags & (W_QUOTED|W_ASSIGNMENT)) == 0 &&
  		  unquoted_glob_pattern_p (tlist->word->word))
  		{
--- 5505,5515 ----
  	      next = tlist->next;
  
! 	      /* If the word isn't an assignment and contains an unquoted
! 	         pattern matching character, then glob it. */
! #if 0
  	      if ((tlist->word->flags & (W_QUOTED|W_ASSIGNMENT)) == 0 &&
+ #else
+ 	      if ((tlist->word->flags & W_ASSIGNMENT) == 0 &&
+ #endif
  		  unquoted_glob_pattern_p (tlist->word->word))
  		{
***************
*** 5759,5762 ****
--- 5895,5899 ----
    if (temp)
      eof_encountered_limit = (*temp && all_digits (temp)) ? atoi (temp) : 10;
+   set_shellopts ();	/* make sure `ignoreeof' is/is not in $SHELLOPTS */
  }
  
***************
*** 5800,5805 ****
    posix_initialize (posixly_correct);
  #if defined (READLINE)
!   posix_readline_initialize (posixly_correct);
  #endif /* READLINE */
  }
  
--- 5937,5944 ----
    posix_initialize (posixly_correct);
  #if defined (READLINE)
!   if (interactive_shell)
!     posix_readline_initialize (posixly_correct);
  #endif /* READLINE */
+   set_shellopts ();	/* make sure `posix' is/is not in $SHELLOPTS */
  }
  
diff -Nrc2 bash-2.0/support/SYMLINKS bash-2.01/support/SYMLINKS
*** bash-2.0/support/SYMLINKS	Thu Jul 11 16:29:28 1996
--- bash-2.01/support/SYMLINKS	Thu Mar  6 12:51:17 1997
***************
*** 6,20 ****
  lib/readline/tilde.c		../tilde/tilde.c
  lib/readline/tilde.h		../tilde/tilde.h
  lib/readline/posixdir.h		../posixheaders/posixdir.h
  lib/readline/posixstat.h	../posixheaders/posixstat.h
- lib/readline/ansi_stdlib.h	../posixheaders/ansi_stdlib.h
  lib/readline/xmalloc.c		../malloc/xmalloc.c
  #
  #lib/tilde/memalloc.h		../posixheaders/memalloc.h
  #
  posixdir.h			lib/posixheaders/posixdir.h
  posixstat.h			lib/posixheaders/posixstat.h
- ansi_stdlib.h			lib/posixheaders/ansi_stdlib.h
  stdc.h				lib/posixheaders/stdc.h
- memalloc.h			lib/posixheaders/memalloc.h
- filecntl.h			lib/posixheaders/filecntl.h
--- 6,23 ----
  lib/readline/tilde.c		../tilde/tilde.c
  lib/readline/tilde.h		../tilde/tilde.h
+ #
+ lib/readline/ansi_stdlib.h	../posixheaders/ansi_stdlib.h
  lib/readline/posixdir.h		../posixheaders/posixdir.h
+ lib/readline/posixjmp.h		../posixheaders/posixjmp.h
  lib/readline/posixstat.h	../posixheaders/posixstat.h
  lib/readline/xmalloc.c		../malloc/xmalloc.c
  #
  #lib/tilde/memalloc.h		../posixheaders/memalloc.h
  #
+ ansi_stdlib.h			lib/posixheaders/ansi_stdlib.h
+ filecntl.h			lib/posixheaders/filecntl.h
+ memalloc.h			lib/posixheaders/memalloc.h
  posixdir.h			lib/posixheaders/posixdir.h
+ posixjmp.h			lib/posixheaders/posixjmp.h
  posixstat.h			lib/posixheaders/posixstat.h
  stdc.h				lib/posixheaders/stdc.h
diff -Nrc2 bash-2.0/support/bashbug.sh bash-2.01/support/bashbug.sh
*** bash-2.0/support/bashbug.sh	Tue Jul 23 11:21:00 1996
--- bash-2.01/support/bashbug.sh	Mon Mar 17 13:09:22 1997
***************
*** 22,26 ****
  export PATH
  
! TEMP=/tmp/bashbug.$$
  
  case "$RELSTATUS" in
--- 22,35 ----
  export PATH
  
! TEMP=/tmp/bbug.$$
! 
! # Figure out how to echo a string without a trailing newline
! N=`echo 'hi there\c'`
! case "$N" in
! *c)	n=-n c= ;;
! *)	n= c='\c' ;;
! esac
! 
! BASHTESTERS="bash-testers@po.cwru.edu"
  
  case "$RELSTATUS" in
***************
*** 29,33 ****
  esac
  
! BUGADDR=${1-$BUGBASH}
  
  : ${EDITOR=emacs}
--- 38,52 ----
  esac
  
! case "$RELSTATUS" in
! alpha*|beta*)	echo "$0: This is a testing release.  Would you like your bug report"
! 		echo "$0: to be sent to the bash-testers mailing list?"
! 		echo $n "$0: Send to bash-testers? $c"
! 		read ans
! 		case "$ans" in
! 		y*|Y*)	BUGBASH="${BUGBASH},${BASHTESTERS}" ;;
! 		esac ;;
! esac
! 
! BUGADDR="${1-$BUGBASH}"
  
  : ${EDITOR=emacs}
***************
*** 83,93 ****
  cp $TEMP $TEMP.x
  
- # Figure out how to echo a string without a trailing newline
- N=`echo 'hi there\c'`
- case "$N" in
- *c)	n=-n c= ;;
- *)	n= c='\c' ;;
- esac
- 
  trap '' 2		# ignore interrupts while in editor
  
--- 102,105 ----
***************
*** 95,105 ****
  	echo "$0: editor \`$EDITOR' exited with nonzero status."
  	echo "$0: Perhaps it was interrupted."
! 	echo "$0: Type `y' to give up, and lose your bug report;"
! 	echo "$0: type `n' to re-enter the editor."
  	echo $n "$0: Do you want to give up? $c"
  
  	read ans
  	case "$ans" in
! 	Yy]*) exit 1 ;;
  	esac
  done
--- 107,117 ----
  	echo "$0: editor \`$EDITOR' exited with nonzero status."
  	echo "$0: Perhaps it was interrupted."
! 	echo "$0: Type \`y' to give up, and lose your bug report;"
! 	echo "$0: type \`n' to re-enter the editor."
  	echo $n "$0: Do you want to give up? $c"
  
  	read ans
  	case "$ans" in
! 	[Yy]*) exit 1 ;;
  	esac
  done
***************
*** 112,115 ****
--- 124,133 ----
  	exit
  fi
+ 
+ echo $n "Send bug report? [y/n] $c"
+ read ans
+ case "$ans" in
+ [Nn]*)	exit 0 ;;
+ esac
  
  ${RMAIL} $BUGADDR < $TEMP || {
diff -Nrc2 bash-2.0/support/config.guess bash-2.01/support/config.guess
*** bash-2.0/support/config.guess	Mon Dec  9 13:33:48 1996
--- bash-2.01/support/config.guess	Tue Mar 18 12:12:45 1997
***************
*** 1,5 ****
  #! /bin/sh
  # Attempt to guess a canonical system name.
! #   Copyright (C) 1992, 1993, 1994, 1995 Free Software Foundation, Inc.
  #
  # This file is free software; you can redistribute it and/or modify it
--- 1,5 ----
  #! /bin/sh
  # Attempt to guess a canonical system name.
! #   Copyright (C) 1992, 1993, 1994, 1995, 1996 Free Software Foundation, Inc.
  #
  # This file is free software; you can redistribute it and/or modify it
***************
*** 44,52 ****
  fi
  
! UNAME=`(uname) 2>/dev/null` || UNAME=unknown			# SunOS
! UNAME_MACHINE=`(uname -m) 2>/dev/null` || UNAME_MACHINE=unknown	# sun4m
! UNAME_RELEASE=`(uname -r) 2>/dev/null` || UNAME_RELEASE=unknown # 4.1.2
! UNAME_SYSTEM=`(uname -s) 2>/dev/null` || UNAME_SYSTEM=unknown	# SunOS
! UNAME_VERSION=`(uname -v) 2>/dev/null` || UNAME_VERSION=unknown	# 13
  
  RELEASE=`expr "$UNAME_RELEASE" : '[^0-9]*\([0-9]*\)'` # 4
--- 44,52 ----
  fi
  
! UNAME=`(uname) 2>/dev/null` || UNAME=unknown
! UNAME_MACHINE=`(uname -m) 2>/dev/null` || UNAME_MACHINE=unknown
! UNAME_RELEASE=`(uname -r) 2>/dev/null` || UNAME_RELEASE=unknown
! UNAME_SYSTEM=`(uname -s) 2>/dev/null` || UNAME_SYSTEM=unknown
! UNAME_VERSION=`(uname -v) 2>/dev/null` || UNAME_VERSION=unknown
  
  RELEASE=`expr "$UNAME_RELEASE" : '[^0-9]*\([0-9]*\)'` # 4
***************
*** 69,148 ****
  
  case "${UNAME_MACHINE}:${UNAME_SYSTEM}:${UNAME_RELEASE}:${UNAME_VERSION}" in
!     alpha:OSF1:V*:*)
! 	# After 1.2, OSF1 uses "V1.3" for uname -r.
! 	echo alpha-dec-osf`echo ${UNAME_RELEASE} | sed -e 's/^V//'`
! 	exit 0 ;;
!     alpha:OSF1:*:*)
! 	# 1.2 uses "1.2" for uname -r.
! 	echo alpha-dec-osf${UNAME_RELEASE}
!         exit 0 ;;
!     i[3456]86:NetBSD:*:*)
! 	echo ${UNAME_MACHINE}-unknown-netbsd`echo ${UNAME_RELEASE}|sed -e 's/[-_].*/\./'`
! 	exit 0 ;;
      alpha:NetBSD:*:*)
  	echo alpha-dec-netbsd${UNAME_RELEASE}
  	exit 0 ;;
!     sparc:NetBSD:*:*)
! 	echo sparc-sun-netbsd${UNAME_RELEASE}
  	exit 0 ;;
!     sun3*:NetBSD:*:*)
! 	echo m68k-sun-netbsd${UNAME_RELEASE}
  	exit 0 ;;
!     atari*:NetBSD:*:*)
! 	echo m68k-atari-netbsd${UNAME_RELEASE}
  	exit 0 ;;
!     mac68k:NetBSD:*:*)
! 	echo m68k-apple-netbsd${UNAME_RELEASE}
  	exit 0 ;;
!     hp3[0-9][05]:NetBSD:*:*)
! 	echo m68k-hp-netbsd${UNAME_RELEASE}
  	exit 0 ;;
!     amiga:NetBSD:*:*)
! 	echo m68k-cbm-netbsd${UNAME_RELEASE}
  	exit 0 ;;
      vax:NetBSD:*:*)
  	echo vax-dec-netbsd${UNAME_RELEASE}
  	exit 0 ;;
!     i[3456]86:OpenBSD:*:*)
! 	echo ${UNAME_MACHINE}-unknown-openbsd`echo ${UNAME_RELEASE}|sed -e 's/[-_].*/\./'`
  	exit 0 ;;
!     alpha:OpenBSD:*:*)
! 	echo alpha-dec-openbsd${UNAME_RELEASE}
  	exit 0 ;;
!     sparc:OpenBSD:*:*)
! 	echo sparc-sun-openbsd${UNAME_RELEASE}
  	exit 0 ;;
!     sun3*:OpenBSD:*:*)
! 	echo m68k-sun-openbsd${UNAME_RELEASE}
  	exit 0 ;;
!     atari*:OpenBSD:*:*)
! 	echo m68k-atari-openbsd${UNAME_RELEASE}
  	exit 0 ;;
!     mac68k:OpenBSD:*:*)
! 	echo m68k-apple-openbsd${UNAME_RELEASE}
  	exit 0 ;;
!     hp3[0-9][05]:OpenBSD:*:*)
! 	echo m68k-hp-openbsd${UNAME_RELEASE}
  	exit 0 ;;
!     amiga:OpenBSD:*:*)
! 	echo m68k-cbm-openbsd${UNAME_RELEASE}
  	exit 0 ;;
!     vax:OpenBSD:*:*)
! 	echo vax-dec-openbsd${UNAME_RELEASE}
  	exit 0 ;;
!     powerpc:machten:*:*)
! 	echo powerpc-apple-machten${UNAME_RELEASE}
  	exit 0 ;;
!     mac68k:machten:*:*)
! 	echo mac68k-apple-machten${UNAME_RELEASE}
  	exit 0 ;;
-     RISC*:Mach:*:*)
-         echo mips-dec-mach_bsd4.3
-         exit 0 ;;
      21064:Windows_NT:50:3)
  	echo alpha-dec-winnt3.5
  	exit 0 ;;
!     Amiga*:UNIX_System_V:4.*:*)
! 	echo m68k-cbm-sysv${UNAME_RELEASE}
  	exit 0 ;;
      arm:RISC*:1.[012]*:*|arm:riscix:1.[012]*:*)
--- 69,174 ----
  
  case "${UNAME_MACHINE}:${UNAME_SYSTEM}:${UNAME_RELEASE}:${UNAME_VERSION}" in
!     # Begin cases added for Bash
      alpha:NetBSD:*:*)
  	echo alpha-dec-netbsd${UNAME_RELEASE}
  	exit 0 ;;
!     alpha:OpenBSD:*:*)
! 	echo alpha-dec-openbsd${UNAME_RELEASE}
  	exit 0 ;;
!     i?86:NetBSD:*:*)
! 	echo ${UNAME_MACHINE}-pc-netbsd`echo ${UNAME_RELEASE}|sed -e 's/[-_].*/\./'`
  	exit 0 ;;
!     i?86:OpenBSD:*:*)
! 	echo ${UNAME_MACHINE}-pc-openbsd`echo ${UNAME_RELEASE}|sed -e 's/[-_].*/\./'`
  	exit 0 ;;
!     i?86:FreeBSD:*:*)
! 	echo ${UNAME_MACHINE}-pc-freebsd`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'`
  	exit 0 ;;
!     sparc:NetBSD:*:*)
! 	echo sparc-unknown-netbsd${UNAME_RELEASE}
  	exit 0 ;;
!     sparc:OpenBSD:*:*)
! 	echo sparc-unknown-openbsd${UNAME_RELEASE}
  	exit 0 ;;
      vax:NetBSD:*:*)
  	echo vax-dec-netbsd${UNAME_RELEASE}
  	exit 0 ;;
!     vax:OpenBSD:*:*)
! 	echo vax-dec-openbsd${UNAME_RELEASE}
  	exit 0 ;;
!     mac68k:machten:*:*)
! 	echo mac68k-apple-machten${UNAME_RELEASE}
  	exit 0 ;;
!     concurrent*:*:*:*)
! 	if test "`(/bin/universe) 2>/dev/null`" = att ; then
! 		echo concurrent-concurrent-sysv3
! 	else
! 		echo concurrent-concurrent-bsd
! 	fi
  	exit 0 ;;
!     ppc*:SunOS:5.*:*)
! 	echo ppc-sun-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
  	exit 0 ;;
!     sparc:UNIX_SV:4.*:*)
! 	echo sparc-unknown-sysv${UNAME_RELEASE}
  	exit 0 ;;
!     mips:UNIX_SV:4.*:*)
! 	echo mips-mips-sysv${UNAME_RELEASE}
  	exit 0 ;;
!     mips:OSF*1:*:*)
! 	echo mips-mips-osf1
  	exit 0 ;;
!     mips:4.4BSD:*:*)
! 	echo mips-mips-bsd4.4
  	exit 0 ;;
!     MIServer-S:SMP_DC.OSx:*:dcosx)
! 	echo mips-pyramid-sysv4
  	exit 0 ;;
!     news*:NEWS*:*:*)
! 	echo mips-sony-newsos${UNAME_RELEASE}
  	exit 0 ;;
!     i?86:NEXTSTEP:*:*)
! 	echo i386-next-nextstep${RELEASE}
! 	exit 0 ;;
!     *680?0:NEXTSTEP:*:*)
! 	echo m68k-next-nextstep${RELEASE}
! 	exit 0 ;;    
!     *370:AIX:*:*)
! 	echo ibm370-ibm-aix
! 	exit 0 ;;
!     ksr1:OSF*1:*:*)
! 	echo ksr1-ksr-osf1
! 	exit 0 ;;
!     esa:OSF*1:*:* | ESA:OSF*:*:*)
! 	echo esa-ibm-osf1
! 	exit 0 ;;
!     DNP*:DNIX:*:*)
! 	echo m68k-dnix-sysv
! 	exit 0 ;;
!     *3b2*:*:*:*)
! 	echo we32k-att-sysv3
! 	exit 0 ;;
!     *:QNX:*:42*)
! 	echo i386-qssl-qnx`echo ${UNAME_VERSION}`
! 	exit 0 ;;
!     # end cases added for Bash
!     alpha:OSF1:*:*)
! 	# A Vn.n version is a released version.
! 	# A Tn.n version is a released field test version.
! 	# A Xn.n version is an unreleased experimental baselevel.
! 	# 1.2 uses "1.2" for uname -r.
! 	echo alpha-dec-osf`echo ${UNAME_RELEASE} | sed -e 's/^[VTX]//'`
  	exit 0 ;;
      21064:Windows_NT:50:3)
  	echo alpha-dec-winnt3.5
  	exit 0 ;;
!     Amiga*:UNIX_System_V:4.0:*)
! 	echo m68k-cbm-sysv4
! 	exit 0;;
!     amiga:NetBSD:*:*)
! 	echo m68k-cbm-netbsd${UNAME_RELEASE}
! 	exit 0 ;;
!     amiga:OpenBSD:*:*)
! 	echo m68k-cbm-openbsd${UNAME_RELEASE}
  	exit 0 ;;
      arm:RISC*:1.[012]*:*|arm:riscix:1.[012]*:*)
***************
*** 150,153 ****
--- 176,180 ----
  	exit 0;;
      Pyramid*:OSx*:*:*|MIS*:OSx*:*:*)
+ 	# akee@wpdis03.wpafb.af.mil (Earle F. Ake) contributed MIS and NILE.
  	if test "`(/bin/universe) 2>/dev/null`" = att ; then
  		echo pyramid-pyramid-sysv3
***************
*** 157,181 ****
  	exit 0 ;;
      NILE:*:*:dcosx)
!         echo pyramid-pyramid-svr4
!         exit 0 ;;
!     concurrent*:*:*:*)
! 	if test "`(/bin/universe) 2>/dev/null`" = att ; then
! 		echo concurrent-concurrent-sysv3
! 	else
! 		echo concurrent-concurrent-bsd
! 	fi
! 	exit 0 ;;
!     ppc*:SunOS:5.*:*)
! 	echo ppc-sun-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
! 	exit 0 ;;
!     prep*:SunOS:5.*:*)
! 	echo powerpcle-unknown-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
! 	exit 0 ;;
!     i86pc:SunOS:5.*:*)
! 	echo i386-unknown-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
  	exit 0 ;;
      sun4*:SunOS:5.*:* | tadpole*:SunOS:5.*:*)
  	echo sparc-sun-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
  	exit 0 ;;
      sun4*:SunOS:6*:*)
  	# According to config.sub, this is the proper way to canonicalize
--- 184,195 ----
  	exit 0 ;;
      NILE:*:*:dcosx)
! 	echo pyramid-pyramid-svr4
  	exit 0 ;;
      sun4*:SunOS:5.*:* | tadpole*:SunOS:5.*:*)
  	echo sparc-sun-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
  	exit 0 ;;
+     i86pc:SunOS:5.*:*)
+ 	echo i386-pc-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
+ 	exit 0 ;;
      sun4*:SunOS:6*:*)
  	# According to config.sub, this is the proper way to canonicalize
***************
*** 197,251 ****
  	exit 0 ;;
      aushp:SunOS:*:*)
!         echo sparc-auspex-sunos${UNAME_RELEASE}
!         exit 0 ;;
!     RISC*:ULTRIX:*:*)
! 	echo mips-dec-ultrix${UNAME_RELEASE}
  	exit 0 ;;
!     VAX*:ULTRIX*:*:*)
! 	echo vax-dec-ultrix${UNAME_RELEASE}
  	exit 0 ;;
!     sparc:UNIX_SV:4.*:*)
! 	echo sparc-unknown-sysv${UNAME_RELEASE}
  	exit 0 ;;
!     mips:UNIX_SV:4.*:*)
! 	echo mips-mips-sysv${UNAME_RELEASE}
  	exit 0 ;;
!     mips:OSF*1:*:*)
! 	echo mips-mips-osf1
  	exit 0 ;;
!     mips:4.4BSD:*:*)
! 	echo mips-mips-bsd4.4
  	exit 0 ;;
      mips:*:*:UMIPS | mips:*:*:RISCos)
!         sed 's/^        //' << EOF >dummy.c
!         int main (argc, argv) int argc; char **argv; {
!         #if defined (host_mips) && defined (MIPSEB)
!         #if defined (SYSTYPE_SYSV)
!           printf ("mips-mips-riscos%ssysv\n", argv[1]); exit (0);
!         #endif
!         #if defined (SYSTYPE_SVR4)
!           printf ("mips-mips-riscos%ssvr4\n", argv[1]); exit (0);
!         #endif
!         #if defined (SYSTYPE_BSD43) || defined(SYSTYPE_BSD)
!           printf ("mips-mips-riscos%sbsd\n", argv[1]); exit (0);
!         #endif
!         #endif
!           exit (-1);
!         }
  EOF
!         ${CC-cc} dummy.c -o dummy \
!           && ./dummy `echo "${UNAME_RELEASE}" | sed -n 's/\([0-9]*\).*/\1/p'` \
!           && rm dummy.c dummy && exit 0
!         rm -f dummy.c dummy
!         echo mips-mips-riscos${UNAME_RELEASE}
!         exit 0 ;;
!     MIServer-S:SMP_DC.OSx:*:dcosx)
! 	echo mips-pyramid-sysv4
  	exit 0 ;;
      Night_Hawk:Power_UNIX:*:*)
! 	echo powerpc-harris-powerunix
! 	exit 0 ;;
!     news*:NEWS*:*:*)
! 	echo mips-sony-newsos${UNAME_RELEASE}
  	exit 0 ;;
      m88k:CX/UX:7*:*)
--- 211,271 ----
  	exit 0 ;;
      aushp:SunOS:*:*)
! 	echo sparc-auspex-sunos${UNAME_RELEASE}
  	exit 0 ;;
!     atari*:NetBSD:*:*)
! 	echo m68k-atari-netbsd${UNAME_RELEASE}
  	exit 0 ;;
!     atari*:OpenBSD:*:*)
! 	echo m68k-atari-openbsd${UNAME_RELEASE}
  	exit 0 ;;
!     sun3*:NetBSD:*:*)
! 	echo m68k-sun-netbsd${UNAME_RELEASE}
  	exit 0 ;;
!     sun3*:OpenBSD:*:*)
! 	echo m68k-sun-openbsd${UNAME_RELEASE}
  	exit 0 ;;
!     mac68k:NetBSD:*:*)
! 	echo m68k-apple-netbsd${UNAME_RELEASE}
! 	exit 0 ;;
!     mac68k:OpenBSD:*:*)
! 	echo m68k-apple-openbsd${UNAME_RELEASE}
! 	exit 0 ;;
!     powerpc:machten:*:*)
! 	echo powerpc-apple-machten${UNAME_RELEASE}
! 	exit 0 ;;
!     RISC*:Mach:*:*)
! 	echo mips-dec-mach_bsd4.3
! 	exit 0 ;;
!     RISC*:ULTRIX:*:*)
! 	echo mips-dec-ultrix${UNAME_RELEASE}
! 	exit 0 ;;
!     VAX*:ULTRIX*:*:*)
! 	echo vax-dec-ultrix${UNAME_RELEASE}
  	exit 0 ;;
      mips:*:*:UMIPS | mips:*:*:RISCos)
! 	sed 's/^	//' << EOF >dummy.c
! 	int main (argc, argv) int argc; char **argv; {
! 	#if defined (host_mips) && defined (MIPSEB)
! 	#if defined (SYSTYPE_SYSV)
! 	  printf ("mips-mips-riscos%ssysv\n", argv[1]); exit (0);
! 	#endif
! 	#if defined (SYSTYPE_SVR4)
! 	  printf ("mips-mips-riscos%ssvr4\n", argv[1]); exit (0);
! 	#endif
! 	#if defined (SYSTYPE_BSD43) || defined(SYSTYPE_BSD)
! 	  printf ("mips-mips-riscos%sbsd\n", argv[1]); exit (0);
! 	#endif
! 	#endif
! 	  exit (-1);
! 	}
  EOF
! 	${CC-cc} dummy.c -o dummy \
! 	  && ./dummy `echo "${UNAME_RELEASE}" | sed -n 's/\([0-9]*\).*/\1/p'` \
! 	  && rm dummy.c dummy && exit 0
! 	rm -f dummy.c dummy
! 	echo mips-mips-riscos${UNAME_RELEASE}
  	exit 0 ;;
      Night_Hawk:Power_UNIX:*:*)
! 	echo powerpc-harris-powerux
  	exit 0 ;;
      m88k:CX/UX:7*:*)
***************
*** 259,265 ****
  	exit 0 ;;
      AViiON:dgux:*:*)
!         # DG/UX returns AViiON for all architectures
!         UNAME_PROCESSOR=`uname -p`
!         if [ $UNAME_PROCESSOR = mc88100 -o $UNAME_PROCESSOR = mc88110 ] ; then
  	if [ ${TARGET_BINARY_INTERFACE}x = m88kdguxelfx \
  	     -o ${TARGET_BINARY_INTERFACE}x = x ] ; then
--- 279,285 ----
  	exit 0 ;;
      AViiON:dgux:*:*)
! 	# DG/UX returns AViiON for all architectures
! 	UNAME_PROCESSOR=`/usr/bin/uname -p`
! 	if [ $UNAME_PROCESSOR = mc88100 -o $UNAME_PROCESSOR = mc88110 ] ; then
  	if [ ${TARGET_BINARY_INTERFACE}x = m88kdguxelfx \
  	     -o ${TARGET_BINARY_INTERFACE}x = x ] ; then
***************
*** 268,273 ****
  		echo m88k-dg-dguxbcs${UNAME_RELEASE}
  	fi
!         else echo i586-dg-dgux${UNAME_RELEASE}
!         fi
   	exit 0 ;;
      M88*:DolphinOS:*:*)	# DolphinOS (SVR3)
--- 288,293 ----
  		echo m88k-dg-dguxbcs${UNAME_RELEASE}
  	fi
! 	else echo i586-dg-dgux${UNAME_RELEASE}
! 	fi
   	exit 0 ;;
      M88*:DolphinOS:*:*)	# DolphinOS (SVR3)
***************
*** 284,293 ****
  	echo m68k-tektronix-bsd
  	exit 0 ;;
-     i?86:NEXTSTEP:*:*)
- 	echo i386-next-nextstep${RELEASE}
- 	exit 0 ;;
-     *680?0:NEXTSTEP:*:*)
- 	echo m68k-next-nextstep${RELEASE}
- 	exit 0 ;;    
      *:IRIX*:*:*)
  	echo mips-sgi-irix`echo ${UNAME_RELEASE}|sed -e 's/-/_/g'`
--- 304,307 ----
***************
*** 299,305 ****
  	echo i386-ibm-aix
  	exit 0 ;;
-     *370:AIX:*:*)
- 	echo ibm370-ibm-aix
- 	exit 0 ;;
      *:AIX:2:3)
  	if grep bos325 /usr/include/stdio.h >/dev/null 2>&1; then
--- 313,316 ----
***************
*** 348,352 ****
  	exit 0 ;;
      ibmrt:*BSD:*|romp-ibm:BSD:*)            # covers RT/PC NetBSD and
! 	echo romp-ibm-bsd${UNAME_RELEASE}   # 4.3 with uname added to 
  	exit 0 ;;                           # report: romp-ibm BSD 4.3
      *:BOSX:*:*)
--- 359,363 ----
  	exit 0 ;;
      ibmrt:*BSD:*|romp-ibm:BSD:*)            # covers RT/PC NetBSD and
! 	echo romp-ibm-bsd${UNAME_RELEASE}   # 4.3 with uname added to
  	exit 0 ;;                           # report: romp-ibm BSD 4.3
      *:BOSX:*:*)
***************
*** 366,370 ****
  	    9000/31? )            HP_ARCH=m68000 ;;
  	    9000/[34]?? )         HP_ARCH=m68k ;;
! 	    9000/7?? | 9000/8?[679] ) HP_ARCH=hppa1.1 ;;
  	    9000/8?? )            HP_ARCH=hppa1.0 ;;
  	esac
--- 377,381 ----
  	    9000/31? )            HP_ARCH=m68000 ;;
  	    9000/[34]?? )         HP_ARCH=m68k ;;
! 	    9000/7?? | 9000/8?[1679] ) HP_ARCH=hppa1.1 ;;
  	    9000/8?? )            HP_ARCH=hppa1.0 ;;
  	esac
***************
*** 414,417 ****
--- 425,435 ----
  	echo hppa1.0-hp-osf
  	exit 0 ;;
+     i?86:OSF1:*:*)
+ 	if [ -x /usr/sbin/sysversion ] ; then
+ 	    echo ${UNAME_MACHINE}-pc-osf1mk
+ 	else
+ 	    echo ${UNAME_MACHINE}-pc-osf1
+ 	fi
+ 	exit 0 ;;
      parisc*:Lites*:*:*)
  	echo hppa1.1-hp-lites
***************
*** 460,465 ****
  	echo f301-fujitsu-uxpv`echo $UNAME_RELEASE | sed 's/ .*//'`
  	exit 0 ;;
      i?86:BSD/386:*:* | *:BSD/OS:*:*)
! 	echo ${UNAME_MACHINE}-unknown-bsdi${UNAME_RELEASE}
  	exit 0 ;;
      *:FreeBSD:*:*)
--- 478,489 ----
  	echo f301-fujitsu-uxpv`echo $UNAME_RELEASE | sed 's/ .*//'`
  	exit 0 ;;
+     hp3[0-9][05]:NetBSD:*:*)
+ 	echo m68k-hp-netbsd${UNAME_RELEASE}
+ 	exit 0 ;;
+     hp3[0-9][05]:OpenBSD:*:*)
+ 	echo m68k-hp-openbsd${UNAME_RELEASE}
+ 	exit 0 ;;
      i?86:BSD/386:*:* | *:BSD/OS:*:*)
! 	echo ${UNAME_MACHINE}-pc-bsdi${UNAME_RELEASE}
  	exit 0 ;;
      *:FreeBSD:*:*)
***************
*** 474,481 ****
      i*:CYGWIN*:*)
  	echo i386-pc-cygwin32
!         exit 0 ;;
      p*:CYGWIN*:*)
!         echo powerpcle-unknown-cygwin32
!         exit 0 ;;
      *:GNU:*:*)
  	echo `echo ${UNAME_MACHINE}|sed -e 's,/.*$,,'`-unknown-gnu`echo ${UNAME_RELEASE}|sed -e 's,/.*$,,'`
--- 498,508 ----
      i*:CYGWIN*:*)
  	echo i386-pc-cygwin32
! 	exit 0 ;;
      p*:CYGWIN*:*)
! 	echo powerpcle-unknown-cygwin32
! 	exit 0 ;;
!     prep*:SunOS:5.*:*)
! 	echo powerpcle-unknown-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
! 	exit 0 ;;
      *:GNU:*:*)
  	echo `echo ${UNAME_MACHINE}|sed -e 's,/.*$,,'`-unknown-gnu`echo ${UNAME_RELEASE}|sed -e 's,/.*$,,'`
***************
*** 485,503 ****
  	# first see if it will tell us.
  	ld_help_string=`ld --help 2>&1`
! 	if echo $ld_help_string | grep >/dev/null 2>&1 "supported emulations: elf_i[345]86"; then
! 	  echo "${UNAME_MACHINE}-unknown-linux" ; exit 0
! 	elif echo $ld_help_string | grep >/dev/null 2>&1 "supported emulations: i[345]86linux"; then
! 	  echo "${UNAME_MACHINE}-unknown-linuxaout" ; exit 0
! 	elif echo $ld_help_string | grep >/dev/null 2>&1 "supported emulations: i[345]86coff"; then
! 	  echo "${UNAME_MACHINE}-unknown-linuxcoff" ; exit 0
  	elif test "${UNAME_MACHINE}" = "alpha" ; then
! 	  echo alpha-unknown-linux ; exit 0
  	elif test "${UNAME_MACHINE}" = "sparc" ; then
! 	  echo sparc-unknown-linux ; exit 0
  	else
! 	  # Either a pre-BFD a.out linker (linuxoldld) or one that does not give us
! 	  # useful --help.  Gcc wants to distinguish between linuxoldld and linuxaout.
  	  test ! -d /usr/lib/ldscripts/. \
! 	    && echo "${UNAME_MACHINE}-unknown-linuxoldld" && exit 0
  	  # Determine whether the default compiler is a.out or elf
  	  cat >dummy.c <<EOF
--- 512,536 ----
  	# first see if it will tell us.
  	ld_help_string=`ld --help 2>&1`
! 	if echo "$ld_help_string" | grep >/dev/null 2>&1 "supported emulations: elf_i.86"; then
! 	  echo "${UNAME_MACHINE}-pc-linux-gnu" ; exit 0
! 	elif echo "$ld_help_string" | grep >/dev/null 2>&1 "supported emulations: i.86linux"; then
! 	  echo "${UNAME_MACHINE}-pc-linux-gnuaout" ; exit 0
! 	elif echo "$ld_help_string" | grep >/dev/null 2>&1 "supported emulations: i.86coff"; then
! 	  echo "${UNAME_MACHINE}-pc-linux-gnucoff" ; exit 0
! 	elif echo "$ld_help_string" | grep >/dev/null 2>&1 "supported emulations: m68kelf"; then
! 	  echo "${UNAME_MACHINE}-unknown-linux-gnu" ; exit 0
! 	elif echo "$ld_help_string" | grep >/dev/null 2>&1 "supported emulations: m68klinux"; then
! 	  echo "${UNAME_MACHINE}-unknown-linux-gnuaout" ; exit 0
! 	elif echo "$ld_help_string" | grep >/dev/null 2>&1 "supported emulations: elf32ppc"; then
! 	  echo "powerpc-unknown-linux-gnu" ; exit 0
  	elif test "${UNAME_MACHINE}" = "alpha" ; then
! 	  echo alpha-unknown-linux-gnu ; exit 0
  	elif test "${UNAME_MACHINE}" = "sparc" ; then
! 	  echo sparc-unknown-linux-gnu ; exit 0
  	else
! 	  # Either a pre-BFD a.out linker (linux-gnuoldld) or one that does not give us
! 	  # useful --help.  Gcc wants to distinguish between linux-gnuoldld and linux-gnuaout.
  	  test ! -d /usr/lib/ldscripts/. \
! 	    && echo "${UNAME_MACHINE}-pc-linux-gnuoldld" && exit 0
  	  # Determine whether the default compiler is a.out or elf
  	  cat >dummy.c <<EOF
***************
*** 507,513 ****
  {
  #ifdef __ELF__
!   printf ("%s-unknown-linux\n", argv[1]);
  #else
!   printf ("%s-unknown-linuxaout\n", argv[1]);
  #endif
    return 0;
--- 540,546 ----
  {
  #ifdef __ELF__
!   printf ("%s-pc-linux-gnu\n", argv[1]);
  #else
!   printf ("%s-pc-linux-gnuaout\n", argv[1]);
  #endif
    return 0;
***************
*** 522,533 ****
  	echo i386-sequent-sysv4
  	exit 0 ;;
-     i?86:OSF1:*:*)
- 	echo i386-unknown-osf1
- 	exit 0 ;;
      i?86:*:4.*:* | i?86:SYSTEM_V:4.*:* | i[34]86:UNIX_SV:4.*:*)
  	if grep Novell /usr/include/link.h >/dev/null 2>/dev/null; then
  		echo ${UNAME_MACHINE}-univel-sysv${UNAME_RELEASE}
  	else
! 		echo ${UNAME_MACHINE}-unknown-sysv${UNAME_RELEASE}
  	fi
  	exit 0 ;;
--- 555,563 ----
  	echo i386-sequent-sysv4
  	exit 0 ;;
      i?86:*:4.*:* | i?86:SYSTEM_V:4.*:* | i[34]86:UNIX_SV:4.*:*)
  	if grep Novell /usr/include/link.h >/dev/null 2>/dev/null; then
  		echo ${UNAME_MACHINE}-univel-sysv${UNAME_RELEASE}
  	else
! 		echo ${UNAME_MACHINE}-pc-sysv${UNAME_RELEASE}
  	fi
  	exit 0 ;;
***************
*** 535,539 ****
  	if test -f /usr/options/cb.name; then
  		UNAME_REL=`sed -n 's/.*Version //p' </usr/options/cb.name`
! 		echo ${UNAME_MACHINE}-unknown-isc$UNAME_REL
  	elif /bin/uname -X 2>/dev/null >/dev/null ; then
  		UNAME_REL=`(/bin/uname -X|egrep Release|sed -e 's/.*= //')`
--- 565,569 ----
  	if test -f /usr/options/cb.name; then
  		UNAME_REL=`sed -n 's/.*Version //p' </usr/options/cb.name`
! 		echo ${UNAME_MACHINE}-pc-isc$UNAME_REL
  	elif /bin/uname -X 2>/dev/null >/dev/null ; then
  		UNAME_REL=`(/bin/uname -X|egrep Release|sed -e 's/.*= //')`
***************
*** 541,551 ****
  		(/bin/uname -X|egrep '^Machine.*Pentium' >/dev/null) \
  			&& UNAME_MACHINE=i586
! 		echo ${UNAME_MACHINE}-unknown-sco$UNAME_REL
  	else
! 		echo ${UNAME_MACHINE}-unknown-sysv32
  	fi
  	exit 0 ;;
      Intel:Mach:3*:*)
! 	echo i386-unknown-mach3
  	exit 0 ;;
      paragon:*:*:*)
--- 571,581 ----
  		(/bin/uname -X|egrep '^Machine.*Pentium' >/dev/null) \
  			&& UNAME_MACHINE=i586
! 		echo ${UNAME_MACHINE}-pc-sco$UNAME_REL
  	else
! 		echo ${UNAME_MACHINE}-pc-sysv32
  	fi
  	exit 0 ;;
      Intel:Mach:3*:*)
! 	echo i386-pc-mach3
  	exit 0 ;;
      paragon:*:*:*)
***************
*** 559,568 ****
  	fi
  	exit 0 ;;
-     ksr1:OSF*1:*:*)
- 	echo ksr1-ksr-osf1
- 	exit 0 ;;
-     esa:OSF*1:*:* | ESA:OSF*:*:*)
- 	echo esa-ibm-osf1
- 	exit 0 ;;
      mini*:CTIX:SYS*5:*)
  	# "miniframe"
--- 589,592 ----
***************
*** 576,582 ****
  	&& OS_REL=.`sed -n 's/[^ ]* [^ ]* \([0-9][0-9]\).*/\1/p' < /etc/.relid`
  	/bin/uname -p 2>/dev/null | grep 86 >/dev/null \
!           && echo i486-ncr-sysv4.3${OS_REL} && exit 0
!         /bin/uname -p 2>/dev/null | /bin/grep entium >/dev/null \
!           && echo i586-ncr-sysv4.3${OS_REL} && exit 0 ;;
      3[34]??:*:4.0:* | 3[34]??,*:*:4.0:*)
  	/bin/uname -p 2>/dev/null | grep 86 >/dev/null \
--- 600,606 ----
  	&& OS_REL=.`sed -n 's/[^ ]* [^ ]* \([0-9][0-9]\).*/\1/p' < /etc/.relid`
  	/bin/uname -p 2>/dev/null | grep 86 >/dev/null \
! 	  && echo i486-ncr-sysv4.3${OS_REL} && exit 0
! 	/bin/uname -p 2>/dev/null | /bin/grep entium >/dev/null \
! 	  && echo i586-ncr-sysv4.3${OS_REL} && exit 0 ;;
      3[34]??:*:4.0:* | 3[34]??,*:*:4.0:*)
  	/bin/uname -p 2>/dev/null | grep 86 >/dev/null \
***************
*** 586,599 ****
  	exit 0 ;;
      m68*:LynxOS:2.*:*)
! 	echo m68k-lynx-lynxos${UNAME_RELEASE}
  	exit 0 ;;
      i?86:LynxOS:2.*:*)
! 	echo i386-lynx-lynxos${UNAME_RELEASE}
  	exit 0 ;;
      TSUNAMI:LynxOS:2.*:*)
! 	echo sparc-lynx-lynxos${UNAME_RELEASE}
  	exit 0 ;;
      rs6000:LynxOS:2.*:* | PowerPC:LynxOS:2.*:*)
! 	echo rs6000-lynx-lynxos${UNAME_RELEASE}
  	exit 0 ;;
      *:LynxOS:*:*)
--- 610,623 ----
  	exit 0 ;;
      m68*:LynxOS:2.*:*)
! 	echo m68k-unknown-lynxos${UNAME_RELEASE}
  	exit 0 ;;
      i?86:LynxOS:2.*:*)
! 	echo i386-pc-lynxos${UNAME_RELEASE}
  	exit 0 ;;
      TSUNAMI:LynxOS:2.*:*)
! 	echo sparc-unknown-lynxos${UNAME_RELEASE}
  	exit 0 ;;
      rs6000:LynxOS:2.*:* | PowerPC:LynxOS:2.*:*)
! 	echo rs6000-unknown-lynxos${UNAME_RELEASE}
  	exit 0 ;;
      *:LynxOS:*:*)
***************
*** 601,608 ****
  	exit 0 ;;
      SM[BE]S:UNIX_SV:*:*)
!         echo mips-dde-sysv${UNAME_RELEASE}
!         exit 0 ;;
!     DNP*:DNIX:*:*)
! 	echo m68k-dnix-sysv
  	exit 0 ;;
      RM*:SINIX-*:*:*)
--- 625,629 ----
  	exit 0 ;;
      SM[BE]S:UNIX_SV:*:*)
! 	echo mips-dde-sysv${UNAME_RELEASE}
  	exit 0 ;;
      RM*:SINIX-*:*:*)
***************
*** 618,629 ****
  	exit 0 ;;
      *:UNIX_System_V:4*:FTX*)
!         # From Gerald Hewes <hewes@openmarket.com>.
!         # How about differentiating between stratus architectures? -djm
!         echo hppa1.1-stratus-sysv4
!         exit 0 ;;
      *:*:*:FTX*)
!         # From seanf@swdc.stratus.com.
!         echo i860-stratus-sysv4
!         exit 0 ;;              
      mc68*:A/UX:*:*)
  	echo m68k-apple-aux${UNAME_RELEASE}
--- 639,650 ----
  	exit 0 ;;
      *:UNIX_System_V:4*:FTX*)
! 	# From Gerald Hewes <hewes@openmarket.com>.
! 	# How about differentiating between stratus architectures? -djm
! 	echo hppa1.1-stratus-sysv4
! 	exit 0 ;;
      *:*:*:FTX*)
! 	# From seanf@swdc.stratus.com.
! 	echo i860-stratus-sysv4
! 	exit 0 ;;              
      mc68*:A/UX:*:*)
  	echo m68k-apple-aux${UNAME_RELEASE}
***************
*** 638,646 ****
      PENTIUM:CPunix:4.0*:*) # Unisys `ClearPath HMP IX 4000' SVR4/MP effort
                             # says <Richard.M.Bartel@ccMail.Census.GOV>
!         echo i586-unisys-sysv4 
!         exit 0 ;;              
!     *3b2*:*:*:*)
! 	echo we32k-att-sysv3
! 	exit 0 ;;
  esac
  
--- 659,664 ----
      PENTIUM:CPunix:4.0*:*) # Unisys `ClearPath HMP IX 4000' SVR4/MP effort
                             # says <Richard.M.Bartel@ccMail.Census.GOV>
! 	echo i586-unisys-sysv4 
! 	exit 0 ;;              
  esac
  
***************
*** 690,694 ****
    int version;
    version=`(hostinfo | sed -n 's/.*NeXT Mach \([0-9]*\).*/\1/p') 2>/dev/null`;
!   printf ("%s-next-nextstep%s\n", __ARCHITECTURE__,  version==2 ? "2" : "3");
    exit (0);
  #endif
--- 708,712 ----
    int version;
    version=`(hostinfo | sed -n 's/.*NeXT Mach \([0-9]*\).*/\1/p') 2>/dev/null`;
!   printf ("%s-next-nextstep%d\n", __ARCHITECTURE__,  version);
    exit (0);
  #endif
***************
*** 707,711 ****
  
  #if defined (__386BSD__)
!   printf ("i386-unknown-bsd\n"); exit (0);
  #endif
  
--- 725,729 ----
  
  #if defined (__386BSD__)
!   printf ("i386-pc-bsd\n"); exit (0);
  #endif
  
***************
*** 746,749 ****
--- 764,768 ----
  #endif
  
+ /* Begin cases added for Bash */
  #if defined (tahoe)
    printf ("tahoe-cci-bsd\n"); exit (0);
***************
*** 783,787 ****
  
  #if defined (qnx) && defined (i386)
!   printf ("i386-unknown-qnx\n"); exit (0);
  #endif
  
--- 802,806 ----
  
  #if defined (qnx) && defined (i386)
!   printf ("i386-pc-qnx\n"); exit (0);
  #endif
  
***************
*** 850,853 ****
--- 869,874 ----
  #endif
  
+ /* End cases added for Bash */
+ 
    exit (1);
  }
***************
*** 887,890 ****
--- 908,912 ----
  fi
  
+ # Begin cases added for Bash
  case "$UNAME" in
  uts) echo uts-amdahl-sysv${UNAME_RELEASE}; exit 0 ;;
***************
*** 899,902 ****
--- 921,925 ----
  	exit 0
  fi
+ # end cases added for Bash
  
  #echo '(Unable to guess system type)' 1>&2
diff -Nrc2 bash-2.0/support/config.sub bash-2.01/support/config.sub
*** bash-2.0/support/config.sub	Fri Sep 13 10:37:36 1996
--- bash-2.01/support/config.sub	Wed Feb  5 10:59:26 1997
***************
*** 4,8 ****
  # This file is (in principle) common to ALL GNU software.
  # The presence of a machine in this file suggests that SOME GNU software
! # can handle that machine.  It does not imply ALL GNU software can. 
  #
  # This file is free software; you can redistribute it and/or modify
--- 4,8 ----
  # This file is (in principle) common to ALL GNU software.
  # The presence of a machine in this file suggests that SOME GNU software
! # can handle that machine.  It does not imply ALL GNU software can.
  #
  # This file is free software; you can redistribute it and/or modify
***************
*** 42,45 ****
--- 42,47 ----
  # machine specification into a single specification in the form:
  #	CPU_TYPE-MANUFACTURER-OPERATING_SYSTEM
+ # or in some cases, the newer four-part form:
+ #	CPU_TYPE-MANUFACTURER-KERNEL-OPERATING_SYSTEM
  # It is wrong to echo any other type of specification.
  
***************
*** 63,71 ****
  esac
  
! # Separate what the user gave into CPU-COMPANY and OS (if any).
! basic_machine=`echo $1 | sed 's/-[^-]*$//'`
! if [ $basic_machine != $1 ]
! then os=`echo $1 | sed 's/.*-/-/'`
! else os=; fi
  
  ### Let's recognize common machines as not being operating systems so
--- 65,83 ----
  esac
  
! # Separate what the user gave into CPU-COMPANY and OS or KERNEL-OS (if any).
! # Here we must recognize all the valid KERNEL-OS combinations.
! maybe_os=`echo $1 | sed 's/^\(.*\)-\([^-]*-[^-]*\)$/\2/'`
! case $maybe_os in
!   linux-gnu*)
!     os=-$maybe_os
!     basic_machine=`echo $1 | sed 's/^\(.*\)-\([^-]*-[^-]*\)$/\1/'`
!     ;;
!   *)
!     basic_machine=`echo $1 | sed 's/-[^-]*$//'`
!     if [ $basic_machine != $1 ]
!     then os=`echo $1 | sed 's/.*-/-/'`
!     else os=; fi
!     ;;
! esac
  
  ### Let's recognize common machines as not being operating systems so
***************
*** 82,86 ****
  	-convergent* | -ncr* | -news | -32* | -3600* | -3100* | -hitachi* |\
  	-c[123]* | -convex* | -sun | -crds | -omron* | -dg | -ultra | -tti* | \
! 	-harris | -dolphin | -highlevel | -gould | -cbm | -ns | -masscomp )
  		os=
  		basic_machine=$1
--- 94,99 ----
  	-convergent* | -ncr* | -news | -32* | -3600* | -3100* | -hitachi* |\
  	-c[123]* | -convex* | -sun | -crds | -omron* | -dg | -ultra | -tti* | \
! 	-harris | -dolphin | -highlevel | -gould | -cbm | -ns | -masscomp | \
! 	-apple)
  		os=
  		basic_machine=$1
***************
*** 91,115 ****
  	-sco5)
  		os=sco3.2v5
! 		basic_machine=`echo $1 | sed -e 's/86-.*/86-unknown/'`
  		;;
  	-sco4)
  		os=-sco3.2v4
! 		basic_machine=`echo $1 | sed -e 's/86-.*/86-unknown/'`
  		;;
  	-sco3.2.[4-9]*)
  		os=`echo $os | sed -e 's/sco3.2./sco3.2v/'`
! 		basic_machine=`echo $1 | sed -e 's/86-.*/86-unknown/'`
  		;;
  	-sco3.2v[4-9]*)
  		# Don't forget version if it is 3.2v4 or newer.
! 		basic_machine=`echo $1 | sed -e 's/86-.*/86-unknown/'`
  		;;
  	-sco*)
  		os=-sco3.2v2
! 		basic_machine=`echo $1 | sed -e 's/86-.*/86-unknown/'`
  		;;
  	-isc)
  		os=-isc2.2
! 		basic_machine=`echo $1 | sed -e 's/86-.*/86-unknown/'`
  		;;
  	-clix*)
--- 104,128 ----
  	-sco5)
  		os=sco3.2v5
! 		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
  		;;
  	-sco4)
  		os=-sco3.2v4
! 		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
  		;;
  	-sco3.2.[4-9]*)
  		os=`echo $os | sed -e 's/sco3.2./sco3.2v/'`
! 		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
  		;;
  	-sco3.2v[4-9]*)
  		# Don't forget version if it is 3.2v4 or newer.
! 		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
  		;;
  	-sco*)
  		os=-sco3.2v2
! 		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
  		;;
  	-isc)
  		os=-isc2.2
! 		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
  		;;
  	-clix*)
***************
*** 117,121 ****
  		;;
  	-isc*)
! 		basic_machine=`echo $1 | sed -e 's/86-.*/86-unknown/'`
  		;;
  	-lynx*)
--- 130,134 ----
  		;;
  	-isc*)
! 		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
  		;;
  	-lynx*)
***************
*** 128,131 ****
--- 141,147 ----
  		os=`echo $os | sed -e 's/windowsnt/winnt/'`
  		;;
+ 	-psos*)
+ 		os=-psos
+ 		;;
  esac
  
***************
*** 134,146 ****
  	# Recognize the basic CPU types without company name.
  	# Some are omitted here because they have special meanings below.
! 	tahoe | i[3456]86 | i860 | m68k | m68000 | m88k | ns32k | arm \
  		| arme[lb] | pyramid \
! 		| tron | a29k | 580 | i960 | h8300 | hppa1.0 | hppa1.1 \
! 		| alpha | we32k | ns16k | clipper | sparclite | i370 | sh \
! 		| powerpc | powerpcle | sparc64 | 1750a | dsp16xx | mips64 | mipsel \
  		| pdp11 | mips64el | mips64orion | mips64orionel \
! 		| sparc)
  		basic_machine=$basic_machine-unknown
  		;;
  	# Object if more than one company name word.
  	*-*-*)
--- 150,168 ----
  	# Recognize the basic CPU types without company name.
  	# Some are omitted here because they have special meanings below.
! 	tahoe | i860 | m68k | m68000 | m88k | ns32k | arm \
  		| arme[lb] | pyramid \
! 		| tron | a29k | 580 | i960 | h8300 | hppa | hppa1.0 | hppa1.1 \
! 		| alpha | we32k | ns16k | clipper | i370 | sh \
! 		| powerpc | powerpcle | 1750a | dsp16xx | mips64 | mipsel \
  		| pdp11 | mips64el | mips64orion | mips64orionel \
! 		| sparc | sparclet | sparclite | sparc64)
  		basic_machine=$basic_machine-unknown
  		;;
+ 	# We use `pc' rather than `unknown'
+ 	# because (1) that's what they normally are, and
+ 	# (2) the word "unknown" tends to confuse beginning users.
+ 	i[3456]86)
+ 	  basic_machine=$basic_machine-pc
+ 	  ;;
  	# Object if more than one company name word.
  	*-*-*)
***************
*** 153,161 ****
  	      | mips-* | pyramid-* | tron-* | a29k-* | romp-* | rs6000-* | power-* \
  	      | none-* | 580-* | cray2-* | h8300-* | i960-* | xmp-* | ymp-* \
! 	      | hppa1.0-* | hppa1.1-* | alpha-* | we32k-* | cydra-* | ns16k-* \
  	      | pn-* | np1-* | xps100-* | clipper-* | orion-* | sparclite-* \
- 	      | c90-* | t90-* \
  	      | pdp11-* | sh-* | powerpc-* | powerpcle-* | sparc64-* | mips64-* | mipsel-* \
! 	      | mips64el-* | mips64orion-* | mips64orionel-* | butterfly-bbn* \
  	      | cadmus-* | ews*-nec | ibmrt-ibm* | masscomp-masscomp \
  	      | tandem-* | symmetric-* | drs6000-icl | *-*ardent | gould-gould \
--- 175,183 ----
  	      | mips-* | pyramid-* | tron-* | a29k-* | romp-* | rs6000-* | power-* \
  	      | none-* | 580-* | cray2-* | h8300-* | i960-* | xmp-* | ymp-* \
! 	      | hppa-* | hppa1.0-* | hppa1.1-* | alpha-* | we32k-* | cydra-* | ns16k-* \
  	      | pn-* | np1-* | xps100-* | clipper-* | orion-* | sparclite-* \
  	      | pdp11-* | sh-* | powerpc-* | powerpcle-* | sparc64-* | mips64-* | mipsel-* \
! 	      | mips64el-* | mips64orion-* | mips64orionel-* | f301-* \
! 	      | butterfly-bbn* \
  	      | cadmus-* | ews*-nec | ibmrt-ibm* | masscomp-masscomp \
  	      | tandem-* | symmetric-* | drs6000-icl | *-*ardent | gould-gould \
***************
*** 165,169 ****
  	# Recognize the various machine names and aliases which stand
  	# for a CPU type and a company and sometimes even an OS.
! 	3b1 | 7300 | 7300-att | att-7300 | pc7300 | safari | unixpc*)
  		basic_machine=m68000-att
  		;;
--- 187,191 ----
  	# Recognize the various machine names and aliases which stand
  	# for a CPU type and a company and sometimes even an OS.
! 	3b1 | 7300 | 7300-att | att-7300 | pc7300 | safari | unixpc)
  		basic_machine=m68000-att
  		;;
***************
*** 200,203 ****
--- 222,229 ----
  		os=-sysv
  		;;
+ 	aux)
+ 		basic_machine=m68k-apple
+ 		os=-aux
+ 		;;
  	balance)
  		basic_machine=ns32k-sequent
***************
*** 224,235 ****
  		os=-bsd
  		;;
- 	c90)
- 		basic_machine=c90-cray
- 		os=-unicos
- 		;;
- 	t90)
- 		basic_machine=t90-cray
- 		os=-unicos
- 		;;
  	cray | ymp)
  		basic_machine=ymp-cray
--- 250,253 ----
***************
*** 240,243 ****
--- 258,265 ----
  		os=-unicos
  		;;
+ 	[ctj]90-cray)
+ 		basic_machine=c90-cray
+ 		os=-unicos
+ 		;;
  	crds | unos)
  		basic_machine=m68k-crds
***************
*** 324,327 ****
--- 346,352 ----
  		basic_machine=hppa1.0-hp
  		;;
+ 	hppa-next)
+ 		os=-nextstep3
+ 		;;
  	ibm032-*)
  		basic_machine=ibmrt-ibm
***************
*** 333,349 ****
  # I'm not sure what "Sysv32" means.  Should this be sysv3.2?
  	i[3456]86v32)
! 		basic_machine=`echo $1 | sed -e 's/86.*/86-unknown/'`
  		os=-sysv32
  		;;
  	i[3456]86v4*)
! 		basic_machine=`echo $1 | sed -e 's/86.*/86-unknown/'`
  		os=-sysv4
  		;;
  	i[3456]86v)
! 		basic_machine=`echo $1 | sed -e 's/86.*/86-unknown/'`
  		os=-sysv
  		;;
  	i[3456]86sol2)
! 		basic_machine=`echo $1 | sed -e 's/86.*/86-unknown/'`
  		os=-solaris2
  		;;
--- 358,374 ----
  # I'm not sure what "Sysv32" means.  Should this be sysv3.2?
  	i[3456]86v32)
! 		basic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`
  		os=-sysv32
  		;;
  	i[3456]86v4*)
! 		basic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`
  		os=-sysv4
  		;;
  	i[3456]86v)
! 		basic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`
  		os=-sysv
  		;;
  	i[3456]86sol2)
! 		basic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`
  		os=-solaris2
  		;;
***************
*** 567,570 ****
--- 592,598 ----
  		os=-vms
  		;;
+ 	vpp*|vx|vx-*)
+ 		basic_machine=f301-fujitsu
+ 		;;
  	vxworks960)
  		basic_machine=i960-wrs
***************
*** 646,649 ****
--- 674,679 ----
  then
  case $os in
+ 	# First match some system type aliases
+ 	# that might get confused with valid system types.
  	# -solaris* is a basic system type, with this one exception.
  	-solaris1 | -solaris1.*)
***************
*** 657,661 ****
  		;;
  	-gnu/linux*)
! 		os=`echo $os | sed -e 's|gnu/linux|linux|'`
  		;;
  	# First accept the basic system types.
--- 687,691 ----
  		;;
  	-gnu/linux*)
! 		os=`echo $os | sed -e 's|gnu/linux|linux-gnu|'`
  		;;
  	# First accept the basic system types.
***************
*** 664,678 ****
  	# -sysv* is not here because it comes later, after sysvr4.
  	-gnu* | -bsd* | -mach* | -minix* | -genix* | -ultrix* | -irix* \
! 	      | -vms* | -sco* | -esix* | -isc* | -aix* | -sunos | -sunos[3456]* \
  	      | -hpux* | -unos* | -osf* | -luna* | -dgux* | -solaris* | -sym* \
  	      | -amigados* | -msdos* | -newsos* | -unicos* | -aof* | -aos* \
! 	      | -nindy* | -vxworks* | -ebmon* | -hms* | -mvs* | -clix* \
! 	      | -riscos* | -linux* | -uniplus* | -iris* | -rtu* | -xenix* \
! 	      | -hiux* | -386bsd* | -netbsd* | -freebsd* | -riscix* \
  	      | -lynxos* | -bosx* | -nextstep* | -cxux* | -aout* | -elf* \
  	      | -ptx* | -coff* | -ecoff* | -winnt* | -domain* | -vsta* \
! 	      | -udi* | -eabi* | -lites* | -ieee* | -go32* | -qnx*)
  	# Remember, each alternative MUST END IN *, to match a version number.
  		;;
  	-sunos5*)
  		os=`echo $os | sed -e 's|sunos5|solaris2|'`
--- 694,713 ----
  	# -sysv* is not here because it comes later, after sysvr4.
  	-gnu* | -bsd* | -mach* | -minix* | -genix* | -ultrix* | -irix* \
! 	      | -*vms* | -sco* | -esix* | -isc* | -aix* | -sunos | -sunos[34]*\
  	      | -hpux* | -unos* | -osf* | -luna* | -dgux* | -solaris* | -sym* \
  	      | -amigados* | -msdos* | -newsos* | -unicos* | -aof* | -aos* \
! 	      | -nindy* | -vxsim* | -vxworks* | -ebmon* | -hms* | -mvs* \
! 	      | -clix* | -riscos* | -uniplus* | -iris* | -rtu* | -xenix* \
! 	      | -hiux* | -386bsd* | -netbsd* | -openbsd* | -freebsd* | -riscix* \
  	      | -lynxos* | -bosx* | -nextstep* | -cxux* | -aout* | -elf* \
  	      | -ptx* | -coff* | -ecoff* | -winnt* | -domain* | -vsta* \
! 	      | -udi* | -eabi* | -lites* | -ieee* | -go32* | -aux* \
! 	      | -cygwin32* | -pe* | -psos* | -moss* | -proelf* | -rtems* \
! 	      | -linux-gnu* | -uxpv* | -qnx* | -powerux)
  	# Remember, each alternative MUST END IN *, to match a version number.
  		;;
+ 	-linux*)
+ 		os=`echo $os | sed -e 's|linux|linux-gnu|'`
+ 		;;
  	-sunos5*)
  		os=`echo $os | sed -e 's|sunos5|solaris2|'`
***************
*** 845,848 ****
--- 880,886 ----
  		os=-rtu
  		;;
+ 	f301-fujitsu)
+ 		os=-uxpv
+ 		;;
  	*)
  		os=-none
***************
*** 893,898 ****
  				vendor=sequent
  				;;
! 			-vxworks*)
  				vendor=wrs
  				;;
  		esac
--- 931,939 ----
  				vendor=sequent
  				;;
! 			-vxsim* | -vxworks*)
  				vendor=wrs
+ 				;;
+ 			-aux*)
+ 				vendor=apple
  				;;
  		esac
diff -Nrc2 bash-2.0/support/mkconffiles bash-2.01/support/mkconffiles
*** bash-2.0/support/mkconffiles	Wed Dec 31 19:00:00 1969
--- bash-2.01/support/mkconffiles	Wed Mar 12 12:37:04 1997
***************
*** 0 ****
--- 1,65 ----
+ #! /bin/sh
+ #
+ # mkconffiles - create _distribution and _patchlevel files in preparation
+ #		for recreating `configure' from `configure.in'
+ #
+ # options:
+ #	-s srcdir	directory where `configure' resides (defaults to `.')
+ #	-d outdir	directory where the files should be written (defaults
+ #			to "$srcdir")
+ #	-v		verbose
+ #	-n		nocreate - don't create the output files
+ #
+ # Chet Ramey
+ # chet@po.cwru.edu
+ 
+ PROG=`basename $0`
+ 
+ # defaults
+ srcdir=.
+ 
+ distname="_distribution"
+ patchname="_patchlevel"
+ 
+ while [ $# -gt 0 ]; do
+ 	case "$1" in
+ 	-s)	shift; srcdir="$1"; shift;;
+ 	-d)	shift; outdir="$1"; shift;;
+ 	-v)	shift; verbose=yes ;;
+ 	-n)	shift; nocreate=yes;;
+ 	--)	shift; break;;
+ 	*)	echo "${PROG}: usage: ${PROG} [-s srcdir] [-d outdir] [-nv]" >&2; exit 2;;
+ 	esac
+ done
+ 
+ if [ ! -f ${srcdir}/configure ]; then
+ 	echo "${PROG}: ${srcdir}/configure not found" >&2
+ 	exit 1
+ fi
+ 
+ # default output directory to source directory
+ if [ -z "$outdir" ]; then
+ 	outdir=${srcdir}
+ fi
+ 
+ DISTRIB=`grep '^BASHVERS' ${srcdir}/configure | sed 's:.*=::'`
+ PATCH=`grep '^BASHPATCH' ${srcdir}/configure | sed 's:.*=::'`
+ 
+ if [ -n "$verbose" ]; then
+ 	echo "${PROG}: creating new distribution files for bash-${DISTRIB}.${PATCH} in ${outdir}"
+ fi
+ 
+ distout=${outdir}/${distname}
+ patchout=${outdir}/${patchname}
+ 
+ if [ -z "$nocreate" ]; then
+ 	echo "$DISTRIB" > $distout
+ 	echo "$PATCH"   > $patchout
+ fi
+ 
+ if [ -n "$verbose" ]; then
+ 	echo "${PROG}: created $distout and $patchout"
+ fi
+ 
+ exit 0
+ 
diff -Nrc2 bash-2.0/support/mksignames.c bash-2.01/support/mksignames.c
*** bash-2.0/support/mksignames.c	Wed Nov 20 11:32:17 1996
--- bash-2.01/support/mksignames.c	Tue Feb 11 14:19:19 1997
***************
*** 49,61 ****
  
    /* Place signal names which can be aliases for more common signal
!      names first.  This allows (for example) SIGEMT to overwrite SIGGRANT. */
  #if defined (SIGGRANT)	/* HFT monitor mode granted */
    signal_names[SIGGRANT] = "SIGGRANT";
  #endif
  
  #if defined (SIGRETRACT) /* HFT monitor mode retracted */
    signal_names[SIGRETRACT] = "SIGRETRACT";
  #endif
  
  #if defined (SIGHUP)	/* hangup */
    signal_names[SIGHUP] = "SIGHUP";
--- 49,147 ----
  
    /* Place signal names which can be aliases for more common signal
!      names first.  This allows (for example) SIGABRT to overwrite SIGLOST. */
! /* AIX */
! #if defined (SIGLOST)	/* resource lost (eg, record-lock lost) */
!   signal_names[SIGLOST] = "SIGLOST";
! #endif
! 
! #if defined (SIGMSG)	/* HFT input data pending */
!   signal_names[SIGMSG] = "SIGMSG";
! #endif
! 
! #if defined (SIGDANGER)	/* system crash imminent */
!   signal_names[SIGDANGER] = "SIGDANGER";
! #endif
! 
! #if defined (SIGMIGRATE) /* migrate process to another CPU */
!   signal_names[SIGMIGRATE] = "SIGMIGRATE";
! #endif
! 
! #if defined (SIGPRE)	/* programming error */
!   signal_names[SIGPRE] = "SIGPRE";
! #endif
! 
! #if defined (SIGVIRT)	/* AIX virtual time alarm */
!   signal_names[SIGVIRT] = "SIGVIRT";
! #endif
! 
! #if defined (SIGALRM1)	/* m:n condition variables */
!   signal_names[SIGALRM1] = "SIGALRM1";
! #endif
! 
! #if defined (SIGWAITING)	/* m:n scheduling */
!   signal_names[SIGWAITING] = "SIGWAITING";
! #endif
! 
  #if defined (SIGGRANT)	/* HFT monitor mode granted */
    signal_names[SIGGRANT] = "SIGGRANT";
  #endif
  
+ #if defined (SIGKAP)	/* keep alive poll from native keyboard */
+   signal_names[SIGKAP] = "SIGKAP";
+ #endif
+ 
  #if defined (SIGRETRACT) /* HFT monitor mode retracted */
    signal_names[SIGRETRACT] = "SIGRETRACT";
  #endif
  
+ #if defined (SIGSOUND)	/* HFT sound sequence has completed */
+   signal_names[SIGSOUND] = "SIGSOUND";
+ #endif
+ 
+ #if defined (SIGSAK)	/* Secure Attention Key */
+   signal_names[SIGSAK] = "SIGSAK";
+ #endif
+ 
+ /* SunOS5 */
+ #if defined (SIGLWP)	/* special signal used by thread library */
+   signal_names[SIGLWP] = "SIGLWP";
+ #endif
+ 
+ #if defined (SIGFREEZE)	/* special signal used by CPR */
+   signal_names[SIGFREEZE] = "SIGFREEZE";
+ #endif
+ 
+ #if defined (SIGTHAW)	/* special signal used by CPR */
+   signal_names[SIGTHAW] = "SIGTHAW";
+ #endif
+ 
+ #if defined (SIGCANCEL)	/* thread cancellation signal used by libthread */
+   signal_names[SIGCANCEL] = "SIGCANCEL";
+ #endif
+ 
+ /* HP-UX */
+ #if defined (SIGDIL)	/* DIL signal (?) */
+   signal_names[SIGDIL] = "SIGDIL";
+ #endif
+ 
+ /* System V */
+ #if defined (SIGCLD)	/* Like SIGCHLD.  */
+   signal_names[SIGCLD] = "SIGCLD";
+ #endif
+ 
+ #if defined (SIGPWR)	/* power state indication */
+   signal_names[SIGPWR] = "SIGPWR";
+ #endif
+ 
+ #if defined (SIGPOLL)	/* Pollable event (for streams)  */
+   signal_names[SIGPOLL] = "SIGPOLL";
+ #endif
+ 
+ /* Unknown */
+ #if defined (SIGWINDOW)
+   signal_names[SIGWINDOW] = "SIGWINDOW";
+ #endif
+ 
+ /* Common */
  #if defined (SIGHUP)	/* hangup */
    signal_names[SIGHUP] = "SIGHUP";
***************
*** 78,89 ****
  #endif
  
- #if defined (SIGABRT)	/* Cause current process to dump core. */
-   signal_names[SIGABRT] = "SIGABRT";
- #endif
- 
  #if defined (SIGIOT)	/* IOT instruction */
    signal_names[SIGIOT] = "SIGIOT";
  #endif
  
  #if defined (SIGEMT)	/* EMT instruction */
    signal_names[SIGEMT] = "SIGEMT";
--- 164,175 ----
  #endif
  
  #if defined (SIGIOT)	/* IOT instruction */
    signal_names[SIGIOT] = "SIGIOT";
  #endif
  
+ #if defined (SIGABRT)	/* Cause current process to dump core. */
+   signal_names[SIGABRT] = "SIGABRT";
+ #endif
+ 
  #if defined (SIGEMT)	/* EMT instruction */
    signal_names[SIGEMT] = "SIGEMT";
***************
*** 122,137 ****
  #endif
  
- #if defined (SIGCLD)	/* Like SIGCHLD.  */
-   signal_names[SIGCLD] = "SIGCLD";
- #endif
- 
- #if defined (SIGPWR)	/* Magic thing for some machines. */
-   signal_names[SIGPWR] = "SIGPWR";
- #endif
- 
- #if defined (SIGPOLL)	/* For keyboard input?  */
-   signal_names[SIGPOLL] = "SIGPOLL";
- #endif
- 
  #if defined (SIGURG)	/* urgent condition on IO channel */
    signal_names[SIGURG] = "SIGURG";
--- 208,211 ----
***************
*** 186,191 ****
  #endif
  
! #if defined (SIGLOST)	/* resource lost (eg, record-lock lost) */
!   signal_names[SIGLOST] = "SIGLOST";
  #endif
  
--- 260,266 ----
  #endif
  
! /* 4.4 BSD */
! #if defined (SIGINFO)	/* information request */
!   signal_names[SIGINFO] = "SIGINFO";
  #endif
  
***************
*** 196,235 ****
  #if defined (SIGUSR2)	/* user defined signal 2 */
    signal_names[SIGUSR2] = "SIGUSR2";
- #endif
- 
- #if defined (SIGMSG)	/* HFT input data pending */
-   signal_names[SIGMSG] = "SIGMSG";
- #endif
- 
- #if defined (SIGPWR)	/* power failure imminent (save your data) */
-   signal_names[SIGPWR] = "SIGPWR";
- #endif
- 
- #if defined (SIGDANGER)	/* system crash imminent */
-   signal_names[SIGDANGER] = "SIGDANGER";
- #endif
- 
- #if defined (SIGMIGRATE) /* migrate process to another CPU */
-   signal_names[SIGMIGRATE] = "SIGMIGRATE";
- #endif
- 
- #if defined (SIGPRE)	/* programming error */
-   signal_names[SIGPRE] = "SIGPRE";
- #endif
- 
- #if defined (SIGSOUND)	/* HFT sound sequence has completed */
-   signal_names[SIGSOUND] = "SIGSOUND";
- #endif
- 
- #if defined (SIGWINDOW)
-   signal_names[SIGWINDOW] = "SIGWINDOW";
- #endif
- 
- #if defined (SIGDIL)
-   signal_names[SIGDIL] = "SIGDIL";
- #endif
- 
- #if defined (SIGSAK)	/* Secure Attention Key */
-   signal_names[SIGSAK] = "SIGSAK";
  #endif
  
--- 271,274 ----
diff -Nrc2 bash-2.0/support/mkversion.c bash-2.01/support/mkversion.c
*** bash-2.0/support/mkversion.c	Thu Nov  7 09:16:30 1996
--- bash-2.01/support/mkversion.c	Wed Dec 31 19:00:00 1969
***************
*** 1,305 ****
- /* Simple program to make new version numbers for the shell.
-    Big deal, but it was getting out of hand to do everything
-    in the makefile. */
- 
- /* Copyright (C) 1989 Free Software Foundation, Inc.
- 
- This file is part of GNU Bash, the Bourne Again SHell.
- 
- Bash is free software; you can redistribute it and/or modify it under
- the terms of the GNU General Public License as published by the Free
- Software Foundation; either version 1, or (at your option) any later
- version.
- 
- Bash is distributed in the hope that it will be useful, but WITHOUT ANY
- WARRANTY; without even the implied warranty of MERCHANTABILITY or
- FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- for more details.
- 
- You should have received a copy of the GNU General Public License along
- with Bash; see the file COPYING.  If not, write to the Free Software
- Foundation, 675 Mass Ave, Cambridge, MA 02139, USA. */
- 
- #include "config.h"
- 
- #include <sys/types.h>
- #include "posixstat.h"
- #include <stdio.h>
- #include "bashansi.h"
- 
- char *progname;
- char *dir;
- char *status;
- 
- FILE *must_open ();
- 
- main (argc, argv)
-      int argc;
-      char **argv;
- {
-   FILE *file;
-   float distver = 0.0;
-   int buildver = 0, patchlevel = 0;
-   int dist = 0, build = 0, patch = 0;
-   int dist_inc = 0, build_inc = 0, patch_inc = 0;
-   int dot_dist_needs_making = 0;
-   int arg_index = 1;
-   struct stat sb;
- 
-   progname = argv[0];
- 
-   status = dir = (char *)0;
-   while (arg_index < argc && argv[arg_index][0] == '-')
-     {
-       if (strcmp (argv[arg_index], "-dist") == 0)
-         {
- 	  dist++;
- 	  dist_inc++;
-         }
-       else if (strcmp (argv[arg_index], "-build") == 0)
-         {
- 	  build++;
- 	  build_inc++;
-         }
-       else if (strcmp (argv[arg_index], "-patch") == 0)
-         {
-           patch++;
- 	  patch_inc++;
-         }
-       else if (strcmp (argv[arg_index], "-dir") == 0)
- 	{
- 	  dir = argv[++arg_index];
- 	  if (dir == 0)
- 	    {
- 	      fprintf (stderr, "%s: `-dir' requires an argument\n", progname);
- 	      exit (1);
- 	    }
- 	  if (stat (dir, &sb) < 0)
- 	    {
- 	      fprintf (stderr, "%s: cannot stat %s\n", progname, dir);
- 	      exit (1);
- 	    }
- 	  if ((sb.st_mode & S_IFMT) != S_IFDIR)
- 	    {
- 	      fprintf (stderr, "%s: not a directory\n", progname);
- 	      exit (1);
- 	    }
- 	}
-       else if (strcmp (argv[arg_index], "-status") == 0)
-         {
-           status = argv[++arg_index];
- 	  if (status == 0)
- 	    {
- 	      fprintf (stderr, "%s: `-status' requires an argument\n", progname);
- 	      exit (1);
- 	    }
-         }
-       else
- 	{
- 	  fprintf (stderr, "%s: unknown option: %s\n", progname, argv[arg_index]);
- 	  fprintf (stderr, "usage: %s [-dist|-patch|-build] [-dir directory]\n", progname);
- 	  exit (1);
- 	}
-       arg_index++;
-     }
- 
-   if (get_float_from_file (".distribution", &distver, 1) == 0)
-     dot_dist_needs_making++;
- 
-   if (get_int_from_file (".patchlevel", &patchlevel, 1) == 0)
-     {
-       patchlevel = 0;
-       patch_inc = 0;
-     }
- 
-   if (get_int_from_file (".build", &buildver, 0) == 0)
-     buildver = 0;
- 
-   /* Setting distribution version. */
-   if (dist && arg_index < argc)
-     if (sscanf (argv[arg_index], "%f", &distver) != 1)
-       {
- 	fprintf (stderr, "%s: Bad input `%s'.  Expected float value for -dist.\n",
- 		 progname, argv[arg_index]);
- 	exit (1);
-       }
-     else
-       {
- 	arg_index++;
- 	dist_inc = 0;
-       }
- 
-   /* Setting patchlevel via argument. */
-   if (patch && arg_index < argc)
-     if (sscanf (argv[arg_index], "%d", &patchlevel) != 1)
-       {
- 	fprintf (stderr, "%s: Bad input `%s'.  Expected int value for -patch.\n",
- 		 progname, argv[arg_index]);
- 	exit (1);
-       }
-     else
-       {
- 	arg_index++;
- 	patch_inc = 0;
-       }
-     
-   if (build && arg_index < argc)
-     if (sscanf (argv[arg_index], "%d", &buildver) != 1)
-       {
- 	fprintf (stderr, "%s: Bad input `%s'.  Expected int value for -build.\n",
- 		 progname, argv[arg_index]);
- 	exit (1);
-       }
-     else
-       {
- 	arg_index++;
- 	build_inc = 0;
-       }
- 
-   if (dot_dist_needs_making && !distver)
-     {
-       fprintf (stderr, "%s: There is no `.distribution' file to infer from.\n", progname);
-       exit (1);
-     }
- 
-   if (dist_inc)
-     distver = distver + 0.01;
- 
-   if (patch_inc)
-     patchlevel++;
- 
-   if (build_inc)
-     buildver++;
- 
-   file = must_open ("newversion.h", "w");
- 
-   /* Output the leading comment. */
-   fprintf (file, 
- "/* Version control for the shell.  This file gets changed when you say\n\
-    `make newversion' to the Makefile.  It is created by mkversion. */\n");
- 
-   fprintf (file, "\n/* The distribution version number of this shell. */\n");
-   fprintf (file, "#define DISTVERSION \"%.2f\"\n", distver);
- 
-   fprintf (file, "\n/* The patch level of this version of the shell. */\n");
-   fprintf (file, "#define PATCHLEVEL %d\n", patchlevel);
- 
-   fprintf (file, "\n/* The last built version of this shell. */\n");
-   fprintf (file, "#define BUILDVERSION %d\n", buildver);
- 
-   if (status)
-     {
-       fprintf (file, "\n/* The release status of this shell. */\n");
-       fprintf (file, "#define RELSTATUS \"%s\"\n", status);
-     }
- 
-   fprintf (file, "\n/* A version string for use by sccs and the what command. */\n\n");
-   if (status)
-     fprintf (file, "#define SCCSVERSION \"@(#)Bash version %.2f.%d(%d) %s GNU\"\n\n",
-       distver, patchlevel, buildver, status);
-   else
-     fprintf (file, "#define SCCSVERSION \"@(#)Bash version %.2f.%d(%d) GNU\"\n\n",
-       distver, patchlevel, buildver);
- 
-   fclose (file);
- 
-   file = must_open (".build", "w");
-   fprintf (file, "%d\n", buildver);
-   fclose (file);
- 
-   /* Making a new distribution. */
-   if (dist)
-     {
-       file = must_open (".distribution", "w");
-       fprintf (file, "%.2f\n", distver);
-       fclose (file);
-     }
- 
-   /* Releasing a new patch level. */
-   if (patch)
-     {
-       file = must_open (".patchlevel", "w");
-       fprintf (file, "%d\n", patchlevel);
-       fclose (file);
-     }
- 
-   exit (0);
- }
- 
- char *
- makename (fn, from_srcdir)
-      char *fn;
- {
-   char *ret;
-   int dlen;
- 
-   dlen = (from_srcdir && dir) ? strlen (dir) + 1 : 0;
-   ret = (char *)malloc (dlen + strlen (fn) + 1);
-   if (ret == 0)
-     {
-       fprintf (stderr, "%s: malloc failed\n", progname);
-       exit (1);
-     }
-   if (from_srcdir && dir)
-     sprintf (ret, "%s/%s", dir, fn);
-   else
-     (void)strcpy (ret, fn);
- 
-   return ret;
- }
- 
- get_float_from_file (filename, var, from_srcdir)
-      char *filename;
-      float *var;
-      int from_srcdir;
- {
-   FILE *stream;
-   int result;
-   char *name;
- 
-   name = makename (filename, from_srcdir);
-   stream = fopen (name, "r");
-   free (name);
-   if (stream == (FILE *)NULL)
-     return (0);
-   result = fscanf (stream, "%f\n", var);
-   fclose (stream);
-   return (result == 1);
- }
- 
- get_int_from_file (filename, var, from_srcdir)
-      char *filename;
-      int *var, from_srcdir;
- {
-   FILE *stream;
-   int result;
-   char *name;
- 
-   name = makename (filename, from_srcdir);
-   stream = fopen (name, "r");
-   free (name);
-   if (stream == (FILE *)NULL)
-     return (0);
-   result = fscanf (stream, "%d\n", var);
-   fclose (stream);
-   return (result == 1);
- }
- 
- FILE *
- must_open (name, mode)
-      char *name, *mode;
- {
-   FILE *temp = fopen (name, mode);
- 
-   if (!temp)
-     {
-       fprintf (stderr, "%s: Cannot open `%s' for mode `%s'.\n",
- 	       progname, name, mode);
-       fprintf
- 	(stderr,
- 	 "Perhaps you don't have %s permission to the file or directory.\n",
- 	 (strcmp (mode, "w") == 0) ? "write" : "read");
-       exit (3);
-     }
-   return (temp);
- }
--- 0 ----
diff -Nrc2 bash-2.0/support/mkversion.sh bash-2.01/support/mkversion.sh
*** bash-2.0/support/mkversion.sh	Wed Dec 31 19:00:00 1969
--- bash-2.01/support/mkversion.sh	Thu Jan 30 14:21:54 1997
***************
*** 0 ****
--- 1,105 ----
+ #! /bin/sh
+ 
+ # Simple program to make new version numbers for the shell.
+ # Big deal, but it was getting out of hand to do everything
+ # in the makefile.  This creates a file named by the -o option,
+ # otherwise everything is echoed to the standard output.
+ 
+ PROGNAME=`basename $0`
+ USAGE="$PROGNAME [-b] -d version -p patchlevel [-s status]"
+ 
+ while [ $# -gt 0 ]; do
+ 	case "$1" in
+ 	-o)	shift; OUTFILE=$1; shift ;;
+ 	-b)	shift; inc_build=yes ;;
+ 	-s)	shift; rel_status=$1; shift ;;
+ 	-p)	shift; patch_level=$1; shift ;;
+ 	-d)	shift; dist_version=$1; shift ;;
+ 	*)	echo "$PROGNAME: usage: $USAGE" >&2 ; exit 2 ;;
+ 	esac
+ done
+ 
+ # Required arguments
+ if [ -z "$dist_version" ]; then
+ 	echo "${PROGNAME}: required argument -d missing" >&2
+ 	echo "$PROGNAME: usage: $USAGE" >&2
+ 	exit 1
+ fi
+ 
+ if [ -z "$patch_level" ]; then
+ 	echo "${PROGNAME}: required argument -p missing" >&2
+ 	echo "$PROGNAME: usage: $USAGE" >&2
+ 	exit 1
+ fi
+ 
+ # Defaults
+ if [ -z "$rel_status" ]; then
+ 	rel_status="release"
+ fi
+ 
+ build_ver=
+ if [ -r .build ]; then
+ 	build_ver=`cat .build`
+ fi
+ if [ -z "$build_ver" ]; then
+ 	build_ver=0
+ fi
+ 
+ # increment the build version if that's what's required
+ 
+ if [ -n "$inc_build" ]; then
+ 	build_ver=`expr $build_ver + 1`
+ fi
+ 
+ # If we have an output file specified, make it the standard output
+ if [ -n "$OUTFILE" ]; then
+ 	if exec >$OUTFILE; then
+ 		:
+ 	else
+ 		echo "${PROGNAME}: cannot redirect standard output to $OUTFILE" >&2
+ 		exit 1
+ 	fi
+ fi
+ 
+ # Output the leading comment.
+ echo "/* Version control for the shell.  This file gets changed when you say"
+ echo "   \`make version.h' to the Makefile.  It is created by mkversion. */"
+ 
+ # Output the distribution version
+ float_dist=`echo $dist_version | awk '{printf "%.2f\n", $1}'`
+ 
+ echo
+ echo "/* The distribution version number of this shell. */"
+ echo "#define DISTVERSION \"${float_dist}\""
+ 
+ # Output the patch level
+ echo
+ echo "/* The patch level of this version of the shell. */"
+ echo "#define PATCHLEVEL ${patch_level}"
+ 
+ # Output the build version
+ echo
+ echo "/* The last built version of this shell. */"
+ echo "#define BUILDVERSION ${build_ver}"
+ 
+ # Output the release status
+ echo
+ echo "/* The release status of this shell. */"
+ echo "#define RELSTATUS \"${rel_status}\""
+ 
+ # Output the SCCS version string
+ sccs_string="${float_dist}.${patch_level}(${build_ver}) ${rel_status} GNU"
+ echo
+ echo "/* A version string for use by sccs and the what command. */"
+ echo "#define SCCSVERSION \"@(#)Bash version ${sccs_string}\""
+ 
+ if [ -n "$inc_build" ]; then
+ 	# Make sure we can write to .build
+ 	if [ -f .build ] && [ ! -w .build ]; then
+ 		echo "$PROGNAME: cannot write to .build, not incrementing build version" >&2
+ 	else
+ 		echo "$build_ver" > .build
+ 	fi
+ fi
+ 	
+ exit 0
diff -Nrc2 bash-2.0/support/printenv bash-2.01/support/printenv
*** bash-2.0/support/printenv	Sat Mar 26 16:14:42 1994
--- bash-2.01/support/printenv	Wed Dec 31 19:00:00 1969
***************
*** 1,11 ****
- #! /bin/sh -
- 
- if [ $# -eq 0 ]; then
- 	env
- 	exit
- elif eval [ "\${$1-unset}" = "unset" ]; then
- 	exit 1
- else
- 	eval echo \$$1
- 	exit 0
- fi
--- 0 ----
diff -Nrc2 bash-2.0/support/printenv.c bash-2.01/support/printenv.c
*** bash-2.0/support/printenv.c	Wed Dec 31 19:00:00 1969
--- bash-2.01/support/printenv.c	Tue Mar 25 13:49:20 1997
***************
*** 0 ****
--- 1,47 ----
+ /* printenv -- minimal clone of BSD printenv(1).
+ 
+    usage: printenv [varname]
+ 
+    Chet Ramey
+    chet@po.cwru.edu
+ */
+ 
+ extern char **environ;
+ 
+ int
+ main (argc, argv) 
+      int argc;
+      char **argv;
+ {
+   register char **envp, *eval;
+   int len;
+ 
+   argv++;
+   argc--;
+ 
+   /* printenv */
+   if (argc == 0)
+     {
+       for (envp = environ; *envp; envp++)
+ 	puts (*envp);
+       exit (0);
+     }
+ 
+   /* printenv varname */
+   len = strlen (*argv);
+   for (envp = environ; *envp; envp++)
+     {
+       if (**argv == **envp && strncmp (*envp, *argv, len) == 0)
+ 	{
+ 	  eval = *envp + len;
+ 	  /* If the environment variable doesn't have an `=', ignore it. */
+ 	  if (*eval == '=')
+ 	    {
+ 	      puts (eval + 1);
+ 	      exit (0);
+ 	    }
+ 	}
+     }
+   exit (1);
+ }
+   
diff -Nrc2 bash-2.0/support/printenv.sh bash-2.01/support/printenv.sh
*** bash-2.0/support/printenv.sh	Wed Dec 31 19:00:00 1969
--- bash-2.01/support/printenv.sh	Sat Mar 26 16:14:42 1994
***************
*** 0 ****
--- 1,11 ----
+ #! /bin/sh -
+ 
+ if [ $# -eq 0 ]; then
+ 	env
+ 	exit
+ elif eval [ "\${$1-unset}" = "unset" ]; then
+ 	exit 1
+ else
+ 	eval echo \$$1
+ 	exit 0
+ fi
diff -Nrc2 bash-2.0/support/recho.c bash-2.01/support/recho.c
*** bash-2.0/support/recho.c	Mon Apr  3 14:11:35 1995
--- bash-2.01/support/recho.c	Wed Feb 19 12:17:28 1997
***************
*** 1,4 ****
--- 1,7 ----
  #include <stdio.h>
  
+ void strprint();
+ 
+ int
  main(argc, argv)
  int	argc;
***************
*** 12,22 ****
  		printf(">\n");
  	}
  }
  
  strprint(str)
  char	*str;
  {
  	register char *s;
- 	int	c;
  
  	for (s = str; s && *s; s++) {
--- 15,26 ----
  		printf(">\n");
  	}
+ 	exit(0);
  }
  
+ void
  strprint(str)
  char	*str;
  {
  	register char *s;
  
  	for (s = str; s && *s; s++) {
***************
*** 30,33 ****
  			putchar(*s);
  	}
- 	return(0);
  }
--- 34,36 ----
diff -Nrc2 bash-2.0/support/xenix-link.sh bash-2.01/support/xenix-link.sh
*** bash-2.0/support/xenix-link.sh	Wed Dec 31 19:00:00 1969
--- bash-2.01/support/xenix-link.sh	Mon Jun  2 16:34:51 1997
***************
*** 0 ****
--- 1,68 ----
+ :
+ # link bash for Xenix under SCO Unix
+ #
+ # For xenix 2.2:
+ #	CC="cc -xenix -lx" ./configure
+ #	edit config.h:
+ #		comment out the define for HAVE_DIRENT_H
+ #		enable the define for HAVE_SYS_NDIR_H to 1
+ #	make
+ #	CC="cc -xenix -lx" ./link.sh
+ #
+ # For xenix 2.3:
+ #	CC="cc -x2.3" ./configure
+ #	make
+ #	CC="cc -x2.3" ./link.sh
+ 
+ set -x
+ 
+ rm -f bash
+ 
+ if [ -z "$CC" ]
+ then
+ 	if [ -f /unix -a ! -f /xenix ]
+ 	then
+ 		CC="cc -xenix"
+ 	else
+ 		CC=gcc
+ 	fi
+ fi
+ 
+ try_dir=no
+ try_23=no
+ try_x=yes
+ 
+ case "$CC" in
+ *-ldir*) try_dir=yes ;;
+ esac
+ 
+ case "$CC" in
+ *-lx*) try_23=no ; try_x=yes ;;
+ esac
+ 
+ case "$CC" in
+ *-x2.3*|*-l2.3*) try_23=yes ; try_dir=yes ;;
+ esac
+ 
+ libs=
+ try="socket"
+ if [ $try_dir = yes ] ; then try="$try dir" ; fi
+ if [ $try_23 = yes ] ; then try="$try 2.3" ; fi
+ if [ $try_x = yes ] ; then try="$try x" ; fi
+ for name in $try
+ do
+ 	if [ -r "/lib/386/Slib${name}.a" ] ; then libs="$libs -l$name" ; fi
+ done
+ 
+ $CC -o bash shell.o eval.o y.tab.o \
+ general.o make_cmd.o print_cmd.o dispose_cmd.o execute_cmd.o variables.o \
+ copy_cmd.o error.o expr.o flags.o nojobs.o subst.o hashcmd.o hashlib.o \
+ mailcheck.o trap.o input.o unwind_prot.o pathexp.o sig.o test.o \
+ version.o alias.o array.o braces.o bracecomp.o bashhist.o bashline.o \
+ getcwd.o siglist.o vprint.o oslib.o list.o stringlib.o locale.o \
+ xmalloc.o builtins/libbuiltins.a \
+ lib/readline/libreadline.a lib/readline/libhistory.a \
+ -ltermcap lib/glob/libglob.a lib/tilde/libtilde.a lib/malloc/libmalloc.a \
+ $libs
+ 
+ ls -l bash
diff -Nrc2 bash-2.0/test.c bash-2.01/test.c
*** bash-2.0/test.c	Mon Nov 11 11:50:58 1996
--- bash-2.01/test.c	Fri Apr 11 17:40:11 1997
***************
*** 21,28 ****
     Foundation, 675 Mass Ave, Cambridge, MA 02139, USA. */
  
- /* Define STANDALONE to get the /bin/test version.  Otherwise, you get
-    the shell builtin version. */
- /* #define STANDALONE */
- 
  /* Define PATTERN_MATCHING to get the csh-like =~ and !~ pattern-matching
     binary operators. */
--- 21,24 ----
***************
*** 35,43 ****
  #include <stdio.h>
  
! #if defined (STANDALONE)
! #  include <sys/types.h>
! #else
! #  include "bashtypes.h"
! #endif
  
  #if defined (HAVE_LIMITS_H)
--- 31,35 ----
  #include <stdio.h>
  
! #include "bashtypes.h"
  
  #if defined (HAVE_LIMITS_H)
***************
*** 57,80 ****
  #include "filecntl.h"
  
! #if !defined (STANDALONE)
! #  include "shell.h"
! #  include "builtins/common.h"
! #  define main test_command
! #  define isint legal_number
! #  define getuid() current_user.uid
! #  define geteuid() current_user.euid
! #  define getgid() current_user.gid
! #  define getegid() current_user.egid
! #else /* STANDALONE */
! #  if !defined (S_IXUGO)
! #    define S_IXUGO 0111
! #  endif
! #  if defined (HAVE_UNISTD_H)
! #    include <unistd.h>
! #  endif /* HAVE_UNISTD_H */
! #  define whitespace(c) (((c) == ' ') || ((c) == '\t'))
! #  define digit(c)  ((c) >= '0' && (c) <= '9')
! #  define digit_value(c) ((c) - '0')
! #endif /* STANDALONE */
  
  #if !defined (STRLEN)
--- 49,54 ----
  #include "filecntl.h"
  
! #include "shell.h"
! #include "builtins/common.h"
  
  #if !defined (STRLEN)
***************
*** 95,108 ****
  #endif /* !member */
  
- /* Make gid_t and uid_t mean something for non-posix systems. */
- #if defined (STANDALONE) && !defined (_POSIX_VERSION) && !defined (HAVE_UID_T)
- #  if !defined (gid_t)
- #    define gid_t int
- #  endif
- #  if !defined (uid_t)
- #    define uid_t int
- #  endif
- #endif /* STANDALONE && !_POSIX_VERSION && !HAVE_UID_T */
- 
  #if !defined (R_OK)
  #define R_OK 4
--- 69,72 ----
***************
*** 131,142 ****
  #define SHELL_BOOLEAN(value) (!(value))
  
- #if defined (STANDALONE)
- #  define test_exit(val) exit (val)
- #else
  static procenv_t test_exit_buf;
  static int test_error_return;
! #  define test_exit(val) \
  	do { test_error_return = val; longjmp (test_exit_buf, 1); } while (0)
- #endif /* STANDALONE */
  
  #if defined (AFS)
--- 95,102 ----
  #define SHELL_BOOLEAN(value) (!(value))
  
  static procenv_t test_exit_buf;
  static int test_error_return;
! #define test_exit(val) \
  	do { test_error_return = val; longjmp (test_exit_buf, 1); } while (0)
  
  #if defined (AFS)
***************
*** 154,160 ****
  static int noeval;
  
- #if defined (STANDALONE)
- static int isint ();
- #endif
  static int unop ();
  static int binop ();
--- 114,117 ----
***************
*** 176,185 ****
       char *format, *arg;
  {
- #if !defined (STANDALONE)
    extern int interactive_shell;
    extern char *get_name_for_error ();
    if (interactive_shell == 0)
      fprintf (stderr, "%s: ", get_name_for_error ());
- #endif
    fprintf (stderr, "%s: ", argv[0]);
    fprintf (stderr, format, arg);
--- 133,140 ----
***************
*** 205,209 ****
  #if !defined (HAVE_DEV_FD)
        long fd;
!       if (isint (path + 8, &fd))
  	return (fstat ((int)fd, finfo));
        else
--- 160,164 ----
  #if !defined (HAVE_DEV_FD)
        long fd;
!       if (legal_number (path + 8, &fd))
  	return (fstat ((int)fd, finfo));
        else
***************
*** 235,247 ****
  {
    struct stat st;
-   static int euid = -1;
  
    if (test_stat (path, &st) < 0)
      return (-1);
  
!   if (euid == -1)
!     euid = geteuid ();
! 
!   if (euid == 0)
      {
        /* Root can read or write any file. */
--- 190,198 ----
  {
    struct stat st;
  
    if (test_stat (path, &st) < 0)
      return (-1);
  
!   if (current_user.euid == 0)
      {
        /* Root can read or write any file. */
***************
*** 255,259 ****
      }
  
!   if (st.st_uid == euid)        /* owner */
      mode <<= 6;
    else if (group_member (st.st_gid))
--- 206,210 ----
      }
  
!   if (st.st_uid == current_user.euid)        /* owner */
      mode <<= 6;
    else if (group_member (st.st_gid))
***************
*** 266,337 ****
  }
  
- #if defined (HAVE_GETGROUPS)
- /* The number of groups that this user is a member of. */
- static int ngroups, maxgroups;
- static GETGROUPS_T *group_array = (GETGROUPS_T *)NULL;
- #endif /* HAVE_GETGROUPS */
- 
- #if !defined (NOGROUP)
- #  define NOGROUP (gid_t) -1
- #endif
- 
- #if defined (HAVE_GETGROUPS)
- 
- #  if defined (NGROUPS_MAX)
- #    define getmaxgroups() NGROUPS_MAX
- #  else /* !NGROUPS_MAX */
- #    if defined (NGROUPS)
- #      define getmaxgroups() NGROUPS
- #    else /* !NGROUPS */
- #      define getmaxgroups() 64
- #    endif /* !NGROUPS */
- #  endif /* !NGROUPS_MAX */
- 
- #endif /* HAVE_GETGROUPS */
- 
- /* Return non-zero if GID is one that we have in our groups list. */
- int
- group_member (gid)
-      gid_t gid;
- {
-   static gid_t pgid = (gid_t)NOGROUP;
-   static gid_t egid = (gid_t)NOGROUP;
- #if defined (HAVE_GETGROUPS)
-   register int i;
- #endif
- 
-   if (pgid == (gid_t)NOGROUP)
-     pgid = (gid_t) getgid ();
- 
-   if (egid == (gid_t)NOGROUP)
-     egid = (gid_t) getegid ();
- 
-   if (gid == pgid || gid == egid)
-     return (1);
- 
- #if defined (HAVE_GETGROUPS)
-   /* getgroups () returns the number of elements that it was able to
-      place into the array. */
-   if (ngroups == 0)
-     {
-       if (maxgroups == 0)
- 	maxgroups = getmaxgroups ();
-       group_array = (GETGROUPS_T *)xrealloc (group_array, maxgroups * sizeof (GETGROUPS_T));
-       ngroups = getgroups (maxgroups, group_array);
-     }
- 
-   /* In case of error, the user loses. */
-   if (ngroups <= 0)
-     return (0);
- 
-   /* Search through the list looking for GID. */
-   for (i = 0; i < ngroups; i++)
-     if (gid == (gid_t)group_array[i])
-       return (1);
- #endif /* HAVE_GETGROUPS */
- 
-   return (0);
- }
- 
  /* Increment our position in the argument list.  Check that we're not
     past the end of the argument list.  This check is supressed if the
--- 217,220 ----
***************
*** 359,424 ****
  }
  
- #if defined (STANDALONE)
- /* Return non-zero if the characters pointed to by STRING constitute a
-    valid number.  Stuff the converted number into RESULT if RESULT is
-    a non-null pointer to a long. */
- static int
- isint (string, result)
-      register char *string;
-      long *result;
- {
-   int sign;
-   long value;
- 
-   sign = 1;
-   value = 0;
- 
-   if (result)
-     *result = 0;
- 
-   /* Skip leading whitespace characters. */
-   while (whitespace (*string))
-     string++;
- 
-   if (!*string)
-     return (0);
- 
-   /* We allow leading `-' or `+'. */
-   if (*string == '-' || *string == '+')
-     {
-       if (!digit (string[1]))
- 	return (0);
- 
-       if (*string == '-')
- 	sign = -1;
- 
-       string++;
-     }
- 
-   while (digit (*string))
-     {
-       if (result)
- 	value = (value * 10) + digit_value (*string);
-       string++;
-     }
- 
-   /* Skip trailing whitespace, if any. */
-   while (whitespace (*string))
-     string++;
- 
-   /* Error if not at end of string. */
-   if (*string)
-     return (0);
- 
-   if (result)
-     {
-       value *= sign;
-       *result = value;
-     }
- 
-   return (1);
- }
- #endif /* STANDALONE */
- 
  /*
   * term - parse a term and return 1 or 0 depending on whether the term
--- 242,245 ----
***************
*** 472,478 ****
--- 293,311 ----
      }
  
+ #if 1
    /* are there enough arguments left that this could be dyadic? */
    if ((pos + 3 <= argc) && binop (argv[pos + 1]))
      value = binary_operator ();
+ #else
+   /* If this is supposed to be a binary operator, make sure there are
+      enough arguments and fail if there are not. */
+   if ((pos + 1 < argc) && binop (argv[pos+1]))
+     {
+       if (pos + 3 <= argc)
+         value = binary_operator ();
+       else
+         beyond ();
+     }
+ #endif
  
    /* Might be a switch type argument */
***************
*** 518,524 ****
    long l, r;
  
!   if (isint (s, &l) == 0)
      integer_expected_error (s);
!   if (isint (t, &r) == 0)
      integer_expected_error (t);
    switch (op)
--- 351,357 ----
    long l, r;
  
!   if (legal_number (s, &l) == 0)
      integer_expected_error (s);
!   if (legal_number (t, &r) == 0)
      integer_expected_error (t);
    switch (op)
***************
*** 667,676 ****
        unary_advance ();
        return (test_stat (argv[pos - 1], &stat_buf) == 0 &&
! 	      (uid_t) geteuid () == (uid_t) stat_buf.st_uid);
  
      case 'G':			/* File is owned by your group? */
        unary_advance ();
        return (test_stat (argv[pos - 1], &stat_buf) == 0 &&
! 	      (gid_t) getegid () == (gid_t) stat_buf.st_gid);
  
      case 'f':			/* File is a file? */
--- 500,509 ----
        unary_advance ();
        return (test_stat (argv[pos - 1], &stat_buf) == 0 &&
! 	      (uid_t) current_user.euid == (uid_t) stat_buf.st_uid);
  
      case 'G':			/* File is owned by your group? */
        unary_advance ();
        return (test_stat (argv[pos - 1], &stat_buf) == 0 &&
! 	      (gid_t) current_user.egid == (gid_t) stat_buf.st_gid);
  
      case 'f':			/* File is a file? */
***************
*** 757,761 ****
      case 't':	/* File fd is a terminal?  fd defaults to stdout. */
        advance (0);
!       if (pos < argc && isint (argv[pos], &r))
  	{
  	  advance (0);
--- 590,594 ----
      case 't':	/* File fd is a terminal?  fd defaults to stdout. */
        advance (0);
!       if (pos < argc && legal_number (argv[pos], &r))
  	{
  	  advance (0);
***************
*** 772,780 ****
        return (argv[pos - 1][0] == '\0');
  
- #if !defined (STANDALONE)
      case 'o':
        unary_advance ();
        return (minus_o_option_value (argv[pos - 1]) == 1);
- #endif /* !STANDALONE */
      }
  }
--- 605,611 ----
***************
*** 843,849 ****
    if (s[0] == '=' && s[1] == '\0')
      return (1);		/* '=' */
!   else if (s[1] == '\0' && (s[0] == '<' || s[0] == '>'))  /* string <, > */
      return (1);
!   else if (s[2] == '\0' && s[1] == '=' && (s[0] == '=' || s[0] == '!'))
      return (1);		/* `==' and `!=' */
  #if defined (PATTERN_MATCHING)
--- 674,680 ----
    if (s[0] == '=' && s[1] == '\0')
      return (1);		/* '=' */
!   else if ((s[0] == '<' || s[0] == '>') && s[1] == '\0')  /* string <, > */
      return (1);
!   else if ((s[0] == '=' || s[0] == '!') && s[1] == '=' && s[2] == '\0')
      return (1);		/* `==' and `!=' */
  #if defined (PATTERN_MATCHING)
***************
*** 903,909 ****
      case 'w': case 'x': case 'z':
      case 'G': case 'L': case 'O': case 'S':
- #if !defined (STANDALONE)
      case 'o':
- #endif
        return (1);
      }
--- 734,738 ----
***************
*** 1016,1020 ****
   */
  int
! main (margc, margv)
       int margc;
       char **margv;
--- 845,849 ----
   */
  int
! test_command (margc, margv)
       int margc;
       char **margv;
***************
*** 1022,1026 ****
    int value;
  
- #if !defined (STANDALONE)
    int code;
  
--- 851,854 ----
***************
*** 1029,1033 ****
    if (code)
      return (test_error_return);
- #endif /* !STANDALONE */
  
    argv = margv;
--- 857,860 ----
diff -Nrc2 bash-2.0/tests/arith.right bash-2.01/tests/arith.right
*** bash-2.0/tests/arith.right	Tue Nov 19 14:17:17 1996
--- bash-2.01/tests/arith.right	Thu Feb 27 11:23:34 1997
***************
*** 90,91 ****
--- 90,117 ----
  ./arith.tests: 0#4: bad number (error token is "0#4")
  ./arith.tests: 2#110#11: bad number (error token is "2#110#11")
+ abc
+ def
+ ghi
+ ok
+ 6
+ 1
+ 0
+ ./arith.tests: 4 + : syntax error: operand expected (error token is " ")
+ 16
+ ./arith.tests: 4 ? : 3 + 5 : expression expected (error token is ": 3 + 5 ")
+ ./arith.tests: 1 ? 20 : `:' expected for conditional expression (error token is " ")
+ ./arith.tests: 4 ? 20 : : expression expected (error token is " ")
+ 9
+ ./arith.tests: 0 && B=42 : attempted assignment to non-variable (error token is "=42 ")
+ 9
+ ./arith.tests: 1 || B=88 : attempted assignment to non-variable (error token is "=88 ")
+ 9
+ 0
+ 9
+ 0
+ 9
+ 1
+ 9
+ 7
+ 7
+ 4
diff -Nrc2 bash-2.0/tests/arith.tests bash-2.01/tests/arith.tests
*** bash-2.0/tests/arith.tests	Tue Nov 19 14:16:53 1996
--- bash-2.01/tests/arith.tests	Wed Apr 16 11:12:14 1997
***************
*** 1,2 ****
--- 1,3 ----
+ set +o posix
  declare -i iv jv
  
***************
*** 157,158 ****
--- 158,215 ----
  i=0#4
  i=2#110#11
+ 
+ ((echo abc; echo def;); echo ghi)
+ 
+ if (((4+4) + (4 + 7))); then
+ 	echo ok
+ fi
+ 
+ (())	# make sure the null expression works OK
+ 
+ a=(0 2 4 6)
+ echo $(( a[1] + a[2] ))
+ echo $(( (a[1] + a[2]) == a[3] ))
+ (( (a[1] + a[2]) == a[3] )) ; echo $?
+ 
+ # test pushing and popping the expression stack
+ unset A
+ A="4 + "
+ echo $(( ( 4 + A ) + 4 ))
+ A="3 + 5"
+ echo $(( ( 4 + A ) + 4 ))
+ 
+ # badly-formed conditional expressions
+ echo $(( 4 ? : $A ))
+ echo $(( 1 ? 20 ))
+ echo $(( 4 ? 20 : ))
+ 
+ # precedence and short-circuit evaluation
+ B=9
+ echo $B
+ 
+ echo $(( 0 && B=42 ))
+ echo $B
+ 
+ echo $(( 1 || B=88 ))
+ echo $B
+ 
+ echo $(( 0 && (B=42) ))
+ echo $B
+ 
+ echo $(( (${$} - $$) && (B=42) ))
+ echo $B
+ 
+ echo $(( 1 || (B=88) ))
+ echo $B
+ 
+ # until command with (( )) command
+ x=7
+ 
+ echo $x
+ until (( x == 4 ))
+ do
+ 	echo $x
+ 	x=4
+ done
+ 
+ echo $x
diff -Nrc2 bash-2.0/tests/array.right bash-2.01/tests/array.right
*** bash-2.0/tests/array.right	Thu Oct 17 10:51:37 1996
--- bash-2.01/tests/array.right	Tue Mar 25 14:00:05 1997
***************
*** 1,3 ****
--- 1,4 ----
  abcde
+ abcde
  abcde bdef
  abcde bdef
***************
*** 53,57 ****
  this is a test of read using arrays
  declare -a DIRSTACK='()'
- declare -a rv='([0]="this" [1]="is" [2]="a" [3]="test" [4]="of" [5]="read" [6]="using" [7]="arrays")'
  declare -ar a='([1]="" [2]="bdef" [5]="hello world" [6]="test expression")'
  declare -a b='([0]="this" [1]="is" [2]="a" [3]="test" [4]="" [5]="/etc/passwd")'
--- 54,57 ----
***************
*** 59,62 ****
--- 59,63 ----
  declare -a d='([1]="test test" [2]="bdef" [5]="hello world" [6]="test" [9]="ninth element")'
  declare -a f='([0]="" [1]="bdef" [2]="hello world" [3]="test" [4]="ninth element")'
+ declare -a rv='([0]="this" [1]="is" [2]="a" [3]="test" [4]="of" [5]="read" [6]="using" [7]="arrays")'
  abde
  abde
***************
*** 77,78 ****
--- 78,97 ----
  e f g
  h
+ /bin /usr/bin /usr/ucb /usr/local/bin . /sbin /usr/sbin
+ bin bin ucb bin . sbin sbin
+ bin
+ / / / / / /
+ /
+ \bin \usr/bin \usr/ucb \usr/local/bin . \sbin \usr/sbin
+ \bin \usr\bin \usr\ucb \usr\local\bin . \sbin \usr\sbin
+ \bin \usr\bin \usr\ucb \usr\local\bin . \sbin \usr\sbin
+ 4 -- 4
+ 7 -- 7
+ 55
+ 49
+ 6 -- 6
+ 42 14 44
+ grep [ 123 ] *
+ 6 7 9
+ 6 7 9 5
+ ./array.tests: narray: unbound variable
diff -Nrc2 bash-2.0/tests/array.tests bash-2.01/tests/array.tests
*** bash-2.0/tests/array.tests	Mon Dec 16 10:53:07 1996
--- bash-2.01/tests/array.tests	Wed Mar 19 10:32:48 1997
***************
*** 1,5 ****
--- 1,16 ----
+ # this is needed so that the bad assignments (b[]=bcde, for example) do not
+ # cause fatal shell errors when in posix mode
+ set +o posix
+ 
  set +a
  # The calls to egrep -v are to filter out builtin array variables that are
  # automatically set and possibly contain values that vary.
+ 
+ # make sure declare -a converts an existing variable to an array
+ unset a
+ a=abcde
+ declare -a a
+ echo ${a[0]}
+ 
  unset a
  a=abcde
***************
*** 24,28 ****
  
  # this should print out values, too
! declare -a | egrep -v '(BASH_VERSINFO|PIPESTATUS)'
  
  unset a[7]
--- 35,39 ----
  
  # this should print out values, too
! declare -a | egrep -v '(BASH_VERSINFO|PIPESTATUS|GROUPS)'
  
  unset a[7]
***************
*** 52,57 ****
  readonly a[5]
  readonly a
! readonly -a | egrep -v '(BASH_VERSINFO|PIPESTATUS)'
! declare -ar | egrep -v '(BASH_VERSINFO|PIPESTATUS)'
  
  declare -a d='([1]="" [2]="bdef" [5]="hello world" "test")'
--- 63,68 ----
  readonly a[5]
  readonly a
! readonly -a | egrep -v '(BASH_VERSINFO|PIPESTATUS|GROUPS)'
! declare -ar | egrep -v '(BASH_VERSINFO|PIPESTATUS|GROUPS)'
  
  declare -a d='([1]="" [2]="bdef" [5]="hello world" "test")'
***************
*** 67,71 ****
  echo ${b[@]:2:3}
  
! declare -a | egrep -v '(BASH_VERSINFO|PIPESTATUS)'
  
  a[3]="this is a test"
--- 78,82 ----
  echo ${b[@]:2:3}
  
! declare -pa | egrep -v '(BASH_VERSINFO|PIPESTATUS|GROUPS)'
  
  a[3]="this is a test"
***************
*** 85,89 ****
  unset e[*]
  
! declare -a | egrep -v '(BASH_VERSINFO|PIPESTATUS)'
  
  ps1='hello'
--- 96,100 ----
  unset e[*]
  
! declare -a | egrep -v '(BASH_VERSINFO|PIPESTATUS|GROUPS)'
  
  ps1='hello'
***************
*** 102,106 ****
  echo ${rv[@]}
  
! declare -a | egrep -v '(BASH_VERSINFO|PIPESTATUS)'
  
  export rv
--- 113,117 ----
  echo ${rv[@]}
  
! declare -a | egrep -v '(BASH_VERSINFO|PIPESTATUS|GROUPS)'
  
  export rv
***************
*** 130,131 ****
--- 141,201 ----
  	echo "$z"
  done
+ 
+ # do various pattern removal and length tests
+ XPATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:.:/sbin:/usr/sbin
+ 
+ xpath=( $( IFS=: ; echo $XPATH ) )
+ 
+ echo ${xpath[@]}
+ echo ${xpath[@]##*/}
+ echo ${xpath[0]##*/}
+ echo ${xpath[@]%%[!/]*}
+ echo ${xpath[0]%%[!/]*}
+ 
+ # let's try to make it a DOS-style path
+ 
+ zecho "${xpath[@]/\//\\}"
+ zecho "${xpath[@]//\//\\}"
+ zecho "${xpath[@]//[\/]/\\}"
+ 
+ # length of the first element of the array, since array without subscript
+ # is equivalent to referencing first element
+ echo ${#xpath} -- ${#xpath[0]}
+ 
+ # number of elements in the array
+ nelem=${#xpath[@]}
+ echo ${#xpath[@]} -- $nelem
+ 
+ # total length of all elements in the array, including space separators
+ xx="${xpath[*]}"
+ echo ${#xx}
+ 
+ # total length of all elements in the array
+ xx=$( IFS='' ; echo "${xpath[*]}" )
+ echo ${#xx}
+ 
+ unset xpath[nelem-1]
+ 
+ nelem=${#xpath[@]}
+ echo ${#xpath[@]} -- $nelem
+ 
+ # arrays and things that look like index assignments
+ array=(42 [1]=14 [2]=44)
+ 
+ array2=(grep [ 123 ] \*)
+ 
+ echo ${array[@]}
+ echo "${array2[@]}"
+ 
+ # arrays and implicit arithmetic evaluation
+ declare -i -a iarray
+ 
+ iarray=( 2+4 1+6 7+2 )
+ echo ${iarray[@]}
+ 
+ iarray[4]=4+1
+ echo ${iarray[@]}
+ 
+ # make sure the array code behaves correctly with respect to unset variables
+ set -u
+ ( echo ${#narray[4]} )
diff -Nrc2 bash-2.0/tests/braces-tests bash-2.01/tests/braces-tests
*** bash-2.0/tests/braces-tests	Tue Dec 13 16:57:59 1994
--- bash-2.01/tests/braces-tests	Wed Feb 19 11:30:00 1997
***************
*** 19,20 ****
--- 19,24 ----
  echo {
  echo abcd{efgh
+ 
+ echo foo {1,2} bar
+ echo `zecho foo {1,2} bar`
+ echo $(zecho foo {1,2} bar)
diff -Nrc2 bash-2.0/tests/braces.right bash-2.01/tests/braces.right
*** bash-2.0/tests/braces.right	Tue Dec 13 16:58:07 1994
--- bash-2.01/tests/braces.right	Wed Feb 19 11:30:11 1997
***************
*** 15,16 ****
--- 15,19 ----
  {
  abcd{efgh
+ foo 1 2 bar
+ foo 1 2 bar
+ foo 1 2 bar
diff -Nrc2 bash-2.0/tests/builtins.right bash-2.01/tests/builtins.right
*** bash-2.0/tests/builtins.right	Wed Dec 31 19:00:00 1969
--- bash-2.01/tests/builtins.right	Thu Mar 13 14:35:48 1997
***************
*** 0 ****
--- 1,113 ----
+ a
+ end-1
+ a
+ end-2
+ a:x
+ end-a
+ b:x
+ end-b
+ c:x
+ end-c
+ end-3
+ a:x
+ end
+ a
+ b
+ c
+ end-1
+ a
+ b
+ c
+ end-2
+ a:x
+ a:y
+ a:z
+ end-a
+ b:x
+ b:y
+ b:z
+ end-b
+ c:x
+ c:y
+ c:z
+ end-c
+ end-3
+ a:x
+ b:x
+ c:x
+ end
+ $BVAR
+ $BVAR
+ $BVAR
+ $BVAR
+ foo
+ bar
+ xxx
+ 022
+ u=rwx,g=rx,o=rx
+ 002
+ u=rwx,g=rwx,o=rx
+ u=rwx,g=rwx,o=rwx
+ enable .
+ enable :
+ enable break
+ enable continue
+ enable eval
+ enable exec
+ enable exit
+ enable export
+ enable readonly
+ enable return
+ enable set
+ enable shift
+ enable source
+ enable trap
+ enable unset
+ enable .
+ enable :
+ enable break
+ enable continue
+ enable eval
+ enable exec
+ enable exit
+ enable export
+ enable readonly
+ enable return
+ enable set
+ enable shift
+ enable source
+ enable trap
+ enable unset
+ enable -n test worked
+ enable test worked
+ specialname
+ FOO=BAR
+ FOO=BAR
+ hash: hash table empty
+ AVAR
+ foo
+ in source.sub2, calling return
+ 5
+ a b c
+ a b c
+ x y z
+ a b c
+ a b c
+ m n o p
+ a b c
+ m n o p
+ /tmp/bash-dir-a
+ /tmp/bash-dir-a
+ /tmp/bash-dir-a
+ AVAR
+ foo
+ foo
+ AVAR
+ foo
+ foo
+ AVAR
+ foo
+ ok
+ ok
+ ./builtins.tests: kill: bad signal number: 4096
+ 1
diff -Nrc2 bash-2.0/tests/builtins.sub1 bash-2.01/tests/builtins.sub1
*** bash-2.0/tests/builtins.sub1	Wed Dec 31 19:00:00 1969
--- bash-2.01/tests/builtins.sub1	Thu Feb 27 11:57:43 1997
***************
*** 0 ****
--- 1,14 ----
+ unset CDPATH
+ 
+ MYDIR=$(pwd -P)
+ FULLDIR=/tmp/bash-dir-a
+ DIR=${FULLDIR##*/}
+ 
+ mkdir $FULLDIR
+ CDPATH=.:/tmp
+ cd $DIR
+ pwd
+ echo $PWD
+ 
+ cd $MYDIR
+ rmdir $FULLDIR
diff -Nrc2 bash-2.0/tests/builtins.tests bash-2.01/tests/builtins.tests
*** bash-2.0/tests/builtins.tests	Wed Dec 31 19:00:00 1969
--- bash-2.01/tests/builtins.tests	Mon Mar 17 13:00:34 1997
***************
*** 0 ****
--- 1,201 ----
+ # tests for miscellaneous builtins not tested elsewhere
+ set +p
+ set +o posix
+ 
+ ulimit -c 0 2>/dev/null
+ 
+ # check that break breaks loops
+ for i in a b c; do echo $i; break; echo bad-$i; done
+ echo end-1
+ for i in a b c; do echo $i; break 1; echo bad-$i; done
+ echo end-2
+ for i in a b c; do
+ 	for j in x y z; do
+ 		echo $i:$j
+ 		break
+ 		echo bad-$i
+ 	done
+ 	echo end-$i
+ done
+ echo end-3
+ 
+ # check that break breaks nested loops
+ for i in a b c; do
+ 	for j in x y z; do
+ 		echo $i:$j
+ 		break 2
+ 		echo bad-$i
+ 	done
+ 	echo end-$i
+ done
+ echo end
+ 
+ # check that continue continues loops
+ for i in a b c; do echo $i; continue; echo bad-$i ; done
+ echo end-1
+ for i in a b c; do echo $i; continue 1; echo bad-$i; done
+ echo end-2
+ for i in a b c; do
+ 	for j in x y z; do
+ 		echo $i:$j
+ 		continue
+ 		echo bad-$i-$j
+ 	done
+ 	echo end-$i
+ done
+ echo end-3
+ 
+ # check that continue breaks out of nested loops
+ for i in a b c; do
+ 	for j in x y z; do
+ 		echo $i:$j
+ 		continue 2
+ 		echo bad-$i-$j
+ 	done
+ 	echo end-$i
+ done
+ echo end
+ 
+ # check that `eval' re-evaluates arguments, but `builtin' and `command' do not
+ AVAR='$BVAR'
+ BVAR=foo
+ 
+ echo $AVAR
+ builtin echo $AVAR
+ command echo $AVAR
+ eval echo \$AVAR
+ eval echo $AVAR
+ 
+ # test out eval with a temp environment
+ AVAR=bar eval echo \$AVAR
+ BVAR=xxx eval echo $AVAR
+ 
+ unset -v AVAR BVAR
+ 
+ # test umask
+ mask=$(umask)
+ umask 022
+ umask
+ umask -S
+ umask -S u=rwx,g=rwx,o=rx >/dev/null # 002
+ umask
+ umask -S
+ umask 0
+ umask -S
+ umask ${mask}	# restore original mask
+ 
+ # builtin/command without arguments should do nothing.  maybe someday they will
+ builtin
+ command
+ 
+ # test enable
+ enable -ps
+ 
+ enable -aps ; enable -nps
+ 
+ enable -n test
+ case "$(type -t test)" in
+ builtin)	echo oops -- enable -n test failed ;;
+ *)	echo enable -n test worked ;;
+ esac
+ 
+ enable test
+ case "$(type -t test)" in
+ builtin)	echo enable test worked ;;
+ *)	echo oops -- enable test failed ;;
+ esac
+ 
+ # test options to exec
+ (exec -a specialname ${THIS_SH} -c 'echo $0' )
+ # test `clean' environment.  if /bin/sh is bash, and the script version of
+ # printenv is run, there will be variables in the environment that bash
+ # sets on startup.
+ (export FOO=BAR ; exec -c printenv ) | grep FOO
+ (FOO=BAR exec -c printenv ) | grep FOO
+ 
+ (export FOO=BAR ; exec printenv ) | grep FOO
+ (FOO=BAR exec printenv ) | grep FOO
+ 
+ # ok, forget everything about hashed commands
+ hash -r
+ hash
+ 
+ # check out source/.
+ 
+ AVAR=AVAR
+ 
+ . ./source.sub1
+ AVAR=foo . ./source.sub1
+ 
+ . ./source.sub2
+ echo $?
+ 
+ set -- a b c
+ . ./source.sub3
+ 
+ # make sure source with arguments does not change the shell's positional
+ # parameters, but that the sourced file sees the arguments as its
+ # positional parameters
+ echo "$@"
+ . ./source.sub3 x y z
+ echo "$@"
+ 
+ # but if the sourced script sets the positional parameters explicitly, they
+ # should be reflected in the calling shell's positional parameters.  this
+ # also tests one of the shopt options that controls source using $PATH to
+ # find the script
+ echo "$@"
+ shopt -u sourcepath
+ . source.sub4
+ echo "$@"
+ 
+ # this is complicated when the sourced scripts gets its own positional
+ # parameters from arguments to `.'
+ set -- a b c
+ echo "$@"
+ . source.sub4 x y z
+ echo "$@"
+ 
+ # test out cd and $CDPATH
+ ${THIS_SH} ./builtins.sub1
+ 
+ # in posix mode, assignment statements preceding special builtins are
+ # reflected in the shell environment.  `.' and `eval' need special-case
+ # code.
+ set -o posix
+ echo $AVAR
+ AVAR=foo . ./source.sub1
+ echo $AVAR
+ 
+ AVAR=AVAR
+ echo $AVAR
+ AVAR=foo eval echo \$AVAR
+ echo $AVAR
+ 
+ AVAR=AVAR
+ echo $AVAR
+ AVAR=foo :
+ echo $AVAR
+ 
+ # test out kill -l.  bash versions prior to 2.01 did `kill -l num' wrong
+ set +o posix
+ sigone=$(kill -l | sed -n 's:^ 1) *\([^ 	]*\)[ 	].*$:\1:p')
+ 
+ case "$(kill -l 1)" in
+ ${sigone/SIG/})	echo ok;;
+ *)	echo oops -- kill -l failure;;
+ esac
+ 
+ # POSIX.2 says that exit statuses > 128 are mapped to signal names by
+ # subtracting 128 so you can find out what signal killed a process
+ case "$(kill -l $(( 128 + 1)) )" in
+ ${sigone/SIG/})	echo ok;;
+ *)	echo oops -- kill -l 129 failure;;
+ esac
+ 
+ # out-of-range signal numbers should report the argument in the error
+ # message, not 128 less than the argument
+ kill -l 4096
+ 
+ # kill -l NAME should return the signal number
+ kill -l ${sigone/SIG/}
diff -Nrc2 bash-2.0/tests/dirstack.right bash-2.01/tests/dirstack.right
*** bash-2.0/tests/dirstack.right	Wed Dec 31 19:00:00 1969
--- bash-2.01/tests/dirstack.right	Mon Mar  3 13:04:11 1997
***************
*** 0 ****
--- 1,51 ----
+ ./dirstack.tests: pushd: no other directory
+ ./dirstack.tests: popd: directory stack empty
+ ./dirstack.tests: pushd: -m: bad argument
+ pushd: usage: pushd [dir | +N | -N] [-n]
+ ./dirstack.tests: popd: -m: bad argument
+ popd: usage: popd [+N | -N] [-n]
+ ./dirstack.tests: dirs: -m: bad argument
+ dirs: usage: dirs [-clpv] [+N] [-N]
+ ok
+ /usr /
+ /usr /
+ /usr /
+ /usr /
+ /usr /
+ /
+ /usr /
+ /etc /usr /
+ /etc /usr /
+ /etc /usr /
+  0  /etc
+  1  /usr
+  2  /
+ /usr /etc /
+ /etc /usr /
+ /tmp /etc /usr /
+ /tmp
+ /tmp
+ /usr
+ /usr
+ ./dirstack.tests: dirs: 9: bad directory stack index
+ ./dirstack.tests: dirs: 9: bad directory stack index
+ ./dirstack.tests: pushd: +9: bad directory stack index
+ ./dirstack.tests: pushd: -9: bad directory stack index
+ ./dirstack.tests: popd: +9: bad directory stack index
+ ./dirstack.tests: popd: -9: bad directory stack index
+ /tmp /etc /
+ /tmp /etc /
+ /tmp /etc /
+ /tmp /usr /etc /
+ /tmp
+ /tmp /usr /etc /
+ /tmp /usr /etc /
+ /tmp
+ /tmp /bin /etc /
+ /tmp
+ /tmp /bin /
+ /tmp
+ /bin / /tmp
+ /bin / /tmp
+ /bin
+ /bin
diff -Nrc2 bash-2.0/tests/dirstack.tests bash-2.01/tests/dirstack.tests
*** bash-2.0/tests/dirstack.tests	Wed Dec 31 19:00:00 1969
--- bash-2.01/tests/dirstack.tests	Mon Mar  3 13:12:09 1997
***************
*** 0 ****
--- 1,79 ----
+ dirs -c
+ # errors -- empty stack
+ pushd
+ popd
+ 
+ # errors -- bad numeric arguments -- should not cause the script to exit
+ pushd -m
+ popd -m
+ dirs -m
+ 
+ MYDIR=$PWD
+ unalias cd 2>/dev/null
+ 
+ unalias -a
+ 
+ command cd -P /
+ 
+ case "$OLDPWD" in
+ $MYDIR)	echo ok ;;
+ *)	echo oops -- bad \$OLDPWD ;;
+ esac
+ 
+ pushd /usr
+ echo $PWD $OLDPWD
+ dirs
+ echo ${DIRSTACK[@]}
+ 
+ # this should not change the directory stack at all
+ pushd -n +0
+ dirs
+ 
+ popd
+ pushd /usr
+ 
+ pushd /etc
+ dirs
+ dirs -l
+ dirs -v
+ 
+ # two consecutive `pushd's should swap the top two stack elements, then
+ # swap them back, leaving the stack intact
+ pushd
+ pushd
+ 
+ pushd /tmp
+ echo ${DIRSTACK[0]} ; dirs +0
+ echo ${DIRSTACK[2]} ; dirs +2
+ 
+ # these should be errors, but not affect the directory stack
+ dirs +9; dirs -9
+ pushd +9 ; pushd -9
+ popd +9 ; popd -9
+ 
+ popd -n +2
+ dirs
+ echo ${DIRSTACK[@]}
+ 
+ pushd -n /usr
+ echo $PWD
+ dirs
+ echo ${DIRSTACK[@]}
+ 
+ builtin pwd
+ 
+ DIRSTACK[1]=/bin
+ dirs
+ 
+ builtin pwd
+ popd +2
+ builtin pwd -L
+ pushd -1
+ dirs
+ echo ${DIRSTACK[0]}
+ 
+ dirs -c
+ dirs
+ 
+ # this is for the benefit of pure coverage
+ cd $MYDIR
diff -Nrc2 bash-2.0/tests/dollar-star.sh bash-2.01/tests/dollar-star.sh
*** bash-2.0/tests/dollar-star.sh	Wed Jun 15 15:53:27 1994
--- bash-2.01/tests/dollar-star.sh	Tue Feb 25 14:06:36 1997
***************
*** 1 ****
--- 1,9 ----
  recho "$*"
+ 
+ # If IFS is null, the parameters are joined without separators
+ IFS=''
+ recho "$*"
+ 
+ # If IFS is unset, the parameters are separated by spaces
+ unset IFS
+ recho "${*}"
diff -Nrc2 bash-2.0/tests/dollar.right bash-2.01/tests/dollar.right
*** bash-2.0/tests/dollar.right	Wed Jun 15 15:57:08 1994
--- bash-2.01/tests/dollar.right	Tue Feb 25 14:05:53 1997
***************
*** 1,3 ****
--- 1,5 ----
  argv[1] = <a b>
+ argv[1] = <ab>
+ argv[1] = <a b>
  argv[1] = <a>
  argv[2] = <b>
diff -Nrc2 bash-2.0/tests/errors.right bash-2.01/tests/errors.right
*** bash-2.0/tests/errors.right	Wed Dec 31 19:00:00 1969
--- bash-2.01/tests/errors.right	Mon Mar  3 13:36:47 1997
***************
*** 0 ****
--- 1,73 ----
+ ./errors.tests: `1': not a valid identifier
+ declare -fr func
+ ./errors.tests: func: readonly function
+ ./errors.tests: unset: func: cannot unset: readonly function
+ ./errors.tests: declare: func: readonly function
+ ./errors.tests: unset: XPATH: cannot unset: readonly variable
+ ./errors.tests: unset: `/bin/sh': not a valid identifier
+ ./errors.tests: declare: unknown option: `-z'
+ declare: usage: declare [-afFrxi] [-p] name[=value] ...
+ ./errors.tests: declare: `-z': not a valid identifier
+ ./errors.tests: declare: `/bin/sh': not a valid identifier
+ ./errors.tests: declare: cannot use `-f' to make functions
+ ./errors.tests: export: XPATH: not a function
+ ./errors.tests: break: only meaningful in a `for', `while', or `until' loop
+ ./errors.tests: continue: only meaningful in a `for', `while', or `until' loop
+ ./errors.tests: shift: bad non-numeric arg `label'
+ ./errors.tests: shift: too many arguments
+ ./errors.tests: let: expression expected
+ ./errors.tests: local: can only be used in a function
+ ./errors.tests: hash: notthere: not found
+ ./errors.tests: hash: hashing disabled
+ ./errors.tests: export: `AA[4]': not a valid identifier
+ ./errors.tests: readonly: `AA[4]': not a valid identifier
+ ./errors.tests: [-2]: bad array subscript
+ ./errors.tests: AA: readonly variable
+ ./errors.tests: shift: shift count must be <= $#
+ ./errors.tests: shift: shift count must be >= 0
+ ./errors.tests: shopt: no_such_option: unknown shell option name
+ ./errors.tests: shopt: no_such_option: unknown shell option name
+ ./errors.tests: umask: `09' is not an octal number from 000 to 777
+ ./errors.tests: umask: bad character in symbolic mode: :
+ ./errors.tests: umask: bad symbolic mode operator: :
+ ./errors.tests: umask: illegal option: -p
+ umask: usage: umask [-S] [mode]
+ ./errors.tests: VAR: readonly variable
+ ./errors.tests: declare: VAR: readonly variable
+ ./errors.tests: declare: VAR: readonly variable
+ ./errors.tests: declare: unset: not found
+ ./errors.tests: VAR: readonly variable
+ ./errors.tests: command substitution: line 2: syntax error: unexpected end of file
+ ./errors.tests: command substitution: line 1: syntax error near unexpected token `done'
+ ./errors.tests: command substitution: line 1: ` for z in 1 2 3; done '
+ ./errors.tests: cd: HOME not set
+ ./errors.tests: cd: OLDPWD not set
+ ./errors.tests: .: filename argument required
+ .: usage: . filename
+ ./errors.tests: source: filename argument required
+ source: usage: source filename
+ ./errors.tests: .: illegal option: -i
+ .: usage: . filename
+ ./errors.tests: set: unknown option: q
+ ./errors.tests: enable: sh: not a shell builtin
+ ./errors.tests: enable: bash: not a shell builtin
+ ./errors.tests: shopt: cannot set and unset shell options simultaneously
+ ./errors.tests: read: `/bin/sh': not a valid identifier
+ ./errors.tests: VAR: readonly variable
+ ./errors.tests: eval: illegal option: -i
+ eval: usage: eval [arg ...]
+ ./errors.tests: command: illegal option: -i
+ command: usage: command [-pVv] command [arg ...]
+ ./errors.tests: trap: NOSIG: not a signal specification
+ ./errors.tests: trap: illegal option: -s
+ trap: usage: trap [arg] [signal_spec ...] or trap -l
+ ./errors.tests: trap: ERR: not a signal specification
+ ./errors.tests: return: can only `return' from a function or sourced script
+ ./errors.tests: break: loop count must be > 0
+ ./errors.tests: continue: loop count must be > 0
+ ./errors.tests: builtin: bash: not a shell builtin
+ ./errors.tests: bg: no job control
+ ./errors.tests: fg: no job control
+ ./errors.tests: kill: -s requires an argument
+ ./errors.tests: kill: bad signal spec `S'
+ ./errors.tests: `!!': not a valid identifier
diff -Nrc2 bash-2.0/tests/errors.tests bash-2.01/tests/errors.tests
*** bash-2.0/tests/errors.tests	Wed Dec 31 19:00:00 1969
--- bash-2.01/tests/errors.tests	Mon Mar  3 13:36:32 1997
***************
*** 0 ****
--- 1,203 ----
+ # These should all be safe
+ LC_ALL=C
+ LC_CTYPE=C
+ LC_COLLATE=C
+ LC_MESSAGES=C
+ 
+ # these tests should all generate errors
+ 
+ # make sure we don't exit prematurely
+ set +e
+ set +o posix
+ 
+ # the iteration variable must be a valid identifier
+ for 1 in a b c; do echo $1; done
+ 
+ # try to rebind a read-only function
+ func()
+ {
+ 	echo func
+ }
+ readonly -f func
+ # make sure `readonly' and `declare' play well together
+ declare -Fr
+ func()
+ {
+ 	echo bar
+ }
+ 
+ # cannot unset readonly functions or variables
+ unset -f func
+ # or make them not readonly
+ declare -fr func
+ declare -f +r func
+ 
+ XPATH=$PATH
+ declare -r XPATH
+ unset -v XPATH
+ 
+ # cannot unset invalid identifiers
+ unset /bin/sh
+ 
+ # bad option
+ declare -z
+ # cannot declare invalid identifiers
+ declare -- -z 
+ declare /bin/sh
+ 
+ # this is the syntax used to export functions in the environment, but
+ # it cannot be used with `declare'
+ declare -f func='() { echo "this is func"; }'
+ 
+ # try to export -f something that is not a function -- this should be
+ # an error, not create an `invisible function'
+ export -f XPATH
+ 
+ # this depends on the setting of BREAK_COMPLAINS in config.h.in
+ break
+ continue
+ 
+ # this should not exit the shell; it did in versions before 2.01
+ shift label
+ 
+ # other shells do not complain about the extra arguments; maybe someday
+ # we won't either
+ set -- a b c
+ shift $# label
+ # and get rid of the positional parameters
+ shift $#
+ 
+ # let without an expression is an error, though maybe it should just return
+ # success
+ let
+ 
+ # local outside a function is an error
+ local
+ 
+ # try to hash a non-existant command
+ hash notthere
+ 
+ # turn off hashing, then try to hash something
+ set +o hashall
+ hash -p ${THIS_SH} ${THIS_SH##*/}
+ 
+ # bad identifiers to declare/readonly/export
+ export AA[4]
+ readonly AA[4]
+ 
+ declare -a AA
+ unset AA[-2]
+ 
+ # try to assign to a readonly array
+ declare -r AA
+ AA=( one two three )
+ 
+ # bad counts to `shift'
+ shopt -s shift_verbose
+ shift $(( $# + 5 ))
+ shift -2
+ 
+ # bad shell options
+ shopt -s no_such_option
+ shopt no_such_option
+ 
+ # non-octal digits for umask and other errors
+ umask 09
+ umask -S u=rwx:g=rwx:o=rx >/dev/null # 002
+ umask -S u:rwx,g:rwx,o:rx >/dev/null # 002
+ # this may behave identically to umask without arguments in the future,
+ # but for now it is an error
+ umask -p
+ 
+ # assignment to a readonly variable in environment
+ VAR=4
+ readonly VAR
+ VAR=7 :
+ 
+ # more readonly variable tests
+ declare VAR=88
+ declare +r VAR
+ 
+ declare -p unset
+ 
+ # iteration variable in a for statement being readonly
+ for VAR in 1 2 3 ; do echo $VAR; done
+ 
+ # parser errors
+ : $( for z in 1 2 3; do )
+ : $( for z in 1 2 3; done )
+ 
+ # various `cd' errors
+ ( unset HOME ; cd )
+ ( unset OLDPWD ; cd - )
+ 
+ # various `source/.' errors
+ .
+ source
+ 
+ # maybe someday this will work like in rc
+ . -i /dev/tty
+ 
+ # make sure that this gives an error rather than setting $1
+ set -q
+ 
+ # enable non-builtins
+ enable sh bash
+ 
+ # try to set and unset shell options simultaneously
+ shopt -s -u checkhash
+ 
+ # try to read into an invalid identifier
+ read /bin/sh < /dev/null
+ 
+ # try to read into a readonly variable
+ read VAR < /dev/null
+ 
+ # someday these may mean something, but for now they're errors
+ eval -i "echo $-"
+ command -i "echo $-"
+ 
+ # error to list trap for an unknown signal
+ trap -p NOSIG
+ 
+ # maybe someday trap will take a -s argument like kill, but not now
+ trap -p -s NOSIG
+ 
+ # maybe someday we will have a ksh-like ERR trap, but not yet
+ trap 'echo [$LINENO] -- error' ERR
+ 
+ # can only return from a function or sourced script
+ return 2
+ 
+ # break and continue with arguments <= 0
+ for z in 1 2 3; do
+ 	break 0
+ 	echo $x
+ done
+ for z in 1 2 3; do
+ 	continue 0
+ 	echo $x
+ done
+ 
+ # builtin with non-builtin
+ builtin bash
+ 
+ # maybe someday you will be able to use fg/bg when job control is not really
+ # active, but for now they are errors
+ bg
+ fg
+ 
+ # argument required
+ kill -s
+ # bad argument
+ kill -S
+ 
+ # this must be last!
+ # in posix mode, a function name must be a valid identifier
+ # this can't go in posix2.tests, since it causes the shell to exit
+ # immediately
+ set -o posix
+ function !! () { fc -s "$@" ; }
+ set +o posix
+ 
+ echo end
diff -Nrc2 bash-2.0/tests/execscript bash-2.01/tests/execscript
*** bash-2.0/tests/execscript	Wed Dec 31 19:00:00 1969
--- bash-2.01/tests/execscript	Tue May 27 10:48:36 1997
***************
*** 0 ****
--- 1,78 ----
+ export LC_ALL=C
+ export LANG=C
+ 
+ set -- one two three
+ echo before execscript.sub: "$@"
+ echo calling execscript.sub
+ ./execscript.sub aa bb cc dd ee
+ echo after execscript.sub with args: $?
+ ./execscript.sub
+ echo after execscript.sub without args: $?
+ 
+ # set up a fixed path so we know notthere will not be found
+ PATH=/usr/bin:/bin:/usr/local/bin:
+ export PATH
+ 
+ notthere
+ echo $?
+ 
+ # this is iffy, since the error messages may vary from system to system
+ ${THIS_SH} notthere
+ echo $?
+ 
+ # /bin/sh should be there on all systems
+ ${THIS_SH} /bin/sh
+ echo $?
+ 
+ # try executing a directory
+ /
+ echo $?
+ 
+ ${THIS_SH} /
+ echo $?
+ 
+ # try sourcing a directory
+ . /
+ echo $?
+ 
+ . ${THIS_SH} 2>/dev/null
+ echo $?
+ 
+ . /dev/null
+ echo $?
+ 
+ # kill two birds with one test -- test out the BASH_ENV code
+ echo echo this is bashenv > /tmp/bashenv
+ export BASH_ENV=/tmp/bashenv
+ ${THIS_SH} ./execscript.sub3
+ rm -f /tmp/bashenv
+ unset BASH_ENV
+ 
+ # we're resetting the $PATH to empty, so this should be last
+ PATH=
+ 
+ notthere
+ echo $?
+ 
+ command notthere
+ echo $?
+ 
+ command -p notthere
+ echo $?
+ 
+ # but -p should guarantee that we find all the standard utilities, even
+ # with an empty or unset $PATH
+ command -p sh -c 'echo this is $0'
+ unset PATH
+ command -p sh -c 'echo this is $0'
+ 
+ # a bug in bash before bash-2.01 caused PATH to be set to the empty string
+ # when command -p was run with PATH unset
+ echo ${PATH-unset}
+ 
+ echo "echo ok" | ${THIS_SH} -t
+ 
+ ${THIS_SH} ./execscript.sub2
+ echo $?
+ 
+ ${THIS_SH} ./execscript.sub4
diff -Nrc2 bash-2.0/tests/execscript.right bash-2.01/tests/execscript.right
*** bash-2.0/tests/execscript.right	Wed Dec 31 19:00:00 1969
--- bash-2.01/tests/execscript.right	Mon Mar  3 13:15:03 1997
***************
*** 0 ****
--- 1,36 ----
+ before execscript.sub: one two three
+ calling execscript.sub
+ aa bb cc dd ee
+ after execscript.sub with args: 0
+ 
+ after execscript.sub without args: 0
+ ./execscript: notthere: command not found
+ 127
+ notthere: notthere: No such file or directory
+ 127
+ /bin/sh: /bin/sh: cannot execute binary file
+ 126
+ ./execscript: /: is a directory
+ 126
+ /: /: cannot execute binary file
+ 126
+ ./execscript: .: /: is a directory
+ 1
+ 126
+ ./execscript: .: /dev/null: not a regular file
+ 1
+ this is bashenv
+ ./execscript.sub3: /tmp/bash-notthere: No such file or directory
+ ./execscript.sub3: exec: /tmp/bash-notthere: cannot execute: No such file or directory
+ 126
+ ./execscript: notthere: No such file or directory
+ 127
+ ./execscript: notthere: No such file or directory
+ 127
+ ./execscript: notthere: No such file or directory
+ 127
+ this is sh
+ this is sh
+ unset
+ ok
+ 5
diff -Nrc2 bash-2.0/tests/execscript.sub bash-2.01/tests/execscript.sub
*** bash-2.0/tests/execscript.sub	Wed Dec 31 19:00:00 1969
--- bash-2.01/tests/execscript.sub	Wed Feb 19 14:06:50 1997
***************
*** 0 ****
--- 1 ----
+ echo "$@"
diff -Nrc2 bash-2.0/tests/execscript.sub2 bash-2.01/tests/execscript.sub2
*** bash-2.0/tests/execscript.sub2	Wed Dec 31 19:00:00 1969
--- bash-2.01/tests/execscript.sub2	Tue Feb 25 13:26:25 1997
***************
*** 0 ****
--- 1,5 ----
+ # make sure an exit command in an exit trap sets the shell's exit status
+ trap - 0
+ trap 'exit 5' 0
+ 
+ exit 0
diff -Nrc2 bash-2.0/tests/execscript.sub3 bash-2.01/tests/execscript.sub3
*** bash-2.0/tests/execscript.sub3	Wed Dec 31 19:00:00 1969
--- bash-2.01/tests/execscript.sub3	Mon Mar  3 12:58:01 1997
***************
*** 0 ****
--- 1,6 ----
+ shopt -s execfail
+ 
+ exec /tmp/bash-notthere
+ # make sure we're still around
+ echo $?
+ 
diff -Nrc2 bash-2.0/tests/execscript.sub4 bash-2.01/tests/execscript.sub4
*** bash-2.0/tests/execscript.sub4	Wed Dec 31 19:00:00 1969
--- bash-2.01/tests/execscript.sub4	Mon Mar  3 13:00:22 1997
***************
*** 0 ****
--- 1,8 ----
+ # let's test out the noexec code
+ set -n
+ 
+ fail
+ whoops
+ wow
+ 
+ set +n
diff -Nrc2 bash-2.0/tests/exp-tests bash-2.01/tests/exp-tests
*** bash-2.0/tests/exp-tests	Tue May 30 11:25:50 1995
--- bash-2.01/tests/exp-tests	Wed Feb 26 14:02:57 1997
***************
*** 233,236 ****
--- 233,249 ----
  recho ${x##*/}
  
+ # pattern removal of patterns that don't match
+ z=abcdef
+ 
+ expect '<abcdef>'
+ recho ${z#xyz}
+ expect '<abcdef>'
+ recho ${z##xyz}
+ 
+ expect '<abcdef>'
+ recho ${z%xyz}
+ expect '<abcdef>'
+ recho ${z%%xyz}
+ 
  # Command substitution and the quirky differences between `` and $()
  
***************
*** 319,324 ****
--- 332,354 ----
  expect '<one> <three> <five>'
  recho $1 $3 ${5} $8 ${9}
+ 
+ # length tests on positional parameters and some special parameters
+ 
  expect '<5> <5>'
  recho $# ${#}
+ expect '<3>'
+ recho ${#1}
+ expect '<1>'
+ recho ${##}
+ expect '<1>'
+ recho ${#?}
+ expect '<5>'
+ recho ${#@}
+ expect '<5>'
+ recho ${#*}
+ expect '<5>'
+ recho "${#@}"
+ expect '<5>'
+ recho "${#*}"
  
  expect '<42>'
***************
*** 335,338 ****
--- 365,370 ----
  expect nothing
  recho $!
+ expect nothing
+ recho ${!}
  
  # test word splitting of assignment statements not preceding a command
diff -Nrc2 bash-2.0/tests/exp.right bash-2.01/tests/exp.right
*** bash-2.0/tests/exp.right	Tue May 30 11:27:28 1995
--- bash-2.01/tests/exp.right	Wed Feb 26 14:05:08 1997
***************
*** 88,91 ****
--- 88,95 ----
  argv[1] = </src/cmd>
  argv[1] = <three>
+ argv[1] = <abcdef>
+ argv[1] = <abcdef>
+ argv[1] = <abcdef>
+ argv[1] = <abcdef>
  argv[1] = <\$x>
  argv[1] = <$x>
***************
*** 124,127 ****
--- 128,138 ----
  argv[1] = <5>
  argv[2] = <5>
+ argv[1] = <3>
+ argv[1] = <1>
+ argv[1] = <1>
+ argv[1] = <5>
+ argv[1] = <5>
+ argv[1] = <5>
+ argv[1] = <5>
  argv[1] = <42>
  argv[1] = <26>
diff -Nrc2 bash-2.0/tests/func.right bash-2.01/tests/func.right
*** bash-2.0/tests/func.right	Wed Dec 31 19:00:00 1969
--- bash-2.01/tests/func.right	Thu Feb 27 11:52:35 1997
***************
*** 0 ****
--- 1,28 ----
+ a returns 5
+ b returns 4
+ c returns 3
+ d returns 2
+ in e
+ e returned 25
+ x is 25
+ ZZ
+ abcde
+ defghi
+ ZZ
+ 5
+ 0
+ AVAR
+ AVAR
+ foo
+ foo
+ AVAR
+ 5
+ 5
+ f1
+ f1 () 
+ { 
+     ( return 5 );
+     status=$?;
+     echo $status;
+     return $status
+ }
diff -Nrc2 bash-2.0/tests/func.tests bash-2.01/tests/func.tests
*** bash-2.0/tests/func.tests	Wed Dec 31 19:00:00 1969
--- bash-2.01/tests/func.tests	Fri Feb 28 16:39:53 1997
***************
*** 0 ****
--- 1,119 ----
+ a()
+ {
+ 	x=$((x - 1))
+ 	return 5
+ }
+ 
+ b()
+ {
+ 	x=$((x - 1))
+ 	a
+ 	echo a returns $?
+ 	return 4
+ }
+ 
+ c()
+ {
+ 	x=$((x - 1))
+ 	b
+ 	echo b returns $?
+ 	return 3
+ }
+ 
+ d()
+ {
+ 	x=$((x - 1))
+ 	c
+ 	echo c returns $?
+ 	return 2
+ }
+ 
+ e()
+ {
+ 	d
+ 	echo d returns $?
+ 	echo in e
+ 	x=$((x - 1))
+ 	return $x
+ }
+ 
+ f()
+ {
+ 	e
+ 	echo e returned $?
+ 	echo x is $x
+ 	return 0
+ }
+ 
+ x=30
+ f
+ 
+ # make sure unsetting a local variable preserves the `local' attribute
+ f1()
+ {
+ 	local zz
+ 	zz=abcde
+ 	echo $zz
+ 	unset zz
+ 	zz=defghi
+ 	echo $zz
+ }
+ 
+ zz=ZZ
+ echo $zz
+ f1
+ echo $zz
+ 
+ unset -f f1
+ f1()
+ {
+ 	return 5
+ }
+ 
+ ( f1 )
+ echo $?
+ 
+ unset -f f1
+ f1()
+ {
+ 	sleep 5
+ 	return 5
+ }
+ 
+ f1 &
+ wait
+ echo $?
+ 
+ unset -f f1
+ 
+ f1()
+ {
+ 	echo $AVAR
+ 	printenv AVAR
+ }
+ 
+ AVAR=AVAR
+ echo $AVAR
+ f1
+ AVAR=foo f1
+ echo $AVAR
+ 
+ unset -f f1
+ # make sure subshells can do a `return' if we're executing in a function
+ f1()
+ {
+ 	( return 5 )
+ 	status=$?
+ 	echo $status
+ 	return $status
+ }
+ 
+ f1
+ echo $?
+ 
+ declare -F f1	# should print just the name
+ declare -f f1	# should print the definition, too
+ 
+ # no functions should be exported, right?
+ declare -xF
+ declare -xf
diff -Nrc2 bash-2.0/tests/getopts.right bash-2.01/tests/getopts.right
*** bash-2.0/tests/getopts.right	Wed Dec 31 19:00:00 1969
--- bash-2.01/tests/getopts.right	Thu Mar  6 15:56:54 1997
***************
*** 0 ****
--- 1,56 ----
+ getopts: usage: getopts optstring name [arg]
+ 2
+ getopts: usage: getopts optstring name [arg]
+ 2
+ ./getopts.tests: getopts: illegal option: -a
+ getopts: usage: getopts optstring name [arg]
+ -a specified
+ -b bval specified
+ remaining args: one two three
+ -a specified
+ -b bval specified
+ remaining args: one two three four five six seven eight nine ten eleven twelve
+ ./getopts.sub1: option requires an argument -- b
+ Usage: ./getopts.sub1 [-a] [-b value] args
+ -a specified
+ -c cval specified
+ -d specified
+ -a specified
+ -b 3 specified
+ remaining args: one two three four five
+ -a specified
+ -b bval specified
+ remaining args: one two three
+ -a specified
+ -b bval specified
+ remaining args: one two three
+ ./getopts.sub4: error: option `b' requires an argument
+ Usage: ./getopts.sub4 [-a] [-b value] args
+ ./getopts.sub4: error: illegal option character `c'
+ Usage: ./getopts.sub4 [-a] [-b value] args
+ -a specified
+ remaining args: -b bval one two three
+ OPTERR=0
+ a here
+ something else here
+ OPTIND=3
+ getop: OPTERR=1
+ a here
+ ./getopts.sub5: illegal option -- c
+ something else here
+ ./getopts.sub5: illegal option -- d
+ something else here
+ ./getopts.sub5: illegal option -- e
+ something else here
+ getop: OPTIND=5
+ OPTIND=3
+ OPTERR=0
+ -a specified
+ remaining args: 
+ -a specified
+ remaining args: 
+ -a specified
+ remaining args: 
+ 0
+ ./getopts.sub7: getopts: `opt-var': not a valid identifier
+ remaining args: 
diff -Nrc2 bash-2.0/tests/getopts.sub1 bash-2.01/tests/getopts.sub1
*** bash-2.0/tests/getopts.sub1	Wed Dec 31 19:00:00 1969
--- bash-2.01/tests/getopts.sub1	Tue Jul 26 16:54:05 1994
***************
*** 0 ****
--- 1,26 ----
+ aflag=
+ bflag=
+ 
+ while getopts ab: name
+ do
+ 	case $name in
+ 	a)	aflag=1 ;;
+ 	b)	bflag=1
+ 		bval=$OPTARG;;
+ 	?)	echo Usage: $0 [-a] [-b value] args
+ 		exit 2;;
+ 	esac
+ 
+ done
+ 
+ if [ ! -z "$aflag" ] ; then echo -a specified ; fi
+ if [ ! -z "$bflag" ] ; then echo -b $bval specified ; fi
+ 
+ if [ "$OPTIND" -gt 1 ]
+ then
+ 	shift $(( $OPTIND - 1 ))
+ fi
+ 
+ echo remaining args: "$*"
+ 
+ exit 0
diff -Nrc2 bash-2.0/tests/getopts.sub2 bash-2.01/tests/getopts.sub2
*** bash-2.0/tests/getopts.sub2	Wed Dec 31 19:00:00 1969
--- bash-2.01/tests/getopts.sub2	Wed May  8 19:36:10 1996
***************
*** 0 ****
--- 1,26 ----
+ aflag=
+ bflag=
+ 
+ while getopts ab:c:de name "$@"
+ do
+ 	case $name in
+ 	a)	aflag=1 ;;
+ 	b)	bflag=1
+ 		bval=$OPTARG;;
+ 	c)	cflag=1
+ 		cval=$OPTARG ;;
+ 	d)	dflag=1 ;;
+ 	e)	eflag=1;;
+ 	?)	echo Usage: $0 [-a] [-b value] [-c value] -[de] args
+ 		exit 2;;
+ 	esac
+ 
+ done
+ 
+ [ ! -z "$aflag" ] && echo -a specified
+ [ ! -z "$bflag" ] && echo -b $bval specified
+ [ ! -z "$cflag" ] && echo -c $cval specified
+ [ ! -z "$dflag" ] && echo -d specified
+ [ ! -z "$eflag" ] && { echo -n - ; echo e specified; }
+ 
+ exit 0
diff -Nrc2 bash-2.0/tests/getopts.sub3 bash-2.01/tests/getopts.sub3
*** bash-2.0/tests/getopts.sub3	Wed Dec 31 19:00:00 1969
--- bash-2.01/tests/getopts.sub3	Tue Feb  7 13:48:42 1995
***************
*** 0 ****
--- 1,27 ----
+ aflag=
+ bflag=
+ 
+ while getopts ab: name -a -b 1 -a -a -a -b 5 -b 3 -a one two three four five
+ do
+ 	case $name in
+ 	a)	aflag=1 ;;
+ 	b)	bflag=1
+ 		bval=$OPTARG;;
+ 	?)	echo Usage: $0 [-a] [-b value] args
+ 		exit 2;;
+ 	esac
+ 
+ done
+ 
+ if [ ! -z "$aflag" ] ; then echo -a specified ; fi
+ if [ ! -z "$bflag" ] ; then echo -b $bval specified ; fi
+ 
+ set -- -a -b 1 -a -a -a -b 5 -b 3 -a one two three four five
+ if [ "$OPTIND" -gt 1 ]
+ then
+ 	shift $(( $OPTIND - 1 ))
+ fi
+ 
+ echo remaining args: "$*"
+ 
+ exit 0
diff -Nrc2 bash-2.0/tests/getopts.sub4 bash-2.01/tests/getopts.sub4
*** bash-2.0/tests/getopts.sub4	Wed Dec 31 19:00:00 1969
--- bash-2.01/tests/getopts.sub4	Fri Feb 28 15:47:34 1997
***************
*** 0 ****
--- 1,30 ----
+ aflag=
+ bflag=
+ 
+ while getopts :ab: name "$@"
+ do
+ 	case $name in
+ 	a)	aflag=1 ;;
+ 	b)	bflag=1
+ 		bval=$OPTARG;;
+ 	:)	echo $0: error: option \`$OPTARG\' requires an argument
+ 		echo Usage: $0 [-a] [-b value] args
+ 		exit 2;;
+ 	?)	echo $0: error: illegal option character \`$OPTARG\'
+ 		echo Usage: $0 [-a] [-b value] args
+ 		exit 2;;
+ 	esac
+ 
+ done
+ 
+ if [ ! -z "$aflag" ] ; then echo -a specified ; fi
+ if [ ! -z "$bflag" ] ; then echo -b $bval specified ; fi
+ 
+ if [ "$OPTIND" -gt 1 ]
+ then
+ 	shift $(( $OPTIND - 1 ))
+ fi
+ 
+ echo remaining args: "$*"
+ 
+ exit 0
diff -Nrc2 bash-2.0/tests/getopts.sub5 bash-2.01/tests/getopts.sub5
*** bash-2.0/tests/getopts.sub5	Wed Dec 31 19:00:00 1969
--- bash-2.01/tests/getopts.sub5	Mon Feb 24 15:15:20 1997
***************
*** 0 ****
--- 1,50 ----
+ #!/local/bin/bash
+ #Time-stamp: <95/06/07 07:40:40 hrue@imf.unit.no>
+ 
+ getop () {
+ 
+     local OPTIND
+     local OPTERR=1
+ 
+     echo getop: OPTERR=$OPTERR    
+     while getopts ab arg "$@"; do
+ 	case $arg in
+ 	    a)
+ 		echo a here
+ 		;;
+ 	    b)
+ 		echo b here
+ 		;;
+ 	    :|?|*)
+ 		echo something else here
+ 		;;
+ 	esac
+     done
+     echo getop: OPTIND=$OPTIND
+ }
+ 
+ OPTIND=
+ OPTERR=0
+ 
+ echo OPTERR=$OPTERR
+ while getopts ab arg; do
+     case $arg in
+ 	a)
+ 	    echo a here
+ 	    ;;
+ 	b)
+ 	    echo b here
+ 	    ;;
+ 	:|?|*)
+ 	    
+ 	    echo something else here
+ 	    ;;
+     esac
+ done
+ 
+ echo OPTIND=$OPTIND
+ 
+ getop "$@" -d -e
+ 
+ echo OPTIND=$OPTIND
+ echo OPTERR=$OPTERR
diff -Nrc2 bash-2.0/tests/getopts.sub6 bash-2.01/tests/getopts.sub6
*** bash-2.0/tests/getopts.sub6	Wed Dec 31 19:00:00 1969
--- bash-2.01/tests/getopts.sub6	Fri Feb 28 13:38:30 1997
***************
*** 0 ****
--- 1,27 ----
+ aflag=
+ bflag=
+ 
+ while getopts :ac name "$@"
+ do
+ 	case $name in
+ 	a)	aflag=1 ;;
+ 	c)	cflag=1 ;;
+ 	?)	exit 2;;
+ 	esac
+ 
+ 	# this came in in a bug report -- it's really a usage error
+ 	# but it shouldn't cause the shell to crash
+ 	shift
+ done
+ 
+ if [ ! -z "$aflag" ] ; then echo -a specified ; fi
+ if [ ! -z "$cflag" ] ; then echo -c specified ; fi
+ 
+ if [ "$OPTIND" -gt 1 ]
+ then
+ 	shift $(( $OPTIND - 1 ))
+ fi
+ 
+ echo remaining args: "$*"
+ 
+ exit 0
diff -Nrc2 bash-2.0/tests/getopts.sub7 bash-2.01/tests/getopts.sub7
*** bash-2.0/tests/getopts.sub7	Wed Dec 31 19:00:00 1969
--- bash-2.01/tests/getopts.sub7	Fri Feb 28 16:03:31 1997
***************
*** 0 ****
--- 1,30 ----
+ aflag=
+ bflag=
+ 
+ while getopts :ab: opt-var "$@"
+ do
+ 	case $name in
+ 	a)	aflag=1 ;;
+ 	b)	bflag=1
+ 		bval=$OPTARG;;
+ 	:)	echo $0: error: option \`$OPTARG\' requires an argument
+ 		echo Usage: $0 [-a] [-b value] args
+ 		exit 2;;
+ 	?)	echo $0: error: illegal option character \`$OPTARG\'
+ 		echo Usage: $0 [-a] [-b value] args
+ 		exit 2;;
+ 	esac
+ 
+ done
+ 
+ if [ ! -z "$aflag" ] ; then echo -a specified ; fi
+ if [ ! -z "$bflag" ] ; then echo -b $bval specified ; fi
+ 
+ if [ "$OPTIND" -gt 1 ]
+ then
+ 	shift $(( $OPTIND - 1 ))
+ fi
+ 
+ echo remaining args: "$*"
+ 
+ exit 0
diff -Nrc2 bash-2.0/tests/getopts.tests bash-2.01/tests/getopts.tests
*** bash-2.0/tests/getopts.tests	Wed Dec 31 19:00:00 1969
--- bash-2.01/tests/getopts.tests	Fri Feb 28 16:03:45 1997
***************
*** 0 ****
--- 1,38 ----
+ # getopts tests
+ # this should fail
+ getopts
+ echo $?
+ getopts opts
+ echo $?
+ 
+ # maybe someday we will have a ksh93-like -a argument to set the name
+ # used in error messages, but not yet
+ getopts -a opts name
+ 
+ ${THIS_SH} ./getopts.sub1 -a -b bval one two three
+ # make sure getopts works when there are more than 9 positional parameters
+ ${THIS_SH} ./getopts.sub1 -a -b bval one two three four five six seven eight nine ten eleven twelve
+ ${THIS_SH} ./getopts.sub1 -a -b 
+ 
+ ${THIS_SH} ./getopts.sub2 -ad -c cval three four five
+ 
+ ${THIS_SH} ./getopts.sub3
+ 
+ # make sure that `-b bval' and `-bbval' are equivalent
+ ${THIS_SH} ./getopts.sub4 -a -b bval one two three
+ ${THIS_SH} ./getopts.sub4 -a -bbval one two three
+ # this tests `silent' error reporting
+ ${THIS_SH} ./getopts.sub4 -a -b
+ ${THIS_SH} ./getopts.sub4 -a -c
+ 
+ # make sure that `--' can be used to end the list of options
+ ${THIS_SH} ./getopts.sub4 -a -- -b bval one two three
+ 
+ ${THIS_SH} ./getopts.sub5 -a -c
+ 
+ ${THIS_SH} ./getopts.sub6 -a
+ ${THIS_SH} ./getopts.sub6 -a -c
+ ${THIS_SH} ./getopts.sub6 -ac
+ echo $? # this should be 2
+ 
+ ${THIS_SH} ./getopts.sub7 -a
diff -Nrc2 bash-2.0/tests/glob-test bash-2.01/tests/glob-test
*** bash-2.0/tests/glob-test	Thu Jun 20 11:43:22 1996
--- bash-2.01/tests/glob-test	Fri May  2 12:08:12 1997
***************
*** 1,2 ****
--- 1,3 ----
+ LC_COLLATE=C
  #
  # test the shell globbing
***************
*** 7,10 ****
--- 8,13 ----
  }
  
+ MYDIR=$PWD	# save where we are
+ 
  TESTDIR=/tmp/glob-test
  mkdir $TESTDIR
***************
*** 120,176 ****
  recho a?c
  
! expect '<match>'
  case abc in
! a"b"c)	echo match
! 	;;
! *)	echo BAD
! 	;;
  esac
  
! expect '<match>'
  case abc in
! a*c)	echo match
! 	;;
! *)	echo BAD
! 	;;
  esac
  
! expect '<ok>'
  case abc in
! "a?c")	echo bad
! 	;;
! *)	echo ok
! 	;;
  esac
  
! expect '<ok>'
  case abc in
! a\*c)	echo bad
! 	;;
! *)	echo ok
! 	;;
  esac
  
! expect '<ok>'
  case abc in
! a\[b]c)	echo bad
! 	;;
! *)	echo ok
! 	;;
  esac
  
! expect '<ok>'
  case "$nosuchvar" in
! "") 	echo ok ;;
! *)	echo bad ;;
  esac
  
  # This is very odd, but sh and ksh seem to agree
! expect '<ok>'
  case abc in
! a["\b"]c) echo ok
! 	;;
! *)	echo bad
! 	;;
  esac
  
--- 123,167 ----
  recho a?c
  
! expect '<match 1>'
  case abc in
! a"b"c)	echo 'match 1' ;;
! *)	echo 'BAD match 1' ;;
  esac
  
! expect '<match 2>'
  case abc in
! a*c)	echo 'match 2' ;;
! *)	echo 'BAD match 2' ;;
  esac
  
! expect '<ok 1>'
  case abc in
! "a?c")	echo 'bad 1' ;;
! *)	echo 'ok 1' ;;
  esac
  
! expect '<ok 2>'
  case abc in
! a\*c)	echo 'bad 2' ;;
! *)	echo 'ok 2' ;;
  esac
  
! expect '<ok 3>'
  case abc in
! a\[b]c)	echo 'bad 3' ;;
! *)	echo 'ok 3' ;;
  esac
  
! expect '<ok 4>'
  case "$nosuchvar" in
! "") 	echo 'ok 4' ;;
! *)	echo 'bad 4' ;;
  esac
  
  # This is very odd, but sh and ksh seem to agree
! expect '<ok 5>'
  case abc in
! a["\b"]c) echo 'ok 5' ;;
! *)	echo 'bad 5' ;;
  esac
  
***************
*** 254,284 ****
  esac
  
  # none of these should output anything
  
  case abc in
! ??**********?****?)	echo bad ;;
  esac
  
  case abc in
! ??**********?****c)	echo bad ;;
  esac
  
  case abc in
! ?************c****?****)	echo bad;;
  esac
  
  case abc in
! *c*?**)	echo bad;;
  esac
  
  case abc in
! a*****c*?**)	echo bad;;
  esac
  
  case abc in
! a********???*******)	echo bad;;
  esac
  
  builtin cd /
  rm -rf $TESTDIR
  exit 0
--- 245,358 ----
  esac
  
+ case '-' in
+ [-abc])	echo ok 26 ;;
+ esac
+ 
+ case '-' in
+ [abc-]) echo ok 27 ;;
+ esac
+ 
+ case '\' in
+ \\)	echo ok 28 ;;
+ esac
+ 
+ case '\' in
+ [\\])	echo ok 29 ;;
+ esac
+ 
+ case '\' in
+ '\')	echo ok 30 ;;
+ esac
+ 
+ case '[' in
+ [[])	echo ok 31 ;;
+ esac
+ 
+ # a `[' without a closing `]' is just another character to match, in the
+ # bash implementation
+ case '[' in
+ [)	echo ok 32 ;;
+ esac
+ 
+ case '[abc' in
+ [*)	echo 'ok 33';;
+ esac
+ 
+ # a right bracket shall lose its special meaning and represent itself in
+ # a bracket expression if it occurs first in the list.  -- POSIX.2 2.8.3.2
+ case ']' in
+ []])	echo ok 34 ;;
+ esac
+ 
+ case '-' in
+ []-])	echo ok 35 ;;
+ esac
+ 
  # none of these should output anything
  
  case abc in
! ??**********?****?)	echo bad 1;;
  esac
  
  case abc in
! ??**********?****c)	echo bad 2;;
  esac
  
  case abc in
! ?************c****?****)	echo bad 3;;
  esac
  
  case abc in
! *c*?**)	echo bad 4;;
  esac
  
  case abc in
! a*****c*?**)	echo bad 5;;
  esac
  
  case abc in
! a********???*******)	echo bad 6;;
! esac
! 
! case 'a' in
! [])	echo bad 7 ;;
! esac
! 
! case '[' in
! [abc)	echo bad 8;;
  esac
  
+ 
+ # make sure set -f works right
+ set -f
+ recho *
+ set +f
+ 
+ # test out the GLOBIGNORE code
+ GLOBIGNORE='.*:*c:*e:?'
+ recho *
+ 
+ GLOBIGNORE='.*:*b:*d:?'
+ recho *
+ 
+ # see if GLOBIGNORE can substitute for `set -f'
+ GLOBIGNORE='.*:*'
+ recho *
+ 
+ unset GLOBIGNORE
+ expect '<man/man1/bash.1>'
+ recho */man*/bash.*
+ 
+ # make sure null values for GLOBIGNORE have no effect
+ GLOBIGNORE=
+ expect '<man/man1/bash.1>'
+ recho */man*/bash.*
+ 
  builtin cd /
  rm -rf $TESTDIR
+ 
+ # this is for the benefit of pure coverage, so it writes the pcv file
+ # in the right place
+ builtin cd $MYDIR
+ 
  exit 0
diff -Nrc2 bash-2.0/tests/glob.right bash-2.01/tests/glob.right
*** bash-2.0/tests/glob.right	Thu Jun 20 11:27:03 1996
--- bash-2.01/tests/glob.right	Wed Mar 19 14:53:27 1997
***************
*** 55,65 ****
  argv[1] = <abc>
  argv[1] = <abc>
! match
! match
! ok
! ok
! ok
! ok
! ok
  argv[1] = <man/man1/bash.1>
  argv[1] = <man/man1/bash.1>
--- 55,65 ----
  argv[1] = <abc>
  argv[1] = <abc>
! match 1
! match 2
! ok 1
! ok 2
! ok 3
! ok 4
! ok 5
  argv[1] = <man/man1/bash.1>
  argv[1] = <man/man1/bash.1>
***************
*** 82,83 ****
--- 82,114 ----
  ok 24
  ok 25
+ ok 26
+ ok 27
+ ok 28
+ ok 29
+ ok 30
+ ok 31
+ ok 32
+ ok 33
+ ok 34
+ ok 35
+ argv[1] = <*>
+ argv[1] = <a*b>
+ argv[2] = <a-b>
+ argv[3] = <aXb>
+ argv[4] = <abd>
+ argv[5] = <bb>
+ argv[6] = <bcd>
+ argv[7] = <bdir>
+ argv[8] = <ca>
+ argv[9] = <cb>
+ argv[10] = <dd>
+ argv[11] = <man>
+ argv[1] = <abc>
+ argv[2] = <abe>
+ argv[3] = <bdir>
+ argv[4] = <ca>
+ argv[5] = <de>
+ argv[6] = <man>
+ argv[1] = <*>
+ argv[1] = <man/man1/bash.1>
+ argv[1] = <man/man1/bash.1>
diff -Nrc2 bash-2.0/tests/heredoc.right bash-2.01/tests/heredoc.right
*** bash-2.0/tests/heredoc.right	Wed Sep 11 15:59:57 1996
--- bash-2.01/tests/heredoc.right	Fri Feb 21 13:53:20 1997
***************
*** 1,3 ****
--- 1,6 ----
  there
+ one - alpha
+ two - beta
+ three - gamma
  hi\
  there$a
***************
*** 9,12 ****
--- 12,43 ----
  hi
  hi
+ tab 1
+ tab 2
+ tab 3
+ abc
+ def ghi
+ jkl mno
+ fff is a function
+ fff () 
+ { 
+     ed /tmp/foo  >/dev/null <<ENDOFINPUT
+ /^name/d
+ w
+ q
+ ENDOFINPUT
+ 
+     aa=1
+ }
+ fff is a function
+ fff () 
+ { 
+     ed /tmp/foo >/dev/null  <<ENDOFINPUT
+ /^name/d
+ w
+ q
+ ENDOFINPUT
+ 
+     aa=1
+ }
  hi
  there
diff -Nrc2 bash-2.0/tests/heredoc.tests bash-2.01/tests/heredoc.tests
*** bash-2.0/tests/heredoc.tests	Wed Sep 11 15:59:44 1996
--- bash-2.01/tests/heredoc.tests	Thu Apr 17 12:03:15 1997
***************
*** 7,10 ****
--- 7,24 ----
  EOF2
  
+ while read line1; do
+ 	read line2 <&3
+ 	echo $line1 - $line2
+ done <<EOF1 3<<EOF2
+ one
+ two
+ three
+ EOF1
+ alpha
+ beta
+ gamma
+ EOF2
+ 
+ 
  # check quoted here-doc is protected
  
***************
*** 37,40 ****
--- 51,89 ----
  EO\
  F
+ 
+ # check operation of tab removal in here documents
+ cat <<- EOF
+ 	tab 1
+ 	tab 2
+ 	tab 3
+ 	EOF
+ 
+ # check appending of text to file from here document
+ rm -f /tmp/bash-zzz
+ cat > /tmp/bash-zzz << EOF
+ abc
+ EOF
+ cat >> /tmp/bash-zzz << EOF
+ def ghi
+ jkl mno
+ EOF
+ cat /tmp/bash-zzz
+ rm -f /tmp/bash-zzz
+ 
+ # make sure command printing puts the here-document as the last redirection
+ # on the line, and the function export code preserves syntactic correctness
+ fff()
+ {
+   ed /tmp/foo <<ENDOFINPUT >/dev/null
+ /^name/d
+ w
+ q
+ ENDOFINPUT
+ aa=1
+ }
+ 
+ type fff
+ export -f fff
+ ${THIS_SH} -c 'type fff'
  
  # check that end of file delimits a here-document
diff -Nrc2 bash-2.0/tests/histexpand.right bash-2.01/tests/histexpand.right
*** bash-2.0/tests/histexpand.right	Wed Dec 31 19:00:00 1969
--- bash-2.01/tests/histexpand.right	Wed Mar 26 14:01:41 1997
***************
*** 0 ****
--- 1,127 ----
+ echo $BASH_VERSION
+     1  for i in one two three; do echo $i; done
+     2  /bin/sh -c 'echo this is $0'
+     3  ls
+     4  echo $BASH_VERSION
+     1  for i in one two three; do echo $i; done
+     2  /bin/sh -c 'echo this is $0'
+     3  ls
+     4  echo $BASH_VERSION
+     5  HISTFILE=/tmp/newhistory
+     6  echo line 2 for history
+ echo line 2 for history
+ echo line 2 for history
+ set -H
+ echo line 2 for history
+ line 2 for history
+     1  for i in one two three; do echo $i; done
+     2  /bin/sh -c 'echo this is $0'
+     3  ls
+     4  echo $BASH_VERSION
+     5  HISTFILE=/tmp/newhistory
+     6  echo line 2 for history
+     7  set -H
+     8  echo line 2 for history
+ a b c d e
+ echo a b c d e
+ a b c d e
+ echo line 2 for history
+ line 2 for history
+ echo line 8 for history
+ line 8 for history
+ /bin/sh -c 'echo this is $0'
+ this is /bin/sh
+ echo sh
+ sh
+ echo /bin
+ /bin
+ echo e
+ e
+ a b c d e
+ echo b c d e
+ b c d e
+ echo b c d
+ b c d
+ echo d e
+ d e
+ echo d e
+ d e
+ echo b c d
+ b c d
+ file.c
+ echo file
+ file
+ echo .c
+ .c
+ echo 'file'
+ file
+ bax.c
+ echo $file
+ bax
+ echo .c
+ .c
+ echo '$file'
+ $file
+ a b c d e
+ echo 'a' 'b' 'c' 'd' 'e'
+ a b c d e
+ echo 'a b c d e'
+ a b c d e
+ foo.c foo.o foo.html foo.h
+ echo bar.c foo.o foo.html foo.h
+ bar.c foo.o foo.html foo.h
+ echo bar.c bar.o bar.html bar.h
+ bar.c bar.o bar.html bar.h
+ echo xbar.c xbar.o xbar.html xbar.h
+ xbar.c xbar.o xbar.html xbar.h
+ echo xbar.c xbar.o xbar.html xbar.h
+ xbar.c xbar.o xbar.html xbar.h
+ echo xwhix.c xwhix.o xwhix.html xwhix.h
+ xwhix.c xwhix.o xwhix.html xwhix.h
+ echo xwhix.c xwhix.o xwhix.html xwhix.h
+ echo 'xwhix'
+ xwhix
+ echo 'xwhix.h'
+ xwhix.h
+ echo 'xwhix.h'
+ xwhix.h
+ echo 'xwhix.h'
+ xwhix.h
+     8  echo line 2 for history
+     9  echo a b c d e
+    10  echo line 2 for history
+    11  echo line 8 for history
+    12  /bin/sh -c 'echo this is $0'
+    13  echo sh
+    14  echo /bin
+    15  echo e
+    16  echo a b c d e
+    17  echo b c d e
+    18  echo b c d
+    19  echo d e
+    20  echo b c d
+    21  echo file.c
+    22  echo file
+    23  echo .c
+    24  echo 'file'
+    25  echo $file.c
+    26  echo $file
+    27  echo .c
+    28  echo '$file'
+    29  echo a b c d e
+    30  echo 'a' 'b' 'c' 'd' 'e'
+    31  echo 'a b c d e'
+    32  echo foo.c foo.o foo.html foo.h
+    33  echo bar.c foo.o foo.html foo.h
+    34  echo bar.c bar.o bar.html bar.h
+    35  echo xbar.c xbar.o xbar.html xbar.h
+    36  echo xwhix.c xwhix.o xwhix.html xwhix.h
+    37  echo xwhix.c xwhix.o xwhix.html xwhix.h
+    38  echo 'xwhix'
+    39  echo 'xwhix.h'
+ !!
+ !!
+ echo '!!' \!\!
+ !! !!
+ ok 1
+ ok 2
diff -Nrc2 bash-2.0/tests/histexpand.tests bash-2.01/tests/histexpand.tests
*** bash-2.0/tests/histexpand.tests	Wed Dec 31 19:00:00 1969
--- bash-2.01/tests/histexpand.tests	Wed Mar 26 14:01:21 1997
***************
*** 0 ****
--- 1,112 ----
+ trap 'rm /tmp/newhistory' 0
+ 
+ file=bax
+ 
+ history -c
+ 
+ HISTFILE=history.list
+ HISTCONTROL=ignoreboth
+ HISTIGNORE='&:#*:history*:fc*'
+ # we will end up exercising the history stifling code as a result
+ HISTSIZE=32
+ 
+ shopt -s cmdhist
+ set -o history
+ 
+ history -p '!!'
+ 
+ history
+ 
+ HISTFILE=/tmp/newhistory
+ history -a
+ 
+ history -w
+ 
+ history -s "echo line 2 for history"
+ history
+ history -p '!e'
+ history -p '!!'
+ 
+ set -H
+ !!
+ !e
+ 
+ history
+ 
+ echo a b c d e
+ !?ch?
+ !-2
+ ^2^8
+ 
+ !2
+ 
+ # we're selecting /bin/sh -c ...; we want `sh'
+ echo !-1:0:t
+ # we're selecting /bin/sh -c ...; we want `/bin'
+ echo !-2:0:h
+ # we're selecting `echo a b c d e'; we want `e'
+ echo !?d?:5
+ 
+ echo a b c d e
+ echo !-1:2-$
+ echo !-2:2-4
+ echo !-2:3*
+ echo !!:*
+ 
+ echo !?a?:2-
+ 
+ echo file.c
+ echo !!:$:r
+ echo !-2:$:e
+ echo !-3:$:r:q
+ 
+ echo $file.c
+ echo !!:$:r
+ echo !-2:^:e
+ echo !-3:$:r:q
+ 
+ echo a b c d e
+ echo !!:1-$:x
+ echo !-2:1-$:q
+ 
+ echo foo.c foo.o foo.html foo.h
+ !!:s/foo/bar/
+ !-2:gs/foo/bar/
+ !!:gs/bar/x&/
+ !-2:g&
+ 
+ # make sure we can use any delimiter in the substitution, not just `/'
+ !!:gs+bar+whix+
+ 
+ !!:p
+ 
+ # wow
+ echo !?.o?:%:r:q
+ 
+ !!:0 !?.h?:%:q
+ !!:-$
+ !:-$
+ 
+ history
+ 
+ # make sure single quotes inhibit history expansion
+ echo '!!'
+ 
+ # make sure backslashes can quote the history expansion character
+ echo \!\!
+ 
+ # but other expansions on the line should still be processed
+ 
+ echo '!!' !!:*
+ history -c
+ unset HISTFILE
+ 
+ # make sure that the special bash cases are not history expanded
+ case p in
+ [!A-Z])	echo ok 1;;
+ esac
+ 
+ var1='ok 2'
+ var2=var1
+ 
+ echo ${!var2}
diff -Nrc2 bash-2.0/tests/history.list bash-2.01/tests/history.list
*** bash-2.0/tests/history.list	Wed Dec 31 19:00:00 1969
--- bash-2.01/tests/history.list	Mon Feb 24 13:31:43 1997
***************
*** 0 ****
--- 1,4 ----
+ for i in one two three; do echo $i; done
+ /bin/sh -c 'echo this is $0'
+ ls
+ echo $BASH_VERSION
diff -Nrc2 bash-2.0/tests/history.right bash-2.01/tests/history.right
*** bash-2.0/tests/history.right	Wed Dec 31 19:00:00 1969
--- bash-2.01/tests/history.right	Mon Mar  3 12:20:47 1997
***************
*** 0 ****
--- 1,104 ----
+     1  for i in one two three; do echo $i; done
+     2  /bin/sh -c 'echo this is $0'
+     3  ls
+     4  echo $BASH_VERSION
+ 1	 for i in one two three; do echo $i; done
+ 2	 /bin/sh -c 'echo this is $0'
+ 3	 ls
+ 4	 echo $BASH_VERSION
+ 	 for i in one two three; do echo $i; done
+ 	 /bin/sh -c 'echo this is $0'
+ 	 ls
+ 	 echo $BASH_VERSION
+ 4	 echo $BASH_VERSION
+ 3	 ls
+ 2	 /bin/sh -c 'echo this is $0'
+ 1	 for i in one two three; do echo $i; done
+ 	 echo $BASH_VERSION
+ 	 ls
+ 	 /bin/sh -c 'echo this is $0'
+ 	 for i in one two three; do echo $i; done
+     1  for i in one two three; do echo $i; done
+     2  /bin/sh -c 'echo this is $0'
+     3  ls
+     4  echo $BASH_VERSION
+     5  echo line for history
+ echo line for history
+ 	 for i in one two three; do echo $i; done
+ 	 /bin/sh -c 'echo this is $0'
+ 	 ls
+ 	 echo $BASH_VERSION
+ 	 echo line for history
+ displaying $HISTFILE after history -a
+ echo line for history
+ HISTFILE=/tmp/newhistory
+     1  for i in one two three; do echo $i; done
+     2  /bin/sh -c 'echo this is $0'
+     3  ls
+     4  echo $BASH_VERSION
+     5  echo line for history
+     6  HISTFILE=/tmp/newhistory
+     7  echo displaying \$HISTFILE after history -a
+     8  cat $HISTFILE
+ for i in one two three; do echo $i; done
+ /bin/sh -c 'echo this is $0'
+ ls
+ echo $BASH_VERSION
+ echo line for history
+ HISTFILE=/tmp/newhistory
+ echo displaying \$HISTFILE after history -a
+ cat $HISTFILE
+     1  for i in one two three; do echo $i; done
+     2  /bin/sh -c 'echo this is $0'
+     3  ls
+     4  echo $BASH_VERSION
+     5  echo line for history
+     6  HISTFILE=/tmp/newhistory
+     7  echo displaying \$HISTFILE after history -a
+     8  cat $HISTFILE
+     9  echo line 2 for history
+ echo line 2 for history
+ echo line 2 for history
+     1  for i in one two three; do echo $i; done
+     2  /bin/sh -c 'echo this is $0'
+     3  ls
+     4  echo $BASH_VERSION
+     5  echo line for history
+     6  HISTFILE=/tmp/newhistory
+     7  echo displaying \$HISTFILE after history -a
+     8  cat $HISTFILE
+     9  echo line 2 for history
+    10  # this should show up as one history entry
+    11  for x in one two three; do 	:; done
+ set -H
+ echo line 2 for history
+ line 2 for history
+ 4	 echo $BASH_VERSION
+ 5	 echo line for history
+ 6	 HISTFILE=/tmp/newhistory
+ 7	 echo displaying \$HISTFILE after history -a
+ 8	 cat $HISTFILE
+ 9	 echo line 2 for history
+ 10	 # this should show up as one history entry
+ 11	 for x in one two three; do 	:; done
+ 12	 # just a basic test.  a full test suite for history expansion should be
+ 13	 # created
+ 14	 set -H
+ 15	 echo line 2 for history
+ 16	 unset HISTSIZE
+ 17	 unset HISTFILE
+ 4	 echo $BASH_VERSION
+ 5	 echo line for history
+ 6	 HISTFILE=/tmp/newhistory
+ 7	 echo displaying \$HISTFILE after history -a
+ 8	 cat $HISTFILE
+ ./history.tests: fc: history specification out of range
+    14  set -H
+    15  echo line 2 for history
+    16  unset HISTSIZE
+    17  unset HISTFILE
+ aa ab ac
+ echo xx xb xc
+ xx xb xc
+ ./history.tests: fc: no command found
+ 1
diff -Nrc2 bash-2.0/tests/history.tests bash-2.01/tests/history.tests
*** bash-2.0/tests/history.tests	Wed Dec 31 19:00:00 1969
--- bash-2.01/tests/history.tests	Mon Mar  3 13:40:39 1997
***************
*** 0 ****
--- 1,83 ----
+ trap 'rm /tmp/newhistory' 0
+ 
+ history -c
+ 
+ HISTFILE=history.list
+ HISTCONTROL=ignoreboth
+ HISTIGNORE='&:history*:fc*'
+ HISTSIZE=32
+ 
+ shopt -s cmdhist
+ set -o history
+ 
+ history
+ 
+ fc -l
+ fc -nl
+ 
+ fc -lr
+ fc -nlr
+ 
+ history -s "echo line for history"
+ history
+ 
+ history -p '!!'
+ 
+ fc -nl
+ 
+ HISTFILE=/tmp/newhistory
+ history -a
+ echo displaying \$HISTFILE after history -a
+ cat $HISTFILE
+ 
+ history
+ history -w
+ cat $HISTFILE
+ 
+ history -s "echo line 2 for history"
+ history
+ history -p '!e'
+ history -p '!!'
+ 
+ # this should show up as one history entry
+ for x in one two three
+ do
+ 	:
+ done
+ history
+ 
+ # just a basic test.  a full test suite for history expansion should be
+ # created
+ set -H
+ !!
+ !e
+ 
+ unset HISTSIZE
+ unset HISTFILE
+ 
+ fc -l 4
+ fc -l 4 8
+ 
+ fc -l 502
+ 
+ history 4
+ 
+ shopt -so history
+ shopt -s expand_aliases
+ 
+ alias r="fc -s"
+ 
+ echo aa ab ac
+ 
+ r a=x
+ 
+ # this had better fail with `no command found'
+ r cc
+ 
+ unalias -a
+ alias
+ 
+ set +o history
+ 
+ shopt -q -o history
+ echo $?
diff -Nrc2 bash-2.0/tests/jobs.right bash-2.01/tests/jobs.right
*** bash-2.0/tests/jobs.right	Wed Dec 31 19:00:00 1969
--- bash-2.01/tests/jobs.right	Tue May 13 10:01:02 1997
***************
*** 0 ****
--- 1,71 ----
+ 0
+ wait-for-pid
+ wait-errors
+ ./jobs.tests: wait: `1-1' is not a pid or valid job spec
+ ./jobs.tests: wait: `-4' is not a pid or valid job spec
+ wait-for-background-pids
+ async list wait-for-background-pids
+ async list wait for child
+ forked
+ wait-when-no-children
+ wait-for-job
+ ./jobs.tests: wait: %2: no such job
+ 127
+ async list wait-for-job
+ forked
+ fg-bg 1
+ sleep 5
+ fg-bg 2
+ sleep 5
+ fg-bg 3
+ sleep 5
+ fg-bg 4
+ sleep 5
+ fg-bg 5
+ ./jobs.tests: fg: %2: no such job
+ ./jobs.tests: bg: bg background job?
+ fg-bg 6
+ ./jobs.tests: fg: illegal option: -s
+ fg: usage: fg [job_spec]
+ ./jobs.tests: bg: illegal option: -s
+ bg: usage: bg [job_spec]
+ ./jobs.tests: disown: illegal option: -r
+ disown: usage: disown [-h] [jobspec ...]
+ ./jobs.tests: disown: %1: no such job
+ wait-for-non-child
+ ./jobs.tests: wait: pid 1 is not a child of this shell
+ 127
+ 3 -- 1 2 3 -- 1 - 2 - 3
+ [1]   Running                 sleep 300 &
+ [2]-  Running                 sleep 350 &
+ [3]+  Running                 sleep 400 &
+ running jobs:
+ [1]   Running                 sleep 300 &
+ [2]-  Running                 sleep 350 &
+ [3]+  Running                 sleep 400 &
+ ./jobs.tests: kill: %4: no such job
+ after kill -STOP
+ running jobs:
+ [1]   Running                 sleep 300 &
+ [3]-  Running                 sleep 400 &
+ stopped jobs:
+ [2]+  Stopped                 sleep 350
+ after disown
+ [2]+  Stopped                 sleep 350
+ [3]-  Running                 sleep 400 &
+ running jobs:
+ [3]-  Running                 sleep 400 &
+ stopped jobs:
+ [2]+  Stopped                 sleep 350
+ after kill -s CONT
+ running jobs:
+ [2]+  Running                 sleep 350 &
+ [3]-  Running                 sleep 400 &
+ stopped jobs:
+ after kill -STOP, backgrounding %3:
+ [3]+ sleep 400 &
+ killing...
+ done
+ after KILL -STOP, foregrounding %1
+ sleep 10
+ done
diff -Nrc2 bash-2.0/tests/jobs.tests bash-2.01/tests/jobs.tests
*** bash-2.0/tests/jobs.tests	Wed Dec 31 19:00:00 1969
--- bash-2.01/tests/jobs.tests	Thu Mar  6 16:07:41 1997
***************
*** 0 ****
--- 1,145 ----
+ jobs
+ echo $?
+ 
+ echo wait-for-pid
+ sleep 10 &
+ wait $!
+ 
+ echo wait-errors
+ wait 1-1
+ wait -- -4
+ 
+ echo wait-for-background-pids
+ sleep 5 &
+ sleep 8 &
+ wait
+ 
+ echo async list wait-for-background-pids
+ sleep 5 & sleep 8 &
+ wait
+ 
+ echo async list wait for child
+ sleep 5 & echo forked
+ wait
+ 
+ echo wait-when-no-children
+ wait
+ 
+ set -m
+ 
+ echo wait-for-job
+ sleep 5 &
+ wait %2		# this should be a no-such-job error
+ echo $?
+ wait %1
+ 
+ echo async list wait-for-job
+ sleep 5 & echo forked
+ wait %1
+ 
+ echo fg-bg 1
+ sleep 5 &
+ %1
+ 
+ echo fg-bg 2
+ sleep 5 &
+ fg %%
+ 
+ echo fg-bg 3
+ sleep 5 &
+ fg %s
+ 
+ echo fg-bg 4
+ sleep 5 &
+ fg %?ee
+ 
+ # these next two are error cases
+ echo fg-bg 5
+ sleep 15 &
+ fg %2		# this should be a no-such-job error
+ bg %1		# this should be a `bg background job?' error
+ wait
+ 
+ # these may someday mean to start the jobs, but not print the line
+ # describing the status, but for now they are errors
+ echo fg-bg 6
+ sleep 5 &
+ fg -s %1
+ bg -s %1
+ wait
+ 
+ # someday this may mean to disown all running jobs, but for now it is
+ # an error
+ disown -r
+ 
+ # this is an error
+ disown %1
+ 
+ echo wait-for-non-child
+ wait 1
+ echo $?
+ 
+ exit 1 | exit 2 | exit 3
+ echo $? -- ${PIPESTATUS[@]} -- ${PIPESTATUS[0]} - ${PIPESTATUS[1]} - ${PIPESTATUS[2]}
+ 
+ sleep 300 &
+ sleep 350 &
+ sleep 400 &
+ 
+ jobs
+ 
+ echo running jobs:
+ jobs -r
+ 
+ # should be an error
+ kill -n 1 %4
+ 
+ kill -STOP %2
+ sleep 5	# give time for the shell to get the stop notification
+ echo after kill -STOP
+ echo running jobs:
+ jobs -r
+ echo stopped jobs:
+ jobs -s
+ 
+ disown %1
+ 
+ echo after disown
+ jobs
+ echo running jobs:
+ jobs -r
+ echo stopped jobs:
+ jobs -s
+ 
+ kill -s CONT %2
+ echo after kill -s CONT
+ echo running jobs:
+ jobs -r
+ echo stopped jobs:
+ jobs -s
+ 
+ kill -STOP %3
+ sleep 5	# give time for the shell to get the stop notification
+ echo after kill -STOP, backgrounding %3:
+ bg %3
+ 
+ disown -h %2
+ 
+ # make sure the killed processes don't cause a message
+ exec 5>&2
+ exec 2>/dev/null
+ 
+ echo killing...
+ kill -n 9 %2 %3
+ wait	# make sure we reap the processes while stderr is still redirected
+ echo done
+ 
+ exec 2>&5
+ 
+ sleep 10 &
+ kill -STOP %1
+ sleep 5	# give time for the shell to get the stop notification
+ echo after KILL -STOP, foregrounding %1
+ fg %1
+ 
+ echo done
diff -Nrc2 bash-2.0/tests/minus-e bash-2.01/tests/minus-e
*** bash-2.0/tests/minus-e	Thu Jun 13 20:49:49 1991
--- bash-2.01/tests/minus-e	Wed Dec 31 19:00:00 1969
***************
*** 1,6 ****
- set -e
- if set +e
- then
- 	false
- fi
- echo hi
--- 0 ----
diff -Nrc2 bash-2.0/tests/minus-e.right bash-2.01/tests/minus-e.right
*** bash-2.0/tests/minus-e.right	Thu Jan  6 12:35:56 1994
--- bash-2.01/tests/minus-e.right	Wed Dec 31 19:00:00 1969
***************
*** 1 ****
- hi
--- 0 ----
diff -Nrc2 bash-2.0/tests/misc/chld-trap.sh bash-2.01/tests/misc/chld-trap.sh
*** bash-2.0/tests/misc/chld-trap.sh	Wed Jul 24 23:39:40 1991
--- bash-2.01/tests/misc/chld-trap.sh	Wed Dec 31 19:00:00 1969
***************
*** 1,14 ****
- #! /bin/sh
- #
- # show that setting a trap on SIGCHLD is not disastrous.
- #
- 
- trap 'echo caught a child death' SIGCHLD
- 
- sleep 5 &
- sleep 5 &
- sleep 5 &
- 
- wait
- 
- exit 0
--- 0 ----
diff -Nrc2 bash-2.0/tests/misc/dot-test-1.sh bash-2.01/tests/misc/dot-test-1.sh
*** bash-2.0/tests/misc/dot-test-1.sh	Fri Jun 12 16:39:53 1992
--- bash-2.01/tests/misc/dot-test-1.sh	Wed Dec 31 19:00:00 1969
***************
*** 1,3 ****
- echo this is $0
- . ./dot-test-1.sub
- echo after . dot-test-1.sub
--- 0 ----
diff -Nrc2 bash-2.0/tests/misc/dot-test-1.sub bash-2.01/tests/misc/dot-test-1.sub
*** bash-2.0/tests/misc/dot-test-1.sub	Fri Jun 12 16:39:21 1992
--- bash-2.01/tests/misc/dot-test-1.sub	Wed Dec 31 19:00:00 1969
***************
*** 1 ****
- echo this is dot-test-1.sub
--- 0 ----
diff -Nrc2 bash-2.0/tests/misc/gotest bash-2.01/tests/misc/gotest
*** bash-2.0/tests/misc/gotest	Tue Jul 26 16:54:05 1994
--- bash-2.01/tests/misc/gotest	Wed Dec 31 19:00:00 1969
***************
*** 1,26 ****
- aflag=
- bflag=
- 
- while getopts ab: name
- do
- 	case $name in
- 	a)	aflag=1 ;;
- 	b)	bflag=1
- 		bval=$OPTARG;;
- 	?)	echo Usage: $0 [-a] [-b value] args
- 		exit 2;;
- 	esac
- 
- done
- 
- if [ ! -z "$aflag" ] ; then echo -a specified ; fi
- if [ ! -z "$bflag" ] ; then echo -b $bval specified ; fi
- 
- if [ "$OPTIND" -gt 1 ]
- then
- 	shift $(( $OPTIND - 1 ))
- fi
- 
- echo remaining args: "$*"
- 
- exit 0
--- 0 ----
diff -Nrc2 bash-2.0/tests/misc/haertel.perftest bash-2.01/tests/misc/haertel.perftest
*** bash-2.0/tests/misc/haertel.perftest	Wed Dec 31 19:00:00 1969
--- bash-2.01/tests/misc/haertel.perftest	Fri May  6 10:18:11 1994
***************
*** 0 ****
--- 1,9 ----
+ foo() { case $1 in a*) ;; *) ;; esac ;}
+ bar() { case $1 in [abc]*) ;; *);; esac ;}
+ baz() { case $1 in xyzzy) ;; *) ;; esac ;}
+ for x in /usr/lib/*/*
+ do
+         foo $x
+         bar $x
+         baz $x
+ done
diff -Nrc2 bash-2.0/tests/misc/redir.t1.sh bash-2.01/tests/misc/redir.t1.sh
*** bash-2.0/tests/misc/redir.t1.sh	Fri Mar 18 11:08:24 1994
--- bash-2.01/tests/misc/redir.t1.sh	Wed Dec 31 19:00:00 1969
***************
*** 1,26 ****
- read line1
- 
- echo read line1 \"$line1\"
- 
- exec 4</etc/passwd
- 
- exec 5<&0
- exec 0<&4
- 
- read line2
- 
- echo read line2 \"$line2\"
- 
- exec 0<&5
- 
- read line3
- 
- echo read line3 \"$line3\"
- 
- exec 0<&4
- 
- read line4
- 
- echo read line4 \"$line4\"
- 
- exec 4<&-
--- 0 ----
diff -Nrc2 bash-2.0/tests/misc/redir.t3.sh bash-2.01/tests/misc/redir.t3.sh
*** bash-2.0/tests/misc/redir.t3.sh	Fri Apr 29 14:30:41 1994
--- bash-2.01/tests/misc/redir.t3.sh	Wed Dec 31 19:00:00 1969
***************
*** 1,8 ****
- #
- # Test the effect of input buffering on the shell's input
- #
- echo this is redir.t3.sh
- 
- exec 0< redir.t3.sub
- 
- echo after exec in redir.t3.sh
--- 0 ----
diff -Nrc2 bash-2.0/tests/misc/redir.t3.sub bash-2.01/tests/misc/redir.t3.sub
*** bash-2.0/tests/misc/redir.t3.sub	Fri Jun 12 16:37:19 1992
--- bash-2.01/tests/misc/redir.t3.sub	Wed Dec 31 19:00:00 1969
***************
*** 1 ****
- echo this is redir-test-3.sub
--- 0 ----
diff -Nrc2 bash-2.0/tests/misc/redir.t4.sh bash-2.01/tests/misc/redir.t4.sh
*** bash-2.0/tests/misc/redir.t4.sh	Wed May  8 19:37:45 1996
--- bash-2.01/tests/misc/redir.t4.sh	Wed Dec 31 19:00:00 1969
***************
*** 1,12 ****
- echo "Point 1"
- exec 3</etc/passwd
- exec 4>/tmp/a
- exec 5>/tmp/b
- echo "Point 2"
- echo to a 1>&4
- echo to b 1>&5
- exec 11</etc/printcap
- echo "Point 3"
- echo to a 1>&4
- echo to b 1>&5
- exit 0
--- 0 ----
diff -Nrc2 bash-2.0/tests/misc/run.r1.sh bash-2.01/tests/misc/run.r1.sh
*** bash-2.0/tests/misc/run.r1.sh	Fri Mar 18 11:08:56 1994
--- bash-2.01/tests/misc/run.r1.sh	Wed Dec 31 19:00:00 1969
***************
*** 1 ****
- ../../bash redir.t1.sh
--- 0 ----
diff -Nrc2 bash-2.0/tests/misc/run.r3.sh bash-2.01/tests/misc/run.r3.sh
*** bash-2.0/tests/misc/run.r3.sh	Fri Mar 18 11:09:30 1994
--- bash-2.01/tests/misc/run.r3.sh	Wed Dec 31 19:00:00 1969
***************
*** 1,3 ****
- #
- # the `after exec in ...' should not be echoed
- ../../bash < redir.t3.sh
--- 0 ----
diff -Nrc2 bash-2.0/tests/misc/test-minus-e.1 bash-2.01/tests/misc/test-minus-e.1
*** bash-2.0/tests/misc/test-minus-e.1	Sun Dec 19 14:43:48 1993
--- bash-2.01/tests/misc/test-minus-e.1	Thu Mar  6 12:45:59 1997
***************
*** 8,12 ****
  	set +e
  done
- 
- 	
- 	
--- 8,9 ----
diff -Nrc2 bash-2.0/tests/misc/test-minus-e.2 bash-2.01/tests/misc/test-minus-e.2
*** bash-2.0/tests/misc/test-minus-e.2	Sun Dec 19 14:45:11 1993
--- bash-2.01/tests/misc/test-minus-e.2	Thu Mar  6 12:45:51 1997
***************
*** 10,14 ****
  done
  rm -f .file
- 
- 	
- 	
--- 10,11 ----
diff -Nrc2 bash-2.0/tests/new-exp.right bash-2.01/tests/new-exp.right
*** bash-2.0/tests/new-exp.right	Thu Dec 12 11:59:44 1996
--- bash-2.01/tests/new-exp.right	Thu Feb 27 12:39:09 1997
***************
*** 29,35 ****
--- 29,38 ----
  barfoo
  barfoo
+ \x
  argv[1] = <abcd>
  argv[1] = <efg>
  argv[2] = <nop>
+ argv[1] = <efg>
+ argv[2] = <nop>
  argv[1] = <hijklmnop>
  argv[1] = <abcdefghijklmnop>
***************
*** 217,219 ****
--- 220,387 ----
  argv[1] = <two>
  argv[1] = <oneonetwo>
+ ./new-exp.tests: -2: substring expression < 0
+ argv[1] = <defghi>
+ argv[1] = <efghi>
+ argv[1] = <e*docrine>
+ argv[1] = <e*docri*e>
+ argv[1] = <endocrine>
+ argv[1] = <endocrine>
+ argv[1] = </usr/bin>
+ argv[2] = </bin>
+ argv[3] = </usr/local/bin>
+ argv[4] = </usr/gnu/bin>
+ argv[5] = </usr/bin/X11>
+ argv[6] = </sbin>
+ argv[7] = </usr/sbin>
+ argv[1] = <r>
+ argv[2] = <s>
+ argv[3] = <t>
+ argv[4] = <u>
+ argv[5] = <v>
+ argv[6] = <w>
+ argv[7] = <x>
+ argv[8] = <y>
+ argv[9] = <z>
+ argv[1] = <r>
+ argv[2] = <s>
+ argv[3] = <t>
+ argv[4] = <u>
+ argv[5] = <v>
+ argv[6] = <w>
+ argv[7] = <x>
+ argv[8] = <y>
+ argv[9] = <z>
+ argv[1] = <r>
+ argv[2] = <s>
+ argv[3] = <t>
+ argv[4] = <u>
+ argv[5] = <v>
+ argv[6] = <w>
+ argv[7] = <x>
+ argv[8] = <y>
+ argv[9] = <z>
+ argv[1] = <r>
+ argv[2] = <s>
+ argv[3] = <t>
+ argv[4] = <u>
+ argv[5] = <v>
+ argv[6] = <w>
+ argv[7] = <x>
+ argv[8] = <y>
+ argv[9] = <z>
+ argv[1] = <a>
+ argv[2] = <a>
+ argv[3] = <a>
+ argv[4] = <a>
+ argv[5] = <a>
+ argv[6] = <a>
+ argv[7] = <a>
+ argv[8] = <a>
+ argv[9] = <a>
+ argv[1] = <a>
+ argv[2] = <a>
+ argv[3] = <a>
+ argv[4] = <a>
+ argv[5] = <a>
+ argv[6] = <a>
+ argv[7] = <a>
+ argv[8] = <a>
+ argv[9] = <a>
+ argv[1] = <r>
+ argv[2] = <s>
+ argv[3] = <t>
+ argv[4] = <u>
+ argv[5] = <v>
+ argv[6] = <w>
+ argv[7] = <x>
+ argv[8] = <y>
+ argv[9] = <z>
+ argv[1] = <r>
+ argv[2] = <s>
+ argv[3] = <t>
+ argv[4] = <u>
+ argv[5] = <v>
+ argv[6] = <w>
+ argv[7] = <x>
+ argv[8] = <y>
+ argv[9] = <z>
+ argv[1] = <r>
+ argv[2] = <s>
+ argv[3] = <t>
+ argv[4] = <u>
+ argv[5] = <v>
+ argv[6] = <w>
+ argv[7] = <x>
+ argv[8] = <y>
+ argv[9] = <z>
+ argv[1] = <r>
+ argv[2] = <s>
+ argv[3] = <t>
+ argv[4] = <u>
+ argv[5] = <v>
+ argv[6] = <w>
+ argv[7] = <x>
+ argv[8] = <y>
+ argv[9] = <z>
+ argv[1] = <r>
+ argv[2] = <s>
+ argv[3] = <t>
+ argv[4] = <u>
+ argv[5] = <v>
+ argv[6] = <w>
+ argv[7] = <x>
+ argv[8] = <y>
+ argv[9] = <z>
+ argv[1] = <r>
+ argv[2] = <s>
+ argv[3] = <t>
+ argv[4] = <u>
+ argv[5] = <v>
+ argv[6] = <w>
+ argv[7] = <x>
+ argv[8] = <y>
+ argv[9] = <z>
+ argv[1] = <a>
+ argv[2] = <a>
+ argv[3] = <a>
+ argv[4] = <a>
+ argv[5] = <a>
+ argv[6] = <a>
+ argv[7] = <a>
+ argv[8] = <a>
+ argv[9] = <a>
+ argv[1] = <a>
+ argv[2] = <a>
+ argv[3] = <a>
+ argv[4] = <a>
+ argv[5] = <a>
+ argv[6] = <a>
+ argv[7] = <a>
+ argv[8] = <a>
+ argv[9] = <a>
+ argv[1] = <r>
+ argv[2] = <s>
+ argv[3] = <t>
+ argv[4] = <u>
+ argv[5] = <v>
+ argv[6] = <w>
+ argv[7] = <x>
+ argv[8] = <y>
+ argv[9] = <z>
+ argv[1] = <r>
+ argv[2] = <s>
+ argv[3] = <t>
+ argv[4] = <u>
+ argv[5] = <v>
+ argv[6] = <w>
+ argv[7] = <x>
+ argv[8] = <y>
+ argv[9] = <z>
+ ./new-exp.tests: $9: unbound variable
+ ./new-exp.tests: 9: unbound variable
+ ./new-exp.tests: UNSET: unbound variable
+ ./new-exp.tests: UNSET: unbound variable
+ ./new-exp.tests: UNSET: unbound variable
+ ./new-exp.tests: UNSET: unbound variable
+ ./new-exp.tests: UNSET: unbound variable
  ./new-exp.tests: ABXD: parameter unset
diff -Nrc2 bash-2.0/tests/new-exp.sub1 bash-2.01/tests/new-exp.sub1
*** bash-2.0/tests/new-exp.sub1	Wed Dec 31 19:00:00 1969
--- bash-2.01/tests/new-exp.sub1	Wed Mar 26 14:12:33 1997
***************
*** 0 ****
--- 1,11 ----
+ expect()
+ {
+         echo expect "$@"
+ }
+ 
+ expect this is a test of proc subst
+ cat <(echo this is a test of proc subst)
+ echo this is test 2 > /tmp/x
+ expect this is test 2
+ cat <(cat /tmp/x)
+ rm -f /tmp/x
diff -Nrc2 bash-2.0/tests/new-exp.tests bash-2.01/tests/new-exp.tests
*** bash-2.0/tests/new-exp.tests	Thu Dec 12 11:59:26 1996
--- bash-2.01/tests/new-exp.tests	Wed Mar 26 14:13:16 1997
***************
*** 1,2 ****
--- 1,6 ----
+ # must do this because posix mode causes process substitution to be disabled
+ # and flagged as a syntax error, which causes the shell to exit
+ set +o posix
+ 
  expect()
  {
***************
*** 84,87 ****
--- 88,96 ----
  echo -e $foo"\c " ; echo foo
  
+ # make sure backslashes are preserved in front of characters that are not
+ # valid backslash escapes
+ expect '<\x>'
+ echo -e '\x'
+ 
  # substring tests
  z=abcdefghijklmnop
***************
*** 92,95 ****
--- 101,107 ----
  recho ${z:4:3} ${z:${#z}-3:3}
  
+ expect '<efg> <nop>'
+ recho ${z:4:3} ${z: -3:3}
+ 
  expect '<hijklmnop>'
  recho ${z:7:30}
***************
*** 139,143 ****
  set -u
  expect $0: ABX: unbound variable
! recho ${ABX}
  set +u
  
--- 151,155 ----
  set -u
  expect $0: ABX: unbound variable
! ( recho ${ABX} )
  set +u
  
***************
*** 223,232 ****
  echo $abmcde
  
! expect this is a test of proc subst
! cat <(echo this is a test of proc subst)
! echo this is test 2 > /tmp/x
! expect this is test 2
! cat <(cat /tmp/x)
! rm -f /tmp/x
  
  expect $0: '${#:-foo}: bad substitution'
--- 235,242 ----
  echo $abmcde
  
! # run process substitution tests in a subshell so that syntax errors
! # caused by a shell not implementing process substitution (e.g., one
! # built on a NeXT) will not cause the whole test to exit prematurely
! ${THIS_SH} ./new-exp.sub1
  
  expect $0: '${#:-foo}: bad substitution'
***************
*** 367,370 ****
--- 377,452 ----
  recho ${xx//one}
  recho ${xx/\/one}
+ 
+ # out-of-range substrings
+ var=abc
+ c=${var:3}
+ expect nothing
+ recho $c
+ c=${var:4}
+ expect nothing
+ recho $c
+ expect '<./new-exp.tests: -2: substring expression < 0>'
+ c=${var:0:-2}
+ 
+ var=abcdefghi
+ c=${var:3:12}
+ recho $c
+ c=${var:4:20}
+ recho $c
+ 
+ # make sure null patterns work
+ xxx=endocrine
+ yyy=n
+ unset zzz
+ 
+ recho ${xxx/$yyy/*}
+ recho ${xxx//$yyy/*}
+ 
+ recho ${xxx/$zzz/*}
+ recho ${xxx//$zzz/*}
+ 
+ # another case that caused a core dump in bash-2.0
+ XPATH=/usr/bin:/bin:/usr/local/bin:/usr/gnu/bin::/usr/bin/X11:/sbin:/usr/sbin
+ 
+ recho ${XPATH//:/ }
+ 
+ xx=(ar as at au av aw ax ay az)
+ 
+ recho ${xx[@]/a/}
+ recho ${xx[@]//a/}
+ 
+ recho ${xx[*]/a/}
+ recho ${xx[*]//a/}
+ 
+ recho ${xx[@]%?}
+ recho ${xx[*]%?}
+ 
+ recho ${xx[@]#?}
+ recho ${xx[*]#?}
+ 
+ set -- ar as at au av aw ax ay az
+ 
+ recho ${@/a/}
+ recho ${@//a/}
+ 
+ recho ${*/a/}
+ recho ${*//a/}
+ 
+ recho ${@%?}
+ recho ${*%?}
+ 
+ recho ${@#?}
+ recho ${*#?}
+ 
+ shift $#
+ set -u
+ ( recho $9 ; echo after 1)
+ ( recho ${9} ; echo after 2)
+ ( recho $UNSET ; echo after 3)
+ ( recho ${UNSET} ; echo after 4)
+ ( recho "$UNSET" ; echo after 5)
+ ( recho "${UNSET}" ; echo after 6)
+ ( recho "${#UNSET}" ; echo after 7)
+ set +u
  
  # this must be last!
diff -Nrc2 bash-2.0/tests/nquote.right bash-2.01/tests/nquote.right
*** bash-2.0/tests/nquote.right	Wed Jun 12 20:06:48 1996
--- bash-2.01/tests/nquote.right	Fri Feb 21 12:14:39 1997
***************
*** 15,16 ****
--- 15,17 ----
  argv[1] = <$hello, chet>
  argv[1] = <hello, chet>
+ ok
diff -Nrc2 bash-2.0/tests/nquote.tests bash-2.01/tests/nquote.tests
*** bash-2.0/tests/nquote.tests	Wed Jun 12 20:06:19 1996
--- bash-2.01/tests/nquote.tests	Mon Feb 24 17:28:19 1997
***************
*** 56,57 ****
--- 56,63 ----
  expect '<hello, chet>'
  recho $"hello, $world"
+ 
+ z=$'\v\f\a\b'
+ case "$z" in
+ $'\v\f\a\b')	echo ok;;
+ *)		echo bad;;
+ esac
diff -Nrc2 bash-2.0/tests/read.right bash-2.01/tests/read.right
*** bash-2.0/tests/read.right	Wed Sep 11 15:56:22 1996
--- bash-2.01/tests/read.right	Fri Mar 14 11:09:25 1997
***************
*** 13,14 ****
--- 13,26 ----
  1a:
  2: x[A B]
+ [A B ]
+ [ A B ]
+ ==aa==
+ ====
+ ====
+ argv[1] = < foo>
+ argv[1] = < foo>
+ argv[1] = <foo>
+ argv[1] = < foo>
+ argv[1] = <foo>
+ argv[1] = <foo>
+ argv[1] = < foo>
diff -Nrc2 bash-2.0/tests/read.tests bash-2.01/tests/read.tests
*** bash-2.0/tests/read.tests	Wed Sep 11 15:55:48 1996
--- bash-2.01/tests/read.tests	Fri Mar 14 11:08:53 1997
***************
*** 23,24 ****
--- 23,69 ----
  rm /tmp/IN
  
+ # this is where the bash `read' behavior with respect to $REPLY differs
+ # from ksh93
+ echo "A B " > /tmp/IN
+ 
+ read < /tmp/IN
+ echo "[$REPLY]"
+ 
+ rm /tmp/IN
+ 
+ echo " A B " > /tmp/IN
+ 
+ read < /tmp/IN
+ echo "[$REPLY]"
+ 
+ rm /tmp/IN
+ 
+ # make sure that read with more variables than words sets the extra
+ # variables to the empty string
+ 
+ bvar=bvar
+ cvar=cvar
+ echo aa > /tmp/IN
+ read avar bvar cvar < /tmp/IN
+ echo =="$avar"==
+ echo =="$bvar"==
+ echo =="$cvar"==
+ 
+ rm /tmp/IN
+ 
+ # test behavior of read with various settings of IFS
+ 
+ echo " foo" | { IFS= read line; recho "$line"; }
+ 
+ echo " foo" | { IFS= ; read line; recho "$line"; }
+ 
+ echo " foo" | { unset IFS ; read line; recho "$line"; }
+ 
+ echo " foo" | { IFS=$'\n' ; read line; recho "$line"; }
+ 
+ echo " foo" | { IFS=$' \n' ; read line; recho "$line"; }
+ 
+ echo " foo" | { IFS=$' \t\n' ; read line; recho "$line"; }
+ 
+ echo " foo" | { IFS=$':' ; read line; recho "$line"; }
+ 
diff -Nrc2 bash-2.0/tests/redir.right bash-2.01/tests/redir.right
*** bash-2.0/tests/redir.right	Wed Dec 31 19:00:00 1969
--- bash-2.01/tests/redir.right	Wed Feb 26 14:28:31 1997
***************
*** 0 ****
--- 1,47 ----
+ abc
+ ./redir.tests: /tmp/redir-test: cannot overwrite existing file
+ abc
+ def
+ def
+ ./redir.tests: $z: ambiguous redirect
+ Point 1
+ Point 2
+ to a
+ to b
+ Point 3
+ to a
+ to a
+ to b
+ to b
+ Point 4
+ to c
+ Point 5
+ this is redir1.sub
+ this is redir2.sub
+ read line1 "ab"
+ read line2 "root"
+ read line3 "cd"
+ read line4 "daemon"
+ from stdin: aa
+ to stdout
+ ./redir4.sub: $fd: ambiguous redirect
+ ./redir4.sub: $fd: ambiguous redirect
+ /tmp/err-and-out:
+ to stdout
+ to stderr
+ /tmp/err-and-out:
+ to stdout
+ to stderr
+ 0 -- 3 0
+ 0 -- 4 0
+ ab
+ cd
+ ef
+ gh
+ ij
+ kl
+ 0
+ ab
+ cd
+ cd
+ ./redir.tests: redir1.*: No such file or directory
diff -Nrc2 bash-2.0/tests/redir.tests bash-2.01/tests/redir.tests
*** bash-2.0/tests/redir.tests	Wed Dec 31 19:00:00 1969
--- bash-2.01/tests/redir.tests	Tue May 27 10:48:51 1997
***************
*** 0 ****
--- 1,147 ----
+ export LC_ALL=C
+ export LANG=C
+ 
+ # catch-all for remaining untested redirection stuff
+ set +o posix
+ 
+ echo abc > /tmp/redir-test
+ cat /tmp/redir-test
+ 
+ set -o noclobber
+ 
+ #this should be an error
+ echo def > /tmp/redir-test
+ cat /tmp/redir-test
+ 
+ # but this should succeed
+ echo def > /tmp/redir-test-2
+ cat /tmp/redir-test-2
+ 
+ # and so should this
+ echo def >| /tmp/redir-test
+ cat /tmp/redir-test
+ 
+ set +o noclobber
+ rm /tmp/redir-test /tmp/redir-test-2
+ 
+ # this should be an error
+ z="a b"
+ cat < $z
+ 
+ echo "Point 1"
+ 
+ exec 3</etc/passwd
+ exec 4>/tmp/bash-a
+ exec 5>/tmp/bash-b
+ echo "Point 2"
+ 
+ echo to a 1>&4
+ echo to b 1>&5
+ cat /tmp/bash-a
+ cat /tmp/bash-b
+ exec 11</dev/null
+ echo "Point 3"
+ 
+ echo to a 1>&4
+ echo to b 1>&5
+ cat /tmp/bash-a
+ cat /tmp/bash-b
+ 
+ exec 11<&-
+ echo "Point 4"
+ 
+ exec 6<>/tmp/bash-c
+ echo to c 1>&6
+ cat /tmp/bash-c
+ echo "Point 5"
+ 
+ rm -f /tmp/bash-a /tmp/bash-b /tmp/bash-c
+ 
+ #
+ # Test the effect of input buffering on the shell's input
+ #
+ ${THIS_SH} < redir1.sub
+ 
+ # more open, close, duplicate file descriptors
+ ${THIS_SH} ./redir3.sub < ./redir3.in1
+ 
+ # still more redirections
+ ${THIS_SH} ./redir4.sub < redir4.in1
+ 
+ # various forms of null redirection
+ testf()
+ {
+ 	if [ -f "$1" ]; then
+ 		rm -f "$1"
+ 	else
+ 		echo oops -- $1 not found
+ 	fi
+ }
+ 
+ > /tmp/null-redir-a
+ testf /tmp/null-redir-a
+ 
+ $EXIT > /tmp/null-redir-b
+ testf /tmp/null-redir-b
+ 
+ ( > /tmp/null-redir-c )
+ testf /tmp/null-redir-c
+ 
+ $EXIT > /tmp/null-redir-d &
+ wait
+ testf /tmp/null-redir-d
+ 
+ exit 3 | $EXIT > /tmp/null-redir-e
+ echo $? -- ${PIPESTATUS[@]}
+ testf /tmp/null-redir-e
+ 
+ exit 4 | > /tmp/null-redir-f
+ echo $? -- ${PIPESTATUS[@]}
+ testf /tmp/null-redir-f
+ 
+ > /tmp/null-redir-g &
+ wait
+ testf /tmp/null-redir-g
+ 
+ exec >/tmp/null-redir-h &
+ wait
+ testf /tmp/null-redir-h
+ 
+ # make sure async commands don't get /dev/null as stdin when an explicit
+ # input redirection is supplied
+ for x in 1 2 3; do
+ 	{ read line ; echo $line ; } &
+ 	wait
+ 	{ read line ; echo $line ; } &
+ 	wait
+ done << EOF
+ ab
+ cd
+ ef
+ gh
+ ij
+ kl
+ EOF
+ 
+ # make sure async commands get /dev/null as stdin in the absence of any
+ # input redirection
+ /bin/cat &
+ wait
+ echo $?
+ 
+ # make sure that loops work OK with here documents and are not run in
+ # subshells
+ while read line; do
+ 	echo $line
+ 	l2=$line
+ done << EOF
+ ab
+ cd
+ EOF
+ echo $l2
+ 
+ # in posix mode, non-interactive shells are not allowed to perform
+ # filename expansion on input redirections, even if they expand to
+ # a single filename
+ set -o posix
+ cat < redir1.*
diff -Nrc2 bash-2.0/tests/redir1.sub bash-2.01/tests/redir1.sub
*** bash-2.0/tests/redir1.sub	Wed Dec 31 19:00:00 1969
--- bash-2.01/tests/redir1.sub	Fri Feb 21 16:36:49 1997
***************
*** 0 ****
--- 1,8 ----
+ #
+ # Test the effect of input buffering on the shell's input
+ #
+ echo this is redir1.sub
+ 
+ exec 0< redir2.sub
+ 
+ echo BUG: after exec in redir1.sub
diff -Nrc2 bash-2.0/tests/redir2.sub bash-2.01/tests/redir2.sub
*** bash-2.0/tests/redir2.sub	Wed Dec 31 19:00:00 1969
--- bash-2.01/tests/redir2.sub	Fri Feb 21 16:35:29 1997
***************
*** 0 ****
--- 1 ----
+ echo this is redir2.sub
diff -Nrc2 bash-2.0/tests/redir3.in1 bash-2.01/tests/redir3.in1
*** bash-2.0/tests/redir3.in1	Wed Dec 31 19:00:00 1969
--- bash-2.01/tests/redir3.in1	Fri Feb 21 16:41:09 1997
***************
*** 0 ****
--- 1,2 ----
+ ab
+ cd
diff -Nrc2 bash-2.0/tests/redir3.in2 bash-2.01/tests/redir3.in2
*** bash-2.0/tests/redir3.in2	Wed Dec 31 19:00:00 1969
--- bash-2.01/tests/redir3.in2	Fri Feb 21 16:41:22 1997
***************
*** 0 ****
--- 1,2 ----
+ root
+ daemon
diff -Nrc2 bash-2.0/tests/redir3.sub bash-2.01/tests/redir3.sub
*** bash-2.0/tests/redir3.sub	Wed Dec 31 19:00:00 1969
--- bash-2.01/tests/redir3.sub	Fri Feb 21 16:42:13 1997
***************
*** 0 ****
--- 1,26 ----
+ read line1
+ 
+ echo read line1 \"$line1\"
+ 
+ exec 4<./redir3.in2
+ 
+ exec 5<&0
+ exec 0<&4
+ 
+ read line2
+ 
+ echo read line2 \"$line2\"
+ 
+ exec 0<&5
+ 
+ read line3
+ 
+ echo read line3 \"$line3\"
+ 
+ exec 0<&4
+ 
+ read line4
+ 
+ echo read line4 \"$line4\"
+ 
+ exec 4<&-
diff -Nrc2 bash-2.0/tests/redir4.in1 bash-2.01/tests/redir4.in1
*** bash-2.0/tests/redir4.in1	Wed Dec 31 19:00:00 1969
--- bash-2.01/tests/redir4.in1	Wed Feb 26 14:13:28 1997
***************
*** 0 ****
--- 1 ----
+ aa
diff -Nrc2 bash-2.0/tests/redir4.sub bash-2.01/tests/redir4.sub
*** bash-2.0/tests/redir4.sub	Wed Dec 31 19:00:00 1969
--- bash-2.01/tests/redir4.sub	Wed Feb 26 14:24:04 1997
***************
*** 0 ****
--- 1,56 ----
+ minus=-
+ 
+ # standard input
+ fd=0
+ 
+ exec 3<&$fd
+ 
+ read line <&3
+ echo from stdin: $line
+ 
+ # close fd 3
+ exec 3<&${minus}
+ 
+ # should give `bad fd', but exact error messages vary
+ # read line <&3
+ 
+ # standard output
+ fd=1
+ 
+ exec 4>&$fd
+ 
+ echo to stdout >&4
+ 
+ exec 4>&$minus
+ 
+ # should give `bad fd', but exact error messages vary
+ # echo to stdout >&4
+ 
+ unset fd
+ 
+ # these are ambiguous redirects
+ exec 3<&$fd
+ exec 4>&$fd
+ 
+ exec 3>&1 4>&2
+ 
+ exec >&/tmp/err-and-out
+ echo to stdout
+ echo to stderr >&2
+ 
+ exec 1>&3 2>&4
+ echo /tmp/err-and-out:
+ cat /tmp/err-and-out
+ 
+ rm /tmp/err-and-out
+ 
+ fd=/tmp/err-and-out
+ exec >&$fd
+ echo to stdout
+ echo to stderr >&2
+ 
+ exec 1>&3 2>&4
+ echo /tmp/err-and-out:
+ cat /tmp/err-and-out
+ 
+ rm /tmp/err-and-out
diff -Nrc2 bash-2.0/tests/rsh.right bash-2.01/tests/rsh.right
*** bash-2.0/tests/rsh.right	Wed Dec 31 19:00:00 1969
--- bash-2.01/tests/rsh.right	Thu Feb 27 11:38:39 1997
***************
*** 0 ****
--- 1,12 ----
+ ./rsh.tests: cd: restricted
+ ./rsh.tests: PATH: readonly variable
+ ./rsh.tests: SHELL: readonly variable
+ ./rsh.tests: /bin/sh: restricted: cannot specify `/' in command names
+ ./rsh.tests: .: ./source.sub3: restricted
+ ./rsh.tests: /tmp/restricted: restricted: cannot redirect output
+ ./rsh.tests: /tmp/restricted: restricted: cannot redirect output
+ ./rsh.tests: command: restricted: cannot use -p
+ ./rsh.tests: set: unknown option: +r
+ set: usage: set [--abefhkmnptuvxBCHP] [-o option] [arg ...]
+ ./rsh.tests: exec: restricted
+ ./rsh.tests: after exec
diff -Nrc2 bash-2.0/tests/rsh.tests bash-2.01/tests/rsh.tests
*** bash-2.0/tests/rsh.tests	Wed Dec 31 19:00:00 1969
--- bash-2.01/tests/rsh.tests	Fri Feb 28 12:46:43 1997
***************
*** 0 ****
--- 1,32 ----
+ # test restricted shell mode -- these should all be errors
+ #
+ # things not tested for:
+ #	adding builtins dynamically with enable -f
+ #	importing function definitions from environment
+ 
+ set -r
+ 
+ cd /
+ PATH=$PATH:/usr/local/bin
+ SHELL=/bin/sh
+ /bin/sh -c 'echo /bin/sh executed'
+ 
+ . ./source.sub3
+ 
+ rm -f /tmp/restricted
+ echo abc > /tmp/restricted
+ if [ -f /tmp/restricted ]; then
+ 	echo oops 1 -- output
+ fi
+ echo abc >> /tmp/restricted
+ if [ -f /tmp/restricted ]; then
+ 	echo oops 2 -- append
+ fi
+ 
+ command -p date
+ 
+ set +r
+ 
+ exec /bin/date
+ 
+ echo $0: after exec
diff -Nrc2 bash-2.0/tests/run-all bash-2.01/tests/run-all
*** bash-2.0/tests/run-all	Thu Nov  7 13:31:48 1996
--- bash-2.01/tests/run-all	Tue Mar 25 13:54:59 1997
***************
*** 1,15 ****
  #! /bin/sh
  
! PATH=.:$PATH	# just to get the right version of printenv
  export PATH
  
! # unset ENV only if it is set
! [ "${ENV+set}" = "set" ] && unset ENV
  
  : ${THIS_SH:=../bash}
  export THIS_SH
  
! echo Testing ${THIS_SH}
! echo Any output from any test indicates an anomaly worth investigating
  for x in run-*
  do
--- 1,19 ----
  #! /bin/sh
  
! PATH=.:$PATH	# just to get recho/zecho/printenv if not run via `make tests'
  export PATH
  
! # unset BASH_ENV only if it is set
! [ "${BASH_ENV+set}" = "set" ] && unset BASH_ENV
! # ditto for SHELLOPTS
! #[ "${SHELLOPTS+set}" = "set" ] && unset SHELLOPTS
  
  : ${THIS_SH:=../bash}
  export THIS_SH
  
! ${THIS_SH} ./version
! 
! echo Any output from any test, unless otherwise noted, indicates a possible anomaly
! 
  for x in run-*
  do
diff -Nrc2 bash-2.0/tests/run-builtins bash-2.01/tests/run-builtins
*** bash-2.0/tests/run-builtins	Wed Dec 31 19:00:00 1969
--- bash-2.01/tests/run-builtins	Mon Feb 24 15:01:30 1997
***************
*** 0 ****
--- 1,2 ----
+ ${THIS_SH} ./builtins.tests > /tmp/xx 2>&1
+ diff /tmp/xx builtins.right && rm -f /tmp/xx
diff -Nrc2 bash-2.0/tests/run-dirstack bash-2.01/tests/run-dirstack
*** bash-2.0/tests/run-dirstack	Wed Dec 31 19:00:00 1969
--- bash-2.01/tests/run-dirstack	Mon Feb 24 12:52:30 1997
***************
*** 0 ****
--- 1,2 ----
+ ${THIS_SH} ./dirstack.tests > /tmp/xx 2>&1
+ diff /tmp/xx dirstack.right && rm -f /tmp/xx
diff -Nrc2 bash-2.0/tests/run-errors bash-2.01/tests/run-errors
*** bash-2.0/tests/run-errors	Wed Dec 31 19:00:00 1969
--- bash-2.01/tests/run-errors	Wed Feb 26 17:39:45 1997
***************
*** 0 ****
--- 1,2 ----
+ ${THIS_SH} ./errors.tests > /tmp/xx 2>&1
+ diff /tmp/xx errors.right && rm -f /tmp/xx
diff -Nrc2 bash-2.0/tests/run-execscript bash-2.01/tests/run-execscript
*** bash-2.0/tests/run-execscript	Wed Dec 31 19:00:00 1969
--- bash-2.01/tests/run-execscript	Fri Mar  7 16:00:39 1997
***************
*** 0 ****
--- 1,7 ----
+ echo "warning: the text of a system error message may vary between systems and" >&2
+ echo "warning: produce diff output." >&2
+ echo "warning: if the text of the error messages concerning \`notthere' or" >&2
+ echo "warning: \`/tmp/bash-notthere' not being found or \`/' being a directory" >&2
+ echo "warning: produce diff output, please do not consider this a test failure" >&2
+ ${THIS_SH} ./execscript > /tmp/xx 2>&1
+ diff /tmp/xx execscript.right && rm -f /tmp/xx
diff -Nrc2 bash-2.0/tests/run-func bash-2.01/tests/run-func
*** bash-2.0/tests/run-func	Wed Dec 31 19:00:00 1969
--- bash-2.01/tests/run-func	Tue May 27 10:50:51 1997
***************
*** 0 ****
--- 1,5 ----
+ echo "warning: if you have exported functions defined in your environment," >&2
+ echo "warning: they may show up as diff output." >&2
+ echo "warning: if so, please do not consider this a test failure" >&2
+ ${THIS_SH} ./func.tests > /tmp/xx 2>&1
+ diff /tmp/xx func.right && rm -f /tmp/xx
diff -Nrc2 bash-2.0/tests/run-getopts bash-2.01/tests/run-getopts
*** bash-2.0/tests/run-getopts	Wed Dec 31 19:00:00 1969
--- bash-2.01/tests/run-getopts	Mon Feb 24 15:16:38 1997
***************
*** 0 ****
--- 1,2 ----
+ ${THIS_SH} ./getopts.tests > /tmp/xx 2>&1
+ diff /tmp/xx getopts.right && rm -f /tmp/xx
diff -Nrc2 bash-2.0/tests/run-histexpand bash-2.01/tests/run-histexpand
*** bash-2.0/tests/run-histexpand	Wed Dec 31 19:00:00 1969
--- bash-2.01/tests/run-histexpand	Thu Mar  6 16:08:44 1997
***************
*** 0 ****
--- 1,4 ----
+ echo "warning: all of these tests will fail if history has not been compiled" >&2
+ echo "warning: into the shell" >&2
+ ${THIS_SH} ./histexpand.tests > /tmp/xx 2>&1
+ diff /tmp/xx histexpand.right && rm -f /tmp/xx
diff -Nrc2 bash-2.0/tests/run-history bash-2.01/tests/run-history
*** bash-2.0/tests/run-history	Wed Dec 31 19:00:00 1969
--- bash-2.01/tests/run-history	Thu Mar  6 16:08:53 1997
***************
*** 0 ****
--- 1,4 ----
+ echo "warning: all of these tests will fail if history has not been compiled" >&2
+ echo "warning: into the shell" >&2
+ ${THIS_SH} ./history.tests > /tmp/xx 2>&1
+ diff /tmp/xx history.right && rm -f /tmp/xx
diff -Nrc2 bash-2.0/tests/run-jobs bash-2.01/tests/run-jobs
*** bash-2.0/tests/run-jobs	Wed Dec 31 19:00:00 1969
--- bash-2.01/tests/run-jobs	Thu Mar  6 16:21:19 1997
***************
*** 0 ****
--- 1,5 ----
+ echo "warning: some of these tests may fail if job control has not been compiled" >&2
+ echo "warning: into the shell" >&2
+ 
+ ${THIS_SH} ./jobs.tests > /tmp/xx 2>&1
+ diff /tmp/xx jobs.right && rm -f /tmp/xx
diff -Nrc2 bash-2.0/tests/run-minimal bash-2.01/tests/run-minimal
*** bash-2.0/tests/run-minimal	Wed Dec 31 19:00:00 1969
--- bash-2.01/tests/run-minimal	Mon Mar 24 15:51:32 1997
***************
*** 0 ****
--- 1,33 ----
+ #! /bin/sh
+ #
+ # run-minimal - a version of run-all for shells configured with
+ #		--enable-minimal-config
+ #
+ PATH=.:$PATH	# just to get the right version of printenv
+ export PATH
+ 
+ # unset BASH_ENV only if it is set
+ [ "${BASH_ENV+set}" = "set" ] && unset BASH_ENV
+ # ditto for SHELLOPTS
+ #[ "${SHELLOPTS+set}" = "set" ] && unset SHELLOPTS
+ 
+ : ${THIS_SH:=../bash}
+ export THIS_SH
+ 
+ ${THIS_SH} ./version.mini
+ 
+ echo Testing ${THIS_SH}
+ echo Any output from any test, unless otherwise noted, indicates a possible anomaly
+ for x in run-*
+ do
+ 	case $x in
+ 	$0)	;;
+ 	*.orig|*~) ;;
+ 	run-dollars|run-execscript|run-func|run-getopts|run-heredoc) echo $x ; sh $x ;;
+ 	run-ifs-tests|run-input-test|run-more-exp|run-nquote|run-posix2) echo $x ; sh $x ;;
+ 	run-precedence|run-quote|run-read|run-rhs-exp|run-strip|run-tilde) echo $x ; sh $x ;;
+ 	*)	;;
+ 	esac
+ done
+ 
+ exit 0
diff -Nrc2 bash-2.0/tests/run-minus-e bash-2.01/tests/run-minus-e
*** bash-2.0/tests/run-minus-e	Fri Feb  2 16:11:10 1996
--- bash-2.01/tests/run-minus-e	Wed Dec 31 19:00:00 1969
***************
*** 1,2 ****
- ${THIS_SH} ./minus-e > /tmp/xx
- diff /tmp/xx minus-e.right && rm -f /tmp/xx
--- 0 ----
diff -Nrc2 bash-2.0/tests/run-redir bash-2.01/tests/run-redir
*** bash-2.0/tests/run-redir	Wed Dec 31 19:00:00 1969
--- bash-2.01/tests/run-redir	Thu Mar  6 16:17:00 1997
***************
*** 0 ****
--- 1,6 ----
+ echo "warning: the text of a system error message may vary between systems and" >&2
+ echo "warning: produce diff output." >&2
+ echo "warning: if the text of an error message concerning \`redir1.*' not being" >&2
+ echo "warning: found produces diff output, please do not consider it a test failure" >&2
+ ${THIS_SH} ./redir.tests > /tmp/xx 2>&1
+ diff /tmp/xx redir.right && rm -f /tmp/xx
diff -Nrc2 bash-2.0/tests/run-rsh bash-2.01/tests/run-rsh
*** bash-2.0/tests/run-rsh	Wed Dec 31 19:00:00 1969
--- bash-2.01/tests/run-rsh	Fri Feb 21 13:26:12 1997
***************
*** 0 ****
--- 1,2 ----
+ ${THIS_SH} ./rsh.tests > /tmp/xx 2>&1
+ diff /tmp/xx rsh.right && rm -f /tmp/xx
diff -Nrc2 bash-2.0/tests/run-test bash-2.01/tests/run-test
*** bash-2.0/tests/run-test	Fri Feb  2 16:12:10 1996
--- bash-2.01/tests/run-test	Fri Feb 21 12:01:35 1997
***************
*** 1,2 ****
! ${THIS_SH} ./test-tests 2>&1 > /tmp/xx
  diff /tmp/xx test.right && rm -f /tmp/xx
--- 1,2 ----
! ${THIS_SH} ./test-tests >/tmp/xx 2>&1
  diff /tmp/xx test.right && rm -f /tmp/xx
diff -Nrc2 bash-2.0/tests/run-trap bash-2.01/tests/run-trap
*** bash-2.0/tests/run-trap	Wed Dec 31 19:00:00 1969
--- bash-2.01/tests/run-trap	Fri Feb 21 14:17:31 1997
***************
*** 0 ****
--- 1,2 ----
+ ${THIS_SH} ./trap.tests > /tmp/xx 2>&1
+ diff /tmp/xx trap.right && rm -f /tmp/xx
diff -Nrc2 bash-2.0/tests/run-type bash-2.01/tests/run-type
*** bash-2.0/tests/run-type	Wed Dec 31 19:00:00 1969
--- bash-2.01/tests/run-type	Mon Feb 24 14:26:51 1997
***************
*** 0 ****
--- 1,2 ----
+ ${THIS_SH} ./type.tests > /tmp/xx 2>&1
+ diff /tmp/xx type.right && rm -f /tmp/xx
diff -Nrc2 bash-2.0/tests/set-e-test bash-2.01/tests/set-e-test
*** bash-2.0/tests/set-e-test	Tue Dec  6 16:10:09 1994
--- bash-2.01/tests/set-e-test	Fri Feb 21 15:57:04 1997
***************
*** 18,19 ****
--- 18,69 ----
  set -e
  echo $(false; echo ok)
+ 
+ if set +e
+ then
+ 	false
+ fi
+ echo hi
+ 
+ set -e
+ 
+ # a failing command in the compound list following a while, until, or
+ # if should not cause the shell to exit
+ 
+ while false; do
+ 	echo hi
+ done
+ echo while succeeded
+ 
+ x=1
+ until (( x == 4 )); do
+ 	x=4
+ done
+ echo until succeeded: $x
+ 
+ if false; then
+ 	echo oops
+ fi
+ echo if succeeded
+ 
+ # failing commands that are part of an AND or OR list should not
+ # cause the shell to exit
+ false && echo AND list failed
+ echo AND list succeeded
+ 
+ false || echo OR list succeeded
+ 
+ ! false
+ echo ! succeeded
+ 
+ # make sure eval preserves the state of the -e flag and `!' reserved word
+ set -e
+ if eval false; then
+ 	echo oops
+ fi
+ echo eval succeeded
+ 
+ ! eval false
+ echo ! eval succeeded -- 1
+ 
+ ! eval '(exit 5)'
+ echo ! eval succeeded -- 2
diff -Nrc2 bash-2.0/tests/set-e.right bash-2.01/tests/set-e.right
*** bash-2.0/tests/set-e.right	Tue Dec  6 16:09:41 1994
--- bash-2.01/tests/set-e.right	Fri Feb 21 15:58:36 1997
***************
*** 15,16 ****
--- 15,26 ----
  9
  ok
+ hi
+ while succeeded
+ until succeeded: 4
+ if succeeded
+ AND list succeeded
+ OR list succeeded
+ ! succeeded
+ eval succeeded
+ ! eval succeeded -- 1
+ ! eval succeeded -- 2
diff -Nrc2 bash-2.0/tests/source.sub1 bash-2.01/tests/source.sub1
*** bash-2.0/tests/source.sub1	Wed Dec 31 19:00:00 1969
--- bash-2.01/tests/source.sub1	Mon Feb 24 14:48:40 1997
***************
*** 0 ****
--- 1 ----
+ echo $AVAR
diff -Nrc2 bash-2.0/tests/source.sub2 bash-2.01/tests/source.sub2
*** bash-2.0/tests/source.sub2	Wed Dec 31 19:00:00 1969
--- bash-2.01/tests/source.sub2	Mon Feb 24 14:51:02 1997
***************
*** 0 ****
--- 1,5 ----
+ echo in source.sub2, calling return
+ 
+ return 5
+ 
+ echo oops -- return in source.sub2 failed
diff -Nrc2 bash-2.0/tests/source.sub3 bash-2.01/tests/source.sub3
*** bash-2.0/tests/source.sub3	Wed Dec 31 19:00:00 1969
--- bash-2.01/tests/source.sub3	Thu Feb 27 11:33:00 1997
***************
*** 0 ****
--- 1 ----
+ echo "$@"
diff -Nrc2 bash-2.0/tests/source.sub4 bash-2.01/tests/source.sub4
*** bash-2.0/tests/source.sub4	Wed Dec 31 19:00:00 1969
--- bash-2.01/tests/source.sub4	Fri Feb 28 12:33:26 1997
***************
*** 0 ****
--- 1 ----
+ set -- m n o p
diff -Nrc2 bash-2.0/tests/test-tests bash-2.01/tests/test-tests
*** bash-2.0/tests/test-tests	Wed Jun 19 11:36:00 1996
--- bash-2.01/tests/test-tests	Mon Mar  3 15:12:36 1997
***************
*** 1,2 ****
--- 1,12 ----
+ if (( $UID == 0 )); then
+ 	echo "test-tests: the test suite should not be run as root" >&2
+ fi
+ 
+ b()
+ {
+ 	[ "$@" ]
+ 	echo $?
+ }
+ 
  t()
  {
***************
*** 24,27 ****
--- 34,41 ----
  echo 't -d /etc'
  t -d /etc
+ echo 't -d ""'
+ t -d ""
+ echo 'b -d ""'
+ b -d ""
  
  echo 't -e noexist'
***************
*** 41,44 ****
--- 55,59 ----
  
  touch /tmp/test.setgid
+ chgrp ${GROUPS[0]} /tmp/test.setgid
  chmod ug+x /tmp/test.setgid
  chmod g+s /tmp/test.setgid
***************
*** 61,69 ****
  t -r noexist
  
! touch /tmp/test.noread
! chmod a-r /tmp/test.noread
! echo 't -r /tmp/test.noread'
! t -r /tmp/test.noread
! rm -f /tmp/test.noread
  
  echo 't -r run-all'
--- 76,89 ----
  t -r noexist
  
! if (( $UID != 0 )); then
! 	touch /tmp/test.noread
! 	chmod a-r /tmp/test.noread
! 	echo 't -r /tmp/test.noread'
! 	t -r /tmp/test.noread
! 	rm -f /tmp/test.noread
! else
! 	echo 't -r /tmp/test.noread'
! 	echo 1
! fi
  
  echo 't -r run-all'
***************
*** 98,106 ****
  t -w noexist
  
! touch /tmp/test.nowrite
! chmod a-w /tmp/test.nowrite
! echo 't -w /tmp/test.nowrite'
! t -w /tmp/test.nowrite
! rm -f /tmp/test.nowrite
  
  echo 't -w /dev/null'
--- 118,131 ----
  t -w noexist
  
! if (( $UID != 0 )); then
! 	touch /tmp/test.nowrite
! 	chmod a-w /tmp/test.nowrite
! 	echo 't -w /tmp/test.nowrite'
! 	t -w /tmp/test.nowrite
! 	rm -f /tmp/test.nowrite
! else
! 	echo 't -w /tmp/test.nowrite'
! 	echo 1
! fi
  
  echo 't -w /dev/null'
***************
*** 164,167 ****
--- 189,194 ----
  echo 't 34 -eq 222'
  t 34 -eq 222
+ echo 't -32 -eq 32'
+ t -32 -eq 32
  
  echo 't 200 -ne 200'
***************
*** 222,227 ****
--- 249,257 ----
  echo 't -w /dev/fd/2'
  t -w /dev/fd/2
+ 
  echo 't'
  t
+ echo 'b'
+ b
  
  echo 't 12 -eq 34'
***************
*** 278,279 ****
--- 308,392 ----
  echo 't ( "" )'
  t \( "" \)
+ 
+ z=42
+ 
+ echo 't ! -z "$z"'
+ t ! -z "$z"
+ 
+ echo 't ! -n "$z"'
+ t ! -n "$z"
+ 
+ zero=
+ echo 't "$zero"'
+ t "$zero"
+ echo 't ! "$zero"'
+ t ! "$zero"
+ echo 'b "$zero"'
+ b "$zero"
+ echo 'b ! "$zero"'
+ b ! "$zero"
+ 
+ touch /tmp/test.group
+ chgrp ${GROUPS[0]} /tmp/test.group
+ echo 't -G /tmp/test.group'
+ t -G /tmp/test.group
+ rm /tmp/test.group
+ 
+ case "${THIS_SH}" in
+ /*)	SHNAME=${THIS_SH} ;;
+ *)	SHNAME=${PWD}/${THIS_SH} ;;
+ esac
+ 
+ if ln -s ${SHNAME} /tmp/test.symlink 2>/dev/null; then
+ 	chgrp ${GROUPS[0]} /tmp/test.symlink
+ 	echo 't -h /tmp/test.symlink'
+ 	t -h /tmp/test.symlink
+ 	# some systems don't let you remove this
+ 	rm -f /tmp/test.symlink 2>/dev/null
+ else
+ 	echo 't -h /tmp/test.symlink'
+ 	echo 0
+ fi
+ 
+ # arithmetic constant errors
+ echo "t 4+3 -eq 7"
+ t 4+3 -eq 7
+ echo "b 4-5 -eq 7"
+ b 4+3 -eq 7
+ 
+ echo "t 9 -eq 4+5"
+ t 9 -eq 4+5
+ echo "b 9 -eq 4+5"
+ b 9 -eq 4+5
+ 
+ A=7
+ echo "t A -eq 7"
+ t A -eq 7
+ echo "b A -eq 7"
+ b A -eq 7
+ 
+ B=9
+ echo "t 9 -eq B"
+ t 9 -eq B
+ echo "b 9 -eq B"
+ b 9 -eq B
+ 
+ # badly formed expressions
+ echo 't ( 1 = 2'
+ t \( 1 = 2
+ echo 'b ( 1 = 2'
+ b \( 1 = 2
+ 
+ # more errors
+ t a b
+ t a b c
+ t -A v
+ # too many arguments -- argument expected is also reasonable
+ t 4 -eq 4 -a 2 -ne 5 -a 4 -ne
+ # too many arguments
+ t 4 -eq 4 -a 3 4
+ 
+ [
+ echo $?
+ 
+ t \( \)
diff -Nrc2 bash-2.0/tests/test.right bash-2.01/tests/test.right
*** bash-2.0/tests/test.right	Wed Jun 19 11:37:25 1996
--- bash-2.01/tests/test.right	Tue Feb 25 13:22:07 1997
***************
*** 15,18 ****
--- 15,22 ----
  t -d /etc
  0
+ t -d ""
+ 1
+ b -d ""
+ 1
  t -e noexist
  1
***************
*** 103,106 ****
--- 107,112 ----
  t 34 -eq 222
  1
+ t -32 -eq 32
+ 1
  t 200 -ne 200
  1
***************
*** 147,150 ****
--- 153,158 ----
  t
  1
+ b
+ 1
  t 12 -eq 34
  1
***************
*** 192,194 ****
--- 200,262 ----
  0
  t ( "" )
+ 1
+ t ! -z "$z"
+ 0
+ t ! -n "$z"
+ 1
+ t "$zero"
+ 1
+ t ! "$zero"
+ 0
+ b "$zero"
+ 1
+ b ! "$zero"
+ 0
+ t -G /tmp/test.group
+ 0
+ t -h /tmp/test.symlink
+ 0
+ t 4+3 -eq 7
+ ./test-tests: test: 4+3: integer expression expected
+ 1
+ b 4-5 -eq 7
+ ./test-tests: [: 4+3: integer expression expected
+ 1
+ t 9 -eq 4+5
+ ./test-tests: test: 4+5: integer expression expected
+ 1
+ b 9 -eq 4+5
+ ./test-tests: [: 4+5: integer expression expected
+ 1
+ t A -eq 7
+ ./test-tests: test: A: integer expression expected
+ 1
+ b A -eq 7
+ ./test-tests: [: A: integer expression expected
+ 1
+ t 9 -eq B
+ ./test-tests: test: B: integer expression expected
+ 1
+ b 9 -eq B
+ ./test-tests: [: B: integer expression expected
+ 1
+ t ( 1 = 2
+ ./test-tests: test: `)' expected
+ 1
+ b ( 1 = 2
+ ./test-tests: [: `)' expected, found ]
+ 1
+ ./test-tests: test: a: unary operator expected
+ 1
+ ./test-tests: test: b: binary operator expected
+ 1
+ ./test-tests: test: -A: unary operator expected
+ 1
+ ./test-tests: test: too many arguments
+ 1
+ ./test-tests: test: too many arguments
+ 1
+ ./test-tests: [: missing `]'
+ 1
+ ./test-tests: test: (: unary operator expected
  1
diff -Nrc2 bash-2.0/tests/tilde-tests bash-2.01/tests/tilde-tests
*** bash-2.0/tests/tilde-tests	Mon Jun 17 16:52:46 1996
--- bash-2.01/tests/tilde-tests	Mon Feb 24 13:10:36 1997
***************
*** 1,2 ****
--- 1,8 ----
+ # this is needed because posix mode restricts tilde expansion to assignment
+ # statements preceding a command, instead of the default of expanding all
+ # assignment statements on the line (e.g., after `export').  Without this,
+ # the next-to-last test fails
+ set +o posix
+ 
  HOME=/usr/xyz
  SHELL=~/bash
***************
*** 34,39 ****
--- 40,66 ----
  export PPATH=$XPATH:~/bin
  echo "$PPATH"
+ declare -x PPATH=$XPATH:~/bin
+ echo "$PPATH"
  
  # no tilde expansion
  export PPATH="$XPATH:~/bin"
  echo "$PPATH"
+ declare -x PPATH="$XPATH:~/bin"
+ echo "$PPATH"
+ 
+ # more tests of tilde expansion when executing case commands
+ case ~ in
+ $HOME)	echo ok 1;;
+ *) echo bad 1 ;;
+ esac
+ 
+ case ~ in
+ ~)	echo ok 2 ;;
+ \~)	echo bad 2a ;;
+ *)	echo bad 2b ;;
+ esac
+ 
+ case $unset in
+ "")	echo ok 3 ;;
+ *)	echo bad 3 ;;
+ esac
diff -Nrc2 bash-2.0/tests/tilde.right bash-2.01/tests/tilde.right
*** bash-2.0/tests/tilde.right	Mon Jun 17 16:54:28 1996
--- bash-2.01/tests/tilde.right	Mon Feb 24 13:10:51 1997
***************
*** 17,19 ****
--- 17,24 ----
  /bin:/usr/bin:.:~/bin
  /bin:/usr/bin:.:/usr/xyz/bin
+ /bin:/usr/bin:.:/usr/xyz/bin
  /bin:/usr/bin:.:~/bin
+ /bin:/usr/bin:.:~/bin
+ ok 1
+ ok 2
+ ok 3
diff -Nrc2 bash-2.0/tests/trap.right bash-2.01/tests/trap.right
*** bash-2.0/tests/trap.right	Wed Dec 31 19:00:00 1969
--- bash-2.01/tests/trap.right	Tue Feb 25 15:36:16 1997
***************
*** 0 ****
--- 1,51 ----
+ subshell exit
+ trap -- 'echo exiting' EXIT
+ trap -- 'echo aborting' SIGHUP
+ trap -- 'echo aborting' SIGINT
+ trap -- 'echo aborting' SIGQUIT
+ trap -- 'echo aborting' SIGABRT
+ trap -- 'echo aborting' SIGTERM
+ debug line
+ [20] debug
+ trap -- 'echo exiting' EXIT
+ trap -- 'echo aborting' SIGHUP
+ trap -- 'echo aborting' SIGINT
+ trap -- 'echo aborting' SIGQUIT
+ trap -- 'echo aborting' SIGABRT
+ trap -- 'echo aborting' SIGTERM
+ trap -- 'echo [$LINENO] debug' DEBUG
+ [22] debug
+ funcdebug line
+ [2] funcdebug
+ [24] debug
+ trap -- 'echo exiting' EXIT
+ trap -- 'echo aborting' SIGHUP
+ trap -- 'echo aborting' SIGINT
+ trap -- 'echo aborting' SIGQUIT
+ trap -- 'echo aborting' SIGABRT
+ trap -- 'echo aborting' SIGTERM
+ trap -- 'echo [$LINENO] debug' DEBUG
+ [26] debug
+ trap -- 'echo exiting' EXIT
+ trap -- 'echo aborting' SIGHUP
+ trap -- 'echo aborting' SIGINT
+ trap -- 'echo aborting' SIGQUIT
+ trap -- 'echo aborting' SIGABRT
+ trap -- 'echo aborting' SIGTERM
+ trap -- '' DEBUG
+ trap -- 'echo exiting' EXIT
+ trap -- 'echo aborting' SIGHUP
+ trap -- 'echo aborting' SIGINT
+ trap -- 'echo aborting' SIGQUIT
+ trap -- 'echo aborting' SIGABRT
+ trap -- 'echo aborting' SIGTERM
+ trap -- 'echo exiting' EXIT
+ trap -- '' SIGINT
+ trap -- 'echo aborting' SIGQUIT
+ trap -- 'echo aborting' SIGABRT
+ trap -- 'echo aborting' SIGTERM
+ caught a child death
+ caught a child death
+ caught a child death
+ trap -- 'echo caught a child death' SIGCHLD
+ exiting
diff -Nrc2 bash-2.0/tests/trap.sub1 bash-2.01/tests/trap.sub1
*** bash-2.0/tests/trap.sub1	Wed Dec 31 19:00:00 1969
--- bash-2.01/tests/trap.sub1	Tue Feb 25 14:28:46 1997
***************
*** 0 ****
--- 1,4 ----
+ # signals ignored at shell startup cannot be trapped or reset
+ trap 'echo USR2' USR2
+ 
+ trap -p USR2
diff -Nrc2 bash-2.0/tests/trap.tests bash-2.01/tests/trap.tests
*** bash-2.0/tests/trap.tests	Wed Dec 31 19:00:00 1969
--- bash-2.01/tests/trap.tests	Thu Mar  6 11:17:06 1997
***************
*** 0 ****
--- 1,58 ----
+ # test the trap code
+ 
+ trap 'echo exiting' 0
+ trap 'echo aborting' 1 2 3 6 15
+ 
+ # make sure a user-specified subshell runs the exit trap, but does not
+ # inherit the exit trap from a parent shell
+ ( trap 'echo subshell exit' 0; exit 0 )
+ ( exit 0 )
+ 
+ trap
+ 
+ func()
+ {
+ 	trap 'echo [$LINENO] funcdebug' DEBUG
+ 	echo funcdebug line
+ }
+ 
+ trap 'echo [$LINENO] debug' DEBUG
+ echo debug line
+ 
+ trap
+ 
+ func
+ 
+ trap
+ 
+ trap '' DEBUG
+ 
+ trap
+ 
+ trap - debug
+ 
+ trap
+ 
+ trap - HUP
+ trap hup
+ trap '' INT
+ trap '' int
+ 
+ trap
+ 
+ # hmmm...should this set the handling to SIG_IGN for children, too?
+ trap '' USR2
+ ./trap.sub1
+ 
+ #
+ # show that setting a trap on SIGCHLD is not disastrous.
+ #
+ set -o monitor
+ 
+ trap 'echo caught a child death' SIGCHLD
+ 
+ sleep 7 & sleep 6 & sleep 5 &
+ 
+ wait
+ 
+ trap -p SIGCHLD
diff -Nrc2 bash-2.0/tests/type.right bash-2.01/tests/type.right
*** bash-2.0/tests/type.right	Wed Dec 31 19:00:00 1969
--- bash-2.01/tests/type.right	Mon Mar  3 13:09:54 1997
***************
*** 0 ****
--- 1,41 ----
+ ./type.tests: type: unknown option: f
+ type: usage: type [-apt] name [name ...]
+ ./type.tests: type: notthere: not found
+ ./type.tests: command: notthere: not found
+ function
+ keyword
+ alias
+ builtin
+ file
+ file
+ func is a function
+ func () 
+ { 
+     echo this is func
+ }
+ while is a shell keyword
+ while is a shell keyword
+ m is aliased to `more'
+ builtin is a shell builtin
+ /bin/sh is /bin/sh
+ func
+ func is a function
+ func () 
+ { 
+     echo this is func
+ }
+ while
+ while is a shell keyword
+ alias m='more'
+ alias m='more'
+ alias m='more'
+ m is aliased to `more'
+ builtin
+ builtin is a shell builtin
+ /bin/sh
+ /bin/sh is /bin/sh
+ ./type.tests: type: func: not found
+ ./type.tests: type: m: not found
+ /bin/sh
+ /tmp/bash
+ bash is hashed (/tmp/bash)
diff -Nrc2 bash-2.0/tests/type.tests bash-2.01/tests/type.tests
*** bash-2.0/tests/type.tests	Wed Dec 31 19:00:00 1969
--- bash-2.01/tests/type.tests	Mon Mar  3 13:09:32 1997
***************
*** 0 ****
--- 1,60 ----
+ set +o posix
+ 
+ hash -r
+ unalias -a
+ 
+ # this should echo nothing
+ type
+ # this should be a usage error
+ type -f ${THIS_SH}
+ 
+ # these should behave identically
+ type notthere
+ command -v notthere
+ 
+ alias m=more
+ 
+ unset -f func 2>/dev/null
+ func() { echo this is func; }
+ 
+ type -t func
+ type -t while
+ type -t m
+ type -t builtin
+ type -t /bin/sh
+ type -t ${THIS_SH}
+ 
+ type func
+ # the following two should produce identical output
+ type while
+ type -a while
+ type m
+ type builtin
+ type /bin/sh
+ 
+ command -v func
+ command -V func
+ command -v while
+ command -V while
+ # the following three lines should produce the same output
+ command -v m
+ alias -p
+ alias m
+ command -V m
+ command -v builtin
+ command -V builtin
+ command -v /bin/sh
+ command -V /bin/sh
+ 
+ unset -f func
+ type func
+ unalias m
+ type m
+ 
+ hash -p /bin/sh sh
+ type -p sh
+ 
+ SHBASE=${THIS_SH##*/}
+ hash -p /tmp/$SHBASE $SHBASE
+ type -p $SHBASE
+ type $SHBASE
diff -Nrc2 bash-2.0/tests/varenv.right bash-2.01/tests/varenv.right
*** bash-2.0/tests/varenv.right	Tue Dec 13 13:43:42 1994
--- bash-2.01/tests/varenv.right	Fri Apr 11 13:55:04 1997
***************
*** 14,15 ****
--- 14,34 ----
  1 1
  unset
+ toronto airport
+ AVAR
+ song by rush
+ BVAR
+ toronto airport
+ AVAR
+ AVAR
+ 42
+ /bin:/usr/bin:/usr/local/bin:.
+ avar=([0]="/bin:/usr/bin:/usr/local/bin:.")
+ z=yy
+ 42
+ declare -i ivar="10"
+ unset
+ declare -x ivar="42"
+ hB
+ braceexpand:hashall
+ hPB
+ braceexpand:hashall:physical
diff -Nrc2 bash-2.0/tests/varenv.sh bash-2.01/tests/varenv.sh
*** bash-2.0/tests/varenv.sh	Tue Dec 13 13:50:18 1994
--- bash-2.01/tests/varenv.sh	Fri Mar  7 15:41:04 1997
***************
*** 104,105 ****
--- 104,169 ----
  export a
  /bin/true 2>/dev/null
+ 
+ func()
+ {
+ 	local YYZ
+ 
+ 	YYZ="song by rush"
+ 	echo $YYZ
+ 	echo $A
+ }
+ 
+ YYZ="toronto airport"
+ A="AVAR"
+ echo $YYZ
+ echo $A
+ A=BVAR func
+ echo $YYZ
+ echo $A
+ 
+ export A
+ # Make sure expansion doesn't use assignment statements preceding a builtin
+ A=ZVAR echo $A
+ 
+ PATH=/bin:/usr/bin:/usr/local/bin:.
+ func2()
+ {
+ 	local z=yy
+ 	local -a avar=( ${PATH//: } )
+ 	echo ${avar[@]}
+ 	local
+ }
+ 
+ avar=42
+ echo $avar
+ func2
+ echo $avar
+ 
+ # try to set an attribute for an unset variable; make sure it persists
+ # when the variable is assigned a value
+ declare -i ivar
+ 
+ ivar=10
+ 
+ declare -p ivar
+ unset ivar
+ 
+ # export an unset variable, make sure it is not suddenly set, but make
+ # sure the export attribute persists when the variable is assigned a
+ # value
+ export ivar
+ echo ${ivar-unset}
+ 
+ ivar=42
+ declare -p ivar
+ 
+ # make sure that shopt -o is reflected in $SHELLOPTS
+ # first, get rid of things that might be set automatically via shell
+ # variables
+ set +o posix
+ set +o ignoreeof
+ echo $-
+ echo ${SHELLOPTS}
+ shopt -so physical
+ echo $-
+ echo ${SHELLOPTS}
diff -Nrc2 bash-2.0/tests/version bash-2.01/tests/version
*** bash-2.0/tests/version	Wed Dec 31 19:00:00 1969
--- bash-2.01/tests/version	Tue Mar  4 13:44:16 1997
***************
*** 0 ****
--- 1,8 ----
+ echo Testing ${THIS_SH}
+ 
+ echo version: $BASH_VERSION
+ echo versinfo: ${BASH_VERSINFO[@]}
+ 
+ echo HOSTTYPE = $HOSTTYPE
+ echo OSTYPE = $OSTYPE
+ echo MACHTYPE = $MACHTYPE
diff -Nrc2 bash-2.0/tests/version.mini bash-2.01/tests/version.mini
*** bash-2.0/tests/version.mini	Wed Dec 31 19:00:00 1969
--- bash-2.01/tests/version.mini	Wed Mar  5 12:35:51 1997
***************
*** 0 ****
--- 1,8 ----
+ echo Testing ${THIS_SH}
+ 
+ echo version: $BASH_VERSION
+ #echo versinfo: ${BASH_VERSINFO[@]}
+ 
+ echo HOSTTYPE = $HOSTTYPE
+ echo OSTYPE = $OSTYPE
+ echo MACHTYPE = $MACHTYPE
diff -Nrc2 bash-2.0/trap.c bash-2.01/trap.c
*** bash-2.0/trap.c	Fri Dec 20 12:39:15 1996
--- bash-2.01/trap.c	Wed May 14 13:08:03 1997
***************
*** 27,35 ****
  #include "trap.h"
  
! #if defined (HAVE_STRING_H)
! #  include <string.h>
! #else /* !HAVE_STRING_H */
! #  include <strings.h>
! #endif /* !HAVE_STRING_H */
  
  #if defined (HAVE_UNISTD_H)
--- 27,31 ----
  #include "trap.h"
  
! #include "bashansi.h"
  
  #if defined (HAVE_UNISTD_H)
***************
*** 62,65 ****
--- 58,62 ----
  extern int interrupt_immediately;
  extern int last_command_exit_value;
+ extern int line_number;
  
  /* The list of things to do originally, before we started trapping. */
***************
*** 82,85 ****
--- 79,87 ----
  int running_trap;
  
+ /* The value of line_number when the trap started executing, since
+    parse_and_execute resets it to 1 and the trap command might want
+    it. */
+ int trap_line_number;
+ 
  /* A value which can never be the target of a trap handler. */
  #define IMPOSSIBLE_TRAP_HANDLER (SigHandler *)initialize_traps
***************
*** 201,205 ****
  	    }
  	  else
! 	    parse_and_execute (savestring (trap_list[sig]), "trap", 0);
  
  	  pending_traps[sig] = 0;
--- 203,207 ----
  	    }
  	  else
! 	    parse_and_execute (savestring (trap_list[sig]), "trap", SEVAL_NONINT|SEVAL_NOHIST);
  
  	  pending_traps[sig] = 0;
***************
*** 308,311 ****
--- 310,315 ----
      {
        change_signal (sig, savestring (string));
+       if (sig == EXIT_TRAP && interactive == 0)
+ 	initialize_terminating_signals ();
        return;
      }
***************
*** 367,371 ****
       char *value;
  {
!   free_trap_command (sig);
    trap_list[sig] = value;
  
--- 371,376 ----
       char *value;
  {
!   if ((sigmodes[sig] & SIG_INPROGRESS) == 0)
!     free_trap_command (sig);
    trap_list[sig] = value;
  
***************
*** 410,416 ****
    if (sig == DEBUG_TRAP || sig == EXIT_TRAP)
      {
!       free_trap_command (sig);
        trap_list[sig] = (char *)NULL;
        sigmodes[sig] &= ~SIG_TRAPPED;
        return;
      }
--- 415,424 ----
    if (sig == DEBUG_TRAP || sig == EXIT_TRAP)
      {
!       if ((sig != DEBUG_TRAP) || (sigmodes[sig] & SIG_INPROGRESS) == 0)
! 	free_trap_command (sig);
        trap_list[sig] = (char *)NULL;
        sigmodes[sig] &= ~SIG_TRAPPED;
+       if (sigmodes[sig] & SIG_INPROGRESS)
+ 	sigmodes[sig] |= SIG_CHANGED;
        return;
      }
***************
*** 492,496 ****
  
        if (code == 0)
! 	parse_and_execute (trap_command, "exit trap", 0);
        else if (code == EXITPROG)
          return (last_command_exit_value);
--- 500,504 ----
  
        if (code == 0)
! 	parse_and_execute (trap_command, "exit trap", SEVAL_NONINT|SEVAL_NOHIST);
        else if (code == EXITPROG)
          return (last_command_exit_value);
***************
*** 517,521 ****
  {
    char *trap_command, *old_trap;
!   int old_exit_value;
  
    /* Run the trap only if SIG is trapped and not ignored, and we are not
--- 525,529 ----
  {
    char *trap_command, *old_trap;
!   int old_exit_value, old_line_number;
  
    /* Run the trap only if SIG is trapped and not ignored, and we are not
***************
*** 532,536 ****
        running_trap = sig + 1;
        old_exit_value = last_command_exit_value;
!       parse_and_execute (trap_command, tag, 0);
        last_command_exit_value = old_exit_value;
        running_trap = 0;
--- 540,547 ----
        running_trap = sig + 1;
        old_exit_value = last_command_exit_value;
!       /* Need to copy the value of line_number because parse_and_execute
! 	 resets it to 1, and the trap command might want it. */
!       trap_line_number = line_number;
!       parse_and_execute (trap_command, tag, SEVAL_NONINT|SEVAL_NOHIST);
        last_command_exit_value = old_exit_value;
        running_trap = 0;
diff -Nrc2 bash-2.0/trap.h bash-2.01/trap.h
*** bash-2.0/trap.h	Fri Apr 12 15:56:46 1996
--- bash-2.01/trap.h	Fri Feb 21 11:32:28 1997
***************
*** 25,29 ****
  
  #if !defined (SIG_DFL)
! #include <sys/types.h>
  #include <signal.h>
  #endif /* SIG_DFL */
--- 25,29 ----
  
  #if !defined (SIG_DFL)
! #include "bashtypes.h"
  #include <signal.h>
  #endif /* SIG_DFL */
diff -Nrc2 bash-2.0/unionwait.h bash-2.01/unionwait.h
*** bash-2.0/unionwait.h	Wed Dec 31 19:00:00 1969
--- bash-2.01/unionwait.h	Tue Feb 18 17:28:55 1997
***************
*** 0 ****
--- 1,98 ----
+ /* unionwait.h -- definitions for using a `union wait' on systems without
+    one. */
+ 
+ /* Copyright (C) 1996 Free Software Foundation, Inc.
+ 
+    This file is part of GNU Bash, the Bourne Again SHell.
+ 
+    Bash is free software; you can redistribute it and/or modify it under
+    the terms of the GNU General Public License as published by the Free
+    Software Foundation; either version 2, or (at your option) any later
+    version.
+ 
+    Bash is distributed in the hope that it will be useful, but WITHOUT ANY
+    WARRANTY; without even the implied warranty of MERCHANTABILITY or
+    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+    for more details.
+ 
+    You should have received a copy of the GNU General Public License along
+    with Bash; see the file COPYING.  If not, write to the Free Software
+    Foundation, 675 Mass Ave, Cambridge, MA 02139, USA. */
+ 
+ #ifndef _UNIONWAIT_H
+ #define _UNIONWAIT_H
+ 
+ #if !defined (WORDS_BIGENDIAN)
+ union wait
+   {
+     int	w_status;		/* used in syscall */
+ 
+     /* Terminated process status. */
+     struct
+       {
+ 	unsigned short
+ 	  w_Termsig  : 7,	/* termination signal */
+ 	  w_Coredump : 1,	/* core dump indicator */
+ 	  w_Retcode  : 8,	/* exit code if w_termsig==0 */
+ 	  w_Fill1    : 16;	/* high 16 bits unused */
+       } w_T;
+ 
+     /* Stopped process status.  Returned
+        only for traced children unless requested
+        with the WUNTRACED option bit. */
+     struct
+       {
+ 	unsigned short
+ 	  w_Stopval : 8,	/* == W_STOPPED if stopped */
+ 	  w_Stopsig : 8,	/* actually zero on XENIX */
+ 	  w_Fill2   : 16;	/* high 16 bits unused */
+       } w_S;
+   };
+ 
+ #else  /* WORDS_BIGENDIAN */
+ 
+ /* This is for big-endian machines like the IBM RT, HP 9000, or Sun-3 */
+ 
+ union wait
+   {
+     int	w_status;		/* used in syscall */
+ 
+     /* Terminated process status. */
+     struct
+       {
+ 	unsigned short w_Fill1    : 16;	/* high 16 bits unused */
+ 	unsigned       w_Retcode  : 8;	/* exit code if w_termsig==0 */
+ 	unsigned       w_Coredump : 1;	/* core dump indicator */
+ 	unsigned       w_Termsig  : 7;	/* termination signal */
+       } w_T;
+ 
+     /* Stopped process status.  Returned
+        only for traced children unless requested
+        with the WUNTRACED option bit. */
+     struct
+       {
+ 	unsigned short w_Fill2   : 16;	/* high 16 bits unused */
+ 	unsigned       w_Stopsig : 8;	/* signal that stopped us */
+ 	unsigned       w_Stopval : 8;	/* == W_STOPPED if stopped */
+       } w_S;
+   };
+ 
+ #endif /* WORDS_BIGENDIAN */
+ 
+ #define w_termsig  w_T.w_Termsig
+ #define w_coredump w_T.w_Coredump
+ #define w_retcode  w_T.w_Retcode
+ #define w_stopval  w_S.w_Stopval
+ #define w_stopsig  w_S.w_Stopsig
+ 
+ #define WSTOPPED       0177
+ #define WIFSTOPPED(x)  ((x).w_stopval == WSTOPPED)
+ #define WIFEXITED(x)   ((x).w_stopval != WSTOPPED && (x).w_termsig == 0)
+ #define WIFSIGNALED(x) ((x).w_stopval != WSTOPPED && (x).w_termsig != 0)
+ 
+ #define WTERMSIG(x)    ((x).w_termsig)
+ #define WSTOPSIG(x)    ((x).w_stopsig)
+ #define WEXITSTATUS(x) ((x).w_retcode)
+ #define WIFCORED(x)    ((x).w_coredump)
+ 
+ #endif /* _UNIONWAIT_H */
diff -Nrc2 bash-2.0/unwind_prot.c bash-2.01/unwind_prot.c
*** bash-2.0/unwind_prot.c	Wed Jan 31 16:39:36 1996
--- bash-2.01/unwind_prot.c	Tue Apr 29 14:21:10 1997
***************
*** 28,31 ****
--- 28,33 ----
  
  #include "bashtypes.h"
+ #include "bashansi.h"
+ 
  #if defined (HAVE_UNISTD_H)
  #  include <unistd.h>
***************
*** 45,52 ****
  } UNWIND_ELT;
  
! static void
!   unwind_frame_discard_internal (), unwind_frame_run_internal (),
!   add_unwind_protect_internal (), remove_unwind_protect_internal (),
!   run_unwind_protects_internal (), without_interrupts ();
  
  static UNWIND_ELT *unwind_protect_list = (UNWIND_ELT *)NULL;
--- 47,65 ----
  } UNWIND_ELT;
  
! /* Structure describing a saved variable and the value to restore it to.
!    If a cleanup function is set to restore_variable, the `arg' pointer
!    points to this. */
! typedef struct {
!   int *variable;
!   char *desired_setting;
!   int size;
! } SAVED_VAR;
! 
! static void unwind_frame_discard_internal (), unwind_frame_run_internal ();
! static void add_unwind_protect_internal (), remove_unwind_protect_internal ();
! static void run_unwind_protects_internal (), without_interrupts ();
! 
! static void restore_variable ();
! static void discard_saved_var ();
  
  static UNWIND_ELT *unwind_protect_list = (UNWIND_ELT *)NULL;
***************
*** 148,156 ****
  remove_unwind_protect_internal ()
  {
!   UNWIND_ELT *elt = unwind_protect_list;
  
    if (elt)
      {
        unwind_protect_list = unwind_protect_list->next;
        free (elt);
      }
--- 161,172 ----
  remove_unwind_protect_internal ()
  {
!   UNWIND_ELT *elt;
  
+   elt = unwind_protect_list;
    if (elt)
      {
        unwind_protect_list = unwind_protect_list->next;
+       if (elt->cleanup && elt->cleanup == (Function *)restore_variable)
+ 	discard_saved_var ((SAVED_VAR *)elt->arg);
        free (elt);
      }
***************
*** 165,169 ****
     {
        /* This function can be run at strange times, like when unwinding
! 	the entire world of unwind protects.  Thus, we may come across
  	 an element which is simply a label for a catch frame.  Don't call
  	 the non-existant function. */
--- 181,185 ----
     {
        /* This function can be run at strange times, like when unwinding
! 	 the entire world of unwind protects.  Thus, we may come across
  	 an element which is simply a label for a catch frame.  Don't call
  	 the non-existant function. */
***************
*** 187,195 ****
      {
        unwind_protect_list = unwind_protect_list->next;
!       if (!elt->cleanup && (STREQ (elt->arg, tag)))
  	{
  	  free (elt);
  	  break;
  	}
        else
  	free (elt);
--- 203,216 ----
      {
        unwind_protect_list = unwind_protect_list->next;
!       if (elt->cleanup == 0 && (STREQ (elt->arg, tag)))
  	{
  	  free (elt);
  	  break;
  	}
+       else if (elt->cleanup && elt->cleanup == (Function *)restore_variable)
+         {
+           discard_saved_var ((SAVED_VAR *)elt->arg);
+           free (elt);
+         }
        else
  	free (elt);
***************
*** 226,235 ****
  }
  
! /* Structure describing a saved variable and the value to restore it to. */
! typedef struct {
!   int *variable;
!   char *desired_setting;
!   int size;
! } SAVED_VAR;
  
  /* Restore the value of a variable, based on the contents of SV.  If
--- 247,258 ----
  }
  
! static void
! discard_saved_var (sv)
!      SAVED_VAR *sv;
! {
!   if (sv->size != sizeof (int))
!     free (sv->desired_setting);
!   free (sv);
! }
  
  /* Restore the value of a variable, based on the contents of SV.  If
***************
*** 243,247 ****
    if (sv->size != sizeof (int))
      {
!       bcopy ((char *)sv->desired_setting, (char *)sv->variable, sv->size);
        free (sv->desired_setting);
      }
--- 266,270 ----
    if (sv->size != sizeof (int))
      {
!       FASTCOPY ((char *)sv->desired_setting, (char *)sv->variable, sv->size);
        free (sv->desired_setting);
      }
***************
*** 268,273 ****
    if (size != sizeof (int))
      {
        s->desired_setting = (char *)xmalloc (size);
!       bcopy (value, (char *)s->desired_setting, size);
      }
    else
--- 291,305 ----
    if (size != sizeof (int))
      {
+       /* There is a problem here when VALUE is 0.  This tries to copy the
+ 	  first SIZE bytes starting at memory location 0 into
+ 	  s->desired_setting.  There is no guarantee that these bytes are
+ 	  0, or make a valid null pointer.  We can try to bzero the space,
+ 	  or just save it as 0 (or (void *)0).  If we do the latter, make
+ 	  sure restore_variable is changed to understand it. */
        s->desired_setting = (char *)xmalloc (size);
!       if (value == 0)
! 	bzero ((char *)s->desired_setting, size);
!       else
! 	FASTCOPY (value, (char *)s->desired_setting, size);
      }
    else
diff -Nrc2 bash-2.0/variables.c bash-2.01/variables.c
*** bash-2.0/variables.c	Thu Oct 17 10:29:29 1996
--- bash-2.01/variables.c	Wed May 14 13:08:38 1997
***************
*** 24,27 ****
--- 24,31 ----
  #include "posixstat.h"
  
+ #if defined (qnx)
+ #  include <sys/vc.h>
+ #endif
+ 
  #if defined (HAVE_UNISTD_H)
  #  include <unistd.h>
***************
*** 39,42 ****
--- 43,47 ----
  #include "input.h"
  
+ #include "builtins/getopt.h"
  #include "builtins/common.h"
  #include <tilde/tilde.h>
***************
*** 94,100 ****
  
  /* An array which is passed to commands as their environment.  It is
!    manufactured from the overlap of the initial environment and the
     shell variables that are marked for export. */
  char **export_env = (char **)NULL;
  
  /* Non-zero means that we have to remake EXPORT_ENV. */
--- 99,107 ----
  
  /* An array which is passed to commands as their environment.  It is
!    manufactured from the union of the initial environment and the
     shell variables that are marked for export. */
  char **export_env = (char **)NULL;
+ static int export_env_index;
+ static int export_env_size;
  
  /* Non-zero means that we have to remake EXPORT_ENV. */
***************
*** 109,112 ****
--- 116,123 ----
  
  /* Some forward declarations. */
+ static void set_home_var ();
+ static void set_shell_var ();
+ static char *get_bash_name ();
+ static void initialize_shell_level ();
  static void uidset ();
  static void initialize_dynamic_variables ();
***************
*** 138,159 ****
      {
        char_index = 0;
! 
!       string_length = strlen (string);
!       name = xmalloc (1 + string_length);
! 
        while ((c = *string++) && c != '=')
! 	name[char_index++] = c;
  
        name[char_index] = '\0';
  
        /* If exported function, define it now. */
        if (no_functions == 0 && STREQN ("() {", string, 4))
  	{
! 	  temp_string = xmalloc (3 + string_length + strlen (name));
  	  sprintf (temp_string, "%s %s", name, string);
  
! 	  parse_and_execute (temp_string, name, 0);
  
! 	  if (name[char_index - 1] == ')')
  	    name[char_index - 2] = '\0';
  
--- 149,186 ----
      {
        char_index = 0;
!       name = string;
        while ((c = *string++) && c != '=')
! 	;
!       if (string[-1] == '=')
!         char_index = string - name - 1;
! 
!       /* If there are weird things in the environment, like `=xxx' or a
! 	 string without an `=', just skip them. */
!       if (char_index == 0)
!         continue;
  
+       /* ASSERT(name[char_index] == '=') */
        name[char_index] = '\0';
+       /* Now, name = env variable name, string = env variable value, and
+          char_index == strlen (name) */
  
        /* If exported function, define it now. */
        if (no_functions == 0 && STREQN ("() {", string, 4))
  	{
! 	  string_length = strlen (string);
! 	  temp_string = xmalloc (3 + string_length + char_index);
! #if 1
! 	  strcpy (temp_string, name);
! 	  temp_string[char_index] = ' ';
! 	  strcpy (temp_string + char_index + 1, string);
! #else
  	  sprintf (temp_string, "%s %s", name, string);
+ #endif
  
! 	  parse_and_execute (temp_string, name, SEVAL_NONINT|SEVAL_NOHIST);
  
! 	  /* Ancient backwards compatibility.  Old versions of bash exported
! 	     functions like name()=() {...} */
! 	  if (name[char_index - 1] == ')' && name[char_index - 2] == '(')
  	    name[char_index - 2] = '\0';
  
***************
*** 165,168 ****
--- 192,198 ----
  	  else
  	    report_error ("error importing function definition for `%s'", name);
+ 
+ 	  if (name[char_index - 1] == ')' && name[char_index - 2] == '\0')
+ 	    name[char_index - 2] = '(';
  	}
  #if defined (ARRAY_VARS)
***************
*** 186,190 ****
  	  array_needs_making = 1;
  	}
!       free (name);
      }
  
--- 216,221 ----
  	  array_needs_making = 1;
  	}
! 
!       name[char_index] = '=';
      }
  
***************
*** 222,225 ****
--- 253,266 ----
    set_auto_export (temp_var);
  
+ #if defined (qnx)
+   /* set node id -- don't import it from the environment */
+   {
+     char node_name[22];
+     qnx_nidtostr (getnid (), node_name, sizeof (node_name));
+     temp_var = bind_variable ("NODE", node_name);
+     set_auto_export (temp_var);
+   }
+ #endif
+ 
    /* set up the prompts. */
    if (interactive_shell)
***************
*** 251,257 ****
  
    /* Do some things with shell level. */
!   temp_var = set_if_not ("SHLVL", "0");
!   set_auto_export (temp_var);
!   adjust_shell_level (1);
  
    /* Make a variable $PPID, which holds the pid of the shell's parent.  */
--- 292,296 ----
  
    /* Do some things with shell level. */
!   initialize_shell_level ();
  
    /* Make a variable $PPID, which holds the pid of the shell's parent.  */
***************
*** 266,320 ****
    /* Initialize the `getopts' stuff. */
    bind_variable ("OPTIND", "1");
!   sv_optind ("OPTIND");
    bind_variable ("OPTERR", "1");
!   sv_opterr ("OPTERR");
  
    /* Get the full pathname to THIS shell, and set the BASH variable
       to it. */
!   if ((login_shell == 1) && (*shell_name != '/'))
!     {
!       /* If HOME doesn't exist, set it. */
!       temp_var = set_if_not ("HOME", current_user.home_dir);
!       temp_var->attributes |= att_exported;
! 
!       name = savestring (current_user.shell);
!     }
!   else if (*shell_name == '/')
!     name = savestring (shell_name);
!   else
!     {
!       char *tname;
!       int s;
! 
!       tname = find_user_command (shell_name);
! 
!       if (tname == 0)
! 	{
! 	  /* Try the current directory.  If there is not an executable
! 	     there, just punt and use the login shell. */
! 	  s = file_status (shell_name);
! 	  if (s & FS_EXECABLE)
! 	    {
! 	      tname = make_absolute (shell_name, get_string_value ("PWD"));
! 	      if (*shell_name == '.')
! 		{
! 		  name = canonicalize_pathname (tname);
! 		  if (name == 0)
! 		    name = tname;
! 		  else
! 		    free (tname);
! 		}
! 	     else
! 		name = tname;
! 	    }
! 	  else
! 	    name = savestring (current_user.shell);
! 	}
!       else
! 	{
! 	  name = full_pathname (tname);
! 	  free (tname);
! 	}
!     }
    temp_var = bind_variable ("BASH", name);
    free (name);
--- 305,318 ----
    /* Initialize the `getopts' stuff. */
    bind_variable ("OPTIND", "1");
!   getopts_reset (0);
    bind_variable ("OPTERR", "1");
!   sh_opterr = 1;
! 
!   if (login_shell == 1)
!     set_home_var ();
  
    /* Get the full pathname to THIS shell, and set the BASH variable
       to it. */
!   name = get_bash_name ();
    temp_var = bind_variable ("BASH", name);
    free (name);
***************
*** 324,329 ****
       to determine what style of commands to output; if it ends in "csh",
       then C-shell commands are output, else Bourne shell commands. */
!   temp_var = set_if_not ("SHELL", current_user.shell);
!   set_auto_export (temp_var);
  
    /* Make a variable called BASH_VERSION which contains the version info. */
--- 322,326 ----
       to determine what style of commands to output; if it ends in "csh",
       then C-shell commands are output, else Bourne shell commands. */
!   set_shell_var ();
  
    /* Make a variable called BASH_VERSION which contains the version info. */
***************
*** 362,371 ****
    /* Handle some "special" variables that we may have inherited from a
       parent shell. */
! 
!   temp_var = find_variable ("IGNOREEOF");
!   if (!temp_var)
!     temp_var = find_variable ("ignoreeof");
!   if (temp_var && imported_p (temp_var))
!     sv_ignoreeof (temp_var->name);
  
  #if defined (HISTORY)
--- 359,370 ----
    /* Handle some "special" variables that we may have inherited from a
       parent shell. */
!   if (interactive_shell)
!     {
!       temp_var = find_variable ("IGNOREEOF");
!       if (!temp_var)
! 	temp_var = find_variable ("ignoreeof");
!       if (temp_var && imported_p (temp_var))
! 	sv_ignoreeof (temp_var->name);
!     }
  
  #if defined (HISTORY)
***************
*** 384,406 ****
  }
  
  void
  adjust_shell_level (change)
       int change;
  {
!   char *new_level, *old_SHLVL;
    int old_level;
  
    old_SHLVL = get_string_value ("SHLVL");
!   if (old_SHLVL)
!     old_level = atoi (old_SHLVL);
!   else
!     old_level = 0;
  
    shell_level = old_level + change;
    if (shell_level < 0)
      shell_level = 0;
!   new_level = itos (shell_level);
!   bind_variable ("SHLVL", new_level);
!   free (new_level);
  }
  
--- 383,543 ----
  }
  
+ /* Set $HOME to the information in the password file if we didn't get
+    it from the environment. */
+ static void
+ set_home_var ()
+ {
+   SHELL_VAR *temp_var;
+ 
+   temp_var = find_variable ("HOME");
+   if (temp_var == 0)
+     {
+       if (current_user.home_dir == 0)
+ 	get_current_user_info ();
+       temp_var = bind_variable ("HOME", current_user.home_dir);
+     }
+   temp_var->attributes |= att_exported;
+ }
+ 
+ /* Set $SHELL to the user's login shell if it is not already set.  Call
+    get_current_user_info if we haven't already fetched the shell. */
+ static void
+ set_shell_var ()
+ {
+   SHELL_VAR *temp_var;
+ 
+   temp_var = find_variable ("SHELL");
+   if (temp_var == 0)
+     {
+       if (current_user.shell == 0)
+ 	get_current_user_info ();
+       temp_var = bind_variable ("SHELL", current_user.shell);
+     }
+   temp_var->attributes |= att_exported;
+ }
+ 
+ static char *
+ get_bash_name ()
+ {
+   char *name;
+ 
+   if ((login_shell == 1) && (*shell_name != '/'))
+     {
+       if (current_user.shell == 0)
+         get_current_user_info ();
+       name = savestring (current_user.shell);
+     }
+   else if (*shell_name == '/')
+     name = savestring (shell_name);
+   else if (shell_name[0] == '.' && shell_name[1] == '/')
+     {
+       /* Fast path for common case. */
+       char *cdir;
+       int len;
+ 
+       cdir = get_string_value ("PWD");
+       len = strlen (cdir);
+       name = xmalloc (len + strlen (shell_name) + 1);
+       strcpy (name, cdir);
+       strcpy (name + len, shell_name + 1);
+     }
+   else
+     {
+       char *tname;
+       int s;
+ 
+       tname = find_user_command (shell_name);
+ 
+       if (tname == 0)
+ 	{
+ 	  /* Try the current directory.  If there is not an executable
+ 	     there, just punt and use the login shell. */
+ 	  s = file_status (shell_name);
+ 	  if (s & FS_EXECABLE)
+ 	    {
+ 	      tname = make_absolute (shell_name, get_string_value ("PWD"));
+ 	      if (*shell_name == '.')
+ 		{
+ 		  name = canonicalize_pathname (tname);
+ 		  if (name == 0)
+ 		    name = tname;
+ 		  else
+ 		    free (tname);
+ 		}
+ 	     else
+ 		name = tname;
+ 	    }
+ 	  else
+ 	    {
+ 	      if (current_user.shell == 0)
+ 		get_current_user_info ();
+ 	      name = savestring (current_user.shell);
+ 	    }
+ 	}
+       else
+ 	{
+ 	  name = full_pathname (tname);
+ 	  free (tname);
+ 	}
+     }
+ 
+   return (name);
+ }
+ 
  void
  adjust_shell_level (change)
       int change;
  {
!   char new_level[5], *old_SHLVL;
    int old_level;
+   SHELL_VAR *temp_var;
  
    old_SHLVL = get_string_value ("SHLVL");
!   old_level = old_SHLVL ? atoi (old_SHLVL) : 0;
  
    shell_level = old_level + change;
    if (shell_level < 0)
      shell_level = 0;
!   else if (shell_level > 1000)
!     {
!       internal_error ("warning: shell level (%d) too high, resetting to 1", shell_level);
!       shell_level = 1;
!     }
! 
!   /* We don't need the full generality of itos here. */
!   if (shell_level < 10)
!     {
!       new_level[0] = shell_level + '0';
!       new_level[1] = '\0';
!     }
!   else if (shell_level < 100)
!     {
!       new_level[0] = (shell_level / 10) + '0';
!       new_level[1] = (shell_level % 10) + '0';
!       new_level[2] = '\0';
!     }
!   else if (shell_level < 1000)
!     {
!       new_level[0] = (shell_level / 100) + '0';
!       old_level = shell_level % 100;
!       new_level[1] = (old_level / 10) + '0';
!       new_level[2] = (old_level % 10) + '0';
!       new_level[3] = '\0';
!     }
! 
!   temp_var = bind_variable ("SHLVL", new_level);
!   set_auto_export (temp_var);
! }
! 
! static void
! initialize_shell_level ()
! {
! #if 0
!   SHELL_VAR *temp_var;
! 
!   temp_var = set_if_not ("SHLVL", "0");
!   set_auto_export (temp_var);
! #endif
!   adjust_shell_level (1);
  }
  
***************
*** 496,502 ****
  
  /* Map FUNCTION over the variables in VARIABLES.  Return an array of the
!    variables that satisfy FUNCTION.  Satisfy means that FUNCTION returns
!    a non-zero value for.  A NULL value for FUNCTION means to use all
!    variables. */
  SHELL_VAR **
  map_over (function, var_hash_table)
--- 633,638 ----
  
  /* Map FUNCTION over the variables in VARIABLES.  Return an array of the
!    variables for which FUNCTION returns a non-zero value.  A NULL value
!    for FUNCTION means to use all variables. */
  SHELL_VAR **
  map_over (function, var_hash_table)
***************
*** 506,513 ****
    register int i;
    register BUCKET_CONTENTS *tlist;
!   SHELL_VAR *var, **list = (SHELL_VAR **)NULL;
!   int list_index = 0, list_size = 0;
  
!   for (i = 0; i < var_hash_table->nbuckets; i++)
      {
        tlist = get_hash_bucket (i, var_hash_table);
--- 642,650 ----
    register int i;
    register BUCKET_CONTENTS *tlist;
!   SHELL_VAR *var, **list;
!   int list_index, list_size;
  
!   list = (SHELL_VAR **)NULL;
!   for (i = list_index = list_size = 0; i < var_hash_table->nbuckets; i++)
      {
        tlist = get_hash_bucket (i, var_hash_table);
***************
*** 559,563 ****
  
    list = map_over ((Function *)NULL, table);
!   if (list && posixly_correct)
      sort_variables (list);
    return (list);
--- 696,700 ----
  
    list = map_over ((Function *)NULL, table);
!   if (list /* && posixly_correct */)
      sort_variables (list);
    return (list);
***************
*** 865,868 ****
--- 1002,1006 ----
    a = word_list_to_array (l);
    dispose_array (array_cell (self));
+   dispose_words (l);
    self->value = (char *)a;
    return self;
***************
*** 880,883 ****
--- 1018,1044 ----
  #endif /* PUSHD AND POPD && ARRAY_VARS */
  
+ #if defined (ARRAY_VARS)
+ /* We don't want to initialize the group set with a call to getgroups()
+    unless we're asked to, but we only want to do it once. */
+ static SHELL_VAR *
+ get_groupset (self)
+      SHELL_VAR *self;
+ {
+   register int i;
+   int ng;
+   ARRAY *a;
+   static char **group_set = (char **)NULL;
+ 
+   if (group_set == 0)
+     {
+       group_set = get_group_list (&ng);
+       a = array_cell (self);
+       for (i = 0; i < ng; i++)
+ 	array_add_element (a, i, group_set[i]);
+     }
+   return (self);
+ }
+ #endif /* ARRAY_VARS */
+   
  static void
  initialize_dynamic_variables ()
***************
*** 908,911 ****
--- 1069,1079 ----
    v->assign_func = assign_dirstack;
  #endif /* PUSHD_AND_POPD && ARRAY_VARS */
+ 
+ #if defined (ARRAY_VARS)
+   v = make_new_array_variable ("GROUPS");
+   v->dynamic_value = get_groupset;
+   v->assign_func = (DYNAMIC_FUNC *)NULL;
+   v->attributes |= att_readonly;
+ #endif
  }
  
***************
*** 976,980 ****
       char *var_name;
  {
!   SHELL_VAR *var = find_variable (var_name);
  
    if (!var)
--- 1144,1150 ----
       char *var_name;
  {
!   SHELL_VAR *var;
! 
!   var = find_variable (var_name);
  
    if (!var)
***************
*** 1013,1020 ****
    /* If a variable does not already exist with this name, then
       just make a new one. */
!   if (!old_var)
!     {
!       new_var = bind_variable (name, "");
!     }
    else
      {
--- 1183,1188 ----
    /* If a variable does not already exist with this name, then
       just make a new one. */
!   if (old_var == 0)
!     new_var = bind_variable (name, "");
    else
      {
***************
*** 1124,1127 ****
--- 1292,1296 ----
    char *retval;
    long lval;
+   int expok;
  
    /* If this variable has had its type set to integer (via `declare -i'),
***************
*** 1132,1136 ****
    if (integer_p (var))
      {
!       lval = evalexp (value);
        retval = itos (lval);
      }
--- 1301,1307 ----
    if (integer_p (var))
      {
!       lval = evalexp (value, &expok);
!       if (expok == 0)
! 	jump_to_top_level (DISCARD);
        retval = itos (lval);
      }
***************
*** 1192,1196 ****
  	 x[0]=b or `read x[0]'. */
        if (array_p (entry))
!         array_add_element (array_cell (entry), 0, newval);
        else
  	{
--- 1363,1370 ----
  	 x[0]=b or `read x[0]'. */
        if (array_p (entry))
! 	{
! 	  array_add_element (array_cell (entry), 0, newval);
! 	  free (newval);
! 	}
        else
  	{
***************
*** 1282,1285 ****
--- 1456,1464 ----
    if (var == 0)
      var = make_new_array_variable (name);
+   else if (readonly_p (var))
+     {
+       report_error ("%s: readonly variable", name);
+       return ((SHELL_VAR *)NULL);
+     }
    else if (array_p (var) == 0)
      var = convert_var_to_array (var);
***************
*** 1447,1451 ****
    if (ind < 0)
      {
!       builtin_error ("[%s: bad array subscript", sub);
        return -1;
      }
--- 1626,1630 ----
    if (ind < 0)
      {
!       builtin_error ("[%s]: bad array subscript", sub);
        return -1;
      }
***************
*** 1492,1496 ****
       HASH_TABLE *hash_list;
  {
!   BUCKET_CONTENTS *elt;
    SHELL_VAR *old_var, *new_var;
    char *t;
--- 1671,1675 ----
       HASH_TABLE *hash_list;
  {
!   BUCKET_CONTENTS *elt, *new_elt;
    SHELL_VAR *old_var, *new_var;
    char *t;
***************
*** 1498,1502 ****
    elt = remove_hash_item (name, hash_list);
  
!   if (!elt)
      return (-1);
  
--- 1677,1681 ----
    elt = remove_hash_item (name, hash_list);
  
!   if (elt == 0)
      return (-1);
  
***************
*** 1516,1522 ****
      {
        old_var->attributes |= att_invisible;
!       elt = add_hash_item (savestring (old_var->name), hash_list);
!       elt->data = (char *)old_var;
        stupidly_hack_special_variables (old_var->name);
        return (0);
      }
--- 1695,1703 ----
      {
        old_var->attributes |= att_invisible;
!       new_elt = add_hash_item (savestring (old_var->name), hash_list);
!       new_elt->data = (char *)old_var;
        stupidly_hack_special_variables (old_var->name);
+       free (elt->key);
+       free (elt);
        return (0);
      }
***************
*** 1525,1530 ****
      {
        /* Has to be a variable, functions don't have previous contexts. */
-       BUCKET_CONTENTS *new_elt;
- 
        new_elt = add_hash_item (savestring (new_var->name), hash_list);
        new_elt->data = (char *)new_var;
--- 1706,1709 ----
***************
*** 1548,1551 ****
--- 1727,1731 ----
  }
  
+ #ifdef INCLUDE_UNUSED
  /* Remove the variable with NAME if it is a local variable in the
     current context. */
***************
*** 1554,1559 ****
       char *name;
  {
!   SHELL_VAR *temp = find_variable (name);
  
    if (temp && temp->context == variable_context)
      {
--- 1734,1740 ----
       char *name;
  {
!   SHELL_VAR *temp;
  
+   temp = find_variable (name);
    if (temp && temp->context == variable_context)
      {
***************
*** 1563,1566 ****
--- 1744,1748 ----
    return (-1);
  }
+ #endif
  
  /* Get rid of all of the variables in the current context. */
***************
*** 1688,1691 ****
--- 1870,1874 ----
  }
  
+ #ifdef INCLUDE_UNUSED
  /* Copy VAR to a new data structure and return that structure. */
  SHELL_VAR *
***************
*** 1723,1726 ****
--- 1906,1910 ----
    return (copy);
  }
+ #endif
  
  #define FIND_OR_MAKE_VARIABLE(name, entry) \
***************
*** 1754,1759 ****
       char *name;
  {
!   SHELL_VAR *entry = find_function (name);
  
    if (entry)
      entry->attributes |= att_readonly;
--- 1938,1944 ----
       char *name;
  {
!   SHELL_VAR *entry;
  
+   entry = find_function (name);
    if (entry)
      entry->attributes |= att_readonly;
***************
*** 1860,1864 ****
    list = map_over (visible_var, table);
  
!   if (list && posixly_correct)
      sort_variables (list);
  
--- 2045,2049 ----
    list = map_over (visible_var, table);
  
!   if (list /* && posixly_correct */)
      sort_variables (list);
  
***************
*** 1899,1906 ****
    SHELL_VAR **vars;
  
-   list = (char **)NULL;
    vars = map_over (visible_and_exported, hashed_vars);
  
!   if (!vars)
      return (char **)NULL;
  
--- 2084,2090 ----
    SHELL_VAR **vars;
  
    vars = map_over (visible_and_exported, hashed_vars);
  
!   if (vars == 0)
      return (char **)NULL;
  
***************
*** 1971,1974 ****
--- 2155,2159 ----
  	{
  	  report_error ("%s: readonly variable", name);
+ 	  free (name);
    	  return (0);
  	}
***************
*** 2048,2052 ****
  	  char *w;
  
! 	  temp = new_shell_variable (name);
  	  w = array[i] + l + 1;
  
--- 2233,2237 ----
  	  char *w;
  
! 	  temp = new_shell_variable (name);	/* XXX memory leak here */
  	  w = array[i] + l + 1;
  
***************
*** 2138,2142 ****
    register int i, l;
    SHELL_VAR *temp;
!   char *w, *name;
  
    if (env_array == 0)
--- 2323,2327 ----
    register int i, l;
    SHELL_VAR *temp;
!   char *val, *name;
  
    if (env_array == 0)
***************
*** 2147,2153 ****
        l = assignment (env_array[i]);
        name = env_array[i];
!       w = env_array[i] + l + 1;
        name[l] = '\0';
!       temp = bind_variable (name, w);
        name[l] = '=';
      }
--- 2332,2338 ----
        l = assignment (env_array[i]);
        name = env_array[i];
!       val = env_array[i] + l + 1;
        name[l] = '\0';
!       temp = bind_variable (name, val);
        name[l] = '=';
      }
***************
*** 2166,2183 ****
  }
  
  #define ISFUNC(s, o) ((s[o + 1] == '(')  && (s[o + 2] == ')'))
  
! /* Add ASSIGN to ARRAY, or supercede a previous assignment in the
!    array with the same left-hand side.  Return the new array. */
  char **
! add_or_supercede (assign, array)
       char *assign;
!      register char **array;
  {
    register int i;
!   int equal_offset = assignment (assign);
  
!   if (!equal_offset)
!     return (array);
  
    /* If this is a function, then only supercede the function definition.
--- 2351,2382 ----
  }
  
+ /* Add ENVSTR to the end of the exported environment, EXPORT_ENV. */
+ #define add_to_export_env(envstr,do_alloc) \
+ do \
+   { \
+     if (export_env_index >= (export_env_size - 1)) \
+       { \
+ 	export_env_size += 16; \
+ 	export_env = (char **)xrealloc (export_env, export_env_size * sizeof (char *)); \
+       } \
+     export_env[export_env_index++] = (do_alloc) ? savestring (envstr) : envstr; \
+     export_env[export_env_index] = (char *)NULL; \
+   } while (0)
+ 
  #define ISFUNC(s, o) ((s[o + 1] == '(')  && (s[o + 2] == ')'))
  
! /* Add ASSIGN to EXPORT_ENV, or supercede a previous assignment in the
!    array with the same left-hand side.  Return the new EXPORT_ENV. */
  char **
! add_or_supercede_exported_var (assign, do_alloc)
       char *assign;
!      int do_alloc;
  {
    register int i;
!   int equal_offset;
  
!   equal_offset = assignment (assign);
!   if (equal_offset == 0)
!     return (export_env);
  
    /* If this is a function, then only supercede the function definition.
***************
*** 2186,2205 ****
      equal_offset++;
  
!   for (i = 0; array && array[i]; i++)
      {
!       if (STREQN (assign, array[i], equal_offset + 1))
  	{
! 	  free (array[i]);
! 	  array[i] = savestring (assign);
! 	  return (array);
  	}
      }
!   array = (char **)xrealloc (array, ((2 + i) * sizeof (char *)));
!   array[i++] = savestring (assign);
!   array[i] = (char *)NULL;
!   return (array);
  }
  
! /* Make the environment array for the command about to be executed.  If the
     array needs making.  Otherwise, do nothing.  If a shell action could
     change the array that commands receive for their environment, then the
--- 2385,2402 ----
      equal_offset++;
  
!   for (i = 0; i < export_env_index; i++)
      {
!       if (STREQN (assign, export_env[i], equal_offset + 1))
  	{
! 	  free (export_env[i]);
! 	  export_env[i] = do_alloc ? savestring (assign) : assign;
! 	  return (export_env);
  	}
      }
!   add_to_export_env (assign, do_alloc);
!   return (export_env);
  }
  
! /* Make the environment array for the command about to be executed, if the
     array needs making.  Otherwise, do nothing.  If a shell action could
     change the array that commands receive for their environment, then the
***************
*** 2210,2239 ****
    register int i;
    register char **temp_array;
  
    if (array_needs_making)
      {
        if (export_env)
! 	free_array (export_env);
  
!       export_env = (char **)xmalloc (sizeof (char *));
!       export_env[0] = (char *)NULL;
  
        temp_array = make_var_array (shell_variables);
!       for (i = 0; temp_array && temp_array[i]; i++)
! 	export_env = add_or_supercede (temp_array[i], export_env);
!       free_array (temp_array);
  
        temp_array = make_var_array (shell_functions);
!       for (i = 0; temp_array && temp_array[i]; i++)
! 	export_env = add_or_supercede (temp_array[i], export_env);
!       free_array (temp_array);
  
        if (function_env)
  	for (i = 0; function_env[i]; i++)
! 	  export_env = add_or_supercede (function_env[i], export_env);
  
        if (temporary_env)
  	for (i = 0; temporary_env[i]; i++)
! 	  export_env = add_or_supercede (temporary_env[i], export_env);
  
  #if 0
--- 2407,2453 ----
    register int i;
    register char **temp_array;
+   int new_size;
  
    if (array_needs_making)
      {
        if (export_env)
! 	free_array_members (export_env);
  
!       /* Make a guess based on how many shell variables and functions we
! 	 have.  Since there will always be array variables, and array
! 	 variables are not (yet) exported, this will always be big enough
! 	 for the exported variables and functions, without any temporary
! 	 or function environments. */
!       new_size = shell_variables->nentries + shell_functions->nentries + 1;
!       if (new_size > export_env_size)
! 	{
! 	  export_env_size = new_size;
!           export_env = (char **)xrealloc (export_env, export_env_size * sizeof (char *));
! 	}
!       export_env[export_env_index = 0] = (char *)NULL;
  
        temp_array = make_var_array (shell_variables);
!       if (temp_array)
! 	{
! 	  for (i = 0; temp_array[i]; i++)
! 	    add_to_export_env (temp_array[i], 0);
! 	  free (temp_array);
! 	}
  
        temp_array = make_var_array (shell_functions);
!       if (temp_array)
! 	{
! 	  for (i = 0; temp_array[i]; i++)
! 	    add_to_export_env (temp_array[i], 0);
! 	  free (temp_array);
! 	}
  
        if (function_env)
  	for (i = 0; function_env[i]; i++)
! 	  export_env = add_or_supercede_exported_var (function_env[i], 1);
  
        if (temporary_env)
  	for (i = 0; temporary_env[i]; i++)
! 	  export_env = add_or_supercede_exported_var (temporary_env[i], 1);
  
  #if 0
***************
*** 2260,2265 ****
    dummy[1] = '=';
    strcpy (dummy + 2, command_name);
!   export_env = add_or_supercede (dummy, export_env);
!   free (dummy);
  }
  
--- 2474,2478 ----
    dummy[1] = '=';
    strcpy (dummy + 2, command_name);
!   export_env = add_or_supercede_exported_var (dummy, 0);
  }
  
***************
*** 2286,2291 ****
    free (pbuf);
  
!   export_env = add_or_supercede (dummy, export_env);
!   free (dummy);
  }
  
--- 2499,2503 ----
    free (pbuf);
  
!   export_env = add_or_supercede_exported_var (dummy, 0);
  }
  
diff -Nrc2 bash-2.0/variables.h bash-2.01/variables.h
*** bash-2.0/variables.h	Wed Oct  9 10:56:51 1996
--- bash-2.01/variables.h	Fri Apr 11 12:09:28 1997
***************
*** 84,88 ****
  
  extern char **make_var_array __P((HASH_TABLE *));
! extern char **add_or_supercede __P((char *, char **));
  
  extern char *get_string_value __P((char *));
--- 84,88 ----
  
  extern char **make_var_array __P((HASH_TABLE *));
! extern char **add_or_supercede_exported_var __P((char *, int));
  
  extern char *get_string_value __P((char *));
diff -Nrc2 bash-2.0/xmalloc.c bash-2.01/xmalloc.c
*** bash-2.0/xmalloc.c	Thu Jun  6 10:44:03 1996
--- bash-2.01/xmalloc.c	Mon Feb 17 14:28:29 1997
***************
*** 24,28 ****
  #endif
  
! #include <sys/types.h>
  #include <stdio.h>
  
--- 24,28 ----
  #endif
  
! #include "bashtypes.h"
  #include <stdio.h>
  
diff -Nrc2 bash-2.0/y.tab.c bash-2.01/y.tab.c
*** bash-2.0/y.tab.c	Mon Dec 16 11:46:22 1996
--- bash-2.01/y.tab.c	Wed May 14 15:00:24 1997
***************
*** 125,128 ****
--- 125,129 ----
  static int read_token ();
  static int yylex ();
+ static int parse_arith_cmd ();
  static int read_token_word ();
  static void discard_parser_constructs ();
***************
*** 131,137 ****
--- 132,142 ----
  static void handle_eof_input_unit ();
  static void prompt_again ();
+ #if 0
  static void reset_readline_prompt ();
+ #endif
  static void print_prompt ();
  
+ extern int yyerror ();
+ 
  /* Default prompt strings */
  char *primary_prompt = PPROMPT;
***************
*** 185,189 ****
  static REDIRECTEE redir;
  
! #line 166 "./parse.y"
  typedef union {
    WORD_DESC *word;		/* the word that we read. */
--- 190,194 ----
  static REDIRECTEE redir;
  
! #line 171 "./parse.y"
  typedef union {
    WORD_DESC *word;		/* the word that we read. */
***************
*** 277,285 ****
       0,    13,    68,    14,    68,    15,     0,    56,     0,    60,
       0,    59,     0,    61,     0,    58,     0,    10,    21,    72,
!     14,    67,    15,     0,    10,    21,    72,    43,    67,    44,
!      0,    10,    21,    36,    72,    14,    67,    15,     0,    10,
!     21,    36,    72,    43,    67,    44,     0,    10,    21,    72,
!     17,    48,    71,    72,    14,    67,    15,     0,    10,    21,
!     72,    17,    48,    71,    72,    43,    67,    44,     0,    11,
      21,    72,    14,    67,    15,     0,    11,    21,    72,    43,
      67,    44,     0,    11,    21,    36,    72,    14,    67,    15,
--- 282,290 ----
       0,    13,    68,    14,    68,    15,     0,    56,     0,    60,
       0,    59,     0,    61,     0,    58,     0,    10,    21,    72,
!     14,    68,    15,     0,    10,    21,    72,    43,    68,    44,
!      0,    10,    21,    36,    72,    14,    68,    15,     0,    10,
!     21,    36,    72,    43,    68,    44,     0,    10,    21,    72,
!     17,    48,    71,    72,    14,    68,    15,     0,    10,    21,
!     72,    17,    48,    71,    72,    43,    68,    44,     0,    11,
      21,    72,    14,    67,    15,     0,    11,    21,    72,    43,
      67,    44,     0,    11,    21,    36,    72,    14,    67,    15,
***************
*** 318,334 ****
  #if YYDEBUG != 0
  static const short yyrline[] = { 0,
!    209,   218,   225,   240,   250,   252,   256,   261,   266,   271,
!    276,   281,   286,   292,   298,   303,   308,   313,   318,   323,
!    328,   333,   338,   345,   352,   357,   362,   367,   372,   377,
!    382,   387,   392,   399,   401,   403,   407,   411,   422,   424,
!    428,   430,   432,   461,   463,   465,   467,   469,   471,   473,
!    475,   477,   481,   483,   485,   487,   489,   491,   495,   499,
!    503,   507,   511,   515,   521,   523,   525,   529,   533,   536,
!    540,   544,   546,   548,   553,   557,   559,   561,   565,   566,
!    570,   572,   574,   576,   580,   581,   585,   587,   596,   604,
!    605,   611,   612,   619,   623,   625,   627,   634,   636,   638,
!    642,   643,   644,   647,   648,   657,   663,   672,   680,   682,
!    684,   691,   694,   698,   700,   705,   710,   715,   722,   725,
!    729,   731
  };
  #endif
--- 323,339 ----
  #if YYDEBUG != 0
  static const short yyrline[] = { 0,
!    214,   223,   230,   245,   255,   257,   261,   266,   271,   276,
!    281,   286,   291,   297,   303,   308,   313,   318,   323,   328,
!    333,   338,   343,   350,   357,   362,   367,   372,   377,   382,
!    387,   392,   397,   404,   406,   408,   412,   416,   427,   429,
!    433,   435,   437,   466,   468,   470,   472,   474,   476,   478,
!    480,   482,   486,   488,   490,   492,   494,   496,   500,   504,
!    508,   512,   516,   520,   526,   528,   530,   534,   538,   541,
!    545,   549,   551,   553,   558,   562,   564,   566,   570,   571,
!    575,   577,   579,   581,   585,   586,   590,   592,   601,   609,
!    610,   616,   617,   624,   628,   630,   632,   639,   641,   643,
!    647,   648,   649,   652,   653,   662,   668,   677,   685,   687,
!    689,   696,   699,   703,   705,   710,   715,   720,   727,   730,
!    734,   736
  };
  #endif
***************
*** 416,574 ****
     178,    28,    29,    88,    30,    31,    32,    33,    34,    35,
      36,    37,    38,    39,   164,   170,   171,   172,   204,    46,
!     47,    99,   100,   212,    83,    40,   132,   101,    43,    44
  };
  
! static const short yypact[] = {   246,
!    -19,-32768,     8,    25,    29,-32768,-32768,    33,   354,     4,
!     34,-32768,   499,    46,    51,    32,    38,    56,    70,    72,
!     90,-32768,-32768,    97,   101,-32768,-32768,-32768,-32768,   161,
! -32768,   483,-32768,-32768,-32768,-32768,-32768,-32768,-32768,     6,
!    139,-32768,    84,   390,-32768,-32768,   120,   282,-32768,    89,
!     94,   112,   117,    87,    84,   462,-32768,    96,   123,   127,
!     52,    55,   128,   129,   133,   137,   140,-32768,-32768,-32768,
  -32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,
! -32768,   121,   282,   122,-32768,-32768,-32768,   483,-32768,-32768,
! -32768,   318,   318,-32768,   462,    84,-32768,-32768,-32768,    92,
! -32768,   -10,-32768,     2,-32768,    14,-32768,-32768,   130,   -28,
!     84,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,
! -32768,-32768,-32768,-32768,-32768,-32768,    92,-32768,-32768,   282,
!    282,    10,    10,   426,    84,    93,-32768,-32768,-32768,-32768,
! -32768,-32768,    23,-32768,   148,-32768,    26,-32768,   148,-32768,
!    158,   164,-32768,-32768,   -28,-32768,-32768,   318,   318,    84,
! -32768,-32768,-32768,   178,   282,   282,   282,   282,   282,   177,
!    166,-32768,    -7,-32768,-32768,   176,-32768,    83,   153,-32768,
! -32768,   183,    83,   155,-32768,-32768,   -28,-32768,   193,   199,
! -32768,-32768,-32768,    57,    57,    57,-32768,-32768,   174,    -1,
! -32768,-32768,   184,   -29,   191,   163,-32768,-32768,-32768,-32768,
! -32768,-32768,-32768,   194,   167,-32768,-32768,-32768,-32768,-32768,
! -32768,-32768,-32768,-32768,-32768,-32768,   -13,   187,-32768,-32768,
! -32768,    27,-32768,-32768,    28,   103,   282,   282,   282,-32768,
! -32768,-32768,   282,-32768,-32768,-32768,-32768,-32768,-32768,-32768,
!    282,   197,   169,   201,   170,-32768,-32768,-32768,-32768,-32768,
!    217,   218,-32768
  };
  
  static const short yypgoto[] = {-32768,
!     74,   -26,   195,-32768,-32768,-32768,-32768,-32768,-32768,-32768,
! -32768,-32768,-32768,   -97,   -12,-32768,    58,-32768,    30,    -3,
!      5,-32768,   -82,    45,    -2,-32768,     3,    22,    12,   220
  };
  
  
! #define	YYLAST		540
  
  
! static const short yytable[] = {    48,
!    127,   201,    41,    48,    48,    87,   142,   226,    98,   228,
!     52,    53,   154,   202,    26,   144,   229,    45,   145,   202,
!     55,    42,    82,    57,    48,   228,    98,   148,    49,    98,
!    149,    84,   240,    90,    91,    98,   174,   203,    98,   180,
!    244,   246,    89,   203,   146,    50,   102,   104,   106,    51,
!     98,   110,    70,    54,    71,    96,   150,   188,    73,    98,
!     74,   129,    98,    98,    98,   175,    68,   111,   181,   245,
!    247,    69,   115,    72,   116,   118,    76,   119,    58,    75,
!    137,   138,   192,   193,   194,   195,   196,   130,   131,   219,
!     77,   134,    78,   117,    48,   133,   120,   161,   162,   163,
!    143,   136,   147,   208,    48,    48,   135,   248,   162,   155,
!     79,   151,   152,    42,    42,   137,   138,    80,   209,   210,
!    211,    81,    94,    97,   103,   107,   139,   140,   141,   105,
!    108,   109,   156,   157,   165,   166,   167,   168,   169,   173,
!    176,   112,   179,   113,   182,   160,   184,   114,   121,   122,
!    187,    42,    42,   123,   194,   195,   196,   124,    48,    48,
!    125,   133,    90,    91,   126,   189,   190,   128,   177,   200,
!    205,   206,   185,    92,    93,   153,   214,   215,   186,    42,
!     42,    85,    12,    13,   191,   197,    14,    15,    16,    17,
!    207,    18,    19,    20,    21,   198,   213,   216,   218,   220,
!     24,    25,   221,   225,   202,   230,   231,   241,   233,   232,
!    234,   257,   258,   260,   235,   259,   262,   263,    48,   237,
!    238,   239,   183,   249,    86,   236,   243,   217,    56,   199,
!      0,     0,   227,   242,     0,     0,     0,   251,     0,     0,
!    252,   253,   254,   255,   250,    48,     1,     0,     2,     0,
!      0,     0,   256,     3,     0,     4,     5,     6,     7,     0,
       0,     8,     0,     9,    10,     0,    11,    12,    13,     0,
       0,    14,    15,    16,    17,     0,    18,    19,    20,    21,
!      0,     0,    22,    23,     2,    24,    25,     0,    26,     3,
      27,     4,     5,     6,     7,     0,     0,     8,     0,     9,
      10,     0,    11,    12,    13,     0,     0,    14,    15,    16,
!     17,     0,    18,    19,    20,    21,     0,     0,    98,     0,
       2,    24,    25,     0,    26,     3,    27,     4,     5,     6,
!      7,     0,     0,     8,     0,     9,    10,     0,    11,    12,
      13,     0,     0,    14,    15,    16,    17,     0,    18,    19,
      20,    21,     0,     0,     0,     0,     2,    24,    25,     0,
      26,     3,    27,     4,     5,     6,     7,     0,     0,     8,
!      0,     0,    10,     0,    11,    12,    13,     0,     0,    14,
      15,    16,    17,     0,    18,    19,    20,    21,     0,     0,
       0,     0,     2,    24,    25,     0,    26,     3,    27,     4,
!      5,     6,     7,     0,     0,     8,     0,    95,     0,     0,
      11,    12,    13,     0,     0,    14,    15,    16,    17,     0,
!     18,    19,    20,    21,     0,     0,     0,     0,     2,    24,
      25,     0,    26,     3,    27,     4,     5,     6,     7,     0,
       0,     8,     0,     0,     0,     0,    11,    12,    13,     0,
       0,    14,    15,    16,    17,     0,    18,    19,    20,    21,
!      0,     0,    98,     0,     2,    24,    25,     0,    26,     3,
!     27,     4,     5,     6,     7,     0,     0,     8,     0,     0,
!      0,     0,    11,    12,    13,     0,     0,    14,    15,    16,
!     17,     0,    18,    19,    20,    21,     0,     0,     0,     0,
!      0,    24,    25,     0,    26,    13,    27,     0,    14,    15,
!     16,    17,     0,    18,    19,    20,    21,     0,     0,     0,
!      0,     0,    24,    25,    59,    60,    61,    62,     0,    63,
!      0,    64,    65,     0,     0,     0,     0,     0,    66,    67
  };
  
! static const short yycheck[] = {     2,
!     83,     9,     0,     6,     7,    32,    17,     9,    37,    39,
!      6,     7,   110,    21,    43,    14,    46,    37,    17,    21,
!      9,     0,    26,    20,    27,    39,    37,    14,    21,    37,
!     17,    27,    46,    24,    25,    37,    14,    45,    37,    14,
!     14,    14,    37,    45,    43,    21,    49,    50,    51,    21,
!     37,    54,    21,    21,    23,    44,    43,   155,    21,    37,
!     23,    88,    37,    37,    37,    43,    21,    56,    43,    43,
!     43,    21,    21,    42,    23,    21,    21,    23,    45,    42,
!     24,    25,   165,   166,   167,   168,   169,    90,    91,   187,
!     21,    94,    21,    42,    97,    93,    42,     5,     6,     7,
!    103,    97,   105,    21,   107,   108,    95,     5,     6,   112,
!     21,   107,   108,    92,    93,    24,    25,    21,    36,    37,
!     38,    21,    39,     4,    36,    14,    35,    36,    37,    36,
!     14,    45,   130,   131,   137,   138,   139,   140,   141,   142,
!    144,    46,   146,    21,   148,   134,   150,    21,    21,    21,
!    153,   130,   131,    21,   237,   238,   239,    21,   161,   162,
!     21,   159,    24,    25,    44,   161,   162,    46,    21,   172,
!    174,   175,    15,    35,    36,    46,   180,   181,    15,   158,
!    159,    21,    22,    23,     7,     9,    26,    27,    28,    29,
!     15,    31,    32,    33,    34,    30,    44,    15,    44,     7,
!     40,    41,     4,    30,    21,    15,    44,    21,    15,   212,
!     44,    15,    44,    44,   217,    15,     0,     0,   221,   222,
!    223,   224,   149,   236,    30,   221,   229,   183,     9,   172,
!     -1,    -1,   203,   229,    -1,    -1,    -1,   240,    -1,    -1,
!    244,   245,   246,   247,   240,   248,     1,    -1,     3,    -1,
!     -1,    -1,   248,     8,    -1,    10,    11,    12,    13,    -1,
      -1,    16,    -1,    18,    19,    -1,    21,    22,    23,    -1,
      -1,    26,    27,    28,    29,    -1,    31,    32,    33,    34,
!     -1,    -1,    37,    38,     3,    40,    41,    -1,    43,     8,
      45,    10,    11,    12,    13,    -1,    -1,    16,    -1,    18,
      19,    -1,    21,    22,    23,    -1,    -1,    26,    27,    28,
!     29,    -1,    31,    32,    33,    34,    -1,    -1,    37,    -1,
       3,    40,    41,    -1,    43,     8,    45,    10,    11,    12,
!     13,    -1,    -1,    16,    -1,    18,    19,    -1,    21,    22,
      23,    -1,    -1,    26,    27,    28,    29,    -1,    31,    32,
      33,    34,    -1,    -1,    -1,    -1,     3,    40,    41,    -1,
      43,     8,    45,    10,    11,    12,    13,    -1,    -1,    16,
!     -1,    -1,    19,    -1,    21,    22,    23,    -1,    -1,    26,
      27,    28,    29,    -1,    31,    32,    33,    34,    -1,    -1,
      -1,    -1,     3,    40,    41,    -1,    43,     8,    45,    10,
!     11,    12,    13,    -1,    -1,    16,    -1,    18,    -1,    -1,
      21,    22,    23,    -1,    -1,    26,    27,    28,    29,    -1,
!     31,    32,    33,    34,    -1,    -1,    -1,    -1,     3,    40,
      41,    -1,    43,     8,    45,    10,    11,    12,    13,    -1,
      -1,    16,    -1,    -1,    -1,    -1,    21,    22,    23,    -1,
      -1,    26,    27,    28,    29,    -1,    31,    32,    33,    34,
!     -1,    -1,    37,    -1,     3,    40,    41,    -1,    43,     8,
!     45,    10,    11,    12,    13,    -1,    -1,    16,    -1,    -1,
!     -1,    -1,    21,    22,    23,    -1,    -1,    26,    27,    28,
!     29,    -1,    31,    32,    33,    34,    -1,    -1,    -1,    -1,
!     -1,    40,    41,    -1,    43,    23,    45,    -1,    26,    27,
!     28,    29,    -1,    31,    32,    33,    34,    -1,    -1,    -1,
!     -1,    -1,    40,    41,    26,    27,    28,    29,    -1,    31,
!     -1,    33,    34,    -1,    -1,    -1,    -1,    -1,    40,    41
  };
  /* -*-C-*-  Note some compilers choke on comments on `#line' lines.  */
--- 421,575 ----
     178,    28,    29,    88,    30,    31,    32,    33,    34,    35,
      36,    37,    38,    39,   164,   170,   171,   172,   204,    46,
!     47,    99,   100,   212,    48,    40,   132,   101,    43,    44
  };
  
! static const short yypact[] = {   240,
!    -25,-32768,    -4,    41,    44,-32768,-32768,    49,   348,     0,
!    -31,-32768,   476,    53,    55,     3,    29,    61,    63,    66,
!     71,-32768,-32768,    76,    79,-32768,-32768,-32768,-32768,   165,
! -32768,   120,-32768,-32768,-32768,-32768,-32768,-32768,-32768,   -12,
!     89,-32768,    12,   384,-32768,-32768,    99,   276,-32768,    93,
!    103,    98,   143,   126,    12,   456,-32768,   127,   151,   153,
!     35,    43,   154,   155,   159,   160,   161,-32768,-32768,-32768,
  -32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,
! -32768,   140,   276,   137,-32768,-32768,-32768,   120,-32768,-32768,
! -32768,   312,   312,-32768,   456,    12,-32768,-32768,-32768,    86,
! -32768,    38,-32768,    -1,-32768,    16,-32768,-32768,   157,   -28,
!     12,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,
! -32768,-32768,-32768,-32768,-32768,-32768,    86,-32768,-32768,   276,
!    276,    15,    15,   420,    12,   128,-32768,-32768,-32768,-32768,
! -32768,-32768,     4,-32768,   164,-32768,    17,-32768,   164,-32768,
!    174,   189,-32768,-32768,   -28,-32768,-32768,   312,   312,    12,
! -32768,-32768,-32768,   201,   276,   276,   276,   276,   276,   200,
!    180,-32768,    -2,-32768,-32768,   196,-32768,    57,   168,-32768,
! -32768,   198,    57,   170,-32768,-32768,   -28,-32768,   209,   213,
! -32768,-32768,-32768,   142,   142,   142,-32768,-32768,   190,     1,
! -32768,-32768,   205,    40,   204,   177,-32768,-32768,-32768,-32768,
! -32768,-32768,-32768,   207,   183,-32768,-32768,-32768,-32768,-32768,
! -32768,-32768,-32768,-32768,-32768,-32768,    50,   210,-32768,-32768,
! -32768,    20,-32768,-32768,    30,   139,   276,   276,   276,-32768,
! -32768,-32768,   276,-32768,-32768,-32768,-32768,-32768,-32768,-32768,
!    276,   215,   188,   218,   191,-32768,-32768,-32768,-32768,-32768,
!    236,   237,-32768
  };
  
  static const short yypgoto[] = {-32768,
!     91,   -27,   214,-32768,-32768,-32768,-32768,-32768,-32768,-32768,
! -32768,-32768,-32768,  -107,     9,-32768,    74,-32768,    46,   -18,
!     -6,-32768,   -60,    64,   -22,-32768,    11,     6,    -7,   245
  };
  
  
! #define	YYLAST		517
  
  
! static const short yytable[] = {    52,
!     53,    55,   154,    83,    87,    42,   201,    82,    98,   226,
!     41,    45,   144,    58,    26,   145,    49,   174,   202,    57,
!     84,   202,   127,    70,    89,    71,   102,   104,   106,   148,
!    180,   110,   149,   244,    98,    98,    96,    98,    90,    91,
!     98,   146,   203,   246,    72,   203,   175,   188,   111,    73,
!     94,    74,    98,    98,   142,   115,    98,   116,   150,   181,
!    129,    50,   245,   118,    51,   119,    98,   130,   131,    54,
!     75,   134,   247,    68,    98,    69,   117,   208,   228,   219,
!    143,    76,   147,    77,   120,   229,    78,   135,   228,   155,
!    136,    79,   209,   210,   211,   240,    80,    42,    42,    81,
!    151,   152,    97,   133,   192,   193,   194,   195,   196,   137,
!    138,   107,    90,    91,   165,   166,   167,   168,   169,   173,
!    139,   140,   141,    92,    93,    83,   160,    83,   103,   182,
!    187,   184,   161,   162,   163,    42,    42,   176,   105,   179,
!    156,   157,    13,   248,   162,    14,    15,    16,    17,   200,
!     18,    19,    20,    21,   189,   190,   108,    83,    83,    24,
!     25,   214,   215,    42,    42,   137,   138,   205,   206,   133,
!    109,   113,   112,   114,   121,   122,   194,   195,   196,   123,
!    124,   125,   128,   126,   177,    85,    12,    13,   185,   232,
!     14,    15,    16,    17,   235,    18,    19,    20,    21,   237,
!    238,   239,   153,   186,    24,    25,   243,   191,   197,   198,
!    207,   213,   216,   218,   236,   220,   221,   251,   230,   225,
!    231,   233,   242,    83,    83,   202,   234,   254,   255,   257,
!    241,   258,   259,   250,   260,   262,   263,   252,   253,   183,
!      1,   256,     2,    86,   249,   199,   217,     3,   227,     4,
!      5,     6,     7,    56,     0,     8,     0,     9,    10,     0,
!     11,    12,    13,     0,     0,    14,    15,    16,    17,     0,
!     18,    19,    20,    21,     0,     0,    22,    23,     2,    24,
!     25,     0,    26,     3,    27,     4,     5,     6,     7,     0,
       0,     8,     0,     9,    10,     0,    11,    12,    13,     0,
       0,    14,    15,    16,    17,     0,    18,    19,    20,    21,
!      0,     0,    98,     0,     2,    24,    25,     0,    26,     3,
      27,     4,     5,     6,     7,     0,     0,     8,     0,     9,
      10,     0,    11,    12,    13,     0,     0,    14,    15,    16,
!     17,     0,    18,    19,    20,    21,     0,     0,     0,     0,
       2,    24,    25,     0,    26,     3,    27,     4,     5,     6,
!      7,     0,     0,     8,     0,     0,    10,     0,    11,    12,
      13,     0,     0,    14,    15,    16,    17,     0,    18,    19,
      20,    21,     0,     0,     0,     0,     2,    24,    25,     0,
      26,     3,    27,     4,     5,     6,     7,     0,     0,     8,
!      0,    95,     0,     0,    11,    12,    13,     0,     0,    14,
      15,    16,    17,     0,    18,    19,    20,    21,     0,     0,
       0,     0,     2,    24,    25,     0,    26,     3,    27,     4,
!      5,     6,     7,     0,     0,     8,     0,     0,     0,     0,
      11,    12,    13,     0,     0,    14,    15,    16,    17,     0,
!     18,    19,    20,    21,     0,     0,    98,     0,     2,    24,
      25,     0,    26,     3,    27,     4,     5,     6,     7,     0,
       0,     8,     0,     0,     0,     0,    11,    12,    13,     0,
       0,    14,    15,    16,    17,     0,    18,    19,    20,    21,
!      0,     0,     0,     0,     0,    24,    25,     0,    26,     0,
!     27,    59,    60,    61,    62,     0,    63,     0,    64,    65,
!      0,     0,     0,     0,     0,    66,    67
  };
  
! static const short yycheck[] = {     6,
!      7,     9,   110,    26,    32,     0,     9,    26,    37,     9,
!      0,    37,    14,    45,    43,    17,    21,    14,    21,    20,
!     27,    21,    83,    21,    37,    23,    49,    50,    51,    14,
!     14,    54,    17,    14,    37,    37,    44,    37,    24,    25,
!     37,    43,    45,    14,    42,    45,    43,   155,    56,    21,
!     39,    23,    37,    37,    17,    21,    37,    23,    43,    43,
!     88,    21,    43,    21,    21,    23,    37,    90,    91,    21,
!     42,    94,    43,    21,    37,    21,    42,    21,    39,   187,
!    103,    21,   105,    21,    42,    46,    21,    95,    39,   112,
!     97,    21,    36,    37,    38,    46,    21,    92,    93,    21,
!    107,   108,     4,    93,   165,   166,   167,   168,   169,    24,
!     25,    14,    24,    25,   137,   138,   139,   140,   141,   142,
!     35,    36,    37,    35,    36,   148,   134,   150,    36,   148,
!    153,   150,     5,     6,     7,   130,   131,   144,    36,   146,
!    130,   131,    23,     5,     6,    26,    27,    28,    29,   172,
!     31,    32,    33,    34,   161,   162,    14,   180,   181,    40,
!     41,   180,   181,   158,   159,    24,    25,   174,   175,   159,
!     45,    21,    46,    21,    21,    21,   237,   238,   239,    21,
!     21,    21,    46,    44,    21,    21,    22,    23,    15,   212,
!     26,    27,    28,    29,   217,    31,    32,    33,    34,   222,
!    223,   224,    46,    15,    40,    41,   229,     7,     9,    30,
!     15,    44,    15,    44,   221,     7,     4,   240,    15,    30,
!     44,    15,   229,   246,   247,    21,    44,   246,   247,    15,
!     21,    44,    15,   240,    44,     0,     0,   244,   245,   149,
!      1,   248,     3,    30,   236,   172,   183,     8,   203,    10,
!     11,    12,    13,     9,    -1,    16,    -1,    18,    19,    -1,
!     21,    22,    23,    -1,    -1,    26,    27,    28,    29,    -1,
!     31,    32,    33,    34,    -1,    -1,    37,    38,     3,    40,
!     41,    -1,    43,     8,    45,    10,    11,    12,    13,    -1,
      -1,    16,    -1,    18,    19,    -1,    21,    22,    23,    -1,
      -1,    26,    27,    28,    29,    -1,    31,    32,    33,    34,
!     -1,    -1,    37,    -1,     3,    40,    41,    -1,    43,     8,
      45,    10,    11,    12,    13,    -1,    -1,    16,    -1,    18,
      19,    -1,    21,    22,    23,    -1,    -1,    26,    27,    28,
!     29,    -1,    31,    32,    33,    34,    -1,    -1,    -1,    -1,
       3,    40,    41,    -1,    43,     8,    45,    10,    11,    12,
!     13,    -1,    -1,    16,    -1,    -1,    19,    -1,    21,    22,
      23,    -1,    -1,    26,    27,    28,    29,    -1,    31,    32,
      33,    34,    -1,    -1,    -1,    -1,     3,    40,    41,    -1,
      43,     8,    45,    10,    11,    12,    13,    -1,    -1,    16,
!     -1,    18,    -1,    -1,    21,    22,    23,    -1,    -1,    26,
      27,    28,    29,    -1,    31,    32,    33,    34,    -1,    -1,
      -1,    -1,     3,    40,    41,    -1,    43,     8,    45,    10,
!     11,    12,    13,    -1,    -1,    16,    -1,    -1,    -1,    -1,
      21,    22,    23,    -1,    -1,    26,    27,    28,    29,    -1,
!     31,    32,    33,    34,    -1,    -1,    37,    -1,     3,    40,
      41,    -1,    43,     8,    45,    10,    11,    12,    13,    -1,
      -1,    16,    -1,    -1,    -1,    -1,    21,    22,    23,    -1,
      -1,    26,    27,    28,    29,    -1,    31,    32,    33,    34,
!     -1,    -1,    -1,    -1,    -1,    40,    41,    -1,    43,    -1,
!     45,    26,    27,    28,    29,    -1,    31,    -1,    33,    34,
!     -1,    -1,    -1,    -1,    -1,    40,    41
  };
  /* -*-C-*-  Note some compilers choke on comments on `#line' lines.  */
***************
*** 1071,1075 ****
  
  case 1:
! #line 210 "./parse.y"
  {
  			  /* Case of regular command.  Discard the error
--- 1072,1076 ----
  
  case 1:
! #line 215 "./parse.y"
  {
  			  /* Case of regular command.  Discard the error
***************
*** 1082,1086 ****
      break;}
  case 2:
! #line 219 "./parse.y"
  {
  			  /* Case of regular command, but not a very
--- 1083,1087 ----
      break;}
  case 2:
! #line 224 "./parse.y"
  {
  			  /* Case of regular command, but not a very
***************
*** 1091,1095 ****
      break;}
  case 3:
! #line 226 "./parse.y"
  {
  			  /* Error during parsing.  Return NULL command. */
--- 1092,1096 ----
      break;}
  case 3:
! #line 231 "./parse.y"
  {
  			  /* Error during parsing.  Return NULL command. */
***************
*** 1108,1112 ****
      break;}
  case 4:
! #line 241 "./parse.y"
  {
  			  /* Case of EOF seen by itself.  Do ignoreeof or
--- 1109,1113 ----
      break;}
  case 4:
! #line 246 "./parse.y"
  {
  			  /* Case of EOF seen by itself.  Do ignoreeof or
***************
*** 1118,1130 ****
      break;}
  case 5:
! #line 251 "./parse.y"
  { yyval.word_list = make_word_list (yyvsp[0].word, (WORD_LIST *)NULL); ;
      break;}
  case 6:
! #line 253 "./parse.y"
  { yyval.word_list = make_word_list (yyvsp[0].word, yyvsp[-1].word_list); ;
      break;}
  case 7:
! #line 257 "./parse.y"
  {
  			  redir.filename = yyvsp[0].word;
--- 1119,1131 ----
      break;}
  case 5:
! #line 256 "./parse.y"
  { yyval.word_list = make_word_list (yyvsp[0].word, (WORD_LIST *)NULL); ;
      break;}
  case 6:
! #line 258 "./parse.y"
  { yyval.word_list = make_word_list (yyvsp[0].word, yyvsp[-1].word_list); ;
      break;}
  case 7:
! #line 262 "./parse.y"
  {
  			  redir.filename = yyvsp[0].word;
***************
*** 1133,1137 ****
      break;}
  case 8:
! #line 262 "./parse.y"
  {
  			  redir.filename = yyvsp[0].word;
--- 1134,1138 ----
      break;}
  case 8:
! #line 267 "./parse.y"
  {
  			  redir.filename = yyvsp[0].word;
***************
*** 1140,1144 ****
      break;}
  case 9:
! #line 267 "./parse.y"
  {
  			  redir.filename = yyvsp[0].word;
--- 1141,1145 ----
      break;}
  case 9:
! #line 272 "./parse.y"
  {
  			  redir.filename = yyvsp[0].word;
***************
*** 1147,1151 ****
      break;}
  case 10:
! #line 272 "./parse.y"
  {
  			  redir.filename = yyvsp[0].word;
--- 1148,1152 ----
      break;}
  case 10:
! #line 277 "./parse.y"
  {
  			  redir.filename = yyvsp[0].word;
***************
*** 1154,1158 ****
      break;}
  case 11:
! #line 277 "./parse.y"
  {
  			  redir.filename = yyvsp[0].word;
--- 1155,1159 ----
      break;}
  case 11:
! #line 282 "./parse.y"
  {
  			  redir.filename = yyvsp[0].word;
***************
*** 1161,1165 ****
      break;}
  case 12:
! #line 282 "./parse.y"
  {
  			  redir.filename = yyvsp[0].word;
--- 1162,1166 ----
      break;}
  case 12:
! #line 287 "./parse.y"
  {
  			  redir.filename = yyvsp[0].word;
***************
*** 1168,1172 ****
      break;}
  case 13:
! #line 287 "./parse.y"
  {
  			  redir.filename = yyvsp[0].word;
--- 1169,1173 ----
      break;}
  case 13:
! #line 292 "./parse.y"
  {
  			  redir.filename = yyvsp[0].word;
***************
*** 1176,1180 ****
      break;}
  case 14:
! #line 293 "./parse.y"
  {
  			  redir.filename = yyvsp[0].word;
--- 1177,1181 ----
      break;}
  case 14:
! #line 298 "./parse.y"
  {
  			  redir.filename = yyvsp[0].word;
***************
*** 1184,1188 ****
      break;}
  case 15:
! #line 299 "./parse.y"
  {
  			  redir.dest = yyvsp[0].number;
--- 1185,1189 ----
      break;}
  case 15:
! #line 304 "./parse.y"
  {
  			  redir.dest = yyvsp[0].number;
***************
*** 1191,1195 ****
      break;}
  case 16:
! #line 304 "./parse.y"
  {
  			  redir.dest = yyvsp[0].number;
--- 1192,1196 ----
      break;}
  case 16:
! #line 309 "./parse.y"
  {
  			  redir.dest = yyvsp[0].number;
***************
*** 1198,1202 ****
      break;}
  case 17:
! #line 309 "./parse.y"
  {
  			  redir.dest = yyvsp[0].number;
--- 1199,1203 ----
      break;}
  case 17:
! #line 314 "./parse.y"
  {
  			  redir.dest = yyvsp[0].number;
***************
*** 1205,1209 ****
      break;}
  case 18:
! #line 314 "./parse.y"
  {
  			  redir.dest = yyvsp[0].number;
--- 1206,1210 ----
      break;}
  case 18:
! #line 319 "./parse.y"
  {
  			  redir.dest = yyvsp[0].number;
***************
*** 1212,1216 ****
      break;}
  case 19:
! #line 319 "./parse.y"
  {
  			  redir.filename = yyvsp[0].word;
--- 1213,1217 ----
      break;}
  case 19:
! #line 324 "./parse.y"
  {
  			  redir.filename = yyvsp[0].word;
***************
*** 1219,1223 ****
      break;}
  case 20:
! #line 324 "./parse.y"
  {
  			  redir.filename = yyvsp[0].word;
--- 1220,1224 ----
      break;}
  case 20:
! #line 329 "./parse.y"
  {
  			  redir.filename = yyvsp[0].word;
***************
*** 1226,1230 ****
      break;}
  case 21:
! #line 329 "./parse.y"
  {
  			  redir.filename = yyvsp[0].word;
--- 1227,1231 ----
      break;}
  case 21:
! #line 334 "./parse.y"
  {
  			  redir.filename = yyvsp[0].word;
***************
*** 1233,1237 ****
      break;}
  case 22:
! #line 334 "./parse.y"
  {
  			  redir.filename = yyvsp[0].word;
--- 1234,1238 ----
      break;}
  case 22:
! #line 339 "./parse.y"
  {
  			  redir.filename = yyvsp[0].word;
***************
*** 1240,1244 ****
      break;}
  case 23:
! #line 339 "./parse.y"
  {
  			  redir.filename = yyvsp[0].word;
--- 1241,1245 ----
      break;}
  case 23:
! #line 344 "./parse.y"
  {
  			  redir.filename = yyvsp[0].word;
***************
*** 1249,1253 ****
      break;}
  case 24:
! #line 346 "./parse.y"
  {
  			  redir.filename = yyvsp[0].word;
--- 1250,1254 ----
      break;}
  case 24:
! #line 351 "./parse.y"
  {
  			  redir.filename = yyvsp[0].word;
***************
*** 1258,1262 ****
      break;}
  case 25:
! #line 353 "./parse.y"
  {
  			  redir.dest = 0L;
--- 1259,1263 ----
      break;}
  case 25:
! #line 358 "./parse.y"
  {
  			  redir.dest = 0L;
***************
*** 1265,1269 ****
      break;}
  case 26:
! #line 358 "./parse.y"
  {
  			  redir.dest = 0L;
--- 1266,1270 ----
      break;}
  case 26:
! #line 363 "./parse.y"
  {
  			  redir.dest = 0L;
***************
*** 1272,1276 ****
      break;}
  case 27:
! #line 363 "./parse.y"
  {
  			  redir.dest = 0L;
--- 1273,1277 ----
      break;}
  case 27:
! #line 368 "./parse.y"
  {
  			  redir.dest = 0L;
***************
*** 1279,1283 ****
      break;}
  case 28:
! #line 368 "./parse.y"
  {
  			  redir.dest = 0L;
--- 1280,1284 ----
      break;}
  case 28:
! #line 373 "./parse.y"
  {
  			  redir.dest = 0L;
***************
*** 1286,1290 ****
      break;}
  case 29:
! #line 373 "./parse.y"
  {
  			  redir.filename = yyvsp[0].word;
--- 1287,1291 ----
      break;}
  case 29:
! #line 378 "./parse.y"
  {
  			  redir.filename = yyvsp[0].word;
***************
*** 1293,1297 ****
      break;}
  case 30:
! #line 378 "./parse.y"
  {
  			  redir.filename = yyvsp[0].word;
--- 1294,1298 ----
      break;}
  case 30:
! #line 383 "./parse.y"
  {
  			  redir.filename = yyvsp[0].word;
***************
*** 1300,1304 ****
      break;}
  case 31:
! #line 383 "./parse.y"
  {
  			  redir.filename = yyvsp[0].word;
--- 1301,1305 ----
      break;}
  case 31:
! #line 388 "./parse.y"
  {
  			  redir.filename = yyvsp[0].word;
***************
*** 1307,1311 ****
      break;}
  case 32:
! #line 388 "./parse.y"
  {
  			  redir.filename = yyvsp[0].word;
--- 1308,1312 ----
      break;}
  case 32:
! #line 393 "./parse.y"
  {
  			  redir.filename = yyvsp[0].word;
***************
*** 1314,1318 ****
      break;}
  case 33:
! #line 393 "./parse.y"
  {
  			  redir.filename = yyvsp[0].word;
--- 1315,1319 ----
      break;}
  case 33:
! #line 398 "./parse.y"
  {
  			  redir.filename = yyvsp[0].word;
***************
*** 1321,1337 ****
      break;}
  case 34:
! #line 400 "./parse.y"
  { yyval.element.word = yyvsp[0].word; yyval.element.redirect = 0; ;
      break;}
  case 35:
! #line 402 "./parse.y"
  { yyval.element.word = yyvsp[0].word; yyval.element.redirect = 0; ;
      break;}
  case 36:
! #line 404 "./parse.y"
  { yyval.element.redirect = yyvsp[0].redirect; yyval.element.word = 0; ;
      break;}
  case 37:
! #line 408 "./parse.y"
  {
  			  yyval.redirect = yyvsp[0].redirect;
--- 1322,1338 ----
      break;}
  case 34:
! #line 405 "./parse.y"
  { yyval.element.word = yyvsp[0].word; yyval.element.redirect = 0; ;
      break;}
  case 35:
! #line 407 "./parse.y"
  { yyval.element.word = yyvsp[0].word; yyval.element.redirect = 0; ;
      break;}
  case 36:
! #line 409 "./parse.y"
  { yyval.element.redirect = yyvsp[0].redirect; yyval.element.word = 0; ;
      break;}
  case 37:
! #line 413 "./parse.y"
  {
  			  yyval.redirect = yyvsp[0].redirect;
***************
*** 1339,1343 ****
      break;}
  case 38:
! #line 412 "./parse.y"
  {
  			  register REDIRECT *t;
--- 1340,1344 ----
      break;}
  case 38:
! #line 417 "./parse.y"
  {
  			  register REDIRECT *t;
***************
*** 1350,1370 ****
      break;}
  case 39:
! #line 423 "./parse.y"
  { yyval.command = make_simple_command (yyvsp[0].element, (COMMAND *)NULL); ;
      break;}
  case 40:
! #line 425 "./parse.y"
  { yyval.command = make_simple_command (yyvsp[0].element, yyvsp[-1].command); ;
      break;}
  case 41:
! #line 429 "./parse.y"
  { yyval.command = clean_simple_command (yyvsp[0].command); ;
      break;}
  case 42:
! #line 431 "./parse.y"
  { yyval.command = yyvsp[0].command; ;
      break;}
  case 43:
! #line 433 "./parse.y"
  {
  			  COMMAND *tc;
--- 1351,1371 ----
      break;}
  case 39:
! #line 428 "./parse.y"
  { yyval.command = make_simple_command (yyvsp[0].element, (COMMAND *)NULL); ;
      break;}
  case 40:
! #line 430 "./parse.y"
  { yyval.command = make_simple_command (yyvsp[0].element, yyvsp[-1].command); ;
      break;}
  case 41:
! #line 434 "./parse.y"
  { yyval.command = clean_simple_command (yyvsp[0].command); ;
      break;}
  case 42:
! #line 436 "./parse.y"
  { yyval.command = yyvsp[0].command; ;
      break;}
  case 43:
! #line 438 "./parse.y"
  {
  			  COMMAND *tc;
***************
*** 1395,1459 ****
      break;}
  case 44:
! #line 462 "./parse.y"
  { yyval.command = yyvsp[0].command; ;
      break;}
  case 45:
! #line 464 "./parse.y"
  { yyval.command = yyvsp[0].command; ;
      break;}
  case 46:
! #line 466 "./parse.y"
  { yyval.command = make_while_command (yyvsp[-3].command, yyvsp[-1].command); ;
      break;}
  case 47:
! #line 468 "./parse.y"
  { yyval.command = make_until_command (yyvsp[-3].command, yyvsp[-1].command); ;
      break;}
  case 48:
! #line 470 "./parse.y"
  { yyval.command = yyvsp[0].command; ;
      break;}
  case 49:
! #line 472 "./parse.y"
  { yyval.command = yyvsp[0].command; ;
      break;}
  case 50:
! #line 474 "./parse.y"
  { yyval.command = yyvsp[0].command; ;
      break;}
  case 51:
! #line 476 "./parse.y"
  { yyval.command = yyvsp[0].command; ;
      break;}
  case 52:
! #line 478 "./parse.y"
  { yyval.command = yyvsp[0].command; ;
      break;}
  case 53:
! #line 482 "./parse.y"
  { yyval.command = make_for_command (yyvsp[-4].word, add_string_to_list ("\"$@\"", (WORD_LIST *)NULL), yyvsp[-1].command); ;
      break;}
  case 54:
! #line 484 "./parse.y"
  { yyval.command = make_for_command (yyvsp[-4].word, add_string_to_list ("$@", (WORD_LIST *)NULL), yyvsp[-1].command); ;
      break;}
  case 55:
! #line 486 "./parse.y"
  { yyval.command = make_for_command (yyvsp[-5].word, add_string_to_list ("\"$@\"", (WORD_LIST *)NULL), yyvsp[-1].command); ;
      break;}
  case 56:
! #line 488 "./parse.y"
  { yyval.command = make_for_command (yyvsp[-5].word, add_string_to_list ("\"$@\"", (WORD_LIST *)NULL), yyvsp[-1].command); ;
      break;}
  case 57:
! #line 490 "./parse.y"
  { yyval.command = make_for_command (yyvsp[-8].word, REVERSE_LIST (yyvsp[-5].word_list, WORD_LIST *), yyvsp[-1].command); ;
      break;}
  case 58:
! #line 492 "./parse.y"
  { yyval.command = make_for_command (yyvsp[-8].word, REVERSE_LIST (yyvsp[-5].word_list, WORD_LIST *), yyvsp[-1].command); ;
      break;}
  case 59:
! #line 496 "./parse.y"
  {
  			  yyval.command = make_select_command (yyvsp[-4].word, add_string_to_list ("\"$@\"", (WORD_LIST *)NULL), yyvsp[-1].command);
--- 1396,1460 ----
      break;}
  case 44:
! #line 467 "./parse.y"
  { yyval.command = yyvsp[0].command; ;
      break;}
  case 45:
! #line 469 "./parse.y"
  { yyval.command = yyvsp[0].command; ;
      break;}
  case 46:
! #line 471 "./parse.y"
  { yyval.command = make_while_command (yyvsp[-3].command, yyvsp[-1].command); ;
      break;}
  case 47:
! #line 473 "./parse.y"
  { yyval.command = make_until_command (yyvsp[-3].command, yyvsp[-1].command); ;
      break;}
  case 48:
! #line 475 "./parse.y"
  { yyval.command = yyvsp[0].command; ;
      break;}
  case 49:
! #line 477 "./parse.y"
  { yyval.command = yyvsp[0].command; ;
      break;}
  case 50:
! #line 479 "./parse.y"
  { yyval.command = yyvsp[0].command; ;
      break;}
  case 51:
! #line 481 "./parse.y"
  { yyval.command = yyvsp[0].command; ;
      break;}
  case 52:
! #line 483 "./parse.y"
  { yyval.command = yyvsp[0].command; ;
      break;}
  case 53:
! #line 487 "./parse.y"
  { yyval.command = make_for_command (yyvsp[-4].word, add_string_to_list ("\"$@\"", (WORD_LIST *)NULL), yyvsp[-1].command); ;
      break;}
  case 54:
! #line 489 "./parse.y"
  { yyval.command = make_for_command (yyvsp[-4].word, add_string_to_list ("$@", (WORD_LIST *)NULL), yyvsp[-1].command); ;
      break;}
  case 55:
! #line 491 "./parse.y"
  { yyval.command = make_for_command (yyvsp[-5].word, add_string_to_list ("\"$@\"", (WORD_LIST *)NULL), yyvsp[-1].command); ;
      break;}
  case 56:
! #line 493 "./parse.y"
  { yyval.command = make_for_command (yyvsp[-5].word, add_string_to_list ("\"$@\"", (WORD_LIST *)NULL), yyvsp[-1].command); ;
      break;}
  case 57:
! #line 495 "./parse.y"
  { yyval.command = make_for_command (yyvsp[-8].word, REVERSE_LIST (yyvsp[-5].word_list, WORD_LIST *), yyvsp[-1].command); ;
      break;}
  case 58:
! #line 497 "./parse.y"
  { yyval.command = make_for_command (yyvsp[-8].word, REVERSE_LIST (yyvsp[-5].word_list, WORD_LIST *), yyvsp[-1].command); ;
      break;}
  case 59:
! #line 501 "./parse.y"
  {
  			  yyval.command = make_select_command (yyvsp[-4].word, add_string_to_list ("\"$@\"", (WORD_LIST *)NULL), yyvsp[-1].command);
***************
*** 1461,1465 ****
      break;}
  case 60:
! #line 500 "./parse.y"
  {
  			  yyval.command = make_select_command (yyvsp[-4].word, add_string_to_list ("$@", (WORD_LIST *)NULL), yyvsp[-1].command);
--- 1462,1466 ----
      break;}
  case 60:
! #line 505 "./parse.y"
  {
  			  yyval.command = make_select_command (yyvsp[-4].word, add_string_to_list ("$@", (WORD_LIST *)NULL), yyvsp[-1].command);
***************
*** 1467,1471 ****
      break;}
  case 61:
! #line 504 "./parse.y"
  {
  			  yyval.command = make_select_command (yyvsp[-5].word, add_string_to_list ("\"$@\"", (WORD_LIST *)NULL), yyvsp[-1].command);
--- 1468,1472 ----
      break;}
  case 61:
! #line 509 "./parse.y"
  {
  			  yyval.command = make_select_command (yyvsp[-5].word, add_string_to_list ("\"$@\"", (WORD_LIST *)NULL), yyvsp[-1].command);
***************
*** 1473,1477 ****
      break;}
  case 62:
! #line 508 "./parse.y"
  {
  			  yyval.command = make_select_command (yyvsp[-5].word, add_string_to_list ("\"$@\"", (WORD_LIST *)NULL), yyvsp[-1].command);
--- 1474,1478 ----
      break;}
  case 62:
! #line 513 "./parse.y"
  {
  			  yyval.command = make_select_command (yyvsp[-5].word, add_string_to_list ("\"$@\"", (WORD_LIST *)NULL), yyvsp[-1].command);
***************
*** 1479,1483 ****
      break;}
  case 63:
! #line 512 "./parse.y"
  {
  			  yyval.command = make_select_command (yyvsp[-8].word, (WORD_LIST *)reverse_list (yyvsp[-5].word_list), yyvsp[-1].command);
--- 1480,1484 ----
      break;}
  case 63:
! #line 517 "./parse.y"
  {
  			  yyval.command = make_select_command (yyvsp[-8].word, (WORD_LIST *)reverse_list (yyvsp[-5].word_list), yyvsp[-1].command);
***************
*** 1485,1489 ****
      break;}
  case 64:
! #line 516 "./parse.y"
  {
  			  yyval.command = make_select_command (yyvsp[-8].word, (WORD_LIST *)reverse_list (yyvsp[-5].word_list), yyvsp[-1].command);
--- 1486,1490 ----
      break;}
  case 64:
! #line 521 "./parse.y"
  {
  			  yyval.command = make_select_command (yyvsp[-8].word, (WORD_LIST *)reverse_list (yyvsp[-5].word_list), yyvsp[-1].command);
***************
*** 1491,1583 ****
      break;}
  case 65:
! #line 522 "./parse.y"
  { yyval.command = make_case_command (yyvsp[-4].word, (PATTERN_LIST *)NULL); ;
      break;}
  case 66:
! #line 524 "./parse.y"
  { yyval.command = make_case_command (yyvsp[-5].word, yyvsp[-2].pattern); ;
      break;}
  case 67:
! #line 526 "./parse.y"
  { yyval.command = make_case_command (yyvsp[-4].word, yyvsp[-1].pattern); ;
      break;}
  case 68:
! #line 530 "./parse.y"
  { yyval.command = make_function_def (yyvsp[-4].word, yyvsp[0].command, function_dstart, function_bstart); ;
      break;}
  case 69:
! #line 534 "./parse.y"
  { yyval.command = make_function_def (yyvsp[-4].word, yyvsp[0].command, function_dstart, function_bstart); ;
      break;}
  case 70:
! #line 537 "./parse.y"
  { yyval.command = make_function_def (yyvsp[-2].word, yyvsp[0].command, function_dstart, function_bstart); ;
      break;}
  case 71:
! #line 541 "./parse.y"
  { yyvsp[-1].command->flags |= CMD_WANT_SUBSHELL; yyval.command = yyvsp[-1].command; ;
      break;}
  case 72:
! #line 545 "./parse.y"
  { yyval.command = make_if_command (yyvsp[-3].command, yyvsp[-1].command, (COMMAND *)NULL); ;
      break;}
  case 73:
! #line 547 "./parse.y"
  { yyval.command = make_if_command (yyvsp[-5].command, yyvsp[-3].command, yyvsp[-1].command); ;
      break;}
  case 74:
! #line 549 "./parse.y"
  { yyval.command = make_if_command (yyvsp[-4].command, yyvsp[-2].command, yyvsp[-1].command); ;
      break;}
  case 75:
! #line 554 "./parse.y"
  { yyval.command = make_group_command (yyvsp[-1].command); ;
      break;}
  case 76:
! #line 558 "./parse.y"
  { yyval.command = make_if_command (yyvsp[-2].command, yyvsp[0].command, (COMMAND *)NULL); ;
      break;}
  case 77:
! #line 560 "./parse.y"
  { yyval.command = make_if_command (yyvsp[-4].command, yyvsp[-2].command, yyvsp[0].command); ;
      break;}
  case 78:
! #line 562 "./parse.y"
  { yyval.command = make_if_command (yyvsp[-3].command, yyvsp[-1].command, yyvsp[0].command); ;
      break;}
  case 80:
! #line 567 "./parse.y"
  { yyvsp[0].pattern->next = yyvsp[-1].pattern; yyval.pattern = yyvsp[0].pattern; ;
      break;}
  case 81:
! #line 571 "./parse.y"
  { yyval.pattern = make_pattern_list (yyvsp[-2].word_list, yyvsp[0].command); ;
      break;}
  case 82:
! #line 573 "./parse.y"
  { yyval.pattern = make_pattern_list (yyvsp[-2].word_list, (COMMAND *)NULL); ;
      break;}
  case 83:
! #line 575 "./parse.y"
  { yyval.pattern = make_pattern_list (yyvsp[-2].word_list, yyvsp[0].command); ;
      break;}
  case 84:
! #line 577 "./parse.y"
  { yyval.pattern = make_pattern_list (yyvsp[-2].word_list, (COMMAND *)NULL); ;
      break;}
  case 86:
! #line 582 "./parse.y"
  { yyvsp[-1].pattern->next = yyvsp[-2].pattern; yyval.pattern = yyvsp[-1].pattern; ;
      break;}
  case 87:
! #line 586 "./parse.y"
  { yyval.word_list = make_word_list (yyvsp[0].word, (WORD_LIST *)NULL); ;
      break;}
  case 88:
! #line 588 "./parse.y"
  { yyval.word_list = make_word_list (yyvsp[0].word, yyvsp[-2].word_list); ;
      break;}
  case 89:
! #line 597 "./parse.y"
  {
  			  yyval.command = yyvsp[0].command;
--- 1492,1584 ----
      break;}
  case 65:
! #line 527 "./parse.y"
  { yyval.command = make_case_command (yyvsp[-4].word, (PATTERN_LIST *)NULL); ;
      break;}
  case 66:
! #line 529 "./parse.y"
  { yyval.command = make_case_command (yyvsp[-5].word, yyvsp[-2].pattern); ;
      break;}
  case 67:
! #line 531 "./parse.y"
  { yyval.command = make_case_command (yyvsp[-4].word, yyvsp[-1].pattern); ;
      break;}
  case 68:
! #line 535 "./parse.y"
  { yyval.command = make_function_def (yyvsp[-4].word, yyvsp[0].command, function_dstart, function_bstart); ;
      break;}
  case 69:
! #line 539 "./parse.y"
  { yyval.command = make_function_def (yyvsp[-4].word, yyvsp[0].command, function_dstart, function_bstart); ;
      break;}
  case 70:
! #line 542 "./parse.y"
  { yyval.command = make_function_def (yyvsp[-2].word, yyvsp[0].command, function_dstart, function_bstart); ;
      break;}
  case 71:
! #line 546 "./parse.y"
  { yyvsp[-1].command->flags |= CMD_WANT_SUBSHELL; yyval.command = yyvsp[-1].command; ;
      break;}
  case 72:
! #line 550 "./parse.y"
  { yyval.command = make_if_command (yyvsp[-3].command, yyvsp[-1].command, (COMMAND *)NULL); ;
      break;}
  case 73:
! #line 552 "./parse.y"
  { yyval.command = make_if_command (yyvsp[-5].command, yyvsp[-3].command, yyvsp[-1].command); ;
      break;}
  case 74:
! #line 554 "./parse.y"
  { yyval.command = make_if_command (yyvsp[-4].command, yyvsp[-2].command, yyvsp[-1].command); ;
      break;}
  case 75:
! #line 559 "./parse.y"
  { yyval.command = make_group_command (yyvsp[-1].command); ;
      break;}
  case 76:
! #line 563 "./parse.y"
  { yyval.command = make_if_command (yyvsp[-2].command, yyvsp[0].command, (COMMAND *)NULL); ;
      break;}
  case 77:
! #line 565 "./parse.y"
  { yyval.command = make_if_command (yyvsp[-4].command, yyvsp[-2].command, yyvsp[0].command); ;
      break;}
  case 78:
! #line 567 "./parse.y"
  { yyval.command = make_if_command (yyvsp[-3].command, yyvsp[-1].command, yyvsp[0].command); ;
      break;}
  case 80:
! #line 572 "./parse.y"
  { yyvsp[0].pattern->next = yyvsp[-1].pattern; yyval.pattern = yyvsp[0].pattern; ;
      break;}
  case 81:
! #line 576 "./parse.y"
  { yyval.pattern = make_pattern_list (yyvsp[-2].word_list, yyvsp[0].command); ;
      break;}
  case 82:
! #line 578 "./parse.y"
  { yyval.pattern = make_pattern_list (yyvsp[-2].word_list, (COMMAND *)NULL); ;
      break;}
  case 83:
! #line 580 "./parse.y"
  { yyval.pattern = make_pattern_list (yyvsp[-2].word_list, yyvsp[0].command); ;
      break;}
  case 84:
! #line 582 "./parse.y"
  { yyval.pattern = make_pattern_list (yyvsp[-2].word_list, (COMMAND *)NULL); ;
      break;}
  case 86:
! #line 587 "./parse.y"
  { yyvsp[-1].pattern->next = yyvsp[-2].pattern; yyval.pattern = yyvsp[-1].pattern; ;
      break;}
  case 87:
! #line 591 "./parse.y"
  { yyval.word_list = make_word_list (yyvsp[0].word, (WORD_LIST *)NULL); ;
      break;}
  case 88:
! #line 593 "./parse.y"
  { yyval.word_list = make_word_list (yyvsp[0].word, yyvsp[-2].word_list); ;
      break;}
  case 89:
! #line 602 "./parse.y"
  {
  			  yyval.command = yyvsp[0].command;
***************
*** 1587,1591 ****
      break;}
  case 91:
! #line 606 "./parse.y"
  {
  			  yyval.command = yyvsp[0].command;
--- 1588,1592 ----
      break;}
  case 91:
! #line 611 "./parse.y"
  {
  			  yyval.command = yyvsp[0].command;
***************
*** 1593,1597 ****
      break;}
  case 93:
! #line 613 "./parse.y"
  {
  			  if (yyvsp[-2].command->type == cm_connection)
--- 1594,1598 ----
      break;}
  case 93:
! #line 618 "./parse.y"
  {
  			  if (yyvsp[-2].command->type == cm_connection)
***************
*** 1602,1614 ****
      break;}
  case 95:
! #line 624 "./parse.y"
  { yyval.command = command_connect (yyvsp[-3].command, yyvsp[0].command, AND_AND); ;
      break;}
  case 96:
! #line 626 "./parse.y"
  { yyval.command = command_connect (yyvsp[-3].command, yyvsp[0].command, OR_OR); ;
      break;}
  case 97:
! #line 628 "./parse.y"
  {
  			  if (yyvsp[-3].command->type == cm_connection)
--- 1603,1615 ----
      break;}
  case 95:
! #line 629 "./parse.y"
  { yyval.command = command_connect (yyvsp[-3].command, yyvsp[0].command, AND_AND); ;
      break;}
  case 96:
! #line 631 "./parse.y"
  { yyval.command = command_connect (yyvsp[-3].command, yyvsp[0].command, OR_OR); ;
      break;}
  case 97:
! #line 633 "./parse.y"
  {
  			  if (yyvsp[-3].command->type == cm_connection)
***************
*** 1619,1635 ****
      break;}
  case 98:
! #line 635 "./parse.y"
  { yyval.command = command_connect (yyvsp[-3].command, yyvsp[0].command, ';'); ;
      break;}
  case 99:
! #line 637 "./parse.y"
  { yyval.command = command_connect (yyvsp[-3].command, yyvsp[0].command, ';'); ;
      break;}
  case 100:
! #line 639 "./parse.y"
  { yyval.command = yyvsp[0].command; ;
      break;}
  case 106:
! #line 658 "./parse.y"
  {
  			  yyval.command = yyvsp[0].command;
--- 1620,1636 ----
      break;}
  case 98:
! #line 640 "./parse.y"
  { yyval.command = command_connect (yyvsp[-3].command, yyvsp[0].command, ';'); ;
      break;}
  case 99:
! #line 642 "./parse.y"
  { yyval.command = command_connect (yyvsp[-3].command, yyvsp[0].command, ';'); ;
      break;}
  case 100:
! #line 644 "./parse.y"
  { yyval.command = yyvsp[0].command; ;
      break;}
  case 106:
! #line 663 "./parse.y"
  {
  			  yyval.command = yyvsp[0].command;
***************
*** 1639,1643 ****
      break;}
  case 107:
! #line 664 "./parse.y"
  {
  			  if (yyvsp[-1].command->type == cm_connection)
--- 1640,1644 ----
      break;}
  case 107:
! #line 669 "./parse.y"
  {
  			  if (yyvsp[-1].command->type == cm_connection)
***************
*** 1650,1654 ****
      break;}
  case 108:
! #line 673 "./parse.y"
  {
  			  yyval.command = yyvsp[-1].command;
--- 1651,1655 ----
      break;}
  case 108:
! #line 678 "./parse.y"
  {
  			  yyval.command = yyvsp[-1].command;
***************
*** 1658,1670 ****
      break;}
  case 109:
! #line 681 "./parse.y"
  { yyval.command = command_connect (yyvsp[-3].command, yyvsp[0].command, AND_AND); ;
      break;}
  case 110:
! #line 683 "./parse.y"
  { yyval.command = command_connect (yyvsp[-3].command, yyvsp[0].command, OR_OR); ;
      break;}
  case 111:
! #line 685 "./parse.y"
  {
  			  if (yyvsp[-2].command->type == cm_connection)
--- 1659,1671 ----
      break;}
  case 109:
! #line 686 "./parse.y"
  { yyval.command = command_connect (yyvsp[-3].command, yyvsp[0].command, AND_AND); ;
      break;}
  case 110:
! #line 688 "./parse.y"
  { yyval.command = command_connect (yyvsp[-3].command, yyvsp[0].command, OR_OR); ;
      break;}
  case 111:
! #line 690 "./parse.y"
  {
  			  if (yyvsp[-2].command->type == cm_connection)
***************
*** 1675,1691 ****
      break;}
  case 112:
! #line 692 "./parse.y"
  { yyval.command = command_connect (yyvsp[-2].command, yyvsp[0].command, ';'); ;
      break;}
  case 113:
! #line 695 "./parse.y"
  { yyval.command = yyvsp[0].command; ;
      break;}
  case 114:
! #line 699 "./parse.y"
  { yyval.command = yyvsp[0].command; ;
      break;}
  case 115:
! #line 701 "./parse.y"
  {
  			  yyvsp[0].command->flags |= CMD_INVERT_RETURN;
--- 1676,1692 ----
      break;}
  case 112:
! #line 697 "./parse.y"
  { yyval.command = command_connect (yyvsp[-2].command, yyvsp[0].command, ';'); ;
      break;}
  case 113:
! #line 700 "./parse.y"
  { yyval.command = yyvsp[0].command; ;
      break;}
  case 114:
! #line 704 "./parse.y"
  { yyval.command = yyvsp[0].command; ;
      break;}
  case 115:
! #line 706 "./parse.y"
  {
  			  yyvsp[0].command->flags |= CMD_INVERT_RETURN;
***************
*** 1694,1698 ****
      break;}
  case 116:
! #line 706 "./parse.y"
  {
  			  yyvsp[0].command->flags |= yyvsp[-1].number;
--- 1695,1699 ----
      break;}
  case 116:
! #line 711 "./parse.y"
  {
  			  yyvsp[0].command->flags |= yyvsp[-1].number;
***************
*** 1701,1705 ****
      break;}
  case 117:
! #line 711 "./parse.y"
  {
  			  yyvsp[0].command->flags |= yyvsp[-2].number;
--- 1702,1706 ----
      break;}
  case 117:
! #line 716 "./parse.y"
  {
  			  yyvsp[0].command->flags |= yyvsp[-2].number;
***************
*** 1708,1712 ****
      break;}
  case 118:
! #line 716 "./parse.y"
  {
  			  yyvsp[0].command->flags |= yyvsp[-1].number|CMD_INVERT_RETURN;
--- 1709,1713 ----
      break;}
  case 118:
! #line 721 "./parse.y"
  {
  			  yyvsp[0].command->flags |= yyvsp[-1].number|CMD_INVERT_RETURN;
***************
*** 1715,1731 ****
      break;}
  case 119:
! #line 724 "./parse.y"
  { yyval.command = command_connect (yyvsp[-3].command, yyvsp[0].command, '|'); ;
      break;}
  case 120:
! #line 726 "./parse.y"
  { yyval.command = yyvsp[0].command; ;
      break;}
  case 121:
! #line 730 "./parse.y"
  { yyval.number = CMD_TIME_PIPELINE; ;
      break;}
  case 122:
! #line 732 "./parse.y"
  { yyval.number = CMD_TIME_PIPELINE|CMD_TIME_POSIX; ;
      break;}
--- 1716,1732 ----
      break;}
  case 119:
! #line 729 "./parse.y"
  { yyval.command = command_connect (yyvsp[-3].command, yyvsp[0].command, '|'); ;
      break;}
  case 120:
! #line 731 "./parse.y"
  { yyval.command = yyvsp[0].command; ;
      break;}
  case 121:
! #line 735 "./parse.y"
  { yyval.number = CMD_TIME_PIPELINE; ;
      break;}
  case 122:
! #line 737 "./parse.y"
  { yyval.number = CMD_TIME_PIPELINE|CMD_TIME_POSIX; ;
      break;}
***************
*** 1928,1932 ****
    goto yynewstate;
  }
! #line 734 "./parse.y"
  
  
--- 1929,1933 ----
    goto yynewstate;
  }
! #line 739 "./parse.y"
  
  
***************
*** 1943,1946 ****
--- 1944,1948 ----
  /* Initial size to allocate for tokens, and the
     amount to grow them by. */
+ #define TOKEN_DEFAULT_INITIAL_SIZE 496
  #define TOKEN_DEFAULT_GROW_SIZE 512
  
***************
*** 2024,2028 ****
  init_yy_io (get, unget, type, name, location)
       Function *get, *unget;
!      int type;
       char *name;
       INPUT_STREAM location;
--- 2026,2030 ----
  init_yy_io (get, unget, type, name, location)
       Function *get, *unget;
!      enum stream_type type;
       char *name;
       INPUT_STREAM location;
***************
*** 2420,2424 ****
    pushed_string_list = temp;
  
!   ap->flags |= AL_BEINGEXPANDED;
  
    shell_input_line = s;
--- 2422,2427 ----
    pushed_string_list = temp;
  
!   if (ap)
!     ap->flags |= AL_BEINGEXPANDED;
  
    shell_input_line = s;
***************
*** 2454,2458 ****
    pushed_string_list = pushed_string_list->next;
  
!   t->expander->flags &= ~AL_BEINGEXPANDED;
  
    free ((char *)t);
--- 2457,2462 ----
    pushed_string_list = pushed_string_list->next;
  
!   if (t->expander)
!     t->expander->flags &= ~AL_BEINGEXPANDED;
  
    free ((char *)t);
***************
*** 2737,2752 ****
  	  history_expansion_inhibited = old_hist;
  #  endif
! 
! 	  free (shell_input_line);
! 	  shell_input_line = expansions;
! 	  shell_input_line_len = shell_input_line ?
! 				 strlen (shell_input_line) :
! 				 0;
! 	  if (!shell_input_line_len)
! 	    current_command_line_count--;
! 
! 	  /* We have to force the xrealloc below because we don't know the
! 	     true allocated size of shell_input_line anymore. */
! 	  shell_input_line_size = shell_input_line_len;
  	}
        /* XXX - this is grotesque */
--- 2741,2757 ----
  	  history_expansion_inhibited = old_hist;
  #  endif
! 	  if (expansions != shell_input_line)
! 	    {
! 	      free (shell_input_line);
! 	      shell_input_line = expansions;
! 	      shell_input_line_len = shell_input_line ?
! 					strlen (shell_input_line) : 0;
! 	      if (!shell_input_line_len)
! 		current_command_line_count--;
! 
! 	      /* We have to force the xrealloc below because we don't know
! 	         the true allocated size of shell_input_line anymore. */
! 	      shell_input_line_size = shell_input_line_len;
! 	    }
  	}
        /* XXX - this is grotesque */
***************
*** 2883,2887 ****
      last_lastarg = savestring (last_lastarg);
  
!   parse_and_execute (savestring (command), "PROMPT_COMMAND", 0);
  
    last_shell_builtin = temp_last;
--- 2888,2892 ----
      last_lastarg = savestring (last_lastarg);
  
!   parse_and_execute (savestring (command), "PROMPT_COMMAND", SEVAL_NONINT|SEVAL_NOHIST);
  
    last_shell_builtin = temp_last;
***************
*** 3174,3178 ****
        result = token_to_read;
        if (token_to_read == WORD || token_to_read == ASSIGNMENT_WORD)
! 	yylval.word = word_desc_to_read;
        token_to_read = 0;
        return (result);
--- 3179,3186 ----
        result = token_to_read;
        if (token_to_read == WORD || token_to_read == ASSIGNMENT_WORD)
! 	{
! 	  yylval.word = word_desc_to_read;
! 	  word_desc_to_read = (WORD_DESC *)NULL;
! 	}
        token_to_read = 0;
        return (result);
***************
*** 3264,3270 ****
  	      if (reserved_word_acceptable (last_read_token))
  		{
! 		  parser_state |= PST_DBLPAREN;
! 		  yylval.word = make_word ("let");
! 		  return (WORD);	  
  		}
  	      break;
--- 3272,3298 ----
  	      if (reserved_word_acceptable (last_read_token))
  		{
! 		  int cmdtyp, sline;
! 		  char *wval;
! 
! 		  sline = line_number;
! 		  cmdtyp = parse_arith_cmd (&wval);
! 		  if (cmdtyp == 1)	/* arithmetic command */
! 		    {
! 		      word_desc_to_read = make_word (wval);
! 		      word_desc_to_read->flags = W_QUOTED;
! 		      token_to_read = WORD;
! 		      free (wval);
! 		      yylval.word = make_word ("let");
! 		      return (WORD);
! 		    }
! 		  else if (cmdtyp == 0)	/* nested subshell */
! 		    {
! 		      push_string (wval, 0, (alias_t *)NULL);
! 		      if ((parser_state & PST_CASEPAT) == 0)
! 			parser_state |= PST_SUBSHELL;
! 		      return (character);
! 		    }
! 		  else			/* ERROR */
! 		    return -1;
  		}
  	      break;
***************
*** 3482,3485 ****
--- 3510,3559 ----
  }
  
+ #if defined (DPAREN_ARITHMETIC)
+ /* We've seen a `(('.  Look for the matching `))'.  If we get it, return 1.
+    If not, assume it's a nested subshell for backwards compatibility and
+    return 0.  In any case, put the characters we've consumed into a locally-
+    allocated buffer and make *ep point to that buffer.  Return -1 on an
+    error, for example EOF. */
+ static int
+ parse_arith_cmd (ep)
+      char **ep;
+ {
+   int exp_lineno, rval, c;
+   char *ttok, *token;
+   int ttoklen;
+ 
+   exp_lineno = line_number;
+   ttok = parse_matched_pair (0, '(', ')', &ttoklen, 0);
+   rval = 1;
+   if (ttok == &matched_pair_error)
+     return -1;
+   /* Check that the next character is the closing right paren.  If
+      not, this is a syntax error. ( */
+   if ((c = shell_getc (0)) != ')')
+     rval = 0;
+ 
+   token = xmalloc(ttoklen + 4);
+ 
+   /* (( ... )) -> "..." */
+   token[0] = (rval == 1) ? '"' : '(';
+   strncpy (token + 1, ttok, ttoklen - 1);	/* don't copy the final `)' */
+   if (rval == 1)
+     {
+       token[ttoklen] = '"';
+       token[ttoklen+1] = '\0';
+     }
+   else
+     {
+       token[ttoklen] = ')';
+       token[ttoklen+1] = c;
+       token[ttoklen+2] = '\0';
+     }
+   *ep = token;
+   FREE (ttok);
+   return rval;
+ }
+ #endif /* DPAREN_ARITHMETIC */
+ 
  static int
  read_token_word (character)
***************
*** 3511,3519 ****
    int ttoklen, ttranslen;
  
!   if (token_buffer_size < TOKEN_DEFAULT_GROW_SIZE)
!     {
!       FREE (token);
!       token = xmalloc (token_buffer_size = TOKEN_DEFAULT_GROW_SIZE);
!     }
  
    token_index = 0;
--- 3585,3590 ----
    int ttoklen, ttranslen;
  
!   if (token_buffer_size < TOKEN_DEFAULT_INITIAL_SIZE)
!     token = xrealloc (token, token_buffer_size = TOKEN_DEFAULT_INITIAL_SIZE);
  
    token_index = 0;
***************
*** 3561,3603 ****
  	}
  
- #if defined (DPAREN_ARITHMETIC)
-       /* Parse a ksh-style ((...)) expression. */
-       if (parser_state & PST_DBLPAREN)
- 	{
- 	  int exp_lineno;
- 
- 	  /* If we've already consumed a right paren that should be part of
- 	     the expression, push it back so the paren matching code won't
- 	     return prematurely. */
- 	  if (character == '(')		/* ) */
- 	    shell_ungetc (character);
- 	  exp_lineno = line_number;
- 	  ttok = parse_matched_pair (0, '(', ')', &ttoklen, 0);
- 	  parser_state &= ~PST_DBLPAREN;
- 	  if (ttok == &matched_pair_error)
- 	    return -1;
- 	  /* Check that the next character is the closing right paren.  If
- 	     not, this is a syntax error. ( */
- 	  if (shell_getc (0) != ')')
- 	    {
- 	      FREE (ttok);	/* ( */
- 	      parser_error (exp_lineno, "missing closing `)' for arithmetic expression");
- 	      return -1;
- 	    }
- 	  RESIZE_MALLOCED_BUFFER (token, token_index, ttoklen + 4,
- 				  token_buffer_size, TOKEN_DEFAULT_GROW_SIZE);
- 	  token[token_index++] = '"';
- 	  if (character != '(')		/* ) */
- 	    token[token_index++] = character;
- 	  strncpy (token + token_index, ttok, ttoklen - 1);
- 	  token_index += ttoklen - 1;
- 	  token[token_index++] = '"';
- 	  FREE (ttok);
- 	  dollar_present = all_digits = 0;
- 	  quoted = 1;
- 	  goto got_token;
- 	}
- #endif /* DPAREN_ARITHMETIC */
- 
        /* Parse a matched pair of quote characters. */
        if (shellquote (character))
--- 3632,3635 ----
***************
*** 3636,3640 ****
  	        ttok = parse_matched_pair (cd, '{', '}', &ttoklen, 0);
  	      else if (peek_char == '(')		/* ) */
! 		ttok = parse_matched_pair (cd, '(', ')', &ttoklen, 0);
  	      else
  		ttok = parse_matched_pair (cd, '[', ']', &ttoklen, 0);
--- 3668,3681 ----
  	        ttok = parse_matched_pair (cd, '{', '}', &ttoklen, 0);
  	      else if (peek_char == '(')		/* ) */
! 		{
! 		  /* XXX - push and pop the `(' as a delimiter for use by
! 		     the command-oriented-history code.  This way newlines
! 		     appearing in the $(...) string get added to the
! 		     history literally rather than causing a possibly-
! 		     incorrect `;' to be added. */
! 		  push_delimiter (dstack, peek_char);
! 		  ttok = parse_matched_pair (cd, '(', ')', &ttoklen, 0);
! 		  pop_delimiter (dstack);
! 		}
  	      else
  		ttok = parse_matched_pair (cd, '[', ']', &ttoklen, 0);
***************
*** 3834,3841 ****
    if (*temp)
      {
!       t = ansicstr (temp, tlen, (int *)NULL);
        free (temp);
-       if (lenp)
- 	*lenp = strlen (t);
        return (t);
      }
--- 3875,3880 ----
    if (*temp)
      {
!       t = ansicstr (temp, tlen, (int *)NULL, lenp);
        free (temp);
        return (t);
      }
***************
*** 4091,4095 ****
  	\]	end a sequence of non-printing chars
  */
! #define PROMPT_GROWTH 50
  char *
  decode_prompt_string (string)
--- 4130,4134 ----
  	\]	end a sequence of non-printing chars
  */
! #define PROMPT_GROWTH 48
  char *
  decode_prompt_string (string)
