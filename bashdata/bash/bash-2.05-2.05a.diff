diff -Nrc2 bash-2.05/AUTHORS bash-2.05a/AUTHORS
*** bash-2.05/AUTHORS	Fri Jan  3 17:02:53 1997
--- bash-2.05a/AUTHORS	Wed Jul 11 10:38:49 2001
***************
*** 154,159 ****
  lib/glob/ChangeLog	Brian Fox, Chet Ramey
  lib/glob/Makefile.in	Brian Fox, Chet Ramey
! lib/glob/fnmatch.c	Roland McGrath, Brian Fox, Chet Ramey
! lib/glob/fnmatch.h	Roland McGrath, Brian Fox, Chet Ramey
  lib/glob/glob.c		Richard Stallman, Roland McGrath, Brian Fox, Chet Ramey
  lib/glob/glob.h		Chet Ramey
--- 154,159 ----
  lib/glob/ChangeLog	Brian Fox, Chet Ramey
  lib/glob/Makefile.in	Brian Fox, Chet Ramey
! lib/glob/strmatch.c	Roland McGrath, Brian Fox, Chet Ramey
! lib/glob/strmatch.h	Roland McGrath, Brian Fox, Chet Ramey
  lib/glob/glob.c		Richard Stallman, Roland McGrath, Brian Fox, Chet Ramey
  lib/glob/glob.h		Chet Ramey
diff -Nrc2 bash-2.05/CHANGES bash-2.05a/CHANGES
*** bash-2.05/CHANGES	Tue Apr  3 10:33:50 2001
--- bash-2.05a/CHANGES	Wed Nov  7 17:00:53 2001
***************
*** 1,2 ****
--- 1,532 ----
+ This document details the changes between this version, bash-2.05a-release,
+ and the previous version, bash-2.05a-rc1.
+ 
+ 1.  Changes to Bash
+ 
+ a.  Fixed the `printf' builtin so that the variable name supplied as an
+     argument to a %n conversion must be a valid shell identifier.
+ 
+ b.  Improved the random number generator slightly.
+ 
+ c.  Changes to configuration to not put -I/usr/include into $CFLAGS, since
+     it messes up some includes.
+ 
+ d.  Corrected description of POSIXLY_CORRECT in man page and info manual.
+ 
+ e.  Fixed a couple of cases of incorrect function prototypes that sneaked
+     through and caused compilation problems.
+ 
+ f.  A few changes to avoid potential core dumps in the programmable completion
+     code.
+ 
+ g.  Fixed a configure problem that could cause a non-existent file to show
+     up in LIBOBJS.
+ 
+ h.  Fixed a configure problem that could cause siglist.o to not be built when
+     required.
+ 
+ i.  Changes to the strtoimax and strtoumax replacement functions to work
+     around buggy compilers.
+ 
+ j.  Fixed a problem with the snprintf replacement function that could
+     potentially cause a core dump.
+ 
+ 2.  Changes to Readline
+ 
+ a.  Fixed a locale-specific problem in the vi-mode `goto mark' command.
+ 
+ b.  Fixed Makefile to not put -I/usr/include into CFLAGS, since it can cause
+     include file problems.
+ 
+ ------------------------------------------------------------------------------
+ This document details the changes between this version, bash-2.05a-rc1,
+ and the previous version, bash-2.05a-beta1.
+ 
+ 1.  Changes to Bash
+ 
+ a.  Fixed the snprintf replacement to correctly implement the `alternate form'
+     of the %g and %G conversions.
+ 
+ b.  Fixed snprintf to correctly handle the optional precision with the %g and
+     %G conversions.
+ 
+ c.  Fixed the arithmetic evaluation code to correct the values of `@' and `_'
+     when translating base-64 constants (they were backwards).
+ 
+ d.  New library functions for formatting long and long long ints.
+ 
+ e.  Fixed a few places where negative array subscripts could have occurred,
+     mostly as the result of systems using signed characters.
+ 
+ f.  Fixed a few places that assumed a pid_t was no wider than an int.
+ 
+ g.  Fixed the `maildir' mail checking code to work on systems where a
+     `struct stat' doesn't include an `st_blocks' member.
+ 
+ h.  Fixed snprintf to make `unsigned long long' conversion formats (%llu)
+     work better.
+ 
+ i.  Fixed snprintf to not print a sign when asked to do an unsigned conversion.
+ 
+ j.  Made configure changes to avoid compiling empty source files in lib/sh.
+ 
+ k.  New replacement functions (if necessary) for strtoull, strtoll, strtoimax,
+     strtoumax.
+ 
+ l.  The `printf' builtin now handles the `ll' and `j' length modifiers
+     directly, since they can affect the type and width of the argument
+     passed to printf(3).
+ 
+ m.  Renamed a number of the bash-specific autoconf macros in aclocal.m4 to
+     have more sytematic naming, with accompanying changes to configure.in.
+ 
+ n.  Fixed snprintf to handle long doubles and the %a/%A conversions by
+     falling back to sprintf, as long as sprintf supports them.
+ 
+ o.  Fixed return value from vsnprintf/snprintf to be the number of characters
+     that would have been printed, even if that number exceeds the buffer
+     size passed as an argument.
+ 
+ p.  Bash no longer attempts to define its own versions of some ctype macros
+     if they are implemented as functions in libc but not as macros in
+     <ctype.h>.
+ 
+ q.  Changed the variable printing code (used by `set', `export', etc.) to
+     not use the $'...' syntax when in posix mode, since that caused
+     interoperability problems with other shells (most notably with autoconf).
+     When not in posix mode, it uses $'...' if the string to be printed
+     contains non-printing characters and regular single quotes otherwise.
+ 
+ r.  snprintf now recognizes the %F conversion.
+ 
+ s.  Fixed a bug that could cause the wrong status to be returned by a shell
+     function when the shell is compiled without job control and a null
+     command containing a command substutition was executed in the function.
+ 
+ t.  When in posix mode, the default value for MAILCHECK is 600.
+ 
+ u.  Bash only initializes FUNCNAME, GROUPS, and DIRSTACK as special variables
+     if they're not in the initial environment.
+ 
+ v.  If SECONDS appears in the initial environment with a valid integer value,
+     bash uses that as the starting value, as if an assignment had been
+     performed.
+ 
+ w.  Bash no longer auto-exports HOME, PATH, SHELL, or TERM, even though it
+     gives them default values if they don't appear in the initial environment.
+ 
+ x.  Bash no longer auto-exports HOSTNAME, HOSTTYPE, MACHTYPE, or OSTYPE,
+     even if it assigns them default values.
+ 
+ y.  Bash no longer removes the export attribute from SSH_CLIENT or SSH2_CLIENT
+     if they appear in the initial environment.
+ 
+ z.  Bash no longer attempts to discover if it's being run by sshd in order to
+     run the startup files.  If the SSH_SOURCE_BASHRC is uncommented in
+     config-top.h it will attempt to do so as previously, but that's commented
+     out in the distributed version.
+ 
+ aa. Fixed a typo in the code that tests for LC_NUMERIC.
+ 
+ bb. The POSIXLY_CORRECT shell variable and its effects are now documented.
+ 
+ cc. Some changes to several of the support shell scripts included in the
+     definitions to try to avoid race conditions and attacks.
+ 
+ dd. Several changes to avoid warnings from `gcc -Wall'.
+ 
+ ee. Fixed a problem with the `unset' builtin that could cause incorrect
+     results if asked to unset a variable and an array subscript in the
+     same command.
+ 
+ ff. A few changes to the shell's temporary file creation code to avoid
+     potential file descriptor leaks and to prefer the system's idea of
+     the temporary directory to use.
+ 
+ gg. Fixes to build with the C alloca in lib/malloc/alloca.c if the system
+     requires it but the shell has been configured --without-bash-malloc.
+ 
+ hh. Updated the documentation to note that only interactive shells resend
+     SIGHUP to all jobs before exiting.
+ 
+ ii. Fixes to only pass unquoted tilde words to tilde_expand, rather than
+     rely on tilde_expand or getpwnam(3) to handle the quotes (MacOS 10.x
+     will remove backslashes in any login name passed to getpwnam(3)).
+ 
+ jj. Small change from Paul Eggert to make LINENO right in commands run with
+     `bash -c'.
+ 
+ 2.  New Features in Bash
+ 
+ a.  The `printf' builtin now handles the %a and %A conversions if they're
+     implemented by printf(3).
+ 
+ b.  The `printf' builtin now handles the %F conversion (just about like %f).
+ 
+ c.  The `printf' builtin now handles the %n conversion like printf(3).  The
+     corresponding argument is the name of a shell variable to which the
+     value is assigned.
+ 
+ 3.  Changes to Readline
+ 
+ a.  Fixed a few places where negative array subscripts could have occurred.
+ 
+ b.  Fixed the vi-mode code to use a better method to determine the bounds of
+     the array used to hold the marks.
+ 
+ c.  Fixed the defines in chardefs.h to work better when chars are signed.
+ 
+ d.  Fixed configure.in to use the new names for bash autoconf macros.
+ 
+ e.  Readline no longer attempts to define its own versions of some ctype
+     macros if they are implemented as functions in libc but not as macros in
+     <ctype.h>.
+ 
+ f.  Fixed a problem where rl_backward could possibly set point to before
+     the beginning of the line.
+ 
+ ------------------------------------------------------------------------------
+ This document details the changes between this version, bash-2.05a-beta1,
+ and the previous version, bash-2.05a-alpha1.
+ 
+ 1.  Changes to Bash
+ 
+ a.  Fixed a bug in the evalution of arithmetic `for' statements when the
+     expanded expression is NULL.
+ 
+ b.  Fixed an unassigned variable problem in the redirection printing code.
+ 
+ c.  Added more prototypes to extern function declarations in the header
+     files and to static function declarations in C source files.
+ 
+ d.  Make sure called functions have a prototype in scope, to get the arguments
+     and return values right instead of casting.  Removed extern function
+     declarations from C source files that were already included in header
+     files.
+ 
+ e.  Changed some function arguments to use function typedefs in general.h so
+     the prototypes can be checked.  The only use of Function and VFunction
+     now is for unwind-protects.
+ 
+ f.  More const changes to function arguments and appropriate variables.
+ 
+ g.  Changed the mail checking support to handle `maildir'-style mail
+     directories.
+ 
+ h.  Augmented the bash malloc to pass in the file and line number information
+     for each malloc, realloc, and free.  This should result in better error
+     messages.
+ 
+ i.  The `old' gnu malloc is no longer a configuration option.
+ 
+ j.  Augmented the bash malloc with optional tracing and registering allocated
+     and freed memory.
+ 
+ k.  Prompt string decoding now saves and restores the value of $? when it
+     expands the prompt string, so command substitutions don't change $?.
+ 
+ i.  Array indices are now `long', since shell arithmetic is performed as long,
+     and the internal arrayind_t type is used consistently.
+ 
+ j.  Some more `unsigned char *' fixes from Paul Eggert.
+ 
+ k.  Fixed a bad call to builtin_error that could cause core dumps when making
+     local variables.
+ 
+ l.  `return' may no longer be used to terminate a `select' command, for
+     compatibility with ksh.
+ 
+ m.  Changed code that reads octal numbers to do a better job of detecting
+     overflows.
+ 
+ n.  The time formatting code no longer uses absolute indices into a buffer,
+     because the buffer size changes depending on the size of a `time_t'.
+ 
+ o.  `umask' now prints four digits when printing in octal mode, for
+     compatibility with other shells.
+ 
+ p.  Lots of changes to the `printf' builtin from Paul Eggert:  it handles `L'
+     formats and long doubles better, and internal functions have been
+     simpified where appropriate.
+ 
+ q.  Some `time_t' fixes for machines were a time_t is bigger than a long.
+ 
+ r.  Replaced some bash-specific autoconf macros with standard equivalents.
+ 
+ s.  Improvmed the code that constructs temporary filenames to make the
+     generated names a bit more random.
+ 
+ t.  Added code that checks for ascii before calling any of the is* ctype
+     functions.
+ 
+ u.  Changed some places where a `char' was used as an array subscript to use
+     `unsigned char', since a `char' can be negative if it's signed by default.
+ 
+ v.  Lots of changes to the `ulimit' builtin from Paul Eggert to add support
+     for the new POSIX-200x RLIM_SAVED_CUR and RLIM_SAVED_MAX values and
+     simplify the code.
+ 
+ w.  `ulimit' now prints the description of a resource in any error message
+     relating to fetching or setting that resource's limits.
+ 
+ x.  The `snprintf' replacement now computes maximum values at compile
+     time rather than using huge constants for things like long long.
+ 
+ y.  Interactive shells now ignore `set -n'.
+ 
+ z.  Changed the malloc bookkeeping information so that it's now 8 bytes
+     instead of 12 on most 32-bit machines (saving 4 bytes per allocation),
+     restoring 8-byte alignment.
+ 
+ aa. The malloc error reporting code now attempts to print the file and line
+     number of the call that caused the error.
+ 
+ bb. Changed the redirection error reporting code to catch EBADF errors and
+     report the file descriptor number rather than the file being redirected
+     to or from (e.g., things like `exec 4242<x' where 4242 is an out-of-range
+     file descriptor).
+ 
+ cc. `printf', `echo -e', and the $'...' code now process only two hex digits
+     after a `\x' escape sequence for compatibility with other shells, and
+     the documentation was changed to note that the octal and hex escape
+     sequences result in an eight-bit value rather than strict ASCII.
+ 
+ 2.  Changes to Readline
+ 
+ a.  The completion code now attempts to do a better job of preserving the
+     case of the word the user typed if ignoring case in completions.
+ 
+ b.  Readline defaults to not echoing the input and lets the terminal
+     initialization code enable echoing if there is a controlling terminal.
+ 
+ c.  The key binding code now processes only two hex digits after a `\x'
+     escape sequence, and the documentation was changed to note that the
+     octal and hex escape sequences result in an eight-bit value rather
+     than strict ASCII.
+ 
+ 3.  New Features in Bash
+ 
+ a.  The builtin `ulimit' now takes two new non-numeric arguments:  `hard',
+     meaning the current hard limit, and `soft', meaning the current soft
+     limit, in addition to `unlimited'
+ 
+ b.  `ulimit' now prints the option letter associated with a particular
+     resource when printing more than one limit.
+ 
+ c.  `ulimit' prints `hard' or `soft' when a value is not `unlimited' but is
+     one of RLIM_SAVED_MAX or RLIM_SAVED_CUR, respectively.
+ 
+ 4.  New Features in Readline
+ 
+ a.  New bindable variable `history-preserve-point'.  If set, the history
+     code attempts to place the user at the same location on each history
+     line retrived with previous-history or next-history.
+ 
+ ------------------------------------------------------------------------------
+ This document details the changes between this version, bash-2.05a-alpha1,
+ and the previous version, bash-2.05-release.
+ 
+ 1.  Changes to Bash
+ 
+ a.  Better checks in the redirection code for write errors.
+ 
+ b.  bashbug now uses $TMPDIR, defaulting to /tmp, and uses mktemp(1) more
+     portably.
+ 
+ c.  System-specific configuration changes for:  Interix, OpenBSD, FreeBSD,
+     MacOS X.
+ 
+ d.  Some more `const' cleanups through the code.
+ 
+ e.  Fixed a typo in the /dev/fd redirection code, better checks for valid
+     numeric fds in /dev/fd.
+ 
+ f.  Fixed many parts of the shell to handle integer overflow more gracefully
+     and to do more stringent checks for valid numbers.
+ 
+ g.  Fixed mksignames to include config.h.
+ 
+ h.  Fixed an uninitialized variable problem that could cause the shell to core
+     dump when replacing characters in a string.
+ 
+ i.  New mechanism for updating the patch level when official patches are
+     released (patchlevel.h).
+ 
+ j.  configure.in changed to no longer require external files _distribution and
+     _patchlevel.
+ 
+ k.  Fixed non-interactive shell initialization problem when bash started as
+     `bash -i filename'.
+ 
+ l.  Fixed printf builtin conversion error handling to be POSIX.2-conformant.
+ 
+ m.  autoconf-2.52 is now used to build configure; autoconf-2.50 or newer is
+     required.  Some of the bash-specific macros were removed, since they are
+     now standard.
+ 
+ n.  Startup files and files read with source or `.' are no longer required to
+     be regular files.
+ 
+ o.  Fixed core dump in builtin printf when user-supplied precision or field
+     width is 0.
+ 
+ p.  Fixed builtin printf to treat a negative field width as a positive field
+     width with left-justification.
+ 
+ r.  New unwind-protect implementation from Paul Eggert.
+ 
+ s.  Fixed an inadvertently-unclosed comment in the bash completion code that
+     caused programmable completions to not add trailing slashes or spaces to
+     completions.
+ 
+ t.  Fixed the process substitution code to cope better when stdin is closed.
+ 
+ v.  Fixes, mostly from Paul Eggert, for a few possible buffer overflows in
+     the shell.
+ 
+ w.  Fixes from Paul Eggert to avoid most of the type casts in the shell code,
+     and use more appropriate types for a number of variables.
+ 
+ x.  Command substition no longer inherits the DEBUG trap.
+ 
+ y.  Some fixes to the process substition code on machines without /dev/fd so
+     that named pipes are not removed inappropriately.
+ 
+ z.  The loadable `getconf' builtin is now much more complete, and will become
+     part of the shell in the future.
+ 
+ aa. The select command no longer terminates on a `return', so it can be used
+     to return from an enclosing function (as ksh does it).
+ 
+ bb. Fixed the extended pattern matching code to behave better when presented
+     with incorrectly-formed patterns.
+ 
+ cc. Some changes were made with the intent of making cross-compilation easier.
+ 
+ dd. The network code (/dev/tcp and /dev/udp redirections) uses getaddrinfo(3)
+     if it's available, which adds support for IPv6.
+ 
+ ee. Subshells of login shells no longer source ~/.bash_logout when they exit.
+ 
+ ff. Fixes so that subshells don't exit inappropriately if the -e option has
+     been set.
+ 
+ gg. Restricted shells no longer allow functions to be exported.
+ 
+ hh. Changes to the pattern matching code so extended pattern matching works
+     on systems with deficient shared library implementations, like MacOS X.
+ 
+ ii. Better error messages when a script with a leading `#!interp' fails
+     to execute because of problems with `interp'.
+ 
+ jj. Fixed `compgen' to handle the `-o default' option better.
+ 
+ kk. Fixed the job control code to force an asynchronous process's standard
+     input to /dev/null only if job control is not active.
+ 
+ ll. Fixed a possible infinite recursion problem when `fc ""=abc' (a null
+     pattern) is used to re-execute a previous command.
+ 
+ mm. Fixed `declare [-a] var=value' to assign VALUE to element 0 if VAR is an
+     array variable.  Similarly for `declare [-a] var[N]=value'.  This is like
+     ksh93.
+ 
+ nn. Fixed a bug that caused `read -a aname' to work even if ANAME had been
+     declared readonly.
+ 
+ oo. Fixed a possible integer overflow problem when constructing names for
+     temporary files.
+ 
+ 2.  New Features in Bash
+ 
+ a.  Added support for DESTDIR installation root prefix, so you can do a
+     `make install DESTDIR=bash-root' and do easier binary packaging.
+ 
+ b.  Added support for builtin printf "'" flag character as per latest POSIX
+     drafts.
+ 
+ c.  Support for POSIX.2 printf(1) length specifiers `j', `t', and `z' (from
+     ISO C99).
+ 
+ d.  New autoconf macro, RL_LIB_READLINE_VERSION, for use by other applications
+     (bash doesn't use very much of what it returns).
+ 
+ e.  `set [-+]o nolog' is recognized as required by the latest POSIX drafts,
+     but ignored.
+ 
+ f.  New read-only `shopt' option:  login_shell.  Set to non-zero value if the
+     shell is a login shell.
+ 
+ g.  New `\A' prompt string escape sequence; expands to time in 24 HH:MM format.
+ 
+ h.  New `-A group/-g' option to complete and compgen; does group name
+     completion.
+ 
+ i.  New `-t' option to `hash' to list hash values for each filename argument.
+ 
+ j.  New [-+]O invocation option to set and unset `shopt' options at startup.
+ 
+ k.  configure's `--with-installed-readline' option now takes an optional
+     `=PATH' suffix to set the root of the tree where readline is installed
+     to PATH.
+ 
+ l.  The ksh-like `ERR' trap has been added.  The `ERR' trap will be run
+     whenever the shell would have exited if the -e option were enabled.
+     It is not inherited by shell functions.
+ 
+ m.  `readonly', `export', and `declare' now print variables which have been
+     given attributes but not set by assigning a value as just a command and
+     a variable name (like `export foo') when listing, as the latest POSIX
+     drafts require.
+ 
+ n.  `bashbug' now requires that the subject be changed from the default.
+ 
+ o.  configure has a new `--enable-largefile' option, like other GNU utilities.
+ 
+ p.  `for' loops now allow empty word lists after `in', like the latest POSIX
+     drafts require.
+ 
+ 3.  Changes to Readline
+ 
+ a.  More `const' and type casting fixes.
+ 
+ b.  Changed rl_message() to use vsnprintf(3) (if available) to fix buffer
+     overflow problems.
+ 
+ c.  The completion code no longer appends a `/' or ` ' to a match when
+     completing a symbolic link that resolves to a directory name, unless
+     the match does not add anything to the word being completed.  This
+     means that a tab will complete the word up to the full name, but not
+     add anything, and a subsequent tab will add a slash.
+ 
+ d.  Fixed a trivial typo that made the vi-mode `dT' command not work.
+ 
+ e.  Fixed the tty code so that ^S and ^Q can be inserted with rl_quoted_insert.
+ 
+ f.  Fixed the tty code so that ^V works more than once.
+ 
+ g.  Changed the use of __P((...)) for function prototypes to PARAMS((...))
+     because the use of __P in typedefs conflicted g++ and glibc.
+ 
+ 4.  New Features in Readline
+ 
+ a.  Added extern declaration for rl_get_termcap to readline.h, making it a
+     public function (it was always there, just not in readline.h).
+ 
+ b.  New #defines in readline.h:  RL_READLINE_VERSION, currently 0x0402,
+     RL_VERSION_MAJOR, currently 4, and RL_VERSION_MINOR, currently 2.
+ 
+ c.  New readline variable:  rl_readline_version, mirrors RL_READLINE_VERSION.
+ 
+ d.  New bindable boolean readline variable:  match-hidden-files.  Controls
+     completion of files beginning with a `.' (on Unix).  Enabled by default.
+ 
+ e.  The history expansion code now allows any character to terminate a
+     `:first-' modifier, like csh.
+ 
+ f.  The incremental search code remembers the last search string and uses
+     it if ^R^R is typed without a search string.
+ 
+ ------------------------------------------------------------------------------
  This document details the changes between this version, bash-2.05-release,
  and the previous version, bash-2.05-beta2.
diff -Nrc2 bash-2.05/COMPAT bash-2.05a/COMPAT
*** bash-2.05/COMPAT	Wed Apr  4 11:07:34 2001
--- bash-2.05a/COMPAT	Tue Oct 30 16:07:56 2001
***************
*** 1,6 ****
  This document details the incompatibilites between this version of bash,
! bash-2.05, and the previous widely-available version, bash-1.14 (which
  is still the `standard' version for many Linux distributions).  These
  were discovered by users of bash-2.x, so this list is not comprehensive.
  
  1.  Bash now uses a new quoting syntax, $"...", to do locale-specific
--- 1,8 ----
  This document details the incompatibilites between this version of bash,
! bash-2.05a, and the previous widely-available version, bash-1.14 (which
  is still the `standard' version for many Linux distributions).  These
  were discovered by users of bash-2.x, so this list is not comprehensive.
+ Some of these incompatibilities occur between the current version and
+ versions 2.0 and above.
  
  1.  Bash now uses a new quoting syntax, $"...", to do locale-specific
***************
*** 133,144 ****
  	alias -x='chmod a-x' --> alias -- -x='chmod a-x'
  
! 13. There was a bug in bash-1.14 and previous versions that caused it to
!     accept as valid syntax for loops of the form
! 
! 	for f in ; do ... ; done
! 
!     This should be a syntax error, and bash-2.x treats it as such.
! 
! 14. The behavior of range specificiers within bracket matching expressions
      in the pattern matcher (e.g., [A-Z]) depends on the current locale,
      specifically the value of the LC_COLLATE environment variable.  Setting
--- 135,139 ----
  	alias -x='chmod a-x' --> alias -- -x='chmod a-x'
  
! 13. The behavior of range specificiers within bracket matching expressions
      in the pattern matcher (e.g., [A-Z]) depends on the current locale,
      specifically the value of the LC_COLLATE environment variable.  Setting
***************
*** 184,188 ****
      Users may put the above command into their own profiles as well, of course.
  
! 15.  Bash versions up to 1.14.7 included an undocumented `-l' operator to
       the `test/[' builtin.  It was a unary operator that expanded to the
       length of its string argument.  This let you do things like
--- 179,183 ----
      Users may put the above command into their own profiles as well, of course.
  
! 14.  Bash versions up to 1.14.7 included an undocumented `-l' operator to
       the `test/[' builtin.  It was a unary operator that expanded to the
       length of its string argument.  This let you do things like
***************
*** 199,200 ****
--- 194,205 ----
       should) use ${#variable} to get the length of a variable's value.
       Bash-2.x does not support it.
+ 
+ 15.  Bash no longer auto-exports the HOME, PATH, SHELL, TERM, HOSTNAME,
+      HOSTTYPE, MACHTYPE, or OSTYPE variables.
+ 
+ 16.  Bash no longer initializes the FUNCNAME, GROUPS, or DIRSTACK variables
+      to have special behavior if they appear in the initial environment.
+ 
+ 17.  Bash no longer removes the export attribute from the SSH_CLIENT or
+      SSH2_CLIENT variables, and no longer attempts to discover whether or
+      not it has been invoked by sshd in order to run the startup files.
diff -Nrc2 bash-2.05/CWRU/changelog bash-2.05a/CWRU/changelog
*** bash-2.05/CWRU/changelog	Fri Apr  6 15:14:31 2001
--- bash-2.05a/CWRU/changelog	Thu Nov  8 08:17:53 2001
***************
*** 1,10041 ****
! 				12/23/1996
! 				----------
! [bash-2.0 released]
  
- 				   12/27
- 				   -----
  configure.in
! 	- don't automatically use GNU malloc on FreeBSD, the builtin one
! 	  is supposed to be better (but doesn't have the debugging hooks)
  
! builtins/exec.def
! 	- check that full_pathname(command) doesn't return NULL because of
! 	  inaccessible parent directories
  
! support/config.sub
! 	- recognize OpenBSD
  
! execute_cmd.c
! 	- broke the code that opens a file for output redirection when in
! 	  noclobber mode out into a separate function: noclobber_open().
! 	  This tries to avoid race conditions and file replacement between
! 	  stat(2) and open(2)
  
! subst.c
! 	- make sure pat_subst does not run off the end of its return
! 	  string when copying the unmatched portion of the input string
  
! 				   12/30
! 				   -----
! doc/Makefile.in
! 	- don't install readline.3 by default
  
! lib/tilde/tilde.c
! 	- removed an unnecessary check for string[i] being non-null in
! 	  tilde_find_suffix
  
! 				   12/31
! 				   -----
! support/config.{sub,guess}
! 	- merged in changes from config.sub in autoconf-2.12 distribution
  
! lib/readline/readline.c
! 	- in rl_newline, only call _rl_vi_done_inserting and _rl_vi_reset_last
! 	  if readline is currently in vi mode
  
! lib/readline/display.c
! 	- corrected a misuse of inv_lbreaks where vis_lbreaks was wanted in
! 	  the code that decides whether the cursor is at the beginning of
! 	  an otherwise-empty line
  
! 				 1/2/1997
! 				 --------
! support/bashbug.sh
! 	- fixed a typo, thanks to eggert@twinsun.com
  
! aclocal.m4
! 	- new test, BASH_STRUCT_DIRENT_D_FILENO, testing for d_fileno member
! 	  of struct dirent
  
! configure.in
! 	- call BASH_STRUCT_DIRENT_D_FILENO
  
! config.h.in
! 	- new #define for STRUCT_DIRENT_HAS_D_FILENO
  
! lib/posixheaders/posixdir.h
! 	- only define d_fileno as d_ino if STRUCT_DIRENT_HAS_D_INO is defined
! 	  and STRUCT_DIRENT_HAS_D_FILENO is not defined.  This fixed the
! 	  problem of compiling getcwd.c on SunOS4.1.4 with cc
  
! 				    1/3
! 				    ---
! lib/readline/complete.c
! 	- fix a memory-used-after-freed bug reported by Andreas Schwab
  
! configure.in
! 	- call BASH_CHECK_SOCKLIB only if getpeername is not found in libc
! 	  (ac_cv_func_getpeername = no)
  
! 				   1/13
  				   ----
  
! builtins/getopt.h
! 	- change #define guard to _SH_GETOPT_H to avoid similar guards in
! 	  /usr/include/getopt.h (Dec OSF/1 4.x, for example)
  
! variables.h
! 	- fix assign_array_from_string so that it rejects attempts to assign
! 	  to readonly variables
  
! subst.c
! 	- fix verify_substring_values to handle offsets that are past the
! 	  end or before the beginning (in the case of a negative offset)
! 	  of the expanded variable value
  
! 				   1/14
! 				   ----
! bashline.c
! 	- fix a problem where any completion after a `cmd` command
! 	  substitution would inappropriately attempt command completion,
! 	  even if the previous command substitution was correctly closed
  
! builtins/evalstring.c
! 	- unwind_protect remember_on_history even if the shell is not
! 	  interactive, since history can now be used in scripts, and
! 	  `source' will turn off interactive_shell before calling
! 	  parse_and_execute
  
! jobs.c
! 	- new function get_job_by_pid(pid, block) to translate a pid to
! 	  a job number.  The block argument says whether or not to block
! 	  SIGCHLD
  
! jobs.h
! 	- new extern declaration for get_job_by_pid
  
! builtins/jobs.def
! 	- call get_job_by_pid if an argument appears to be a pid rather
! 	  than a jobspec
  
! configure.in
! 	- configure --without-gnu-malloc automatically on MachTen 4.x
  
! builtins/cd.def
! 	- change to mindist() so that a best guess of `.' returns 3,
! 	  which means not reasonable
! 
! lib/posixheaders/memalloc.h
! 	- changed hpux_9 to __hpux, since the new config stuff doesn't
! 	  define hpux_9
  
! subst.c
! 	- fix parameter_brace_patsub to handle null patterns (doesn't
! 	  do anything)
  
! oslib.c
! 	- slight change to bzero replacement
  
! support/bashbug.sh
! 	- changed TEMP to be /tmp/bbug.$$ as a sop to systems with 14-char
! 	  file names
  
! doc/bashref.texi
! 	- add note to POSIX Mode section that the output of `set' when
! 	  invoked without arguments is sorted when in POSIX mode
  
! 				   1/15
! 				   ----
! support/recho.c
! 	- a couple of changes prompted by a `gcc -Wall'
  
! subst.c
! 	- changed ASSIGN_RETURN macro to use the do...while(0) idiom to
! 	  avoid problems with its multiple statements
  
! builtins/setattr.def
! 	- a bad identifier given to readonly or export without an assignment
! 	  statement (e.g. `readonly a[5]') is an error, but not an assignment
! 	  error (i.e., return EXECUTION_FAILURE rather than EX_BADASSIGN)
! 
! tests/{{array,new-exp}.,tilde-}tests
! 	- added `set +o posix' at the beginning to disable POSIX mode, which
! 	  causes some of the tests to fail.  Some systems (e.g. LINUX-FT),
! 	  set POSIXLY_CORRECT by default
! 
! tests/test-tests
! 	- added a warning if $UID is 0 to the effect that the test suite
! 	  should not be run as root
! 	- worked around the `noread' and `nowrite' tests failing when run
! 	  as root
  
! test.c
! 	- began removing the remains of the STANDALONE code, since test is
! 	  included in GNU shellutils
  
! 				   1/16
! 				   ----
! lib/readline/{readline,display}.c
! 	- a couple of slight changes to build on Win95 using djgpp (reported
! 	  by x-aes@telelogic.se)
  
! Makefile.in
! 	- changed TERMCAP_LIBDIR to TERM_LIBDIR, so building the termcap
! 	  library (if necessary) should work now
  
! bashline.c
! 	- new function: quote_word_break_characters(), to backslash-quote 
! 	  characters in a filename that the readline completion code would
! 	  treat as word breaks
! 	- change bash_quote_filename to call quote_word_break_characters if
! 	  the completion quoting style says to use backslashes
! 	- add `:' to rl_filename_quote_characters, since it's part of
! 	  filename_word_break_characters
! 
! lib/posixheaders/posixjmp.h
! 	- new file, with half of bashjmp.h
! 	- posixjmp.h and lib/readline/posixjmp.h are symlinks to this file
! 
! bashjmp.h
! 	- include "posixjmp.h" for possible redefinitions of setjmp/longjmp
! 	  and procenv_t
  
! 				   1/17
! 				   ----
! shell.c
! 	- bad options now cause the standard shell usage message (a subset
! 	  of what `bash --help' prints) to be displayed on stderr
  
! trap.c
! 	- don't free the trap command for a DEBUG trap in
! 	  restore_default_signal if SIG_INPROGRESS is set -- there's already
! 	  a pointer saved to the old value in _run_trap_internal.  This
! 	  makes bashdb run better, too
  
! examples/bashdb/bashdb.{pre,fns}
! 	- a couple of minor fixes; it actually has a chance of working now
  
! 				   1/21
! 				   ----
! config.h.in
! 	- add a define for <dlfcn.h>, HAVE_DLFCN_H
  
! configure.in
! 	- look for <dlfcn.h>, define HAVE_DLFCN_H if found
  
! builtins/enable.def
! 	- include <dlfcn.h> only if HAVE_DLFCN_H is defined
  
! lib/readline/display.c
! 	- renamed clear_to_eol to _rl_clear_to_eol and made it global, so
! 	  other library files (readline.c) can use it
! 	- new function _rl_clear_screen, to clear the screen with the right
! 	  termcap escape sequence
  
! lib/readline/readline.c
! 	- call _rl_clear_to_eol and _rl_clear_screen instead of using tputs
! 	- extern declarations for _rl_clear_to_eol and _rl_clear_screen
  
! 				   1/22
! 				   ----
! mailcheck.c
! 	- fixed a problem in make_default_mailpath() where a slash was not
! 	  added between the default mail directory and the username
  
! 				   1/23
! 				   ----
! stringlib.c
! 	- added a fourth parameter to ansicstr: the length of the returned
! 	  string
  
! externs.h
! 	- changed declaration of ansicstr
  
! parse.y
! 	- changed call to ansicstr -- saves a call to strlen
  
! builtins/echo.def
! 	- changed call to ansicstr
! 	- if do_v9 is non-zero, use putchar to output the string instead
! 	  of printf, since there may be embedded NULL characters
! 
! doc/{bash.1,bashref.texi}, builtins/trap.def
! 	- modified the `trap' documentation to make it clearer that trap
! 	  takes multiple signal specs as arguments
! 
! jobs.c, nojobs.c, jobs.h
! 	- renamed initialize_jobs to initialize_job_control, added an
! 	  argument (force)
  
! jobs.c
! 	- set shell_tty to fileno(stderr) in initialize_job_control if
! 	  the shell is not interactive.  This fixes the problem of bad
! 	  tty pgrps when monitor mode is turned on in a non-interactive
! 	  shell
! 
! sig.c
! 	- made initialize_terminating_signals do only that; moved the rest
! 	  of the code that used to be there into a new function:
! 	  initialize_shell_signals, which calls initialize_terminating_signals
! 	  if the shell is interactive
! 	- initialize_terminating_signals is now extern
! 	- made reset_terminating_signals return immediately if
! 	  termsigs_intitialized is zero, meaning that
! 	  initialize_terminating_signals has not been called
  
! sig.h
! 	- new extern declaration for initialize_terminating_signals
  
! trap.c
! 	- call initialize_terminating_signals from set_signal if sig is
! 	  EXIT_TRAP and the shell is not interactive.  Since the terminating
! 	  signals do not need to be initialized until a trap on exit is
! 	  set, not doing that at startup should result in a speed increase
! 	  for scripts
  
  execute_cmd.c
! 	- save and restore command->flags in time_command, so you can use
! 	  `time command' in a loop
  
! 				   1/24
! 				   ----
! lib/readline/display.c
! 	- fix redisplay code to wrap correctly if the prompt is longer than
! 	  the screen width (reported by bos@Eng.Sun.COM)
  
! lib/readline/undo.c
! 	- don't include <setjmp.h>, it's not needed
  
! lib/readline/{util,readline}.c
! 	- include "posixjmp.h" instead of <setjmp.h>
! 	- readline_top_level is now a `procenv_t' instead of a `jmp_buf'
! 	  (now readline uses the correct posix semantics for preserving
! 	  the signal mask and other things across longjmp)
  
  parse.y
! 	- fixes to push_string/pop_string to make them more general -- they
! 	  now can be used generally, instead of having to be associated
! 	  with an alias being expanded
! 	- fixes to the parser so that it parses (( ls abc; ls def); ls ghi)
! 	  as a nested subshell command for backwards compatibility.  Broke
! 	  the double-paren expression parsing off into a new function:
! 	  parse_arith_cmd, called from read_token when a `((' is seen.  If
! 	  it looks like an arithmetic command, return `let' and set things
! 	  up so that the expression is returned as a double-quoted string
! 	  by the next call to read_token.  If it's a nested subshell, push
! 	  the text we parsed onto the list of strings for later consumption
! 	  and return `('
  
! lib/glob/glob.c
! 	- fix glob_vector so it doesn't short-circuit checking a filename if
! 	  it starts with a `.' and the pattern starts with `\.' (if
! 	  noglob_dot_filenames is set).  This makes `".junk2"*' match
! 	  `.junk2.txt' correctly
  
! 				   1/27
! 				   ----
! support/bashbug.sh
! 	- ask for confirmation before sending the bug report
  
! builtins/fc.def
! 	- when editing and re-executing a multiline command, make sure
! 	  current_command_line_count is initialized and then incremented
! 	  for each line read from the file so that the lines added to
! 	  the history list by fc_replhist and fc_addhist obey the `lithist'
! 	  and `cmdhist' shopt options.  Reported by tibbitts@pb.seflin.org
  
! 				   1/28
! 				   ----
! lib/readline/readline.h
! 	- added a couple of extern declarations for variables described in
! 	  the documentation but heretofore undeclared
  
! builtins/ulimit.def
! 	- try to catch some classes of integer overflows before calling
! 	  set_limit
  
! 				   1/29
! 				   ----
! parse.y
! 	- push and pop a `(' delimiter while parsing a $(...) construct, so
! 	  the history code doesn't try to inappropriately add a `;' when
! 	  a newline appears in the `...'
  
! aclocal.m4
! 	- new macro, BASH_STRUCT_WINSIZE, which looks for `struct winsize'
! 	  in <sys/ioctl.h> (or one of the files it includes)
  
! configure.in
! 	- call BASH_STRUCT_WINSIZE
! 	- slightly reorganized the calls to bash-specific macros
  
! config.h.in
! 	- add an `#undef STRUCT_WINSIZE_IN_SYS_IOCTL'
  
! jobs.c, nojobs.c
! 	- only look in sys/ptem.h for struct winsize if
! 	  STRUCT_WINSIZE_IN_SYS_IOCTL is not defined to cpp
  
! 				   1/30
! 				   ----
! .{distribution,patchlevel}
! 	- renamed to _{distribution,patchlevel}
  
! configure.in
! 	- create a variable BASHVERS, from the contents of _distribution,
! 	  and a variable BASHPATCH, from the contents of _patchlevel,
! 	  (using m4 magic so we don't have to distribute .distribution
! 	  and .patchlevel) and substitute them into Makefile.in
  
! Makefile.in
! 	- use Version and PatchLevel variables instead of the contents of
! 	  .distribution and .patchlevel, respectively.  These are set by
! 	  configure
! 	- removed `.machine' from targets and dependencies
  
! support/mkversion.sh
! 	- new shell script to handle updating version.h, replaces mkversion.c
! 	  (which is now overkill)
  
! support/mkdist
! 	- don't bother with writing .distribution and .patchlevel files,
! 	  since they're no longer distributed
! 
! support/mknewvers.sh
! 	- simple bash script to make new version files.  It can increment
! 	  the major or minor version numbers or patchlevel, or take a
! 	  completely new version number (e.g., 2.01) as an argument
! 
! doc/Makefile.in
! 	- added support for the `install-info' command to update the info
! 	  directory file after installing bash.info
  
! 				   1/31
! 				   ----
! builtins/help.def
! 	- fix core dump with `help --'
  
! susbt.c
! 	- make call_expand_word_internal obey the convention that if
! 	  expand_word_internal returns &expand_word_{fatal,error}, then
! 	  w->word has already been freed
! 	- return &expand_word_fatal from expand_word_internal if the shell
! 	  is not interactive and `set -u' has been executed
  
! test.c, general.c
! 	- moved group_member from test.c to general.c
  
! externs.h, general.h
! 	- moved extern declaration of group_member from externs.h to general.h
  
  general.c
! 	- broke the code that initializes the group array out into a new
! 	  function, initialize_group_array()
! 	- initialize_group_array() now initializes an array even if the OS
! 	  does not have getgroups().  If it does not, an array with one
! 	  element (the real gid) is created
! 	- call sysconf(_SC_NGROUPS_MAX) if sysconf is available and
! 	  _SC_NGROUPS_MAX is defined
! 	- new function, char **get_group_list(int *), to return an array
! 	  of strings made from the groups list
! 
! variables.c
! 	- new dynamic array variable: GROUPS, expands to the group set as
! 	  obtained with getgroups() (or whatever initialize_group_array()
! 	  makes)
! 
! doc/{bash.{1,html},bashref.texi}
! 	- added description of GROUPS variable
! 
! test/test-tests
! 	- before modifying the setgid bit on /tmp/setgid, try to change its
! 	  group to ${GROUPS[0]} 
! 
! 				    2/3
! 				    ---
! aclocal.m4
! 	- new autconf macro, BASH_MISC_SPEED_T, to see if speed_t is defined
! 	  in <sys/types.h>
  
! configure.in
! 	- call BASH_MISC_SPEED_T
  
! config.h.in
! 	- add `#undef SPEED_T_IN_SYS_TYPES'
  
! lib/readline/tcap.h
! 	- include `rltty.h' if HAVE_TERMCAP_H and __linux__ are defined, but
! 	  SPEED_T_IN_SYS_STYPES is not, before including <termcap.h>
  
! support/mksignames.c, siglist.c
! 	- add support for 4.4 BSD SIGLOST
  
! support/config.guess
! 	- add support for recognizing QNX based on `uname' output
  
! Makefile.in
! 	- make sure recho and zecho are compiled with the same set of CC
! 	  options as the rest of the sources
  
! lib/readline/bind.c
! 	- change calls to rl_generic_bind to cast the third argument to
! 	  (char *) where necessary
  
  command.h
! 	- two new flags: CMD_AMPERSAND (currently unused), and CMD_STDIN_REDIR,
! 	  which means that this command should have its standard input
! 	  redirected from /dev/null if there are not any explicit redirections
! 	  to stdin
! 
! execute_cmd.c
! 	- a redirection of type r_inputa_direction is no longer added at the
! 	  beginning of the redirection chain for an async command;
! 	  CMD_STDIN_REDIR is set in the flags instead
! 	- new function: stdin_redirects: returns the number of redirections to
! 	  stdin in a chain of redirections
! 	- new functions: async_redirect_stdin() to open /dev/null and make it
! 	  file descriptor 0
! 	- changes to make CMD_STDIN_REDIR propagate to all of the necessary
! 	  functions (like execute_simple_command)
! 	- execute_disk command now takes the flags from simple_command rather
! 	  than just the CMD_NO_FORK flag as its last argument
! 	- various places after make_child is executed (in the child) check for
! 	  CMD_STDIN_REDIRECT (and no stdin redirections or piping) and call
! 	  async_redirect_stdin
! 	- stdin_redir is now global
  
! eval.c
! 	- set stdin_redir to 0 just before calling execute_command so it
! 	  gets reset to a known value and doesn't persist across commands
  
! 				    2/4
! 				    ---
! builtins/ulimit.def
! 	- add a stub function for ulimit(2) on systems without HAVE_RESOURCE
! 	  or HAVE_ULIMIT that just sets errno to EINVAL and returns -1 --
! 	  QNX is one such system
  
! bashhist.c
! 	- pre_process_line needs to protect all occurrences of hist_verify
! 	  with #ifdef READLINE
  
  builtins/shopt.def
! 	- hist_verify needs to be protected with #ifdef READLINE, not
! 	  #ifdef HISTORY
  
! 				    2/5
! 				    ---
! support/config.{guess,sub}, configure.in
! 	- chages to better support the Harris Night Hawk
  
! [many files]
! 	- changes for things pointed out by gcc -Wall
  
! lib/glob/Makefile.in
! 	- make sure -DSHELL is included in CCFLAGS so that globbing is
! 	  interruptible
  
! lib/malloc/malloc.c
! 	- extern declaration for botch: if botch is #defined, it should be
! 	  the name of a void function
  
! configure.in,Makefile.in,builtins/Makefile.in,
! lib/{glob,malloc,readline,tilde}/Makefile.in
! 	- add a LOCAL_DEFS variable, substituted from configure into the
! 	  various Makefiles.  It's set to -DSHELL, so that define gets
! 	  passed to all sub-makes without doing anything special
  
! lib/readline/readline.c
! 	- change to rl_digit_loop to make it compatible with GNU emacs:
! 	  if a key bound to `universal-argument' is read after reading
! 	  some digits, it terminates the argument but is otherwise
! 	  ignored.  This is how people can insert repeated digits
! 
! doc/{bash.{1,html},readline.3}, lib/readline/doc/rluser.texinfo
! 	- changed description of `universal-argument' to describe how
! 	  to terminate a numeric argument
  
! 				    2/6
! 				    ---
! jobs.c
! 	- changed kill_pid to diddle the job and process data structures
! 	  if we're sending SIGCONT to a stopped job with `kill' so that
! 	  the shell knows the job is running again.  ksh93 does this
  
! 				    2/7
! 				    ---
! unwind_prot.c
! 	- changed bcopy to FASTCOPY
  
! builtins/enable.def
! 	- changed pointer arithmetic in delete_builtin to just subtract
! 	  the head of the builtins list (shell_builtins) from a pointer
! 	  to the builtin to be deleted (b) to find its index in the list
! 	  on ANSI C systems
  
- 				   2/10
- 				   ----
  lib/readline/bind.c
! 	- when using old-style keynames to bind to a new-style macro,
! 	  pass an array of type (unsigned char *) to rl_macro_bind
  
! builtins/getopt.c
! 	- change sh_getopt to return EOF if nextchar is empty or NULL
! 	  and sh_optind is greater than argc.  This can happen if a
! 	  script mixes calls to `getopts' with calls to `shift'
! 
! 				   2/11
! 				   ----
! print_cmd.c
! 	- fixed make_command_string_internal so that commands with the
! 	  CMD_TIME_POSIX flag set print `time -p' instead of `time'
! 	- changed print_redirection_list so the here documents are
! 	  printed after all the other redirections, and followed by a
! 	  newline (rather than a possible semicolon)
! 	- added a new variable, was_heredoc, to avoid adding a semicolon
! 	  at the beginning of an empty line after printing the heredoc
! 	  ending delimiter
  
! execute_cmd.c
! 	- don't put the gnu_argv_flags into the environment any more; it's
! 	  proven to be a bad idea
  
! configure.in
! 	- set LOCAL_CFLAGS to `-DSunOS5' on Solaris 5.5[.x]
  
! builtins/echo.def
! 	- only call fflush() after printing each word on SunOS 5.5, since
! 	  that's the system with the bug that prompted its inclusion in
! 	  the first place
  
! support/mksignames.c
! 	- added support for more system-specific signals from AIX 4.2,
! 	  changed initialization order so that system-specific signals
! 	  are done first, before the common signals
  
! 				   2/12
! 				   ----
! execute_cmd.c
! 	- broke the code that creates a file containing the text of a
! 	  here document out into a separate function: here_doc_to_fd
! 	- create the temp file used for a here document with mode 600
! 	- open the temp file used for a here document with O_EXCL
  
! shell.h
! 	- changed the uid members of struct user_info to be of type uid_t
! 	  and the gid members to be of type gid_t
  
! parse.y
! 	- changed the type of the `type' argument to init_yy_io() to be
! 	  `enum stream_type', since that's what's always passed
  
! input.h
! 	- changed the function prototype for init_yy_io so the third arg is
! 	  type `enum stream_type'
  
! externs.h
! 	- added a prototype for getcwd, if HAVE_GETCWD is not defined
  
! builtins/umask.def
! 	- changed all variables that are used as arguments to or save the
! 	  return value from umask(2) to be of type mode_t
! 	- changed print_symbolic_umask to take an argument of type mode_t
  
! 				   2/13
! 				   ----
! jobs.c
! 	- if old_sigint_handler is set to SIG_DFL, as it will be in a script
! 	  without a trap on SIGINT installed, call termination_unwind_protect()
! 	  directly from waitchld()
  
! 				   2/14
  				   ----
  configure.in
! 	- added a section before the call to BASH_CHECK_LIB_TERMCAP to
! 	  set a variable prefer_curses on some systems (AIX, for one)
  
! aclocal.m4
! 	- in BASH_CHECK_LIB_TERMCAP, don't return -ltermcap if $prefer_curses
! 	  is non-empty
  
! lib/readline/Makefile.in
! 	- redid the dependencies
  
! 				   2/17
! 				   ----
! hashlib.c, getcwd.c
! 	- include `bashansi.h' instead of stdlib.h and string.h
  
! error.c, siglist.c, xmalloc.c, builtins/{common,evalfile,mkbuiltins,psize}.c,
! builtins/{exec,exit,fg_bg,hash,history}.def
! 	- include `bashtypes.h' instead of directly including <sys/types.h> 
  
! builtins/fc.def
! 	- include ../bashtypes.h and ../posixstat.h instead of bashtypes.h
! 	  and posixstat.h
  
! builtins/mkbuiltins.c
! 	- include ../posixstat.h instead of <sys/stat.h>
  
! general.h
! 	- include `bashtypes.h' if RLIMTYPE is defined, so we can fetch
! 	  a definition of quad_t (or whatever) from <sys/types.h> before
! 	  using it in a function prototype
  
! Makefile.in, builtins/Makefile.in
! 	- updated dependencies
  
! 				   2/18
! 				   ----
! builtins/set.def
! 	- new function, set_posix_mode, called when `set [-+]o posix'
! 	  or `shopt -[su] -o posix' is executed.  It sets or unsets
! 	  $POSIXLY_CORRECT and calls sv_strict_posix
  
  subst.c
! 	- in sv_strict_posix, call posix_readline_initialize only if
! 	  the shell is interactive (interactive_shell != 0)
  
! shell.c
! 	- if we are acting like `sh', call posix_readline_initialize
! 	  if the shell is interactive
! 	- moved the code that does posix.2 mode initialization after
! 	  interactive_shell is set, and call posix_readline_initialize
! 	  if interactive_shell is non-zero
  
! bashwait.h
! 	- renamed to unionwait.h, since that is what it defines
  
! posixwait.h
! 	- moved the POSIX 1003.1 job control defines here from jobs.h
  
! jobs.h
! 	- include `posixwait.h'
  
! 				   2/19
! 				   ----
! braces.c
! 	- if SHELL is defined, pass the contents of new-style command
! 	  substitution through without expanding brace constructs between
! 	  the parens -- let the subshell do it
  
! subst.c
! 	- when brace-expanding words, preserve the flags (word->flags) if
! 	  brace expansion does not change the word.  This fixes the problem
! 	  of things like
  
! 		 local -a avar=( ${PATH//: } );
  
! bashline.c
! 	- have shell_expand_line pass a copy of rl_line_buffer to expand_string
! 	  in case there are substitution errors and the string gets freed
  
! 				   2/20
! 				   ----
! expr.c
! 	- make sure that expland and explor set `lasttok' to LAND and LOR,
! 	  respectively, if they parse `&&' or `||'.  This makes the
! 	  precedence code work right
  
! subst.c
! 	- changes so that non-interactive shells exit immediately when a
! 	  parameter that is unset is referenced after `set -u' has been
! 	  executed causes the shell to exit immediately
  
! 				   2/21
! 				   ----
! flags.c
! 	- if `set -r' is executed, call maybe_make_restricted so that $PATH
! 	  and $SHELL are made read-only
  
! execute_cmd.c
! 	- if `set -e' has been executed, and we're inverting a pipeline's
! 	  return status with `!', set CMD_IGNORE_RETURN so a failing
! 	  command does not inadvertently cause the shell to exit before
! 	  the exit status can be inverted.  This is probably only a problem
! 	  with the `eval' builtin.
  
! 				   2/24
! 				   ----
! builtins/hash.def
! 	- add a missing argument of 0 to add_hashed_command
  
! builtins/kill.def
! 	- job identifiers can be used in non-interactive shells as long as
! 	  job control has been turned on with `set -m'
  
! jobs.c
! 	- we want to be notified of stopped jobs if job_control is non-zero,
! 	  even if the shell is not interactive
  
! execute_cmd.c
! 	- make sure shell_execve returns EX_NOTFOUND if execve fails and
! 	  errno is set to ENOENT
! 	- makes sure execute_builtin saves the temporary environment to
! 	  builtin_env for the `eval' builtin, since it can destroy the
! 	  temporary environment when it calls parse_and_execute
  
! bashhist.c
! 	- new variable: hist_last_line_added, set to 1 if the last command
! 	  line was added to the history successfully as a separate entry.
! 	  Used by `history' and `fc'
  
! 				   2/25
! 				   ----
! trap.c
! 	- save line number before executing trap command, because
! 	  parse_and_execute resets it to 1 and the trap command might
! 	  want it
  
! execute_cmd.c
! 	- change to executing_line_number to return trap_line_number if
! 	  the shell is currently running a trap
  
! 				   2/26
  				   ----
! execute_cmd.c
! 	- change to time_command so that a `real' value of 0 does not
! 	  cause a divide-by-zero error when computing cpu percentage
  
! lib/readline/signals.c
! 	- if MUST_REINSTALL_SIGHANDLERS is defined, reinstall the SIGWINCH
! 	  handler in rl_handle_sigwinch
  
! builtins/set.def
! 	- `unset' now rejects attempts to unset names that are not valid
! 	  shell identifiers as errors
! 	- add a description of `-o history' option to help text
  
  subst.c
! 	- in parameter_brace_patsub, we want backslash removal done on
! 	  the replacement if (mflags & MATCH_QUOTED), since the code
! 	  in expand_word_internal will not do it.  We need to call
! 	  expand_string_unsplit directly, since maybe_expand_string does
! 	  not do the right thing
  
! 				   2/28
  				   ----
! execute_cmd.c
! 	- if execute_for_command finds that the iteration variable is readonly,
! 	  decrement loop_level before returning
  
! builtins/break.def
! 	- if the break count is <= 0, display an error message and break out
! 	  of all loops
  
! builtins/command.def
! 	- if PATH is unset, and we're using command -p, we don't want PATH
! 	  to be set to the empty string when `command' completes
  
! builtins/common.c
! 	- POSIX.2 says `kill -l signum' prints the signal name without the
! 	  leading `SIG' prefix, so check for this_shell_builtin == kill_builtin
! 	  in display_signal_list
  
! builtins/getopts.def
! 	- when invoked without any arguments, `getopts' now prints a usage
! 	  message
  
! 				    3/3
! 				    ---
! builtins/common.c
! 	- add a second argument to get_numeric_arg: if non-zero, the shell
! 	  exits on a bad argument; if not, the shell jumps to top_level
! 	  with a DISCARD argument, which aborts the current command
  
! builtins/{break,exit,history,return,shift}.def
! 	- change calls to get_numeric_argument
  
! lib/readline/funmap.c
! 	- add `dump-macros' to list of bindable names
  
! lib/readline/readline.h
! 	- added extern declaration for rl_prompt (it was apparently missing)
  
! lib/readline/readline.c
! 	- new internal function, _rl_init_line_state, which sets rl_point
! 	  and rl_end to 0, sets the_line to point to _rl_line_buffer, and
! 	  clears the line
  
! lib/readline/callback.c
! 	- if a user's callback function does not clear the line, clear it
! 	  for him by calling _rl_init_line_state
  
! 				    3/4
! 				    ---
! alias.c
! 	- made the readline support functions #ifdef READLINE, so they're
! 	  not compiled into the shell unless readline is
  
! lib/readline/bind.c
! 	- new function _rl_untranslate_macro_value, to expand meta-prefixes
! 	  and other special characters in a macro value for printing by
! 	  _rl_macro_dumper_internal
! 	- call _rl_untranslate_macro_value in _rl_macro_dumper_internal to
! 	  get a printable version of the macro value
  
! lib/readline/readline.c
! 	- new variable, rl_dispatching, set to 1 when we call a function
! 	  from _rl_dispatch
  
! lib/readline/readline.h
! 	- extern declaration for rl_dispatching
  
! lib/readline/complete.c
! 	- make sure S_ISCHR and S_ISBLK are defined before using them
  
! lib/readline/terminal.c
! 	- add a new #define NEED_EXTERN_PC.  Define this if the termcap
! 	  or curses libraries need `extern' before declarations of PC,
! 	  BC, and UP
! 
! lib/readline/{readline,terminal,histfile}.c
! 	- changes to compile on OS/2 with OS/2 `EMX' port of gcc, originally
! 	  sent by ilya@math.ohio-state.edu
  
! builtins/set.def
! 	- fixed a bug in set_shellopts that caused the shell to crash if
! 	  there were no shell options set
  
! 				    3/5
! 				    ---
! configure.in,Makefile.in
! 	- choose run-all or run-minimal as the test script based on whether
! 	  the --enable-minimal-config option was given to configure
  
! builtins/setattr.def
! 	- fixed `export -p' and `readonly -p' so that they output `export'
! 	  or `readonly' when in POSIX mode, as POSIX.2 specifies
  
! 				    3/6
! 				    ---
! builtins/setattr.def
! 	- make `readonly -a var=(...)' work just like `declare -ar var=(...)',
! 	  since the two logically mean the same
! 	- `readonly -f' and `export -f' don't print the function definition
! 	  for each readonly or exported function, respectively, when in
! 	  POSIX mode
! 
! jobs.c, nojobs.c
! 	- don't report status for processes killed by SIGPIPE if
! 	  DONT_REPORT_SIGPIPE is defined
  
! config.h.top
! 	- added a commented-out define for DONT_REPORT_SIGPIPE
  
! execute_cmd.c
! 	- `time' can now be used to time background pipelines, and reports
! 	  the timing statistics when the pipeline completes
  
! [bash-2.01-alpha1 frozen]
  
! 				   3/12
! 				   ----
! subst.c
! 	- move the parent end of the pipe file descriptor used for process
! 	  substitution to a high, unused file descriptor to avoid clashes
! 	  with redirections performed explicitly by a script
  
! configure.in
! 	- added a `--with-curses' argument so curses can be forcibly chosen
! 	  over libtermcap (some Unix versions ship lousy termcap databases)
  
! support/mkconffiles
! 	- new script to create _distribution and _patchlevel from values
! 	  contained in `configure'
  
! doc/bashref.texi
! 	- updated installation instructions
  
! 				   3/13
  				   ----
! general.c
! 	- if `getgroups' returns 0, make sure we add the primary group id
! 	  as GROUPS[0].
! 	- if we have getgroups, and the primary gid is not in the array
! 	  getgroups returns, add it as group_array[0] and shuffle everything
! 	  up one element.  This ensures that current_user.gid == group_array[0]
! 	  all the time
! 
! tests/builtins.tests
! 	- changes to avoid stray variables in environment when the shell
! 	  version of printenv is used with bash as /bin/sh, running the
! 	  `exec -c' tests.
  
! 				   3/14
  				   ----
! builtins/cd.def
! 	- spelling correction is no longer enabled by default
  
! support/bashbug.sh
! 	- if the shell's release status is alpha or beta, offer the option
! 	  of sending the bug report to the bash-testers mailing list as
! 	  well as to chet
  
! 				   3/17
! 				   ----
! configure.in
! 	- configure --without-gnu-malloc by default on *-sgi-irix6* because
! 	  their code needs 8-byte alignment
  
! support/bashbug.sh
! 	- ``' needs to be quoted with a backslash in double-quoted strings
  
! aclocal.m4
! 	- slight changes to the strcoll test, since AIX 4.2 returns -1, 0, or
! 	  1 from strcmp(3) but a numeric collation order difference from
! 	  strcoll(3)
  
! 				   3/18
! 				   ----
! command.h
! 	- new redirection error code:  HEREDOC_REDIRECT
  
  execute_cmd.c
! 	- return HEREDOC_REDIRECT from do_redirection_internal when
! 	  here_document_to_fd cannot create the temp file for a here document
! 	- changed redirection_error to print a meaningful message when
! 	  here document temp file creation fails (HEREDOC_REDIRECT)
! 
! 				   3/19
! 				   ----
! subst.c
! 	- changes to match_pattern_char: return 1 if the first char of the
! 	  pattern is `?' only if the string is non-null; just return 1 if
! 	  the first char of the pattern is `[' and the string is non-empty
! 	  rather than try to re-implement the brace matching code from fnmatch
  
! lib/glob/fnmatch.c
! 	- some changes from glibc-2.0.1 posix/fnmatch.c
  
! 				   3/21
! 				   ----
! variables.c
! 	- only do the initialization of `ignoreeof' if the shell is
! 	  interactive
! 	- reset values of $SHLVL > 1000 to 1 in adjust_shell_level, and
! 	  don't call itos, since we don't need its generality
! 	- new function, initialize_shell_level, just calls adjust_shell_level
! 	  with argument of 1.  If $SHLVL is unset, adjust_shell_level will
! 	  deal with it correctly
! 	- change initialize_shell_variables to not malloc a copy of each
! 	  environment variable, just keep two pointers into the env string:
! 	  one for the name, one for the value
! 	- broke the code that computes the value of $BASH out into a separate
! 	  function: get_bash_name
! 	- get_bash_name special-cases shell_name with a `./' prefix when
! 	  initializing $BASH
! 	- new function: set_home_var, sets $HOME to current_user.home_dir if
! 	  it's not already set, calling get_current_user_info if
! 	  current_user.home_dir is NULL
! 	- new function: set_shell_var, sets $SHELL to current_user.shell if
! 	  it's not already set, calling get_current_user_info if
! 	  current_user.shell is NULL
! 	- changed places that reference information in current_user to check
! 	  for NULL values of the member they're interested in and call
! 	  get_current_user_info if necessary
  
! shell.c
! 	- moved the code that sets up the information in current_user that
! 	  comes from the password file into a new function,
! 	  get_current_user_info
! 	- shell_initialize calls get_current_user_info only if the shell is
! 	  interactive
  
! externs.h
! 	- new extern declaration for get_current_user_info(), so variables.c
! 	  can use it
  
! 				   3/24
  				   ----
! lib/tilde/tilde.c
! 	- if SHELL is defined, user the current_user struct info to find
! 	  the user's home directory rather than calling getpwuid
  
! 				   3/25
  				   ----
- nojobs.c
- 	- don't try to open /dev/tty when getting or setting the tty state
- 	  and window size; use shell_tty instead
- 	- initialize shell_tty to standard error in initialize_job_control
- 	- only fetch the tty state initially if the shell is interactive
  
! general.c
! 	- open /dev/tty with the O_NONBLOCK flag
  
! variables.c
! 	- changed all_vars so that it sorts its output all the time, not
! 	  just when in POSIX mode.  This means that the output of `set'
! 	  and `export' will be sorted
  
! builtins/set.def
! 	- in initialize_shell_options, only call parse_shellopts if we
! 	  inherited $SHELLOPTS from the environment
! 	- make sure we call parse_shellopts from initialize_shell_options
! 	  with a copy of the value of SHELLOPTS, in case one of the functions
! 	  called while setting one of the variables modifies $SHELLOPTS
  
  lib/readline/readline.c
! 	- make sure that digit arguments don't change the state of
! 	  rl_last_func
  
! support/printenv.c
! 	- new file, printenv(1) clone, used to avoid environment variables
! 	  that might be set automatically when using printenv.sh
  
! lib/tilde/tilde.c
! 	- if SHELL is defined, don't call getenv to get the value of $HOME,
! 	  call get_string_value () directly
  
! 				   3/26
! 				   ----
! lib/readline/histexpand.c
! 	- abstracted the `#ifdef SHELL' stuff that checked for special cases
! 	  that should not be history expanded ([!...], ${!...}) into a call
! 	  to a function that is the value of the
! 	  new history_inhibit_expansion_function variable
  
! lib/readline/history.h
! 	- extern declaration for history_inhibit_expansion_function
  
! bashhist.c
! 	- new function, bash_history_inhibit_expansion, which checks for
! 	  the special cases in which history expansion should be inhibited
! 	- changes to the various history initialization functions to
! 	  set history_inhibit_expansion_function
  
! lib/readline/doc/hstech.texinfo
! 	- documented history_inhibit_expansion_function
  
! lib/readline/shell.c
! 	- new file, containing versions of the functions that are provided
! 	  by bash when readline is linked as part of bash
! 	- new function: get_env_value().  If SHELL is defined, this calls
! 	  get_string_value().  If SHELL is not defined, this calls getenv()
  
! lib/readline/histexpand.c
! 	- moved single_quote() to shell.c
  
! lib/readline/util.c
! 	- moved savestring() to shell.c
  
! lib/readline/terminal.c
! 	- moved set_lines_and_columns() to shell.c
  
! lib/readline/Makefile.in, Makefile.in
! 	- added shell.c and shell.o to the appropriate variables that contain
! 	  the files comprising the readline and history libraries
! 
! lib/readline/signals.c
! 	- introduced two new cpp defines:  HANDLE_JOB_SIGNALS and
! 	  HANDLE_SIGTERM.  When HANDLE_JOB_SIGNALS is defined, SIGTSTP,
! 	  SIGTTIN, and SIGTTOU are caught and handled.  When HANDLE_SIGTERM
! 	  is defined, SIGTERM is caught and handled.  These are both
! 	  defined automatically if SHELL is not defined
! 
! lib/readline/{bind,histfile,nls,readline,terminal}.c
! 	- call get_env_value instead of getenv().  This should remove the
! 	  dependency on being able to redefine getenv() in oslib.c
  
! shell.c
! 	- added a missing argument of -1 to the call to list_minus_o_opts.
! 	  Now `bash -o' lists all options, not just random ones depending
! 	  on what's on the stack
  
! 				   3/28
! 				   ----
! builtins/ulimit.def
! 	- change RLIM_INFINITY to the hard limit only if the hard limit is
! 	  greater than the current (soft) limit
  
! hashlib.c
! 	- return immediately from flush_hash_table if the hash table passed
! 	  is NULL
  
! 				    4/1
  				    ---
! shell.c
! 	- remove call to initialize_filename_hashing -- initialize the hash
! 	  table the first time a hashed command has to be remembered
  
! hashcmd.c
! 	- new file, with functions to perform filename hashing and lookup
! 	  taken from builtins/hash.def and builtins/common.c
! 	- change to remember_filename -- call initialize_filename_hashing
! 	  if hashing_initialized is 0
! 
! hashcmd.h
! 	- new file, mostly from builtins/hashcom.h, with extern function
! 	  declarations added
  
! execute_cmd.c, builtins/{hash,type}.def
! 	- include hashcmd.h for hash function and type definitions
  
! builtins/{common.{c,h},hash.def}
! 	- moved hashing functions and declarations to hashcmd.c/hashcmd.h
  
! Makefile.in, builtins/Makefile.in
! 	- changed source and object file definitions and dependencies because
! 	  of addition of hashcmd.h and hashcmd.c
  
! builtins/hash.def
! 	- return immediately from print_hashed_commands if hashed_commands
! 	  is empty, indicating that the hash table has not been initialized
  
! 				    4/2
! 				    ---
! lib/readline/bind.c
! 	- fixed translation of ESC in rl_untranslate_keyseq and
! 	  rl_untranslate_macro_value
  
! lib/readline/{readline,kill}.c
! 	- added an argument to _rl_fix_point telling it whether or not to
! 	  fix up the mark also; changed calls to _rl_fix_point to add the
! 	  appropriate argument
  
! Makefile.in
! 	- changed the substitution delimiter in the `sed' commands that
! 	  create bashbug from `:' to `%' to avoid conflicts with options
! 	  containing `:'
  
! 				    4/3
! 				    ---
! print_cmd.c
! 	- made the initial value and the default growth value for the
! 	  printed command somewhat smaller -- we don't really need to
! 	  allocate 4096 bytes for the printed command
! 	- added stdarg support to xprintf if PREFER_STDARG is defined
  
! stringlib.c
! 	- changed strip_trailing to take the index of the last character
! 	  as the second argument, saving a (useless) call to strlen, since
! 	  the caller already knows where the end of the string is
  
! subst.c
! 	- change call to strip_trailing in command_substitute to add the
! 	  new second argument
  
! externs.h
! 	- changed extern declaration for strip_trailing
  
! 				    4/4
! 				    ---
! Makefile.in, configure.in, lib/malloc/Makefile.in
! 	- changed the strategy for picking which `malloc' to include by
! 	  having configure define a `malloc target' and the Makefile in
! 	  lib/malloc implementing rules for that target
  
! 				    4/5
  				    ---
! Makefile.in
! 	- slightly changed the rules for remaking `parser-built':  it is
! 	  now a copy of y.tab.h, updated only when the contents of y.tab.h
! 	  change
! 	- everything that used to depend on y.tab.h now depends on
! 	  parser-built
  
! 				    4/6
! 				    ---
! execute_cmd.c, print_cmd.c
! 	- use #include <y.tab.h> so we pick up y.tab.h from the build
! 	  directory instead of the source directory if it happens to be
! 	  recreated in the build directory
  
! 				    4/7
! 				    ---
! bashline.c
! 	- fixed another problem with `pwd`/[TAB] thinking that the `/
! 	  started an unclosed command substitution, generating errors
  
! 				    4/8
  				    ---
! general.c
! 	- renamed bash_tilde_expansion_failure_hook to be
! 	  bash_special_tilde_expansions, since that more accurately reflects
! 	  its function
! 	- changed tilde_initialize so that there is no failure hook -- the
! 	  special expansions are handled first with the preexpansion hook
! 
! lib/tilde/tilde.c
! 	- new variable: tilde_expansion_preexpansion_hook -- if non-null, it
! 	  points to a function that is called before standard tilde expansion
! 	  is attempted
  
! lib/tilde/tilde.h
! 	- extern declaration for tilde_expansion_preexpansion_hook
  
! doc/{bash.{1,html},bashref.texi}
! 	- added optional open paren to description of `case' command syntax
  
! 				    4/9
! 				    ---
! variables.c
! 	- on qnx, set and export a variable `NODE' which contains the QNX
! 	  `node id'
  
! general.c
! 	- QNX system can now handle pathnames with a leading `//'
  
! configure.in
! 	- added `-Dqnx' to LOCAL_CFLAGS on QNX machines
  
! lib/malloc/getpagesize.h
! 	- some systems need sysconf(_SC_PAGE_SIZE) to obtain the page size;
! 	  added code to check for it
  
! 				   4/10
! 				   ----
! print_cmd.c
! 	- include the prototype for cprintf only if PREFER_STDARG is defined,
! 	  otherwise just have a K&R-style forward function declaration
  
! hashlib.h
! 	- reduced the default number of buckets in a hash table to 53
  
! lib/tilde/tilde.c
! 	- prime the result string in tilde_expand by allocating a new string
! 	  that's as long as the input string (+16 if a tilde appears in
! 	  the string to be expanded).  This should reduce the number of
! 	  reallocs
  
! subst.c
! 	- broke the code that reads the output of a command substitution
! 	  through the pipe to the subshell out into a separate function:
! 	  read_comsub().  This does not use stdio, but rather reads
! 	  directly from the pipe into a local 128-character buffer
  
! 				   4/11
! 				   ----
! execute_cmd.c
! 	- some systems need both <sys/time.h> and <time.h>, so include both
! 	  if it's possible, otherwise include <sys/time.h> (if present)
  
! lib/readline/rl{tty,defs}.h
! 	- moved includes of <sys/stream.h>, <sys/ptem.h>, etc. to rltty.h
  
! lib/readline/terminal.c
! 	- include rltty.h after rldefs.h
  
! variables.c
! 	- changes to make environment creation faster and use less memory
! 	  (fewer malloc/free calls, too):
  
! 		o two new variables: export_env_index (how many environment
! 		  strings are in export_env) and export_env_size (the
! 		  number of slots for strings allocated in export_env)
! 		o added new function add_to_export_env, since adding the
! 		  exported shell variables and shell functions does not
! 		  need to search the export_env for a definition to supersede
! 		  (we just cleared it out!)
! 		o renamed add_or_supersede to add_or_supersede_exported_var,
! 		  since it always works on export_env, and changed the second
! 		  argument to a flag saying whether or not to allocate a new
! 		  copy of the string placed into the environment
! 		o changed calls to add_or_supersede to the new
! 		  add_or_supersede_exported_var with the appropriate flags
! 		o don't free and reallocate export_env in maybe_make_export_env,
! 		  just free the strings and start anew
! 		o prime the size of export_env from the total number of shell
! 		  variables and shell functions -- this will always be enough
! 		  for the exported shell functions and variables, and big
! 		  enough most of the time for the entire environment
! 
! builtins/cd.def
! 	- efficiency hack in bindpwd():  if PWD is exported, we will have to
! 	  rebuild the entire exported environment after every time we change
! 	  directories.  What we do is see if array_needs_making changes value
! 	  from 0 to 1 after bind_variable ("PWD", dirname) is called, and
! 	  that PWD is exported.  If that happens, we just replace the value
! 	  of PWD in the exported environment with a call to
! 	  add_or_supersede_exported_var
! 
! bashline.c, parse.y
! 	- check calls to pre_process_line to make a fresh copy of the line
! 	  if pre_process_line returns what it was passed, in preparation
! 	  for future changes
  
! bashhist.c
! 	- pre_process_line now returns its argument if it did not make
! 	  any changes to it
  
! alias.c
! 	- free the bucket entry holding the alias to be removed in
! 	  remove_alias, as well as the data
  
! 				   4/14
  				   ----
! unwind_prot.c
! 	- if an unwind-protect frame is being discarded, and its cleanup
! 	  function is `restore_variable', the `arg' member points to a
! 	  SAVED_VAR that must be freed.  This change is made in
! 	  remove_unwind_protect_internal and unwind_frame_discard_internal
  
! parse.y
! 	- need to free memory allocated by parse_arith_cmd if it is an
! 	  arithmetic command, after using it to make a new word
  
! subst.c
! 	- fixed some memory leaks caused by not freeing the argument to
! 	  make_bare_word, which duplicates its string argument
! 	- need to dispose list generated by list_rest_of_args in
! 	  paramter_list_remove_pattern
! 	- make sure the return value from getpattern() is freed
! 	- make sure array_value_internal always returns newly-allocated
! 	  memory
! 	- get_var_and_type returns a new type: VT_ARRAYMEMBER if the
! 	  string passed is of the form var[index]
! 	- make sure parameter_brace_substring frees the memory allocated
! 	  by get_var_and_type if verify_substring_values returns 0
! 
! hashlib.c, hashlib.h
! 	- new function, dispose_hash_table (table), which frees the
! 	  table's bucket array and the table itself
  
! alias.c
! 	- call dispose_hash_table from delete_all_aliases instead of just
! 	  freeing the table
  
! pathexp.c
! 	- make sure to free `newnames' (but *not* its contents) before
! 	  returning from ignore_globbed_names
  
! builtins/exec.def
! 	- make sure the argv created to pass to shell_execve is freed if
! 	  the execve fails and we're not exiting on failed execs
  
! expr.c
! 	- broke evalexp into two functions: evalexp, which sets up the
! 	  jmp_buf that errors jump to, and subexpr, which does the
! 	  evaluation and pushing and popping of contexts
! 	- readtok now calls subexpr to evaluate subexpressions in
! 	  parentheses
! 	- evalexp now takes an additional paramter, a pointer to an int.
! 	  If the expression contains errors, the location to which this
! 	  points gets 0, otherwise it gets 1 to show that the value
! 	  returned may be used.  This plugs up memory leaks that were
! 	  the result of evalexp() longjmping back to top_level
! 	- fixed a memory leak: expr_stack[0] was not being freed
  
! externs.h
! 	- changed extern declaration for evalexp
! 
! variables.c, subst.c, builtins/let.def
! 	- changed calls to evalexp appropriately.  They either cause a
! 	  longjmp (top_level, DISCARD) (which is what the old stuff in
! 	  expr.c did) or are handled by returning an appropriate error
! 	  value (e.g., &expand_word_error in subst.c)
  
! 				   4/16
! 				   ----
! shell.c
! 	- make sure to free dollar_vars[0] before assigning it the first
! 	  argument following `-c command'
  
! variables.c
! 	- if unsetting a local variable with a previous context, make sure	
! 	  to free the hash table element used to store the local variable
  
! lib/readline/terminal.c
! 	- rearrange the includes so <sys/ioctl.h> is included before rltty.h,
! 	  as it is in rltty.c
  
! 				   4/17
  				   ----
! flags.c
! 	- new function: reset_shell_flags, which resets all of the flags
! 	  back to their initial values
  
! flags.h
! 	- extern declaration for reset_shell_flags
  
! builtins/set.def
! 	- new function: reset_shell_options, which resets all of the -o
! 	  options that are not also shell flags back to their initial values
  
! builtins/shopt.def
! 	- new function: reset_shopt_options, which resets all of the shopt
! 	  options that are not also shell flags or -o options back to their
! 	  initial values
  
! builtins/common.h
! 	- extern declarations for reset_shell_options and reset_shopt_options
  
! execute_cmd.c
! 	- broke the code that reinitializes things when an executable script
! 	  without a leading `#!' is found out into a new function:
! 	  initialize_subshell
! 	- initialize_subshell now calls the reset_* functions that reset the
! 	  shell flags and options
! 
! general.c, general.h
! 	- move_to_high_fd now takes a third argument: the highest fd at which
! 	  to start looking.  If that's less than 20, the maximum number of
! 	  open files as returned by getdtablesize() is used (which is what
! 	  it did before this)
  
! jobs.c, shell.c, subst.c
! 	- changed calls to move_to_high_fd appropriately
  
! [bash-2.01-beta1 frozen]
  
! 				   4/18
! 				   ----
! general.c
! 	- itos now uses a local char buffer to do its conversion, but still
! 	  returns newly-allocated memory
  
! 				   4/21
! 				   ----
! variables.c
! 	- be a little more careful when checking for backwards-compatibility
! 	  with exported function definitions
  
! 				   4/22
  				   ----
! builtins/ulimit.def
! 	- translate RLIM_INFINITY to limit.rlim_max if the current limit is
! 	  less than or equal to the hard limit, not just strictly less than
! 	  (the change of 3/28 was too drastic)
  
! 				   4/23
! 				   ----
! oslib.c
! 	- fixed definition of to_lower on machines without strcasecmp
  
! trap.c
! 	- don't free the trap command in change_signal if the SIG_INPROGRESS
! 	  is set in the signal's flags -- it will cause memory to be freed
! 	  twice if a trap command resets the signal handler more than once,
! 	  and _run_trap_internal keeps a pointer to the trap command so it
! 	  can free it, so there will be no leaks
  
! 				   4/24
  				   ----
! aclocal.m4,configure.in
! 	- removed BASH_CC_WORKS, since AC_PROG_CC now has the functionality
  
! shell.c, externs.h
! 	- get_current_user_info is now a void function
  
! bashline.c
! 	- alias_expand_line_internal was removed
! 	- new function, alias_expand_line, performs alias expansion on
! 	  rl_line_buffer and either replaces rl_line_buffer or signals
! 	  an error
! 	- new bindable commands: alias-expand-line and
! 	  history-and-alias-expand-line, available if ALIAS is defined
! 
! 				   4/25
! 				   ----
! Makefile.in, lib/malloc/malloc.c
! 	- changed the define that turns on malloc range checking from
! 	  `rcheck' to `RCHECK'
  
! lib/readline/isearch.c
! 	- fixed a couple of places where rl_search_history would try to
! 	  free a NULL pointer
  
! 				   4/29
  				   ----
! unwind_prot.c
! 	- fixed a problem with saving a variable that is a null pointer
! 	  in unwind_protect_var.  It happens only on machines where the
! 	  size of a pointer is not the size of an int.  The old FASTCOPY
! 	  code would copy the eight bytes at memory location zero, which
! 	  did not necessarily make a null pointer
  
! 				   4/30
  				   ----
! shell.c
! 	- run_startup_files should turn off job control, since the startup
! 	  files should be run without job control enabled -- this makes
! 	  SIGINT interrupt startup file execution again
! 	- if we get a SIGINT or other longjmp to top_level while executing
! 	  the startup files, re-enable job control for interactive shells
! 	  before setting locally_skip_execution
  
! 				    5/2
! 				    ---
! lib/readline/nls.c
! 	- if we have setlocale(3), don't bother with checking the
! 	  environment variables for valid values; just use setlocale()
! 	  to set the locale categories from the environment variables
! 	  directly and go into eight-bit mode if the current locale is
! 	  not C or POSIX
  
! 				    5/5
! 				    ---
! sig.c
! 	- make sure that the handler for SIGPROF is not changed if it has
! 	  been set to something other than SIG_IGN or SIG_DFL -- this makes
! 	  profiling work after the terminating signals have been initialized
  
! bashline.c
! 	- if a filename containing `!' is completed, and the user has started
! 	  the string with a `"', change the completion style to backslash-	
! 	  quoting, since there's no way to use `!' with double quotes (this
! 	  requires more changes to readline to really work right)
  
! 				    5/6
! 				    ---
! lib/readline/complete.c
! 	- changes to make_quoted_replacement, insert_all_matches, and
! 	  insert_match and their callers to allow the application-specific
! 	  filename quoting function to change the quote character (e.g., for
! 	  bash to change a filename containing a `!' and started with a
! 	  double quote by the user into a filename with the `!' quoted by
! 	  a backslas and no double quote)
  
! 				    5/8
! 				    ---
! jobs.c
! 	- new function: nohup_all_jobs(), calls nohup_job for each entry in
! 	  the jobs list
! 	- delete_all_jobs is now global
  
! jobs.h
! 	- new extern declarations for delete_all_jobs() and nohup_all_jobs()
  
! builtins/jobs.def
! 	- `disown' without any jobspec arguments means the current job.  Fix
! 	  a core dump printing the error message when there is no current job
  
! 				   5/12
! 				   ----
! subst.c
! 	- process an expansion like $((foo); bar) as a command substitution,
! 	  not as an arithmetic expansion.  An arithmetic expansion must have
! 	  a closing `))'
  
! 				   5/14
! 				   ----
! builtins/evalstring.c
! 	- the third argument to parse_and_execute() is now a flags word.
! 	  The caller can control the value of `interactive' and whether
! 	  or not history is disabled while parse_and_execute() runs
  
  builtins/common.h
! 	- new #defines for the flag values for parse_and_execute()
  
! {bashline,jobs,shell,subst,trap,variables}.c, parse.y, builtins/evalfile.c,
! builtins/{eval,fc}.def
! 	- changed calls to parse_and_execute appropriately
! 
! builtins/evalfile.c
! 	- if _evalfile() is passed FEVAL_HISTORY as part of the flags arg,
! 	  don't pass SEVAL_NOHIST to parse_and_execute
! 	- new function: fc_execute_file, which sets FEVAL_HISTORY in the
! 	  flags argument to _evalfile()
! 
! bashline.c
! 	- call bash_add_history instead of add_history from
! 	  vi_edit_and_execute_command so the bash state variables get
! 	  updated properly.  This keeps the `v' command from operating
! 	  on an empty command when the history list is stifled
  
! bashhist.c
! 	- bash_add_history is now global
  
! bashhist.h
! 	- extern declaration for bash_add_history
  
! builtins/fc.def
! 	- call fc_execute_file instead of maybe_execute_file in the
! 	  edit-and-re-execute case (fc -e ...)
! 	- don't manually insert the commands from the file created by `fc -e'
! 	  into the history list, just set remember_on_history and let
! 	  fc_execute_file take care of telling parse_and_execute to do the
! 	  right thing.  This makes compound commands and the `cmdhist'
! 	  and `lithist' settings work better.  This supersedes the fix of
! 	  1/27.  This was reported again by rchen@fractal.eng.yale.edu.
  
! parse.y
! 	- the body of a `for' command (the commands between do...done or
! 	  {...}) should be a `compound_list' instead of a `list'.  Problem
! 	  reported by cpg@research.bell-labs.com
  
! 				   5/19
! 				   ----
! lib/readline/complete.c
! 	- in filename_completion_function, if we find that the directory
! 	  pointer (return value from opendir(3)), is not null when state
! 	  is 0 (indicating that this is the first time the completion
! 	  function has been called for the current completion), call
! 	  closedir on it, assuming that it was left open by a previous
! 	  (interrupted) completion
  
! [bash-2.01-beta2 frozen]
  
! 				   5/27
! 				   ----
! Makefile.in
! 	- make sure that `make distclean' (and other clean targets) remove
! 	  the `printenv' executable
  
! tests/execscript, tests/redir.tests
! 	- make sure to set LANG=C and LC_ALL=C so the messages show up in
! 	  English
  
! tests/run-func
! 	- add a warning about exported functions in the environment
  
! 				   5/29
! 				   ----
! builtins/hash.def
! 	- if one of the arguments passed to `hash' is an absolute pathname,
! 	  just continue the loop, don't do list=list->next first.  This
! 	  fixes the `hash a/b' -> core dump bug
  
! 				   5/30
! 				   ----
! general.c
! 	- change canonicalize_pathname to leave a leading `/' alone, as
! 	  POSIX requires
  
! 				    6/2
! 				    ---
! support/xenix-link.sh
! 	- shell script for linking bash under Xenix
  
- 				    6/3
- 				    ---
  bashline.c
! 	- fixed a memory leak in command_word_completion_function, courtesy
! 	  of a.pfaller@pop.gun.de
! 
! hashcmd.c
! 	- fixed find_hashed_filename to always return a newly-allocated
! 	  string
! 
! execute_cmd.c
! 	- since find_hashed_filename returns newly-allocated memory, don't
! 	  call savestring() on it, and free it if the data is stale (in
! 	  search_for_command()).  Another memory leak fixed courtesy of
! 	  a.pfaller@pop.gun.de
  
! builtins/type.def
! 	- free the value returned by find_hashed_filename
  
! [bash-2.01-release frozen]
! 
! 				    6/6
! 				    ---
! configure.in
! 	- force shlicc2 and libc malloc for BSD/OS 3.0
  
! 				    6/9
! 				    ---
! doc/Makefile.in
! 	- don't create ${man3dir}, since we're not installing the readline
! 	  manual page
  
! lib/readline/readline.h
! 	- rl_dispatching should be declared `extern'
! 	  [in bash-2.01.1]
  
! 				   6/10
! 				   ----
! lib/malloc/Makefile.in
! 	- make sure ${ALLOCA_SOURCE} is preceded by ${srcdir} so that things
! 	  work when building in a directory other than the source directory
! 	  [in bash-2.01.1]
! 
! 				   6/30
! 				   ----
! lib/readline/examples/rltest.c
! 	- don't free the value returned by history_list()
! 
! lib/readline/histfile.c
! 	- open the history file for writing with mode 0600 for better
! 	  security
! 	  [in bash-2.01.1]
  
! execute_cmd.c
! 	- select_query now uses legal_number to decide whether the user's
! 	  selection is a valid number, and just executes the loop again if
! 	  invalid input is entered
! 	  [in bash-2.01.1]
  
! 				    7/1
! 				    ---
! builtins/evalstring.c
! 	- fix to parse_and_execute so `bash -c 'time [-p] zzz'' works right
! 	  [in bash-2.01.1]
  
! execute_cmd.c
! 	- fix to execute_command_internal so that `bash -c time [-p] (zzz)''
! 	  works right
! 	  [in bash-2.01.1]
! 	- print_formatted_time should pass a long as the fourth parameter
! 	  to mkfmt 
! 	  [in bash-2.01.1]
  
! externs.h, shell.c
! 	- `exit_shell' is now a void function
  
! hashlib.c
! 	- print_table_stats is now a void function
  
! mailcheck.c
! 	- made add_mail_file check for the filename in the mail file list
! 	  using the expanded filename, since that is what it puts into
! 	  the list
! 	  [in bash-2.01.1]
  
! variables.c
! 	- for the time being, PWD will be auto-exported, since some systems
! 	  seem to expect it
  
! doc/bashref.texi, lib/readline/doc/{hist,rlman}.texinfo
! 	- added necessary `dircategory' and `direntry' commands to make
! 	  `install-info' work correctly
  
! Makefile.in
! 	- move $(LDFLAGS) after $(BUILTINS_LDFLAGS) and $(LIBRARY_LDFLAGS) on
! 	  the line that links bash
  
! doc/texinfo.tex
! 	- upgraded to version 2.185 from the texinfo-3.9 distribution
  
! lib/tilde/tilde.c
! 	- fixed a bug in tilde_expand so that enough space is allocated for
! 	  the string and terminating null byte if a `~' does not appear.
! 	  This was masked before by the bash malloc()
! 	  [in bash-2.01.1]
  
! 				    7/3
  				    ---
! aclocal.m4
! 	- new test, BASH_TYPE_INT32_T, to check which builtin C type is
! 	  32 bits wide
! 	- new test, BASH_TYPE_PTRDIFF_T, to check which builtin C type is
! 	  appropriate for pointer arithmetic
! 
! configure.in
! 	- check sizes of int and long, and for the existence of an int32_t
! 	  basic system type.  Call BASH_TYPE_INT32_T if int32_t is not
! 	  defined anywhere in the system header files
! 	- check size of (char *), and for the existence of a ptrdiff_t
! 	  basic system type.  Call BASH_TYPE_PTRDIFF_T if ptrdiff_t is not
! 	  defined anywhere in the system header files
! 	- added a check for <stddef.h>
  
! config.h.in
! 	- add lines for SIZEOF_INT, SIZEOF_LONG, SIZEOF_CHAR_P, int32_t,
! 	  u_int32_t, and ptrdiff_t
! 	- added line for HAVE_STDDEF_H
  
! lib/malloc/malloc.c
! 	- new version, with many changes and much better memory usage; old
! 	  (bash-2.01) version is lib/malloc/omalloc.c
  
! lib/malloc/gmalloc.c
! 	- new version, with a number of changes and range checking included
! 	  by default; old (bash-2.01) version is lib/malloc/ogmalloc.c
  
! execute_cmd.c
! 	- applied patch from 5/27 to make execute_simple_command fork early
! 	  if it's part of a pipeline.  This keeps assignment statements or
! 	  other commands that don't require a builtin, function, or disk
! 	  command to be executed from modifying the shell's environment
! 
! tests/exec?.sub
! 	- renamed from tests/execscript.sub? because those filenames are
! 	  too long for System V 14-char filename systems
! 
! tests/source?.sub
! 	- renamed from tests/source.sub? because those filenames are bad
! 	  for DOS/Windows
! 
! tests/getopts?.sub
! 	- renamed from tests/getopts.sub? because those filenames are bad
! 	  for DOS/Windows
! 
! tests/histexp.{tests,right}
! 	- renamed from histexpand.{tests,right} because those filenames are
! 	  too long for System V 14-char filename systems
! 
! tests/trap1.sub
! 	- renamed from trap.sub1 because that filename was bad for DOS/Windows
! 
! tests/ifs-[123].right
! 	- renamed from ifs.[123].right because those filenames were bad for
! 	  DOS/Windows
! 
! tests/ifs-[123].test
! 	- renamed from ifs-test-[123].sh because those filenames were bad
! 	  for DOS/Windows
! 
! examples/startup-files/Bashrc.bfox
! 	- renamed from examples/startup-files/Bashrc because that filename
! 	  conflicts with examples/startup-files/bashrc on case-insensitive
! 	  file systems
! 
! tests/exec.right
! 	- renamed from execscript.right because that filename is too long
! 	  for System V 14-char filename systems
! 
! tests/run-set-e
! 	- renamed from run-set-e-test
! 
! tests/misc/perftest
! 	- renamed from tests/misc/haertel.perftest because that filename is
! 	  too long for System V 14-char filename systems
  
! lib/glob/fnmatch.c
! 	- new version with full POSIX.2 BRE matching (character classes,
! 	  collating symbols, equivalence classes), full support for
! 	  strcoll(3), and case-insensitive pattern matching
  
! lib/glob/fnmatch.h
! 	- new version, with necessary symbols for the new fnmatch.c
  
! tests/posixpat.{tests,right}, tests/run-posixpat
! 	- test suite for the POSIX.2 BRE pattern matching code
  
! variables.c
! 	- make sure that array assignment using the compound syntax empties
! 	  the array before doing the assignment
! 	  [in bash-2.01.1]
  
! trap.c
! 	- new function, trap_to_sighandler(sig), which returns the correct
! 	  trap handler for SIG depending on the information in sigmodes[sig]
! 	  [in bash-2.01.1]
! 
! sig.h
! 	- extern declarations for trap_handler and trap_to_sighandler
! 	  [in bash-2.01.1]
  
! jobs.c
! 	- if we get an interrupt while waiting for a command to complete,
! 	  and there was a trap set on SIGINT that resets the handler to
! 	  SIG_DFL, the value that waitchld uses for old_trap_handler will
! 	  be wrong (it will be trap_handler, but trap_handler no longer
! 	  knows anything about SIGINT).  If old_signal_handler is trap_handler,
! 	  but signal_is_trapped(SIGINT) returns 0, we need to call
! 	  trap_to_sighandler to decide what to do
! 	  [in bash-2.01.1]
  
! 				    7/7
! 				    ---
! locale.c
! 	- fix to set_locale_var to handle an assignment to LC_ALL (e.g., as
! 	  the result of `unset LANG') when default_locale is null
! 	  [in bash-2.01.1]
  
! 				    7/8
! 				    ---
! builtins/umask.def, doc/{bash.{1,html},bashref.texi}
! 	- added `-p' option for umask to print output in a reusable form
  
! 				    7/9
! 				    ---
! doc/{bash.{1,html},bashref.texi}
! 	- removed descriptions of `-type', `-path', and `-all' options to
! 	  the `type' builtin in preparation for removing them in the next
! 	  release
! 
! builtins/type.def
! 	- removed mention of `-type', `-path', and `-all' options from the
! 	  long help description
  
! error.c, error.h
! 	- new function: internal_warning, for warning messages
  
! variables.c
! 	- changed a call to internal_error to use internal_warning
! 	- modified change of 7/3 so that arrays are not emptied until
! 	  just before the shell is about to assign the new values, so
! 	  the old value can be used to generate the rhs of the assignment,
! 	  if necessary.  This is how `normal' shell variables work
! 	  [in bash-2.01.1]
! 
! jobs.c, jobs.h
! 	- delete_job now takes a second int argument and prints a warning
! 	  message when deleting a stopped job if the second argument is
! 	  non-zero
  
! jobs.c, builtins/jobs.def
! 	- changed all calls to delete_job to provide a proper second arg
  
! lib/readline/bind.c
! 	- broke rl_read_init_file into an `upper' and `lower' half in
! 	  preparation for adding file inclusion capability to inputrc
! 	  parsing
! 	- handle_parser_directive now displays an error message if an
! 	  unknown directive is encountered
! 	- parser_endif now prints an error message if an $endif without
! 	  a matching $if is found
! 	- added `$include' parser directive to read bindings and commands
! 	  from another file at that point
! 
! lib/readline/doc/rluser.texinfo, doc/{bash.{1,html},readline.3}
! 	- documented new readline `$include' parser directive
! 
! shell.c, parse.y
! 	- added a new invocation option, --dump-po-strings, and code to
! 	  make it dump translatable strings ($"...") in GNU gettext
! 	  `po' format
! 
! doc/{bash.{1,html},bashref.texi}
! 	- documented new `--dump-po-strings' invocation option
! 
! lib/readline/{{kill,funmap}.c,readline.h}
! 	- added `rl_paste_from_clipboard()', bound to `paste-from-clipboard'
! 	  for CYGWIN32 users
! 
! lib/readline/kill.c
! 	- incorporated bfox's patches for `iterative' yank-last-arg handling.
! 	  This means that one can keep pressing M-. and move backwards in
! 	  the history, yanking the last argument of successive history lines
! 
! lib/readline/rlwinsize.h
! 	- new file, encapsulates various locations of the definition for
! 	  `struct winsize'
  
! aclocal.m4
! 	- augmented BASH_STRUCT_WINSIZE to look in termios.h as well as
! 	  sys/ioctl.h for definition of `struct winsize'
  
! lib/readline/rltty.h
! 	- include "rlwinsize.h" after including tty-driver-specific header
! 	  file
  
! 				   7/10
! 				   ----
! support/config.guess
! 	- add better support for SunOS on M68K (old Sun3 machines)
  
! parse.y
! 	- check for compound array assignment in read_token_word only if
! 	  there are characters before the `=' (which would make it a legal
! 	  assignment statement).  This fixes the problem with defining a
! 	  function named `=' with `=() { echo foo; }'
! 	  [in bash-2.01.1]
! 
! jobs.c, jobs.h
! 	- nohup_all_jobs and delete_all_jobs now take a parameter which
! 	  says whether or not to restrict their operation to only running
! 	  jobs
  
! jobs.c
! 	- changed all calls to delete_all_jobs
  
! builtins/jobs.def
! 	- added `-a' (all jobs) and `-r' (running jobs only) options to
! 	  `disown'
! 
! doc/{bash.{1,html},bashref.texi}
! 	- documented new `-a' and `-r' options to `disown'
! 
! findcmd.c, findcmd.h
! 	- new files with command searching code from execute_cmd.c and
! 	  function declarations from execute_cmd.h
  
! Makefile.in, builtins/Makefile.in
! 	- updated dependencies to account for new findcmd.[ch]
! 	- updated dependencies to account for new redir.[ch]
  
! redir.c, redir.h
! 	- new files with code that sets up lists and performs redirections
! 	  from execute_cmd.c and execute_cmd.h
  
  execute_cmd.c
! 	- include new findcmd.h, redir.h
  
! 				   7/11
! 				   ----
! Makefile.in, configure.in
! 	- PROFILE_FLAGS is now substituted into the Makefile by configure
  
! 				   7/14
! 				   ----
! print_cmd.c
! 	- make sure single_quote is called from xtrace_print_word_list
! 	  to correctly quote each word of trace output, especially those
! 	  with embedded quotes
! 	  [in bash-2.01.1]
  
! aclocal.m4
! 	- extended BASH_CHECK_GETPW_FUNCS so that it checks that getpwuid
! 	  and getpwnam can also be declared, as well as getpwent
! 	  [in bash-2.01.1]
! 	- in BASH_FUNC_PRINTF, cast printf to type `_bashfunc' before trying
! 	  to assign it to `pf' to avoid any prototype problems in the
! 	  declaration
! 	  [in bash-2.01.1]
  
! trap.c
! 	- include <unistd.h> before any of the bash-specific header files,
! 	  but after config.h
! 	  [in bash-2.01.1]
  
! test.c
! 	- include <errno.h> and declare `extern int errno' before including
! 	  any of the bash-specific include files, but after <unistd.h>
! 	  [in bash-2.01.1]
  
! builtins/Makefile.in
! 	- PROFILE_FLAGS is now substituted into the Makefile by configure
  
! configure.in
! 	- new options, --enable-profiling and --enable-static-link, to turn
! 	  on profiling with gprof and link bash statically (if using gcc)
! 	  for use as a root shell.  The former implies the latter.  If
! 	  we're linking statically, dynamic loading of new builtins is not
! 	  available
  
! doc/bashref.texi
! 	- documented new --enable-profiling and --enable-static-link
! 	  options in installation section; regenerated INSTALL
  
! lib/glob/glob.[ch]
! 	- new global variable, glob_ignore_case, turns on case-insensitive
! 	  filename matching in fnmatch() using the FNM_CASEFOLD flag
  
! doc/{bash.{1,html},bashref.texi}
! 	- documented new shopt `nocaseglob' option
  
! 				   7/15
! 				   ----
! bashline.c
! 	- when glob_complete_word is called with state == 0, make sure we
! 	  set rl_filename_completion_desired so that proper quoting of
! 	  the resultant filenames is performed
! 	  [in bash-2.01.1]
! 
! 				   7/16
! 				   ----
! externs.h, oslib.c
! 	- strcasecmp and strncasecmp replacements should have `const char *'
! 	  as the first two arguments, to match OS definitions
! 	  [in bash-2.01.1]
! 
! 				   7/17
! 				   ----
! (many files)
! 	- changes for minix-2.0, mostly just adding #ifndef _MINIX around
! 	  include files that minix doesn't provide, like <sys/param.h> and
! 	  <sys/file.h>
! 
! lib/readline/terminal.c
! 	- removed `outchar' function; use _rl_output_character_function in
! 	  its place
  
! support/config.guess
! 	- changes to recognize HP_ARCH of `hppa2.0'
  
! test.c
! 	- new `-N' option: `test -N file' returns true if FILE exists and
! 	  has been modified since it was last accessed
  
! doc/{bash.{1,html},bashref.texi}
! 	- documented new `test -N' option
  
! 				   7/22
! 				   ----
! aclocal.m4
! 	- prefer /var/spool/mail to /usr/spool/mail in BASH_DEFAULT_MAIL_DIR
! 	  [in bash-2.01.1]
  
! lib/readline/{complete,bind}.c
! 	- new readline variable, print-completions-horizontally, which causes
! 	  matches to be printed across the screen (like `ls -x') rather than
! 	  up-and-down (like `ls')
! 	- new readline variable, completion-ignore-case, which causes filename
! 	  completion and matching to be performed case-insensitively
! 
! doc/{bash.{1,html},readline.3}, lib/readline/doc/rluser.texinfo
! 	- documented new print-completions-horizontally variable
! 	- documented new completion-ignore-case variable
  
! _distribution, Makefile.in
! 	- bumped the version number up to 2.02-alpha1
  
! bracecomp.c
! 	- fixes so that the braces are not quoted by the filename quoting
! 	  function when complete-into-braces is executed with M-{.  The
! 	  brace completion functions do filename quoting themselves
! 	  [in bash-2.01.1]
  
! pathexp.c
! 	- changed quote_string_for_globbing so that it takes a flags word
! 	  as its second argument
  
! pathexp.h
! 	- defines for flags passed to quote_string_for_globbing
  
! subst.c,execute_cmd.c
! 	- changed calls to quote_string_for_globbing to pass the correct
! 	  flag arguments
  
! expr.c
! 	- added a `**' binary operator to do exponentiation (2**16 == 65536).
! 	  precedence is lower than arithmetic operators, higher than unary
! 	  operators (2**16-1 == 65535)
  
! doc/{bash.{1,html},bashref.texi}
! 	- documented new `**' arithmetic binary operator
  
! 				   7/24
! 				   ----
! shell.c
! 	- added new (currently undocumented) `--wordexp' option to do the
! 	  job required by POSIX.2 wordexp().  If -n is supplied along with
! 	  --wordexp, command substitution is disallowed and the shell
! 	  exits with a status of 125 if one is attempted.  If there is an
! 	  expansion error, the shell exits with a status of 127.  If there
! 	  is a shell parsing error, the shell exits with a status of 126.
! 	  Otherwise, the exit status is 0.  The current output is
! 
! 		number of words\n
! 		number of bytes\n
! 		expanded words, one per line, separated by newlines
! 
! 	  This will have to be changed when an interface to glibc is coded
! 
! 				   7/28
! 				   ----
! hashcmd.h
! 	- reduced the default size of the filename hash table from 631
! 	  to 107
! 
! sig.c
! 	- don't call initialize_siglist if HAVE_UNDER_SYS_SIGLIST is defined
! 	  [in bash-2.01.1]
  
! siglist.c
! 	- don't compile this file if HAVE_UNDER_SYS_SIGLIST is defined
! 	  [in bash-2.01.1]
  
! variables.c
! 	- fix to make $RANDOM work better in subshells
! 	  [in bash-2.01.1]
  
! aclocal.m4
! 	- new macro, BASH_DECL_UNDER_SYS_SIGLIST, looks for _sys_siglist in
! 	  <signal.h> and <unistd.h>, defines UNDER_SYS_SIGLIST_DECLARED if
! 	  found
! 	  [in bash-2.01.1]
! 	- change BASH_UNDER_SYS_SIGLIST to require BASH_DECL_UNDER_SYS_SIGLIST,
! 	  like BASH_SYS_SIGLIST requires AC_DECL_SYS_SIGLIST
! 	  [in bash-2.01.1]
  
  config.h.in
! 	- add a line for UNDER_SYS_SIGLIST_DECLARED
! 	  [in bash-2.01.1]
  
! configure.in
! 	- make sure that SVR4_2 is defined for machines that have $host_os
! 	  sysv4.2* (e.g., sysv4.2MP) as well as $host == sysv4.2
! 	  [in bash-2.01.1]
  
! 				   7/29
  				   ----
! command.h
! 	- new command type, ARITH_COM, used to create and execute a ((...))
! 	  command without translating it into let "..."
  
! parse.y
! 	- changes to the grammar and lexer so that ((...)) is parsed as a
! 	  command of type ARITH_CMD.  An ARITH_CMD is a WORD_LIST, for
! 	  future expansion, even though only the first word is used
! 
! make_cmd.c, make_cmd.h
! 	- definition and declaration of a function to build an arithmetic
! 	  command
  
! dispose_cmd.c
! 	- added code to dispose of arithmetic commands
  
! print_cmd.c
! 	- added code to print arithmetic commands, both `regularly' and
! 	  when they're being traced with `set -x'
  
! externs.h
! 	- extern declaration for xtrace_print_arith_cmd
  
! copy_cmd.c
! 	- added code to copy arithmetic commands
  
! execute_cmd.c
! 	- added code to directly execute arithmetic commands -- they are
! 	  a shell_control_structure, so just about everything like
! 	  redirections and piping is taken care of by the boilerplate code.
! 	  All that's needed is to expand the expression (which is within
! 	  double quotes -- added by parse.y:parse_arith_cmd()), print it
! 	  if tracing is enabled, call the expression evaluator, and return
! 	  an appropriate result
  
! 				   7/30
! 				   ----
! input.c
! 	- new function, set_buffered_stream(fd, bp), sets the buffered stream
! 	  associated with FD to BP and returns the old buffered stream
  
! input.h
! 	- extern declaration for set_buffered_stream
  
! parse.y
! 	- call set_buffered_stream rather than manipulating the BUFFERS array
! 	  directly
  
! shell.c
! 	- unset_bash_input now takes an argument, CHECK_ZERO.  This tells it
! 	  whether to check whether default_buffered_input is >= 0 or just > 0
  
! externs.h
! 	- changed extern declaration for unset_bash_input
  
! execute_cmd.c, jobs.c, nojobs.c
! 	- changed calls to unset_bash_input to add appropriate argument
  
! input.h
! 	- #undef B_* before defining them as flag values for b_flags.  Some
! 	  systems, like SVR4, have a B_ERROR define in a file included by
! 	  jobs.c and nojobs.c, and it causes a warning
  
! 				   7/31
! 				   ----
! fnmatch.c
! 	- rewrote most of fnmatch(), so that it now implements ksh-88 style
! 	  pattern matching (`[@+*?!](patlist)') if the FNM_EXTMATCH flag
! 	  is set
  
! fnmatch.h
! 	- added a define for FNM_EXTMATCH
! 
! 				    8/4
! 				    ---
! lib/readline/display.c
! 	- fixed _rl_redisplay_after_sigwinch () so that it really redisplays
! 	  only the portion after the final newline of a multi-line prompt
! 	  [in bash-2.01.1]
! 
! bashline.c
! 	- attempt_shell_completion no longer returns matches if a glob pattern
! 	  matches more than one filename -- it caused too many problems
! 	  [in bash-2.01.1]
  
! 				    8/5
! 				    ---
! lib/glob/glob.c
! 	- updated glob_pattern_p so that the extended matching operators
! 	  are recognized
  
! pathexp.c
! 	- udpated unquoted_glob_pattern_p so that the extended matching
! 	  operators are recognized
! 	- udpated quote_globbing_chars so that the extended matching
! 	  operators are recognized and quoted appropriately
  
! subst.c
! 	- updated match_pattern_char so that the extended matching operators
! 	  are recognized
  
! parse.y
! 	- updated read_token_word so that it parses an extended matching
! 	  pattern as a single word
  
! jobs.c
! 	- if a job is suspended with SIGTSTP, and the user has set
! 	  checkwinsize with `shopt', update the window size
! 	  [in bash-2.01.1]
! 
! pathexp.c, pathexp.h
! 	- new global variable, extended_glob, controls whether the extended
! 	  pattern matching features are enabled
! 
! pathexp.h
! 	- new define, FNMATCH_EXTFLAG, to be OR'd with other values for
! 	  flags argument to fnmatch to enable the extended pattern matching
! 	  features if extended_glob is set
! 
! {pathexp,execute_cmd,bashhist,subst,test}.c, builtins/help.def
! 	- changed calls to fnmatch to add FNMATCH_EXTFLAG to the flags arg if
! 	  extended_glob is non-zero
  
! lib/glob/glob.c
! 	- changed flags arg passed to fnmatch to include FNM_EXTMATCH if
! 	  extended_glob is non-zero (#ifdef SHELL)
  
! 				    8/6
! 				    ---
! builtins/shopt.def
! 	- added a new `extglob' shell option, controls the value of
! 	  extended_glob
  
! 				    8/7
! 				    ---
! doc/{bash.{1,html},bashref.texi}
! 	- documented new extended pattern matching operators and the `extglob'
! 	  shell option
  
! tests/{extglob.{tests,right},run-extglob}
! 	- test suite for the new extended globbing features
  
! 				    8/8
! 				    ---
! parse.y, pathexp.h, lib/glob/fnmatch.c
! 	- made the extended globbing code #ifdef EXTENDED_GLOB
  
! config.h.in
! 	- added a line for EXTENDED_GLOB, controlled by configure
  
! configure.in
! 	- new option, --enable-extended-glob, controls defining of
! 	  EXTENDED_GLOB (on by default)
  
! doc/bashref.texi
! 	- documented new `configure' `--enable-extended-glob' option
  
! 				   8/11
! 				   ----
! builtins/printf.def
! 	- new `printf' builtin, implemented according to POSIX.2 spec
! 	  for printf(1)
  
! Makefile.in,builtins/Makefile.in
! 	- added necessary stuff for new printf builtin
  
! 				   8/12
! 				   ----
! lib/readline/isearch.c
! 	- change to make ^G interrupt the incremental search correctly
! 	  [in bash-2.01.1]
  
! configure.in, config.h.in
! 	- configure now checks for the availability of strtoul(3)
  
! builtins/printf.def
! 	- use strtoul for the `%o', `%u', `%x', and `%X' formats if it
! 	  is available
  
! 				   8/13
  				   ----
! tests/{printf.{right,tests},run-printf}
! 	- extensive test suite for the new `printf' builtin
  
! builtins/Makefile.in
! 	- change so that `builtext.h' is not recreated every time the source
! 	  file for a builtin is changed if the contents are the same.  This
! 	  keeps many files from being recompiled
  
! 				   8/14
! 				   ----
! subst.c
! 	- changed verify_substring_values so that it returns -1 for substring
! 	  range errors, 0 for expression errors, and 1 for success
! 	  [in bash-2.01.1]
! 	- changed parameter_brace_substring to return an error if
! 	  verify_substring_values returns 0, and a null string if it returns
! 	  -1.  This matches the ksh93 behavior
! 	  [in bash-2.01.1]
  
! trap.c
! 	- changed decode_signal so that it makes sure the first three
! 	  characters of a signal name are `SIG' before allowing the `SIG'
! 	  prefix to be omitted.  This is so a signal spec of `T' does not
! 	  match `EXIT', for instance
! 	  [in bash-2.01.1]
! 
! builtins/trap.def
! 	- make sure that showtrap() displays traps for signals with unknown
! 	  names using the signal number
! 	  [in bash-2.01.1]
! shell.c
! 	- make sure that `bash -r' doesn't turn on the restricted mode until
! 	  after the startup files are executed
! 	  [in bash-2.01.1]
  
! doc/{bash.{1,html},bashref.texi}
! 	- documented printf builtin
  
! 				   8/15
! 				   ----
! general.c
! 	- added \xNNN escape to ansicstr -- NNN are up to three hex digits.
! 	  This affects $'...', `echo -e', and printf
  
! builtins/printf.def
! 	- added \xNNN escape to bexpand -- NNN are up to three hex digits.
! 	  This affects printf's `%b' conversion specifier
  
! doc/{bash.{1,html},bashref.texi}
! 	- documented new \xNNN escape sequence for echo, $'...', and printf
  
! builtins/setattr.def
! 	- make sure that a variable found in the temp environment does not
! 	  cause a null string to be assigned by bind_variable (e.g.,
! 		foo="" export foo
! 	  )
! 	  [in bash-2.01.1]
  
! 				   8/18
  				   ----
! subst.c
! 	- fixed a bug that sometimes caused bad memory (pointer into an
! 	  allocated block) to be passed to free when doing arithmetic
! 	  substitution.  Bug report from stevet@myofb.org
! 	  [in bash-2.01.1]
  
! 				   8/19
! 				   ----
! subst.c
! 	- considerable changes:  moved the code that expands a single
! 	  $... parameter expansion into a separate function: param_expand()
! 	  This function returns a string, which may contain characters
! 	  quoted with CTLESC or CTLNUL without doing word splitting
! 	- changed expand_word_internal to not remove the expansion of "$*"
! 	  if the number of positional parameters is > 0
! 	- changed the '"' case of expand_word_internal to remove quoted
! 	  nulls from the resultant word if the expansion was not "$@", and
! 	  the word is not a quoted null string ([] == CTLNUL, [1] == '\0')
! 
! subst.c, variables.c
! 	- moved the code that handles special variables from subst.c to
! 	  variables.c
  
! 				   8/20
  				   ----
  subst.c
! 	- rearranged the source a bit to group functions with similar
! 	  operation together
! 	- fixed parameter_brace_expand so that it no longer allows
! 	  indirect expansion of `special' variables
! 	- fixed parameter_brace_expand so taking the length of some of
! 	  the shell's special parameters works again
! 	- moved all of the code that computes the length of a shell
! 	  parameter (the ${#xxx} expansion) into parameter_brace_expand_length.
! 	  Previously, the code that handled the lengths of the shell's
! 	  special parameters was in parameter_brace_expand_word
! 	- valid indirect expansions are now only variable names or positional
! 	  parameters
  
! 				   8/21
! 				   ----
! subst.c
! 	- fixed param_expand to raise an expansion error if $! is being
! 	  expanded and no asynchronous processes have been created
! 	- an expression error in a $((...)) arithmetic expansion now causes
! 	  a non-interactive shell running in POSIX mode to exit
! 	- relaxed change of 8/20 to allow indirect references to $#, $@, $*
  
! builtins/bashref.texi
! 	- documented new posix-mode exit on invalid expressions in $((...))
  
! lib/readline/complete.c
! 	- don't call rl_strpbrk unless rl_filename_quote_characters is not
! 	  NULL -- strpbrk requires non-NULL arguments
! 	  [in bash-2.01.1]
  
! 				   8/22
  				   ----
! bashline.c
! 	- don't make `history-expand-line' a bindable command unless
! 	  BANG_HISTORY is defined, and don't compile the code for that
! 	  command in unless BANG_HISTORY is defined
! 	- make history_expand_line(), tcsh_magic_space(), alias_expand_line(),
! 	  and history_and_alias_expand_line() int-returning functions that
! 	  return 0 for success and non-zero on error.  This allows
! 	  tcsh_magic_space() to just call history_expand_line() and insert
! 	  a space if that returns successfully
! 	- `magic-space' is now a bindable readline command
! 
! doc/bash.{1,html}, lib/readline/doc/rluser.texinfo
! 	- documented new `magic-space' bindable readline command
  
! 				   8/25
  				   ----
! parse.y
! 	- fixed decode_prompt_string so that values of $PWD longer than
! 	  PATH_MAX don't cause buffer overruns (char t_string[PATH_MAX])
! 	  [in bash-2.01.1]
! 
! general.c
! 	- fixed polite_directory_format so that values of $HOME longer
! 	  than PATH_MAX don't cause buffer overruns (char tdir[PATH_MAX])
! 	  [in bash-2.01.1]
  
! subst.c
! 	- fix to expansion of $* so that the positional parameters are
! 	  separated by the first character of $IFS, even when the expansion
! 	  is not within double quotes, so the correct split is still
! 	  performed even when IFS does not contain a space.  Works for
! 	  ${*}, too
! 	- fix to expansion of $@ so that the positional parameters are
! 	  separated by the first character of $IFS, even when the expansion
! 	  is not within double quotes, so the correct split is still
! 	  performed even when IFS does not contain a space.  Works for
! 	  ${@}, too
! 	- new function, string_list_dollar_at(), which is to $@ as
! 	  string_list_dollar_star is to $*
! 	- fixed expansion of $@ so that splitting is still done even if
! 	  IFS is unset or NULL, as POSIX.2 specifies (section 3.5.2)
! 	- fixed expansion of $* so that it expands to multiple words if there
! 	  is more than one positional parameter, just like $@, even if
! 	  IFS is unset or NULL
! 	- new function list_quote_escapes, quotes (with CTLESC) all
! 	  CTLESC and CTLNUL characters in each member of the list
  
! tests/dollar-{at,star}.sh
! 	- combined into dollar-at-star, changed run-dollars accordingly
  
! 				   8/26
  				   ----
! Makefile.in
! 	- make the `tests' target use $(SHELL) instead of hardcoding `sh'
  
! 				   8/29
! 				   ----
! subst.c
! 	- expand_word_list_internal now takes a flags word as the second
! 	  argument, telling which expansions to perform on the WORD_LIST
! 	- broke expand_word_list_internal into several functions: one
! 	  each to do brace expansion, glob expansion, and the `normal'
! 	  shell expansions
! 	- new extern function: expand_words_shellexp() to perform the
! 	  `normal' shell expansions on a WORD_LIST
  
! subst.h
! 	- extern declaration for expand_words_shellexp
  
! bashline.c
! 	- fixed a problem with attempt_shell_completion where it attempted
! 	  to refer to rl_line_buffer[-1] (completion at the start of the
! 	  line, which means that ti == -1, which means that the test for
! 	  rl_line_buffer[ti] at line 715 was an array bounds error
! 	  [in bash-2.01.1]
  
! eval.c
! 	- new function, parse_string_to_word_list(), which takes a string
! 	  and runs it through the parser, returning the resultant word
! 	  list
  
! externs.h
! 	- new extern declaration for parse_string_to_word_list()
  
! variables.c
! 	- change assign_array_var_from_string to first split the string
! 	  between the parens on whitespace, then expand the resultant
! 	  list of words with all the shell expansions before doing the
! 	  assignment
  
! 				    9/4
! 				    ---
! redir.c, redir.h
! 	- redirection_error is no longer a static function
  
! builtins/evalstring.c
! 	- changes to handle $( < filename ) (equivalent to $(cat filename))
! 	  as in ksh
  
! lib/readline/bind.c
! 	- added two new functions: rl_unbind_function_in_map(func, map),
! 	  which unbinds all keys that execute FUNC in MAP; and
! 	  rl_unbind_command_in_map(command, map), which unbinds all keys
! 	  bound to COMMAND in MAP
  
! lib/readline/readline.h
! 	- extern declarations for rl_unbind_{function,command}_in_map
  
! lib/readline/doc/rltech.texi
! 	- documented rl_unbind_{function,command}_in_map
  
! builtins/bind.def
! 	- added a new option, -u FUNCNAME, which unbinds all key sequences
! 	  bound to FUNCNAME in the specified (or current) keymap
  
! doc/{bash.{1,html},bashref.texi}
! 	- documented new $( < filename ) command substitution
! 	- documented new bind -u FUNCNAME option
  
! 				    9/5
! 				    ---
! shell.c
! 	- send SIGHUP to all jobs when an interactive login shell exits if
! 	  the variable `hup_on_exit' is non-zero
! 	- modified run_startup_files so that if `NON_INTERACTIVE_LOGIN_SHELLS'
! 	  is #define'd (perhaps in config.h.top, though there is nothing there
! 	  for it), all login shells (interactive and non-interactive) run
! 	  /etc/profile and one of the per-user login shell startup files
  
! builtins/shopt.def
! 	- new shopt option `huponexit' to control the value of hup_on_exit
  
! doc/{bash.{1,html},bashref.texi}
! 	- documented new `huponexit' shell option
  
! 				    9/8
! 				    ---
! builtins/common.c
! 	- changed contains_shell_metas to return 1 if a tilde appears at the
! 	  start of a string or after a `=' or `:'
! 	- changed backslash_quote to quote a tilde if it appears at the start
! 	  of a string or after a `=' or `:'
  
! lib/readline/complete.c
! 	- moved rl_tilde_expand to util.c; it doesn't really have anything
! 	  to do with completion
! 	- moved insert_text to readline.c, renamed it _rl_replace_text (since
! 	  that's really what it does), changed callers
! 	- moved code that postprocesses the list of completion matches into
! 	  a new function: postprocess_matches
! 	- new implementation of tcsh-like menu completion in a single new
! 	  function: rl_menu_complete
! 
! lib/readline/{funmap.c,readline.h}
! 	- necessary declarations for binding rl_menu_complete to the
! 	  new `menu-complete' command
  
! doc/{bash.{1,html},readline.3}, lib/readline/doc/rluser.texinfo
! 	- documented new `menu-complete' bindable readline command
  
! 				    9/9
! 				    ---
! jobs.c
! 	- delete_job should print a warning only if subshell_environment
! 	  is 0, so we don't print bogus warnings when shell scripts without
! 	  a leading #! are executed
  
! 				   9/10
  				   ----
! builtins/read.def
! 	- fixed the code so that the `read' is automatically restarted when
! 	  it returns -1 with errno == EINTR.  SIGINT is handled by the
! 	  interrupt handler, since interrupt_immediately is set to 1, so
! 	  this handles things like SIGCHLD
! 	  [in bash-2.01.1]
  
! 				   9/11
! 				   ----
! test.c
! 	- reorganized the code slightly to make it easier to add the ksh-like
! 	  [[...]] compound command
  
! test.h
! 	- new file, with extern declarations for functions available in test.c
  
! externs.h
! 	- moved declaration of test_command to test.h
  
! builtins/test.def
! 	- include `test.h'
  
! 				   9/16
  				   ----
! {command,make_cmd,dispose_cmd,externs,subst}.h
! parse.y, subst.c
! {make,dispose,copy,print,execute}_cmd.c
! 	- changes to add the new ksh-93 compatible [[...]] conditional command
  
  configure.in
! 	- new enable option, --enable-cond-command, to compile in the [[...]]
! 	  command code
  
! config.h.in
! 	- new #define, COND_COMMAND, to compile in the [[...]] command code
  
! tests/{run-cond,cond.{tests,right}}
! 	- test suite for the new [[...]] command
  
! {builtins,lib/{readline,glob,tilde}}/Makefile.in
! 	- explicit dependencies for .o files on .c files for losing makes
! 	  like Solaris
! 
! doc/{bash.{1,html},bashref.texi}
! 	- documented the new `[[' compound command
! 	- documented the test/[ builtin behavior based on the number of
! 	  arguments in the description of the builtin
! 	- made a new section for conditional expressions that just lists
! 	  the available primaries -- the connectives and other operators
! 	  are listed in the description of the [[ command and the test/[
! 	  builtin
  
! 				   9/18
! 				   ----
! builtins/set.def
! 	- minus_o_option_commands is now a global function so the shopt
! 	  code can use it
! 	- minus_o_option_commands now takes an argument telling it which
! 	  options to print, just like list_minus_o_options
! 	- new function, print_minus_o_option, which prints the value of
! 	  a `set -o' option either in the traditional format or in the
! 	  format used by `set +o'
! 	- changed list_minus_o_opts and minus_o_option_commands to call
! 	  print_minus_o_option
  
! builtins/shopt.def
! 	- `shopt -p' now causes output to be printed in a format reusable
! 	  as input (the format is a series of shopt commands, like the
! 	  output of `set +o')
! 	- fixed a bug that made `shopt -so' and `shopt -uo' not work
! 	- fixed list_shopt_o_options so that `shopt -op' acts like `set +o'
! 	- fixed list_shopt_o_options to that `shopt -op optname' prints the
! 	  value of optname in a reusable format
! 	- fixed list_some_o_options so that `shopt -ops' and `shopt -opu'
! 	  work and display output in a reusable format
  
! 				   9/19
! 				   ----
! doc/{bash.{1,html},bashref.texi}
! 	- documented new `shopt -p' behavior
  
! shell.c
! 	- made `bash +o' display the same output as `set +o' and then
! 	  start an interactive shell (previously `bash -o' and `bash +o'
! 	  displayed the same thing)
  
! builtins/common.h
! 	- added prototypes to the extern function declarations
  
! 				   9/22
! 				   ----
! builtins/evalstring.c
! 	- fixed the DISCARD case of the jump_to_top_level so that it
! 	  doesn't try to call dispose_command(command) after the
! 	  `pe_dispose' unwind frame gets run, since that disposes the
! 	  command
! 
! 				   9/23
! 				   ----
! test.[ch]
! 	- test_eaccess is now a global function so that globbing code can
! 	  use it
  
! lib/glob/glob.c
! 	- rewrote glob_vector to be slightly more efficient and to not
! 	  read the directory if the filename pattern does not contain
! 	  any globbing chars.  This satisfies the POSIX requirement that
! 	  read permission is not required for a directory when the
! 	  pathname component does not contain a pattern character (bug
! 	  reported by jsm28@cam.ac.uk)
  
! subst.c
! 	- fixed parameter_brace_expand so that ${array[@]} and ${array[*]}
! 	  behave correctly when IFS is unset or set to something that does
! 	  not contain a space (they should result in separate words, just
! 	  like $@ and $*)
! 
! tests/{run-array2,array-at-star,array2.right}
! 	- tests for the expansions of ${array[@]} and ${array[*]}, derived
! 	  from the tests in dollar-at-star
  
! 				   9/24
! 				   ----
! jobs.c
! 	- fixed cleanup_dead_jobs so that it doesn't remove the job
! 	  containing last_asynchronous_pid from the job table.  This
! 	  fixes the POSIX.2 `wait' requirement problem
  
- 				   9/25
- 				   ----
  parse.y
! 	- added `\r' escape sequence to the prompt expansion code
  
  lib/readline/chardefs.h
! 	- added defines for ISOCTAL, OCTVALUE, isxdigit (if not defined),
! 	  and HEXVALUE
  
! lib/readline/bind.c
! 	- added `normal' echo/printf-like backslash escapes to the
! 	  key sequence translation code, with the addition that \d
! 	  expands to RUBOUT.  This means that key sequence definitions
! 	  (before the `:') and macro values may contain these special
! 	  backslash-escape sequences
! 	- now that we can translate octal escape sequences in key bindings,
! 	  change _rl_get_keyname so that it turns characters with values
! 	  128-159 inclusive into octal escape sequences (\200-\237), since
! 	  those characters are not ASCII or ISO Latin 1
! 
! doc/{bash.{1,html},readline.3}, lib/readline/doc/rluser.texinfo
! 	- documented new backslash escapes for readline key sequence and
! 	  macro translation
  
! builtins/pushd.def
! 	- new function, get_dirstack_from_string(char *string), returns an
! 	  element from the directory stack or null, treating the argument
! 	  exactly as `dirs string' would, with the exception that if
! 	  the first character of `string' is not `+' or `-', a `+' is
! 	  assumed
  
! builtins/common.h
! 	- new extern declaration for get_dirstack_from_string
  
! general.c
! 	- added code to bash_special_tilde_expansions to get the expansion
! 	  using get_dirstack_from_string() if the first character of the
! 	  tilde-prefix is a digit or the first character is a `+' or `-'
! 	  and the second is a digit
  
! tests/dstack.{tests,right}
! 	- renamed from dirstack.{tests,right}
  
! tests/dtack2.{tests,right}
! 	- new tests for the directory stack tilde expansion code
  
! tests/run-dirstack
! 	- now runs both dstack and dstack2
  
! 				   10/3
! 				   ----
! trap.c
! 	- reordered header file inclusion for irix 4
  
! execute_cmd.c
! 	- fixed select_query so that a reply that is not a number is treated
! 	  the same as a numeric reply that is out of range
  
! lib/readline/util.c
! 	- added a backwards-compatibility definition of _rl_savestring()
  
! builtins/set.def
! 	- initialize_shell_options now takes an argument saying whether or
! 	  not we should parse $SHELLOPTS from the environment.  The shell
! 	  does not parse the value if it's restricted, running setuid, or
! 	  running in `privileged mode'
  
! shell.c
! 	- change call to initialize_shell_options to add the correct argument
  
! builtins/common.h
! 	- changed extern declaration for initialize_shell_options
  
! doc/{bash.{1,html},bashref.texi}
! 	- added note that the shell ignores $SHELLOPTS in the environment at
! 	  startup if running in privileged mode
! 	- added note that the restricted shell does not parse $SHELLOPTS from
! 	  the environment at startup
  
- 				   10/6
- 				   ----
  aclocal.m4
! 	- change BASH_RLIMIT_TYPE so that it looks for rlim_t in
! 	  <sys/resource.h> as well as <sys/types.h>, for Solaris 2.6
! 	- new macro, BASH_LARGE_FILE_SUPPORT, to enable special compilation
! 	  options for large files on Solaris 2.6 (from eggert@twinsun.com)
  
! mailcheck.c
! 	- the `file_size' member of the FILEINFO struct should be of
! 	  type `off_t'
! 	- the `size' variable in file_has_grown should be of type `off_t'
! 	- the RESET_MAIL_FILE macro should initialize file_size to 0, not 0L
! 
! builtins/Makefile.in
! 	- LDFLAGS and LOCAL_LDFLAGS are now set by configure
! 	- `mkbuiltins' is now created from `mkbuiltins.o' instead of directly
! 	  from the source to the executable
  
! builtins/evalfile.c
! 	- fixed _evalfile so that it handles large files correctly on
! 	  systems where the st_size member of `struct stat' will not fit
! 	  into an `int'
  
! builtins/mkbuiltins.c
! 	- don't assume that st_size fits into an int
  
! input.[ch]
! 	- the `b_size' member of a struct BSTREAM is now of type `size_t'
! 	- changed third argument to make_buffered_stream to size_t; changed
! 	  caller
! 	- changed `size' variable in fd_to_buffered_stream to type `size_t'
  
! general.h
! 	- include <sys/resource.h> if HAVE_SYS_RESOURCE_H and RLIMTYPE are
! 	  both defined, for possible necessary definition of RLIMTYPE
! 	  (e.g., on Solaris 2.6)
! 
! {execute_cmd,jobs}.c, builtins/times.def
! 	- don't include <sys/resource.h> explicitly if RLIMTYPE is defined,
! 	  since general.h will include it in that case
  
! lib/readline/bind.c
! 	- new function, char *_rl_read_file(filename, sizep), which reads
! 	  FILENAME into a malloced buffer, returning the buffer and the
! 	  size of the buffer in *SIZEP
! 
! lib/readline/histfile.c
! 	- changed read_history_range and history_truncate_file to handle
! 	  large files
  
! hashcmd.c
! 	- find_hashed_filename should not add `./' to the front of a pathname
! 	  that already begins with `./'
  
! 				   10/8
! 				   ----
! support/config.sub
! 	- recognize `hppa2.0' as a valid machine architecture
  
! aclocal.m4
! 	- changed BASH_CHECK_LIB_TERMCAP so that `gnutermcap' is not chosen
! 	  if `$prefer_curses' is set to something
  
! bashhist.c
! 	- don't use HISTCONTROL or HISTIGNORE to remove lines from the
! 	  second and subsequent lines of a multi-line command
! 	  (current_command_line_count > 1).  Old code did this only when
! 	  command-oriented-history was enabled
! 
! doc/{bash.{1,html},bashref.texi}
! 	- changed descriptions of HISTCONTROL and HISTIGNORE to state that
! 	  these variables are not applied to the second and subsequent
! 	  lines of a multi-line command
! 
! builtins/hash.def, {copy,dispose}_cmd.c
! 	- include "bashtypes.h" -- cray machines need it because of their
! 	  oddball definition of `word'
  
! configure.in
! 	- changed check of ${host_cpu} to check for `*cray*' and `*Cray*'
! 	  when deciding whether to include the GNU malloc, since it
! 	  seems that ${host_cpu} gets set to `CrayYMP'
  
! 				   10/9
! 				   ----
! configure.in
! 	- look for strtod and strtol in libc
! 	- make lib/sh directory in build directory if not there
! 	- create lib/sh/Makefile
  
! config.h.in
! 	- added HAVE_STRTOD and HAVE_STRTOL
  
! Makefile.in
! 	- changes for lib/sh/libsh.a (shell library)
  
  builtins/printf.def
! 	- took out the `#ifdef STRTOUL' code, since strtoul is in libsh.a,
! 	  and will be resolved from there if it's not in libc
  
  variables.c
! 	- call strtol() instead of string_to_long()
  
! general.c, general.h
! 	- removed string_to_long
! 	- changed legal_number to use strtol so it correctly sets errno
! 	  to ERANGE on overflow
! 	- moved bash_getcwd_errstr here from lib/sh/oslib.c
  
! externs.h
! 	- moved extern declarations for functions defined in libsh to a
! 	  separate section of the file, added extern declarations for
! 	  other functions in libsh
  
! builtins/ulimit.def
! 	- changed macro definition for string_to_rlimtype to call strtol
! 	  directly instead of string_to_long
  
! lib/sh/clktck.c
! 	- moved get_clock_tck to its own file, since it's compiled in
! 	  unconditionally
  
! 				   10/10
  				   -----
! lib/sh/getenv.c
! 	- moved getenv() and __getenv() here from lib/sh/oslib.c
  
! lib/sh/{setlinebuf,strerror,strcasecmp}.c
! 	- moved {setlinebuf,strerror,strcasecmp}() from oslib.c to
! 	  individual files
  
! lib/sh/Makefile.in, Makefile.in
! 	- changes for new files in lib/sh
  
! aclocal.m4
! 	- new macro BASH_SYS_RESTARTABLE_SYSCALLS, which does what
! 	  AC_SYS_RESTARTABLE_SYSCALLS does, but using posix sigaction()
! 
! configure.in
! 	- call BASH_SYS_RESTARTABLE_SYSCALLS if ac_cv_sys_restartable_syscalls
! 	  is `no'
! 
! 				   10/13
! 				   -----
! builtins/jobs.def
! 	- catch out-of-range jobs better in disown_builtin
! 
! configure.in
! 	- don't build with GNU malloc on cygwin32
! 
! trap.c
! 	- change signal_name to handle the case where signal_names[sig] is
! 	  NULL, which can happen on cygwin32
! 
! execute_cmd.c
! 	- changes to do_piping to make pipes text mode (O_TEXT) on cygwin32
! 
! cross-build
! 	- new directory with cache files and other stuff for cross-compiling
! 	  bash (currently only for building for cygwin32 on a Unix machine)
! 
! cross-build/cygwin32.cache
! 	- new file containing configuration variable assignments for
! 	  cygwin32 that would otherwise require a default case for AC_TRY_RUN
! 
! configure.in
! 	- source ${srcdir}/cross-build/cygwin32.cache on CYGWIN32 systems
! 	  if we're cross-compiling on a unix machine
! 	- set $CC_FOR_BUILD for cygwin32 cross-compiling environment
! 
! Makefile.in
! 	- CC_FOR_BUILD is now a variable set by configure
! 
! builtins/mkbuiltins.c
! 	- only check for read(2) returning <= 0 in extract_info() (error
! 	  and exit on < 0, warning and return on == 0)
! 
! builtins/evalfile.c
! 	- only check for read(2) returning <= 0 in _evalfile() (error and
! 	  and failure return on < 0, success on == 0 while short-circuting
! 	  rest of operation)
! 
! 				   10/14
! 				   -----
! 
! vprint.c
! 	- moved to lib/sh/vprint.c
! 
! lib/sh/Makefile.in
! 	- added entries for vprint.[co] in the appropriate places
! 
! cross-build/win32sig.h
! 	- a version of signames.h for cross-compiling for the CYGWIN32
! 	  environment on a Unix machine (from noer@cygnus.com)
! 
! aclocal.m4
! 	- made all cases of AC_TRY_RUN and AC_TRY_COMPILE have reasonable
! 	  default cases for cross-compiling, and tell the user what they are
! 
! Makefile.in
! 	- removed vprint.c from shell sources and vprint.o from shell
! 	  objects
! 	- added a level of indirection for signames.h -- the variable
! 	  SIGNAMES_H is set by configure to either `lsignames.h' or
! 	  a file for a cross-compilation environment (currently only
! 	  the cygwin32 stuff is supported).  Then that file is copied
! 	  to `signames.h'.  `lsignames.h' is created by `mksignames' as
! 	  was previously used to create signames.h directly
! 
! configure.in
! 	- set SIGNAMES_H to either `$(srcdir)/cross-build/win32sig.h' or
! 	  `lsignames.h' as appropriate, substitute into Makefile
! 
! 				   10/15
! 				   -----
! builtins/Makefile.in
! 	- CC_FOR_BUILD is now set by configure and used to build mkbuiltins
! 	  and psize.aux
! 
! variables.h
! 	- new variable attribute `att_tempvar', set if the SHELL_VAR * was
! 	  constructed on the fly from the temporary environment
! 
! variables.c
! 	- find_name_in_env_array now sets the `att_tempvar' attribute on
! 	  the SHELL_VAR it creates
! 
! findcmd.c
! 	- search_for_command now disposes the SHELL_VAR created by searching
! 	  the temporary environment for $PATH, if it is found there
! 	- _find_user_command_internal also disposes of the SHELL_VAR if it
! 	  has the `att_tempvar' attribute set
! 
! builtins/setattr.c
! 	- show_name_attributes looks in the temporary environemnt, so it needs
! 	  to dispose the SHELL_VAR if it has the att_tempvar attribute set
! 
! subst.c
! 	- parameter_brace_expand_word now disposes of the SHELL_VAR returned
! 	  by find_variable if it has the att_tempvar attribute set
! 	- ditto for param_expand and word_split
! 
! builtins/kill.def
! 	- disallow null pid arguments instead of treating them as 0
! 	- display a usage message and return failure if no pid or job
! 	  arguments are supplied
! 
! 				   10/16
! 				   -----
! builtins/declare.def
! 	- make `var=value declare -x var' behave the same as
! 	  `var=value export var' and `var=value declare -r var' behave the
! 	  same as `var=value readonly var', now that we have the `tempvar'
! 	  attribute
! 
! 				   10/22
! 				   -----
! jobs.c
! 	- non-interactive shells shouldn't report jobs killed by a SIGINT,
! 	  even if the standard output is to a terminal
! 	- pretty_print_job should add a CR at the end of its output if the
! 	  shell is interactive and asynchronous notification is being
! 	  performed.  This fixes the problem with extra CRs in the output
! 	  of $(jobs)
! 
! general.c
! 	- changed canonicalize_pathname to change `//' into `/', but leave
! 	  other pathnames starting with two consecutive slashes alone
! 
! 				   10/27
! 				   -----
! 
! lib/readline/histexpand.c
! 	- fixed history_expand so that the appearance of the history
! 	  comment character at the beginning of a word inhibits history
! 	  expansion for the rest of the line
! 
! 				   10/29
! 				   -----
! jobs.c,variables.c
! 	- moved set_pipestatus_array to variables.c
! 
! variables.c
! 	- new function, set_pipestatus_from_exit(int), which sets the
! 	  PIPESTATUS variable from a command's exit status
! 
! variables.h
! 	- extern declarations for set_pipestatus_from_exit and
! 	  set_pipestatus_array
! 
! execute_cmd.c
! 	- fixed execute_simple_command to call set_pipestatus_from_exit
! 	  if a foreground builtin or function, or a foreground null
! 	  command is executed
! 
! 				   10/31
! 				   -----
! shell.c
! 	- fixed run_startup_files to detect being run by sshd, and treat
! 	  that case as equivalent to being run by rshd
! 
! 				   11/3
! 				   ----
! builtins/set.def
! 	- make sure `set -a' doesn't cause SHELLOPTS to be exported when
! 	  a change is made to one of the shell options
! 
! 				   11/4
! 				   ----
! pathexp.c
! 	- fix to shell_glob_filename in the code that uses a POSIX glob
! 	  library
! 
! 				   11/5
! 				   ----
! jobs.c
! 	- fix cleanup_dead_jobs to hang onto the job corresponding to
! 	  last_asynchronous_pid only if the shell is not interactive
! 	  (this still has the problem that until a new async process
! 	  is started, the job will stay in the jobs table)
! 
! configure.in,aclocal.m4
! 	- added a new macro, BASH_TYPE_U_INT32_T, to check for u_int32_t
! 	  separately from int32_t, since there are systems (HP-UX 10.20)
! 	  that have a define for the latter but not the former
! 
! 				   11/6
! 				   ----
! jobs.c
! 	- cleanup_dead_jobs no longer checks whether the job it is deleting
! 	  corresponds to last_asynchronous_pid
! 	- notify_of_job_status and mark_dead_jobs_as_notified now will not
! 	  mark the job corresponding to last_asynchronous_pid as notified
! 	  if the shell is not interactive
! 	- wait_for_single_pid, if told to wait for last_asynchronous_pid,
! 	  or the job of which it is a member, will take care of marking
! 	  the job as notified after calling wait_for and collecting the
! 	  status.  This means that two successive `wait' calls for $! will
! 	  succeed the first time and fail the second, as POSIX.2 specifies
! 	  (take this code out if it causes problems)
! 
! 				   11/7
! 				   ----
! jobs.c
! 	- wait_for_job, if told to wait for the job corresponding to the
! 	  last async pid, will mark the job as notified after waiting for
! 	  it and collecting the status
! 
! general.h
! 	- fixed MEMBER macro to avoid reading past end of S (it used to
! 	  test s[1] before s[0], which is an error if s == "")
! 
! subst.c
! 	- expand_word_internal should free ISTRING before returning if
! 	  param_expand returns an error
! 	- parameter_brace_expand_word should free the memory it allocates
! 	  and passes to param_expand
! 
! execute_cmd.c
! 	- execute_arith_command should call dispose_words on the list
! 	  returned by expand_words
! 
! parse.y
! 	- after calling parse_arith_command, read_token needs to free the
! 	  string value that parse_arith_command fills in, since make_word
! 	  makes a copy of the string it's passed
! 
! 				   11/10
! 				   -----
! subst.c
! 	- cond_expand_word needs to free the value returned by string_list
! 	  after it is run through quote_string_for_globbing
! 
! parse.y
! 	- make sure cond_term frees yylval.word if it is just a `!' and
! 	  it's parsed as a term negation operator
! 
! variables.c
! 	- assign_array_var_from_string needs to free the word list returned
! 	  by parse_string_to_word_list after calling expand_words_shellexp
! 	  on it
! 
! execute_cmd.c
! 	- changed execute_simple_command to avoid saving the_printed_command
! 	  into command_line until just before it's needed.  This should save
! 	  time and prevent memory leaks on errors, but it must be watched
! 	  closely to make sure that the_printed_command doesn't change out
! 	  from under execute_simple_command before we copy it
! 
! 				   11/12
! 				   -----
! builtins/alias.def
! 	- alias and unalias should print error messages when passed an
! 	  argument that is not an alias for printing or deletion,
! 	  respectively, even if the shell is not interactive
! 
! builtins/exit.def
! 	- `logout' will no longer exit a non-login non-interactive shell
! 
! 				   11/17
! 				   -----
! lib/readline/nls.c
! 	- add `koi8-r' as a legal LANG value
! 
! builtins/alias.def
! 	- if `alias' or `alias -p' is executed when no aliases are defined,
! 	  the return status should be 0, according to POSIX.2
! 
! 				   11/18
! 				   -----
! subst.c
! 	- changed a couple of calls to make_word_list (make_word(z), ...)
! 	  to add_string_to_list (z, ...)
! 
! execute_cmd.c
! 	- execute_cond_command now sets this_command_name to `[['
! 
! 				   11/21
! 				   -----
! variables.c
! 	- all_visible_{function,variable}s and the functions they call
! 	  should be compiled in only if READLINE is defined
! 
! 				   11/24
! 				   -----
! aclocal.m4
! 	- remove some leading whitespace before preprocessor statements in
! 	  BASH_KERNEL_RLIMIT_CHECK
! 
! general.[ch]
! 	- fix declarations for group_member so the extern declaration in
! 	  general.h agrees with the definition in general.c (fix from
! 	  Andreas Schwab <schwab@issan.informatik.uni-dortmund.de>)
! 
! builtins/cd.def
! 	- print the new working directory if the shell is interactive
! 	  and `cd -' succeeds
! 	- don't print the new working directory if it's found in $CDPATH
! 	  if the shell is not interactive
! 
! 				   11/25
! 				   -----
! builtins/cd.def
! 	- fixes to bindpwd so that it copes with get_working_directory
! 	  returning NULL (bug from schwab@issan.informatik.uni-dortmund.de)
! 
! 				   12/2
! 				   ----
! support/config.guess
! 	- add support for new OS name for SINIX SVR4 systems
! 
! 				   12/3
! 				   ----
! 
! builtins/set.def
! 	- `unset' should check that a function it's trying to unset is a
! 	  legal identifier only when in POSIX mode
! 
! redir.c
! 	- changed here_document_to_fd to try and make sure the filename
! 	  used for the here document is `more unique', since the old
! 	  version would fail if two here documents were created in less
! 	  than a second
! 
! 				   12/4
! 				   ----
! builtins/cd.def
! 	- POSIX.2 says that if CDPATH is used to find the new directory,
! 	  and it's not relative to the current directory, the new directory
! 	  name should be displayed on stdout even if the shell is not
! 	  interactive
! 
! 				   12/5
! 				   ----
! parse.y
! 	- changes so that `time' is recognized as a reserved word only at
! 	  the beginning of a pipeline (the last read token is one of 0,
! 	  `;', `\n', `&&', `||', or `&'):
! 
! 		o add clause to special_case_tokens that does the check
! 		  and returns TIME if the conditions are met
! 		o take check for `TIME' out of CHECK_FOR_RESERVED_WORD, but
! 		  leave it in the word_token_alist so that `type' still
! 		  reports it as a `keyword'
! 		o new function, time_command_acceptable(), encapsulates the
! 		  necessary conditions for `time' to be returned as a 
! 		  reserved word
! 
! [bash-2.02-alpha1 frozen]
! 
! 				 1/6/1998
! 				 --------
! lib/glob/fnmatch.c
! 	- fix define for isgraph so that it does not return success for space
! 	- fix strcompare() so that the call to strcoll is surrounded by
! 	  #ifdef HAVE_STRCOLL
! 
! 				    1/7
! 				    ---
! lib/glob/fnmatch.c
! 	- the `test' argument to brackmatch() should be of type `unsigned char'
! 
! 				   1/11
! 				   ----
! execute_cmd.c
! 	- make sure execute_arith_command sets this_command_name to `(('
! 
! 				   1/29
! 				   ----
! parse.y
! 	- make sure the code for pushing and popping strings is compiled in
! 	  if either ALIAS or DPAREN_ARITHMETIC is defined, because the ((
! 	  code uses push_string in the case of a nested subshell
! 	- fix cond_skip_newlines so it resets the prompt to $PS2 while
! 	  parsing an unfinished conditional command
! 
! dispose_cmd.c, copy_cmd.c, builtins/hash.def
! 	- fixes to not use `word' as a variable name or the name of a
! 	  function parameter to get around stuff in the Cray Unix include
! 	  files
! 
! builtins/printf.def
! 	- return failure immediately if an illegal format character is
! 	  encountered
! 
! redir.c
! 	- make the code that creates here-documents behave better if the
! 	  file it's trying to create already exists for some reason
! 
! lib/readline/complete.c
! 	- changed print_filename to return the number of characters it
! 	  outputs; changed callers to use that value.  This makes columns
! 	  line up when printing completion listings with filenames
! 	  containing control characters
! 
! doc/bash.{1,html}
! 	- fixed a typo in the quote removal section
! 
! 				   1/30
! 				   ----
! parse.y
! 	- free_string_list() needs to check that t->expander is not NULL
! 	  before trying to dereference it
! 	- reset_parser() doesn't need to set pushed_string_list to NULL
! 	  after calling free_string_list(), since free_string_list does it
! 
! configure.in,cross-build/cygwin32.cache
! 	- fixes from Geoff Noer for better cygwin32 cross-compilation
! 
! tests/printf.{tests,right}
! 	- removed test for integer overflow, since error messages differ
! 	  across systems
! 
! pathexp.c
! 	- fixed a problem with unquoted_glob_pattern_p that made things
! 	  like `x+*' not expand correctly
! 
! lib/glob/glob.c
! 	- fixed a problem with glob_pattern_p that made things like `x+*'
! 	  not expand correctly
! 
! builtins/cd.def
! 	- if `cd -P' is executed, or `set -o physical' has been executed,
! 	  the value of $PWD after a successful cd will not contain any
! 	  symlinks, regardless of whether or not the shell is in posix mode
! 
! 				    2/3
! 				    ---
! lib/readline/shell.c
! 	- include <string.h> or <strings.h> as appropriate
! 
! 				    2/4
! 				    ---
! builtins/common.c
! 	- take out the code in backslash_quote() that looks for tildes to
! 	  quote, for the time being
! 	- if getcwd() fails, get_working_directory now prints the error
! 	  message corresponding to errno in addition to the rest of the
! 	  information -- TENTATIVE CHANGE
! 
! lib/sh/getcwd.c
! 	- fix from Paul Smith to make getcwd() behave better in the presence
! 	  of lstat(2) failures
! 
! stringlib.c
! 	- when copying the replacement string into the output string being
! 	  constructed, strsub() needs to make sure enough space for the
! 	  replacement string is allocated, not the length of the pattern
! 	  (use REPLEN, not PATLEN)
! 
! mailcheck.c
! 	- make sure make_default_mailpath() has a valid current_user struct
! 	  before trying to construct the default mailpath
! 
! 				    2/5
! 				    ---
! execute_cmd.c
! 	- execute_builtin needs to call run_unwind_frame if the builtin is
! 	  `source' or `eval' and we're not in a subshell rather than just
! 	  calling dispose_builtin_env, because not all invocations copy 
! 	  the temporary_env to builtin_env, and nested calls to `.' require
! 	  that the temporary env given to the first persist until that first
! 	  call to `.' finishes
! 
! parse.y
! 	- fix to history_delimiting_chars so that function definitions like
! 
! 		function xyz
! 		{
! 			echo a
! 		}
! 
! 	  are saved to the history correctly when command_oriented_history
! 	  is enabled, but literal_history is not
! 
! bashhist.c
! 	- when calling internal_error from pre_process_line, use "%s" as
! 	  the format with history_value as the argument to avoid the
! 	  problem with the failed history event containing printf escape
! 	  sequences
! 
! 				   2/13
! 				   ----
! shell.c
! 	- if shell_initialized is non-zero, don't line-buffer stderr and
! 	  stdout in shell_initialize on SunOS5 -- see if this fixes the
! 	  crashing problems for scripts without a leading `#! /bin/sh'
! 
! 				   2/17
! 				   ----
! bashline.c
! 	- added diffs to _ignore_completion_names from Andreas Schwab to
! 	  complete names that would otherwise be ignored with FIGNORE if
! 	  they are the only possible completions.  Define NO_FORCE_FIGNORE
! 	  if you want this; it is not defined by default
! 
! 				   2/19
! 				   ----
! support/bashbug.sh
! 	- changed the bug-bash address to bug-bash@gnu.org
! 
! examples/loadables/Makefile.in
! 	- converted from `Makefile' with some boilerplate configure variables
! 	  to find the source and build directories -- still requires some
! 	  hand-editing to get the right CFLAGS and LDFLAGS for shared object
! 	  creation
! 
! Makefile.in
! 	- create examples/loadables/Makefile with `make makefiles'
! 
! configure.in
! 	- create examples/loadables directory so `make makefiles' can write a
! 	  makefile there
! 
! general.c
! 	- make sure initialize_groups_array always sets things up so that
! 	  ${GROUPS[0]} is the user's primary group (current_user.gid)
! 
! 				   2/20
! 				   ----
! lib/readline/parens.c
! 	- change the time delay when showing matching parens from 1.5 sec to
! 	  0.5 sec
! 
! 				   2/23
! 				   ----
! shell.c
! 	- isnetconn() should call getpeername(fd,...) instead of using 0
! 	  (though fileno(stdin) should always be 0)
! 
! support/config.guess
! 	- updates from master FSF copy
! 
! 				   2/24
! 				   ----
! support/man2html.c
! 	- modified version of man2html to convert bash.1 into bash.html
! 
! support/Makefile.in
! 	- simple Makefile to create man2html
! 
! configure.in
! 	- make sure support/Makefile is created
! 
! Makefile.in
! 	- make sure support/Makefile is created and cleaned
! 
! doc/Makefile.in
! 	- changes to suffix rules to say how to make .html from .1 
! 	- `bash.html' is now a makefile target, created by man2html from
! 	  bash.1 rather than being hand-modified
! 
! lib/sh/itos.c, general.c
! 	- new file, itos() from general.c.  This is here because the
! 	  implementation of strerror in lib/sh/strerror.c uses itos()
! 
! Makefile.in, lib/sh/Makefile.in
! 	- changes to add itos.c in libsh.a
! 
! externs.h, general.h
! 	- moved extern declaration of itos() from general.h to externs.h
! 
! aclocal.m4
! 	- changes to BASH_LARGE_FILE_SUPPORT for the LFS64_* variables in
! 	  Solaris 2.6
! 
! Makefile.in
! 	- make sure configure sets CPPFLAGS in this file
! 
! 				   2/27
! 				   ----
! 
! builtins/command.def
! 	- make sure get_standard_path returns the value of
! 	  STANDARD_UTILS_PATH if _CS_PATH is defined, but confstr(3)
! 	  returns 0, indicating that _CS_PATH does not have a defined
! 	  value
! 
! bashhist.c
! 	- fixed bash_history_inhibit_expansion() so that extended globbing
! 	  expressions like *.!(c) are not history expanded if extended_glob
! 	  is non-zero (shopt -s extglob has been executed)
! 
! 				    3/2
! 				    ---
! Makefile.in
! 	- changed release status to `beta1'
! 
! [bash-2.02-beta1 frozen]
! 
! 				   3/17
! 				   ----
! lib/readline/vi_mode.c
! 	- make sure _rl_vi_save_insert() gets a non-null UNDO_LIST pointer
! 	  before trying to do anything with it
! 
! jobs.c
! 	- add a call to internal_warning from wait_for_job if the job is
! 	  stopped
! 	- changed notify_of_job_status to not report pipelines exiting due to
! 	  SIGPIPE in non-interactive shells if the shell is compiled with
! 	  -DDONT_REPORT_SIGPIPE
! 
! builtins/psize.sh
! 	- some fixes to try to avoid /tmp file races and surreptitious
! 	  substitutions
! 
! version.c
! 	- changed the extended version info to show 1998 as the copyright year
! 
! parse.y
! 	- fixes from Andreas Schwab <schwab@LS5.informatik.uni-dortmund.de>
! 	  for compilation errors when the shell is configured --disable-alias
! 	  but with dparen arithmetic enabled
! 
! eval.c
! 	- fixes from Andreas Schwab <schwab@LS5.informatik.uni-dortmund.de> to
! 	  make sure the input stream is popped correctly when performing an
! 	  array assignment in the command argument to `bash -c', e.g.,
! 	  `bash -c 'A=()''
! 
! builtins/kill.def
! 	- make `kill' with no arguments print a usage message and return a
! 	  failure status
! 
! alias.c
! 	- fix so that rd_token doesn't dump core when trying to do alias
! 	  expansion on a line containing an unclosed single quote (fix from
! 	  Vasco Pedro <vp@di.fct.unl.pt>)
! 
! builtins/cd.def
! 	- fix so that using a non-empty directory from CDPATH to construct
! 	  the name of the directory to change to results in an absolute
! 	  pathname of the new current working directory being displayed,
! 	  as POSIX.2 specifies
! 
! support/bashbug.sh
! 	- a couple of small fixes to minimize /tmp file races -- the script
! 	  is still raceable, the window is just smaller
! 
! 				   3/24
! 				   ----
! variables.c
! 	- make sure assign_in_env passes a malloc'd string to
! 	  expand_string_unsplit, because some of the error code assumes that
! 	  it is malloc'd and frees it (bug reported by Marko.Makela@HUT.FI)
! 
! 				   3/25
! 				   ----
! doc/bashref.texi
! 	- changed the email addresses to use the @email texinfo tag
! 
! trap.c
! 	- call reset_parser from the exit trap code before calling
! 	  parse_and_execute, so reserved words are parsed correctly
! 
! subst.c
! 	- make sure parameter_brace_patsub expands the pattern string as if
! 	  the expression were not in double quotes, even if the entire
! 	  expansion is enclosed in double quotes, so that quote removal
! 	  on embedded double quotes is performed correctly (bug report from
! 	  schwab@issan.informatik.uni-dortmund.de)
! 
! 				   3/27
! 				   ----
! support/config.guess
! 	- changes to allow Power PCs running Apple's Rhapsody to configure
! 
! 				   3/31
! 				   ----
! 
! Makefile.in
! 	- changed release status to `beta2'
! 
! [bash-2.02-beta2 frozen]
! 
! 				    4/6
! 				    ---
! subst.c
! 	- make sure command_substitute does not try to set the terminal's
! 	  process group to a background job
! 
! [bash-2.02 frozen]
! 
! 				   4/18
! 				   ----
! [bash-2.02 released]
! 
! 				   4/20
! 				   ----
! bashline.c
! 	- make sure that rl_defun is not called for
! 	  history-and-alias-expand-line unless both ALIAS and BANG_HISTORY
! 	  are defined
! 	  [in bash-2.02.1]
! 
! 				   4/22
! 				   ----
! make_cmd.c
! 	- make sure that make_here_document allocates enough space for the
! 	  first line of the here document, by using the line length +2
! 	  (instead of 1000, which is what the old code did, and breaks if
! 	  the first line of the here document is enough longer than 1000
! 	  characters to cause other memory to be scribbled on)
! 	  [in bash-2.02.1]
! 
! builtins/cd.def
! 	- when in posix mode, a value of "" for CDPATH should be treated the
! 	  same as the current directory, not result in an error
! 	  [in bash-2.02.1]
! 
! lib/malloc/malloc.c
! 	- change the mh_align member of `union mhead' to be of type double
! 	  rather than a pointer, so that malloc will return (hopefully)
! 	  8-byte aligned memory
! 	  [in bash-2.02.1]
! 
! 				   4/23
! 				   ----
! aclocal.m4
! 	- add a new macro to check whether or not off_t is 64 bits 
! 
! 				   4/24
! 				   ----
! configure.in
! 	- fixed a typo so the bash malloc is not compiled in on mips-sgi-irix6
! 
! lib/readline/display.c
! 	- fix for readline redisplay if the prompt string is longer than the
! 	  screen width and includes invisible characters
! 	  [in bash-2.02.1]
! 
! jobs.c
! 	- make_child should not set the terminal's process group to
! 	  pipeline_pgrp if pipeline_pgrp == shell_pgrp (indicating that we
! 	  are forking a child for a command substitution)
! 	  [in bash-2.02.1]
! 
! subst.c
! 	- in execute_simple_command, in the child forked if there is a pipe
! 	  or the command is asynchronous, set subshell_environment to
! 	  SUBSHELL_ASYNC only if the command is asynchronous, SUBSHELL_FORK
! 	  if there is a pipe in or out
! 	  [in bash-2.02.1]
! 
! 				   4/27
! 				   ----
! support/texi2dvi
! 	- upgraded to version 0.8 (from 0.5)
! 
! support/texi2html
! 	- upgraded to version 1.52 (from 1.51)
! 
! support/config.sub
! 	- config.sub now recognizes all the permutations of the system name
! 	  that config.guess produces for alphas
! 	  [in bash-2.02.1]
! 
! aclocal.m4
! 	- changed BASH_TYPE_INT32_T, BASH_TYPE_U_INT32_T, and
! 	  BASH_TYPE_PTRDIFF_T to avoid compiling a program; instead use
! 	  the values determined by the AC_CHECK_SIZEOF tests to determine
! 	  the default values to supply to AC_CHECK_TYPE
! 
! configure.in
! 	- don't call AC_CHECK_TYPE({int32_t,u_int32_t,ptrdiff_t}) from
! 	  configure.in; use the updated BASH_TYPE macros instead
! 
! builtins/exec.def
! 	- if shell_execve fails, set ARGS to null because the realloc() call
! 	  by shell_execve may have caused it to be reallocated and freed --
! 	  we don't want to free the memory twice
! 
! lib/glob/fnmatch.c
! 	- fixes from ache@nagual.pp.ru to make fnmatch work for eight-bit
! 	  characters when `isupper' and `islower' are used -- they were
! 	  restricted to ASCII characters before, probably to work around
! 	  some ancient, broken C libraries in which is{low,upp}er are valid
! 	  only for ASCII characters and return bogus values otherwise
! 	  [in bash-2.02.1]
! 
! 				   4/29
! 				   ----
! builtins/cd.def
! 	- fixed a problem with the shell displaying the old working directory
! 	  instead of the new one after changing to a directory found via
! 	  $CDPATH when in physical mode (set -o physical)
! 	  [in bash-2.02.1]
! 
! make_cmd.c
! 	- make make_cond_command initialize the line number from the cond_node
! 	  that's passed as an argument (not that it's used right now)
! 
! copy_cmd.c
! 	- make sure that copy_cond_command copies the type of the cond command,
! 	  since execute_cond_command uses that to decide what kind of test
! 	  to perform
! 	  [in bash-2.02.1]
! 
! builtins/printf.def
! 	- make sure the for loop that processes the format string actually
! 	  consumes arguments; otherwise process it only once to avoid
! 	  infinite loops (e.g., `printf " " abc def ghi')
! 	  [in bash-2.02.1]
! 	- if the format string is empty after preprocessing by ansicstr,
! 	  return immediately
! 	  [in bash-2.02.1]
! 
! tests/run-printf
! 	- use `diff -a' so the presence of a non-printing character in the
! 	  output doesn't confuse diff into thinking the files are binary
! 	  (test whether or not `diff' supports `-a' first)
! 
! Makefile.in
! 	- keep $(LOCAL_LIBS) from being specified twice
! 
! 				   4/30
! 				   ----
! support/shobj-conf
! 	- a script to generate variables to do shared object configuration
! 	  for the loadable builtin stuff
! 
! configure.in
! 	- added a section for shared object configuration using an `eval'
! 	  of the output of shobj-conf and substituting the generated values
! 	  with AC_SUBST
! 
! examples/loadables/Makefile.in
! 	- the system-specific shared object configuration variables are now
! 	  substituted by configure
! 
! 				    5/4
! 				    ---
! builtins/ulimit.def
! 	- some changes for HPUX 9.x's peculiar handling of RLIMIT_FILESIZE
! 	- changed the limit retrieval functions to return an error code
! 	  and the value in a reference argument to avoid use of RLIM_INVALID
! 
! general.c
! 	- new function, get_group_array(), which returns an array of
! 	  gids
! 
! examples/loadables/{id,printenv,sync,uname,whoami,push}.c
! 	- new loadable builtins
! 
! variables.c
! 	- moved code that initializes $PPID into a new function, set_ppid()
! 
! variables.h
! 	- extern declaration for set_ppid()
! 
! 				    5/6
! 				    ---
! subst.c
! 	- make sure that the `"' (double-quoted string) case of
! 	  expand_word_internal calls string_list_dollar_at if we've expanded
! 	  a double-quoted $@ so correct splitting on $IFS is done when
! 	  the expansion is complete.  We can't simply call string_list
! 	  because that forces a space separator, and $IFS may not contain
! 	  a space
! 	  [in bash-2.02.1]
! 
! 				    5/7
! 				    ---
! builtins/umask.def
! 	- broke the code that parses a symbolic mode out of symbolic_umask
! 	  into a separate function that takes a symbolic mode and an initial
! 	  set of bits to modify
! 
! examples/loadables/mkdir.c
! 	- new loadable builtin
! 
! 				   5/11
! 				   ----
! builtins/printf.def
! 	- use the format string length provided by ansicstr() to process the
! 	  format string, rather than testing for nullness, to handle NUL
! 	  bytes in the expanded format string
! 
! builtins/pushd.def
! 	- changes so it can be built as both a regular builtin and a loadable
! 	  builtin from the same source
! 
! examples/loadables/Makefile.in
! 	- changes to build pushd.c from ${topdir}/builtins/pushd.def and then
! 	  compile it with the correct flags to make it a loadable builtin,
! 	  even if PUSHD_AND_POPD is not defined in config.h
! 
! 				   5/12
! 				   ----
! lib/readline/complete.c
! 	- use rl_completer_quote_characters instead of #ifdef SHELL/#endif
! 	  code in make_quoted_replacement.  This means complete.c no longer
! 	  has any #ifdef SHELL code
! 
! 				   5/13
! 				   ----
! builtins/Makefile.in
! 	- `make clean' should remove mkbuiltins.o
! 
! Makefile.in
! 	- all of the various `clean' targets need to descend into lib/sh
! 	  and run the appropriate target there
! 
! builtins/type.def
! 	- changed to use the builtin getopt.  The old long options are
! 	  handled by prescanning the argument list looking for the long
! 	  options, processing them, and taking them out of the list before
! 	  passing it to internal_getopt()
! 
! lib/readline/signals.c
! 	- removed #ifdef SHELL code -- job control signals and SIGTERM are
! 	  always set in rl_set_signals, but are set to SIG_IGN if the old
! 	  handler was SIG_IGN (as bash sets it)
! 	- new function rl_maybe_set_sighandler, which sets the signal
! 	  disposition back to SIG_IGN if the old handler was SIG_IGN
! 	- removed #ifdef HANDLE_JOB_SIGNALS and #ifdef HANDLE_SIGTERM code
! 
! lib/readline/rltty.c
! 	- removed #ifdef SHELL code -- set_winsize is always called
! 	  to force the application to stop if it's not in the foreground
! 	  before getting the tty attributes
! 
! 				   5/14
! 				   ----
! lib/readline/signals.c
! 	- readline now catches SIGQUIT and cleans up the tty before resending
! 	  it to its container application (unless the calling application has
! 	  set the disposition of SIGQUIT to be SIG_IGN)
! 	- rl_handle_sigwinch is now called rl_sigwinch_handler
! 	- rl_sigwinch_handler now calls rl_resize_terminal to fetch the
! 	  screen size after a SIGWINCH
! 	- the sighandler_cxt struct for non-posix systems now includes
! 	  sa_flags and sa_mask variables, for future use
! 	- new variable, rl_catch_signals, indicating that readline should
! 	  install its own signal handlers for SIGINT, SIGTERM, SIGQUIT,
! 	  SIGALRM, SIGTSTP, SIGTTIN, and SIGTTOU
! 	- new variable, rl_catch_sigwinch, indicating that readline should
! 	  install its own SIGWINCH handler, which will chain to a calling
! 	  application's SIGWINCH handler
! 	- new function, rl_free_line_state(), to free up variable state
! 	  associated with the current line after receiving a signal
! 	- new function, rl_cleanup_after_signal(), to clean up the display
! 	  and terminal state after receiving a signal
! 	- new function, rl_reset_after_signal(), to reinitialize the
! 	  terminal state after a signal handler returns and readline
! 	  continues
! 	- rl_set_signals and rl_clear_signals now look at the values of
! 	  rl_catch_signals and rl_catch_sigwinch
! 
! lib/readline/terminal.c
! 	- new function rl_resize_terminal (), to reset readline's idea of
! 	  the screen size after a SIGWINCH
! 
! lib/readline/readline.h
! 	- extern declarations for rl_resize_terminal(), rl_free_line_state(),
! 	  rl_cleanup_after_signal(), rl_reset_after_signal()
! 	- extern declarations for rl_catch_signals and rl_catch_sigwinch
! 
! variables.c
! 	- new functions, get_env_value(char *) and get_home_dir(void) to
! 	  satisfy references from the tilde and readline libraries when
! 	  they are compiled as part of bash
! 
! lib/tilde/tilde.c
! 	- rely on extern declarations of get_env_value and get_home_dir;
! 	  there is no more #ifdef SHELL code
! 
! lib/readline/shell.c
! 	- implementation of get_home_dir that uses getpwuid() to satisfy
! 	  references from tilde.c when not compiled as part of bash
! 	- removed savestring()
! 	- removed #ifdef SHELL/#endif pair -- all of these functions will be
! 	  resolved from bash when readline is linked into bash
! 
! lib/readline/savestring.c
! 	- new file, with function definition for savestring() for backwards
! 	  compatibility
! 
! Makefile.in, _distribution
! 	- bumped things up to bash-2.03-alpha
! 
! 				   5/15
! 				   ----
! lib/readline/rlconf.h
! 	- removed #ifdef SHELL/#endif pair, so the callback stuff will be
! 	  compiled into libreadline, but never linked into bash (since it's
! 	  not referenced)
! 
! configure.in
! 	- added new `--with-installed-readline' option to allow readline to
! 	  be linked with an already-installed version -- this will probably
! 	  not work with versions of readline prior to 2.3 (libreadline.so.4)
! 	  [THIS IS STILL UNDOCUMENTED]
! 
! Makefile.in
! 	- changed necessary variables to allow the `--with-installed-readline'
! 	  option to work; shared and static libraries are supported
! 
! 				   5/18
! 				   ----
! lib/readline/display.c
! 	- _rl_save_prompt is now rl_save_prompt; _rl_restore_prompt is now
! 	  rl_restore_prompt
! 
! lib/readline/readline.h
! 	- extern declarations for rl_save_prompt and rl_restore_prompt
! 
! lib/readline/{search,isearch,readline,display}.c
! 	- converted calls to _rl_{save,restore}_prompt () to use new public
! 	  versions
! 
! lib/readline/doc/rltech.texinfo
! 	- documented new public functions rl_{save,restore}_prompt
! 
! 				   5/19
! 				   ----
! lib/readline/readline.c
! 	- new hook function variable, rl_pre_input_hook.  If non-zero, it's
! 	  called from readline_internal_setup just before it returns and
! 	  readline starts reading input
! 
! lib/readline/readline.h
! 	- extern declaration for rl_pre_input_hook
! 
! lib/readline/doc/rltech.texinfo
! 	- documented new variable rl_pre_input_hook
! 
! 				   5/20
! 				   ----
! lib/readline/complete.c
! 	- new hook function variable, rl_completion_display_matches_hook.
! 	  If non-null, this function is called when readline would normally
! 	  display the list of completion matches
! 
! lib/readline/readline.h
! 	- extern declaration for rl_completion_display_matches_hook
! 
! lib/readline/doc/rltech.texinfo
! 	- documented rl_completion_display_matches_hook
! 
! lib/readline/readline.c
! 	- if RL_LIBRARY_VERSION is not defined, define it to 4.0 to match
! 	  the version number of the shared libraries
! 
! lib/readline/doc/{hist,rlman}.texinfo
! 	- changed the version and edition to 4.0 to match the library version
! 
! support/config.guess
! 	- added case clause for matching UnixWare 7 from SCO (SVR5) -- further
! 	  work may be needed 
! 	  [These fixes were in a usenet posting from hops@sco.com]
! 
! support/config.sub
! 	- added case clauses to recognize various aliases for SCO Open Server
! 	  and Open Desktop
! 	  [in bash-2.02.1]
! 	- broke the code that canonicalizes unixware into unixware2 and
! 	  unixware7 clauses (multiple places)
! 	  [in bash-2.02.1]
! 	- added clause to recognize `sysv5' for SVR5
! 	  [These fixes were in a usenet posting from hops@sco.com]
! 	  [in bash-2.02.1]
! 
! configure.in
! 	- add `-b elf' to LOCAL_CFLAGS for sco3.2v5* to allow dynamic linking
! 	  (and loadable builtins)
! 	- add AC_DEFINE(SVR5) on SVR5 (unixware 7)
! 
! config.h.in
! 	- add #undef SVR5, set by configure
! 
! 				   5/21
! 				   ----
! shell.c
! 	- line-buffer stdout and stderr in shell_initialize only if
! 	  shell_initialized is 0 on all systems, not just SunOS 5
! 	  [in bash-2.02.1]
! 
! support/rlvers.sh
! 	- script to print out the version number of any installed
! 	  readline library
! 
! configure.in
! 	- only allow --with-installed-readline if the version of the
! 	  installed readline library is 4.0 or greater
! 
! 				   5/22
! 				   ----
! lib/readline/complete.c
! 	- broke the code that actually displays a list of completion
! 	  matches on the output stream into a separate public function,
! 	  rl_display_match_list, so it can be called from the hook
! 	  function rl_completion_display_matches_hook.
! 
! lib/readline/readline.h
! 	- new extern declaration for rl_display_match_list
! 
! lib/readline/rltech.texinfo
! 	- documented rl_display_match_list
! 
! configure.in,Makefile.in
! 	- --enable-static-link now creates a STATIC_LD variable in Makefile
! 	  rather than adding to LDFLAGS directly.  LDFLAGS now includes
! 	  $(STATIC_LD)
! 
! 				    6/2
! 				    ---
! builtins/cd.def
! 	- OLDPWD is now auto-exported
! 	- broke the code out of bindpwd() that updated the value of PWD in
! 	  the export environment in-place and made it general, so it can
! 	  be used for OLDPWD, too (this should be made *more* general, and
! 	  moved to variables.c)
! 
! 				    6/3
! 				    ---
! variables.c
! 	- moved builtins/cd.def:export_pwd_var to here, renamed it to
! 	  update_export_env_inplace
! 	- converted put_command_name_into_env to just call
! 	  update_export_env_inplace
! 	- made dummy variable for OLDPWD, marked as invisible and exported,
! 	  in initialize_shell_variables
! 
! variables.h
! 	- extern declaration for update_export_env_inplace
! 
! builtins/cd.def
! 	- changed calls to export_pwd_var to update_export_env_inplace
! 
! lib/readline/bind.c
! 	- added missing return in rl_unbind_function_in_map
! 	- changed _rl_read_file to check whether or not `read' returns
! 	  < 0 rather than < file_size
! 	- _rl_read_init_file needs to free `openname' after calling
! 	  _rl_read_file, since it's not used again
! 
! lib/readline/callback.c
! 	- bogus extern declaration for `readline_internal_startup', should
! 	  be readline_internal_setup
! 
! lib/readline/histfile.c
! 	- read_history_range now checks whether read(2) returns < 0 rather
! 	  than checking the return value against the file size
! 
! lib/readline/parens.c
! 	- whoops -- timer.tv_usec is *micro* seconds, not milliseconds
! 
! lib/readline/readline.c
! 	- initialize `eof' to 1 in readline_internal_charloop
! 
! 				    6/5
! 				    ---
! configure.in
! 	- if we're configuring with an installed version of readline, set and
! 	  have configure substitute RL_INCLUDE to `-I$(includedir)', so the
! 	  build process uses the installed readline include files as well as
! 	  the libraries
! 
! Makefile.in, builtins/Makefile.in
! 	- add @RL_INCLUDE@ in the appropriate places, substituted by configure
! 
! lib/readline/{history,readline}.h
! 	- add `extern "C"' wrapper if `__cplusplus' is defined
! 
! lib/glob/fnmatch.h
! 	- include stdc.h
! 	- add prototypes to extern declaration for fnmatch()
! 
! lib/readline/rlstdc.h
! 	- link to ../posixheaders/stdc.h (in readline lib with different name
! 	  for benefit of standalone readline library installation)
! 
! lib/readline/{history,keymaps}.h
! 	- include rlstdc.h
! 	- add prototypes to all of the extern function declarations
! 
! lib/readline/history.h
! 	- the `data' member of a HIST_ENTRY is now a histdata_t, which is
! 	  either a void * (ansi c) or a char * (k&r c)
! 
! lib/readline/readline.c
! 	- changed calls to replace_history_entry to pass a histdata_t as the
! 	  third parameter
! 
! 				    6/8
! 				    ---
! copy_cmd.c
! 	- make sure that copy_cond_command doesn't blindly try to copy
! 	  com->op, since that will be null for AND and OR nodes, at least
! 	  [in bash-2.02.1]
! 
! lib/readline/vi_mode.c
! 	- added missing second argument to rl_vi_[fbe][Ww]ord(), since
! 	  they're used as pseudo-bindable commands (they appear in the
! 	  default funmap) as well as utility functions
! 
! lib/readline/readline.h
! 	- include rlstdc.h
! 	- added prototypes for functions from vi_mode.c, util.c, terminal.c,
! 	  search.c, util.c, undo.c, readline.c, parens.c, macro.c, kill.c,
! 	  keymaps.c, isearch.c, input.c, funmap.c, display.c, complete.c,
! 	  callback.c, 
! 	- added extern declarations for functions from rltty.c
! 
! lib/readline/{readline,util}.c
! 	- rl_refresh_line now takes the standard two arguments for bindable
! 	  commands; changed callers
! 
! lib/readline/*.c
! 	- small cleanups for incorrect arguments, etc. uncovered by use of
! 	  function prototypes
! 
! bashline.c
! 	- small cleanups for incorrect arguments, etc. uncovered by use of
! 	  function prototypes
! 
! 				   6/11
! 				   ----
! jobs.c
! 	- cast result of strsignal() to (char *) for the benefit of broken
! 	  Cray UNICOS machines
! 	  [in bash-2.02.1]
! 
! configure.in,aclocal.m4
! 	- new test, BASH_TYPE_BITS64_T, used to find out what basic type is
! 	  64 bits long; defaults to `double'
! 	- call AC_CHECK_SIZEOF(double)
! 
! config.h.in
! 	- #define for bits64_t, undef by default
! 
! 				   6/24
! 				   ----
! aclocal.m4
! 	- changed BASH_TYPE_BITS64_T so that it checks the size of a char *
! 	  first, before trying sizeof(double)
! 
! lib/readline/doc/rluser.texinfo,doc/{bash.1,readline.3}
! 	- changed default binding for tilde-expand to M-&, since bash
! 	  overrides M-~ to force username completion
! 
! bashline.c
! 	- fixed an off-by-one error in hostnames_matching that exhibited
! 	  itself when an exact multiple of 16 hostnames matched (fix
! 	  from <davidg@nikhef.nl>)
! 	  [in bash-2.02.1]
! 
! 				   6/30
! 				   ----
! lib/readline/readline.c
! 	- the maximum numeric argument is now 1000000
! 
! bashline.c
! 	- fixed a bug in bash_directory_completion_hook that caused memory
! 	  to be freed twice if a directory name containing an unset
! 	  variable was completed and `set -u' had been set
! 
! configure.in
! 	- on LynxOS, add a -DRECYCLES_PIDS to LOCAL_CFLAGS
! 
! execute_cmd.c
! 	- make sure that the changes to make the shell fork early when
! 	  run in the background do not cause commands such as `%1 &'
! 	  to fork
! 	  [in bash-2.02.1]
! 	- if RECYCLES_PIDS is defined, execute_command_internal sets
! 	  last_made_pid to NO_PID after waiting for a foreground process,
! 	  if the return status is 0 (fix from plai@Lynx.COM (Paul Lai))
! 
! lib/readline/kill.c
! 	- fixes from Andreas Schwab to rl_yank_last_arg that make it
! 	  behave better
! 
! lib/readline/input.c
! 	- fixes from Donald Beaudry <donb@sgi.com> to make the input buffering
! 	  and rl_stuff_char work right when the input buffer is nearly full
! 	  (probably not a problem with keyboard input, but maybe a problem
! 	  with programmers attempting to use rl_stuff_char to preload the
! 	  input buffer)
! 
! 				   7/14
! 				   ----
! parse.y
! 	- fix to decode_prompt_string so that the \$ expansion quotes the `$'
! 	  so it won't be processed by subsequent parameter expansion
! 	- change read_token_word so a $$ appearing in a token is recognized
! 	  and parsed immediately, so a single or double quote after the
! 	  second `$' doesn't cause ANSI-C expansion or locale translation
! 	  (bug report from haertel@ichips.intel.com)
! 
! 				   7/16
! 				   ----
! lib/readline/display.c
! 	- fixed a bug that caused core dumps in xrealloc if the prompt was
! 	  longer than 1024 characters
! 
! 				   7/21
! 				   ----
! builtins/mkbuiltins.c
! 	- if the number of characters read from the .def file is less than
! 	  the file size reported by `stat', and the read completed without
! 	  errors, reset the file size to avoid writing garbage at the end
! 	  of the generated .c file (needed on WIN32 systems, doesn't hurt
! 	  on Unix)
! 
! 				   7/22
! 				   ----
! CWRU/empty-for-wordlist
! 	- patch from Brian Fox for parse.y to allow bash to accept an empty
! 	  `wordlist' after the `in' keyword in a for statement
! 
! 				   7/23
! 				   ----
! doc/bash.1
! 	- corrected the synopsis of the `for' and `select' statements to
! 	  indicate that the semicolon (or newline) after the optional
! 	  `in words' is required
! 
! [bash-2.02.1 released]
! 
! 				   7/28
! 				   ----
! lib/readline/display.c
! 	- make sure visible_length is initialized to 0 in rl_expand_prompt.
! 	  Fix from Gerhard Niklasch <nikl@mathematik.tu-muenchen.de>.
! 
! lib/glob/glob.c
! 	- make sure that quotes are removed from the filename being globbed
! 	  in glob_vector() before calling the GLOB_TESTNAME macro if there
! 	  are no globbing characters in the pattern
! 
! doc/Makefile.in
! 	- make sure that builtins.1 is looked for in $(srcdir) when running
! 	  `make install' (it's still commented out, though)
! 
! 				   7/30
! 				   ----
! config.h.bot
! 	- if PROMPT_STRING_DECODE is not defined, define PPROMPT (the primary
! 	  prompt string) as "$ "
! 
! variables.c
! 	- if PROMPT_STRING_DECODE is not defined, and current_user.euid == 0,
! 	  PS1 defaults to "# ", otherwise it defaults to `primary_prompt'
! 
! doc/bashbug.1
! 	- fixed email address prep.ai.mit.edu -> gnu.org
! 
! 				    8/3
! 				    ---
! support/shobj-conf
! 	- add `solaris2' as a possible OS name, treated the same as sunos5
! 
! 				    8/4
! 				    ---
! shell.c
! 	- changed maybe_make_restricted() so that $ENV and $BASH_ENV are
! 	  read-only variables in a restricted shell
! 
! doc/{bash.1,bashref.texi}
! 	- added ENV and BASH_ENV to the list of readonly variables in
! 	  restricted mode
! 
! parse.y
! 	- added `do', `then', `else', `{', and `(' to the list of keywords
! 	  that may precede the `time' reserved word
! 
! general.c
! 	- added sanity checks to timeval_to_secs and clock_t_to_secs so
! 	  that if the fractional part is >= 1000, 1 is added to the
! 	  seconds and 1000 is subtracted from the fractional seconds
! 
! 				    8/6
! 				    ---
! Makefile.in
! 	- use $(CC_FOR_BUILD) to build mksignames
! 
! configure.in
! 	- changes to allow cross-building for BeOS as well as cygwin32
! 
! cross-build/{beos-sig.h,x86-beos.cache}
! 	- new files for cross-compiling for BeOS
! 
! 				    8/7
! 				    ---
! Makefile.in
! 	- changed rule for version.h to use && instead of if-then-else-fi to
! 	  make sure the recipe fails if mkversion.sh fails
! 
! configure.in
! 	- beos does not use the GNU malloc
! 
! lib/sh/itos.c
! 	- broke itos into inttostr(i, buf, len) and itos(i), which calls
! 	  inttostr and returns a newly-allocated string with the result
! 
! support/mksignames.c
! 	- define `SIGKILLTHR' if system include files define it
! 
! externs.h
! 	- extern declaration for inttostr(int, char *, int)
! 
! 				   8/13
! 				   ----
! lib/sh/strtol.c
! 	- include stdc.h before bashansi.h
! 
! execute_cmd.c
! 	- make sure that execute_cond_node treats `=' the same as `=='
! 
! 				   8/25
! 				   ----
! variables.c, print_cmd.c
! 	- changed some calls to itos to use inttostr instead
! 
! cross-build/x86-beos.cache, {execute_cmd,general,shell,trap}.c
! 	- some changes for BeOS (from fnf@ninemoons.com)
! 
! lib/posixheaders/memalloc.h
! 	- changes to handle case where we're using both gcc and the C
! 	  version of alloca(), or if we have alloca.h and we're using
! 	  the C version of alloca() (from fnf@ninemoons.com)
! 
! lib/sh/oslib.c
! 	- if bcopy or bzero are #defines, #undef them before defining
! 	  replacement functions
! 
! support/config.guess
! 	- recognize AmigaOS (from fnf@ninemoons.com)
! 	- recognize BeOS running on various machines
! 	  (from fnf@ninemoons.com)
! 
! support/config.sub
! 	- change basic_machine definition for amiga; added amigaos
! 	  (from fnf@ninemoons.com)
! 	- changed definitions for MIPS machines running Linux (from
! 	  fnf@ninemoons.com)
! 	- recognize `beos' as a valid operating system
! 	  (from fnf@ninemoons.com)
! 	- changed OS for *-cbm to `amigaos' rather than `amigados'
! 	  (from fnf@ninemoons.com)
! 
! examples/functions/autoload.v3
! 	- a new version, from Mark Kennedy <mtk@ny.ubs.com>
! 
! lib/readline/readline.c
! 	- new function, rl_delete_or_show_completions, like tcsh editing
! 	  function delete-char-or-list
! 
! lib/readline/readline.h
! 	- new extern declaration for rl_delete_or_show_completions
! 
! lib/readline/funmap.c
! 	- new bindable name `delete-char-or-list', like tcsh
! 
! lib/readline/doc/rluser.texinfo, doc/{bash.1,readline.3}
! 	- documented new delete-char-or-list command
! 
! general.c
! 	- fix full_pathname to keep it from generating things like
! 	  //foo when the current directory is /
! 
! 				   8/27
! 				   ----
! builtins/fc.def
! 	- fixed the help text for the -e option
! 
! 				   8/28
! 				   ----
! support/shobj-conf
! 	- added a clause for AIX 4.2 systems running gcc -- just the
! 	  standard gcc stuff for shared objects, but it has to come
! 	  before the other AIX 4.2 clause
! 
! 				   8/31
! 				   ----
! shell.c
! 	- some changes so that `set -e' is turned off while executing
! 	  the startup files
! 
! 				    9/3
! 				    ---
! flags.c
! 	- new variable, `restricted_shell', non-zero if the shell was
! 	  started in restricted mode
! 
! flags.h
! 	- extern declaration for restricted_shell
! 
! shell.c
! 	- new function, shell_is_restricted, returns 1 if the shell is
! 	  supposed to be restricted based on the basename of $0 or the
! 	  -r option
! 	- set restricted_shell to the value returned by shell_is_restricted
! 	  before executing the startup files
! 
! externs.h
! 	- extern declaration for shell_is_restricted
! 
! builtins/shopt.def
! 	- new shopt variable, restricted_shell, indicates whether the shell
! 	  was restricted at startup -- useful in startup files
! 
! doc/{bash.1,bashref.texi}
! 	- documented new restricted_shell shopt option
! 
! 				   9/15
! 				   ----
! lib/sh/rename.c
! 	- new file, replacement for rename(2) if the OS doesn't provide it
! 
! configure.in,config.h.in,Makefile.in,lib/sh/Makefile.in
! 	- machinery for including rename.o in libsh.a
! 
! nojobs.c
! 	- make sure that set_tty_state returns a value
! 
! builtins/mkbuiltins.c
! 	- use a call to rename(2) instead of a link/unlink pair
! 
! lib/glob/glob.c
! 	- don't #define bcopy if bcopy is already defined
! 
! lib/readline/histfile.c
! 	- add a call to ftruncate for BeOS, which ignores the O_TRUNC flag
! 	  to open
! 
! lib/readline/input.c
! 	- make rl_getc loop if read returns -1/EINTR on BeOS
! 
! configure.in
! 	- set ARFLAGS and substitute it into the Makefiles
! 
! {,builtins,lib/{glob,malloc,readline,sh,termcap,tilde}}/Makefile.in
! 	- ARFLAGS is now substituted by configure
! 	- use ARFLAGS in rules that create libraries using $(AR)
! 
! builtins/printf.def
! 	- fixed bug that caused a core dump when a modifier was supplied
! 	  in the format string without a conversion character (e.g. `%h')
! 
! 				   9/17
! 				   ----
! lib/glob/glob.c
! 	- if filenames starting with a dot don't have to be matched
! 	  explicitly (e.g., after a `shopt -s dotglob'), don't match
! 	  `.' or `..' in any case
! 
! eval.c
! 	- make sure that array assignments don't show up in the history list
! 	  (fix from Andreas Schwab <schwab@issan.informatik.uni-dortmund.de>)
! 
! lib/readline/complete.c
! 	- fix to rl_menu_complete so it inserts a single completion properly
! 	  when a word matches only one filename
! 
! 				   9/24
! 				   ----
! execute_cmd.c
! 	- difftimeval should zero out the tv_usec field if the tv_sec field
! 	  is < 0
! 	- addtimeval should check for tv_usec being == 1000000 and add one
! 	  to tv_sec if it is
! 
! 				   9/25
! 				   ----
! subst.c
! 	- fix to expand_word_internal to prevent non-whitespace IFS characters
! 	  from causing word splitting if they are not the results of an
! 	  expansion (not exactly right yet, but I think it's the result of a
! 	  problem with the ${...} end-brace-matching code in the parser)
! 
! 				   9/28
! 				   ----
! parse.y
! 	- new flag for parse_matched_pair -- P_FIRSTCLOSE -- which makes it not
! 	  count and match additional construct open characters
! 	- change calls to parse_matched_pair when matching braces in
! 	  ${...} constructs (both unquoted and within double quotes) to
! 	  specify the P_FIRSTCLOSE flag to match POSIX.2 requirements
! 
! subst.c
! 	- changed fix from 9/25, now that the parser problem is fixed
! 
! 				   9/30
! 				   ----
! variables.c
! 	- change expansion of list of words between (...) in array assignments
! 	  to include pathname generation in assign_array_var_from_string
! 
! doc/{bash.1,bashref.texi}
! 	- clarified behavior of the shell at startup if running setuid, with
! 	  and without the -p option supplied
! 
! 				   10/7
! 				   ----
! bashhist.c
! 	- change default open(2) mode to 0600 instead of 0666 for `privacy
! 	  concerns'
! 
! 				   10/13
! 				   -----
! lib/readline/display.c
! 	- fixed a problem with displaying tabs after newlines, from
! 	  <qrczak@knm.org.pl>
! 	- in update_line, if we are printing over existing material,
! 	  only call space_to_eol or _rl_clear_to_eol if lendiff is non-zero
! 	- when moving the cursor in _rl_move_cursor_relative, only call
! 	  _rl_backspace if the current cursor position is strictly greater
! 	  than the desired cursor position
! 
! 				   10/14
! 				   -----
! locale.c
! 	- LC_ALL is no longer set automatically when LANG is assigned a value
! 
! config.h.{top,bot}
! 	- renamed to config-{top,bot}.h, respectively
! 
! config.h.in
! 	- include config-top.h and config-bot.h
! 
! Makefile.in
! 	- things now depend on config-top.h and config-bot.h
! 
! subst.c
! 	- minor changes to extract_dollar_brace_string and char_is_quoted to
! 	  allow things like "${PIP[TAB] to perform correct variable completion
! 
! 				   10/15
! 				   -----
! builtins/Makefile.in
! 	- add $(PROFILE_FLAGS) to the make recipe that creates `mkbuiltins',
! 	  so configuring with --enable-profiling works right
! 
! 				   10/20
! 				   -----
! doc/bashref.texi
! 	- documented the new --with-installed-readline option
! 
! [bash-2.03-alpha1 frozen]
! 
! 				   10/21
! 				   -----
! builtins/reserved.def
! 	- fixed help text for { ... } to make it clear that a semicolon is
! 	  required before the closing brace
! 
! 				   10/22
! 				   -----
! trap.c
! 	- in decode_signal, don't bother calling strcasecmp if
! 	  signal_names[sig] is null or empty
! 
! 				   11/2
! 				   ----
! configure.in
! 	- make sure RL_LIBDIR and HIST_LIBDIR are assigned values even if
! 	  readline or history is configured out of the shell, so the -L
! 	  options have arguments in the link command
! 
! test.c
! 	- make test_syntax_error cause test to return a status > 1, to
! 	  conform to POSIX.2 4.62.8
! 
! doc/readline.3
! 	- make sure the SYNOPSIS section indicates that programmers should
! 	  include <stdio.h> before <readline.h>
! 
! 				   11/9
! 				   ----
! Makefile.in
! 	- install with explicit mode of 0755
! 
! 				   11/10
! 				   -----
! builtins/test.def
! 	- make sure that a missing `]' makes `[' exit with status 2, to
! 	  conform to POSIX.2 4.62.8
! 
! command.h
! 	- new word flag: W_NOGLOB, meaning to not perform globbing
! 
! execute_cmd.c
! 	- fix_assignment_statements now turns on the W_NOGLOB flag for
! 	  arguments to `assignment builtins' that have W_ASSIGNMENT set
! 
! subst.c
! 	- expand_word_internal needs to preserve the W_NOGLOB flag from
! 	  the word being expanded to the word being returned
! 	- glob_expand_word_list does not call shell_glob_filename for a
! 	  word with W_NOGLOB set
! 
! builtins/shopt.def
! 	- print_shopt is now void
! 
! configure.in
! 	- machines running Rhapsody don't use the bash malloc
! 	- pass host_vendor to the Makefiles with AC_SUBST
! 
! support/config.guess
! 	- Rhapsody is really rhapsody, not nextstep
! 
! support/config.sub
! 	- add rhapsody to the list of supported configurations
! 
! Makefile.in
! 	- pass CONF_HOSTTYPE, CONF_OSTYPE, and CONF_MACHTYPE as -D options
! 	  in SYSTEM_FLAGS, to indicate that they came from the configuration
! 	  process
! 	- set VENDOR variable from host_vendor configuration variable
! 	- pass CONF_VENDOR as part of SYSTEM_FLAGS
! 
! variables.c
! 	- define HOSTTYPE, OSTYPE, and MACHTYPE as CONF_HOSTTYPE, CONF_OSTYPE,
! 	  and CONF_MACHTYPE, respectively
! 
! 				   11/11
! 				   -----
! doc/{bashref.texi,bash.1}
! 	- updated description of `read' to clarify the -r option and its
! 	  effect on backslash escaping
! 
! 				   11/13
! 				   -----
! examples/loadables/{ln,unlink}.c
! 	- new loadable builtins
! 
! 				   11/23
! 				   -----
! lib/glob/fnmatch.c
! 	- some fixes to handle extended glob patterns immediately following
! 	  a `*'
! 
! tests/extglob.tests
! 	- updated with cases from bug report fixed today
! 
! support/shobj-conf
! 	- udpated stanza for aix 4.2 with gcc, based on information from
! 	  jik@cisco.com
! 
! configure.in
! 	- changes to add the correct linker options to allow dynamic linking
! 	  when using gcc on AIX 4.2, instead of insisting on the AIX C
! 	  compiler
! 
! examples/misc/aliasconv.{bash,sh}
! 	- changes to handle aliases with embedded single quotes
! 
! 				   11/25
! 				   -----
! lib/readline/complete.c
! 	- postprocess_matches should call compute_lcd_of_matches with an
! 	  argument of `t' instead of `text'
! 	- postprocess_matches should never call ding(); leave that for the
! 	  callers
! 	- postprocess_matches no longer needs `text' as the first argument
! 	- rl_complete_internal needs to call ding() if postprocess_matches
! 	  returns 0, since postprocess_matches no longer does it
! 	- rl_complete_internal can now free `text' immediately after calling
! 	  gen_completion_matches, since it's no longer used
! 
! 				   11/30
! 				   -----
! print_cmd.c
! 	- make sure redirections following compound commands have a space
! 	  separating them from the command
! 
! 				   12/1
! 				   ----
! general.c
! 	- changed canonicalize_pathname so that if the result path begins
! 	  with `//', it will be changed to `/' if and only if the original
! 	  path did not begin with `//' (there has to be a non-slash after
! 	  the leading `///' in the original path)
! 
! 				   12/2
! 				   ----
! builtins/evalstring.c
! 	- augment the test for turning on CMD_NO_FORK to make sure that
! 	  parse_and_execute_level == 1.  That takes care of things like
! 
! 		bash -c 'for f in 1 2 3; do eval "/bin/echo \"$f\"" ; done'
! 
! 	  only printing one line of output
! 
! 				   12/8
! 				   ----
! config-top.h
! 	- add commented-out #define for NON_INTERACTIVE_LOGIN_SHELLS so
! 	  that users may, if they choose, make things like
! 
! 		#! /bin/bash --login
! 
! 	  work in shell scripts
! 
! 				   12/10
! 				   -----
! jobs.c
! 	- changes to the way jobs are reaped when the shell is not
! 	  interactive:
! 
! 		o notify_of_job_status no longer marks dead jobs as
! 		  notified if they did not exit due to a signal;
! 		o changed mark_background_jobs_as_notified to take an
! 		  argument `force':  if zero, we only mark enough
! 		  dead jobs as notified to keep CHILD_MAX jobs in the
! 		  jobs list, as POSIX.2 specifies.  If non-zero, mark
! 		  all dead jobs as notified;
! 		o wait_for_background_pids marks all dead jobs as
! 		  notified when it has finished waiting for everything,
! 		  since the only thing that calls it is the `wait' builtin;
! 		o wait_for_single_pid marks a job as notified after it
! 		  has completed, since the only things that call it are
! 		  wait_for_background_pids and the `wait' builtin
! 		o wait_for_job marks the job as notified after the last
! 		  pid completes
! 
! execute_cmd.c
! 	- change execute_subshell_builtin_or_function to check
! 	  subshell_environment and pipe_out to decide whether or not to fork
! 	  if builtin == jobs_builtin, since the early-forking code added in
! 	  bash-2.02 means that the piping has probably already been done
! 
! 				   12/15
! 				   -----
! parse.y
! 	- changes to make avar=((...)) a syntax error instead of ignoring
! 	  the nested parens and treating it as an array assignment
! 
! shell.c
! 	- changed run_startup_files so that any shell, whether or not it is
! 	  interactive, will run the login shell startup files when given the
! 	  --login option.  This happens only when not in posix mode.
! 
! builtins/enable.def
! 	- changes to handle Tenon's MachTen, whose dlclose() does not return
! 	  a value
! 
! lib/glob/fnmatch.c
! 	- changed gmatch so that when it calls extmatch, it removes FNM_PERIOD
! 	  from the flags if it's not matching at the start of the string.
! 	  This fixes the problem of `@' and `+' extended-glob subpatterns
! 	  containing bracket expressions treating `.' specially when matching
! 	  a portion of the string starting with `.'
! 
! config-top.h
! 	- removed define for NON_INTERACTIVE_LOGIN_SHELLS, since it's no longer
! 	  necessary
! 
! 				   12/17
! 				   -----
! lib/readline/complete.c
! 	- change rl_complete_internal and rl_menu_complete to check
! 	  rl_filename_completion_desired to decide whether or not we're
! 	  completing filenames instead of checking whether the attempted
! 	  completion function is filename_completion_function.
! 	  filename_completion_function sets rl_filename_completion_desired,
! 	  so this shouldn't break anything -- just allow postprocessing of
! 	  matches for user-supplied filename completion functions that don't
! 	  call filename_completion_function
! 
! lib/readline/display.c
! 	- new function, _rl_erase_entire_line, which erases the entire line,
! 	  no matter where the cursor is, and puts the cursor at the beginning
! 	  of the (newly-empty) line
! 
! lib/readline/readline.c
! 	- new application-level variable, rl_erase_empty_line, which, if
! 	  non-zero, tells readline to erase the contents of the current line,
! 	  prompt and all, if the only character typed to an otherwise-blank
! 	  line is bound to rl_newline.  Requested by the Cygnus GDB folks.
! 	- change to rl_newline to suppress the call to _rl_update_final if
! 	  rl_erase_empty_line is non-zero, and rl_point == rl_end == 0, since
! 	  _rl_update_final calls crlf()
! 	- change to readline_internal_charloop to call _rl_erase_entire_line
! 	  if newline was the only thing typed on an otherwise-empty line
! 
! lib/readline/readline.h
! 	- extern declaration for rl_erase_empty_line
! 
! lib/readline/doc/rltech.texinfo
! 	- documented new rl_erase_empty_line variable
! 
! 				   12/18
! 				   -----
! Makefile.in
! 	- changed RELSTATUS to `beta1'
! 
! [bash-2.03-beta1 frozen]
! 
! 				   12/21
! 				   -----
! doc/{bash.1,bashref.texi}
! 	- added description of `test -h'; equivalent to `test -L'
! 
! 				   12/22
! 				   -----
! support/shobj-conf
! 	- SHOBJ_LDFLAGS should be those options to ld which are common
! 	  between building dynamically loadable shared objects and shared
! 	  libraries
! 	- added two new variables: SHOBJ_XLDFLAGS, which are ld options
! 	  specific to building dynamically loaded shared objects, and
! 	  SHLIB_LIBS, which are other libraries against which shared libraries
! 	  should be linked.  These are for the benefit of AIX 4.2; other
! 	  stanzas do not need to be changed.
! 
! configure.in
! 	- add call to AC_SUBST for SHOBJ_XLDFLAGS
! 
! examples/loadables/Makefile.in
! 	- SHOBJ_XLDFLAGS is now substituted by configure
! 	- $(SHOBJ_LDFLAGS) -> $(SHOBJ_LDFLAGS) $(SHOBJ_XLDFLAGS) in all
! 	  recipes that build loadable builtins
! 
! 				   12/29
! 				   -----
! support/config.{guess,sub}
! 	- changes for NEC SX4 machines running SUPER-UX (?).  Info from
! 	  Nicholas Clark <nick@flirble.org>
! 
! lib/readline/bind.c
! 	- new bindable variable, `isearch-terminators', which is the list of
! 	  characters that will terminate an incremental search without
! 	  subsequently executing the character as a command
! 
! lib/readline/isearch.c
! 	- changes to incorporate the new isearch-terminators bindable variable;
! 	  uses new private readline variable _rl_isearch_terminators
! 	  (suggested by Brian Fox)
! 
! doc/{bash.1,readline.3}, lib/readline/doc/rluser.texinfo
! 	- documented new `isearch-terminators' settable variable
! 
! lib/readline/complete.c
! 	- new convenience function, free_match_list, called from
! 	  rl_complete_internal
! 
! 				   12/30
! 				   -----
! aclocal.m4
! 	- changed the calls to AC_MSG_ERROR in the cross-compiling sections
! 	  to AC_MSG_WARN, since AC_MSG_ERROR can cause configure to abort
! 
! examples/functions/which
! 	- new function, emulation of `which' as it appears in FreeBSD
! 
! 				   12/31
! 				   -----
! lib/readline/readline.c
! 	- new bindable function: rl_rubout_or_delete.  Does rl_rubout if
! 	  rl_point is at the end of the line, or rl_delete if not.  This
! 	  is intended to mimic the Motif/Netscape/GNOME behavior of the
! 	  DEL character, and can be bound to delete to get that behavior
! 
! lib/readline/readline.h
! 	- new extern declaration for rl_rubout_or_delete
! 
! lib/readline/funmap.c
! 	- bound the name `forward-backward-delete-char' to
! 	  rl_rubout_or_delete (currently not bound to any keys)
! 
! lib/readline/doc/manvers.texinfo
! 	- new file with readline manual version information, to mantain
! 	  consistent numbering between readline and history manuals
! 
! lib/readline/doc/{rlman,hist}.texinfo
! 	- @include manvers.texinfo for version information
! 	- moved the @dircategory and and @direntry directives inside
! 	  the @ifinfo block
! 	- changed copyrights to 1988-1999
! 
! doc/Makefile.in, lib/readline/doc/Makefile.in
! 	- texi2html is now called with -menu (to handle the texinfo menus)
! 	  and -monolithic (to include the table of contents in the generated
! 	  HTML file instead of putting it in a separate file
! 	- changed recipes to remove references to TOC html files
! 
! lib/glob/fnmatch.c
! 	- include <string.h> or <strings.h> as appropriate for strchr()
! 	  declaration
! 
! 				 1/4/1999
! 				 --------
! print_cmd.c
! 	- don't print bare words when printing conditional expressions in
! 	  print_cond_node, use cprintf("%s", cond->op->word)
! 
! subst.c
! 	- in separate_out_assignments, if VARLIST is non-null on function
! 	  entry, free it up to clean up after a previous error longjmp
! 
! 				    1/5
! 				    ---
! configure.in
! 	- make sure the case clause that disables the bash malloc on alpha
! 	  machines catches things like `alphaev56' as well as `alpha'
! 
! 				   1/12
! 				   ----
! lib/readline/histlib.h
! 	- new error message code: NO_PREV_SUBST
! 
! lib/readline/histexpand.c
! 	- handle NO_PREV_SUBST with appropriate error message in hist_error
! 	- in history_expand_internal, if the `s' or `&' case results in a
! 	  null or empty LHS, return NO_PREV_SUBST
! 
! error.c
! 	- new interface: command_error(func, code, e, flags); intended to
! 	  collect command-related errors in one place
! 	- new interface: command_errstr(code); returns a string describing
! 	  command error CODE
! 
! error.h
! 	- extern declarations for command_error and command_errstr
! 
! command.h
! 	- possible values for CODE in calls to command_error and command_errstr
! 
! {shell,print_cmd,make_cmd,execute_cmd,dispose_cmd,eval}.c ,builtins/evalstring.c
! 	- changed some calls to programming_error to use command_error
! 
! 				   1/13
! 				   ----
! configure.in
! 	- if --enable-profiling is specified on a solaris2 machine, don't
! 	  turn on enable-static-link, since it's very hard to build a
! 	  static binary on solaris2 and gprof does not (apparently) require it
! 
! builtins/getopts.def
! 	- add calls to sh_getopt_restore_state so the state is restored each
! 	  time getopts is called.  This protects us against the behavior of
! 	  some mallocs, which causes `nextchar' to be set to garbage in
! 	  getopt.c when a function is called between calls to getopts
! 
! 				   1/14
! 				   ----
! lib/readline/complete.c
! 	- if postprocess_matches returns 0 in rl_complete_internal, reset
! 	  completion_changed_buffer to 0 before returning, since nothing
! 	  has been changed
! 
! 				   1/20
! 				   ----
! subst.c
! 	- fixed pat_subst so that null patterns with a `#' specifier prefix
! 	  the string to be substituted on with the replacement, and null
! 	  patterns with a `%' specifier append the replacement to the string
! 	  to be substituted on
! 
! doc/{bash.1,bashref.texi}
! 	- corrected a small error in the description of parameter pattern
! 	  substitution
! 
! support/mksignames.c
! 	- SIGINFO means something else on sequent systems
! 
! 				   1/26
! 				   ----
! execute_cmd.c
! 	- fix to execute_simple_command to keep a child process from getting
! 	  a bad value of last_asynchronous_pid when the shell forks early
! 
! 				    2/1
! 				    ---
! Makefile.in
! 	- changed RELSTATUS to `beta2'
! 
! 				    2/2
! 				    ---
! [bash-2.03-beta2 released]
! 
! 				    2/3
! 				    ---
! tests/{cprint.{tests,right},run-cprint}
! 	- new test to exercise the command printing and copying code --
! 	  hopefully this will avoid things like the `conditional commands
! 	  in functions make the shell abort' problem
! 
! 				    2/4
! 				    ---
! version.c
! 	- if MACHTYPE is not defined, use CONF_MACHTYPE if it's defined
! 
! 				    2/5
! 				    ---
! builtins/read.def
! 	- if READLINE is defined, we need an extra pair of braces around
! 	  the `while' loop that reads from fd 0 if the -e option is
! 	  supplied, otherwise the code erroneously tests the value of
! 	  `retval', which is not set when using readline
! 
! 				   2/15
! 				   ----
! builtins/fc.def
! 	- make sure that fc closes `stream' before calling fc_execute_file
! 
! 				   2/17
! 				   ----
! builtins/fc.def
! 	- don't bother opening and closing the file of commands before
! 	  calling fc_execute_file, since parse_and_execute will write the
! 	  commands to the history file for us
! 
! Makefile.in
! 	- changed release status to `release'
! 
! 				   2/18
! 				   ----
! parse.y
! 	- change to special_case_tokens so that `time' is not recognized
! 	  as a reserved word while the parser is parsing a case statement
! 	  pattern list (if `time' is the first pattern, the last read
! 	  token will be newline, which time_command_acceptable says is OK
! 	  to start a pipeline)
! 
! pathexp.c
! 	- some changes to the POSIX_GLOB_LIBRARY code (often unused)
! 
! shell.c
! 	- a couple of changes for Interix (nee OPENNT)
! 	- added code that handles systems without a third argument to main();
! 	  initializing `env' from `environ', conditionalized on a cpp define
! 	  NO_MAIN_ENV_ARG
! 
! configure.in, config.h.in
! 	- check for the presence of sbrk(2); define HAVE_SBRK if found
! 
! xmalloc.c
! 	- don't do the space allocated computation when malloc or realloc
! 	  fails if HAVE_SBRK is not defined
! 
! configure.in
! 	- new configure variable, MAKE_SHELL, defaults to /bin/sh
! 
! Makefile.in,{builtins,doc,support,lib/{glob,malloc,readline,sh,termcap,tilde},examples/loadables}/Makefile.in
! 	- set SHELL from @MAKE_SHELL@
! 
! lib/posixheaders/posixjmp.h
! 	- Don't override defines for setjmp and longjmp in <setjmp.h> on
! 	  Internix (nee OPENNT)
! 
! lib/readline/complete.c
! 	- Interix (OPENNT) doesn't do username completion
! 
! configure.in
! 	- on Interix/OPENNT ($host_os == interix* or opennt*), add
! 	  -DNO_MAIN_ENV_ARG to LOCAL_CFLAGS
! 	- on Interix/OPENNT, set MAKE_SHELL to $OPENNT_ROOT/bin/sh rather
! 	  than a straight /bin/sh
! 
! cross-build/opennt.cache
! 	- a `configure' cache file for Interix/OPENNT; not necessarily
! 	  for cross-compiling, but this is where the other system cache
! 	  files are
! 
! [bash-2.03 released]
! 
! 				   2/19
! 				   ----
! configure.in
! 	- changed OPENNT_ROOT to INTERIX_ROOT for building on Interix
! 
! support/config.guess
! 	- added two stanzas for Interix running on alpha and intel hardware
! 
! 				   2/22
! 				   ----
! config-bot.h
! 	- if PROMPT_STRING_DECODE is not defined, #undef PPROMPT before
! 	  redefining it, to avoid warning messages
! 
! execute_cmd.c
! 	- set jobs_hack in execute_subshell_builtin_or_function only if
! 	  JOB_CONTROL is defined
! 
! 				   2/24
! 				   ----
! trap.c
! 	- fixed an obscure bug caused by a race condition in run_pending_traps.
! 	  Read the comments in the source code for a full description of the
! 	  problem and solution
! 
! 				    3/1
! 				    ---
! aclocal.m4
! 	- new test, BASH_STRUCT_TIMEVAL, which tries to compile a code
! 	  fragment that includes <sys/time.h> and <time.h> as appropriate
! 	  and defines HAVE_TIMEVAL if the compile succeeds
! 
! configure.in
! 	- call BASH_STRUCT_TIMEVAL rather than running a pair of
! 	  AC_HEADER_EGREPs on sys/time.h and time.h
! 
! lib/readline/histfile.c
! 	- include "posixstat.h" rather than <sys/stat.h>
! 	- in history_truncate_file, only try to truncate if the history file
! 	  is a regular file
! 
! 				    3/2
! 				    ---
! aclocal.m4
! 	- changed BASH_STRUCT_TIMEVAL back to using a pair of
! 	  AC_EGREP_HEADERs instead of compiling a program fragment
! 
! lib/readline/readline.c
! 	- readline_internal_charloop should cast the first argument to
! 	  _rl_dispatch to `unsigned char' to avoid problems with negative
! 	  array indices on systems where signed chars are the default
! 
! lib/readline/kill.c
! 	- instead of doing a sequence of next_history() calls in
! 	  rl_yank_nth_arg_internal, save and restore the history
! 	  position explicitly after finding the correct entry.  This
! 	  attempts to ensure that rl_yank_nth_arg leaves the history
! 	  pointer set to the same position as when it was called.
! 	  Fix from Vasco Pedro <vp@di.fct.unl.pt>
! 
! 				    3/5
! 				    ---
! redir.c
! 	- broke code that opens file for redirection in do_redirection_internal
! 	  into a separate function: redir_open(path, flags, mode, ri)
! 
! general.h
! 	- changed STREQN so that it evaluates to 1 (strings are equivalent)
! 	  if N == 0, to match the behavior of strncmp
! 
! lib/sh/zwrite.c
! 	- new file, zwrite() from builtins/evalstring.c
! 
! builtins/evalstring.c
! 	- removed private definition of zwrite
! 
! builtins/common.c
! 	- double_quote needs to protect newlines with backslashes as well
! 	- new function, un_double_quote, to remove backslashes proctecting
! 	  characters that are special in double quotes
! 
! builtins/common.h
! 	- new extern declaration for un_double_quote
! 
! parse.y
! 	- changed read_token_word to requote the expanded value of $'...'
! 	  using single_quote
! 	- added a new flag to parse_matched_pair: P_ALLOWESC.  It allows
! 	  backslashes to quote embedded single quotes, and is used by
! 	  the $'...' translation code for better ksh93-compatibility
! 	- changed localeexpand to call mk_msgstr on the string passed
! 	  before displaying it if all we're doing is displaying translatable
! 	  strings in `po' format.  mk_msgstr quotes backslashes and double
! 	  quotes in the string passed with backslashes, and encloses the
! 	  result in double quotes.  If only -D is supplied, the string is
! 	  not changed at all -- this is what ksh93 does
! 
! lib/readline/rlconf.h
! 	- removed PAREN_MATCHING #define, paren matching is always compiled
! 	  into readline
! 
! lib/readline/parens.c
! 	- removed code that was active if PAREN_MATCHING was not defined
! 	- added _rl_enable_paren_matching, which is called when the readline
! 	  variable `blink-matching-paren' is assigned a value and changes
! 	  the appropriate key bindings in emacs_standard_keymap
! 
! lib/readline/bind.c
! 	- no more PAREN_MATCHING defines, `blink-matching-paren' is always
! 	  available
! 	- if `blink-matching-paren' is assigned a value, call
! 	  _rl_enable_paren_matching (rl_blink_matching_paren)
! 
! lib/readline/emacs_keymap.c
! 	- removed PAREN_MATCHING defines; the default key bindings for
! 	  ), ], and } are self-insert
! 
! 				    3/7
! 				    ---
! stringlib.c
! 	- added an extra argument to ansicstr so that `echo -e' will not
! 	  convert \' to '
! 
! externs.h
! 	- changed extern declaration for ansicstr
! 
! parse.y, builtins/{echo,printf}.def
! 	- changed calls to ansicstr() appropriately
! 
! eval.c
! 	- in parse_string_to_word_list, if an unexpected token is encountered
! 	  that causes the string to not parse to a simple command, or to
! 	  completely consume the string, display an error message and jump
! 	  back to the top level after restoring the parsing environment,
! 	  returning an error status from the attempted assignment
! 
! 				    3/8
! 				    ---
! lib/glob/fnmatch.c
! 	- fixed patscan and extmatch to handle embedded [...](...) patterns
! 	  better
! 
! tests/{extglob2.{tests,right},run-extglob2}
! 	- an additional set of ksh extended globbing tests, cribbed from zsh
! 
! 				   3/10
! 				   ----
! general.c
! 	- changed unset_nodelay_mode slightly to make sure it handles both
! 	  O_NDELAY and O_NONBLOCK if they have different values; it now
! 	  returns a value of 0 on success (or no action); -1 on failure
! 
! general.h
! 	- changed extern declaration for unset_nodelay_mode
! 
! 
! lib/readline/shell.c
! 	- new function: unset_nodelay_mode; identical to definition in
! 	  general.c
! 
! lib/readline/input.c
! 	- changed rl_getc to call unset_nodelay_mode if the read fails with
! 	  errno == EWOULDBLOCK || errno == EAGAIN
! 
! 				   3/11
! 				   ----
! lib/termcap/termcap.c
! 	- minor changes from termutils-2.0
! 	- minor change to MS-DOS version of valid_filename_p so MS-DOS-specific
! 	  code from tgetent() can be removed (from Michel@smr.nl)
! 
! lib/readline/bind.c
! 	- in _rl_read_file, null-terminate the buffer at the number of
! 	  characters actually read, not what stat() says the file size is
! 	- use ~/_inputrc as a last-ditch inputrc filename on MS-DOS
! 
! lib/readline/complete.c
! 	- change printable_part to handle MS-DOS `drive-letter:' pathname
! 	  prefixes
! 	- removed __GO32__ code, since it's for DJGPP 1.x, which is not
! 	  supported any more, and they don't work for DJGPP 2.x
! 	- added code to support MS-DOS drive letter prefixes and //X/...
! 	  to filename_completion_function
! 	- _rl_completion_case_fold defaults to 1 on MS-DOS
! 
! lib/readline/{display,input,readline,rltty,signals,terminal}.c
! 	- removed __GO32__ code
! 
! lib/readline/histfile.c
! 	- make read_history_range and history_truncate_file work with the
! 	  actual number of characters read from the file, not the file size
! 	  as reported by stat()
! 
! lib/readline/readline.c
! 	- change bind_arrow_keys_internal to bind MS-DOS arrow keys to the
! 	  appropriate functions if __MSDOS__ is defined
! 
! lib/readline/rltty.c
! 	- make sure set_winsize is always defined, with a null body if
! 	  TIOCGWINSZ is not defined
! 
! lib/readline/shell.c
! 	- include <stdio.h>, since this file uses sprintf
! 
! support/shobj-conf
! 	- MS-DOS does not support shared objects
! 
! lib/tilde/tilde.c
! 	- change tilde_find_suffix and isolate_tilde_prefix to understand
! 	  backslash as a pathname separator on MS-DOS
! 
! 				   3/12
! 				   ----
! lib/readline/{bind,readline,terminal}.c
! 	- no longer need to include <signal.h>
! 
! lib/readline/terminal.c
! 	- don't need to include <setjmp.h>
! 
! builtins/history.def
! 	- broke the code than handles deleting a particular history entry
! 	  from the history list out into a separate function: delete_histent
! 	- added `-d offset' option to delete the history entry at position
! 	  OFFSET, as displayed when the history is listed
! 
! jobs.c, nojobs.c
! 	- new function, count_all_jobs(), returns the number of active jobs
! 	  in the jobs list
! 
! jobs.h
! 	- extern declaration for count_all_jobs()
! 
! configure.in
! 	- check for C library function ttyname()
! 
! config.h.in
! 	- define HAVE_TTYNAME if configure finds ttyname(3)
! 
! parse.y
! 	- two new escape sequences for decode_prompt_string:
! 
! 		\j	number of active jobs in jobs list
! 		\l	basename of shell's tty device name
! 
! doc/{bash.1,bashref.texi}, lib/readline/doc/hsuser.texi
! 	- documented new `history -d' option
! 	- documented new \j and \l prompt string expansion sequences
! 
! lib/readline/bind.c
! 	- new static state variable, currently_reading_init_file, set to
! 	  1 while _rl_read_init_file is operating on a file
! 	- changed _rl_init_file_error to include the name and line number
! 	  from the init file only if currently_reading_init_file is non-zero
! 	  (this is needed since applications like bash can call
! 	  rl_parse_and_bind, and error messages from those calls would be
! 	  misleading if they referred to the last inputrc file read
! 
! bashline.c
! 	- support for a `extended command keymap', which will allow
! 	  readline key sequences to be bound to unix commands using an
! 	  auxiliary keymap and a special function that knows how to execute
! 	  commands from it
! 	- bind_keyseq_to_unix_command supports `bind -x'
! 	- bash_execute_unix_command is the readline callback that looks in
! 	  an auxiliary keymap to find the shell command to execute for a
! 	  particular key sequence
! 	- new variable, no_empty_command_completion, which suppresses $PATH
! 	  searching for command completion when TAB is typed on an empty
! 	  line
! 
! bashline.h
! 	- extern declaration for new function bind_keyseq_to_unix_command
! 
! builtins/bind.def
! 	- added `-x' option to bind a key sequence to a shell command
! 
! builtins/help.def
! 	- added `-s' option to just print a builtin's short_doc
! 
! builtins/shopt.def
! 	- added new shell option, no_empty_cmd_completion', mirroring value
! 	  of no_empty_command_completion
! 
! doc/{bash.1,bashref.texi}
! 	- documented new `bind -x' option
! 	- documented new shopt `no_empty_cmd_completion' option
! 	- documented new `help -s' option
! 
! Makefile.in
! 	- changed RELSTATUS to `devel'
! 
! _distribution
! 	- changed to `2.04'
! 
! 				   3/15
! 				   ----
! support/shobj-conf
! 	- add `-h $@' to linking options on Solaris 2 with gcc
! 
! expr.c
! 	- changes to add {pre,post}-{inc,dec}rement operators (++id, --id,
! 	  id++, id--).  These are somewhat more liberal than ksh93, and
! 	  may require more strict syntax checking down the line
! 
! tests/arith.{tests,right}
! 	- additional tests for {pre,post}-{inc,dec}rement operators
! 
! 				   3/16
! 				   ----
! command.h
! 	- structures and types for ksh-93-style arithmetic `for' command
! 
! configure.in
! 	- new `--enable-arith-for-command' option to compile arithmetic for
! 	  command code into the shell
! 
! config.h.in
! 	- new define, ARITH_FOR_COMMAND, turned on by configure
! 
! parse.y
! 	- changed read_token_word to parse a set of arithmetic for expressions
! 	  between (( and )) as long as the last token read before the `(('
! 	  was FOR
! 	- added grammar rules to build arithmetic for commands
! 
! make_cmd.c
! 	- functions to parse (( ... )) into the three sub-expressions needed
! 	  for the arithmetic for command and create the command structures
! 	  (done this way instead of in the grammar rules to avoid forcing
! 	  users to quote special characters between the (( and )) )
! 
! make_cmd.h
! 	- extern declaration for make_arith_for_command
! 
! copy_cmd.c
! 	- code to copy arithmetic for commands
! 
! dispose_cmd.c
! 	- code to dispose of arithmetic for commands
! 
! print_cmd.c
! 	- code to print arithmetic for commands
! 
! execute_cmd.c
! 	- code to execute arithmetic for commands and note that they are
! 	  shell control structures for the piping code
! 
! doc/{bash.1,bashref.texi}
! 	 - documented new arithmetic for command
! 
! doc/bashref.texi
! 	- documented new configure --enable-arith-for-command option
! 
! 				   3/17
! 				   ----
! builtins/read.def
! 	- added `-t timeout' option and code to support it
! 
! 				   3/18
! 				   ----
! examples/loadables/Makefile.in
! 	- various clean targets need to descend into perl
! 
! examples/loadables/perl/Makefile.in
! 	- added mostlyclean and maintainer-clean targets
! 
! include
! 	- new directory, with files from lib/posixheaders
! 
! lib/posixheaders
! 	- removed
! 
! {posixwait,unionwait,maxpath}.h
! 	- moved from top src directory to include subdir
! 
! Makefile.in,builtins/Makefile.in,lib/{glob,malloc,sh,tilde}/Makefile.in
! 	- updated dependencies and file lists for new include directory
! 	- added BASHINCDIR variable, added -I${BASHINCDIR} to cc's include path
! 
! MANIFEST,support/SYMLINKS
! 	- updated for new include directory
! 
! lib/readline/{ansi_stdlib,posixdir,posixjmp,posixstat,rlstdc}.h
! 	- changed symlinks to point to ../../include rather than
! 	  ../posixheaders
! 
! builtins/common.h
! 	- changed `#include "../stdc.h"' to `#include "stdc.h"'
! 
! builtins/{cd,exec,fc,history,pushd,source,type,umask,printf}.def
! builtins/{mkbuiltins,common,evalfile,evalstring,getopt}.c
! 	- changed include specifications:
! 		../posixstat.h -> posixstat.h
! 		../filecntl.h -> filecntl.h
! 		../maxpath.h -> maxpath.h
! 		../memalloc.h -> memalloc.h
! 
! include/shtty.h
! 	- new file, contents of bashtty.h and code from jobs.c that includes
! 	  the appropriate terminal file
! 
! lib/sh/shtty.c
! 	- new file with some tty manipulation utility functions
! 
! bashtty.h
! 	- removed
! 
! jobs.c, nojobs.c
! 	- include shtty.h instead of bashty.h and other code that includes
! 	  the correct system-dependent tty include file
! 
! lib/sh/Makefile.in
! 	- added shtty.o as part of libsh.a
! 
! MANIFEST
! 	- added include/shtty.h and lib/sh/shtty.c, removed bashtty.h
! 
! 				   3/19
! 				   ----
! lib/readline/display.c
! 	- some more __MSDOS__ code to make readline work better with DJGPP:
! 		output \r instead of tputs(term_cr, ...)
! 
! lib/readline/terminal.c
! 	- some changes for __DJGPP__ (one is of dubious value -- doesn't
! 	  DJGPP have a termcap library?)
! 
! 				   3/23
! 				   ----
! configure.in
! 	- make sure that the $CC argument to shobj-conf is quoted
! 
! support/shobj-conf
! 	- changes to SGI SHOBJ_LDFLAGS from David Kaelbling <drk@sgi.com>
! 
! 				   3/24
! 				   ----
! lib/sh/zread.c
! 	- interface to read(2) that restarts automatically if errno == EINTR
! 
! externs.h
! 	- new declarations for functions in lib/sh/{zread,zwrite}.c
! 
! lib/sh/Makefile.in, Makefile.in
! 	- add zread.c, zread.o to appropriate file lists
! 
! {subst,input}.c, builtins/{evalstring.c,read.def}
! 	- converted some loops around read() to call zread() instead
! 
! lib/readline/rltty.h
! 	- new struct _rl_tty_chars to save tty special characters
! 
! lib/readline/rltty.c
! 	- new function save_tty_chars to save tty special characters
! 	  (currently they're only saved -- nothing looks at them yet)
! 	- two new internal library functions, _rl_disable_tty_signals ()
! 	  and _rl_restore_tty_signals (), intended to disable tty driver
! 	  signal processing for readline's literal-next code, so users
! 	  can do stuff like ^V^C and have ^C end up in the readline
! 	  buffer even if ^C is the terminal's interrupt character
! 
! lib/readline/readline.c
! 	- changed rl_quoted_insert to disable and restore tty signal
! 	  handling around the call to rl_read_key (), so users can put
! 	  tty special chars into the readline buffer
! 
! 				   3/25
! 				   ----
! expr.c
! 	- added `,' operator (expr1 , expr2) -- both expr1 and expr2 are
! 	  evaluated and the return value is the value of expr2.  Precedence
! 	  is higher than assignment (which makes it highest)
! 	- make `lasttp' (pointer to last token) part of the expression
! 	  context that is saved and restored by {push,pop}_context.  This
! 	  is used only in error reporting
! 
! doc/{bash.1,bashref.texi}
! 	- documented new `,' arithmetic operator
! 	- cleaned up some of the language concerning variables referenced
! 	  by name within an arithmetic expression
! 
! lib/readline/readline.c
! 	- new application-settable variable, rl_num_chars_to_read, which, if
! 	  set to a non-zero value, causes readline to return after reading
! 	  that many characters (or at least that many characters, if
! 	  rl_startup_hook is used to prime the input buffer) rather than
! 	  when reading a character bound to accept-line
! 
! lib/readline/readline.h
! 	- extern declaration for rl_num_chars_to_read
! 
! builtins/read.def
! 	- added new `-n nchars' option to read NCHARS from stdin rather than
! 	  a complete line.  Works both with and without using readline
! 
! doc/{bash.1,builtins.texi}
! 	- documented new `read -n nchars' option
! 
! 				   3/26
! 				   ----
! execute_cmd.c
! 	- make sure all uses of PIDs are of type pid_t
! 
! redir.c
! 	- broke stdin_redirects into two functions: stdin_redirection, which
! 	  checks a single redirection specification, and a new stdin_redirects,
! 	  which does what it did before but calls stdin_redirection for each
! 	  redirection in the chain
! 
! 				   3/29
! 				   ----
! aclocal.m4
! 	- new test, BASH_CHECK_DEV_STDIN, checks for /dev/stdin.  If it's
! 	  present HAVE_DEV_STDIN is defined and it's assumed that /dev/stdout
! 	  and /dev/stderr are present as well
! 
! configure.in
! 	- call BASH_CHECK_DEV_STDIN
! 
! config.h.in
! 	- add HAVE_DEV_STDIN, initially undefined
! 
! test.c
! 	- add /dev/std{in,out,err} to the special filenames that are handled
! 	  by test_stat() if HAVE_DEV_STDIN is not defined
! 
! doc/{bash.1,bashref.texi}
! 	- documented conditional expressions' handling of /dev/std{in,out,err}
! 
! stringlib.c
! 	- new function, find_string_in_alist, to find (or match as an extended
! 	  glob pattern) a string in a STRING_INT_ALIST and return the
! 	  associated token value
! 
! externs.h
! 	- extern declaration for find_string_in_alist
! 
! redir.c
! 	- new STRING_INT_ALIST list of filenames the redirection code handles
! 	  specially (_redir_special_filenames)
! 	- new function, redir_special_open () to handle filenames found in
! 	  _redir_special_filenames (framework for /dev/tcp and /dev/udp, but
! 	  those are not implemented get)
! 
! doc/{bash.1,bashref.texi}
! 	- documented special filename handling in redirections
! 
! 				   3/30
! 				   ----
! builtins/read.def
! 	- added `-d delim' option, like ksh93, to read until delim rather
! 	  than newline
! 
! doc/{bash.1,bashref.texi}
! 	- documented new read `-d delim' option
! 
! configure.in
! 	- look for gethostbyname(3), inet_aton(3)
! 	- look for <netdb.h> and <netinet/in.h>
! 	- call BASH_FUNC_GETHOSTBYNAME if gethostbyname(3) is not in libc
! 	- check for u_int and u_long types, default to `unsigned int' and
! 	  `unsigned long' respectively
! 	- new enable option `--enable-net-redirections' to compile in the
! 	  /dev/tcp and /dev/udp redirection code
! 
! aclocal.m4
! 	- new macro, BASH_FUNC_GETHOSTBYNAME, looks for gethostbyname(3) in
! 	  the socket libraries if it's not found in libc
! 
! config.h.in
! 	- new defines: HAVE_GETHOSTBYNAME, HAVE_INET_ATON, HAVE_NETDB_H,
! 	  HAVE_NETINET_IN_H, NETWORK_REDIRECTIONS
! 	- new defines: u_int, u_long
! 
! lib/sh/inet_aton.c
! 	- new file, from GNU libc, slightly modified to remove inet_addr()
! 
! lib/sh/netopen.c
! 	- new file, functions to create tcp/udp network connections.  Exports
! 	  a single function: netopen(pathname)
! 
! externs.h
! 	- extern declaration for netopen()
! 
! lib/sh/Makefile.in, Makefile.in, MANIFEST
! 	- added appropriate references to inet_aton.c and netopen.c
! 
! config-bot.h
! 	- if HAVE_SYS_SOCKET_H, HAVE_GETPEERNAME, and HAVE_NETINET_IN_H are
! 	  all defined, define HAVE_NETWORK
! 
! redir.c
! 	- call netopen for pathnames of the form /dev/(tcp|udp)/host/port
! 	  if HAVE_NETWORK is defined; print a warning message otherwise
! 	- /dev/tcp and /dev/udp code is only compiled in if
! 	  NETWORK_REDIRECTIONS is defined
! 
! 				   3/31
! 				   ----
! lib/sh/zread.c
! 	- new function, zsyncfd(fd) which syncs the kernel's seek pointer on
! 	  FD with the last character returned by zreadc()
! 
! externs.h
! 	- extern declaration for zsyncfd
! 
! builtins/read.def
! 	- use zreadc if the input is not unbuffered (this cuts the number
! 	  of read(2) calls *way* down)
! 	- if input is not unbuffered, call zsyncfd before returning to make
! 	  sure zreadc's buffering doesn't consume too much input
! 
! 				    4/1
! 				    ---
! Makefile.in
! 	- install bashbug with mode 555
! 
! 				    4/2
! 				    ---
! shell.c
! 	- make want_pending_command and read_from_stdin global rather than
! 	  local variables
! 
! flags.c
! 	- change which_set_flags to insert `c' and `s' if the `-c' and `-s'
! 	  invocation options, respectively, were supplied at shell startup
! 
! bashline.c
! 	- change bash_directory_completion_hook to change the logic for
! 	  deciding whether or not to parameter expand the directory name --
! 	  now we expand only if there's a `$' (still has problems if the
! 	  user quoted the `$') or a `` pair.  Fixes bug reported by
! 	  chuckjr@sinclair.net.  To fix the `$' problem, could possibly
! 	  check what the user typed with rl_line_buffer and start, end
! 	  parameters to gen_completion_matches
! 	- changed attempt_shell_completion to slightly adjust the logic for
! 	  deciding whether or not a word is in a command position:  if the
! 	  word being completed has a single opening single or double quote
! 	  before the command separator, treat it as a candidate for (quoted)
! 	  command word completion
! 	- now that we understand partially-quoted strings as completion
! 	  candidates, we can do command completion on certain unclosed
! 	  uses of $(...
! 
! subst.c
! 	- change extract_delimited_string to not return an error for an
! 	  unclosed construct if DOING_COMPLETION is non-zero
! 
! 				    4/5
! 				    ---
! expr.c
! 	- fixed `ss=09 ; let ss=10' bug by introducing one-token lookahead
! 	  after a string token is parsed.  If the next token is `=', we
! 	  don't evaluate the variable's value as an expression, since it's
! 	  not going to be used
! 
! variables.h
! 	- added new member to struct variable: exportstr -- for the future
! 	  caching of strings to be placed into the environment
! 	- extern declaration for bind_variable_value
! 
! variables.c
! 	- make sure that the `exportstr' member of a struct variable is
! 	  initialized correctly, and put code in to free it where appropriate
! 	  (if non-null)
! 	- new function, bind_variable_value(VAR, VALUE); make shell variable
! 	  VAR have value VALUE
! 	- make sure var->exportstr is invalidated when a variable or function
! 	  is assigned a value
! 
! builtins/declare.def
! 	- call bind_variable_value instead of duplicating some of bind_variable
! 	  inline
! 
! 				    4/6
! 				    ---
! variables.h
! 	- new macros, VSETATTR and VUNSETATTR to set and clear variable
! 	  attributes
! 
! builtins{read,set,setattr,declare}.def,{execute_cmd,expr,shell,subst,variables}.c
! 	- change to use VSETATTR and VUNSETATTR
! 
! 				    4/7
! 				    ---
! doc/Makefile.in
! 	- if htmldir is set by configure, install the html files into that
! 	  directory with `make install' and remove them with `make uninstall'
! 
! Makefile.in,doc/Makefile.in
! 	- htmldir is set by configure and passed from the Makefile to the
! 	  install in the doc subdirectory
! 
! configure.in
! 	- substitute `htmldir' into Makefiles
! 
! support/config.guess
! 	- some small changes for Apple's Rhapsody
! 
! lib/termcap/Makefile.in
! 	- make the `distclean' and `maintainer-clean' targets remove Makefile
! 
! lib/termcap/ltcap.h
! 	- new private library include file, for Rhapsody __private_extern__
! 	  define
! 
! lib/termcap/{termcap,tparam}.c
! 	- include "ltcap.h"
! 	- if HAVE_CONFIG_H is defined, include <stdlib.h> if HAVE_STDLIB_H is
! 	  defined, otherwise declare getenv, malloc, realloc as extern
! 	- add __private_extern__ qualifier for extern data that Rhapsody
! 	  requires
! 
! shell.c
! 	- don't run the startup files in the rshd case if shell_level is >= 2
! 	  This should catch the case of
! 		rsh machine bash -c 'echo a'
! 	  running the .bashrc twice, once for the shell started by rshd and
! 	  one for the shell running -c command
! 
! 				    4/8
! 				    ---
! variables.c
! 	- in initialize_shell_variables, unset the export attribute from
! 	  SSH_CLIENT if it exists and we got it from the initial environment
! 
! shell.c
! 	- don't bother unsetting export attribute from SSH_CLIENT, since we
! 	  now do it in initialize_shell_variables
! 
! lib/readline/display.c
! 	- don't check prompt_this_line[-2] in rl_redisplay if prompt_this_line
! 	  isn't at least 2 characters after the start of rl_display_prompt
! 
! lib/readline/histfile.c
! 	- change the name of the default history file to _history on MS-DOS
! 
! lib/readline/histlib.h
! 	- add an extern declaration for history_offset
! 
! lib/readline/hist{expand,search}.c
! 	- remove extern declaration for history_offset; now in histlib.h
! 
! lib/readline/xmalloc.h
! 	- new file, extern declarations for xmalloc, xrealloc, xfree
! 
! lib/readline/rlprivate.h
! 	- new file, with extern declarations for `readline private' global
! 	  variables and functions
! 
! lib/readline/rlshell.h
! 	- new file, with extern function declarations for stuff in shell.c
! 
! lib/readline/Makefile.in
! 	- add dependencies on xmalloc.h, rlshell.h
! 	- add xmalloc.h, rlprivate.h to list of header files
! 
! MANIFEST
! 	- add lib/readline/xmalloc.h, lib/readline/rlprivate.h,
! 	  lib/readline/rlshell.h
! 
! Makefile.in
! 	- add $(RL_LIBSRC)/xmalloc, $(RL_LIBSRC)/rlprivate.h,
! 	  $(RL_LIBSRC)/rlshell.h to READLINE_SOURCE variable
! 
! lib/readline/{bind,complete,display,funmap,histexpand,histfile,history,input,
! isearch,keymaps,kill,macro,readline,search,shell,util,vi_mode}.c
! 	- include "xmalloc.h" rather than extern declarations for xmalloc,
! 	  xrealloc, xfree
! 
! lib/readline/terminal.c
! 	- new function, used in two places, _emx_get_screensize for EMX
! 
! lib/readline/readline.c
! 	- EMX apparently no longer needs _emx_build_environ
! 
! lib/readline/signals.c
! 	- support for __EMX__ in rl_signal_handler
! 	- don't set the old handler passed to rl_set_sighandler to
! 	  rl_signal_handler, because that would cause infinite recursion if
! 	  that signal were generated
! 
! lib/readline/xmalloc.c
! 	- no longer the same as lib/malloc/xmalloc.c, which is no longer
! 	  used by anyone
! 	- changes to include xmalloc.h, define READLINE_LIBRARY, change
! 	  some of the argument types
! 
! lib/tilde/tilde.c
! 	- add prototypes for extern function declarations if __STDC__
! 	  defined
! 
! lib/readline/{terminal,bind,readline,nls,histexpand}.c
! 	- include "rlshell.h" for function prototypes
! 
! 				    4/9
! 				    ---
! lib/readline/{bind,callback,complete,display,input,isearch,kill,macro,nls,
! parens,readline,rltty,search,signals,terminal,util,vi_mode}.c
! 	- include "rlprivate.h"
! 	- remove extern declarations already in rlprivate.h
! 
! xmalloc.c
! 	- xfree should take a PTR_T as its argument
! 
! general.h
! 	- change prototype for xfree to use void * instead of char *
! 
! lib/malloc/malloc.c
! 	- define PTR_T like it is defined in general.h
! 	- malloc() returns a PTR_T
! 	- free() takes a PTR_T as its argument
! 	- realloc() returns a PTR_T and takes a PTR_T as its first argument
! 	- memalign returns a PTR_T
! 	- valloc returns a PTR_T
! 	- calloc returns a PTR_T
! 	- cfree() takes a PTR_T
! 
! variables.c
! 	- new function: char **all_variables_matching_prefix (char *prefix)
! 
! variables.h
! 	- extern declaration for all_variables_matching_prefix
! 
! bashline.c
! 	- converted variable_completion_function to use
! 	  all_variables_matching_prefix
! 
! stringlib.c
! 	- new function, char **alloc_array(n), allocates an argv-style
! 	  array of strings with room for N members
! 
! externs.h
! 	- extern declaration for alloc_array
! 
! 				   4/13
! 				   ----
! lib/readline/keymaps.c
! 	- include "readline.h"
! 	- remove extern function declarations
! 
! include/stdc.h
! 	- break the definition of __P out from a strict __STDC__ block,
! 	  since __GNUC__ and __cplusplus also indicate that prototypes
! 	  are available
! 
! lib/readline/readline.h
! 	- adjust conditional declaration of rl_message, since __cplusplus
! 	  indicates that prototypes are available
! 
! lib/readline/rlstdc.h
! 	- private copy, modified, no longer symlinked to ../../include/stdc.h
! 	- __P is defined if __GNUC__ or __cplusplus is defined
! 	- removed defines for __STRING, const, inline, signed, volatile, since
! 	  readline does not use them
! 
! lib/readline/{search,readline}.c
! 	- extern declaration for _rl_free_history_entry with prototypes,
! 	  since it's not in rlprivate.h
! 
! lib/readline/history.h
! 	- added some missing `extern's in function declarations
! 
! lib/readline/undo.c
! 	- include "rlprivate.h"
! 
! lib/readline/shell.c
! 	- include "rlshell.h"
! 
! lib/readline/Makefile.in
! 	- update dependencies for undo.c, shell.c
! 
! lib/tilde/tilde.h
! 	- add #define for __P if not already defined
! 	- use prototypes in extern function declarations with __P()
! 
! lib/readline/doc/rluserman.texinfo
! 	- new file, derived from rlman.texinfo
! 
! {bashline,findcmd,general,pathexp}.c, builtins/getopts.def
! 	- call alloc_array(N) instead of (char **)xmalloc (N * sizeof (char *))
! 
! subst.c
! 	- added code to implement ksh-93 ${!prefix*} expansion
! 
! doc/{bash.1,bashref.texi}
! 	- documented new ${!prefix*} expansion
! 
! 				   4/15
! 				   ----
! execute_cmd.c
! 	- new variable, this_shell_function, points to SHELL_VAR of currently
! 	  executing shell function
! 
! variables.c
! 	- new dynamic variable, FUNCNAME -- invisible when not executing shell
! 	  function
! 
! doc/{bash.1,bashref.texi}
! 	- documented new FUNCNAME variable
! 
! 				   4/16
! 				   ----
! support/rlvers.sh
! 	- add -T option to specify correct termcap library
! 
! configure.in
! 	- Irix 4.x still needs to link with -lsun if it contains a replacement
! 	  getpwent function that works with NIS
! 	- if we're configuring with an already-installed readline library,
! 	  call BASH_CHECK_LIB_TERMCAP and pass the resulting $TERMCAP_LIB to
! 	  support/rlvers.sh
! 
! lib/readline/readline.c
! 	- in rl_forward, if rl_point ends up being < 0, set it to 0
! 
! lib/readline/exammples/excallback.c
! 	- new callback example code, from `Jeff Solomon <jsolomon@stanford.edu>'
! 
! lib/sh/getcwd.c
! 	- define NULL as 0 if not defined by one of the standard include files
! 	- cast result of malloc and realloc to (char *) where appropriate
! 
! variables.c
! 	- new functions for use by dynamic variables: null_assign and
! 	  null_array_assign.  Used as assign_func for a particular variable,
! 	  they cause assignments to that variable to be silently ignored
! 	- FUNCNAME and GROUPS are no longer readonly
! 	- FUNCNAME changed to use null_assign
! 	- GROUPS changed to use null_array_assign.  This means that the
! 	  variable can be unset if desired (like for Oracle startup scripts),
! 	  but cannot be assigned to
! 
! doc/{bash.1,bashref.texi}
! 	- added text about assignments being silently discarded to descriptions
! 	  of FUNCNAME and GROUPS
! 	- removed text saying that GROUPS is readonly
! 	- added standard text about GROUPS being unset and losing its special
! 	  properties, even if reset
! 
! command.h
! 	- new command type, cm_subshell, actually causes the shell to fork
! 	  and then executes the command in the SUBSHELL_COM struct
! 
! parse.y
! 	- ( ... ) now creates a command of type cm_subshell, with the same
! 	  flag CMD_WANT_SUBSHELL as previous
! 
! make_cmd.c
! 	- new function make_subshell_command
! 
! make_cmd.h
! 	- extern declaration for make_subshell_command
! 
! dispose_cmd.c
! 	- code to destroy a SUBSHELL_COM
! 
! copy_cmd.c
! 	- code to duplicate a SUBSHELL_COM
! 
! print_cmd.c
! 	- code to print a SUBSHELL_COM
! 
! execute_cmd.c
! 	- broke the code that handles executing commands in subshells out of
! 	  execute_command_internal into a new function, execute_in_subshell,
! 	  with the same arguments
! 	- executing a command of type cm_subshell is just a slightly special
! 	  case, handled in execute_in_subshell
! 
! 				   4/18
! 				   ----
! execute_cmd.c
! 	- changed code in execute_command_internal that executes subshell
! 	  commands to check for command->type == cm_subshell in addition to
! 	  checking that commmand->flags & CMD_WANT_SUBSHELL is non-zero
! 	- changed execute_in_subshell to set the CMD_NO_FORK flag on the
! 	  command to be executed by a command of type cm_subshell
! 	  (command->value.Subshell->command), if that command is a simple
! 	  command (type == cm_simple) or a nested subshell (type == cm_subshell)
! 	  and is not being timed
! 	- changed execute_command_internal to just call and return the value
! 	  returned by execute_in_subshell if it gets a command of type
! 	  cm_subshell with flags including CMD_NO_FORK
! 
! lib/malloc/malloc.c
! 	- morecore() should always return through morecore_done, not with a
! 	  simple `return'
! 
! 				   4/20
! 				   ----
! variables.c
! 	- new function, quote_array_assignment_chars, backslash quotes all
! 	  `[' and `]' before an `=' in a word that's part of the body of a
! 	  compound array assignment.  Needed because we run the list through
! 	  the globbing code now.  Don't bother if `=' does not appear in
! 	  the string or if the first char is not `['
! 	- call quote_array_assignment_chars from assign_array_var_from_string
! 	  now
! 
! eval.c
! 	- moved parse_string_to_word_list to parse.y
! 
! parse.y
! 	- moved parse_string_to_word_list here.  Much simpler -- no longer
! 	  tries to parse a command, but just reads tokens using read_token().
! 	  Any token but a WORD or ASSIGNMENT_WORD causes a syntax error.
! 	  Don't have to mess around with saving global_command or calling
! 	  parse_command, but do need to save and restore the history stuff,
! 	  so the array assignment doesn't get saved on the history list
! 
! 				   4/21
! 				   ----
! nojobs.c
! 	- changed to use functions in lib/sh/shtty.c (tt{get,set}attr) for
! 	  the terminal attributes
! 	- added a `flags' field to struct proc_status, flags are PROC_RUNNING
! 	  and PROC_NOTIFIED (status has been returned to `wait')
! 	- functions check flags & PROC_RUNNING to check whether or not a
! 	  particular process is still alive; PROC_RUNNING is reset by
! 	  set_pid_status
! 	- new function, mark_dead_jobs_as_notified, same function as the one
! 	  in jobs.c
! 	- cleanup_dead_jobs reaps jobs only if they're dead and not marked
! 	  as notified
! 	- wait_for_background pids marks all pids as notified and reaps them
! 	  before it returns, since it's called by the `wait' builtin
! 	- wait_for_single_pid marks the pid being waited for as notified so
! 	  its slot can be reclaimed -- it's only called by the `wait' builtin
! 	- new function, process_exit_status, to turn what wait(2) takes into
! 	  an exit status
! 
! 				   4/22
! 				   ----
! nojobs.c
! 	- add_pid takes a new second argument, async_p, which is non-zero if
! 	  the process is in the background
! 	- new flag, PROC_ASYNC, set by add_pid
! 	- set_pid_status now sets the PROC_NOTIFIED flag if PROC_ASYNC is unset,
! 	  so foreground jobs get cleaned up right away
! 	- changed mark_dead_jobs_as_notified to take a `force' argument; if
! 	  non-zero, it marks only enough dead jobs to make the number of
! 	  un-notified dead jobs < CHILD_MAX
! 	- new function, reap_dead_jobs, same as in jobs.c
! 
! execute_cmd.c
! 	- don't need separate cases for REAP any more
! 
! 				   4/23
! 				   ----
! builtins/printf.def
! 	- new function, tescape, which processes a single backslash
! 	  escape sequence and returns the number of characters consumed by
! 	  the argument string (code taken from bexpand)
! 	- changed bexpand to call tescape rather than do backslash-escape
! 	  sequence conversion itself
! 	- changed occurrences of `illegal' in error messages to `invalid'
! 	- printf no longer calls ansicstr to translate backslash-escape
! 	  sequences; the mainline printf code now calls tescape whenever it
! 	  hits a backslash
! 
! 				   4/26
! 				   ----
! subst.c
! 	- new variable, garglist, set to list of words to be expanded after
! 	  leading assignment statements are removed
! 	- command_substitute now calls maybe_make_exported_env before making
! 	  the child process if there are no variable assignments preceding
! 	  the command currently being expanded, or if the command currently
! 	  being expanded consists only of variable assignments
! 
! execute_cmd.c
! 	- the `early fork' code in execute_simple_command now calls
! 	  maybe_make_export_env before forking because execute_disk_command
! 	  would do that in the vast majority of cases, and this will obviate
! 	  the need to do it for subsequent commands if the environment does
! 	  not change
! 
! 				   4/27
! 				   ----
! variables.h
! 	- more macros to manipulate the exportstr member of a SHELL_VAR
! 	- changed initialize_shell_variables to cache the value from the
! 	  environment as the initial exportstr for all imported variables
! 	- changed make_var_array to use exportstr if it exists, instead
! 	  of computing the value
! 	- changed make_var_array to cache exportstr for exported functions,
! 	  so they don't have to be deparsed every time the export env is
! 	  remade
! 
! 				   4/28
! 				   ----
! lib/readline/{histlib,rldefs}.h
! 	- changed STREQN macro to evaluate to 1 if the third argument is 0
! 
! lib/readline/search.c
! 	- changed rl_history_search_{for,back}ward so they leave point at
! 	  the end of the line when the string to search for is empty, like
! 	  previous-history and next-history
! 	- broke common code out of rl_history_search_{for,back}ward into
! 	  a new function, rl_history_search_reinit
! 	- rewrote rl_history_search_internal to be more like the
! 	  non-incremental search functions, use noninc_search_from_pos,
! 	  and leave the last history line found in the current line buffer
! 	  if the search fails
! 	- new function, make_history_line_current, takes care of making
! 	  the current line buffer a copy of the history entry passed as an
! 	  argument; used by rl_history_search_internal and noninc_dosearch
! 
! subst.c
! 	- make ${!prefix@} be the same as ${!prefix*} for (undocumented)
! 	  ksh93 compatibility
! 
! 				   4/30
! 				   ----
! lib/readline/doc/rltech.texinfo
! 	- added note about including <readline/readline.h>, and that <stdio.h>
! 	  should be included before readline.h
! 
! lib/readline/doc/hstech.texinfo
! 	- added note about including <readline/history.h>
! 
! lib/readline/doc/manvers.texinfo
! 	- updated version to 4.1
! 
! lib/readline/{bind,complete,display,isearch,nls,parens,readline,signals,tilde,
! histexpand}.c
! 	- added prototypes with __P((...)) for forward static function
! 	  declarations
! 
! lib/readline/display.c
! 	- broke the code that initializes VISIBLE_LINE and INVISIBLE_LINE out
! 	  of rl_redisplay into a new function, init_line_structures, which
! 	  takes an argument giving the minimum number of characters that the
! 	  line must hold 
! 	- new function for use by applications that want to display the
! 	  initial prompt themselves rather than having the first call to
! 	  readline do it:  rl_on_new_line_with_prompt (modified from code in
! 	  the CLISP distribution)
! 
! lib/readline/readline.c
! 	- new external variable, rl_already_prompted, to let readline know
! 	  that the prompt string has already been displayed on the screen
! 	  before the first call to readline
! 	- test rl_already_prompted before displaying the prompt in
! 	  readline_internal_setup
! 	- if rl_already_prompted is non-zero, readline_internal_setup calls
! 	  rl_on_new_line_with_prompt instead of rl_on_new_line
! 
! lib/readline/readline.h
! 	- extern declaration for rl_on_new_line_with_prompt
! 	- extern declaration for rl_already_prompted
! 
! lib/readline/doc/rltech.texinfo
! 	- documented rl_on_new_line_with_prompt and rl_already_prompted
! 
! builtins/read.def
! 	- new -s option (silent mode).  Input from a terminal is not echoed
! 
! doc/{bash.1,bashref.texi}
! 	- documented new `-s' option to read builtin
! 
! 				    5/3
! 				    ---
! lib/readline/vi_mode.c
! 	- replaced references to rl_getc with (*rl_getc_function)
! 
! [bash-2.04-devel frozen]
! 
! 				    5/5
! 				    ---
! subst.c
! 	- make sure that verify_substring_values always passes malloc'd
! 	  memory to maybe_expand_string as the string to be expanded,
! 	  since it gets freed on errors
! 
! support/shobj-conf
! 	- don't need -R option for shared libraries on Solaris
! 	- new stanza for OSF/1 machines with gcc
! 
! lib/readline/readline.c
! 	- new variable, rl_gnu_readline_p, always 1.  Available to allow
! 	  readline users to test whether or not they're linking against
! 	  the true readline, rather than some bogus replacement (from CLISP)
! 
! lib/readline/readline.h
! 	- extern declaration for rl_gnu_readline_p
! 
! hashlib.h, hashcmd.h
! 	- added prototypes to extern function declarations
! 
! pcomplete.h
! 	- new file, declarations for the programmable completion stuff
! 
! pcomplib.c
! 	- new file, library functions for programmable completion
! 
! 				    5/6
! 				    ---
! builtins/complete.def
! 	- new file, interface to programmable completion management
! 
! configure.in
! 	- new enable argument --enable-progcomp, defines
! 	  PROGRAMMABLE_COMPLETION
! 
! config.h.in
! 	- #define for PROGRAMMABLE_COMPLETION
! 
! config-bot.h
! 	- if PROGRAMMABLE_COMPLETION is defined and READLINE is not,
! 	  #undef PROGRAMMABLE_COMPLETION
! 
! pcomplete.c
! 	- new file, placeholder for programmable completion generators and
! 	  associated functions
! 
! Makefile.in, builtins/Makefile.in
! 	- changes to add pcomplete.c, builtins/complete.def
! 
! 				    5/7
! 				    ---
! subst.c
! 	- new function, #ifdef READLINE, skip_to_delim (s, i, delims).
! 	  Starting at s[i], return the index of the first character in s
! 	  that is contained in delims.  Understands shell quoting.
! 	- added two arguments to list_string_with_quotes: an index to
! 	  watch for, and a pointer to int to return the index into the
! 	  created word list of the word containing the sentinel.  Now
! 	  compiled in all the time.  The returned index starts at 1.
! 
! subst.h
! 	- extern declarations for char_is_quoted, unclosed_pair, and
! 	  skip_to_delim
! 	- changed extern declaration for list_string_with_quotes, moved
! 	  it out of the #ifdef ARRAY_VARS section
! 
! bashline.c
! 	- removed extern declarations for char_is_quoted and unclosed_pair
! 
! variables.c
! 	- new function, SHELL_VAR **all_exported_variables()
! 	= new function, SHELL_VAR **all_array_variables(), #ifdef ARRAY_VARS
! 
! variables.h
! 	- extern declaration for all_exported_variables, all_array_variables
! 
! lib/sh/strpbrk.c
! 	- replacement if we don't have strpbrk(3)
! 
! configure.in, config.h.in
! 	- check for strpbrk(3), define HAVE_STRPBRK if found
! 
! builtins/shopt.def
! 	- new function, char **get_shopt_options (), returns an array of
! 	  shopt option names
! 
! builtins/set.def
! 	- new function, char **get_minus_o_opts (), returns an array of
! 	  `set -o' option names
! 
! builtins/common.h
! 	- extern declarations for get_shopt_options, get_minus_o_opts
! 
! 				   5/10
! 				   ----
! pathexp.c
! 	- make the POSIX_GLOB_LIBRARY code implement the GLOBIGNORE stuff
! 
! 				   5/11
! 				   ----
! array.c
! 	- new convenience function, char **array_to_argv (ARRAY *),
! 	  converts an array to a list of string values
! 
! array.h
! 	- extern declaration for array_to_argv
! 
! execute_cmd.c
! 	- new convenience function, int execute_shell_function (SHELL_VAR *,
! 	  WORD_LIST *)
! 
! execute_cmd.h
! 	- extern declaration for execute_shell_function
! 
! builtins/evalstring.c
! 	- make parse_and_execute unwind_protect current_prompt_string
! 	  if the shell is interactive
! 
! 				   5/12
! 				   ----
! variables.c
! 	- moved bind_int_variable from expr.c to here; it now returns a
! 	  SHELL_VAR *, like the other variable binding functions
! 
! variables.h
! 	- extern declaration for bind_int_variable
! 
! 				   5/14
! 				   ----
! bashline.c, parse.y, general.c, make_cmd.c, subst.c, braces.c, execute_cmd.c
! 	- replaced some common code sequences with calls to substring()
! 
! lib/readline/doc/rltech.texinfo
! 	- fixed small typo in description of rl_completion_entry_function
! 
! 				   5/18
! 				   ----
! stringlib.c
! 	- new function, strcreplace(char *string, int c, char *text, int do_glob)
! 	  replaces all occurrences of C in STRING with TEXT.  Backslash may
! 	  be used to quote C.  If DO_GLOB is non-zero, the replacement TEXT
! 	  is quoted to protect globbing characters.
! 
! externs.h
! 	- extern declaration for strcreplace
! 
! bashhist.c
! 	- use strcreplace in expand_histignore_pattern
! 
! pcomplete.c
! 	- finished initial implementation of programmable completion
! 
! alias.c
! 	- code to set the aliases itemlist to dirty when an alias is added
! 	  or removed, if PROGRAMMABLE_COMPLETION is defined
! 
! variables.c
! 	- code to set the functions itemlist to dirty when a shell function
! 	  is added or removed, if PROGRAMMABLE_COMPLETION is defined
! 
! builtins/enable.def
! 	- code to set the builtins itemlist to dirty when a shell builtin
! 	  is added or removed, if PROGRAMMABLE_COMPLETION is defined
! 	- code to set the enabled and disabled itemlists to dirty when a
! 	  builtin is enabled or disabled, if PROGRAMMABLE_COMPLETION is
! 	  defined
! 
! builtins/shopt.def
! 	- new shell option, `progcomp', on if programmable_completion_enabled
! 	  (from pcomplete.c) is non-zero
! 
! doc/{bash.1,bashref.texi}
! 	- note that `${' is not eligible for brace expansion to avoid
! 	  conflicts with parameter expansion
! 
! 				   5/19
! 				   ----
! builtins/complete.def
! 	- added a new `compgen' builtin for use by completion functions
! 
! 				   5/21
! 				   ----
! bashline.c
! 	- new function, void clear_hostname_list(void), to delete all the
! 	  entries in the hostname completion list
! 
! bashline.h
! 	- extern declaration for clear_hostname_list
! 
! variables.c
! 	- changed sv_hostfile to clear the hostname list if $HOSTFILE is
! 	  unset
! 
! doc/{bash.1,bashref.texi}
! 	- documented new behavior of HOSTFILE when it's unset
! 	- added some awkwardly-worded text to make it clear that an
! 	  interactive shell cannot be started with non-option arguments
! 	  or with the -c option
! 
! shell.c
! 	- restored NON_INTERACTIVE_LOGIN_SHELLS test, so that if it is
! 	  defined, shells with argv[0][0] == '-' and not in posix mode
! 	  run the startup files even if non-interactive
! 
! config-top.h
! 	- added commented-out #define for NON_INTERACTIVE_LOGIN_SHELLS
! 
! 				   5/24
! 				   ----
! subst.c
! 	- make sure the characters in IFS are cast to unsigned before being
! 	  indexed in ifscmap (expand_word_internal)
! 
! 				   5/25
! 				   ----
! parse.y
! 	- change grammar rule for arithmetic for expressions to handle a
! 	  list_terminator after the `))' instead of requiring a newline_list
! 
! subst.c
! 	- fix so that variable indirection can reference the shell's special
! 	  variables (like $0...$9, $$, $#, etc.)
! 
! pcomplete.c
! 	- changed gen_wordlist_matches to use split_at_delims to split the
! 	  string at $IFS first, then expand each individual word
! 
! 				   5/27
! 				   ----
! lib/readline/histfile.c
! 	- change things so that O_BINARY mode is used when reading and writing
! 	  the history file on cygwin32 as well as OS/2 (__EMX__)
! 
! parse.y
! 	- add calls to push_delimiter and pop_delimiter around the call
! 	  to parse_matched_pair when parsing $'...' and $"..." so the
! 	  history entry is added correctly
! 
! 				   5/28
! 				   ----
! doc/{bash.1,bashref.texi}, lib/readline/doc/rluser.texinfo
! 	- documented new programmable completion facilities
! 
! doc/bashref.texi
! 	- documented new configure `--enable-progcomp' option
! 
! 				    6/1
! 				    ---
! variables.c
! 	- if make_local_variable is being asked to make a local shadow
! 	  variable of a read-only variable, print an error message and
! 	  return NULL
! 	- if make_local_variable returns NULL to make_local_array_variable,
! 	  just return it
! 
! builtins/declare.def
! 	- if we're making local variables, and make_local_array_variable or
! 	  make_local_variable returns NULL, just flag an error and go on
! 
! 				    6/2
! 				    ---
! Makefile.in
! 	- changed release status to `alpha1'
! 
! [bash-2.04-alpha1 frozen]
! 
! 				   6/18
! 				   ----
! bashline.c
! 	- fixed find_cmd_start so that it doesn't spin-loop on commands with
! 	  a command separator like `;' or `&'.  Problem was not incrementing
! 	  `os' past the delimiter found
! 
! 				   6/21
! 				   ----
! variables.c
! 	- cosmetic change: introduced two macros to encapsulate initialization
! 	  of dynamic variables
! 
! 				   6/23
! 				   ----
! pcomplib.c
! 	- new function: num_progcomps(void), returns the number of entries in
! 	  the programmable completions hash table
! 
! pcomplete.h
! 	- extern declaration for num_progcomps
! 
! bashline.c
! 	- make sure some programmable completions have been defined before
! 	  diving into the programmable completion code
! 
! shell.c
! 	- in open_shell_script, move the fd opened to the script to a high
! 	  one with move_to_high_fd in all cases -- the buffered input code
! 	  still has problems if fd == 0 and later on fd 0 is closed or
! 	  redirected (cf. input.c:check_bash_input())
! 
! builtins/printf.def
! 	- getlong() now calls strtol directly with a third argument of 0 so
! 	  it can handle 0x (hex) and 0 (octal) prefixes, which legal_number
! 	  does not -- this has implications for arguments to %d that begin
! 	  with `0'
! 
! lib/sh/getenv.c
! 	- make sure that the variable found in the temporary environment has
! 	  a non-null value before calling savestring() on it
! 
! subst.c
! 	- make sure split_at_delims returns 0 in *nwp and *cwp if handed a
! 	  null or empty string
! 
! pcomplete.c
! 	- make sure build_arg_list handles lwords == 0, as it will be if an
! 	  empty command line is handed to the programmable completion code
! 	  (like compgen -C xyz)
! 
! execute_cmd.c
! 	- make sure execute_shell_function passes a non-null bitmap of fds to
! 	  close to execute_function, allocating and deallocating it locally
! 
! sig.c
! 	- don't mess with SIGPROF in initialize_terminating_signals
! 
! jobs.c, nojobs.c
! 	- if the user has requested it with checkwinsize, check for a new
! 	  window size after a job exits due to a signal as well as being
! 	  stopped
! 
! lib/readline/kill.c
! 	- changed rl_kill_region to set the point to the beginning of the
! 	  region after the kill is performed
! 
! 				   6/24
! 				   ----
! configure.in
! 	- make sure ranges ([1-9]*) are protected with [...] for m4 quoting
! 
! variables.c
! 	- make sure that bind_variable_value honors `set -a' and that it
! 	  marks the environment for recreation if necessary
! 
! 				   6/25
! 				   ----
! lib/readline/complete.c
! 	- if we're completing at the end of the line, find_completion_word
! 	  shouldn't test whether the character is a special word break
! 	  char and (possibly) advance rl_point past the end of the buffer
! 
! parse.y
! 	- change mk_msgstr to write embedded newlines as `\n"<NL>"', as the
! 	  PO file format apparently requires
! 
! 				   6/28
! 				   ----
! lib/readline/display.c
! 	- code to manage the growth of the inv_lbreaks and vis_lbreaks arrays
! 	  beyond 256, since there are pathalogical command lines that can
! 	  have more than 256 line breaks for redisplay
! 
! 				   6/30
! 				   ----
! stringlib.c
! 	- include pathexp.h for extern declaration of quote_globbing_chars
! 
! variables.h
! 	- change CACHE_EXPORTSTR to savestring() the value and not set the
! 	  att_importstr flag
! 
! 				    7/6
! 				    ---
! support/bashbug.sh
! 	- bashbug now accepts --help and --version options
! 
! bashline.c
! 	- change bash_quote_filename to use single quotes if the user
! 	  does not specify an opening quote character and the filename being
! 	  completed contains newlines
! 
! 				    7/8
! 				    ---
! configure.in, aclocal.m4, config.h.in
! 	- BASH_TYPE_INT32_T --> BASH_TYPE_BITS32_T; int32_t --> bits32_t
! 	- BASH_TYPE_U_INT32_T --> BASH_TYPE_U_BITS32_T; u_int32_t --> u_bits32_t
! 
! lib/malloc/{malloc,gmalloc}.c, lib/sh/inet_aton.c
! 	- int32_t --> bits32_t; u_int32_t --> u_bits32_t
! 
! aclocal.m4
! 	- new tests: BASH_TYPE_BITS16_T, BASH_TYPE_U_BITS16_T
! 
! configure.in
! 	- add check for sizeof short, sizeof char
! 	- call BASH_TYPE_BITS16_T, BASH_TYPE_U_BITS16_T
! 
! config.h.in
! 	- new #defines for bits16_t, u_bits16_t
! 
! lib/malloc/malloc.c
! 	- use u_bits16_t for type of mi_magic2
! 
! 
! 				   7/16
! 				   ----
! lib/readline/display.c
! 	- new private library function, _rl_strip_prompt, to remove instances
! 	  of RL_PROMPT_{START,END}_IGNORE from the passed prompt string
! 
! lib/readline/rlprivate.h
! 	- extern declaration for _rl_strip_prompt
! 
! lib/readline/readline.c
! 	- call _rl_strip_prompt before outputting the prompt if we're not
! 	  doing any echoing of input chars (readline_echoing_p == 0)
! 
! Makefile.in
! 	- tentative change to rule for parser-built: use $< instead of
! 	  `y.tab.h' in recipe
! 
! 				   7/19
! 				   ----
! support/config.{guess,sub}
! 	- add code to handle all versions of Mac OS (e.g., Mac OS X)
! 
! 				   7/26
! 				   ----
! lib/readline/bind.c
! 	- on cygwin32, treat \r\n as a line terminator when reading the
! 	  inputrc file
! 
! 				   7/29
! 				   ----
! lib/sh/netopen.c
! 	- fixed problem in _getaddr with copying the address returned from
! 	  gethostbyname to the `struct in_addr *' argument -- hostnames
! 	  now work in /dev/(tcp|udp)/host/port
! 
! 				    8/2
! 				    ---
! configure.in
! 	- on Apple Rhapsody systems, set LOCAL_CFLAGS to -DRHAPSODY
! 
! variables.h
! 	- changes from Apple for building fat binaries on Rhapsody,
! 	  setting HOSTYPE, OSTYPE, VENDOR, and MACHTYPE
! 
! lib/readline/terminal.c
! 	- some work on the `dumb terminal' setup code in _rl_init_terminal_io
! 	  to make sure it's complete for use by the redisplay code and some
! 	  stuff in {readline,complete}.c
! 
! lib/readline/display.c
! 	- new function, _rl_current_display_line, returns the number of
! 	  lines down from the first `screen line' of the current readline
! 	  line the cursor is
! 
! lib/readline/readline.c
! 	- make rl_refresh_line call _rl_current_display_line
! 
! lib/readline/rlprivate.h
! 	- extern declaration for _rl_current_display_line
! 
! 				    8/3
! 				    ---
! doc/bashref.texi
! 	- reorganized slightly:
! 		o a new shell builtins chapter
! 		o a new shell variables chapter
! 		o a new special builtins section
! 		o bourne shell features chapter removed
! 		o alias builtins moved to the bash builtins section
! 		o bourne shell differences moved to appendix
! 		o order of readline and history chapters swapped
! 		o indices are now unnumbered appendices
! 		o some text cleaned up and some explanatory text added
! 
! lib/readline/terminal.c
! 	- if a calling application is using a custom redisplay function,
! 	  don't call tgetent to get the terminal attributes, since those
! 	  are used only by the redisplay code.  Still get the window
! 	  size, though
! 
! lib/glob/fnmatch.c
! 	- range comparisons in bracket expressions no longer use strcoll(3),
! 	  since in some locales (de, for example), [A-Z] matches all
! 	  characters
! 
! parse.y, print_cmd.c
! 	- some changes to make sure the shell compiles when
! 	  DPAREN_ARITHMETIC is not defined but ARITH_FOR_COMMAND is
! 
! 				    8/5
! 				    ---
! redir.c
! 	- in the here document code in do_redirection_internal, check
! 	  that the file descriptor returned by here_document_to_fd is not
! 	  the same as a file descriptor specified as the redirector
! 	  before closing it
! 
! 				    8/6
! 				    ---
! parse.y
! 	- make sure the pipline rule for `timespec BANG pipeline' sets the
! 	  CMD_INVERT_RETURN flag for the pipeline command
! 
! builtins/wait.def
! 	- use setjmp with a special jump buffer to take longjmps in the
! 	  case that a SIGINT is received while waiting for jobs or processes
! 	  it makes wait return with a status > 128, as POSIX.2 specifies
! 
! {jobs,nojobs}.c
! 	- changed wait_sigint_handler to longjmp to wait_intr_buf if it's
! 	  executing the wait builtin and SIGINT is trapped.  It calls
! 	  trap_handler to make sure a pending trap for SIGINT is set also,
! 	  so the trap is taken when the wait builtin returns
! 
! 				    8/9
! 				    ---
! jobs.c
! 	- save and restore the value of errno in sigchld_handler
! 
! trap.c
! 	- save and restore the value of errno in trap_handler
! 
! 				   8/10
! 				   ----
! Makefile.in
! 	- changed release status to beta1
! 
! 				   8/13
! 				   ----
! include/posixtime.h
! 	- new file to encapsulate the <time.h> and <sys/time.h> mess
! 
! Makefile.in
! 	- add posixtime.h to list of include files in BASHINCFILES
! 	- update dependencies for general.o, execute_cmd.o
! 
! general.c, execute_cmd.c, builtins/times.def
! 	- include posixtime.h instead of <time.h>, <sys/time.h>
! 
! general.c
! 	- protect inclusion of <sys/times.h> with HAVE_SYS_TIMES_H check
! 
! builtins/Makefile.in
! 	- update dependencies for times.o
! 
! 				   8/16
! 				   ----
! lib/sh/timeval.c
! 	- moved functions dealing with struct timevals here from general.c
! 	  and execute_cmd.c
! 
! lib/sh/clock.c
! 	- moved functions dealing with clock_ts here from general.c
! 	  (print_time_in_hz renamed to print_clock_t)
! 
! externs.h
! 	- moved extern declarations for timeval_to_secs and print_timeval
! 	  here from general.h
! 	- moved extern declarations for clock_t_to_secs and print_clock_t
! 	  here from general.h
! 
! builtins/times.def
! 	- calls to print_time_in_hz changed to print_clock_t
! 
! Makefile.in
! 	- added references for lib/sh/timeval.c and lib/sh/clock.c
! 
! lib/sh/Makefile.in
! 	- clock.o and timeval.o are now included in libsh.a
! 
! 				   8/23
! 				   ----
! execute_cmd.c
! 	- make sure last_command_exit_value is updated before running a
! 	  DEBUG trap in the cm_simple case of execute_command_internal
! 
! lib/readline/display.c
! 	- new function, static void redraw_prompt (char *), used to
! 	  redraw the last line of a multiline prompt that possibly
! 	  contains terminal escape sequences
! 	- call redraw_prompt from _rl_redisplay_after_sigwinch
! 
! 				   8/24
! 				   ----
! lib/readline/bind.c
! 	- new struct with names of string-valued readline variables and
! 	  handler functions to call when the variable is set
! 	- changed rl_variable_bind to use functions to find boolean vars
! 	  and string vars in their respective lists
! 	- new function, bool_to_int, to translate a boolean value that may
! 	  appear as an argument to `set <boolean-var-name>' to 1 or 0
! 	- new function, hack_special_boolean_var, called if the element in
! 	  the boolean_vars struct has the V_SPECIAL flag set, to provide
! 	  any necessary other action when a boolean variable is set
! 	- new functions to be called when each string variable is set;
! 	  called by rl_variable_bind
! 
! execute_cmd.c
! 	- do_piping no longer sets pipes to O_TEXT mode if __CYGWIN32__
! 	  is defined
! 
! 				   8/25
! 				   ----
! subst.c
! 	- parameter_brace_patsub now mallocs a local copy of `patsub', because
! 	  if it starts with a `/' we increment it, and functions down the call
! 	  chain will free that on an error (and if we pass the incremented
! 	  value, will try to free unallocated memory)
! 	- pos_params now short-circuits and returns a null string immediately
! 	  if start == end, meaning we want 0 positional parameters
! 
! 				   8/26
! 				   ----
! subst.c
! 	- fixed pat_subst to correctly handle a null replacement string with
! 	  a null pattern string prefixed with `%' or `#'
! 
! 				    9/3
! 				    ---
! variables.c
! 	- don't import shell functions from the environment if the shell was
! 	  started with -n
! 
! 				    9/8
! 				    ---
! subst.c
! 	- if a command substitution is being performed inside a shell function,
! 	  catch `return' in command_substitute so that a return inside the
! 	  command substitution doesn't jump back to execute_function (or one
! 	  of its brethren) and go on with the command
! 
! parse.y
! 	- in history_delimiting_chars, if the first line is `for var' and
! 	  command_oriented_history is active, we don't want a semicolon if
! 	  the next token to be read is `in', but we do want one otherwise.
! 	  All we can do is check shell_input_line and see if the next chars
! 	  are `in' -- if so, we return " "
! 
! 				   9/16
! 				   ----
! builtins/hash.def
! 	- don't allow `hash -p /pathname/with/slashes name' if the shell
! 	  is restricted
! 
! doc/{bash.1,bashref.texi}
! 	- updated description of restricted shell mode
! 
! lib/readline/display.c
! 	- fixed a bug in _rl_update_final which used the inv_lbreaks array
! 	  to index into visible_line
! 
! jobs.c
! 	- waitchld() need not go through the pain of setting up an environment
! 	  to execute traps on SIGCHLD if children_exited == 0
! 	- waitchld returns -1 if waitpid() returns -1 with errno == ECHILD,
! 	  indicating that there are no unwaited-for child processes, and it
! 	  has not yet reaped any dead children
! 	- wait_for, wait_for_single_pid return -1 if waitchld() returns -1
! 	- new function, mark_all_jobs_as_dead
! 	- wait_for_background_pids calls mark_all_jobs_as_dead if
! 	  wait_for_single_pid returns -1 with errno == ECHILD, since there are
! 	  no unwaited-for child processes
! 
! subst.c
! 	- tentative change: subshells started for command substitution no
! 	  longer unconditionally disable job control
! 
! 				   9/17
! 				   ----
! parse.y
! 	- new function: save_token_state().  Saves the value of last_read_token
! 	  and the two previous tokens in an allocated array and returns the
! 	  array
! 	- new function: restore_token_state(ts).  TS is an array returned by
! 	  save_token_state.  last_read_token and the two previous tokens are
! 	  set from the values in TS
! 
! trap.c
! 	- run_pending_traps calls save_token_state and restore_token_state
! 	  around the call to parse_and_execute, which will call the parser
! 	  and possibly leave it in a state where reserved words will not be
! 	  recognized (_run_trap_internal, too)
! 
! 				   9/20
! 				   ----
! support/bashbug.sh
! 	- if sendmail is used as $RMAIL, pass `-i -t' as arguments so changes
! 	  made by the user to the recipient headers in the message are
! 	  honored
! 
! 				   9/21
! 				   ----
! bashhist.c
! 	- if histverify has been set, make sure a `:p' modifier to a history
! 	  expansion prints the result
! 
! builtins/echo.def
! 	- new extern variable, xpg_echo, set to 1 if DEFAULT_ECHO_TO_USG is
! 	  defined and 0 otherwise
! 	- echo_builtin now sets the initial value of do_v9 from xpg_echo
! 
! builtins/shopt.def
! 	- new shopt option, `xpg_echo', turns backslash escape expansion by
! 	  `echo' on and off at runtime
! 
! builtins/{bash.1,bashref.texi}
! 	- documented new `xpg_echo' shell option
! 
! tests/{builtins.tests,builtins2.sub,shopt.tests}
! 	- changes for new `xpg_echo' shell option
! 
! configure.in
! 	- changes for FreeBSD-3.x ELF to add `-rdynamic' to LOCAL_LDFLAGS.
! 	  This allows dynamic loading of builtins
! 
! support/shobj-conf
! 	- changes to handle FreeBSD-3.x elf or a.out object file formats
! 
! 				   9/23
! 				   ----
! [bash-2.04-beta1 released]
! 
! 				   9/24
! 				   ----
! jobs.c
! 	- wait_for returns -1 only if the shell is currently executing the
! 	  `wait' builtin, since that's the only thing that cares
! 
! execute_cmd.c
! 	- moved cases of close_fd_bitmap to before calls to do_piping to
! 	  handle some pathological cases
! 
! 				   9/29
! 				   ----
! execute_cmd.c
! 	- save the command line in execute_simple_command before making the
! 	  export environment, since maybe_make_export_env clobbers
! 	  the_printed_command if there are exported functions
! 
! 				   9/30
! 				   ----
! configure.in,config.h.in
! 	- check explicitly for setvbuf; define HAVE_SETVBUF if found
! 
! configure.in
! 	- change opt_gnu_malloc to opt_bash_malloc, since the bash malloc
! 	  is not really the gnu malloc anymore
! 	- new argument, --with-bash-malloc, identical to --with-gnu-malloc
! 	- AC_DEFINE(USING_BASH_MALLOC) if opt_bash_malloc is enabled
! 
! config.h.in
! 	- new #define for USING_BASH_MALLOC
! 
! doc/bashref.texi
! 	- updated installation section to add --with-bash-malloc and
! 	  change description of --with-gnu-malloc
! 
! lib/sh/setlinebuf.c
! 	- change name of function to sh_setlinebuf, just returns 0 if
! 	  HAVE_SETVBUF and HAVE_SETLINEBUF are undefined
! 	- prefer setvbuf to setlinebuf if we have both
! 	- if we're using setvbuf, use a local buffer for stdin and stdout
! 	  local buffer is BUFSIZ unless we're using the bash malloc
! 	  (USING_BASH_MALLOC is defined), in which case it's 1008 (which
! 	  the bash malloc rounds up to 1024)
! 
! 				   10/4
! 				   ----
! input.c
! 	- if USING_BASH_MALLOC is defined, set the max buffer size to 8176,
! 	  which the bash malloc rounds up to 8192
! 
! 				   10/5
! 				   ----
! pcomplete.c
! 	- new function, pcomp_filename_completion_function, a wrapper for
! 	  filename_completion_function that dequotes the filename first
! 
! bashline.c
! 	- changed bash_directory_completion_matches to dequote the filename
! 	  before passing it (indirectly) to filename_completion_function
! 
! execute_cmd.c
! 	- change execute_command to defer calling unlink_fifo_list until any
! 	  shell function has finished executing (variable_context == 0)
! 
! configure.in
! 	- added AC_CYGWIN, AC_MINGW32, AC_EXEEXT
! 
! 				   10/8
! 				   ----
! subst.c
! 	- expand_word_internal(): changes some things to avoid small (2 or 3
! 	  byte) calls to xmalloc -- added a label and some gotos (BEWARE)
! 	- changed make_dev_fd_filename so it doesn't call sprintf anymore
! 
! 				   10/27
! 				   -----
! execute_cmd.c
! 	- make execute_select_command handle the effects of the `continue'
! 	  builtin correctly
! 
! 				   11/5
! 				   ----
! Makefile.in
! 	- RELSTATUS changed to `beta2'
! 
! 				   11/8
! 				   ----
! [bash-2.04-beta2 released]
! 
! 				   11/9
! 				   ----
! shell.c
! 	- make run_startup_files check for ssh2 as well as ssh1
! 
! 				   11/19
! 				   -----
! parse.y
! 	- make sure parsing conditional commands isn't confused by unexpected
! 	  tokens (like `[[)]]')
! 
! builtins/common.c
! 	- fix get_job_spec to return NO_JOB for numeric job specs that are
! 	  beyond the size of the jobs table
! 
! builtins/type.def
! 	- change describe_command to report `not found' if a path search
! 	  returns the same string as the command name and the command name
! 	  does not match an executable file.  This has implications for
! 	  `type' and `command -[vV]'.
! 	- if a command is not found in $PATH, but an executable file with the
! 	  name supplied exists in the current directory, make the command
! 	  into a full pathname for the `command' builtin.  This has
! 	  implications for `type' and `command -[vV]'
! 
! subst.c
! 	- new function, expand_prompt_string, expands prompt string and
! 	  returns the string passed if an error occurs
! 
! subst.h
! 	- extern declaration for expand_prompt_string
! 
! parse.y
! 	- decode_prompt_string calls expand_prompt_string instead of
! 	  expand_string_unsplit
! 
! 				   11/22
! 				   -----
! builtins/echo.def
! 	- return EXECUTION_FAILURE if ferror(stdout) is true
! 
! 				   11/23
! 				   -----
! locale.c
! 	- if LC_ALL is unset, call setlocale(LC_ALL, lc_all), because lc_all
! 	  holds the default locale
! 
! 				   11/29
! 				   -----
! lib/readline/shell.c
! 	- define NULL as 0 if it's not defined
! 	- change single_quote to allocate 4 characters in new string for
! 	  each character in the old one (like builtins/common.c:single_quote)
! 
! locale.c
! 	- when a locale variable (LC_*) is unset, pass "" to setlocale()
! 	  to get the default locale set, since value is NULL
! 
! lib/sh/makepath.c
! 	- new function, sh_makepath(char *path, char *dir, int flags)
! 
! Makefile.in
! 	- changed version to beta3
! 
! builtins/type.def
! 	- changed describe_command to use sh_makepath()
! 
! builtins/cd.def
! 	- removed private declaration of mkpath(), changed to use sh_makepath
! 
! general.c
! 	- changed make_absolute to use sh_makepath
! 	- changed full_pathname to use sh_makepath
! 
! findcmd.c
! 	- removed private definition of make_full_pathname, changed to use
! 	  sh_makepath
! 
! doc/{bashref.texi,bash.1}
! 	- added text to description of `getopts' to make it clear that getopts
! 	  may be used to parse option characters other than letters, and
! 	  that `:' and `?' may not be used as option characters
! 
! eval.c
! 	- when processing a jump_to_top_level(EXITPROG), make sure the shell
! 	  doesn't think it's still in a function by setting variable_context
! 	  to 0
! 
! doc/rbash.1
! 	- a skeletal man page for rbash, adapted from debian
! 
! support/bashbug.sh
! 	- try to find a default editor if EDITOR is unset, rather than blindly
! 	  using `emacs'
! 
! 				   11/30
! 				   -----
! support/config.{guess,sub}
! 	- many changes from the latest `automake' distribution, from the
! 	  Debian folks
! 
! 				   12/2
! 				   ----
! lib/readline/keymaps.h, lib/tilde/tilde.h
! 	- added support for C++ compilation (`extern "C" {...}')
! 
! 				   12/3
! 				   ----
! subst.c
! 	- in process_substitute, make sure the child resets the O_NONBLOCK
! 	  flag on the file descriptor opened for read to a named pipe
! 
! jobs.c
! 	- new function, raw_job_exit_status, returns exit status of last job
! 	  in pipeline
! 	- change job_exit_status to call raw_job_exit_status and pass the
! 	  result to process_exit_status
! 	- in notify_of_job_status, get termination status from call to
! 	  raw_job_exit_status, rather than the first job in the pipeline
! 	  (fixes debian bug #15165)
! 
! bashhist.c
! 	- changed bash_history to not add shell comment lines to the history
! 	  file (fixes debian bug #21901).  Uses new function shell_comment(L)
! 	  which returns 1 if L is a shell comment line.  Doesn't handle
! 	  comments embedded in lines yet
! 
! redir.c
! 	- when running in POSIX.2 mode, bash no longer performs word splitting
! 	  on the expanded value of the word supplied as the filename argument
! 	  to a redirection operator (fixes debian bug #30460)
! 
! doc/bashref.texi
! 	- added new redirection stuff to POSIX Mode section (from previous fix)
! 
! 				   12/6
! 				   ----
! hashlib.h
! 	- removed extra semicolon at end of HASH_ENTRIES define
! 
! redir.c
! 	- replaced toggling of disallow_filename_globbing flag with setting
! 	  flags in redirection word to include W_NOGLOB if the shell is in
! 	  POSIX mode and not interactive when expanding the filename argument
! 	  to a redirection
! 
! 				   12/7
! 				   ----
! builtins/common.c
! 	- new function, backslash_quote_for_double_quotes(char *), quotes
! 	  characters special when in double quotes in the string passed as
! 	  an argument.
! 	  #ifdef PROMPT_STRING_DECODE; called by decode_prompt_string
! 
! builtins/common.h
! 	- extern declaration for backslash_quote_for_double_quotes
! 
! parse.y
! 	- call backslash_quote_for_double_quotes instead of backslash_quote
! 	  in decode_prompt_string
! 
! 				   12/9
! 				   ----
! parse.y
! 	- before expanding the \u prompt string escape sequence, make sure
! 	  current_user.user_name is non-null and call get_current_user_info
! 	  if it is
! 
! 				   12/10
! 				   -----
! support/mkversion.sh
! 	- changes to avoid relying on floating point output format, which
! 	  can be locale-specific
! 
! 				   12/14
! 				   -----
! print_cmd.c
! 	- changes to named_function_string (for normal function printing)
! 	  and print_function_def (for printing function definitions embedded
! 	  in other commands) to print redirections that should be attached
! 	  to the function as a whole after the closing brace
! 
! tests/func1.sub
! 	- tests for printing functions with attached redirections, called by
! 	  func.tests
! 
! 				   12/16
! 				   -----
! lib/readline/complete.c
! 	- if we're completing files in the root directory and executing the
! 	  visible-stats code, don't pass an empty pathname to
! 	  rl_directory_completion_hook, because, for bash, that will be
! 	  expanded to the current directory.  Just pass `/' instead.
! 
! lib/tilde/tilde.c
! 	- fix to tilde_expand_word for Cygwin to avoid creating pathnames
! 	  beginning with `//' if $HOME == `/'
! 
! variables.c
! 	- don't bother with the exportstr validation on cygwin systems,
! 	  or even using exportstr at all, since that system has weird
! 	  environment variables
! 
! 				   12/17
! 				   -----
! configure.in
! 	- new option, --enable-xpg-echo-default, new name for
! 	  --enable-usg-echo-default (which is still present for backwards
! 	  compatibility)
! 
! configure.in, config.h.in, builtins/echo.def
! 	- DEFAULT_ECHO_TO_USG -> DEFAULT_ECHO_TO_XPG
! 
! 				   12/29
! 				   -----
! aclocal.m4
! 	- changed a couple of tests to avoid creating files with known
! 	  names in /tmp
! 
! support/rlvers.sh
! 	- changed to create files in /tmp/rlvers
! 
! support/mksignames.c
! 	- now understands the POSIX.1b real-time signal names on systems
! 	  that support them
! 
! 				   12/30
! 				   -----
! [bash-2.04-beta3 released]
! 
! 				   12/31
! 				   -----
! redir.c
! 	- try some more things to avoid race file replacements in
! 	  here_document_to_fd
! 
! parse.y
! 	- two new functions:
! 		get_current_prompt_level: returns 2 if current prompt is $PS2,
! 					  1 otherwise
! 		set_current_prompt_level: sets current prompt to $PS2 if arg
! 					  is 2, $PS1 otherwise
! 
! copy_cmd.c
! 	- make sure to copy the `line' member in copy_arith_for_command
! 
! pcomplete.c
! 	- free up `lwords' and `line' after evaluating any command or shell
! 	  function in gen_compspec_completions
! 	- after filtering any matches specified by cs->filterpat in
! 	  gen_compspec_completions, free ret->list (the members have
! 	  already been copied or freed by filter_stringlist)
! 
! bashline.c
! 	- free what find_cmd_name returns after calling the programmable
! 	  completion code
! 
! 				 1/4/2000
! 				 --------
! subst.c 
! 	- make call_expand_word_internal set w->word to NULL if either
! 	  expand_word_error or expand_word_fatal is returned 
! 
! 				    1/7
! 				    ---
! parse.y
! 	- two new functions: set_current_prompt_level(int) and
! 	  get_current_prompt_level() to set and get the `level' of
! 	  current_prompt_string (1 if $PS1, 2 if $PS2)
! 
! externs.h
! 	- extern declarations for {get,set}_current_prompt_level
! 
! builtins/evalstring.c
! 	- add an unwind_protect to save and restore the current prompt
! 	  string pointers using {get,set}_current_prompt_level
! 
! 				    1/9
! 				    ---
! Makefile.in
! 	- changed release status to `beta4'
! 
! 				   1/18
! 				   ----
! [bash-2.04-beta4 released]
! 
! 				   1/19
! 				   ----
! configure.in
! 	- moved checks for non-unix variants to beginning of tests
! 
! Makefile.in, {builtins,support}/Makefile.in
! 	- added some $(EXEEXT) suffixes to generated programs for non-Unix
! 	  systems
! 
! 				   1/20
! 				   ----
! parse.y
! 	- make get_current_prompt_level return 1 if current_prompt_string is
! 	  NULL (as it would be while sourcing startup files)
! 
! support/rlvers.sh
! 	- rmdir $TDIR in the exit trap
! 	- move the exit trap after we successfully create $TDIR
! 
! 				   1/21
! 				   ----
! subst.c
! 	- several changes to split_at_delims to make non-whitespace
! 	  delimiters create separate fields containing those delimiters,
! 	  like the shell parser does with meta characters.  This allows
! 	  redirection operators, for example, to be treated as separate
! 	  words by the programmable completion code
! 
! examples/complete/complete-examples
! 	- added new function: _redir_op, which return true if the word
! 	  passed as an argument contains a redirection operator (just
! 	  bare-bones for now)
! 	- changed set completion function to use _redir_op as an example
! 
! parse.y
! 	- make parse_string_to_word_list save and restore the value of
! 	  shell_input_line_terminator, since an assignment like
! 	  COMPREPLY=() inside a shell function called by the programmable
! 	  completion code can change shell_input_line_terminator out from
! 	  underneath shell_getc().  shell_getc will set the input line
! 	  terminator to EOF when it gets EOF from the getter function, and
! 	  the string getter function returns EOF at EOS.  parse_and_execute
! 	  tests for EOS directly and never gets EOF from shell_getc, so it
! 	  does not have this problem.
! 
! 				   1/24
! 				   ----
! lib/readline/funmap.c
! 	- #define QSFUNC like in complete.c
! 	- cast _rl_qsort_string_compare to a QSFUNC * in the call to qsort
! 
! lib/readline/terminal.c
! 	- correct a typo in usage of the __EMX__ preprocessor define
! 	- fix a reversed usage of `#if defined (__DJGPP__)' in 
! 	  _rl_control_keypad
! 	- remove extern declarations for _rl_in_stream and _rl_out_stream
! 
! lib/readline/rlprivate.h
! 	- add extern declaration for _rl_in_stream, since there's already
! 	  one for _rl_out_stream
! 
! builtins/ulimit.def
! 	- if bash is using ulimit(2), make sure that getfilesize() returns
! 	  the value multiplied by 512 to convert it from a number of blocks
! 	  to a number of bytes
! 
! 				   1/25
! 				   ----
! execute_cmd.c
! 	- make sure execute_command_internal sets last_command_exit_value
! 	  correctly when inverting the return value of a (...) subshell
! 	  command
! 
! tests/{run-invert,invert.{tests,right}}
! 	- new tests for return value inversion
! 
! configure.in
! 	- compile without bash malloc on m68k-motorola-sysv due to a file
! 	  descriptor leak in closedir(3) -- the motorola implementation
! 	  requires that freed memory be readable so it can free the dirent
! 	  and then look back at it to find the file descriptor
! 
! expr.c
! 	- fix negative exponents in v**e to return an eval error
! 
! 				    2/1
! 				    ---
! Makefile.in
! 	- changed status to beta5
! 
! jobs.c
! 	- fixed a problem with checking the wrong process when checking to
! 	  see whether or not we need to reset the tty state.  The old code
! 	  checked the first process in a pipeline; the new code checks all
! 	  processes in the pipeline to see whether any of them exited due
! 	  to a signal or was stopped.  If none were signalled or stopped,
! 	  the code uses the exit status of the last process in the job's
! 	  pipeline
! 
! 				    2/4
! 				    ---
! [bash-2.04-beta5 released]
! 
! eval.c
! 	- call set_current_prompt_level instead of setting prompt_string_pointer
! 	  directly
! 
! 				   2/10
! 				   ----
! [bash-2.04-beta5 re-released to net]
! 
! 				   2/11
! 				   ----
! sig.c
! 	- make sure SIGCHLD is defined in initialize_shell_signals before
! 	  trying to use it in sigdelset() (DJGPP fix)
! 
! 				   2/14
! 				   ----
! lib/sh/shtty.c
! 	- include <unistd.h> before <shtty.h>
! 	- separate tests for ONLCR, ONOCR, ONLRET to cope with systems like
! 	  DJGPP that don't implement the full POSIX termios option set
! 
! builtins/psize.sh
! 	- set TMPDIR only if it's not already set
! 
! lib/glob/glob.c
! 	- if a system doesn't define _POSIX_SOURCE but has a `struct dirent'
! 	  without a d_ino member, define REAL_DIR_ENTRY to 1 so all entries
! 	  are read
! 
! configure.in
! 	- check for <arpa/inet.h> header file
! 
! config.h.in
! 	- add HAVE_ARPA_INET_H define
! 
! lib/sh/inet_aton.c
! 	- don't compile unless HAVE_NETWORK, HAVE_NETINET_IN_H, and
! 	  HAVE_ARPA_INET_H are all defined in config.h or config-bot.h
! 
! 				   2/16
! 				   ----
! subst.c
! 	- if we have a construct like "${@:-}", we need to note that we're
! 	  not using whatever is in $@ (we're using the rhs), so the special
! 	  double-quoting $@ rules do not apply
! 
! 				   2/21
! 				   ----
! lib/readline/signals.c
! 	- declare SigHandler before using it on non-POSIX systems
! 
! lib/sh/{zread,zwrite}.c
! 	- include <sys/types.h> unconditionally
! 
! configure.in
! 	- m68k-motorola-sysv should be m68k-sysv in the section that sets
! 	  opt_bash_malloc to no for certain systems
! 
! builtins/complete.def
! 	- fixed a typo (stoppped) when printing out completion actions
! 
! 				   2/22
! 				   ----
! lib/sh/netopen.c
! 	- include <arpa/inet.h> if it's present
! 
! aclocal.m4
! 	- new macro, BASH_FUNC_INET_ATON, checks for inet_aton(3) including
! 	  <netinet/in.h> and <arpa/inet.h>, which some systems require to
! 	  resolve the function
! 
! configure.in
! 	- if autoconf can't fund inet_aton on its own, try BASH_FUNC_INET_ATON
! 
! pcomplete.c
! 	- fixed a memory leak in gen_wordlist_completions
! 	- changed gen_wordlist_completions to do prefix-matching against the
! 	  word being completed
! 
! doc/bash.1, lib/readline/doc/rluser.texinfo
! 	- documented the change in behavior of the -W option to complete and
! 	  compgen
! 
! builtins/umask.def
! 	- if parse_symbolic_mode() returns -1, symbolic_umask needs to return
! 	  -1 as well, otherwise the umask will be changed inappropriately
! 
! input.c
! 	- always compile in getc_with_restart and ungetc_with_restart
! 
! parse.y
! 	- yy_stream_get and yy_stream_unget now call getc_with_restart and
! 	  ungetc_with_restart, respectively, to avoid problems with some
! 	  systems not restarting the read(2) when signals that bash handles
! 	  are received during the read (since bash installs its signal
! 	  handlers without the SA_RESTART flag)
! 
! lib/readline/complete.c
! 	- don't default rl_completion_case_fold to 1 if __DJGPP__ is defined
! 
! 				   2/25
! 				   ----
! subst.c
! 	- renamed `varlist' to `subst_assign_varlist' and made it global
! 
! jobs.c
! 	- when running a SIGCHLD trap, need to unwind-protect
! 	  subst_assign_varlist and set it to NULL before running the trap
! 	  command (fix from ericw@bestnet.org and doogie@debian.org)
! 
! 				   2/28
! 				   ----
! lib/readline/doc/rltech.texinfo
! 	- document rl_funmap_names()
! 
! 				   2/29
! 				   ----
! subst.c
! 	- change split_at_delims to set the current word more appropriately
! 	  when the cursor is between two words.  Should probably change this
! 	  again to set the current word like this only when the cursor is at
! 	  whitespace or another delim just before the word start
! 
! 				    3/1
! 				    ---
! lib/sh/shtty.c
! 	- more checks for flag bits being defined before using them
! 
! 				    3/7
! 				    ---
! variables.h
! 	- fix typo in COPY_EXPORTSTR definition 
! 
! 				   3/14
! 				   ----
! subst.c
! 	- changed split_at_delims so that if the cursor is at whitespace
! 	  between words, and we're interested in the current word (cwp != NULL),
! 	  make a new empty word and set the cwp to that word
! 
! locale.c
! 	- support for setting LC_NUMERIC locale category based on value of
! 	  LC_NUMERIC shell variable
! 
! variables.c
! 	- LC_NUMERIC is now treated specially
! 
! doc/{bash.1,bashref.texi}
! 	- LC_NUMERIC updates
! 
! 				   3/15
! 				   ----
! pcomplete.c
! 	- fix to avoid freeing memory twice
! 
! 				   3/17
! 				   ----
! [bash-2.04 released]
! 
! 				   3/20
! 				   ----
! doc/bash.1
! 	- minor typo fix to description of `xpg_echo' option in `echo'
! 	  description
! 
! 				   3/23
! 				   ----
! parse.y
! 	- minor fix to parse_string_to_word_list to allow newlines in
! 	  compound array assignments
! 
! 				   3/27
! 				   ----
! lib/readline/rltty.c
! 	- fixed a missing-semicolon syntax error in the old 4.3 BSD tty code
! 
! support/mksignames.c
! 	- if SIGRTMAX is >= 2*NSIG, just #undef SIGRTMIN and SIGRTMAX.  This
! 	  is an issue on AIX 4.3 (only, so far) -- checked by configure, which
! 	  #defines UNUSABLE_RT_SIGNALS if this is the case
! 
! aclocal.m4
! 	- new macro, BASH_CHECK_RTSIGS, checks whether or not real-time
! 	  signals are defined with large values and defines UNUSABLE_RT_SIGNALS
! 	  if they are
! 
! config.h.in
! 	- place marker for UNDEF_RT_SIGNALS (initially undefined)
! 
! configure.in
! 	- call BASH_CHECK_RTSIGS in the `bash miscellaneous' section
! 
! 				   3/29
! 				   ----
! 
! subst.c
! 	- fixed a problem in match_pattern_char, where `string' was checked
! 	  for a paren following a [?+!@], rather than `pat'
! 	- the code that checks whether or not to exit after a failed
! 	  ${word?msg} substitution needs to check interactive_shell rather
! 	  than interactive to avoid exiting if such a construct appears in
! 	  a sourced file
! 
! 				   3/31
! 				   ----
! 
! bashline.c
! 	- add `{' to the list of characters that need to be quoted by the
! 	  completion code when appearing in a filename
! 
! 				    4/1
! 				    ---
! lib/glob/fnmatch.c
! 	- fixed an error in brackmatch() while skipping the rest of a bracket
! 	  expression after a character matched.  When `c' was a backslash and
! 	  *p was a backslash, as in a pattern like [/\\], the old code didn't
! 	  take both backslashes into account and ended up skipping the `]'
! 	  after erroneously concluding that it was quoted.  Report and fix
! 	  from akim@epita.fr
! 
! 				    4/3
! 				    ---
! lib/readline/rltty.c
! 	- slight change to the BSD tty interface code, so that if the first
! 	  ioctl fails, get_tty_settings returns -1 immediately
! 	- better checking of ioctl return values in BSD tty version of
! 	  get_tty_settings
! 
! 				    4/5
! 				    ---
! doc/{bash.1,bashref.texi}
! 	- documented use of LINES and COLUMNS variables
! 
! 				   4/12
! 				   ----
! lib/readline/rltty.c
! 	- change the SETATTR define for the termio tty driver to use
! 	  TCSETAW (the analog of the termios TCSADRAIN)
! 
! lib/glob/fnmatch.c
! 	- fix for posix-style bracket expressions ([:xxx:], [=x=]) broken
! 	  by fix of 4/1 for quotes in bracket expressions
! 
! 				   4/26
! 				   ----
! subst.c
! 	- fix to list_string and get_word_from_string to make a non-whitespace
! 	  IFS character preceded by IFS whitespace part of the current field
! 	  delimiter, not a separate delimiter that would result in a separate
! 	  null field when splitting.  cf POSIX.2, 3.6.5, (3)(b).  Bug reported
! 	  by amc@cs.berkeley.edu
! 	- changed the behavior of the (currently undocumented) ${!prefix@}
! 	  expansion to be analogous to the expansion of $@ in other contexts
! 	  when double-quoted.  ksh93 seems to do this.  Bug reported by
! 	  Ken Pizzini <ken@halcyon.com>
! 	- changed read_comsub to ignore NUL bytes in the command substitution
! 	  output, printing a warning message for now
! 
! parse.y
! 	- changed shell_getc to ignore NUL bytes in the input, printing a
! 	  warning message for now
! 	- changed read_a_line to print a warning when a NUL byte is encountered,
! 	  like shell_getc does
! 
! 				   5/18
! 				   ----
! subst.c
! 	- make sure split_at_delims uses d2 only if it's non-null
! 	- make split_at_delims skip leading newlines in the string to split,
! 	  if newline is a delimiter
! 
! jobs.c
! 	- prevent hanging processes by marking a child process as not running
! 	  (even if the shell thinks it is) when waitpid() returns -1/ECHILD --
! 	  this indicates that waitpid never returned a reasonable status
! 	  for that child though, which may be a symptom of another problem
! 
! builtins/cd.def
! 	- make `pwd' print an error message if the write fails when displaying
! 	  the current directory
! 
! lib/readline/histexpand.c
! 	- return NULL from history_find_word if history_tokenize_internal
! 	  returns (char **)NULL rather than attempting to dereference a
! 	  possibly-NULL pointer
! 	- change history_tokenize_internal to set *indp to -1 before any
! 	  processing if indp is non-null
! 
! 				   5/19
! 				   ----
! builtins/trap.def
! 	- when in POSIX.2 mode and printing trap dispositions, print the
! 	  signal name without the leading `SIG', as POSIX.2 requires
! 
! 				   5/23
! 				   ----
! lib/readline/readline.c
! 	- readline_initialize_everything now assigns $TERM to rl_terminal_name
! 	  if the application has left it unset, and calls _rl_init_terminal_io
! 	  with the resultant value
! 
! lib/readline/doc/rltech.texinfo
! 	- updated the description of rl_terminal_name to note initialization
! 
! parse.y
! 	- change parse_string_to_word_list to save and restore the value of
! 	  current_command_line_count before calling back into the parser --
! 	  it will screw up history if the string extends over one line.  Bug
! 	  reported by Jan.Djarv@mbox200.swipnet.se
! 
! 				    6/7
! 				    ---
! unwind_prot.h
! 	- change unwind_protect_string to pass the address of the variable to
! 	  unwind_protect_var on machines where ints and char *s are not the
! 	  same size
! 
! unwind_prot.c
! 	- make sure we save the value of a variable in unwind_protect_var on
! 	  machines where sizeof(char *) != sizeof(int), not the contents the
! 	  value points to.  Fix from Andreas Schwab <schwab@suse.de>
! 
! 				    6/8
! 				    ---
! configure.in
! 	- auto-configure MacOS X without bash malloc (like Rhapsody)
! 
! 				   6/12
! 				   ----
! configure.in
! 	- replace `cygwin32' with `cygwin'
! 
! builtins/evalfile.c
! 	- in _evalfile, change all instances of \r to \n in the file to be
!           sourced and evaluated if __CYGWIN__ is defined
! 
! input.c
! 	- change \r to \n in the buffer argument to make_buffered_stream and
!           after calling zread() from b_fill_buffer if __CYGWIN__ is defined
! 
! 				   6/29
! 				   ----
! lib/sh/Makefile.in
! 	- add rest of dependency rules for makepath.o
! 
! 				    7/3
! 				    ---
! jobs.c
! 	- changed `int' to `WAIT' in a couple of places for non-POSIX
! 	  environments
! 
! 				    7/5
! 				    ---
! locale.c
! 	- try to avoid an unnecessary memory allocation in localetrans() in
! 	  the case that a translation for the string exists
! 
! lib/readline/doc/rluserman.texinfo
! 	- change the `direntry' information to make it use rluserman instead
! 	  of readline
! 
! 				    7/6
! 				    ---
! execute_cmd.c
! 	- changes to execute_in_subshell so it honors a `!' prefixing a command
! 	  inside a user subshell (...)
! 
! support/config.{guess,sub}
! 	- add cases for Apple Darwin (Mac OS X)
! 
! configure.in
! 	- Apple Darwin (MacOS X) uses its own malloc
! 
! lib/readline/readline.h
! 	- removed bogus extern declaration of savestring
! 
! 				    7/7
! 				    ---
! builtins/common.c
! 	- in get_working_directory, don't count on getcwd returning anything
! 	  useful in the buffer passed as the first argument on failure; just
! 	  use bash_getcwd_errstr in the error message
! 
! examples/loadables/cut.c
! 	- loadable version of cut(1), from the FreeBSD source tree
! 
! 				   7/18
! 				   ----
! lib/readline/vi_mode.c
! 	- changed two instances of (*rl_getc_function) (rl_instream) to calls
! 	  to rl_read_key(), which works better when using the readline
! 	  callback interface
! 
! builtins/evalfile.c
! 	- added FEVAL_CHECKBINARY flag for _evalfile; controls whether a check
! 	  for a binary file is performed
! 	- FEVAL_CHECKBINARY is not set by source_file or maybe_execute_file,
! 	  which means that the startup file execution and the `.' builtin will
! 	  not check for binary files
! 	- FEVAL_CHECKBINARY is not set by fc_execute_file, so that files
! 	  composed of history commands run by the `fc' builtin will not check
! 	  for binary files
! 
! 				   7/21
! 				   ----
! shell.c
! 	- added `--init-file' as a synonym for `--rcfile'
! 
! 				   7/26
! 				   ----
! support/shobj-conf
! 	- added commented-out stanzas for hpux 10 and hpux 11 when the HP
! 	  unbundled ANSI C compiler is being used
! 
! 				   7/27
! 				   ----
! shell.c
! 	- don't call end_job_control() from exit_shell if subshell_environment
! 	  is non-zero, even if the shell is interactive
! 
! 				    8/1
! 				    ---
! bashhist.c
! 	- change maybe_add_history to remember if we saved the first line of
! 	  a command and don't save the second and subsequent lines of a
! 	  multi-line command if we didn't save the first line
! 
! configure.in, config.h.in
! 	- add autoconf check for getservbyname()
! 
! lib/sh/netopen.c
! 	- add support for named services in /dev/(tcp|udp)/host/service
! 	  translation
! 	- make sure _netopen sets errno to something other than 0 if something
! 	  goes wrong, so the redirection functions behave
! 
! 				    8/3
! 				    ---
! parse.y
! 	- changes to shell_getc so that history saving of blank lines in
! 	  multi-line commands does a better job of syntactic correctness
! 
! bashline.c
! 	- bind ^O to operate-and-get-next in emacs_standard_keymap explicitly,
! 	  rather than letting rl_add_defun do it in whatever keymap is current
! 
! 				    8/4
! 				    ---
! builtins/ulimit.def
! 	- removed some of the special handling of RLIM_INFINITY -- the old
! 	  code would let people use RLIM_INFINITY as a shorthand for setting
! 	  the soft limit to the hard limit.  Now, the code just passes
! 	  RLIM_INFINITY through if the hard limit is being set, so any kernel
! 	  errors will get through
! 
! 				   8/10
! 				   ----
! parse.y
! 	- change the grammar rule for group_command so that it's composed of
! 	  a compound_list instead of a list, which requires a terminator
! 	  This means that you can now do (legal) things like
! 
! 		{ { echo a b c ; } }
! 
! 	  since the second close brace will be recognized as such because a
! 	  reserved word is legal in that context
! 
! 				   8/23
! 				   ----
! subst.c
! 	- fix parameter_brace_substring to free all memory allocated by
! 	  get_var_and_type in the VT_ARRAYMEMBER case (returned parameter
! 	  `val')
! 
! 				   8/30
! 				   ----
! variables.c
! 	- now that we have dynamic array variables, remove the check for
! 	  array_p in bind_variable and let array variables with assignment
! 	  functions call the assignment function
! 
! subst.c
! 	- change cond_expand_word to perform tilde expansion (like it should
! 	  have done all along)
! 
! lib/readline/complete.c
! 	- don't allow backslash to quote anything inside a single-quoted
! 	  string in find_completion_word
! 
! doc/{bash.1,bashref.texi}
! 	- note that `set -a' will cause functions to be exported
! 
! lib/readline/parens.c
! 	- changed the blink timeout so it's settable by the application.  A
! 	  new function, int rl_set_paren_blink_timeout (int u), (still
! 	  undocumented) will set the timeout to U usec
! 
! variables.c
! 	- at startup of an interactive login shell, if the current directory
! 	  is $HOME, and $HOME and $PWD are not the same, set the current
! 	  directory (and $PWD) to $HOME
! 	- break code that initializes $PWD and $OLDPWD into set_pwd function
! 
! variables.h
! 	- new extern declaration for set_pwd()
! 
! 				    9/6
! 				    ---
! lib/readline/{readline,callback}.c
! 	- allocate memory for rl_prompt instead of simply using what's passed
! 	  as the `prompt' argument to readline() or
! 	  rl_callback_handler_install().  This will allow constant strings to
! 	  be passed to readline(), since the prompt processing code wants to
! 	  write to rl_prompt
! 
! lib/sh/pathcanon.c
! 	- new file, does pathname canonicalization
! 
! externs.h
! 	- extern declarations for stuff in lib/sh/pathcanon.c
! 
! general.c
! 	- canonicalize_pathname now simply calls sh_canonpath()
! 
! 				    9/7
! 				    ---
! pcomplete.h
! 	- new member in a `struct compspec': options
! 	- define some flag values for options field
! 
! pcomplib.c
! 	- make sure options field is allocated and copied by compspec utility
! 	  functions
! 
! builtins/complete.def
! 	- add struct for completion options.  These control the `meta-behavior'
! 	  of the compspec.  Initially, there are three:
! 
! 		default - perform bash default completion if programmable
! 			  completion produces no matches
! 		dirnames - perform directory name completion if programmable
! 			   completion produces no matches
! 		filenames - tell readline that the compspec produces filenames,
! 			    so it can do things like append slashes to
! 			    directory names and suppress trailing spaces
! 
! 	- add `-o option' to complete and compgen, setting new options field
! 	  in a compspec
! 	- add code to display any -o options when a compspect is printed
! 	  with the `-p' option to complete
! 
! pcomplete.c
! 	- programmable_completions now passes back to the caller in the last
! 	  argument any options associated with the active compspec (from the
! 	  options field)
! 	- change gen_compspec_completions to re-call gen_action_completions
! 	  with a CA_DIRECTORY action if the rest of the compspec actions
! 	  generate no matches and the COPT_DIRNAMES option is present
! 
! bashline.c
! 	- if a programmable completion was specified to return filenames with
! 	  the `-o filenames' option, set rl_filename_completion_desired to 1
! 	  so readline does its special filename-specific things
! 	- if a compspec was defined to fall back to the readline default with
! 	  the `-o default' option, suppress setting the
! 	  rl_attempted_completion_over variable in attempt_shell_completion
! 	  so readline will go on and do filename completion
! 
! include/ansi_stdlib.h
! 	- add extern declarations for atof and strtod
! 
! builtins/printf.def
! 	- change getdouble() to use strtod (since we provide a version in
! 	  libsh if the C library doesn't have one), and change the calling
! 	  convention to match the other getXXX functions (take value pointer
! 	  as argument, return success or failure).  This makes printf handle
! 	  invalid floating point numbers better
! 
! doc/bash.1, lib/readline/doc/rluser.texinfo
! 	- documented new `-o' option to complete and compgen; described the
! 	  arguments and their effects
! 
! lib/readline/{macro,util}.c
! 	- renamed _rl_executing_macro to rl_executing_macro; made it public
! 
! lib/readline/readline.h
! 	- new extern declaration for rl_executing_macro
! 
! lib/readline/rltech.texinfo
! 	- documented rl_executing_macro
! 
! 				    8/8
! 				    ---
! lib/readline/readline.c
! 	- new state variable, rl_readline_state
! 
! lib/readline/readline.h
! 	- extern declaration for rl_readline_state
! 	- define some flag bits for rl_readline_state and macros to test and
! 	  set them
! 
! lib/readline/{readline,complete,isearch,macro,rltty,search,signals,undo,vi_mode}.c
! 	- added calls to the macros that set and unset various readline states
! 
! lib/readline/readline.c
! 	- new private function, _rl_free_saved_history_line, to free up the
! 	  history entry saved in saved_line_for_history
! 
! lib/readline/search.c
! 	- free any saved history entry in rl_history_search_reinit(), because
! 	  rl_get_previous_history makes a call to maybe_save_line without
! 	  freeing up the saved line when it returns (so rl_get_next_history
! 	  can use it)
! 	- fix up noninc_search_from_pos to deal with invalid history indices
! 	  better
! 
! 				   9/12
! 				   ----
! support/shobj-conf
! 	- HPUX 11.0 needs the `-fpic' flag passed to the linker as well as
! 	  the compiler
! 
! execute_cmd.c
! 	- on MS-DOS systems, let the #! checking stuff in execute_shell_script
! 	  treat \r as EOL (identical to \n)
! 
! input.c
! 	- on DJGPP systems, allow buffered_getchar to ignore \r.  Change
! 	  suggested by snowball3@bigfoot.com
! 
! 				   9/13
! 				   ----
! lib/sh/tmpfile.c
! 	- new file, with functions for creating and (hopefully safely) opening
! 	  temporary files for the shell
! 
! externs.h
! 	- extern declarations for functions in tmpfile.c
! 
! variables.c
! 	- new function, get_random_number, returns random values from the
! 	  shell's (lame) RNG to the rest of the shell
! 
! variables.h
! 	- new extern declaration for get_random_number()
! 
! subst.c
! 	- changed make_named_pipe to call sh_mktmpname instead of mktemp
! 
! redir.c
! 	- changed here_document_to_fd to call sh_mktmpfd instead of using
! 	  inline code
! 
! builtins/fc.def
! 	- changed fc_builtin to call sh_mktmpfp instead of using inline code
! 
! builtins/common.h
! 	- new extern declaration for fc_execute_file()
! 
! bashline.c
! 	- if RL_ISSTATE(RL_STATE_INITIALIZED) is 0 in initialize_readline,
! 	  call rl_initialize to bind the defaults before setting up our
! 	  custom shell functions and key bindings
! 
! lib/readline/doc/{rluser,hsuser}.texinfo
! 	- some markup changes proposed by dima@chg.ru
! 
! lib/readline/rlstdc.h, lib/tilde/tilde.h
! 	- to get ready for some `const' changes to the source, define const
! 	  as either `__const' (gcc -traditional) or nothing if __STDC__ and
! 	  __cplusplus are not defined
! 
! lib/readline/readline.c
! 	- upped the default readline version to `4.2-alpha'
! 
! lib/readline/readline.[ch]
! 	- readline now takes a `const char *' as an argument
! 
! lib/readline/history.h
! 	- read_history(), read_history_range(), write_history(),
! 	  append_history(), history_truncate_file() now take `const char *'
! 	  filename arguments
! 
! lib/readline/histfile.c
! 	- history_filename(), read_history(), read_history_range(),
! 	  write_history(), append_history(), history_truncate_file(),
! 	  history_do_write() now take `const char *' filename arguments
! 
! lib/readline/readline.h
! 	- rl_read_init_file() now takes a `const char *' filename argument
! 
! lib/readline/bind.c
! 	- current_readline_init_file is now a `const char *'
! 	- _rl_read_init_file(), rl_read_init_file() now take `const char *'
! 	  filename arguments
! 
! lib/tilde/tilde.c
! 	- tilde_expand(), tilde_expand_word() now take a `const char *'
! 	  as their first argument
! 
! lib/readline/chardefs.h
! 	- fixed CTRL_CHAR macro to be right on systems where chars are unsigned
! 	  by default
! 
! 				   9/14
! 				   ----
! lib/readline/doc/{rl,hs}tech.texinfo
! 	- documented new `const char *' function arguments where appropriate
! 
! lib/readline/vi_mode.c
! 	- clamp the numeric argument in vi mode at 999999, just like in emacs
! 	  mode
! 
! lib/readline/doc/rltech.texinfo
! 	- documented rl_readline_state and its possible bit values
! 
! builtins/source.def
! 	- in maybe_pop_dollar_vars, don't overwrite a shell function's
! 	  argument list even if the sourced script changes the positional
! 	  parameters
! 
! lib/readline/{util.c,rlprivate.h}
! 	- made _rl_strindex() and _rl_savestring() take `const char *'
! 	  arguments
! 
! 				   9/15
! 				   ----
! subst.c
! 	- renamed `doing_completion' to `no_longjmp_on_fatal_error', a more
! 	  accurate description of its current behavior
! 
! pcomplete.[ch], externs.h, lib/sh/stringlist.c
! 	- moved the stringlist code from pcomplete.c to lib/sh/stringlist.c
! 	- moved the type declaration and extern function declarations from
! 	  pcomplete.h to externs.h
! 
! stringlib.c, externs.h, lib/sh/stringvec.c
! 	- moved the char array code from stringlib.c to lib/sh/stringvec.c
! 
! 				   9/18
! 				   ----
! subst.c
! 	- new static variable, expand_no_split_dollar_star, to ensure that
! 	  $* isn't `split and rejoined' when expanded via a call to
! 	  expand_string_unsplit or expand_word_no_split
! 
! 				   9/19
! 				   ----
! subst.[ch], execute_cmd.c
! 	- renamed expand_word_no_split to expand_word_unsplit
! 
! copy_cmd.c
! 	- in copy_word, just assign w->flags to new_word->flags rather than
! 	  bcopying the entire structure
! 
! configure.in, config.h.in
! 	- add autoconf check for pathconf(3)
! 
! lib/sh/tmpfile.c
! 	- test for systems with short filenames using pathconf and
! 	  _PC_NAME_MAX, so generated temp file names don't exceed that length
! 	  (only do this if the file name length is less than 32, since the
! 	  current code doesn't generate filenames longer than about 17 chars)
! 
! 				   9/20
! 				   ----
! command.h
! 	- added `W_NOSPLIT2' word flag to prepare for supporting weird $@
! 	  expansion on the rhs of assignment statements (inspecting the ksh93
! 	  behavior, it seems like nothing except $@ is split, and $@ is split
! 	  on $IFS and rejoined as a single string)
! 
! 				   9/21
! 				   ----
! subst.c
! 	- since verify_substring_values looks for arithmetic expressions
! 	  bounded by `:', do some ad-hoc parsing of the substring passed as
! 	  the argument to avoid cutting the expression off at the wrong `:'
! 	  (since the inclusion of conditional expressions, expressions may
! 	  contain a `:').  Do some paren balancing, too.
! 
! 				   9/22
! 				   ----
! command.h
! 	- new #define, CLOBBERING_REDIRECT, evaluates to true for any redirect
! 	  that will clobber a file and should be subject to `noclobber'
! 
! redir.c
! 	- changed redir_open to use CLOBBERING_REDIRECT instead of
! 	  OUTPUT_REDIRECT.  This means that <> no longer tests the value of
! 	  noclobber, as POSIX.2 specifies
! 
! parse.y
! 	- made a change to cond_term so that expressions like [[ (x) ]] are
! 	  parsed correctly
! 
! 				   9/25
! 				   ----
! parse.y
! 	- small change to grammar for arith_for_command and special_case_tokens
! 	  to allow `do...done' or {...} after ((...)) without an intervening
! 	  list_terminator (for ksh93 compatibility)
! 
! builtins/printf.def
! 	- `printf' now treats \E and \e the same when performing backslash
! 	  escape expansion for the %b format character for compatibility with
! 	  $'...' quoting (for ksh93 compatibility)
! 
! 				   9/26
! 				   ----
! builtins/source.def
! 	- new variable, source_searches_cwd, initially 1.  If non-zero, `.'
! 	  searches $PWD for the filename argument if it's not found in $PATH
! 
! general.c
! 	- changed posix_initialize to turn off source_searches_cwd if posix
! 	  mode is being enabled; turn it on if posix mode is being disabled
! 	- changed things so interactive_comments is not turned off if posix
! 	  mode is disabled, since that's rarely what is desired
! 
! variables.c
! 	- changed uidset() to set UID and EUID only if they are not already
! 	  set when the shell starts up
! 	- changed things to HOSTNAME is set only if it's not set when the
! 	  shell starts up
! 
! execute_cmd.c
! 	- changed execute_builtin_or_function so that if a command like
! 	  `command exec 4<file' is executed, the effect is as if the `command'
! 	  had been omitted, as POSIX.2 requires
! 
! subst.c
! 	- changed array_length_reference to support ${foo[X]} when foo is not
! 	  an array variable and X is 0, @, or * (everything else returns 0)
! 	  for ksh compatibility
! 	- changed array_value_internal to support ${foo[@]} and ${foo[*]}
! 	  when foo is not an array variable (as ksh does)
! 
! 				   9/27
! 				   ----
! general.h
! 	- added defines for ABSPATH (absolute pathname), RELPATH (relative
! 	  pathname, and ROOTEDPATH (pathname rooted at /), with different
! 	  definitions for Unix and Cygwin
! 	- added defines for DIRSEP (the directory separator in pathnames,
! 	  and ISDIRSEP (whether a particular character is the directory
! 	  separator)
! 	- added PATHSEP define: takes a character and decides whether it
! 	  delimits a filename component of a pathname
! 	- changed isletter(c) #define to just call isalpha(c)
! 
! lib/sh/pathcanon.c
! 	- changed to use new pathname #defines from general.h above
! 
! general.c
! 	- changed make_absolute, absolute_pathname to understand
! 	  Cygwin's idea of an absolute pathname: [[:upper:][:lower:]]:/
! 	- rewrote absolute_pathname to use PATHSEP and ABSPATH
! 	- changed full_pathname to use ABSPATH
! 
! variables.c
! 	- changed get_bash_name to use ABSPATH and RELPATH, and to handle the
! 	  case when $PWD is unset when it is called
! 
! subst.c
! 	- if compiling on cygwin, translate \r\n to \n when reading the output
! 	  of a command substitution in read_comsub()
! 
! 				   9/28
! 				   ----
! input.c, shell.c, builtins/read.def, lib/tilde/tilde.c
! 	- changed __CYGWIN32__ to __CYGWIN__
! 
! lib/readline/{bind,funmap,kill}.c, lib/readline/readline.h
! 	- changed __CYGWIN32__ to __CYGWIN__
! 
! input.c
! 	- a couple of minor changes to clean up the code
! 
! parse.y
! 	- changed shell_getc and shell_ungetc to implement one character of
! 	  lookahead/lookbehind when pushing a character back at the start
! 	  of an input line (the old code would have discarded it because
! 	  shell_input_line_index was 0)
! 
! lib/readline{histsearch.c,history.h}
! 	- history_search_internal, history_search, history_search_prefix,
! 	  history_search_pos now take const char * string arguments
! 
! lib/readline/{histexpand.c,history.h}
! 	- get_history_event, history_arg_extract, history_tokenize_internal,
! 	  history_tokenize now take const char * string arguments
! 
! lib/readline/{history.c,history.h}
! 	- add_history, replace_history_entry now take const char * string
! 	  arguments
! 
! lib/readline/{bind.c,readline.h}
! 	- rl_add_defun, rl_unbind_command_in_map, rl_set_key, rl_macro_bind,
! 	  rl_generic_bind, rl_translate_keyseq, rl_named_function,
! 	  rl_function_of_keyseq, rl_variable_bind, rl_get_keymap_by_name
! 	  now take const char * string arguments where appropriate
! 	- rl_function_dumper, rl_list_funmap_names needed changes to deal
! 	  with rl_funmap_names returning const char **
! 	- rl_readline_name is now a const char * variable
! 
! lib/readline/keymaps.h
! 	- duplicate definition of rl_get_keymap_by_name needs const changes
! 
! lib/readline/{bind.c,rlprivate.h}
! 	- _rl_bind_if_unbound takes a const char * string argument
! 
! lib/readline/{funmap.c,readline.h}
! 	- rl_add_funmap_entry now takes a const char * string argument
! 	- rl_funmap_names now returns a const char **
! 	- a FUNMAP now has a const char *name member
! 
! lib/readline/{terminal.c,readline.h,rlprivate.h}
! 	- _rl_init_terminal_io, rl_get_termcap, rl_reset_terminal,
! 	  _rl_output_some_chars now take const char * string arguments
! 
! lib/readline/{readline.[ch],rlprivate.h}
! 	- rl_library_version and rl_terminal_name are now const char *
! 	  variables
! 	- rl_insert_text, _rl_replace_text now take const char * string
! 	  arguments
! 
! lib/readline/{callback.c,readline.h}
! 	- rl_callback_handler_install takes a const char * string argument
! 
! lib/readline/doc/{rltech,hstech}.texinfo
! 	- changed documentation for newly-consted functions and variables
! 
! lib/readline/{complete.c,readline.h}
! 	- rl_strpbrk now takes const char * string arguments
! 	- username_completion_function and filename_completion_function
! 	  now take const char * string arguments
! 	- rl_basic_word_break_characters, rl_basic_quote_characters,
! 	  rl_completer_word_break_characters, rl_completer_quote_characters,
! 	  rl_filename_quote_characters, rl_special_prefixes are all
! 	  const char * variables
! 
! lib/readline/{display.c,rlprivate.h}
! 	- _rl_move_cursor_relative takes a const char * string argument
! 
! redir.c
! 	- change from tbisp@uswest.net to fix a problem with cygwin and
! 	  here_document_to_fd, since cygwin doesn't allow a file to be
! 	  unlinked if there is a descriptor open on it
! 
! display.c
! 	- fixed a slight bug in the logic deciding whether or not to redraw
! 	  a prompt containing invisible characters in update_line.  Fixes
! 	  bug reported by bdluevel@heitec.net
! 
! 				   9/29
! 				   ----
! shell.c
! 	- fixed a problem with a too-aggressive setting of restricted shell
! 	  mode based on shell_name.  Old code set `restricted' even after a
! 	  longjmp due to shell_execve trying to execute an executable script
! 	  without a leading `#!', though that case should result in an
! 	  unrestricted shell
! 
! 				   10/2
! 				   ----
! copy_cmd.c
! 	- make sure copy_function_def copies the `flags' and `line' members
! 	  of the function_def
! 
! parse.y
! 	- make the function_def production take a new function_body parse
! 	  unit, which is currently just a group_command (in prep for future
! 	  changes)
! 
! builtins/printf.def
! 	- changed getint, getlong, getulong, getdouble to print warnings on
! 	  range errors and return the clamped values that strtol/strtod
! 	  return, as POSIX.2 specifies
! 
! 				   10/3
! 				   ----
! parse.y
! 	- made a function_def a `command' instead of a `shell_command'
! 	  This makes the grammar more closely resemble that supplied in
! 	  the POSIX.2 standard
! 	- made a `function_body' be like the function_body production in
! 	  the POSIX.2 standard.  This relaxes the restriction that the
! 	  body be composed of a group_command, but introduces a YACC
! 	  shift/reduce conflict
! 
! print_cmd.c
! 	- changes to named_function_string (for normal function printing)
! 	  and print_function_def (for printing function definitions embedded
! 	  in other commands) to print redirections that should be attached
! 	  to the function as a whole after the closing brace, because of
! 	  the changes to the parser
! 
! tests/func2.sub
! 	- tests for new function declarations whose bodies are not group
! 	  commands -- the command printing code still prints them with the
! 	  braces
! 
! 				   10/4
! 				   ----
! lib/sh/pathphys.c
! 	- new function, sh_physpath, resolves symlinks in pathname passed
! 	  as argument
! 
! builtins/cd.def
! 	- changed pwd_builtin to use sh_physpath if -P supplied or in
! 	  physical mode
! 	- changed bindpwd to use sh_physpath if the no_symlinks argument is
! 	  non-zero
! 	- changed change_to_directory to use sh_physpath and set
! 	  the_current_working_directory appropriately if the `nolinks'
! 	  argument is non-zero
! 
! 				   10/5
! 				   ----
! variables.c, bashline.c, builtins/cd.def
! 	- replaced calls to canonicalize_pathname with sh_canonpath
! 
! builtins/cd.def
! 	- rewrote change_to_directory to make it much shorter and simpler
! 
! command.h
! 	- added SUBSHELL_PIPE as possible flag value for subshell_environment
! 
! execute_cmd.c
! 	- execute_simple_command sets SUBSHELL_PIPE in subshell_environment
! 	  if the command has a pipe in or out
! 
! subst.c
! 	- don't reset pipeline_pgrp to shell_pgrp in command_substitute if
! 	  we're already in a pipline
! 	  ((subshell_environment & SUBSHELL_PIPE) != 0)
! 
! 				   10/6
! 				   ----
! subst.c 
! 	- change command_substitute to call setmode(fd, O_TEXT) on the pipe
! 	  file descriptor if __CYGWIN__ is defined; remove the other code
! 	  that converts CR/LF to LF on cygwin
! 
! 				   10/9
! 				   ----
! stringlib.c
! 	- change strcreplace() to make sure that RESIZE_MALLOCED_BUFFER is
! 	  called everywhere characters are added
! 
! 				   10/11
! 				   -----
! lib/sh/spell.c
! 	- new file, with the spelling correction code from builtins/cd.def
! 
! builtins/cd.def
! 	- a little surgery on cd_builtin, to make the structure clearer
! 
! 				   10/12
! 				   -----
! builtins/read.def
! 	- include fcntl.h and io.h on __CYGWIN__
! 	- set mode of fd 0 to O_TEXT if __CYGWIN__ and O_TEXT are both
! 	  defined
! 
! shell.c
! 	- in open_shell_script, set mode of fd opened to the shell script
! 	  to O_TEXT if __CYGWIN__ and O_TEXT are both defined
! 
! builtins/evalfile.c
! 	- changed the __CYGWIN__ code to call setmode(fd, O_TEXT) instead
! 	  of translating \r to \n after the read() returns
! 
! 				   10/13
! 				   -----
! lib/sh/strtrans.c, stringlib.c
! 	- moved ansicstr() from stringlib.c to new file lib/sh/strtrans.c
! 	- new function ansic_quote, to quote a string with $'...'
! 
! lib/sh/strindex.c, stringlib.c
! 	- moved strindex() from stringlib.c to new file lib/sh/strindex.c
! 
! lib/sh/Makefile.in
! 	- compile `shquote.c' in as part of the shell library
! 	- compile `strtrans.c' in as part of the shell library
! 	- compile `strindex.c' in as part of the shell library
! 
! Makefile.in
! 	- link with libsh before any of the readline libraries
! 
! builtins/common.c
! 	- removed the functions also appearing in lib/sh/shquote.c
! 
! externs.h, builtins/common.h
! 	- moved extern declarations for functions in lib/sh/shquote.c to
! 	  externs.h from builtins/common.h
! 
! variables.c
! 	- print_var_value (used in the output of `set') now calls
! 	  ansic_quote to quote the value, so any non-printable characters
! 	  are displayed
! 
! 				   10/14
! 				   -----
! syntax.h
! 	- new file, with definitions from shell.h having to do with shell
! 	  syntax, metacharacters, and quoting
! 
! parse.y
! 	- moved defines for shell metachars and other char class declarations
! 	  to syntax.h
! 
! shell.h
! 	- now includes syntax.h
! 
! Makefile.in,builtins/Makefile.in,lib/sh/Makefile.in
! 	- added syntax.h to appropriate dependency lists
! 
! 				   10/16
! 				   -----
! mksyntax.c
! 	- new program, to build a syntax table for the shell at compile time
! 
! Makefile.in
! 	- new generated file, syntax.c, generated by mksyntax
! 
! general.h
! 	- `digit(x)' is now just defined as `isdigit(x)'
! 
! syntax.h
! 	- now that we have sh_syntaxtab[], change the appropriate defines
! 	  to use it
! 
! parse.y, subst.c
! 	- change checks of member(c, slashify_in_quotes) to test
! 	  sh_syntaxtab[c] & CBSDQUOTE
! 
! builtins/set.def
! 	- corrected the help text for `unset', since PATH and IFS may be
! 	  unset
! 
! subst.c
! 	- changed explicit tests for shell special parameters using member()
! 	  or strchr() to test (sh_syntaxtab[c] & CSPECVAR) instead
! 	- changed some boilerplate calls to member() that test for validity
! 	  of various characters in the expansion process to macros for
! 	  efficiency
! 
! lib/sh/shquote.c
! 	- changed some of the functions to use checks against sh_syntaxtab[]
! 	  flag values
! 
! 				   10/19
! 				   -----
! findcmd.c
! 	- find_user_command_in_path no longer finds directories if the caller
! 	  specified FS_NODIRS in the flags argument.  This fixes the bug of
! 	  hashing directory names, at the loss of some information about
! 	  attempting to execute directories
! 
! builtins/hash.def
! 	- hash -p dirname name no longer puts directories into the hash table
! 
! 				   10/26
! 				   -----
! builtins/read.def
! 	- make sure that the last unwind-protect added is the one that calls
! 	  xfree(input_string), so that this is the top element on the
! 	  unwind-protect stack
! 	- if xrealloc() is called to increase the size of input_string, make
! 	  sure to remove the top element from the unwind-protect stack (the
! 	  old xfree) and add a new one, in case realloc() freed the original
! 	  input_string and allocated new space.  This fixes the bug of bash
! 	  crashing because it's trying to free already-freed memory if the
! 	  `read' is interrupted (reported by klausf@Pool.Informatik.RWTH-Aachen.DE)
! 
! 				   10/27
! 				   -----
! subst.c
! 	- fixed a problem in expand_word_list_internal so that
! 	  last_command_exit_value is set to 1 if a variable assignment fails
! 	  and a jump_to_top_level (DISCARD) is taken.  This fixes the problem
! 	  of assignment statements to read-only variables appearing to succeed
! 	  (though it always worked right in non-interactive posix-mode shells)
! 
! 				   10/30
! 				   -----
! lib/readline/readline.h
! 	- rl_completion_entry_function is now of type CPFunction *, since
! 	  that's the actual type that's used, and casting function pointers
! 	  of different types (which happened all the time as a result), is
! 	  problematic on some architectures
! 
! lib/readline/complete.c
! 	- changed entry function argument to gen_completion_matches to be of
! 	  type CPFunction *, since that's how it's used
! 	- changed variables that are completion entry function pointers to be
! 	  of type CPFunction *, removed problematic typecasts
! 
! lib/readline/doc/rltech.texinfo
! 	- documented type change for rl_completion_entry_func
! 
! lib/readline/rltypedefs.h
! 	- new file, with all the readline function typedefs
! 
! lib/readline/rltypedefs.h
! 	- new typedef, rl_command_func_t, which is a function returning
! 	  an int
! 	- a KEYMAP_ENTRY now contains a pointer to an rl_command_func_t
! 	- new typedef, rl_compentry_func_t, which is a function returning
! 	  a char *
! 	- new typdef, rl_completion_func_t, which is a function returning
! 	  a char **
! 	- new typedef, rl_quote_func_t, which is a function returning a
! 	  char *
! 	- new typedef, rl_dequote_func_t, which is a function returning a
! 	  char *
! 	- new typedef, rl_compignore_func_t, which is a function returning a
! 	  char *
! 	- new typedef, rl_compdisp_func_t, which is a void function taking
! 	  a char **, int, int argument list
! 	- new typedef, rl_hook_func_t, which is a function taking no args
! 	  and returning an int (used for input and other hooks)
! 	- new typedef, rl_modterm_func_t, which is a void function tkaing
! 	  an int, used to modify terminal (rl_prep_term_function)
! 	- new typedef, rl_getc_func_t, which is an int-returning function
! 	  that takes a FILE *
! 	- new typedef, rl_linebuf_func_t, which takes a string and an int
! 	  index and returns an int
! 	- new generic typedefs, rl_intfunc_t and rl_voidfunc_t, which are
! 	  functions which take and return int and void, respectively 
! 	- new generic typedef, rl_vintfunc_t, which takes an int and returns
! 	  void
! 	- new generic typedefs, rl_icpfunc_t and rl_vcpfunc_t, which take a
! 	  char * and return int and void, respectively
! 	- new generic typedefs, rl_icppfunc_t and rl_vcppfunc_t, which take
! 	  a char ** and return int and void, respectively
! 
! lib/readline/rlprivate.h
! 	- rl_last_func is now of type rl_command_func_t *
! 
! lib/readline/readline.c
! 	- declare rl_last_func as rl_command_func_t *
! 
! lib/readline/{bind,readline,vi_keymap,emacs_keymap,funmap,keymaps,isearch}.c
! lib/readline/readline.h
! 	- change appropriate cases of (Function *) to (rl_command_func_t *)
! 
! lib/readline/{readline.h,bind.c}
! 	- rl_named_function and rl_function_of_keyseq now return a
! 	  (rl_command_func_t *)
! 
! lib/readline/bind.c
! 	- changed type of functions in parser function table from Function *
! 	  to _rl_parser_func_t *
! 
! lib/readline/funmap.c
! 	- removed `vi-bracktype' from vi function map -- it's not a
! 	  bindable function
! 
! lib/readline/{readline.h,complete.c}
! 	- changed appropriate uses of CPFunction * to rl_compentry_func_t *
! 	  or rl_quote_func_t *
! 
! lib/readline/{rltty.c,readline.h}
! 	- rl_prep_term_function is now of type rl_vintfunc_t *
! 	- rl_deprep_term_function is now of type rl_voidfunc_t *
! 
! lib/readline/{keymaps,history.h}
! 	- include rltypedefs.h or <readline/rltypedefs.h> as appropriate
! 
! lib/readline/{display.c,readline.h}
! 	- rl_redisplay_func is now of type rl_voidfunc_t *
! 
! lib/readline/{callbacks.c,readline.h}
! 	- the `linefunc' argument to rl_callback_handler_install and the
! 	  rl_linefunc variable are now of type rl_vcpfunc_t *
! 
! lib/readline/{complete.c,readline.h}
! 	- rl_completion_display_matches_hook is now of type
! 	  rl_compdisplay_func_t *
! 	- rl_directory_completion_hook is now of type rl_icppfunc_t *
! 
! lib/readline/{history.h,histexpand.c}
! 	- history_inhibit_expansion_function is now of type
! 	  rl_linebuf_func_t *
! 
! lib/readline/histexpand.c
! 	- new private type, _hist_search_func_t, used to indirect through
! 	  the various history search functions
! 
! lib/tilde/tilde.h
! 	- new typedef, tilde_hook_func_t, which takes a char * and returns
! 	  a char *
! 
! lib/tilde/tilde.[ch]
! 	- tilde_expansion_preexpansion_hook and tilde_expansion_failure_hook
! 	  are now of type tilde_hook_func_t *
! 
! [THERE ARE NO LONGER ANY REFERENCES TO Function *, CPFunction *, or
! CPPFunction * IN THE READLINE SOURCE, WHICH INCLUDES THE TILDE LIBRARY]
! 
! {bashline,bracecomp}.c, bashline.h
! 	- changes for changed type of rl_completion_entry_func and other
! 	  changed types (rl_compentry_func_t, rl_completion_func_t,
! 	  const changes for prototypes, etc.)
! 
! pathexp.[ch]
! 	- shell_glob_filename now takes a `const char *' argument
! 	- quote_string_for_globbing now takes a `const char *' argument
! 
! 				   10/31
! 				   -----
! lib/sh/zwrite.c
! 	- fix zwrite() to update the buffer pointer in the case of a
! 	  partial write, in addition to decreasing the count of bytes to
! 	  be written
! 
! support/config.{guess,sub}
! 	- added entries for MIPS-based Compaq machines running NonStopUX
! 
! 				   11/1
! 				   ----
! lib/readline/undo.c
! 	- renamed free_undo_list to be rl_free_undo_list, made a dummy
! 	  replacement function free_undo_list that just calls
! 	  rl_free_undo_list
! 
! lib/readline/readline.h
! 	- extern declaration for rl_free_undo_list
! 
! lib/readline/{readline,signals}.c
! 	- changed calls to free_undo_list to rl_free_undo_list
! 
! lib/readline/doc/rltech.texinfo
! 	- changed all function types and arguments for new typedefs
! 
! 				   11/2
! 				   ----
! lib/readline/{rlprivate.h,terminal.c,display.c}
! 	- term_clreol, term_clrpag, term_cr, term_backspace, term_goto,
! 	  term_pc, term_im, term_ei, term_ic, term_ip, term_IC, term_dc,
! 	  term_DC, term_forward_char, term_up, term_mm, term_mo, term_ku,
! 	  term_kd, term_kr, term_kl, term_ks, term_ke, term_kh, term_kH,
! 	  terminal_can_insert variables all now have a _rl_ prefix
! 
! lib/readline/{rlprivate.h,terminal.c,display.c, readline.c}
! 	- screenheight, screenwidth, screenchars now have an _rl_ prefix
! 
! lib/readline/{terminal,complete,isearch,kill,macro,readline,search,undo,util,vi_mode}.c
! 	- changed calls to ding to calls to rl_ding
! 
! lib/readine/{isearch,readline,search}.c
! 	- saved_line_for_history now has an _rl_ prefix
! 
! lib/readline/readline.[ch]
! 	- renamed maybe_{replace,save,unsave} line to have an rl_ prefix
! 
! lib/readline/{readline,search,isearch}.c
! 	- changed calls to maybe_{replace,save,unsave} line to call the
! 	  rl_-prefixed equivalents
! 
! lib/readline/{rlprivate.h,readline.c,util.c}
! 	- renamed alphabetic to rl_alphabetic; changed calls
! 
! lib/readline/{bind.c,funmap.c,rlprivate.h}
! 	- possible_control_prefixes -> _rl_possible_control_prefixes
! 	- possible_meta_prefixes -> _rl_possible_meta_prefixes
! 
! lib/readline/compat.c
! 	- new file for entry points for backwards compatibility functions
! 	- moved free_undo_list here from undo.c
! 	- maybe_{replace,save,unsave}_line function that call their rl_
! 	  counterparts
! 	- moved ding() here; it just calls rl_ding()
! 	- moved alphabetic here; it just calls _rl_alphabetic()
! 
! lib/readline/Makefile.in
! 	- make sure compat.o is built and linked appropriately
! 
! bashline.c,pcomplete.c
! 	- changed calls to ding() to call rl_ding()
! 
! support/shobj-conf
! 	- changed linux stanza SHLIB_XLDFLAGS to make the `soname' in a
! 	  shared library have only the major version number, rather than
! 	  major and minor numbers
! 	- made analogous changes for bsd/os-4
! 	- changed freebsd 3.x stanza to match `freebsdelf[3-9]*' for
! 	  FreeBSD elf systems and `freebsdaout[3-9]*' for FreeBSD
! 	  a.out systems (are there any?)
! 
! lib/readline/doc/{rluser,hsuser}.texinfo
! 	- changed uses of @samp to @option where appropriate
! 
! doc/bashref.texi
! 	- changed uses of @samp to @option where appropriate
! 
! 				   11/3
! 				   ----
! lib/readline/{readline.h,complete.c,compat.c}
! 	- completion_matches, username_completion_function,
! 	  filename_completion_function all have an rl_ prefix
! 
! {bashline,bracecomp,pcomplete}.c
! 	- changed calls to completion_matches, username_completion_function,
! 	  and filename_completion_function
! 
! lib/sh/shquote.c
! 	- single_quote, double_quote, un_double_quote, backslash_quote,
! 	  backslash_quote_for_double_quotes, contains_shell_metas all now
! 	  have an sh_ prefix
! 
! externs.h
! 	- changed extern declarations for functions from shquote.c
! 
! {array,bashline,pcomplete,print_cmd,variables}.c, parse.y
! builtins/{alias,complete,trap,type}.def
! 	- changed callers of single_quote
! 
! {array,bashline}.c, builtins/setattr.def
! 	- changed callers of double_quote
! 
! {bashline,bracecomp}.c, parse.y, builtins/printf.def
! 	- changed callers of backslash_quote
! 
! parse.y
! 	- changed callers of backslash_quote_for_double_quotes
! 
! {print_cmd,variables}.c
! 	- changed callers of contains_shell_metas
! 
! lib/readline/{rlshell.h,shell.c,histexpand.c}
! 	- single_quote -> sh_single_quote
! 
! lib/readline/{rlshell.h,shell.c,input.c}
! general.[ch],shell.c,subst.c
! 	 - unset_nodelay_mode -> sh_unset_nodelay_mode
! 
! lib/readline/{rlshell.h,shell.c}, lib/tilde/tilde.c, variables.c
! 	- get_home_dir -> sh_get_home_dir
! 
! lib/readline/rlshell.h,lib/readline/bind,histfile,nls,readline,shell,terminal}.c, lib/tilde/tilde.c, variables.c
! 	- get_env_value -> sh_get_env_value
! 
! lib/readline/rlshell.h,lib/readline/{shell,terminal}.c
! variables.h,{jobs,nojobs,variables}.c
! 	- set_lines_and_columns -> sh_set_lines_and_columns
! 
! 				   11/6
! 				   ----
! configure.in
! 	- bash can only link with an already-installed readline library whose
! 	  version is 4.2 or greater
! 
! variables.h
! 	- new variable attribiute, noassign, with its accompanying test macro,
! 	  noassign_p.  Completely internal, not user-settable
! 
! execute_cmd.c
! 	- treat noassign variables like readonly variables, except an attempt
! 	  to assign to them does not cause a non-interactive shell in POSIX
! 	  mode to abort
! 
! {subst,variables}.c,builtins/declare.def
! 	- attempts to assign to `noassign' variables return an error status,
! 	  but no error messages -- almost identical to readonly variables
! 
! variables.c
! 	- GROUPS and FUNCNAME are `noassign' variables, meaning assignment to
! 	  them is disallowed, but that they may be unset (in which case they
! 	  lose their special properties)
! 
! doc/{bash.1,bashref.texi}
! 	- documented that assignments to GROUPS and FUNCNAME are disallowed
! 	  and return an error status
! 
! 				   11/8
! 				   ----
! lib/readline/{funmap.c,bind.c,rlprivate.h}
! 	- _rl_possible_{control,meta}_prefixes are now arrays of `const char *'
! 	  and are defined in bind.c, since that's where they're used
! 
! lib/readline/rltty.c
! 	- changed prepare_terminal_settings to take an `oldtio' argument
! 	  instead of `otio', which shadows the global declaration
! 
! lib/readline/bind.c
! 	- the `name' member of a parser_directive element is now a
! 	  `const char *'
! 	- the `name' member of a boolean_varlist element is now a
! 	  `const char *'
! 	- the `name' member of a string_varlist element is now a
! 	  `const char *'
! 	- the `name' member of an assoc_list element is now a
! 	  `const char *'
! 	- the `name' member of an keymap_names element is now a
! 	  `const char *'
! 
! lib/readline/display.c
! 	- changed scope-local char * variable `temp' to `vtemp' because
! 	  there's already a function local variable named `temp' of a
! 	  different type (int) in rl_redisplay
! 
! lib/readline/util.c
! 	- pathname_alphabetic_chars is now `const char *'
! 
! lib/readline/terminal.c
! 	- the `tc_var' member of a _tc_string element is now a
! 	  `const char *'
! 
! lib/readline/histexpand.c
! 	- changed history_expand_internal to remove the duplicate local
! 	  declaration of `t' in the `s'/`&' case
! 
! lib/readline/histfile.c
! 	- in history_filename, `home' is now a `const char *'
! 
! lib/tilde/tilde.c
! 	- default_prefixes and default_suffixes are now arrays of
! 	  `const char *'
! 
! lib/readline/vi_mode.c
! 	- vi_motion and vi_texmod are now `const char *'
! 
! lib/readline/complete.c
! 	- simplified the conditional declaration of getpwent()
! 
! variables.[ch]
! 	- get_string_value now takes a `const char *' argument
! 
! 				   11/10
! 				   -----
! display.c
! 	- changes to expand_prompt and rl_redisplay to keep track of the number
! 	  of invisible characters on the first line of the prompt, in case it
! 	  takes up more than one physical line, and not all invisible chars are
! 	  on the first line
! 	- the code that determines the index into the line at which to wrap the
! 	  first line if the visible prompt length exceeds the screen width was
! 	  changed to use the number of invisible chars in the first physical
! 	  prompt line rather than the total number of invisible characters
! 	- changed redraw_prompt to save and restore prompt_invis_chars_first_line
! 
! subst.c
! 	- changed expand_string_internal to savestring() the string argument
! 	  to avoid possible doubly-freed memory on substitution errors
! 	- fixed expand_word_list_internal so that commands with assignment
! 	  statements preceding words that expand to nothing return a failure
! 	  status if one of the assignments fails; for example
! 
! 		readonly TVAR
! 		TVAR=7 $ECHO $ABCDE
! 	- made sure that all cases of jump_to_top_level set
! 	  last_command_exit_value to something non-zero before jumping, since
! 	  they are by definition errors
! 
! builtins/evalstring.c
! 	- changed parse_and_execute to set last_result to EXECUTION_FAILURE
! 	  along with last_command_exit_value in the `DISPOSE' case of a
! 	  jump_to_top_level, since we can return this value in most
! 	  (interactive) circumstances
! 
! 				   11/14
! 				   -----
! general.c
! 	- fix legal_number so that it skips any trailing whitespace in its
! 	  string argument after strtol returns, since strtol does not
! 
! lib/readline/{complete.c,readline.h}
! 	- new function pointer, rl_directory_rewrite_hook, identical in effect
! 	  to rl_directory_completion_hook except that it does not modify what
! 	  is displayed when the possible completions are listed or inserted
! 
! bashline.c
! 	- changed tcsh_magic_space to try and insert a space closer to where
! 	  the point was originally, rather than always inserting it at the
! 	  end of the line
! 
! 				   11/16
! 				   -----
! jobs.c
! 	- fixed a bug that happened on cygwin systems that caused the jobs
! 	  table to fill up if a file sourced from an interactive shell ran
! 	  lots of jobs -- notify_and_cleanup() never called notify_of_job_status
! 
! subst.c
! 	- fixed pat_match to avoid infinite recursion on zero-length matches
! 	  from match_pattern
! 
! 				11/17/2000
! 				----------
! [bash-2.05-alpha1 released]
! 
! 				   11/18
! 				   -----
! support/shobj-conf
! 	- added GNU Hurd support, identical to linux
! 
! variables.c
! 	- cygwin systems don't use the exportstr stuff at all, so call
! 	  INVALIDATE_EXPORTSTR before testing var->exportstr, since just
! 	  blindly using the value_cell will break exported functions that
! 	  already have an exportstr set
! 	- when recomputing the exported value because valid_exportstr fails,
! 	  make sure to call named_function_string if the variable is a shell
! 	  function
! 
! 				   11/20
! 				   -----
! variables.c
! 	- removed call to valid_exportstr; the exportstr code has been
! 	  adequately debugged
! 
! lib/glob/fnmatch.c
! 	- reverted to the POSIX.2 behavior of using the current locale and
! 	  strcoll() to evaluate range expressions in bracket expressions
! 
! doc/{bash.1,bashref.texi}
! 	- added note to Pattern Matching section emphasizing that the current
! 	  locale plays a part in evaluating range expressions within [...]
! 
! aclocal.m4
! 	- added an #include <unistd.h> to the test for posix sigaction
! 	  restarting interrupted system calls
! 
! support/config.guess
! 	- changes from Tim Mooney to support `letter version' releases of
! 	  Tru 64 Unix on the Alpha (e.g., 5.1a)
! 
! 				   11/21
! 				   -----
! lib/sh/pathphys.c
! 	- make sure MAXSYMLINKS is defined
! 
! aclocal.m4
! 	- changed BASH_CHECK_PWFUNCS to just use AC_EGREP_CPP on a file
! 	  that includes pwd.h and other header files, checking for getpwuid.
! 	  It #defines HAVE_GETPW_DECLS if the egrep succeeds
! 
! lib/readline/complete.c
! 	- provide extern declaration of getpwent if _POSIX_SOURCE is defined,
! 	  since most systems don't declare it in <pwd.h> unless _POSIX_SOURCE
! 	  is undefined
! 
! 				   11/22
! 				   -----
! input.c
! 	- fixed a small typo in the cygwin-specific code
! 
! doc/{bashref.texi,bash.1}
! 	- added some more explanatory text about the effect of the current
! 	  locale's collating order on range expressions within bracket
! 	  expressions
! 
! doc/bashref.texi, lib/readline/doc/{rltech,rluser,hstech}.texinfo
! 	- changed to use @env instead of @code for the names of environment
! 	  and shell variables in text (not in tables yet)
! 
! 				   11/27
! 				   -----
! configure.in
! 	- configure without the bash malloc on Interix
! 
! lib/readline/doc/rltech.texinfo
! 	- changed completion_matches() to rl_completion_matches()
! 	- changed filename_completion_function() to
! 	  rl_filename_completion_function()
! 	- changed username_completion_function() to
! 	  rl_username_completion_function()
! 
! lib/readline/rlprivate.h
! 	- changed declaration of _rl_alphabetic to rl_alphabetic, since that's
! 	  what's used in the C files
! 
! support/bashbug.sh
! 	- Debian has /usr/bin/editor as a link to the system default editor;
! 	  make that one of the alternatives if $EDITOR is not set
! 	- if the OS provides mktemp(1) or tempfile(1), use those to create
! 	  the temp file for the bug report
! 
! lib/readline/{readline.[ch], callback.c}
! 	- new function, rl_set_prompt, called with prompt string as argument,
! 	  sets and, if necessary, expands rl_prompt
! 
! lib/readline/{complete.c,compat.c,readline.h}
! 	- rl_completion_matches now takes a `const char *' as its first
! 	  argument
! 	- compute_lcd_of_matches now takes a `const char *' as its third
! 	  argument
! 
! lib/readline/rltypedefs.h
! 	- a rl_completion_func_t now takes a `const char *' as its first
! 	  argument
! 
! lib/readline/Makefile.in
! 	- added dependencies on rltypedefs.h
! 
! bashline.c
! 	- attempt_shell_completion now takes a `const char *' as its first
! 	  argument
! 	- removed bogus cast when assigning to rl_attempted_completion_function
! 	  and rl_completion_entry_function
! 	- bash_directory_completion_matches takes a `const char *' argument
! 
! pcomplete.c
! 	- gen_matches_from_itemlist, pcomp_filename_completion_function,
! 	  gen_action_completions, gen_globpat_matches, gen_wordlist_matches,
! 	  gen_compspec_completions now take `const char *' arguments as
! 	  appropriate
! 	- programmable_completions now takes `const char *' first and 
! 	  second arguments
! 
! pcomplib.c
! 	- find_compspec now takes a `const char *' argument
! 
! 				   11/29
  				   -----
- shell.c
- 	- in open_shell_script, if we have /dev/fd, don't perform the check
- 	  for a binary file if isatty(fd) (where fd is opened on the script
- 	  name) returns non-zero
- 	- in open_shell_script, don't call init_noninteractive again, since it
- 	  can undo changes made by the startup files ($BASH_ENV)
  
! input.c
! 	- in fd_to_buffered_stream, make sure buffer size (and hence size
! 	  arg passed to read(2)) is greater than zero.  This makes
! 	  bash /dev/stdin work right.
! 	- return -1 from sync_buffered_stream immediately if buffers is NULL
! 	  (can happen when running `bash -i /dev/stdin' and executing a
! 	  command that requires a fork)
  
! 				   11/30
  				   -----
! jobs.c
! 	- renamed cont_signal_handler to sigcont_sighandler for consistency
! 	- renamed stop_signal_handler to sigstop_sighandler for consistency
! 	- if there is no jobs list or no outstanding jobs, return immediately
! 	  from notify_of_job_status, before fussing with the signal state
! 	- change map_over_jobs to not fuss with the signal state unless there
! 	  are jobs
! 
! lib/malloc/malloc.c
! 	- encapsulated the code to block and unblock signals during morecore()
! 	  execution into two functions:  block_signals and unblock_signals
! 	- only block signals in morecore() if interrupt_immediately is non-zero
! 	  or SIGINT or SIGCHLD is trapped
  
! 				   12/1
! 				   ----
! lib/readline/readline.c
! 	- fix to rl_forward to make sure that lend doesn't get set < 0, since
! 	  that will result in rl_point being < 0
  
! 				   12/5
! 				   ----
! parse.y
! 	- fix to parse_matched_pair to allow backslash to escape a ' inside a
! 	  $'...' construct inside another grouping construct like ${...}
! 	- translate $'...' and $"..." in parse_matched_pair, because nothing
! 	  else will do it if such a construct appears inside a grouping
! 	  construct
  
! 				   12/6
! 				   ----
! configure.in
! 	- make sure all bracket tests for pattern matching in case statements
! 	  are appropriately quoted, so autoconf doesn't swallow the brackets
! 	- add -rdynamic to LOCAL_LDFLAGS for freebsd-4.x
  
! examples/loadables/realpath.c
! 	- new loadable builtin, canonicalizes pathnames and expands symlinks
  
! builtins/ulimit.def
! 	- added undocumented -w option for setting RLIMIT_SWAP, if it's defined
  
! 				   12/7
! 				   ----
! bashline.c
! 	- reordered code in initialize_readline so all of the rl_add_defun
! 	  calls are made before the call to rl_initialize, and all of the
! 	  rl_{bind,unbind}_key_in_map calls are made after initializing
! 	  readline.  This allows the bash-specific function names to be used
! 	  in ~/.inputrc
  
! 				   12/12
! 				   -----
! lib/readline/callback.c
! 	- in rl_callback_read_char, loop after returning from
! 	  readline_internal_char and test rl_pending_input in case some
! 	  function (like the incremental search functions and digit argument
! 	  functions) pushed input back with rl_execute_next
  
! lib/readline/readline.h
! 	- new rl_state flag:  RL_STATE_INPUTPENDING, indicating that
! 	  rl_execute_next has pushed input back for rl_get_key to read
  
! lib/readline/input.c
! 	- new function to clear rl_pending_input: rl_clear_pending_input()
  
! lib/readline/{input,readline,signals}.c
! 	- when rl_pending_input is set, set state RL_STATE_INPUTPENDING;
! 	  unset that state when rl_read_key returns the pending input
! 	- call rl_clear_pending_input at appropriate points
  
! 				   12/15
! 				   -----
! lib/readline/histfile.c
! 	- don't leak file descriptors while attempting to truncate a non-regular
! 	  file
  
! input.c
! 	- make sure check_bash_input sets the close-on-exec flag for the file
! 	  descriptor used to save the bash input fd
  
! parse.y
! 	- if default_buffered_input gets changed while it's on the saved
! 	  stream stack, make sure it gets set to close-on-exec when it's
! 	  restored by pop_stream()
  
! 				   12/18
! 				   -----
! builtins/ulimit.def
! 	- change set_limit to account for Cygwin's setdtablesize() being
! 	  declared as a void function
  
! support/config.{guess,sub}
! 	- change cygwin32 to cygwin
  
! 				   12/20
  				   -----
! nojobs.c
! 	- make wait_sigint_handler handle the case of interrupt_immediately
! 	  being non-zero when it's called, and jump out appropriately
! 
! jobs.c
! 	- new function to run sigchld traps: run_sigchld_trap(); called from
! 	  waitchld
! 	- broke the code that computes the printable job status messages for
! 	  pretty_print_job out into a separate function
! 	- rearranged some code eliminating a useless `else' branch in wait_for
! 	- shell_tty_info is now a TTYSTRUCT, using defines from shtty.h
! 	- broke the code that sets a job's status after waitpid says its state
! 	  has changed and cleans up after a received SIGINT out into a separate
! 	  function: set_job_status_and_cleanup
! 	- last_stopped_job() -> job_last_stopped() to avoid collision with a
! 	  variable name
! 	- last_running_job() -> job_last_running() for consistency
  
! 				   12/21
! 				   -----
! variables.c
! 	- new function, print_func_list (SHELL_VAR **list); prints shell
! 	  functions from list in a form that may be re-used as input to
! 	  redefine the functions
  
! variables.h
! 	- new extern declaration for print_func_list
  
! builtins/set.def
! 	- set without options now calls print_func_list to have functions
! 	  printed in a way that can be reused as input (this affects
! 	  `declare' and `declare -p' also)
  
! 				   12/27
! 				   -----
! general.h
! 	- add an ISOCTAL define
  
! builtins/common.h
! 	- use ISOCTAL in read_octal function
  
! parse.y
! 	- in decode_prompt_string, don't just skip STRING forward by 3 if an
! 	  octal sequence is translated; handle sequences of fewer than three
! 	  characters by checking each character
  
! 				   12/28
  				   -----
  doc/{bash.1,bashref.texi}
! 	- make sure `vi-move' is a documented keymap argument to bind's
! 	  `-m' option
  
! 				   12/29
! 				   -----
! variables.c
! 	- change print_assignment so that functions are printed in a way that
! 	  may be reused as input (without the `=')
! 
! 				 1/2/2001
! 				 --------
! test.c
! 	- fix test_command to print an error message if `[' is supplied a
! 	  single argument that is not `]'
  
! support/shobj-conf
! 	- change test of $SHOBJ_CC from `gcc*' to `*gcc*' to handle full
! 	  pathnames
  
! 				   1/11
  				   ----
! execute_cmd.c
! 	- in initialize_subshell, zero out builtin_env, since those aren't
! 	  supposed to be exported
  
! variables.c
! 	- new function: shell_var_from_env_string, creates a SHELL_VAR from
! 	  a `name=value' style environment string and returns it
! 	- new function: bind_name_in_env_array(name, value, array), makes
! 	  NAME have VALUE in ARRAY, a temporary environment
! 	- new function: bind_tempenv_variable (name, value), makes NAME have
! 	  VALUE in one of the temporary environments -- temporary_env,
! 	  builtin_env, or function_env
! 	- changed bind_variable to call bind_tempenv_variable if one of the
! 	  temporary environments is non-null before modifying the
! 	  shell_variables table.  This fixes a problem with sourced scripts
! 	  modifying variables in a temporary environment, but not seeing the
! 	  updated values
  
! 				   1/12
! 				   ----
! variables.c
! 	- changed things so OSTYPE, HOSTTYPE, and MACHTYPE are set only if
! 	  they don't have a value at shell startup
  
! 				   1/17
! 				   ----
! builtins/fc.def
! 	- create temp file with MT_USETMPDIR
  
  variables.c
! 	- allow function local readonly variables to overwrite (or shadow)
! 	  other (calling) function readonly variables, but not global
! 	  readonly ones
! 
! builtins/wait.def
! 	- replace unwind_protect of interrupt_immediately, since that's a
! 	  variable that you cannot unwind-protect (the unwind-protect code
! 	  uses it)
  
! 				   1/22
  				   ----
- Makefile.in
- 	- changed RELSTATUS to `beta1'
- 
- lib/readline/terminal.c
- 	- added rl_set_screen_size function, wrapper around
- 	  _rl_set_screen_size so bash doesn't call _rl_ functions
- 
- lib/readline/{rlprivate,readline}.h
- 	- moved rl_explicit_arg to readline.h
- 	- moved rl_numeric_arg to readline.h
- 	- moved rl_editing_mode to readline.h
- 	- moved rl_last_func to readline.h
- 	- added rl_set_screen_size to readline.h
- 
- lib/readline/doc/rltech.texinfo
- 	- documented rl_explicit_arg, rl_editing_mode, rl_numeric_arg,
- 	  rl_last_func
- 	- documented rl_set_screen_size
- 
- {jobs,nojobs}.c
- 	- _rl_set_screen_size -> rl_set_screen_size
- 
- {bashline,pcomplete}.c, builtins/set.def
- 	- removed extern declarations of variables defined in readline.h
- 
- 				   1/23
- 				   ----
- support/rlvers.sh
- 	- use $TMPDIR if it's defined
- 	- use $RL_INCDIR (set by -I option, /usr/local/include by default)
- 	  as the directory containing the installed readline header files
- 	- cd to the temp directory before attempting compilation
- 
  configure.in
! 	- pass `-I ${includedir}' to rlvers.sh
! 
! 				   1/29
! 				   ----
! subst.c
! 	- fixed parameter_brace_expand to only throw away the state of
! 	  quoted dollar-at if we're going to be using the rhs of the
! 	  brace expansion, since whatever parameter_brace_expand_rhs sets
! 	  should be what goes (corrects bad fix of 2/16/2000)
! 	- fixed param_expand to only free temp after calling
! 	  parameter_brace_expand if it's a quoted null and we *did not*
! 	  have a quoted $@, since in that case we want to keep it and
! 	  do the $@ special handling (fixes real problem from 2/16/2000)
! 
! 				   1/30
! 				   ----
! variables.c
! 	- remove export attribute from SSH2_CLIENT, like SSH_CLIENT
! 
! 				    2/1
! 				    ---
! unwind_prot.c
! 	- added new function, clear_unwind_protect_list, to zero out the
! 	  unwind_protect list, optionally freeing the elements
! 
! unwind_prot.h
! 	- new extern declaration for clear_unwind_protect_list
! 
! execute_cmd.c
! 	- call clear_unwind_protect_list in initialize_subshell.  This fixes
! 	  the problem of core dumps when calling a shell script without a
! 	  leading `#!' from a shell function or other context with an
! 	  unwind-protect list
! 	- set variable_context and return_catch_flag to 0 in
! 	  initialize_subshell, since a new subshell is no longer in a shell
! 	  function
! 
! 				    2/2
! 				    ---
! doc/readline.3
! 	- updated the text; clarified several points
! 	- changed the usage synopsis to include <readline/readline.h> and
! 	  <readline/history.h>
! 
! lib/readline/doc/hstech.texinfo
! 	- made sure all function prototypes are valid ANSI C (mostly
! 	  changing () to (void))
! 
! lib/readline/doc/rluser.texinfo
! 	- a few clarifications
! 
! lib/readline/doc/rltech.texinfo
! 	- a few clarifications
! 	- added two new subsections for character input and terminal
! 	  management
! 	- changed all function prototypes to be valid ANSI C (mostly
! 	  replacing () with (void))
! 	- documented some variables in readline.h but previously not in
! 	  the reference manual (rl_num_chars_to_read, rl_dispatching,
! 	  rl_gnu_readline_p, rl_completion_type)
! 	- documented some functions in readline.h but previously not in
! 	  the reference manual (rl_clear_pending_input, rl_prep_terminal,
! 	  rl_deprep_terminal, rl_tty_set_default_bindings, rl_alphabetic,
! 	  rl_crlf)
! 
! lib/readline/readline.h
! 	- added extern declaration for rl_clear_pending_input()
! 	- added extern declaration for rl_alphabetic
! 	- changed rltty_set_default_bindings to rl_tty_set_default_bindings
! 	- changed crlf() -> rl_crlf()
! 
! lib/readline/rltty.c
! 	- new function, rl_tty_set_default_bindings, just calls
! 	  rltty_set_default_bindings (needed `rl_' prefix)
! 
! lib/readline/readline.c
! 	- readline_default_bindings now calls rl_tty_set_default_bindings
! 
! lib/readline/terminal.c
! 	- renamed crlf() to rl_crlf(); crlf() is still defined for backwards
! 	  compatibility 
! 
! bashline.c, lib/readline/{complete,display}.c
! 	- changed all calls to crlf() to rl_crlf()
! 
! test.c
! 	- fix filecomp() so that `test file1 -nt file2' doesn't fail if file1
! 	  exists but file2 does not
! 
! 				    2/5
! 				    ---
! lib/readline/{terminal,compat}.c
! 	- move crlf() backwards-compatibility definition to compat.c
! 
! execute_cmd.c
! 	- if we're running a command `( command ) &' from a non-interactive
! 	  shell, don't unconditionally disable expand_aliases.  Only do it
! 	  when running such a command from an interactive shell, since then
! 	  we're changing to a non-interactive shell
! 
! 				    2/6
! 				    ---
! [bash-2.05-beta1 released]
! 
! lib/readline/compat.c
! 	- add extern declaration for rl_crlf()
! 
! lib/readline/undo.c
! 	- initialize start and end in rl_do_undo to avoid bogus gcc compiler
! 	  warning with -Wall
  
! lib/readline/rlprivate.h
! 	- fix typo in extern declaration of _rl_current_display_line()
! 	- add extern declaration of _rl_free_saved_history_line()
! 
! lib/readline/terminal.c
! 	- return immediately from _rl_set_screen_size if one of the args is 0
! 	- new function, rl_get_screen_size (int *rows, int *cols) to return
! 	  readline's idea of the screen dimensions
! 
! lib/readline/doc/rltech.texinfo
! 	- documented rl_get_screen_size
! 
! 				    2/7
! 				    ---
! pathexp.c
! 	- a couple of fixes for the POSIX_GLOB_LIBRARY version of the globbing
! 	  code
! 
! expr.c
! 	- fixed omission of ^= from the special assignment operators
! 
! shell.c
! 	- change logic for setting `posixly_correct' at shell startup:  if
! 	  $POSIXLY_CORRECT or $POSIX_PEDANTIC is found in the environment,
! 	  set it to 1, otherwise retain the previous value (which is
! 	  initialized to 0)
! 
! 				   2/10
! 				   ----
! builtins/evalstring.c
! 	- since subshell_environment is now a flags word, test for the
! 	  SUBSHELL_COMSUB bit being set when decided whether or not to
! 	  evaluate $(<file), not just for subshell_environment ==
! 	  SUBSHELL_COMSUB
! 
! 				   2/12
! 				   ----
! lib/readline/doc/rltech.texinfo
! 	- fixed a couple of problems with the documentation for
! 	  rl_prep_terminal and rl_deprep_terminal 
! 	- added description of rl_set_prompt
! 
! support/config.sub
! 	- added support for Linux running on the IBM S390
! 
! 				   2/13
! 				   ----
! input.c
! 	- new function, fd_is_bash_input (fd), encapsulates the test for
! 	  whether or not FD is the file descriptor from which bash is reading
! 	  its input
! 	- change check_bash_input to call fd_is_bash_input
! 	- new function, save_bash_input (fd, new_fd), handles saving the
! 	  buffered stream associated with file descriptor FD to one
! 	  associated with NEW_FD.  If NEW_FD == -1, this function allocates a
! 	  file descriptor itself with fcntl
! 	- new function, set_bash_input_fd(fd), sets the fd bash is using to
! 	  read input to FD
! 	- changed duplicate_buffered_stream to note that the buffer it's
! 	  duplicating to was the bash input buffer (B_WASBASHINPUT)
! 
! input.h
! 	- extern declarations for fd_is_bash_input and save_bash_input
! 	- new flag for b->flag: B_WASBASHINPUT
! 
! redir.c
! 	- in add_undo_redirect, if FD is 0, make the undo redirect be of type
! 	  r_duplicating_input instead of r_duplicating_output, since that fd
! 	  requires special handling in the presence of buffered streams (fixes
! 	  problem with scripts reading input through a pipe restoring bash
! 	  input buffered stream correctly after a `read' with an input
! 	  redirection
! 
! 				   2/14
! 				   ----
! lib/readline{complete,util}.c
! 	- moved rl_strpbrk to util.c with rest of string utility functions,
! 	  renamed to _rl_strpbrk
! 
! lib/readline/rlprivate.h
! 	- extern declaration for _rl_strpbrk
! 
! lib/readline/input.c
! 	- make the timeout in rl_gather_tyi() be a variable
! 	  (_keyboard_input_timeout) rather than a constant
! 	- new function, rl_set_keyboard_input_timeout (int u) to set
! 	  _keyboard_input_timeout.  The argument is in microseconds; returns
! 	  the old value of _keyboard_input_timeout
! 	- _rl_input_available uses _keyboard_input_timeout also
! 
! lib/readline/readline.h
! 	- extern declaration for rl_set_keyboard_input_timeout
! 
! lib/readline/doc/rltech.texinfo
! 	- documented rl_variable_bind(), rl_macro_bind(), rl_macro_dumper(),
! 	  rl_variable_dumper(), rl_push_macro_input(), rl_show_char()
! 
! 				   2/20
! 				   ----
! findcmd.c
! 	- new function, executable_or_directory(name), returns 1 if NAME is
! 	  an executable file or a directory
! 
! findcmd.h
! 	- extern declaration for executable_or_directory()
! 
! bashline.c
! 	- call executable_or_directory() from command_word_completion_function,
! 	  which requires a single stat(2), instead of executable_file() and
! 	  is_directory(), each of which requires a stat(2)
! 
! 				   2/21
  				   ----
! execute_cmd.c
! 	- changed execute_builtin to handle `return' with a preceding variable
! 	  assignment list specially when in POSIX mode.  POSIX says that the
! 	  variable assignments should persist after the builtin returns, since
! 	  `return' is a special builtin.  Since `return' does a longjmp and
! 	  doesn't go through the normal cleanup path, we need to do special
! 	  things
! 
! variables.c
! 	- new function, merge_function_env(), merges the function_env into
! 	  the shell_variables table
! 
! variables.h
! 	- extern declaration for merge_function_env()
! 
! execute_cmd.c
! 	- changed execute_function to merge any variable assignments preceding
! 	  the function call into shell_variables if the shell is running in
! 	  POSIX mode
! 
! subst.c
! 	- changed parameter_brace_expand_error to do tilde expansion on the
! 	  rhs of the expansion, if it's not null
! 	- changed command_substitute so that the subshell begun to execute
! 	  the command substitution inherits the setting of the `-e' option
! 	  when in POSIX mode
! 
! builtins/break.def
! 	- changed check_loop_level to not print a complaining message when
! 	  the shell is running in POSIX mode, even if BREAK_COMPLAINS is
! 	  defined.  This affects `break' and `continue'
! 	- changed `break' and `continue' to return success even if the shell
! 	  is not executing a loop, as POSIX specifies
! 
! builtins/set.def
! 	- changed reset_shell_options() to not clear posixly_correct, so
! 	  subshells spawned to execute shell scripts without a leading `#!'
! 	  inherit posix mode from their parent shell
  
  variables.c
! 	- changed make_new_variable to create the shell_variables hash table
! 	  if it hasn't been done yet.  This is needed because bind_variable
! 	  may be called before initialize_shell_variables (e.g., when
! 	  `bash -o posix' calls bind_variable("POSIXLY_CORRECT", "y") from
! 	  parse_shell_options -> set_minus_o_option -> set_posix_mode
! 	  This makes `bash --posix' and `bash -o posix' equivalent, as they
! 	  should always have been
! 	- changed maybe_make_export_env to merge the contents of `builtin_env'
! 	  into export_env after function_env and before temporary_env.  This
! 	  fixes the problems with variable assignments preceding `eval' or
! 	  `source' not making it into the environment passed to executed disk
! 	  commands (var=20 eval printenv var)
! 
! doc/bashref.texi
! 	- noted that variable assignments preceding shell function calls
! 	  persist in the shell environment after the function returns when
! 	  the shell is running in POSIX mode
! 	- noted that when the shell is running in POSIX mode, subshells
! 	  spawned to execute command substitutions inherit the value of
! 	  the `-e' option from the parent shell
! 
! 				   2/26
! 				   ----
! doc/bashref.texi
! 	- augmented description of bash non-posix behavior in posix mode
! 	  with information from running the vsc-lite test suite
! 
! 				   2/28
! 				   ----
! general.c
! 	- since POSIX.2 says that aliases should be expanded even in
! 	  non-interactive shells, enable alias expansion in
! 	  posix_initialize() when posix mode is enabled, and set it to the
! 	  value of interactive_shell if posix mode is disabled
! 
! shell.c
! 	- before running the startup scripts, set expand_aliases to
! 	  posixly_correct, since we don't want alias expansion in startup
! 	  files unless we've been given the --posix invocation option
! 
! doc/bashref.texi
! 	- added item in BASH Posix Mode section noting that alias expansion
! 	  is always enabled when in posix mode
  
- Makefile.in
- 	- changed release level to `beta2'
- 
- 				    3/1
- 				    ---
  jobs.c
! 	- expanded retcode_name_buffer to 64
! 	- changed printable_job_status to conform to posix.2 for text of
! 	  stopped job status: `Stopped(SIGTSTP)' or `Stopped(SIGSTOP)'
! 
! doc/bashref.texi
! 	- Noted above change in posix mode section
! 
! 				    3/5
! 				    ---
! lib/readline/bind.c
! 	- changed rl_get_keymap_by_name to work case-insensitively
! 
! 				    3/6
! 				    ---
! doc/readline.{0,3,ps}
! 	- removed from distribution; moved to readline distribution
! 
! lib/readline/doc/history.3
! 	- man page for history library; neither built nor installed
! 	  (part of the standalone readline distribution)
! 
! lib/readline/histfile.c
! 	- changed history_truncate_file to return 0 on success, errno
! 	  on failure
! 	- changed history_do_write to return errno on a write error.  This
! 	  affects write_history and append_history
! 
! lib/readline/history.c
! 	- max_input_history is now history_max_entries; the old variable is
! 	  maintained for backwards compatibility
! 
! lib/readline/histexpand.c
! 	- the list of delimiters that separate words for history_tokenize
! 	  is now a variable: history_word_delimiters; default value is as
! 	  before
! 	- changed history_expand to return 0 immediately if its second
! 	  argument is NULL
! 
! bashline.c
! 	- changed to use history_max_entries
  
! lib/readline/history.h
! 	- extern declaration for history_max_entries
! 	- extern declaration for history_word_delimiters
! 
! 				    3/8
! 				    ---
! test.c
! 	- changed unary_operator() to return FALSE for non-numeric arguments
! 	  to `-t'
! 
! 				    3/9
! 				    ---
! [bash-2.05-beta2 released]
! 
! 				   3/12
! 				   ----
! lib/readline/doc/rltech.texinfo
! 	- documented rl_set_paren_blink_timeout()
! 	- moved the example function to its own info node
! 
! lib/readline/{hstech.texinfo,history.3}
! 	- `$' is not in the default value of history_word_delimiters
  
- 				   3/13
- 				   ----
  bashline.c
! 	- in maybe_add_history, if the tests for HISTCONTROL succeed, but
! 	  the HISTIGNORE check fails, set first_line_saved to 0
! 
! 				   3/15
! 				   ----
! 
! lib/glob/fnmatch.c
! 	- fixed a bug in patscan that caused `[' to be treated as special
! 	  even inside a nested bracket expression.  It's supposed to lose
! 	  it's special handling inside []
! 	- fixed a bug in patscan that caused `]' to end an embedded bracket
! 	  expression even if it was the first character after the `[' (or
! 	  a leading `!' or `^')
! 
! 				   3/22
! 				   ----
! execute_cmd.c
! 	- made a small change to shell_execve to report a more user-friendly
! 	  error if execve(2) fails because of a `#! interpreter' error with
! 	  `interpreter'
! 	- in shell_execve, if HAVE_HASH_BANG_EXEC is not defined, make sure
! 	  the file length is > 2 characters before attempting to execute an
! 	  interpreter
! 
! 				   3/26
! 				   ----
! jobs.c, nojobs.c
! 	- give_terminal_to now takes a second argument, FORCE.  If that
! 	  second argument is non-zero, give the terminal away no matter
! 	  what job_control is set to
! 
! jobs.h
! 	- changed extern declaration of give_terminal_to
  
! {jobs,sig,subst}.c,parse.y
! 	- changed all calls to give_terminal_to to add a second argument
! 	  of 0
  
! jobs.c
! 	- changed second argument of call to give_terminal_to in
! 	  end_job_control to 1, to force this even if job_control is 0.
! 	  This fixes the problem of `exec other-job-control-shell' in a
! 	  startup file hanging, since run_startup_files sets job_control to 0
  
! subst.c
! 	- fixed test of subshell_environment in command_substitute to test the
! 	  bit SUBSHELL_ASYNC rather than test equality, since it's now a
! 	  bitmask
  
! 				   3/27
  				   ----
! shell.c
! 	- changed posix initialization calls to set POSIXLY_CORRECT=y and
! 	  then call sv_strict_posix, so $SHELLOPTS includes `posix' and
! 	  POSIXLY_CORRECT is set, for both the posix command line options
! 	  and when act_like_sh is non-zero
! 
! redir.c
! 	- the `>& filename' redirection now works in posix mode, redirecting
! 	  stdout and stderr, since POSIX.2 leaves it unspecified
! 
! doc/bashref.texi
! 	- removed item about `>& filename' from Bash POSIX Mode section
! 
! parse.y
! 	- fixed a problem in decode_prompt_string with `\W' not printing
! 	  anything if PWD == "//"
! 
! lib/readline/input.c
! 	- in rl_read_key, after calling (*rl_event_hook), check for rl_done
! 	  being set, and return '\n' if it is
  
  Makefile.in
  	- changed RELSTATUS to `release'
  
! 				   3/28
  				   ----
! support/bashbug.sh
! 	- replace use of $(...) with `...` for the benefit of old versions
! 	  of sh
! 
! builtins/set.def
! 	- changed print_all_shell_variables to not print shell function names
! 	  and definitions when in posix mode
! 
! doc/bashref.texi
! 	- noted change in `set' behavior in posix mode section
  
! 				    4/2
! 				    ---
! lib/readline/readline.c
! 	- changed default value of RL_LIBRARY_VERSION to `4.2'
  
! 				    4/5
! 				    ---
! [bash-2.05-release frozen]
--- 1,2940 ----
! 				 4/9/2001
! 				 --------
! [bash-2.05 released]
! 
! 				   4/10
! 				   ----
! redir.c
! 	- check return value of fclose() in write_here_document() for error
! 	  returns; don't just rely on fwrite() failing
! 
! support/bashbug.sh
! 	- set TMPDIR to /tmp if it's null or unset
! 	- use $TMPDIR in the TEMP tempfile name template
! 	- fixed the call to `mktemp', if it exists, to make it more portable
! 
! jobs.c
! 	- if WCONTINUED is not defined, define it to 0 and add a define for
! 	  WIFCONTINUED(wstatus) which expands to 0
! 	- add WCONTINUED to the flags passed to waitpid(2) in waitchld()
! 	- don't increment children_exited if waitpid's status is WIFCONTINUED,
! 	  since we don't want to call a SIGCHLD trap handler in this case
! 	- in waitchld(), we set child->running to 1 if WIFCONTINUED(status)
! 	  is non-zero
! 	- make sure pretty_print_job doesn't check for the core dump bit if
! 	  the process has been continued; it's only valid if the job is dead
! 	- in set_job_status_and_cleanup, set the job to JRUNNING if job_state
! 	  is non-zero and the job was previously marked as JSTOPPED
  
  configure.in
! 	- add -DBROKEN_DIRENT_D_INO to interix LOCAL_CFLAGS
  
! lib/glob/glob.c
! 	- if BROKEN_DIRENT_D_INO is defined, define REAL_DIR_ENTRY to 1
  
! jobs.c
! 	- in kill_pid, we only need to block and unblock SIGCHLD if the
! 	  `group' argument is non-zero, since otherwise we just call `kill'
! 	  on the pid argument
  
! version.c
! 	- update copyright date to 2001
  
! bashline.c
! 	- prog_complete_return needs to take a `const char *' as its first
! 	  argument
! 	- history_completion_generator needs to take a `const char *' as
! 	  its first argument, and `text' needs to be a `const char *'
  
! 				   4/11
! 				   ----
! redir.c
! 	- fixed a weird typo in redir_special_open, case RF_DEVFD, added
! 	  call to all_digits before call to legal_number
! 	- fixed do_redirection_internal to call legal_number instead of atol(3)
! 	  when translating r_duplicating_{in,out}put_word, so it handles
! 	  overflow better
! 	- produce an error message in redirection_error for out-of-range
! 	  file descriptors
! 	- change allocation strategy in redirection_error so we don't have to
! 	  malloc scratch memory if redirection_expand() fails
  
! jobs.h
! 	- added defines for `running' member of a struct process
  
! general.c
! 	- fix legal_number to return 0 when strtol(3) reports overflow or
! 	  underflow
  
! parse.y
! 	- changed read_token_word to call legal_number instead of atoi(3)
  
! input.c
! 	- return -1/EBADF from close_buffered_fd if fd is < 0
  
! command.h
! 	- fixed bogus comment about IS_DESCRIPTOR in description of the
! 	  REDIRECTEE struct
  
! print_cmd.c
! 	- change cprintf's 'd' modifier code to display negative numbers as
! 	  an out-of-range value.  We can do this only because the only use
! 	  of %d is to output file descriptor numbers in redirections
  
! support/mksignames.c
! 	- need to include config.h to get a possible value for
! 	  UNUSABLE_RT_SIGNALS
  
! 				   4/16
! 				   ----
! lib/readline/doc/rluser.texinfo
! 	- corrected a small error in one description of M-DEL
  
! 				   4/17
! 				   ----
! stringlib.c
! 	- need to initialize `ind' before calls to RESIZE_MALLOCED_BUFFER
! 	  in strcreplace()
  
! support/bashversion.c
! 	- new file, prints bash version information
  
! Makefile.in
! 	- rules for building bashversion and linking it to version.o
  
! 				   4/24
  				   ----
+ conftypes.h
+ 	- new file with HOSTTYPE, OSTYPE, MACHTYPE, etc. defines from
+ 	  variables.h
+ 
+ variables.h, version.c
+ 	- include conftypes.h
+ 
+ patchlevel.h
+ 	- new file, contains define for PATCHLEVEL.  Doing away with the old
+ 	  scheme of having the information in configure.in
  
! version.c
! 	- include patchlevel.h
  
! Makefile.in
! 	- run bashversion -p to find patch level rather than have configure
! 	  substitute in a value
! 	- pass -S ${top_srcdir} to support/mkversion.sh
  
! support/mkversion.sh
! 	- don't put PATCHLEVEL define into version.h, but accept and ignore
! 	  a -p option
! 	- take a new -S srcdir option
! 	- find the patch level by parsing it out of patchlevel.h
  
! configure.in
! 	- hard-code BASHVERS assignment instead of reading it from a file
! 	- remove BASHPATCH; don't substitute it
  
! _distribution,_patchlevel
! 	- removed
  
! 				   4/26
! 				   ----
! shell.c
! 	- call init_noninteractive() in open_shell_script if forced_interactive
! 	  is non-zero (the shell was started with -i) and fd_is_tty is 0
! 	  (the script file is a real file, not something like /dev/stdin),
! 	  since it wasn't done earlier
  
! builtins/printf.def
! 	- change for POSIX.2 compliance when conversion errors are encountered
! 	  when processing %d, %u, and floating point conversion operators
! 	  (print a warning message, return the value accumulated at the time
! 	  of the error -- which is always 0 -- and exit with a non-zero status)
  
! command.h
! 	- added CMD_COMMAND_BUILTIN for use by the `command' builtin and the
! 	  code in execute_cmd.c
  
! builtins/command.def
! 	- add CMD_COMMAND_BUILTIN to the created command's flags
  
! 				    5/1
! 				    ---
! configure.in
! 	- add call to AC_C_CONST to test `const' compiler behavior
! 	- add call to AC_C_INLINE to test `inline' compiler behavior
! 	- add call to AC_C_STRINGIZE to test cpp #x stringizing operator
  
! config.h.in
! 	- add `#undef const' for configure to substitute
! 	- add `#undef inline' for configure to substitute
! 	- add `#undef HAVE_STRINGIZE' for configure to substitute
  
! include/stdc.h
! 	- remove code that defines or undefines `const' and `inline'
! 	- change the __STRING macro to be defined depending on the value
! 	  of HAVE_STRINGIZE
  
! lib/malloc/malloc.c
! 	- change the __STRING macro to be defined depending on the value
! 	  of HAVE_STRINGIZE
  
! lib/readline/{readline,rlprivate}.h
! 	- moved rl_get_termcap to readline.h, making it a public function
  
! lib/readline/readline.h
! 	- new #define, RL_READLINE_VERSION, hex-encoded library version
! 	  number, currently set to 0x0402
! 	- new public int variable, rl_readline_version
  
! lib/readline/readline.c
! 	- #define RL_READLINE_VERSION if it is not already defined (which it
! 	  should be in readline.h)
! 	- initialize rl_readline_version to RL_READLINE_VERSION
  
! lib/readline/doc/rltech.texinfo
! 	- documented rl_get_termcap
! 	- documented rl_readline_version
  
! jobs.c
! 	- job_exit_status should return an int, not a WAIT (undetected
! 	  before because on most POSIX-like systems a WAIT is really an int)
  
! builtins/evalfile.c
! 	- added FEVAL_REGFILE (file must be a regular file) to accepted
! 	   _evalfile flags
! 	- fc_execute_file() adds FEVAL_REGFILE to _evalfile flags.  This
! 	  means that startup files and files read with `.' no longer need
! 	  to be regular files
  
! 				    5/2
! 				    ---
  
! lib/termcap/Makefile.in
! 	- fix target for installed termcap library (normally unused)
  
! lib/tilde/Makefile.in
! 	- fix install target to install in $(libdir) (normally unused)
  
! Makefile.in
! 	- don't make $(man3dir) since there's nothing installed there
  
! Makefile.in,doc/Makefile.in
! 	- change `man1ext' to `.1', `man3ext' to `.3'
! 	- change appropriate install targets to use new values of man[13]ext
! 	- use `test ...' instead of `[...]'
! 	- add support for DESTDIR root installation prefix, for package
! 	  building (installdirs, install, install-strip, uninstall targets)
  
! builtins/common.c
! 	- new function int get_exitstat(WORD_LIST *list) returns an eight-bit
! 	  exit status value for use in return, exit, logout builtins
  
! builtins/common.h
! 	- extern declaration for get_exitstat()
  
! builtins/{exit,return}.def
! 	- call get_exitstat where appropriate
  
! builtins/printf.def
! 	- add support for "'" flag character as posix 1003.2-200x d6 says
! 	- fix core dump when user-supplied field width or precision is 0
! 	- fix to printstr() to handle zero-length precision with `%b' format
! 	  specifier (printf '%.0b-%.0s\n' foo bar)
! 	- fix to printstr() to treat a negative field width as a positive
! 	  field width with left-justification
! 	- fix to mklong to avoid static buffers, which can always be overrun
! 	  by someone sufficiently motivated
  
! bashline.c
! 	- change var in add_host_name to type `size_t' for passing to xrealloc
  
! 				    5/3
! 				    ---
! execute_cmd.c
! 	- change restore_signal_mask to accept a sigset_t *, since a sigset_t
! 	  may not fit into a pointer, change call
  
! unwind_prot.c
! 	- use a union UWP in restore_variable when restoring a variable whose
! 	  size is the same as sizeof(int), the reverse of the method used to
! 	  store it in unwind_protect_int
  
! builtins/printf.def
! 	- use a #define LENMODS containing the length modifiers instead of
! 	  testing against each possible modifier character, save any mod
! 	  character found
! 	- add support for ISO C99 length specifiers `j', `t', and `z'
! 	- if `L' modifier is supplied with a floating point conversion char,
! 	  pass a `long double' to printf if HAVE_LONG_DOUBLE is defined
  
! configure.in,config.h.in
! 	- call AC_C_LONG_DOUBLE to check for `long double'; define
! 	  HAVE_LONG_DOUBLE if supported
  
! bashline.c
! 	- fix an inadvertantly-unclosed comment in attempt_shell_completion
! 	- make set_saved_history return a value
! 	- make dynamic_complete_history return a useful value
  
! {make_cmd,execute_cmd,shell,subst,trap,variables,input,unwind_prot,test,
! pcomplete}.c
! 	- removed some declared-but-unused variables
  
! builtins/{cd,enable,fc,set,setattr,type,umask,printf,complete}.def
! 	- removed some declared-but-unused variables
  
! lib/sh/{zread,netopen}.c
! 	- removed some declared-but-unused variables
  
  execute_cmd.c
! 	- in execute_arith_command, use a long variable to hold the result
! 	  of evalexp(), since that's what it returns
  
! builtins/evalstring.c
! 	- make cat_file return -1 on a read or write error
  
! lib/sh/stringlib.c
! 	- make merge_stringlists() return the right value
  
! 				    5/7
! 				    ---
! pcomplete.c
! 	- remove typo that caused empty declaration (;;)
  
  parse.y
! 	- fix yyerror() to accept a single string argument; fix callers
  
! trap.c
! 	- cast pointer to long instead of int when printing message with
! 	  internal_warning() in run_pending_traps()
  
! subst.c
! 	- fix process_substitute to handle stdin being closed
  
! test.c
! 	- change `while' to `if' in and() and or(), since the loop isn't
! 	  actually performed -- there's an unconditional `return' in the
! 	  loop body
! 	- check for integer overflow of arguments to `-t'
  
! lib/sh/netopen.c
! 	- change _getserv() to reject negative port/service numbers
  
! expr.c
! 	- fix strlong() to not convert the base specification from long to
! 	  int before checking for overflow, since truncation on machines
! 	  where sizeof(int) != sizeof(long) may mask errors
! 
! builtins/{jobs,kill,wait}.def
! 	- use legal_number instead of atoi when converting strings to pid_t;
! 	  check for numeric overflow
  
! input.c
! 	- fix for cygwin in b_fill_buffer -- off-by-one error when checking
! 	  buffer for \r\n termination
  
! general.h
! 	- new #define INT_STRLEN_BOUND(t), computes max length of string
! 	  representing integer value of type T, possibly including a sign
! 	  character
! 	- include <limits.h> if it's present
! 
! {execute_cmd,findcmd,test}.c
! 	- don't include <limits.h>, since general.h does it now
! 
! {execute_cmd,lib/sh/itos,pcomplete,print_cmd,subst,variables}.c
! 	- use INT_STRLEN_BOUND instead of static array sizes when converting
! 	  various strings to integer values
  
! shell.h
! 	- struct fd_bitmap now uses an `int' size, since it's bounded by
! 	  the number of file descriptors, which must fit into an `int'
  
! execute_cmd.c
! 	- FD_BITMAP_DEFAULT_SIZE is now 32, not 32L
! 	- new_fd_bitmap takes an `int' size parameter, not a `long'
  
! execute_cmd.h
! 	- change prototype for new_fd_bitmap()
  
! test.c
! 	- fix test_stat to check for overflow when parsing the integer file
! 	  descriptor number; return ENOENT instead of EBADF for files that
! 	  are not open
  
! hashlib.c
! 	- don't discard the upper 32 bits of the random value, if present
  
! lib/readline/shell.c
! 	- use the same INT_STRLEN_BOUND mechanism to decide how much space to
! 	  allocated in sh_set_lines_and_columns
  
! 				    5/8
! 				    ---
! aclocal.m4
! 	- add check for libtinfo (termcap-specific portion of ncurses-5.2) to
! 	  BASH_CHECK_LIB_TERMCAP
! 	- new macro, RL_LIB_READLINE_VERSION, checks version of installed
! 	  readline library and (optionally) writes version #defines to
! 	  config.h.  Bash doesn't use the version defines
  
! configure.in
! 	- call RL_LIB_READLINE_VERSION instead of support/rlvers.sh
  
! execute_cmd.c
! 	- fix execute_shell_script and the WHITECHAR and STRINGCHAR macros
! 	  to check array bounds before indexing into the sample string
  
! unwind_prot.[ch]
! 	- import new versions submitted by Paul Eggert <eggert@twinsun.com>
! 	  with a couple of changes for backwards compatibility, so the rest
! 	  of the source doesn't need to be changed yet
  
! jobs.c
! 	- use unwind_protect_var on last_made_pid in run_sigchld_trap
  
! builtins/bind.def
! 	- use unwind_protect_var on rl_outstream
  
  general.c
! 	- rework print_rlimtype to use INT_STRLEN_BOUND and handle the
! 	  most negative number correctly
  
! expr.c
! 	- `tokval' should have been a `long', since all arithmetic is done
! 	  as longs
  
! builtins/history.def
! 	- consolidate tests for valid history position in one block to
! 	  avoid duplicate code and strings
  
! builtins/ulimit.def
! 	- fix check for overflow when setting limit to work when int is 32
! 	  bits and RLIMTYPE is 64
  
! lib/sh/tmpfile.c
! 	- don't truncate the result of time(3) to int; just use time_t,
! 	  since it's being assigned to an `unsigned long'
  
! mailcheck.c
! 	- use legal_number instead of atoi in time_to_check_mail() to catch
! 	  more numeric errors; consolidate error checking in one block
! 	- last_time_mail_checked should be a time_t
  
! 				    5/9
! 				    ---
! builtins/set.def
! 	- recognize `set [-+]o nolog' if HISTORY is defined
  
! bashline.c
! 	- new variable `dont_save_function_defs', set by `set -o nolog';
! 	  currently ignored
  
  command.h
! 	- the `dest' member of a REDIRECTEE is now an `int'
  
! parse.y,redir.c
! 	- changed uses of `redir.test' (where redir is a REDIRECTEE) since
! 	  it's now an int
  
! lib/readline/rlstdc.h
! 	- don't mess around with `const', rely on configure to supply a
! 	  proper definition if the compiler doesn't support it
  
! lib/tilde/tilde.h
! 	- include <config.h> if HAVE_CONFIG_H is defined
! 	- don't mess around with `const', rely on configure
  
  builtins/shopt.def
! 	- new read-only `shopt' option, login_shell, non-zero if shell is a
! 	  login shell (as decided by shell.c)
! 	- new function set_login_shell(), sets shopt private value of
! 	  login_shell
  
! builtins/common.h
! 	- new extern declaration for set_login_shell
  
! shell.c
! 	- call set_login_shell after setting value of login_shell (in
! 	  main() and set_shell_name())
  
! parse.y
! 	- added new `\A' prompt string escape sequence:  time in 24-hour
! 	  HH:MM format
  
! configure.in, config.h.in
! 	- check for <grp.h>, define HAVE_GRP_H if found
  
! builtins/complete.def
! 	- add new `-A group/-g' option to complete group names
  
! pcomplete.h
! 	- new define for CA_GROUP, used with group name completion
  
! pcomplete.c
! 	- add code to support CA_GROUP group name completion
  
! bashline.c
! 	- new function, bash_groupname_completion_function(), supports
! 	  programmable completion of group names
  
! bashline.h
! 	- extern declaration for bash_groupname_completion_function
  
  lib/readline/bind.c
! 	- new inputrc variable, `match-hidden-files', controls completion
! 	  matching files beginning with a `.' (on Unix)
  
! lib/readline/complete.c
! 	- new variable, _rl_match_hidden_files, mirrors `match-hidden-files'
! 	  inputrc variable
  
! lib/readline/rlprivate.h
! 	- extern declaration for _rl_match_hidden_files
  
! builtins/hash.def
! 	- new `-t' option to list hash values for each filename argument
  
! builtins/read.def
! 	- alarm(3) takes an `unsigned int' argument, not int
! 	- check for arithmetic overflow with -t and -n options
  
! input.c
! 	- check for read error before doing \r\n translation on cygnus in
! 	  b_fill_buffer
! 	- reset bp->b_used to 0 instead of leaving it at -1 on read error
! 	  in b_fill_buffer
  
! builtins/shopt.def
! 	- new functions, shopt_setopt(name, mode) and
! 	  shopt_listopt(name, mode) to give the rest of the shell an easy
! 	  interface
  
! builtins/common.h
! 	- extern declarations for shopt_setopt and shopt_listopt
  
! shell.c
! 	- new invocation options -O and +O, to list or set/unset shopt
! 	  options like +o/-o sets and unsets `set -o' options
  
! doc/{bash.1,bashref.texi}
! 	- document `set -o nolog'
! 	- document `login_shell' shopt option
! 	- document new `\A' prompt string escape sequence
! 	- document new `-t' option to `hash'
! 	- document new `[+-]O' invocation option
  
! doc/bashref.texi
! 	- add text to `Invoking Bash' section defining a login shell; text
! 	  taken from man page
  
! doc/bash.1, lib/readline/doc/rluser.texinfo
! 	- documented new complete/compgen `-A group/-g' option
  
! lib/readline/doc/{rluser.texinfo,readline.3}, doc/bash.1
! 	- documented new `match-hidden-files' inputrc variable
  
! 				   5/10
  				   ----
  configure.in
! 	- fix AC_CHECK_PROG(ar, ...)
! 	- add AC_CHECK_TYPE for ssize_t
  
! config.h.in
! 	- new #undef for ssize_t
  
! lib/sh/zread.c
! 	- int -> ssize_t fixes to mirror modern declarations of read and write
! 	- the `off' variable in zsyncfd should be an off_t since it computes
! 	  a file offset
! 	- the local buffer `lbuf' is now char, since it's not nice to pass
! 	  unsigned char * to read(2), and the values from it are assigned to
! 	  a char anyway
! 	- lind and lused are now size_t, since they index into a buffer
! 	- set lused to 0 on read error
  
! lib/sh/zwrite.c
! 	- change second argument to type `char *', since ISO C says you have
! 	  to pass a `char *' to `write'
  
! externs.h
! 	- fix extern declarations of zread, zread1, zreadc, and zwrite
! 	- prototype extern declaration of qsort_string_compare
! 	- add extern declaration for history_delimiting_chars() from parse.y
  
! input.h
! 	- b_used and b_inputp members ofr struct BSTREAM are now size_t
  
! builtins/evalstring.c
! 	- the number of chars read with zread in cat_file should be assigned
! 	  to a variable of type ssize_t
  
! input.c
! 	- the number of chars read with zread in b_fill_buffer should be
! 	  assigned to a variable of type ssize_t
! 	- `localbuf' is now type char[], since POSIX says you shouldn't pass
! 	  unsigned char * to read(2)
! 	- in getc_with_restart(), use a variable of type unsigned char to
! 	  get a value from the local buffer and return it
! 	- in ungetc_with_restart, explicitly return the character arg passed
! 	  to avoid relying on localbuf being unsigned char
  
! subst.c
! 	- the number of chars read with zread in read_comsub should be
! 	  assigned to a variable of type ssize_t
  
! mksyntax.c
! 	- instead of casting to unsigned char * in addcstr, use a variable
! 	  of type unsigned char and let the compiler do the work
! 
! parse.y
! 	- instead of casting to unsigned char * in yy_readline_get, use a
! 	  variable of type unsigned char and let the compiler do the work
! 	- ditto for yy_string_get and shell_getc (cast to unsigned char)
  
  subst.c
! 	- instead of casting to unsigned char when assigning to ifscmap in
! 	  expand_word_internal, use a variable of type unsigned char and
! 	  let the compiler do the work
  
! lib/sh/strtrans.c
! 	- instead of casting to unsigned char in ansic_quote, use a variable
! 	  of type unsigned char and let the compiler do the work
  
! builtins/evalstring.c
! 	- remove extern declarations for zwrite and run_trap_cleanup; they're
! 	  in externs.h
! 	- prototype cat_file forward declaration
! 
! Makefile.in
! 	- remove -I$(includedir) from INCLUDES and SUBDIR_INCLUDES
! 
! aclocal.m4
! 	- change RL_LIB_READLINE_VERSION to set RL_PREFIX, RL_LIBDIR,
! 	  and RL_INCLUDEDIR to what it used to test the installed readline
! 	  library version for use by the caller
! 	- change RL_LIB_READLINE_VERSION to not compute ac_cv_rl_prefix if
! 	  the caller has already assigned it a value
! 	- rename _rl_prefix -> ac_cv_rl_prefix, _rl_libdir -> ac_cv_rl_libdir,
! 	  _rl_includedir -> ac_cv_rl_includedir
! 
! configure.in
! 	- change testing of whether to use the value of
! 	  $opt_with_installed_readline to be != no, to allow the user to
! 	  specify a prefix where the installed readline library may be found
! 	- if --with-installed-readline=PREFIX is supplied, set ac_cv_rl_prefix
! 	  to PREFIX before calling RL_LIB_READLINE_VERSION
! 	- if --with-installed-readline[=PREFIX] is supplied, don't set
! 	  RL_LIBDIR and RL_INCLUDEDIR; let RL_LIB_READLINE_VERSION take care
! 	  of it, set RL_INCLUDE=-I${RL_INCLUDEDIR}
! 	- if --with-installed-readline[=PREFIX] is supplied, and we're
! 	  linking with the history library, assign $RL_LIBDIR to HIST_LIBDIR
! 	  so we use the same version of the installed readline and history
! 	  libraries
  
! Makefile.in, builtins/Makefile.in
! 	- have configure substitute RL_INCLUDEDIR, set RL_INCLUDEDIR variable
  
! doc/bashref.texi
! 	- updated description of --with-installed-readline configure option 
  
! general.c
! 	- moved QSFUNC typedef here from builtins/common.c
  
! {alias,bashline,variables,lib/sh/stringvec}.c
! 	- cast fourth argument to qsort to (QSFUNC *)
  
! alias.c
! 	- prototype forward declaration of qsort_alias_compare
  
! bashhist.c
! 	- include <glob/glob.h> for extern declaration of glob_pattern_p
! 	- remove extern declaration of history_delimiting_chars; it's now
! 	  in externs.h
! 	- prototype forward declarations of histignore_item_func,
! 	  maybe_add_history, and bash_add_history
  
! bracecomp.c
! 	- remove extern declaration for sh_backslash_quote; it's in externs.h
  
! braces.c
! 	- remove extern declaration for extract_command_subst; it's in subst.h
! 	- prototype forward declarations for expand_amble, array_concat, and
! 	  brace_gobbler
  
! error.c
! 	- prototype extern declaration of give_terminal_to, fix bad call
  
! {execute_cmd,expr,findcmd,jobs,mailcheck,nojobs,pcomplete,print_cmd,redir,
! shell}.c
! 	- prototype all static forward function declarations
  
! pcomplete.c
! 	- changed some function parameters to `const char *' to avoid discarding
! 	  const qualifier
  
! make_cmd.c
! 	- make_bare_word, make_word_flags, and make_word now take a
! 	  `const char *' string argument
  
! make_cmd.h
! 	- changed extern declarations for make_bare_word and make_word
  
! print_cmd.c
! 	- cprintf now takes a `const char *' as its first argument, like
! 	  xprintf and printf
! 	- the conditional define for xprintf should have been HAVE_VPRINTF,
! 	  not HAVE_VFPRINTF
  
! shell.c
! 	- in isnetconn(), the return value of sizeof() is size_t
  
! aclocal.m4
! 	- add inclusion of stddef.h if STDC_HEADERS is defined to 1 in
! 	  BASH_CHECK_TYPE
  
! configure.in
! 	- add a call to BASH_CHECK_TYPE for socklen_t (type of third argument
! 	  to getpeername(2))
  
! 				   5/11
  				   ----
! lib/readline/bind.c
! 	- make `useq' a char array to pass to rl_macro_bind in
! 	  rl_parse_and_bind
  
! lib/readline/{{bind,isearch}.c,rlprivate.h}
! 	- _rl_isearch_terminators is now a char *, not unsigned char *
  
! {subst,variables,lib/sh/tmpfile}.c
! 	- dollar_dollar_pid is now a `pid_t' instead of `int'
! 
! variables.c
! 	- sbrand() now takes an `unsigned long' to set the seed value
! 	- changed last_random_value to type int, since it's always between
! 	  0 and 32767
! 	- use strtoul to convert the value in assign_random instead of atoi
! 	- take out casts in any arguments to sbrand()
! 	- take out cast to int in call to inttostr in set_ppid()
  
  subst.c
! 	- don't cast last_asynchronous_pid when passing to itos()
! 
! {sig,subst}.c
! 	- prototype all static forward function declarations
  
! 				   5/14
  				   ----
! {test,trap,variables}.c
! 	- prototype all static forward function declarations
  
! variables.c
! 	- free_variable_hash_data() now takes a PTR_T, a `generic pointer'
  
! builtins/{alias,bind,break,cd,complete,declare,enable,exit,fc,fg_bg,help,
! history,jobs,pushd,read,set,trap,umask,
! 	- prototype all static forward function declarations
  
! builtins/read.def
! 	- reset_eol_delim now takes a `char *' arg, since that's what the
! 	  unwind_protect functions pass it, and it ignores its arguments
! 	  anyway
  
! lib/readline/{histsearch,input,kill,rltty,search,vi_mode}.c
! 	- prototype all static forward function declarations
  
! lib/tilde/tilde.c
! 	- prototype all static forward function declarations
! 	- tilde_find_prefix, tilde_find_suffix, isolate_tilde_prefix, and
! 	  glue_prefix_and_suffix now take `const char *' arguments where
! 	  appropriate
  
! configure.in,config.h.in
! 	- check for vsnprintf, define HAVE_VSNPRINTF if found
  
! lib/readline/display.c
! 	- use vsnprintf() in rl_message if it's available; if we don't, at
! 	  least set the last character in msg_buf to 0 to avoid overrun --
! 	  we really can't do anything about overflow at this point.  if it's
! 	  available, this fixes buffer overflow problems in rl_message
  
! 				   5/15
! 				   ----
! lib/readline/histexpand.c
! 	- in get_history_word_specifier, allow any character to terminate
! 	  a `:first-' modifier, not just `:' and null.  This is what csh
! 	  appears to do.  This allows things like `!:0- xyzzy' to replace the
! 	  last argument with xyzzy
  
! 				   5/18
! 				   ----
! configure.in, config.h.in
! 	- check for <stdint.h>, define HAVE_STDINT_H if found
! 	- check for intmax_t in <stdint.h>, define intmax_t as long if not
! 	  found
  
! 				   5/21
! 				   ----
! builtins/kill.def
! 	- change to use strerror() for error message when kill(2) fails
  
! aclocal.m4
! 	- new macro, BASH_C_LONG_LONG, check for `long long'
  
! configure.in, config.h.in
! 	- call BASH_C_LONG_LONG, define HAVE_LONG_LONG if found
  
! lib/sh/snprintf.c
! 	- new file, with implementations of snprintf, vsnprintf, asprintf,
! 	  and vasprintf, derived from inetutils version
  
! Makefile.in, lib/sh/Makefile.in
! 	- add snprintf.c/snprintf.o
  
! configure.in, config.h.in
! 	- add checks for snprintf, asprintf, vasprintf, with appropriate
! 	  cpp defines
  
! lib/readline/{rldefs,xmalloc}.h, lib/readline/xmalloc.c
! 	- xmalloc and xrealloc now take `size_t' arguments, like their bash
! 	  counterparts
  
! externs.h,lib/sh/itos.c
! 	- inttostr and itos now take `long' arguments
! 	- inttostr takes a `size_t' argument for the buffer size
! 
! {expr,lib/malloc/malloc,variables,general}.c
! 	- fixed calls to itos() by removing casts, etc.
! 
! subst.[ch]
! 	- get_dollar_var_value now takes a long, not an int
! 	- sub_append_number now takes a long, not an int
! 
! subst.c
! 	- in parameter_brace_expand_word, use a long and legal_number to
! 	  translate ${N}, to avoid overflow
! 	- in parameter_brace_expand_length, use a long and legal_number to
! 	  translate ${#N}, to avoid overflow
! 	- in do_array_element_assignment, array_expand_index,
! 	  array_value_internal, use arrayind_t instead of int
! 	- let verify_substring_values take long * arguments for the return
! 	  value of evalexp()
! 	- pass long * arguments to verify_substring_values in
! 	  parameter_brace_substring
! 	- parameter_brace_expand_length now returns `long'
! 	- parameter_brace_expand now uses a long variable for the return
! 	  value of parameter_brace_expand_length
! 	- param_expand now uses a long variable for the return value from
! 	  evalexp
! 	- array_length reference now returns an `arrayind_t', since it can
! 	  return the num_elements member of an array, which is of type
! 	  arrayind_t
  
! subst.h
! 	- array_expand_index now returns an `arrayind_t'
  
! array.[ch]
! 	- array_subrange now takes arrayind_t arguments, not `int'
! 	- dup_array_subrange now uses arrayind_t local variable to do
! 	  array indexing
! 	- use long to print array indices in print_element
  
! variables.c
! 	- null_array_assign, assign_dirstack, bind_array_variable
! 	  now take arrayind_t arguments as array indices
! 	- assign_array_var_from_word_list, assign_array_var_from_string,
! 	  unbind_array_element now use arrayind_t local variables for
! 	  array indexing
  
! variables.h
! 	- change extern declaration of bind_array_variable
  
! builtins/common.[ch]
! 	- get_numeric_arg now returns a `long', since it usually returns
! 	  the value of legal_number()
  
! builtins/{shift,break}.def
! 	- use long variables for the return value of get_numeric_arg
  
! builtins/history.def
! 	- convert string argument to int only if it's in range
  
! builtins/pushd.def
! 	- set_dirstack_element and get_dirstack_element now take `long'
! 	  index arguments
! 	- get_dirstack_index now takes a `long' index argument, since it's
! 	  passed the converted value from legal_number
  
! lib/sh/timeval.c
! 	- in print_timeval, don't assume that the number of minutes fits into
! 	  an int, since it's just seconds/60.
  
! lib/sh/clock.c
! 	- ditto for print_clock_t
  
! 				   5/22
  				   ----
! shell.c
! 	- since the -O option settings may possibly be overridden by the
! 	  normal shell initialization or posix initialization, save the
! 	  invocation options on an alist (with add_shopt_to_alist) and
! 	  process them after basic initialization (with run_shopt_alist)
  
! 				   5/23
  				   ----
! trap.h
! 	- new define, BASH_NSIG, all system signals plus special bash traps
  
! trap.c, builtins/trap.def
! 	- use BASH_NSIG for array bounds and loops where appropriate
  
! trap.c
! 	- change decode_signal to disallow numeric signal numbers above
! 	  NSIG -- this means you can only reference special traps like
! 	  DEBUG by name
! 	- new SPECIAL_TRAP(s) macro to test whether s is one of the special
! 	  bash traps (currently DEBUG and EXIT)
! 	- change reset_or_restore_signal_handlers so command substitution
! 	  doesn't inherit the debug trap (like ksh93), and child processes
! 	  don't have to rely on initialize_traps being run to get rid of
! 	  any debug trap
  
! support/mksignames.c
! 	- add extra "ERR" signal name, value NSIG+1, allocate space for it
! 	  and write it out in signal_names[]
  
! trap.h
! 	- new define: ERROR_TRAP == NSIG+1, change BASH_NSIG to NSIG+2
! 	- extern declarations for set_error_trap, run_error_trap
! 	- new define: TRAP_STRING(s), expands to trap_list[s] if signal S
! 	  is trapped and not ignored, NULL otherwise
  
! trap.c
! 	- add ERROR_TRAP to SPECIAL_TRAPS define
! 	- initialize ERROR_TRAP stuff in initialize_traps
! 	- new function: set_error_trap(command), sets the ERR trap string
! 	- new function: run_error_trap(command), runs the ERR trap string
! 	- set trap string for ERROR_TRAP to NULL in free_trap_strings
! 	- change reset_or_restore_signal_handlers so child processes don't
! 	  inherit the ERR trap
! 	- add case to call run_error_trap in maybe_call_trap_handler
  
  execute_cmd.c
! 	- in execute_command_internal, keep track of ERR trap and call it if
! 	  necessary
! 	- use TRAP_STRING to get the value of debug and error traps
! 	- in execute_function, arrange things so the ERR trap is not inherited
! 	  by shell functions, and is saved and restored like the DEBUG trap
  
! doc/{bash.1,bashref.texi}
! 	- documented new ERR trap
  
! tests/{trap.{tests,right},trap2.sub,trap2a.sub}
! 	- added ERR trap tests
  
! subst.c
! 	- on machines without /dev/fd, change the named pipe fifo list to a
! 	  list of structs containing pathname and proc information
! 	- change unlink_fifo_list to kill the proc in the fifo list with
! 	  signal 0 and not remove the fifo if the proc is still alive.  This
! 	  should fix the problem on those backward systems without /dev/fd
! 	  where fifos were removed when a job using process substitution was
! 	  suspended
  
! 				   5/24
! 				   ----
! examples/loadables/getconf.h
! 	- new file, with basic defines needed to make getconf work minimally
! 	  on POSIX systems without the necessary definitions
! 
! examples/loadables/getconf.c
! 	- replacement functions for confstr, sysconf, pathconf for systems
! 	  that lack them, providing a minimal posix interface
! 	- heavily augmented getconf, now supports all POSIX.1-200x,
! 	  POSIX.2-200x, Solaris 7, AIX 4.2 getconf variables
  
! 				   5/29
  				   ----
! builtins/setattr.def
! 	- make `readonly', `export', and `declare' print `invisible' variables
! 	  as just a command and variable name, without a value, when listing
! 	  all variables (as POSIX.2-200x d6 requires)
  
! 				   5/30
  				   ----
  
! configure.in
! 	- upgraded to autoconf-2.50 on main development machine, so require
! 	  autoconf-2.50 in preparation for using some if its new features
! 	- call AC_C_PROTOTYPES
! 	- remove call to AC_EXEEXT, which now does the wrong thing
! 	- changed AC_INIT to new flavor
! 	- added call to AC_CONFIG_SRCDIR
! 	- AC_CONFIG_HEADER -> AC_CONFIG_HEADERS
! 	- AC_RETSIGTYPE -> AC_TYPE_SIGNAL
  
! configure.in, aclocal.m4, config.h.in
! 	- removed call to BASH_LARGE_FILE_SUPPORT, use AC_SYS_LARGEFILE
! 	  standard support, with new macros _FILE_OFFSET_BITS and
! 	  _LARGE_FILES
! 	- removed definition of BASH_LARGE_FILE_SUPPORT
  
! doc/bashref.texi
! 	- document new `--enable-largefile' configure option
  
  lib/readline/readline.c
! 	- change rl_set_prompt to call rl_expand_prompt unconditionally, so
! 	  local_prompt and local_prompt_prefix get set correctly
  
! 				    6/6
! 				    ---
! lib/readline/complete.c
! 	- don't append `/' or ` ' to a match when completing a symlink that
! 	  resolves to a directory, unless the match doesn't add anything
! 	  to the word.  This means that a tab will complete the word up to
! 	  the full name, but not add anything, and a subsequent tab will add
! 	  a slash.  Change to append_to_match; callers changed
  
! hashlib.c
! 	- new function, hash_table_nentries (table), returns the number of
! 	  items in TABLE
  
! hashlib.h
! 	- extern declaration for hash_table_nentries
  
! configure.in
! 	- configure without bash malloc on openbsd; they claim it needs
! 	  eight-bit alignment (which the bash malloc provides, but...)
  
! 				    7/2
! 				    ---
! stringlib.c
! 	- only call RESIZE_MALLOCED_BUFFER from strsub() if the replacement
! 	  string length is > 0, avoid possible hangs if replacement is null
  
! subst.c
! 	- don't include input.h; no longer needed
  
! configure.in
! 	- remove calls to AC_SYS_RESTARTABLE_SYSCALLS and
! 	  BASH_SYS_RESTARTABLE_SYSCALLS; the results are no longer used
  
! config.h.in
! 	- remove define for HAVE_RESTARTABLE_SYSCALLS
  
! aclocal.m4
! 	- removed definition of BASH_SYS_RESTARTABLE_SYSCALLS; no longer used
  
! execute_cmd.c
! 	- changed select command so `return' no longer terminates the select
! 	  command, so it can be used to return from an enclosing function.
! 	  This is as ksh (88 and 93) does it
  
! lib/readline/vi_mode.c
! 	- fix trivial typo in declaration of vi_motion; `t' appears twice;
! 	  the second instance should be `T'
  
! 				    7/3
! 				    ---
! configure.in
! 	- don't add -static to LDFLAGS on Solaris 2.x.  This means that the
! 	  auxiliary programs will be built as dynamic executables, but that
! 	  should do no harm
  
! 				    7/5
! 				    ---
! lib/glob/fnmatch.c
! 	- fix the code that processes **(pattern) to short-circuit if the
! 	  pattern is ill-formed or lacks a trailing `)'  -- this fixes the
! 	  segfault on **(/*)
  
! Makefile.in, builtins/Makefile.in
! 	- split CCFLAGS into CCFLAGS_FOR_BUILD and CFLAGS, to aid in
! 	  cross-compilation
! 	- build programs that use $(CC_FOR_BUILD) using $(CCFLAGS_FOR_BUILD)
! 
! configure.in, config.h.in
! 	- check for getaddrinfo(3), define HAVE_GETADDRINFO if found
  
! lib/sh/netopen.c
! 	- implemented a version of _netopen (_netopen6) that uses
! 	  getaddrinfo(3) if available, use if HAVE_GETADDRINFO is defined.
! 	  old _netopen is _netopen4; _netopen now calls either _netopen6
! 	  or _netopen4 as appropriate
! 
! 				    7/9
  				    ---
! builtins/exit.def
! 	- don't source ~/.bash_logout if subshell_environment is non-zero
  
! execute_command.c
! 	- in execute_until_or_while, handle the case where `breaking' is
! 	  set in the loop test (e.g., by the job control code when a job
! 	  is stopped with SIGTSTP), but the return value from the test is
! 	  something that would cause the loop to break.  Need to decrement
! 	  `breaking' in this case
  
! 				   7/10
! 				   ----
! execute_cmd.c
! 	- in execute_in_subshell, make sure a command of type cm_subshell
! 	  inherits its `enclosing' command's CMD_IGNORE_RETURN flag
  
! variables.c
! 	- in maybe_make_export_env, don't allow restricted shells to put
! 	  exported functions in the export environment
  
! 				   7/11
! 				   ----
! lib/glob/strmatch.h
! 	- renamed old fnmatch.h
! 	- changed guard #ifdef to _STRMATCH_H
! 	- include system <fnmatch.h> if HAVE_LIBC_FNM_EXTMATCH is defined
! 
! lib/glob/strmatch.c
! 	- renamed old fnmatch.c
! 	- include "strmatch.h"
! 	- if HAVE_LIBC_FNM_EXTMATCH is defined, define a dummy version of
! 	  strmatch() that just calls fnmatch(3)
  
! lib/glob/glob.c
! 	- include "strmatch.h"
! 	- fnmatch -> strmatch
  
! Makefile.in, lib/glob/Makefile.in
! 	- fnmatch -> strmatch
  
! {bashhist,execute_cmd,pathexp,pcomplete,shell,stringlib,subst,test}.c,
! pathexp.h,builtins/help.def
! 	- include <glob/strmatch.h>
! 	- fnmatch -> strmatch
  
! execute_cmd.c
! 	- broke the code that parses the interpreter name from a #! line
! 	  out from execute_shell_script to a new function, getinterp()
! 	- call getinterp from execute_shell_script
! 	- use return value from getinterp in error message about bad
! 	  #! interpreter in shell_execve
  
! 				   7/12
! 				   ----
! lib/readline/isearch.c
! 	- the last isearch string is now remembered in a new static variable,
! 	  last_isearch_string
! 	- if ^R^R is typed, readline now searches for the remembered isearch
! 	  string, if one exists
  
! 				   7/24
! 				   ----
! pcomplete.h
! 	- extern declaration for completions_to_stringlist()
  
! 				   7/25
! 				   ----
! builtins/complete.def
! 	- make compgen handle -o default option
! 	- make compgen return success only if sl->list_len is non-zero,
! 	  indicating that there are items on the list
  
! 				   7/31
! 				   ----
! execute_cmd.c
! 	- in execute_connection, force stdin to /dev/null for asynchronous
! 	  commands if job control is not active, not just if the shell is
! 	  running a shell script (since you can run `set -m' in a script)
  
! lib/readline/rltty.c
! 	- make sure _rl_tty_restore_signals resets `tty_sigs_disabled' on
! 	  successful restoration of the terminal modes
! 	- make sure _rl_tty_disable_signals turns off IXON so that ^S and
! 	  ^Q can be read by rl_quoted_insert
  
! 				    8/1
  				    ---
! aclocal.m4
! 	- new check for FNM_EXTMATCH being defined in <fnmatch.h>, as Ullrich
! 	  Drepper intends to do for new versions of GNU libc
  
! config.h.in
! 	- new definition for HAVE_LIBC_FNM_EXTMATCH
  
! configure.in
! 	- check for fnmatch, but don't define anything in config.h
! 	- call BASH_FUNC_FNMATCH_EXTMATCH to check for FNM_EXTMATCH
  
! 				    8/2
  				    ---
! alias.h
! 	- remove bogus extern declaration for xmalloc()
! 	- include "stdc.h"
! 	- add prototype declarations for all extern function declarations
! 
! xmalloc.c,lib/readline/xmalloc.c
! 	- fix xmalloc to return a PTR_T
! 	- fix xrealloc to return a PTR_T and take a PTR_T as first argument
  
! include/ansi_stdlib.h
! 	- extern declarations for malloc and realloc have them return PTR_T
  
! xmalloc.h
! 	- new file, with extern declarations for functions in xmalloc.c
  
! general.h
! 	- removed extern declarations for functions in xmalloc.c
! 	- include xmalloc.h
  
! Makefile.in,builtins/Makefile.in
! 	- update dependencies to include xmalloc.h
  
! parse.y,{alias,array,bashline,bracecomp,execute_cmd,findcmd,flags,general,
! hashcmd,locale,mailcheck,make_cmd,pathexp,pcomplete,print_cmd,stringlib,
! subst,unwind_prot,variables}.c
! builtins/{common,evalfile}.c
! builtins/{cd,command,enable,exec,printf,read,set}.def
! lib/sh/{makepath,netopen,pathphys,setlinebuf,shquote,snprintf,stringlist,
! strtrans,tmpfile}.c
! lib/readline/{util,terminal,shell,readline,macro,kill,isearch,input,
! histfile,histexpand,display,complete,bind}.c
! 	- make sure all calls to xmalloc are cast to the right return value
  
! siglist.c
! 	- include xmalloc.h
  
! parse.y,{alias,bashline,bracecomp,expr,make_cmd,nojobs,print_cmd,subst}.c
! builtins/{fc,printf,read}.def
! lib/sh/snprintf.c, lib/tilde/tilde.c
! lib/readline/{bind,display,histexpand,isearch,macro,util,vi_mode}.c
! 	- make sure all calls to xrealloc are cast to the right return value
  
! lib/sh/{netopen,setlinebuf,shquote,snprintf}.c, lib/tilde/tilde.c
! 	- include xmalloc.h, remove extern declaration of xmalloc
  
! lib/readline/xmalloc.h
! 	- xmalloc and xrealloc should return PTR_T
  
! lib/readline/rldefs.h
! 	- don't include an extern declaration for xmalloc
  
! 				    8/7
! 				    ---
! support/shobj-conf
! 	- fixed up commented-out stanzas for HP's unbundled C compiler on
! 	  HP/UX
  
! support/bashbug.sh
! 	- force the subject to be changed from the default
  
! lib/readline/doc/{rluser.texinfo,readline.3}, doc/bash.1
! 	- document that transpose-words swaps the last two words on the line
! 	  if point is at the end of the line
  
! 				    8/9
! 				    ---
! stringlib.c
! 	- fix possible infinite recursion problem with null pattern in
! 	  strsub()
  
! hashlib.c
! 	- new function copy_hash_table to copy a hash table using a caller-
! 	  supplied function to copy item data (defaults to savestring())
  
! hashlib.h
! 	- new extern declaration for copy_hash_table
  
! builtins/declare.def
! 	- changes so that declare [-a] var=value assigns `value' to element 0
! 	  of array variable `var' like ksh93
! 	- change so that declare [-a] var[N]=value assigns `value' to element
! 	  N of array variable `var' like ksh93
  
! 				   8/13
  				   ----
! arrayfunc.c
! 	- new file, for miscellaneous array functions
  
! arrayfunc.h
! 	- new file, extern declarations for functions in arrayfunc.c
  
! variables.c
! 	- move convert_var_to_array, bind_array_variable,
! 	  assign_array_from_string, assign_array_var_from_word_list,
! 	  assign_array_var_from_string, quote_array_assignment_chars,
! 	  skipsubscript, unbind_array_element, print_array_assignment
! 	  to arrayfunc.c
  
! shell.h
! 	- include arrayfunc.h after variables.h
  
! variables.h
! 	- remove above extern function declarations moved to arrayfunc.h
! 	- add extern declaration for var_lookup
  
! Makefile.in
! 	- add arrayfunc.c, arrayfunc.h in appropriate places
! 	- add arrayfunc.h to dependencies
  
! subst.c
! 	- move valid_array_reference, array_expand_index, array_variable_part,
! 	  array_value_internal, array_value (now global), get_array_value,
! 	  do_array_element_assignment to arrayfunc.c
  
! subst.h
! 	- extern declarations for functions above moved to arrayfunc.h
  
! arrayfunc.h
! 	- extern declarations for above functions from subst.c
  
! subst.[ch]
! 	- string_list_dollar_star and string_list_dollar_at are now global
! 	  functions
! 	- quote_escapes is now a global function
  
! subst.c
! 	- maybe_expand_string -> expand_string_if_necessary
! 	- expand_string_to_string -> expand_string_to_string_internal
! 	- new functions: expand_string_to_string and
! 	  expand_string_unsplit_to_string, which call
! 	  expand_string_to_string_internal with expand_string and
! 	  expand_string_unsplit as the FUNC arguments, respectively
! 
! arrayfunc.c
! 	- change array_expand_index to call expand_string_to_string instead
! 	  of maybe_expand_string
  
! 				   8/14
  				   ----
! shell.c
! 	- in execute_env_file, call expand_string_unsplit_to_string
  
! mailcheck.c
! 	- in check_mail, call expand_string_to_string
  
! variables.c
! 	- in assign_in_env, call expand_string_unsplit_to_string
  
! arrayfunc.c
! 	- new function, array_variable_name, splits an array reference into
! 	  a name (which is returned as a new string) and subscript
! 	- change array_variable_part to just call array_variable_name and
! 	  look up the string returned with find_variable
! 	- new function, find_or_make_array_variable (name, flags) which will
! 	  look up an array variable and convert a string variable to an
! 	  array if necessary.  The FLAGS argument, if non-zero, says to
! 	  check the readonly and noassign attributes and fail if either is set
  
! builtins/read.def
! 	- make `read -a aname' honor any readonly status of `aname'
! 	- read -a now calls find_or_make_array_variable with FLAGS value 1
  
! arrayfunc.[ch], subst.c, builtins/{declare,read}.def
! 	- do_array_element_assignment -> assign_array_element
  
! 				   8/20
! 				   ----
! parse.y
! 	- changed `for' command grammar to allow missing word list after `IN'
! 	  token, like latest POSIX drafts require
  
! lib/sh/tmpfile.c
! 	- in sh_mktmpname(), check for filenum == 0 and init to non-zero number
! 	  in this case.  it can happen on arithmetic overflow
  
! support/mkversion.sh
! 	- added `[0-9].[0-9][0-9][a-z]' as an acceptable value for a
! 	  distribution to allow for intermediate versions, like 2.05a
  
! support/config.guess
! 	- removed the addition of the output of `/usr/bin/objformat' when
! 	  creating the canonical name on FreeBSD machines, so the canonical
! 	  name is once again `freebsd4.2' instead of `freebsdelf4.2'
  
! 				   8/22
  				   ----
! lib/readline/{rlstdc,history,keymaps,readline,rldefs,rlprivate,rlshell,
! rltypedefs,xmalloc}.h
! lib/readline/{bind,compat,complete,display,funmap,histexpand,histsearch,
! input,isearch,kill,nls,parens,readline,rltty,search,shell,signals,vi_mode
! 	- changed __P to PARAMS
  
! lib/tilde/tilde.[ch]
! 	- changed __P to PARAMS
  
! {Makefile,configure}.in
! 	- changed the version number to 2.05a
! 	- changed the release status to `alpha1'
  
! 				   8/23
  				   ----
! support/shobj-conf
! 	- support for building shared libraries on Darwin/MacOS X
  
! siglist.h
! 	- extern declaration for strsignal() to compensate for lack of
! 	  a definition in some system include files
  
! jobs.c
! 	- remove casts from strsignal() calls
  
! [bash-2.05a-alpha1 frozen]
  
! 				   8/27
  				   ----
! [bash-2.05a-alpha1 released]
  
! 				   8/27
  				   ----
! execute_cmd.c
! 	- fix eval_arith_for_expr to handle the case where the expanded
! 	  word list is NULL, returning 0 in this case
  
! print_cmd.c
! 	- in print_function_def, make sure that func_redirects is assigned
! 	  a value before being used
  
! 				   8/28
! 				   ----
! alias.c
! 	- include <ctype.h> for definition of isalpha()
  
! bashhist.h
! 	- add prototypes for extern function declarations
  
! flags.c
! 	- include bashhist.h for extern function declarations
  
! mksyntax.c
! 	- include <unistd.h> if HAVE_UNISTD_H is defined in config.h
  
! parse.y
! 	- include test.h for extern function declarations
  
! externs.h
! 	- change extern declaration for setlinebuf to sh_setlinebuf
  
! stringlib.c
! 	- include <glob/glob.h> for extern function declarations
  
! variables.h
! 	- add function prototypes for all of the sv_* functions
  
  builtins/common.h
! 	- add extern declarations for set_shellopts() and parse_shellopts()
! 	  from builtins/set.def
  
! variables.c
! 	- include "hashcmd.h" for extern declaration for flush_hashed_filenames
! 	- include "pathexp.h" for extern declaration for setup_glob_ignore
  
! lib/malloc/malloc.c
! 	- cast to `long' instead of `int' in memalign for 64-bit machines
  
! {pcomplete,trap}.c
! 	- changed printf escape sequences used to print pointers to %p
  
! lib/readline/undo.c
! 	- include "xmalloc.h" for extern function declaration
  
! input.h
! 	- add function prototypes to extern declarations for getc_with_restart
! 	  and ungetc_with_restart
  
! variables.[ch]
! 	- changed type of `function' member of `struct name_and_function' to
! 	  `sv_func_t', which is defined and prototyped in variables.h
! 	- map_over now takes an `sh_var_map_func_t *'
  
! shell.h
! 	- start of a set of function pointer typedefs like those in
! 	  lib/readline/rltypedefs.h
  
! hashlib.[ch]
! 	- second paramter to flush_hash_table is now an `sh_free_func_t *'
  
! trap.c
! 	- parameter to reset_or_restore_signal_handlers is now an
! 	  `sh_resetsig_func_t *'
  
! pcomplete.h, pcomplib.c
! 	- function pointer argument to print_all_compspecs is now an
! 	  `sh_csprint_func_t *'
! 	- function pointer `list_getter' element of an `ITEMLIST' is now
! 	  prototyped with __P((...)) instead of using `Function *'
  
! jobs.[ch]
! 	- `j_cleanup' member of a JOB is now an `sh_vptrfunc_t *'
  
! alias.c
! 	- map_over_aliases now takes an `sh_alias_map_func_t *'
! 	- free_alias_data now takes a `PTR_T'
  
! pathexp.c
! 	- function pointer argument to ignore_globbed_names is now an
! 	  `sh_ignore_func_t *' 
  
  bashline.c
! 	- function pointer argument to _ignore_completion_names is now an
! 	  `sh_ignore_func_t *' 
  
! pathexp.h,{bashhist,bashline.c
! 	- `item_func' member of a `struct ignorevar' is now an
! 	  `sh_iv_item_func_t *'
  
! builtins/evalfile.c
! 	- `errfunc' is now an `sh_vmsg_func_t *'
  
! jobs.c
! 	- map_over_job now takes an `sh_job_map_func_t *' as its first argument
  
! array.[ch]
! 	- function pointer argument to array_walk is now an
! 	  `sh_ae_map_func_t *'
  
! general.c
! 	- tilde_expansion_preexpansion_hook has type `tilde_hook_func_t *',
! 	  and so the assignment in tilde_initialize doesn't need a cast
  
! list.c
! 	- map_over_words now takes an `sh_icpfunc_t *' as its second argument
  
! input.h
! 	- the `getter' and `ungetter' function pointer members of a
! 	  BASH_INPUT are now of types `sh_cget_func_t *' and
! 	  `sh_cunget_func_t *' respectively
! 	- init_yy_io now takes an `sh_cget_func_t *' as its first argument and
! 	  an `sh_cunget_func_t *' as its second
  
! parse.y
! 	- init_yy_io now takes an `sh_cget_func_t *' as its first argument and
! 	  an `sh_cunget_func_t *' as its second
! 	- initialize_bash_input casts bash_input.getter and bash_input.ungetter
! 	  appropriately
  
! builtins/mkbuiltins.c
! 	- make the extern function definitions written to builtext.h have
! 	  prototypes with __P((...))
! 	- include "stdc.h"
! 	- change Function to mk_handler_func_t
! 	- fixed comment_handler to take the right number of args
! 	- prototyped all the handler functions with __P((...))
! 
! builtins.h
! 	- the `function' member of a struct builtin is now of type
! 	  `sh_builtin_func_t *'
! 
! builtins/common.[ch]
! 	- last_shell_builtin, this_shell_builtin are now of type
! 	  `sh_builtin_func_t *'
! 	- find_shell_builtin, builtin_address, find_special_builtin now return
! 	  `sh_builtin_func_t *'
! 
! builtins/exit.def, {execute_cmd,jobs,nojobs,variables}.c, parse.y
! 	- changed all declarations of last_shell_builtin and this_shell_builtin
! 
! execute_cmd.c
! 	- execute_builtin, execute_builtin_or_function,
! 	  execute_subshell_builtin_or_function now take an
! 	  `sh_builtin_func_t *' instead of a `Function *' for argument
! 	- changed appropriate variables from `Function *' to
! 	  `sh_builtin_func_t *'
! 
! builtins/{bind,builtin,enable,read,setattr}.def
! 	- replaced uses of `Function *' in variable declarations with
! 	  appropriate types (sh_builtin_func_t * or rl_command_func_t *)
  
! builtins/set.def
! 	- set_func and get_func members of binary_o_options are now of types
! 	  `setopt_set_func_t *' and `setopt_get_func_t *', which are
! 	  prototyped
  
! builtins/shopt.def
! 	- set_func member of shopt_vars is now of type `shopt_set_func_t *'
  
! bashline.c
! 	- enable_hostname_completion now returns `int' (the old value of
! 	  perform_hostname_completion)
  
! [The only use of Function and VFunction now is for unwind-protects]
  
! 				    9/4
! 				    ---
! lib/sh/getcwd.c
! 	- use const define from config.h rather than `CONST'
! 	- use PTR_T define from xmalloc.h rather than `PTR'
! 	- include xmalloc.h for PTR_T
! 	- remove PATH_MAX define, rely on value from maxpath.h
! 
! {general,mailcheck}.c, lib/sh/{pathcanon,pathphys}.c
! 	- don't include maxpath.h directly; it's already included by shell.h
! 
! lib/sh/mailstat.c
! 	- new `mailstat()' implementation, to stat a mailbox file for
! 	  mail checking.  handles maildir-style mail directories with one
! 	  file per message and creates a dummy stat struct from them
  
! lib/sh/Makefile.in
! 	- add mailstat.c and mailstat.o in the appropriate places
  
! lib/malloc/malloc.c
! 	- augmented implementation with wrapper functions that pass in file
! 	  and line number information from cpp.  currently unused, but a
! 	  placeholder for future debugging and use tracking
! 
! lib/malloc/shmalloc.h
! 	- new file, extern declarations for allocation wrapper functions for
! 	  use by the shell (and others, I guess)
! 
! xmalloc.[ch]
! 	- wrapper functions for xmalloc, xfree, xrealloc (sh_ prefixed) that
! 	  pass cpp line number information through to the malloc functions,
! 	  if USING_BASH_MALLOC is defined
  
! 				    9/5
  				    ---
! lib/malloc/gmalloc.c
! 	- removed; no longer part of distribution
  
! lib/malloc/Makefile.in
! 	- removed references to gmalloc.[co]
  
! configure.in, doc/bashref.texi
! 	- removed references to `--with-glibc-malloc' configure option
  
! {configure,Makefile}.in
! 	- changed the way bash malloc is configured into the Makefile, making
! 	  it more like how readline is configured.  If the bash malloc is
! 	  not configured in, nothing in lib/malloc will be built
  
! 				    9/6
! 				    ---
! lib/malloc/imalloc.h
! 	- new file, some internal malloc definitions
  
! lib/malloc/mstats.h
! 	- new file, definitions for malloc statistics structs and functions
  
! lib/malloc/trace.c
! 	- new file, malloc tracing functions (currently just print messages
! 	  to stderr), code is #ifdef MALLOC_TRACE
  
! lib/malloc/stats.c
! 	- new file, moved malloc stats code from malloc.c to here
  
! lib/malloc/malloc.c
! 	- moved some definitions to imalloc.h
! 	- moved stats code to stats.c
! 	- malloc tracing calls added to internal_{malloc,realloc,free}, all
! 	  #ifdef MALLOC_TRACE
  
! lib/malloc/Makefile.in, Makefile.in
! 	- added {imalloc,mstats}.h, {trace,stats}.c
  
! parse.y
! 	- changed decode_prompt_string to save and restore $?
! 	  (last_command_exit_value) around calls to expand_prompt_string(),
! 	  so command substitutions in PS1, etc. don't change $?
  
! {array,subst}.c
! 	- a couple more arrayind_t fixes from Paul Eggert
  
! configure.in
! 	- remove redundant check for wait3(2)
  
! redir.h
! 	- fixed a typo (stdin_redirs -> stdin_redirects)
  
! 				   9/10
! 				   ----
! execute_cmd.c
! 	- remove check for \n and \r from WHITESPACE macro, since those
! 	  chars are not whitespace as returned by the whitespace(c) macro
! 	- getinterp now takes a `char *' as first arg, not unsigned char *
! 	- execute_shell_script now takes a `char *' as first arg, not
! 	  unsigned char *
! 	- fix typo in forward declaration for `initialize_subshell'
! 	
! general.[ch]
! 	- check_binary_file now takes a (char *) argument, not unsigned char *
! 	- pass unsigned char to isspace and isprint because of ISO C fuckup
! 	- bash_tilde_expand now takes a `const char *' as its argument
  
! builtins/evalfile.c, shell.c
! 	- buffer passed to check_binary_file is char, not unsigned char
  
! parse.y
! 	- fix extern declaration for yyerror()
! 	- yyerror now takes a `const char *' as first arg
  
! {error,jobs}.c
! 	- fixes to printf-style functions to handle pids wider than an int
  
! lib/readline/{isearch,vi_mode}.c
! 	- fix call to rl_message in rl_display_search (remove extra arg)
  
! variables.c
! 	- fix missing argument to builtin_error in make_local_variable
  
! builtins/getopts.def
! 	- since getopts takes no options, change while loop calling
! 	  internal_getopts to a simple `if' check
  
! builtins/printf.def
! 	- since printf takes no options, change while loop calling
! 	  internal_getopts to a simple `if' check
  
! lib/readline/bind.c
! 	- remove _SET_BELL macro, expand code inline
  
! lib/readline/input.c
! 	- change _rl_input_available to use either select or FIONREAD,
! 	  but not both
  
! lib/readline/readline.c
! 	- fix rl_digit_loop to remove unreachable code at end of loop
  
! {bashhist,bashline,expr,jobs,redir,shell}.c, builtins/fc.def, lib/sh/snprintf.c
! 	- bracket unused functions with #ifdef INCLUDE_UNUSED/#endif
! 	- remove some unused variables
  
  execute_cmd.c
! 	- remove #ifdef'd code that allowed `return' to terminate a select
! 	  statement
  
! expr.c
! 	- remove some extraneous tests from strlong()
  
! array.h
! 	- arrayind_t is now a long, since shell arithmetic is performed as
! 	  longs
! 	- remove second declaration of new_array_element
  
! builtins/printf.def
! 	- in mklong, xrealloc cannot return NULL, so don't check for it
! 	- remove some #if 0 code
! 	- fix core dump triggered by a format specification with more than
! 	  one `*'
! 	- remove `foundmod', since its value mirrors `modchar != 0'
! 	- include "common.h" for builtin_{error,usage} declarations
  
! Makefile.in,builtins/Makefile.in
! 	- updated some dependencies due to new include files
  
! pcomplete.c
! 	- include "execute_cmd.h" for declaration of execute_shell_function
  
! arrayfunc.c
! 	- include <stdio.h> for printf
! 	- include "builtins/common.h" for builtin_error declaration
  
! builtins/evalstring.c
! 	- include "../trap.h" for run_trap_cleanup declaration
  
! builtins/help.def
! 	- include "common.h" instead of locally declaring builtin_error
! 	  and builtin_usage
  
! error.h
! 	- add extern declaration for itrace()
! 	- add prototype to extern declaration of get_name_for_error
! 	- file_error now takes a `const char *' as first argument
  
! externs.h
! 	- added prototype for sh_setlinebuf declaration, bracketed with
! 	  NEED_SH_SETLINEBUF_DECL so we don't need stdio.h everywhere
! 	- add extern declaration for parse.y:return_EOF()
  
! shell.c
! 	- add NEED_SH_SETLINEBUF_DECL before including shell.h
  
! lib/readline/callback.c
! 	- include <stdlib.h> or "ansi_stdlib.h" for abort declaration
  
! quit.h
! 	- remove declaration of throw_to_top_level
  
! subst.c
! 	- remove unused extern declaration for getopts_reset
  
! lib/sh/netopen.c
! 	- include <shell.h> for legal_number, etc.
! 	- add prototype for inet_aton extern declaration
  
! lib/sh/clock.c
! 	- include <stdc.h> for __P declaration
! 	- add extern declaration for get_clk_tck
  
! support/mkversion.sh
! 	- changed so that extern function declarations for functions in
! 	  version.c (moved from externs.h) are in the generated version.h
  
! shell.h
! 	- include version.h
  
! version.c
! 	- various `char *' version variables are now `const char *'
  
! general.h
! 	- add prototype for same_file, bracketed with _POSIXSTAT_H
! 	  #ifdef, since that's what include/posixstat.h defines
  
! builtins/common.[ch]
! 	- _evalfile, maybe_execute_file, source_file, and fc_execute_file
! 	  now take a `const char *' as their first argument
  
! eval.c
! 	- removed extern declaration of yyparse; it's in externs.h
  
! parse.y
! 	- added prototypes to static forward function declarations
! 	- changed local `all_digits' variable in read_token_word () to
! 	  all_digit_token to avoid clash with all_digits() function in
! 	  general.c
  
! {bashhist,copy_cmd,make_cmd,hashlib,mailcheck}.c
! 	- added prototypes for static function declarations
  
! shell.h
! 	- add extern declarations for interactive, interactive_shell,
! 	  changed c files with extern declarations
  
! pcomplete.c
! 	- changed it_init_aliases to avoid shadowing global variable
! 	  `aliases'
  
! bashline.c,pathexp.c,general.h
! 	- sh_ignore_func_t is now a pointer to a function taking a
! 	  `const char *'; users changed
! 
! configure.in
! 	- test for <strings.h>
  
  config.h.in
! 	- add #undef HAVE_STRINGS_H
  
! bashansi.h
! 	- change like recommended in autoconf manual
  
! 				   9/11
  				   ----
! [a date which will live in infamy.  prayers for the victims.]
  
! execute_cmd.c
! 	- don't use an absolute index into abuf in mkfmt, use
! 	  sizeof(abuf) to compute last index
  
! builtins/common.c
! 	- fix read_octal to do a better job of detecting overflow while
! 	  iterating through the string
  
! builtins/umask.def
! 	- change octal-print mode to print 4 digits, like other shells
! 	- cast umask to unsigned long to avoid problems on systems where
! 	  it's wider than an int (POSIX doesn't guarantee that mode_t is
! 	  no wider than an int, but real-world systems use int)
  
! builtins/printf.def
! 	- mklong can never return NULL (it uses xrealloc), so the mainline
! 	  doesn't need to check for NULL returns
! 	- new function, getldouble (long double *), to get long doubles
! 	- mklong now takes a `char *' as its second argument, the modifier(s)
! 	  to use
! 	- changed use of `modchar' to handle more than a single modifier
! 	  character
! 	- changed to handle `long double' and `L' formats better, rather
! 	  than discarding long double information
! 	- since printf now follows the POSIX.2 rules for conversion errors,
! 	  we can dispense with the status returns from the get* functions
! 	- make the get* functions as similar in structure as possible,
! 	  removing type casts, etc.
! 
! lib/sh/timeval.c,execute_cmd.c
! 	- change some instances of `long' to `time_t', for systems where
! 	  a time_t is bigger than a long
! 
! jobs.c
! 	- include "posixtime.h" instead of <sys/time.h>
! 
! config.h.in
! 	- add defines for HAVE_DECL_CONFSTR, HAVE_DECL_STRTOLD,
! 	  HAVE_DECL_SBRK, HAVE_DECL_PRINTF
! 	- remove defines for SBRK_DECLARED and PRINTF_DECLARED
! 	- add _GNU_SOURCE define
! 
! configure.in
! 	- add AC_CHECK_DECLS for strtold, confstr, sbrk, printf
! 	- remove call to BASH_FUNC_SBRK_DECLARED
! 	- remove call to BASH_FUNC_PRINTF
  
! xmalloc.c, lib/malloc/malloc.c
! 	- change check of SBRK_DECLARED to HAVE_SBRK_DECL
  
! print_cmd.c
! 	- change PRINTF_DECLARED to HAVE_DECL_PRINTF
  
! builtins/evalstring.c, builtins/common.h
! 	- parse_and_execute now takes a `const char *' as its second argument
  
! input.h,parse.y
! 	- with_input_from_* functions now take a `const char *' as their
! 	  second argument
! 	- init_yy_io now takes a `const char *' as its fourth argument
  
! parse.y,externs.h
! 	- parse_string_to_word_list now takes a `const char *' as its second
! 	  argument
  
! tests/builtins.right
! 	- change output to account for extra digit in umask output
  
! pcomplib.c
! 	- free_progcomp now takes a PTR_T argument
  
! builtins/bashgetopt.h
! 	- include <stdc.h>
! 	- add prototypes to extern declarations
  
! builtins/shopt.def
! 	- add prototypes to static function declarations
  
! builtins/{fc,umask,wait}.def, builtins/{bashgetopt,common}.c
! 	- include <ctype.h> for isdigit macro (referenced by `digit(x)')
  
! lib/readline/complete.c
! 	- added more static function declarations with prototypes
  
! 				   9/12
! 				   ----
! lib/sh/tmpfile.c
! 	- use `^' instead of `*' in sh_mktmpname to make filenames a bit
! 	  more random
  
! include/stdc.h,lib/readline/rldstdc.h
! 	- add __attribute__ definition 
  
! builtins/common.h
! 	- add printf __attribute__ to declaration of builtin_error
  
! error.h
! 	- add printf __attribute__ to declaration of programming_error,
! 	  report_error, parser_error, fatal_error, sys_error, internal_error,
! 	  internal_warning
  
! lib/readline/readline.h
! 	- add printf __attribute__ to declaration of rl_message
  
! pcomplete.c
! 	- add printf __attribute__ to declaration of debug_printf
  
! print_cmd.c
! 	- add printf __attribute__ to declarations of cprintf, xprintf
  
! include/chartypes.h
! 	- new file, includes <ctype.h> and defines macros that check for
! 	  safe (ascii) arguments before calling the regular ctype macros
! 
! {alias,bashline,execute_cmd,expr,findcmd,general,locale,mksyntax,stringlib,subst,variables}.c
! parse.y
! builtins/{bashgetopt,common}.c
! builtins/{fc,printf,umask,wait}.def
! lib/glob/strmatch.c
! lib/sh/{oslib,pathcanon,pathphys,snprintf,strcasecmp,strindex,stringvec,strtod,strtol,strtrans}.c
! examples/loadables/{head,sleep}.c
! 	- include "chartypes.h" or <chartypes.h> instead of <ctype.h>
  
! Makefile.in,{builtins,lib/{glob,sh}}/Makefile.in
! 	- update dependencies to include chartypes.h
  
! lib/sh/inet_aton.c
! 	- use `unsigned char' instead of `char' to pass to ctype.h functions
  
! lib/sh/netopen.c
! 	- check for '0' <= host[0] <= '9' in _getaddr instead of using
! 	  isdigit
  
! subst.c,lib/sh/shquote.c
! 	- change array subscripts into sh_syntaxtab from `char' to
! 	  `unsigned char'
! 
! {alias,bashline,execute_cmd,expr,general,subst}.c, parse.y
! builtins/{fc,printf,umask,wait}.def builtins/{bashgetopt,common}.c
! lib/sh/{pathcanon,pathphys,snprintf,strcasecmp,strindex,strtod,strtol,strtrans}.c
! examples/loadables/{head,sleep}.c
! 	- change to use some of the new macros in chartypes.h
! 	- remove old local macro definitions now provided by chartypes.h
  
! general.h
! 	- remove definition of isletter, ISOCTAL, digit, digit_value
! 	- change legal_variable_starter and legal_variable_char to use
! 	  chartypes.h macros
! 	- change ABSPATH to use chartypes.h macros
  
! lib/readline/util.c
! 	- change to use Paul Eggert's FUNCTION_FOR_MACRO define to define
! 	  function replacements for macros in chardefs.h
  
! lib/readline/chardefs.h
! 	- added some of the same macros as in chartypes.h
! 	- change _rl_lowercase_p, _rl_uppercase_p, _rl_digit_p,
! 	  _rl_to_upper, _rl_to_lower to use new IS* macros
! 	- added _rl_isident macro from vi_mode.c:isident
  
! lib/readline/{bind,complete,nls}.c
! 	- change to use some of the new macros from chardefs.h
  
! lib/readline/vi_mode.c
! 	- isident -> _rl_isident
! 	- remove local defines of macros in chardefs.h
  
! lib/sh/strtol.c
! 	- updated to new version, modified from glibc 2.2.4 and sh-utils-2.0.
! 	  This one can do strtoll and strtoull, if necessary
  
! 				   9/13
  				   ----
! builtins/ulimit.def
! 	- changed get_limit so it retrieves both hard and soft limits
! 	  instead of one or the other
! 	- changed callers of get_limit
! 	- changed getmaxvm to take soft limit, hard limit as arguments
! 	- changed getmaxuprc to just take a single argument, the value
! 	- changed calls to printone() to pass soft limit or hard limit
! 	  depending on `mode' instead of using old current_limit variable
! 	- moved check for out-of-range limits in ulimit_internal into the
! 	  block that converts a string argument to a value of type rlim_t
! 	- changed RESOURCE_LIMITS struct to break the description into a
! 	  description string and separate scale factor string
! 	- changed print_all_limits to print a single error message if
! 	  get_limit fails, including limits[i].description now that the
! 	  scale factor has been removed from the description string
! 	- removed DESCFMT define, since it's now used only in printone()
! 	- changed printone to print the option character associated with a
! 	  particular limit if we're printing multiple limits
! 	- changed calls to builtin_error to print the description associated
! 	  with a limit if setting or getting the limit fails
! 	- added support for new POSIX 1003.1-200x rlim_t values:
! 	  RLIM_SAVED_CUR and RLIM_SAVED_MAX, which expand to the current
! 	  soft and hard limits, whatever they are
! 	- changed printone to print `hard' or `soft' if the current limit is
! 	  RLIM_SAVED_MAX or RLIM_SAVED_CUR, respectively
! 	- changed ulimit_internal to handle new `hard' and `soft' arguments
! 	- changed help text do describe the special limit arguments `hard',
! 	  `soft', and `unlimited'
! 
! doc/{bash.1,bashref.texi}
! 	- documented new `hard' and `soft' limit arguments to `ulimit'
! 
! hashlib.[ch]
! 	- find_hash_item now takes a `const char *' is its first argument
! 	- hash_string now takes a `const char *' is its first argument
! 	- remove_hash_item now takes a `const char *' as its first argument
  
! pcomplib.c
! 	- removed cast from first argument to find_hash_item in find_compspec
  
! general.[ch]
! 	- absolute_program now takes a `const char *' as its argument
! 	- absolute_pathname now takes a `const char *' as its argument
  
! lib/glob/glob.[ch]
! 	- glob_pattern_p now takes a `const char *' as its argument
  
! bashline.c
! 	- removed cast from first argument to absolute_program in
! 	  command_word_completion_function
! 	- removed cast from first argument to glob_pattern_p in
! 	  attempt_shell_completion
! 
! findcmd.[ch]
! 	- find_absolute_program, find_user_command, find_path_file,
! 	  search_for_command, user_command_matches now take a
! 	  `const char *' as their first argument
! 	- file_status, executable_file, is_directory, executable_or_directory
! 	  now take a `const char *' as their argument
! 	- _find_user_command_internal, find_user_command_internal,
! 	  find_user_command_in_path 
! 
! lib/sh/makepath.c, externs.h
! 	- changed sh_makepath so it takes `const char *' for its first
! 	  two arguments
! 
! hashcmd.[ch]
! 	- find_hashed_filename now takes a `const char *' as its first arg
! 	- remove_hashed_filename now takes a `const char *' as its first arg
  
! variables.[ch]
! 	- new_shell_variable, var_lookup, shell_var_from_env_string,
! 	  find_name_in_env_array, bind_function, makunbound,
! 	  bind_name_in_env_array, bind_tempenv_variable, bind_variable
! 	  now take a `const char *' as their first arg
! 	- find_function, make_new_variable, find_tempenv_variable,
! 	  find_variable_internal, find_variable, set_func_read_only,
! 	  set_func_auto_export, all_variables_matching_prefix, assign_in_env,
! 	  assignment, kill_local_variable, make_local_variable, unbind_variable
! 	  now take a `const char *' as their arg
! 	- mk_env_string now takes `const char *' arguments
  
! arrayfunc.[ch]
! 	- skipsubscript now takes a `const char *' as its argument
  
! 				   9/17
! 				   ----
! lib/readline/complete.c
! 	- attempt to preserve case of what the user typed in
! 	  compute_lcd_of_matches if we're ignoring case in completion
  
! builtins/{let,pushd}.def,{execute_cmd,expr}.c
! 	- change some 0L constants to 0 and let the compiler sort it out
  
! 				   9/18
  				   ----
! lib/malloc/alloca.c
! 	- alloca now takes a `size_t' argument
  
! include/memalloc.h
! 	- if we're providing an extern function declaration for alloca,
! 	  use `void *' and prototype if __STDC__ is defined
! 	- if HAVE_ALLOCA_H is defined, but C_ALLOCA is defined, don't
! 	  define HAVE_ALLOCA
  
! 				   9/19
  				   ----
  subst.c
! 	- do_assignment_internal, do_assignment, and do_assignment_no_expand
! 	  now take a `const char *' as their first argument
  
! general.h
! 	- a `sh_assign_func_t' is now a function taking a `const char *' and
! 	  returning int
  
! hashcmd.c
! 	- free_filename_data now takes a `PTR_T' argument to agree with the
! 	  typedef for `sh_free_func_t'
  
! lib/sh/snprintf.c
! 	- use TYPE_MAXIMUM define like strtol.c instead of huge constants
  
! 				   9/20
  				   ----
! lib/sh/snprintf.c
! 	- don't bother to compile the bulk of the body unless HAVE_SNPRINTF
! 	  or HAVE_ASPRINTF is not defined
  
! 				   9/24
  				   ----
! flags.c
! 	- ignore `set -n' if the shell was started interactively
  
! lib/readline/readline.c
! 	- initialize readline_echoing_p to 0; let the terminal-specific code
! 	  in rltty.c set it appropriately
  
! lib/malloc/malloc.c
! 	- changed internal_memalign() slightly to avoid compiler warnings about
! 	  negating an unsigned variable (-alignment -> (~alignment + 1))
  
! 				   9/27
  				   ----
! lib/readline/readline.c
! 	- changed rl_newline to set _rl_history_saved_point appropriately
! 	  for the {previous,next}_history code
  
! lib/readline/rlprivate.h
! 	- extern declaration for _rl_history_preserve_point
  
! lib/readline/bind.c
! 	- new bindable variable, `history-preserve-point', sets value of
! 	  _rl_history_preserve_point
  
! 				   10/1
! 				   ----
! lib/malloc/table.c
! 	- new file, with a map of allocated (and freed) memory for debugging
! 	  multiple frees, etc.  Indexed by hash on values returned by
! 	  malloc(); holds size, file and line number info for last alloc or
! 	  free and a couple of statistics pointers
  
! lib/malloc/malloc.c
! 	- a few cleanups; added calls for registering allocations and frees
! 	  if MALLOC_REGISTER is defined
! 	- replaced MALLOC_RETURN with explicit MALLOC_NOTRACE define
! 	- reordered fields in `struct...minfo' in `union mhead' to restore
! 	  eight-byte alignment
! 	- added explicit checks for underflow in free and realloc since
! 	  checking mh_magic2 is not sufficient to detect everything (it's
! 	  no longer the last field in the struct, and thus not the bytes
! 	  immediately preceding what's returned to the user)
! 	- new function, xbotch, for printing file and line number info for
! 	  the failed assertion before calling botch() (programming_error())
! 
! configure.in
! 	- replaced call to BASH_C_LONG_LONG with call to
! 	  AC_CHECK_TYPES([long long])
! 	- moved the C compiler tests before the tests for various
! 	  system types, so we can know whether we have `long long'
! 	  before testing for 64-bit types
! 	- if we have `long long', check for sizeof(long long) and save value
  
! aclocal.m4
! 	- changed BASH_TYPE_BITS64_T to check `long long' before `long', but
! 	  after `double'
  
! 				   10/2
! 				   ----
! lib/malloc/malloc.c
! 	- made malloc and realloc both agree on the rounding for a request of
! 	  size N (round up to nearest multiple of 8 after adjusting for
! 	  malloc overhead); uses new ALLOCATED_BYTES macro
! 	- realloc and free now use new IN_BUCKET macro for underflow checks
  
! execute_cmd.c
! 	- fixed time_command() to use `time_t' instead of `long' to hold
! 	  time stamps
  
! lib/sh/clock.c
! 	- clock_t_to_secs now takes a `time_t *' second argument
! 	- fixed print_clock_t to call clock_t_to_secs with right arguments
  
! lib/sh/timeval.c
! 	- fixed print_timeval to make `minutes' a `long' and make its
! 	  structure identical to print_clock_t
  
! redir.c
! 	- changed redirection_error to check for EBADF and use the file
! 	  descriptor being redirected from in the error message if it
! 	  is >= 0
  
! Makefile.in
! 	- changed release status to `beta1'
  
! lib/glob/collsyms.h
! 	- added a few ASCII symbols to the posix_collsyms array
  
! 				   10/3
! 				   ----
! aclocal.m4
! 	- fixed typo in BASH_TYPE_BITS64_T
  
! configure.in
! 	- added check for unsigned chars with AC_C_CHAR_UNSIGNED
  
! config.h.in
! 	- added PROTOTYPES and __CHAR_UNSIGNED__ #defines
  
! general.h
! 	- if CHAR_MAX is not define by <limits.h>, provide a definition
  
! builtins/printf.def
! 	- change tescape() to mask \0 and \x escape sequences with 0xFF
! 	- change tescape() to process at most two hex digits after a `\x'
  
! lib/sh/strtrans.c
! 	- change strtrans() to mask \0 and \x escape sequences with 0xFF
! 	- change strtrans() to process at most two hex digits after a `\x'.
! 	  This affects `echo -e' and $'...' processing
  
! lib/readline/bind.c
! 	- changed rl_translate_keyseq() to process at most two hex digits
! 	  after a `\x'
  
! lib/readline/doc/{rluser.texinfo,readline.3}, doc/bash.1
! 	- changed documentation for key binding escape sequences to specify
! 	  that at most two hex digits after \x are translated
! 	- changed documentation for key binding to specify that the result
! 	  of \nnn or \xhh escapes is an eight-bit value, not just ASCII
! 
! doc/{bash.1,bashref.texi}
! 	- changed documentation of $'...' to specify that at most two hex
! 	  digits after \x are translated
! 	- changed `echo' documentation to specify that at most two hex
! 	  digits after \x are translated
! 	- changed documentation for `echo' and $'...' to specify that the
! 	  result of \nnn or \xhh escapes is an eight-bit value, not just ASCII
  
! 				   10/4
  				   ----
! lib/malloc/malloc.c
! 	- changed interface for xbotch to pass memory address and error code
! 	  as two additional arguments
! 	- call mregister_describe_mem from xbotch to get the last allocation
! 	  or free before the botch
  
! configure.in
! 	- call AC_CHECK_DECLS([strsignal])
  
! config.h.in
! 	- add HAVE_DECL_STRSIGNAL
  
! siglist.h
! 	- make declaration of strsignal() dependent on !HAVE_DECL_STRSIGNAL
  
! 				   10/5
! 				   ----
! support/texi2html
! 	- upgraded to version 1.64
  
! 				   10/9
  				   ----
! aclocal.m4
! 	- added check for `long long' to BASH_TYPE_PTRDIFF_T
  
  configure.in
! 	- replaced call to BASH_HAVE_TIOCGWINSZ with AC_HEADER_TIOCGWINSZ
  
! aclocal.m4
! 	- replaced body of BASH_STRUCT_TERMIOS_LDISC with call to
! 	  AC_CHECK_MEMBER(struct termios.c_line, ...)
! 	- replaced body of BASH_STRUCT_TERMIO_LDISC with call to
! 	  AC_CHECK_MEMBER(struct termios.c_line, ...)
  
! [bash-2.05a-beta1 frozen]
  
! 				   10/10
! 				   -----
! lib/sh/snprintf.c
! 	- fixed exponent() to not smash the trailing zeros in the fraction
! 	  when using %g or %G with an `alternate form'
! 	- fixed exponent() to handle the optional precision with %g and %G
! 	  correctly (number of significant digits before the exponent)
  
! 				   10/11
! 				   -----
! expr.c
! 	- fixed strlong() to correct the values of `@' and `_' when
! 	  translating base-64 constants (64#@ == 62 and 64#_ == 64), for
! 	  compatibility with ksh
  
! lib/sh/itos.c
! 	- added a slightly more flexible fmtlong() function that takes a
! 	  base argument and flags (for future use)
! 	- rewrote itos and inttostr in terms of fmtlong
! 
! lib/sh/fmtulong.c
! 	- new file, converts unsigned long to string.  hooks for `unsigned
! 	  long long' in the future.  unused as yet
  
! 				   10/15
! 				   -----
! lib/readline/rltty.c
! 	- change the SET_SPECIAL macro to avoid possible (but highly
! 	  unlikely) negative array subscripts
  
! error.h
! 	- add __attribute__ to extern declaration of itrace (even though the
! 	  function isn't defined in released versions of bash)
  
! bashansi.h
! 	- include <strings.h> if HAVE_STRINGS_H is defined, to get any extra
! 	  function declarations provided therein
  
! copy_cmd.c
! 	- fix typo in forward declaration for copy_arith_for_command
  
! lib/malloc/stats.c
! 	- make the accumulators in _print_malloc_stats be `unsigned long'
! 	  instead of `int'
  
! externs.h, sig.h
! 	- add `__noreturn__' gcc attribute to exit_shell and jump_to_top_level
! 	  declarations
  
! lib/sh/mailstat.c, support/bashversion.c
! 	- include <bashansi.h> for some string function declarations
! 
! lib/malloc/shmalloc.h
! 	- added extern declarations of functions that do malloc debugging
! 
! lib/readline/{isearch,readline,vi_mode}.c
! 	- make sure we index into _rl_keymap with a non-negative index
  
  parse.y
! 	- make sure we index into sh_syntaxtab with a non-negative index
! 
! lib/readline/vi_mode.c
! 	- bound the vi_mark_chars array with the number of characters between
! 	  'a' and 'z' rather than using a fixed amount
! 	- don't use _rl_lowercase_p when deciding whether the char read by
! 	  rl_vi_set_mark is a valid mark; just use 'a' <= char <= 'z'
  
  lib/readline/chardefs.h
! 	- conditionally include memory.h and strings.h as in general.h
! 	- replace ISASCII with IN_CTYPE_DOMAIN like other GNU software
! 	- add defines for ISPRINT(c), ISLOWER(c) and ISUPPER(c)
! 	- fix defines for _rl_lowercase_p, _rl_uppercase_p, _rl_digit_p,
! 	  _rl_pure_alphabetic, ALPHABETIC, _rl_to_upper, _rl_to_lower,
! 	  and _rl_isident to work on systems with signed chars
! 
! include/chartypes.h
! 	- replace ISASCII with IN_CTYPE_DOMAIN like other GNU software
! 
! lib/sh/{strcasecmp,strtod,strtol}.c
! 	- don't pass possibly-negative characters to tolower() or toupper()
! 
! lib/glob/strmatch.c
! 	- don't bother testing for isupper in FOLD; rely on TOLOWER macro
! 	  from <chartypes.h> to do it
! 	- don't use local definitions of isblank, et al.; rely on macros
! 	  from <chartypes.h>
! 
! lib/readline/{display,readline}.c, mksyntax.c
! 	- use new ISPRINT macro instead of isprint()
! 
! builtins/{kill.def,mkbuiltins.c},{error,execute_cmd,jobs,nojobs,subst}.c
! 	- don't assume that a pid_t fits into an int for printing and other
! 	  uses
  
! variables.[ch]
! 	- the unused put_gnu_argv_flags_into_env now takes a `long' pid
! 	  argument
  
! configure.in, config.h.in
! 	- call AC_STRUCT_ST_BLOCKS, define HAVE_STRUCT_STAT_ST_BLOCKS if found
! 	- check for strtoull(), define HAVE_STRTOULL if found
! 	- check for uintmax_t, define to `unsigned long' if not found
! 
! lib/sh/mailstat.c
! 	- don't use st_blocks member of struct stat unless
! 	  HAVE_STRUCT_STAT_ST_BLOCKS is defined; otherwise use the st_nlink
! 	  field to return the total number of messages in a maildir-style
! 	  mail directory
! 
! general.h,{alias,expr,general,subst,variables}.c
! builtins/{printf,read}.def
! lib/readline/{bind,complete,nls}.c
! lib/sh/{pathcanon,pathphys,shquote,snprintf,strindex,strtod,strtol,strtrans}.c
! 	- cast args to ctype macros to unsigned char for systems with signed
! 	  chars; other fixes for signed chars
  
! lib/sh/{fmtullong,strtoull.c}
! 	- new files, more support for `long long'
  
! Makefile.in, lib/sh/Makefile.in
! 	- make fmtullong.o and strtoull.o part of libsh
! 
! lib/sh/itos.c
! 	- remove local copy of fmtlong; use fmtulong instead
! 	- new functions: uitos, uinttostr work on `unsigned long'
  
! lib/sh/snprintf.c
! 	- fixes to make `unsigned long long' work (%llu)
! 	- fixes to make unsigned formats not print the sign when given
! 	  an unsigned long that is greater than LONG_MAX
  
! externs.h
! 	- extern declarations for fmtulong, fmtulloing, strtoull
! 	- extern declarations for uitos, uinttostr
  
! 				   10/16
! 				   -----
! configure.in
! 	- move header checks before function checks
! 	- move c compiler tests before header checks
! 	- check for <inttypes.h> with BASH_HEADER_INTTYPES
! 	- change type checks for intmax_t, uintmax_t to not attempt to
! 	  include <stdint.h>
! 	- check for strtoimax, strtoumax, strtoll, strtol, strtoull, strtoul
! 	  with BASH_CHECK_DECL (for declarations in header files) and
! 	  AC_REPLACE_FUNCS (for availability and LIBOBJS substitution)
! 	- remove check for have_long_long around sizeof check for long long
! 	  (since autoconf will give it a size of 0 if the type isn't found)
! 
! config.h.in
! 	- add a define for HAVE_INTTYPES_H
! 	- add a define for HAVE_UNSIGNED_LONG_LONG
! 	- add defines for HAVE_STRTOIMAX, HAVE_STRTOUMAX, HAVE_STRTOLL
! 
! aclocal.m4
! 	- new func, BASH_HEADER_INTTYPES, which just calls AC_CHECK_HEADERS
! 	  on <inttypes.h>; separate so it can be AC_REQUIREd
! 	- AC_REQUIRE([BASH_HEADER_INTTYPES]) in BASH_CHECK_TYPE
! 	- include <inttypes.h> in BASH_CHECK_TYPE if HAVE_INTTYPES_H is
! 	  defined
! 	- change AC_DEFINE to AC_DEFINE_UNQUOTED in BASH_CHECK_TYPE
! 	- new `long long' checking macros:  BASH_TYPE_LONG_LONG and
! 	  BASH_TYPE_UNSIGNED_LONG_LONG
! 	- new BASH_CHECK_DECL 
  
! lib/sh/{strto[iu]max,strtoll}.c, lib/sh/Makefile.in, Makefile.in
! 	- new files
  
! externs.h
! 	- extern declarations for strtoll, strtoimax, strtoumax
  
! lib/malloc/alloca.c
! 	- include <bashtypes.h> for size_t
  
! builtins/printf.def
! 	- new functions: getllong, getullong, getintmax, getuintmax; return
! 	  long long, unsigned long long, intmax_t, uintmax_t respectively
! 	- builtin printf now handles `ll' and `j' length modifiers directly
  
! lib/sh/Makefile.in
! 	- use LIBOBJS to decide whether or not the strto* functions are
! 	  needed
  
! 				   10/17
! 				   -----
! configure.in
! 	- call AC_REPLACE_FUNCS(rename)
! 	- move getcwd, strpbrk, strcasecmp, strerror, strtod
! 	  from AC_CHECK_FUNCS to AC_REPLACE_FUNCS
! 	- only call BASH_FUNC_GETCWD if $ac_func_getcwd == "yes"
! 	- call BASH_CHECK_SYS_SIGLIST
! 	- if we don't have vprintf but have _doprnt, call AC_LIBOBJ(vprint)
  
! lib/sh/Makefile.in
! 	- remove rename, getcwd, inet_aton, strpbrk, strcasecmp, strerror,
! 	  strtod, vprint from OBJECTS; picked up from LIBOBJS
  
  aclocal.m4
! 	- change BASH_FUNC_GETCWD to call AC_LIBOBJ(getcwd) if the libc
! 	  getcwd(3) calls popen(3)
! 	- change BASH_FUNC_INET_ATON to call AC_LIBOBJ(inet_aton) if it's
! 	  not found in libc or as a #define even with the special includes
! 	- BASH_KERNEL_RLIMIT_CHECK -> BASH_CHECK_KERNEL_RLIMIT
! 	- BASH_DEFAULT_MAILDIR -> BASH_SYS_DEFAULT_MAILDIR
! 	- BASH_JOB_CONTROL_MISSING -> BASH_SYS_JOB_CONTROL_MISSING
! 	- BASH_REINSTALL_SIGHANDLERS -> BASH_SYS_REINSTALL_SIGHANDLERS
! 	- BASH_SIGNAL_CHECK -> BASH_SYS_SIGNAL_VINTAGE
! 	- BASH_DUP2_CLOEXEC_CHECK -> BASH_FUNC_DUP2_CLOEXEC_CHECK
! 	- BASH_PGRP_SYNC -> BASH_SYS_PGRP_SYNC
! 	- BASH_RLIMIT_TYPE -> BASH_TYPE_RLIMIT
! 	- BASH_FUNC_PRINTF -> BASH_DECL_PRINTF
! 	- BASH_FUNC_SBRK_DECLARED -> BASH_DECL_SBRK
! 	- BASH_MISC_SPEED_T -> BASH_CHECK_SPEED_T
! 	- BASH_CHECK_SOCKLIB -> BASH_CHECK_LIB_SOCKET
! 	- new macro, BASH_CHECK_SYS_SIGLIST, encapsulates all the checks for
! 	  sys_siglist, _sys_siglist, and strsignal(), sets SIGLIST_O to
! 	  siglist.o if appropriate
! 
! Makefile.in
! 	- use SIGLIST_O variable to decide whether or not we need siglist.o
! 
! {execute_cmd,subst}.c
! 	- change a couple of instances of ISDIGIT to DIGIT, where we really,
! 	  really only want ascii digits
! 
! ansi_stdlib.h
! 	- don't need a declaration for atol()
! 
! 				   10/18
! 				   -----
  
! aclocal.m4
! 	- new macro, BASH_FUNC_PRINTF_A_FORMAT, checks for printf support
! 	  for %a, %A conversion specifiers, defines HAVE_PRINTF_A_FORMAT
! 	  if successful
! 
! configure.in
! 	- call AC_CHECK_FUNCS for isascii
! 	- call BASH_FUNC_PRINTF_A_FORMAT
! 
! config.h.in
! 	- add a define for HAVE_ISASCII
! 	- add a define for HAVE_PRINTF_A_FORMAT
! 
! lib/sh/snprintf.c
! 	- for long double output, fall back to sprintf using ldfallback()
! 	  function for floating point formats
! 	- support %a, %A using dfallback() or ldfallback() if
! 	  HAVE_PRINTF_A_FORMAT is defined
! 	- fix bug in vasprintf that returned wrong value in its first
! 	  argument if the buffer holding the result string got reallocated
! 	- fixed PUT_CHAR macro to increment the counter even if we've
! 	  exceeded the buffer size, for the return value from
! 	  vsnprintf/snprintf
! 	- fix vsnprintf_internal to not use counter < length as a loop
! 	  condition, but always process the entire format string (for
! 	  the return value from vsnprintf/snprintf)
  
! builtins/printf.def
! 	- support %a, %A if HAVE_PRINTF_A_FORMAT is defined
  
! include/typemax.h
! 	- new file, with the TYPE_MAXIMUM stuff that's duplicated in several
! 	  files in lib/sh
  
! lib/sh/{fmtulong,strtol,snprintf}.c
! 	- include <typemax.h> instead of having the definitions in each file
  
! lib/sh/Makefile.in
! 	- updated dependencies for typemax.h
  
! 				   10/22
! 				   -----
! configure.in
! 	- call AC_CHECK_FUNCS on ctype.h functions/macros that bash redefines
! 	  in chartypes.h
  
! config.h.in
! 	- defines for HAVE_IS{ASCII,BLANK,GRAPH,PRINT,SPACE,XDIGIT}
  
! include/chartypes.h, lib/glob/strmatch.c, lib/readline/chardefs.h
! 	- don't redefine some is* ctype macros/functions if HAVE_ISXXX is
! 	  defined (meaning that an appropriate function, but not a macro,
! 	  exists)
  
! lib/sh/strtrans.c
! 	- new function, ansic_shouldquote, returns 1 if argument string
! 	  contains non-printing chars that should be quoted with $'...'
  
! externs.h
! 	- new declaration for ansic_shouldquote()
  
! variables.c
! 	- change print_var_value to ansi C quote the string if we're not in
! 	  posix mode and the variable's value contains non-printing chars,
! 	  to use the regular shell single quoting if the value contains
! 	  shell meta-characters, and to just output the string otherwise
  
! lib/sh/shquote.c
! 	- add `break' to `case '~':' to avoid fallthrough and extra test
  
! doc/bashref.texi
! 	- note that in POSIX mode, `set' displays variable values that
! 	  include nonprinting characters without quoting, unless they
! 	  contain shell metacharacters
  
! builtins/printf.def, lib/sh/snprintf.c
! 	- handle `F' conversion specifier as equivalent to 'f'
! 
! parse.y, {nojobs,variables}.c
! 	- a couple of cleanups for when building a minimal configuration
! 
! nojobs.c
! 	- new function: stop_making_children(), just sets
! 	  already_making_children to 0 (like stop_pipeline)
! 
! subst.c
! 	- call stop_making_children from subst.c:command_substitute if
! 	  JOB_CONTROL is not defined.  This fixes the bug where the wrong
! 	  process is waited for (and its status returned) when using
! 	  command substitution in a null command in a shell function
  
  builtins/printf.def
! 	- new variable `tw' used to keep track of the total number of
! 	  characters written by a single call to `printf' -- to be
! 	  used for the `%n' conversion, which will be added later.  It
! 	  gets reset each time we reuse the format string, which is what
! 	  ksh93 seems to do
  
+ 				   10/23
+ 				   -----
  variables.c
! 	- new function, bind_var_to_int (char *var, long val)
  
! variables.h
! 	- extern declaration for bind_var_to_int
  
! lib/sh/netopen.c
! 	- use gai_strerror() for error messages when getaddrinfo() fails
! 	- use PF_INET if DEBUG is defined, since IPv6 doesn't work for me
  
! Makefile.in
! 	- pass DEBUG=${DEBUG} down to makes in some subdirectories
  
! {builtins,lib{glob,sh}}/Makefile.in
! 	- append ${DEBUG} to LOCAL_CFLAGS value, passed by top-level Makefile
  
! builtins/printf.def
! 	- added support for %n format conversion char (number of chars printed
! 	  so far from current format string)
! 
! 				   10/24
  				   -----
! variables.c
! 	- if posixly_correct is set, the default value of $MAILCHECK is 600
! 	- use legal_number instead of atoi in adjust_shell_level
! 	- treat non-numeric assignments to SECONDS as 0 in assign_seconds
! 	- new function, init_funcname_var; sets FUNCNAME as a dynamic variable
! 	  if it's not set in the initial environment
! 	- new function, init_groups_var; sets GROUPS as a dynamic array
! 	  variable if it's not set in the initial environment
! 	- new function, init_dirstack_var; sets DIRSTACK as a dynamic array
! 	  variable if it's not set in the initial environment
! 	- new function, init_seconds_var; sets SECONDS as a dynamic
! 	  variable using any valid integer value in the initial environment
! 	  as the initial value, as if an assignment had been performed
! 	- call init_funcname_var, init_groups_var, init_dirstack_var,
! 	  init_seconds_var from initialize_dynamic_variables
! 	- non-numeric values assigned to LINENO are treated as 0
! 	- change initialize_shell_variables to not auto-export PATH or TERM
! 	- change set_home_var to not auto-export HOME
! 	- change set_shell_var to not auto-export SHELL
! 	- broke the code that sets HOSTNAME, HOSTTYPE, MACHTYPE, OSTYPE
! 	  out into a separate function, set_machine_vars; none of those
! 	  variables are auto-exported
! 	- bash no longer un-exports SSH_CLIENT or SSH2_CLIENT
  
! shell.c
! 	- changed isnetconn() to check SSH_CLIENT and SSH2_CLIENT only if
! 	  SSH_SOURCE_BASHRC is defined in config-top.h
  
! config-top.h
! 	- added a commented-out definition for SSH_SOURCE_BASHRC
  
! 				   10/25
  				   -----
  
! Makefile.in
! 	- changed RELSTATUS to `rc1' (release candidate 1)
  
! 				   10/29
  				   -----
! locale.c
! 	- fixed an `=' vs. `==' typo in set_locale_var when parsing
! 	  LC_NUMERIC
  
! doc/{bash.1,bashref.texi}
! 	- document what bash does with $POSIXLY_CORRECT
  
! doc/builtins.1
! 	- some updates
  
! builtins/psize.sh
! 	- some mktemp(1) changes
  
! lib/readline/readline.c
! 	- change rl_backward to check for rl_point < 0 and reset to 0 if so
  
! lib/readline/util.c
! 	- don't compile in _rl_strpbrk if HAVE_STRPBRK is defined
  
! lib/readline/rlprivate.h
! 	- remove extern declaration of _rl_strpbrk
  
! lib/readline/rldefs.h
! 	- #define _rl_strpbrk as strpbrk if HAVE_STRPBRK is define, otherwise
! 	  add extern declaration of _rl_strpbrk from rlprivate.h
  
! {mailcheck,shell,variables}.c
! 	- make sure to include posixtime.h to get any prototype for time(3)
! 	  in scope
  
! {array,eval,execute_cmd,mksyntax,subst}.c, parse.y
! builtins/common.c
! lib/sh/pathcanon.c
! 	- a few changes as the result of `gcc -Wall' patches from solar
! 	  designer
  
! builtins/read.def, parse.y
! 	- change some calls to free() to xfree()
  
! builtins/set.def
! 	- make sure unset_builtin() resets unset_array to 0 each time through
! 	  the loop, because it's set (and used) depending on the current
! 	  argument
  
! shell.h
! 	- new define, USE_VAR, to force the compiler to not put a particular
! 	  variable in a register -- helpful if registers are not restored
! 	  by setjmp/longjmp
! 
! builtins/{evalfile.c,{read,wait}.def}, {eval,execute_cmd,shell,test}.c
! 	- use USE_VAR for some variables
  
! subst.c
! 	- fixed a case in expand_word_internal where a NULL pointer could
! 	  have been passed to free() (though free() should ignore it)
! 	- fixed a case at the end of expand_word_internal where LIST could
! 	  have been used uninitialized (it makes gcc happy, though it
! 	  doesn't happen in practice)
  
! test.c
! 	- give test_syntax_error(), beyond(), and integer_expected_error()
! 	  the `__noreturn__' attribute for gcc
  
! unwind_prot.c
! 	- in clear_unwind_protect_list(), convert `flags' to `long' (via
! 	  assignment to a `long' variable) before casting to `char *', in
! 	  case pointers and longs are 64 bits and ints are 32 (makes no
! 	  difference on 32-bit machines)
  
! 				   10/30
  				   -----
! print_cmd.c
! 	- fixed cprintf to avoid gcc warning about assigning const pointer
! 	  to non-const (discarding type qualifier)
  
! {make_cmd,pcomplete,test}.c,parse.y
! 	- some minor changes to shut up gcc warnings
  
! lib/sh/tmpfile.c
! 	- fixed sh_mktmpfp to avoid file descriptor leaks in the case that
! 	  sh_mktmpfd succeeds but fdopen fails for some reason
! 	- change sh_mktmpfd to use the same scheme for computing `filenum'
! 	  as sh_mktmpname
! 	- change get_sys_tmpdir to prefer P_tmpdir if P_tmpdir is defined
! 	- changed sh_mktmpname and sh_mktmpfd to avoid trying to assign to
! 	  `nameroot' if `nameroot == 0' (duh)
! 	- add code to sh_mktmpfd to use mkstemp(3) if USE_MKSTEMP is defined
! 	- add code to sh_mktmpname to use mktemp(3) if USE_MKTEMP is defined
! 
! support/{fixlinks,mkclone}
! 	- use mktemp if it's available for the symlink test
! 	- use $TMPDIR instead of hardcoding /tmp; default to /tmp
! 	- use a better filename for the symlink test instead of `z'
  
! support/bashbug.sh
! 	- more changes inspired by a patch from solar designer
  
! lib/malloc/Makefile.in
! 	- new target `alloca', which builds libmalloc.a with alloca.o only
! 	  (for systems without alloca that are configured --without-bash-malloc)
  
! configure.in
! 	- if we don't have a working alloca and are not configured to build
! 	  the bash malloc library, make a malloc library containing only
! 	  alloca.o
  
! aclocal.m4
! 	- slight change to RL_LIB_READLINE_VERSION to deal with minor version
! 	  numbers with a letter appended (like 4.2a)
  
! 				   10/31
  				   -----
  doc/{bash.1,bashref.texi}
! 	- slight change to note that only interactive shells resend a SIGHUP
! 	  to all jobs before exiting
  
! externs.h
! 	- declare strto[ui]max only if NEED_STRTOIMAX_DECL is defined.  This
! 	  keeps picky compilers from choking because intmax_t is not defined
! 	  (MacOS X 10.1)
  
! builtins/printf.def
! 	- #define NEED_STRTOIMAX_DECL before including shell.h
  
! 				   11/1
  				   ----
! general.c
! 	- check in bash_tilde_expand() for an unquoted tilde-prefix; don't
! 	  bother passing the string to tilde_expand unless the prefix is
! 	  unquoted
  
! shell.c
! 	- fix a problem with $LINENO when executing commands supplied with
! 	  the -c invocation option when ONESHOT is defined
  
! [bash-2.05a-rc1 frozen]
  
! builtins/printf.def
! 	- fix the %n conversion to require that the variable name supplied
! 	  be a valid shell identifier
  
  variables.c
! 	- improve random number generator slightly by using the upper 16
! 	  bits of the running random number instead of the lower 16, which
! 	  are incrementally more random
  
! 				   11/2
  				   ----
  configure.in
! 	- if RL_INCLUDEDIR ends up being /usr/include, don't put
! 	  -I$(RL_INCLUDEDIR) into CFLAGS
  
! 				   11/5
  				   ----
! doc/{bash.1,bashref.texi}
! 	- correct description of POSIXLY_CORRECT to note that the shell enters
! 	  posix mode *before* the startup files are read if POSIXLY_CORRECT
! 	  is in the initial environment
  
  variables.c
! 	- fix function prologues for init_dirstack_var and init_groups_var
! 	  to agree with caller (no arguments)
  
  jobs.c
! 	- fix forward function declarations for pipe_read and pipe_close
  
! subst.c
! 	- removed `inline' attribute from skip_double_quoted because it can
! 	  potentially be called recursively
  
  bashline.c
! 	- quick fix to bashline.c:attempt_shell_completion programmable
! 	  completion code to just punt if the end of the command word found
! 	  by find_cmd_end is <= the start found by find_cmd_start (the bug
! 	  is probably in find_cmd_start -- fix later)
  
! pcomplete.c
! 	- fix gen_matches_from_itemlist to return if the stringlist is null
! 	  after any cleaning or initialization, before trying to use it
! 	- fix GEN_COMPS to only bother to try to append the STRINGLIST
! 	  returned by gen_matches_from_itemlist to `glist' if it's non-NULL
  
! lib/sh/stringlist.c
! 	- make copy_stringlist return NULL if the STRINGLIST * passed as an
! 	  argument is NULL
! 	- make append_stringlist call copy_stringlist only if M2 is non-NULL;
! 	  otherwise just return NULL if m1 is NULL
! 	- make word_list_to_stringlist return 0 immediately if the passed
! 	  LIST argument is NULL
! 	- make realloc_stringlist call alloc_stringlist if the passed
! 	  STRINGLIST argument (`sl') is 0, just like realloc calls malloc
! 
! subst.c
! 	- in skip_to_delim(), if we have an unclosed ${, and it's at the end
! 	  of the string (string[i] == '{', string[i+1] == '{' and
! 	  string[i+2] == 0, return si (i +2) immediately without bothering
! 	  to call extract_dollar_brace_string or extract_delimited_string
! 	- in skip_to_delim(), if string[i] is 0 after a call to
! 	  extract_dollar_brace_string or extract_delimited_string (meaning we
! 	  have an unclosed ${ or other expansion, return i immediately without
! 	  doing a `continue' (which will increment i past the end of string)
! 	- in split_at_delims, don't increment te by 1 if it's pointing to a
! 	  delimiter.  this has the effect of skipping the first delimiter
! 	  char in a possibly multi-character delimiter, and ignoring
! 	  single-char delimiters like `>'
! 
! configure.in
! 	- use AC_CHECK_MEMBERS([struct stat.st_blocks]) instead of a call to
! 	  AC_STRUCT_ST_BLOCKS to avoid configure changing LIBOBJS if the test
! 	  fails
! 
! general.c
! 	- introduce two new variables: bash_tilde_{prefixes,suffixes}, set
! 	  to the additional prefixes and suffixes bash wants to pass to the
! 	  tilde expansion code (reserved for post-bash-2.05a fix)
  
! aclocal.m4
! 	- add missing `test' in BASH_CHECK_SYS_SIGLIST
  
! 				   11/7
  				   ----
! lib/readline/vi_mode.c
! 	- fix rl_vi_goto_mark to explicitly check that the desired mark is
! 	  between 'a' and 'z', since some locales have lowercase letters
! 	  outside that range, which could cause a negative subscript
! 
! include/chartypes.h
! 	- remove superfluous `#undef ISASCII'
! 
! lib/sh/strto[iu]max.c
! 	- changes from Paul Eggert to work around buggy compilers and catch
! 	  configuration errors at compile time
! 
! aclocal.m4
! 	- new macro, BASH_C_LONG_DOUBLE, identical to AC_C_LONG_DOUBLE but
! 	  with a fix for Irix 5.3 (not called, since I'm not sure it's the
! 	  right thing to do -- the C standard allows double and long double
! 	  to be the same size)
! 
! lib/sh/snprintf.c
! 	- only try to write the trailing NUL in vsnprintf_internal if
! 	  data->length is >= 0, since if it's not, we probably don't have
! 	  a buffer
  
  Makefile.in
  	- changed RELSTATUS to `release'
  
! 				   11/8
  				   ----
! lib/sh/strtol.c
! 	- make sure chars passed to toupper are cast to unsigned
  
! unwind_prot.c
! 	- change clear_unwind_protect_list to not require a cast from `int'
! 	  to `char *'
  
! lib/readline/chardefs.h
! 	- make _rl_digit_p succeed only for ascii digits, since that's what
! 	  most callers assume
diff -Nrc2 bash-2.05/CWRU/empty-for-wordlist bash-2.05a/CWRU/empty-for-wordlist
*** bash-2.05/CWRU/empty-for-wordlist	Wed Jul 22 12:16:28 1998
--- bash-2.05a/CWRU/empty-for-wordlist	Wed Dec 31 19:00:00 1969
***************
*** 1,25 ****
- This patch is from Brian Fox, in reply to an email message from
- "Marcin 'Qrczak' Kowalczyk" <qrczak@knm.org.pl>, who wrote:
- 
-    I think that bash should accept such a syntax:
- 
-    for var in ; do command; done
- 
-    Of course it should do nothing. It would simplify some scripts.
- 
- Here is a patch for those who wish it:
- 
- *** parse.y.~1~ Wed Mar  4 09:39:46 1998
- --- parse.y     Mon Jul 13 14:40:23 1998
- ***************
- *** 495,500 ****
- --- 495,504 ----
-                         { $$ = make_for_command ($2, REVERSE_LIST ($5, WORD_LIST *), $9); }
-         |       FOR WORD newline_list IN word_list list_terminator newline_list '{' compound_list '}'
-                         { $$ = make_for_command ($2, REVERSE_LIST ($5, WORD_LIST *), $9); }
- +       |       FOR WORD newline_list IN list_terminator newline_list DO compound_list DONE
- +                       { $$ = make_for_command ($2, (WORD_LIST *)NULL, $8); }
- +       |       FOR WORD newline_list IN  list_terminator newline_list '{' compound_list '}'
- +                       { $$ = make_for_command ($2, (WORD_LIST *)NULL, $8); }
-         ;
-   
--- 0 ----
diff -Nrc2 bash-2.05/CWRU/maildir-patch bash-2.05a/CWRU/maildir-patch
*** bash-2.05/CWRU/maildir-patch	Mon Nov 27 11:26:32 2000
--- bash-2.05a/CWRU/maildir-patch	Wed Dec 31 19:00:00 1969
***************
*** 1,175 ****
- # DP: From: Miquel van Smoorenburg <miquels@cistron.nl>
- # DP: A patch that adds support for Maildir type mailboxes.
- 
- --- ./mailcheck.c.orig	Wed Feb  4 21:30:33 1998
- +++ ./mailcheck.c	Sun Nov 14 15:35:07 1999
- @@ -21,8 +21,10 @@
-  #include "config.h"
-  
-  #include <stdio.h>
- +#include <errno.h>
-  #include "bashtypes.h"
-  #include "posixstat.h"
- +#include "posixdir.h"
-  #ifndef _MINIX
-  #  include <sys/param.h>
-  #endif
- @@ -37,6 +39,8 @@
-  #include "mailcheck.h"
-  #include <tilde/tilde.h>
-  
- +#include "mailstat.c"
- +
-  #ifndef NOW
-  #define NOW ((time_t)time ((time_t *)0))
-  #endif
- @@ -131,7 +135,7 @@
-    struct stat finfo;
-  
-    file = mailfiles[i]->name;
- -  if (stat (file, &finfo) == 0)
- +  if (mailstat (file, &finfo) == 0)
-      {
-        mailfiles[i]->access_time = finfo.st_atime;
-        mailfiles[i]->mod_time = finfo.st_mtime;
- @@ -155,7 +159,7 @@
-    i = find_mail_file (filename);
-    if (i >= 0)
-      {
- -      if (stat (filename, &finfo) == 0)
- +      if (mailstat (filename, &finfo) == 0)
-  	{
-  	  mailfiles[i]->mod_time = finfo.st_mtime;
-  	  mailfiles[i]->access_time = finfo.st_atime;
- @@ -221,7 +225,7 @@
-    file = mailfiles[i]->name;
-    mtime = mailfiles[i]->mod_time;
-  
- -  if ((stat (file, &finfo) == 0) && (finfo.st_size > 0))
- +  if ((mailstat (file, &finfo) == 0) && (finfo.st_size > 0))
-      return (mtime != finfo.st_mtime);
-  
-    return (0);
- @@ -239,7 +243,7 @@
-    file = mailfiles[i]->name;
-    atime = mailfiles[i]->access_time;
-  
- -  if ((stat (file, &finfo) == 0) && (finfo.st_size > 0))
- +  if ((mailstat (file, &finfo) == 0) && (finfo.st_size > 0))
-      return (atime != finfo.st_atime);
-  
-    return (0);
- @@ -257,7 +261,7 @@
-    file = mailfiles[i]->name;
-    size = mailfiles[i]->file_size;
-  
- -  return ((stat (file, &finfo) == 0) && (finfo.st_size > size));
- +  return ((mailstat (file, &finfo) == 0) && (finfo.st_size > size));
-  }
-  
-  /* Take an element from $MAILPATH and return the portion from
- 
- 
- diff -ruN bash-2.01.1.b4/mailstat.c bash-2.01.1/mailstat.c
- --- bash-2.01.1.b4/mailstat.c   Thu Jan  1 01:00:00 1970
- +++ bash-2.01.1/mailstat.c      Wed Jun  2 12:05:04 1999
- @@ -0,0 +1,98 @@
- +/*
- + *     Stat a file. If it's a maildir, check all messages
- + *     in the maildir and present the grand total as a file.
- + *     The fields in the 'struct stat' are from the mail directory.
- + *     The following fields are emulated:
- + *
- + *     st_nlink        always 1
- + *     st_size         total number of bytes in all files
- + *     st_blocks       total number of messages
- + *     st_atime        access time of newest file in maildir
- + *     st_mtime        modify time of newest file in maildir
- + *     st_mode         S_IFDIR changed to S_IFREG
- + *
- + *     This is good enough for most mail-checking applications.
- + */
- +int
- +mailstat(char *path, struct stat *st)
- +{
- +       DIR                     *dd;
- +       struct                  dirent *fn;
- +       struct stat             st_ret, st_tmp;
- +       static struct stat      st_new_last, st_ret_last;
- +       char                    dir[PATH_MAX * 2];
- +       char                    file[PATH_MAX * 2];
- +       int                     i, l;
- +       time_t                  atime = 0, mtime = 0;
- +
- +       /* First see if it's a directory. */
- +       if ((i = stat(path, st)) != 0 || !S_ISDIR(st->st_mode))
- +               return i;
- +       if (strlen(path) > sizeof(dir) - 5) {
- +               errno = ENAMETOOLONG;
- +               return -1;
- +       }
- +
- +       st_ret = *st;
- +       st_ret.st_nlink = 1;
- +       st_ret.st_size  = 0;
- +       st_ret.st_blocks  = 0;
- +       st_ret.st_mode  &= ~S_IFDIR;
- +       st_ret.st_mode  |= S_IFREG;
- +
- +       /* See if cur/ is present */
- +       sprintf(dir, "%s/cur", path);
- +       if (stat(dir, &st_tmp) || !S_ISDIR(st_tmp.st_mode)) return 0;
- +       st_ret.st_atime = st_tmp.st_atime;
- +
- +       /* See if tmp/ is present */
- +       sprintf(dir, "%s/tmp", path);
- +       if (stat(dir, &st_tmp) || !S_ISDIR(st_tmp.st_mode)) return 0;
- +       st_ret.st_mtime = st_tmp.st_mtime;
- +
- +       /* And new/ */
- +       sprintf(dir, "%s/new", path);
- +       if (stat(dir, &st_tmp) || !S_ISDIR(st_tmp.st_mode)) return 0;
- +       st_ret.st_mtime = st_tmp.st_mtime;
- +
- +       /* Optimization - if new/ didn't change, nothing else did. */
- +       if (st_tmp.st_dev == st_new_last.st_dev &&
- +           st_tmp.st_ino == st_new_last.st_ino &&
- +           st_tmp.st_atime == st_new_last.st_atime &&
- +           st_tmp.st_mtime == st_new_last.st_mtime) {
- +               *st = st_ret_last;
- +               return 0;
- +       }
- +       st_new_last = st_tmp;
- +
- +       /* Loop over new/ and cur/ */
- +       for (i = 0; i < 2; i++) {
- +               sprintf(dir, "%s/%s", path, i ? "cur" : "new");
- +               sprintf(file, "%s/", dir);
- +               l = strlen(file);
- +               if ((dd = opendir(dir)) == NULL)
- +                       return 0;
- +               while ((fn = readdir(dd)) != NULL) {
- +                       if (fn->d_name[0] == '.' ||
- +                           strlen(fn->d_name) + l >= sizeof(file))
- +                               continue;
- +                       strcpy(file + l, fn->d_name);
- +                       if (stat(file, &st_tmp) != 0)
- +                               continue;
- +                       st_ret.st_size += st_tmp.st_size;
- +                       st_ret.st_blocks++;
- +                       if (st_tmp.st_atime != st_tmp.st_mtime &&
- +                           st_tmp.st_atime > atime)
- +                               atime = st_tmp.st_atime;
- +                       if (st_tmp.st_mtime > mtime)
- +                               mtime = st_tmp.st_mtime;
- +               }
- +               closedir(dd);
- +       }
- +
- +       if (atime) st_ret.st_atime = atime;
- +       if (mtime) st_ret.st_mtime = mtime;
- +
- +       *st = st_ret_last = st_ret;
- +       return 0;
- +}
- 
--- 0 ----
diff -Nrc2 bash-2.05/INSTALL bash-2.05a/INSTALL
*** bash-2.05/INSTALL	Thu Mar  8 10:44:18 2001
--- bash-2.05a/INSTALL	Thu Oct 11 08:34:09 2001
***************
*** 51,63 ****
  called Autoconf.  You only need `configure.in' if you want to change it
  or regenerate `configure' using a newer version of Autoconf.  If you do
! this, make sure you are using Autoconf version 2.10 or newer.
! 
! If you need to change `configure.in' or regenerate `configure', you
! will need to create two files: `_distribution' and `_patchlevel'.
! `_distribution' should contain the major and minor version numbers of
! the Bash distribution, for example `2.01'.  `_patchlevel' should
! contain the patch level of the Bash distribution, `0' for example.  The
! script `support/mkconffiles' has been provided to automate the creation
! of these files.
  
  You can remove the program binaries and object files from the source
--- 51,55 ----
  called Autoconf.  You only need `configure.in' if you want to change it
  or regenerate `configure' using a newer version of Autoconf.  If you do
! this, make sure you are using Autoconf version 2.50 or newer.
  
  You can remove the program binaries and object files from the source
***************
*** 119,123 ****
  By default, `make install' will install into `/usr/local/bin',
  `/usr/local/man', etc.  You can specify an installation prefix other
! than `/usr/local' by giving `configure' the option `--prefix=PATH'.
  
  You can specify separate installation prefixes for
--- 111,117 ----
  By default, `make install' will install into `/usr/local/bin',
  `/usr/local/man', etc.  You can specify an installation prefix other
! than `/usr/local' by giving `configure' the option `--prefix=PATH', or
! by specifying a value for the `DESTDIR' `make' variable when running
! `make install'.
  
  You can specify separate installation prefixes for
***************
*** 131,140 ****
  
  There may be some features `configure' can not figure out
! automatically, but needs to determine by the type of host Bash will run
  on.  Usually `configure' can figure that out, but if it prints a
  message saying it can not guess the host type, give it the
  `--host=TYPE' option.  `TYPE' can either be a short name for the system
  type, such as `sun4', or a canonical name with three fields:
! `CPU-COMPANY-SYSTEM' (e.g., `sparc-sun-sunos4.1.2').
  
  See the file `support/config.sub' for the possible values of each field.
--- 125,134 ----
  
  There may be some features `configure' can not figure out
! automatically, but need to determine by the type of host Bash will run
  on.  Usually `configure' can figure that out, but if it prints a
  message saying it can not guess the host type, give it the
  `--host=TYPE' option.  `TYPE' can either be a short name for the system
  type, such as `sun4', or a canonical name with three fields:
! `CPU-COMPANY-SYSTEM' (e.g., `i386-unknown-freebsd4.2').
  
  See the file `support/config.sub' for the possible values of each field.
***************
*** 211,229 ****
       database.
  
- `--with-glibc-malloc'
-      Use the GNU libc version of `malloc' in `lib/malloc/gmalloc.c'.
-      This is not the version of `malloc' that appears in glibc version
-      2, but a modified version of the `malloc' from glibc version 1.
-      This is somewhat slower than the default `malloc', but wastes less
-      space on a per-allocation basis, and will return memory to the
-      operating system under certain circumstances.
- 
  `--with-gnu-malloc'
       A synonym for `--with-bash-malloc'.
  
! `--with-installed-readline'
       Define this to make Bash link with a locally-installed version of
       Readline rather than the version in `lib/readline'.  This works
!      only with Readline 4.1 and later versions.
  
  `--with-purify'
--- 205,224 ----
       database.
  
  `--with-gnu-malloc'
       A synonym for `--with-bash-malloc'.
  
! `--with-installed-readline[=PREFIX]'
       Define this to make Bash link with a locally-installed version of
       Readline rather than the version in `lib/readline'.  This works
!      only with Readline 4.2 and later versions.  If PREFIX is `yes' or
!      not supplied, `configure' uses the values of the make variables
!      `includedir' and `libdir', which are subdirectories of `prefix' by
!      default, to find the installed version of Readline if it is not in
!      the standard system include and library directories.  If PREFIX is
!      `no', Bash links with the version in `lib/readline'.  If PREFIX is
!      set to any other value, `configure' treats it as a directory
!      pathname and looks for the installed version of Readline in
!      subdirectories of that directory (include files in
!      PREFIX/`include' and the library in PREFIX/`lib').
  
  `--with-purify'
***************
*** 237,240 ****
--- 232,241 ----
  There are several `--enable-' options that alter how Bash is compiled
  and linked, rather than changing run-time features.
+ 
+ `--enable-largefile'
+      Enable support for large files
+      (http://www.sas.com/standards/large_file/x_open.20Mar96.html) if
+      the operating system requires special compiler options to build
+      programs which can access large files.
  
  `--enable-profiling'
diff -Nrc2 bash-2.05/MANIFEST bash-2.05a/MANIFEST
*** bash-2.05/MANIFEST	Tue Mar 20 09:35:19 2001
--- bash-2.05a/MANIFEST	Thu Oct 18 16:15:35 2001
***************
*** 56,59 ****
--- 56,60 ----
  aclocal.m4	f
  array.c		f
+ arrayfunc.c	f
  eval.c		f
  print_cmd.c	f
***************
*** 101,106 ****
--- 102,110 ----
  bashhist.h	f
  bashline.h	f
+ conftypes.h	f
+ patchlevel.h	f
  variables.h	f
  array.h		f
+ arrayfunc.h	f
  jobs.h		f
  findcmd.h	f
***************
*** 135,142 ****
  mailcheck.h	f
  pathnames.h	f
  y.tab.c		f
  y.tab.h		f
  parser-built	f
- builtins/ChangeLog	f
  builtins/Makefile.in	f
  builtins/alias.def	f
--- 139,146 ----
  mailcheck.h	f
  pathnames.h	f
+ xmalloc.h	f
  y.tab.c		f
  y.tab.h		f
  parser-built	f
  builtins/Makefile.in	f
  builtins/alias.def	f
***************
*** 199,202 ****
--- 203,207 ----
  cross-build/opennt.cache	f
  include/ansi_stdlib.h	f
+ include/chartypes.h	f
  include/filecntl.h	f
  include/maxpath.h	f
***************
*** 210,218 ****
  include/stdc.h		f
  include/systimes.h	f
  include/unionwait.h	f
- lib/glob/ChangeLog	f
  lib/glob/Makefile.in	f
! lib/glob/fnmatch.c	f
! lib/glob/fnmatch.h	f
  lib/glob/glob.c		f
  lib/glob/glob.h		f
--- 215,223 ----
  include/stdc.h		f
  include/systimes.h	f
+ include/typemax.h	f
  include/unionwait.h	f
  lib/glob/Makefile.in	f
! lib/glob/strmatch.c	f
! lib/glob/strmatch.h	f
  lib/glob/glob.c		f
  lib/glob/glob.h		f
***************
*** 223,232 ****
  lib/malloc/Makefile.in	f
  lib/malloc/getpagesize.h	f
  lib/malloc/alloca.c	f
  lib/malloc/malloc.c	f
! lib/malloc/gmalloc.c	f
  lib/malloc/xmalloc.c	f
! lib/malloc/ogmalloc.c	f
! lib/malloc/omalloc.c	f
  lib/malloc/stub.c	f
  lib/malloc/i386-alloca.s	f
--- 228,242 ----
  lib/malloc/Makefile.in	f
  lib/malloc/getpagesize.h	f
+ lib/malloc/imalloc.h	f
+ lib/malloc/mstats.h	f
+ lib/malloc/shmalloc.h	f
+ lib/malloc/table.h	f
  lib/malloc/alloca.c	f
  lib/malloc/malloc.c	f
! lib/malloc/stats.c	f
! lib/malloc/table.c	f
! lib/malloc/trace.c	f
  lib/malloc/xmalloc.c	f
! lib/malloc/xleaktrace	f	755
  lib/malloc/stub.c	f
  lib/malloc/i386-alloca.s	f
***************
*** 308,315 ****
--- 318,328 ----
  lib/sh/clktck.c		f
  lib/sh/clock.c		f
+ lib/sh/fmtullong.c	f
+ lib/sh/fmtulong.c	f
  lib/sh/getcwd.c		f
  lib/sh/getenv.c		f
  lib/sh/inet_aton.c	f
  lib/sh/itos.c		f
+ lib/sh/mailstat.c	f
  lib/sh/makepath.c	f
  lib/sh/netopen.c	f
***************
*** 321,324 ****
--- 334,338 ----
  lib/sh/shquote.c	f
  lib/sh/shtty.c		f
+ lib/sh/snprintf.c	f
  lib/sh/spell.c		f
  lib/sh/strcasecmp.c	f
***************
*** 329,334 ****
--- 343,352 ----
  lib/sh/strpbrk.c	f
  lib/sh/strtod.c		f
+ lib/sh/strtoimax.c	f
  lib/sh/strtol.c		f
+ lib/sh/strtoll.c	f
  lib/sh/strtoul.c	f
+ lib/sh/strtoull.c	f
+ lib/sh/strtoumax.c	f
  lib/sh/strtrans.c	f
  lib/sh/times.c		f
***************
*** 360,364 ****
  lib/termcap/grot/README	f
  lib/tilde/README	f
- lib/tilde/ChangeLog	f
  lib/tilde/Makefile.in	f
  lib/tilde/doc/tilde.texi	f
--- 378,381 ----
***************
*** 379,384 ****
  CWRU/changelog		f
  CWRU/sh-redir-hack	f
- CWRU/empty-for-wordlist	f
- CWRU/maildir-patch	f
  CWRU/mh-folder-comp	f
  doc/FAQ		f
--- 396,399 ----
***************
*** 396,399 ****
--- 411,415 ----
  doc/htmlpost.sh	f	755
  support/Makefile.in	f
+ support/bashversion.c	f
  support/config.guess	f
  support/config.sub	f
***************
*** 428,431 ****
--- 444,448 ----
  examples/complete/complete2.ianmac	f
  examples/complete/complete.freebsd	f
+ examples/complete/complete.gnu-longopt	f
  examples/loadables/README	f
  examples/loadables/template.c	f
***************
*** 435,441 ****
  examples/loadables/print.c	f
  examples/loadables/realpath.c	f
- examples/loadables/sprintf.c	f
  examples/loadables/sleep.c	f
  examples/loadables/truefalse.c	f
  examples/loadables/getconf.c	f
  examples/loadables/finfo.c	f
--- 452,458 ----
  examples/loadables/print.c	f
  examples/loadables/realpath.c	f
  examples/loadables/sleep.c	f
  examples/loadables/truefalse.c	f
+ examples/loadables/getconf.h	f
  examples/loadables/getconf.c	f
  examples/loadables/finfo.c	f
***************
*** 470,473 ****
--- 487,493 ----
  examples/functions/basename	f
  examples/functions/basename2	f
+ examples/functions/coproc.bash	f
+ examples/functions/coshell.README	f
+ examples/functions/coshell.bash	f
  examples/functions/csh-compat	f
  examples/functions/dirfuncs	f
***************
*** 738,741 ****
--- 758,763 ----
  tests/trap.right	f
  tests/trap1.sub		f	755
+ tests/trap2.sub		f	755
+ tests/trap2a.sub	f	755
  tests/type.tests	f
  tests/type.right	f
diff -Nrc2 bash-2.05/Makefile.in bash-2.05a/Makefile.in
*** bash-2.05/Makefile.in	Tue Apr  3 15:03:24 2001
--- bash-2.05a/Makefile.in	Mon Nov 12 11:42:45 2001
***************
*** 1,3 ****
! # Makefile for bash-2.05, version 2.120
  #
  # Copyright (C) 1996 Free Software Foundation, Inc.
--- 1,3 ----
! # Makefile for bash-2.05a, version 2.128
  #
  # Copyright (C) 1996 Free Software Foundation, Inc.
***************
*** 32,42 ****
  manpfx = man
  
! man1ext = 1
! man1dir = $(mandir)/$(manpfx)$(man1ext)
! man3ext = 3
! man3dir = $(mandir)/$(manpfx)$(man3ext)
  
  htmldir = @htmldir@
  
  topdir = @top_srcdir@
  BUILD_DIR = @BUILD_DIR@
--- 32,45 ----
  manpfx = man
  
! man1ext = .1
! man1dir = $(mandir)/$(manpfx)1
! man3ext = .3
! man3dir = $(mandir)/$(manpfx)3
  
  htmldir = @htmldir@
  
+ # Support an alternate destination root directory for package building
+ DESTDIR =
+ 
  topdir = @top_srcdir@
  BUILD_DIR = @BUILD_DIR@
***************
*** 74,82 ****
  	$(CC) $(CCFLAGS) -c $<
  
- # The name of this program and some version information.
  EXEEXT = @EXEEXT@
  Program = bash$(EXEEXT)
  Version = @BASHVERS@
! PatchLevel = @BASHPATCH@
  RELSTATUS = release
  
--- 77,90 ----
  	$(CC) $(CCFLAGS) -c $<
  
  EXEEXT = @EXEEXT@
+ OBJEXT = @OBJEXT@
+ 
+ # The name of this program and some version information.
+ VERSPROG = bashversion$(EXEEXT)
+ VERSOBJ = bashversion.$(OBJEXT)
+ 
  Program = bash$(EXEEXT)
  Version = @BASHVERS@
! PatchLevel = `$(BUILD_DIR)/$(VERSPROG) -p`
  RELSTATUS = release
  
***************
*** 87,91 ****
  
  # comment out for release
! # DEBUG = -DDEBUG
  
  THIS_SH = $(BUILD_DIR)/$(Program)
--- 95,100 ----
  
  # comment out for release
! #DEBUG = -DDEBUG
! #MALLOC_DEBUG = -DMALLOC_DEBUG
  
  THIS_SH = $(BUILD_DIR)/$(Program)
***************
*** 111,123 ****
  SYSTEM_FLAGS = -DPROGRAM='"$(Program)"' -DCONF_HOSTTYPE='"$(Machine)"' -DCONF_OSTYPE='"$(OS)"' -DCONF_MACHTYPE='"$(MACHTYPE)"' -DCONF_VENDOR='"$(VENDOR)"'
  
! CCFLAGS	= $(PROFILE_FLAGS) $(SYSTEM_FLAGS) $(LOCAL_DEFS) \
! 	  $(DEFS) $(LOCAL_CFLAGS) $(CPPFLAGS) $(INCLUDES) $(CFLAGS)
  
! INCLUDES = -I. @RL_INCLUDE@ -I$(srcdir) -I$(BASHINCDIR) -I$(LIBSRC) -I$(includedir)
  
! GCC_LINT_FLAGS = -ansi -Wall -Wshadow -Wpointer-arith -Wcast-qual \
! 		 -Wwrite-strings -Werror -Wstrict-prototypes \
! 		 -Wmissing-prototypes -Wno-implicit
! GCC_LINT_CFLAGS = $(CCFLAGS) $(GCC_LINT_FLAGS)
  
  #
--- 120,135 ----
  SYSTEM_FLAGS = -DPROGRAM='"$(Program)"' -DCONF_HOSTTYPE='"$(Machine)"' -DCONF_OSTYPE='"$(OS)"' -DCONF_MACHTYPE='"$(MACHTYPE)"' -DCONF_VENDOR='"$(VENDOR)"'
  
! CCFLAGS_FOR_BUILD = $(PROFILE_FLAGS) $(SYSTEM_FLAGS) $(LOCAL_DEFS) \
! 	  $(DEFS) $(LOCAL_CFLAGS) $(CPPFLAGS) $(INCLUDES)
! 
! CCFLAGS = $(CCFLAGS_FOR_BUILD) $(CFLAGS)
  
! INCLUDES = -I. @RL_INCLUDE@ -I$(srcdir) -I$(BASHINCDIR) -I$(LIBSRC)
  
! GCC_LINT_FLAGS = -Wall -Wshadow -Wpointer-arith -Wcast-qual \
! 		 -Wcast-align -Wstrict-prototypes -Wconversion \
! 		 -Wmissing-prototypes -Wtraditional -Wredundant-decls -pedantic
! 
! GCC_LINT_CFLAGS = $(CCFLAGS_FOR_BUILD) $(GCC_LINT_FLAGS)
  
  #
***************
*** 130,134 ****
  LIBSRC = $(srcdir)/$(LIBSUBDIR)
  
! SUBDIR_INCLUDES = -I. @RL_INCLUDE@ -I$(topdir) -I$(topdir)/$(LIBSUBDIR) -I$(includedir)
  
  # the bash library
--- 142,146 ----
  LIBSRC = $(srcdir)/$(LIBSUBDIR)
  
! SUBDIR_INCLUDES = -I. @RL_INCLUDE@ -I$(topdir) -I$(topdir)/$(LIBSUBDIR)
  
  # the bash library
***************
*** 154,158 ****
  	       ${SH_LIBSRC}/stringvec.c ${SH_LIBSRC}/tmpfile.c \
  	       ${SH_LIBSRC}/spell.c ${SH_LIBSRC}/strtrans.c \
! 	       ${SH_LIBSRC}/strindex.c ${SH_LIBSRC}/shquote.c
  
  SHLIB_LIB = -lsh
--- 166,174 ----
  	       ${SH_LIBSRC}/stringvec.c ${SH_LIBSRC}/tmpfile.c \
  	       ${SH_LIBSRC}/spell.c ${SH_LIBSRC}/strtrans.c \
! 	       ${SH_LIBSRC}/strindex.c ${SH_LIBSRC}/shquote.c \
! 	       ${SH_LIBSRC}/snprintf.c ${SH_LIBSRC}/mailstat.c \
! 	       ${SH_LIBSRC}/fmtulong.c ${SH_LIBSRC}/fmtullong.c \
! 	       ${SH_LIBSRC}/strtoll.c ${SH_LIBSRC}/strtoull.c \
! 	       ${SH_LIBSRC}/strtoimax.c ${SH_LIBSRC}/strtoumax.c
  
  SHLIB_LIB = -lsh
***************
*** 168,171 ****
--- 184,189 ----
  RL_ABSSRC = ${topdir}/$(RL_LIBDIR)
  
+ RL_INCLUDEDIR = @RL_INCLUDEDIR@
+ 
  READLINE_LIB = @READLINE_LIB@
  READLINE_LIBRARY = $(RL_LIBDIR)/libreadline.a
***************
*** 253,259 ****
  GLOB_DEP = $(GLOB_LIBRARY)
  
! GLOB_SOURCE = $(GLOB_LIBSRC)/glob.c $(GLOB_LIBSRC)/fnmatch.c \
! 	      $(GLOB_LIBSRC)/glob.h $(GLOB_LIBSRC)/fnmatch.h
! GLOB_OBJ    = $(GLOB_LIBDIR)/glob.o $(GLOB_LIBDIR)/fnmatch.o
  
  # The source, object and documentation for the GNU Tilde library.
--- 271,277 ----
  GLOB_DEP = $(GLOB_LIBRARY)
  
! GLOB_SOURCE = $(GLOB_LIBSRC)/glob.c $(GLOB_LIBSRC)/strmatch.c \
! 	      $(GLOB_LIBSRC)/glob.h $(GLOB_LIBSRC)/strmatch.h
! GLOB_OBJ    = $(GLOB_LIBDIR)/glob.o $(GLOB_LIBDIR)/strmatch.o
  
  # The source, object and documentation for the GNU Tilde library.
***************
*** 281,295 ****
  
  MALLOC_SRC = @MALLOC_SRC@
! MALLOC_SOURCE = ${ALLOC_LIBSRC}/${MALLOC_SRC}
! MALLOC_CFLAGS = -DRCHECK -Dbotch=programming_error
! 
! MALLOC_LIB     = -lmalloc
! MALLOC_LIBRARY = $(ALLOC_LIBDIR)/libmalloc.a
! MALLOC_LDFLAGS = -L$(ALLOC_LIBDIR)
! MALLOC_DEP = $(MALLOC_LIBRARY)
  
! ALLOC_HEADERS = $(ALLOC_LIBSRC)/getpagesize.h
  
! $(MALLOC_LIBRARY):	${MALLOC_SOURCE}
  		@(cd $(ALLOC_LIBDIR) && \
  		 $(MAKE) $(MFLAGS) \
--- 299,316 ----
  
  MALLOC_SRC = @MALLOC_SRC@
! MALLOC_OTHERSRC = ${ALLOC_LIBSRC}/trace.c ${ALLOC_LIBSRC}/stats.c \
! 		  ${ALLOC_LIBSRC}/table.c
! MALLOC_SOURCE = ${ALLOC_LIBSRC}/${MALLOC_SRC} ${MALLOC_OTHERSRC}
! MALLOC_CFLAGS = -DRCHECK -Dbotch=programming_error ${MALLOC_DEBUG}
! 
! MALLOC_LIB     = @MALLOC_LIB@
! MALLOC_LIBRARY = @MALLOC_LIBRARY@
! MALLOC_LDFLAGS = @MALLOC_LDFLAGS@
! MALLOC_DEP = @MALLOC_DEP@
  
! ALLOC_HEADERS = $(ALLOC_LIBSRC)/getpagesize.h $(ALLOC_LIBSRC)/shmalloc.h \
! 		$(ALLOC_LIBSRC)/imalloc.h $(ALLOC_LIBSRC)/mstats.h
  
! $(MALLOC_LIBRARY):	${MALLOC_SOURCE} ${ALLOC_HEADERS} config.h
  		@(cd $(ALLOC_LIBDIR) && \
  		 $(MAKE) $(MFLAGS) \
***************
*** 303,307 ****
  		 $(BASHINCDIR)/posixtime.h $(BASHINCDIR)/systimes.h \
  		 $(BASHINCDIR)/unionwait.h $(BASHINCDIR)/maxpath.h \
! 		 $(BASHINCDIR)/shtty.h
  
  LIBRARIES = $(SHLIB_LIB) $(READLINE_LIB) $(HISTORY_LIB) $(TERMCAP_LIB) $(GLOB_LIB) \
--- 324,328 ----
  		 $(BASHINCDIR)/posixtime.h $(BASHINCDIR)/systimes.h \
  		 $(BASHINCDIR)/unionwait.h $(BASHINCDIR)/maxpath.h \
! 		 $(BASHINCDIR)/shtty.h $(BASHINCDIR)/typemax.h
  
  LIBRARIES = $(SHLIB_LIB) $(READLINE_LIB) $(HISTORY_LIB) $(TERMCAP_LIB) $(GLOB_LIB) \
***************
*** 323,327 ****
  	   expr.c copy_cmd.c flags.c subst.c hashcmd.c hashlib.c mailcheck.c \
  	   test.c trap.c alias.c jobs.c nojobs.c $(ALLOC_FILES) braces.c \
! 	   input.c bashhist.c array.c sig.c pathexp.c \
  	   unwind_prot.c siglist.c bashline.c bracecomp.c error.c \
  	   list.c stringlib.c locale.c findcmd.c redir.c \
--- 344,348 ----
  	   expr.c copy_cmd.c flags.c subst.c hashcmd.c hashlib.c mailcheck.c \
  	   test.c trap.c alias.c jobs.c nojobs.c $(ALLOC_FILES) braces.c \
! 	   input.c bashhist.c array.c arrayfunc.c sig.c pathexp.c \
  	   unwind_prot.c siglist.c bashline.c bracecomp.c error.c \
  	   list.c stringlib.c locale.c findcmd.c redir.c \
***************
*** 330,337 ****
  HSOURCES = shell.h flags.h trap.h hashcmd.h hashlib.h jobs.h builtins.h \
  	   general.h variables.h config.h $(ALLOC_HEADERS) alias.h \
! 	   quit.h unwind_prot.h syntax.h \
  	   command.h input.h error.h bashansi.h dispose_cmd.h make_cmd.h \
  	   subst.h externs.h siglist.h bashhist.h bashline.h bashtypes.h \
! 	   array.h sig.h mailcheck.h bashintl.h bashjmp.h ${GRAM_H} \
  	   execute_cmd.h parser.h pathexp.h pathnames.h pcomplete.h \
  	   $(BASHINCFILES)
--- 351,358 ----
  HSOURCES = shell.h flags.h trap.h hashcmd.h hashlib.h jobs.h builtins.h \
  	   general.h variables.h config.h $(ALLOC_HEADERS) alias.h \
! 	   quit.h unwind_prot.h syntax.h ${GRAM_H} \
  	   command.h input.h error.h bashansi.h dispose_cmd.h make_cmd.h \
  	   subst.h externs.h siglist.h bashhist.h bashline.h bashtypes.h \
! 	   array.h arrayfunc.h sig.h mailcheck.h bashintl.h bashjmp.h \
  	   execute_cmd.h parser.h pathexp.h pathnames.h pcomplete.h \
  	   $(BASHINCFILES)
***************
*** 344,347 ****
--- 365,369 ----
  # object files chosen based on running of configure
  JOBS_O = @JOBS_O@
+ SIGLIST_O = @SIGLIST_O@
  
  # Matching object files.
***************
*** 350,355 ****
  	   expr.o flags.o $(JOBS_O) subst.o hashcmd.o hashlib.o mailcheck.o \
  	   trap.o input.o unwind_prot.o pathexp.o sig.o test.o version.o \
! 	   alias.o array.o braces.o bracecomp.o bashhist.o bashline.o \
! 	   siglist.o list.o stringlib.o locale.o findcmd.o redir.o \
  	   pcomplete.o pcomplib.o syntax.o xmalloc.o
  
--- 372,377 ----
  	   expr.o flags.o $(JOBS_O) subst.o hashcmd.o hashlib.o mailcheck.o \
  	   trap.o input.o unwind_prot.o pathexp.o sig.o test.o version.o \
! 	   alias.o array.o arrayfunc.o braces.o bracecomp.o bashhist.o \
! 	   bashline.o $(SIGLIST_O) list.o stringlib.o locale.o findcmd.o redir.o \
  	   pcomplete.o pcomplib.o syntax.o xmalloc.o
  
***************
*** 415,419 ****
  		  tests/recho$(EXEEXT) tests/zecho$(EXEEXT) \
  		  tests/printenv$(EXEEXT) mksignames$(EXEEXT) lsignames.h \
! 		  mksyntax${EXEEXT} syntax.c
  CREATED_CONFIGURE = config.h config.cache config.status config.log \
  		    stamp-h
--- 437,441 ----
  		  tests/recho$(EXEEXT) tests/zecho$(EXEEXT) \
  		  tests/printenv$(EXEEXT) mksignames$(EXEEXT) lsignames.h \
! 		  mksyntax${EXEEXT} syntax.c $(VERSPROG) $(VERSOBJ)
  CREATED_CONFIGURE = config.h config.cache config.status config.log \
  		    stamp-h
***************
*** 436,449 ****
  	size $(Program)
  
! .build:	$(SOURCES) config.h Makefile version.h
  	@echo
  	@echo "	  ***********************************************************"
  	@echo "	  *                                                         *"
! 	@echo "	  * Making Bash-$(Version).$(PatchLevel)-$(RELSTATUS) for a $(Machine) running $(OS)"
  	@echo "	  *                                                         *"
  	@echo "	  ***********************************************************"
  	@echo
  
! bashbug: $(SUPPORT_SRC)bashbug.sh config.h Makefile
  	@sed -e "s%!MACHINE!%$(Machine)%" -e "s%!OS!%$(OS)%" \
  	     -e "s%!CFLAGS!%$(CCFLAGS)%" -e "s%!CC!%$(CC)%" \
--- 458,471 ----
  	size $(Program)
  
! .build:	$(SOURCES) config.h Makefile version.h $(VERSPROG)
  	@echo
  	@echo "	  ***********************************************************"
  	@echo "	  *                                                         *"
! 	@echo "	  * `$(BUILD_DIR)/$(VERSPROG) -l`"
  	@echo "	  *                                                         *"
  	@echo "	  ***********************************************************"
  	@echo
  
! bashbug: $(SUPPORT_SRC)bashbug.sh config.h Makefile $(VERSPROG)
  	@sed -e "s%!MACHINE!%$(Machine)%" -e "s%!OS!%$(OS)%" \
  	     -e "s%!CFLAGS!%$(CCFLAGS)%" -e "s%!CC!%$(CC)%" \
***************
*** 458,465 ****
  	size $(Program)
  
  version.h:  $(SOURCES) config.h Makefile 
! 	$(SHELL) $(SUPPORT_SRC)mkversion.sh -b -s $(RELSTATUS) -d $(Version) -p $(PatchLevel) -o newversion.h \
  		&& mv newversion.h version.h
  
  # old rules
  GRAM_H = parser-built
--- 480,493 ----
  	size $(Program)
  
+ lint:
+ 	${MAKE} ${MFLAGS} CFLAGS='${GCC_LINT_FLAGS}' .made
+ 
  version.h:  $(SOURCES) config.h Makefile 
! 	$(SHELL) $(SUPPORT_SRC)mkversion.sh -b -S ${topdir} -s $(RELSTATUS) -d $(Version) -o newversion.h \
  		&& mv newversion.h version.h
  
+ bashversion$(EXEEXT):	patchlevel.h conftypes.h version.h version.o $(SUPPORT_SRC)bashversion.c
+ 	$(CC_FOR_BUILD) $(CCFLAGS_FOR_BUILD) $(CPPFLAGS) -o $@ $(SUPPORT_SRC)bashversion.c version.o
+ 
  # old rules
  GRAM_H = parser-built
***************
*** 472,475 ****
--- 500,504 ----
  #	-if test -f y.tab.h; then mv -f y.tab.h old-y.tab.h; fi
  	$(YACC) -d $(srcdir)/parse.y
+ 	touch parser-built
  #	-if cmp -s old-y.tab.h y.tab.h; then mv old-y.tab.h y.tab.h; else cp -p y.tab.h ${GRAM_H}; fi
  
***************
*** 494,498 ****
  	@echo making $@ in ${GLOB_LIBDIR}
  	@(cd ${GLOB_LIBDIR} && \
! 		$(MAKE) $(MFLAGS) libglob.a) || exit 1
  
  $(TILDE_LIBRARY): config.h $(TILDE_SOURCE)
--- 523,527 ----
  	@echo making $@ in ${GLOB_LIBDIR}
  	@(cd ${GLOB_LIBDIR} && \
! 		$(MAKE) $(MFLAGS) DEBUG=${DEBUG} libglob.a) || exit 1
  
  $(TILDE_LIBRARY): config.h $(TILDE_SOURCE)
***************
*** 509,519 ****
  	@echo making $@ in ${SH_LIBDIR}
  	@(cd ${SH_LIBDIR} && \
! 		$(MAKE) $(MFLAGS) ${SHLIB_LIBNAME}) || exit 1
  
  mksignames$(EXEEXT):	$(SUPPORT_SRC)mksignames.c
! 	$(CC_FOR_BUILD) $(CCFLAGS) $(CPPFLAGS) -o $@ $(SUPPORT_SRC)mksignames.c
  
! mksyntax$(EXEEXT):	${srcdir}/mksyntax.c config.h syntax.h
! 	${CC_FOR_BUILD} ${CCFLAGS} ${CPPFLAGS} -o $@ ${srcdir}/mksyntax.c
  
  # make a list of signals for the local system -- this is done when we're
--- 538,548 ----
  	@echo making $@ in ${SH_LIBDIR}
  	@(cd ${SH_LIBDIR} && \
! 		$(MAKE) $(MFLAGS) DEBUG=${DEBUG} ${SHLIB_LIBNAME}) || exit 1
  
  mksignames$(EXEEXT):	$(SUPPORT_SRC)mksignames.c
! 	$(CC_FOR_BUILD) $(CCFLAGS_FOR_BUILD) $(CPPFLAGS) -o $@ $(SUPPORT_SRC)mksignames.c
  
! mksyntax$(EXEEXT):	${srcdir}/mksyntax.c config.h syntax.h ${BASHINCDIR}/chartypes.h
! 	${CC_FOR_BUILD} ${CCFLAGS_FOR_BUILD} ${CPPFLAGS} -o $@ ${srcdir}/mksyntax.c
  
  # make a list of signals for the local system -- this is done when we're
***************
*** 532,543 ****
  
  $(BUILTINS_LIBRARY): $(BUILTIN_DEFS) $(BUILTIN_C_SRC) config.h ${BASHINCDIR}/memalloc.h
! 	@(cd $(DEFDIR) && $(MAKE) $(MFLAGS) libbuiltins.a ) || exit 1
  
  # these require special rules to circumvent make builtin rules
  ${DEFDIR}/common.o:	$(BUILTIN_SRCDIR)/common.c
! 	@(cd $(DEFDIR) && $(MAKE) $(MFLAGS) common.o) || exit 1
  
  ${DEFDIR}/bashgetopt.o:	$(BUILTIN_SRCDIR)/bashgetopt.c
! 	@(cd $(DEFDIR) && $(MAKE) $(MFLAGS) bashgetopt.o) || exit 1
  
  ${DEFDIR}/builtext.h: $(BUILTIN_DEFS)
--- 561,572 ----
  
  $(BUILTINS_LIBRARY): $(BUILTIN_DEFS) $(BUILTIN_C_SRC) config.h ${BASHINCDIR}/memalloc.h
! 	@(cd $(DEFDIR) && $(MAKE) $(MFLAGS) DEBUG=${DEBUG} libbuiltins.a ) || exit 1
  
  # these require special rules to circumvent make builtin rules
  ${DEFDIR}/common.o:	$(BUILTIN_SRCDIR)/common.c
! 	@(cd $(DEFDIR) && $(MAKE) $(MFLAGS) DEBUG=${DEBUG} common.o) || exit 1
  
  ${DEFDIR}/bashgetopt.o:	$(BUILTIN_SRCDIR)/bashgetopt.c
! 	@(cd $(DEFDIR) && $(MAKE) $(MFLAGS) DEBUG=${DEBUG} bashgetopt.o) || exit 1
  
  ${DEFDIR}/builtext.h: $(BUILTIN_DEFS)
***************
*** 594,619 ****
  
  installdirs:
! 	@${SHELL} $(SUPPORT_SRC)mkdirs $(bindir)
! 	@${SHELL} $(SUPPORT_SRC)mkdirs $(man1dir) $(man3dir)
! 	@${SHELL} $(SUPPORT_SRC)mkdirs $(infodir)
  
  install:	.made installdirs
! 	$(INSTALL_PROGRAM) $(INSTALLMODE) $(Program) $(bindir)/$(Program)
! 	$(INSTALL_PROGRAM) $(INSTALLMODE2) bashbug $(bindir)/bashbug
  	-( cd $(DOCDIR) ; $(MAKE) $(MFLAGS) \
  		man1dir=$(man1dir) man1ext=$(man1ext) \
  		man3dir=$(man3dir) man3ext=$(man3ext) \
! 		infodir=$(infodir) htmldir=$(htmldir) $@ )
  
  install-strip:
  	$(MAKE) $(MFLAGS) INSTALL_PROGRAM='$(INSTALL_PROGRAM) -s' \
! 		prefix=${prefix} exec_prefix=${exec_prefix} install
  
  uninstall:	.made
! 	$(RM) $(bindir)/$(Program) $(bindir)/bashbug
  	-( cd $(DOCDIR) ; $(MAKE) $(MFLAGS) \
  		man1dir=$(man1dir) man1ext=$(man1ext) \
  		man3dir=$(man3dir) man3ext=$(man3ext) \
! 		infodir=$(infodir) $@ )
  
  .PHONY: basic-clean clean realclean maintainer-clean distclean mostlyclean
--- 623,649 ----
  
  installdirs:
! 	@${SHELL} $(SUPPORT_SRC)mkdirs $(DESTDIR)$(bindir)
! 	@${SHELL} $(SUPPORT_SRC)mkdirs $(DESTDIR)$(man1dir)
! 	@${SHELL} $(SUPPORT_SRC)mkdirs $(DESTDIR)$(infodir)
  
  install:	.made installdirs
! 	$(INSTALL_PROGRAM) $(INSTALLMODE) $(Program) $(DESTDIR)$(bindir)/$(Program)
! 	$(INSTALL_PROGRAM) $(INSTALLMODE2) bashbug $(DESTDIR)$(bindir)/bashbug
  	-( cd $(DOCDIR) ; $(MAKE) $(MFLAGS) \
  		man1dir=$(man1dir) man1ext=$(man1ext) \
  		man3dir=$(man3dir) man3ext=$(man3ext) \
! 		infodir=$(infodir) htmldir=$(htmldir) DESTDIR=$(DESTDIR) $@ )
  
  install-strip:
  	$(MAKE) $(MFLAGS) INSTALL_PROGRAM='$(INSTALL_PROGRAM) -s' \
! 		prefix=${prefix} exec_prefix=${exec_prefix} \
! 		DESTDIR=$(DESTDIR) install
  
  uninstall:	.made
! 	$(RM) $(DESTDIR)$(bindir)/$(Program) $(DESTDIR)$(bindir)/bashbug
  	-( cd $(DOCDIR) ; $(MAKE) $(MFLAGS) \
  		man1dir=$(man1dir) man1ext=$(man1ext) \
  		man3dir=$(man3dir) man3ext=$(man3ext) \
! 		infodir=$(infodir) htmldir=$(htmldir) DESTDIR=$(DESTDIR) $@ )
  
  .PHONY: basic-clean clean realclean maintainer-clean distclean mostlyclean
***************
*** 661,665 ****
  	@echo This command is intended for maintainers to use.
  	@echo It deletes files that may require special tools to rebuild.
! 	$(RM) y.tab.c y.tab.h parser-built.h tags TAGS
  	( cd $(DOCDIR) && $(MAKE) $(MFLAGS) $@ )
  	( cd builtins && $(MAKE) $(MFLAGS) $@ )
--- 691,695 ----
  	@echo This command is intended for maintainers to use.
  	@echo It deletes files that may require special tools to rebuild.
! 	$(RM) y.tab.c y.tab.h parser-built tags TAGS
  	( cd $(DOCDIR) && $(MAKE) $(MFLAGS) $@ )
  	( cd builtins && $(MAKE) $(MFLAGS) $@ )
***************
*** 683,687 ****
  	@$(CC) $(CCFLAGS) -o $@ $(SUPPORT_SRC)printenv.c
  
! test tests check:		force $(Program) $(TESTS_SUPPORT)
  	@-test -d tests || mkdir tests
  	@cp $(TESTS_SUPPORT) tests
--- 713,717 ----
  	@$(CC) $(CCFLAGS) -o $@ $(SUPPORT_SRC)printenv.c
  
! test tests check:	force $(Program) $(TESTS_SUPPORT)
  	@-test -d tests || mkdir tests
  	@cp $(TESTS_SUPPORT) tests
***************
*** 704,707 ****
--- 734,741 ----
  	$(Program) $(SUPPORT_SRC)mkdep -c ${CC} -- ${CCFLAGS} ${CSOURCES}
  
+ #### PRIVATE TARGETS ####
+ hashtest:	hashlib.c
+ 	$(CC) -DTEST_HASHING $(CCFLAGS) -o $@ $(srcdir)/hashlib.c
+ 
  ############################ DEPENDENCIES ###############################
  
***************
*** 725,741 ****
  # shell basics
  copy_cmd.o: shell.h syntax.h config.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h ${BASHINCDIR}/stdc.h error.h
! copy_cmd.o: general.h bashtypes.h variables.h array.h hashlib.h
  copy_cmd.o: quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
  copy_cmd.o: make_cmd.h subst.h sig.h pathnames.h externs.h
  dispose_cmd.o: bashansi.h ${BASHINCDIR}/ansi_stdlib.h
  dispose_cmd.o: shell.h syntax.h config.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h ${BASHINCDIR}/stdc.h
! dispose_cmd.o: error.h general.h bashtypes.h variables.h array.h hashlib.h
  dispose_cmd.o: quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
  dispose_cmd.o: make_cmd.h subst.h sig.h pathnames.h externs.h
  error.o: config.h bashtypes.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h flags.h ${BASHINCDIR}/stdc.h error.h
! error.o: command.h general.h externs.h input.h bashhist.h
  eval.o: config.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h trap.h flags.h ${DEFSRC}/common.h
  eval.o: shell.h syntax.h config.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h ${BASHINCDIR}/stdc.h error.h
! eval.o: general.h bashtypes.h variables.h array.h hashlib.h
  eval.o: quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
  eval.o: make_cmd.h subst.h sig.h pathnames.h externs.h
--- 759,775 ----
  # shell basics
  copy_cmd.o: shell.h syntax.h config.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h ${BASHINCDIR}/stdc.h error.h
! copy_cmd.o: general.h xmalloc.h bashtypes.h variables.h arrayfunc.h conftypes.h array.h hashlib.h
  copy_cmd.o: quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
  copy_cmd.o: make_cmd.h subst.h sig.h pathnames.h externs.h
  dispose_cmd.o: bashansi.h ${BASHINCDIR}/ansi_stdlib.h
  dispose_cmd.o: shell.h syntax.h config.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h ${BASHINCDIR}/stdc.h
! dispose_cmd.o: error.h general.h xmalloc.h bashtypes.h variables.h arrayfunc.h conftypes.h array.h hashlib.h
  dispose_cmd.o: quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
  dispose_cmd.o: make_cmd.h subst.h sig.h pathnames.h externs.h
  error.o: config.h bashtypes.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h flags.h ${BASHINCDIR}/stdc.h error.h
! error.o: command.h general.h xmalloc.h externs.h input.h bashhist.h
  eval.o: config.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h trap.h flags.h ${DEFSRC}/common.h
  eval.o: shell.h syntax.h config.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h ${BASHINCDIR}/stdc.h error.h
! eval.o: general.h xmalloc.h bashtypes.h variables.h arrayfunc.h conftypes.h array.h hashlib.h
  eval.o: quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
  eval.o: make_cmd.h subst.h sig.h pathnames.h externs.h
***************
*** 743,821 ****
  execute_cmd.o: config.h bashtypes.h ${BASHINCDIR}/filecntl.h ${BASHINCDIR}/posixstat.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h
  execute_cmd.o: shell.h syntax.h config.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h ${BASHINCDIR}/stdc.h error.h
! execute_cmd.o: general.h bashtypes.h variables.h array.h hashlib.h
  execute_cmd.o: quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
  execute_cmd.o: make_cmd.h subst.h sig.h pathnames.h externs.h
  execute_cmd.o: ${BASHINCDIR}/memalloc.h ${GRAM_H} flags.h builtins.h jobs.h quit.h siglist.h
  execute_cmd.o: execute_cmd.h findcmd.h redir.h trap.h test.h pathexp.h
! execute_cmd.o: $(DEFSRC)/common.h ${DEFDIR}/builtext.h ${GLOB_LIBSRC}/fnmatch.h
! execute_cmd.o: ${BASHINCDIR}/posixtime.h
  expr.o: config.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h
  expr.o: shell.h syntax.h config.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h ${BASHINCDIR}/stdc.h error.h
! expr.o: general.h bashtypes.h variables.h array.h hashlib.h
  expr.o: quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
  expr.o: make_cmd.h subst.h sig.h pathnames.h externs.h
  findcmd.o: config.h bashtypes.h ${BASHINCDIR}/filecntl.h ${BASHINCDIR}/posixstat.h bashansi.h
  findcmd.o: ${BASHINCDIR}/ansi_stdlib.h ${BASHINCDIR}/memalloc.h shell.h syntax.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h
! findcmd.o: ${BASHINCDIR}/stdc.h error.h general.h variables.h quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h
  findcmd.o: dispose_cmd.h make_cmd.h subst.h sig.h pathnames.h externs.h
  findcmd.o: flags.h hashlib.h pathexp.h hashcmd.h 
  flags.o: config.h flags.h
  flags.o: shell.h syntax.h config.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h ${BASHINCDIR}/stdc.h error.h
! flags.o: general.h bashtypes.h variables.h array.h hashlib.h
  flags.o: quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
! flags.o: make_cmd.h subst.h sig.h pathnames.h externs.h
  general.o: config.h bashtypes.h ${BASHINCDIR}/posixstat.h ${BASHINCDIR}/filecntl.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h
  general.o: shell.h syntax.h config.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h ${BASHINCDIR}/stdc.h error.h
! general.o: general.h bashtypes.h variables.h array.h hashlib.h
  general.o: quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
  general.o: make_cmd.h subst.h sig.h pathnames.h externs.h
  general.o: ${BASHINCDIR}/maxpath.h ${BASHINCDIR}/posixtime.h
  hashcmd.o: config.h ${BASHINCDIR}/posixstat.h bashtypes.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h
  hashcmd.o: shell.h syntax.h config.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h ${BASHINCDIR}/stdc.h error.h
! hashcmd.o: general.h bashtypes.h variables.h array.h hashcmd.h
  hashcmd.o: execute_cmd.h findcmd.h ${BASHINCDIR}/stdc.h
  hashlib.o: config.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h
  hashlib.o: shell.h syntax.h config.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h ${BASHINCDIR}/stdc.h error.h
! hashlib.o: general.h bashtypes.h variables.h array.h hashlib.h
  hashlib.o: quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
  hashlib.o: make_cmd.h subst.h sig.h pathnames.h externs.h
  input.o: config.h bashtypes.h ${BASHINCDIR}/filecntl.h ${BASHINCDIR}/posixstat.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h
! input.o: command.h ${BASHINCDIR}/stdc.h general.h input.h error.h externs.h
  list.o: shell.h syntax.h config.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h ${BASHINCDIR}/stdc.h error.h
! list.o: general.h bashtypes.h variables.h array.h hashlib.h
  list.o: quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
  list.o: make_cmd.h subst.h sig.h pathnames.h externs.h
  locale.o: config.h bashtypes.h bashintl.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h
  locale.o: shell.h syntax.h config.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h ${BASHINCDIR}/stdc.h error.h
! locale.o: general.h bashtypes.h variables.h array.h hashlib.h
  locale.o: quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
  locale.o: make_cmd.h subst.h sig.h pathnames.h externs.h
  mailcheck.o: config.h bashtypes.h ${BASHINCDIR}/posixstat.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h
  mailcheck.o: shell.h syntax.h config.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h ${BASHINCDIR}/stdc.h error.h
! mailcheck.o: general.h bashtypes.h variables.h array.h hashlib.h
  mailcheck.o: quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
  mailcheck.o: make_cmd.h subst.h sig.h pathnames.h externs.h
  mailcheck.o: execute_cmd.h mailcheck.h
  make_cmd.o: config.h bashtypes.h ${BASHINCDIR}/filecntl.h bashansi.h
! make_cmd.o: command.h ${BASHINCDIR}/stdc.h general.h error.h flags.h make_cmd.h
! make_cmd.o: variables.h array.h hashlib.h subst.h input.h externs.h
  make_cmd.o: jobs.h quit.h siglist.h syntax.h
  y.tab.o: config.h bashtypes.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h ${BASHINCDIR}/memalloc.h
  y.tab.o: shell.h syntax.h config.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h ${BASHINCDIR}/stdc.h error.h
! y.tab.o: general.h bashtypes.h variables.h array.h hashlib.h
  y.tab.o: quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
! y.tab.o: make_cmd.h subst.h sig.h pathnames.h externs.h
  y.tab.o: trap.h flags.h parser.h input.h mailcheck.h $(DEFSRC)/common.h
  y.tab.o: $(DEFDIR)/builtext.h bashline.h bashhist.h jobs.h siglist.h alias.h
  pathexp.o: config.h bashtypes.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h
  pathexp.o: shell.h syntax.h config.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h ${BASHINCDIR}/stdc.h error.h
! pathexp.o: general.h bashtypes.h variables.h array.h hashlib.h
  pathexp.o: quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
  pathexp.o: make_cmd.h subst.h sig.h pathnames.h externs.h
  pathexp.o: pathexp.h flags.h 
! pathexp.o: $(GLOB_LIBSRC)/glob.h $(GLOB_LIBSRC)/fnmatch.h
  print_cmd.o: config.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h
  print_cmd.o: shell.h syntax.h config.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h ${BASHINCDIR}/stdc.h error.h
! print_cmd.o: general.h bashtypes.h variables.h array.h hashlib.h
  print_cmd.o: quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
  print_cmd.o: make_cmd.h subst.h sig.h pathnames.h externs.h
--- 777,860 ----
  execute_cmd.o: config.h bashtypes.h ${BASHINCDIR}/filecntl.h ${BASHINCDIR}/posixstat.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h
  execute_cmd.o: shell.h syntax.h config.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h ${BASHINCDIR}/stdc.h error.h
! execute_cmd.o: general.h xmalloc.h bashtypes.h variables.h arrayfunc.h conftypes.h array.h hashlib.h
  execute_cmd.o: quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
  execute_cmd.o: make_cmd.h subst.h sig.h pathnames.h externs.h
  execute_cmd.o: ${BASHINCDIR}/memalloc.h ${GRAM_H} flags.h builtins.h jobs.h quit.h siglist.h
  execute_cmd.o: execute_cmd.h findcmd.h redir.h trap.h test.h pathexp.h
! execute_cmd.o: $(DEFSRC)/common.h ${DEFDIR}/builtext.h ${GLOB_LIBSRC}/strmatch.h
! execute_cmd.o: ${BASHINCDIR}/posixtime.h ${BASHINCDIR}/chartypes.h
  expr.o: config.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h
  expr.o: shell.h syntax.h config.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h ${BASHINCDIR}/stdc.h error.h
! expr.o: general.h xmalloc.h bashtypes.h variables.h arrayfunc.h conftypes.h array.h hashlib.h
  expr.o: quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
  expr.o: make_cmd.h subst.h sig.h pathnames.h externs.h
+ expr.o: ${BASHINCDIR}/chartypes.h
  findcmd.o: config.h bashtypes.h ${BASHINCDIR}/filecntl.h ${BASHINCDIR}/posixstat.h bashansi.h
  findcmd.o: ${BASHINCDIR}/ansi_stdlib.h ${BASHINCDIR}/memalloc.h shell.h syntax.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h
! findcmd.o: ${BASHINCDIR}/stdc.h error.h general.h xmalloc.h variables.h arrayfunc.h conftypes.h quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h
  findcmd.o: dispose_cmd.h make_cmd.h subst.h sig.h pathnames.h externs.h
  findcmd.o: flags.h hashlib.h pathexp.h hashcmd.h 
+ findcmd.o: ${BASHINCDIR}/chartypes.h
  flags.o: config.h flags.h
  flags.o: shell.h syntax.h config.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h ${BASHINCDIR}/stdc.h error.h
! flags.o: general.h xmalloc.h bashtypes.h variables.h arrayfunc.h conftypes.h array.h hashlib.h
  flags.o: quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
! flags.o: make_cmd.h subst.h sig.h pathnames.h externs.h bashhist.h
  general.o: config.h bashtypes.h ${BASHINCDIR}/posixstat.h ${BASHINCDIR}/filecntl.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h
  general.o: shell.h syntax.h config.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h ${BASHINCDIR}/stdc.h error.h
! general.o: general.h xmalloc.h bashtypes.h variables.h arrayfunc.h conftypes.h array.h hashlib.h
  general.o: quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
  general.o: make_cmd.h subst.h sig.h pathnames.h externs.h
  general.o: ${BASHINCDIR}/maxpath.h ${BASHINCDIR}/posixtime.h
+ general.o: ${BASHINCDIR}/chartypes.h
  hashcmd.o: config.h ${BASHINCDIR}/posixstat.h bashtypes.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h
  hashcmd.o: shell.h syntax.h config.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h ${BASHINCDIR}/stdc.h error.h
! hashcmd.o: general.h xmalloc.h bashtypes.h variables.h arrayfunc.h conftypes.h array.h hashcmd.h
  hashcmd.o: execute_cmd.h findcmd.h ${BASHINCDIR}/stdc.h
  hashlib.o: config.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h
  hashlib.o: shell.h syntax.h config.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h ${BASHINCDIR}/stdc.h error.h
! hashlib.o: general.h xmalloc.h bashtypes.h variables.h arrayfunc.h conftypes.h array.h hashlib.h
  hashlib.o: quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
  hashlib.o: make_cmd.h subst.h sig.h pathnames.h externs.h
  input.o: config.h bashtypes.h ${BASHINCDIR}/filecntl.h ${BASHINCDIR}/posixstat.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h
! input.o: command.h ${BASHINCDIR}/stdc.h general.h xmalloc.h input.h error.h externs.h
  list.o: shell.h syntax.h config.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h ${BASHINCDIR}/stdc.h error.h
! list.o: general.h xmalloc.h bashtypes.h variables.h arrayfunc.h conftypes.h array.h hashlib.h
  list.o: quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
  list.o: make_cmd.h subst.h sig.h pathnames.h externs.h
  locale.o: config.h bashtypes.h bashintl.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h
  locale.o: shell.h syntax.h config.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h ${BASHINCDIR}/stdc.h error.h
! locale.o: general.h xmalloc.h bashtypes.h variables.h arrayfunc.h conftypes.h array.h hashlib.h
  locale.o: quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
  locale.o: make_cmd.h subst.h sig.h pathnames.h externs.h
+ locale.o: ${BASHINCDIR}/chartypes.h
  mailcheck.o: config.h bashtypes.h ${BASHINCDIR}/posixstat.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h
+ mailcheck.o: ${BASHINCDIR}/posixtime.h
  mailcheck.o: shell.h syntax.h config.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h ${BASHINCDIR}/stdc.h error.h
! mailcheck.o: general.h xmalloc.h bashtypes.h variables.h arrayfunc.h conftypes.h array.h hashlib.h
  mailcheck.o: quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
  mailcheck.o: make_cmd.h subst.h sig.h pathnames.h externs.h
  mailcheck.o: execute_cmd.h mailcheck.h
  make_cmd.o: config.h bashtypes.h ${BASHINCDIR}/filecntl.h bashansi.h
! make_cmd.o: command.h ${BASHINCDIR}/stdc.h general.h xmalloc.h error.h flags.h make_cmd.h
! make_cmd.o: variables.h arrayfunc.h conftypes.h array.h hashlib.h subst.h input.h externs.h
  make_cmd.o: jobs.h quit.h siglist.h syntax.h
  y.tab.o: config.h bashtypes.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h ${BASHINCDIR}/memalloc.h
  y.tab.o: shell.h syntax.h config.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h ${BASHINCDIR}/stdc.h error.h
! y.tab.o: general.h xmalloc.h bashtypes.h variables.h arrayfunc.h conftypes.h array.h hashlib.h
  y.tab.o: quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
! y.tab.o: make_cmd.h subst.h sig.h pathnames.h externs.h test.h
  y.tab.o: trap.h flags.h parser.h input.h mailcheck.h $(DEFSRC)/common.h
  y.tab.o: $(DEFDIR)/builtext.h bashline.h bashhist.h jobs.h siglist.h alias.h
  pathexp.o: config.h bashtypes.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h
  pathexp.o: shell.h syntax.h config.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h ${BASHINCDIR}/stdc.h error.h
! pathexp.o: general.h xmalloc.h bashtypes.h variables.h arrayfunc.h conftypes.h array.h hashlib.h
  pathexp.o: quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
  pathexp.o: make_cmd.h subst.h sig.h pathnames.h externs.h
  pathexp.o: pathexp.h flags.h 
! pathexp.o: $(GLOB_LIBSRC)/glob.h $(GLOB_LIBSRC)/strmatch.h
  print_cmd.o: config.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h
  print_cmd.o: shell.h syntax.h config.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h ${BASHINCDIR}/stdc.h error.h
! print_cmd.o: general.h xmalloc.h bashtypes.h variables.h arrayfunc.h conftypes.h array.h hashlib.h
  print_cmd.o: quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
  print_cmd.o: make_cmd.h subst.h sig.h pathnames.h externs.h
***************
*** 823,860 ****
  redir.o: config.h bashtypes.h ${BASHINCDIR}/posixstat.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h ${BASHINCDIR}/filecntl.h
  redir.o: ${BASHINCDIR}/memalloc.h shell.h syntax.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h ${BASHINCDIR}/stdc.h error.h
! redir.o: general.h variables.h array.h hashlib.h quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h
  redir.o: dispose_cmd.h make_cmd.h subst.h sig.h pathnames.h externs.h
  redir.o: flags.h execute_cmd.h redir.h input.h
  shell.o: config.h bashtypes.h ${BASHINCDIR}/posixstat.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h ${BASHINCDIR}/filecntl.h
  shell.o: shell.h syntax.h config.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h ${BASHINCDIR}/stdc.h error.h
! shell.o: general.h bashtypes.h variables.h array.h hashlib.h
  shell.o: quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
! shell.o: make_cmd.h subst.h sig.h pathnames.h externs.h
  shell.o: flags.h trap.h mailcheck.h builtins.h $(DEFSRC)/common.h
  shell.o: jobs.h siglist.h input.h execute_cmd.h findcmd.h bashhist.h
! shell.o: ${GLOB_LIBSRC}/fnmatch.h
  sig.o: config.h bashtypes.h
  sig.o: shell.h syntax.h config.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h ${BASHINCDIR}/stdc.h error.h
! sig.o: general.h bashtypes.h variables.h array.h hashlib.h
  sig.o: quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
  sig.o: make_cmd.h subst.h sig.h pathnames.h externs.h
  sig.o: jobs.h siglist.h trap.h $(DEFSRC)/common.h bashline.h bashhist.h
  siglist.o: config.h bashtypes.h siglist.h trap.h
! stringlib.o: bashtypes.h
  stringlib.o: shell.h syntax.h config.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h ${BASHINCDIR}/stdc.h error.h
! stringlib.o: general.h bashtypes.h variables.h array.h hashlib.h
  stringlib.o: quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
  stringlib.o: make_cmd.h subst.h sig.h pathnames.h externs.h
  subst.o: config.h bashtypes.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h ${BASHINCDIR}/posixstat.h
  subst.o: shell.h syntax.h config.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h ${BASHINCDIR}/stdc.h error.h
! subst.o: general.h bashtypes.h variables.h array.h hashlib.h
  subst.o: quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
  subst.o: make_cmd.h subst.h sig.h pathnames.h externs.h
  subst.o: flags.h jobs.h siglist.h execute_cmd.h ${BASHINCDIR}/filecntl.h trap.h pathexp.h
  subst.o: mailcheck.h input.h $(DEFSRC)/getopt.h $(DEFSRC)/common.h
! subst.o: bashline.h bashhist.h ${GLOB_LIBSRC}/fnmatch.h
  test.o: bashtypes.h ${BASHINCDIR}/posixstat.h ${BASHINCDIR}/filecntl.h
  test.o: shell.h syntax.h config.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h ${BASHINCDIR}/stdc.h error.h
! test.o: general.h bashtypes.h variables.h array.h hashlib.h
  test.o: quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
  test.o: make_cmd.h subst.h sig.h pathnames.h externs.h test.h
--- 862,901 ----
  redir.o: config.h bashtypes.h ${BASHINCDIR}/posixstat.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h ${BASHINCDIR}/filecntl.h
  redir.o: ${BASHINCDIR}/memalloc.h shell.h syntax.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h ${BASHINCDIR}/stdc.h error.h
! redir.o: general.h xmalloc.h variables.h arrayfunc.h conftypes.h array.h hashlib.h quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h
  redir.o: dispose_cmd.h make_cmd.h subst.h sig.h pathnames.h externs.h
  redir.o: flags.h execute_cmd.h redir.h input.h
  shell.o: config.h bashtypes.h ${BASHINCDIR}/posixstat.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h ${BASHINCDIR}/filecntl.h
  shell.o: shell.h syntax.h config.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h ${BASHINCDIR}/stdc.h error.h
! shell.o: general.h xmalloc.h bashtypes.h variables.h arrayfunc.h conftypes.h array.h hashlib.h
  shell.o: quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
! shell.o: make_cmd.h subst.h sig.h pathnames.h externs.h version.h
  shell.o: flags.h trap.h mailcheck.h builtins.h $(DEFSRC)/common.h
  shell.o: jobs.h siglist.h input.h execute_cmd.h findcmd.h bashhist.h
! shell.o: ${GLOB_LIBSRC}/strmatch.h ${BASHINCDIR}/posixtime.h
  sig.o: config.h bashtypes.h
  sig.o: shell.h syntax.h config.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h ${BASHINCDIR}/stdc.h error.h
! sig.o: general.h xmalloc.h bashtypes.h variables.h arrayfunc.h conftypes.h array.h hashlib.h
  sig.o: quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
  sig.o: make_cmd.h subst.h sig.h pathnames.h externs.h
  sig.o: jobs.h siglist.h trap.h $(DEFSRC)/common.h bashline.h bashhist.h
  siglist.o: config.h bashtypes.h siglist.h trap.h
! stringlib.o: bashtypes.h ${BASHINCDIR}/chartypes.h
  stringlib.o: shell.h syntax.h config.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h ${BASHINCDIR}/stdc.h error.h
! stringlib.o: general.h xmalloc.h bashtypes.h variables.h arrayfunc.h conftypes.h array.h hashlib.h
  stringlib.o: quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
  stringlib.o: make_cmd.h subst.h sig.h pathnames.h externs.h
+ stringlib.o: ${GLOB_LIBSRC}/glob.h ${GLOB_LIBSRC}/strmatch.h
  subst.o: config.h bashtypes.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h ${BASHINCDIR}/posixstat.h
  subst.o: shell.h syntax.h config.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h ${BASHINCDIR}/stdc.h error.h
! subst.o: general.h xmalloc.h bashtypes.h variables.h arrayfunc.h conftypes.h array.h hashlib.h
  subst.o: quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
  subst.o: make_cmd.h subst.h sig.h pathnames.h externs.h
  subst.o: flags.h jobs.h siglist.h execute_cmd.h ${BASHINCDIR}/filecntl.h trap.h pathexp.h
  subst.o: mailcheck.h input.h $(DEFSRC)/getopt.h $(DEFSRC)/common.h
! subst.o: bashline.h bashhist.h ${GLOB_LIBSRC}/strmatch.h
! subst.o: ${BASHINCDIR}/chartypes.h
  test.o: bashtypes.h ${BASHINCDIR}/posixstat.h ${BASHINCDIR}/filecntl.h
  test.o: shell.h syntax.h config.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h ${BASHINCDIR}/stdc.h error.h
! test.o: general.h xmalloc.h bashtypes.h variables.h arrayfunc.h conftypes.h array.h hashlib.h
  test.o: quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
  test.o: make_cmd.h subst.h sig.h pathnames.h externs.h test.h
***************
*** 862,880 ****
  trap.o: config.h bashtypes.h trap.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h
  trap.o: shell.h syntax.h config.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h ${BASHINCDIR}/stdc.h error.h
! trap.o: general.h bashtypes.h variables.h array.h hashlib.h
  trap.o: quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
  trap.o: make_cmd.h subst.h sig.h pathnames.h externs.h
  trap.o: signames.h $(DEFSRC)/common.h
  unwind_prot.o: config.h bashtypes.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h command.h ${BASHINCDIR}/stdc.h
! unwind_prot.o: general.h unwind_prot.h quit.h sig.h
  variables.o: config.h bashtypes.h ${BASHINCDIR}/posixstat.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h
  variables.o: shell.h syntax.h config.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h ${BASHINCDIR}/stdc.h error.h
! variables.o: general.h bashtypes.h variables.h array.h hashlib.h
  variables.o: quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
  variables.o: make_cmd.h subst.h sig.h pathnames.h externs.h
  variables.o: flags.h execute_cmd.h mailcheck.h input.h $(DEFSRC)/common.h
! variables.o: findcmd.h bashhist.h
! variables.o: pcomplete.h
! version.o: version.h .build
  xmalloc.o: config.h bashtypes.h ${BASHINCDIR}/ansi_stdlib.h error.h
  
--- 903,922 ----
  trap.o: config.h bashtypes.h trap.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h
  trap.o: shell.h syntax.h config.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h ${BASHINCDIR}/stdc.h error.h
! trap.o: general.h xmalloc.h bashtypes.h variables.h arrayfunc.h conftypes.h array.h hashlib.h
  trap.o: quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
  trap.o: make_cmd.h subst.h sig.h pathnames.h externs.h
  trap.o: signames.h $(DEFSRC)/common.h
  unwind_prot.o: config.h bashtypes.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h command.h ${BASHINCDIR}/stdc.h
! unwind_prot.o: general.h xmalloc.h unwind_prot.h quit.h sig.h
  variables.o: config.h bashtypes.h ${BASHINCDIR}/posixstat.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h
  variables.o: shell.h syntax.h config.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h ${BASHINCDIR}/stdc.h error.h
! variables.o: general.h xmalloc.h bashtypes.h variables.h arrayfunc.h conftypes.h array.h hashlib.h
  variables.o: quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
  variables.o: make_cmd.h subst.h sig.h pathnames.h externs.h
  variables.o: flags.h execute_cmd.h mailcheck.h input.h $(DEFSRC)/common.h
! variables.o: findcmd.h bashhist.h hashcmd.h pathexp.h
! variables.o: pcomplete.h version.h ${BASHINCDIR}/chartypes.h
! variables.o: ${BASHINCDIR}/posixtime.h
! version.o: version.h conftypes.h patchlevel.h
  xmalloc.o: config.h bashtypes.h ${BASHINCDIR}/ansi_stdlib.h error.h
  
***************
*** 884,894 ****
  jobs.o: bashansi.h ${BASHINCDIR}/ansi_stdlib.h
  jobs.o: shell.h syntax.h config.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h ${BASHINCDIR}/stdc.h error.h
! jobs.o: general.h bashtypes.h variables.h array.h hashlib.h
  jobs.o: quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
  jobs.o: make_cmd.h subst.h sig.h pathnames.h externs.h
  jobs.o: jobs.h flags.h $(DEFSRC)/common.h $(DEFDIR)/builtext.h
  jobs.o: ${BASHINCDIR}/posixwait.h ${BASHINCDIR}/unionwait.h
  nojobs.o: config.h bashtypes.h ${BASHINCDIR}/filecntl.h bashjmp.h ${BASHINCDIR}/posixjmp.h
! nojobs.o: command.h ${BASHINCDIR}/stdc.h general.h jobs.h quit.h siglist.h externs.h
  nojobs.o: sig.h error.h ${BASHINCDIR}/shtty.h input.h
  
--- 926,937 ----
  jobs.o: bashansi.h ${BASHINCDIR}/ansi_stdlib.h
  jobs.o: shell.h syntax.h config.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h ${BASHINCDIR}/stdc.h error.h
! jobs.o: general.h xmalloc.h bashtypes.h variables.h arrayfunc.h conftypes.h array.h hashlib.h
  jobs.o: quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
  jobs.o: make_cmd.h subst.h sig.h pathnames.h externs.h
  jobs.o: jobs.h flags.h $(DEFSRC)/common.h $(DEFDIR)/builtext.h
  jobs.o: ${BASHINCDIR}/posixwait.h ${BASHINCDIR}/unionwait.h
+ jobs.o: ${BASHINCDIR}/posixtime.h
  nojobs.o: config.h bashtypes.h ${BASHINCDIR}/filecntl.h bashjmp.h ${BASHINCDIR}/posixjmp.h
! nojobs.o: command.h ${BASHINCDIR}/stdc.h general.h xmalloc.h jobs.h quit.h siglist.h externs.h
  nojobs.o: sig.h error.h ${BASHINCDIR}/shtty.h input.h
  
***************
*** 897,916 ****
  array.o: config.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h
  array.o: shell.h syntax.h config.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h ${BASHINCDIR}/stdc.h error.h
! array.o: general.h bashtypes.h variables.h array.h hashlib.h
  array.o: quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
  array.o: make_cmd.h subst.h sig.h pathnames.h externs.h
  array.o: $(DEFSRC)/common.h
  braces.o: config.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h
  braces.o: shell.h syntax.h config.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h ${BASHINCDIR}/stdc.h error.h
! braces.o: general.h bashtypes.h variables.h array.h hashlib.h
  braces.o: quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
  braces.o: make_cmd.h subst.h sig.h pathnames.h externs.h
  alias.o: config.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h command.h ${BASHINCDIR}/stdc.h
! alias.o: general.h bashtypes.h externs.h alias.h
  alias.o: pcomplete.h
  
  pcomplib.o: config.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h bashtypes.h
  pcomplib.o: ${BASHINCDIR}/stdc.h hashlib.h pcomplete.h shell.h syntax.h
! pcomplib.o: bashjmp.h command.h general.h error.h variables.h quit.h
  pcomplib.o: unwind_prot.h dispose_cmd.h make_cmd.h subst.h sig.h pathnames.h
  pcomplib.o: externs.h ${BASHINCDIR}/maxpath.h
--- 940,966 ----
  array.o: config.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h
  array.o: shell.h syntax.h config.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h ${BASHINCDIR}/stdc.h error.h
! array.o: general.h xmalloc.h bashtypes.h variables.h arrayfunc.h conftypes.h array.h hashlib.h
  array.o: quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
  array.o: make_cmd.h subst.h sig.h pathnames.h externs.h
  array.o: $(DEFSRC)/common.h
+ arrayfunc.o: config.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h
+ arrayfunc.o: shell.h syntax.h config.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h ${BASHINCDIR}/stdc.h error.h
+ arrayfunc.o: general.h xmalloc.h bashtypes.h variables.h arrayfunc.h conftypes.h array.h hashlib.h
+ arrayfunc.o: quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
+ arrayfunc.o: make_cmd.h subst.h sig.h pathnames.h externs.h
+ arrayfunc.o: $(DEFSRC)/common.h
  braces.o: config.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h
  braces.o: shell.h syntax.h config.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h ${BASHINCDIR}/stdc.h error.h
! braces.o: general.h xmalloc.h bashtypes.h variables.h arrayfunc.h conftypes.h array.h hashlib.h
  braces.o: quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
  braces.o: make_cmd.h subst.h sig.h pathnames.h externs.h
  alias.o: config.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h command.h ${BASHINCDIR}/stdc.h
! alias.o: general.h xmalloc.h bashtypes.h externs.h alias.h
  alias.o: pcomplete.h
+ alias.o: ${BASHINCDIR}/chartypes.h
  
  pcomplib.o: config.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h bashtypes.h
  pcomplib.o: ${BASHINCDIR}/stdc.h hashlib.h pcomplete.h shell.h syntax.h
! pcomplib.o: bashjmp.h command.h general.h xmalloc.h error.h variables.h arrayfunc.h conftypes.h quit.h
  pcomplib.o: unwind_prot.h dispose_cmd.h make_cmd.h subst.h sig.h pathnames.h
  pcomplib.o: externs.h ${BASHINCDIR}/maxpath.h
***************
*** 918,924 ****
  pcomplete.o: config.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h bashtypes.h
  pcomplete.o: ${BASHINCDIR}/stdc.h hashlib.h pcomplete.h shell.h syntax.h
! pcomplete.o: bashjmp.h command.h general.h error.h variables.h quit.h
  pcomplete.o: unwind_prot.h dispose_cmd.h make_cmd.h subst.h sig.h pathnames.h
! pcomplete.o: externs.h ${BASHINCDIR}/maxpath.h
  
  # library support files
--- 968,974 ----
  pcomplete.o: config.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h bashtypes.h
  pcomplete.o: ${BASHINCDIR}/stdc.h hashlib.h pcomplete.h shell.h syntax.h
! pcomplete.o: bashjmp.h command.h general.h xmalloc.h error.h variables.h arrayfunc.h conftypes.h quit.h
  pcomplete.o: unwind_prot.h dispose_cmd.h make_cmd.h subst.h sig.h pathnames.h
! pcomplete.o: externs.h ${BASHINCDIR}/maxpath.h execute_cmd.h
  
  # library support files
***************
*** 927,950 ****
  bashhist.o: ${BASHINCDIR}/filecntl.h
  bashhist.o: shell.h syntax.h config.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h ${BASHINCDIR}/stdc.h error.h
! bashhist.o: general.h bashtypes.h variables.h array.h hashlib.h
  bashhist.o: quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
  bashhist.o: make_cmd.h subst.h sig.h pathnames.h externs.h
  bashhist.o: flags.h input.h parser.h pathexp.h $(DEFSRC)/common.h bashline.h
! bashhist.o: $(GLOB_LIBSRC)/fnmatch.h
  bashline.o: config.h bashtypes.h ${BASHINCDIR}/posixstat.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h
  bashline.o: shell.h syntax.h config.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h ${BASHINCDIR}/stdc.h error.h
! bashline.o: general.h bashtypes.h variables.h array.h hashlib.h
  bashline.o: quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
  bashline.o: make_cmd.h subst.h sig.h pathnames.h externs.h
  bashline.o: builtins.h bashhist.h bashline.h execute_cmd.h findcmd.h pathexp.h
  bashline.o: $(DEFSRC)/common.h $(GLOB_LIBSRC)/glob.h alias.h
! bashline.o: pcomplete.h
  bracecomp.o: config.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h
  bracecomp.o: shell.h syntax.h config.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h ${BASHINCDIR}/stdc.h error.h
! bracecomp.o: general.h bashtypes.h variables.h array.h hashlib.h
  bracecomp.o: quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
  bracecomp.o: make_cmd.h subst.h sig.h pathnames.h externs.h
! bracecomp.o: shell.h syntax.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h command.h hashlib.h builtins.h general.h
! bracecomp.o: quit.h alias.h config.h  variables.h
  bracecomp.o: dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
  
--- 977,1000 ----
  bashhist.o: ${BASHINCDIR}/filecntl.h
  bashhist.o: shell.h syntax.h config.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h ${BASHINCDIR}/stdc.h error.h
! bashhist.o: general.h xmalloc.h bashtypes.h variables.h arrayfunc.h conftypes.h array.h hashlib.h
  bashhist.o: quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
  bashhist.o: make_cmd.h subst.h sig.h pathnames.h externs.h
  bashhist.o: flags.h input.h parser.h pathexp.h $(DEFSRC)/common.h bashline.h
! bashhist.o: $(GLOB_LIBSRC)/strmatch.h
  bashline.o: config.h bashtypes.h ${BASHINCDIR}/posixstat.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h
  bashline.o: shell.h syntax.h config.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h ${BASHINCDIR}/stdc.h error.h
! bashline.o: general.h xmalloc.h bashtypes.h variables.h arrayfunc.h conftypes.h array.h hashlib.h
  bashline.o: quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
  bashline.o: make_cmd.h subst.h sig.h pathnames.h externs.h
  bashline.o: builtins.h bashhist.h bashline.h execute_cmd.h findcmd.h pathexp.h
  bashline.o: $(DEFSRC)/common.h $(GLOB_LIBSRC)/glob.h alias.h
! bashline.o: pcomplete.h ${BASHINCDIR}/chartypes.h
  bracecomp.o: config.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h
  bracecomp.o: shell.h syntax.h config.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h ${BASHINCDIR}/stdc.h error.h
! bracecomp.o: general.h xmalloc.h bashtypes.h variables.h arrayfunc.h conftypes.h array.h hashlib.h
  bracecomp.o: quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
  bracecomp.o: make_cmd.h subst.h sig.h pathnames.h externs.h
! bracecomp.o: shell.h syntax.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h command.h hashlib.h builtins.h general.h xmalloc.h
! bracecomp.o: quit.h alias.h config.h  variables.h arrayfunc.h conftypes.h
  bracecomp.o: dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
  
***************
*** 978,995 ****
  # builtin c sources
  builtins/bashgetopt.o: config.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h
! builtins/bashgetopt.o: shell.h syntax.h config.h bashjmp.h command.h general.h error.h
! builtins/bashgetopt.o: variables.h quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
  builtins/bashgetopt.o: make_cmd.h subst.h sig.h pathnames.h externs.h
  builtins/bashgetopt.o: $(DEFSRC)/common.h
  builtins/common.o: bashtypes.h ${BASHINCDIR}/posixstat.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h
  builtins/common.o: shell.h syntax.h config.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h command.h
! builtins/common.o: ${BASHINCDIR}/memalloc.h variables.h input.h siglist.h
  builtins/common.o: quit.h unwind_prot.h ${BASHINCDIR}/maxpath.h jobs.h builtins.h
  builtins/common.o: dispose_cmd.h make_cmd.h subst.h externs.h bashhist.h
! builtins/common.o: execute_cmd.h ${BASHINCDIR}/stdc.h general.h error.h pathnames.h
  builtins/common.o: ${DEFDIR}/builtext.h
  builtins/evalfile.o: bashtypes.h ${BASHINCDIR}/posixstat.h ${BASHINCDIR}/filecntl.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h
! builtins/evalfile.o: shell.h syntax.h config.h bashjmp.h command.h general.h error.h
! builtins/evalfile.o: variables.h quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
  builtins/evalfile.o: make_cmd.h subst.h sig.h pathnames.h externs.h
  builtins/evalfile.o: jobs.h builtins.h flags.h input.h execute_cmd.h
--- 1028,1047 ----
  # builtin c sources
  builtins/bashgetopt.o: config.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h
! builtins/bashgetopt.o: shell.h syntax.h config.h bashjmp.h command.h general.h xmalloc.h error.h
! builtins/bashgetopt.o: variables.h arrayfunc.h conftypes.h quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
  builtins/bashgetopt.o: make_cmd.h subst.h sig.h pathnames.h externs.h
  builtins/bashgetopt.o: $(DEFSRC)/common.h
+ builtins/bashgetopt.o: ${BASHINCDIR}/chartypes.h
  builtins/common.o: bashtypes.h ${BASHINCDIR}/posixstat.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h
  builtins/common.o: shell.h syntax.h config.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h command.h
! builtins/common.o: ${BASHINCDIR}/memalloc.h variables.h arrayfunc.h conftypes.h input.h siglist.h
  builtins/common.o: quit.h unwind_prot.h ${BASHINCDIR}/maxpath.h jobs.h builtins.h
  builtins/common.o: dispose_cmd.h make_cmd.h subst.h externs.h bashhist.h
! builtins/common.o: execute_cmd.h ${BASHINCDIR}/stdc.h general.h xmalloc.h error.h pathnames.h
  builtins/common.o: ${DEFDIR}/builtext.h
+ builtins/common.o: ${BASHINCDIR}/chartypes.h
  builtins/evalfile.o: bashtypes.h ${BASHINCDIR}/posixstat.h ${BASHINCDIR}/filecntl.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h
! builtins/evalfile.o: shell.h syntax.h config.h bashjmp.h command.h general.h xmalloc.h error.h
! builtins/evalfile.o: variables.h arrayfunc.h conftypes.h quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
  builtins/evalfile.o: make_cmd.h subst.h sig.h pathnames.h externs.h
  builtins/evalfile.o: jobs.h builtins.h flags.h input.h execute_cmd.h
***************
*** 997,1001 ****
  builtins/evalstring.o: config.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h
  builtins/evalstring.o: shell.h syntax.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h command.h siglist.h
! builtins/evalstring.o: ${BASHINCDIR}/memalloc.h variables.h input.h
  builtins/evalstring.o: quit.h unwind_prot.h ${BASHINCDIR}/maxpath.h jobs.h builtins.h
  builtins/evalstring.o: dispose_cmd.h make_cmd.h subst.h externs.h 
--- 1049,1053 ----
  builtins/evalstring.o: config.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h
  builtins/evalstring.o: shell.h syntax.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h command.h siglist.h
! builtins/evalstring.o: ${BASHINCDIR}/memalloc.h variables.h arrayfunc.h conftypes.h input.h
  builtins/evalstring.o: quit.h unwind_prot.h ${BASHINCDIR}/maxpath.h jobs.h builtins.h
  builtins/evalstring.o: dispose_cmd.h make_cmd.h subst.h externs.h 
***************
*** 1003,1008 ****
  builtins/evalstring.o: bashhist.h $(DEFSRC)/common.h
  builtins/getopt.o: config.h ${BASHINCDIR}/memalloc.h
! builtins/getopt.o: shell.h syntax.h bashjmp.h command.h general.h error.h
! builtins/getopt.o: variables.h quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
  builtins/getopt.o: make_cmd.h subst.h sig.h pathnames.h externs.h
  builtins/getopt.o: $(DEFSRC)/getopt.h
--- 1055,1060 ----
  builtins/evalstring.o: bashhist.h $(DEFSRC)/common.h
  builtins/getopt.o: config.h ${BASHINCDIR}/memalloc.h
! builtins/getopt.o: shell.h syntax.h bashjmp.h command.h general.h xmalloc.h error.h
! builtins/getopt.o: variables.h arrayfunc.h conftypes.h quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
  builtins/getopt.o: make_cmd.h subst.h sig.h pathnames.h externs.h
  builtins/getopt.o: $(DEFSRC)/getopt.h
***************
*** 1011,1161 ****
  
  # builtin def files
! builtins/alias.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h ${BASHINCDIR}/maxpath.h
  builtins/alias.o: quit.h $(DEFSRC)/common.h
  builtins/alias.o: shell.h syntax.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h command.h ${BASHINCDIR}/stdc.h unwind_prot.h
! builtins/alias.o: dispose_cmd.h make_cmd.h subst.h externs.h variables.h 
! builtins/bind.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h ${BASHINCDIR}/maxpath.h
  builtins/bind.o: dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
! builtins/bind.o: shell.h syntax.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h variables.h quit.h
  builtins/bind.o: $(DEFSRC)/bashgetopt.h
! builtins/break.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h ${BASHINCDIR}/maxpath.h
! builtins/break.o: shell.h syntax.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h variables.h quit.h
  builtins/break.o: dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
! builtins/builtin.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h ${BASHINCDIR}/maxpath.h
  builtins/builtin.o: quit.h $(DEFSRC)/common.h
! builtins/builtin.o: shell.h syntax.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h variables.h 
  builtins/builtin.o: dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
! builtins/cd.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h ${BASHINCDIR}/maxpath.h
! builtins/cd.o: shell.h syntax.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h variables.h
  builtins/cd.o: dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
  builtins/cd.o: $(DEFSRC)/common.h quit.h 
! builtins/command.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h ${BASHINCDIR}/maxpath.h
  builtins/command.o: quit.h $(DEFSRC)/bashgetopt.h
! builtins/command.o: shell.h syntax.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h variables.h 
  builtins/command.o: dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
! builtins/declare.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h ${BASHINCDIR}/maxpath.h
! builtins/declare.o: shell.h syntax.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h variables.h quit.h
  builtins/declare.o: dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
! builtins/echo.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h ${BASHINCDIR}/maxpath.h
! builtins/echo.o: shell.h syntax.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h variables.h quit.h
  builtins/echo.o: dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
! builtins/enable.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h ${BASHINCDIR}/maxpath.h
! builtins/enable.o: shell.h syntax.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h variables.h quit.h
  builtins/enable.o: dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
  builtins/enable.o: pcomplete.h
! builtins/eval.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h ${BASHINCDIR}/maxpath.h
! builtins/eval.o: shell.h syntax.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h variables.h quit.h 
  builtins/eval.o: dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
  builtins/exec.o: bashtypes.h
! builtins/exec.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h ${BASHINCDIR}/maxpath.h
! builtins/exec.o: shell.h syntax.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h variables.h
  builtins/exec.o: dispose_cmd.h make_cmd.h subst.h externs.h execute_cmd.h
  builtins/exec.o: findcmd.h flags.h quit.h $(DEFSRC)/common.h ${BASHINCDIR}/stdc.h
  builtins/exit.o: bashtypes.h
! builtins/exit.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h ${BASHINCDIR}/maxpath.h
! builtins/exit.o: shell.h syntax.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h variables.h quit.h
  builtins/exit.o: dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
  builtins/fc.o: bashtypes.h ${BASHINCDIR}/posixstat.h
  builtins/fc.o: bashansi.h ${BASHINCDIR}/ansi_stdlib.h builtins.h command.h ${BASHINCDIR}/stdc.h 
! builtins/fc.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h ${BASHINCDIR}/maxpath.h
! builtins/fc.o: flags.h unwind_prot.h variables.h shell.h syntax.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h 
  builtins/fc.o: dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h quit.h 
  builtins/fc.o: $(DEFSRC)/bashgetopt.h bashhist.h
  builtins/fg_bg.o: bashtypes.h
! builtins/fg_bg.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h ${BASHINCDIR}/maxpath.h
! builtins/fg_bg.o: shell.h syntax.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h variables.h quit.h
  builtins/fg_bg.o: dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
! builtins/getopts.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h ${BASHINCDIR}/maxpath.h
! builtins/getopts.o: shell.h syntax.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h variables.h quit.h 
  builtins/getopts.o: dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
  builtins/hash.o: bashtypes.h
  builtins/hash.o: builtins.h command.h findcmd.h ${BASHINCDIR}/stdc.h $(DEFSRC)/common.h
! builtins/hash.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h ${BASHINCDIR}/maxpath.h
! builtins/hash.o: shell.h syntax.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h variables.h quit.h 
! builtins/help.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h ${BASHINCDIR}/maxpath.h
  builtins/help.o: dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
! builtins/help.o: shell.h syntax.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h variables.h quit.h
! builtins/help.o: $(GLOB_LIBSRC)/glob.h
  builtins/history.o: bashtypes.h
! builtins/history.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h ${BASHINCDIR}/maxpath.h
  builtins/history.o: quit.h dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
  builtins/history.o: ${BASHINCDIR}/filecntl.h shell.h syntax.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h
! builtins/history.o: bashhist.h variables.h 
! builtins/inlib.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h ${BASHINCDIR}/maxpath.h
! builtins/inlib.o: shell.h syntax.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h variables.h quit.h 
  builtins/inlib.o: dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
! builtins/jobs.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h ${BASHINCDIR}/maxpath.h
  builtins/jobs.o: quit.h $(DEFSRC)/bashgetopt.h
! builtins/jobs.o: shell.h syntax.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h variables.h 
  builtins/jobs.o: dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
! builtins/kill.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h ${BASHINCDIR}/maxpath.h
  builtins/kill.o: quit.h dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
! builtins/kill.o: shell.h syntax.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h trap.h unwind_prot.h variables.h 
! builtins/let.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h ${BASHINCDIR}/maxpath.h
  builtins/let.o: quit.h dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
! builtins/let.o: shell.h syntax.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h variables.h 
  builtins/printf.o: config.h ${BASHINCDIR}/memalloc.h bashjmp.h command.h error.h
! builtins/printf.o: general.h quit.h dispose_cmd.h make_cmd.h subst.h
  builtins/printf.o: externs.h sig.h pathnames.h shell.h syntax.h unwind_prot.h
! builtins/printf.o: variables.h ${BASHINCDIR}/stdc.h $(DEFSRC)/bashgetopt.h
! builtins/pushd.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h ${BASHINCDIR}/maxpath.h
  builtins/pushd.o: quit.h dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
! builtins/pushd.o: shell.h syntax.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h variables.h
  builtins/pushd.o: $(DEFSRC)/common.h
! builtins/read.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h ${BASHINCDIR}/maxpath.h
  builtins/read.o: quit.h dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
! builtins/read.o: shell.h syntax.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h variables.h 
! builtins/return.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h ${BASHINCDIR}/maxpath.h
  builtins/return.o: quit.h dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
! builtins/return.o: shell.h syntax.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h variables.h 
! builtins/set.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h ${BASHINCDIR}/maxpath.h
  builtins/set.o: quit.h dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
! builtins/set.o: shell.h syntax.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h variables.h flags.h
! builtins/setattr.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h ${BASHINCDIR}/maxpath.h
  builtins/setattr.o: quit.h $(DEFSRC)/common.h $(DEFSRC)/bashgetopt.h
! builtins/setattr.o: shell.h syntax.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h variables.h 
  builtins/setattr.o: dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
! builtins/shift.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h ${BASHINCDIR}/maxpath.h
  builtins/shift.o: quit.h dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
! builtins/shift.o: shell.h syntax.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h variables.h 
  builtins/shift.o: dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
! builtins/shopt.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h
  builtins/shopt.o: quit.h dispose_cmd.h make_cmd.h subst.h externs.h
! builtins/shopt.o: shell.h syntax.h bashjmp.h ${BASHINCDIR}/posixjmp.h unwind_prot.h variables.h ${BASHINCDIR}/maxpath.h
  builtins/shopt.o: $(DEFSRC)/common.h $(DEFSRC)/bashgetopt.h
! builtins/source.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h ${BASHINCDIR}/maxpath.h
  builtins/source.o: quit.h dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
! builtins/source.o: shell.h syntax.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h variables.h
  builtins/source.o: findcmd.h
! builtins/suspend.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h ${BASHINCDIR}/maxpath.h
  builtins/suspend.o: quit.h dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
! builtins/suspend.o: shell.h syntax.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h variables.h 
! builtins/test.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h ${BASHINCDIR}/maxpath.h
  builtins/test.o: quit.h dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
! builtins/test.o: shell.h syntax.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h variables.h 
  builtins/test.o: test.h
! builtins/times.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h ${BASHINCDIR}/maxpath.h
  builtins/times.o: quit.h dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
! builtins/times.o: shell.h syntax.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h variables.h 
! builtins/trap.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h ${BASHINCDIR}/maxpath.h
  builtins/trap.o: quit.h $(DEFSRC)/common.h
! builtins/trap.o: shell.h syntax.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h variables.h 
  builtins/trap.o: dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
! builtins/type.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h ${BASHINCDIR}/maxpath.h
  builtins/type.o: quit.h $(DEFSRC)/common.h findcmd.h
! builtins/type.o: shell.h syntax.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h variables.h
  builtins/type.o: dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
! builtins/ulimit.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h ${BASHINCDIR}/maxpath.h
  builtins/ulimit.o: quit.h dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
! builtins/ulimit.o: shell.h syntax.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h variables.h 
! builtins/umask.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h ${BASHINCDIR}/maxpath.h
  builtins/umask.o: quit.h dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
! builtins/umask.o: shell.h syntax.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h variables.h 
! builtins/wait.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h ${BASHINCDIR}/maxpath.h
  builtins/wait.o: quit.h dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
! builtins/wait.o: shell.h syntax.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h variables.h
  
  builtins/complete.o: config.h shell.h syntax.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h
! builtins/complete.o: unwind_prot.h variables.h
  builtins/complete.o: bashtypes.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h
  builtins/complete.o: builtins.h
--- 1063,1217 ----
  
  # builtin def files
! builtins/alias.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h xmalloc.h ${BASHINCDIR}/maxpath.h
  builtins/alias.o: quit.h $(DEFSRC)/common.h
  builtins/alias.o: shell.h syntax.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h command.h ${BASHINCDIR}/stdc.h unwind_prot.h
! builtins/alias.o: dispose_cmd.h make_cmd.h subst.h externs.h variables.h arrayfunc.h conftypes.h 
! builtins/bind.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h xmalloc.h ${BASHINCDIR}/maxpath.h
  builtins/bind.o: dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
! builtins/bind.o: shell.h syntax.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h variables.h arrayfunc.h conftypes.h quit.h
  builtins/bind.o: $(DEFSRC)/bashgetopt.h
! builtins/break.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h xmalloc.h ${BASHINCDIR}/maxpath.h
! builtins/break.o: shell.h syntax.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h variables.h arrayfunc.h conftypes.h quit.h
  builtins/break.o: dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
! builtins/builtin.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h xmalloc.h ${BASHINCDIR}/maxpath.h
  builtins/builtin.o: quit.h $(DEFSRC)/common.h
! builtins/builtin.o: shell.h syntax.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h variables.h arrayfunc.h conftypes.h 
  builtins/builtin.o: dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
! builtins/cd.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h xmalloc.h ${BASHINCDIR}/maxpath.h
! builtins/cd.o: shell.h syntax.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h variables.h arrayfunc.h conftypes.h
  builtins/cd.o: dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
  builtins/cd.o: $(DEFSRC)/common.h quit.h 
! builtins/command.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h xmalloc.h ${BASHINCDIR}/maxpath.h
  builtins/command.o: quit.h $(DEFSRC)/bashgetopt.h
! builtins/command.o: shell.h syntax.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h variables.h arrayfunc.h conftypes.h 
  builtins/command.o: dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
! builtins/declare.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h xmalloc.h ${BASHINCDIR}/maxpath.h
! builtins/declare.o: shell.h syntax.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h variables.h arrayfunc.h conftypes.h quit.h
  builtins/declare.o: dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
! builtins/echo.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h xmalloc.h ${BASHINCDIR}/maxpath.h
! builtins/echo.o: shell.h syntax.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h variables.h arrayfunc.h conftypes.h quit.h
  builtins/echo.o: dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
! builtins/enable.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h xmalloc.h ${BASHINCDIR}/maxpath.h
! builtins/enable.o: shell.h syntax.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h variables.h arrayfunc.h conftypes.h quit.h
  builtins/enable.o: dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
  builtins/enable.o: pcomplete.h
! builtins/eval.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h xmalloc.h ${BASHINCDIR}/maxpath.h
! builtins/eval.o: shell.h syntax.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h variables.h arrayfunc.h conftypes.h quit.h 
  builtins/eval.o: dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
  builtins/exec.o: bashtypes.h
! builtins/exec.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h xmalloc.h ${BASHINCDIR}/maxpath.h
! builtins/exec.o: shell.h syntax.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h variables.h arrayfunc.h conftypes.h
  builtins/exec.o: dispose_cmd.h make_cmd.h subst.h externs.h execute_cmd.h
  builtins/exec.o: findcmd.h flags.h quit.h $(DEFSRC)/common.h ${BASHINCDIR}/stdc.h
  builtins/exit.o: bashtypes.h
! builtins/exit.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h xmalloc.h ${BASHINCDIR}/maxpath.h
! builtins/exit.o: shell.h syntax.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h variables.h arrayfunc.h conftypes.h quit.h
  builtins/exit.o: dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
  builtins/fc.o: bashtypes.h ${BASHINCDIR}/posixstat.h
  builtins/fc.o: bashansi.h ${BASHINCDIR}/ansi_stdlib.h builtins.h command.h ${BASHINCDIR}/stdc.h 
! builtins/fc.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h xmalloc.h ${BASHINCDIR}/maxpath.h
! builtins/fc.o: flags.h unwind_prot.h variables.h arrayfunc.h conftypes.h shell.h syntax.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h 
  builtins/fc.o: dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h quit.h 
  builtins/fc.o: $(DEFSRC)/bashgetopt.h bashhist.h
+ builtins/fc.o: ${BASHINCDIR}/chartypes.h
  builtins/fg_bg.o: bashtypes.h
! builtins/fg_bg.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h xmalloc.h ${BASHINCDIR}/maxpath.h
! builtins/fg_bg.o: shell.h syntax.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h variables.h arrayfunc.h conftypes.h quit.h
  builtins/fg_bg.o: dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
! builtins/getopts.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h xmalloc.h ${BASHINCDIR}/maxpath.h
! builtins/getopts.o: shell.h syntax.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h variables.h arrayfunc.h conftypes.h quit.h 
  builtins/getopts.o: dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
  builtins/hash.o: bashtypes.h
  builtins/hash.o: builtins.h command.h findcmd.h ${BASHINCDIR}/stdc.h $(DEFSRC)/common.h
! builtins/hash.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h xmalloc.h ${BASHINCDIR}/maxpath.h
! builtins/hash.o: shell.h syntax.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h variables.h arrayfunc.h conftypes.h quit.h 
! builtins/help.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h xmalloc.h ${BASHINCDIR}/maxpath.h
  builtins/help.o: dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
! builtins/help.o: shell.h syntax.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h variables.h arrayfunc.h conftypes.h quit.h
! builtins/help.o: $(GLOB_LIBSRC)/glob.h version.h
  builtins/history.o: bashtypes.h
! builtins/history.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h xmalloc.h ${BASHINCDIR}/maxpath.h
  builtins/history.o: quit.h dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
  builtins/history.o: ${BASHINCDIR}/filecntl.h shell.h syntax.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h
! builtins/history.o: bashhist.h variables.h arrayfunc.h conftypes.h 
! builtins/inlib.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h xmalloc.h ${BASHINCDIR}/maxpath.h
! builtins/inlib.o: shell.h syntax.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h variables.h arrayfunc.h conftypes.h quit.h 
  builtins/inlib.o: dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
! builtins/jobs.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h xmalloc.h ${BASHINCDIR}/maxpath.h
  builtins/jobs.o: quit.h $(DEFSRC)/bashgetopt.h
! builtins/jobs.o: shell.h syntax.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h variables.h arrayfunc.h conftypes.h 
  builtins/jobs.o: dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
! builtins/kill.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h xmalloc.h ${BASHINCDIR}/maxpath.h
  builtins/kill.o: quit.h dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
! builtins/kill.o: shell.h syntax.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h trap.h unwind_prot.h variables.h arrayfunc.h conftypes.h 
! builtins/let.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h xmalloc.h ${BASHINCDIR}/maxpath.h
  builtins/let.o: quit.h dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
! builtins/let.o: shell.h syntax.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h variables.h arrayfunc.h conftypes.h 
  builtins/printf.o: config.h ${BASHINCDIR}/memalloc.h bashjmp.h command.h error.h
! builtins/printf.o: general.h xmalloc.h quit.h dispose_cmd.h make_cmd.h subst.h
  builtins/printf.o: externs.h sig.h pathnames.h shell.h syntax.h unwind_prot.h
! builtins/printf.o: variables.h arrayfunc.h conftypes.h ${BASHINCDIR}/stdc.h $(DEFSRC)/bashgetopt.h
! builtins/printf.o: ${BASHINCDIR}/chartypes.h
! builtins/pushd.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h xmalloc.h ${BASHINCDIR}/maxpath.h
  builtins/pushd.o: quit.h dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
! builtins/pushd.o: shell.h syntax.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h variables.h arrayfunc.h conftypes.h
  builtins/pushd.o: $(DEFSRC)/common.h
! builtins/read.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h xmalloc.h ${BASHINCDIR}/maxpath.h
  builtins/read.o: quit.h dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
! builtins/read.o: shell.h syntax.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h variables.h arrayfunc.h conftypes.h 
! builtins/return.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h xmalloc.h ${BASHINCDIR}/maxpath.h
  builtins/return.o: quit.h dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
! builtins/return.o: shell.h syntax.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h variables.h arrayfunc.h conftypes.h 
! builtins/set.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h xmalloc.h ${BASHINCDIR}/maxpath.h
  builtins/set.o: quit.h dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
! builtins/set.o: shell.h syntax.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h variables.h arrayfunc.h conftypes.h flags.h
! builtins/setattr.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h xmalloc.h ${BASHINCDIR}/maxpath.h
  builtins/setattr.o: quit.h $(DEFSRC)/common.h $(DEFSRC)/bashgetopt.h
! builtins/setattr.o: shell.h syntax.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h variables.h arrayfunc.h conftypes.h 
  builtins/setattr.o: dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
! builtins/shift.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h xmalloc.h ${BASHINCDIR}/maxpath.h
  builtins/shift.o: quit.h dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
! builtins/shift.o: shell.h syntax.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h variables.h arrayfunc.h conftypes.h 
  builtins/shift.o: dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
! builtins/shopt.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h xmalloc.h
  builtins/shopt.o: quit.h dispose_cmd.h make_cmd.h subst.h externs.h
! builtins/shopt.o: shell.h syntax.h bashjmp.h ${BASHINCDIR}/posixjmp.h unwind_prot.h variables.h arrayfunc.h conftypes.h ${BASHINCDIR}/maxpath.h
  builtins/shopt.o: $(DEFSRC)/common.h $(DEFSRC)/bashgetopt.h
! builtins/source.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h xmalloc.h ${BASHINCDIR}/maxpath.h
  builtins/source.o: quit.h dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
! builtins/source.o: shell.h syntax.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h variables.h arrayfunc.h conftypes.h
  builtins/source.o: findcmd.h
! builtins/suspend.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h xmalloc.h ${BASHINCDIR}/maxpath.h
  builtins/suspend.o: quit.h dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
! builtins/suspend.o: shell.h syntax.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h variables.h arrayfunc.h conftypes.h 
! builtins/test.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h xmalloc.h ${BASHINCDIR}/maxpath.h
  builtins/test.o: quit.h dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
! builtins/test.o: shell.h syntax.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h variables.h arrayfunc.h conftypes.h 
  builtins/test.o: test.h
! builtins/times.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h xmalloc.h ${BASHINCDIR}/maxpath.h
  builtins/times.o: quit.h dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
! builtins/times.o: shell.h syntax.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h variables.h arrayfunc.h conftypes.h 
! builtins/trap.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h xmalloc.h ${BASHINCDIR}/maxpath.h
  builtins/trap.o: quit.h $(DEFSRC)/common.h
! builtins/trap.o: shell.h syntax.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h variables.h arrayfunc.h conftypes.h 
  builtins/trap.o: dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
! builtins/type.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h xmalloc.h ${BASHINCDIR}/maxpath.h
  builtins/type.o: quit.h $(DEFSRC)/common.h findcmd.h
! builtins/type.o: shell.h syntax.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h variables.h arrayfunc.h conftypes.h
  builtins/type.o: dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
! builtins/ulimit.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h xmalloc.h ${BASHINCDIR}/maxpath.h
  builtins/ulimit.o: quit.h dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
! builtins/ulimit.o: shell.h syntax.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h variables.h arrayfunc.h conftypes.h 
! builtins/umask.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h xmalloc.h ${BASHINCDIR}/maxpath.h
  builtins/umask.o: quit.h dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
! builtins/umask.o: shell.h syntax.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h variables.h arrayfunc.h conftypes.h 
! builtins/umask.o: ${BASHINCDIR}/chartypes.h
! builtins/wait.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h xmalloc.h ${BASHINCDIR}/maxpath.h
  builtins/wait.o: quit.h dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
! builtins/wait.o: shell.h syntax.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h variables.h arrayfunc.h conftypes.h
! builtins/wait.o: ${BASHINCDIR}/chartypes.h
  
  builtins/complete.o: config.h shell.h syntax.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h
! builtins/complete.o: unwind_prot.h variables.h arrayfunc.h conftypes.h
  builtins/complete.o: bashtypes.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h
  builtins/complete.o: builtins.h
diff -Nrc2 bash-2.05/NEWS bash-2.05a/NEWS
*** bash-2.05/NEWS	Wed Apr  4 10:44:08 2001
--- bash-2.05a/NEWS	Tue Oct 30 16:02:14 2001
***************
*** 1,2 ****
--- 1,95 ----
+ This is a terse description of the new features added to bash-2.05a since
+ the release of bash-2.05.  As always, the manual page (doc/bash.1) is
+ the place to look for complete descriptions.
+ 
+ 1.  New Features in Bash
+ 
+ a.  Added support for DESTDIR installation root prefix, so you can do a
+     `make install DESTDIR=bash-root' and do easier binary packaging.
+ 
+ b.  Added support for builtin printf "'" flag character as per latest POSIX
+     drafts.
+ 
+ c.  Support for POSIX.2 printf(1) length specifiers `j', `t', and `z' (from
+     ISO C99).
+ 
+ d.  New autoconf macro, RL_LIB_READLINE_VERSION, for use by other applications
+     (bash doesn't use very much of what it returns).
+ 
+ e.  `set [-+]o nolog' is recognized as required by the latest POSIX drafts,
+     but ignored.
+ 
+ f.  New read-only `shopt' option:  login_shell.  Set to non-zero value if the
+     shell is a login shell.
+ 
+ g.  New `\A' prompt string escape sequence; expands to time in 24 HH:MM format.
+ 
+ h.  New `-A group/-g' option to complete and compgen; does group name
+     completion.
+ 
+ i.  New `-t' option to `hash' to list hash values for each filename argument.
+ 
+ j.  New [-+]O invocation option to set and unset `shopt' options at startup.
+ 
+ k.  configure's `--with-installed-readline' option now takes an optional
+     `=PATH' suffix to set the root of the tree where readline is installed
+     to PATH.
+ 
+ l.  The ksh-like `ERR' trap has been added.  The `ERR' trap will be run
+     whenever the shell would have exited if the -e option were enabled.
+     It is not inherited by shell functions.
+ 
+ m.  `readonly', `export', and `declare' now print variables which have been
+     given attributes but not set by assigning a value as just a command and
+     a variable name (like `export foo') when listing, as the latest POSIX
+     drafts require.
+ 
+ n.  `bashbug' now requires that the subject be changed from the default.
+ 
+ o.  configure has a new `--enable-largefile' option, like other GNU utilities.
+ 
+ p.  `for' loops now allow empty word lists after `in', like the latest POSIX
+     drafts require.
+ 
+ q.  The builtin `ulimit' now takes two new non-numeric arguments:  `hard',
+     meaning the current hard limit, and `soft', meaning the current soft  
+     limit, in addition to `unlimited'
+     
+ r.  `ulimit' now prints the option letter associated with a particular
+     resource when printing more than one limit.
+ 
+ s.  `ulimit' prints `hard' or `soft' when a value is not `unlimited' but is
+     one of RLIM_SAVED_MAX or RLIM_SAVED_CUR, respectively.
+ 
+ t.  The `printf' builtin now handles the %a and %A conversions if they're
+     implemented by printf(3).
+ 
+ u.  The `printf' builtin now handles the %F conversion (just about like %f).
+ 
+ v.  The `printf' builtin now handles the %n conversion like printf(3).  The
+     corresponding argument is the name of a shell variable to which the
+     value is assigned.
+ 
+ 2.  New Features in Readline
+ 
+ a.  Added extern declaration for rl_get_termcap to readline.h, making it a
+     public function (it was always there, just not in readline.h).
+ 
+ b.  New #defines in readline.h:  RL_READLINE_VERSION, currently 0x0402,
+     RL_VERSION_MAJOR, currently 4, and RL_VERSION_MINOR, currently 2.
+ 
+ c.  New readline variable:  rl_readline_version, mirrors RL_READLINE_VERSION.
+ 
+ d.  New bindable boolean readline variable:  match-hidden-files.  Controls
+     completion of files beginning with a `.' (on Unix).  Enabled by default.
+ 
+ e.  The history expansion code now allows any character to terminate a
+     `:first-' modifier, like csh.
+ 
+ f.  New bindable variable `history-preserve-point'.  If set, the history
+     code attempts to place the user at the same location on each history
+     line retrived with previous-history or next-history.
+ 
+ -------------------------------------------------------------------------------
  This is a terse description of the new features added to bash-2.05 since
  the release of bash-2.04.  As always, the manual page (doc/bash.1) is
***************
*** 88,92 ****
  
  f.  There are several new arithmetic operators:  id++, id-- (variable
!     post-increment/decrement), ++id, --id (variabl pre-increment/decrement),
      expr1 , expr2 (comma operator).
  
--- 181,185 ----
  
  f.  There are several new arithmetic operators:  id++, id-- (variable
!     post-increment/decrement), ++id, --id (variable pre-increment/decrement),
      expr1 , expr2 (comma operator).
  
diff -Nrc2 bash-2.05/NOTES bash-2.05a/NOTES
*** bash-2.05/NOTES	Wed Apr  4 11:07:16 2001
--- bash-2.05a/NOTES	Tue Nov 13 10:32:22 2001
***************
*** 211,215 ****
      `cr: not found' when library construction is attempted.
  
! 11. Building a statically-linked bash on Solaris 2.5.x, 2.6, or 7 is
      complicated.
  
--- 211,215 ----
      `cr: not found' when library construction is attempted.
  
! 11. Building a statically-linked bash on Solaris 2.5.x, 2.6, 7, or 8 is
      complicated.
  
***************
*** 253,261 ****
  	        libdl.so.1 =>    /etc/lib/libdl.so.1
  
!     On Solaris 7 (and presumably Solaris 8, though I do not run that), the
!     following recipe appears to work for gcc:
  
  	configure --enable-static-link
! 	make STATIC_LD='-Wl,-Bstatic' LOCAL_LIBS='Wl,-Bdynamic -Wl,-R/etc/lib -ldl -Wl,-Bstatic'
  
  	thor.ins.cwru.edu(2)$ ldd bash
--- 253,261 ----
  	        libdl.so.1 =>    /etc/lib/libdl.so.1
  
!     On Solaris 7 (Solaris 8, using the version of gcc on the free software
!     CD-ROM), the following recipe appears to work for gcc:
  
  	configure --enable-static-link
! 	make STATIC_LD='-Wl,-Bstatic' LOCAL_LIBS='-Wl,-Bdynamic -Wl,-R/etc/lib -ldl -Wl,-Bstatic'
  
  	thor.ins.cwru.edu(2)$ ldd bash
***************
*** 264,267 ****
--- 264,270 ----
      Make the analogous changes if you are running Sun's C Compiler.
  
+     I have received word that adding -L/etc/lib (or the equivalent
+     -Wl,-L/etc/lib) might also be necessary, in addition to the -R/etc/lib.
+ 
  12. Configuring bash to build it in a cross environment.  Currently only
      two native versions can be compiled this way, cygwin32 and x86 BeOS.
***************
*** 310,312 ****
--- 313,328 ----
      Users may put the above command into their own profiles as well, of course.
  
+ 14. Building on Interix (nee OpenNT), which Microsoft bought from Softway
+     Systems and has seemingly abandoned (thanks to Kevin Moore for this item).
+ 
+ 	1.  cp cross-build/opennt.cache config.cache
+ 
+ 	2.  If desired, edit pathnames.h to set the values of SYS_PROFILE and
+ 	    DEFAULT_HOSTS_FILE appropriately.
+ 
+ 	3.  export CONFIG_SHELL=$INTERIX_ROOT/bin/sh
+ 
+ 	4.  ./configure --prefix=$INTERIX_ROOT/usr/local (or wherever you
+ 	    want it).
  
+ 	5. make; make install; enjoy
diff -Nrc2 bash-2.05/README bash-2.05a/README
*** bash-2.05/README	Mon Mar 26 11:25:33 2001
--- bash-2.05a/README	Wed Aug 22 13:27:17 2001
***************
*** 2,6 ****
  ============
  
! This is GNU Bash, version 2.05.  Bash is the GNU Project's Bourne
  Again SHell, a complete implementation of the POSIX.2 shell spec,
  but also with interactive command line editing, job control on
--- 2,6 ----
  ============
  
! This is GNU Bash, version 2.05a.  Bash is the GNU Project's Bourne
  Again SHell, a complete implementation of the POSIX.2 shell spec,
  but also with interactive command line editing, job control on
***************
*** 20,25 ****
  features that are new in this release. 
  
! Bash is free software, distributed under the terms of the GNU Public
! License, version 2.  For more information, see the file COPYING.
  
  A number of frequently-asked questions are answered in the file
--- 20,26 ----
  features that are new in this release. 
  
! Bash is free software, distributed under the terms of the [GNU]
! General Public License, version 2.  For more information, see the
! file COPYING.
  
  A number of frequently-asked questions are answered in the file
diff -Nrc2 bash-2.05/aclocal.m4 bash-2.05a/aclocal.m4
*** bash-2.05/aclocal.m4	Tue Nov 21 10:42:10 2000
--- bash-2.05a/aclocal.m4	Wed Nov  7 10:59:37 2001
***************
*** 4,143 ****
  dnl Some derived from PDKSH 5.1.3 autoconf tests
  dnl
! dnl
! dnl Check if dup2() does not clear the close on exec flag
! dnl
! AC_DEFUN(BASH_DUP2_CLOEXEC_CHECK,
! [AC_MSG_CHECKING(if dup2 fails to clear the close-on-exec flag)
! AC_CACHE_VAL(bash_cv_dup2_broken,
! [AC_TRY_RUN([
! #include <sys/types.h>
! #include <fcntl.h>
  main()
  {
!   int fd1, fd2, fl;
!   fd1 = open("/dev/null", 2);
!   if (fcntl(fd1, 2, 1) < 0)
!     exit(1);
!   fd2 = dup2(fd1, 1);
!   if (fd2 < 0)
!     exit(2);
!   fl = fcntl(fd2, 1, 0);
!   /* fl will be 1 if dup2 did not reset the close-on-exec flag. */
!   exit(fl != 1);
  }
! ], bash_cv_dup2_broken=yes, bash_cv_dup2_broken=no,
!     [AC_MSG_WARN(cannot check dup2 if cross compiling -- defaulting to no)
!      bash_cv_dup2_broken=no])
! ])
! AC_MSG_RESULT($bash_cv_dup2_broken)
! if test $bash_cv_dup2_broken = yes; then
! AC_DEFINE(DUP2_BROKEN)
! fi
! ])
! 
! dnl Check type of signal routines (posix, 4.2bsd, 4.1bsd or v7)
! AC_DEFUN(BASH_SIGNAL_CHECK,
! [AC_REQUIRE([AC_TYPE_SIGNAL])
! AC_MSG_CHECKING(for type of signal functions)
! AC_CACHE_VAL(bash_cv_signal_vintage,
! [
!   AC_TRY_LINK([#include <signal.h>],[
!     sigset_t ss;
!     struct sigaction sa;
!     sigemptyset(&ss); sigsuspend(&ss);
!     sigaction(SIGINT, &sa, (struct sigaction *) 0);
!     sigprocmask(SIG_BLOCK, &ss, (sigset_t *) 0);
!   ], bash_cv_signal_vintage=posix,
!   [
!     AC_TRY_LINK([#include <signal.h>], [
! 	int mask = sigmask(SIGINT);
! 	sigsetmask(mask); sigblock(mask); sigpause(mask);
!     ], bash_cv_signal_vintage=4.2bsd,
!     [
!       AC_TRY_LINK([
! 	#include <signal.h>
! 	RETSIGTYPE foo() { }], [
! 		int mask = sigmask(SIGINT);
! 		sigset(SIGINT, foo); sigrelse(SIGINT);
! 		sighold(SIGINT); sigpause(SIGINT);
!         ], bash_cv_signal_vintage=svr3, bash_cv_signal_vintage=v7
!     )]
!   )]
! )
! ])
! AC_MSG_RESULT($bash_cv_signal_vintage)
! if test "$bash_cv_signal_vintage" = posix; then
! AC_DEFINE(HAVE_POSIX_SIGNALS)
! elif test "$bash_cv_signal_vintage" = "4.2bsd"; then
! AC_DEFINE(HAVE_BSD_SIGNALS)
! elif test "$bash_cv_signal_vintage" = svr3; then
! AC_DEFINE(HAVE_USG_SIGHOLD)
  fi
  ])
  
! dnl Check if the pgrp of setpgrp() can't be the pid of a zombie process.
! AC_DEFUN(BASH_PGRP_SYNC,
! [AC_REQUIRE([AC_FUNC_GETPGRP])
! AC_MSG_CHECKING(whether pgrps need synchronization)
! AC_CACHE_VAL(bash_cv_pgrp_pipe,
! [AC_TRY_RUN([
! #ifdef HAVE_UNISTD_H
! #  include <unistd.h>
! #endif
  main()
  {
! # ifdef GETPGRP_VOID
! #  define getpgID()	getpgrp()
! # else
! #  define getpgID()	getpgrp(0)
! #  define setpgid(x,y)	setpgrp(x,y)
! # endif
! 	int pid1, pid2, fds[2];
! 	int status;
! 	char ok;
! 
! 	switch (pid1 = fork()) {
! 	  case -1:
! 	    exit(1);
! 	  case 0:
! 	    setpgid(0, getpid());
! 	    exit(0);
! 	}
! 	setpgid(pid1, pid1);
! 
! 	sleep(2);	/* let first child die */
! 
! 	if (pipe(fds) < 0)
! 	  exit(2);
! 
! 	switch (pid2 = fork()) {
! 	  case -1:
! 	    exit(3);
! 	  case 0:
! 	    setpgid(0, pid1);
! 	    ok = getpgID() == pid1;
! 	    write(fds[1], &ok, 1);
! 	    exit(0);
! 	}
! 	setpgid(pid2, pid1);
! 
! 	close(fds[1]);
! 	if (read(fds[0], &ok, 1) != 1)
! 	  exit(4);
! 	wait(&status);
! 	wait(&status);
! 	exit(ok ? 0 : 5);
  }
! ], bash_cv_pgrp_pipe=no,bash_cv_pgrp_pipe=yes,
!    [AC_MSG_WARN(cannot check pgrp synchronization if cross compiling -- defaulting to no)
!     bash_cv_pgrp_pipe=no])
! ])
! AC_MSG_RESULT($bash_cv_pgrp_pipe)
! if test $bash_cv_pgrp_pipe = yes; then
! AC_DEFINE(PGRP_PIPE)
  fi
  ])
  
  dnl
  dnl check for typedef'd symbols in header files, but allow the caller to
  dnl specify the include files to be checked in addition to the default
--- 4,66 ----
  dnl Some derived from PDKSH 5.1.3 autoconf tests
  dnl
! 
! AC_DEFUN(BASH_C_LONG_LONG,
! [AC_CACHE_CHECK(for long long, ac_cv_c_long_long,
! [if test "$GCC" = yes; then
!   ac_cv_c_long_long=yes
! else
! AC_TRY_RUN([
! int
  main()
  {
! long long foo = 0;
! exit(sizeof(long long) < sizeof(long));
  }
! ], ac_cv_c_long_long=yes, ac_cv_c_long_long=no)
! fi])
! if test $ac_cv_c_long_long = yes; then
!   AC_DEFINE(HAVE_LONG_LONG, 1, [Define if the `long long' type works.])
  fi
  ])
  
! dnl
! dnl This is very similar to AC_C_LONG_DOUBLE, with the fix for IRIX
! dnl (< changed to <=) added.
! dnl
! AC_DEFUN(BASH_C_LONG_DOUBLE,
! [AC_CACHE_CHECK(for long double, ac_cv_c_long_double,
! [if test "$GCC" = yes; then
!   ac_cv_c_long_double=yes
! else
! AC_TRY_RUN([
! int
  main()
  {
!   /* The Stardent Vistra knows sizeof(long double), but does not
!      support it. */
!   long double foo = 0.0;
!   /* On Ultrix 4.3 cc, long double is 4 and double is 8.  */
!   /* On IRIX 5.3, the compiler converts long double to double with a warning,
!      but compiles this successfully. */
!   exit(sizeof(long double) <= sizeof(double));
  }
! ], ac_cv_c_long_double=yes, ac_cv_c_long_double=no)
! fi])
! if test $ac_cv_c_long_double = yes; then
!   AC_DEFINE(HAVE_LONG_DOUBLE, 1, [Define if the `long double' type works.])
  fi
  ])
  
  dnl
+ dnl Check for <inttypes.h>.  This is separated out so that it can be
+ dnl AC_REQUIREd.
+ dnl
+ dnl BASH_HEADER_INTTYPES
+ AC_DEFUN(BASH_HEADER_INTTYPES,
+ [
+  AC_CHECK_HEADERS(inttypes.h)
+ ])
+ 
+ dnl
  dnl check for typedef'd symbols in header files, but allow the caller to
  dnl specify the include files to be checked in addition to the default
***************
*** 145,149 ****
  dnl BASH_CHECK_TYPE(TYPE, HEADERS, DEFAULT[, VALUE-IF-FOUND])
  AC_DEFUN(BASH_CHECK_TYPE,
! [AC_REQUIRE([AC_HEADER_STDC])dnl
  AC_MSG_CHECKING(for $1)
  AC_CACHE_VAL(bash_cv_type_$1,
--- 68,74 ----
  dnl BASH_CHECK_TYPE(TYPE, HEADERS, DEFAULT[, VALUE-IF-FOUND])
  AC_DEFUN(BASH_CHECK_TYPE,
! [
! AC_REQUIRE([AC_HEADER_STDC])dnl
! AC_REQUIRE([BASH_HEADER_INTTYPES])
  AC_MSG_CHECKING(for $1)
  AC_CACHE_VAL(bash_cv_type_$1,
***************
*** 151,154 ****
--- 76,83 ----
  #if STDC_HEADERS
  #include <stdlib.h>
+ #include <stddef.h>
+ #endif
+ #if HAVE_INTTYPES_H
+ #include <inttypes.h>
  #endif
  $2
***************
*** 159,199 ****
  	fi])
  if test $bash_cv_type_$1 = no; then
!   AC_DEFINE($1, $3)
  fi
  ])
  
  dnl
! dnl Type of struct rlimit fields: some systems (OSF/1, NetBSD, RISC/os 5.0)
! dnl have a rlim_t, others (4.4BSD based systems) use quad_t, others use
! dnl long and still others use int (HP-UX 9.01, SunOS 4.1.3).  To simplify
! dnl matters, this just checks for rlim_t, quad_t, or long.
  dnl
! AC_DEFUN(BASH_RLIMIT_TYPE,
! [AC_MSG_CHECKING(for size and type of struct rlimit fields)
! AC_CACHE_VAL(bash_cv_type_rlimit,
! [AC_TRY_COMPILE([#include <sys/types.h>
! #include <sys/resource.h>],
! [rlim_t xxx;], bash_cv_type_rlimit=rlim_t,[
! AC_TRY_RUN([
! #include <sys/types.h>
! #include <sys/time.h>
! #include <sys/resource.h>
  main()
  {
! #ifdef HAVE_QUAD_T
!   struct rlimit rl;
!   if (sizeof(rl.rlim_cur) == sizeof(quad_t))
!     exit(0);
! #endif
!   exit(1);
! }], bash_cv_type_rlimit=quad_t, bash_cv_type_rlimit=long,
!         [AC_MSG_WARN(cannot check quad_t if cross compiling -- defaulting to long)
!          bash_cv_type_rlimit=long])])
  ])
! AC_MSG_RESULT($bash_cv_type_rlimit)
! if test $bash_cv_type_rlimit = quad_t; then
! AC_DEFINE(RLIMTYPE, quad_t)
! elif test $bash_cv_type_rlimit = rlim_t; then
! AC_DEFINE(RLIMTYPE, rlim_t)
  fi
  ])
--- 88,159 ----
  	fi])
  if test $bash_cv_type_$1 = no; then
!   AC_DEFINE_UNQUOTED($1, $3)
  fi
  ])
  
  dnl
! dnl BASH_CHECK_DECL(FUNC)
  dnl
! dnl Check for a declaration of FUNC in stdlib.h and inttypes.h like
! dnl AC_CHECK_DECL
! dnl
! AC_DEFUN(BASH_CHECK_DECL,
! [
! AC_REQUIRE([AC_HEADER_STDC])
! AC_REQUIRE([BASH_HEADER_INTTYPES])
! AC_CACHE_CHECK([for declaration of $1], bash_cv_decl_$1,
! [AC_TRY_LINK(
! [
! #if STDC_HEADERS
! #  include <stdlib.h>
! #endif
! #if HAVE_INTTYPES_H
! #  include <inttypes.h>
! #endif
! ],
! [return !$1;],
! bash_cv_decl_$1=yes, bash_cv_decl_$1=no)])
! bash_tr_func=HAVE_DECL_`echo $1 | tr 'abcdefghijklmnopqrstuvwxyz' 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'`
! if test $bash_cv_decl_$1 = yes; then
!   AC_DEFINE_UNQUOTED($bash_tr_func, 1)
! else
!   AC_DEFINE_UNQUOTED($bash_tr_func, 0)
! fi
! ])
! 
! AC_DEFUN(BASH_DECL_PRINTF,
! [AC_MSG_CHECKING(for declaration of printf in <stdio.h>)
! AC_CACHE_VAL(bash_cv_printf_declared,
! [AC_TRY_RUN([
! #include <stdio.h>
! #ifdef __STDC__
! typedef int (*_bashfunc)(const char *, ...);
! #else
! typedef int (*_bashfunc)();
! #endif
  main()
  {
! _bashfunc pf;
! pf = (_bashfunc) printf;
! exit(pf == 0);
! }
! ], bash_cv_printf_declared=yes, bash_cv_printf_declared=no,
!    [AC_MSG_WARN(cannot check printf declaration if cross compiling -- defaulting to yes)
!     bash_cv_printf_declared=yes]
! )])
! AC_MSG_RESULT($bash_cv_printf_declared)
! if test $bash_cv_printf_declared = yes; then
! AC_DEFINE(PRINTF_DECLARED)
! fi
  ])
! 
! AC_DEFUN(BASH_DECL_SBRK,
! [AC_MSG_CHECKING(for declaration of sbrk in <unistd.h>)
! AC_CACHE_VAL(bash_cv_sbrk_declared,
! [AC_EGREP_HEADER(sbrk, unistd.h,
!  bash_cv_sbrk_declared=yes, bash_cv_sbrk_declared=no)])
! AC_MSG_RESULT($bash_cv_sbrk_declared)
! if test $bash_cv_sbrk_declared = yes; then
! AC_DEFINE(SBRK_DECLARED)
  fi
  ])
***************
*** 273,276 ****
--- 233,250 ----
  ])
  
+ dnl Check for the various permutations of sys_siglist and make sure we
+ dnl compile in siglist.o if they're not defined
+ AC_DEFUN(BASH_CHECK_SYS_SIGLIST, [
+ AC_REQUIRE([BASH_SYS_SIGLIST])
+ AC_REQUIRE([BASH_DECL_UNDER_SYS_SIGLIST])
+ AC_REQUIRE([BASH_FUNC_STRSIGNAL])
+ if test "$bash_cv_sys_siglist" = no && test "$bash_cv_under_sys_siglist" = no && test "$bash_cv_have_strsignal" = no; then
+   SIGLIST_O=siglist.o
+ else
+   SIGLIST_O=
+ fi
+ AC_SUBST([SIGLIST_O])
+ ])
+ 
  dnl Check for sys_errlist[] and sys_nerr, check for declaration
  AC_DEFUN(BASH_SYS_ERRLIST,
***************
*** 288,291 ****
--- 262,310 ----
  ])
  
+ dnl
+ dnl Check if dup2() does not clear the close on exec flag
+ dnl
+ AC_DEFUN(BASH_FUNC_DUP2_CLOEXEC_CHECK,
+ [AC_MSG_CHECKING(if dup2 fails to clear the close-on-exec flag)
+ AC_CACHE_VAL(bash_cv_dup2_broken,
+ [AC_TRY_RUN([
+ #include <sys/types.h>
+ #include <fcntl.h>
+ main()
+ {
+   int fd1, fd2, fl;
+   fd1 = open("/dev/null", 2);
+   if (fcntl(fd1, 2, 1) < 0)
+     exit(1);
+   fd2 = dup2(fd1, 1);
+   if (fd2 < 0)
+     exit(2);
+   fl = fcntl(fd2, 1, 0);
+   /* fl will be 1 if dup2 did not reset the close-on-exec flag. */
+   exit(fl != 1);
+ }
+ ], bash_cv_dup2_broken=yes, bash_cv_dup2_broken=no,
+     [AC_MSG_WARN(cannot check dup2 if cross compiling -- defaulting to no)
+      bash_cv_dup2_broken=no])
+ ])
+ AC_MSG_RESULT($bash_cv_dup2_broken)
+ if test $bash_cv_dup2_broken = yes; then
+ AC_DEFINE(DUP2_BROKEN)
+ fi
+ ])
+ 
+ AC_DEFUN(BASH_FUNC_STRSIGNAL,
+ [AC_MSG_CHECKING([for the existence of strsignal])
+ AC_CACHE_VAL(bash_cv_have_strsignal,
+ [AC_TRY_LINK([#include <sys/types.h>
+ #include <signal.h>],
+ [char *s = (char *)strsignal(2);],
+  bash_cv_have_strsignal=yes, bash_cv_have_strsignal=no)])
+ AC_MSG_RESULT($bash_cv_have_strsignal)
+ if test $bash_cv_have_strsignal = yes; then
+ AC_DEFINE(HAVE_STRSIGNAL)
+ fi
+ ])
+ 
  dnl Check to see if opendir will open non-directories (not a nice thing)
  AC_DEFUN(BASH_FUNC_OPENDIR_CHECK,
***************
*** 423,426 ****
--- 442,447 ----
  elif test "$ac_cv_sizeof_long" = "$ac_cv_sizeof_char_p"; then
    AC_CHECK_TYPE(ptrdiff_t, long)
+ elif test "$ac_cv_type_long_long" = yes && test "$ac_cv_sizeof_long_long" = "$ac_cv_sizeof_char_p"; then
+   AC_CHECK_TYPE(ptrdiff_t, [long long])
  else
    AC_CHECK_TYPE(ptrdiff_t, int)
***************
*** 433,440 ****
  AC_DEFUN(BASH_TYPE_BITS64_T,
  [
! if test "$ac_sv_sizeof_char_p" = 8; then
    AC_CHECK_TYPE(bits64_t, char *)
  elif test "$ac_cv_sizeof_double" = 8; then
    AC_CHECK_TYPE(bits64_t, double)
  elif test "$ac_cv_sizeof_long" = 8; then
    AC_CHECK_TYPE(bits64_t, long)
--- 454,463 ----
  AC_DEFUN(BASH_TYPE_BITS64_T,
  [
! if test "$ac_cv_sizeof_char_p" = 8; then
    AC_CHECK_TYPE(bits64_t, char *)
  elif test "$ac_cv_sizeof_double" = 8; then
    AC_CHECK_TYPE(bits64_t, double)
+ elif test -n "$ac_cv_type_long_long" && test "$ac_cv_sizeof_long_long" = 8; then
+   AC_CHECK_TYPE(bits64_t, [long long])
  elif test "$ac_cv_sizeof_long" = 8; then
    AC_CHECK_TYPE(bits64_t, long)
***************
*** 444,457 ****
  ])
  
! AC_DEFUN(BASH_FUNC_STRSIGNAL,
! [AC_MSG_CHECKING([for the existence of strsignal])
! AC_CACHE_VAL(bash_cv_have_strsignal,
! [AC_TRY_LINK([#include <sys/types.h>
! #include <signal.h>],
! [char *s = (char *)strsignal(2);],
!  bash_cv_have_strsignal=yes, bash_cv_have_strsignal=no)])
! AC_MSG_RESULT($bash_cv_have_strsignal)
! if test $bash_cv_have_strsignal = yes; then
! AC_DEFINE(HAVE_STRSIGNAL)
  fi
  ])
--- 467,532 ----
  ])
  
! AC_DEFUN(BASH_TYPE_LONG_LONG,
! [
! AC_CACHE_CHECK([for long long], bash_cv_type_long_long,
! [AC_TRY_LINK([
! long long ll = 1; int i = 63;],
! [
! long long llm = (long long) -1;
! return ll << i | ll >> i | llm / ll | llm % ll;
! ], bash_cv_type_long_long='long long', bash_cv_type_long_long='long')])
! if test "$bash_cv_type_long_long" = 'long long'; then
!   AC_DEFINE(HAVE_LONG_LONG, 1)
! fi
! ])
! 
! AC_DEFUN(BASH_TYPE_UNSIGNED_LONG_LONG,
! [
! AC_CACHE_CHECK([for unsigned long long], bash_cv_type_unsigned_long_long,
! [AC_TRY_LINK([
! unsigned long long ull = 1; int i = 63;],
! [
! unsigned long long ullmax = (unsigned long long) -1;
! return ull << i | ull >> i | ullmax / ull | ullmax % ull;
! ], bash_cv_type_unsigned_long_long='unsigned long long',
!    bash_cv_type_unsigned_long_long='unsigned long')])
! if test "$bash_cv_type_unsigned_long_long" = 'unsigned long long'; then
!   AC_DEFINE(HAVE_UNSIGNED_LONG_LONG, 1)
! fi
! ])
! 
! dnl
! dnl Type of struct rlimit fields: some systems (OSF/1, NetBSD, RISC/os 5.0)
! dnl have a rlim_t, others (4.4BSD based systems) use quad_t, others use
! dnl long and still others use int (HP-UX 9.01, SunOS 4.1.3).  To simplify
! dnl matters, this just checks for rlim_t, quad_t, or long.
! dnl
! AC_DEFUN(BASH_TYPE_RLIMIT,
! [AC_MSG_CHECKING(for size and type of struct rlimit fields)
! AC_CACHE_VAL(bash_cv_type_rlimit,
! [AC_TRY_COMPILE([#include <sys/types.h>
! #include <sys/resource.h>],
! [rlim_t xxx;], bash_cv_type_rlimit=rlim_t,[
! AC_TRY_RUN([
! #include <sys/types.h>
! #include <sys/time.h>
! #include <sys/resource.h>
! main()
! {
! #ifdef HAVE_QUAD_T
!   struct rlimit rl;
!   if (sizeof(rl.rlim_cur) == sizeof(quad_t))
!     exit(0);
! #endif
!   exit(1);
! }], bash_cv_type_rlimit=quad_t, bash_cv_type_rlimit=long,
!         [AC_MSG_WARN(cannot check quad_t if cross compiling -- defaulting to long)
!          bash_cv_type_rlimit=long])])
! ])
! AC_MSG_RESULT($bash_cv_type_rlimit)
! if test $bash_cv_type_rlimit = quad_t; then
! AC_DEFINE(RLIMTYPE, quad_t)
! elif test $bash_cv_type_rlimit = rlim_t; then
! AC_DEFINE(RLIMTYPE, rlim_t)
  fi
  ])
***************
*** 482,509 ****
  if test $bash_cv_func_inet_aton = yes; then
    AC_DEFINE(HAVE_INET_ATON)
! fi
! ])
! 
! AC_DEFUN(BASH_STRUCT_TERMIOS_LDISC,
! [AC_MSG_CHECKING([for a c_line member of struct termios])
! AC_CACHE_VAL(bash_cv_termios_ldisc,
! [AC_TRY_COMPILE([#include <sys/types.h>
! #include <termios.h>],[struct termios t; int i; i = t.c_line;],
!   bash_cv_termios_ldisc=yes, bash_cv_termios_ldisc=no)])dnl
! AC_MSG_RESULT($bash_cv_termios_ldisc)
! if test $bash_cv_termios_ldisc = yes; then
! AC_DEFINE(TERMIOS_LDISC)
! fi
! ])
! 
! AC_DEFUN(BASH_STRUCT_TERMIO_LDISC,
! [AC_MSG_CHECKING([for a c_line member of struct termio])
! AC_CACHE_VAL(bash_cv_termio_ldisc,
! [AC_TRY_COMPILE([#include <sys/types.h>
! #include <termio.h>],[struct termio t; int i; i = t.c_line;],
!   bash_cv_termio_ldisc=yes, bash_cv_termio_ldisc=no)])dnl
! AC_MSG_RESULT($bash_cv_termio_ldisc)
! if test $bash_cv_termio_ldisc = yes; then
! AC_DEFINE(TERMIO_LDISC)
  fi
  ])
--- 557,562 ----
  if test $bash_cv_func_inet_aton = yes; then
    AC_DEFINE(HAVE_INET_ATON)
! else
!   AC_LIBOBJ(inet_aton)
  fi
  ])
***************
*** 553,582 ****
  ])
  
- AC_DEFUN(BASH_FUNC_PRINTF,
- [AC_MSG_CHECKING(for declaration of printf in <stdio.h>)
- AC_CACHE_VAL(bash_cv_printf_declared,
- [AC_TRY_RUN([
- #include <stdio.h>
- #ifdef __STDC__
- typedef int (*_bashfunc)(const char *, ...);
- #else
- typedef int (*_bashfunc)();
- #endif
- main()
- {
- _bashfunc pf;
- pf = (_bashfunc) printf;
- exit(pf == 0);
- }
- ], bash_cv_printf_declared=yes, bash_cv_printf_declared=no,
-    [AC_MSG_WARN(cannot check printf declaration if cross compiling -- defaulting to yes)
-     bash_cv_printf_declared=yes]
- )])
- AC_MSG_RESULT($bash_cv_printf_declared)
- if test $bash_cv_printf_declared = yes; then
- AC_DEFINE(PRINTF_DECLARED)
- fi
- ])
- 
  AC_DEFUN(BASH_FUNC_ULIMIT_MAXFDS,
  [AC_MSG_CHECKING(whether ulimit can substitute for getdtablesize)
--- 606,609 ----
***************
*** 598,634 ****
  ])
  
- AC_DEFUN(BASH_CHECK_LIB_TERMCAP,
- [
- if test "X$bash_cv_termcap_lib" = "X"; then
- _bash_needmsg=yes
- else
- AC_MSG_CHECKING(which library has the termcap functions)
- _bash_needmsg=
- fi
- AC_CACHE_VAL(bash_cv_termcap_lib,
- [AC_CHECK_LIB(termcap, tgetent, bash_cv_termcap_lib=libtermcap,
-     [AC_CHECK_LIB(curses, tgetent, bash_cv_termcap_lib=libcurses,
- 	[AC_CHECK_LIB(ncurses, tgetent, bash_cv_termcap_lib=libncurses,
- 	    bash_cv_termcap_lib=gnutermcap)])])])
- if test "X$_bash_needmsg" = "Xyes"; then
- AC_MSG_CHECKING(which library has the termcap functions)
- fi
- AC_MSG_RESULT(using $bash_cv_termcap_lib)
- if test $bash_cv_termcap_lib = gnutermcap && test -z "$prefer_curses"; then
- LDFLAGS="$LDFLAGS -L./lib/termcap"
- TERMCAP_LIB="./lib/termcap/libtermcap.a"
- TERMCAP_DEP="./lib/termcap/libtermcap.a"
- elif test $bash_cv_termcap_lib = libtermcap && test -z "$prefer_curses"; then
- TERMCAP_LIB=-ltermcap
- TERMCAP_DEP=
- elif test $bash_cv_termcap_lib = libncurses; then
- TERMCAP_LIB=-lncurses
- TERMCAP_DEP=
- else
- TERMCAP_LIB=-lcurses
- TERMCAP_DEP=
- fi
- ])
- 
  AC_DEFUN(BASH_FUNC_GETCWD,
  [AC_MSG_CHECKING([if getcwd() calls popen()])
--- 625,628 ----
***************
*** 692,695 ****
--- 686,1000 ----
  if test $bash_cv_getcwd_calls_popen = yes; then
  AC_DEFINE(GETCWD_BROKEN)
+ AC_LIBOBJ(getcwd)
+ fi
+ ])
+ 
+ dnl
+ dnl This needs BASH_CHECK_SOCKLIB, but since that's not called on every
+ dnl system, we can't use AC_PREREQ
+ dnl
+ AC_DEFUN(BASH_FUNC_GETHOSTBYNAME,
+ [if test "X$bash_cv_have_gethostbyname" = "X"; then
+ _bash_needmsg=yes
+ else
+ AC_MSG_CHECKING(for gethostbyname in socket library)
+ _bash_needmsg=
+ fi
+ AC_CACHE_VAL(bash_cv_have_gethostbyname,
+ [AC_TRY_LINK([#include <netdb.h>],
+ [ struct hostent *hp;
+   hp = gethostbyname("localhost");
+ ], bash_cv_have_gethostbyname=yes, bash_cv_have_gethostbyname=no)]
+ )
+ if test "X$_bash_needmsg" = Xyes; then
+     AC_MSG_CHECKING(for gethostbyname in socket library)
+ fi
+ AC_MSG_RESULT($bash_cv_have_gethostbyname)
+ if test "$bash_cv_have_gethostbyname" = yes; then
+ AC_DEFINE(HAVE_GETHOSTBYNAME)
+ fi
+ ])
+ 
+ AC_DEFUN(BASH_FUNC_FNMATCH_EXTMATCH,
+ [AC_MSG_CHECKING(if fnmatch does extended pattern matching with FNM_EXTMATCH)
+ AC_CACHE_VAL(bash_cv_fnm_extmatch,
+ [AC_TRY_RUN([
+ #include <fnmatch.h>
+ 
+ main()
+ {
+ #ifdef FNM_EXTMATCH
+   exit (0);
+ #else
+   exit (1);
+ #endif
+ }
+ ], bash_cv_fnm_extmatch=yes, bash_cv_fnm_extmatch=no,
+     [AC_MSG_WARN(cannot check FNM_EXTMATCH if cross compiling -- defaulting to no)
+      bash_cv_fnm_extmatch=no])
+ ])
+ AC_MSG_RESULT($bash_cv_fnm_extmatch)
+ if test $bash_cv_fnm_extmatch = yes; then
+ AC_DEFINE(HAVE_LIBC_FNM_EXTMATCH)
+ fi
+ ])
+ 
+ AC_DEFUN(BASH_FUNC_POSIX_SETJMP,
+ [AC_REQUIRE([BASH_SYS_SIGNAL_VINTAGE])
+ AC_MSG_CHECKING(for presence of POSIX-style sigsetjmp/siglongjmp)
+ AC_CACHE_VAL(bash_cv_func_sigsetjmp,
+ [AC_TRY_RUN([
+ #ifdef HAVE_UNISTD_H
+ #include <unistd.h>
+ #endif
+ #include <sys/types.h>
+ #include <signal.h>
+ #include <setjmp.h>
+ 
+ main()
+ {
+ #if !defined (_POSIX_VERSION) || !defined (HAVE_POSIX_SIGNALS)
+ exit (1);
+ #else
+ 
+ int code;
+ sigset_t set, oset;
+ sigjmp_buf xx;
+ 
+ /* get the mask */
+ sigemptyset(&set);
+ sigemptyset(&oset);
+ sigprocmask(SIG_BLOCK, (sigset_t *)NULL, &set);
+ sigprocmask(SIG_BLOCK, (sigset_t *)NULL, &oset);
+ 
+ /* save it */
+ code = sigsetjmp(xx, 1);
+ if (code)
+   exit(0);	/* could get sigmask and compare to oset here. */
+ 
+ /* change it */
+ sigaddset(&set, SIGINT);
+ sigprocmask(SIG_BLOCK, &set, (sigset_t *)NULL);
+ 
+ /* and siglongjmp */
+ siglongjmp(xx, 10);
+ exit(1);
+ #endif
+ }], bash_cv_func_sigsetjmp=present, bash_cv_func_sigsetjmp=missing,
+     [AC_MSG_WARN(cannot check for sigsetjmp/siglongjmp if cross-compiling -- defaulting to missing)
+      bash_cv_func_sigsetjmp=missing]
+ )])
+ AC_MSG_RESULT($bash_cv_func_sigsetjmp)
+ if test $bash_cv_func_sigsetjmp = present; then
+ AC_DEFINE(HAVE_POSIX_SIGSETJMP)
+ fi
+ ])
+ 
+ AC_DEFUN(BASH_FUNC_STRCOLL,
+ [
+ AC_MSG_CHECKING(whether or not strcoll and strcmp differ)
+ AC_CACHE_VAL(bash_cv_func_strcoll_broken,
+ [AC_TRY_RUN([
+ #include <stdio.h>
+ #if defined (HAVE_LOCALE_H)
+ #include <locale.h>
+ #endif
+ 
+ main(c, v)
+ int     c;
+ char    *v[];
+ {
+         int     r1, r2;
+         char    *deflocale, *defcoll;
+ 
+ #ifdef HAVE_SETLOCALE
+         deflocale = setlocale(LC_ALL, "");
+ 	defcoll = setlocale(LC_COLLATE, "");
+ #endif
+ 
+ #ifdef HAVE_STRCOLL
+ 	/* These two values are taken from tests/glob-test. */
+         r1 = strcoll("abd", "aXd");
+ #else
+ 	r1 = 0;
+ #endif
+         r2 = strcmp("abd", "aXd");
+ 
+ 	/* These two should both be greater than 0.  It is permissible for
+ 	   a system to return different values, as long as the sign is the
+ 	   same. */
+ 
+         /* Exit with 1 (failure) if these two values are both > 0, since
+ 	   this tests whether strcoll(3) is broken with respect to strcmp(3)
+ 	   in the default locale. */
+ 	exit (r1 > 0 && r2 > 0);
+ }
+ ], bash_cv_func_strcoll_broken=yes, bash_cv_func_strcoll_broken=no,
+    [AC_MSG_WARN(cannot check strcoll if cross compiling -- defaulting to no)
+     bash_cv_func_strcoll_broken=no]
+ )])
+ AC_MSG_RESULT($bash_cv_func_strcoll_broken)
+ if test $bash_cv_func_strcoll_broken = yes; then
+ AC_DEFINE(STRCOLL_BROKEN)
+ fi
+ ])
+ 
+ AC_DEFUN(BASH_FUNC_PRINTF_A_FORMAT,
+ [AC_MSG_CHECKING([for printf floating point output in hex notation])
+ AC_CACHE_VAL(bash_cv_printf_a_format,
+ [AC_TRY_RUN([
+ #include <stdio.h>
+ #include <string.h>
+ 
+ int
+ main()
+ {
+ 	double y = 0.0;
+ 	char abuf[1024];
+ 
+ 	sprintf(abuf, "%A", y);
+ 	exit(strchr(abuf, 'P') == (char *)0);
+ }
+ ], bash_cv_printf_a_format=yes, bash_cv_printf_a_format=no,
+    [AC_MSG_WARN(cannot check printf if cross compiling -- defaulting to no)
+     bash_cv_printf_a_format=no]
+ )])
+ AC_MSG_RESULT($bash_cv_printf_a_format)
+ if test $bash_cv_printf_a_format = yes; then
+ AC_DEFINE(HAVE_PRINTF_A_FORMAT)
+ fi
+ ])
+ 
+ AC_DEFUN(BASH_STRUCT_TERMIOS_LDISC,
+ [
+ AC_CHECK_MEMBER(struct termios.c_line, AC_DEFINE(TERMIOS_LDISC), ,[
+ #include <sys/types.h>
+ #include <termios.h>
+ ])
+ ])
+ 
+ AC_DEFUN(BASH_STRUCT_TERMIO_LDISC,
+ [
+ AC_CHECK_MEMBER(struct termio.c_line, AC_DEFINE(TERMIO_LDISC), ,[
+ #include <sys/types.h>
+ #include <termio.h>
+ ])
+ ])
+ 
+ dnl
+ dnl Like AC_STRUCT_ST_BLOCKS, but doesn't muck with LIBOBJS
+ dnl
+ dnl sets bash_cv_struct_stat_st_blocks
+ dnl
+ dnl unused for now; we'll see how AC_CHECK_MEMBERS works
+ dnl
+ AC_DEFUN(BASH_STRUCT_ST_BLOCKS,
+ [
+ AC_MSG_CHECKING([for struct stat.st_blocks])
+ AC_CACHE_VAL(bash_cv_struct_stat_st_blocks,
+ [AC_TRY_COMPILE(
+ [
+ #include <sys/types.h>
+ #include <sys/stat.h>
+ ],
+ [
+ main()
+ {
+ static struct stat a;
+ if (a.st_blocks) return 0;
+ return 0;
+ }
+ ], bash_cv_struct_stat_st_blocks=yes, bash_cv_struct_stat_st_blocks=no)
+ ])
+ AC_MSG_RESULT($bash_cv_struct_stat_st_blocks)
+ if test "$bash_cv_struct_stat_st_blocks" = "yes"; then
+ AC_DEFINE(HAVE_STRUCT_STAT_ST_BLOCKS)
+ fi
+ ])
+ 
+ AC_DEFUN(BASH_CHECK_LIB_TERMCAP,
+ [
+ if test "X$bash_cv_termcap_lib" = "X"; then
+ _bash_needmsg=yes
+ else
+ AC_MSG_CHECKING(which library has the termcap functions)
+ _bash_needmsg=
+ fi
+ AC_CACHE_VAL(bash_cv_termcap_lib,
+ [AC_CHECK_LIB(termcap, tgetent, bash_cv_termcap_lib=libtermcap,
+     [AC_CHECK_LIB(tinfo, tgetent, bash_cv_termcal_lib=libtinfo,
+         [AC_CHECK_LIB(curses, tgetent, bash_cv_termcap_lib=libcurses,
+ 	    [AC_CHECK_LIB(ncurses, tgetent, bash_cv_termcap_lib=libncurses,
+ 	        bash_cv_termcap_lib=gnutermcap)])])])])
+ if test "X$_bash_needmsg" = "Xyes"; then
+ AC_MSG_CHECKING(which library has the termcap functions)
+ fi
+ AC_MSG_RESULT(using $bash_cv_termcap_lib)
+ if test $bash_cv_termcap_lib = gnutermcap && test -z "$prefer_curses"; then
+ LDFLAGS="$LDFLAGS -L./lib/termcap"
+ TERMCAP_LIB="./lib/termcap/libtermcap.a"
+ TERMCAP_DEP="./lib/termcap/libtermcap.a"
+ elif test $bash_cv_termcap_lib = libtermcap && test -z "$prefer_curses"; then
+ TERMCAP_LIB=-ltermcap
+ TERMCAP_DEP=
+ elif test $bash_cv_termcap_lib = libtinfo; then
+ TERMCAP_LIB=-ltinfo
+ TERMCAP_DEP=
+ elif test $bash_cv_termcap_lib = libncurses; then
+ TERMCAP_LIB=-lncurses
+ TERMCAP_DEP=
+ else
+ TERMCAP_LIB=-lcurses
+ TERMCAP_DEP=
+ fi
+ ])
+ 
+ dnl
+ dnl Check for the presence of getpeername in libsocket.
+ dnl If libsocket is present, check for libnsl and add it to LIBS if
+ dnl it's there, since most systems with libsocket require linking
+ dnl with libnsl as well.  This should only be called if getpeername
+ dnl was not found in libc.
+ dnl
+ dnl NOTE: IF WE FIND GETPEERNAME, WE ASSUME THAT WE HAVE BIND/CONNECT
+ dnl	  AS WELL
+ dnl
+ AC_DEFUN(BASH_CHECK_LIB_SOCKET,
+ [
+ if test "X$bash_cv_have_socklib" = "X"; then
+ _bash_needmsg=
+ else
+ AC_MSG_CHECKING(for socket library)
+ _bash_needmsg=yes
+ fi
+ AC_CACHE_VAL(bash_cv_have_socklib,
+ [AC_CHECK_LIB(socket, getpeername,
+         bash_cv_have_socklib=yes, bash_cv_have_socklib=no, -lnsl)])
+ if test "X$_bash_needmsg" = Xyes; then
+   AC_MSG_RESULT($bash_cv_have_socklib)
+   _bash_needmsg=
+ fi
+ if test $bash_cv_have_socklib = yes; then
+   # check for libnsl, add it to LIBS if present
+   if test "X$bash_cv_have_libnsl" = "X"; then
+     _bash_needmsg=
+   else
+     AC_MSG_CHECKING(for libnsl)
+     _bash_needmsg=yes
+   fi
+   AC_CACHE_VAL(bash_cv_have_libnsl,
+ 	   [AC_CHECK_LIB(nsl, t_open,
+ 		 bash_cv_have_libnsl=yes, bash_cv_have_libnsl=no)])
+   if test "X$_bash_needmsg" = Xyes; then
+     AC_MSG_RESULT($bash_cv_have_libnsl)
+     _bash_needmsg=
+   fi
+   if test $bash_cv_have_libnsl = yes; then
+     LIBS="-lsocket -lnsl $LIBS"
+   else
+     LIBS="-lsocket $LIBS"
+   fi
+   AC_DEFINE(HAVE_LIBSOCKET)
+   AC_DEFINE(HAVE_GETPEERNAME)
  fi
  ])
***************
*** 761,767 ****
  ])
  
! AC_DEFUN(BASH_REINSTALL_SIGHANDLERS,
  [AC_REQUIRE([AC_TYPE_SIGNAL])
! AC_REQUIRE([BASH_SIGNAL_CHECK])
  AC_MSG_CHECKING([if signal handlers must be reinstalled when invoked])
  AC_CACHE_VAL(bash_cv_must_reinstall_sighandlers,
--- 1066,1212 ----
  ])
  
! AC_DEFUN(BASH_STRUCT_TIMEVAL,
! [AC_MSG_CHECKING(for struct timeval in sys/time.h and time.h)
! AC_CACHE_VAL(bash_cv_struct_timeval,
! [
! AC_EGREP_HEADER(struct timeval, sys/time.h,
! 		bash_cv_struct_timeval=yes,
! 		AC_EGREP_HEADER(struct timeval, time.h,
! 			bash_cv_struct_timeval=yes,
! 			bash_cv_struct_timeval=no))
! ])
! AC_MSG_RESULT($bash_cv_struct_timeval)
! if test $bash_cv_struct_timeval = yes; then
!   AC_DEFINE(HAVE_TIMEVAL)
! fi
! ])
! 
! AC_DEFUN(BASH_STRUCT_WINSIZE,
! [AC_MSG_CHECKING(for struct winsize in sys/ioctl.h and termios.h)
! AC_CACHE_VAL(bash_cv_struct_winsize_header,
! [AC_TRY_COMPILE([#include <sys/types.h>
! #include <sys/ioctl.h>], [struct winsize x;],
!   bash_cv_struct_winsize_header=ioctl_h,
!   [AC_TRY_COMPILE([#include <sys/types.h>
! #include <termios.h>], [struct winsize x;],
!   bash_cv_struct_winsize_header=termios_h, bash_cv_struct_winsize_header=other)
! ])])
! if test $bash_cv_struct_winsize_header = ioctl_h; then
!   AC_MSG_RESULT(sys/ioctl.h)
!   AC_DEFINE(STRUCT_WINSIZE_IN_SYS_IOCTL)
! elif test $bash_cv_struct_winsize_header = termios_h; then
!   AC_MSG_RESULT(termios.h)
!   AC_DEFINE(STRUCT_WINSIZE_IN_TERMIOS)
! else
!   AC_MSG_RESULT(not found)
! fi
! ])
! 
! dnl Check type of signal routines (posix, 4.2bsd, 4.1bsd or v7)
! AC_DEFUN(BASH_SYS_SIGNAL_VINTAGE,
! [AC_REQUIRE([AC_TYPE_SIGNAL])
! AC_MSG_CHECKING(for type of signal functions)
! AC_CACHE_VAL(bash_cv_signal_vintage,
! [
!   AC_TRY_LINK([#include <signal.h>],[
!     sigset_t ss;
!     struct sigaction sa;
!     sigemptyset(&ss); sigsuspend(&ss);
!     sigaction(SIGINT, &sa, (struct sigaction *) 0);
!     sigprocmask(SIG_BLOCK, &ss, (sigset_t *) 0);
!   ], bash_cv_signal_vintage=posix,
!   [
!     AC_TRY_LINK([#include <signal.h>], [
! 	int mask = sigmask(SIGINT);
! 	sigsetmask(mask); sigblock(mask); sigpause(mask);
!     ], bash_cv_signal_vintage=4.2bsd,
!     [
!       AC_TRY_LINK([
! 	#include <signal.h>
! 	RETSIGTYPE foo() { }], [
! 		int mask = sigmask(SIGINT);
! 		sigset(SIGINT, foo); sigrelse(SIGINT);
! 		sighold(SIGINT); sigpause(SIGINT);
!         ], bash_cv_signal_vintage=svr3, bash_cv_signal_vintage=v7
!     )]
!   )]
! )
! ])
! AC_MSG_RESULT($bash_cv_signal_vintage)
! if test "$bash_cv_signal_vintage" = posix; then
! AC_DEFINE(HAVE_POSIX_SIGNALS)
! elif test "$bash_cv_signal_vintage" = "4.2bsd"; then
! AC_DEFINE(HAVE_BSD_SIGNALS)
! elif test "$bash_cv_signal_vintage" = svr3; then
! AC_DEFINE(HAVE_USG_SIGHOLD)
! fi
! ])
! 
! dnl Check if the pgrp of setpgrp() can't be the pid of a zombie process.
! AC_DEFUN(BASH_SYS_PGRP_SYNC,
! [AC_REQUIRE([AC_FUNC_GETPGRP])
! AC_MSG_CHECKING(whether pgrps need synchronization)
! AC_CACHE_VAL(bash_cv_pgrp_pipe,
! [AC_TRY_RUN([
! #ifdef HAVE_UNISTD_H
! #  include <unistd.h>
! #endif
! main()
! {
! # ifdef GETPGRP_VOID
! #  define getpgID()	getpgrp()
! # else
! #  define getpgID()	getpgrp(0)
! #  define setpgid(x,y)	setpgrp(x,y)
! # endif
! 	int pid1, pid2, fds[2];
! 	int status;
! 	char ok;
! 
! 	switch (pid1 = fork()) {
! 	  case -1:
! 	    exit(1);
! 	  case 0:
! 	    setpgid(0, getpid());
! 	    exit(0);
! 	}
! 	setpgid(pid1, pid1);
! 
! 	sleep(2);	/* let first child die */
! 
! 	if (pipe(fds) < 0)
! 	  exit(2);
! 
! 	switch (pid2 = fork()) {
! 	  case -1:
! 	    exit(3);
! 	  case 0:
! 	    setpgid(0, pid1);
! 	    ok = getpgID() == pid1;
! 	    write(fds[1], &ok, 1);
! 	    exit(0);
! 	}
! 	setpgid(pid2, pid1);
! 
! 	close(fds[1]);
! 	if (read(fds[0], &ok, 1) != 1)
! 	  exit(4);
! 	wait(&status);
! 	wait(&status);
! 	exit(ok ? 0 : 5);
! }
! ], bash_cv_pgrp_pipe=no,bash_cv_pgrp_pipe=yes,
!    [AC_MSG_WARN(cannot check pgrp synchronization if cross compiling -- defaulting to no)
!     bash_cv_pgrp_pipe=no])
! ])
! AC_MSG_RESULT($bash_cv_pgrp_pipe)
! if test $bash_cv_pgrp_pipe = yes; then
! AC_DEFINE(PGRP_PIPE)
! fi
! ])
! 
! AC_DEFUN(BASH_SYS_REINSTALL_SIGHANDLERS,
  [AC_REQUIRE([AC_TYPE_SIGNAL])
! AC_REQUIRE([BASH_SYS_SIGNAL_VINTAGE])
  AC_MSG_CHECKING([if signal handlers must be reinstalled when invoked])
  AC_CACHE_VAL(bash_cv_must_reinstall_sighandlers,
***************
*** 819,836 ****
  ])
  
- AC_DEFUN(BASH_FUNC_SBRK_DECLARED,
- [AC_MSG_CHECKING(for declaration of sbrk in <unistd.h>)
- AC_CACHE_VAL(bash_cv_sbrk_declared,
- [AC_EGREP_HEADER(sbrk, unistd.h,
-  bash_cv_sbrk_declared=yes, bash_cv_sbrk_declared=no)])
- AC_MSG_RESULT($bash_cv_sbrk_declared)
- if test $bash_cv_sbrk_declared = yes; then
- AC_DEFINE(SBRK_DECLARED)
- fi
- ])
- 
  dnl check that some necessary job control definitions are present
! AC_DEFUN(BASH_JOB_CONTROL_MISSING,
! [AC_REQUIRE([BASH_SIGNAL_CHECK])
  AC_MSG_CHECKING(for presence of necessary job control definitions)
  AC_CACHE_VAL(bash_cv_job_control_missing,
--- 1264,1270 ----
  ])
  
  dnl check that some necessary job control definitions are present
! AC_DEFUN(BASH_SYS_JOB_CONTROL_MISSING,
! [AC_REQUIRE([BASH_SYS_SIGNAL_VINTAGE])
  AC_MSG_CHECKING(for presence of necessary job control definitions)
  AC_CACHE_VAL(bash_cv_job_control_missing,
***************
*** 940,991 ****
  ])
  
! AC_DEFUN(BASH_FUNC_POSIX_SETJMP,
! [AC_REQUIRE([BASH_SIGNAL_CHECK])
! AC_MSG_CHECKING(for presence of POSIX-style sigsetjmp/siglongjmp)
! AC_CACHE_VAL(bash_cv_func_sigsetjmp,
! [AC_TRY_RUN([
! #ifdef HAVE_UNISTD_H
! #include <unistd.h>
! #endif
! #include <sys/types.h>
! #include <signal.h>
! #include <setjmp.h>
! 
! main()
! {
! #if !defined (_POSIX_VERSION) || !defined (HAVE_POSIX_SIGNALS)
! exit (1);
! #else
! 
! int code;
! sigset_t set, oset;
! sigjmp_buf xx;
! 
! /* get the mask */
! sigemptyset(&set);
! sigemptyset(&oset);
! sigprocmask(SIG_BLOCK, (sigset_t *)NULL, &set);
! sigprocmask(SIG_BLOCK, (sigset_t *)NULL, &oset);
! 
! /* save it */
! code = sigsetjmp(xx, 1);
! if (code)
!   exit(0);	/* could get sigmask and compare to oset here. */
! 
! /* change it */
! sigaddset(&set, SIGINT);
! sigprocmask(SIG_BLOCK, &set, (sigset_t *)NULL);
! 
! /* and siglongjmp */
! siglongjmp(xx, 10);
! exit(1);
! #endif
! }], bash_cv_func_sigsetjmp=present, bash_cv_func_sigsetjmp=missing,
!     [AC_MSG_WARN(cannot check for sigsetjmp/siglongjmp if cross-compiling -- defaulting to missing)
!      bash_cv_func_sigsetjmp=missing]
! )])
! AC_MSG_RESULT($bash_cv_func_sigsetjmp)
! if test $bash_cv_func_sigsetjmp = present; then
! AC_DEFINE(HAVE_POSIX_SIGSETJMP)
  fi
  ])
--- 1374,1403 ----
  ])
  
! AC_DEFUN(BASH_SYS_DEFAULT_MAIL_DIR,
! [AC_MSG_CHECKING(for default mail directory)
! AC_CACHE_VAL(bash_cv_mail_dir,
! [if test -d /var/mail; then
!    bash_cv_mail_dir=/var/mail
!  elif test -d /usr/mail; then
!    bash_cv_mail_dir=/usr/mail
!  elif test -d /var/spool/mail; then
!    bash_cv_mail_dir=/var/spool/mail
!  elif test -d /usr/spool/mail; then
!    bash_cv_mail_dir=/usr/spool/mail
!  else
!    bash_cv_mail_dir=unknown
!  fi
! ])
! AC_MSG_RESULT($bash_cv_mail_dir)
! if test $bash_cv_mail_dir = "/var/mail"; then
!    AC_DEFINE(DEFAULT_MAIL_DIRECTORY, "/var/mail")
! elif test $bash_cv_mail_dir = "/usr/mail"; then
!    AC_DEFINE(DEFAULT_MAIL_DIRECTORY, "/usr/mail")
! elif test $bash_cv_mail_dir = "/var/spool/mail"; then
!    AC_DEFINE(DEFAULT_MAIL_DIRECTORY, "/var/spool/mail")
! elif test $bash_cv_mail_dir = "/usr/spool/mail"; then
!    AC_DEFINE(DEFAULT_MAIL_DIRECTORY, "/usr/spool/mail")
! else
!    AC_DEFINE(DEFAULT_MAIL_DIRECTORY, "unknown")
  fi
  ])
***************
*** 1003,1027 ****
  ])
  
- AC_DEFUN(BASH_STRUCT_WINSIZE,
- [AC_MSG_CHECKING(for struct winsize in sys/ioctl.h and termios.h)
- AC_CACHE_VAL(bash_cv_struct_winsize_header,
- [AC_TRY_COMPILE([#include <sys/types.h>
- #include <sys/ioctl.h>], [struct winsize x;],
-   bash_cv_struct_winsize_header=ioctl_h,
-   [AC_TRY_COMPILE([#include <sys/types.h>
- #include <termios.h>], [struct winsize x;],
-   bash_cv_struct_winsize_header=termios_h, bash_cv_struct_winsize_header=other)
- ])])
- if test $bash_cv_struct_winsize_header = ioctl_h; then
-   AC_MSG_RESULT(sys/ioctl.h)
-   AC_DEFINE(STRUCT_WINSIZE_IN_SYS_IOCTL)
- elif test $bash_cv_struct_winsize_header = termios_h; then
-   AC_MSG_RESULT(termios.h)
-   AC_DEFINE(STRUCT_WINSIZE_IN_TERMIOS)
- else
-   AC_MSG_RESULT(not found)
- fi
- ])
- 
  AC_DEFUN(BASH_HAVE_TIOCSTAT,
  [AC_MSG_CHECKING(for TIOCSTAT in sys/ioctl.h)
--- 1415,1418 ----
***************
*** 1054,1058 ****
  dnl versions) or <sys/types.h> (on others).
  dnl
! AC_DEFUN(BASH_MISC_SPEED_T,
  [AC_MSG_CHECKING(for speed_t in sys/types.h)
  AC_CACHE_VAL(bash_cv_speed_t_in_sys_types,
--- 1445,1449 ----
  dnl versions) or <sys/types.h> (on others).
  dnl
! AC_DEFUN(BASH_CHECK_SPEED_T,
  [AC_MSG_CHECKING(for speed_t in sys/types.h)
  AC_CACHE_VAL(bash_cv_speed_t_in_sys_types,
***************
*** 1122,1233 ****
  
  dnl
- dnl Check for the presence of getpeername in libsocket.
- dnl If libsocket is present, check for libnsl and add it to LIBS if
- dnl it's there, since most systems with libsocket require linking
- dnl with libnsl as well.  This should only be called if getpeername
- dnl was not found in libc.
- dnl
- dnl NOTE: IF WE FIND GETPEERNAME, WE ASSUME THAT WE HAVE BIND/CONNECT
- dnl	  AS WELL
- dnl
- AC_DEFUN(BASH_CHECK_SOCKLIB,
- [
- if test "X$bash_cv_have_socklib" = "X"; then
- _bash_needmsg=
- else
- AC_MSG_CHECKING(for socket library)
- _bash_needmsg=yes
- fi
- AC_CACHE_VAL(bash_cv_have_socklib,
- [AC_CHECK_LIB(socket, getpeername,
-         bash_cv_have_socklib=yes, bash_cv_have_socklib=no, -lnsl)])
- if test "X$_bash_needmsg" = Xyes; then
-   AC_MSG_RESULT($bash_cv_have_socklib)
-   _bash_needmsg=
- fi
- if test $bash_cv_have_socklib = yes; then
-   # check for libnsl, add it to LIBS if present
-   if test "X$bash_cv_have_libnsl" = "X"; then
-     _bash_needmsg=
-   else
-     AC_MSG_CHECKING(for libnsl)
-     _bash_needmsg=yes
-   fi
-   AC_CACHE_VAL(bash_cv_have_libnsl,
- 	   [AC_CHECK_LIB(nsl, t_open,
- 		 bash_cv_have_libnsl=yes, bash_cv_have_libnsl=no)])
-   if test "X$_bash_needmsg" = Xyes; then
-     AC_MSG_RESULT($bash_cv_have_libnsl)
-     _bash_needmsg=
-   fi
-   if test $bash_cv_have_libnsl = yes; then
-     LIBS="-lsocket -lnsl $LIBS"
-   else
-     LIBS="-lsocket $LIBS"
-   fi
-   AC_DEFINE(HAVE_LIBSOCKET)
-   AC_DEFINE(HAVE_GETPEERNAME)
- fi
- ])
- 
- dnl
- dnl This needs BASH_CHECK_SOCKLIB, but since that's not called on every
- dnl system, we can't use AC_PREREQ
- dnl
- AC_DEFUN(BASH_FUNC_GETHOSTBYNAME,
- [if test "X$bash_cv_have_gethostbyname" = "X"; then
- _bash_needmsg=yes
- else
- AC_MSG_CHECKING(for gethostbyname in socket library)
- _bash_needmsg=
- fi
- AC_CACHE_VAL(bash_cv_have_gethostbyname,
- [AC_TRY_LINK([#include <netdb.h>],
- [ struct hostent *hp;
-   hp = gethostbyname("localhost");
- ], bash_cv_have_gethostbyname=yes, bash_cv_have_gethostbyname=no)]
- )
- if test "X$_bash_needmsg" = Xyes; then
-     AC_MSG_CHECKING(for gethostbyname in socket library)
- fi
- AC_MSG_RESULT($bash_cv_have_gethostbyname)
- if test "$bash_cv_have_gethostbyname" = yes; then
- AC_DEFINE(HAVE_GETHOSTBYNAME)
- fi
- ])
- 
- AC_DEFUN(BASH_DEFAULT_MAIL_DIR,
- [AC_MSG_CHECKING(for default mail directory)
- AC_CACHE_VAL(bash_cv_mail_dir,
- [if test -d /var/mail; then
-    bash_cv_mail_dir=/var/mail
-  elif test -d /usr/mail; then
-    bash_cv_mail_dir=/usr/mail
-  elif test -d /var/spool/mail; then
-    bash_cv_mail_dir=/var/spool/mail
-  elif test -d /usr/spool/mail; then
-    bash_cv_mail_dir=/usr/spool/mail
-  else
-    bash_cv_mail_dir=unknown
-  fi
- ])
- AC_MSG_RESULT($bash_cv_mail_dir)
- if test $bash_cv_mail_dir = "/var/mail"; then
-    AC_DEFINE(DEFAULT_MAIL_DIRECTORY, "/var/mail")
- elif test $bash_cv_mail_dir = "/usr/mail"; then
-    AC_DEFINE(DEFAULT_MAIL_DIRECTORY, "/usr/mail")
- elif test $bash_cv_mail_dir = "/var/spool/mail"; then
-    AC_DEFINE(DEFAULT_MAIL_DIRECTORY, "/var/spool/mail")
- elif test $bash_cv_mail_dir = "/usr/spool/mail"; then
-    AC_DEFINE(DEFAULT_MAIL_DIRECTORY, "/usr/spool/mail")
- else
-    AC_DEFINE(DEFAULT_MAIL_DIRECTORY, "unknown")
- fi
- ])
- 
- dnl
  dnl Check if HPUX needs _KERNEL defined for RLIMIT_* definitions
  dnl
! AC_DEFUN(BASH_KERNEL_RLIMIT_CHECK,
  [AC_MSG_CHECKING([whether $host_os needs _KERNEL for RLIMIT defines])
  AC_CACHE_VAL(bash_cv_kernel_rlimit,
--- 1513,1519 ----
  
  dnl
  dnl Check if HPUX needs _KERNEL defined for RLIMIT_* definitions
  dnl
! AC_DEFUN(BASH_CHECK_KERNEL_RLIMIT,
  [AC_MSG_CHECKING([whether $host_os needs _KERNEL for RLIMIT defines])
  AC_CACHE_VAL(bash_cv_kernel_rlimit,
***************
*** 1257,1399 ****
  ])
  
- AC_DEFUN(BASH_FUNC_STRCOLL,
- [
- AC_MSG_CHECKING(whether or not strcoll and strcmp differ)
- AC_CACHE_VAL(bash_cv_func_strcoll_broken,
- [AC_TRY_RUN([
- #include <stdio.h>
- #if defined (HAVE_LOCALE_H)
- #include <locale.h>
- #endif
- 
- main(c, v)
- int     c;
- char    *v[];
- {
-         int     r1, r2;
-         char    *deflocale, *defcoll;
- 
- #ifdef HAVE_SETLOCALE
-         deflocale = setlocale(LC_ALL, "");
- 	defcoll = setlocale(LC_COLLATE, "");
- #endif
- 
- #ifdef HAVE_STRCOLL
- 	/* These two values are taken from tests/glob-test. */
-         r1 = strcoll("abd", "aXd");
- #else
- 	r1 = 0;
- #endif
-         r2 = strcmp("abd", "aXd");
- 
- 	/* These two should both be greater than 0.  It is permissible for
- 	   a system to return different values, as long as the sign is the
- 	   same. */
- 
-         /* Exit with 1 (failure) if these two values are both > 0, since
- 	   this tests whether strcoll(3) is broken with respect to strcmp(3)
- 	   in the default locale. */
- 	exit (r1 > 0 && r2 > 0);
- }
- ], bash_cv_func_strcoll_broken=yes, bash_cv_func_strcoll_broken=no,
-    [AC_MSG_WARN(cannot check strcoll if cross compiling -- defaulting to no)
-     bash_cv_func_strcoll_broken=no]
- )])
- AC_MSG_RESULT($bash_cv_func_strcoll_broken)
- if test $bash_cv_func_strcoll_broken = yes; then
- AC_DEFINE(STRCOLL_BROKEN)
- fi
- ])
- 
- dnl
- dnl If available, use support for large files unless the user specified
- dnl one of the CPPFLAGS, LDFLAGS, or LIBS variables (<eggert@twinsun.com>
- dnl via GNU patch 2.5)
- dnl
- AC_DEFUN(BASH_LARGE_FILE_SUPPORT,
- [AC_MSG_CHECKING(whether large file support needs explicit enabling)
- ac_getconfs=''
- ac_result=yes
- ac_set=''
- ac_shellvars='CPPFLAGS LDFLAGS LIBS'
- for ac_shellvar in $ac_shellvars; do
-   case $ac_shellvar in
-   CPPFLAGS) ac_lfsvar=LFS_CFLAGS ac_lfs64var=LFS64_CFLAGS ;;
-   *) ac_lfsvar=LFS_$ac_shellvar ac_lfs64var=LFS64_$ac_shellvar ;;
-   esac
-   eval test '"${'$ac_shellvar'+set}"' = set && ac_set=$ac_shellvar
-   (getconf $ac_lfsvar) >/dev/null 2>&1 || { ac_result=no; break; }
-   ac_getconf=`getconf $ac_lfsvar`
-   ac_getconf64=`getconf $ac_lfs64var`
-   ac_getconfs=$ac_getconfs$ac_getconf\ $ac_getconf64
-   eval ac_test_$ac_shellvar="\$ac_getconf\ \$ac_getconf64"
- done
- case "$ac_result$ac_getconfs" in
- yes) ac_result=no ;;
- esac
- case "$ac_result$ac_set" in
- yes?*) ac_result="yes, but $ac_set is already set, so use its settings"
- esac
- AC_MSG_RESULT($ac_result)
- case $ac_result in
- yes)
-   for ac_shellvar in $ac_shellvars; do
-     eval $ac_shellvar=\$ac_test_$ac_shellvar
-   done ;;
- esac
- ])
- 
- dnl
- dnl AC_SYS_RESTARTABLE_SYSCALLS tests only for restarted system calls
- dnl after a signal handler has been installed with signal().  Since
- dnl Bash uses sigaction() if it is available, we need to check whether
- dnl or not a signal handler installed with sigaction and SA_RESTART
- dnl causes system calls to be restarted after the signal is caught
- dnl
- AC_DEFUN(BASH_SYS_RESTARTABLE_SYSCALLS,
- [AC_REQUIRE([BASH_SIGNAL_CHECK])
- AC_CACHE_CHECK(whether posix sigaction restarts system calls by default,
- bash_cv_sys_restartable_syscalls,
- [AC_TRY_RUN(
- [/* Exit 0 (true) if wait returns something other than -1,
-    i.e. the pid of the child, which means that wait was restarted
-    after getting the signal.  */
- #ifdef HAVE_UNISTD_H
- #  include <unistd.h>
- #endif
- #include <sys/types.h>
- #include <signal.h>
- static int caught = 0;
- void ucatch (isig) int isig; { caught = 1; }
- main ()
- {
- #if !defined (_POSIX_VERSION) || !defined (HAVE_POSIX_SIGNALS)
-   exit (1);
- #else
-   struct sigaction act, oact;
-   int i, status;
- 
-   act.sa_handler = ucatch;
-   /* Might want to add SA_RESTART here, but bash's set_signal_handler
-      does not. */
-   act.sa_flags = 0;
-   sigemptyset(&act.sa_mask);
-   sigemptyset(&oact.sa_mask);
-   i = fork ();
-   /* A possible race condition here, but in practice it never happens. */
-   if (i == 0) { sleep (3); kill (getppid (), SIGINT); sleep (3); exit (0); }
-   sigaction(SIGINT, &act, &oact);
-   status = wait(&i);
-   if (status == -1) wait(&i);
-   exit (status == -1);
- #endif
- }
- ], bash_cv_sys_restartable_syscalls=yes, bash_cv_sys_restartable_syscalls=no,
-    AC_MSG_WARN(cannot check restartable syscalls if cross compiling))
- ])
- if test $bash_cv_sys_restartable_syscalls = yes; then
-   AC_DEFINE(HAVE_RESTARTABLE_SYSCALLS)
- fi
- ])
  dnl
  dnl Check for 64-bit off_t -- used for malloc alignment
--- 1543,1546 ----
***************
*** 1416,1435 ****
  fi])
  
- AC_DEFUN(BASH_STRUCT_TIMEVAL,
- [AC_MSG_CHECKING(for struct timeval in sys/time.h and time.h)
- AC_CACHE_VAL(bash_cv_struct_timeval,
- [
- AC_EGREP_HEADER(struct timeval, sys/time.h,
- 		bash_cv_struct_timeval=yes,
- 		AC_EGREP_HEADER(struct timeval, time.h,
- 			bash_cv_struct_timeval=yes,
- 			bash_cv_struct_timeval=no))
- ])
- AC_MSG_RESULT($bash_cv_struct_timeval)
- if test $bash_cv_struct_timeval = yes; then
-   AC_DEFINE(HAVE_TIMEVAL)
- fi
- ])
- 
  AC_DEFUN(BASH_CHECK_RTSIGS,
  [AC_MSG_CHECKING(for unusable real-time signals due to large values)
--- 1563,1566 ----
***************
*** 1460,1463 ****
--- 1591,1706 ----
  if test $bash_cv_unusable_rtsigs = yes; then
  AC_DEFINE(UNUSABLE_RT_SIGNALS)
+ fi
+ ])
+ 
+ dnl need: prefix exec_prefix libdir includedir CC TERMCAP_LIB
+ dnl require:
+ dnl	AC_PROG_CC
+ dnl	BASH_CHECK_LIB_TERMCAP
+ 
+ AC_DEFUN(RL_LIB_READLINE_VERSION,
+ [
+ AC_REQUIRE([BASH_CHECK_LIB_TERMCAP])
+ 
+ AC_MSG_CHECKING([version of installed readline library])
+ 
+ # What a pain in the ass this is.
+ 
+ # save cpp and ld options
+ _save_CFLAGS="$CFLAGS"
+ _save_LDFLAGS="$LDFLAGS"
+ _save_LIBS="$LIBS"
+ 
+ # Don't set ac_cv_rl_prefix if the caller has already assigned a value.  This
+ # allows the caller to do something like $_rl_prefix=$withval if the user
+ # specifies --with-installed-readline=PREFIX as an argument to configure
+ 
+ if test -z "$ac_cv_rl_prefix"; then
+ test "x$prefix" = xNONE && ac_cv_rl_prefix=$ac_default_prefix || ac_cv_rl_prefix=${prefix}
+ fi
+ 
+ eval ac_cv_rl_includedir=${ac_cv_rl_prefix}/include
+ eval ac_cv_rl_libdir=${ac_cv_rl_prefix}/lib
+ 
+ LIBS="$LIBS -lreadline ${TERMCAP_LIB}"
+ CFLAGS="$CFLAGS -I${ac_cv_rl_includedir}"
+ LDFLAGS="$LDFLAGS -L${ac_cv_rl_libdir}"
+ 
+ AC_TRY_RUN([
+ #include <stdio.h>
+ #include <readline/readline.h>
+ 
+ main()
+ {
+ 	FILE *fp;
+ 	fp = fopen("conftest.rlv", "w");
+ 	if (fp == 0) exit(1);
+ 	fprintf(fp, "%s\n", rl_library_version ? rl_library_version : "0.0");
+ 	fclose(fp);
+ 	exit(0);
+ }
+ ],
+ ac_cv_rl_version=`cat conftest.rlv`,
+ ac_cv_rl_version='0.0',
+ ac_cv_rl_version='4.2')
+ 
+ CFLAGS="$_save_CFLAGS"
+ LDFLAGS="$_save_LDFLAGS"
+ LIBS="$_save_LIBS"
+ 
+ RL_MAJOR=0
+ RL_MINOR=0
+ 
+ # (
+ case "$ac_cv_rl_version" in
+ 2*|3*|4*|5*|6*|7*|8*|9*)
+ 	RL_MAJOR=`echo $ac_cv_rl_version | sed 's:\..*$::'`
+ 	RL_MINOR=`echo $ac_cv_rl_version | sed -e 's:^.*\.::' -e 's:[a-zA-Z]*$::'`
+ 	;;
+ esac
+ 
+ # (((
+ case $RL_MAJOR in
+ [[0-9][0-9]])	_RL_MAJOR=$RL_MAJOR ;;
+ [[0-9]])	_RL_MAJOR=0$RL_MAJOR ;;
+ *)		_RL_MAJOR=00 ;;
+ esac
+ 
+ # (((
+ case $RL_MINOR in
+ [[0-9][0-9]])	_RL_MINOR=$RL_MINOR ;;
+ [[0-9]])	_RL_MINOR=0$RL_MINOR ;;
+ *)		_RL_MINOR=00 ;;
+ esac
+ 
+ RL_VERSION="0x${_RL_MAJOR}${_RL_MINOR}"
+ 
+ # Readline versions greater than 4.2 have these defines in readline.h
+ 
+ if test $ac_cv_rl_version = '0.0' ; then
+ 	AC_MSG_WARN([Could not test version of installed readline library.])
+ elif test $RL_MAJOR -gt 4 || { test $RL_MAJOR = 4 && test $RL_MINOR -gt 2 ; } ; then
+ 	# set these for use by the caller
+ 	RL_PREFIX=$ac_cv_rl_prefix
+ 	RL_LIBDIR=$ac_cv_rl_libdir
+ 	RL_INCLUDEDIR=$ac_cv_rl_includedir
+ 	AC_MSG_RESULT($ac_cv_rl_version)
+ else
+ 
+ AC_DEFINE_UNQUOTED(RL_READLINE_VERSION, $RL_VERSION, [encoded version of the installed readline library])
+ AC_DEFINE_UNQUOTED(RL_VERSION_MAJOR, $RL_MAJOR, [major version of installed readline library])
+ AC_DEFINE_UNQUOTED(RL_VERSION_MINOR, $RL_MINOR, [minor version of installed readline library])
+ 
+ AC_SUBST(RL_VERSION)
+ AC_SUBST(RL_MAJOR)
+ AC_SUBST(RL_MINOR)
+ 
+ # set these for use by the caller
+ RL_PREFIX=$ac_cv_rl_prefix
+ RL_LIBDIR=$ac_cv_rl_libdir
+ RL_INCLUDEDIR=$ac_cv_rl_includedir
+ 
+ AC_MSG_RESULT($ac_cv_rl_version)
+ 
  fi
  ])
diff -Nrc2 bash-2.05/alias.c bash-2.05a/alias.c
*** bash-2.05/alias.c	Thu Aug  5 07:17:24 1999
--- bash-2.05a/alias.c	Mon Oct 15 14:16:36 2001
***************
*** 32,35 ****
--- 32,36 ----
  
  #include <stdio.h>
+ #include "chartypes.h"
  #include "bashansi.h"
  #include "command.h"
***************
*** 42,46 ****
  #endif
  
! static int qsort_alias_compare ();
  
  /* Non-zero means expand all words on the line.  Otherwise, expand
--- 43,58 ----
  #endif
  
! typedef int sh_alias_map_func_t __P((alias_t *));
! 
! static void free_alias_data __P((PTR_T));
! static alias_t **map_over_aliases __P((sh_alias_map_func_t *));
! static void sort_aliases __P((alias_t **));
! static int qsort_alias_compare __P((alias_t **, alias_t **));
! 
! #if defined (READLINE)
! static int skipquotes __P((char *, int));
! static int skipws __P((char *, int));
! static int rd_token __P((char *, int));
! #endif
  
  /* Non-zero means expand all words on the line.  Otherwise, expand
***************
*** 135,139 ****
  static void
  free_alias_data (data)
!      char *data;
  {
    register alias_t *a;
--- 147,151 ----
  static void
  free_alias_data (data)
!      PTR_T data;
  {
    register alias_t *a;
***************
*** 190,194 ****
  static alias_t **
  map_over_aliases (function)
!      Function *function;
  {
    register int i;
--- 202,206 ----
  static alias_t **
  map_over_aliases (function)
!      sh_alias_map_func_t *function;
  {
    register int i;
***************
*** 209,214 ****
  	    {
  	      if (list_index + 1 >= list_size)
! 		list = (alias_t **)
! 		  xrealloc ((char *)list, (list_size += 20) * sizeof (alias_t *));
  
  	      list[list_index++] = alias;
--- 221,229 ----
  	    {
  	      if (list_index + 1 >= list_size)
! 	        {
! 	          list_size += 20;
! 		  list = (alias_t **)xrealloc (list,
! 					       list_size * sizeof (alias_t *));
! 	        }
  
  	      list[list_index++] = alias;
***************
*** 225,229 ****
       alias_t **array;
  {
!   qsort (array, array_len ((char **)array), sizeof (alias_t *), qsort_alias_compare);
  }
  
--- 240,244 ----
       alias_t **array;
  {
!   qsort (array, array_len ((char **)array), sizeof (alias_t *), (QSFUNC *)qsort_alias_compare);
  }
  
***************
*** 249,253 ****
      return ((alias_t **)NULL);
  
!   list = map_over_aliases ((Function *)NULL);
    if (list)
      sort_aliases (list);
--- 264,268 ----
      return ((alias_t **)NULL);
  
!   list = map_over_aliases ((sh_alias_map_func_t *)NULL);
    if (list)
      sort_aliases (list);
***************
*** 325,334 ****
       int start;
  {
!   register int i = 0;
!   int pass_next, backslash_quoted_word, peekc;
  
    /* skip quoted strings, in ' or ", and words in which a character is quoted
       with a `\'. */
!   backslash_quoted_word = pass_next = 0;
  
    /* Skip leading whitespace (or separator characters), and quoted words.
--- 340,350 ----
       int start;
  {
!   register int i;
!   int pass_next, backslash_quoted_word;
!   unsigned char peekc;
  
    /* skip quoted strings, in ' or ", and words in which a character is quoted
       with a `\'. */
!   i = backslash_quoted_word = pass_next = 0;
  
    /* Skip leading whitespace (or separator characters), and quoted words.
***************
*** 352,356 ****
  	{
  	  peekc = string[i+1];
! 	  if (isletter (peekc))
  	    backslash_quoted_word++;	/* this is a backslash-quoted word */
  	  else
--- 368,372 ----
  	{
  	  peekc = string[i+1];
! 	  if (ISLETTER (peekc))
  	    backslash_quoted_word++;	/* this is a backslash-quoted word */
  	  else
***************
*** 373,377 ****
  
  	  peekc = string[i + 1];
! 	  if (isletter (peekc))
  	    backslash_quoted_word++;
  	  continue;
--- 389,393 ----
  
  	  peekc = string[i + 1];
! 	  if (ISLETTER (peekc))
  	    backslash_quoted_word++;
  	  continue;
***************
*** 453,458 ****
  
    line_len = strlen (string) + 1;
!   line = xmalloc (line_len);
!   token = xmalloc (line_len);
  
    line[0] = i = 0;
--- 469,474 ----
  
    line_len = strlen (string) + 1;
!   line = (char *)xmalloc (line_len);
!   token = (char *)xmalloc (line_len);
  
    line[0] = i = 0;
diff -Nrc2 bash-2.05/alias.h bash-2.05a/alias.h
*** bash-2.05/alias.h	Thu Aug  5 07:00:05 1999
--- bash-2.05a/alias.h	Thu Aug  2 11:27:15 2001
***************
*** 22,28 ****
  #define _ALIAS_H_
  
! #include "hashlib.h"
  
! extern char *xmalloc ();
  
  typedef struct alias {
--- 22,28 ----
  #define _ALIAS_H_
  
! #include "stdc.h"
  
! #include "hashlib.h"
  
  typedef struct alias {
***************
*** 39,70 ****
  extern HASH_TABLE *aliases;
  
! extern void initialize_aliases ();
  
  /* Scan the list of aliases looking for one with NAME.  Return NULL
     if the alias doesn't exist, else a pointer to the alias. */
! extern alias_t *find_alias ();
  
  /* Return the value of the alias for NAME, or NULL if there is none. */
! extern char *get_alias_value ();
  
  /* Make a new alias from NAME and VALUE.  If NAME can be found,
     then replace its value. */
! extern void add_alias ();
  
  /* Remove the alias with name NAME from the alias list.  Returns
     the index of the removed alias, or -1 if the alias didn't exist. */
! extern int remove_alias ();
  
  /* Remove all aliases. */
! extern void delete_all_aliases ();
! 
! /* Return a new line, with any aliases expanded. */
! extern char *alias_expand ();
  
  /* Return an array of all defined aliases. */
! extern alias_t **all_aliases ();
  
  /* Expand a single word for aliases. */
! extern char *alias_expand_word ();
  
  #endif /* _ALIAS_H_ */
--- 39,70 ----
  extern HASH_TABLE *aliases;
  
! extern void initialize_aliases __P((void));
  
  /* Scan the list of aliases looking for one with NAME.  Return NULL
     if the alias doesn't exist, else a pointer to the alias. */
! extern alias_t *find_alias __P((char *));
  
  /* Return the value of the alias for NAME, or NULL if there is none. */
! extern char *get_alias_value __P((char *));
  
  /* Make a new alias from NAME and VALUE.  If NAME can be found,
     then replace its value. */
! extern void add_alias __P((char *, char *));
  
  /* Remove the alias with name NAME from the alias list.  Returns
     the index of the removed alias, or -1 if the alias didn't exist. */
! extern int remove_alias __P((char *));
  
  /* Remove all aliases. */
! extern void delete_all_aliases __P((void));
  
  /* Return an array of all defined aliases. */
! extern alias_t **all_aliases __P((void));
  
  /* Expand a single word for aliases. */
! extern char *alias_expand_word __P((char *));
! 
! /* Return a new line, with any aliases expanded. */
! extern char *alias_expand __P((char *));
  
  #endif /* _ALIAS_H_ */
diff -Nrc2 bash-2.05/array.c bash-2.05a/array.c
*** bash-2.05/array.c	Fri Nov  3 11:20:00 2000
--- bash-2.05a/array.c	Mon Oct 29 13:09:42 2001
***************
*** 46,51 ****
  #include "builtins/common.h"
  
- extern char *quote_string ();	/* XXX */
- 
  #define ADD_BEFORE(ae, new) \
  	do { \
--- 46,49 ----
***************
*** 67,71 ****
  	ARRAY_ELEMENT *r;
  
! 	r = (ARRAY_ELEMENT *) xmalloc(sizeof(ARRAY_ELEMENT));
  	r->ind = indx;
  	r->value = value ? savestring(value) : (char *)NULL;
--- 65,69 ----
  	ARRAY_ELEMENT *r;
  
! 	r = (ARRAY_ELEMENT *)xmalloc(sizeof(ARRAY_ELEMENT));
  	r->ind = indx;
  	r->value = value ? savestring(value) : (char *)NULL;
***************
*** 88,92 ****
  	ARRAY_ELEMENT	*head;
  
! 	r =(ARRAY *) xmalloc(sizeof(ARRAY));
  	r->type = array_indexed;
  	r->max_index = r->max_size = -1;
--- 86,90 ----
  	ARRAY_ELEMENT	*head;
  
! 	r =(ARRAY *)xmalloc(sizeof(ARRAY));
  	r->type = array_indexed;
  	r->max_index = r->max_size = -1;
***************
*** 160,164 ****
  	ARRAY	*a;
  	ARRAY_ELEMENT *p, *n;
! 	int	i;
  
  	a = new_array ();
--- 158,162 ----
  	ARRAY	*a;
  	ARRAY_ELEMENT *p, *n;
! 	arrayind_t i;
  
  	a = new_array ();
***************
*** 281,285 ****
  array_walk(a, func)
  ARRAY	*a;
! Function *func;
  {
  	register ARRAY_ELEMENT *ae;
--- 279,283 ----
  array_walk(a, func)
  ARRAY	*a;
! sh_ae_map_func_t *func;
  {
  	register ARRAY_ELEMENT *ae;
***************
*** 310,316 ****
  
  	slen = strlen(sep);
  	for (rsize = rlen = 0, ae = start; ae != end; ae = element_forw(ae)) {
  		if (rsize == 0)
! 			result = xmalloc (rsize = 64);
  		if (element_value(ae)) {
  			t = quoted ? quote_string(element_value(ae)) : element_value(ae);
--- 308,315 ----
  
  	slen = strlen(sep);
+ 	result = NULL;
  	for (rsize = rlen = 0, ae = start; ae != end; ae = element_forw(ae)) {
  		if (rsize == 0)
! 			result = (char *)xmalloc (rsize = 64);
  		if (element_value(ae)) {
  			t = quoted ? quote_string(element_value(ae)) : element_value(ae);
***************
*** 331,335 ****
  		}
  	}
! 	result[rlen] = '\0';	/* XXX */
  	return(result);
  }
--- 330,335 ----
  		}
  	}
! 	if (result)
! 	  result[rlen] = '\0';	/* XXX */
  	return(result);
  }
***************
*** 359,363 ****
  		return((char *)NULL);
  
! 	result = xmalloc (rsize = 128);
  	result[0] = '(';
  	rlen = 1;
--- 359,363 ----
  		return((char *)NULL);
  
! 	result = (char *)xmalloc (rsize = 128);
  	result[0] = '(';
  	rlen = 1;
***************
*** 526,533 ****
  array_subrange (a, start, end, quoted)
  ARRAY	*a;
! int	start, end, quoted;
  {
  	ARRAY_ELEMENT	*h, *p;
! 	int	i;
  
  	p = array_head (a);
--- 526,534 ----
  array_subrange (a, start, end, quoted)
  ARRAY	*a;
! arrayind_t	start, end;
! int	quoted;
  {
  	ARRAY_ELEMENT	*h, *p;
! 	arrayind_t	i;
  
  	p = array_head (a);
***************
*** 578,582 ****
  ARRAY_ELEMENT	*ae;
  {
! 	printf("array[%d] = %s\n",(int)element_index(ae), element_value(ae));
  }
  
--- 579,583 ----
  ARRAY_ELEMENT	*ae;
  {
! 	printf("array[%ld] = %s\n", element_index(ae), element_value(ae));
  }
  
diff -Nrc2 bash-2.05/array.h bash-2.05a/array.h
*** bash-2.05/array.h	Thu Aug  5 07:01:14 1999
--- bash-2.05a/array.h	Mon Sep 10 12:32:13 2001
***************
*** 25,29 ****
  #include "stdc.h"
  
! typedef int	arrayind_t;
  
  enum atype {array_indexed, array_assoc};
--- 25,29 ----
  #include "stdc.h"
  
! typedef long	arrayind_t;
  
  enum atype {array_indexed, array_assoc};
***************
*** 41,44 ****
--- 41,46 ----
  } ARRAY_ELEMENT;
  
+ typedef int sh_ae_map_func_t __P((ARRAY_ELEMENT *));
+ 
  char	*array_reference __P((ARRAY *, arrayind_t));
  
***************
*** 54,58 ****
  extern ARRAY	*dup_array __P((ARRAY *));
  extern ARRAY	*dup_array_subrange __P((ARRAY *, ARRAY_ELEMENT *, ARRAY_ELEMENT *));
- extern ARRAY_ELEMENT *new_array_element __P((arrayind_t, char *));
  extern ARRAY_ELEMENT *copy_array_element __P((ARRAY_ELEMENT *));
  
--- 56,59 ----
***************
*** 68,72 ****
  extern ARRAY *string_to_array __P((char *, char *));
  
! extern char *array_subrange __P((ARRAY *, int, int, int));
  extern char *array_pat_subst __P((ARRAY *, char *, char *, int));
  
--- 69,73 ----
  extern ARRAY *string_to_array __P((char *, char *));
  
! extern char *array_subrange __P((ARRAY *, arrayind_t, arrayind_t, int));
  extern char *array_pat_subst __P((ARRAY *, char *, char *, int));
  
diff -Nrc2 bash-2.05/arrayfunc.c bash-2.05a/arrayfunc.c
*** bash-2.05/arrayfunc.c	Wed Dec 31 19:00:00 1969
--- bash-2.05a/arrayfunc.c	Thu Sep 13 16:31:58 2001
***************
*** 0 ****
--- 1,645 ----
+ /* arrayfunc.c -- High-level array functions used by other parts of the shell. */
+ 
+ /* Copyright (C) 2001 Free Software Foundation, Inc.
+ 
+    This file is part of GNU Bash, the Bourne Again SHell.
+ 
+    Bash is free software; you can redistribute it and/or modify it under
+    the terms of the GNU General Public License as published by the Free
+    Software Foundation; either version 2, or (at your option) any later
+    version.
+ 
+    Bash is distributed in the hope that it will be useful, but WITHOUT ANY
+    WARRANTY; without even the implied warranty of MERCHANTABILITY or
+    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+    for more details.
+ 
+    You should have received a copy of the GNU General Public License along
+    with Bash; see the file COPYING.  If not, write to the Free Software
+    Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. */
+ 
+ #include "config.h"
+ 
+ #if defined (ARRAY_VARS)
+ 
+ #if defined (HAVE_UNISTD_H)
+ #  include <unistd.h>
+ #endif
+ #include <stdio.h>
+ 
+ #include "shell.h"
+ #include "builtins/common.h"
+ 
+ extern char *this_command_name;
+ extern int last_command_exit_value;
+ 
+ static void quote_array_assignment_chars __P((WORD_LIST *));
+ static char *array_value_internal __P((char *, int, int));
+ 
+ /* **************************************************************** */
+ /*								    */
+ /*  Functions to manipulate array variables and perform assignments */
+ /*								    */
+ /* **************************************************************** */
+ 
+ /* Convert a shell variable to an array variable.  The original value is
+    saved as array[0]. */
+ SHELL_VAR *
+ convert_var_to_array (var)
+      SHELL_VAR *var;
+ {
+   char *oldval;
+   ARRAY *array;
+ 
+   oldval = value_cell (var);
+   array = new_array ();
+   array_add_element (array, 0, oldval);
+ 
+   FREE (value_cell (var));
+   var->value = (char *)array;
+ 
+   INVALIDATE_EXPORTSTR (var);
+ 
+   VSETATTR (var, att_array);
+   VUNSETATTR (var, att_invisible);
+ 
+   return var;
+ }
+ 
+ /* Perform an array assignment name[ind]=value.  If NAME already exists and
+    is not an array, and IND is 0, perform name=value instead.  If NAME exists
+    and is not an array, and IND is not 0, convert it into an array with the
+    existing value as name[0].
+ 
+    If NAME does not exist, just create an array variable, no matter what
+    IND's value may be. */
+ SHELL_VAR *
+ bind_array_variable (name, ind, value)
+      char *name;
+      arrayind_t ind;
+      char *value;
+ {
+   SHELL_VAR *entry;
+   char *newval;
+ 
+   entry = var_lookup (name, shell_variables);
+ 
+   if (entry == (SHELL_VAR *) 0)
+     entry = make_new_array_variable (name);
+   else if (readonly_p (entry) || noassign_p (entry))
+     {
+       if (readonly_p (entry))
+ 	report_error ("%s: readonly variable", name);
+       return (entry);
+     }
+   else if (array_p (entry) == 0)
+     entry = convert_var_to_array (entry);
+ 
+   /* ENTRY is an array variable, and ARRAY points to the value. */
+   newval = make_variable_value (entry, value);
+   if (entry->assign_func)
+     (*entry->assign_func) (entry, ind, newval);
+   else
+     array_add_element (array_cell (entry), ind, newval);
+   FREE (newval);
+ 
+   return (entry);
+ }
+ 
+ /* Parse NAME, a lhs of an assignment statement of the form v[s], and
+    assign VALUE to that array element by calling bind_array_variable(). */
+ SHELL_VAR *
+ assign_array_element (name, value)
+      char *name, *value;
+ {
+   char *sub, *vname;
+   arrayind_t ind;
+   int sublen;
+   SHELL_VAR *entry;
+ 
+   vname = array_variable_name (name, &sub, &sublen);
+ 
+   if (vname == 0)
+     return ((SHELL_VAR *)NULL);
+ 
+   if ((ALL_ELEMENT_SUB (sub[0]) && sub[1] == ']') || (sublen <= 1))
+     {
+       free (vname);
+       report_error ("%s: bad array subscript", name);
+       return ((SHELL_VAR *)NULL);
+     }
+ 
+   ind = array_expand_index (sub, sublen);
+   if (ind < 0)
+     {
+       free (vname);
+       report_error ("%s: bad array subscript", name);
+       return ((SHELL_VAR *)NULL);
+     }
+ 
+   entry = bind_array_variable (vname, ind, value);
+ 
+   free (vname);
+   return (entry);
+ }
+ 
+ /* Find the array variable corresponding to NAME.  If there is no variable,
+    create a new array variable.  If the variable exists but is not an array,
+    convert it to an indexed array.  If CHECK_FLAGS is non-zero, an existing
+    variable is checked for the readonly or noassign attribute in preparation
+    for assignment (e.g., by the `read' builtin). */
+ SHELL_VAR *
+ find_or_make_array_variable (name, check_flags)
+      char *name;
+      int check_flags;
+ {
+   SHELL_VAR *var;
+ 
+   var = find_variable (name);
+ 
+   if (var == 0)
+     var = make_new_array_variable (name);
+   else if (check_flags && (readonly_p (var) || noassign_p (var)))
+     {
+       if (readonly_p (var))
+ 	report_error ("%s: readonly variable", name);
+       return ((SHELL_VAR *)NULL);
+     }
+   else if (array_p (var) == 0)
+     var = convert_var_to_array (var);
+ 
+   return (var);
+ }
+   
+ /* Perform a compound assignment statement for array NAME, where VALUE is
+    the text between the parens:  NAME=( VALUE ) */
+ SHELL_VAR *
+ assign_array_from_string (name, value)
+      char *name, *value;
+ {
+   SHELL_VAR *var;
+ 
+   var = find_or_make_array_variable (name, 1);
+   if (var == 0)
+     return ((SHELL_VAR *)NULL);
+ 
+   return (assign_array_var_from_string (var, value));
+ }
+ 
+ /* Sequentially assign the indices of indexed array variable VAR from the
+    words in LIST. */
+ SHELL_VAR *
+ assign_array_var_from_word_list (var, list)
+      SHELL_VAR *var;
+      WORD_LIST *list;
+ {
+   register arrayind_t i;
+   register WORD_LIST *l;
+   ARRAY *a;
+ 
+   for (a = array_cell (var), l = list, i = 0; l; l = l->next, i++)
+     if (var->assign_func)
+       (*var->assign_func) (var, i, l->word->word);
+     else
+       array_add_element (a, i, l->word->word);
+   return var;
+ }
+ 
+ /* Perform a compound array assignment:  VAR->name=( VALUE ).  The
+    VALUE has already had the parentheses stripped. */
+ SHELL_VAR *
+ assign_array_var_from_string (var, value)
+      SHELL_VAR *var;
+      char *value;
+ {
+   ARRAY *a;
+   WORD_LIST *list, *nlist;
+   char *w, *val, *nval;
+   int ni, len;
+   arrayind_t ind, last_ind;
+ 
+   if (value == 0)
+     return var;
+ 
+   /* If this is called from declare_builtin, value[0] == '(' and
+      strchr(value, ')') != 0.  In this case, we need to extract
+      the value from between the parens before going on. */
+   if (*value == '(')	/*)*/
+     {
+       ni = 1;
+       val = extract_array_assignment_list (value, &ni);
+       if (val == 0)
+ 	return var;
+     }
+   else
+     val = value;
+ 
+   /* Expand the value string into a list of words, performing all the
+      shell expansions including pathname generation and word splitting. */
+   /* First we split the string on whitespace, using the shell parser
+      (ksh93 seems to do this). */
+   list = parse_string_to_word_list (val, "array assign");
+ 
+   /* If we're using [subscript]=value, we need to quote each [ and ] to
+      prevent unwanted filename expansion. */
+   if (list)
+     quote_array_assignment_chars (list);
+ 
+   /* Now that we've split it, perform the shell expansions on each
+      word in the list. */
+   nlist = list ? expand_words_no_vars (list) : (WORD_LIST *)NULL;
+ 
+   dispose_words (list);
+ 
+   if (val != value)
+     free (val);
+ 
+   a = array_cell (var);
+ 
+   /* Now that we are ready to assign values to the array, kill the existing
+      value. */
+   if (a)
+     empty_array (a);
+ 
+   for (last_ind = 0, list = nlist; list; list = list->next)
+     {
+       w = list->word->word;
+ 
+       /* We have a word of the form [ind]=value */
+       if (w[0] == '[')
+ 	{
+ 	  len = skipsubscript (w, 0);
+ 
+ 	  if (w[len] != ']' || w[len+1] != '=')
+ 	    {
+ 	      nval = make_variable_value (var, w);
+ 	      if (var->assign_func)
+ 		(*var->assign_func) (var, last_ind, nval);
+ 	      else
+ 		array_add_element (a, last_ind, nval);
+ 	      FREE (nval);
+ 	      last_ind++;
+ 	      continue;
+ 	    }
+ 
+ 	  if (len == 1)
+ 	    {
+ 	      report_error ("%s: bad array subscript", w);
+ 	      continue;
+ 	    }
+ 
+ 	  if (ALL_ELEMENT_SUB (w[1]) && len == 2)
+ 	    {
+ 	      report_error ("%s: cannot assign to non-numeric index", w);
+ 	      continue;
+ 	    }
+ 
+ 	  ind = array_expand_index (w + 1, len);
+ 	  if (ind < 0)
+ 	    {
+ 	      report_error ("%s: bad array subscript", w);
+ 	      continue;
+ 	    }
+ 	  last_ind = ind;
+ 	  val = w + len + 2;
+ 	}
+       else		/* No [ind]=value, just a stray `=' */
+ 	{
+ 	  ind = last_ind;
+ 	  val = w;
+ 	}
+ 
+       if (integer_p (var))
+ 	this_command_name = (char *)NULL;	/* no command name for errors */
+       nval = make_variable_value (var, val);
+       if (var->assign_func)
+ 	(*var->assign_func) (var, ind, nval);
+       else
+ 	array_add_element (a, ind, nval);
+       FREE (nval);
+       last_ind++;
+     }
+ 
+   dispose_words (nlist);
+   return (var);
+ }
+ 
+ /* For each word in a compound array assignment, if the word looks like
+    [ind]=value, quote the `[' and `]' before the `=' to protect them from
+    unwanted filename expansion. */
+ static void
+ quote_array_assignment_chars (list)
+      WORD_LIST *list;
+ {
+   char *s, *t, *nword;
+   int saw_eq;
+   WORD_LIST *l;
+ 
+   for (l = list; l; l = l->next)
+     {
+       if (l->word == 0 || l->word->word == 0 || l->word->word[0] == '\0')
+ 	continue;	/* should not happen, but just in case... */
+       /* Don't bother if it doesn't look like [ind]=value */
+       if (l->word->word[0] != '[' || strchr (l->word->word, '=') == 0) /* ] */
+ 	continue;
+       s = nword = (char *)xmalloc (strlen (l->word->word) * 2 + 1);
+       saw_eq = 0;
+       for (t = l->word->word; *t; )
+ 	{
+ 	  if (*t == '=')
+ 	    saw_eq = 1;
+ 	  if (saw_eq == 0 && (*t == '[' || *t == ']'))
+ 	    *s++ = '\\';
+ 	  *s++ = *t++;
+ 	}
+       *s = '\0';
+       free (l->word->word);
+       l->word->word = nword;
+     }
+ }
+ 
+ /* This function assumes s[i] == '['; returns with s[ret] == ']' if
+    an array subscript is correctly parsed. */
+ int
+ skipsubscript (s, i)
+      const char *s;
+      int i;
+ {
+   int count, c;
+ 
+   for (count = 1; count && (c = s[++i]); )
+     {
+       if (c == '[')
+ 	count++;
+       else if (c == ']')
+ 	count--;
+     }
+   return i;
+ }
+ 
+ /* This function is called with SUB pointing to just after the beginning
+    `[' of an array subscript and removes the array element to which SUB
+    expands from array VAR.  A subscript of `*' or `@' unsets the array. */
+ int
+ unbind_array_element (var, sub)
+      SHELL_VAR *var;
+      char *sub;
+ {
+   int len;
+   arrayind_t ind;
+   ARRAY_ELEMENT *ae;
+ 
+   len = skipsubscript (sub, 0);
+   if (sub[len] != ']' || len == 0)
+     {
+       builtin_error ("%s[%s: bad array subscript", var->name, sub);
+       return -1;
+     }
+   sub[len] = '\0';
+ 
+   if (ALL_ELEMENT_SUB (sub[0]) && sub[1] == 0)
+     {
+       makunbound (var->name, shell_variables);
+       return (0);
+     }
+   ind = array_expand_index (sub, len+1);
+   if (ind < 0)
+     {
+       builtin_error ("[%s]: bad array subscript", sub);
+       return -1;
+     }
+   ae = array_delete_element (array_cell (var), ind);
+   if (ae)
+     destroy_array_element (ae);
+   return 0;
+ }
+ 
+ /* Format and output an array assignment in compound form VAR=(VALUES),
+    suitable for re-use as input. */
+ void
+ print_array_assignment (var, quoted)
+      SHELL_VAR *var;
+      int quoted;
+ {
+   char *vstr;
+ 
+   if (quoted)
+     vstr = quoted_array_assignment_string (array_cell (var));
+   else
+     vstr = array_to_assignment_string (array_cell (var));
+ 
+   if (vstr == 0)
+     printf ("%s=%s\n", var->name, quoted ? "'()'" : "()");
+   else
+     {
+       printf ("%s=%s\n", var->name, vstr);
+       free (vstr);
+     }
+ }
+ 
+ /***********************************************************************/
+ /*								       */
+ /* Utility functions to manage arrays and their contents for expansion */
+ /*								       */
+ /***********************************************************************/
+ 
+ /* Return 1 if NAME is a properly-formed array reference v[sub]. */
+ int
+ valid_array_reference (name)
+      char *name;
+ {
+   char *t;
+   int r, len;
+ 
+   t = strchr (name, '[');	/* ] */
+   if (t)
+     {
+       *t = '\0';
+       r = legal_identifier (name);
+       *t = '[';
+       if (r == 0)
+ 	return 0;
+       /* Check for a properly-terminated non-blank subscript. */
+       len = skipsubscript (t, 0);
+       if (t[len] != ']' || len == 1)
+ 	return 0;
+       for (r = 1; r < len; r++)
+ 	if (whitespace (t[r]) == 0)
+ 	  return 1;
+       return 0;
+     }
+   return 0;
+ }
+ 
+ /* Expand the array index beginning at S and extending LEN characters. */
+ arrayind_t
+ array_expand_index (s, len)
+      char *s;
+      int len;
+ {
+   char *exp, *t;
+   int expok;
+   arrayind_t val;
+ 
+   exp = (char *)xmalloc (len);
+   strncpy (exp, s, len - 1);
+   exp[len - 1] = '\0';
+   t = expand_string_to_string (exp, 0);
+   this_command_name = (char *)NULL;
+   val = evalexp (t, &expok);
+   free (t);
+   free (exp);
+   if (expok == 0)
+     {
+       last_command_exit_value = EXECUTION_FAILURE;
+       jump_to_top_level (DISCARD);
+     }
+   return val;
+ }
+ 
+ /* Return the name of the variable specified by S without any subscript.
+    If SUBP is non-null, return a pointer to the start of the subscript
+    in *SUBP. If LENP is non-null, the length of the subscript is returned
+    in *LENP.  This returns newly-allocated memory. */
+ char *
+ array_variable_name (s, subp, lenp)
+      char *s, **subp;
+      int *lenp;
+ {
+   char *t, *ret;
+   int ind, ni;
+ 
+   t = strchr (s, '[');
+   if (t == 0)
+     return ((char *)NULL);
+   ind = t - s;
+   ni = skipsubscript (s, ind);
+   if (ni <= ind + 1 || s[ni] != ']')
+     {
+       report_error ("%s: bad array subscript", s);
+       return ((char *)NULL);
+     }
+ 
+   *t = '\0';
+   ret = savestring (s);
+   *t++ = '[';		/* ] */
+ 
+   if (subp)
+     *subp = t;
+   if (lenp)
+     *lenp = ni - ind;
+ 
+   return ret;
+ }
+ 
+ /* Return the variable specified by S without any subscript.  If SUBP is
+    non-null, return a pointer to the start of the subscript in *SUBP.
+    If LENP is non-null, the length of the subscript is returned in *LENP. */
+ SHELL_VAR *
+ array_variable_part (s, subp, lenp)
+      char *s, **subp;
+      int *lenp;
+ {
+   char *t;
+   SHELL_VAR *var;
+ 
+   t = array_variable_name (s, subp, lenp);
+   if (t == 0)
+     return ((SHELL_VAR *)NULL);
+   var = find_variable (t);
+ 
+   free (t);
+   return var;
+ }
+ 
+ /* Return a string containing the elements in the array and subscript
+    described by S.  If the subscript is * or @, obeys quoting rules akin
+    to the expansion of $* and $@ including double quoting. */
+ static char *
+ array_value_internal (s, quoted, allow_all)
+      char *s;
+      int quoted, allow_all;
+ {
+   int len;
+   arrayind_t ind;
+   char *retval, *t, *temp;
+   WORD_LIST *l;
+   SHELL_VAR *var;
+ 
+   var = array_variable_part (s, &t, &len);
+ 
+   if (var == 0)
+     return (char *)NULL;
+ 
+   /* [ */
+   if (ALL_ELEMENT_SUB (t[0]) && t[1] == ']')
+     {
+       if (allow_all == 0)
+ 	{
+ 	  report_error ("%s: bad array subscript", s);
+ 	  return ((char *)NULL);
+ 	}
+       else if (array_p (var) == 0)
+ 	{
+ 	  l = (WORD_LIST *)NULL;
+ 	  l = add_string_to_list (value_cell (var), l);
+ 	}
+       else
+ 	{
+ 	  l = array_to_word_list (array_cell (var));
+ 	  if (l == (WORD_LIST *)NULL)
+ 	    return ((char *) NULL);
+ 	}
+ 
+       if (t[0] == '*' && (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)))
+ 	{
+ 	  temp = string_list_dollar_star (l);
+ 	  retval = quote_string (temp);
+ 	  free (temp);
+ 	}
+       else	/* ${name[@]} or unquoted ${name[*]} */
+ 	retval = string_list_dollar_at (l, quoted);
+ 
+       dispose_words (l);
+     }
+   else
+     {
+       ind = array_expand_index (t, len);
+       if (ind < 0)
+ 	{
+ 	  report_error ("%s: bad array subscript", var->name);
+ 	  return ((char *)NULL);
+ 	}
+       if (array_p (var) == 0)
+ 	return (ind == 0 ? savestring (value_cell (var)) : (char *)NULL);
+       retval = array_reference (array_cell (var), ind);
+       if (retval)
+ 	retval = quote_escapes (retval);
+     }
+ 
+   return retval;
+ }
+ 
+ /* Return a string containing the elements described by the array and
+    subscript contained in S, obeying quoting for subscripts * and @. */
+ char *
+ array_value (s, quoted)
+      char *s;
+      int quoted;
+ {
+   return (array_value_internal (s, quoted, 1));
+ }
+ 
+ /* Return the value of the array indexing expression S as a single string.
+    If ALLOW_ALL is 0, do not allow `@' and `*' subscripts.  This is used
+    by other parts of the shell such as the arithmetic expression evaluator
+    in expr.c. */
+ char *
+ get_array_value (s, allow_all)
+      char *s;
+      int allow_all;
+ {
+   return (array_value_internal (s, 0, allow_all));
+ }
+ 
+ #endif /* ARRAY_VARS */
diff -Nrc2 bash-2.05/arrayfunc.h bash-2.05a/arrayfunc.h
*** bash-2.05/arrayfunc.h	Wed Dec 31 19:00:00 1969
--- bash-2.05a/arrayfunc.h	Thu Sep 13 16:32:06 2001
***************
*** 0 ****
--- 1,53 ----
+ /* arrayfunc.h -- declarations for miscellaneous array functions in arrayfunc.c */
+ 
+ /* Copyright (C) 2001 Free Software Foundation, Inc.
+ 
+    This file is part of GNU Bash, the Bourne Again SHell.
+ 
+    Bash is free software; you can redistribute it and/or modify it
+    under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2, or (at your option)
+    any later version.
+ 
+    Bash is distributed in the hope that it will be useful, but WITHOUT
+    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+    or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+    License for more details.
+ 
+    You should have received a copy of the GNU General Public License
+    along with Bash; see the file COPYING.  If not, write to the Free
+    Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. */
+ 
+ #if !defined (_ARRAYFUNC_H_)
+ #define _ARRAYFUNC_H_
+ 
+ /* Must include variables.h before including this file. */
+ 
+ #if defined (ARRAY_VARS)
+ 
+ extern SHELL_VAR *convert_var_to_array __P((SHELL_VAR *));
+ 
+ extern SHELL_VAR *bind_array_variable __P((char *, arrayind_t, char *));
+ extern SHELL_VAR *assign_array_element __P((char *, char *));
+ 
+ extern SHELL_VAR *find_or_make_array_variable __P((char *, int));
+ 
+ extern SHELL_VAR *assign_array_from_string  __P((char *, char *));
+ extern SHELL_VAR *assign_array_var_from_word_list __P((SHELL_VAR *, WORD_LIST *));
+ extern SHELL_VAR *assign_array_var_from_string __P((SHELL_VAR *, char *));
+ 
+ extern int unbind_array_element __P((SHELL_VAR *, char *));
+ extern int skipsubscript __P((const char *, int));
+ extern void print_array_assignment __P((SHELL_VAR *, int));
+ 
+ extern arrayind_t array_expand_index __P((char *, int));
+ extern int valid_array_reference __P((char *));
+ extern char *array_value __P((char *, int));
+ extern char *get_array_value __P((char *, int));
+ 
+ extern char *array_variable_name __P((char *, char **, int *));
+ extern SHELL_VAR *array_variable_part __P((char *, char **, int *));
+ 
+ #endif
+ 
+ #endif /* !_ARRAYFUNC_H_ */
diff -Nrc2 bash-2.05/bashansi.h bash-2.05a/bashansi.h
*** bash-2.05/bashansi.h	Thu Aug  5 07:01:23 1999
--- bash-2.05a/bashansi.h	Mon Oct 15 09:29:48 2001
***************
*** 23,30 ****
  
  #if defined (HAVE_STRING_H)
  #  include <string.h>
- #else
- #  include <strings.h>
  #endif /* !HAVE_STRING_H */
  
  #if defined (HAVE_STDLIB_H)
--- 23,35 ----
  
  #if defined (HAVE_STRING_H)
+ #  if ! defined (STDC_HEADERS) && defined (HAVE_MEMORY_H)
+ #    include <memory.h>
+ #  endif
  #  include <string.h>
  #endif /* !HAVE_STRING_H */
+ 
+ #if defined (HAVE_STRINGS_H)
+ #  include <strings.h>
+ #endif /* !HAVE_STRINGS_H */
  
  #if defined (HAVE_STDLIB_H)
diff -Nrc2 bash-2.05/bashhist.c bash-2.05a/bashhist.c
*** bash-2.05/bashhist.c	Tue Mar 13 14:54:46 2001
--- bash-2.05a/bashhist.c	Mon Sep 10 15:18:59 2001
***************
*** 42,49 ****
  #include "parser.h"	/* for the struct dstack stuff. */
  #include "pathexp.h"	/* for the struct ignorevar stuff */
  #include "builtins/common.h"
  
  #include <readline/history.h>
! #include <glob/fnmatch.h>
  
  #if defined (READLINE)
--- 42,51 ----
  #include "parser.h"	/* for the struct dstack stuff. */
  #include "pathexp.h"	/* for the struct ignorevar stuff */
+ #include "bashhist.h"	/* matching prototypes and declarations */
  #include "builtins/common.h"
  
  #include <readline/history.h>
! #include <glob/glob.h>
! #include <glob/strmatch.h>
  
  #if defined (READLINE)
***************
*** 55,61 ****
  #endif
  
! extern int glob_pattern_p ();
! 
! static int histignore_item_func ();
  
  static struct ignorevar histignore =
--- 57,61 ----
  #endif
  
! static int histignore_item_func __P((struct ign *));
  
  static struct ignorevar histignore =
***************
*** 65,69 ****
    0,
    (char *)0,
!   (Function *)histignore_item_func,
  };
  
--- 65,69 ----
    0,
    (char *)0,
!   (sh_iv_item_func_t *)histignore_item_func,
  };
  
***************
*** 149,164 ****
  #endif /* READLINE */
  
  /* Variables declared in other files used here. */
- extern int interactive;
  extern int current_command_line_count;
  
  extern struct dstack dstack;
  
! extern char *extract_colon_unit ();
! extern char *history_delimiting_chars ();
! extern void maybe_add_history ();	/* forward declaration */
! extern void bash_add_history ();	/* forward declaration */
! 
! static int history_should_ignore ();
  
  /* Is the history expansion starting at string[i] one that should not
--- 149,170 ----
  #endif /* READLINE */
  
+ /* Non-zero means to not save function definitions in the history list. */
+ int dont_save_function_defs;
+ 
  /* Variables declared in other files used here. */
  extern int current_command_line_count;
  
  extern struct dstack dstack;
  
! static int bash_history_inhibit_expansion __P((char *, int));
! #if defined (READLINE)
! static void re_edit __P((char *));
! #endif
! static int history_expansion_p __P((char *));
! static int shell_comment __P((char *));
! static int should_expand __P((char *));
! static HIST_ENTRY *last_history_entry __P((void));
! static char *expand_histignore_pattern __P((char *));
! static int history_should_ignore __P((char *));
  
  /* Is the history expansion starting at string[i] one that should not
***************
*** 471,474 ****
--- 477,481 ----
  }
  
+ #ifdef INCLUDE_UNUSED
  /* Remove shell comments from LINE.  A `#' and anything after it is a comment.
     This isn't really useful yet, since it doesn't handle quoting. */
***************
*** 485,488 ****
--- 492,496 ----
    return (line);
  }
+ #endif
  
  /* Add LINE to the history list depending on the value of HISTORY_CONTROL. */
***************
*** 581,588 ****
  	    }
  
! 	  new_line = (char *) xmalloc (1
! 				       + curlen
! 				       + strlen (line)
! 				       + strlen (chars_to_add));
  	  sprintf (new_line, "%s%s%s", current->line, chars_to_add, line);
  	  offset = where_history ();
--- 589,596 ----
  	    }
  
! 	  new_line = (char *)xmalloc (1
! 				      + curlen
! 				      + strlen (line)
! 				      + strlen (chars_to_add));
  	  sprintf (new_line, "%s%s%s", current->line, chars_to_add, line);
  	  offset = where_history ();
***************
*** 705,709 ****
  	npat = histignore.ignores[i].val;
  
!       match = fnmatch (npat, line, FNMATCH_EXTFLAG) != FNM_NOMATCH;
  
        if (histignore.ignores[i].flags & HIGN_EXPAND)
--- 713,717 ----
  	npat = histignore.ignores[i].val;
  
!       match = strmatch (npat, line, FNMATCH_EXTFLAG) != FNM_NOMATCH;
  
        if (histignore.ignores[i].flags & HIGN_EXPAND)
diff -Nrc2 bash-2.05/bashhist.h bash-2.05a/bashhist.h
*** bash-2.05/bashhist.h	Thu Aug  5 07:01:46 1999
--- bash-2.05a/bashhist.h	Tue Aug 28 08:05:57 2001
***************
*** 22,25 ****
--- 22,27 ----
  #define _BASHHIST_H_
  
+ #include "stdc.h"
+ 
  extern int remember_on_history;
  extern int history_lines_this_session;
***************
*** 34,53 ****
  #  endif /* BANG_HISTORY */
  
! extern void bash_initialize_history ();
! extern void bash_history_reinit ();
! extern void bash_history_disable ();
! extern void bash_history_enable ();
! extern void load_history ();
! extern void save_history ();
! extern int maybe_append_history ();
! extern int maybe_save_shell_history ();
! extern char *pre_process_line ();
! extern int history_number ();
! extern void maybe_add_history ();
! extern void bash_add_history ();
  
! extern void setup_history_ignore ();
  
! extern char *last_history_line ();
  
  #endif /* _BASHHIST_H_ */
--- 36,55 ----
  #  endif /* BANG_HISTORY */
  
! extern void bash_initialize_history __P((void));
! extern void bash_history_reinit __P((int));
! extern void bash_history_disable __P((void));
! extern void bash_history_enable __P((void));
! extern void load_history __P((void));
! extern void save_history __P((void));
! extern int maybe_append_history __P((char *));
! extern int maybe_save_shell_history __P((void));
! extern char *pre_process_line __P((char *, int, int));
! extern void maybe_add_history __P((char *));
! extern void bash_add_history __P((char *));
! extern int history_number __P((void));
  
! extern void setup_history_ignore __P((char *));
  
! extern char *last_history_line __P((void));
  
  #endif /* _BASHHIST_H_ */
diff -Nrc2 bash-2.05/bashline.c bash-2.05a/bashline.c
*** bash-2.05/bashline.c	Tue Mar  6 13:36:07 2001
--- bash-2.05a/bashline.c	Mon Nov  5 12:58:59 2001
***************
*** 30,34 ****
--- 30,39 ----
  #endif
  
+ #if defined (HAVE_GRP_H)
+ #  include <grp.h>
+ #endif
+ 
  #include <stdio.h>
+ #include "chartypes.h"
  #include "bashansi.h"
  #include "shell.h"
***************
*** 60,65 ****
  /* Forward declarations */
  
- extern char *command_word_completion_function __P((const char *, int));
- 
  /* Functions bound to keys in Readline for Bash users. */
  static int shell_expand_line __P((int, int));
--- 65,68 ----
***************
*** 70,77 ****
  static int bash_ignore_everything __P((char **));
  
- static void cleanup_expansion_error __P((void));
- static void set_up_new_line __P((char *));
- 
  #if defined (BANG_HISTORY)
  static int history_expand_line __P((int, int));
  static int tcsh_magic_space __P((int, int));
--- 73,78 ----
  static int bash_ignore_everything __P((char **));
  
  #if defined (BANG_HISTORY)
+ static char *history_expand_line_internal __P((char *));
  static int history_expand_line __P((int, int));
  static int tcsh_magic_space __P((int, int));
***************
*** 85,92 ****
  
  /* Helper functions for Readline. */
! static int bash_directory_completion_hook ();
! static int filename_completion_ignore ();
  static int bash_push_line __P((void));
  
  static char **attempt_shell_completion __P((const char *, int, int));
  static char *variable_completion_function __P((const char *, int));
--- 86,98 ----
  
  /* Helper functions for Readline. */
! static int bash_directory_completion_hook __P((char **));
! static int filename_completion_ignore __P((char **));
  static int bash_push_line __P((void));
  
+ static void cleanup_expansion_error __P((void));
+ static void maybe_make_readline_line __P((char *));
+ static void set_up_new_line __P((char *));
+ 
+ static int check_redir __P((int));
  static char **attempt_shell_completion __P((const char *, int, int));
  static char *variable_completion_function __P((const char *, int));
***************
*** 94,109 ****
  static char *command_subst_completion_function __P((const char *, int));
  
  static int dynamic_complete_history __P((int, int));
  
! static char *glob_complete_word __P((const char *, int));
! static int bash_glob_expand_word __P((int, int));
! static int bash_glob_list_expansions __P((int, int));
! 
! static void snarf_hosts_from_file __P((char *));
  static void add_host_name __P((char *));
  
  static char *bash_dequote_filename __P((char *, int));
  static char *bash_quote_filename __P((char *, int, char *));
  
  #if defined (ALIAS)
  static int posix_edit_macros __P((int, int));
--- 100,127 ----
  static char *command_subst_completion_function __P((const char *, int));
  
+ static void build_history_completion_array __P((void));
+ static char *history_completion_generator __P((const char *, int));
  static int dynamic_complete_history __P((int, int));
  
! static void initialize_hostname_list __P((void));
  static void add_host_name __P((char *));
+ static void snarf_hosts_from_file __P((char *));
+ static char **hostnames_matching __P((char *));
+ 
+ static void _ignore_completion_names __P((char **, sh_ignore_func_t *));
+ static int name_is_acceptable __P((const char *));
+ static int test_for_directory __P((const char *));
+ static int return_zero __P((const char *));
  
  static char *bash_dequote_filename __P((char *, int));
+ static char *quote_word_break_chars __P((char *));
  static char *bash_quote_filename __P((char *, int, char *));
  
+ static int bash_execute_unix_command __P((int, int));
+ static void init_unix_command_map __P((void));
+ static int isolate_sequence __P((char *, int, int, int *));
+ 
+ static int set_saved_history __P((void));
+ 
  #if defined (ALIAS)
  static int posix_edit_macros __P((int, int));
***************
*** 111,119 ****
  
  #if defined (PROGRAMMABLE_COMPLETION)
  static char **prog_complete_matches;
- static int old_rl_completion_append_character;
  #endif
  
  /* Variables used here but defined in other files. */
  extern int posixly_correct, no_symbolic_links;
  extern char *current_prompt_string, *ps1_prompt;
--- 129,142 ----
  
  #if defined (PROGRAMMABLE_COMPLETION)
+ static int find_cmd_start __P((int));
+ static int find_cmd_end __P((int));
+ static char *find_cmd_name __P((int));
+ static char *prog_complete_return __P((const char *, int));
+ 
  static char **prog_complete_matches;
  #endif
  
  /* Variables used here but defined in other files. */
+ extern int current_command_line_count;
  extern int posixly_correct, no_symbolic_links;
  extern char *current_prompt_string, *ps1_prompt;
***************
*** 145,148 ****
--- 168,176 ----
  static int bash_complete_command __P((int, int));
  static int bash_possible_command_completions __P((int, int));
+ 
+ static char *glob_complete_word __P((const char *, int));
+ static int bash_glob_completion_internal __P((int));
+ static int bash_glob_expand_word __P((int, int));
+ static int bash_glob_list_expansions __P((int, int));
  #endif /* SPECIFIC_COMPLETION_FUNCTIONS */
  
***************
*** 190,197 ****
  }
  
! void
  enable_hostname_completion (on_or_off)
       int on_or_off;
  {
    if (on_or_off)
      {
--- 218,229 ----
  }
  
! int
  enable_hostname_completion (on_or_off)
       int on_or_off;
  {
+   int old_value;
+ 
+   old_value = perform_hostname_completion;
+ 
    if (on_or_off)
      {
***************
*** 206,209 ****
--- 238,243 ----
        rl_completer_word_break_characters = bash_nohostname_word_break_characters;
      }
+ 
+   return (old_value);
  }
  
***************
*** 458,462 ****
       char *name;
  {
!   long size;
  
    if (hostname_list_length + 2 > hostname_list_size)
--- 492,496 ----
       char *name;
  {
!   size_t size;
  
    if (hostname_list_length + 2 > hostname_list_size)
***************
*** 515,519 ****
  
        /* Skip internet address if present. */
!       if (digit (buffer[i]))
  	for (; buffer[i] && cr_whitespace (buffer[i]) == 0; i++);
  
--- 549,553 ----
  
        /* Skip internet address if present. */
!       if (DIGIT (buffer[i]))
  	for (; buffer[i] && cr_whitespace (buffer[i]) == 0; i++);
  
***************
*** 620,623 ****
--- 654,658 ----
    saved_history_line_to_use = -1;
    rl_startup_hook = old_rl_startup_hook;
+   return (0);
  }
  
***************
*** 658,662 ****
  {
    char *command;
!   int r;
  
    /* Accept the current line. */
--- 693,700 ----
  {
    char *command;
!   int r, cclc, rrs;
! 
!   rrs = rl_readline_state;
!   cclc = current_command_line_count;
  
    /* Accept the current line. */
***************
*** 665,669 ****
    if (rl_explicit_arg)
      {
!       command = xmalloc (strlen (VI_EDIT_COMMAND) + 8);
        sprintf (command, "%s %d", VI_EDIT_COMMAND, count);
      }
--- 703,707 ----
    if (rl_explicit_arg)
      {
!       command = (char *)xmalloc (strlen (VI_EDIT_COMMAND) + 8);
        sprintf (command, "%s %d", VI_EDIT_COMMAND, count);
      }
***************
*** 682,686 ****
--- 720,735 ----
      }
    r = parse_and_execute (command, "v", SEVAL_NOHIST);
+ 
+   current_command_line_count = cclc;
+ 
+   /* Now erase the contents of the current line and undo the effects of the
+      rl_accept_line() above.  We don't even want to make the text we just
+      executed available for undoing. */
    rl_line_buffer[0] = '\0';	/* XXX */
+   rl_point = rl_end = 0;
+   rl_done = 0;
+   rl_readline_state = rrs;
+ 
+   rl_forced_update_display ();
  
    return r;
***************
*** 740,743 ****
--- 789,797 ----
  
  #if defined (PROGRAMMABLE_COMPLETION)
+ /*
+  * XXX - because of the <= start test, and setting os = s+1, this can
+  * potentially return os > start.  This is probably not what we want to
+  * happen, but fix later after 2.05a-release.
+  */
  static int
  find_cmd_start (start)
***************
*** 783,787 ****
  static char *
  prog_complete_return (text, matchnum)
!      char *text;
       int matchnum;
  {
--- 837,841 ----
  static char *
  prog_complete_return (text, matchnum)
!      const char *text;
       int matchnum;
  {
***************
*** 887,891 ****
        e = find_cmd_end (end);
        n = find_cmd_name (s);
!       prog_complete_matches = programmable_completions (n, text, s, e, &foundcs);
        FREE (n);
        /* XXX - if we found a COMPSPEC for the command, just return whatever
--- 941,948 ----
        e = find_cmd_end (end);
        n = find_cmd_name (s);
!       if (e > s)
! 	prog_complete_matches = programmable_completions (n, text, s, e, &foundcs);
!       else
! 	foundcs = 0;
        FREE (n);
        /* XXX - if we found a COMPSPEC for the command, just return whatever
***************
*** 896,900 ****
  	{
  	  /* If the user specified that the compspec returns filenames, make
! 	     sure that readline knows it.
  	  if (foundcs & COPT_FILENAMES)
  	    rl_filename_completion_desired = 1;
--- 953,957 ----
  	{
  	  /* If the user specified that the compspec returns filenames, make
! 	     sure that readline knows it. */
  	  if (foundcs & COPT_FILENAMES)
  	    rl_filename_completion_desired = 1;
***************
*** 954,958 ****
    /* This could be a globbing pattern, so try to expand it using pathname
       expansion. */
!   if (!matches && glob_pattern_p ((char *)text))	/* XXX fix const later */
      {
        matches = rl_completion_matches (text, glob_complete_word);
--- 1011,1015 ----
    /* This could be a globbing pattern, so try to expand it using pathname
       expansion. */
!   if (!matches && glob_pattern_p (text))
      {
        matches = rl_completion_matches (text, glob_complete_word);
***************
*** 1003,1012 ****
  	 whether or not it is unique, and, if so, whether that filename
  	 is executable. */
!       if (absolute_program ((char *)hint_text))
  	{
  	  /* Perform tilde expansion on what's passed, so we don't end up
  	     passing filenames with tildes directly to stat(). */
  	  if (*hint_text == '~')
! 	    hint = bash_tilde_expand ((char *)hint_text);
  	  else
  	    hint = savestring (hint_text);
--- 1060,1069 ----
  	 whether or not it is unique, and, if so, whether that filename
  	 is executable. */
!       if (absolute_program (hint_text))
  	{
  	  /* Perform tilde expansion on what's passed, so we don't end up
  	     passing filenames with tildes directly to stat(). */
  	  if (*hint_text == '~')
! 	    hint = bash_tilde_expand (hint_text);
  	  else
  	    hint = savestring (hint_text);
***************
*** 1147,1151 ****
  	free (filename_hint);
  
!       filename_hint = xmalloc (2 + strlen (current_path) + hint_len);
        sprintf (filename_hint, "%s/%s", current_path, hint);
  
--- 1204,1208 ----
  	free (filename_hint);
  
!       filename_hint = (char *)xmalloc (2 + strlen (current_path) + hint_len);
        sprintf (filename_hint, "%s/%s", current_path, hint);
  
***************
*** 1182,1186 ****
  	      tl = strlen (hint_text);
  	      l = vl - hint_len;	/* # of chars added */
! 	      temp = xmalloc (l + 2 + tl);
  	      strcpy (temp, hint_text);
  	      strcpy (temp + tl, val + vl - l);
--- 1239,1243 ----
  	      tl = strlen (hint_text);
  	      l = vl - hint_len;	/* # of chars added */
! 	      temp = (char *)xmalloc (l + 2 + tl);
  	      strcpy (temp, hint_text);
  	      strcpy (temp + tl, val + vl - l);
***************
*** 1259,1263 ****
    else
      {
!       value = xmalloc (1 + start_len + strlen (matches[cmd_index]));
  
        if (start_len == 1)
--- 1316,1320 ----
    else
      {
!       value = (char *)xmalloc (1 + start_len + strlen (matches[cmd_index]));
  
        if (start_len == 1)
***************
*** 1315,1319 ****
    else
      {
!       char *value = xmalloc (4 + strlen (varlist[varlist_index]));
  
        if (first_char_loc)
--- 1372,1378 ----
    else
      {
!       char *value;
! 
!       value = (char *)xmalloc (4 + strlen (varlist[varlist_index]));
  
        if (first_char_loc)
***************
*** 1356,1360 ****
  	first_char_loc++;
  
!       list = hostnames_matching (&text[first_char_loc]);
        list_index = 0;
      }
--- 1415,1419 ----
  	first_char_loc++;
  
!       list = hostnames_matching ((char *)text+first_char_loc);
        list_index = 0;
      }
***************
*** 1364,1368 ****
        char *t;
  
!       t = xmalloc (2 + strlen (list[list_index]));
        *t = first_char;
        strcpy (t + first_char_loc, list[list_index]);
--- 1423,1427 ----
        char *t;
  
!       t = (char *)xmalloc (2 + strlen (list[list_index]));
        *t = first_char;
        strcpy (t + first_char_loc, list[list_index]);
***************
*** 1374,1377 ****
--- 1433,1475 ----
  }
  
+ char *
+ bash_groupname_completion_function (text, state)
+      const char *text;
+      int state;
+ {
+ #if defined (__WIN32__) || defined (__OPENNT) || !defined (HAVE_GRP_H)
+   return ((char *)NULL);
+ #else
+   static char *gname = (char *)NULL;
+   static struct group *grent;
+   static int gnamelen;
+   char *value;
+ 
+   if (state == 0)
+     {
+       FREE (gname);
+       gname = savestring (text);
+       gnamelen = strlen (gname);
+ 
+       setgrent ();
+     }
+ 
+   while (grent = getgrent ())
+     {
+       if (gnamelen == 0 || (STREQN (gname, grent->gr_name, gnamelen)))
+         break;
+     }
+ 
+   if (grent == 0)
+     {
+       endgrent ();
+       return ((char *)NULL);
+     }
+ 
+   value = savestring (grent->gr_name);
+   return (value);
+ #endif
+ }
+ 
  /* Functions to perform history and alias expansions on the current line. */
  
***************
*** 1430,1435 ****
       char *new_line;
  {
!   int old_point = rl_point;
!   int at_end = rl_point == rl_end;
  
    /* If the line was history and alias expanded, then make that
--- 1528,1535 ----
       char *new_line;
  {
!   int old_point, at_end;
! 
!   old_point = rl_point;
!   at_end = rl_point == rl_end;
  
    /* If the line was history and alias expanded, then make that
***************
*** 1595,1599 ****
        if (expanded_string == 0)
  	{
! 	  new_line = xmalloc (1);
  	  new_line[0] = '\0';
  	}
--- 1695,1699 ----
        if (expanded_string == 0)
  	{
! 	  new_line = (char *)xmalloc (1);
  	  new_line[0] = '\0';
  	}
***************
*** 1643,1647 ****
    0,
    (char *)0,
!   (Function *) 0,
  };
  
--- 1743,1747 ----
    0,
    (char *)0,
!   (sh_iv_item_func_t *) 0,
  };
  
***************
*** 1649,1653 ****
  _ignore_completion_names (names, name_func)
       char **names;
!      Function *name_func;
  {
    char **newnames;
--- 1749,1753 ----
  _ignore_completion_names (names, name_func)
       char **names;
!      sh_ignore_func_t *name_func;
  {
    char **newnames;
***************
*** 1738,1742 ****
  static int
  name_is_acceptable (name)
!      char *name;
  {
    struct ign *p;
--- 1838,1842 ----
  static int
  name_is_acceptable (name)
!      const char *name;
  {
    struct ign *p;
***************
*** 1783,1787 ****
  static int
  test_for_directory (name)
!      char *name;
  {
    struct stat finfo;
--- 1883,1887 ----
  static int
  test_for_directory (name)
!      const char *name;
  {
    struct stat finfo;
***************
*** 1809,1813 ****
  static int
  return_zero (name)
!      char *name;
  {
    return 0;
--- 1909,1913 ----
  static int
  return_zero (name)
!      const char *name;
  {
    return 0;
***************
*** 1867,1871 ****
  	  free (new_dirname);
  	  free (local_dirname);
! 	  *dirname = xmalloc (1);
  	  **dirname = '\0';
  	  return 1;
--- 1967,1971 ----
  	  free (new_dirname);
  	  free (local_dirname);
! 	  *dirname = (char *)xmalloc (1);
  	  **dirname = '\0';
  	  return 1;
***************
*** 1892,1896 ****
  	{
  	  len2 = strlen (temp2);
! 	  temp2 = xrealloc (temp2, len2 + 2);
  	  temp2[len2] = '/';
  	  temp2[len2 + 1] = '\0';
--- 1992,1996 ----
  	{
  	  len2 = strlen (temp2);
! 	  temp2 = (char *)xrealloc (temp2, len2 + 2);
  	  temp2[len2] = '/';
  	  temp2[len2 + 1] = '\0';
***************
*** 1943,1947 ****
  		{
  		  harry_size += 10;
! 		  history_completion_array = (char **) xrealloc
  		    (history_completion_array, harry_size * sizeof (char *));
  		}
--- 2043,2047 ----
  		{
  		  harry_size += 10;
! 		  history_completion_array = (char **)xrealloc
  		    (history_completion_array, harry_size * sizeof (char *));
  		}
***************
*** 1954,1958 ****
  
        /* Sort the complete list of tokens. */
!       qsort (history_completion_array, harry_len, sizeof (char *), (Function *)qsort_string_compare);
      }
  }
--- 2054,2058 ----
  
        /* Sort the complete list of tokens. */
!       qsort (history_completion_array, harry_len, sizeof (char *), (QSFUNC *)qsort_string_compare);
      }
  }
***************
*** 1960,1968 ****
  static char *
  history_completion_generator (hint_text, state)
!      char *hint_text;
       int state;
  {
    static int local_index, len;
!   static char *text;
  
    /* If this is the first call to the generator, then initialize the
--- 2060,2068 ----
  static char *
  history_completion_generator (hint_text, state)
!      const char *hint_text;
       int state;
  {
    static int local_index, len;
!   static const char *text;
  
    /* If this is the first call to the generator, then initialize the
***************
*** 1988,1991 ****
--- 2088,2093 ----
       int count, key;
  {
+   int r;
+ 
    rl_compentry_func_t *orig_func;
    rl_completion_func_t *orig_attempt_func;
***************
*** 1997,2006 ****
  
    if (rl_last_func == dynamic_complete_history)
!     rl_complete_internal ('?');
    else
!     rl_complete_internal (TAB);
  
    rl_completion_entry_function = orig_func;
    rl_attempted_completion_function = orig_attempt_func;
  }
  
--- 2099,2109 ----
  
    if (rl_last_func == dynamic_complete_history)
!     r = rl_complete_internal ('?');
    else
!     r = rl_complete_internal (TAB);
  
    rl_completion_entry_function = orig_func;
    rl_attempted_completion_function = orig_attempt_func;
+   return r;
  }
  
***************
*** 2216,2220 ****
  
    l = strlen (text);
!   ret = xmalloc (l + 1);
    for (quoted = quote_char, p = text, r = ret; p && *p; p++)
      {
--- 2319,2323 ----
  
    l = strlen (text);
!   ret = (char *)xmalloc (l + 1);
    for (quoted = quote_char, p = text, r = ret; p && *p; p++)
      {
***************
*** 2256,2260 ****
  
    l = strlen (text);
!   ret = xmalloc ((2 * l) + 1);
    for (s = text, r = ret; *s; s++)
      {
--- 2359,2363 ----
  
    l = strlen (text);
!   ret = (char *)xmalloc ((2 * l) + 1);
    for (s = text, r = ret; *s; s++)
      {
***************
*** 2359,2363 ****
       care of avoiding doubled opening quotes. */
    rlen = strlen (rtext);
!   ret = xmalloc (rlen + 1);
    strcpy (ret, rtext);
  
--- 2462,2466 ----
       care of avoiding doubled opening quotes. */
    rlen = strlen (rtext);
!   ret = (char *)xmalloc (rlen + 1);
    strcpy (ret, rtext);
  
***************
*** 2485,2489 ****
    Keymap kmap;
    char *kseq, *value;
!   int i, kstart, len, ok;
  
    if (cmd_xmap == 0)
--- 2588,2592 ----
    Keymap kmap;
    char *kseq, *value;
!   int i, kstart;
  
    if (cmd_xmap == 0)
diff -Nrc2 bash-2.05/bashline.h bash-2.05a/bashline.h
*** bash-2.05/bashline.h	Mon Nov 27 12:23:19 2000
--- bash-2.05a/bashline.h	Mon Sep 10 13:45:18 2001
***************
*** 27,30 ****
--- 27,31 ----
  
  extern void posix_readline_initialize __P((int));
+ extern int enable_hostname_completion __P((int));
  extern void initialize_readline __P((void));
  extern void bashline_reinitialize __P((void));
***************
*** 35,38 ****
--- 36,40 ----
  /* Used by programmable completion code. */
  extern char *command_word_completion_function __P((const char *, int));
+ extern char *bash_groupname_completion_function __P((const char *, int));
  
  extern char **get_hostname_list __P((void));
diff -Nrc2 bash-2.05/bracecomp.c bash-2.05a/bracecomp.c
*** bash-2.05/bracecomp.c	Fri Nov  3 11:22:00 2000
--- bash-2.05a/bracecomp.c	Thu Aug  2 12:15:44 2001
***************
*** 40,45 ****
  #include <readline/readline.h>
  
- extern char *sh_backslash_quote ();
- 
  /* Find greatest common prefix of two strings. */
  static int
--- 40,43 ----
***************
*** 79,83 ****
      }
  
!   result = xmalloc (result_size = 16);
    *result = '\0';
  
--- 77,81 ----
      }
  
!   result = (char *)xmalloc (result_size = 16);
    *result = '\0';
  
***************
*** 103,107 ****
  	     top level, and there isn't a consistent prefix. */
  	  result_size += 1;
! 	  result = xrealloc (result, result_size);
  	  result[0] = '{'; result[1] = '\0';
  	  flag++;
--- 101,105 ----
  	     top level, and there isn't a consistent prefix. */
  	  result_size += 1;
! 	  result = (char *)xrealloc (result, result_size);
  	  result[0] = '{'; result[1] = '\0';
  	  flag++;
***************
*** 122,126 ****
  	     insert the (quoted) prefix and an opening brace. */
  	  tlen = gcd - gcd_zero;
! 	  x = xmalloc (tlen + 1);
  	  strncpy (x, array[start] + gcd_zero, tlen);
  	  x[tlen] = '\0';
--- 120,124 ----
  	     insert the (quoted) prefix and an opening brace. */
  	  tlen = gcd - gcd_zero;
! 	  x = (char *)xmalloc (tlen + 1);
  	  strncpy (x, array[start] + gcd_zero, tlen);
  	  x[tlen] = '\0';
***************
*** 128,132 ****
  	  free (x);
  	  result_size += strlen (subterm) + 1;
! 	  result = xrealloc (result, result_size);
  	  strcat (result, subterm);
  	  free (subterm);
--- 126,130 ----
  	  free (x);
  	  result_size += strlen (subterm) + 1;
! 	  result = (char *)xrealloc (result, result_size);
  	  strcat (result, subterm);
  	  free (subterm);
***************
*** 137,141 ****
  
        result_size += strlen (subterm) + 1;
!       result = xrealloc (result, result_size);
        strcat (result, subterm);
        strcat (result, ",");
--- 135,139 ----
  
        result_size += strlen (subterm) + 1;
!       result = (char *)xrealloc (result, result_size);
        strcat (result, subterm);
        strcat (result, ",");
diff -Nrc2 bash-2.05/braces.c bash-2.05a/braces.c
*** bash-2.05/braces.c	Wed Feb 14 16:51:23 2001
--- bash-2.05a/braces.c	Thu May 10 12:25:46 2001
***************
*** 41,48 ****
  #define brace_whitespace(c) (!(c) || (c) == ' ' || (c) == '\t' || (c) == '\n')
  
- #if defined (SHELL)
- extern char *extract_command_subst ();
- #endif
- 
  /* Basic idea:
  
--- 41,44 ----
***************
*** 57,62 ****
  int brace_arg_separator = ',';
  
  static int brace_gobbler ();
! static char **expand_amble (), **array_concat ();
  
  /* Return an array of strings; the brace expansion of TEXT. */
--- 53,65 ----
  int brace_arg_separator = ',';
  
+ #if defined (__P)
+ static int brace_gobbler __P((char *, int *, int));
+ static char **expand_amble __P((char *));
+ static char **array_concat __P((char **, char **));
+ #else
  static int brace_gobbler ();
! static char **expand_amble ();
! static char **array_concat ();
! #endif
  
  /* Return an array of strings; the brace expansion of TEXT. */
diff -Nrc2 bash-2.05/builtins/Makefile.in bash-2.05a/builtins/Makefile.in
*** bash-2.05/builtins/Makefile.in	Sat Oct 14 17:35:28 2000
--- bash-2.05a/builtins/Makefile.in	Tue Oct 23 14:32:18 2001
***************
*** 37,41 ****
  PROFILE_FLAGS = @PROFILE_FLAGS@
  CFLAGS = @CFLAGS@
! LOCAL_CFLAGS = @LOCAL_CFLAGS@
  CPPFLAGS = @CPPFLAGS@
  DEFS = @DEFS@
--- 37,41 ----
  PROFILE_FLAGS = @PROFILE_FLAGS@
  CFLAGS = @CFLAGS@
! LOCAL_CFLAGS = @LOCAL_CFLAGS@ ${DEBUG}
  CPPFLAGS = @CPPFLAGS@
  DEFS = @DEFS@
***************
*** 47,54 ****
  BASHINCDIR = ${topdir}/include
  
  INCLUDES = -I. -I.. @RL_INCLUDE@ -I$(topdir) -I$(BASHINCDIR) -I$(topdir)/lib -I$(srcdir)
  
! CCFLAGS = ${PROFILE_FLAGS} $(DEFS) $(LOCAL_DEFS) $(SYSTEM_FLAGS) $(CPPFLAGS) \
! 	  ${INCLUDES} $(LOCAL_CFLAGS) $(CFLAGS)
  
  MKBUILTINS = mkbuiltins$(EXEEXT)
--- 47,62 ----
  BASHINCDIR = ${topdir}/include
  
+ RL_INCLUDEDIR = @RL_INCLUDEDIR@
+ 
  INCLUDES = -I. -I.. @RL_INCLUDE@ -I$(topdir) -I$(BASHINCDIR) -I$(topdir)/lib -I$(srcdir)
  
! CCFLAGS_FOR_BUILD = ${PROFILE_FLAGS} $(DEFS) $(LOCAL_DEFS) $(SYSTEM_FLAGS) \
! 	$(CPPFLAGS) ${INCLUDES} $(LOCAL_CFLAGS)
! 
! CCFLAGS = $(CCFLAGS_FOR_BUILD) $(CFLAGS)
! 
! GCC_LINT_FLAGS = -Wall -Wshadow -Wpointer-arith -Wcast-qual \
! 		 -Wcast-align -Wstrict-prototypes -Wconversion \
! 		 -Wmissing-prototypes -Wtraditional -Wredundant-decls -pedantic
  
  MKBUILTINS = mkbuiltins$(EXEEXT)
***************
*** 132,136 ****
  mkbuiltins.o: mkbuiltins.c
  	$(RM) $@
! 	$(CC_FOR_BUILD) -c $(CCFLAGS) $<
  
  mkbuiltins$(EXEEXT): mkbuiltins.o
--- 140,144 ----
  mkbuiltins.o: mkbuiltins.c
  	$(RM) $@
! 	$(CC_FOR_BUILD) -c $(CCFLAGS_FOR_BUILD) $<
  
  mkbuiltins$(EXEEXT): mkbuiltins.o
***************
*** 152,156 ****
  
  psize.aux:	psize.c
! 	$(CC_FOR_BUILD) $(CCFLAGS) -o $@ $(srcdir)/psize.c
  
  documentation: builtins.texi
--- 160,164 ----
  
  psize.aux:	psize.c
! 	$(CC_FOR_BUILD) $(CCFLAGS_FOR_BUILD) -o $@ $(srcdir)/psize.c
  
  documentation: builtins.texi
***************
*** 215,228 ****
  bashgetopt.o: ../config.h $(topdir)/bashansi.h $(BASHINCDIR)/ansi_stdlib.h
  bashgetopt.o: $(topdir)/shell.h $(topdir)/syntax.h $(topdir)/bashjmp.h
! bashgetopt.o: $(topdir)/command.h $(topdir)/general.h $(topdir)/error.h
! bashgetopt.o: $(topdir)/variables.h $(topdir)/quit.h $(BASHINCDIR)/maxpath.h
  bashgetopt.o: $(topdir)/unwind_prot.h $(topdir)/dispose_cmd.h
  bashgetopt.o: $(topdir)/make_cmd.h $(topdir)/subst.h $(topdir)/sig.h
  bashgetopt.o: $(topdir)/pathnames.h $(topdir)/externs.h $(srcdir)/common.h
  common.o: $(topdir)/bashtypes.h $(BASHINCDIR)/posixstat.h $(topdir)/bashansi.h $(BASHINCDIR)/ansi_stdlib.h
  common.o: $(topdir)/shell.h $(topdir)/syntax.h ../config.h $(topdir)/bashjmp.h $(BASHINCDIR)/posixjmp.h
  common.o: $(topdir)/sig.h $(topdir)/command.h
! common.o: $(topdir)/general.h $(BASHINCDIR)/stdc.h $(BASHINCDIR)/memalloc.h
! common.o: $(topdir)/variables.h $(topdir)/input.h
  common.o: $(topdir)/siglist.h $(topdir)/bashhist.h $(topdir)/quit.h
  common.o: $(topdir)/unwind_prot.h $(BASHINCDIR)/maxpath.h $(topdir)/jobs.h
--- 223,237 ----
  bashgetopt.o: ../config.h $(topdir)/bashansi.h $(BASHINCDIR)/ansi_stdlib.h
  bashgetopt.o: $(topdir)/shell.h $(topdir)/syntax.h $(topdir)/bashjmp.h
! bashgetopt.o: $(topdir)/command.h $(topdir)/general.h $(topdir)/xmalloc.h $(topdir)/error.h
! bashgetopt.o: $(topdir)/variables.h $(topdir)/conftypes.h $(topdir)/quit.h $(BASHINCDIR)/maxpath.h
  bashgetopt.o: $(topdir)/unwind_prot.h $(topdir)/dispose_cmd.h
  bashgetopt.o: $(topdir)/make_cmd.h $(topdir)/subst.h $(topdir)/sig.h
  bashgetopt.o: $(topdir)/pathnames.h $(topdir)/externs.h $(srcdir)/common.h
+ bashgetopt.o: $(BASHINCDIR)/chartypes.h
  common.o: $(topdir)/bashtypes.h $(BASHINCDIR)/posixstat.h $(topdir)/bashansi.h $(BASHINCDIR)/ansi_stdlib.h
  common.o: $(topdir)/shell.h $(topdir)/syntax.h ../config.h $(topdir)/bashjmp.h $(BASHINCDIR)/posixjmp.h
  common.o: $(topdir)/sig.h $(topdir)/command.h
! common.o: $(topdir)/general.h $(topdir)/xmalloc.h $(BASHINCDIR)/stdc.h $(BASHINCDIR)/memalloc.h
! common.o: $(topdir)/variables.h $(topdir)/conftypes.h $(topdir)/input.h
  common.o: $(topdir)/siglist.h $(topdir)/bashhist.h $(topdir)/quit.h
  common.o: $(topdir)/unwind_prot.h $(BASHINCDIR)/maxpath.h $(topdir)/jobs.h
***************
*** 230,238 ****
  common.o: $(topdir)/subst.h $(topdir)/execute_cmd.h $(topdir)/error.h
  common.o: $(topdir)/externs.h $(topdir)/pathnames.h ./builtext.h
  evalfile.o: $(topdir)/bashtypes.h $(BASHINCDIR)/posixstat.h ${BASHINCDIR}/filecntl.h
  evalfile.o: $(topdir)/bashansi.h $(BASHINCDIR)/ansi_stdlib.h
  evalfile.o: $(topdir)/shell.h $(topdir)/syntax.h ../config.h $(topdir)/bashjmp.h
! evalfile.o: $(topdir)/command.h $(topdir)/general.h $(topdir)/error.h
! evalfile.o: $(topdir)/variables.h $(topdir)/quit.h $(BASHINCDIR)/maxpath.h
  evalfile.o: $(topdir)/unwind_prot.h $(topdir)/dispose_cmd.h
  evalfile.o: $(topdir)/make_cmd.h $(topdir)/subst.h $(topdir)/sig.h
--- 239,248 ----
  common.o: $(topdir)/subst.h $(topdir)/execute_cmd.h $(topdir)/error.h
  common.o: $(topdir)/externs.h $(topdir)/pathnames.h ./builtext.h
+ common.o: $(BASHINCDIR)/chartypes.h
  evalfile.o: $(topdir)/bashtypes.h $(BASHINCDIR)/posixstat.h ${BASHINCDIR}/filecntl.h
  evalfile.o: $(topdir)/bashansi.h $(BASHINCDIR)/ansi_stdlib.h
  evalfile.o: $(topdir)/shell.h $(topdir)/syntax.h ../config.h $(topdir)/bashjmp.h
! evalfile.o: $(topdir)/command.h $(topdir)/general.h $(topdir)/xmalloc.h $(topdir)/error.h
! evalfile.o: $(topdir)/variables.h $(topdir)/conftypes.h $(topdir)/quit.h $(BASHINCDIR)/maxpath.h
  evalfile.o: $(topdir)/unwind_prot.h $(topdir)/dispose_cmd.h
  evalfile.o: $(topdir)/make_cmd.h $(topdir)/subst.h $(topdir)/sig.h
***************
*** 244,248 ****
  evalstring.o: $(topdir)/shell.h $(topdir)/syntax.h $(topdir)/bashjmp.h $(BASHINCDIR)/posixjmp.h
  evalstring.o: $(topdir)/sig.h $(topdir)/command.h $(topdir)/siglist.h
! evalstring.o: $(BASHINCDIR)/memalloc.h $(topdir)/variables.h $(topdir)/input.h
  evalstring.o: $(topdir)/quit.h $(topdir)/unwind_prot.h
  evalstring.o: $(BASHINCDIR)/maxpath.h $(topdir)/jobs.h $(topdir)/builtins.h
--- 254,258 ----
  evalstring.o: $(topdir)/shell.h $(topdir)/syntax.h $(topdir)/bashjmp.h $(BASHINCDIR)/posixjmp.h
  evalstring.o: $(topdir)/sig.h $(topdir)/command.h $(topdir)/siglist.h
! evalstring.o: $(BASHINCDIR)/memalloc.h $(topdir)/variables.h $(topdir)/conftypes.h $(topdir)/input.h
  evalstring.o: $(topdir)/quit.h $(topdir)/unwind_prot.h
  evalstring.o: $(BASHINCDIR)/maxpath.h $(topdir)/jobs.h $(topdir)/builtins.h
***************
*** 251,257 ****
  evalstring.o: $(topdir)/flags.h $(topdir)/input.h $(topdir)/execute_cmd.h
  evalstring.o: $(topdir)/bashhist.h $(srcdir)/common.h
  getopt.o: ../config.h $(BASHINCDIR)/memalloc.h
  getopt.o: $(topdir)/shell.h $(topdir)/syntax.h $(topdir)/bashjmp.h $(topdir)/command.h
! getopt.o: $(topdir)/general.h $(topdir)/error.h $(topdir)/variables.h
  getopt.o: $(topdir)/quit.h $(BASHINCDIR)/maxpath.h $(topdir)/unwind_prot.h
  getopt.o: $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h $(topdir)/subst.h
--- 261,268 ----
  evalstring.o: $(topdir)/flags.h $(topdir)/input.h $(topdir)/execute_cmd.h
  evalstring.o: $(topdir)/bashhist.h $(srcdir)/common.h
+ evalstring.o: $(topdir)/trap.h $(topdir)/redir.h
  getopt.o: ../config.h $(BASHINCDIR)/memalloc.h
  getopt.o: $(topdir)/shell.h $(topdir)/syntax.h $(topdir)/bashjmp.h $(topdir)/command.h
! getopt.o: $(topdir)/general.h $(topdir)/xmalloc.h $(topdir)/error.h $(topdir)/variables.h $(topdir)/conftypes.h
  getopt.o: $(topdir)/quit.h $(BASHINCDIR)/maxpath.h $(topdir)/unwind_prot.h
  getopt.o: $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h $(topdir)/subst.h
***************
*** 264,333 ****
  # def files
  alias.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h
! alias.o: $(topdir)/error.h $(topdir)/general.h $(BASHINCDIR)/maxpath.h
  alias.o: $(topdir)/quit.h $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h
  alias.o: $(topdir)/subst.h $(topdir)/externs.h $(srcdir)/common.h
! alias.o: $(topdir)/shell.h $(topdir)/syntax.h $(topdir)/unwind_prot.h $(topdir)/variables.h
  bind.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h $(topdir)/error.h
  bind.o: $(topdir)/quit.h $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h
  bind.o: $(topdir)/subst.h $(topdir)/externs.h $(srcdir)/bashgetopt.h
! bind.o: $(topdir)/general.h $(BASHINCDIR)/maxpath.h $(topdir)/bashline.h
! bind.o: $(topdir)/shell.h $(topdir)/syntax.h $(topdir)/unwind_prot.h $(topdir)/variables.h 
  break.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h 
! break.o: $(topdir)/error.h $(topdir)/general.h
  break.o: $(topdir)/quit.h $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h
  break.o: $(topdir)/subst.h $(topdir)/externs.h $(BASHINCDIR)/maxpath.h
! break.o: $(topdir)/shell.h $(topdir)/syntax.h $(topdir)/unwind_prot.h $(topdir)/variables.h
  builtin.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h
! builtin.o: $(topdir)/error.h $(topdir)/general.h $(topdir)/externs.h
  builtin.o: $(topdir)/quit.h $(srcdir)/common.h $(BASHINCDIR)/maxpath.h
  builtin.o: $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h $(topdir)/subst.h
! builtin.o: $(topdir)/shell.h $(topdir)/syntax.h $(topdir)/unwind_prot.h $(topdir)/variables.h 
  cd.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h $(topdir)/error.h
! cd.o: $(topdir)/general.h $(topdir)/quit.h $(topdir)/dispose_cmd.h
  cd.o: $(topdir)/make_cmd.h $(topdir)/subst.h $(topdir)/externs.h
! cd.o: $(topdir)/shell.h $(topdir)/syntax.h $(topdir)/unwind_prot.h $(topdir)/variables.h
  cd.o: $(srcdir)/common.h $(BASHINCDIR)/maxpath.h
  command.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h
! command.o: $(topdir)/error.h $(topdir)/general.h $(topdir)/externs.h
  command.o: $(topdir)/quit.h $(srcdir)/bashgetopt.h $(BASHINCDIR)/maxpath.h
  command.o: $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h $(topdir)/subst.h
! command.o: $(topdir)/shell.h $(topdir)/syntax.h $(topdir)/unwind_prot.h $(topdir)/variables.h 
  declare.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h
! declare.o: $(topdir)/error.h $(topdir)/general.h
  declare.o: $(topdir)/quit.h $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h
  declare.o: $(topdir)/subst.h $(topdir)/externs.h $(BASHINCDIR)/maxpath.h
! declare.o: $(topdir)/shell.h $(topdir)/syntax.h $(topdir)/unwind_prot.h $(topdir)/variables.h
  echo.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h $(topdir)/error.h
! echo.o: $(topdir)/general.h $(topdir)/subst.h $(topdir)/externs.h
  echo.o: $(topdir)/quit.h $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h
! echo.o: $(topdir)/shell.h $(topdir)/syntax.h $(topdir)/unwind_prot.h $(topdir)/variables.h
  echo.o: $(BASHINCDIR)/maxpath.h
  enable.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h
! enable.o: $(topdir)/error.h $(topdir)/general.h
  enable.o: $(topdir)/quit.h $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h
  enable.o: $(topdir)/subst.h $(topdir)/externs.h
! enable.o: $(topdir)/shell.h $(topdir)/syntax.h $(topdir)/unwind_prot.h $(topdir)/variables.h
  enable.o: $(BASHINCDIR)/maxpath.h
  enable.o: $(topdir)/pcomplete.h
  eval.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h
! eval.o: $(topdir)/error.h $(topdir)/general.h
  eval.o: $(topdir)/quit.h $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h
  eval.o: $(topdir)/subst.h $(topdir)/externs.h
! eval.o: $(topdir)/shell.h $(topdir)/syntax.h $(topdir)/unwind_prot.h $(topdir)/variables.h
  eval.o: $(BASHINCDIR)/maxpath.h
  exec.o: $(topdir)/bashtypes.h
  exec.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h
! exec.o: $(topdir)/error.h $(topdir)/general.h
  exec.o: $(topdir)/quit.h $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h
  exec.o: $(topdir)/subst.h $(topdir)/externs.h $(topdir)/flags.h
! exec.o: $(topdir)/shell.h $(topdir)/syntax.h $(topdir)/unwind_prot.h $(topdir)/variables.h
  exec.o: $(srcdir)/common.h $(topdir)/execute_cmd.h $(BASHINCDIR)/maxpath.h
  exec.o: $(topdir)/findcmd.h
  exit.o: $(topdir)/bashtypes.h
  exit.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h
! exit.o: $(topdir)/error.h $(topdir)/general.h
  exit.o: $(topdir)/quit.h $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h
  exit.o: $(topdir)/subst.h $(topdir)/externs.h
! exit.o: $(topdir)/shell.h $(topdir)/syntax.h $(topdir)/unwind_prot.h $(topdir)/variables.h
  exit.o: $(BASHINCDIR)/maxpath.h ./builtext.h
  fc.o: $(topdir)/bashtypes.h $(BASHINCDIR)/posixstat.h
--- 275,345 ----
  # def files
  alias.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h
! alias.o: $(topdir)/error.h $(topdir)/general.h $(topdir)/xmalloc.h $(BASHINCDIR)/maxpath.h
  alias.o: $(topdir)/quit.h $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h
  alias.o: $(topdir)/subst.h $(topdir)/externs.h $(srcdir)/common.h
! alias.o: $(topdir)/shell.h $(topdir)/syntax.h $(topdir)/unwind_prot.h $(topdir)/variables.h $(topdir)/conftypes.h
  bind.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h $(topdir)/error.h
  bind.o: $(topdir)/quit.h $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h
  bind.o: $(topdir)/subst.h $(topdir)/externs.h $(srcdir)/bashgetopt.h
! bind.o: $(topdir)/general.h $(topdir)/xmalloc.h $(BASHINCDIR)/maxpath.h $(topdir)/bashline.h
! bind.o: $(topdir)/shell.h $(topdir)/syntax.h $(topdir)/unwind_prot.h $(topdir)/variables.h $(topdir)/conftypes.h 
  break.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h 
! break.o: $(topdir)/error.h $(topdir)/general.h $(topdir)/xmalloc.h
  break.o: $(topdir)/quit.h $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h
  break.o: $(topdir)/subst.h $(topdir)/externs.h $(BASHINCDIR)/maxpath.h
! break.o: $(topdir)/shell.h $(topdir)/syntax.h $(topdir)/unwind_prot.h $(topdir)/variables.h $(topdir)/conftypes.h
  builtin.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h
! builtin.o: $(topdir)/error.h $(topdir)/general.h $(topdir)/xmalloc.h $(topdir)/externs.h
  builtin.o: $(topdir)/quit.h $(srcdir)/common.h $(BASHINCDIR)/maxpath.h
  builtin.o: $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h $(topdir)/subst.h
! builtin.o: $(topdir)/shell.h $(topdir)/syntax.h $(topdir)/unwind_prot.h $(topdir)/variables.h $(topdir)/conftypes.h 
  cd.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h $(topdir)/error.h
! cd.o: $(topdir)/general.h $(topdir)/xmalloc.h $(topdir)/quit.h $(topdir)/dispose_cmd.h
  cd.o: $(topdir)/make_cmd.h $(topdir)/subst.h $(topdir)/externs.h
! cd.o: $(topdir)/shell.h $(topdir)/syntax.h $(topdir)/unwind_prot.h $(topdir)/variables.h $(topdir)/conftypes.h
  cd.o: $(srcdir)/common.h $(BASHINCDIR)/maxpath.h
  command.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h
! command.o: $(topdir)/error.h $(topdir)/general.h $(topdir)/xmalloc.h $(topdir)/externs.h
  command.o: $(topdir)/quit.h $(srcdir)/bashgetopt.h $(BASHINCDIR)/maxpath.h
  command.o: $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h $(topdir)/subst.h
! command.o: $(topdir)/shell.h $(topdir)/syntax.h $(topdir)/unwind_prot.h $(topdir)/variables.h $(topdir)/conftypes.h 
  declare.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h
! declare.o: $(topdir)/error.h $(topdir)/general.h $(topdir)/xmalloc.h
  declare.o: $(topdir)/quit.h $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h
  declare.o: $(topdir)/subst.h $(topdir)/externs.h $(BASHINCDIR)/maxpath.h
! declare.o: $(topdir)/shell.h $(topdir)/syntax.h $(topdir)/unwind_prot.h $(topdir)/variables.h $(topdir)/conftypes.h
! declare.o: $(topdir)/arrayfunc.h
  echo.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h $(topdir)/error.h
! echo.o: $(topdir)/general.h $(topdir)/xmalloc.h $(topdir)/subst.h $(topdir)/externs.h
  echo.o: $(topdir)/quit.h $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h
! echo.o: $(topdir)/shell.h $(topdir)/syntax.h $(topdir)/unwind_prot.h $(topdir)/variables.h $(topdir)/conftypes.h
  echo.o: $(BASHINCDIR)/maxpath.h
  enable.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h
! enable.o: $(topdir)/error.h $(topdir)/general.h $(topdir)/xmalloc.h
  enable.o: $(topdir)/quit.h $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h
  enable.o: $(topdir)/subst.h $(topdir)/externs.h
! enable.o: $(topdir)/shell.h $(topdir)/syntax.h $(topdir)/unwind_prot.h $(topdir)/variables.h $(topdir)/conftypes.h
  enable.o: $(BASHINCDIR)/maxpath.h
  enable.o: $(topdir)/pcomplete.h
  eval.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h
! eval.o: $(topdir)/error.h $(topdir)/general.h $(topdir)/xmalloc.h
  eval.o: $(topdir)/quit.h $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h
  eval.o: $(topdir)/subst.h $(topdir)/externs.h
! eval.o: $(topdir)/shell.h $(topdir)/syntax.h $(topdir)/unwind_prot.h $(topdir)/variables.h $(topdir)/conftypes.h
  eval.o: $(BASHINCDIR)/maxpath.h
  exec.o: $(topdir)/bashtypes.h
  exec.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h
! exec.o: $(topdir)/error.h $(topdir)/general.h $(topdir)/xmalloc.h
  exec.o: $(topdir)/quit.h $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h
  exec.o: $(topdir)/subst.h $(topdir)/externs.h $(topdir)/flags.h
! exec.o: $(topdir)/shell.h $(topdir)/syntax.h $(topdir)/unwind_prot.h $(topdir)/variables.h $(topdir)/conftypes.h
  exec.o: $(srcdir)/common.h $(topdir)/execute_cmd.h $(BASHINCDIR)/maxpath.h
  exec.o: $(topdir)/findcmd.h
  exit.o: $(topdir)/bashtypes.h
  exit.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h
! exit.o: $(topdir)/error.h $(topdir)/general.h $(topdir)/xmalloc.h
  exit.o: $(topdir)/quit.h $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h
  exit.o: $(topdir)/subst.h $(topdir)/externs.h
! exit.o: $(topdir)/shell.h $(topdir)/syntax.h $(topdir)/unwind_prot.h $(topdir)/variables.h $(topdir)/conftypes.h
  exit.o: $(BASHINCDIR)/maxpath.h ./builtext.h
  fc.o: $(topdir)/bashtypes.h $(BASHINCDIR)/posixstat.h
***************
*** 335,485 ****
  fc.o: $(topdir)/bashhist.h
  fc.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h $(topdir)/error.h
! fc.o: $(topdir)/general.h $(BASHINCDIR)/maxpath.h
  fc.o: $(topdir)/quit.h $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h
  fc.o: $(topdir)/subst.h $(topdir)/externs.h $(topdir)/shell.h $(topdir)/syntax.h
! fc.o: $(topdir)/flags.h $(topdir)/unwind_prot.h $(topdir)/variables.h
! fc.o: $(topdir)/bashansi.h $(BASHINCDIR)/ansi_stdlib.h
  fg_bg.o: $(topdir)/bashtypes.h
  fg_bg.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h
! fg_bg.o: $(topdir)/error.h $(topdir)/general.h
  fg_bg.o: $(topdir)/quit.h $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h
  fg_bg.o: $(topdir)/subst.h $(topdir)/externs.h $(BASHINCDIR)/maxpath.h
! fg_bg.o: $(topdir)/shell.h $(topdir)/syntax.h $(topdir)/unwind_prot.h $(topdir)/variables.h
  getopts.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h
! getopts.o: $(topdir)/error.h $(topdir)/general.h
  getopts.o: $(topdir)/quit.h $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h
  getopts.o: $(topdir)/subst.h $(topdir)/externs.h $(BASHINCDIR)/maxpath.h
! getopts.o: $(topdir)/shell.h $(topdir)/syntax.h $(topdir)/unwind_prot.h $(topdir)/variables.h
  hash.o: $(topdir)/builtins.h $(topdir)/command.h $(topdir)/quit.h
  hash.o: $(topdir)/findcmd.h $(topdir)/hashlib.h
  hash.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h
! hash.o: $(topdir)/error.h $(topdir)/general.h
! hash.o: $(topdir)/shell.h $(topdir)/syntax.h $(topdir)/unwind_prot.h $(topdir)/variables.h
  hash.o: $(srcdir)/common.h $(BASHINCDIR)/maxpath.h
  help.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h
! help.o: $(topdir)/error.h $(topdir)/general.h
  help.o: $(topdir)/quit.h $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h
  help.o: $(topdir)/subst.h $(topdir)/externs.h $(BASHINCDIR)/maxpath.h
! help.o: $(topdir)/shell.h $(topdir)/syntax.h $(topdir)/unwind_prot.h $(topdir)/variables.h
  history.o: $(topdir)/bashtypes.h
  history.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h
! history.o: $(topdir)/error.h $(topdir)/general.h
  history.o: $(topdir)/quit.h $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h
  history.o: $(topdir)/subst.h $(topdir)/externs.h
  history.o: ${BASHINCDIR}/filecntl.h $(topdir)/shell.h $(topdir)/syntax.h $(topdir)/unwind_prot.h
! history.o: $(topdir)/variables.h $(topdir)/bashhist.h $(BASHINCDIR)/maxpath.h
  inlib.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h
! inlib.o: $(topdir)/error.h $(topdir)/general.h
! inlib.o: $(topdir)/shell.h $(topdir)/syntax.h $(topdir)/unwind_prot.h $(topdir)/variables.h
  inlib.o: $(BASHINCDIR)/maxpath.h $(topdir)/subst.h $(topdir)/externs.h
  inlib.o: $(topdir)/quit.h $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h
  jobs.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h $(topdir)/error.h
! jobs.o: $(topdir)/general.h $(topdir)/quit.h $(srcdir)/bashgetopt.h
  jobs.o: $(BASHINCDIR)/maxpath.h $(topdir)/externs.h
  jobs.o: $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h $(topdir)/subst.h
! jobs.o: $(topdir)/shell.h $(topdir)/syntax.h $(topdir)/unwind_prot.h $(topdir)/variables.h 
  kill.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h $(topdir)/error.h
! kill.o: $(topdir)/general.h $(topdir)/subst.h $(topdir)/externs.h
  kill.o: $(topdir)/quit.h $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h
  kill.o: $(topdir)/shell.h $(topdir)/syntax.h $(topdir)/trap.h $(topdir)/unwind_prot.h
! kill.o: $(topdir)/variables.h $(BASHINCDIR)/maxpath.h
  let.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h
! let.o: $(topdir)/error.h $(topdir)/general.h
  let.o: $(topdir)/quit.h $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h
  let.o: $(topdir)/subst.h $(topdir)/externs.h $(BASHINCDIR)/maxpath.h
! let.o: $(topdir)/shell.h $(topdir)/syntax.h $(topdir)/unwind_prot.h $(topdir)/variables.h
  printf.o: ../config.h $(BASHINCDIR)/memalloc.h $(topdir)/bashjmp.h
! printf.o: $(topdir)/command.h $(topdir)/error.h $(topdir)/general.h
  printf.o: $(topdir)/quit.h $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h
  printf.o: $(topdir)/subst.h $(topdir)/externs.h $(topdir)/sig.h
  printf.o: $(topdir)/pathnames.h $(topdir)/shell.h $(topdir)/syntax.h $(topdir)/unwind_prot.h
! printf.o: $(topdir)/variables.h $(BASHINCDIR)/stdc.h $(srcdir)/bashgetopt.h
  pushd.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h
! pushd.o: $(topdir)/error.h $(topdir)/general.h
  pushd.o: $(topdir)/quit.h $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h
  pushd.o: $(topdir)/subst.h $(topdir)/externs.h
! pushd.o: $(topdir)/shell.h $(topdir)/syntax.h $(topdir)/unwind_prot.h $(topdir)/variables.h
  pushd.o: $(BASHINCDIR)/maxpath.h $(srcdir)/common.h ./builtext.h
  read.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h
! read.o: $(topdir)/error.h $(topdir)/general.h
  read.o: $(topdir)/quit.h $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h
  read.o: $(topdir)/subst.h $(topdir)/externs.h $(BASHINCDIR)/maxpath.h
! read.o: $(topdir)/shell.h $(topdir)/syntax.h $(topdir)/unwind_prot.h $(topdir)/variables.h
  read.o: $(BASHINCDIR)/shtty.h
  return.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h
! return.o: $(topdir)/error.h $(topdir)/general.h
  return.o: $(topdir)/quit.h $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h
  return.o: $(topdir)/subst.h $(topdir)/externs.h $(BASHINCDIR)/maxpath.h
! return.o: $(topdir)/shell.h $(topdir)/syntax.h $(topdir)/unwind_prot.h $(topdir)/variables.h
  set.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h
! set.o: $(topdir)/general.h $(topdir)/subst.h $(topdir)/externs.h
  set.o: $(topdir)/quit.h $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h
! set.o: $(topdir)/shell.h $(topdir)/syntax.h $(topdir)/unwind_prot.h $(topdir)/variables.h
  set.o: $(BASHINCDIR)/maxpath.h $(topdir)/error.h
  setattr.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h
! setattr.o: $(topdir)/error.h $(topdir)/general.h $(BASHINCDIR)/maxpath.h
  setattr.o: $(topdir)/quit.h $(srcdir)/common.h $(srcdir)/bashgetopt.h
  setattr.o: $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h $(topdir)/subst.h
  setattr.o: $(topdir)/externs.h
! setattr.o: $(topdir)/shell.h $(topdir)/syntax.h $(topdir)/unwind_prot.h $(topdir)/variables.h 
  shift.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h
! shift.o: $(topdir)/error.h $(topdir)/general.h
  shift.o: $(topdir)/quit.h $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h
  shift.o: $(topdir)/subst.h $(topdir)/externs.h $(BASHINCDIR)/maxpath.h
! shift.o: $(topdir)/shell.h $(topdir)/syntax.h $(topdir)/unwind_prot.h $(topdir)/variables.h
  source.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h
! source.o: $(topdir)/error.h $(topdir)/general.h $(topdir)/findcmd.h
  source.o: $(topdir)/quit.h $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h
  source.o: $(topdir)/subst.h $(topdir)/externs.h $(BASHINCDIR)/maxpath.h
! source.o: $(topdir)/shell.h $(topdir)/syntax.h $(topdir)/unwind_prot.h $(topdir)/variables.h
  suspend.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h
! suspend.o: $(topdir)/error.h $(topdir)/general.h
  suspend.o: $(topdir)/quit.h $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h
  suspend.o: $(topdir)/subst.h $(topdir)/externs.h $(BASHINCDIR)/maxpath.h
! suspend.o: $(topdir)/shell.h $(topdir)/syntax.h $(topdir)/unwind_prot.h $(topdir)/variables.h
  test.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h
! test.o: $(topdir)/error.h $(topdir)/general.h
  test.o: $(topdir)/quit.h $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h
  test.o: $(topdir)/subst.h $(topdir)/externs.h $(BASHINCDIR)/maxpath.h
! test.o: $(topdir)/shell.h $(topdir)/syntax.h $(topdir)/unwind_prot.h $(topdir)/variables.h
  test.o: $(topdir)/test.h
  times.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h
! times.o: $(topdir)/error.h $(topdir)/general.h
  times.o: $(topdir)/quit.h $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h
  times.o: $(topdir)/subst.h $(topdir)/externs.h $(BASHINCDIR)/maxpath.h
! times.o: $(topdir)/shell.h $(topdir)/syntax.h $(topdir)/unwind_prot.h $(topdir)/variables.h
  times.o: $(BASHINCDIR)/posixtime.h
  trap.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h
! trap.o: $(topdir)/error.h $(topdir)/general.h $(topdir)/externs.h
  trap.o: $(topdir)/quit.h $(srcdir)/common.h $(BASHINCDIR)/maxpath.h
  trap.o: $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h $(topdir)/subst.h
! trap.o: $(topdir)/shell.h $(topdir)/syntax.h $(topdir)/unwind_prot.h $(topdir)/variables.h
  trap.o: $(topdir)/findcmd.h
  type.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h
! type.o: $(topdir)/error.h $(topdir)/general.h
  type.o: $(topdir)/quit.h $(srcdir)/common.h $(BASHINCDIR)/maxpath.h
  type.o: $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h $(topdir)/subst.h
  type.o: $(topdir)/externs.h $(topdir)/hashcmd.h
! type.o: $(topdir)/shell.h $(topdir)/syntax.h $(topdir)/unwind_prot.h $(topdir)/variables.h 
  ulimit.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h
! ulimit.o: $(topdir)/error.h $(topdir)/general.h
  ulimit.o: $(topdir)/quit.h $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h
  ulimit.o: $(topdir)/subst.h $(topdir)/externs.h $(BASHINCDIR)/maxpath.h
! ulimit.o: $(topdir)/shell.h $(topdir)/syntax.h $(topdir)/unwind_prot.h $(topdir)/variables.h
  umask.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h
! umask.o: $(topdir)/error.h $(topdir)/general.h
  umask.o: $(topdir)/quit.h $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h
  umask.o: $(topdir)/subst.h $(topdir)/externs.h $(BASHINCDIR)/maxpath.h
! umask.o: $(topdir)/shell.h $(topdir)/syntax.h $(topdir)/unwind_prot.h $(topdir)/variables.h
  wait.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h
! wait.o: $(topdir)/error.h $(topdir)/general.h
  wait.o: $(topdir)/quit.h $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h
  wait.o: $(topdir)/subst.h $(topdir)/externs.h $(BASHINCDIR)/maxpath.h
! wait.o: $(topdir)/shell.h $(topdir)/syntax.h $(topdir)/unwind_prot.h $(topdir)/variables.h
  shopt.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h
! shopt.o: $(topdir)/error.h $(topdir)/general.h 
  shopt.o: $(topdir)/quit.h $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h
  shopt.o: $(topdir)/subst.h $(topdir)/externs.h $(BASHINCDIR)/maxpath.h
! shopt.o: $(topdir)/shell.h $(topdir)/syntax.h $(topdir)/unwind_prot.h $(topdir)/variables.h
  shopt.o: $(srcdir)/common.h $(srcdir)/bashgetopt.h
  
--- 347,504 ----
  fc.o: $(topdir)/bashhist.h
  fc.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h $(topdir)/error.h
! fc.o: $(topdir)/general.h $(topdir)/xmalloc.h $(BASHINCDIR)/maxpath.h
  fc.o: $(topdir)/quit.h $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h
  fc.o: $(topdir)/subst.h $(topdir)/externs.h $(topdir)/shell.h $(topdir)/syntax.h
! fc.o: $(topdir)/flags.h $(topdir)/unwind_prot.h $(topdir)/variables.h $(topdir)/conftypes.h
! fc.o: $(topdir)/bashansi.h $(BASHINCDIR)/ansi_stdlib.h $(BASHINCDIR)/chartypes.h
  fg_bg.o: $(topdir)/bashtypes.h
  fg_bg.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h
! fg_bg.o: $(topdir)/error.h $(topdir)/general.h $(topdir)/xmalloc.h
  fg_bg.o: $(topdir)/quit.h $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h
  fg_bg.o: $(topdir)/subst.h $(topdir)/externs.h $(BASHINCDIR)/maxpath.h
! fg_bg.o: $(topdir)/shell.h $(topdir)/syntax.h $(topdir)/unwind_prot.h $(topdir)/variables.h $(topdir)/conftypes.h
  getopts.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h
! getopts.o: $(topdir)/error.h $(topdir)/general.h $(topdir)/xmalloc.h
  getopts.o: $(topdir)/quit.h $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h
  getopts.o: $(topdir)/subst.h $(topdir)/externs.h $(BASHINCDIR)/maxpath.h
! getopts.o: $(topdir)/shell.h $(topdir)/syntax.h $(topdir)/unwind_prot.h $(topdir)/variables.h $(topdir)/conftypes.h
  hash.o: $(topdir)/builtins.h $(topdir)/command.h $(topdir)/quit.h
  hash.o: $(topdir)/findcmd.h $(topdir)/hashlib.h
  hash.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h
! hash.o: $(topdir)/error.h $(topdir)/general.h $(topdir)/xmalloc.h
! hash.o: $(topdir)/shell.h $(topdir)/syntax.h $(topdir)/unwind_prot.h $(topdir)/variables.h $(topdir)/conftypes.h
  hash.o: $(srcdir)/common.h $(BASHINCDIR)/maxpath.h
  help.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h
! help.o: $(topdir)/error.h $(topdir)/general.h $(topdir)/xmalloc.h
  help.o: $(topdir)/quit.h $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h
  help.o: $(topdir)/subst.h $(topdir)/externs.h $(BASHINCDIR)/maxpath.h
! help.o: $(topdir)/shell.h $(topdir)/syntax.h $(topdir)/unwind_prot.h $(topdir)/variables.h $(topdir)/conftypes.h
! help.o: ${srcdir}/common.h ../version.h
  history.o: $(topdir)/bashtypes.h
  history.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h
! history.o: $(topdir)/error.h $(topdir)/general.h $(topdir)/xmalloc.h
  history.o: $(topdir)/quit.h $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h
  history.o: $(topdir)/subst.h $(topdir)/externs.h
  history.o: ${BASHINCDIR}/filecntl.h $(topdir)/shell.h $(topdir)/syntax.h $(topdir)/unwind_prot.h
! history.o: $(topdir)/variables.h $(topdir)/conftypes.h $(topdir)/bashhist.h $(BASHINCDIR)/maxpath.h
  inlib.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h
! inlib.o: $(topdir)/error.h $(topdir)/general.h $(topdir)/xmalloc.h
! inlib.o: $(topdir)/shell.h $(topdir)/syntax.h $(topdir)/unwind_prot.h $(topdir)/variables.h $(topdir)/conftypes.h
  inlib.o: $(BASHINCDIR)/maxpath.h $(topdir)/subst.h $(topdir)/externs.h
  inlib.o: $(topdir)/quit.h $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h
  jobs.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h $(topdir)/error.h
! jobs.o: $(topdir)/general.h $(topdir)/xmalloc.h $(topdir)/quit.h $(srcdir)/bashgetopt.h
  jobs.o: $(BASHINCDIR)/maxpath.h $(topdir)/externs.h
  jobs.o: $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h $(topdir)/subst.h
! jobs.o: $(topdir)/shell.h $(topdir)/syntax.h $(topdir)/unwind_prot.h $(topdir)/variables.h $(topdir)/conftypes.h 
  kill.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h $(topdir)/error.h
! kill.o: $(topdir)/general.h $(topdir)/xmalloc.h $(topdir)/subst.h $(topdir)/externs.h
  kill.o: $(topdir)/quit.h $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h
  kill.o: $(topdir)/shell.h $(topdir)/syntax.h $(topdir)/trap.h $(topdir)/unwind_prot.h
! kill.o: $(topdir)/variables.h $(topdir)/conftypes.h $(BASHINCDIR)/maxpath.h
  let.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h
! let.o: $(topdir)/error.h $(topdir)/general.h $(topdir)/xmalloc.h
  let.o: $(topdir)/quit.h $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h
  let.o: $(topdir)/subst.h $(topdir)/externs.h $(BASHINCDIR)/maxpath.h
! let.o: $(topdir)/shell.h $(topdir)/syntax.h $(topdir)/unwind_prot.h $(topdir)/variables.h $(topdir)/conftypes.h
  printf.o: ../config.h $(BASHINCDIR)/memalloc.h $(topdir)/bashjmp.h
! printf.o: $(topdir)/command.h $(topdir)/error.h $(topdir)/general.h $(topdir)/xmalloc.h
  printf.o: $(topdir)/quit.h $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h
  printf.o: $(topdir)/subst.h $(topdir)/externs.h $(topdir)/sig.h
  printf.o: $(topdir)/pathnames.h $(topdir)/shell.h $(topdir)/syntax.h $(topdir)/unwind_prot.h
! printf.o: $(topdir)/variables.h $(topdir)/conftypes.h $(BASHINCDIR)/stdc.h $(srcdir)/bashgetopt.h
! printf.o: $(topdir)/bashtypes.h ${srcdir}/common.h $(BASHINCDIR)/chartypes.h
  pushd.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h
! pushd.o: $(topdir)/error.h $(topdir)/general.h $(topdir)/xmalloc.h
  pushd.o: $(topdir)/quit.h $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h
  pushd.o: $(topdir)/subst.h $(topdir)/externs.h
! pushd.o: $(topdir)/shell.h $(topdir)/syntax.h $(topdir)/unwind_prot.h $(topdir)/variables.h $(topdir)/conftypes.h
  pushd.o: $(BASHINCDIR)/maxpath.h $(srcdir)/common.h ./builtext.h
  read.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h
! read.o: $(topdir)/error.h $(topdir)/general.h $(topdir)/xmalloc.h
  read.o: $(topdir)/quit.h $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h
  read.o: $(topdir)/subst.h $(topdir)/externs.h $(BASHINCDIR)/maxpath.h
! read.o: $(topdir)/shell.h $(topdir)/syntax.h $(topdir)/unwind_prot.h $(topdir)/variables.h $(topdir)/conftypes.h
  read.o: $(BASHINCDIR)/shtty.h
+ read.o: $(topdir)/arrayfunc.h
  return.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h
! return.o: $(topdir)/error.h $(topdir)/general.h $(topdir)/xmalloc.h
  return.o: $(topdir)/quit.h $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h
  return.o: $(topdir)/subst.h $(topdir)/externs.h $(BASHINCDIR)/maxpath.h
! return.o: $(topdir)/shell.h $(topdir)/syntax.h $(topdir)/unwind_prot.h $(topdir)/variables.h $(topdir)/conftypes.h
  set.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h
! set.o: $(topdir)/general.h $(topdir)/xmalloc.h $(topdir)/subst.h $(topdir)/externs.h
  set.o: $(topdir)/quit.h $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h
! set.o: $(topdir)/shell.h $(topdir)/syntax.h $(topdir)/unwind_prot.h $(topdir)/variables.h $(topdir)/conftypes.h
  set.o: $(BASHINCDIR)/maxpath.h $(topdir)/error.h
+ set.o: $(topdir)/arrayfunc.h
  setattr.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h
! setattr.o: $(topdir)/error.h $(topdir)/general.h $(topdir)/xmalloc.h $(BASHINCDIR)/maxpath.h
  setattr.o: $(topdir)/quit.h $(srcdir)/common.h $(srcdir)/bashgetopt.h
  setattr.o: $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h $(topdir)/subst.h
  setattr.o: $(topdir)/externs.h
! setattr.o: $(topdir)/shell.h $(topdir)/syntax.h $(topdir)/unwind_prot.h $(topdir)/variables.h $(topdir)/conftypes.h 
! setattr.o: $(topdir)/arrayfunc.h
  shift.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h
! shift.o: $(topdir)/error.h $(topdir)/general.h $(topdir)/xmalloc.h
  shift.o: $(topdir)/quit.h $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h
  shift.o: $(topdir)/subst.h $(topdir)/externs.h $(BASHINCDIR)/maxpath.h
! shift.o: $(topdir)/shell.h $(topdir)/syntax.h $(topdir)/unwind_prot.h $(topdir)/variables.h $(topdir)/conftypes.h
  source.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h
! source.o: $(topdir)/error.h $(topdir)/general.h $(topdir)/xmalloc.h $(topdir)/findcmd.h
  source.o: $(topdir)/quit.h $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h
  source.o: $(topdir)/subst.h $(topdir)/externs.h $(BASHINCDIR)/maxpath.h
! source.o: $(topdir)/shell.h $(topdir)/syntax.h $(topdir)/unwind_prot.h $(topdir)/variables.h $(topdir)/conftypes.h
  suspend.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h
! suspend.o: $(topdir)/error.h $(topdir)/general.h $(topdir)/xmalloc.h
  suspend.o: $(topdir)/quit.h $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h
  suspend.o: $(topdir)/subst.h $(topdir)/externs.h $(BASHINCDIR)/maxpath.h
! suspend.o: $(topdir)/shell.h $(topdir)/syntax.h $(topdir)/unwind_prot.h $(topdir)/variables.h $(topdir)/conftypes.h
  test.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h
! test.o: $(topdir)/error.h $(topdir)/general.h $(topdir)/xmalloc.h
  test.o: $(topdir)/quit.h $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h
  test.o: $(topdir)/subst.h $(topdir)/externs.h $(BASHINCDIR)/maxpath.h
! test.o: $(topdir)/shell.h $(topdir)/syntax.h $(topdir)/unwind_prot.h $(topdir)/variables.h $(topdir)/conftypes.h
  test.o: $(topdir)/test.h
  times.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h
! times.o: $(topdir)/error.h $(topdir)/general.h $(topdir)/xmalloc.h
  times.o: $(topdir)/quit.h $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h
  times.o: $(topdir)/subst.h $(topdir)/externs.h $(BASHINCDIR)/maxpath.h
! times.o: $(topdir)/shell.h $(topdir)/syntax.h $(topdir)/unwind_prot.h $(topdir)/variables.h $(topdir)/conftypes.h
  times.o: $(BASHINCDIR)/posixtime.h
  trap.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h
! trap.o: $(topdir)/error.h $(topdir)/general.h $(topdir)/xmalloc.h $(topdir)/externs.h
  trap.o: $(topdir)/quit.h $(srcdir)/common.h $(BASHINCDIR)/maxpath.h
  trap.o: $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h $(topdir)/subst.h
! trap.o: $(topdir)/shell.h $(topdir)/syntax.h $(topdir)/unwind_prot.h $(topdir)/variables.h $(topdir)/conftypes.h
  trap.o: $(topdir)/findcmd.h
  type.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h
! type.o: $(topdir)/error.h $(topdir)/general.h $(topdir)/xmalloc.h
  type.o: $(topdir)/quit.h $(srcdir)/common.h $(BASHINCDIR)/maxpath.h
  type.o: $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h $(topdir)/subst.h
  type.o: $(topdir)/externs.h $(topdir)/hashcmd.h
! type.o: $(topdir)/shell.h $(topdir)/syntax.h $(topdir)/unwind_prot.h $(topdir)/variables.h $(topdir)/conftypes.h 
  ulimit.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h
! ulimit.o: $(topdir)/error.h $(topdir)/general.h $(topdir)/xmalloc.h
  ulimit.o: $(topdir)/quit.h $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h
  ulimit.o: $(topdir)/subst.h $(topdir)/externs.h $(BASHINCDIR)/maxpath.h
! ulimit.o: $(topdir)/shell.h $(topdir)/syntax.h $(topdir)/unwind_prot.h $(topdir)/variables.h $(topdir)/conftypes.h
  umask.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h
! umask.o: $(topdir)/error.h $(topdir)/general.h $(topdir)/xmalloc.h
  umask.o: $(topdir)/quit.h $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h
  umask.o: $(topdir)/subst.h $(topdir)/externs.h $(BASHINCDIR)/maxpath.h
! umask.o: $(topdir)/shell.h $(topdir)/syntax.h $(topdir)/unwind_prot.h $(topdir)/variables.h $(topdir)/conftypes.h
! umask.o: $(BASHINCDIR)/chartypes.h
  wait.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h
! wait.o: $(topdir)/error.h $(topdir)/general.h $(topdir)/xmalloc.h
  wait.o: $(topdir)/quit.h $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h
  wait.o: $(topdir)/subst.h $(topdir)/externs.h $(BASHINCDIR)/maxpath.h
! wait.o: $(topdir)/shell.h $(topdir)/syntax.h $(topdir)/unwind_prot.h $(topdir)/variables.h $(topdir)/conftypes.h
! wait.o: $(BASHINCDIR)/chartypes.h
  shopt.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h
! shopt.o: $(topdir)/error.h $(topdir)/general.h $(topdir)/xmalloc.h 
  shopt.o: $(topdir)/quit.h $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h
  shopt.o: $(topdir)/subst.h $(topdir)/externs.h $(BASHINCDIR)/maxpath.h
! shopt.o: $(topdir)/shell.h $(topdir)/syntax.h $(topdir)/unwind_prot.h $(topdir)/variables.h $(topdir)/conftypes.h
  shopt.o: $(srcdir)/common.h $(srcdir)/bashgetopt.h
  
diff -Nrc2 bash-2.05/builtins/alias.def bash-2.05a/builtins/alias.def
*** bash-2.05/builtins/alias.def	Fri Nov  3 11:18:42 2000
--- bash-2.05a/builtins/alias.def	Tue Sep 11 15:26:14 2001
***************
*** 52,57 ****
  #  include "bashgetopt.h"
  
! extern int interactive;
! static void print_alias ();
  
  /* Hack the alias command in a Korn shell way. */
--- 52,56 ----
  #  include "bashgetopt.h"
  
! static void print_alias __P((alias_t *));
  
  /* Hack the alias command in a Korn shell way. */
diff -Nrc2 bash-2.05/builtins/bashgetopt.c bash-2.05a/builtins/bashgetopt.c
*** bash-2.05/builtins/bashgetopt.c	Thu Aug  5 07:39:28 1999
--- bash-2.05a/builtins/bashgetopt.c	Wed Sep 12 11:56:33 2001
***************
*** 26,29 ****
--- 26,30 ----
  
  #include "../bashansi.h"
+ #include <chartypes.h>
  #include <errno.h>
  
***************
*** 125,129 ****
  		/* optional numeric argument */
  		if (lcurrent->word->word[sp+1]) {
! 			if (digit(lcurrent->word->word[sp+1])) {
  				list_optarg = lcurrent->word->word + sp + 1;
  				lcurrent = lcurrent->next;
--- 126,130 ----
  		/* optional numeric argument */
  		if (lcurrent->word->word[sp+1]) {
! 			if (DIGIT(lcurrent->word->word[sp+1])) {
  				list_optarg = lcurrent->word->word + sp + 1;
  				lcurrent = lcurrent->next;
diff -Nrc2 bash-2.05/builtins/bashgetopt.h bash-2.05a/builtins/bashgetopt.h
*** bash-2.05/builtins/bashgetopt.h	Thu Aug  5 07:28:57 1999
--- bash-2.05a/builtins/bashgetopt.h	Tue Sep 11 15:25:47 2001
***************
*** 24,27 ****
--- 24,29 ----
  #  define __BASH_GETOPT_H
  
+ #include <stdc.h>
+ 
  extern char *list_optarg;
  
***************
*** 31,37 ****
  extern WORD_LIST *loptend;
  
! extern int internal_getopt ();
! extern void reset_internal_getopt ();
! extern void report_bad_option ();
  
  #endif /* !__BASH_GETOPT_H */
--- 33,39 ----
  extern WORD_LIST *loptend;
  
! extern int internal_getopt __P((WORD_LIST *, char *));
! extern void reset_internal_getopt __P((void));
! extern void report_bad_option __P((void));
  
  #endif /* !__BASH_GETOPT_H */
diff -Nrc2 bash-2.05/builtins/bind.def bash-2.05a/builtins/bind.def
*** bash-2.05/builtins/bind.def	Wed Feb 14 17:07:33 2001
--- bash-2.05a/builtins/bind.def	Tue Aug 28 13:03:19 2001
***************
*** 77,82 ****
  #include "common.h"
  
! static int query_bindings ();
! static int unbind_command ();
  
  extern int no_line_editing;
--- 77,82 ----
  #include "common.h"
  
! static int query_bindings __P((char *));
! static int unbind_command __P((char *));
  
  extern int no_line_editing;
***************
*** 103,107 ****
  {
    int return_code;
-   FILE *old_rl_outstream;
    Keymap kmap, saved_keymap;
    int flags, opt;
--- 103,106 ----
***************
*** 119,126 ****
      initialize_readline ();
  
!   /* Cannot use unwind_protect_pointer () on "FILE *", it is only
!      guaranteed to work for strings. */
!   /* XXX -- see if we can use unwind_protect here */
!   old_rl_outstream = rl_outstream;
    rl_outstream = stdout;
  
--- 118,124 ----
      initialize_readline ();
  
!   begin_unwind_frame ("bind_builtin");
!   unwind_protect_var (rl_outstream);
! 
    rl_outstream = stdout;
  
***************
*** 243,247 ****
    if ((flags & RFLAG) && remove_seq)
      {
!       if (rl_set_key (remove_seq, (Function *)NULL, rl_get_keymap ()) != 0)
  	{
  	  builtin_error ("cannot unbind %s", remove_seq);
--- 241,245 ----
    if ((flags & RFLAG) && remove_seq)
      {
!       if (rl_set_key (remove_seq, (rl_command_func_t *)NULL, rl_get_keymap ()) != 0)
  	{
  	  builtin_error ("cannot unbind %s", remove_seq);
***************
*** 264,268 ****
      rl_set_keymap (saved_keymap);
  
!   rl_outstream = old_rl_outstream;
    return (return_code);
  }
--- 262,267 ----
      rl_set_keymap (saved_keymap);
  
!   run_unwind_frame ("bind_builtin");
! 
    return (return_code);
  }
***************
*** 272,276 ****
       char *name;
  {
!   Function *function;
    char **keyseqs;
    int j;
--- 271,275 ----
       char *name;
  {
!   rl_command_func_t *function;
    char **keyseqs;
    int j;
***************
*** 304,308 ****
       char *name;
  {
!   Function *function;
  
    function = rl_named_function (name);
--- 303,307 ----
       char *name;
  {
!   rl_command_func_t *function;
  
    function = rl_named_function (name);
diff -Nrc2 bash-2.05/builtins/break.def bash-2.05a/builtins/break.def
*** bash-2.05/builtins/break.def	Wed Feb 21 12:03:00 2001
--- bash-2.05a/builtins/break.def	Mon May 21 15:26:47 2001
***************
*** 43,47 ****
  extern int posixly_correct;
  
! static int check_loop_level ();
  
  /* The depth of while's and until's. */
--- 43,47 ----
  extern int posixly_correct;
  
! static int check_loop_level __P((void));
  
  /* The depth of while's and until's. */
***************
*** 60,64 ****
       WORD_LIST *list;
  {
!   int newbreak;
  
    if (check_loop_level () == 0)
--- 60,64 ----
       WORD_LIST *list;
  {
!   long newbreak;
  
    if (check_loop_level () == 0)
***************
*** 95,99 ****
       WORD_LIST *list;
  {
!   int newcont;
  
    if (check_loop_level () == 0)
--- 95,99 ----
       WORD_LIST *list;
  {
!   long newcont;
  
    if (check_loop_level () == 0)
diff -Nrc2 bash-2.05/builtins/builtin.def bash-2.05a/builtins/builtin.def
*** bash-2.05/builtins/builtin.def	Thu Aug  5 07:39:51 1999
--- bash-2.05a/builtins/builtin.def	Tue Aug 28 13:02:02 2001
***************
*** 49,53 ****
       WORD_LIST *list;
  {
!   Function *function;
    register char *command;
  
--- 49,53 ----
       WORD_LIST *list;
  {
!   sh_builtin_func_t *function;
    register char *command;
  
diff -Nrc2 bash-2.05/builtins/cd.def bash-2.05a/builtins/cd.def
*** bash-2.05/builtins/cd.def	Wed Oct 11 11:10:20 2000
--- bash-2.05a/builtins/cd.def	Tue Sep 11 16:22:46 2001
***************
*** 54,64 ****
  #endif /* !errno */
  
! extern int posixly_correct, interactive;
  extern int array_needs_making;
  extern char *bash_getcwd_errstr;
  
! static int change_to_directory ();
  
! static char *cdspell ();
  
  /* Change this to 1 to get cd spelling correction by default. */
--- 54,65 ----
  #endif /* !errno */
  
! extern int posixly_correct;
  extern int array_needs_making;
  extern char *bash_getcwd_errstr;
  
! static int bindpwd __P((int));
! static int change_to_directory __P((char *, int));
  
! static char *cdspell __P((char *));
  
  /* Change this to 1 to get cd spelling correction by default. */
***************
*** 88,92 ****
  {
    char *dirname, *pwdvar;
!   int old_symlinks, old_anm;
    SHELL_VAR *tvar;
  
--- 89,93 ----
  {
    char *dirname, *pwdvar;
!   int old_anm;
    SHELL_VAR *tvar;
  
***************
*** 425,429 ****
  
    n = (strlen (dirname) * 3 + 1) / 2 + 1;
!   guess = xmalloc (n);
  
    switch (spname (dirname, guess))
--- 426,430 ----
  
    n = (strlen (dirname) * 3 + 1) / 2 + 1;
!   guess = (char *)xmalloc (n);
  
    switch (spname (dirname, guess))
diff -Nrc2 bash-2.05/builtins/command.def bash-2.05a/builtins/command.def
*** bash-2.05/builtins/command.def	Thu Aug  5 07:40:23 1999
--- bash-2.05a/builtins/command.def	Tue Sep 11 10:59:12 2001
***************
*** 50,57 ****
  #include "common.h"
  
  extern int subshell_environment;
  
! static void restore_path ();
! static char *get_standard_path ();
  
  /* Run the commands mentioned in LIST without paying attention to shell
--- 50,61 ----
  #include "common.h"
  
+ #if defined (_CS_PATH) && defined (HAVE_CONFSTR) && !HAVE_DECL_CONFSTR
+ extern size_t confstr __P((int, char *, size_t));
+ #endif
+ 
  extern int subshell_environment;
  
! static void restore_path __P((char *));
! static char *get_standard_path __P((void));
  
  /* Run the commands mentioned in LIST without paying attention to shell
***************
*** 132,140 ****
      }
  
    command = make_bare_simple_command ();
    command->value.Simple->words = (WORD_LIST *)copy_word_list (list);
    command->value.Simple->redirects = (REDIRECT *)NULL;
!   command->flags |= (CMD_NO_FUNCTIONS | CMD_INHIBIT_EXPANSION);
!   command->value.Simple->flags |= (CMD_NO_FUNCTIONS | CMD_INHIBIT_EXPANSION);
  #if 0
    /* This breaks for things like ( cd /tmp ; command z ababa ; echo next )
--- 136,146 ----
      }
  
+ #define COMMAND_BUILTIN_FLAGS (CMD_NO_FUNCTIONS | CMD_INHIBIT_EXPANSION | CMD_COMMAND_BUILTIN)
+ 
    command = make_bare_simple_command ();
    command->value.Simple->words = (WORD_LIST *)copy_word_list (list);
    command->value.Simple->redirects = (REDIRECT *)NULL;
!   command->flags |= COMMAND_BUILTIN_FLAGS;
!   command->value.Simple->flags |= COMMAND_BUILTIN_FLAGS;
  #if 0
    /* This breaks for things like ( cd /tmp ; command z ababa ; echo next )
***************
*** 185,189 ****
    if (len > 0)
      {
!       p = xmalloc ((int)len + 2);
        *p = '\0';
        confstr (_CS_PATH, p, len);
--- 191,195 ----
    if (len > 0)
      {
!       p = (char *)xmalloc (len + 2);
        *p = '\0';
        confstr (_CS_PATH, p, len);
diff -Nrc2 bash-2.05/builtins/common.c bash-2.05a/builtins/common.c
*** bash-2.05/builtins/common.c	Wed Feb 14 17:05:11 2001
--- bash-2.05a/builtins/common.c	Mon Oct 29 13:14:49 2001
***************
*** 27,30 ****
--- 27,31 ----
  
  #include <stdio.h>
+ #include <chartypes.h>
  #include "../bashtypes.h"
  #include "posixstat.h"
***************
*** 64,87 ****
  #endif /* !errno */
  
! #ifdef __STDC__
! typedef int QSFUNC (const void *, const void *);
! #else
! typedef int QSFUNC ();
! #endif 
! 
! extern int no_symbolic_links, interactive, interactive_shell;
  extern int indirection_level, startup_state, subshell_environment;
  extern int line_number;
  extern int last_command_exit_value;
  extern int running_trap;
- extern int variable_context;
  extern int posixly_correct;
  extern char *this_command_name, *shell_name;
- extern COMMAND *global_command;
  extern char *bash_getcwd_errstr;
  
  /* Used by some builtins and the mainline code. */
! Function *last_shell_builtin = (Function *)NULL;
! Function *this_shell_builtin = (Function *)NULL;
  
  /* **************************************************************** */
--- 65,80 ----
  #endif /* !errno */
  
! extern int no_symbolic_links;
  extern int indirection_level, startup_state, subshell_environment;
  extern int line_number;
  extern int last_command_exit_value;
  extern int running_trap;
  extern int posixly_correct;
  extern char *this_command_name, *shell_name;
  extern char *bash_getcwd_errstr;
  
  /* Used by some builtins and the mainline code. */
! sh_builtin_func_t *last_shell_builtin = (sh_builtin_func_t *)NULL;
! sh_builtin_func_t *this_shell_builtin = (sh_builtin_func_t *)NULL;
  
  /* **************************************************************** */
***************
*** 338,342 ****
     shell; if not, call jump_to_top_level (DISCARD), which aborts the
     current command. */
! int
  get_numeric_arg (list, fatal)
       WORD_LIST *list;
--- 331,335 ----
     shell; if not, call jump_to_top_level (DISCARD), which aborts the
     current command. */
! long
  get_numeric_arg (list, fatal)
       WORD_LIST *list;
***************
*** 360,366 ****
--- 353,381 ----
        no_args (list->next);
      }
+ 
    return (count);
  }
  
+ /* Get an eight-bit status value from LIST */
+ int
+ get_exitstat (list)
+      WORD_LIST *list;
+ {
+   int status;
+   long sval;
+   char *arg;
+ 
+   arg = list->word->word;
+   if (arg == 0 || legal_number (arg, &sval) == 0)
+     {
+       builtin_error ("bad non-numeric arg `%s'", list->word->word);
+       return 255;
+     }
+   no_args (list->next);
+ 
+   status = sval & 255;
+   return status;
+ }
+ 
  /* Return the octal number parsed from STRING, or -1 to indicate
     that the string contained a bad number. */
***************
*** 376,382 ****
        digits++;
        result = (result * 8) + (*string++ - '0');
      }
  
!   if (!digits || result > 0777 || *string)
      result = -1;
  
--- 391,399 ----
        digits++;
        result = (result * 8) + (*string++ - '0');
+       if (result > 0777)
+ 	return -1;
      }
  
!   if (digits == 0 || *string)
      result = -1;
  
***************
*** 410,414 ****
    if (the_current_working_directory == 0)
      {
!       the_current_working_directory = xmalloc (PATH_MAX);
        the_current_working_directory[0] = '\0';
        directory = getcwd (the_current_working_directory, PATH_MAX);
--- 427,431 ----
    if (the_current_working_directory == 0)
      {
!       the_current_working_directory = (char *)xmalloc (PATH_MAX);
        the_current_working_directory[0] = '\0';
        directory = getcwd (the_current_working_directory, PATH_MAX);
***************
*** 450,454 ****
  {
    register char *word;
!   int job, substring;
  
    if (list == 0)
--- 467,471 ----
  {
    register char *word;
!   int job, substring_search;
  
    if (list == 0)
***************
*** 463,467 ****
      word++;
  
!   if (digit (*word) && all_digits (word))
      {
        job = atoi (word);
--- 480,484 ----
      word++;
  
!   if (DIGIT (*word) && all_digits (word))
      {
        job = atoi (word);
***************
*** 469,473 ****
      }
  
!   substring = 0;
    switch (*word)
      {
--- 486,490 ----
      }
  
!   substring_search = 0;
    switch (*word)
      {
***************
*** 481,485 ****
  
      case '?':			/* Substring search requested. */
!       substring++;
        word++;
        /* FALLTHROUGH */
--- 498,502 ----
  
      case '?':			/* Substring search requested. */
!       substring_search++;
        word++;
        /* FALLTHROUGH */
***************
*** 499,511 ****
  		do
  		  {
! 		    if ((substring && strindex (p->command, word)) ||
  			(STREQN (p->command, word, wl)))
! 		      if (job != NO_JOB)
! 			{
! 			  builtin_error ("ambigious job spec: %s", word);
! 			  return (DUP_JOB);
! 			}
! 		      else
! 			job = i;
  
  		    p = p->next;
--- 516,530 ----
  		do
  		  {
! 		    if ((substring_search && strindex (p->command, word)) ||
  			(STREQN (p->command, word, wl)))
! 		      {
! 			if (job != NO_JOB)
! 			  {
! 			    builtin_error ("ambigious job spec: %s", word);
! 			    return (DUP_JOB);
! 			  }
! 			else
! 			  job = i;
! 		      }
  
  		    p = p->next;
***************
*** 659,682 ****
  
  /* Return the pointer to the function implementing builtin command NAME. */
! Function *
  find_shell_builtin (name)
       char *name;
  {
    current_builtin = builtin_address_internal (name, 0);
!   return (current_builtin ? current_builtin->function : (Function *)NULL);
  }
  
  /* Return the address of builtin with NAME, whether it is enabled or not. */
! Function *
  builtin_address (name)
       char *name;
  {
    current_builtin = builtin_address_internal (name, 1);
!   return (current_builtin ? current_builtin->function : (Function *)NULL);
  }
  
  /* Return the function implementing the builtin NAME, but only if it is a
     POSIX.2 special builtin. */
! Function *
  find_special_builtin (name)
       char *name;
--- 678,701 ----
  
  /* Return the pointer to the function implementing builtin command NAME. */
! sh_builtin_func_t *
  find_shell_builtin (name)
       char *name;
  {
    current_builtin = builtin_address_internal (name, 0);
!   return (current_builtin ? current_builtin->function : (sh_builtin_func_t *)NULL);
  }
  
  /* Return the address of builtin with NAME, whether it is enabled or not. */
! sh_builtin_func_t *
  builtin_address (name)
       char *name;
  {
    current_builtin = builtin_address_internal (name, 1);
!   return (current_builtin ? current_builtin->function : (sh_builtin_func_t *)NULL);
  }
  
  /* Return the function implementing the builtin NAME, but only if it is a
     POSIX.2 special builtin. */
! sh_builtin_func_t *
  find_special_builtin (name)
       char *name;
***************
*** 685,689 ****
    return ((current_builtin && (current_builtin->flags & SPECIAL_BUILTIN)) ?
    			current_builtin->function :
!   			(Function *)NULL);
  }
    
--- 704,708 ----
    return ((current_builtin && (current_builtin->flags & SPECIAL_BUILTIN)) ?
    			current_builtin->function :
!   			(sh_builtin_func_t *)NULL);
  }
    
diff -Nrc2 bash-2.05/builtins/common.h bash-2.05a/builtins/common.h
*** bash-2.05/builtins/common.h	Fri Oct 13 11:52:55 2000
--- bash-2.05a/builtins/common.h	Wed Sep 12 10:01:40 2001
***************
*** 32,36 ****
  
  /* Functions from common.c */
! extern void builtin_error __P((const char *, ...));
  extern void builtin_usage __P((void));
  extern void no_args __P((WORD_LIST *));
--- 32,36 ----
  
  /* Functions from common.c */
! extern void builtin_error __P((const char *, ...))  __attribute__((__format__ (printf, 1, 2)));
  extern void builtin_usage __P((void));
  extern void no_args __P((WORD_LIST *));
***************
*** 50,54 ****
  extern void set_dollar_vars_changed __P((void));
  
! extern int get_numeric_arg __P((WORD_LIST *, int));
  extern int read_octal __P((char *));
  
--- 50,55 ----
  extern void set_dollar_vars_changed __P((void));
  
! extern long get_numeric_arg __P((WORD_LIST *, int));
! extern int get_exitstat __P((WORD_LIST *));
  extern int read_octal __P((char *));
  
***************
*** 66,81 ****
     providing a definition of what a `Function' is. */
  extern struct builtin *builtin_address_internal __P((char *, int));
! extern Function *find_shell_builtin __P((char *));
! extern Function *builtin_address __P((char *));
! extern Function *find_special_builtin __P((char *));
  extern void initialize_shell_builtins __P((void));
  
  /* Functions from set.def */
! extern void initialize_shell_options __P((int));
  extern void list_minus_o_opts __P((int, int));
  extern int set_minus_o_option __P((int, char *));
! extern int minus_o_option_value __P((char *));
  extern void reset_shell_options __P((void));
- extern char **get_minus_o_opts __P((void));
  
  /* Functions from shopt.def */
--- 67,89 ----
     providing a definition of what a `Function' is. */
  extern struct builtin *builtin_address_internal __P((char *, int));
! extern sh_builtin_func_t *find_shell_builtin __P((char *));
! extern sh_builtin_func_t *builtin_address __P((char *));
! extern sh_builtin_func_t *find_special_builtin __P((char *));
  extern void initialize_shell_builtins __P((void));
  
+ /* Functions from getopts.def */
+ extern void getopts_reset __P((int));
+ 
  /* Functions from set.def */
! extern int minus_o_option_value __P((char *));
  extern void list_minus_o_opts __P((int, int));
+ extern char **get_minus_o_opts __P((void));
  extern int set_minus_o_option __P((int, char *));
! 
! extern void set_shellopts __P((void));
! extern void parse_shellopts __P((char *));
! extern void initialize_shell_options __P((int));
! 
  extern void reset_shell_options __P((void));
  
  /* Functions from shopt.def */
***************
*** 83,86 ****
--- 91,99 ----
  extern char **get_shopt_options __P((void));
  
+ extern int shopt_setopt __P((char *, int));
+ extern int shopt_listopt __P((char *, int));
+ 
+ extern int set_login_shell __P((int));
+ 
  /* Functions from type.def */
  extern int describe_command __P((char *, int, int));
***************
*** 94,109 ****
  /* Functions from pushd.def */
  extern char *get_dirstack_from_string __P((char *));
! extern char *get_dirstack_element __P((int, int));
! extern void set_dirstack_element __P((int, int, char *));
  extern WORD_LIST *get_directory_stack __P((void));
  
  /* Functions from evalstring.c */
! extern int parse_and_execute __P((char *, char *, int));
  extern void parse_and_execute_cleanup __P((void));
  
  /* Functions from evalfile.c */
! extern int maybe_execute_file __P((char *, int));
! extern int source_file __P((char *));
! extern int fc_execute_file __P((char *));
  
  #endif /* !__COMMON_H */
--- 107,122 ----
  /* Functions from pushd.def */
  extern char *get_dirstack_from_string __P((char *));
! extern char *get_dirstack_element __P((long, int));
! extern void set_dirstack_element __P((long, int, char *));
  extern WORD_LIST *get_directory_stack __P((void));
  
  /* Functions from evalstring.c */
! extern int parse_and_execute __P((char *, const char *, int));
  extern void parse_and_execute_cleanup __P((void));
  
  /* Functions from evalfile.c */
! extern int maybe_execute_file __P((const char *, int));
! extern int source_file __P((const char *));
! extern int fc_execute_file __P((const char *));
  
  #endif /* !__COMMON_H */
diff -Nrc2 bash-2.05/builtins/complete.def bash-2.05a/builtins/complete.def
*** bash-2.05/builtins/complete.def	Wed Feb 14 17:07:54 2001
--- bash-2.05a/builtins/complete.def	Wed Jul 25 15:23:35 2001
***************
*** 25,29 ****
  $DEPENDS_ON PROGRAMMABLE_COMPLETION
  $FUNCTION complete_builtin
! $SHORT_DOC complete [-abcdefjkvu] [-pr] [-o option] [-A action] [-G globpat] [-W wordlist] [-P prefix] [-S suffix] [-X filterpat] [-F function] [-C command] [name ...]
  For each NAME, specify how arguments are to be completed.
  If the -p option is supplied, or if no options are supplied, existing
--- 25,29 ----
  $DEPENDS_ON PROGRAMMABLE_COMPLETION
  $FUNCTION complete_builtin
! $SHORT_DOC complete [-abcdefgjkvu] [-pr] [-o option] [-A action] [-G globpat] [-W wordlist] [-P prefix] [-S suffix] [-X filterpat] [-F function] [-C command] [name ...]
  For each NAME, specify how arguments are to be completed.
  If the -p option is supplied, or if no options are supplied, existing
***************
*** 52,61 ****
  #include "bashgetopt.h"
  
  #define STRDUP(x)       ((x) ? savestring (x) : (char *)NULL)
  
! static int remove_cmd_completions ();
  
! static void print_all_completions ();
! static int print_cmd_completions ();
  
  static char *Aarg, *Garg, *Warg, *Parg, *Sarg, *Xarg, *Farg, *Carg;
--- 52,69 ----
  #include "bashgetopt.h"
  
+ #include <readline/readline.h>
+ 
  #define STRDUP(x)       ((x) ? savestring (x) : (char *)NULL)
  
! static int find_compact __P((char *));
! static int find_compopt __P((char *));
! 
! static int build_actions __P((WORD_LIST *, int *, int *, unsigned long *, unsigned long *));
! 
! static int remove_cmd_completions __P((WORD_LIST *));
  
! static void print_one_completion __P((char *, COMPSPEC *));
! static void print_all_completions __P((void));
! static int print_cmd_completions __P((WORD_LIST *));
  
  static char *Aarg, *Garg, *Warg, *Parg, *Sarg, *Xarg, *Farg, *Carg;
***************
*** 79,82 ****
--- 87,91 ----
    { "helptopic", CA_BUILTIN,  0 },	/* for now */
    { "hostname",  CA_HOSTNAME,   0 },
+   { "group",     CA_GROUP,     'g' },
    { "job",       CA_JOB,       'j' },
    { "keyword",   CA_KEYWORD,   'k' },
***************
*** 145,149 ****
       unsigned long *actp, *optp;
  {
!   int opt, ind, pflag, rflag, opt_given;
    unsigned long acts, copts;
  
--- 154,158 ----
       unsigned long *actp, *optp;
  {
!   int opt, ind, opt_given;
    unsigned long acts, copts;
  
***************
*** 152,156 ****
  
    reset_internal_getopt ();
!   while ((opt = internal_getopt (list, "abcdefjko:pruvA:G:W:P:S:X:F:C:")) != -1)
      {
        opt_given = 1;
--- 161,165 ----
  
    reset_internal_getopt ();
!   while ((opt = internal_getopt (list, "abcdefgjko:pruvA:G:W:P:S:X:F:C:")) != -1)
      {
        opt_given = 1;
***************
*** 201,204 ****
--- 210,216 ----
  	  acts |= CA_FILE;
  	  break;
+ 	case 'g':
+ 	  acts |= CA_GROUP;
+ 	  break;
  	case 'j':
  	  acts |= CA_JOB;
***************
*** 425,428 ****
--- 437,441 ----
    PRINTOPT (CA_EXPORT, "-e");
    PRINTOPT (CA_FILE, "-f");
+   PRINTOPT (CA_GROUP, "-g");
    PRINTOPT (CA_KEYWORD, "-k");
    PRINTOPT (CA_JOB, "-j");
***************
*** 491,495 ****
  $DEPENDS_ON PROGRAMMABLE_COMPLETION
  $FUNCTION compgen_builtin
! $SHORT_DOC compgen [-abcdefjkvu] [-o option] [-A action] [-G globpat] [-W wordlist] [-P prefix] [-S suffix] [-X filterpat] [-F function] [-C command] [word]
  Display the possible completions depending on the options.  Intended
  to be used from within a shell function generating possible completions.
--- 504,508 ----
  $DEPENDS_ON PROGRAMMABLE_COMPLETION
  $FUNCTION compgen_builtin
! $SHORT_DOC compgen [-abcdefgjkvu] [-o option] [-A action] [-G globpat] [-W wordlist] [-P prefix] [-S suffix] [-X filterpat] [-F function] [-C command] [word]
  Display the possible completions depending on the options.  Intended
  to be used from within a shell function generating possible completions.
***************
*** 548,554 ****
    rval = EXECUTION_FAILURE;
    sl = gen_compspec_completions (cs, "compgen", word, 0, 0);
    if (sl)
      {
!       if (sl->list)
  	{
  	  rval = EXECUTION_SUCCESS;
--- 561,579 ----
    rval = EXECUTION_FAILURE;
    sl = gen_compspec_completions (cs, "compgen", word, 0, 0);
+ 
+   /* This isn't perfect, but it's the best we can do, given what readline
+      exports from its set of completion utility functions. */
+   if ((sl == 0 || sl->list_len == 0) && (copts & COPT_DEFAULT))
+     {
+       char **matches;
+ 
+       matches = rl_completion_matches (word, rl_filename_completion_function);
+       sl = completions_to_stringlist (matches);
+       free_array (matches);
+     }
+ 
    if (sl)
      {
!       if (sl->list && sl->list_len)
  	{
  	  rval = EXECUTION_SUCCESS;
diff -Nrc2 bash-2.05/builtins/declare.def bash-2.05a/builtins/declare.def
*** bash-2.05/builtins/declare.def	Wed Feb 14 17:08:37 2001
--- bash-2.05a/builtins/declare.def	Tue Sep 11 15:32:08 2001
***************
*** 72,78 ****
  #include "builtext.h"
  
! extern int variable_context, array_needs_making;
  
! static int declare_internal ();
  
  /* Declare or change variable attributes. */
--- 72,78 ----
  #include "builtext.h"
  
! extern int array_needs_making;
  
! static int declare_internal __P((register WORD_LIST *, int));
  
  /* Declare or change variable attributes. */
***************
*** 111,115 ****
  {
    int flags_on, flags_off, *flags, any_failed, assign_error, pflag, nodefs;
!   char *t;
    SHELL_VAR *var;
  
--- 111,115 ----
  {
    int flags_on, flags_off, *flags, any_failed, assign_error, pflag, nodefs;
!   char *t, *subscript_start;
    SHELL_VAR *var;
  
***************
*** 216,220 ****
        int offset;
  #if defined (ARRAY_VARS)
!       int making_array_special, assigning_array_special;
  #endif
  
--- 216,220 ----
        int offset;
  #if defined (ARRAY_VARS)
!       int making_array_special, compound_array_assign, simple_array_assign;
  #endif
  
***************
*** 231,237 ****
  
  #if defined (ARRAY_VARS)
!       assigning_array_special = 0;
!       if (t = strchr (name, '['))
  	{
  	  *t = '\0';
  	  making_array_special = 1;
--- 231,239 ----
  
  #if defined (ARRAY_VARS)
!       compound_array_assign = simple_array_assign = 0;
!       subscript_start = (char *)NULL;
!       if (t = strchr (name, '['))	/* ] */
  	{
+ 	  subscript_start = t;
  	  *t = '\0';
  	  making_array_special = 1;
***************
*** 345,360 ****
  
  #if defined (ARRAY_VARS)
- 	  /* declare -a name=value does not work; declare name=value when
- 	     name is already an array does not work. */
  	  if ((making_array_special || (flags_on & att_array) || array_p (var)) && offset)
  	    {
  	      if (value[0] == '(' && strchr (value, ')'))
! 		assigning_array_special = 1;
  	      else
! 		{
! 		  builtin_error ("%s: cannot assign to array variables in this way", name);
! 		  assign_error++;
! 		  NEXT_VARIABLE ();
! 		}
  	    }
  
--- 347,356 ----
  
  #if defined (ARRAY_VARS)
  	  if ((making_array_special || (flags_on & att_array) || array_p (var)) && offset)
  	    {
  	      if (value[0] == '(' && strchr (value, ')'))
! 		compound_array_assign = 1;
  	      else
! 		simple_array_assign = 1;
  	    }
  
***************
*** 376,381 ****
  
  #if defined (ARRAY_VARS)
! 	  if (offset && assigning_array_special)
  	    assign_array_var_from_string (var, value);
  	  else
  #endif
--- 372,387 ----
  
  #if defined (ARRAY_VARS)
! 	  if (offset && compound_array_assign)
  	    assign_array_var_from_string (var, value);
+ 	  else if (simple_array_assign && subscript_start)
+ 	    {
+ 	      /* declare [-a] name[N]=value */
+ 	      *subscript_start = '[';	/* ] */
+ 	      var = assign_array_element (name, value);
+ 	      *subscript_start = '\0';
+ 	    }
+ 	  else if (simple_array_assign)
+ 	    /* let bind_array_variable take care of this. */
+ 	    bind_array_variable (name, 0, value);
  	  else
  #endif
diff -Nrc2 bash-2.05/builtins/enable.def bash-2.05a/builtins/enable.def
*** bash-2.05/builtins/enable.def	Wed Feb 14 17:09:05 2001
--- bash-2.05a/builtins/enable.def	Tue Aug 28 13:04:44 2001
***************
*** 61,72 ****
  #endif
  
- #if defined (HAVE_DLOPEN) && defined (HAVE_DLSYM)
- static int dyn_load_builtin ();
- #endif
- 
- #if defined (HAVE_DLCLOSE)
- static int dyn_unload_builtin ();
- #endif
- 
  #define ENABLED  1
  #define DISABLED 2
--- 61,64 ----
***************
*** 80,85 ****
  #define SFLAG	0x20
  
! static int enable_shell_command ();
! static void list_some_builtins ();
  
  /* Enable/disable shell commands present in LIST.  If list is not specified,
--- 72,87 ----
  #define SFLAG	0x20
  
! #if defined (HAVE_DLOPEN) && defined (HAVE_DLSYM)
! static int dyn_load_builtin __P((WORD_LIST *, int, char *));
! #endif
! 
! #if defined (HAVE_DLCLOSE)
! static int dyn_unload_builtin __P((char *));
! static void delete_builtin __P((struct builtin *));
! static int local_dlclose __P((void *));
! #endif
! 
! static void list_some_builtins __P((int));
! static int enable_shell_command __P((char *, int));
  
  /* Enable/disable shell commands present in LIST.  If list is not specified,
***************
*** 306,310 ****
  
        size = strlen (name);
!       struct_name = xmalloc (size + 8);
        strcpy (struct_name, name);
        strcpy (struct_name + size, "_struct");
--- 308,312 ----
  
        size = strlen (name);
!       struct_name = (char *)xmalloc (size + 8);
        strcpy (struct_name, name);
        strcpy (struct_name + size, "_struct");
***************
*** 356,360 ****
  
        new_shell_builtins[total].name = (char *)0;
!       new_shell_builtins[total].function = (Function *)0;
        new_shell_builtins[total].flags = 0;
  
--- 358,362 ----
  
        new_shell_builtins[total].name = (char *)0;
!       new_shell_builtins[total].function = (sh_builtin_func_t *)0;
        new_shell_builtins[total].flags = 0;
  
***************
*** 428,432 ****
    void *handle;
    int ref, i;
-   char *uerror;
  
    b = builtin_address_internal (name, 1);
--- 430,433 ----
diff -Nrc2 bash-2.05/builtins/evalfile.c bash-2.05a/builtins/evalfile.c
*** bash-2.05/builtins/evalfile.c	Wed Feb 14 17:05:16 2001
--- bash-2.05a/builtins/evalfile.c	Mon Oct 29 13:45:50 2001
***************
*** 58,63 ****
  #define FEVAL_HISTORY		0x020
  #define FEVAL_CHECKBINARY	0x040
  
! extern int interactive, interactive_shell, posixly_correct;
  extern int indirection_level, startup_state, subshell_environment;
  extern int return_catch_flag, return_catch_value;
--- 58,64 ----
  #define FEVAL_HISTORY		0x020
  #define FEVAL_CHECKBINARY	0x040
+ #define FEVAL_REGFILE		0x080
  
! extern int posixly_correct;
  extern int indirection_level, startup_state, subshell_environment;
  extern int return_catch_flag, return_catch_value;
***************
*** 69,73 ****
  static int
  _evalfile (filename, flags)
!      char *filename;
       int flags;
  {
--- 70,74 ----
  static int
  _evalfile (filename, flags)
!      const char *filename;
       int flags;
  {
***************
*** 78,82 ****
    struct stat finfo;
    size_t file_size;
!   VFunction *errfunc;
  
    fd = open (filename, O_RDONLY);
--- 79,85 ----
    struct stat finfo;
    size_t file_size;
!   sh_vmsg_func_t *errfunc;
! 
!   USE_VAR(pflags);
  
    fd = open (filename, O_RDONLY);
***************
*** 98,102 ****
      }
  
!   errfunc = (VFunction *)((flags & FEVAL_BUILTIN) ? builtin_error : internal_error);
  
    if (S_ISDIR (finfo.st_mode))
--- 101,105 ----
      }
  
!   errfunc = ((flags & FEVAL_BUILTIN) ? builtin_error : internal_error);
  
    if (S_ISDIR (finfo.st_mode))
***************
*** 105,109 ****
        return ((flags & FEVAL_BUILTIN) ? EXECUTION_FAILURE : -1);
      }
!   else if (S_ISREG (finfo.st_mode) == 0)
      {
        (*errfunc) ("%s: not a regular file", filename);
--- 108,112 ----
        return ((flags & FEVAL_BUILTIN) ? EXECUTION_FAILURE : -1);
      }
!   else if ((flags & FEVAL_REGFILE) && S_ISREG (finfo.st_mode) == 0)
      {
        (*errfunc) ("%s: not a regular file", filename);
***************
*** 123,127 ****
  #endif
  
!   string = xmalloc (1 + file_size);
    result = read (fd, string, file_size);
    string[result] = '\0';
--- 126,130 ----
  #endif
  
!   string = (char *)xmalloc (1 + file_size);
    result = read (fd, string, file_size);
    string[result] = '\0';
***************
*** 144,148 ****
        
    if ((flags & FEVAL_CHECKBINARY) && 
!       check_binary_file ((unsigned char *)string, (result > 80) ? 80 : result))
      {
        free (string);
--- 147,151 ----
        
    if ((flags & FEVAL_CHECKBINARY) && 
!       check_binary_file (string, (result > 80) ? 80 : result))
      {
        free (string);
***************
*** 208,212 ****
  int
  maybe_execute_file (fname, force_noninteractive)
!      char *fname;
       int force_noninteractive;
  {
--- 211,215 ----
  int
  maybe_execute_file (fname, force_noninteractive)
!      const char *fname;
       int force_noninteractive;
  {
***************
*** 226,230 ****
  int
  fc_execute_file (filename)
!      char *filename;
  {
    int flags;
--- 229,233 ----
  int
  fc_execute_file (filename)
!      const char *filename;
  {
    int flags;
***************
*** 232,236 ****
    /* We want these commands to show up in the history list if
       remember_on_history is set. */
!   flags = FEVAL_ENOENTOK|FEVAL_HISTORY;
    return (_evalfile (filename, flags));
  }
--- 235,239 ----
    /* We want these commands to show up in the history list if
       remember_on_history is set. */
!   flags = FEVAL_ENOENTOK|FEVAL_HISTORY|FEVAL_REGFILE;
    return (_evalfile (filename, flags));
  }
***************
*** 239,243 ****
  int
  source_file (filename)
!      char *filename;
  {
    int flags;
--- 242,246 ----
  int
  source_file (filename)
!      const char *filename;
  {
    int flags;
diff -Nrc2 bash-2.05/builtins/evalstring.c bash-2.05a/builtins/evalstring.c
*** bash-2.05/builtins/evalstring.c	Wed Feb 14 17:05:23 2001
--- bash-2.05a/builtins/evalstring.c	Tue Sep 11 16:24:42 2001
***************
*** 41,44 ****
--- 41,45 ----
  #include "../execute_cmd.h"
  #include "../redir.h"
+ #include "../trap.h"
  
  #if defined (HISTORY)
***************
*** 54,61 ****
  #define IS_BUILTIN(s)	(builtin_address_internal(s, 0) != (struct builtin *)NULL)
  
- extern void run_trap_cleanup ();
- extern int zwrite ();
- 
- extern int interactive, interactive_shell;
  extern int indirection_level, startup_state, subshell_environment;
  extern int line_number;
--- 55,58 ----
***************
*** 63,71 ****
  extern int running_trap;
  extern int posixly_correct;
- extern COMMAND *global_command;
  
  int parse_and_execute_level = 0;
  
! static int cat_file ();
  
  /* How to force parse_and_execute () to clean up after itself. */
--- 60,67 ----
  extern int running_trap;
  extern int posixly_correct;
  
  int parse_and_execute_level = 0;
  
! static int cat_file __P((REDIRECT *));
  
  /* How to force parse_and_execute () to clean up after itself. */
***************
*** 93,97 ****
  parse_and_execute (string, from_file, flags)
       char *string;
!      char *from_file;
       int flags;
  {
--- 89,93 ----
  parse_and_execute (string, from_file, flags)
       char *string;
!      const char *from_file;
       int flags;
  {
***************
*** 298,302 ****
  {
    char lbuf[128], *fn;
!   int nr, fd, rval;
  
    if (r->instruction != r_input_direction)
--- 294,299 ----
  {
    char lbuf[128], *fn;
!   int fd, rval;
!   ssize_t nr;
  
    if (r->instruction != r_input_direction)
***************
*** 345,348 ****
    close (fd);
  
!   return (0);  
  }
--- 342,345 ----
    close (fd);
  
!   return (rval);
  }
diff -Nrc2 bash-2.05/builtins/exec.def bash-2.05a/builtins/exec.def
*** bash-2.05/builtins/exec.def	Mon Mar 26 13:07:57 2001
--- bash-2.05a/builtins/exec.def	Tue Sep 11 15:35:10 2001
***************
*** 67,71 ****
  #endif /* !errno */
  
! extern int interactive, interactive_shell, subshell_environment;
  extern REDIRECT *redirection_undo_list;
  
--- 67,71 ----
  #endif /* !errno */
  
! extern int subshell_environment;
  extern REDIRECT *redirection_undo_list;
  
***************
*** 80,84 ****
    char *ret;
  
!   ret = xmalloc (2 + strlen (name));
    ret[0] = '-';
    strcpy (ret + 1, name);
--- 80,84 ----
    char *ret;
  
!   ret = (char *)xmalloc (2 + strlen (name));
    ret[0] = '-';
    strcpy (ret + 1, name);
diff -Nrc2 bash-2.05/builtins/exit.def bash-2.05a/builtins/exit.def
*** bash-2.05/builtins/exit.def	Thu Aug  5 07:42:05 1999
--- bash-2.05a/builtins/exit.def	Tue Sep 11 15:36:18 2001
***************
*** 44,53 ****
  #include "builtext.h"	/* for jobs_builtin */
  
- extern int interactive, login_shell;
  extern int last_command_exit_value;
! extern Function *this_shell_builtin;
! extern Function *last_shell_builtin;
  
! static int exit_or_logout ();
  static int sourced_logout;
  
--- 44,53 ----
  #include "builtext.h"	/* for jobs_builtin */
  
  extern int last_command_exit_value;
! extern int subshell_environment;
! extern sh_builtin_func_t *this_shell_builtin;
! extern sh_builtin_func_t *last_shell_builtin;
  
! static int exit_or_logout __P((WORD_LIST *));
  static int sourced_logout;
  
***************
*** 120,127 ****
    /* Get return value if present.  This means that you can type
       `logout 5' to a shell, and it returns 5. */
!   exit_value = list ? get_numeric_arg (list, 1) : last_command_exit_value;
  
    /* Run our `~/.bash_logout' file if it exists, and this is a login shell. */
!   if (login_shell && sourced_logout++ == 0)
      {
        maybe_execute_file ("~/.bash_logout", 1);
--- 120,127 ----
    /* Get return value if present.  This means that you can type
       `logout 5' to a shell, and it returns 5. */
!   exit_value = list ? get_exitstat (list) : last_command_exit_value;
  
    /* Run our `~/.bash_logout' file if it exists, and this is a login shell. */
!   if (login_shell && sourced_logout++ == 0 && subshell_environment == 0)
      {
        maybe_execute_file ("~/.bash_logout", 1);
diff -Nrc2 bash-2.05/builtins/fc.def bash-2.05a/builtins/fc.def
*** bash-2.05/builtins/fc.def	Wed Jan 17 11:51:50 2001
--- bash-2.05a/builtins/fc.def	Wed Sep 12 11:57:25 2001
***************
*** 64,67 ****
--- 64,68 ----
  
  #include <stdio.h>
+ #include <chartypes.h>
  
  #include "../bashansi.h"
***************
*** 85,89 ****
  extern int literal_history;
  
! extern int unlink ();
  
  extern FILE *sh_mktmpfp __P((char *, int, char **));
--- 86,90 ----
  extern int literal_history;
  
! extern int unlink __P((const char *));
  
  extern FILE *sh_mktmpfp __P((char *, int, char **));
***************
*** 118,125 ****
  */
  
- static char *fc_dosubs (), *fc_gethist (), *fc_readline ();
- static int fc_gethnum (), fc_number ();
- static void fc_replhist (), fc_addhist ();
- 
  /* Data structure describing a list of global replacements to perform. */
  typedef struct repl {
--- 119,122 ----
***************
*** 147,150 ****
--- 144,157 ----
  	} while (0)
  
+ static char *fc_dosubs __P((char *, REPL *));
+ static char *fc_gethist __P((char *, HIST_ENTRY **));
+ static int fc_gethnum __P((char *, HIST_ENTRY **));
+ static int fc_number __P((WORD_LIST *));
+ static void fc_replhist __P((char *));
+ #ifdef INCLUDE_UNUSED
+ static char *fc_readline __P((FILE *));
+ static void fc_addhist __P((char *));
+ #endif
+ 
  /* String to execute on a file that we want to edit. */
  #define FC_EDIT_COMMAND "${FCEDIT:-${EDITOR:-vi}}"
***************
*** 160,164 ****
    FILE *stream;
    REPL *rlist, *rl;
!   char *ename, *command, *newcom, *line;
    HIST_ENTRY **hlist;
    char *fn;
--- 167,171 ----
    FILE *stream;
    REPL *rlist, *rl;
!   char *ename, *command, *newcom;
    HIST_ENTRY **hlist;
    char *fn;
***************
*** 446,450 ****
      }
  
!   if (s && digit(*s))
      {
        n = atoi (s);
--- 453,457 ----
      }
  
!   if (s && DIGIT(*s))
      {
        n = atoi (s);
***************
*** 495,498 ****
--- 502,506 ----
  }
  
+ #ifdef INCLUDE_UNUSED
  /* Read the edited history lines from STREAM and return them
     one at a time.  This can read unlimited length lines.  The
***************
*** 509,513 ****
      {
        if ((lindex + 2) >= line_len)
! 	line = (char *) xrealloc (line, (line_len += 128));
  
        if (c == '\n')
--- 517,521 ----
      {
        if ((lindex + 2) >= line_len)
! 	line = (char *)xrealloc (line, (line_len += 128));
  
        if (c == '\n')
***************
*** 536,539 ****
--- 544,548 ----
    return (line);
  }
+ #endif
  
  /* Perform the SUBS on COMMAND.
***************
*** 605,608 ****
--- 614,618 ----
  }
  
+ #ifdef INCLUDE_UNUSED
  /* Add LINE to the history, after removing a single trailing newline. */
  static void
***************
*** 620,622 ****
--- 630,634 ----
      maybe_add_history (line);
  }
+ #endif
+ 
  #endif /* HISTORY */
diff -Nrc2 bash-2.05/builtins/fg_bg.def bash-2.05a/builtins/fg_bg.def
*** bash-2.05/builtins/fg_bg.def	Thu Aug  5 07:42:21 1999
--- bash-2.05a/builtins/fg_bg.def	Mon May 14 11:52:47 2001
***************
*** 47,51 ****
  extern char *this_command_name;
  
! static int fg_bg ();
  
  /* How to bring a job into the foreground. */
--- 47,51 ----
  extern char *this_command_name;
  
! static int fg_bg __P((WORD_LIST *, int));
  
  /* How to bring a job into the foreground. */
diff -Nrc2 bash-2.05/builtins/getopt.h bash-2.05a/builtins/getopt.h
*** bash-2.05/builtins/getopt.h	Thu Aug  5 07:32:48 1999
--- bash-2.05a/builtins/getopt.h	Mon Sep 10 14:12:49 2001
***************
*** 21,24 ****
--- 21,26 ----
  #define _SH_GETOPT_H 1
  
+ #include "stdc.h"
+ 
  /* For communication from `getopt' to the caller.
     When `getopt' finds an option that takes an argument,
***************
*** 55,60 ****
  extern int sh_badopt;
  
! extern int sh_getopt ();
! extern void sh_getopt_restore_state ();
  
  #endif /* _SH_GETOPT_H */
--- 57,62 ----
  extern int sh_badopt;
  
! extern int sh_getopt __P((int, char *const *, const char *));
! extern void sh_getopt_restore_state __P((char **));
  
  #endif /* _SH_GETOPT_H */
diff -Nrc2 bash-2.05/builtins/getopts.def bash-2.05a/builtins/getopts.def
*** bash-2.05/builtins/getopts.def	Wed Feb 14 17:09:23 2001
--- bash-2.05a/builtins/getopts.def	Tue Sep 11 15:46:40 2001
***************
*** 80,84 ****
  
  extern char *this_command_name;
- extern WORD_LIST *rest_of_args;
  
  /* getopts_reset is magic code for when OPTIND is reset.  N is the
--- 80,83 ----
***************
*** 305,316 ****
  
    reset_internal_getopt ();
!   while ((ret = internal_getopt (list, "")) != -1)
      {
!       switch (ret)
! 	{
! 	default:
! 	  builtin_usage ();
! 	  return (EX_USAGE);
! 	}
      }
    list = loptend;
--- 304,311 ----
  
    reset_internal_getopt ();
!   if (internal_getopt (list, "") != -1)
      {
!       builtin_usage ();
!       return (EX_USAGE);
      }
    list = loptend;
diff -Nrc2 bash-2.05/builtins/hash.def bash-2.05a/builtins/hash.def
*** bash-2.05/builtins/hash.def	Thu Oct 19 13:13:16 2000
--- bash-2.05a/builtins/hash.def	Wed May  9 12:00:35 2001
***************
*** 24,33 ****
  $BUILTIN hash
  $FUNCTION hash_builtin
! $SHORT_DOC hash [-r] [-p pathname] [name ...]
  For each NAME, the full pathname of the command is determined and
  remembered.  If the -p option is supplied, PATHNAME is used as the
  full pathname of NAME, and no path search is performed.  The -r
! option causes the shell to forget all remembered locations.  If no
! arguments are given, information about remembered commands is displayed.
  $END
  
--- 24,36 ----
  $BUILTIN hash
  $FUNCTION hash_builtin
! $SHORT_DOC hash [-r] [-p pathname] [-t] [name ...]
  For each NAME, the full pathname of the command is determined and
  remembered.  If the -p option is supplied, PATHNAME is used as the
  full pathname of NAME, and no path search is performed.  The -r
! option causes the shell to forget all remembered locations.
! If the -t option is supplied the full pathname to which each NAME
! corresponds is printed.  If multiple NAME arguments are supplied with
! -t, the NAME is printed before the hashed full pathname.  If no arguments
! are given, information about remembered commands is displayed.
  $END
  
***************
*** 57,62 ****
  extern char *this_command_name;
  
! static int add_hashed_command ();
! static int print_hashed_commands ();
  
  /* Print statistics on the current state of hashed commands.  If LIST is
--- 60,66 ----
  extern char *this_command_name;
  
! static int add_hashed_command __P((char *, int));
! static int print_hashed_commands __P((void));
! static int list_hashed_filename_targets __P((WORD_LIST *));
  
  /* Print statistics on the current state of hashed commands.  If LIST is
***************
*** 67,71 ****
       WORD_LIST *list;
  {
!   int expunge_hash_table, opt;
    char *w, *pathname;
  
--- 71,75 ----
       WORD_LIST *list;
  {
!   int expunge_hash_table, list_targets, opt;
    char *w, *pathname;
  
***************
*** 76,83 ****
      }
  
!   expunge_hash_table = 0;
    pathname = (char *)NULL;
    reset_internal_getopt ();
!   while ((opt = internal_getopt (list, "rp:")) != -1)
      {
        switch (opt)
--- 80,87 ----
      }
  
!   expunge_hash_table = list_targets = 0;
    pathname = (char *)NULL;
    reset_internal_getopt ();
!   while ((opt = internal_getopt (list, "rp:t")) != -1)
      {
        switch (opt)
***************
*** 89,92 ****
--- 93,99 ----
  	  pathname = list_optarg;
  	  break;
+ 	case 't':
+ 	  list_targets = 1;
+ 	  break;
  	default:
  	  builtin_usage ();
***************
*** 96,99 ****
--- 103,113 ----
    list = loptend;
  
+   /* hash -t requires at least one argument. */
+   if (list == 0 && list_targets)
+     {
+       builtin_error("-t: argument required");
+       return (EXECUTION_FAILURE);
+     }
+ 
    /* We want hash -r to be silent, but hash -- to print hashing info.  That
       is the reason for the test of expunge_hash_table. */
***************
*** 109,112 ****
--- 123,132 ----
      flush_hashed_filenames ();
  
+   /* If someone runs `hash -r -t xyz' he will be disappointed. */
+   if (list_targets)
+     {
+       return (list_hashed_filename_targets (list));
+     }
+       
  #if defined (RESTRICTED_SHELL)
    if (restricted && pathname && strchr (pathname, '/'))
***************
*** 198,200 ****
--- 218,248 ----
      }
    return (any_printed);
+ }
+ 
+ static int
+ list_hashed_filename_targets (list)
+      WORD_LIST *list;
+ {
+   int all_found, multiple;
+   char *target;
+   WORD_LIST *l;
+ 
+   all_found = 1;
+   multiple = list->next != 0;
+ 
+   for (l = list; l; l = l->next)
+     {
+       target = find_hashed_filename (l->word->word);
+       if (target == 0)
+ 	{
+ 	  all_found = 0;
+ 	  builtin_error ("%s: not found", l->word->word);
+ 	  continue;
+ 	}
+       if (multiple)
+         printf ("%s\t", l->word->word);
+       printf ("%s\n", target);
+     }
+ 
+   return (all_found ? EXECUTION_SUCCESS : EXECUTION_FAILURE);
  }
diff -Nrc2 bash-2.05/builtins/help.def bash-2.05a/builtins/help.def
*** bash-2.05/builtins/help.def	Thu Aug  5 07:42:44 1999
--- bash-2.05a/builtins/help.def	Mon Sep 10 09:54:50 2001
***************
*** 48,60 ****
  #include "../builtins.h"
  #include "../pathexp.h"
  #include "bashgetopt.h"
  
! #include <glob/fnmatch.h>
  #include <glob/glob.h>
  
! extern void builtin_error ();
! extern void builtin_usage ();
! 
! static  void show_builtin_command_help ();
  
  /* Print out a list of the known functions in the shell, and what they do.
--- 48,58 ----
  #include "../builtins.h"
  #include "../pathexp.h"
+ #include "common.h"
  #include "bashgetopt.h"
  
! #include <glob/strmatch.h>
  #include <glob/glob.h>
  
! static  void show_builtin_command_help __P((void));
  
  /* Print out a list of the known functions in the shell, and what they do.
***************
*** 110,114 ****
  	  QUIT;
  	  if ((strncmp (pattern, name, plen) == 0) ||
! 	      (fnmatch (pattern, name, FNMATCH_EXTFLAG) != FNM_NOMATCH))
  	    {
  	      printf ("%s: %s\n", name, shell_builtins[i].short_doc);
--- 108,112 ----
  	  QUIT;
  	  if ((strncmp (pattern, name, plen) == 0) ||
! 	      (strmatch (pattern, name, FNMATCH_EXTFLAG) != FNM_NOMATCH))
  	    {
  	      printf ("%s: %s\n", name, shell_builtins[i].short_doc);
diff -Nrc2 bash-2.05/builtins/history.def bash-2.05a/builtins/history.def
*** bash-2.05/builtins/history.def	Wed Feb 14 17:09:42 2001
--- bash-2.05a/builtins/history.def	Mon May 21 15:32:57 2001
***************
*** 71,78 ****
  #endif
  
! static void display_history ();
! static void push_history ();
! static int expand_and_print_history ();
! static int delete_histent ();
  
  #define AFLAG	0x01
--- 71,79 ----
  #endif
  
! static void display_history __P((WORD_LIST *));
! static int delete_histent __P((int));
! static int delete_last_history __P((void));
! static void push_history __P((WORD_LIST *));
! static int expand_and_print_history __P((WORD_LIST *));
  
  #define AFLAG	0x01
***************
*** 164,168 ****
    else if (flags & DFLAG)
      {
!       if (legal_number (delete_arg, &delete_offset) == 0)
  	{
  	  builtin_error ("%s: not a valid history position", delete_arg);
--- 165,171 ----
    else if (flags & DFLAG)
      {
!       if ((legal_number (delete_arg, &delete_offset) == 0)
! 	  || (delete_offset < history_base)
! 	  || (delete_offset > (history_base + history_length)))
  	{
  	  builtin_error ("%s: not a valid history position", delete_arg);
***************
*** 170,178 ****
  	}
        opt = delete_offset;
-       if (opt < history_base || opt < 0 || opt > (history_base + history_length))
- 	{
- 	  builtin_error ("%d: not a valid history position", opt);
- 	  return (EXECUTION_FAILURE);
- 	}
        result = delete_histent (opt - history_base);
        /* Since remove_history changes history_length, this can happen if
--- 173,176 ----
***************
*** 218,231 ****
  {
    register int i;
!   int limited, limit;
    HIST_ENTRY **hlist;
  
    if (list)
      {
-       limited = 1;
        limit = get_numeric_arg (list, 0);
      }
    else
!     limited = limit = 0;
  
    hlist = history_list ();
--- 216,230 ----
  {
    register int i;
!   long limit;
    HIST_ENTRY **hlist;
  
    if (list)
      {
        limit = get_numeric_arg (list, 0);
+       if (limit < 0)
+ 	limit = -limit;
      }
    else
!     limit = -1;
  
    hlist = history_list ();
***************
*** 236,243 ****
  	;
  
!       if (limit < 0)
! 	limit = -limit;
! 
!       if ((limited == 0)  || ((i -= limit) < 0))
  	i = 0;
  
--- 235,241 ----
  	;
  
!       if (0 <= limit && limit < i)
! 	i -= limit;
!       else
  	i = 0;
  
diff -Nrc2 bash-2.05/builtins/jobs.def bash-2.05a/builtins/jobs.def
*** bash-2.05/builtins/jobs.def	Thu Aug  5 07:43:05 1999
--- bash-2.05a/builtins/jobs.def	Tue Sep 11 15:38:49 2001
***************
*** 58,63 ****
  #define JSTATE_STOPPED	0x2
  
! extern int job_control, interactive_shell;
! static int execute_list_with_replacements ();
  
  /* The `jobs' command.  Prints outs a list of active jobs.  If the
--- 58,62 ----
  #define JSTATE_STOPPED	0x2
  
! static int execute_list_with_replacements __P((WORD_LIST *));
  
  /* The `jobs' command.  Prints outs a list of active jobs.  If the
***************
*** 221,224 ****
--- 220,224 ----
    int opt, job, retval, nohup_only, running_jobs, all_jobs;
    sigset_t set, oset;
+   long pid_value;
  
    nohup_only = running_jobs = all_jobs = 0;
***************
*** 258,263 ****
      {
        BLOCK_CHILD (set, oset);
!       job = (list && all_digits(list->word->word))
! 		? get_job_by_pid (atoi(list->word->word), 0)
  		: get_job_spec (list);
  
--- 258,263 ----
      {
        BLOCK_CHILD (set, oset);
!       job = (list && legal_number (list->word->word, &pid_value) && pid_value == (pid_t) pid_value)
! 		? get_job_by_pid ((pid_t) pid_value, 0)
  		: get_job_spec (list);
  
diff -Nrc2 bash-2.05/builtins/kill.def bash-2.05a/builtins/kill.def
*** bash-2.05/builtins/kill.def	Thu Aug  5 07:43:12 1999
--- bash-2.05a/builtins/kill.def	Mon Oct 15 13:23:32 2001
***************
*** 59,64 ****
  
  #if defined (JOB_CONTROL)
- extern int interactive;
- extern int job_control;
  extern int posixly_correct;
  
--- 59,62 ----
***************
*** 79,82 ****
--- 77,81 ----
    char *sigspec, *word;
    pid_t pid;
+   long pid_value;
  
    if (list == 0)
***************
*** 165,172 ****
  	word++;
  
!       if (*word && all_digits (word))
  	{
  	  /* Use the entire argument in case of minus sign presence. */
! 	  pid = (pid_t) atoi (list->word->word);
  
  	  if (kill_pid (pid, signal, 0) < 0)
--- 164,171 ----
  	word++;
  
!       if (*word && legal_number (word, &pid_value) && (pid_value == (pid_t)pid_value))
  	{
  	  /* Use the entire argument in case of minus sign presence. */
! 	  pid = (pid_t) pid_value;
  
  	  if (kill_pid (pid, signal, 0) < 0)
***************
*** 208,217 ****
  	    {
  	    signal_error:
! 	      if (errno == EPERM)
! 		builtin_error ("(%d) - Not owner", (int)pid);
! 	      else if (errno == ESRCH)
! 		builtin_error ("(%d) - No such pid", (int)pid);
! 	      else
  		builtin_error ("Invalid signal %d", signal);
  	      CONTINUE_OR_FAIL;
  	    }
--- 207,214 ----
  	    {
  	    signal_error:
! 	      if (errno == EINVAL)
  		builtin_error ("Invalid signal %d", signal);
+ 	      else
+ 		builtin_error ("(%ld) - %s", (long)pid, strerror (errno));
  	      CONTINUE_OR_FAIL;
  	    }
diff -Nrc2 bash-2.05/builtins/let.def bash-2.05a/builtins/let.def
*** bash-2.05/builtins/let.def	Thu Aug  5 07:43:19 1999
--- bash-2.05a/builtins/let.def	Mon Sep 17 13:51:02 2001
***************
*** 94,98 ****
      }
  
!   return ((ret == 0L) ? EXECUTION_FAILURE : EXECUTION_SUCCESS);
  }
  
--- 94,98 ----
      }
  
!   return ((ret == 0) ? EXECUTION_FAILURE : EXECUTION_SUCCESS);
  }
  
***************
*** 114,118 ****
    ret = evalexp (exp, &expok);
    (void)free (exp);
!   return (((ret == 0L) || (expok == 0)) ? EXECUTION_FAILURE : EXECUTION_SUCCESS);
  }
  #endif
--- 114,118 ----
    ret = evalexp (exp, &expok);
    (void)free (exp);
!   return (((ret == 0) || (expok == 0)) ? EXECUTION_FAILURE : EXECUTION_SUCCESS);
  }
  #endif
diff -Nrc2 bash-2.05/builtins/mkbuiltins.c bash-2.05a/builtins/mkbuiltins.c
*** bash-2.05/builtins/mkbuiltins.c	Wed Feb 14 17:06:45 2001
--- bash-2.05a/builtins/mkbuiltins.c	Mon Oct 15 13:24:15 2001
***************
*** 40,43 ****
--- 40,45 ----
  #include <stdio.h>
  
+ #include "stdc.h"
+ 
  #define DOCFILE "builtins.texi"
  
***************
*** 224,228 ****
  	{
  	  temp_struct_filename = xmalloc (15);
! 	  sprintf (temp_struct_filename, "mk-%d", (int) getpid ());
  	  structfile = fopen (temp_struct_filename, "w");
  
--- 226,230 ----
  	{
  	  temp_struct_filename = xmalloc (15);
! 	  sprintf (temp_struct_filename, "mk-%ld", (long) getpid ());
  	  structfile = fopen (temp_struct_filename, "w");
  
***************
*** 379,393 ****
  /* The definition of a function. */
  typedef int Function ();
  
  /* Structure handles processor directives. */
  typedef struct {
    char *directive;
!   Function *function;
  } HANDLER_ENTRY;
  
! extern int
!   builtin_handler (), function_handler (), short_doc_handler (),
!   comment_handler (), depends_on_handler (), produces_handler (),
!   end_handler (), docname_handler ();
  
  HANDLER_ENTRY handlers[] = {
--- 381,400 ----
  /* The definition of a function. */
  typedef int Function ();
+ typedef int mk_handler_func_t __P((char *, DEF_FILE *, char *));
  
  /* Structure handles processor directives. */
  typedef struct {
    char *directive;
!   mk_handler_func_t *function;
  } HANDLER_ENTRY;
  
! extern int builtin_handler __P((char *, DEF_FILE *, char *));
! extern int function_handler __P((char *, DEF_FILE *, char *));
! extern int short_doc_handler __P((char *, DEF_FILE *, char *));
! extern int comment_handler __P((char *, DEF_FILE *, char *));
! extern int depends_on_handler __P((char *, DEF_FILE *, char *));
! extern int produces_handler __P((char *, DEF_FILE *, char *));
! extern int end_handler __P((char *, DEF_FILE *, char *));
! extern int docname_handler __P((char *, DEF_FILE *, char *));
  
  HANDLER_ENTRY handlers[] = {
***************
*** 401,405 ****
    { "PRODUCES", produces_handler },
    { "END", end_handler },
!   { (char *)NULL, (Function *)NULL }
  };
  
--- 408,412 ----
    { "PRODUCES", produces_handler },
    { "END", end_handler },
!   { (char *)NULL, (mk_handler_func_t *)NULL }
  };
  
***************
*** 725,730 ****
  int
  builtin_handler (self, defs, arg)
!      char *self, *arg;
       DEF_FILE *defs;
  {
    BUILTIN_DESC *new;
--- 732,738 ----
  int
  builtin_handler (self, defs, arg)
!      char *self;
       DEF_FILE *defs;
+      char *arg;
  {
    BUILTIN_DESC *new;
***************
*** 770,775 ****
  int
  function_handler (self, defs, arg)
!      char *self, *arg;
       DEF_FILE *defs;
  {
    register BUILTIN_DESC *builtin;
--- 778,784 ----
  int
  function_handler (self, defs, arg)
!      char *self;
       DEF_FILE *defs;
+      char *arg;
  {
    register BUILTIN_DESC *builtin;
***************
*** 794,799 ****
  int
  docname_handler (self, defs, arg)
!      char *self, *arg;
       DEF_FILE *defs;
  {
    register BUILTIN_DESC *builtin;
--- 803,809 ----
  int
  docname_handler (self, defs, arg)
!      char *self;
       DEF_FILE *defs;
+      char *arg;
  {
    register BUILTIN_DESC *builtin;
***************
*** 813,818 ****
  int
  short_doc_handler (self, defs, arg)
!      char *self, *arg;
       DEF_FILE *defs;
  {
    register BUILTIN_DESC *builtin;
--- 823,829 ----
  int
  short_doc_handler (self, defs, arg)
!      char *self;
       DEF_FILE *defs;
+      char *arg;
  {
    register BUILTIN_DESC *builtin;
***************
*** 831,837 ****
  /* How to handle the $COMMENT directive. */
  int
! comment_handler (self, defs)
       char *self;
       DEF_FILE *defs;
  {
    return (0);
--- 842,849 ----
  /* How to handle the $COMMENT directive. */
  int
! comment_handler (self, defs, arg)
       char *self;
       DEF_FILE *defs;
+      char *arg;
  {
    return (0);
***************
*** 841,846 ****
  int
  depends_on_handler (self, defs, arg)
!      char *self, *arg;
       DEF_FILE *defs;
  {
    register BUILTIN_DESC *builtin;
--- 853,859 ----
  int
  depends_on_handler (self, defs, arg)
!      char *self;
       DEF_FILE *defs;
+      char *arg;
  {
    register BUILTIN_DESC *builtin;
***************
*** 861,866 ****
  int
  produces_handler (self, defs, arg)
!      char *self, *arg;
       DEF_FILE *defs;
  {
    /* If just hacking documentation, don't change any of the production
--- 874,880 ----
  int
  produces_handler (self, defs, arg)
!      char *self;
       DEF_FILE *defs;
+      char *arg;
  {
    /* If just hacking documentation, don't change any of the production
***************
*** 894,899 ****
  int
  end_handler (self, defs, arg)
!      char *self, *arg;
       DEF_FILE *defs;
  {
    must_be_building (self, defs);
--- 908,914 ----
  int
  end_handler (self, defs, arg)
!      char *self;
       DEF_FILE *defs;
+      char *arg;
  {
    must_be_building (self, defs);
***************
*** 1057,1061 ****
    "   Functions which need to look at only the simple commands (e.g.",
    "   the enable_builtin ()), should ignore entries where",
!   "   (array[i].function == (Function *)NULL).  Such entries are for",
    "   the list of shell reserved control structures, like `if' and `while'.",
    "   The end of the list is denoted with a NULL name field. */",
--- 1072,1076 ----
    "   Functions which need to look at only the simple commands (e.g.",
    "   the enable_builtin ()), should ignore entries where",
!   "   (array[i].function == (sh_builtin_func_t *)NULL).  Such entries are for",
    "   the list of shell reserved control structures, like `if' and `while'.",
    "   The end of the list is denoted with a NULL name field. */",
***************
*** 1066,1070 ****
  
  char *structfile_footer[] = {
!   "  { (char *)0x0, (Function *)0x0, 0, (char **)0x0, (char *)0x0 }",
    "};",
    "",
--- 1081,1085 ----
  
  char *structfile_footer[] = {
!   "  { (char *)0x0, (sh_builtin_func_t *)0x0, 0, (char **)0x0, (char *)0x0 }",
    "};",
    "",
***************
*** 1148,1152 ****
  		{
  		  if (builtin->function)
! 		    fprintf (externfile, "extern int %s ();\n",
  			     builtin->function);
  
--- 1163,1167 ----
  		{
  		  if (builtin->function)
! 		    fprintf (externfile, "extern int %s __P((WORD_LIST *));\n",
  			     builtin->function);
  
***************
*** 1163,1167 ****
  		    fprintf (structfile, "%s, ", builtin->function);
  		  else
! 		    fprintf (structfile, "(Function *)0x0, ");
  
  		  fprintf (structfile, "%s%s%s, %s_doc,\n",
--- 1178,1182 ----
  		    fprintf (structfile, "%s, ", builtin->function);
  		  else
! 		    fprintf (structfile, "(sh_builtin_func_t *)0x0, ");
  
  		  fprintf (structfile, "%s%s%s, %s_doc,\n",
diff -Nrc2 bash-2.05/builtins/printf.def bash-2.05a/builtins/printf.def
*** bash-2.05/builtins/printf.def	Wed Feb 14 17:09:55 2001
--- bash-2.05a/builtins/printf.def	Thu Nov  1 12:37:49 2001
***************
*** 43,49 ****
  #  include <limits.h>
  #else
!    /* Assume 32-bit ints and longs. */
! #  define LONG_MAX		2147483647L
! #  define LONG_MIN		(-2147483647L-1)
  #  define INT_MAX		2147483647
  #  define INT_MIN		(-2147483647-1)
--- 43,47 ----
  #  include <limits.h>
  #else
!    /* Assume 32-bit ints. */
  #  define INT_MAX		2147483647
  #  define INT_MIN		(-2147483647-1)
***************
*** 51,60 ****
  
  #include <stdio.h>
! #include <ctype.h>
  
  #include "../bashansi.h"
  #include "../shell.h"
  #include "stdc.h"
  #include "bashgetopt.h"
  
  #if !defined (errno)
--- 49,73 ----
  
  #include <stdio.h>
! #include <chartypes.h>
! 
! #ifdef HAVE_INTTYPES_H
! #  include <inttypes.h>
! #endif
  
  #include "../bashansi.h"
+ 
+ #define NEED_STRTOIMAX_DECL
+ 
  #include "../shell.h"
  #include "stdc.h"
  #include "bashgetopt.h"
+ #include "common.h"
+ 
+ /* This should use the ISO C constant format strings; I'll do that later. */
+ #if SIZEOF_LONG < SIZEOF_LONG_LONG
+ #  define INTMAX_CONV	"ll"
+ #else
+ #  define INTMAX_CONV	"l"
+ #endif
  
  #if !defined (errno)
***************
*** 64,99 ****
  #define PF(f, func) \
    do { \
!     if (fieldwidth && precision) \
!       (void)printf(f, fieldwidth, precision, func); \
!     else if (fieldwidth && precision == 0) \
!       (void)printf(f, fieldwidth, func); \
!     else if (precision) \
!       (void)printf(f, precision, func); \
      else \
!       (void)printf(f, func); \
    } while (0)
  
  #define PRETURN(value) \
!   do { /* free (format); */ fflush (stdout); return (value); } while (0)
  
! #define  SKIP1 "#-+ 0"
! #define  SKIP2 "*0123456789"
  
  static void printstr __P((char *, char *, int, int, int));
  static int tescape __P((char *, int, char *, int *));
  static char *bexpand __P((char *, int, int *, int *));
! static char *mklong __P((char *, int));
  static int getchr __P((void));
  static char *getstr __P((void));
  static int  getint __P((void));
! static int getlong __P((long *));
! static int getulong __P((unsigned long *));
! static int getdouble __P((double *));
  static int asciicode __P((void));
  
  static WORD_LIST *garglist;
  static int retval;
  
! extern char *sh_backslash_quote ();
  
  int
--- 77,135 ----
  #define PF(f, func) \
    do { \
!     if (have_fieldwidth && have_precision) \
!       tw += printf(f, fieldwidth, precision, func); \
!     else if (have_fieldwidth) \
!       tw += printf(f, fieldwidth, func); \
!     else if (have_precision) \
!       tw += printf(f, precision, func); \
      else \
!       tw += printf(f, func); \
    } while (0)
  
+ /* We free the buffer used by mklong() if it's `too big'. */
  #define PRETURN(value) \
!   do \
!     { \
!       if (conv_bufsize > 4096 ) \
! 	{ \
! 	  free(conv_buf); \
! 	  conv_bufsize = 0; \
! 	  conv_buf = 0; \
! 	} \
!       fflush (stdout); \
!       return (value); \
!     } \
!   while (0)
  
! #define SKIP1 "#'-+ 0"
! #define LENMODS "hjlLtz"
  
  static void printstr __P((char *, char *, int, int, int));
  static int tescape __P((char *, int, char *, int *));
  static char *bexpand __P((char *, int, int *, int *));
! static char *mklong __P((char *, char *));
  static int getchr __P((void));
  static char *getstr __P((void));
  static int  getint __P((void));
! static long getlong __P((void));
! static unsigned long getulong __P((void));
! #if defined (HAVE_LONG_LONG)
! static long long getllong __P((void));
! static unsigned long long getullong __P((void));
! #endif
! static intmax_t getintmax __P((void));
! static uintmax_t getuintmax __P((void));
! static double getdouble __P((void));
! #if defined (HAVE_LONG_DOUBLE) && HAVE_DECL_STRTOLD
! static long double getldouble __P((void));
! #endif
  static int asciicode __P((void));
  
  static WORD_LIST *garglist;
  static int retval;
+ static int conversion_error;
  
! static char *conv_buf;
! static size_t conv_bufsize;
  
  int
***************
*** 101,118 ****
       WORD_LIST *list;
  {
!   int ch, end, fieldwidth, precision, foundmod, fmtlen;
!   char convch, nextch, *format, *fmt, *start;
  
    retval = EXECUTION_SUCCESS;
    reset_internal_getopt ();
!   while ((ch = internal_getopt (list, "")) != -1)
      {
!       switch (ch)
! 	{
! 	case '?':
! 	default:
! 	  builtin_usage();
! 	  return (EX_USAGE);
! 	}
      }
    list = loptend;
--- 137,152 ----
       WORD_LIST *list;
  {
!   int ch, fieldwidth, precision;
!   int have_fieldwidth, have_precision;
!   long tw;
!   char convch, thisch, nextch, *format, *modstart, *fmt, *start;
  
+   conversion_error = 0;
    retval = EXECUTION_SUCCESS;
    reset_internal_getopt ();
!   if (internal_getopt (list, "") != -1)
      {
!       builtin_usage();
!       return (EX_USAGE);
      }
    list = loptend;
***************
*** 141,156 ****
       arguments, arguments of zero/null string are provided to use
       up the format string. */
- 
    do
      {
        /* find next format specification */
        for (fmt = format; *fmt; fmt++)
  	{
! 	  precision = fieldwidth = foundmod = 0;
  
  	  if (*fmt == '\\')
  	    {
  	      fmt++;
! 	      /* A NULL third argument to tescape means to not do special
  		 processing for \c. */
  	      fmt += tescape (fmt, 1, &nextch, (int *)NULL);
--- 175,192 ----
       arguments, arguments of zero/null string are provided to use
       up the format string. */
    do
      {
+       tw = 0;
        /* find next format specification */
        for (fmt = format; *fmt; fmt++)
  	{
! 	  precision = fieldwidth = 0;
! 	  have_fieldwidth = have_precision = 0;
! 
  
  	  if (*fmt == '\\')
  	    {
  	      fmt++;
! 	      /* A NULL fourth argument to tescape means to not do special
  		 processing for \c. */
  	      fmt += tescape (fmt, 1, &nextch, (int *)NULL);
***************
*** 178,202 ****
  	  for (; *fmt && strchr(SKIP1, *fmt); ++fmt)
  	    ;
- 	  fieldwidth = (*fmt == '*') ? getint () : 0;
  
! 	  /* skip to possible '.', get following precision */
! 	  for (; *fmt && strchr(SKIP2, *fmt); ++fmt)
! 	    ;
  	  if (*fmt == '.')
  	    {
  	      ++fmt;
! 	      precision = (*fmt == '*') ? getint () : 0;
  	    }
  
- 	  /* skip to conversion char */
- 	  for (; *fmt && strchr(SKIP2, *fmt); ++fmt)
- 	    ;
- 
  	  /* skip possible format modifiers */
! 	  if (*fmt == 'l' || *fmt == 'L' || *fmt == 'h')
! 	    {
! 	      fmt++;
! 	      foundmod = 1;
! 	    }
  	    
  	  if (*fmt == 0)
--- 214,248 ----
  	  for (; *fmt && strchr(SKIP1, *fmt); ++fmt)
  	    ;
  
! 	  /* Skip optional field width. */
! 	  if (*fmt == '*')
! 	    {
! 	      fmt++;
! 	      have_fieldwidth = 1;
! 	      fieldwidth = getint ();
! 	    }
! 	  else
! 	    while (DIGIT (*fmt))
! 	      fmt++;
! 
! 	  /* Skip optional '.' and precision */
  	  if (*fmt == '.')
  	    {
  	      ++fmt;
! 	      if (*fmt == '*')
! 		{
! 		  fmt++;
! 		  have_precision = 1;
! 		  precision = getint ();
! 		}
! 	      else
! 		while (DIGIT (*fmt))
! 		  fmt++;
  	    }
  
  	  /* skip possible format modifiers */
! 	  modstart = fmt;
! 	  while (*fmt && strchr (LENMODS, *fmt))
! 	    fmt++;
  	    
  	  if (*fmt == 0)
***************
*** 207,212 ****
  
  	  convch = *fmt;
! 	  nextch = fmt[1];
! 	  fmt[1] = '\0';
  	  switch(convch)
  	    {
--- 253,261 ----
  
  	  convch = *fmt;
! 	  thisch = modstart[0];
! 	  nextch = modstart[1];
! 	  modstart[0] = convch;
! 	  modstart[1] = '\0';
! 
  	  switch(convch)
  	    {
***************
*** 229,232 ****
--- 278,299 ----
  	      }
  
+ 	    case 'n':
+ 	      {
+ 		char *var;
+ 
+ 		var = getstr ();
+ 		if (var && *var)
+ 		  {
+ 		    if (legal_identifier (var))
+ 		      bind_var_to_int (var, tw);
+ 		    else
+ 		      {
+ 			builtin_error ("%s: invalid variable name", var);
+ 			PRETURN (EXECUTION_FAILURE);
+ 		      }
+ 		  }
+ 		break;
+ 	      }
+ 
  	    case 'b':		/* expand escapes in argument */
  	      {
***************
*** 269,282 ****
  	    case 'i':
  	      {
- 		long p;
  		char *f;
  
! 		if (foundmod == 0 && ((f = mklong (start, convch)) == NULL))
! 		  PRETURN (EXECUTION_FAILURE);
  		else
! 		  f = start;
! 		if (getlong (&p))
! 		  PRETURN (EXECUTION_FAILURE);
! 		PF(f, p);
  		break;
  	      }
--- 336,367 ----
  	    case 'i':
  	      {
  		char *f;
+ #if defined (HAVE_LONG_LONG)
+ 		if (thisch == 'l' && nextch == 'l')
+ 		  {
+ 		    long long p;
+ 
+ 		    p = getllong ();
+ 		    f = mklong (start, "ll");
+ 		    PF(f, p);
+ 		  }
+ 		else
+ #endif
+ 		if (thisch == 'j')
+ 		  {
+ 		    intmax_t p;
  
! 		    p = getintmax ();
! 		    f = mklong (start, INTMAX_CONV);
! 		    PF(f, p);
! 		  }
  		else
! 		  {
! 		    long p;
! 
! 		    p = getlong ();
! 		    f = mklong (start, "l");
! 		    PF(f, p);
! 		  }
  		break;
  	      }
***************
*** 287,300 ****
  	    case 'X':
  	      {
- 		unsigned long p;
  		char *f;
  
! 		if (foundmod == 0 && ((f = mklong (start, convch)) == NULL))
! 		  PRETURN (EXECUTION_FAILURE);
  		else
! 		  f = start;
! 		if (getulong (&p))
! 		  PRETURN (EXECUTION_FAILURE);
! 		PF (f, p);
  		break;
  	      }
--- 372,403 ----
  	    case 'X':
  	      {
  		char *f;
+ #if defined (HAVE_LONG_LONG)
+ 		if (thisch == 'l' && nextch == 'l')
+ 		  {
+ 		    unsigned long long p;
  
! 		    p = getullong ();
! 		    f = mklong (start, "ll");
! 		    PF(f, p);
! 		  }
  		else
! #endif
! 		if (thisch == 'j')
! 		  {
! 		    uintmax_t p;
! 
! 		    p = getuintmax ();
! 		    f = mklong (start, INTMAX_CONV);
! 		    PF(f, p);
! 		  }
! 		else
! 		  {
! 		    unsigned long p;
! 
! 		    p = getulong ();
! 		    f = mklong (start, "l");
! 		    PF (f, p);
! 		  }
  		break;
  	      }
***************
*** 303,314 ****
  	    case 'E':
  	    case 'f':
  	    case 'g':
  	    case 'G':
  	      {
! 		double p;
  
! 		if (getdouble (&p))
! 		  PRETURN (EXECUTION_FAILURE);
! 		PF(start, p);
  		break;
  	      }
--- 406,436 ----
  	    case 'E':
  	    case 'f':
+ 	    case 'F':
  	    case 'g':
  	    case 'G':
+ #if defined (HAVE_PRINTF_A_FORMAT)
+ 	    case 'a':
+ 	    case 'A':
+ #endif
  	      {
! 		char *f;
! #if defined (HAVE_LONG_DOUBLE) && HAVE_DECL_STRTOLD
! 		if (thisch == 'L')
! 		  {
! 		    long double p;
  
! 		    p = getldouble ();
! 		    f = mklong (start, "L");
! 		    PF (f, p);
! 		  }
! 		else
! #endif
! 		  {
! 		    double p;
! 
! 		    p = getdouble ();
! 		    f = mklong (start, "");
! 		    PF (f, p);
! 		  }
  		break;
  	      }
***************
*** 321,329 ****
  	    }
  
! 	  fmt[1] = nextch;
  	}
      }
    while (garglist && garglist != list->next);
  
    PRETURN (retval);
  }
--- 443,455 ----
  	    }
  
! 	  modstart[0] = thisch;
! 	  modstart[1] = nextch;
  	}
      }
    while (garglist && garglist != list->next);
  
+   if (conversion_error)
+     retval = EXECUTION_FAILURE;
+ 
    PRETURN (retval);
  }
***************
*** 353,360 ****
      fmt++;
  
!   ljust = fw = pr = 0;
  
    /* skip flags */
!   while (*fmt == '#' || *fmt == '-' || *fmt == '+' || *fmt == ' ' || *fmt == '0')
      {
        if (*fmt == '-')
--- 479,487 ----
      fmt++;
  
!   ljust = fw = 0;
!   pr = -1;
  
    /* skip flags */
!   while (strchr (SKIP1, *fmt))
      {
        if (*fmt == '-')
***************
*** 368,376 ****
        fmt++;
        fw = fieldwidth;
      }
!   else if (isdigit (*fmt))
      {
        fw = *fmt++ - '0';
!       while (isdigit (*fmt))
  	fw = (fw * 10) + (*fmt++ - '0');
      }
--- 495,508 ----
        fmt++;
        fw = fieldwidth;
+       if (fw < 0)
+ 	{
+ 	  fw = -fw;
+ 	  ljust = 1;
+ 	}
      }
!   else if (DIGIT (*fmt))
      {
        fw = *fmt++ - '0';
!       while (DIGIT (*fmt))
  	fw = (fw * 10) + (*fmt++ - '0');
      }
***************
*** 385,392 ****
  	  pr = precision;
  	}
!       else if (isdigit (*fmt))
  	{
  	  pr = *fmt++ - '0';
! 	  while (isdigit (*fmt))
  	    pr = (pr * 10) + (*fmt++ - '0');
  	}
--- 517,524 ----
  	  pr = precision;
  	}
!       else if (DIGIT (*fmt))
  	{
  	  pr = *fmt++ - '0';
! 	  while (DIGIT (*fmt))
  	    pr = (pr * 10) + (*fmt++ - '0');
  	}
***************
*** 403,407 ****
  
    /* chars from string to print */
!   nc = (pr > 0 && pr <= len) ? pr : len;
  
    padlen = fw - nc;
--- 535,539 ----
  
    /* chars from string to print */
!   nc = (pr >= 0 && pr <= len) ? pr : len;
  
    padlen = fw - nc;
***************
*** 429,447 ****
     *SAWC to 1 before returning.  LEN is the length of STRING. */
  
- #ifdef isoctal
- #undef isoctal
- #endif
- 
- #define isoctal(c)	((c) >= '0' && (c) <= '7')
- 
- #define OCTVALUE(c)	((c) - '0')
- 
- #ifndef isxdigit
- #  define isxdigit(c)	(isdigit((c)) || ((c) >= 'a' && (c) <= 'f') || ((c) >= 'A' && (c) <= 'F'))
- #endif
- 
- #define HEXVALUE(c) \
-   ((c) >= 'a' && (c) <= 'f' ? (c)-'a'+10 : (c) >= 'A' && (c) <= 'F' ? (c)-'A'+10 : (c)-'0')
- 
  /* Translate a single backslash-escape sequence starting at ESTART (the
     character after the backslash) and return the number of characters
--- 561,564 ----
***************
*** 489,495 ****
  	 octal digits... */
        case '0':
! 	for (temp = 3, evalue = 0; isoctal (*p) && temp--; p++)
  	  evalue = (evalue * 8) + OCTVALUE (*p);
! 	*cp = evalue;
  	break;
  
--- 606,612 ----
  	 octal digits... */
        case '0':
! 	for (temp = 3, evalue = 0; ISOCTAL (*p) && temp--; p++)
  	  evalue = (evalue * 8) + OCTVALUE (*p);
! 	*cp = evalue & 0xFF;
  	break;
  
***************
*** 498,504 ****
        case '1': case '2': case '3': case '4':
        case '5': case '6': case '7':
! 	for (temp = 2, evalue = c - '0'; isoctal (*p) && temp--; p++)
  	  evalue = (evalue * 8) + OCTVALUE (*p);
! 	*cp = evalue;
  	break;
  
--- 615,621 ----
        case '1': case '2': case '3': case '4':
        case '5': case '6': case '7':
! 	for (temp = 2, evalue = c - '0'; ISOCTAL (*p) && temp--; p++)
  	  evalue = (evalue * 8) + OCTVALUE (*p);
! 	*cp = evalue & 0xFF;
  	break;
  
***************
*** 506,512 ****
  	 hex digit. */
        case 'x':
! 	for (temp = 3, evalue = 0; isxdigit (*p) && temp--; p++)
  	  evalue = (evalue * 16) + HEXVALUE (*p);
! 	if (temp == 3)
  	  {
  	    builtin_error ("missing hex digit for \\x");
--- 623,629 ----
  	 hex digit. */
        case 'x':
! 	for (temp = 2, evalue = 0; ISXDIGIT ((unsigned char)*p) && temp--; p++)
  	  evalue = (evalue * 16) + HEXVALUE (*p);
! 	if (temp == 2)
  	  {
  	    builtin_error ("missing hex digit for \\x");
***************
*** 514,518 ****
  	    return 0;
  	  }
! 	*cp = evalue;
  	break;
  
--- 631,635 ----
  	    return 0;
  	  }
! 	*cp = evalue & 0xFF;
  	break;
  
***************
*** 562,566 ****
      }
  
!   ret = xmalloc (len + 1);
    for (r = ret, s = string; s && *s; )
      {
--- 679,683 ----
      }
  
!   ret = (char *)xmalloc (len + 1);
    for (r = ret, s = string; s && *s; )
      {
***************
*** 590,606 ****
  
  static char *
! mklong (str, ch)
       char *str;
!      int ch;
  {
!   static char copy[64];
!   int len;
  
!   len = strlen (str) + 2;
!   FASTCOPY (str, copy, len - 3);
!   copy[len - 3] = 'l';
!   copy[len - 2] = ch;
!   copy[len - 1] = '\0';
!   return (copy);
  }
  
--- 707,732 ----
  
  static char *
! mklong (str, modifiers)
       char *str;
!      char *modifiers;
  {
!   size_t len, slen, mlen;
! 
!   slen = strlen (str);
!   mlen = strlen (modifiers);
!   len = slen + mlen + 1;
! 
!   if (len > conv_bufsize)
!     {
!       conv_bufsize = (((len + 1023) >> 10) << 10);
!       conv_buf = (char *)xrealloc (conv_buf, conv_bufsize);
!     }
! 
!   FASTCOPY (str, conv_buf, slen - 1);
!   FASTCOPY (modifiers, conv_buf + slen - 1, mlen);
  
!   conv_buf[len - 2] = str[slen - 1];
!   conv_buf[len - 1] = '\0';
!   return (conv_buf);
  }
  
***************
*** 636,641 ****
    long ret;
  
!   if (getlong (&ret))
!     return (0);
  
    if (ret > INT_MAX)
--- 762,766 ----
    long ret;
  
!   ret = getlong ();
  
    if (ret > INT_MAX)
***************
*** 653,659 ****
  }
  
! static int
! getlong (lp)
!      long *lp;
  {
    long ret;
--- 778,783 ----
  }
  
! static long
! getlong ()
  {
    long ret;
***************
*** 661,697 ****
  
    if (garglist == 0)
!     {
!       *lp = 0L;
!       return (0);
!     }
  
    if (garglist->word->word[0] == '\'' || garglist->word->word[0] == '"')
!     {
!       *lp =  (long)asciicode ();
!       return (0);
!     }
  
    errno = 0;
-   /* If we use 0 as the third argument, we can handle octal and hex, which
-      legal_number does not.  (This was
- 	  if (legal_number (garglist->word->word, &ret) == 0)
-      ) */
    ret = strtol (garglist->word->word, &ep, 0);
!   if (*ep != '\0')
      {
        builtin_error ("%s: invalid number", garglist->word->word);
!       return (1);
      }
    else if (errno == ERANGE)
      builtin_error ("warning: %s: %s", garglist->word->word, strerror(ERANGE));
  
-   *lp = ret;
    garglist = garglist->next;
!   return (0);
  }
  
! static int
! getulong (ulp)
!      unsigned long *ulp;
  {
    unsigned long ret;
--- 785,816 ----
  
    if (garglist == 0)
!     return (0);
  
    if (garglist->word->word[0] == '\'' || garglist->word->word[0] == '"')
!     return asciicode ();
  
    errno = 0;
    ret = strtol (garglist->word->word, &ep, 0);
! 
!   if (*ep)
      {
        builtin_error ("%s: invalid number", garglist->word->word);
!       /* POSIX.2 says ``...a diagnostic message shall be written to standard
! 	 error, and the utility shall not exit with a zero exit status, but
! 	 shall continue processing any remaining operands and shall write the
!          value accumulated at the time the error was detected to standard
! 	 output.''  Yecch. */
!       ret = 0;
!       conversion_error = 1;
      }
    else if (errno == ERANGE)
      builtin_error ("warning: %s: %s", garglist->word->word, strerror(ERANGE));
  
    garglist = garglist->next;
!   return (ret);
  }
  
! static unsigned long
! getulong ()
  {
    unsigned long ret;
***************
*** 699,762 ****
  
    if (garglist == 0)
      {
!       *ulp = (unsigned long)0;
!       return (0);
      }
  
    if (garglist->word->word[0] == '\'' || garglist->word->word[0] == '"')
      {
!       *ulp =  (unsigned long)asciicode ();
!       return (0);
      }
  
    errno = 0;
!   ret = strtoul (garglist->word->word, &ep, 0);
    
    if (*ep)
      {
        builtin_error ("%s: invalid number", garglist->word->word);
!       return (1);
      }
    else if (errno == ERANGE)
      builtin_error ("warning: %s: %s", garglist->word->word, strerror(ERANGE));
  
-   *ulp = ret;
    garglist = garglist->next;
!   return (0);
  }
  
! static int
! getdouble (dp)
!      double *dp;
  {
!   double ret;
    char *ep;
  
    if (garglist == 0)
      {
!       *dp = (double)0;
!       return (0);
      }
  
    if (garglist->word->word[0] == '\'' || garglist->word->word[0] == '"')
      {
!       *dp = (double)asciicode ();
!       return (0);
      }
  
    errno = 0;
    ret = strtod (garglist->word->word, &ep);
    if (*ep)
      {
        builtin_error ("%s: invalid number", garglist->word->word);
!       return (1);
      }
    else if (errno == ERANGE)
      builtin_error ("warning: %s: %s", garglist->word->word, strerror(ERANGE));
  
-   *dp = ret;
    garglist = garglist->next;
!   return (0);
  }
  
  /* NO check is needed for garglist here. */
--- 818,1030 ----
  
    if (garglist == 0)
+     return (0);
+ 
+   if (garglist->word->word[0] == '\'' || garglist->word->word[0] == '"')
+     return asciicode ();
+ 
+   errno = 0;
+   ret = strtoul (garglist->word->word, &ep, 0);
+   
+   if (*ep)
      {
!       builtin_error ("%s: invalid number", garglist->word->word);
!       /* Same thing about POSIX.2 conversion error requirements as getlong(). */
!       ret = 0;
!       conversion_error = 1;
      }
+   else if (errno == ERANGE)
+     builtin_error ("warning: %s: %s", garglist->word->word, strerror(ERANGE));
+ 
+   garglist = garglist->next;
+   return (ret);
+ }
+ 
+ #if defined (HAVE_LONG_LONG)
+ 
+ static long long
+ getllong ()
+ {
+   long long ret;
+   char *ep;
+ 
+   if (garglist == 0)
+     return (0);
  
    if (garglist->word->word[0] == '\'' || garglist->word->word[0] == '"')
+     return asciicode ();
+ 
+   errno = 0;
+   ret = strtoll (garglist->word->word, &ep, 0);
+ 
+   if (*ep)
      {
!       builtin_error ("%s: invalid number", garglist->word->word);
!       /* POSIX.2 says ``...a diagnostic message shall be written to standard
! 	 error, and the utility shall not exit with a zero exit status, but
! 	 shall continue processing any remaining operands and shall write the
!          value accumulated at the time the error was detected to standard
! 	 output.''  Yecch. */
!       ret = 0;
!       conversion_error = 1;
      }
+   else if (errno == ERANGE)
+     builtin_error ("warning: %s: %s", garglist->word->word, strerror(ERANGE));
+ 
+   garglist = garglist->next;
+   return (ret);
+ }
+ 
+ static unsigned long long
+ getullong ()
+ {
+   unsigned long long ret;
+   char *ep;
+ 
+   if (garglist == 0)
+     return (0);
+ 
+   if (garglist->word->word[0] == '\'' || garglist->word->word[0] == '"')
+     return asciicode ();
  
    errno = 0;
!   ret = strtoull (garglist->word->word, &ep, 0);
    
    if (*ep)
      {
        builtin_error ("%s: invalid number", garglist->word->word);
!       /* Same thing about POSIX.2 conversion error requirements as getlong(). */
!       ret = 0;
!       conversion_error = 1;
      }
    else if (errno == ERANGE)
      builtin_error ("warning: %s: %s", garglist->word->word, strerror(ERANGE));
  
    garglist = garglist->next;
!   return (ret);
  }
  
! #endif /* HAVE_LONG_LONG */
! 
! static intmax_t
! getintmax ()
  {
!   intmax_t ret;
    char *ep;
  
    if (garglist == 0)
+     return (0);
+ 
+   if (garglist->word->word[0] == '\'' || garglist->word->word[0] == '"')
+     return asciicode ();
+ 
+   errno = 0;
+   ret = strtoimax (garglist->word->word, &ep, 0);
+ 
+   if (*ep)
      {
!       builtin_error ("%s: invalid number", garglist->word->word);
!       /* POSIX.2 says ``...a diagnostic message shall be written to standard
! 	 error, and the utility shall not exit with a zero exit status, but
! 	 shall continue processing any remaining operands and shall write the
!          value accumulated at the time the error was detected to standard
! 	 output.''  Yecch. */
!       ret = 0;
!       conversion_error = 1;
      }
+   else if (errno == ERANGE)
+     builtin_error ("warning: %s: %s", garglist->word->word, strerror(ERANGE));
+ 
+   garglist = garglist->next;
+   return (ret);
+ }
+ 
+ static uintmax_t
+ getuintmax ()
+ {
+   uintmax_t ret;
+   char *ep;
+ 
+   if (garglist == 0)
+     return (0);
  
    if (garglist->word->word[0] == '\'' || garglist->word->word[0] == '"')
+     return asciicode ();
+ 
+   errno = 0;
+   ret = strtoumax (garglist->word->word, &ep, 0);
+   
+   if (*ep)
      {
!       builtin_error ("%s: invalid number", garglist->word->word);
!       /* Same thing about POSIX.2 conversion error requirements as getlong(). */
!       ret = 0;
!       conversion_error = 1;
      }
+   else if (errno == ERANGE)
+     builtin_error ("warning: %s: %s", garglist->word->word, strerror(ERANGE));
+ 
+   garglist = garglist->next;
+   return (ret);
+ }
+ 
+ static double
+ getdouble ()
+ {
+   double ret;
+   char *ep;
+ 
+   if (garglist == 0)
+     return (0);
+ 
+   if (garglist->word->word[0] == '\'' || garglist->word->word[0] == '"')
+     return asciicode ();
  
    errno = 0;
    ret = strtod (garglist->word->word, &ep);
+ 
+   if (*ep)
+     {
+       builtin_error ("%s: invalid number", garglist->word->word);
+       /* Same thing about POSIX.2 conversion error requirements. */
+       ret = 0;
+       conversion_error = 1;
+     }
+   else if (errno == ERANGE)
+     builtin_error ("warning: %s: %s", garglist->word->word, strerror(ERANGE));
+ 
+   garglist = garglist->next;
+   return (ret);
+ }
+ 
+ #if defined (HAVE_LONG_DOUBLE) && HAVE_DECL_STRTOLD
+ static long double
+ getldouble ()
+ {
+   long double ret;
+   char *ep;
+ 
+   if (garglist == 0)
+     return (0);
+ 
+   if (garglist->word->word[0] == '\'' || garglist->word->word[0] == '"')
+     return (asciicode ());
+ 
+   errno = 0;
+   ret = strtold (garglist->word->word, &ep);
+ 
    if (*ep)
      {
        builtin_error ("%s: invalid number", garglist->word->word);
!       /* Same thing about POSIX.2 conversion error requirements. */
!       ret = 0;
!       conversion_error = 1;
      }
    else if (errno == ERANGE)
      builtin_error ("warning: %s: %s", garglist->word->word, strerror(ERANGE));
  
    garglist = garglist->next;
!   return (ret);
  }
+ #endif /* HAVE_LONG_DOUBLE && HAVE_DECL_STRTOLD */
  
  /* NO check is needed for garglist here. */
diff -Nrc2 bash-2.05/builtins/psize.sh bash-2.05a/builtins/psize.sh
*** bash-2.05/builtins/psize.sh	Mon Feb 14 10:53:07 2000
--- bash-2.05a/builtins/psize.sh	Thu Nov  1 10:57:35 2001
***************
*** 5,12 ****
  
  : ${TMPDIR:=/tmp}
! TMPNAME=pipsize.$$
! TMPFILE=$TMPDIR/$TMPNAME
  
! trap 'rm -f $TMPFILE' 0 1 2 3 6 15
  
  echo "/*"
--- 5,20 ----
  
  : ${TMPDIR:=/tmp}
! # try to use mktemp(1) if the system supports it
! { TMPFILE="`mktemp $TMPDIR/pipsize.XXXXXX 2>/dev/null`"; } 2>/dev/null
! used_mktemp=true
  
! if [ -z "$TMPFILE" ]; then
! 	TMPNAME=pipsize.$$
! 	TMPFILE=$TMPDIR/$TMPNAME
! 	used_mktemp=false
! fi
! 
! trap 'rm -f "$TMPFILE" ; exit 1' 1 2 3 6 15
! trap 'rm -f "$TMPFILE"' 0
  
  echo "/*"
***************
*** 22,33 ****
  # existance before we run psize.aux, because `test -e' is not portable,
  # `test -h' (test for symlinks) is not portable, and `test -f' only
! # checks for regular files
  #
! rm -f $TMPFILE
  
! ./psize.aux 2>$TMPFILE | sleep 3
  
! if [ -s $TMPFILE ]; then
! 	echo "#define PIPESIZE `cat $TMPFILE`"
  else
  	echo "#define PIPESIZE 512"
--- 30,42 ----
  # existance before we run psize.aux, because `test -e' is not portable,
  # `test -h' (test for symlinks) is not portable, and `test -f' only
! # checks for regular files.  If we used mktemp(1), we're ahead of the
! # game.
  #
! $used_mktemp || rm -f "$TMPFILE"
  
! ./psize.aux 2>"$TMPFILE" | sleep 3
  
! if [ -s "$TMPFILE" ]; then
! 	echo "#define PIPESIZE `cat "$TMPFILE"`"
  else
  	echo "#define PIPESIZE 512"
diff -Nrc2 bash-2.05/builtins/pushd.def bash-2.05a/builtins/pushd.def
*** bash-2.05/builtins/pushd.def	Wed Feb 14 17:10:37 2001
--- bash-2.05a/builtins/pushd.def	Mon Sep 17 13:46:28 2001
***************
*** 137,146 ****
  static int directory_list_offset;
  
! static void pushd_error ();
! static void clear_directory_stack ();
! static int cd_to_string ();
! static int change_to_temp ();
! static int get_dirstack_index ();
! static void add_dirstack_element ();
  
  #define NOCD		0x01
--- 137,146 ----
  static int directory_list_offset;
  
! static void pushd_error __P((int, char *));
! static void clear_directory_stack __P((void));
! static int cd_to_string __P((char *));
! static int change_to_temp __P((char *));
! static void add_dirstack_element __P((char *));
! static int get_dirstack_index __P((long, int, int *));
  
  #define NOCD		0x01
***************
*** 294,298 ****
  
    which_word = (char *)NULL;
!   for (flags = 0, which = 0L, direction = '+'; list; list = list->next)
      {
        if (ISOPTION (list->word->word, 'n'))
--- 294,298 ----
  
    which_word = (char *)NULL;
!   for (flags = 0, which = 0, direction = '+'; list; list = list->next)
      {
        if (ISOPTION (list->word->word, 'n'))
***************
*** 538,542 ****
  static int
  get_dirstack_index (ind, sign, indexp)
!      int ind, sign, *indexp;
  {
    if (indexp)
--- 538,543 ----
  static int
  get_dirstack_index (ind, sign, indexp)
!      long ind;
!      int sign, *indexp;
  {
    if (indexp)
***************
*** 553,558 ****
        return 0;
      }
!   else
      return (sign > 0 ? directory_list_offset - ind : ind);
  }
  
--- 554,561 ----
        return 0;
      }
!   else if (ind >= 0 && ind <= directory_list_offset)
      return (sign > 0 ? directory_list_offset - ind : ind);
+   else
+     return -1;
  }
  
***************
*** 587,591 ****
  char *
  get_dirstack_element (ind, sign)
!      int ind, sign;
  {
    int i;
--- 590,595 ----
  char *
  get_dirstack_element (ind, sign)
!      long ind;
!      int sign;
  {
    int i;
***************
*** 599,603 ****
  void
  set_dirstack_element (ind, sign, value)
!      int ind, sign;
       char *value;
  {
--- 603,608 ----
  void
  set_dirstack_element (ind, sign, value)
!      long ind;
!      int  sign;
       char *value;
  {
diff -Nrc2 bash-2.05/builtins/read.def bash-2.05a/builtins/read.def
*** bash-2.05/builtins/read.def	Wed Feb 14 17:10:46 2001
--- bash-2.05a/builtins/read.def	Wed Oct 31 10:31:52 2001
***************
*** 84,96 ****
  
  #if defined (READLINE)
! static char *edit_line ();
! static void set_eol_delim ();
! static void reset_eol_delim ();
  #endif
! static SHELL_VAR *bind_read_variable ();
  
  static procenv_t alrmbuf;
  static SigHandler *old_alrm;
! static int delim;
  
  static sighandler
--- 84,99 ----
  
  #if defined (READLINE)
! static char *edit_line __P((char *));
! static void set_eol_delim __P((int));
! static void reset_eol_delim __P((char *));
  #endif
! static SHELL_VAR *bind_read_variable __P((char *, char *));
! 
! static sighandler sigalrm __P((int));
! static void reset_alarm __P((void));
  
  static procenv_t alrmbuf;
  static SigHandler *old_alrm;
! static unsigned char delim;
  
  static sighandler
***************
*** 121,125 ****
    int size, i, pass_next, saw_escape, eof, opt, retval, code;
    int input_is_tty, input_is_pipe, unbuffered_read;
!   int raw, edit, tmout, nchars, silent;
    long timeoutval, ncharsval;
    char c;
--- 124,129 ----
    int size, i, pass_next, saw_escape, eof, opt, retval, code;
    int input_is_tty, input_is_pipe, unbuffered_read;
!   int raw, edit, nchars, silent, have_timeout;
!   unsigned int tmout;
    long timeoutval, ncharsval;
    char c;
***************
*** 136,139 ****
--- 140,162 ----
  #endif
  
+   USE_VAR(size);
+   USE_VAR(i);
+   USE_VAR(pass_next);
+   USE_VAR(saw_escape);
+   USE_VAR(input_is_pipe);
+ /*  USE_VAR(raw); */
+   USE_VAR(edit);
+   USE_VAR(tmout);
+   USE_VAR(nchars);
+   USE_VAR(silent);
+   USE_VAR(ifs_chars);
+   USE_VAR(prompt);
+   USE_VAR(arrayname);
+ #if defined (READLINE)
+   USE_VAR(rlbuf);
+   USE_VAR(rlind);
+ #endif
+   USE_VAR(list);
+ 
    i = 0;		/* Index into the string that we are reading. */
    raw = edit = 0;	/* Not reading raw input by default. */
***************
*** 146,151 ****
  #endif
  
!   tmout = -1;		/* no timeout */
!   nchars = input_is_tty = input_is_pipe = unbuffered_read = 0;
    delim = '\n';		/* read until newline */
  
--- 169,174 ----
  #endif
  
!   tmout = 0;		/* no timeout */
!   nchars = input_is_tty = input_is_pipe = unbuffered_read = have_timeout = 0;
    delim = '\n';		/* read until newline */
  
***************
*** 176,180 ****
  	case 't':
  	  code = legal_number (list_optarg, &timeoutval);
! 	  if (code == 0 || timeoutval < 0)
  	    {
  	      builtin_error ("%s: invalid timeout specification", list_optarg);
--- 199,203 ----
  	case 't':
  	  code = legal_number (list_optarg, &timeoutval);
! 	  if (code == 0 || timeoutval < 0 || timeoutval != (unsigned int)timeoutval)
  	    {
  	      builtin_error ("%s: invalid timeout specification", list_optarg);
***************
*** 182,190 ****
  	    }
  	  else
! 	    tmout = timeoutval;
  	  break;
  	case 'n':
  	  code = legal_number (list_optarg, &ncharsval);
! 	  if (code == 0 || ncharsval < 0)
  	    {
  	      builtin_error ("%s: invalid number specification", list_optarg);
--- 205,216 ----
  	    }
  	  else
! 	    {
! 	      have_timeout = 1;
! 	      tmout = timeoutval;
! 	    }
  	  break;
  	case 'n':
  	  code = legal_number (list_optarg, &ncharsval);
! 	  if (code == 0 || ncharsval < 0 || ncharsval != (int)ncharsval)
  	    {
  	      builtin_error ("%s: invalid number specification", list_optarg);
***************
*** 205,209 ****
  
    /* `read -t 0 var' returns failure immediately. */
!   if (tmout == 0)
      return (EXECUTION_FAILURE);
  
--- 231,235 ----
  
    /* `read -t 0 var' returns failure immediately. */
!   if (have_timeout && tmout == 0)
      return (EXECUTION_FAILURE);
  
***************
*** 214,218 ****
      ifs_chars = "";		/* XXX */
  
!   input_string = xmalloc (size = 128);
  
    begin_unwind_frame ("read_builtin");
--- 240,244 ----
      ifs_chars = "";		/* XXX */
  
!   input_string = (char *)xmalloc (size = 128);
  
    begin_unwind_frame ("read_builtin");
***************
*** 251,255 ****
  	 input redirection). */
        if ((fstat (0, &tsb) < 0) || S_ISREG (tsb.st_mode))
! 	tmout = -1;
      }
  
--- 277,281 ----
  	 input redirection). */
        if ((fstat (0, &tsb) < 0) || S_ISREG (tsb.st_mode))
! 	tmout = 0;
      }
  
***************
*** 359,363 ****
        if (i + 2 >= size)
  	{
! 	  input_string = xrealloc (input_string, size += 128);
  	  remove_unwind_protect ();
  	  add_unwind_protect (xfree, input_string);
--- 385,389 ----
        if (i + 2 >= size)
  	{
! 	  input_string = (char *)xrealloc (input_string, size += 128);
  	  remove_unwind_protect ();
  	  add_unwind_protect (xfree, input_string);
***************
*** 384,388 ****
  	}
  
!       if (c == delim)
  	break;
  
--- 410,414 ----
  	}
  
!       if ((unsigned char)c == delim)
  	break;
  
***************
*** 411,415 ****
  	    rl_num_chars_to_read = 0;
  	  if (delim != '\n')
! 	    reset_eol_delim ();
  	}
        else
--- 437,441 ----
  	    rl_num_chars_to_read = 0;
  	  if (delim != '\n')
! 	    reset_eol_delim ((char *)NULL);
  	}
        else
***************
*** 434,443 ****
    if (arrayname)
      {
!       var = find_variable (arrayname);
        if (var == 0)
! 	var = make_new_array_variable (arrayname);
!       else if (array_p (var) == 0)
! 	var = convert_var_to_array (var);
! 
        empty_array (array_cell (var));
  
--- 460,466 ----
    if (arrayname)
      {
!       var = find_or_make_array_variable (arrayname, 1);
        if (var == 0)
! 	return EXECUTION_FAILURE;	/* readonly or noassign */
        empty_array (array_cell (var));
  
***************
*** 505,509 ****
  	{
  	  builtin_error ("`%s': not a valid identifier", varname);
! 	  free (orig_input_string);
  	  return (EXECUTION_FAILURE);
  	}
--- 528,532 ----
  	{
  	  builtin_error ("`%s': not a valid identifier", varname);
! 	  xfree (orig_input_string);
  	  return (EXECUTION_FAILURE);
  	}
***************
*** 523,527 ****
  	      t1 = dequote_string (t);
  	      var = bind_read_variable (varname, t1);
! 	      free (t1);
  	    }
  	  else
--- 546,550 ----
  	      t1 = dequote_string (t);
  	      var = bind_read_variable (varname, t1);
! 	      xfree (t1);
  	    }
  	  else
***************
*** 537,541 ****
        if (var == 0)
  	{
! 	  free (orig_input_string);
  	  return (EXECUTION_FAILURE);
  	}
--- 560,564 ----
        if (var == 0)
  	{
! 	  xfree (orig_input_string);
  	  return (EXECUTION_FAILURE);
  	}
***************
*** 553,557 ****
      {
        builtin_error ("`%s': not a valid identifier", list->word->word);
!       free (orig_input_string);
        return (EXECUTION_FAILURE);
      }
--- 576,580 ----
      {
        builtin_error ("`%s': not a valid identifier", list->word->word);
!       xfree (orig_input_string);
        return (EXECUTION_FAILURE);
      }
***************
*** 566,570 ****
        t = dequote_string (input_string);
        var = bind_read_variable (list->word->word, t);
!       free (t);
      }
    else
--- 589,593 ----
        t = dequote_string (input_string);
        var = bind_read_variable (list->word->word, t);
!       xfree (t);
      }
    else
***************
*** 573,577 ****
    if (var)
      VUNSETATTR (var, att_invisible);
!   free (orig_input_string);
  
    return (retval);
--- 596,600 ----
    if (var)
      VUNSETATTR (var, att_invisible);
!   xfree (orig_input_string);
  
    return (retval);
***************
*** 584,602 ****
  #if defined (ARRAY_VARS)
    if (valid_array_reference (name) == 0)
!     {
! #if 0
!       if (legal_identifier (name) == 0)
! 	{
! 	  builtin_error ("`%s': not a valid identifier", name);
! 	  return ((SHELL_VAR *)NULL);
! 	}
! #endif
!       return (bind_variable (name, value));
!     }
    else
!     return (do_array_element_assignment (name, value));
! #else
    return bind_variable (name, value);
! #endif
  }
  
--- 607,616 ----
  #if defined (ARRAY_VARS)
    if (valid_array_reference (name) == 0)
!     return (bind_variable (name, value));
    else
!     return (assign_array_element (name, value));
! #else /* !ARRAY_VARS */
    return bind_variable (name, value);
! #endif /* !ARRAY_VARS */
  }
  
***************
*** 615,619 ****
      return ret;
    len = strlen (ret);
!   ret = xrealloc (ret, len + 2);
    ret[len++] = delim;
    ret[len] = '\0';
--- 629,633 ----
      return ret;
    len = strlen (ret);
!   ret = (char *)xrealloc (ret, len + 2);
    ret[len++] = delim;
    ret[len] = '\0';
***************
*** 622,630 ****
  
  static int old_delim_ctype;
! static Function *old_delim_func;
  static int old_newline_ctype;
! static Function *old_newline_func;
  
! static int delim_char;
  
  static void
--- 636,644 ----
  
  static int old_delim_ctype;
! static rl_command_func_t *old_delim_func;
  static int old_newline_ctype;
! static rl_command_func_t *old_newline_func;
  
! static unsigned char delim_char;
  
  static void
***************
*** 654,659 ****
  
  static void
! reset_eol_delim (c)
!      int c;
  {
    Keymap cmap;
--- 668,673 ----
  
  static void
! reset_eol_delim (cp)
!      char *cp;
  {
    Keymap cmap;
diff -Nrc2 bash-2.05/builtins/reserved.def bash-2.05a/builtins/reserved.def
*** bash-2.05/builtins/reserved.def	Thu Aug  5 07:44:11 1999
--- bash-2.05a/builtins/reserved.def	Thu Sep 27 09:40:11 2001
***************
*** 160,164 ****
  #  endif /* BANG_HISTORY */
  HISTIGNORE	A colon-separated list of patterns used to decide which
! 		command should be saved on the history list.
  #endif /* HISTORY */
  $END
--- 160,164 ----
  #  endif /* BANG_HISTORY */
  HISTIGNORE	A colon-separated list of patterns used to decide which
! 		commands should be saved on the history list.
  #endif /* HISTORY */
  $END
diff -Nrc2 bash-2.05/builtins/return.def bash-2.05a/builtins/return.def
*** bash-2.05/builtins/return.def	Wed Sep  8 12:56:25 1999
--- bash-2.05a/builtins/return.def	Wed May  2 12:50:17 2001
***************
*** 53,57 ****
       WORD_LIST *list;
  {
!   return_catch_value = list ? get_numeric_arg (list, 1) : last_command_exit_value;
  
    if (return_catch_flag)
--- 53,57 ----
       WORD_LIST *list;
  {
!   return_catch_value = list ? get_exitstat (list) : last_command_exit_value;
  
    if (return_catch_flag)
diff -Nrc2 bash-2.05/builtins/set.def bash-2.05a/builtins/set.def
*** bash-2.05/builtins/set.def	Wed Mar 28 14:47:55 2001
--- bash-2.05a/builtins/set.def	Mon Oct 29 13:33:31 2001
***************
*** 50,55 ****
  #endif
  
- extern int interactive;
  extern int noclobber, posixly_correct, ignoreeof, eof_encountered_limit;
  #if defined (READLINE)
  extern int no_line_editing;
--- 50,57 ----
  #endif
  
  extern int noclobber, posixly_correct, ignoreeof, eof_encountered_limit;
+ #if defined (HISTORY)
+ extern int dont_save_function_defs;
+ #endif
  #if defined (READLINE)
  extern int no_line_editing;
***************
*** 93,96 ****
--- 95,99 ----
              noexec       same as -n
              noglob       same as -f
+             nolog        currently accepted but ignored
              notify       same as -b
              nounset      same as -u
***************
*** 133,146 ****
  $END
  
! static int set_ignoreeof ();
! static int set_posix_mode ();
  
  #if defined (READLINE)
! static int set_edit_mode ();
! static int get_edit_mode ();
  #endif
  
  #if defined (HISTORY)
! static int bash_set_history ();
  #endif
  
--- 136,152 ----
  $END
  
! static void print_minus_o_option __P((char *, int, int));
! static void print_all_shell_variables __P((void));
! 
! static int set_ignoreeof __P((int, char *));
! static int set_posix_mode __P((int, char *));
  
  #if defined (READLINE)
! static int set_edit_mode __P((int, char *));
! static int get_edit_mode __P((char *));
  #endif
  
  #if defined (HISTORY)
! static int bash_set_history __P((int, char *));
  #endif
  
***************
*** 180,200 ****
  };
  
  struct {
    char *name;
    int *variable;
!   Function *set_func;
!   Function *get_func;
  } binary_o_options[] = {
  #if defined (HISTORY)
!   { "history", &remember_on_history, bash_set_history, (Function *)NULL },
  #endif
!   { "ignoreeof", &ignoreeof, set_ignoreeof, (Function *)NULL },
!   { "interactive-comments", &interactive_comments, (Function *)NULL, (Function *)NULL },
!   { "posix", &posixly_correct, set_posix_mode, (Function *)NULL },
  #if defined (READLINE)
    { "emacs", (int *)NULL, set_edit_mode, get_edit_mode },
    { "vi", (int *)NULL, set_edit_mode, get_edit_mode },
  #endif
!   { (char *)NULL, (int *)NULL }
  };
  
--- 186,212 ----
  };
  
+ typedef int setopt_set_func_t __P((int, char *));
+ typedef int setopt_get_func_t __P((char *));
+ 
  struct {
    char *name;
    int *variable;
!   setopt_set_func_t *set_func;
!   setopt_get_func_t *get_func;
  } binary_o_options[] = {
  #if defined (HISTORY)
!   { "history", &remember_on_history, bash_set_history, (setopt_get_func_t *)NULL },
! #endif
!   { "ignoreeof", &ignoreeof, set_ignoreeof, (setopt_get_func_t *)NULL },
!   { "interactive-comments", &interactive_comments, (setopt_set_func_t *)NULL, (setopt_get_func_t *)NULL },
! #if defined (HISTORY)
!   { "nolog", &dont_save_function_defs, (setopt_set_func_t *)NULL, (setopt_get_func_t *)NULL },
  #endif
!   { "posix", &posixly_correct, set_posix_mode, (setopt_get_func_t *)NULL },
  #if defined (READLINE)
    { "emacs", (int *)NULL, set_edit_mode, get_edit_mode },
    { "vi", (int *)NULL, set_edit_mode, get_edit_mode },
  #endif
!   { (char *)NULL, (int *)NULL, (setopt_set_func_t *)NULL, (setopt_get_func_t *)NULL }
  };
  
***************
*** 376,380 ****
  {
    int option_char;
-   VFunction *set_func;
    register int i;
  
--- 388,391 ----
***************
*** 388,392 ****
      }
  
!   for (i = 0, option_char = -1, set_func = 0; o_options[i].name; i++)
      {
        if (STREQ (option_name, o_options[i].name))
--- 399,403 ----
      }
  
!   for (i = 0, option_char = -1; o_options[i].name; i++)
      {
        if (STREQ (option_name, o_options[i].name))
***************
*** 451,455 ****
        vsize += strlen (binary_o_options[i].name) + 1;
  
!   value = xmalloc (vsize + 1);
  
    for (i = vptr = 0; o_options[i].name; i++)
--- 462,466 ----
        vsize += strlen (binary_o_options[i].name) + 1;
  
!   value = (char *)xmalloc (vsize + 1);
  
    for (i = vptr = 0; o_options[i].name; i++)
***************
*** 753,756 ****
--- 764,768 ----
  
  #if defined (ARRAY_VARS)
+       unset_array = 0;
        if (!unset_function && valid_array_reference (name))
  	{
diff -Nrc2 bash-2.05/builtins/setattr.def bash-2.05a/builtins/setattr.def
*** bash-2.05/builtins/setattr.def	Wed Feb 14 17:11:44 2001
--- bash-2.05a/builtins/setattr.def	Tue Aug 28 13:20:53 2001
***************
*** 41,45 ****
  extern int array_needs_making;
  extern char *this_command_name;
! extern Function *this_shell_builtin;
  
  #ifdef ARRAY_VARS
--- 41,45 ----
  extern int array_needs_making;
  extern char *this_command_name;
! extern sh_builtin_func_t *this_shell_builtin;
  
  #ifdef ARRAY_VARS
***************
*** 249,253 ****
--- 249,257 ----
  		continue;
  #endif
+ #if 0
  	      if ((var->attributes & attribute) && invisible_p (var) == 0)
+ #else
+ 	      if ((var->attributes & attribute))
+ #endif
  		show_var_attributes (var, READONLY_OR_EXPORT, nodefs);
  	    }
***************
*** 328,331 ****
--- 332,337 ----
    else if (function_p (var))
      printf ("%s\n", named_function_string (var->name, function_cell (var), 1));
+   else if (invisible_p (var))
+     printf ("%s\n", var->name);
    else
      {
***************
*** 343,347 ****
  {
    SHELL_VAR *var;
-   int ret;
  
    var = find_tempenv_variable (name);
--- 349,352 ----
diff -Nrc2 bash-2.05/builtins/shift.def bash-2.05a/builtins/shift.def
*** bash-2.05/builtins/shift.def	Thu Aug  5 07:44:38 1999
--- bash-2.05a/builtins/shift.def	Mon May 21 15:26:12 2001
***************
*** 53,57 ****
       WORD_LIST *list;
  {
!   int times;
    register int count;
    WORD_LIST *temp;
--- 53,57 ----
       WORD_LIST *list;
  {
!   long times;
    register int count;
    WORD_LIST *temp;
diff -Nrc2 bash-2.05/builtins/shopt.def bash-2.05a/builtins/shopt.def
*** bash-2.05/builtins/shopt.def	Wed Feb 14 17:11:56 2001
--- bash-2.05a/builtins/shopt.def	Tue Sep 11 15:55:06 2001
***************
*** 79,83 ****
  extern int hist_verify, history_reediting, perform_hostname_completion;
  extern int no_empty_command_completion;
! extern void enable_hostname_completion ();
  #endif
  
--- 79,83 ----
  extern int hist_verify, history_reediting, perform_hostname_completion;
  extern int no_empty_command_completion;
! extern int enable_hostname_completion __P((int));
  #endif
  
***************
*** 91,152 ****
  #endif
  
! extern void set_shellopts ();
! 
! static int set_interactive_comments ();
  
  #if defined (RESTRICTED_SHELL)
! static int set_restricted_shell ();
  #endif
  
  static struct {
    char *name;
    int  *value;
!   Function *set_func;
  } shopt_vars[] = {
!   { "cdable_vars", &cdable_vars, (Function *)NULL },
!   { "cdspell", &cdspelling, (Function *)NULL },
!   { "checkhash", &check_hashed_filenames, (Function *)NULL },
!   { "checkwinsize", &check_window_size, (Function *)NULL },
  #if defined (HISTORY)
!   { "cmdhist", &command_oriented_history, (Function *)NULL },
  #endif
!   { "dotglob", &glob_dot_filenames, (Function *)NULL },
!   { "execfail", &no_exit_on_failed_exec, (Function *)NULL },
!   { "expand_aliases", &expand_aliases, (Function *)NULL },
  #if defined (EXTENDED_GLOB)
!   { "extglob", &extended_glob, (Function *)NULL },
  #endif
  #if defined (READLINE)
!   { "histreedit", &history_reediting, (Function *)NULL },
  #endif
  #if defined (HISTORY)
!   { "histappend", &force_append_history, (Function *)NULL },
  #endif
  #if defined (READLINE)
!   { "histverify", &hist_verify, (Function *)NULL },
!   { "hostcomplete", &perform_hostname_completion, (Function *)enable_hostname_completion },
  #endif
!   { "huponexit", &hup_on_exit, (Function *)NULL },
    { "interactive_comments", &interactive_comments, set_interactive_comments },
  #if defined (HISTORY)
!   { "lithist", &literal_history, (Function *)NULL },
  #endif
!   { "mailwarn", &mail_warning, (Function *)NULL },
  #if defined (READLINE)
!   { "no_empty_cmd_completion", &no_empty_command_completion, (Function *)NULL },
  #endif
!   { "nocaseglob", &glob_ignore_case, (Function *)NULL },
!   { "nullglob",	&allow_null_glob_expansion, (Function *)NULL },
  #if defined (PROGRAMMABLE_COMPLETION)
!   { "progcomp", &prog_completion_enabled, (Function *)NULL },
  #endif
!   { "promptvars", &promptvars, (Function *)NULL },
  #if defined (RESTRICTED_SHELL)
    { "restricted_shell", &restricted_shell, set_restricted_shell },
  #endif
!   { "shift_verbose", &print_shift_error, (Function *)NULL },
!   { "sourcepath", &source_uses_path, (Function *)NULL },
!   { "xpg_echo", &xpg_echo, (Function *)NULL },
!   { (char *)0, (int *)0, (Function *)NULL }
  };
  
--- 91,155 ----
  #endif
  
! static int set_interactive_comments __P((int));
  
  #if defined (RESTRICTED_SHELL)
! static int set_restricted_shell __P((int));
  #endif
  
+ static int shopt_login_shell;
+ 
+ typedef int shopt_set_func_t __P((int));
+ 
  static struct {
    char *name;
    int  *value;
!   shopt_set_func_t *set_func;
  } shopt_vars[] = {
!   { "cdable_vars", &cdable_vars, (shopt_set_func_t *)NULL },
!   { "cdspell", &cdspelling, (shopt_set_func_t *)NULL },
!   { "checkhash", &check_hashed_filenames, (shopt_set_func_t *)NULL },
!   { "checkwinsize", &check_window_size, (shopt_set_func_t *)NULL },
  #if defined (HISTORY)
!   { "cmdhist", &command_oriented_history, (shopt_set_func_t *)NULL },
  #endif
!   { "dotglob", &glob_dot_filenames, (shopt_set_func_t *)NULL },
!   { "execfail", &no_exit_on_failed_exec, (shopt_set_func_t *)NULL },
!   { "expand_aliases", &expand_aliases, (shopt_set_func_t *)NULL },
  #if defined (EXTENDED_GLOB)
!   { "extglob", &extended_glob, (shopt_set_func_t *)NULL },
  #endif
  #if defined (READLINE)
!   { "histreedit", &history_reediting, (shopt_set_func_t *)NULL },
  #endif
  #if defined (HISTORY)
!   { "histappend", &force_append_history, (shopt_set_func_t *)NULL },
  #endif
  #if defined (READLINE)
!   { "histverify", &hist_verify, (shopt_set_func_t *)NULL },
!   { "hostcomplete", &perform_hostname_completion, enable_hostname_completion },
  #endif
!   { "huponexit", &hup_on_exit, (shopt_set_func_t *)NULL },
    { "interactive_comments", &interactive_comments, set_interactive_comments },
  #if defined (HISTORY)
!   { "lithist", &literal_history, (shopt_set_func_t *)NULL },
  #endif
!   { "login_shell", &shopt_login_shell, set_login_shell },
!   { "mailwarn", &mail_warning, (shopt_set_func_t *)NULL },
  #if defined (READLINE)
!   { "no_empty_cmd_completion", &no_empty_command_completion, (shopt_set_func_t *)NULL },
  #endif
!   { "nocaseglob", &glob_ignore_case, (shopt_set_func_t *)NULL },
!   { "nullglob",	&allow_null_glob_expansion, (shopt_set_func_t *)NULL },
  #if defined (PROGRAMMABLE_COMPLETION)
!   { "progcomp", &prog_completion_enabled, (shopt_set_func_t *)NULL },
  #endif
!   { "promptvars", &promptvars, (shopt_set_func_t *)NULL },
  #if defined (RESTRICTED_SHELL)
    { "restricted_shell", &restricted_shell, set_restricted_shell },
  #endif
!   { "shift_verbose", &print_shift_error, (shopt_set_func_t *)NULL },
!   { "sourcepath", &source_uses_path, (shopt_set_func_t *)NULL },
!   { "xpg_echo", &xpg_echo, (shopt_set_func_t *)NULL },
!   { (char *)0, (int *)0, (shopt_set_func_t *)NULL }
  };
  
***************
*** 154,160 ****
  static char *off = "off";
  
! static int list_shopt_o_options ();
! static int list_some_o_options (), list_some_shopts ();
! static int toggle_shopts (), list_shopts (), set_shopt_o_options ();
  
  #define SFLAG	0x01
--- 157,168 ----
  static char *off = "off";
  
! static int find_shopt __P((char *));
! static int toggle_shopts __P((int, WORD_LIST *, int));
! static void print_shopt __P((char *, int, int));
! static int list_shopts __P((WORD_LIST *, int));
! static int list_some_shopts __P((int, int));
! static int list_shopt_o_options __P((WORD_LIST *, int));
! static int list_some_o_options __P((int, int));
! static int set_shopt_o_options __P((int, WORD_LIST *, int));
  
  #define SFLAG	0x01
***************
*** 245,248 ****
--- 253,258 ----
    perform_hostname_completion = 1;
  #endif
+ 
+   shopt_login_shell = login_shell;
  }
  
***************
*** 445,448 ****
--- 455,467 ----
  #endif /* RESTRICTED_SHELL */
  
+ /* Not static so shell.c can call it to initialize shopt_login_shell */
+ int
+ set_login_shell (mode)
+      int mode;
+ {
+   shopt_login_shell = login_shell != 0;
+   return (0);
+ }
+ 
  char **
  get_shopt_options ()
***************
*** 457,459 ****
--- 476,518 ----
    ret[i] = (char *)NULL;
    return ret;
+ }
+ 
+ /*
+  * External interface for other parts of the shell.  NAME is a string option;
+  * MODE is 0 if we want to unset an option; 1 if we want to set an option.
+  * REUSABLE is 1 if we want to print output in a form that may be reused.
+  */
+ int
+ shopt_setopt (name, mode)
+      char *name;
+      int mode;
+ {
+   WORD_LIST *wl;
+   int r;
+ 
+   wl = add_string_to_list (name, (WORD_LIST *)NULL);
+   r = toggle_shopts (mode, wl, 0);
+   dispose_words (wl);
+   return r;
+ }
+ 
+ int
+ shopt_listopt (name, reusable)
+      char *name;
+      int reusable;
+ {
+   int i;
+ 
+   if (name == 0)
+     return (list_shopts ((WORD_LIST *)NULL, reusable ? PFLAG : 0));
+ 
+   i = find_shopt (name);
+   if (i < 0)
+     {
+       SHOPT_ERROR (name);
+       return (EXECUTION_FAILURE);
+     }
+ 
+   print_shopt (name, *shopt_vars[i].value, reusable ? PFLAG : 0);
+   return (EXECUTION_SUCCESS);
  }
diff -Nrc2 bash-2.05/builtins/suspend.def bash-2.05a/builtins/suspend.def
*** bash-2.05/builtins/suspend.def	Thu Aug  5 07:45:00 1999
--- bash-2.05a/builtins/suspend.def	Tue Sep 11 15:41:26 2001
***************
*** 48,53 ****
  #include "bashgetopt.h"
  
- extern int job_control;
- 
  static SigHandler *old_cont;
  #if 0
--- 48,51 ----
diff -Nrc2 bash-2.05/builtins/test.def bash-2.05a/builtins/test.def
*** bash-2.05/builtins/test.def	Thu Aug  5 07:45:06 1999
--- bash-2.05a/builtins/test.def	Wed May 30 09:09:31 2001
***************
*** 32,35 ****
--- 32,36 ----
  File operators:
  
+     -a FILE        True if file exists.
      -b FILE        True if file is block special.
      -c FILE        True if file is character special.
diff -Nrc2 bash-2.05/builtins/trap.def bash-2.05a/builtins/trap.def
*** bash-2.05/builtins/trap.def	Fri Nov  3 11:18:54 2000
--- bash-2.05a/builtins/trap.def	Tue Sep 11 15:42:30 2001
***************
*** 59,63 ****
  #include "bashgetopt.h"
  
! static int display_traps ();
  
  /* The trap command:
--- 59,64 ----
  #include "bashgetopt.h"
  
! static void showtrap __P((int));
! static int display_traps __P((WORD_LIST *));
  
  /* The trap command:
***************
*** 80,84 ****
  #define IGNORE 2		/* Ignore this signal. */
  
! extern int interactive, posixly_correct;
  
  int
--- 81,85 ----
  #define IGNORE 2		/* Ignore this signal. */
  
! extern int posixly_correct;
  
  int
***************
*** 229,233 ****
    if (list == 0)
      {
!       for (i = 0; i <= NSIG; i++)
  	showtrap (i);
        return (EXECUTION_SUCCESS);
--- 230,234 ----
    if (list == 0)
      {
!       for (i = 0; i < BASH_NSIG; i++)
  	showtrap (i);
        return (EXECUTION_SUCCESS);
diff -Nrc2 bash-2.05/builtins/type.def bash-2.05a/builtins/type.def
*** bash-2.05/builtins/type.def	Wed Feb 14 17:12:13 2001
--- bash-2.05a/builtins/type.def	Mon May 14 12:05:00 2001
***************
*** 65,69 ****
  #include "bashgetopt.h"
  
! extern int find_reserved_word ();
  
  extern char *this_command_name;
--- 65,69 ----
  #include "bashgetopt.h"
  
! extern int find_reserved_word __P((char *));
  
  extern char *this_command_name;
***************
*** 214,218 ****
  {
    int found, i, found_file, f;
!   char *full_path, *x, *cwd;
    SHELL_VAR *func;
  #if defined (ALIAS)
--- 214,218 ----
  {
    int found, i, found_file, f;
!   char *full_path, *x;
    SHELL_VAR *func;
  #if defined (ALIAS)
diff -Nrc2 bash-2.05/builtins/ulimit.def bash-2.05a/builtins/ulimit.def
*** bash-2.05/builtins/ulimit.def	Mon Dec 18 10:37:45 2000
--- bash-2.05a/builtins/ulimit.def	Thu Sep 13 14:30:54 2001
***************
*** 45,49 ****
      -v	the size of virtual memory 
  
! If LIMIT is given, it is the new value of the specified resource.
  Otherwise, the current value of the specified resource is printed.
  If no option is given, then -f is assumed.  Values are in 1024-byte
--- 45,51 ----
      -v	the size of virtual memory 
  
! If LIMIT is given, it is the new value of the specified resource;
! the special LIMIT values `soft', `hard', and `unlimited' stand for
! the current soft limit, the current hard limit, and no limit, respectively.
  Otherwise, the current value of the specified resource is printed.
  If no option is given, then -f is assumed.  Values are in 1024-byte
***************
*** 110,115 ****
  #endif
  
- #define DESCFMT	"%-28s"
- 
  /* Some systems use RLIMIT_NOFILE, others use RLIMIT_OFILE */
  #if defined (HAVE_RESOURCE) && defined (RLIMIT_OFILE) && !defined (RLIMIT_NOFILE)
--- 112,115 ----
***************
*** 155,172 ****
  #endif
  
  #define LIMIT_HARD 0x01
  #define LIMIT_SOFT 0x02
  
  static int ulimit_internal __P((int, char *, int, int));
  static void printone __P((int, RLIMTYPE, int));
  static void print_all_limits __P((int));
  
! static int get_limit __P((int, int, RLIMTYPE *));
! static int set_limit __P((int, RLIMTYPE, int));
  
  static int filesize __P((RLIMTYPE *));
  static int pipesize __P((RLIMTYPE *));
! static int getmaxuprc __P((int, RLIMTYPE *));
! static int getmaxvm __P((int, RLIMTYPE *));
  
  typedef struct {
--- 155,185 ----
  #endif
  
+ #if !defined (RLIM_SAVED_CUR)
+ #  define RLIM_SAVED_CUR RLIM_INFINITY
+ #endif
+ 
+ #if !defined (RLIM_SAVED_MAX)
+ #  define RLIM_SAVED_MAX RLIM_INFINITY
+ #endif
+ 
  #define LIMIT_HARD 0x01
  #define LIMIT_SOFT 0x02
  
+ static int _findlim __P((int));
+ 
  static int ulimit_internal __P((int, char *, int, int));
+ 
+ static int get_limit __P((int, RLIMTYPE *, RLIMTYPE *));
+ static int set_limit __P((int, RLIMTYPE, int));
+ 
  static void printone __P((int, RLIMTYPE, int));
  static void print_all_limits __P((int));
  
! static int set_all_limits __P((int, RLIMTYPE));
  
  static int filesize __P((RLIMTYPE *));
  static int pipesize __P((RLIMTYPE *));
! static int getmaxuprc __P((RLIMTYPE *));
! static int getmaxvm __P((RLIMTYPE *, RLIMTYPE *));
  
  typedef struct {
***************
*** 175,210 ****
    int  block_factor;		/* Blocking factor for specific limit. */
    char *description;		/* Descriptive string to output. */
  } RESOURCE_LIMITS;
  
  static RESOURCE_LIMITS limits[] = {
  #ifdef RLIMIT_CORE
!   { 'c',	RLIMIT_CORE,  1024, "core file size (blocks)" },
  #endif
  #ifdef RLIMIT_DATA
!   { 'd',	RLIMIT_DATA,  1024, "data seg size (kbytes)" },
  #endif
!   { 'f',	RLIMIT_FILESIZE, 1024, "file size (blocks)" },
  #ifdef RLIMIT_MEMLOCK
!   { 'l',	RLIMIT_MEMLOCK, 1024, "max locked memory (kbytes)" },
  #endif
  #ifdef RLIMIT_RSS
!   { 'm',	RLIMIT_RSS,   1024, "max memory size (kbytes)" },
  #endif /* RLIMIT_RSS */
!   { 'n',	RLIMIT_OPENFILES, 1, "open files" },
!   { 'p',	RLIMIT_PIPESIZE, 512, "pipe size (512 bytes)" },
  #ifdef RLIMIT_STACK
!   { 's',	RLIMIT_STACK, 1024, "stack size (kbytes)" },
  #endif
  #ifdef RLIMIT_CPU
!   { 't',	RLIMIT_CPU,      1, "cpu time (seconds)" },
  #endif /* RLIMIT_CPU */
!   { 'u',	RLIMIT_MAXUPROC, 1, "max user processes" },
  #if defined (HAVE_RESOURCE)
!   { 'v',	RLIMIT_VIRTMEM, RLIMIT_VMBLKSZ, "virtual memory (kbytes)" },
  #endif
  #ifdef RLIMIT_SWAP
!   { 'w',	RLIMIT_SWAP,	1024,	"swap size (kbytes)" },
  #endif
!   { -1, -1, -1, (char *)NULL }
  };
  #define NCMDS	(sizeof(limits) / sizeof(limits[0]))
--- 188,224 ----
    int  block_factor;		/* Blocking factor for specific limit. */
    char *description;		/* Descriptive string to output. */
+   char *units;			/* scale */
  } RESOURCE_LIMITS;
  
  static RESOURCE_LIMITS limits[] = {
  #ifdef RLIMIT_CORE
!   { 'c',	RLIMIT_CORE,  1024,	"core file size",	"blocks" },
  #endif
  #ifdef RLIMIT_DATA
!   { 'd',	RLIMIT_DATA,  1024,	"data seg size",	"kbytes" },
  #endif
!   { 'f',	RLIMIT_FILESIZE, 1024,	"file size",		"blocks" },
  #ifdef RLIMIT_MEMLOCK
!   { 'l',	RLIMIT_MEMLOCK, 1024,	"max locked memory",	"kbytes" },
  #endif
  #ifdef RLIMIT_RSS
!   { 'm',	RLIMIT_RSS,   1024,	"max memory size",	"kbytes" },
  #endif /* RLIMIT_RSS */
!   { 'n',	RLIMIT_OPENFILES, 1,	"open files",		(char *)NULL},
!   { 'p',	RLIMIT_PIPESIZE, 512,	"pipe size", 		"512 bytes" },
  #ifdef RLIMIT_STACK
!   { 's',	RLIMIT_STACK, 1024,	"stack size",		"kbytes" },
  #endif
  #ifdef RLIMIT_CPU
!   { 't',	RLIMIT_CPU,      1,	"cpu time",		"seconds" },
  #endif /* RLIMIT_CPU */
!   { 'u',	RLIMIT_MAXUPROC, 1,	"max user processes",	(char *)NULL },
  #if defined (HAVE_RESOURCE)
!   { 'v',	RLIMIT_VIRTMEM, RLIMIT_VMBLKSZ, "virtual memory", "kbytes" },
  #endif
  #ifdef RLIMIT_SWAP
!   { 'w',	RLIMIT_SWAP,	1024,	"swap size",		"kbytes" },
  #endif
!   { -1, -1, -1, (char *)NULL, (char *)NULL }
  };
  #define NCMDS	(sizeof(limits) / sizeof(limits[0]))
***************
*** 309,312 ****
--- 323,337 ----
    if (all_limits)
      {
+ #ifdef NOTYET
+       if (list)		/* setting */
+         {
+           if (STREQ (list->word->word, "unlimited") == 0)
+             {
+               builtin_error ("invalid limit argument: %s", list->word->word);
+               return (EXECUTION_FAILURE);
+             }
+           return (set_all_limits (mode == 0 ? LIMIT_SOFT|LIMIT_HARD : mode, RLIM_INFINITY));
+         }
+ #endif
        print_all_limits (mode == 0 ? LIMIT_SOFT : mode);
        return (EXECUTION_SUCCESS);
***************
*** 348,353 ****
  {
    int opt, limind, setting;
!   long block_factor;
!   RLIMTYPE current_limit, real_limit, limit;
  
    setting = cmdarg != 0;
--- 373,378 ----
  {
    int opt, limind, setting;
!   int block_factor;
!   RLIMTYPE soft_limit, hard_limit, real_limit, limit;
  
    setting = cmdarg != 0;
***************
*** 355,362 ****
    if (mode == 0)
      mode = setting ? (LIMIT_HARD|LIMIT_SOFT) : LIMIT_SOFT;
!   opt = get_limit (limind, mode, &current_limit);
    if (opt < 0)
      {
!       builtin_error ("cannot get limit: %s", strerror (errno));
        return (EXECUTION_FAILURE);
      }
--- 380,388 ----
    if (mode == 0)
      mode = setting ? (LIMIT_HARD|LIMIT_SOFT) : LIMIT_SOFT;
!   opt = get_limit (limind, &soft_limit, &hard_limit);
    if (opt < 0)
      {
!       builtin_error ("cannot get %s limit: %s", limits[limind].description,
! 						strerror (errno));
        return (EXECUTION_FAILURE);
      }
***************
*** 364,388 ****
    if (setting == 0)	/* print the value of the specified limit */
      {
!       printone (limind, current_limit, multiple);
        return (EXECUTION_SUCCESS);
      }
   
    /* Setting the limit. */
!   if (STREQ (cmdarg, "unlimited"))
!     limit = RLIM_INFINITY;
    else if (all_digits (cmdarg))
-     limit = string_to_rlimtype (cmdarg);
-   else
      {
!       builtin_error ("bad non-numeric arg `%s'", cmdarg);
!       return (EXECUTION_FAILURE);
!     }
  
!   block_factor = (limit == RLIM_INFINITY) ? 1 : limits[limind].block_factor;
!   real_limit = limit * block_factor;
! 
!   if (real_limit < 0 || (real_limit == 0 && limit != 0))
      {
!       builtin_error ("limit out of range: %d", limit);
        return (EXECUTION_FAILURE);
      }
--- 390,419 ----
    if (setting == 0)	/* print the value of the specified limit */
      {
!       printone (limind, (mode & LIMIT_SOFT) ? soft_limit : hard_limit, multiple);
        return (EXECUTION_SUCCESS);
      }
   
    /* Setting the limit. */
!   if (STREQ (cmdarg, "hard"))
!     real_limit = hard_limit;
!   else if (STREQ (cmdarg, "soft"))
!     real_limit = soft_limit;
!   else if (STREQ (cmdarg, "unlimited"))
!     real_limit = RLIM_INFINITY;
    else if (all_digits (cmdarg))
      {
!       limit = string_to_rlimtype (cmdarg);
!       block_factor = limits[limind].block_factor;
!       real_limit = limit * block_factor;
  
!       if ((real_limit / block_factor) != limit)
! 	{
! 	  builtin_error ("limit out of range: %s", cmdarg);
! 	  return (EXECUTION_FAILURE);
! 	}
!     }
!   else
      {
!       builtin_error ("bad non-numeric arg `%s'", cmdarg);
        return (EXECUTION_FAILURE);
      }
***************
*** 390,403 ****
    if (set_limit (limind, real_limit, mode) < 0)
      {
!       builtin_error ("cannot modify limit: %s", strerror (errno));
        return (EXECUTION_FAILURE);
      }
    return (EXECUTION_SUCCESS);
  }
  
  static int
! get_limit (ind, mode, limptr)
!      int ind, mode;
!      RLIMTYPE *limptr;
  {
    RLIMTYPE value;
--- 421,436 ----
    if (set_limit (limind, real_limit, mode) < 0)
      {
!       builtin_error ("cannot modify %s limit: %s", limits[limind].description,
! 						   strerror (errno));
        return (EXECUTION_FAILURE);
      }
+ 
    return (EXECUTION_SUCCESS);
  }
  
  static int
! get_limit (ind, softlim, hardlim)
!      int ind;
!      RLIMTYPE *softlim, *hardlim;
  {
    RLIMTYPE value;
***************
*** 422,430 ****
  	  break;
  	case RLIMIT_VIRTMEM:
! 	  if (getmaxvm (mode, &value) < 0)
! 	    return -1;
! 	  break;
  	case RLIMIT_MAXUPROC:
! 	  if (getmaxuprc (mode, &value) < 0)
  	    return -1;
  	  break;
--- 455,461 ----
  	  break;
  	case RLIMIT_VIRTMEM:
! 	  return (getmaxvm (softlim, hardlim));
  	case RLIMIT_MAXUPROC:
! 	  if (getmaxuprc (&value) < 0)
  	    return -1;
  	  break;
***************
*** 433,437 ****
  	  return -1;
  	}
!       *limptr = value;
        return (0);
      }
--- 464,468 ----
  	  return -1;
  	}
!       *softlim = *hardlim = value;
        return (0);
      }
***************
*** 441,451 ****
        if (getrlimit (limits[ind].parameter, &limit) < 0)
  	return -1;
!       value = (mode & LIMIT_SOFT) ? limit.rlim_cur : limit.rlim_max;
  #  if defined (HPUX9)
        if (limits[ind].parameter == RLIMIT_FILESIZE)
! 	*limptr = value * 512;			/* Ugh. */
        else
  #  endif /* HPUX9 */
-       *limptr = value;
        return 0;
  #else
--- 472,485 ----
        if (getrlimit (limits[ind].parameter, &limit) < 0)
  	return -1;
!       *softlim = limit.rlim_cur;
!       *hardlim = limit.rlim_max;
  #  if defined (HPUX9)
        if (limits[ind].parameter == RLIMIT_FILESIZE)
! 	{
! 	  *softlim *= 512;
! 	  *hardlim *= 512;			/* Ugh. */
! 	}
        else
  #  endif /* HPUX9 */
        return 0;
  #else
***************
*** 522,545 ****
  
  static int
! getmaxvm (mode, valuep)
!      int mode;
!      RLIMTYPE *valuep;
  {
  #if defined (HAVE_RESOURCE)
!   struct rlimit rl;
!   RLIMTYPE maxdata, maxstack;
  
!   if (getrlimit (RLIMIT_DATA, &rl) < 0)
      return -1;
-   else
-     maxdata = (mode & LIMIT_SOFT) ? rl.rlim_cur : rl.rlim_max;
  
!   if (getrlimit (RLIMIT_STACK, &rl) < 0)
      return -1;
-   else
-     maxstack = (mode & LIMIT_SOFT) ? rl.rlim_cur : rl.rlim_max;
  
    /* Protect against overflow. */
!   *valuep = (maxdata / 1024L) + (maxstack / 1024L);
    return 0;
  #else
--- 556,574 ----
  
  static int
! getmaxvm (softlim, hardlim)
!      RLIMTYPE *softlim, *hardlim;
  {
  #if defined (HAVE_RESOURCE)
!   struct rlimit datalim, stacklim;
  
!   if (getrlimit (RLIMIT_DATA, &datalim) < 0)
      return -1;
  
!   if (getrlimit (RLIMIT_STACK, &stacklim) < 0)
      return -1;
  
    /* Protect against overflow. */
!   *softlim = (datalim.rlim_cur / 1024L) + (stacklim.rlim_cur / 1024L);
!   *hardlim = (datalim.rlim_max / 1024L) + (stacklim.rlim_max / 1024L);
    return 0;
  #else
***************
*** 558,566 ****
      return -1;
    else
! #  if 0
!     *valuep = (RLIMTYPE) result;
! #  else
!     *valuep = (RLIMTYPE) result * 512L;
! #  endif
    return 0;
  #else
--- 587,591 ----
      return -1;
    else
!     *valuep = (RLIMTYPE) result * 512;
    return 0;
  #else
***************
*** 591,596 ****
  
  static int
! getmaxuprc (mode, valuep)
!      int mode;
       RLIMTYPE *valuep;
  {
--- 616,620 ----
  
  static int
! getmaxuprc (valuep)
       RLIMTYPE *valuep;
  {
***************
*** 619,623 ****
  {
    register int i;
!   RLIMTYPE value;
  
    if (mode == 0)
--- 643,647 ----
  {
    register int i;
!   RLIMTYPE softlim, hardlim;
  
    if (mode == 0)
***************
*** 626,636 ****
    for (i = 0; limits[i].option > 0; i++)
      {
!       if (get_limit (i, mode, &value) < 0)
! 	{
! 	  fprintf (stderr, DESCFMT, limits[i].description);
! 	  builtin_error ("cannot get limit: %s", strerror (errno));
! 	}
        else
! 	printone (i, value, 1);     
      }
  }
--- 650,657 ----
    for (i = 0; limits[i].option > 0; i++)
      {
!       if (get_limit (i, &softlim, &hardlim) < 0)
! 	builtin_error ("cannot get %s limit: %s", limits[i].description, strerror (errno));
        else
! 	printone (i, (mode & LIMIT_SOFT) ? softlim : hardlim, 1);
      }
  }
***************
*** 642,651 ****
       int pdesc;
  {
    if (pdesc)
!     printf (DESCFMT, limits[limind].description);
    if (curlim == RLIM_INFINITY)
      puts ("unlimited");
    else
      print_rlimtype ((curlim / limits[limind].block_factor), 1);
  }
  #endif /* !_MINIX */
--- 663,726 ----
       int pdesc;
  {
+   char unitstr[64];
+ 
    if (pdesc)
!     {
!       if (limits[limind].units)
! 	sprintf (unitstr, "(%s, -%c) ", limits[limind].units, limits[limind].option);
!       else
!         sprintf (unitstr, "(-%c) ", limits[limind].option);
! 
!       printf ("%-18s %16s", limits[limind].description, unitstr);
!     }
    if (curlim == RLIM_INFINITY)
      puts ("unlimited");
+   else if (curlim == RLIM_SAVED_MAX)
+     puts ("hard");
+   else if (curlim == RLIM_SAVED_CUR)
+     puts ("soft");
    else
      print_rlimtype ((curlim / limits[limind].block_factor), 1);
  }
+ 
+ /* Set all limits to NEWLIM.  NEWLIM currently must be RLIM_INFINITY, which
+    causes all limits to be set as high as possible depending on mode (like
+    csh `unlimit').  Returns -1 if NEWLIM is invalid, 0 if all limits
+    were set successfully, and 1 if at least one limit could not be set.
+ 
+    To raise all soft limits to their corresponding hard limits, use
+ 	ulimit -S -a unlimited
+    To attempt to raise all hard limits to infinity (superuser-only), use
+ 	ulimit -H -a unlimited
+    To attempt to raise all soft and hard limits to infinity, use
+ 	ulimit -a unlimited
+ */
+ 
+ static int
+ set_all_limits (mode, newlim)
+      int mode;
+      RLIMTYPE newlim;
+ {
+   register int i;
+   int retval = 0;
+ 
+   if (newlim != RLIM_INFINITY)
+     {
+       errno = EINVAL;
+       return -1;
+     }
+   
+   if (mode == 0)
+     mode = LIMIT_SOFT|LIMIT_HARD;
+ 
+   for (retval = i = 0; limits[i].option > 0; i++)
+     if (set_limit (i, newlim, mode) < 0)
+       {
+ 	builtin_error ("cannot modify %s limit: %s", limits[i].description,
+ 						     strerror (errno));
+ 	retval = 1;
+       }
+   return retval;
+ }
+ 
  #endif /* !_MINIX */
diff -Nrc2 bash-2.05/builtins/umask.def bash-2.05a/builtins/umask.def
*** bash-2.05/builtins/umask.def	Wed Feb 14 17:12:26 2001
--- bash-2.05a/builtins/umask.def	Thu Sep 20 15:24:53 2001
***************
*** 47,50 ****
--- 47,51 ----
  
  #include <stdio.h>
+ #include <chartypes.h>
  
  #include "../shell.h"
***************
*** 53,56 ****
--- 54,61 ----
  #include "bashgetopt.h"
  
+ #ifdef __LCC__
+ #define mode_t int
+ #endif
+ 
  /* **************************************************************** */
  /*                                                                  */
***************
*** 59,64 ****
  /* **************************************************************** */
  
! static void print_symbolic_umask ();
! static int symbolic_umask ();
  
  /* Set or display the mask used by the system when creating files.  Flag
--- 64,69 ----
  /* **************************************************************** */
  
! static void print_symbolic_umask __P((mode_t));
! static int symbolic_umask __P((WORD_LIST *));
  
  /* Set or display the mask used by the system when creating files.  Flag
***************
*** 93,97 ****
    if (list)
      {
!       if (digit (*list->word->word))
  	{
  	  umask_value = read_octal (list->word->word);
--- 98,102 ----
    if (list)
      {
!       if (DIGIT (*list->word->word))
  	{
  	  umask_value = read_octal (list->word->word);
***************
*** 129,133 ****
  	print_symbolic_umask (umask_arg);
        else
! 	printf ("%03o\n", umask_arg);
      }
  
--- 134,138 ----
  	print_symbolic_umask (umask_arg);
        else
! 	printf ("%04lo\n", (unsigned long)umask_arg);
      }
  
***************
*** 180,189 ****
       int initial_bits;
  {
!   int who, op, perm, mask, bits, c;
    char *s;
  
    for (s = mode, bits = initial_bits;;)
      {
!       who = op = perm = mask = 0;
  
        /* Parse the `who' portion of the symbolic mode clause. */
--- 185,194 ----
       int initial_bits;
  {
!   int who, op, perm, bits, c;
    char *s;
  
    for (s = mode, bits = initial_bits;;)
      {
!       who = op = perm = 0;
  
        /* Parse the `who' portion of the symbolic mode clause. */
diff -Nrc2 bash-2.05/builtins/wait.def bash-2.05a/builtins/wait.def
*** bash-2.05/builtins/wait.def	Wed Jan 17 15:40:08 2001
--- bash-2.05a/builtins/wait.def	Mon Oct 29 13:45:52 2001
***************
*** 51,54 ****
--- 51,56 ----
  #endif
  
+ #include <chartypes.h>
+ 
  #include "../bashansi.h"
  
***************
*** 82,85 ****
--- 84,89 ----
    volatile int old_interrupt_immediately;
  
+   USE_VAR(list);
+ 
    if (no_options (list))
      return (EX_USAGE);
***************
*** 121,131 ****
        pid_t pid;
        char *w;
  
        w = list->word->word;
!       if (digit (*w))
  	{
! 	  if (all_digits (w + 1))
  	    {
! 	      pid = (pid_t)atoi (w);
  	      status = wait_for_single_pid (pid);
  	    }
--- 125,136 ----
        pid_t pid;
        char *w;
+       long pid_value;
  
        w = list->word->word;
!       if (DIGIT (*w))
  	{
! 	  if (legal_number (w, &pid_value) && pid_value == (pid_t)pid_value)
  	    {
! 	      pid = (pid_t)pid_value;
  	      status = wait_for_single_pid (pid);
  	    }
diff -Nrc2 bash-2.05/builtins.h bash-2.05a/builtins.h
*** bash-2.05/builtins.h	Thu Aug  5 07:18:12 1999
--- bash-2.05a/builtins.h	Tue Aug 28 12:42:53 2001
***************
*** 45,49 ****
  struct builtin {
    char *name;			/* The name that the user types. */
!   Function *function;		/* The address of the invoked function. */
    int flags;			/* One of the #defines above. */
    char **long_doc;		/* NULL terminated array of strings. */
--- 45,49 ----
  struct builtin {
    char *name;			/* The name that the user types. */
!   sh_builtin_func_t *function;		/* The address of the invoked function. */
    int flags;			/* One of the #defines above. */
    char **long_doc;		/* NULL terminated array of strings. */
diff -Nrc2 bash-2.05/command.h bash-2.05a/command.h
*** bash-2.05/command.h	Thu Oct  5 15:31:17 2000
--- bash-2.05a/command.h	Wed May  9 08:52:36 2001
***************
*** 96,107 ****
  /* **************************************************************** */
  
! /* What a redirection descriptor looks like.  If FLAGS is IS_DESCRIPTOR,
!    then we use REDIRECTEE.DEST, else we use the file specified. */
  
  typedef union {
!   long dest;			/* Place to redirect REDIRECTOR to, or ... */
    WORD_DESC *filename;		/* filename to redirect to. */
  } REDIRECTEE;
  
  typedef struct redirect {
    struct redirect *next;	/* Next element, or NULL. */
--- 96,111 ----
  /* **************************************************************** */
  
! /* What a redirection descriptor looks like.  If the redirection instruction
!    is ri_duplicating_input or ri_duplicating_output, use DEST, otherwise
!    use the file in FILENAME.  Out-of-range descriptors are identified by a
!    negative DEST. */
  
  typedef union {
!   int dest;			/* Place to redirect REDIRECTOR to, or ... */
    WORD_DESC *filename;		/* filename to redirect to. */
  } REDIRECTEE;
  
+ /* Structure describing a redirection.  If REDIRECTOR is negative, the parser
+    (or translator in redir.c) encountered an out-of-range file descriptor. */
  typedef struct redirect {
    struct redirect *next;	/* Next element, or NULL. */
***************
*** 132,135 ****
--- 136,140 ----
  #define CMD_AMPERSAND	   0x200 /* command & */
  #define CMD_STDIN_REDIR	   0x400 /* async command needs implicit </dev/null */
+ #define CMD_COMMAND_BUILTIN 0x0800 /* command executed by `command' builtin */
  
  /* What a command looks like. */
diff -Nrc2 bash-2.05/config-top.h bash-2.05a/config-top.h
*** bash-2.05/config-top.h	Wed Feb  7 13:28:14 2001
--- bash-2.05a/config-top.h	Wed Oct 24 13:28:49 2001
***************
*** 58,59 ****
--- 58,63 ----
     run the startup files when not in posix mode. */
  /* #define NON_INTERACTIVE_LOGIN_SHELLS */
+ 
+ /* Define this if you want bash to try to check whether it's being run by
+    sshd and source the .bashrc if so (like the rshd behavior). */
+ /* #define SSH_SOURCE_BASHRC */
diff -Nrc2 bash-2.05/config.h.in bash-2.05a/config.h.in
*** bash-2.05/config.h.in	Mon Oct  2 09:44:22 2000
--- bash-2.05a/config.h.in	Mon Oct 22 09:58:13 2001
***************
*** 1,5 ****
  /* config.h -- Configuration file for bash. */
  
! /* Copyright (C) 1987,1991 Free Software Foundation, Inc.
  
     This file is part of GNU Bash, the Bourne Again SHell.
--- 1,5 ----
  /* config.h -- Configuration file for bash. */
  
! /* Copyright (C) 1987-2001 Free Software Foundation, Inc.
  
     This file is part of GNU Bash, the Bourne Again SHell.
***************
*** 22,26 ****
  #define _CONFIG_H_
  
! /* Configuration settings controllable by autoconf. */
  
  /* Define JOB_CONTROL if your operating system supports
--- 22,26 ----
  #define _CONFIG_H_
  
! /* Configuration feature settings controllable by autoconf. */
  
  /* Define JOB_CONTROL if your operating system supports
***************
*** 143,148 ****
--- 143,201 ----
  /* Beginning of autoconf additions. */
  
+ /* Characteristics of the C compiler */
+ #undef const
+ 
+ #undef inline
+ 
+ /* Define if cpp supports the ANSI-C stringizing `#' operator */
+ #undef HAVE_STRINGIZE
+ 
+ /* Define if the compiler supports `long double' variables. */
+ #undef HAVE_LONG_DOUBLE
+ 
+ #undef PROTOTYPES
+ 
+ #undef __CHAR_UNSIGNED__
+ 
+ /* Define if the compiler supports `long long' variables. */
+ #undef HAVE_LONG_LONG
+ 
+ #undef HAVE_UNSIGNED_LONG_LONG
+ 
+ /* The number of bytes in a int.  */
+ #undef SIZEOF_INT
+ 
+ /* The number of bytes in a long.  */
+ #undef SIZEOF_LONG
+ 
+ /* The number of bytes in a pointer to char.  */
+ #undef SIZEOF_CHAR_P
+ 
+ /* The number of bytes in a double (hopefully 8). */
+ #undef SIZEOF_DOUBLE
+ 
+ /* The number of bytes in a `long long', if we have one. */
+ #undef SIZEOF_LONG_LONG
+ 
+ /* System paths */
+ 
  #define DEFAULT_MAIL_DIRECTORY "/usr/spool/mail"
  
+ /* Characteristics of the system's header files and libraries that affect
+    the compilation environment. */
+ 
+ /* Define if the system does not provide POSIX.1 features except
+    with this defined.  */
+ #undef _POSIX_1_SOURCE
+ 
+ /* Define if you need to in order for stat and other things to work.  */
+ #undef _POSIX_SOURCE
+ 
+ /* Define to use GNU libc extensions */
+ #undef _GNU_SOURCE
+ 
+ /* Define if you have the ANSI C header files.  */
+ #undef STDC_HEADERS
+ 
  /* Memory management functions. */
  
***************
*** 166,181 ****
  /* SYSTEM TYPES */
  
- /* The number of bytes in a int.  */
- #undef SIZEOF_INT
- 
- /* The number of bytes in a long.  */
- #undef SIZEOF_LONG
- 
- /* The number of bytes in a pointer to char.  */
- #undef SIZEOF_CHAR_P
- 
- /* The number of bytes in a double (hopefully 8). */
- #undef SIZEOF_DOUBLE
- 
  /* Define to `long' if <sys/types.h> doesn't define.  */
  #undef off_t
--- 219,222 ----
***************
*** 205,211 ****
  #undef bits64_t
  
- /* Define to `int' if <sys/types.h> doesn't define. */
- #undef ptrdiff_t
- 
  /* Define to `unsigned int' if <sys/types.h> doesn't define. */
  #undef u_int
--- 246,249 ----
***************
*** 214,220 ****
--- 252,270 ----
  #undef u_long
  
+ /* Define to `int' if <sys/types.h> doesn't define. */
+ #undef ptrdiff_t
+ 
  /* Define to `unsigned' if <sys/types.h> doesn't define.  */
  #undef size_t
  
+ /* Define to `int' if <sys/types.h> doesn't define. */
+ #undef ssize_t
+ 
+ /* Define to `long' if <stdint.h> doesn't define. */
+ #undef intmax_t
+ 
+ /* Define to `unsigned long' if <stdint.h> doesn't define. */
+ #undef uintmax_t
+  
  /* Define to `int' if <sys/types.h> doesn't define.  */
  #undef uid_t
***************
*** 229,232 ****
--- 279,285 ----
  #undef gid_t
  
+ /* Define to `unsigned int' if <sys/socket.h> doesn't define. */
+ #undef socklen_t
+ 
  /* Define if you have quad_t in <sys/types.h>. */
  #undef HAVE_QUAD_T
***************
*** 238,248 ****
  #undef GETGROUPS_T
  
- /* Define if the system does not provide POSIX.1 features except
-    with this defined.  */
- #undef _POSIX_1_SOURCE
- 
- /* Define if you need to in order for stat and other things to work.  */
- #undef _POSIX_SOURCE
- 
  /* Characteristics of the machine archictecture. */
  
--- 291,294 ----
***************
*** 259,265 ****
  #undef WORDS_BIGENDIAN
  
- /* Define if you have the ANSI C header files.  */
- #undef STDC_HEADERS
- 
  /* Check for the presence of certain non-function symbols in the system
     libraries. */
--- 305,308 ----
***************
*** 302,305 ****
--- 345,349 ----
  #undef TERMIO_LDISC
  
+ #undef HAVE_STRUCT_STAT_ST_BLOCKS
  
  /* Characteristics of definitions in the system header files. */
***************
*** 309,315 ****
  #undef HAVE_RESOURCE
  
! #undef SBRK_DECLARED
  
! #undef PRINTF_DECLARED
  
  /* Characteristics of system calls and C library functions. */
--- 353,376 ----
  #undef HAVE_RESOURCE
  
! #undef HAVE_LIBC_FNM_EXTMATCH
! 
! #undef HAVE_DECL_CONFSTR
! 
! #undef HAVE_DECL_STRTOLD
! 
! #undef HAVE_DECL_SBRK
! 
! #undef HAVE_DECL_PRINTF
! 
! #undef HAVE_DECL_STRSIGNAL
! 
! /* These are checked with BASH_CHECK_DECL */
  
! #undef HAVE_DECL_STRTOIMAX
! #undef HAVE_DECL_STRTOL
! #undef HAVE_DECL_STRTOLL
! #undef HAVE_DECL_STRTOUL
! #undef HAVE_DECL_STRTOULL
! #undef HAVE_DECL_STRTOUMAX
  
  /* Characteristics of system calls and C library functions. */
***************
*** 335,338 ****
--- 396,400 ----
  #undef CAN_REDEFINE_GETENV
  
+ #undef HAVE_PRINTF_A_FORMAT
  
  /* Characteristics of properties exported by the kernel. */
***************
*** 361,368 ****
  #undef MUST_REINSTALL_SIGHANDLERS
  
- /* Define if system calls automatically restart after interruption
-    by a signal.  */
- #undef HAVE_RESTARTABLE_SYSCALLS
- 
  #undef HAVE_BSD_SIGNALS
  
--- 423,426 ----
***************
*** 376,379 ****
--- 434,440 ----
  /* Presence of system and C library functions. */
  
+ /* Define if you have the asprintf function.  */
+ #undef HAVE_ASPRINTF
+ 
  /* Define if you have the bcopy function.  */
  #undef HAVE_BCOPY
***************
*** 403,406 ****
--- 464,470 ----
  #undef HAVE_DUP2
  
+ /* Define if you have the getaddrinfo function. */
+ #undef HAVE_GETADDRINFO
+ 
  /* Define if you have the getcwd function.  */
  #undef HAVE_GETCWD
***************
*** 445,448 ****
--- 509,530 ----
  #undef HAVE_INET_ATON
  
+ /* Define if you have the isascii function. */
+ #undef HAVE_ISASCII
+ 
+ /* Define if you have the isblank function.  */
+ #undef HAVE_ISBLANK
+ 
+ /* Define if you have the isgraph function.  */
+ #undef HAVE_ISGRAPH
+ 
+ /* Define if you have the isprint function.  */
+ #undef HAVE_ISPRINT
+ 
+ /* Define if you have the isspace function.  */
+ #undef HAVE_ISSPACE
+ 
+ /* Define if you have the isxdigit function.  */
+ #undef HAVE_ISXDIGIT
+ 
  /* Define if you have the killpg function.  */
  #undef HAVE_KILLPG
***************
*** 499,502 ****
--- 581,587 ----
  #undef HAVE_POSIX_SIGSETJMP
  
+ /* Define if you have the snprintf function.  */
+ #undef HAVE_SNPRINTF
+ 
  /* Define if you have the strcasecmp function.  */
  #undef HAVE_STRCASECMP
***************
*** 517,526 ****
--- 602,623 ----
  #undef HAVE_STRTOD
  
+ /* Define if you have the strtoimax function. */
+ #undef HAVE_STRTOIMAX
+ 
  /* Define if you have the strtol function. */
  #undef HAVE_STRTOL
  
+ /* Define if you have the strtoll function. */
+ #undef HAVE_STRTOLL
+ 
  /* Define if you have the strtoul function. */
  #undef HAVE_STRTOUL
  
+ /* Define if you have the strtoull function. */
+ #undef HAVE_STRTOULL
+ 
+ /* Define if you have the strtoumax function. */
+ #undef HAVE_STRTOUMAX
+ 
  /* Define if you have the strsignal function or macro. */
  #undef HAVE_STRSIGNAL
***************
*** 553,559 ****
--- 650,662 ----
  #undef HAVE_UNAME
  
+ /* Define if you have the vasprintf function.  */
+ #undef HAVE_VASPRINTF
+ 
  /* Define if you have the vprintf function.  */
  #undef HAVE_VPRINTF
  
+ /* Define if you have the vsnprintf function.  */
+ #undef HAVE_VSNPRINTF
+ 
  /* Define if you have the waitpid function. */
  #undef HAVE_WAITPID
***************
*** 562,566 ****
  #undef HAVE_WAIT3
  
- 
  /* Presence of certain system include files. */
  
--- 665,668 ----
***************
*** 574,577 ****
--- 676,685 ----
  #undef HAVE_DLFCN_H
  
+ /* Define if you have the <grp.h> header file.  */
+ #undef HAVE_GRP_H
+ 
+ /* Define if you have the <inttypes.h> header file. */
+ #undef HAVE_INTTYPES_H
+ 
  /* Define if you have the <libintl.h> header file. */
  #undef HAVE_LIBINTL_H
***************
*** 601,604 ****
--- 709,715 ----
  #undef HAVE_STRING_H
  
+ /* Define if you have the <strings.h> header file.  */
+ #undef HAVE_STRINGS_H
+ 
  /* Define if you have the <memory.h> header file.  */
  #undef HAVE_MEMORY_H
***************
*** 607,610 ****
--- 718,724 ----
  #undef HAVE_STDDEF_H
  
+ /* Define if you have the <stdint.h> header file. */
+ #undef HAVE_STDINT_H
+ 
  /* Define if you have the <sys/dir.h> header file.  */
  #undef HAVE_SYS_DIR_H
***************
*** 690,693 ****
--- 804,813 ----
     <sys/resource.h>? */
  #undef RLIMIT_NEEDS_KERNEL
+ 
+ /* Number of bits in a file offset, on hosts where this is settable. */
+ #undef _FILE_OFFSET_BITS
+ 
+ /* Define for large files on AIX-style hosts. */
+ #undef _LARGE_FILES
  
  /* Do strcoll(3) and strcmp(3) give different results in the default locale? */
diff -Nrc2 bash-2.05/configure bash-2.05a/configure
*** bash-2.05/configure	Tue Jan 23 12:57:28 2001
--- bash-2.05a/configure	Mon Nov 12 06:53:01 2001
***************
*** 1,196 ****
  #! /bin/sh
  
! # From configure.in for Bash 2.05, version 2.90, from autoconf version 2.13
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
  
  
  
  
  
- # Guess values for system-dependent variables and create Makefiles.
- # Generated automatically using autoconf version 2.13 
- # Copyright (C) 1992, 93, 94, 95, 96 Free Software Foundation, Inc.
  #
! # This configure script is free software; the Free Software Foundation
! # gives unlimited permission to copy, distribute and modify it.
! 
! # Defaults:
! ac_help=
  ac_default_prefix=/usr/local
! # Any additions from configure.in:
! ac_help="$ac_help
! --with-afs		if you are running AFS"
! ac_help="$ac_help
! --with-bash-malloc	use the Bash version of malloc"
! ac_help="$ac_help
! --with-curses		use the curses library instead of the termcap library"
! ac_help="$ac_help
! --with-glibc-malloc	use the GNU C library version of malloc"
! ac_help="$ac_help
! --with-gnu-malloc	synonym for --with-bash-malloc"
! ac_help="$ac_help
! --with-installed-readline	use a version of the readline library that is already installed"
! ac_help="$ac_help
! --with-purecov		configure to postprocess with pure coverage"
! ac_help="$ac_help
! --with-purify		configure to postprocess with purify"
! ac_help="$ac_help
! --enable-minimal-config	a minimal sh-like configuration"
! ac_help="$ac_help
! --enable-alias		enable shell aliases"
! ac_help="$ac_help
! --enable-arith-for-command	enable arithmetic for command"
! ac_help="$ac_help
! --enable-array-variables	include shell array variables"
! ac_help="$ac_help
! --enable-bang-history	turn on csh-style history substitution"
! ac_help="$ac_help
! --enable-brace-expansion	include brace expansion"
! ac_help="$ac_help
! --enable-command-timing	enable the time reserved word and command timing"
! ac_help="$ac_help
! --enable-cond-command	enable the conditional command"
! ac_help="$ac_help
! --enable-directory-stack	enable builtins pushd/popd/dirs"
! ac_help="$ac_help
! --enable-disabled-builtins	allow disabled builtins to still be invoked"
! ac_help="$ac_help
! --enable-dparen-arithmetic	include ((...)) command"
! ac_help="$ac_help
! --enable-extended-glob	include ksh-style extended pattern matching"
! ac_help="$ac_help
! --enable-help-builtin	include the help builtin"
! ac_help="$ac_help
! --enable-history	turn on command history"
! ac_help="$ac_help
! --enable-job-control	enable job control features"
! ac_help="$ac_help
! --enable-net-redirections	enable /dev/tcp/host/port redirection"
! ac_help="$ac_help
! --enable-process-substitution	enable process substitution"
! ac_help="$ac_help
! --enable-progcomp	enable programmable completion and the complete builtin"
! ac_help="$ac_help
! --enable-prompt-string-decoding	turn on escape character decoding in prompts"
! ac_help="$ac_help
! --enable-readline	turn on command line editing"
! ac_help="$ac_help
! --enable-restricted	enable a restricted shell"
! ac_help="$ac_help
! --enable-select		include select command"
! ac_help="$ac_help
! --enable-usg-echo-default	a synonym for --enable-xpg-echo-default"
! ac_help="$ac_help
! --enable-xpg-echo-default	make the echo builtin expand escape sequences by default"
! ac_help="$ac_help
! --enable-profiling		allow profiling with gprof"
! ac_help="$ac_help
! --enable-static-link		link bash statically, for use as a root shell"
  
  # Initialize some variables set by options.
  # The variables have the same names as the options, with
  # dashes changed to underlines.
! build=NONE
! cache_file=./config.cache
  exec_prefix=NONE
- host=NONE
  no_create=
- nonopt=NONE
  no_recursion=
  prefix=NONE
--- 1,157 ----
  #! /bin/sh
+ # From configure.in for Bash 2.05a, version 2.128, from autoconf version 2.52.
+ # Guess values for system-dependent variables and create Makefiles.
+ # Generated by Autoconf 2.52 for bash 2.05a.
+ #
+ # Report bugs to <bug-bash@gnu.org>.
+ #
+ # Copyright 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001
+ # Free Software Foundation, Inc.
+ # This configure script is free software; the Free Software Foundation
+ # gives unlimited permission to copy, distribute and modify it.
  
! # Avoid depending upon Character Ranges.
! as_cr_letters='abcdefghijklmnopqrstuvwxyz'
! as_cr_LETTERS='ABCDEFGHIJKLMNOPQRSTUVWXYZ'
! as_cr_Letters=$as_cr_letters$as_cr_LETTERS
! as_cr_digits='0123456789'
! as_cr_alnum=$as_cr_Letters$as_cr_digits
! 
! # Sed expression to map a string onto a valid variable name.
! as_tr_sh="sed y%*+%pp%;s%[^_$as_cr_alnum]%_%g"
! 
! # Sed expression to map a string onto a valid CPP name.
! as_tr_cpp="sed y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g"
! 
! # Be Bourne compatible
! if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then
!   emulate sh
!   NULLCMD=:
! elif test -n "${BASH_VERSION+set}" && (set -o posix) >/dev/null 2>&1; then
!   set -o posix
! fi
! 
! # Name of the executable.
! as_me=`echo "$0" |sed 's,.*[\\/],,'`
! 
! if expr a : '\(a\)' >/dev/null 2>&1; then
!   as_expr=expr
! else
!   as_expr=false
! fi
! 
! rm -f conf$$ conf$$.exe conf$$.file
! echo >conf$$.file
! if ln -s conf$$.file conf$$ 2>/dev/null; then
!   # We could just check for DJGPP; but this test a) works b) is more generic
!   # and c) will remain valid once DJGPP supports symlinks (DJGPP 2.04).
!   if test -f conf$$.exe; then
!     # Don't use ln at all; we don't have any links
!     as_ln_s='cp -p'
!   else
!     as_ln_s='ln -s'
!   fi
! elif ln conf$$.file conf$$ 2>/dev/null; then
!   as_ln_s=ln
! else
!   as_ln_s='cp -p'
! fi
! rm -f conf$$ conf$$.exe conf$$.file
  
+ as_executable_p="test -f"
  
+ # Support unset when possible.
+ if (FOO=FOO; unset FOO) >/dev/null 2>&1; then
+   as_unset=unset
+ else
+   as_unset=false
+ fi
  
+ # NLS nuisances.
+ $as_unset LANG || test "${LANG+set}" != set || { LANG=C; export LANG; }
+ $as_unset LC_ALL || test "${LC_ALL+set}" != set || { LC_ALL=C; export LC_ALL; }
+ $as_unset LC_TIME || test "${LC_TIME+set}" != set || { LC_TIME=C; export LC_TIME; }
+ $as_unset LC_CTYPE || test "${LC_CTYPE+set}" != set || { LC_CTYPE=C; export LC_CTYPE; }
+ $as_unset LANGUAGE || test "${LANGUAGE+set}" != set || { LANGUAGE=C; export LANGUAGE; }
+ $as_unset LC_COLLATE || test "${LC_COLLATE+set}" != set || { LC_COLLATE=C; export LC_COLLATE; }
+ $as_unset LC_NUMERIC || test "${LC_NUMERIC+set}" != set || { LC_NUMERIC=C; export LC_NUMERIC; }
+ $as_unset LC_MESSAGES || test "${LC_MESSAGES+set}" != set || { LC_MESSAGES=C; export LC_MESSAGES; }
+ 
+ # IFS
+ # We need space, tab and new line, in precisely that order.
+ as_nl='
+ '
+ IFS=" 	$as_nl"
+ 
+ # CDPATH.
+ $as_unset CDPATH || test "${CDPATH+set}" != set || { CDPATH=:; export CDPATH; }
+ 
+ # Name of the host.
+ # hostname on some systems (SVR3.2, Linux) returns a bogus exit status,
+ # so uname gets run too.
+ ac_hostname=`(hostname || uname -n) 2>/dev/null | sed 1q`
  
+ exec 6>&1
  
  #
! # Initializations.
! #
  ac_default_prefix=/usr/local
! cross_compiling=no
! subdirs=
! MFLAGS= MAKEFLAGS=
! SHELL=${CONFIG_SHELL-/bin/sh}
! 
! # Maximum number of lines to put in a shell here document.
! # This variable seems obsolete.  It should probably be removed, and
! # only ac_max_sed_lines should be used.
! : ${ac_max_here_lines=38}
! 
! ac_unique_file="shell.h"
! # Factoring default headers for most tests.
! ac_includes_default="\
! #include <stdio.h>
! #if HAVE_SYS_TYPES_H
! # include <sys/types.h>
! #endif
! #if HAVE_SYS_STAT_H
! # include <sys/stat.h>
! #endif
! #if STDC_HEADERS
! # include <stdlib.h>
! # include <stddef.h>
! #else
! # if HAVE_STDLIB_H
! #  include <stdlib.h>
! # endif
! #endif
! #if HAVE_STRING_H
! # if !STDC_HEADERS && HAVE_MEMORY_H
! #  include <memory.h>
! # endif
! # include <string.h>
! #endif
! #if HAVE_STRINGS_H
! # include <strings.h>
! #endif
! #if HAVE_INTTYPES_H
! # include <inttypes.h>
! #else
! # if HAVE_STDINT_H
! #  include <stdint.h>
! # endif
! #endif
! #if HAVE_UNISTD_H
! # include <unistd.h>
! #endif"
  
  # Initialize some variables set by options.
+ ac_init_help=
+ ac_init_version=false
  # The variables have the same names as the options, with
  # dashes changed to underlines.
! cache_file=/dev/null
  exec_prefix=NONE
  no_create=
  no_recursion=
  prefix=NONE
***************
*** 201,208 ****
  site=
  srcdir=
- target=NONE
  verbose=
  x_includes=NONE
  x_libraries=NONE
  bindir='${exec_prefix}/bin'
  sbindir='${exec_prefix}/sbin'
--- 162,174 ----
  site=
  srcdir=
  verbose=
  x_includes=NONE
  x_libraries=NONE
+ 
+ # Installation directory options.
+ # These are left unexpanded so users can "make install exec_prefix=/foo"
+ # and all the variables that are supposed to be based on exec_prefix
+ # by default will actually change.
+ # Use braces instead of parens because sh, perl, etc. also accept them.
  bindir='${exec_prefix}/bin'
  sbindir='${exec_prefix}/sbin'
***************
*** 218,232 ****
  mandir='${prefix}/man'
  
! # Initialize some other variables.
! subdirs=
! MFLAGS= MAKEFLAGS=
! SHELL=${CONFIG_SHELL-/bin/sh}
! # Maximum number of lines to put in a shell here document.
! ac_max_here_lines=12
  
  ac_prev=
  for ac_option
  do
- 
    # If the previous option needs an argument, assign it.
    if test -n "$ac_prev"; then
--- 184,197 ----
  mandir='${prefix}/man'
  
! # Identity of this package.
! PACKAGE_NAME='bash'
! PACKAGE_TARNAME='bash'
! PACKAGE_VERSION='2.05a'
! PACKAGE_STRING='bash 2.05a'
! PACKAGE_BUGREPORT='bug-bash@gnu.org'
  
  ac_prev=
  for ac_option
  do
    # If the previous option needs an argument, assign it.
    if test -n "$ac_prev"; then
***************
*** 236,257 ****
    fi
  
!   case "$ac_option" in
!   -*=*) ac_optarg=`echo "$ac_option" | sed 's/[-_a-zA-Z0-9]*=//'` ;;
!   *) ac_optarg= ;;
!   esac
  
    # Accept the important Cygnus configure options, so we can diagnose typos.
  
!   case "$ac_option" in
  
    -bindir | --bindir | --bindi | --bind | --bin | --bi)
      ac_prev=bindir ;;
    -bindir=* | --bindir=* | --bindi=* | --bind=* | --bin=* | --bi=*)
!     bindir="$ac_optarg" ;;
  
    -build | --build | --buil | --bui | --bu)
!     ac_prev=build ;;
    -build=* | --build=* | --buil=* | --bui=* | --bu=*)
!     build="$ac_optarg" ;;
  
    -cache-file | --cache-file | --cache-fil | --cache-fi \
--- 201,219 ----
    fi
  
!   ac_optarg=`expr "x$ac_option" : 'x[^=]*=\(.*\)'`
  
    # Accept the important Cygnus configure options, so we can diagnose typos.
  
!   case $ac_option in
  
    -bindir | --bindir | --bindi | --bind | --bin | --bi)
      ac_prev=bindir ;;
    -bindir=* | --bindir=* | --bindi=* | --bind=* | --bin=* | --bi=*)
!     bindir=$ac_optarg ;;
  
    -build | --build | --buil | --bui | --bu)
!     ac_prev=build_alias ;;
    -build=* | --build=* | --buil=* | --bui=* | --bu=*)
!     build_alias=$ac_optarg ;;
  
    -cache-file | --cache-file | --cache-fil | --cache-fi \
***************
*** 260,264 ****
    -cache-file=* | --cache-file=* | --cache-fil=* | --cache-fi=* \
    | --cache-f=* | --cache-=* | --cache=* | --cach=* | --cac=* | --ca=* | --c=*)
!     cache_file="$ac_optarg" ;;
  
    -datadir | --datadir | --datadi | --datad | --data | --dat | --da)
--- 222,229 ----
    -cache-file=* | --cache-file=* | --cache-fil=* | --cache-fi=* \
    | --cache-f=* | --cache-=* | --cache=* | --cach=* | --cac=* | --ca=* | --c=*)
!     cache_file=$ac_optarg ;;
! 
!   --config-cache | -C)
!     cache_file=config.cache ;;
  
    -datadir | --datadir | --datadi | --datad | --data | --dat | --da)
***************
*** 266,292 ****
    -datadir=* | --datadir=* | --datadi=* | --datad=* | --data=* | --dat=* \
    | --da=*)
!     datadir="$ac_optarg" ;;
  
    -disable-* | --disable-*)
!     ac_feature=`echo $ac_option|sed -e 's/-*disable-//'`
      # Reject names that are not valid shell variable names.
!     if test -n "`echo $ac_feature| sed 's/[-a-zA-Z0-9_]//g'`"; then
!       { echo "configure: error: $ac_feature: invalid feature name" 1>&2; exit 1; }
!     fi
!     ac_feature=`echo $ac_feature| sed 's/-/_/g'`
!     eval "enable_${ac_feature}=no" ;;
  
    -enable-* | --enable-*)
!     ac_feature=`echo $ac_option|sed -e 's/-*enable-//' -e 's/=.*//'`
      # Reject names that are not valid shell variable names.
!     if test -n "`echo $ac_feature| sed 's/[-_a-zA-Z0-9]//g'`"; then
!       { echo "configure: error: $ac_feature: invalid feature name" 1>&2; exit 1; }
!     fi
!     ac_feature=`echo $ac_feature| sed 's/-/_/g'`
!     case "$ac_option" in
!       *=*) ;;
        *) ac_optarg=yes ;;
      esac
!     eval "enable_${ac_feature}='$ac_optarg'" ;;
  
    -exec-prefix | --exec_prefix | --exec-prefix | --exec-prefi \
--- 231,257 ----
    -datadir=* | --datadir=* | --datadi=* | --datad=* | --data=* | --dat=* \
    | --da=*)
!     datadir=$ac_optarg ;;
  
    -disable-* | --disable-*)
!     ac_feature=`expr "x$ac_option" : 'x-*disable-\(.*\)'`
      # Reject names that are not valid shell variable names.
!     expr "x$ac_feature" : ".*[^-_$as_cr_alnum]" >/dev/null &&
!       { echo "$as_me: error: invalid feature name: $ac_feature" >&2
!    { (exit 1); exit 1; }; }
!     ac_feature=`echo $ac_feature | sed 's/-/_/g'`
!     eval "enable_$ac_feature=no" ;;
  
    -enable-* | --enable-*)
!     ac_feature=`expr "x$ac_option" : 'x-*enable-\([^=]*\)'`
      # Reject names that are not valid shell variable names.
!     expr "x$ac_feature" : ".*[^-_$as_cr_alnum]" >/dev/null &&
!       { echo "$as_me: error: invalid feature name: $ac_feature" >&2
!    { (exit 1); exit 1; }; }
!     ac_feature=`echo $ac_feature | sed 's/-/_/g'`
!     case $ac_option in
!       *=*) ac_optarg=`echo "$ac_optarg" | sed "s/'/'\\\\\\\\''/g"`;;
        *) ac_optarg=yes ;;
      esac
!     eval "enable_$ac_feature='$ac_optarg'" ;;
  
    -exec-prefix | --exec_prefix | --exec-prefix | --exec-prefi \
***************
*** 297,301 ****
    | --exec-pref=* | --exec-pre=* | --exec-pr=* | --exec-p=* | --exec-=* \
    | --exec=* | --exe=* | --ex=*)
!     exec_prefix="$ac_optarg" ;;
  
    -gas | --gas | --ga | --g)
--- 262,266 ----
    | --exec-pref=* | --exec-pre=* | --exec-pr=* | --exec-p=* | --exec-=* \
    | --exec=* | --exe=* | --ex=*)
!     exec_prefix=$ac_optarg ;;
  
    -gas | --gas | --ga | --g)
***************
*** 303,365 ****
      with_gas=yes ;;
  
!   -help | --help | --hel | --he)
!     # Omit some internal or obsolete options to make the list less imposing.
!     # This message is too long to be a string in the A/UX 3.1 sh.
!     cat << EOF
! Usage: configure [options] [host]
! Options: [defaults in brackets after descriptions]
! Configuration:
!   --cache-file=FILE       cache test results in FILE
!   --help                  print this message
!   --no-create             do not create output files
!   --quiet, --silent       do not print \`checking...' messages
!   --version               print the version of autoconf that created configure
! Directory and file names:
!   --prefix=PREFIX         install architecture-independent files in PREFIX
!                           [$ac_default_prefix]
!   --exec-prefix=EPREFIX   install architecture-dependent files in EPREFIX
!                           [same as prefix]
!   --bindir=DIR            user executables in DIR [EPREFIX/bin]
!   --sbindir=DIR           system admin executables in DIR [EPREFIX/sbin]
!   --libexecdir=DIR        program executables in DIR [EPREFIX/libexec]
!   --datadir=DIR           read-only architecture-independent data in DIR
!                           [PREFIX/share]
!   --sysconfdir=DIR        read-only single-machine data in DIR [PREFIX/etc]
!   --sharedstatedir=DIR    modifiable architecture-independent data in DIR
!                           [PREFIX/com]
!   --localstatedir=DIR     modifiable single-machine data in DIR [PREFIX/var]
!   --libdir=DIR            object code libraries in DIR [EPREFIX/lib]
!   --includedir=DIR        C header files in DIR [PREFIX/include]
!   --oldincludedir=DIR     C header files for non-gcc in DIR [/usr/include]
!   --infodir=DIR           info documentation in DIR [PREFIX/info]
!   --mandir=DIR            man documentation in DIR [PREFIX/man]
!   --srcdir=DIR            find the sources in DIR [configure dir or ..]
!   --program-prefix=PREFIX prepend PREFIX to installed program names
!   --program-suffix=SUFFIX append SUFFIX to installed program names
!   --program-transform-name=PROGRAM
!                           run sed PROGRAM on installed program names
! EOF
!     cat << EOF
! Host type:
!   --build=BUILD           configure for building on BUILD [BUILD=HOST]
!   --host=HOST             configure for HOST [guessed]
!   --target=TARGET         configure for TARGET [TARGET=HOST]
! Features and packages:
!   --disable-FEATURE       do not include FEATURE (same as --enable-FEATURE=no)
!   --enable-FEATURE[=ARG]  include FEATURE [ARG=yes]
!   --with-PACKAGE[=ARG]    use PACKAGE [ARG=yes]
!   --without-PACKAGE       do not use PACKAGE (same as --with-PACKAGE=no)
!   --x-includes=DIR        X include files are in DIR
!   --x-libraries=DIR       X library files are in DIR
! EOF
!     if test -n "$ac_help"; then
!       echo "--enable and --with options recognized:$ac_help"
!     fi
!     exit 0 ;;
  
    -host | --host | --hos | --ho)
!     ac_prev=host ;;
    -host=* | --host=* | --hos=* | --ho=*)
!     host="$ac_optarg" ;;
  
    -includedir | --includedir | --includedi | --included | --include \
--- 268,282 ----
      with_gas=yes ;;
  
!   -help | --help | --hel | --he | -h)
!     ac_init_help=long ;;
!   -help=r* | --help=r* | --hel=r* | --he=r* | -hr*)
!     ac_init_help=recursive ;;
!   -help=s* | --help=s* | --hel=s* | --he=s* | -hs*)
!     ac_init_help=short ;;
  
    -host | --host | --hos | --ho)
!     ac_prev=host_alias ;;
    -host=* | --host=* | --hos=* | --ho=*)
!     host_alias=$ac_optarg ;;
  
    -includedir | --includedir | --includedi | --included | --include \
***************
*** 368,382 ****
    -includedir=* | --includedir=* | --includedi=* | --included=* | --include=* \
    | --includ=* | --inclu=* | --incl=* | --inc=*)
!     includedir="$ac_optarg" ;;
  
    -infodir | --infodir | --infodi | --infod | --info | --inf)
      ac_prev=infodir ;;
    -infodir=* | --infodir=* | --infodi=* | --infod=* | --info=* | --inf=*)
!     infodir="$ac_optarg" ;;
  
    -libdir | --libdir | --libdi | --libd)
      ac_prev=libdir ;;
    -libdir=* | --libdir=* | --libdi=* | --libd=*)
!     libdir="$ac_optarg" ;;
  
    -libexecdir | --libexecdir | --libexecdi | --libexecd | --libexec \
--- 285,299 ----
    -includedir=* | --includedir=* | --includedi=* | --included=* | --include=* \
    | --includ=* | --inclu=* | --incl=* | --inc=*)
!     includedir=$ac_optarg ;;
  
    -infodir | --infodir | --infodi | --infod | --info | --inf)
      ac_prev=infodir ;;
    -infodir=* | --infodir=* | --infodi=* | --infod=* | --info=* | --inf=*)
!     infodir=$ac_optarg ;;
  
    -libdir | --libdir | --libdi | --libd)
      ac_prev=libdir ;;
    -libdir=* | --libdir=* | --libdi=* | --libd=*)
!     libdir=$ac_optarg ;;
  
    -libexecdir | --libexecdir | --libexecdi | --libexecd | --libexec \
***************
*** 385,389 ****
    -libexecdir=* | --libexecdir=* | --libexecdi=* | --libexecd=* | --libexec=* \
    | --libexe=* | --libex=* | --libe=*)
!     libexecdir="$ac_optarg" ;;
  
    -localstatedir | --localstatedir | --localstatedi | --localstated \
--- 302,306 ----
    -libexecdir=* | --libexecdir=* | --libexecdi=* | --libexecd=* | --libexec=* \
    | --libexe=* | --libex=* | --libe=*)
!     libexecdir=$ac_optarg ;;
  
    -localstatedir | --localstatedir | --localstatedi | --localstated \
***************
*** 394,403 ****
    | --localstate=* | --localstat=* | --localsta=* | --localst=* \
    | --locals=* | --local=* | --loca=* | --loc=* | --lo=*)
!     localstatedir="$ac_optarg" ;;
  
    -mandir | --mandir | --mandi | --mand | --man | --ma | --m)
      ac_prev=mandir ;;
    -mandir=* | --mandir=* | --mandi=* | --mand=* | --man=* | --ma=* | --m=*)
!     mandir="$ac_optarg" ;;
  
    -nfp | --nfp | --nf)
--- 311,320 ----
    | --localstate=* | --localstat=* | --localsta=* | --localst=* \
    | --locals=* | --local=* | --loca=* | --loc=* | --lo=*)
!     localstatedir=$ac_optarg ;;
  
    -mandir | --mandir | --mandi | --mand | --man | --ma | --m)
      ac_prev=mandir ;;
    -mandir=* | --mandir=* | --mandi=* | --mand=* | --man=* | --ma=* | --m=*)
!     mandir=$ac_optarg ;;
  
    -nfp | --nfp | --nf)
***************
*** 420,429 ****
    | --oldinclude=* | --oldinclud=* | --oldinclu=* | --oldincl=* | --oldinc=* \
    | --oldin=* | --oldi=* | --old=* | --ol=* | --o=*)
!     oldincludedir="$ac_optarg" ;;
  
    -prefix | --prefix | --prefi | --pref | --pre | --pr | --p)
      ac_prev=prefix ;;
    -prefix=* | --prefix=* | --prefi=* | --pref=* | --pre=* | --pr=* | --p=*)
!     prefix="$ac_optarg" ;;
  
    -program-prefix | --program-prefix | --program-prefi | --program-pref \
--- 337,346 ----
    | --oldinclude=* | --oldinclud=* | --oldinclu=* | --oldincl=* | --oldinc=* \
    | --oldin=* | --oldi=* | --old=* | --ol=* | --o=*)
!     oldincludedir=$ac_optarg ;;
  
    -prefix | --prefix | --prefi | --pref | --pre | --pr | --p)
      ac_prev=prefix ;;
    -prefix=* | --prefix=* | --prefi=* | --pref=* | --pre=* | --pr=* | --p=*)
!     prefix=$ac_optarg ;;
  
    -program-prefix | --program-prefix | --program-prefi | --program-pref \
***************
*** 432,436 ****
    -program-prefix=* | --program-prefix=* | --program-prefi=* \
    | --program-pref=* | --program-pre=* | --program-pr=* | --program-p=*)
!     program_prefix="$ac_optarg" ;;
  
    -program-suffix | --program-suffix | --program-suffi | --program-suff \
--- 349,353 ----
    -program-prefix=* | --program-prefix=* | --program-prefi=* \
    | --program-pref=* | --program-pre=* | --program-pr=* | --program-p=*)
!     program_prefix=$ac_optarg ;;
  
    -program-suffix | --program-suffix | --program-suffi | --program-suff \
***************
*** 439,443 ****
    -program-suffix=* | --program-suffix=* | --program-suffi=* \
    | --program-suff=* | --program-suf=* | --program-su=* | --program-s=*)
!     program_suffix="$ac_optarg" ;;
  
    -program-transform-name | --program-transform-name \
--- 356,360 ----
    -program-suffix=* | --program-suffix=* | --program-suffi=* \
    | --program-suff=* | --program-suf=* | --program-su=* | --program-s=*)
!     program_suffix=$ac_optarg ;;
  
    -program-transform-name | --program-transform-name \
***************
*** 456,460 ****
    | --program-trans=* | --program-tran=* \
    | --progr-tra=* | --program-tr=* | --program-t=*)
!     program_transform_name="$ac_optarg" ;;
  
    -q | -quiet | --quiet | --quie | --qui | --qu | --q \
--- 373,377 ----
    | --program-trans=* | --program-tran=* \
    | --progr-tra=* | --program-tr=* | --program-t=*)
!     program_transform_name=$ac_optarg ;;
  
    -q | -quiet | --quiet | --quie | --qui | --qu | --q \
***************
*** 466,470 ****
    -sbindir=* | --sbindir=* | --sbindi=* | --sbind=* | --sbin=* \
    | --sbi=* | --sb=*)
!     sbindir="$ac_optarg" ;;
  
    -sharedstatedir | --sharedstatedir | --sharedstatedi \
--- 383,387 ----
    -sbindir=* | --sbindir=* | --sbindi=* | --sbind=* | --sbin=* \
    | --sbi=* | --sb=*)
!     sbindir=$ac_optarg ;;
  
    -sharedstatedir | --sharedstatedir | --sharedstatedi \
***************
*** 477,491 ****
    | --sharedst=* | --shareds=* | --shared=* | --share=* | --shar=* \
    | --sha=* | --sh=*)
!     sharedstatedir="$ac_optarg" ;;
  
    -site | --site | --sit)
      ac_prev=site ;;
    -site=* | --site=* | --sit=*)
!     site="$ac_optarg" ;;
  
    -srcdir | --srcdir | --srcdi | --srcd | --src | --sr)
      ac_prev=srcdir ;;
    -srcdir=* | --srcdir=* | --srcdi=* | --srcd=* | --src=* | --sr=*)
!     srcdir="$ac_optarg" ;;
  
    -sysconfdir | --sysconfdir | --sysconfdi | --sysconfd | --sysconf \
--- 394,408 ----
    | --sharedst=* | --shareds=* | --shared=* | --share=* | --shar=* \
    | --sha=* | --sh=*)
!     sharedstatedir=$ac_optarg ;;
  
    -site | --site | --sit)
      ac_prev=site ;;
    -site=* | --site=* | --sit=*)
!     site=$ac_optarg ;;
  
    -srcdir | --srcdir | --srcdi | --srcd | --src | --sr)
      ac_prev=srcdir ;;
    -srcdir=* | --srcdir=* | --srcdi=* | --srcd=* | --src=* | --sr=*)
!     srcdir=$ac_optarg ;;
  
    -sysconfdir | --sysconfdir | --sysconfdi | --sysconfd | --sysconf \
***************
*** 494,532 ****
    -sysconfdir=* | --sysconfdir=* | --sysconfdi=* | --sysconfd=* | --sysconf=* \
    | --syscon=* | --sysco=* | --sysc=* | --sys=* | --sy=*)
!     sysconfdir="$ac_optarg" ;;
  
    -target | --target | --targe | --targ | --tar | --ta | --t)
!     ac_prev=target ;;
    -target=* | --target=* | --targe=* | --targ=* | --tar=* | --ta=* | --t=*)
!     target="$ac_optarg" ;;
  
    -v | -verbose | --verbose | --verbos | --verbo | --verb)
      verbose=yes ;;
  
!   -version | --version | --versio | --versi | --vers)
!     echo "configure generated by autoconf version 2.13"
!     exit 0 ;;
  
    -with-* | --with-*)
!     ac_package=`echo $ac_option|sed -e 's/-*with-//' -e 's/=.*//'`
      # Reject names that are not valid shell variable names.
!     if test -n "`echo $ac_package| sed 's/[-_a-zA-Z0-9]//g'`"; then
!       { echo "configure: error: $ac_package: invalid package name" 1>&2; exit 1; }
!     fi
      ac_package=`echo $ac_package| sed 's/-/_/g'`
!     case "$ac_option" in
!       *=*) ;;
        *) ac_optarg=yes ;;
      esac
!     eval "with_${ac_package}='$ac_optarg'" ;;
  
    -without-* | --without-*)
!     ac_package=`echo $ac_option|sed -e 's/-*without-//'`
      # Reject names that are not valid shell variable names.
!     if test -n "`echo $ac_package| sed 's/[-a-zA-Z0-9_]//g'`"; then
!       { echo "configure: error: $ac_package: invalid package name" 1>&2; exit 1; }
!     fi
!     ac_package=`echo $ac_package| sed 's/-/_/g'`
!     eval "with_${ac_package}=no" ;;
  
    --x)
--- 411,448 ----
    -sysconfdir=* | --sysconfdir=* | --sysconfdi=* | --sysconfd=* | --sysconf=* \
    | --syscon=* | --sysco=* | --sysc=* | --sys=* | --sy=*)
!     sysconfdir=$ac_optarg ;;
  
    -target | --target | --targe | --targ | --tar | --ta | --t)
!     ac_prev=target_alias ;;
    -target=* | --target=* | --targe=* | --targ=* | --tar=* | --ta=* | --t=*)
!     target_alias=$ac_optarg ;;
  
    -v | -verbose | --verbose | --verbos | --verbo | --verb)
      verbose=yes ;;
  
!   -version | --version | --versio | --versi | --vers | -V)
!     ac_init_version=: ;;
  
    -with-* | --with-*)
!     ac_package=`expr "x$ac_option" : 'x-*with-\([^=]*\)'`
      # Reject names that are not valid shell variable names.
!     expr "x$ac_package" : ".*[^-_$as_cr_alnum]" >/dev/null &&
!       { echo "$as_me: error: invalid package name: $ac_package" >&2
!    { (exit 1); exit 1; }; }
      ac_package=`echo $ac_package| sed 's/-/_/g'`
!     case $ac_option in
!       *=*) ac_optarg=`echo "$ac_optarg" | sed "s/'/'\\\\\\\\''/g"`;;
        *) ac_optarg=yes ;;
      esac
!     eval "with_$ac_package='$ac_optarg'" ;;
  
    -without-* | --without-*)
!     ac_package=`expr "x$ac_option" : 'x-*without-\(.*\)'`
      # Reject names that are not valid shell variable names.
!     expr "x$ac_package" : ".*[^-_$as_cr_alnum]" >/dev/null &&
!       { echo "$as_me: error: invalid package name: $ac_package" >&2
!    { (exit 1); exit 1; }; }
!     ac_package=`echo $ac_package | sed 's/-/_/g'`
!     eval "with_$ac_package=no" ;;
  
    --x)
***************
*** 539,543 ****
    -x-includes=* | --x-includes=* | --x-include=* | --x-includ=* | --x-inclu=* \
    | --x-incl=* | --x-inc=* | --x-in=* | --x-i=*)
!     x_includes="$ac_optarg" ;;
  
    -x-libraries | --x-libraries | --x-librarie | --x-librari \
--- 455,459 ----
    -x-includes=* | --x-includes=* | --x-include=* | --x-includ=* | --x-inclu=* \
    | --x-incl=* | --x-inc=* | --x-in=* | --x-i=*)
!     x_includes=$ac_optarg ;;
  
    -x-libraries | --x-libraries | --x-librarie | --x-librari \
***************
*** 546,562 ****
    -x-libraries=* | --x-libraries=* | --x-librarie=* | --x-librari=* \
    | --x-librar=* | --x-libra=* | --x-libr=* | --x-lib=* | --x-li=* | --x-l=*)
!     x_libraries="$ac_optarg" ;;
  
!   -*) { echo "configure: error: $ac_option: invalid option; use --help to show usage" 1>&2; exit 1; }
      ;;
  
    *)
!     if test -n "`echo $ac_option| sed 's/[-a-z0-9.]//g'`"; then
!       echo "configure: warning: $ac_option: invalid host type" 1>&2
!     fi
!     if test "x$nonopt" != xNONE; then
!       { echo "configure: error: can only configure for one host and one target at a time" 1>&2; exit 1; }
!     fi
!     nonopt="$ac_option"
      ;;
  
--- 462,488 ----
    -x-libraries=* | --x-libraries=* | --x-librarie=* | --x-librari=* \
    | --x-librar=* | --x-libra=* | --x-libr=* | --x-lib=* | --x-li=* | --x-l=*)
!     x_libraries=$ac_optarg ;;
  
!   -*) { echo "$as_me: error: unrecognized option: $ac_option
! Try \`$0 --help' for more information." >&2
!    { (exit 1); exit 1; }; }
      ;;
  
+   *=*)
+     ac_envvar=`expr "x$ac_option" : 'x\([^=]*\)='`
+     # Reject names that are not valid shell variable names.
+     expr "x$ac_envvar" : ".*[^_$as_cr_alnum]" >/dev/null &&
+       { echo "$as_me: error: invalid variable name: $ac_envvar" >&2
+    { (exit 1); exit 1; }; }
+     ac_optarg=`echo "$ac_optarg" | sed "s/'/'\\\\\\\\''/g"`
+     eval "$ac_envvar='$ac_optarg'"
+     export $ac_envvar ;;
+ 
    *)
!     # FIXME: should be removed in autoconf 3.0.
!     echo "$as_me: WARNING: you should use --build, --host, --target" >&2
!     expr "x$ac_option" : ".*[^-._$as_cr_alnum]" >/dev/null &&
!       echo "$as_me: WARNING: invalid host type: $ac_option" >&2
!     : ${build_alias=$ac_option} ${host_alias=$ac_option} ${target_alias=$ac_option}
      ;;
  
***************
*** 565,627 ****
  
  if test -n "$ac_prev"; then
!   { echo "configure: error: missing argument to --`echo $ac_prev | sed 's/_/-/g'`" 1>&2; exit 1; }
  fi
  
! trap 'rm -fr conftest* confdefs* core core.* *.core $ac_clean_files; exit 1' 1 2 15
! 
! # File descriptor usage:
! # 0 standard input
! # 1 file creation
! # 2 errors and warnings
! # 3 some systems may open it to /dev/tty
! # 4 used on the Kubota Titan
! # 6 checking for... messages and results
! # 5 compiler messages saved in config.log
! if test "$silent" = yes; then
!   exec 6>/dev/null
! else
!   exec 6>&1
! fi
! exec 5>./config.log
! 
! echo "\
! This file contains any messages produced by compilers while
! running configure, to aid debugging if configure makes a mistake.
! " 1>&5
  
! # Strip out --no-create and --no-recursion so they do not pile up.
! # Also quote any args containing shell metacharacters.
! ac_configure_args=
! for ac_arg
  do
!   case "$ac_arg" in
!   -no-create | --no-create | --no-creat | --no-crea | --no-cre \
!   | --no-cr | --no-c) ;;
!   -no-recursion | --no-recursion | --no-recursio | --no-recursi \
!   | --no-recurs | --no-recur | --no-recu | --no-rec | --no-re | --no-r) ;;
!   *" "*|*"	"*|*[\[\]\~\#\$\^\&\*\(\)\{\}\\\|\;\<\>\?]*)
!   ac_configure_args="$ac_configure_args '$ac_arg'" ;;
!   *) ac_configure_args="$ac_configure_args $ac_arg" ;;
    esac
  done
  
! # NLS nuisances.
! # Only set these to C if already set.  These must not be set unconditionally
! # because not all systems understand e.g. LANG=C (notably SCO).
! # Fixing LC_MESSAGES prevents Solaris sh from translating var values in `set'!
! # Non-C LC_CTYPE values break the ctype check.
! if test "${LANG+set}"   = set; then LANG=C;   export LANG;   fi
! if test "${LC_ALL+set}" = set; then LC_ALL=C; export LC_ALL; fi
! if test "${LC_MESSAGES+set}" = set; then LC_MESSAGES=C; export LC_MESSAGES; fi
! if test "${LC_CTYPE+set}"    = set; then LC_CTYPE=C;    export LC_CTYPE;    fi
  
! # confdefs.h avoids OS command line length limits that DEFS can exceed.
! rm -rf conftest* confdefs.h
! # AIX cpp loses on an empty file, so make sure it contains at least a newline.
! echo > confdefs.h
  
! # A filename unique to this package, relative to the directory that
! # configure is in, which we can look for to find out if srcdir is correct.
! ac_unique_file=shell.h
  
  # Find the source files, if location was not specified.
--- 491,543 ----
  
  if test -n "$ac_prev"; then
!   ac_option=--`echo $ac_prev | sed 's/_/-/g'`
!   { echo "$as_me: error: missing argument to $ac_option" >&2
!    { (exit 1); exit 1; }; }
  fi
  
! # Be sure to have absolute paths.
! for ac_var in exec_prefix prefix
! do
!   eval ac_val=$`echo $ac_var`
!   case $ac_val in
!     [\\/$]* | ?:[\\/]* | NONE | '' ) ;;
!     *)  { echo "$as_me: error: expected an absolute path for --$ac_var: $ac_val" >&2
!    { (exit 1); exit 1; }; };;
!   esac
! done
  
! # Be sure to have absolute paths.
! for ac_var in bindir sbindir libexecdir datadir sysconfdir sharedstatedir \
!               localstatedir libdir includedir oldincludedir infodir mandir
  do
!   eval ac_val=$`echo $ac_var`
!   case $ac_val in
!     [\\/$]* | ?:[\\/]* ) ;;
!     *)  { echo "$as_me: error: expected an absolute path for --$ac_var: $ac_val" >&2
!    { (exit 1); exit 1; }; };;
    esac
  done
  
! # There might be people who depend on the old broken behavior: `$host'
! # used to hold the argument of --host etc.
! build=$build_alias
! host=$host_alias
! target=$target_alias
! 
! # FIXME: should be removed in autoconf 3.0.
! if test "x$host_alias" != x; then
!   if test "x$build_alias" = x; then
!     cross_compiling=maybe
!     echo "$as_me: WARNING: If you wanted to set the --build type, don't use --host.
!     If a cross compiler is detected then cross compile mode will be used." >&2
!   elif test "x$build_alias" != "x$host_alias"; then
!     cross_compiling=yes
!   fi
! fi
  
! ac_tool_prefix=
! test -n "$host_alias" && ac_tool_prefix=$host_alias-
  
! test "$silent" = yes && exec 6>/dev/null
  
  # Find the source files, if location was not specified.
***************
*** 630,634 ****
    # Try the directory containing this script, then its parent.
    ac_prog=$0
!   ac_confdir=`echo $ac_prog|sed 's%/[^/][^/]*$%%'`
    test "x$ac_confdir" = "x$ac_prog" && ac_confdir=.
    srcdir=$ac_confdir
--- 546,550 ----
    # Try the directory containing this script, then its parent.
    ac_prog=$0
!   ac_confdir=`echo "$ac_prog" | sed 's%[\\/][^\\/][^\\/]*$%%'`
    test "x$ac_confdir" = "x$ac_prog" && ac_confdir=.
    srcdir=$ac_confdir
***************
*** 641,760 ****
  if test ! -r $srcdir/$ac_unique_file; then
    if test "$ac_srcdir_defaulted" = yes; then
!     { echo "configure: error: can not find sources in $ac_confdir or .." 1>&2; exit 1; }
    else
!     { echo "configure: error: can not find sources in $srcdir" 1>&2; exit 1; }
    fi
  fi
! srcdir=`echo "${srcdir}" | sed 's%\([^/]\)/*$%\1%'`
  
! # Prefer explicitly selected file to automatically selected ones.
! if test -z "$CONFIG_SITE"; then
!   if test "x$prefix" != xNONE; then
!     CONFIG_SITE="$prefix/share/config.site $prefix/etc/config.site"
!   else
!     CONFIG_SITE="$ac_default_prefix/share/config.site $ac_default_prefix/etc/config.site"
!   fi
! fi
! for ac_site_file in $CONFIG_SITE; do
!   if test -r "$ac_site_file"; then
!     echo "loading site script $ac_site_file"
!     . "$ac_site_file"
!   fi
! done
  
! if test -r "$cache_file"; then
!   echo "loading cache $cache_file"
!   . $cache_file
! else
!   echo "creating cache $cache_file"
!   > $cache_file
! fi
  
! ac_ext=c
! # CFLAGS is not in ac_cpp because -g, -O, etc. are not valid cpp options.
! ac_cpp='$CPP $CPPFLAGS'
! ac_compile='${CC-cc} -c $CFLAGS $CPPFLAGS conftest.$ac_ext 1>&5'
! ac_link='${CC-cc} -o conftest${ac_exeext} $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS 1>&5'
! cross_compiling=$ac_cv_prog_cc_cross
! 
! ac_exeext=
! ac_objext=o
! if (echo "testing\c"; echo 1,2,3) | grep c >/dev/null; then
!   # Stardent Vistra SVR4 grep lacks -e, says ghazi@caip.rutgers.edu.
!   if (echo -n testing; echo 1,2,3) | sed s/-n/xn/ | grep xn >/dev/null; then
!     ac_n= ac_c='
! ' ac_t='	'
!   else
!     ac_n=-n ac_c= ac_t=
!   fi
! else
!   ac_n= ac_c='\c' ac_t=
! fi
  
  
  
  
  
  
! ac_aux_dir=
! for ac_dir in ./support $srcdir/./support; do
!   if test -f $ac_dir/install-sh; then
!     ac_aux_dir=$ac_dir
!     ac_install_sh="$ac_aux_dir/install-sh -c"
!     break
!   elif test -f $ac_dir/install.sh; then
!     ac_aux_dir=$ac_dir
!     ac_install_sh="$ac_aux_dir/install.sh -c"
!     break
!   fi
! done
! if test -z "$ac_aux_dir"; then
!   { echo "configure: error: can not find install-sh or install.sh in ./support $srcdir/./support" 1>&2; exit 1; }
  fi
- ac_config_guess=$ac_aux_dir/config.guess
- ac_config_sub=$ac_aux_dir/config.sub
- ac_configure=$ac_aux_dir/configure # This should be Cygnus configure.
  
  
  
! # Make sure we can run config.sub.
! if ${CONFIG_SHELL-/bin/sh} $ac_config_sub sun4 >/dev/null 2>&1; then :
! else { echo "configure: error: can not run $ac_config_sub" 1>&2; exit 1; }
  fi
  
! echo $ac_n "checking host system type""... $ac_c" 1>&6
! echo "configure:727: checking host system type" >&5
  
! host_alias=$host
! case "$host_alias" in
! NONE)
!   case $nonopt in
!   NONE)
!     if host_alias=`${CONFIG_SHELL-/bin/sh} $ac_config_guess`; then :
!     else { echo "configure: error: can not guess host type; you must specify one" 1>&2; exit 1; }
!     fi ;;
!   *) host_alias=$nonopt ;;
!   esac ;;
! esac
  
! host=`${CONFIG_SHELL-/bin/sh} $ac_config_sub $host_alias`
! host_cpu=`echo $host | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\1/'`
! host_vendor=`echo $host | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\2/'`
! host_os=`echo $host | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\3/'`
! echo "$ac_t""$host" 1>&6
  
  
! opt_bash_malloc=yes
! opt_glibc_malloc=no
! opt_purify=no
! opt_purecov=no
! opt_afs=no
! opt_curses=no
! opt_with_installed_readline=no
  
! #htmldir=
  
! case "${host_cpu}-${host_os}" in
! alpha*-*)	opt_bash_malloc=no ;;	# alpha running osf/1 or linux
  *[Cc]ray*-*)	opt_bash_malloc=no ;;	# Crays
  *-osf1*)	opt_bash_malloc=no ;;	# other osf/1 machines
--- 557,1105 ----
  if test ! -r $srcdir/$ac_unique_file; then
    if test "$ac_srcdir_defaulted" = yes; then
!     { echo "$as_me: error: cannot find sources in $ac_confdir or .." >&2
!    { (exit 1); exit 1; }; }
    else
!     { echo "$as_me: error: cannot find sources in $srcdir" >&2
!    { (exit 1); exit 1; }; }
    fi
  fi
! srcdir=`echo "$srcdir" | sed 's%\([^\\/]\)[\\/]*$%\1%'`
! ac_env_build_alias_set=${build_alias+set}
! ac_env_build_alias_value=$build_alias
! ac_cv_env_build_alias_set=${build_alias+set}
! ac_cv_env_build_alias_value=$build_alias
! ac_env_host_alias_set=${host_alias+set}
! ac_env_host_alias_value=$host_alias
! ac_cv_env_host_alias_set=${host_alias+set}
! ac_cv_env_host_alias_value=$host_alias
! ac_env_target_alias_set=${target_alias+set}
! ac_env_target_alias_value=$target_alias
! ac_cv_env_target_alias_set=${target_alias+set}
! ac_cv_env_target_alias_value=$target_alias
! ac_env_CC_set=${CC+set}
! ac_env_CC_value=$CC
! ac_cv_env_CC_set=${CC+set}
! ac_cv_env_CC_value=$CC
! ac_env_CFLAGS_set=${CFLAGS+set}
! ac_env_CFLAGS_value=$CFLAGS
! ac_cv_env_CFLAGS_set=${CFLAGS+set}
! ac_cv_env_CFLAGS_value=$CFLAGS
! ac_env_LDFLAGS_set=${LDFLAGS+set}
! ac_env_LDFLAGS_value=$LDFLAGS
! ac_cv_env_LDFLAGS_set=${LDFLAGS+set}
! ac_cv_env_LDFLAGS_value=$LDFLAGS
! ac_env_CPPFLAGS_set=${CPPFLAGS+set}
! ac_env_CPPFLAGS_value=$CPPFLAGS
! ac_cv_env_CPPFLAGS_set=${CPPFLAGS+set}
! ac_cv_env_CPPFLAGS_value=$CPPFLAGS
! ac_env_CPP_set=${CPP+set}
! ac_env_CPP_value=$CPP
! ac_cv_env_CPP_set=${CPP+set}
! ac_cv_env_CPP_value=$CPP
  
! #
! # Report the --help message.
! #
! if test "$ac_init_help" = "long"; then
!   # Omit some internal or obsolete options to make the list less imposing.
!   # This message is too long to be a string in the A/UX 3.1 sh.
!   cat <<EOF
! \`configure' configures bash 2.05a to adapt to many kinds of systems.
  
! Usage: $0 [OPTION]... [VAR=VALUE]...
  
! To assign environment variables (e.g., CC, CFLAGS...), specify them as
! VAR=VALUE.  See below for descriptions of some of the useful variables.
  
+ Defaults for the options are specified in brackets.
  
+ Configuration:
+   -h, --help              display this help and exit
+       --help=short        display options specific to this package
+       --help=recursive    display the short help of all the included packages
+   -V, --version           display version information and exit
+   -q, --quiet, --silent   do not print \`checking...' messages
+       --cache-file=FILE   cache test results in FILE [disabled]
+   -C, --config-cache      alias for \`--cache-file=config.cache'
+   -n, --no-create         do not create output files
+       --srcdir=DIR        find the sources in DIR [configure dir or \`..']
  
+ EOF
  
+   cat <<EOF
+ Installation directories:
+   --prefix=PREFIX         install architecture-independent files in PREFIX
+                           [$ac_default_prefix]
+   --exec-prefix=EPREFIX   install architecture-dependent files in EPREFIX
+                           [PREFIX]
  
+ By default, \`make install' will install all the files in
+ \`$ac_default_prefix/bin', \`$ac_default_prefix/lib' etc.  You can specify
+ an installation prefix other than \`$ac_default_prefix' using \`--prefix',
+ for instance \`--prefix=\$HOME'.
  
! For better control, use the options below.
! 
! Fine tuning of the installation directories:
!   --bindir=DIR           user executables [EPREFIX/bin]
!   --sbindir=DIR          system admin executables [EPREFIX/sbin]
!   --libexecdir=DIR       program executables [EPREFIX/libexec]
!   --datadir=DIR          read-only architecture-independent data [PREFIX/share]
!   --sysconfdir=DIR       read-only single-machine data [PREFIX/etc]
!   --sharedstatedir=DIR   modifiable architecture-independent data [PREFIX/com]
!   --localstatedir=DIR    modifiable single-machine data [PREFIX/var]
!   --libdir=DIR           object code libraries [EPREFIX/lib]
!   --includedir=DIR       C header files [PREFIX/include]
!   --oldincludedir=DIR    C header files for non-gcc [/usr/include]
!   --infodir=DIR          info documentation [PREFIX/info]
!   --mandir=DIR           man documentation [PREFIX/man]
! EOF
! 
!   cat <<\EOF
! 
! System types:
!   --build=BUILD     configure for building on BUILD [guessed]
!   --host=HOST       build programs to run on HOST [BUILD]
! EOF
  fi
  
+ if test -n "$ac_init_help"; then
+   case $ac_init_help in
+      short | recursive ) echo "Configuration of bash 2.05a:";;
+    esac
+   cat <<\EOF
  
+ Optional Features:
+   --disable-FEATURE       do not include FEATURE (same as --enable-FEATURE=no)
+   --enable-FEATURE[=ARG]  include FEATURE [ARG=yes]
+ --enable-minimal-config	a minimal sh-like configuration
+ --enable-alias		enable shell aliases
+ --enable-arith-for-command	enable arithmetic for command
+ --enable-array-variables	include shell array variables
+ --enable-bang-history	turn on csh-style history substitution
+ --enable-brace-expansion	include brace expansion
+ --enable-command-timing	enable the time reserved word and command timing
+ --enable-cond-command	enable the conditional command
+ --enable-directory-stack	enable builtins pushd/popd/dirs
+ --enable-disabled-builtins	allow disabled builtins to still be invoked
+ --enable-dparen-arithmetic	include ((...)) command
+ --enable-extended-glob	include ksh-style extended pattern matching
+ --enable-help-builtin	include the help builtin
+ --enable-history	turn on command history
+ --enable-job-control	enable job control features
+ --enable-largefile	enable support for large files
+ --enable-net-redirections	enable /dev/tcp/host/port redirection
+ --enable-process-substitution	enable process substitution
+ --enable-progcomp	enable programmable completion and the complete builtin
+ --enable-prompt-string-decoding	turn on escape character decoding in prompts
+ --enable-readline	turn on command line editing
+ --enable-restricted	enable a restricted shell
+ --enable-select		include select command
+ --enable-usg-echo-default	a synonym for --enable-xpg-echo-default
+ --enable-xpg-echo-default	make the echo builtin expand escape sequences by default
+ --enable-profiling		allow profiling with gprof
+ --enable-static-link		link bash statically, for use as a root shell
+   --disable-largefile     omit support for large files
  
! Optional Packages:
!   --with-PACKAGE[=ARG]    use PACKAGE [ARG=yes]
!   --without-PACKAGE       do not use PACKAGE (same as --with-PACKAGE=no)
! --with-afs		if you are running AFS
! --with-bash-malloc	use the Bash version of malloc
! --with-curses		use the curses library instead of the termcap library
! --with-gnu-malloc	synonym for --with-bash-malloc
! --with-installed-readline	use a version of the readline library that is already installed
! --with-purecov		configure to postprocess with pure coverage
! --with-purify		configure to postprocess with purify
! 
! Some influential environment variables:
!   CC          C compiler command
!   CFLAGS      C compiler flags
!   LDFLAGS     linker flags, e.g. -L<lib dir> if you have libraries in a
!               nonstandard directory <lib dir>
!   CPPFLAGS    C/C++ preprocessor flags, e.g. -I<include dir> if you have
!               headers in a nonstandard directory <include dir>
!   CPP         C preprocessor
! 
! Use these variables to override the choices made by `configure' or to help
! it to find libraries and programs with nonstandard names/locations.
! 
! Report bugs to <bug-bash@gnu.org>.
! EOF
  fi
  
! if test "$ac_init_help" = "recursive"; then
!   # If there are subdirs, report their specific --help.
!   ac_popdir=`pwd`
!   for ac_subdir in : $ac_subdirs_all; do test "x$ac_subdir" = x: && continue
!     cd $ac_subdir
!     # A "../" for each directory in /$ac_subdir.
!     ac_dots=`echo $ac_subdir |
!              sed 's,^\./,,;s,[^/]$,&/,;s,[^/]*/,../,g'`
! 
!     case $srcdir in
!     .) # No --srcdir option.  We are building in place.
!       ac_sub_srcdir=$srcdir ;;
!     [\\/]* | ?:[\\/]* ) # Absolute path.
!       ac_sub_srcdir=$srcdir/$ac_subdir ;;
!     *) # Relative path.
!       ac_sub_srcdir=$ac_dots$srcdir/$ac_subdir ;;
!     esac
  
!     # Check for guested configure; otherwise get Cygnus style configure.
!     if test -f $ac_sub_srcdir/configure.gnu; then
!       echo
!       $SHELL $ac_sub_srcdir/configure.gnu  --help=recursive
!     elif test -f $ac_sub_srcdir/configure; then
!       echo
!       $SHELL $ac_sub_srcdir/configure  --help=recursive
!     elif test -f $ac_sub_srcdir/configure.ac ||
!            test -f $ac_sub_srcdir/configure.in; then
!       echo
!       $ac_configure --help
!     else
!       echo "$as_me: WARNING: no configuration information is in $ac_subdir" >&2
!     fi
!     cd $ac_popdir
!   done
! fi
  
! test -n "$ac_init_help" && exit 0
! if $ac_init_version; then
!   cat <<\EOF
! bash configure 2.05a
! generated by GNU Autoconf 2.52
! 
! Copyright 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001
! Free Software Foundation, Inc.
! This configure script is free software; the Free Software Foundation
! gives unlimited permission to copy, distribute and modify it.
! EOF
!   exit 0
! fi
! exec 5>config.log
! cat >&5 <<EOF
! This file contains any messages produced by compilers while
! running configure, to aid debugging if configure makes a mistake.
  
+ It was created by bash $as_me 2.05a, which was
+ generated by GNU Autoconf 2.52.  Invocation command line was
  
!   $ $0 $@
  
! EOF
! {
! cat <<_ASUNAME
! ## ---------- ##
! ## Platform.  ##
! ## ---------- ##
  
! hostname = `(hostname || uname -n) 2>/dev/null | sed 1q`
! uname -m = `(uname -m) 2>/dev/null || echo unknown`
! uname -r = `(uname -r) 2>/dev/null || echo unknown`
! uname -s = `(uname -s) 2>/dev/null || echo unknown`
! uname -v = `(uname -v) 2>/dev/null || echo unknown`
! 
! /usr/bin/uname -p = `(/usr/bin/uname -p) 2>/dev/null || echo unknown`
! /bin/uname -X     = `(/bin/uname -X) 2>/dev/null     || echo unknown`
! 
! /bin/arch              = `(/bin/arch) 2>/dev/null              || echo unknown`
! /usr/bin/arch -k       = `(/usr/bin/arch -k) 2>/dev/null       || echo unknown`
! /usr/convex/getsysinfo = `(/usr/convex/getsysinfo) 2>/dev/null || echo unknown`
! hostinfo               = `(hostinfo) 2>/dev/null               || echo unknown`
! /bin/machine           = `(/bin/machine) 2>/dev/null           || echo unknown`
! /usr/bin/oslevel       = `(/usr/bin/oslevel) 2>/dev/null       || echo unknown`
! /bin/universe          = `(/bin/universe) 2>/dev/null          || echo unknown`
! 
! PATH = $PATH
! 
! _ASUNAME
! } >&5
! 
! cat >&5 <<EOF
! ## ------------ ##
! ## Core tests.  ##
! ## ------------ ##
! 
! EOF
! 
! # Keep a trace of the command line.
! # Strip out --no-create and --no-recursion so they do not pile up.
! # Also quote any args containing shell meta-characters.
! ac_configure_args=
! ac_sep=
! for ac_arg
! do
!   case $ac_arg in
!   -no-create | --no-create | --no-creat | --no-crea | --no-cre \
!   | --no-cr | --no-c) ;;
!   -no-recursion | --no-recursion | --no-recursio | --no-recursi \
!   | --no-recurs | --no-recur | --no-recu | --no-rec | --no-re | --no-r) ;;
!   *" "*|*"	"*|*[\[\]\~\#\$\^\&\*\(\)\{\}\\\|\;\<\>\?\"\']*)
!     ac_arg=`echo "$ac_arg" | sed "s/'/'\\\\\\\\''/g"`
!     ac_configure_args="$ac_configure_args$ac_sep'$ac_arg'"
!     ac_sep=" " ;;
!   *) ac_configure_args="$ac_configure_args$ac_sep$ac_arg"
!      ac_sep=" " ;;
!   esac
!   # Get rid of the leading space.
! done
! 
! # When interrupted or exit'd, cleanup temporary files, and complete
! # config.log.  We remove comments because anyway the quotes in there
! # would cause problems or look ugly.
! trap 'exit_status=$?
!   # Save into config.log some information that might help in debugging.
!   echo >&5
!   echo "## ----------------- ##" >&5
!   echo "## Cache variables.  ##" >&5
!   echo "## ----------------- ##" >&5
!   echo >&5
!   # The following way of writing the cache mishandles newlines in values,
! {
!   (set) 2>&1 |
!     case `(ac_space='"'"' '"'"'; set | grep ac_space) 2>&1` in
!     *ac_space=\ *)
!       sed -n \
!         "s/'"'"'/'"'"'\\\\'"'"''"'"'/g;
!     	  s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1='"'"'\\2'"'"'/p"
!       ;;
!     *)
!       sed -n \
!         "s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1=\\2/p"
!       ;;
!     esac;
! } >&5
!   sed "/^$/d" confdefs.h >conftest.log
!   if test -s conftest.log; then
!     echo >&5
!     echo "## ------------ ##" >&5
!     echo "## confdefs.h.  ##" >&5
!     echo "## ------------ ##" >&5
!     echo >&5
!     cat conftest.log >&5
!   fi
!   (echo; echo) >&5
!   test "$ac_signal" != 0 &&
!     echo "$as_me: caught signal $ac_signal" >&5
!   echo "$as_me: exit $exit_status" >&5
!   rm -rf conftest* confdefs* core core.* *.core conf$$* $ac_clean_files &&
!     exit $exit_status
!      ' 0
! for ac_signal in 1 2 13 15; do
!   trap 'ac_signal='$ac_signal'; { (exit 1); exit 1; }' $ac_signal
! done
! ac_signal=0
! 
! # confdefs.h avoids OS command line length limits that DEFS can exceed.
! rm -rf conftest* confdefs.h
! # AIX cpp loses on an empty file, so make sure it contains at least a newline.
! echo >confdefs.h
! 
! # Let the site file select an alternate cache file if it wants to.
! # Prefer explicitly selected file to automatically selected ones.
! if test -z "$CONFIG_SITE"; then
!   if test "x$prefix" != xNONE; then
!     CONFIG_SITE="$prefix/share/config.site $prefix/etc/config.site"
!   else
!     CONFIG_SITE="$ac_default_prefix/share/config.site $ac_default_prefix/etc/config.site"
!   fi
! fi
! for ac_site_file in $CONFIG_SITE; do
!   if test -r "$ac_site_file"; then
!     { echo "$as_me:910: loading site script $ac_site_file" >&5
! echo "$as_me: loading site script $ac_site_file" >&6;}
!     cat "$ac_site_file" >&5
!     . "$ac_site_file"
!   fi
! done
! 
! if test -r "$cache_file"; then
!   # Some versions of bash will fail to source /dev/null (special
!   # files actually), so we avoid doing that.
!   if test -f "$cache_file"; then
!     { echo "$as_me:921: loading cache $cache_file" >&5
! echo "$as_me: loading cache $cache_file" >&6;}
!     case $cache_file in
!       [\\/]* | ?:[\\/]* ) . $cache_file;;
!       *)                      . ./$cache_file;;
!     esac
!   fi
! else
!   { echo "$as_me:929: creating cache $cache_file" >&5
! echo "$as_me: creating cache $cache_file" >&6;}
!   >$cache_file
! fi
! 
! # Check that the precious variables saved in the cache have kept the same
! # value.
! ac_cache_corrupted=false
! for ac_var in `(set) 2>&1 |
!                sed -n 's/^ac_env_\([a-zA-Z_0-9]*\)_set=.*/\1/p'`; do
!   eval ac_old_set=\$ac_cv_env_${ac_var}_set
!   eval ac_new_set=\$ac_env_${ac_var}_set
!   eval ac_old_val="\$ac_cv_env_${ac_var}_value"
!   eval ac_new_val="\$ac_env_${ac_var}_value"
!   case $ac_old_set,$ac_new_set in
!     set,)
!       { echo "$as_me:945: error: \`$ac_var' was set to \`$ac_old_val' in the previous run" >&5
! echo "$as_me: error: \`$ac_var' was set to \`$ac_old_val' in the previous run" >&2;}
!       ac_cache_corrupted=: ;;
!     ,set)
!       { echo "$as_me:949: error: \`$ac_var' was not set in the previous run" >&5
! echo "$as_me: error: \`$ac_var' was not set in the previous run" >&2;}
!       ac_cache_corrupted=: ;;
!     ,);;
!     *)
!       if test "x$ac_old_val" != "x$ac_new_val"; then
!         { echo "$as_me:955: error: \`$ac_var' has changed since the previous run:" >&5
! echo "$as_me: error: \`$ac_var' has changed since the previous run:" >&2;}
!         { echo "$as_me:957:   former value:  $ac_old_val" >&5
! echo "$as_me:   former value:  $ac_old_val" >&2;}
!         { echo "$as_me:959:   current value: $ac_new_val" >&5
! echo "$as_me:   current value: $ac_new_val" >&2;}
!         ac_cache_corrupted=:
!       fi;;
!   esac
!   # Pass precious variables to config.status.  It doesn't matter if
!   # we pass some twice (in addition to the command line arguments).
!   if test "$ac_new_set" = set; then
!     case $ac_new_val in
!     *" "*|*"	"*|*[\[\]\~\#\$\^\&\*\(\)\{\}\\\|\;\<\>\?\"\']*)
!       ac_arg=$ac_var=`echo "$ac_new_val" | sed "s/'/'\\\\\\\\''/g"`
!       ac_configure_args="$ac_configure_args '$ac_arg'"
!       ;;
!     *) ac_configure_args="$ac_configure_args $ac_var=$ac_new_val"
!        ;;
!     esac
!   fi
! done
! if $ac_cache_corrupted; then
!   { echo "$as_me:978: error: changes in the environment can compromise the build" >&5
! echo "$as_me: error: changes in the environment can compromise the build" >&2;}
!   { { echo "$as_me:980: error: run \`make distclean' and/or \`rm $cache_file' and start over" >&5
! echo "$as_me: error: run \`make distclean' and/or \`rm $cache_file' and start over" >&2;}
!    { (exit 1); exit 1; }; }
! fi
! 
! ac_ext=c
! ac_cpp='$CPP $CPPFLAGS'
! ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
! ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
! ac_compiler_gnu=$ac_cv_c_compiler_gnu
! 
! case `echo "testing\c"; echo 1,2,3`,`echo -n testing; echo 1,2,3` in
!   *c*,-n*) ECHO_N= ECHO_C='
! ' ECHO_T='	' ;;
!   *c*,*  ) ECHO_N=-n ECHO_C= ECHO_T= ;;
!   *)      ECHO_N= ECHO_C='\c' ECHO_T= ;;
! esac
! echo "#! $SHELL" >conftest.sh
! echo  "exit 0"   >>conftest.sh
! chmod +x conftest.sh
! if { (echo "$as_me:1000: PATH=\".;.\"; conftest.sh") >&5
!   (PATH=".;."; conftest.sh) 2>&5
!   ac_status=$?
!   echo "$as_me:1003: \$? = $ac_status" >&5
!   (exit $ac_status); }; then
!   ac_path_separator=';'
! else
!   ac_path_separator=:
! fi
! PATH_SEPARATOR="$ac_path_separator"
! rm -f conftest.sh
! 
! ac_aux_dir=
! for ac_dir in ./support $srcdir/./support; do
!   if test -f $ac_dir/install-sh; then
!     ac_aux_dir=$ac_dir
!     ac_install_sh="$ac_aux_dir/install-sh -c"
!     break
!   elif test -f $ac_dir/install.sh; then
!     ac_aux_dir=$ac_dir
!     ac_install_sh="$ac_aux_dir/install.sh -c"
!     break
!   elif test -f $ac_dir/shtool; then
!     ac_aux_dir=$ac_dir
!     ac_install_sh="$ac_aux_dir/shtool install -c"
!     break
!   fi
! done
! if test -z "$ac_aux_dir"; then
!   { { echo "$as_me:1029: error: cannot find install-sh or install.sh in ./support $srcdir/./support" >&5
! echo "$as_me: error: cannot find install-sh or install.sh in ./support $srcdir/./support" >&2;}
!    { (exit 1); exit 1; }; }
! fi
! ac_config_guess="$SHELL $ac_aux_dir/config.guess"
! ac_config_sub="$SHELL $ac_aux_dir/config.sub"
! ac_configure="$SHELL $ac_aux_dir/configure" # This should be Cygnus configure.
! 
! ac_config_headers="$ac_config_headers config.h"
! 
! BASHVERS=2.05a
! 
! # Make sure we can run config.sub.
! $ac_config_sub sun4 >/dev/null 2>&1 ||
!   { { echo "$as_me:1043: error: cannot run $ac_config_sub" >&5
! echo "$as_me: error: cannot run $ac_config_sub" >&2;}
!    { (exit 1); exit 1; }; }
! 
! echo "$as_me:1047: checking build system type" >&5
! echo $ECHO_N "checking build system type... $ECHO_C" >&6
! if test "${ac_cv_build+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
! else
!   ac_cv_build_alias=$build_alias
! test -z "$ac_cv_build_alias" &&
!   ac_cv_build_alias=`$ac_config_guess`
! test -z "$ac_cv_build_alias" &&
!   { { echo "$as_me:1056: error: cannot guess build type; you must specify one" >&5
! echo "$as_me: error: cannot guess build type; you must specify one" >&2;}
!    { (exit 1); exit 1; }; }
! ac_cv_build=`$ac_config_sub $ac_cv_build_alias` ||
!   { { echo "$as_me:1060: error: $ac_config_sub $ac_cv_build_alias failed." >&5
! echo "$as_me: error: $ac_config_sub $ac_cv_build_alias failed." >&2;}
!    { (exit 1); exit 1; }; }
! 
! fi
! echo "$as_me:1065: result: $ac_cv_build" >&5
! echo "${ECHO_T}$ac_cv_build" >&6
! build=$ac_cv_build
! build_cpu=`echo $ac_cv_build | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\1/'`
! build_vendor=`echo $ac_cv_build | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\2/'`
! build_os=`echo $ac_cv_build | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\3/'`
! 
! echo "$as_me:1072: checking host system type" >&5
! echo $ECHO_N "checking host system type... $ECHO_C" >&6
! if test "${ac_cv_host+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
! else
!   ac_cv_host_alias=$host_alias
! test -z "$ac_cv_host_alias" &&
!   ac_cv_host_alias=$ac_cv_build_alias
! ac_cv_host=`$ac_config_sub $ac_cv_host_alias` ||
!   { { echo "$as_me:1081: error: $ac_config_sub $ac_cv_host_alias failed" >&5
! echo "$as_me: error: $ac_config_sub $ac_cv_host_alias failed" >&2;}
!    { (exit 1); exit 1; }; }
! 
! fi
! echo "$as_me:1086: result: $ac_cv_host" >&5
! echo "${ECHO_T}$ac_cv_host" >&6
! host=$ac_cv_host
! host_cpu=`echo $ac_cv_host | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\1/'`
! host_vendor=`echo $ac_cv_host | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\2/'`
! host_os=`echo $ac_cv_host | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\3/'`
! 
! opt_bash_malloc=yes
! opt_purify=no
! opt_purecov=no
! opt_afs=no
! opt_curses=no
! opt_with_installed_readline=no
! 
! #htmldir=
! 
! case "${host_cpu}-${host_os}" in
! alpha*-*)	opt_bash_malloc=no ;;	# alpha running osf/1 or linux
  *[Cc]ray*-*)	opt_bash_malloc=no ;;	# Crays
  *-osf1*)	opt_bash_malloc=no ;;	# other osf/1 machines
***************
*** 765,768 ****
--- 1110,1114 ----
  sparc-linux*)	opt_bash_malloc=no ;;	# sparc running linux; requires ELF
  #*-freebsd*)	opt_bash_malloc=no ;;	# they claim it's better
+ *-openbsd*)	opt_bash_malloc=no ;;	# they claim it needs eight-bit alignment
  *-aix*)		opt_bash_malloc=no ;;	# AIX machines
  *-nextstep*)	opt_bash_malloc=no ;;	# NeXT machines running NeXTstep
***************
*** 783,787 ****
    withval="$with_afs"
    opt_afs=$withval
! fi
  
  # Check whether --with-bash-malloc or --without-bash-malloc was given.
--- 1129,1133 ----
    withval="$with_afs"
    opt_afs=$withval
! fi;
  
  # Check whether --with-bash-malloc or --without-bash-malloc was given.
***************
*** 789,793 ****
    withval="$with_bash_malloc"
    opt_bash_malloc=$withval
! fi
  
  # Check whether --with-curses or --without-curses was given.
--- 1135,1139 ----
    withval="$with_bash_malloc"
    opt_bash_malloc=$withval
! fi;
  
  # Check whether --with-curses or --without-curses was given.
***************
*** 795,805 ****
    withval="$with_curses"
    opt_curses=$withval
! fi
! 
! # Check whether --with-glibc-malloc or --without-glibc-malloc was given.
! if test "${with_glibc_malloc+set}" = set; then
!   withval="$with_glibc_malloc"
!   opt_glibc_malloc=$withval
! fi
  
  # Check whether --with-gnu-malloc or --without-gnu-malloc was given.
--- 1141,1145 ----
    withval="$with_curses"
    opt_curses=$withval
! fi;
  
  # Check whether --with-gnu-malloc or --without-gnu-malloc was given.
***************
*** 807,811 ****
    withval="$with_gnu_malloc"
    opt_bash_malloc=$withval
! fi
  
  # Check whether --with-installed-readline or --without-installed-readline was given.
--- 1147,1151 ----
    withval="$with_gnu_malloc"
    opt_bash_malloc=$withval
! fi;
  
  # Check whether --with-installed-readline or --without-installed-readline was given.
***************
*** 813,817 ****
    withval="$with_installed_readline"
    opt_with_installed_readline=$withval
! fi
  
  # Check whether --with-purecov or --without-purecov was given.
--- 1153,1157 ----
    withval="$with_installed_readline"
    opt_with_installed_readline=$withval
! fi;
  
  # Check whether --with-purecov or --without-purecov was given.
***************
*** 819,823 ****
    withval="$with_purecov"
    opt_purecov=$withval
! fi
  
  # Check whether --with-purify or --without-purify was given.
--- 1159,1163 ----
    withval="$with_purecov"
    opt_purecov=$withval
! fi;
  
  # Check whether --with-purify or --without-purify was given.
***************
*** 825,844 ****
    withval="$with_purify"
    opt_purify=$withval
! fi
! 
  
! if test "$opt_glibc_malloc" = yes; then 
! 	MALLOC_TARGET=gmalloc
! 	MALLOC_SRC=gmalloc.c
! elif test "$opt_bash_malloc" = yes; then
  	MALLOC_TARGET=malloc
  	MALLOC_SRC=malloc.c
! 	cat >> confdefs.h <<\EOF
  #define USING_BASH_MALLOC 1
  EOF
  
  else
! 	MALLOC_TARGET=stubmalloc
! 	MALLOC_SRC=stub.c
  fi
  
--- 1165,1188 ----
    withval="$with_purify"
    opt_purify=$withval
! fi;
  
! if test "$opt_bash_malloc" = yes; then
  	MALLOC_TARGET=malloc
  	MALLOC_SRC=malloc.c
! 
! 	MALLOC_LIB='-lmalloc'
! 	MALLOC_LIBRARY='$(ALLOC_LIBDIR)/libmalloc.a'
! 	MALLOC_LDFLAGS='-L$(ALLOC_LIBDIR)'
! 	MALLOC_DEP='$(MALLOC_LIBRARY)'
! 
! 	cat >>confdefs.h <<\EOF
  #define USING_BASH_MALLOC 1
  EOF
  
  else
! 	MALLOC_LIB=
! 	MALLOC_LIBRARY=
! 	MALLOC_LDFLAGS=
! 	MALLOC_DEP=
  fi
  
***************
*** 854,858 ****
  
  if test "$opt_afs" = yes; then
! 	cat >> confdefs.h <<\EOF
  #define AFS 1
  EOF
--- 1198,1202 ----
  
  if test "$opt_afs" = yes; then
! 	cat >>confdefs.h <<\EOF
  #define AFS 1
  EOF
***************
*** 888,891 ****
--- 1232,1236 ----
  opt_net_redirs=yes
  opt_progcomp=yes
+ opt_largefile=yes
  
  opt_static_link=no
***************
*** 896,901 ****
    enableval="$enable_minimal_config"
    opt_minimal_config=$enableval
! fi
! 
  
  if test $opt_minimal_config = yes; then
--- 1241,1245 ----
    enableval="$enable_minimal_config"
    opt_minimal_config=$enableval
! fi;
  
  if test $opt_minimal_config = yes; then
***************
*** 913,1050 ****
    enableval="$enable_alias"
    opt_alias=$enableval
! fi
! 
  # Check whether --enable-arith-for-command or --disable-arith-for-command was given.
  if test "${enable_arith_for_command+set}" = set; then
    enableval="$enable_arith_for_command"
    opt_arith_for_command=$enableval
! fi
! 
  # Check whether --enable-array-variables or --disable-array-variables was given.
  if test "${enable_array_variables+set}" = set; then
    enableval="$enable_array_variables"
    opt_array_variables=$enableval
! fi
! 
  # Check whether --enable-bang-history or --disable-bang-history was given.
  if test "${enable_bang_history+set}" = set; then
    enableval="$enable_bang_history"
    opt_bang_history=$enableval
! fi
! 
  # Check whether --enable-brace-expansion or --disable-brace-expansion was given.
  if test "${enable_brace_expansion+set}" = set; then
    enableval="$enable_brace_expansion"
    opt_brace_expansion=$enableval
! fi
! 
  # Check whether --enable-command-timing or --disable-command-timing was given.
  if test "${enable_command_timing+set}" = set; then
    enableval="$enable_command_timing"
    opt_command_timing=$enableval
! fi
! 
  # Check whether --enable-cond-command or --disable-cond-command was given.
  if test "${enable_cond_command+set}" = set; then
    enableval="$enable_cond_command"
    opt_cond_command=$enableval
! fi
! 
  # Check whether --enable-directory-stack or --disable-directory-stack was given.
  if test "${enable_directory_stack+set}" = set; then
    enableval="$enable_directory_stack"
    opt_dirstack=$enableval
! fi
! 
  # Check whether --enable-disabled-builtins or --disable-disabled-builtins was given.
  if test "${enable_disabled_builtins+set}" = set; then
    enableval="$enable_disabled_builtins"
    opt_disabled_builtins=$enableval
! fi
! 
  # Check whether --enable-dparen-arithmetic or --disable-dparen-arithmetic was given.
  if test "${enable_dparen_arithmetic+set}" = set; then
    enableval="$enable_dparen_arithmetic"
    opt_dparen_arith=$enableval
! fi
! 
  # Check whether --enable-extended-glob or --disable-extended-glob was given.
  if test "${enable_extended_glob+set}" = set; then
    enableval="$enable_extended_glob"
    opt_extended_glob=$enableval
! fi
! 
  # Check whether --enable-help-builtin or --disable-help-builtin was given.
  if test "${enable_help_builtin+set}" = set; then
    enableval="$enable_help_builtin"
    opt_help=$enableval
! fi
! 
  # Check whether --enable-history or --disable-history was given.
  if test "${enable_history+set}" = set; then
    enableval="$enable_history"
    opt_history=$enableval
! fi
! 
  # Check whether --enable-job-control or --disable-job-control was given.
  if test "${enable_job_control+set}" = set; then
    enableval="$enable_job_control"
    opt_job_control=$enableval
! fi
! 
  # Check whether --enable-net-redirections or --disable-net-redirections was given.
  if test "${enable_net_redirections+set}" = set; then
    enableval="$enable_net_redirections"
    opt_net_redirs=$enableval
! fi
! 
  # Check whether --enable-process-substitution or --disable-process-substitution was given.
  if test "${enable_process_substitution+set}" = set; then
    enableval="$enable_process_substitution"
    opt_process_subst=$enableval
! fi
! 
  # Check whether --enable-progcomp or --disable-progcomp was given.
  if test "${enable_progcomp+set}" = set; then
    enableval="$enable_progcomp"
    opt_progcomp=$enableval
! fi
! 
  # Check whether --enable-prompt-string-decoding or --disable-prompt-string-decoding was given.
  if test "${enable_prompt_string_decoding+set}" = set; then
    enableval="$enable_prompt_string_decoding"
    opt_prompt_decoding=$enableval
! fi
! 
  # Check whether --enable-readline or --disable-readline was given.
  if test "${enable_readline+set}" = set; then
    enableval="$enable_readline"
    opt_readline=$enableval
! fi
! 
  # Check whether --enable-restricted or --disable-restricted was given.
  if test "${enable_restricted+set}" = set; then
    enableval="$enable_restricted"
    opt_restricted=$enableval
! fi
! 
  # Check whether --enable-select or --disable-select was given.
  if test "${enable_select+set}" = set; then
    enableval="$enable_select"
    opt_select=$enableval
! fi
! 
  # Check whether --enable-usg-echo-default or --disable-usg-echo-default was given.
  if test "${enable_usg_echo_default+set}" = set; then
    enableval="$enable_usg_echo_default"
    opt_xpg_echo=$enableval
! fi
! 
  # Check whether --enable-xpg-echo-default or --disable-xpg-echo-default was given.
  if test "${enable_xpg_echo_default+set}" = set; then
    enableval="$enable_xpg_echo_default"
    opt_xpg_echo=$enableval
! fi
! 
  
  # Check whether --enable-profiling or --disable-profiling was given.
--- 1257,1376 ----
    enableval="$enable_alias"
    opt_alias=$enableval
! fi;
  # Check whether --enable-arith-for-command or --disable-arith-for-command was given.
  if test "${enable_arith_for_command+set}" = set; then
    enableval="$enable_arith_for_command"
    opt_arith_for_command=$enableval
! fi;
  # Check whether --enable-array-variables or --disable-array-variables was given.
  if test "${enable_array_variables+set}" = set; then
    enableval="$enable_array_variables"
    opt_array_variables=$enableval
! fi;
  # Check whether --enable-bang-history or --disable-bang-history was given.
  if test "${enable_bang_history+set}" = set; then
    enableval="$enable_bang_history"
    opt_bang_history=$enableval
! fi;
  # Check whether --enable-brace-expansion or --disable-brace-expansion was given.
  if test "${enable_brace_expansion+set}" = set; then
    enableval="$enable_brace_expansion"
    opt_brace_expansion=$enableval
! fi;
  # Check whether --enable-command-timing or --disable-command-timing was given.
  if test "${enable_command_timing+set}" = set; then
    enableval="$enable_command_timing"
    opt_command_timing=$enableval
! fi;
  # Check whether --enable-cond-command or --disable-cond-command was given.
  if test "${enable_cond_command+set}" = set; then
    enableval="$enable_cond_command"
    opt_cond_command=$enableval
! fi;
  # Check whether --enable-directory-stack or --disable-directory-stack was given.
  if test "${enable_directory_stack+set}" = set; then
    enableval="$enable_directory_stack"
    opt_dirstack=$enableval
! fi;
  # Check whether --enable-disabled-builtins or --disable-disabled-builtins was given.
  if test "${enable_disabled_builtins+set}" = set; then
    enableval="$enable_disabled_builtins"
    opt_disabled_builtins=$enableval
! fi;
  # Check whether --enable-dparen-arithmetic or --disable-dparen-arithmetic was given.
  if test "${enable_dparen_arithmetic+set}" = set; then
    enableval="$enable_dparen_arithmetic"
    opt_dparen_arith=$enableval
! fi;
  # Check whether --enable-extended-glob or --disable-extended-glob was given.
  if test "${enable_extended_glob+set}" = set; then
    enableval="$enable_extended_glob"
    opt_extended_glob=$enableval
! fi;
  # Check whether --enable-help-builtin or --disable-help-builtin was given.
  if test "${enable_help_builtin+set}" = set; then
    enableval="$enable_help_builtin"
    opt_help=$enableval
! fi;
  # Check whether --enable-history or --disable-history was given.
  if test "${enable_history+set}" = set; then
    enableval="$enable_history"
    opt_history=$enableval
! fi;
  # Check whether --enable-job-control or --disable-job-control was given.
  if test "${enable_job_control+set}" = set; then
    enableval="$enable_job_control"
    opt_job_control=$enableval
! fi;
! # Check whether --enable-largefile or --disable-largefile was given.
! if test "${enable_largefile+set}" = set; then
!   enableval="$enable_largefile"
!   opt_largefile=$enableval
! fi;
  # Check whether --enable-net-redirections or --disable-net-redirections was given.
  if test "${enable_net_redirections+set}" = set; then
    enableval="$enable_net_redirections"
    opt_net_redirs=$enableval
! fi;
  # Check whether --enable-process-substitution or --disable-process-substitution was given.
  if test "${enable_process_substitution+set}" = set; then
    enableval="$enable_process_substitution"
    opt_process_subst=$enableval
! fi;
  # Check whether --enable-progcomp or --disable-progcomp was given.
  if test "${enable_progcomp+set}" = set; then
    enableval="$enable_progcomp"
    opt_progcomp=$enableval
! fi;
  # Check whether --enable-prompt-string-decoding or --disable-prompt-string-decoding was given.
  if test "${enable_prompt_string_decoding+set}" = set; then
    enableval="$enable_prompt_string_decoding"
    opt_prompt_decoding=$enableval
! fi;
  # Check whether --enable-readline or --disable-readline was given.
  if test "${enable_readline+set}" = set; then
    enableval="$enable_readline"
    opt_readline=$enableval
! fi;
  # Check whether --enable-restricted or --disable-restricted was given.
  if test "${enable_restricted+set}" = set; then
    enableval="$enable_restricted"
    opt_restricted=$enableval
! fi;
  # Check whether --enable-select or --disable-select was given.
  if test "${enable_select+set}" = set; then
    enableval="$enable_select"
    opt_select=$enableval
! fi;
  # Check whether --enable-usg-echo-default or --disable-usg-echo-default was given.
  if test "${enable_usg_echo_default+set}" = set; then
    enableval="$enable_usg_echo_default"
    opt_xpg_echo=$enableval
! fi;
  # Check whether --enable-xpg-echo-default or --disable-xpg-echo-default was given.
  if test "${enable_xpg_echo_default+set}" = set; then
    enableval="$enable_xpg_echo_default"
    opt_xpg_echo=$enableval
! fi;
  
  # Check whether --enable-profiling or --disable-profiling was given.
***************
*** 1052,1068 ****
    enableval="$enable_profiling"
    opt_profiling=$enableval
! fi
! 
  # Check whether --enable-static-link or --disable-static-link was given.
  if test "${enable_static_link+set}" = set; then
    enableval="$enable_static_link"
    opt_static_link=$enableval
! fi
! 
! 
! 
  
  if test $opt_alias = yes; then
! cat >> confdefs.h <<\EOF
  #define ALIAS 1
  EOF
--- 1378,1390 ----
    enableval="$enable_profiling"
    opt_profiling=$enableval
! fi;
  # Check whether --enable-static-link or --disable-static-link was given.
  if test "${enable_static_link+set}" = set; then
    enableval="$enable_static_link"
    opt_static_link=$enableval
! fi;
  
  if test $opt_alias = yes; then
! cat >>confdefs.h <<\EOF
  #define ALIAS 1
  EOF
***************
*** 1070,1074 ****
  fi
  if test $opt_dirstack = yes; then
! cat >> confdefs.h <<\EOF
  #define PUSHD_AND_POPD 1
  EOF
--- 1392,1396 ----
  fi
  if test $opt_dirstack = yes; then
! cat >>confdefs.h <<\EOF
  #define PUSHD_AND_POPD 1
  EOF
***************
*** 1076,1080 ****
  fi
  if test $opt_restricted = yes; then
! cat >> confdefs.h <<\EOF
  #define RESTRICTED_SHELL 1
  EOF
--- 1398,1402 ----
  fi
  if test $opt_restricted = yes; then
! cat >>confdefs.h <<\EOF
  #define RESTRICTED_SHELL 1
  EOF
***************
*** 1082,1086 ****
  fi
  if test $opt_process_subst = yes; then
! cat >> confdefs.h <<\EOF
  #define PROCESS_SUBSTITUTION 1
  EOF
--- 1404,1408 ----
  fi
  if test $opt_process_subst = yes; then
! cat >>confdefs.h <<\EOF
  #define PROCESS_SUBSTITUTION 1
  EOF
***************
*** 1088,1092 ****
  fi
  if test $opt_prompt_decoding = yes; then
! cat >> confdefs.h <<\EOF
  #define PROMPT_STRING_DECODE 1
  EOF
--- 1410,1414 ----
  fi
  if test $opt_prompt_decoding = yes; then
! cat >>confdefs.h <<\EOF
  #define PROMPT_STRING_DECODE 1
  EOF
***************
*** 1094,1098 ****
  fi
  if test $opt_select = yes; then
! cat >> confdefs.h <<\EOF
  #define SELECT_COMMAND 1
  EOF
--- 1416,1420 ----
  fi
  if test $opt_select = yes; then
! cat >>confdefs.h <<\EOF
  #define SELECT_COMMAND 1
  EOF
***************
*** 1100,1104 ****
  fi
  if test $opt_help = yes; then
! cat >> confdefs.h <<\EOF
  #define HELP_BUILTIN 1
  EOF
--- 1422,1426 ----
  fi
  if test $opt_help = yes; then
! cat >>confdefs.h <<\EOF
  #define HELP_BUILTIN 1
  EOF
***************
*** 1106,1110 ****
  fi
  if test $opt_array_variables = yes; then
! cat >> confdefs.h <<\EOF
  #define ARRAY_VARS 1
  EOF
--- 1428,1432 ----
  fi
  if test $opt_array_variables = yes; then
! cat >>confdefs.h <<\EOF
  #define ARRAY_VARS 1
  EOF
***************
*** 1112,1116 ****
  fi
  if test $opt_dparen_arith = yes; then
! cat >> confdefs.h <<\EOF
  #define DPAREN_ARITHMETIC 1
  EOF
--- 1434,1438 ----
  fi
  if test $opt_dparen_arith = yes; then
! cat >>confdefs.h <<\EOF
  #define DPAREN_ARITHMETIC 1
  EOF
***************
*** 1118,1122 ****
  fi
  if test $opt_brace_expansion = yes; then
! cat >> confdefs.h <<\EOF
  #define BRACE_EXPANSION 1
  EOF
--- 1440,1444 ----
  fi
  if test $opt_brace_expansion = yes; then
! cat >>confdefs.h <<\EOF
  #define BRACE_EXPANSION 1
  EOF
***************
*** 1124,1128 ****
  fi
  if test $opt_disabled_builtins = yes; then
! cat >> confdefs.h <<\EOF
  #define DISABLED_BUILTINS 1
  EOF
--- 1446,1450 ----
  fi
  if test $opt_disabled_builtins = yes; then
! cat >>confdefs.h <<\EOF
  #define DISABLED_BUILTINS 1
  EOF
***************
*** 1130,1134 ****
  fi
  if test $opt_command_timing = yes; then
! cat >> confdefs.h <<\EOF
  #define COMMAND_TIMING 1
  EOF
--- 1452,1456 ----
  fi
  if test $opt_command_timing = yes; then
! cat >>confdefs.h <<\EOF
  #define COMMAND_TIMING 1
  EOF
***************
*** 1136,1140 ****
  fi
  if test $opt_xpg_echo = yes ; then
! cat >> confdefs.h <<\EOF
  #define DEFAULT_ECHO_TO_XPG 1
  EOF
--- 1458,1462 ----
  fi
  if test $opt_xpg_echo = yes ; then
! cat >>confdefs.h <<\EOF
  #define DEFAULT_ECHO_TO_XPG 1
  EOF
***************
*** 1142,1146 ****
  fi
  if test $opt_extended_glob = yes ; then
! cat >> confdefs.h <<\EOF
  #define EXTENDED_GLOB 1
  EOF
--- 1464,1468 ----
  fi
  if test $opt_extended_glob = yes ; then
! cat >>confdefs.h <<\EOF
  #define EXTENDED_GLOB 1
  EOF
***************
*** 1148,1152 ****
  fi
  if test $opt_cond_command = yes ; then
! cat >> confdefs.h <<\EOF
  #define COND_COMMAND 1
  EOF
--- 1470,1474 ----
  fi
  if test $opt_cond_command = yes ; then
! cat >>confdefs.h <<\EOF
  #define COND_COMMAND 1
  EOF
***************
*** 1154,1158 ****
  fi
  if test $opt_arith_for_command = yes; then
! cat >> confdefs.h <<\EOF
  #define ARITH_FOR_COMMAND 1
  EOF
--- 1476,1480 ----
  fi
  if test $opt_arith_for_command = yes; then
! cat >>confdefs.h <<\EOF
  #define ARITH_FOR_COMMAND 1
  EOF
***************
*** 1160,1164 ****
  fi
  if test $opt_net_redirs = yes; then
! cat >> confdefs.h <<\EOF
  #define NETWORK_REDIRECTIONS 1
  EOF
--- 1482,1486 ----
  fi
  if test $opt_net_redirs = yes; then
! cat >>confdefs.h <<\EOF
  #define NETWORK_REDIRECTIONS 1
  EOF
***************
*** 1166,1170 ****
  fi
  if test $opt_progcomp = yes; then
! cat >> confdefs.h <<\EOF
  #define PROGRAMMABLE_COMPLETION 1
  EOF
--- 1488,1492 ----
  fi
  if test $opt_progcomp = yes; then
! cat >>confdefs.h <<\EOF
  #define PROGRAMMABLE_COMPLETION 1
  EOF
***************
*** 1178,1258 ****
  fi
  
  
  
  
  
  
  
! 
! BASHVERS=2.05
! BASHPATCH=0
! 
! echo "Beginning configuration for bash-$BASHVERS for ${host_cpu}-${host_vendor}-${host_os}"
! 
! # Extract the first word of "gcc", so it can be a program name with args.
! set dummy gcc; ac_word=$2
! echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
! echo "configure:1196: checking for $ac_word" >&5
! if eval "test \"`echo '$''{'ac_cv_prog_CC'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
    if test -n "$CC"; then
    ac_cv_prog_CC="$CC" # Let the user override the test.
  else
!   IFS="${IFS= 	}"; ac_save_ifs="$IFS"; IFS=":"
!   ac_dummy="$PATH"
!   for ac_dir in $ac_dummy; do
!     test -z "$ac_dir" && ac_dir=.
!     if test -f $ac_dir/$ac_word; then
!       ac_cv_prog_CC="gcc"
!       break
!     fi
!   done
!   IFS="$ac_save_ifs"
  fi
  fi
! CC="$ac_cv_prog_CC"
  if test -n "$CC"; then
!   echo "$ac_t""$CC" 1>&6
  else
!   echo "$ac_t""no" 1>&6
  fi
  
  if test -z "$CC"; then
    # Extract the first word of "cc", so it can be a program name with args.
  set dummy cc; ac_word=$2
! echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
! echo "configure:1226: checking for $ac_word" >&5
! if eval "test \"`echo '$''{'ac_cv_prog_CC'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
    if test -n "$CC"; then
    ac_cv_prog_CC="$CC" # Let the user override the test.
  else
-   IFS="${IFS= 	}"; ac_save_ifs="$IFS"; IFS=":"
    ac_prog_rejected=no
!   ac_dummy="$PATH"
!   for ac_dir in $ac_dummy; do
!     test -z "$ac_dir" && ac_dir=.
!     if test -f $ac_dir/$ac_word; then
!       if test "$ac_dir/$ac_word" = "/usr/ucb/cc"; then
!         ac_prog_rejected=yes
! 	continue
!       fi
!       ac_cv_prog_CC="cc"
!       break
!     fi
!   done
!   IFS="$ac_save_ifs"
  if test $ac_prog_rejected = yes; then
    # We found a bogon in the path, so make sure we never use it.
    set dummy $ac_cv_prog_CC
    shift
!   if test $# -gt 0; then
      # We chose a different compiler from the bogus one.
      # However, it has the same basename, so the bogon will be chosen
      # first if we set CC to just the basename; use the full file name.
      shift
!     set dummy "$ac_dir/$ac_word" "$@"
      shift
      ac_cv_prog_CC="$@"
--- 1500,1697 ----
  fi
  
+ echo ""
+ echo "Beginning configuration for bash-$BASHVERS for ${host_cpu}-${host_vendor}-${host_os}"
+ echo ""
  
+ ac_ext=c
+ ac_cpp='$CPP $CPPFLAGS'
+ ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ ac_compiler_gnu=$ac_cv_c_compiler_gnu
+ if test -n "$ac_tool_prefix"; then
+   # Extract the first word of "${ac_tool_prefix}gcc", so it can be a program name with args.
+ set dummy ${ac_tool_prefix}gcc; ac_word=$2
+ echo "$as_me:1514: checking for $ac_word" >&5
+ echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+ if test "${ac_cv_prog_CC+set}" = set; then
+   echo $ECHO_N "(cached) $ECHO_C" >&6
+ else
+   if test -n "$CC"; then
+   ac_cv_prog_CC="$CC" # Let the user override the test.
+ else
+   ac_save_IFS=$IFS; IFS=$ac_path_separator
+ ac_dummy="$PATH"
+ for ac_dir in $ac_dummy; do
+   IFS=$ac_save_IFS
+   test -z "$ac_dir" && ac_dir=.
+   $as_executable_p "$ac_dir/$ac_word" || continue
+ ac_cv_prog_CC="${ac_tool_prefix}gcc"
+ echo "$as_me:1529: found $ac_dir/$ac_word" >&5
+ break
+ done
  
+ fi
+ fi
+ CC=$ac_cv_prog_CC
+ if test -n "$CC"; then
+   echo "$as_me:1537: result: $CC" >&5
+ echo "${ECHO_T}$CC" >&6
+ else
+   echo "$as_me:1540: result: no" >&5
+ echo "${ECHO_T}no" >&6
+ fi
  
+ fi
+ if test -z "$ac_cv_prog_CC"; then
+   ac_ct_CC=$CC
+   # Extract the first word of "gcc", so it can be a program name with args.
+ set dummy gcc; ac_word=$2
+ echo "$as_me:1549: checking for $ac_word" >&5
+ echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+ if test "${ac_cv_prog_ac_ct_CC+set}" = set; then
+   echo $ECHO_N "(cached) $ECHO_C" >&6
+ else
+   if test -n "$ac_ct_CC"; then
+   ac_cv_prog_ac_ct_CC="$ac_ct_CC" # Let the user override the test.
+ else
+   ac_save_IFS=$IFS; IFS=$ac_path_separator
+ ac_dummy="$PATH"
+ for ac_dir in $ac_dummy; do
+   IFS=$ac_save_IFS
+   test -z "$ac_dir" && ac_dir=.
+   $as_executable_p "$ac_dir/$ac_word" || continue
+ ac_cv_prog_ac_ct_CC="gcc"
+ echo "$as_me:1564: found $ac_dir/$ac_word" >&5
+ break
+ done
  
+ fi
+ fi
+ ac_ct_CC=$ac_cv_prog_ac_ct_CC
+ if test -n "$ac_ct_CC"; then
+   echo "$as_me:1572: result: $ac_ct_CC" >&5
+ echo "${ECHO_T}$ac_ct_CC" >&6
+ else
+   echo "$as_me:1575: result: no" >&5
+ echo "${ECHO_T}no" >&6
+ fi
  
+   CC=$ac_ct_CC
+ else
+   CC="$ac_cv_prog_CC"
+ fi
  
! if test -z "$CC"; then
!   if test -n "$ac_tool_prefix"; then
!   # Extract the first word of "${ac_tool_prefix}cc", so it can be a program name with args.
! set dummy ${ac_tool_prefix}cc; ac_word=$2
! echo "$as_me:1588: checking for $ac_word" >&5
! echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
! if test "${ac_cv_prog_CC+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
    if test -n "$CC"; then
    ac_cv_prog_CC="$CC" # Let the user override the test.
  else
!   ac_save_IFS=$IFS; IFS=$ac_path_separator
! ac_dummy="$PATH"
! for ac_dir in $ac_dummy; do
!   IFS=$ac_save_IFS
!   test -z "$ac_dir" && ac_dir=.
!   $as_executable_p "$ac_dir/$ac_word" || continue
! ac_cv_prog_CC="${ac_tool_prefix}cc"
! echo "$as_me:1603: found $ac_dir/$ac_word" >&5
! break
! done
! 
  fi
  fi
! CC=$ac_cv_prog_CC
  if test -n "$CC"; then
!   echo "$as_me:1611: result: $CC" >&5
! echo "${ECHO_T}$CC" >&6
  else
!   echo "$as_me:1614: result: no" >&5
! echo "${ECHO_T}no" >&6
  fi
  
+ fi
+ if test -z "$ac_cv_prog_CC"; then
+   ac_ct_CC=$CC
+   # Extract the first word of "cc", so it can be a program name with args.
+ set dummy cc; ac_word=$2
+ echo "$as_me:1623: checking for $ac_word" >&5
+ echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+ if test "${ac_cv_prog_ac_ct_CC+set}" = set; then
+   echo $ECHO_N "(cached) $ECHO_C" >&6
+ else
+   if test -n "$ac_ct_CC"; then
+   ac_cv_prog_ac_ct_CC="$ac_ct_CC" # Let the user override the test.
+ else
+   ac_save_IFS=$IFS; IFS=$ac_path_separator
+ ac_dummy="$PATH"
+ for ac_dir in $ac_dummy; do
+   IFS=$ac_save_IFS
+   test -z "$ac_dir" && ac_dir=.
+   $as_executable_p "$ac_dir/$ac_word" || continue
+ ac_cv_prog_ac_ct_CC="cc"
+ echo "$as_me:1638: found $ac_dir/$ac_word" >&5
+ break
+ done
+ 
+ fi
+ fi
+ ac_ct_CC=$ac_cv_prog_ac_ct_CC
+ if test -n "$ac_ct_CC"; then
+   echo "$as_me:1646: result: $ac_ct_CC" >&5
+ echo "${ECHO_T}$ac_ct_CC" >&6
+ else
+   echo "$as_me:1649: result: no" >&5
+ echo "${ECHO_T}no" >&6
+ fi
+ 
+   CC=$ac_ct_CC
+ else
+   CC="$ac_cv_prog_CC"
+ fi
+ 
+ fi
  if test -z "$CC"; then
    # Extract the first word of "cc", so it can be a program name with args.
  set dummy cc; ac_word=$2
! echo "$as_me:1662: checking for $ac_word" >&5
! echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
! if test "${ac_cv_prog_CC+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
    if test -n "$CC"; then
    ac_cv_prog_CC="$CC" # Let the user override the test.
  else
    ac_prog_rejected=no
!   ac_save_IFS=$IFS; IFS=$ac_path_separator
! ac_dummy="$PATH"
! for ac_dir in $ac_dummy; do
!   IFS=$ac_save_IFS
!   test -z "$ac_dir" && ac_dir=.
!   $as_executable_p "$ac_dir/$ac_word" || continue
! if test "$ac_dir/$ac_word" = "/usr/ucb/cc"; then
!   ac_prog_rejected=yes
!   continue
! fi
! ac_cv_prog_CC="cc"
! echo "$as_me:1682: found $ac_dir/$ac_word" >&5
! break
! done
! 
  if test $ac_prog_rejected = yes; then
    # We found a bogon in the path, so make sure we never use it.
    set dummy $ac_cv_prog_CC
    shift
!   if test $# != 0; then
      # We chose a different compiler from the bogus one.
      # However, it has the same basename, so the bogon will be chosen
      # first if we set CC to just the basename; use the full file name.
      shift
!     set dummy "$ac_dir/$ac_word" ${1+"$@"}
      shift
      ac_cv_prog_CC="$@"
***************
*** 1261,1403 ****
  fi
  fi
! CC="$ac_cv_prog_CC"
  if test -n "$CC"; then
!   echo "$ac_t""$CC" 1>&6
  else
!   echo "$ac_t""no" 1>&6
  fi
  
!   if test -z "$CC"; then
!     case "`uname -s`" in
!     *win32* | *WIN32*)
!       # Extract the first word of "cl", so it can be a program name with args.
! set dummy cl; ac_word=$2
! echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
! echo "configure:1277: checking for $ac_word" >&5
! if eval "test \"`echo '$''{'ac_cv_prog_CC'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
    if test -n "$CC"; then
    ac_cv_prog_CC="$CC" # Let the user override the test.
  else
!   IFS="${IFS= 	}"; ac_save_ifs="$IFS"; IFS=":"
!   ac_dummy="$PATH"
!   for ac_dir in $ac_dummy; do
!     test -z "$ac_dir" && ac_dir=.
!     if test -f $ac_dir/$ac_word; then
!       ac_cv_prog_CC="cl"
!       break
!     fi
!   done
!   IFS="$ac_save_ifs"
  fi
  fi
! CC="$ac_cv_prog_CC"
  if test -n "$CC"; then
!   echo "$ac_t""$CC" 1>&6
  else
!   echo "$ac_t""no" 1>&6
! fi
!  ;;
!     esac
!   fi
!   test -z "$CC" && { echo "configure: error: no acceptable cc found in \$PATH" 1>&2; exit 1; }
  fi
  
! echo $ac_n "checking whether the C compiler ($CC $CFLAGS $LDFLAGS) works""... $ac_c" 1>&6
! echo "configure:1309: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) works" >&5
! 
! ac_ext=c
! # CFLAGS is not in ac_cpp because -g, -O, etc. are not valid cpp options.
! ac_cpp='$CPP $CPPFLAGS'
! ac_compile='${CC-cc} -c $CFLAGS $CPPFLAGS conftest.$ac_ext 1>&5'
! ac_link='${CC-cc} -o conftest${ac_exeext} $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS 1>&5'
! cross_compiling=$ac_cv_prog_cc_cross
! 
! cat > conftest.$ac_ext << EOF
! 
! #line 1320 "configure"
! #include "confdefs.h"
  
- main(){return(0);}
- EOF
- if { (eval echo configure:1325: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
-   ac_cv_prog_cc_works=yes
-   # If we can't run a trivial program, we are probably using a cross compiler.
-   if (./conftest; exit) 2>/dev/null; then
-     ac_cv_prog_cc_cross=no
-   else
-     ac_cv_prog_cc_cross=yes
-   fi
- else
-   echo "configure: failed program was:" >&5
-   cat conftest.$ac_ext >&5
-   ac_cv_prog_cc_works=no
  fi
- rm -fr conftest*
- ac_ext=c
- # CFLAGS is not in ac_cpp because -g, -O, etc. are not valid cpp options.
- ac_cpp='$CPP $CPPFLAGS'
- ac_compile='${CC-cc} -c $CFLAGS $CPPFLAGS conftest.$ac_ext 1>&5'
- ac_link='${CC-cc} -o conftest${ac_exeext} $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS 1>&5'
- cross_compiling=$ac_cv_prog_cc_cross
- 
- echo "$ac_t""$ac_cv_prog_cc_works" 1>&6
- if test $ac_cv_prog_cc_works = no; then
-   { echo "configure: error: installation or configuration problem: C compiler cannot create executables." 1>&2; exit 1; }
- fi
- echo $ac_n "checking whether the C compiler ($CC $CFLAGS $LDFLAGS) is a cross-compiler""... $ac_c" 1>&6
- echo "configure:1351: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) is a cross-compiler" >&5
- echo "$ac_t""$ac_cv_prog_cc_cross" 1>&6
- cross_compiling=$ac_cv_prog_cc_cross
- 
- echo $ac_n "checking whether we are using GNU C""... $ac_c" 1>&6
- echo "configure:1356: checking whether we are using GNU C" >&5
- if eval "test \"`echo '$''{'ac_cv_prog_gcc'+set}'`\" = set"; then
-   echo $ac_n "(cached) $ac_c" 1>&6
- else
-   cat > conftest.c <<EOF
- #ifdef __GNUC__
-   yes;
- #endif
- EOF
- if { ac_try='${CC-cc} -E conftest.c'; { (eval echo configure:1365: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }; } | egrep yes >/dev/null 2>&1; then
-   ac_cv_prog_gcc=yes
- else
-   ac_cv_prog_gcc=no
  fi
  fi
  
! echo "$ac_t""$ac_cv_prog_gcc" 1>&6
  
! if test $ac_cv_prog_gcc = yes; then
!   GCC=yes
! else
!   GCC=
  fi
  
- ac_test_CFLAGS="${CFLAGS+set}"
- ac_save_CFLAGS="$CFLAGS"
- CFLAGS=
- echo $ac_n "checking whether ${CC-cc} accepts -g""... $ac_c" 1>&6
- echo "configure:1384: checking whether ${CC-cc} accepts -g" >&5
- if eval "test \"`echo '$''{'ac_cv_prog_cc_g'+set}'`\" = set"; then
-   echo $ac_n "(cached) $ac_c" 1>&6
- else
-   echo 'void f(){}' > conftest.c
- if test -z "`${CC-cc} -g -c conftest.c 2>&1`"; then
-   ac_cv_prog_cc_g=yes
- else
-   ac_cv_prog_cc_g=no
  fi
- rm -f conftest*
  
! fi
  
! echo "$ac_t""$ac_cv_prog_cc_g" 1>&6
! if test "$ac_test_CFLAGS" = set; then
!   CFLAGS="$ac_save_CFLAGS"
! elif test $ac_cv_prog_cc_g = yes; then
!   if test "$GCC" = yes; then
      CFLAGS="-g -O2"
    else
--- 1700,2081 ----
  fi
  fi
! CC=$ac_cv_prog_CC
  if test -n "$CC"; then
!   echo "$as_me:1704: result: $CC" >&5
! echo "${ECHO_T}$CC" >&6
  else
!   echo "$as_me:1707: result: no" >&5
! echo "${ECHO_T}no" >&6
  fi
  
! fi
! if test -z "$CC"; then
!   if test -n "$ac_tool_prefix"; then
!   for ac_prog in cl
!   do
!     # Extract the first word of "$ac_tool_prefix$ac_prog", so it can be a program name with args.
! set dummy $ac_tool_prefix$ac_prog; ac_word=$2
! echo "$as_me:1718: checking for $ac_word" >&5
! echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
! if test "${ac_cv_prog_CC+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
    if test -n "$CC"; then
    ac_cv_prog_CC="$CC" # Let the user override the test.
  else
!   ac_save_IFS=$IFS; IFS=$ac_path_separator
! ac_dummy="$PATH"
! for ac_dir in $ac_dummy; do
!   IFS=$ac_save_IFS
!   test -z "$ac_dir" && ac_dir=.
!   $as_executable_p "$ac_dir/$ac_word" || continue
! ac_cv_prog_CC="$ac_tool_prefix$ac_prog"
! echo "$as_me:1733: found $ac_dir/$ac_word" >&5
! break
! done
! 
  fi
  fi
! CC=$ac_cv_prog_CC
  if test -n "$CC"; then
!   echo "$as_me:1741: result: $CC" >&5
! echo "${ECHO_T}$CC" >&6
  else
!   echo "$as_me:1744: result: no" >&5
! echo "${ECHO_T}no" >&6
  fi
  
!     test -n "$CC" && break
!   done
! fi
! if test -z "$CC"; then
!   ac_ct_CC=$CC
!   for ac_prog in cl
! do
!   # Extract the first word of "$ac_prog", so it can be a program name with args.
! set dummy $ac_prog; ac_word=$2
! echo "$as_me:1757: checking for $ac_word" >&5
! echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
! if test "${ac_cv_prog_ac_ct_CC+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
! else
!   if test -n "$ac_ct_CC"; then
!   ac_cv_prog_ac_ct_CC="$ac_ct_CC" # Let the user override the test.
! else
!   ac_save_IFS=$IFS; IFS=$ac_path_separator
! ac_dummy="$PATH"
! for ac_dir in $ac_dummy; do
!   IFS=$ac_save_IFS
!   test -z "$ac_dir" && ac_dir=.
!   $as_executable_p "$ac_dir/$ac_word" || continue
! ac_cv_prog_ac_ct_CC="$ac_prog"
! echo "$as_me:1772: found $ac_dir/$ac_word" >&5
! break
! done
  
  fi
  fi
+ ac_ct_CC=$ac_cv_prog_ac_ct_CC
+ if test -n "$ac_ct_CC"; then
+   echo "$as_me:1780: result: $ac_ct_CC" >&5
+ echo "${ECHO_T}$ac_ct_CC" >&6
+ else
+   echo "$as_me:1783: result: no" >&5
+ echo "${ECHO_T}no" >&6
  fi
  
!   test -n "$ac_ct_CC" && break
! done
  
!   CC=$ac_ct_CC
  fi
  
  fi
  
! test -z "$CC" && { { echo "$as_me:1795: error: no acceptable cc found in \$PATH" >&5
! echo "$as_me: error: no acceptable cc found in \$PATH" >&2;}
!    { (exit 1); exit 1; }; }
! 
! # Provide some information about the compiler.
! echo "$as_me:1800:" \
!      "checking for C compiler version" >&5
! ac_compiler=`set X $ac_compile; echo $2`
! { (eval echo "$as_me:1803: \"$ac_compiler --version </dev/null >&5\"") >&5
!   (eval $ac_compiler --version </dev/null >&5) 2>&5
!   ac_status=$?
!   echo "$as_me:1806: \$? = $ac_status" >&5
!   (exit $ac_status); }
! { (eval echo "$as_me:1808: \"$ac_compiler -v </dev/null >&5\"") >&5
!   (eval $ac_compiler -v </dev/null >&5) 2>&5
!   ac_status=$?
!   echo "$as_me:1811: \$? = $ac_status" >&5
!   (exit $ac_status); }
! { (eval echo "$as_me:1813: \"$ac_compiler -V </dev/null >&5\"") >&5
!   (eval $ac_compiler -V </dev/null >&5) 2>&5
!   ac_status=$?
!   echo "$as_me:1816: \$? = $ac_status" >&5
!   (exit $ac_status); }
  
! cat >conftest.$ac_ext <<_ACEOF
! #line 1820 "configure"
! #include "confdefs.h"
! 
! int
! main ()
! {
! 
!   ;
!   return 0;
! }
! _ACEOF
! ac_clean_files_save=$ac_clean_files
! ac_clean_files="$ac_clean_files a.out a.exe"
! # Try to create an executable without -o first, disregard a.out.
! # It will help us diagnose broken compilers, and finding out an intuition
! # of exeext.
! echo "$as_me:1836: checking for C compiler default output" >&5
! echo $ECHO_N "checking for C compiler default output... $ECHO_C" >&6
! ac_link_default=`echo "$ac_link" | sed 's/ -o *conftest[^ ]*//'`
! if { (eval echo "$as_me:1839: \"$ac_link_default\"") >&5
!   (eval $ac_link_default) 2>&5
!   ac_status=$?
!   echo "$as_me:1842: \$? = $ac_status" >&5
!   (exit $ac_status); }; then
!   # Find the output, starting from the most likely.  This scheme is
! # not robust to junk in `.', hence go to wildcards (a.*) only as a last
! # resort.
! for ac_file in `ls a.exe conftest.exe 2>/dev/null;
!                 ls a.out conftest 2>/dev/null;
!                 ls a.* conftest.* 2>/dev/null`; do
!   case $ac_file in
!     *.$ac_ext | *.o | *.obj | *.xcoff | *.tds | *.d | *.pdb ) ;;
!     a.out ) # We found the default executable, but exeext='' is most
!             # certainly right.
!             break;;
!     *.* ) ac_cv_exeext=`expr "$ac_file" : '[^.]*\(\..*\)'`
!           # FIXME: I believe we export ac_cv_exeext for Libtool --akim.
!           export ac_cv_exeext
!           break;;
!     * ) break;;
!   esac
! done
! else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! { { echo "$as_me:1865: error: C compiler cannot create executables" >&5
! echo "$as_me: error: C compiler cannot create executables" >&2;}
!    { (exit 77); exit 77; }; }
! fi
! 
! ac_exeext=$ac_cv_exeext
! echo "$as_me:1871: result: $ac_file" >&5
! echo "${ECHO_T}$ac_file" >&6
! 
! # Check the compiler produces executables we can run.  If not, either
! # the compiler is broken, or we cross compile.
! echo "$as_me:1876: checking whether the C compiler works" >&5
! echo $ECHO_N "checking whether the C compiler works... $ECHO_C" >&6
! # FIXME: These cross compiler hacks should be removed for Autoconf 3.0
! # If not cross compiling, check that we can run a simple program.
! if test "$cross_compiling" != yes; then
!   if { ac_try='./$ac_file'
!   { (eval echo "$as_me:1882: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:1885: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!     cross_compiling=no
!   else
!     if test "$cross_compiling" = maybe; then
! 	cross_compiling=yes
!     else
! 	{ { echo "$as_me:1892: error: cannot run C compiled programs.
! If you meant to cross compile, use \`--host'." >&5
! echo "$as_me: error: cannot run C compiled programs.
! If you meant to cross compile, use \`--host'." >&2;}
!    { (exit 1); exit 1; }; }
!     fi
!   fi
! fi
! echo "$as_me:1900: result: yes" >&5
! echo "${ECHO_T}yes" >&6
! 
! rm -f a.out a.exe conftest$ac_cv_exeext
! ac_clean_files=$ac_clean_files_save
! # Check the compiler produces executables we can run.  If not, either
! # the compiler is broken, or we cross compile.
! echo "$as_me:1907: checking whether we are cross compiling" >&5
! echo $ECHO_N "checking whether we are cross compiling... $ECHO_C" >&6
! echo "$as_me:1909: result: $cross_compiling" >&5
! echo "${ECHO_T}$cross_compiling" >&6
! 
! echo "$as_me:1912: checking for executable suffix" >&5
! echo $ECHO_N "checking for executable suffix... $ECHO_C" >&6
! if { (eval echo "$as_me:1914: \"$ac_link\"") >&5
!   (eval $ac_link) 2>&5
!   ac_status=$?
!   echo "$as_me:1917: \$? = $ac_status" >&5
!   (exit $ac_status); }; then
!   # If both `conftest.exe' and `conftest' are `present' (well, observable)
! # catch `conftest.exe'.  For instance with Cygwin, `ls conftest' will
! # work properly (i.e., refer to `conftest.exe'), while it won't with
! # `rm'.
! for ac_file in `(ls conftest.exe; ls conftest; ls conftest.*) 2>/dev/null`; do
!   case $ac_file in
!     *.$ac_ext | *.o | *.obj | *.xcoff | *.tds | *.d | *.pdb ) ;;
!     *.* ) ac_cv_exeext=`expr "$ac_file" : '[^.]*\(\..*\)'`
!           export ac_cv_exeext
!           break;;
!     * ) break;;
!   esac
! done
! else
!   { { echo "$as_me:1933: error: cannot compute EXEEXT: cannot compile and link" >&5
! echo "$as_me: error: cannot compute EXEEXT: cannot compile and link" >&2;}
!    { (exit 1); exit 1; }; }
! fi
! 
! rm -f conftest$ac_cv_exeext
! echo "$as_me:1939: result: $ac_cv_exeext" >&5
! echo "${ECHO_T}$ac_cv_exeext" >&6
! 
! rm -f conftest.$ac_ext
! EXEEXT=$ac_cv_exeext
! ac_exeext=$EXEEXT
! echo "$as_me:1945: checking for object suffix" >&5
! echo $ECHO_N "checking for object suffix... $ECHO_C" >&6
! if test "${ac_cv_objext+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
! else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 1951 "configure"
! #include "confdefs.h"
! 
! int
! main ()
! {
! 
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.o conftest.obj
! if { (eval echo "$as_me:1963: \"$ac_compile\"") >&5
!   (eval $ac_compile) 2>&5
!   ac_status=$?
!   echo "$as_me:1966: \$? = $ac_status" >&5
!   (exit $ac_status); }; then
!   for ac_file in `(ls conftest.o conftest.obj; ls conftest.*) 2>/dev/null`; do
!   case $ac_file in
!     *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb ) ;;
!     *) ac_cv_objext=`expr "$ac_file" : '.*\.\(.*\)'`
!        break;;
!   esac
! done
! else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! { { echo "$as_me:1978: error: cannot compute OBJEXT: cannot compile" >&5
! echo "$as_me: error: cannot compute OBJEXT: cannot compile" >&2;}
!    { (exit 1); exit 1; }; }
! fi
! 
! rm -f conftest.$ac_cv_objext conftest.$ac_ext
! fi
! echo "$as_me:1985: result: $ac_cv_objext" >&5
! echo "${ECHO_T}$ac_cv_objext" >&6
! OBJEXT=$ac_cv_objext
! ac_objext=$OBJEXT
! echo "$as_me:1989: checking whether we are using the GNU C compiler" >&5
! echo $ECHO_N "checking whether we are using the GNU C compiler... $ECHO_C" >&6
! if test "${ac_cv_c_compiler_gnu+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
! else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 1995 "configure"
! #include "confdefs.h"
! 
! int
! main ()
! {
! #ifndef __GNUC__
!        choke me
! #endif
! 
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext
! if { (eval echo "$as_me:2010: \"$ac_compile\"") >&5
!   (eval $ac_compile) 2>&5
!   ac_status=$?
!   echo "$as_me:2013: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest.$ac_objext'
!   { (eval echo "$as_me:2016: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:2019: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   ac_compiler_gnu=yes
! else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! ac_compiler_gnu=no
! fi
! rm -f conftest.$ac_objext conftest.$ac_ext
! ac_cv_c_compiler_gnu=$ac_compiler_gnu
! 
! fi
! echo "$as_me:2031: result: $ac_cv_c_compiler_gnu" >&5
! echo "${ECHO_T}$ac_cv_c_compiler_gnu" >&6
! GCC=`test $ac_compiler_gnu = yes && echo yes`
! ac_test_CFLAGS=${CFLAGS+set}
! ac_save_CFLAGS=$CFLAGS
! CFLAGS="-g"
! echo "$as_me:2037: checking whether $CC accepts -g" >&5
! echo $ECHO_N "checking whether $CC accepts -g... $ECHO_C" >&6
! if test "${ac_cv_prog_cc_g+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
! else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 2043 "configure"
! #include "confdefs.h"
! 
! int
! main ()
! {
! 
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext
! if { (eval echo "$as_me:2055: \"$ac_compile\"") >&5
!   (eval $ac_compile) 2>&5
!   ac_status=$?
!   echo "$as_me:2058: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest.$ac_objext'
!   { (eval echo "$as_me:2061: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:2064: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   ac_cv_prog_cc_g=yes
! else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! ac_cv_prog_cc_g=no
! fi
! rm -f conftest.$ac_objext conftest.$ac_ext
! fi
! echo "$as_me:2074: result: $ac_cv_prog_cc_g" >&5
! echo "${ECHO_T}$ac_cv_prog_cc_g" >&6
! if test "$ac_test_CFLAGS" = set; then
!   CFLAGS=$ac_save_CFLAGS
! elif test $ac_cv_prog_cc_g = yes; then
!   if test "$GCC" = yes; then
      CFLAGS="-g -O2"
    else
***************
*** 1411,1456 ****
    fi
  fi
! 
! echo $ac_n "checking whether large file support needs explicit enabling""... $ac_c" 1>&6
! echo "configure:1416: checking whether large file support needs explicit enabling" >&5
! ac_getconfs=''
! ac_result=yes
! ac_set=''
! ac_shellvars='CPPFLAGS LDFLAGS LIBS'
! for ac_shellvar in $ac_shellvars; do
!   case $ac_shellvar in
!   CPPFLAGS) ac_lfsvar=LFS_CFLAGS ac_lfs64var=LFS64_CFLAGS ;;
!   *) ac_lfsvar=LFS_$ac_shellvar ac_lfs64var=LFS64_$ac_shellvar ;;
!   esac
!   eval test '"${'$ac_shellvar'+set}"' = set && ac_set=$ac_shellvar
!   (getconf $ac_lfsvar) >/dev/null 2>&1 || { ac_result=no; break; }
!   ac_getconf=`getconf $ac_lfsvar`
!   ac_getconf64=`getconf $ac_lfs64var`
!   ac_getconfs=$ac_getconfs$ac_getconf\ $ac_getconf64
!   eval ac_test_$ac_shellvar="\$ac_getconf\ \$ac_getconf64"
  done
! case "$ac_result$ac_getconfs" in
! yes) ac_result=no ;;
! esac
! case "$ac_result$ac_set" in
! yes?*) ac_result="yes, but $ac_set is already set, so use its settings"
! esac
! echo "$ac_t""$ac_result" 1>&6
! case $ac_result in
! yes)
!   for ac_shellvar in $ac_shellvars; do
!     eval $ac_shellvar=\$ac_test_$ac_shellvar
!   done ;;
! esac
  
  
! echo $ac_n "checking for POSIXized ISC""... $ac_c" 1>&6
! echo "configure:1449: checking for POSIXized ISC" >&5
  if test -d /etc/conf/kconfig.d &&
!   grep _POSIX_VERSION /usr/include/sys/unistd.h >/dev/null 2>&1
  then
!   echo "$ac_t""yes" 1>&6
    ISC=yes # If later tests want to check for ISC.
!   cat >> confdefs.h <<\EOF
  #define _POSIX_SOURCE 1
  EOF
--- 2089,2213 ----
    fi
  fi
! # Some people use a C++ compiler to compile C.  Since we use `exit',
! # in C++ we need to declare it.  In case someone uses the same compiler
! # for both compiling C and C++ we need to have the C++ compiler decide
! # the declaration of exit, since it's the most demanding environment.
! cat >conftest.$ac_ext <<_ACEOF
! #ifndef __cplusplus
!   choke me
! #endif
! _ACEOF
! rm -f conftest.$ac_objext
! if { (eval echo "$as_me:2101: \"$ac_compile\"") >&5
!   (eval $ac_compile) 2>&5
!   ac_status=$?
!   echo "$as_me:2104: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest.$ac_objext'
!   { (eval echo "$as_me:2107: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:2110: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   for ac_declaration in \
!    ''\
!    '#include <stdlib.h>' \
!    'extern "C" void std::exit (int) throw (); using std::exit;' \
!    'extern "C" void std::exit (int); using std::exit;' \
!    'extern "C" void exit (int) throw ();' \
!    'extern "C" void exit (int);' \
!    'void exit (int);'
! do
!   cat >conftest.$ac_ext <<_ACEOF
! #line 2122 "configure"
! #include "confdefs.h"
! #include <stdlib.h>
! $ac_declaration
! int
! main ()
! {
! exit (42);
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext
! if { (eval echo "$as_me:2135: \"$ac_compile\"") >&5
!   (eval $ac_compile) 2>&5
!   ac_status=$?
!   echo "$as_me:2138: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest.$ac_objext'
!   { (eval echo "$as_me:2141: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:2144: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   :
! else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! continue
! fi
! rm -f conftest.$ac_objext conftest.$ac_ext
!   cat >conftest.$ac_ext <<_ACEOF
! #line 2154 "configure"
! #include "confdefs.h"
! $ac_declaration
! int
! main ()
! {
! exit (42);
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext
! if { (eval echo "$as_me:2166: \"$ac_compile\"") >&5
!   (eval $ac_compile) 2>&5
!   ac_status=$?
!   echo "$as_me:2169: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest.$ac_objext'
!   { (eval echo "$as_me:2172: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:2175: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   break
! else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! fi
! rm -f conftest.$ac_objext conftest.$ac_ext
  done
! rm -f conftest*
! if test -n "$ac_declaration"; then
!   echo '#ifdef __cplusplus' >>confdefs.h
!   echo $ac_declaration      >>confdefs.h
!   echo '#endif'             >>confdefs.h
! fi
  
+ else
+   echo "$as_me: failed program was:" >&5
+ cat conftest.$ac_ext >&5
+ fi
+ rm -f conftest.$ac_objext conftest.$ac_ext
+ ac_ext=c
+ ac_cpp='$CPP $CPPFLAGS'
+ ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ ac_compiler_gnu=$ac_cv_c_compiler_gnu
  
! echo "$as_me:2202: checking for POSIXized ISC" >&5
! echo $ECHO_N "checking for POSIXized ISC... $ECHO_C" >&6
  if test -d /etc/conf/kconfig.d &&
!    grep _POSIX_VERSION /usr/include/sys/unistd.h >/dev/null 2>&1
  then
!   echo "$as_me:2207: result: yes" >&5
! echo "${ECHO_T}yes" >&6
    ISC=yes # If later tests want to check for ISC.
! 
! cat >>confdefs.h <<\EOF
  #define _POSIX_SOURCE 1
  EOF
***************
*** 1462,1471 ****
    fi
  else
!   echo "$ac_t""no" 1>&6
    ISC=
  fi
  
! echo $ac_n "checking how to run the C preprocessor""... $ac_c" 1>&6
! echo "configure:1470: checking how to run the C preprocessor" >&5
  # On Suns, sometimes $CPP names a directory.
  if test -n "$CPP" && test -d "$CPP"; then
--- 2219,2234 ----
    fi
  else
!   echo "$as_me:2221: result: no" >&5
! echo "${ECHO_T}no" >&6
    ISC=
  fi
  
! ac_ext=c
! ac_cpp='$CPP $CPPFLAGS'
! ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
! ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
! ac_compiler_gnu=$ac_cv_c_compiler_gnu
! echo "$as_me:2231: checking how to run the C preprocessor" >&5
! echo $ECHO_N "checking how to run the C preprocessor... $ECHO_C" >&6
  # On Suns, sometimes $CPP names a directory.
  if test -n "$CPP" && test -d "$CPP"; then
***************
*** 1473,1593 ****
  fi
  if test -z "$CPP"; then
! if eval "test \"`echo '$''{'ac_cv_prog_CPP'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
!     # This must be in double quotes, not single quotes, because CPP may get
!   # substituted into the Makefile and "${CC-cc}" will confuse make.
!   CPP="${CC-cc} -E"
    # On the NeXT, cc -E runs the code through the compiler's parser,
!   # not just through cpp.
!   cat > conftest.$ac_ext <<EOF
! #line 1485 "configure"
  #include "confdefs.h"
  #include <assert.h>
! Syntax Error
! EOF
! ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
! { (eval echo configure:1491: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
! ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
! if test -z "$ac_err"; then
    :
  else
!   echo "$ac_err" >&5
!   echo "configure: failed program was:" >&5
    cat conftest.$ac_ext >&5
!   rm -rf conftest*
!   CPP="${CC-cc} -E -traditional-cpp"
!   cat > conftest.$ac_ext <<EOF
! #line 1502 "configure"
! #include "confdefs.h"
! #include <assert.h>
! Syntax Error
! EOF
! ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
! { (eval echo configure:1508: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
! ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
! if test -z "$ac_err"; then
!   :
  else
!   echo "$ac_err" >&5
!   echo "configure: failed program was:" >&5
    cat conftest.$ac_ext >&5
!   rm -rf conftest*
!   CPP="${CC-cc} -nologo -E"
!   cat > conftest.$ac_ext <<EOF
! #line 1519 "configure"
  #include "confdefs.h"
  #include <assert.h>
! Syntax Error
! EOF
! ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
! { (eval echo configure:1525: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
! ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
! if test -z "$ac_err"; then
    :
  else
!   echo "$ac_err" >&5
!   echo "configure: failed program was:" >&5
    cat conftest.$ac_ext >&5
!   rm -rf conftest*
!   CPP=/lib/cpp
! fi
! rm -f conftest*
  fi
! rm -f conftest*
  fi
! rm -f conftest*
!   ac_cv_prog_CPP="$CPP"
  fi
!   CPP="$ac_cv_prog_CPP"
  else
!   ac_cv_prog_CPP="$CPP"
  fi
- echo "$ac_t""$CPP" 1>&6
  
! ac_safe=`echo "minix/config.h" | sed 'y%./+-%__p_%'`
! echo $ac_n "checking for minix/config.h""... $ac_c" 1>&6
! echo "configure:1551: checking for minix/config.h" >&5
! if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
!   cat > conftest.$ac_ext <<EOF
! #line 1556 "configure"
  #include "confdefs.h"
  #include <minix/config.h>
! EOF
! ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
! { (eval echo configure:1561: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
! ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
! if test -z "$ac_err"; then
!   rm -rf conftest*
!   eval "ac_cv_header_$ac_safe=yes"
  else
!   echo "$ac_err" >&5
!   echo "configure: failed program was:" >&5
    cat conftest.$ac_ext >&5
!   rm -rf conftest*
!   eval "ac_cv_header_$ac_safe=no"
  fi
! rm -f conftest*
  fi
! if eval "test \"`echo '$ac_cv_header_'$ac_safe`\" = yes"; then
!   echo "$ac_t""yes" 1>&6
    MINIX=yes
  else
!   echo "$ac_t""no" 1>&6
! MINIX=
  fi
  
  if test "$MINIX" = yes; then
!   cat >> confdefs.h <<\EOF
  #define _POSIX_SOURCE 1
  EOF
  
!   cat >> confdefs.h <<\EOF
  #define _POSIX_1_SOURCE 2
  EOF
  
!   cat >> confdefs.h <<\EOF
  #define _MINIX 1
  EOF
--- 2236,2481 ----
  fi
  if test -z "$CPP"; then
!   if test "${ac_cv_prog_CPP+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
!       # Double quotes because CPP needs to be expanded
!     for CPP in "$CC -E" "$CC -E -traditional-cpp" "/lib/cpp"
!     do
!       ac_preproc_ok=false
! for ac_c_preproc_warn_flag in '' yes
! do
!   # Use a header file that comes with gcc, so configuring glibc
!   # with a fresh cross-compiler works.
    # On the NeXT, cc -E runs the code through the compiler's parser,
!   # not just through cpp. "Syntax error" is here to catch this case.
!   cat >conftest.$ac_ext <<_ACEOF
! #line 2252 "configure"
  #include "confdefs.h"
  #include <assert.h>
!                      Syntax error
! _ACEOF
! if { (eval echo "$as_me:2257: \"$ac_cpp conftest.$ac_ext\"") >&5
!   (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
!   ac_status=$?
!   egrep -v '^ *\+' conftest.er1 >conftest.err
!   rm -f conftest.er1
!   cat conftest.err >&5
!   echo "$as_me:2263: \$? = $ac_status" >&5
!   (exit $ac_status); } >/dev/null; then
!   if test -s conftest.err; then
!     ac_cpp_err=$ac_c_preproc_warn_flag
!   else
!     ac_cpp_err=
!   fi
! else
!   ac_cpp_err=yes
! fi
! if test -z "$ac_cpp_err"; then
    :
  else
!   echo "$as_me: failed program was:" >&5
    cat conftest.$ac_ext >&5
!   # Broken: fails on valid input.
! continue
! fi
! rm -f conftest.err conftest.$ac_ext
! 
!   # OK, works on sane cases.  Now check whether non-existent headers
!   # can be detected and how.
!   cat >conftest.$ac_ext <<_ACEOF
! #line 2286 "configure"
! #include "confdefs.h"
! #include <ac_nonexistent.h>
! _ACEOF
! if { (eval echo "$as_me:2290: \"$ac_cpp conftest.$ac_ext\"") >&5
!   (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
!   ac_status=$?
!   egrep -v '^ *\+' conftest.er1 >conftest.err
!   rm -f conftest.er1
!   cat conftest.err >&5
!   echo "$as_me:2296: \$? = $ac_status" >&5
!   (exit $ac_status); } >/dev/null; then
!   if test -s conftest.err; then
!     ac_cpp_err=$ac_c_preproc_warn_flag
!   else
!     ac_cpp_err=
!   fi
! else
!   ac_cpp_err=yes
! fi
! if test -z "$ac_cpp_err"; then
!   # Broken: success on invalid input.
! continue
  else
!   echo "$as_me: failed program was:" >&5
    cat conftest.$ac_ext >&5
!   # Passes both tests.
! ac_preproc_ok=:
! break
! fi
! rm -f conftest.err conftest.$ac_ext
! 
! done
! # Because of `break', _AC_PREPROC_IFELSE's cleaning code was skipped.
! rm -f conftest.err conftest.$ac_ext
! if $ac_preproc_ok; then
!   break
! fi
! 
!     done
!     ac_cv_prog_CPP=$CPP
! 
! fi
!   CPP=$ac_cv_prog_CPP
! else
!   ac_cv_prog_CPP=$CPP
! fi
! echo "$as_me:2333: result: $CPP" >&5
! echo "${ECHO_T}$CPP" >&6
! ac_preproc_ok=false
! for ac_c_preproc_warn_flag in '' yes
! do
!   # Use a header file that comes with gcc, so configuring glibc
!   # with a fresh cross-compiler works.
!   # On the NeXT, cc -E runs the code through the compiler's parser,
!   # not just through cpp. "Syntax error" is here to catch this case.
!   cat >conftest.$ac_ext <<_ACEOF
! #line 2343 "configure"
  #include "confdefs.h"
  #include <assert.h>
!                      Syntax error
! _ACEOF
! if { (eval echo "$as_me:2348: \"$ac_cpp conftest.$ac_ext\"") >&5
!   (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
!   ac_status=$?
!   egrep -v '^ *\+' conftest.er1 >conftest.err
!   rm -f conftest.er1
!   cat conftest.err >&5
!   echo "$as_me:2354: \$? = $ac_status" >&5
!   (exit $ac_status); } >/dev/null; then
!   if test -s conftest.err; then
!     ac_cpp_err=$ac_c_preproc_warn_flag
!   else
!     ac_cpp_err=
!   fi
! else
!   ac_cpp_err=yes
! fi
! if test -z "$ac_cpp_err"; then
    :
  else
!   echo "$as_me: failed program was:" >&5
    cat conftest.$ac_ext >&5
!   # Broken: fails on valid input.
! continue
  fi
! rm -f conftest.err conftest.$ac_ext
! 
!   # OK, works on sane cases.  Now check whether non-existent headers
!   # can be detected and how.
!   cat >conftest.$ac_ext <<_ACEOF
! #line 2377 "configure"
! #include "confdefs.h"
! #include <ac_nonexistent.h>
! _ACEOF
! if { (eval echo "$as_me:2381: \"$ac_cpp conftest.$ac_ext\"") >&5
!   (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
!   ac_status=$?
!   egrep -v '^ *\+' conftest.er1 >conftest.err
!   rm -f conftest.er1
!   cat conftest.err >&5
!   echo "$as_me:2387: \$? = $ac_status" >&5
!   (exit $ac_status); } >/dev/null; then
!   if test -s conftest.err; then
!     ac_cpp_err=$ac_c_preproc_warn_flag
!   else
!     ac_cpp_err=
!   fi
! else
!   ac_cpp_err=yes
  fi
! if test -z "$ac_cpp_err"; then
!   # Broken: success on invalid input.
! continue
! else
!   echo "$as_me: failed program was:" >&5
!   cat conftest.$ac_ext >&5
!   # Passes both tests.
! ac_preproc_ok=:
! break
  fi
! rm -f conftest.err conftest.$ac_ext
! 
! done
! # Because of `break', _AC_PREPROC_IFELSE's cleaning code was skipped.
! rm -f conftest.err conftest.$ac_ext
! if $ac_preproc_ok; then
!   :
  else
!   { { echo "$as_me:2415: error: C preprocessor \"$CPP\" fails sanity check" >&5
! echo "$as_me: error: C preprocessor \"$CPP\" fails sanity check" >&2;}
!    { (exit 1); exit 1; }; }
  fi
  
! ac_ext=c
! ac_cpp='$CPP $CPPFLAGS'
! ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
! ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
! ac_compiler_gnu=$ac_cv_c_compiler_gnu
! 
! echo "$as_me:2426: checking for minix/config.h" >&5
! echo $ECHO_N "checking for minix/config.h... $ECHO_C" >&6
! if test "${ac_cv_header_minix_config_h+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 2432 "configure"
  #include "confdefs.h"
  #include <minix/config.h>
! _ACEOF
! if { (eval echo "$as_me:2436: \"$ac_cpp conftest.$ac_ext\"") >&5
!   (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
!   ac_status=$?
!   egrep -v '^ *\+' conftest.er1 >conftest.err
!   rm -f conftest.er1
!   cat conftest.err >&5
!   echo "$as_me:2442: \$? = $ac_status" >&5
!   (exit $ac_status); } >/dev/null; then
!   if test -s conftest.err; then
!     ac_cpp_err=$ac_c_preproc_warn_flag
!   else
!     ac_cpp_err=
!   fi
! else
!   ac_cpp_err=yes
! fi
! if test -z "$ac_cpp_err"; then
!   ac_cv_header_minix_config_h=yes
  else
!   echo "$as_me: failed program was:" >&5
    cat conftest.$ac_ext >&5
!   ac_cv_header_minix_config_h=no
  fi
! rm -f conftest.err conftest.$ac_ext
  fi
! echo "$as_me:2461: result: $ac_cv_header_minix_config_h" >&5
! echo "${ECHO_T}$ac_cv_header_minix_config_h" >&6
! if test $ac_cv_header_minix_config_h = yes; then
    MINIX=yes
  else
!   MINIX=
  fi
  
  if test "$MINIX" = yes; then
! 
! cat >>confdefs.h <<\EOF
  #define _POSIX_SOURCE 1
  EOF
  
! cat >>confdefs.h <<\EOF
  #define _POSIX_1_SOURCE 2
  EOF
  
! cat >>confdefs.h <<\EOF
  #define _MINIX 1
  EOF
***************
*** 1595,1699 ****
  fi
  
  
! echo $ac_n "checking for Cygwin environment""... $ac_c" 1>&6
! echo "configure:1600: checking for Cygwin environment" >&5
! if eval "test \"`echo '$''{'ac_cv_cygwin'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
! else
!   cat > conftest.$ac_ext <<EOF
! #line 1605 "configure"
! #include "confdefs.h"
  
! int main() {
  
! #ifndef __CYGWIN__
! #define __CYGWIN__ __CYGWIN32__
! #endif
! return __CYGWIN__;
! ; return 0; }
! EOF
! if { (eval echo configure:1616: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
!   rm -rf conftest*
!   ac_cv_cygwin=yes
  else
!   echo "configure: failed program was:" >&5
!   cat conftest.$ac_ext >&5
!   rm -rf conftest*
!   ac_cv_cygwin=no
  fi
! rm -f conftest*
! rm -f conftest*
  fi
  
! echo "$ac_t""$ac_cv_cygwin" 1>&6
! CYGWIN=
! test "$ac_cv_cygwin" = yes && CYGWIN=yes
! echo $ac_n "checking for mingw32 environment""... $ac_c" 1>&6
! echo "configure:1633: checking for mingw32 environment" >&5
! if eval "test \"`echo '$''{'ac_cv_mingw32'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
! else
!   cat > conftest.$ac_ext <<EOF
! #line 1638 "configure"
! #include "confdefs.h"
! 
! int main() {
! return __MINGW32__;
! ; return 0; }
! EOF
! if { (eval echo configure:1645: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
!   rm -rf conftest*
!   ac_cv_mingw32=yes
  else
!   echo "configure: failed program was:" >&5
!   cat conftest.$ac_ext >&5
!   rm -rf conftest*
!   ac_cv_mingw32=no
! fi
! rm -f conftest*
! rm -f conftest*
  fi
  
! echo "$ac_t""$ac_cv_mingw32" 1>&6
! MINGW32=
! test "$ac_cv_mingw32" = yes && MINGW32=yes
! 
! 
! echo $ac_n "checking for executable suffix""... $ac_c" 1>&6
! echo "configure:1664: checking for executable suffix" >&5
! if eval "test \"`echo '$''{'ac_cv_exeext'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
! else
!   if test "$CYGWIN" = yes || test "$MINGW32" = yes; then
!   ac_cv_exeext=.exe
! else
!   rm -f conftest*
!   echo 'int main () { return 0; }' > conftest.$ac_ext
!   ac_cv_exeext=
!   if { (eval echo configure:1674: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; }; then
!     for file in conftest.*; do
!       case $file in
!       *.c | *.o | *.obj) ;;
!       *) ac_cv_exeext=`echo $file | sed -e s/conftest//` ;;
!       esac
!     done
!   else
!     { echo "configure: error: installation or configuration problem: compiler cannot create executables." 1>&2; exit 1; }
!   fi
!   rm -f conftest*
!   test x"${ac_cv_exeext}" = x && ac_cv_exeext=no
  fi
  fi
  
! EXEEXT=""
! test x"${ac_cv_exeext}" != xno && EXEEXT=${ac_cv_exeext}
! echo "$ac_t""${ac_cv_exeext}" 1>&6
! ac_exeext=$EXEEXT
  
  
  
! SIGNAMES_H=lsignames.h
  
  
  
  if test "x$cross_compiling" = "xyes"; then
--- 2483,2780 ----
  fi
  
+ case $host_os in
+   *cygwin* ) CYGWIN=yes;;
+          * ) CYGWIN=no;;
+ esac
  
! case $host_os in
!   *mingw32* ) MINGW32=yes;;
!           * ) MINGW32=no;;
! esac
  
! # Check whether --enable-largefile or --disable-largefile was given.
! if test "${enable_largefile+set}" = set; then
!   enableval="$enable_largefile"
! 
! fi;
! if test "$enable_largefile" != no; then
! 
!   echo "$as_me:2502: checking for special C compiler options needed for large files" >&5
! echo $ECHO_N "checking for special C compiler options needed for large files... $ECHO_C" >&6
! if test "${ac_cv_sys_largefile_CC+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
! else
!   ac_cv_sys_largefile_CC=no
!      if test "$GCC" != yes; then
!        ac_save_CC=$CC
!        while :; do
!      	 # IRIX 6.2 and later do not support large files by default,
!      	 # so use the C compiler's -n32 option if that helps.
!          cat >conftest.$ac_ext <<_ACEOF
! #line 2514 "configure"
! #include "confdefs.h"
! #include <sys/types.h>
!  /* Check that off_t can represent 2**63 - 1 correctly.
!     We can't simply define LARGE_OFF_T to be 9223372036854775807,
!     since some C++ compilers masquerading as C compilers
!     incorrectly reject 9223372036854775807.  */
! #define LARGE_OFF_T (((off_t) 1 << 62) - 1 + ((off_t) 1 << 62))
!   int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
! 		       && LARGE_OFF_T % 2147483647 == 1)
! 		      ? 1 : -1];
! int
! main ()
! {
  
!   ;
!   return 0;
! }
! _ACEOF
!      	 rm -f conftest.$ac_objext
! if { (eval echo "$as_me:2534: \"$ac_compile\"") >&5
!   (eval $ac_compile) 2>&5
!   ac_status=$?
!   echo "$as_me:2537: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest.$ac_objext'
!   { (eval echo "$as_me:2540: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:2543: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   break
  else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
  fi
! rm -f conftest.$ac_objext
!      	 CC="$CC -n32"
!      	 rm -f conftest.$ac_objext
! if { (eval echo "$as_me:2553: \"$ac_compile\"") >&5
!   (eval $ac_compile) 2>&5
!   ac_status=$?
!   echo "$as_me:2556: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest.$ac_objext'
!   { (eval echo "$as_me:2559: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:2562: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   ac_cv_sys_largefile_CC=' -n32'; break
! else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! fi
! rm -f conftest.$ac_objext
!          break
!        done
!        CC=$ac_save_CC
!        rm -f conftest.$ac_ext
!     fi
  fi
+ echo "$as_me:2576: result: $ac_cv_sys_largefile_CC" >&5
+ echo "${ECHO_T}$ac_cv_sys_largefile_CC" >&6
+   if test "$ac_cv_sys_largefile_CC" != no; then
+     CC=$CC$ac_cv_sys_largefile_CC
+   fi
+ 
+   echo "$as_me:2582: checking for _FILE_OFFSET_BITS value needed for large files" >&5
+ echo $ECHO_N "checking for _FILE_OFFSET_BITS value needed for large files... $ECHO_C" >&6
+ if test "${ac_cv_sys_file_offset_bits+set}" = set; then
+   echo $ECHO_N "(cached) $ECHO_C" >&6
+ else
+   while :; do
+   ac_cv_sys_file_offset_bits=no
+   cat >conftest.$ac_ext <<_ACEOF
+ #line 2590 "configure"
+ #include "confdefs.h"
+ #include <sys/types.h>
+  /* Check that off_t can represent 2**63 - 1 correctly.
+     We can't simply define LARGE_OFF_T to be 9223372036854775807,
+     since some C++ compilers masquerading as C compilers
+     incorrectly reject 9223372036854775807.  */
+ #define LARGE_OFF_T (((off_t) 1 << 62) - 1 + ((off_t) 1 << 62))
+   int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
+ 		       && LARGE_OFF_T % 2147483647 == 1)
+ 		      ? 1 : -1];
+ int
+ main ()
+ {
  
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext
! if { (eval echo "$as_me:2610: \"$ac_compile\"") >&5
!   (eval $ac_compile) 2>&5
!   ac_status=$?
!   echo "$as_me:2613: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest.$ac_objext'
!   { (eval echo "$as_me:2616: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:2619: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   break
  else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
  fi
+ rm -f conftest.$ac_objext conftest.$ac_ext
+   cat >conftest.$ac_ext <<_ACEOF
+ #line 2628 "configure"
+ #include "confdefs.h"
+ #define _FILE_OFFSET_BITS 64
+ #include <sys/types.h>
+  /* Check that off_t can represent 2**63 - 1 correctly.
+     We can't simply define LARGE_OFF_T to be 9223372036854775807,
+     since some C++ compilers masquerading as C compilers
+     incorrectly reject 9223372036854775807.  */
+ #define LARGE_OFF_T (((off_t) 1 << 62) - 1 + ((off_t) 1 << 62))
+   int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
+ 		       && LARGE_OFF_T % 2147483647 == 1)
+ 		      ? 1 : -1];
+ int
+ main ()
+ {
  
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext
! if { (eval echo "$as_me:2649: \"$ac_compile\"") >&5
!   (eval $ac_compile) 2>&5
!   ac_status=$?
!   echo "$as_me:2652: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest.$ac_objext'
!   { (eval echo "$as_me:2655: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:2658: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   ac_cv_sys_file_offset_bits=64; break
! else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
  fi
+ rm -f conftest.$ac_objext conftest.$ac_ext
+   break
+ done
  fi
+ echo "$as_me:2669: result: $ac_cv_sys_file_offset_bits" >&5
+ echo "${ECHO_T}$ac_cv_sys_file_offset_bits" >&6
+ if test "$ac_cv_sys_file_offset_bits" != no; then
  
! cat >>confdefs.h <<EOF
! #define _FILE_OFFSET_BITS $ac_cv_sys_file_offset_bits
! EOF
! 
! fi
! rm -f conftest*
!   echo "$as_me:2679: checking for _LARGE_FILES value needed for large files" >&5
! echo $ECHO_N "checking for _LARGE_FILES value needed for large files... $ECHO_C" >&6
! if test "${ac_cv_sys_large_files+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
! else
!   while :; do
!   ac_cv_sys_large_files=no
!   cat >conftest.$ac_ext <<_ACEOF
! #line 2687 "configure"
! #include "confdefs.h"
! #include <sys/types.h>
!  /* Check that off_t can represent 2**63 - 1 correctly.
!     We can't simply define LARGE_OFF_T to be 9223372036854775807,
!     since some C++ compilers masquerading as C compilers
!     incorrectly reject 9223372036854775807.  */
! #define LARGE_OFF_T (((off_t) 1 << 62) - 1 + ((off_t) 1 << 62))
!   int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
! 		       && LARGE_OFF_T % 2147483647 == 1)
! 		      ? 1 : -1];
! int
! main ()
! {
  
+   ;
+   return 0;
+ }
+ _ACEOF
+ rm -f conftest.$ac_objext
+ if { (eval echo "$as_me:2707: \"$ac_compile\"") >&5
+   (eval $ac_compile) 2>&5
+   ac_status=$?
+   echo "$as_me:2710: \$? = $ac_status" >&5
+   (exit $ac_status); } &&
+          { ac_try='test -s conftest.$ac_objext'
+   { (eval echo "$as_me:2713: \"$ac_try\"") >&5
+   (eval $ac_try) 2>&5
+   ac_status=$?
+   echo "$as_me:2716: \$? = $ac_status" >&5
+   (exit $ac_status); }; }; then
+   break
+ else
+   echo "$as_me: failed program was:" >&5
+ cat conftest.$ac_ext >&5
+ fi
+ rm -f conftest.$ac_objext conftest.$ac_ext
+   cat >conftest.$ac_ext <<_ACEOF
+ #line 2725 "configure"
+ #include "confdefs.h"
+ #define _LARGE_FILES 1
+ #include <sys/types.h>
+  /* Check that off_t can represent 2**63 - 1 correctly.
+     We can't simply define LARGE_OFF_T to be 9223372036854775807,
+     since some C++ compilers masquerading as C compilers
+     incorrectly reject 9223372036854775807.  */
+ #define LARGE_OFF_T (((off_t) 1 << 62) - 1 + ((off_t) 1 << 62))
+   int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
+ 		       && LARGE_OFF_T % 2147483647 == 1)
+ 		      ? 1 : -1];
+ int
+ main ()
+ {
  
+   ;
+   return 0;
+ }
+ _ACEOF
+ rm -f conftest.$ac_objext
+ if { (eval echo "$as_me:2746: \"$ac_compile\"") >&5
+   (eval $ac_compile) 2>&5
+   ac_status=$?
+   echo "$as_me:2749: \$? = $ac_status" >&5
+   (exit $ac_status); } &&
+          { ac_try='test -s conftest.$ac_objext'
+   { (eval echo "$as_me:2752: \"$ac_try\"") >&5
+   (eval $ac_try) 2>&5
+   ac_status=$?
+   echo "$as_me:2755: \$? = $ac_status" >&5
+   (exit $ac_status); }; }; then
+   ac_cv_sys_large_files=1; break
+ else
+   echo "$as_me: failed program was:" >&5
+ cat conftest.$ac_ext >&5
+ fi
+ rm -f conftest.$ac_objext conftest.$ac_ext
+   break
+ done
+ fi
+ echo "$as_me:2766: result: $ac_cv_sys_large_files" >&5
+ echo "${ECHO_T}$ac_cv_sys_large_files" >&6
+ if test "$ac_cv_sys_large_files" != no; then
  
! cat >>confdefs.h <<EOF
! #define _LARGE_FILES $ac_cv_sys_large_files
! EOF
  
+ fi
+ rm -f conftest*
+ fi
  
+ SIGNAMES_H=lsignames.h
  
  if test "x$cross_compiling" = "xyes"; then
***************
*** 1717,1721 ****
  fi
  
- 
  if test -z "$CC_FOR_BUILD"; then
      if test "x$cross_compiling" = "xno"; then
--- 2798,2801 ----
***************
*** 1726,1731 ****
  fi
  
- 
- 
  test -z "$CFLAGS" && CFLAGS=-g auto_cflags=1
  
--- 2806,2809 ----
***************
*** 1741,1790 ****
  
  if test "$opt_static_link" = yes; then
! 	# if we're using gcc, add `-static' to LDFLAGS
! 	if test -n "$GCC" || test "$ac_cv_prog_gcc" = "yes"; then
  		STATIC_LD="-static"
! 		LDFLAGS="$LDFLAGS -static"	# XXX experimental
  	fi
  fi
  
! 
! 
! 
! 
! 
! if test $ac_cv_prog_gcc = yes; then
!     echo $ac_n "checking whether ${CC-cc} needs -traditional""... $ac_c" 1>&6
! echo "configure:1758: checking whether ${CC-cc} needs -traditional" >&5
! if eval "test \"`echo '$''{'ac_cv_prog_gcc_traditional'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
      ac_pattern="Autoconf.*'x'"
!   cat > conftest.$ac_ext <<EOF
! #line 1764 "configure"
  #include "confdefs.h"
  #include <sgtty.h>
  Autoconf TIOCGETP
! EOF
  if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
    egrep "$ac_pattern" >/dev/null 2>&1; then
-   rm -rf conftest*
    ac_cv_prog_gcc_traditional=yes
  else
-   rm -rf conftest*
    ac_cv_prog_gcc_traditional=no
  fi
  rm -f conftest*
  
- 
    if test $ac_cv_prog_gcc_traditional = no; then
!     cat > conftest.$ac_ext <<EOF
! #line 1782 "configure"
  #include "confdefs.h"
  #include <termio.h>
  Autoconf TCGETA
! EOF
  if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
    egrep "$ac_pattern" >/dev/null 2>&1; then
-   rm -rf conftest*
    ac_cv_prog_gcc_traditional=yes
  fi
--- 2819,2862 ----
  
  if test "$opt_static_link" = yes; then
! 	# if we're using gcc, add `-static' to LDFLAGS, except on Solaris >= 2
! 	if test -n "$GCC" || test "$ac_cv_c_compiler_gnu" = "yes"; then
  		STATIC_LD="-static"
! 		case "$host_os" in
! 		solaris2*)	;;
! 		*)		LDFLAGS="$LDFLAGS -static" ;;	# XXX experimental
! 		esac
  	fi
  fi
  
! if test $ac_cv_c_compiler_gnu = yes; then
!     echo "$as_me:2832: checking whether $CC needs -traditional" >&5
! echo $ECHO_N "checking whether $CC needs -traditional... $ECHO_C" >&6
! if test "${ac_cv_prog_gcc_traditional+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
      ac_pattern="Autoconf.*'x'"
!   cat >conftest.$ac_ext <<_ACEOF
! #line 2839 "configure"
  #include "confdefs.h"
  #include <sgtty.h>
  Autoconf TIOCGETP
! _ACEOF
  if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
    egrep "$ac_pattern" >/dev/null 2>&1; then
    ac_cv_prog_gcc_traditional=yes
  else
    ac_cv_prog_gcc_traditional=no
  fi
  rm -f conftest*
  
    if test $ac_cv_prog_gcc_traditional = no; then
!     cat >conftest.$ac_ext <<_ACEOF
! #line 2854 "configure"
  #include "confdefs.h"
  #include <termio.h>
  Autoconf TCGETA
! _ACEOF
  if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
    egrep "$ac_pattern" >/dev/null 2>&1; then
    ac_cv_prog_gcc_traditional=yes
  fi
***************
*** 1793,1798 ****
    fi
  fi
! 
! echo "$ac_t""$ac_cv_prog_gcc_traditional" 1>&6
    if test $ac_cv_prog_gcc_traditional = yes; then
      CC="$CC -traditional"
--- 2865,2870 ----
    fi
  fi
! echo "$as_me:2867: result: $ac_cv_prog_gcc_traditional" >&5
! echo "${ECHO_T}$ac_cv_prog_gcc_traditional" >&6
    if test $ac_cv_prog_gcc_traditional = yes; then
      CC="$CC -traditional"
***************
*** 1800,1937 ****
  fi
  
! 
! 
! if test "$opt_readline" = yes && test "$opt_with_installed_readline" = "yes"
  then
  
- 
- 	if test -z "$TERMCAP_LIB" ; then
- 		
  if test "X$bash_cv_termcap_lib" = "X"; then
  _bash_needmsg=yes
  else
! echo $ac_n "checking which library has the termcap functions""... $ac_c" 1>&6
! echo "configure:1815: checking which library has the termcap functions" >&5
  _bash_needmsg=
  fi
! if eval "test \"`echo '$''{'bash_cv_termcap_lib'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
!   echo $ac_n "checking for tgetent in -ltermcap""... $ac_c" 1>&6
! echo "configure:1822: checking for tgetent in -ltermcap" >&5
! ac_lib_var=`echo termcap'_'tgetent | sed 'y%./+-%__p_%'`
! if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
!   ac_save_LIBS="$LIBS"
  LIBS="-ltermcap  $LIBS"
! cat > conftest.$ac_ext <<EOF
! #line 1830 "configure"
  #include "confdefs.h"
  /* Override any gcc2 internal prototype to avoid an error.  */
  /* We use char because int might match the return type of a gcc2
!     builtin and then its argument prototype would still apply.  */
! char tgetent();
! 
! int main() {
! tgetent()
! ; return 0; }
! EOF
! if { (eval echo configure:1841: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
!   rm -rf conftest*
!   eval "ac_cv_lib_$ac_lib_var=yes"
! else
!   echo "configure: failed program was:" >&5
!   cat conftest.$ac_ext >&5
!   rm -rf conftest*
!   eval "ac_cv_lib_$ac_lib_var=no"
! fi
! rm -f conftest*
! LIBS="$ac_save_LIBS"
! 
! fi
! if eval "test \"`echo '$ac_cv_lib_'$ac_lib_var`\" = yes"; then
!   echo "$ac_t""yes" 1>&6
    bash_cv_termcap_lib=libtermcap
  else
!   echo "$ac_t""no" 1>&6
! echo $ac_n "checking for tgetent in -lcurses""... $ac_c" 1>&6
! echo "configure:1860: checking for tgetent in -lcurses" >&5
! ac_lib_var=`echo curses'_'tgetent | sed 'y%./+-%__p_%'`
! if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
! else
!   ac_save_LIBS="$LIBS"
! LIBS="-lcurses  $LIBS"
! cat > conftest.$ac_ext <<EOF
! #line 1868 "configure"
  #include "confdefs.h"
  /* Override any gcc2 internal prototype to avoid an error.  */
  /* We use char because int might match the return type of a gcc2
!     builtin and then its argument prototype would still apply.  */
! char tgetent();
! 
! int main() {
! tgetent()
! ; return 0; }
! EOF
! if { (eval echo configure:1879: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
!   rm -rf conftest*
!   eval "ac_cv_lib_$ac_lib_var=yes"
  else
!   echo "configure: failed program was:" >&5
!   cat conftest.$ac_ext >&5
!   rm -rf conftest*
!   eval "ac_cv_lib_$ac_lib_var=no"
! fi
! rm -f conftest*
! LIBS="$ac_save_LIBS"
  
! fi
! if eval "test \"`echo '$ac_cv_lib_'$ac_lib_var`\" = yes"; then
!   echo "$ac_t""yes" 1>&6
!   bash_cv_termcap_lib=libcurses
  else
!   echo "$ac_t""no" 1>&6
! echo $ac_n "checking for tgetent in -lncurses""... $ac_c" 1>&6
! echo "configure:1898: checking for tgetent in -lncurses" >&5
! ac_lib_var=`echo ncurses'_'tgetent | sed 'y%./+-%__p_%'`
! if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
!   ac_save_LIBS="$LIBS"
  LIBS="-lncurses  $LIBS"
! cat > conftest.$ac_ext <<EOF
! #line 1906 "configure"
  #include "confdefs.h"
  /* Override any gcc2 internal prototype to avoid an error.  */
  /* We use char because int might match the return type of a gcc2
!     builtin and then its argument prototype would still apply.  */
! char tgetent();
! 
! int main() {
! tgetent()
! ; return 0; }
! EOF
! if { (eval echo configure:1917: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
!   rm -rf conftest*
!   eval "ac_cv_lib_$ac_lib_var=yes"
  else
!   echo "configure: failed program was:" >&5
!   cat conftest.$ac_ext >&5
!   rm -rf conftest*
!   eval "ac_cv_lib_$ac_lib_var=no"
  fi
- rm -f conftest*
- LIBS="$ac_save_LIBS"
  
  fi
- if eval "test \"`echo '$ac_cv_lib_'$ac_lib_var`\" = yes"; then
-   echo "$ac_t""yes" 1>&6
-   bash_cv_termcap_lib=libncurses
- else
-   echo "$ac_t""no" 1>&6
- bash_cv_termcap_lib=gnutermcap
- fi
  
  fi
--- 2872,3104 ----
  fi
  
! if test "$opt_readline" = yes && test "$opt_with_installed_readline" != "no"
  then
+ echo opt_with_installed_readline = $opt_with_installed_readline
+ 	# If the user specified --with-installed-readline=PREFIX and PREFIX
+ 	# is not `yes', set ac_cv_rl_prefix to PREFIX
+ 	test $opt_with_installed_readline != "yes" && ac_cv_rl_prefix=$opt_with_installed_readline
  
  if test "X$bash_cv_termcap_lib" = "X"; then
  _bash_needmsg=yes
  else
! echo "$as_me:2884: checking which library has the termcap functions" >&5
! echo $ECHO_N "checking which library has the termcap functions... $ECHO_C" >&6
  _bash_needmsg=
  fi
! if test "${bash_cv_termcap_lib+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
!   echo "$as_me:2891: checking for tgetent in -ltermcap" >&5
! echo $ECHO_N "checking for tgetent in -ltermcap... $ECHO_C" >&6
! if test "${ac_cv_lib_termcap_tgetent+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
!   ac_check_lib_save_LIBS=$LIBS
  LIBS="-ltermcap  $LIBS"
! cat >conftest.$ac_ext <<_ACEOF
! #line 2899 "configure"
  #include "confdefs.h"
+ 
  /* Override any gcc2 internal prototype to avoid an error.  */
+ #ifdef __cplusplus
+ extern "C"
+ #endif
  /* We use char because int might match the return type of a gcc2
!    builtin and then its argument prototype would still apply.  */
! char tgetent ();
! int
! main ()
! {
! tgetent ();
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext conftest$ac_exeext
! if { (eval echo "$as_me:2918: \"$ac_link\"") >&5
!   (eval $ac_link) 2>&5
!   ac_status=$?
!   echo "$as_me:2921: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest$ac_exeext'
!   { (eval echo "$as_me:2924: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:2927: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   ac_cv_lib_termcap_tgetent=yes
! else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! ac_cv_lib_termcap_tgetent=no
! fi
! rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
! LIBS=$ac_check_lib_save_LIBS
! fi
! echo "$as_me:2938: result: $ac_cv_lib_termcap_tgetent" >&5
! echo "${ECHO_T}$ac_cv_lib_termcap_tgetent" >&6
! if test $ac_cv_lib_termcap_tgetent = yes; then
    bash_cv_termcap_lib=libtermcap
  else
!   echo "$as_me:2943: checking for tgetent in -ltinfo" >&5
! echo $ECHO_N "checking for tgetent in -ltinfo... $ECHO_C" >&6
! if test "${ac_cv_lib_tinfo_tgetent+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
! else
!   ac_check_lib_save_LIBS=$LIBS
! LIBS="-ltinfo  $LIBS"
! cat >conftest.$ac_ext <<_ACEOF
! #line 2951 "configure"
  #include "confdefs.h"
+ 
  /* Override any gcc2 internal prototype to avoid an error.  */
+ #ifdef __cplusplus
+ extern "C"
+ #endif
  /* We use char because int might match the return type of a gcc2
!    builtin and then its argument prototype would still apply.  */
! char tgetent ();
! int
! main ()
! {
! tgetent ();
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext conftest$ac_exeext
! if { (eval echo "$as_me:2970: \"$ac_link\"") >&5
!   (eval $ac_link) 2>&5
!   ac_status=$?
!   echo "$as_me:2973: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest$ac_exeext'
!   { (eval echo "$as_me:2976: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:2979: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   ac_cv_lib_tinfo_tgetent=yes
! else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! ac_cv_lib_tinfo_tgetent=no
! fi
! rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
! LIBS=$ac_check_lib_save_LIBS
! fi
! echo "$as_me:2990: result: $ac_cv_lib_tinfo_tgetent" >&5
! echo "${ECHO_T}$ac_cv_lib_tinfo_tgetent" >&6
! if test $ac_cv_lib_tinfo_tgetent = yes; then
!   bash_cv_termcal_lib=libtinfo
! else
!   echo "$as_me:2995: checking for tgetent in -lcurses" >&5
! echo $ECHO_N "checking for tgetent in -lcurses... $ECHO_C" >&6
! if test "${ac_cv_lib_curses_tgetent+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
!   ac_check_lib_save_LIBS=$LIBS
! LIBS="-lcurses  $LIBS"
! cat >conftest.$ac_ext <<_ACEOF
! #line 3003 "configure"
! #include "confdefs.h"
  
! /* Override any gcc2 internal prototype to avoid an error.  */
! #ifdef __cplusplus
! extern "C"
! #endif
! /* We use char because int might match the return type of a gcc2
!    builtin and then its argument prototype would still apply.  */
! char tgetent ();
! int
! main ()
! {
! tgetent ();
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext conftest$ac_exeext
! if { (eval echo "$as_me:3022: \"$ac_link\"") >&5
!   (eval $ac_link) 2>&5
!   ac_status=$?
!   echo "$as_me:3025: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest$ac_exeext'
!   { (eval echo "$as_me:3028: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:3031: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   ac_cv_lib_curses_tgetent=yes
! else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! ac_cv_lib_curses_tgetent=no
! fi
! rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
! LIBS=$ac_check_lib_save_LIBS
! fi
! echo "$as_me:3042: result: $ac_cv_lib_curses_tgetent" >&5
! echo "${ECHO_T}$ac_cv_lib_curses_tgetent" >&6
! if test $ac_cv_lib_curses_tgetent = yes; then
!   bash_cv_termcap_lib=libcurses
  else
!   echo "$as_me:3047: checking for tgetent in -lncurses" >&5
! echo $ECHO_N "checking for tgetent in -lncurses... $ECHO_C" >&6
! if test "${ac_cv_lib_ncurses_tgetent+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
!   ac_check_lib_save_LIBS=$LIBS
  LIBS="-lncurses  $LIBS"
! cat >conftest.$ac_ext <<_ACEOF
! #line 3055 "configure"
  #include "confdefs.h"
+ 
  /* Override any gcc2 internal prototype to avoid an error.  */
+ #ifdef __cplusplus
+ extern "C"
+ #endif
  /* We use char because int might match the return type of a gcc2
!    builtin and then its argument prototype would still apply.  */
! char tgetent ();
! int
! main ()
! {
! tgetent ();
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext conftest$ac_exeext
! if { (eval echo "$as_me:3074: \"$ac_link\"") >&5
!   (eval $ac_link) 2>&5
!   ac_status=$?
!   echo "$as_me:3077: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest$ac_exeext'
!   { (eval echo "$as_me:3080: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:3083: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   ac_cv_lib_ncurses_tgetent=yes
! else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! ac_cv_lib_ncurses_tgetent=no
! fi
! rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
! LIBS=$ac_check_lib_save_LIBS
! fi
! echo "$as_me:3094: result: $ac_cv_lib_ncurses_tgetent" >&5
! echo "${ECHO_T}$ac_cv_lib_ncurses_tgetent" >&6
! if test $ac_cv_lib_ncurses_tgetent = yes; then
!   bash_cv_termcap_lib=libncurses
  else
!   bash_cv_termcap_lib=gnutermcap
  fi
  
  fi
  
  fi
***************
*** 1942,1949 ****
  
  if test "X$_bash_needmsg" = "Xyes"; then
! echo $ac_n "checking which library has the termcap functions""... $ac_c" 1>&6
! echo "configure:1946: checking which library has the termcap functions" >&5
  fi
! echo "$ac_t""using $bash_cv_termcap_lib" 1>&6
  if test $bash_cv_termcap_lib = gnutermcap && test -z "$prefer_curses"; then
  LDFLAGS="$LDFLAGS -L./lib/termcap"
--- 3109,3117 ----
  
  if test "X$_bash_needmsg" = "Xyes"; then
! echo "$as_me:3111: checking which library has the termcap functions" >&5
! echo $ECHO_N "checking which library has the termcap functions... $ECHO_C" >&6
  fi
! echo "$as_me:3114: result: using $bash_cv_termcap_lib" >&5
! echo "${ECHO_T}using $bash_cv_termcap_lib" >&6
  if test $bash_cv_termcap_lib = gnutermcap && test -z "$prefer_curses"; then
  LDFLAGS="$LDFLAGS -L./lib/termcap"
***************
*** 1953,1956 ****
--- 3121,3127 ----
  TERMCAP_LIB=-ltermcap
  TERMCAP_DEP=
+ elif test $bash_cv_termcap_lib = libtinfo; then
+ TERMCAP_LIB=-ltinfo
+ TERMCAP_DEP=
  elif test $bash_cv_termcap_lib = libncurses; then
  TERMCAP_LIB=-lncurses
***************
*** 1961,1994 ****
  fi
  
! 	fi
  
! 	test "x$prefix" = xNONE && _rl_prefix=$ac_default_prefix || _rl_prefix=${prefix}
! 	test "x$exec_prefix" = xNONE && _rl_exec_prefix=${_rl_prefix} || _rl_exec_prefix=${exec_prefix}
  
! 	echo $ac_n "checking version of installed readline library""... $ac_c" 1>&6
! echo "configure:1970: checking version of installed readline library" >&5
! 	_rl_version=`exec_prefix=${_rl_exec_prefix} ${CONFIG_SHELL-/bin/sh} ${srcdir}/support/rlvers.sh -C "${CC}" -L ${libdir} -I ${includedir} -T ${TERMCAP_LIB}`
! 	echo "$ac_t""$_rl_version" 1>&6
  
! 	case "$_rl_version" in
  	4.[2-9]*|5*|6*|7*|8*|9*)	;;
! 	*)	opt_with_installed_readline=no 
! 		echo "configure: warning: installed readline library is too old to be linked with bash" 1>&2
! 		echo "configure: warning: using private bash version" 1>&2
  		;;
  	esac
- 	unset _rl_version _rl_prefix _rl_exec_prefix
  fi
  
  if test $opt_readline = yes; then
! 	cat >> confdefs.h <<\EOF
  #define READLINE 1
  EOF
  
  	READLINE_LIB=-lreadline
! 	if test "$opt_with_installed_readline" = "yes" ; then
! 		RL_LIBDIR='$(libdir)'
  		READLINE_DEP=
- 		RL_INCLUDE='-I$(includedir)'
  	else
  		RL_LIBDIR='$(dot)/$(LIBSUBDIR)/readline'
--- 3132,3292 ----
  fi
  
! echo "$as_me:3134: checking version of installed readline library" >&5
! echo $ECHO_N "checking version of installed readline library... $ECHO_C" >&6
! 
! # What a pain in the ass this is.
! 
! # save cpp and ld options
! _save_CFLAGS="$CFLAGS"
! _save_LDFLAGS="$LDFLAGS"
! _save_LIBS="$LIBS"
! 
! # Don't set ac_cv_rl_prefix if the caller has already assigned a value.  This
! # allows the caller to do something like $_rl_prefix=$withval if the user
! # specifies --with-installed-readline=PREFIX as an argument to configure
! 
! if test -z "$ac_cv_rl_prefix"; then
! test "x$prefix" = xNONE && ac_cv_rl_prefix=$ac_default_prefix || ac_cv_rl_prefix=${prefix}
! fi
! 
! eval ac_cv_rl_includedir=${ac_cv_rl_prefix}/include
! eval ac_cv_rl_libdir=${ac_cv_rl_prefix}/lib
! 
! LIBS="$LIBS -lreadline ${TERMCAP_LIB}"
! CFLAGS="$CFLAGS -I${ac_cv_rl_includedir}"
! LDFLAGS="$LDFLAGS -L${ac_cv_rl_libdir}"
  
! if test "$cross_compiling" = yes; then
!   ac_cv_rl_version='4.2'
! else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 3163 "configure"
! #include "confdefs.h"
! 
! #include <stdio.h>
! #include <readline/readline.h>
! 
! main()
! {
! 	FILE *fp;
! 	fp = fopen("conftest.rlv", "w");
! 	if (fp == 0) exit(1);
! 	fprintf(fp, "%s\n", rl_library_version ? rl_library_version : "0.0");
! 	fclose(fp);
! 	exit(0);
! }
! 
! _ACEOF
! rm -f conftest$ac_exeext
! if { (eval echo "$as_me:3181: \"$ac_link\"") >&5
!   (eval $ac_link) 2>&5
!   ac_status=$?
!   echo "$as_me:3184: \$? = $ac_status" >&5
!   (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
!   { (eval echo "$as_me:3186: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:3189: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   ac_cv_rl_version=`cat conftest.rlv`
! else
!   echo "$as_me: program exited with status $ac_status" >&5
! echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! ac_cv_rl_version='0.0'
! fi
! rm -f core core.* *.core conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
! fi
! 
! CFLAGS="$_save_CFLAGS"
! LDFLAGS="$_save_LDFLAGS"
! LIBS="$_save_LIBS"
! 
! RL_MAJOR=0
! RL_MINOR=0
! 
! # (
! case "$ac_cv_rl_version" in
! 2*|3*|4*|5*|6*|7*|8*|9*)
! 	RL_MAJOR=`echo $ac_cv_rl_version | sed 's:\..*$::'`
! 	RL_MINOR=`echo $ac_cv_rl_version | sed -e 's:^.*\.::' -e 's:a-zA-Z*$::'`
! 	;;
! esac
! 
! # (((
! case $RL_MAJOR in
! [0-9][0-9])	_RL_MAJOR=$RL_MAJOR ;;
! [0-9])	_RL_MAJOR=0$RL_MAJOR ;;
! *)		_RL_MAJOR=00 ;;
! esac
! 
! # (((
! case $RL_MINOR in
! [0-9][0-9])	_RL_MINOR=$RL_MINOR ;;
! [0-9])	_RL_MINOR=0$RL_MINOR ;;
! *)		_RL_MINOR=00 ;;
! esac
! 
! RL_VERSION="0x${_RL_MAJOR}${_RL_MINOR}"
! 
! # Readline versions greater than 4.2 have these defines in readline.h
  
! if test $ac_cv_rl_version = '0.0' ; then
! 	{ echo "$as_me:3235: WARNING: Could not test version of installed readline library." >&5
! echo "$as_me: WARNING: Could not test version of installed readline library." >&2;}
! elif test $RL_MAJOR -gt 4 || { test $RL_MAJOR = 4 && test $RL_MINOR -gt 2 ; } ; then
! 	# set these for use by the caller
! 	RL_PREFIX=$ac_cv_rl_prefix
! 	RL_LIBDIR=$ac_cv_rl_libdir
! 	RL_INCLUDEDIR=$ac_cv_rl_includedir
! 	echo "$as_me:3242: result: $ac_cv_rl_version" >&5
! echo "${ECHO_T}$ac_cv_rl_version" >&6
! else
! 
! cat >>confdefs.h <<EOF
! #define RL_READLINE_VERSION $RL_VERSION
! EOF
! 
! cat >>confdefs.h <<EOF
! #define RL_VERSION_MAJOR $RL_MAJOR
! EOF
! 
! cat >>confdefs.h <<EOF
! #define RL_VERSION_MINOR $RL_MINOR
! EOF
! 
! # set these for use by the caller
! RL_PREFIX=$ac_cv_rl_prefix
! RL_LIBDIR=$ac_cv_rl_libdir
! RL_INCLUDEDIR=$ac_cv_rl_includedir
  
! echo "$as_me:3263: result: $ac_cv_rl_version" >&5
! echo "${ECHO_T}$ac_cv_rl_version" >&6
! 
! fi
! 
! 	case "$ac_cv_rl_version" in
  	4.[2-9]*|5*|6*|7*|8*|9*)	;;
! 	*)	opt_with_installed_readline=no
! 		{ echo "$as_me:3271: WARNING: installed readline library is too old to be linked with bash" >&5
! echo "$as_me: WARNING: installed readline library is too old to be linked with bash" >&2;}
! 		{ echo "$as_me:3273: WARNING: using private bash version" >&5
! echo "$as_me: WARNING: using private bash version" >&2;}
  		;;
  	esac
  fi
  
  if test $opt_readline = yes; then
! 	cat >>confdefs.h <<\EOF
  #define READLINE 1
  EOF
  
  	READLINE_LIB=-lreadline
! 	if test "$opt_with_installed_readline" != "no" ; then
! 		case "$RL_INCLUDEDIR" in
! 		/usr/include)	;;
! 		*)		RL_INCLUDE='-I${RL_INCLUDEDIR}'
! 		esac
  		READLINE_DEP=
  	else
  		RL_LIBDIR='$(dot)/$(LIBSUBDIR)/readline'
***************
*** 2001,2005 ****
  if test $opt_history = yes || test $opt_bang_history = yes; then
  	if test $opt_history = yes; then
! 		cat >> confdefs.h <<\EOF
  #define HISTORY 1
  EOF
--- 3299,3303 ----
  if test $opt_history = yes || test $opt_bang_history = yes; then
  	if test $opt_history = yes; then
! 		cat >>confdefs.h <<\EOF
  #define HISTORY 1
  EOF
***************
*** 2007,2011 ****
  	fi
  	if test $opt_bang_history = yes; then
! 		cat >> confdefs.h <<\EOF
  #define BANG_HISTORY 1
  EOF
--- 3305,3309 ----
  	fi
  	if test $opt_bang_history = yes; then
! 		cat >>confdefs.h <<\EOF
  #define BANG_HISTORY 1
  EOF
***************
*** 2013,2020 ****
  	fi
  	HISTORY_LIB=-lhistory
!  	if test "$opt_with_installed_readline" = "yes"; then
! 		HIST_LIBDIR='$(libdir)'
  		HISTORY_DEP=
! 		RL_INCLUDE='-I$(includedir)'
  	else
  		HIST_LIBDIR='$(dot)/$(LIBSUBDIR)/readline'
--- 3311,3321 ----
  	fi
  	HISTORY_LIB=-lhistory
!  	if test "$opt_with_installed_readline" != "no"; then
! 		HIST_LIBDIR=$RL_LIBDIR
  		HISTORY_DEP=
! 		case "$RL_INCLUDEDIR" in
! 		/usr/include)	;;
! 		*)		RL_INCLUDE='-I${RL_INCLUDEDIR}'
! 		esac
  	else
  		HIST_LIBDIR='$(dot)/$(LIBSUBDIR)/readline'
***************
*** 2026,2037 ****
  fi
  
- 
- 
- 
- 
- 
- 
- 
- 
  # Find a good install program.  We prefer a C program (faster),
  # so one script is as good as another.  But avoid the broken or
--- 3327,3330 ----
***************
*** 2041,2059 ****
  # IRIX /sbin/install
  # AIX /bin/install
  # AIX 4 /usr/bin/installbsd, which doesn't work without a -g flag
  # AFS /usr/afsws/bin/install, which mishandles nonexistent args
  # SVR4 /usr/ucb/install, which tries to use the nonexistent group "staff"
  # ./install, which can be erroneously created by make from ./install.sh.
! echo $ac_n "checking for a BSD compatible install""... $ac_c" 1>&6
! echo "configure:2049: checking for a BSD compatible install" >&5
  if test -z "$INSTALL"; then
! if eval "test \"`echo '$''{'ac_cv_path_install'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
!     IFS="${IFS= 	}"; ac_save_IFS="$IFS"; IFS=":"
    for ac_dir in $PATH; do
      # Account for people who put trailing slashes in PATH elements.
!     case "$ac_dir/" in
!     /|./|.//|/etc/*|/usr/sbin/*|/usr/etc/*|/sbin/*|/usr/afsws/bin/*|/usr/ucb/*) ;;
      *)
        # OSF1 and SCO ODT 3.0 have their own names for install.
--- 3334,3356 ----
  # IRIX /sbin/install
  # AIX /bin/install
+ # AmigaOS /C/install, which installs bootblocks on floppy discs
  # AIX 4 /usr/bin/installbsd, which doesn't work without a -g flag
  # AFS /usr/afsws/bin/install, which mishandles nonexistent args
  # SVR4 /usr/ucb/install, which tries to use the nonexistent group "staff"
  # ./install, which can be erroneously created by make from ./install.sh.
! echo "$as_me:3341: checking for a BSD compatible install" >&5
! echo $ECHO_N "checking for a BSD compatible install... $ECHO_C" >&6
  if test -z "$INSTALL"; then
! if test "${ac_cv_path_install+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
!     ac_save_IFS=$IFS; IFS=$ac_path_separator
    for ac_dir in $PATH; do
+     IFS=$ac_save_IFS
      # Account for people who put trailing slashes in PATH elements.
!     case $ac_dir/ in
!     / | ./ | .// | /cC/* \
!     | /etc/* | /usr/sbin/* | /usr/etc/* | /sbin/* | /usr/afsws/bin/* \
!     | /usr/ucb/* ) ;;
      *)
        # OSF1 and SCO ODT 3.0 have their own names for install.
***************
*** 2061,2069 ****
        # by default.
        for ac_prog in ginstall scoinst install; do
!         if test -f $ac_dir/$ac_prog; then
  	  if test $ac_prog = install &&
!             grep dspmsg $ac_dir/$ac_prog >/dev/null 2>&1; then
  	    # AIX install.  It has an incompatible calling convention.
  	    :
  	  else
  	    ac_cv_path_install="$ac_dir/$ac_prog -c"
--- 3358,3370 ----
        # by default.
        for ac_prog in ginstall scoinst install; do
!         if $as_executable_p "$ac_dir/$ac_prog"; then
  	  if test $ac_prog = install &&
!             grep dspmsg "$ac_dir/$ac_prog" >/dev/null 2>&1; then
  	    # AIX install.  It has an incompatible calling convention.
  	    :
+ 	  elif test $ac_prog = install &&
+ 	    grep pwplus "$ac_dir/$ac_prog" >/dev/null 2>&1; then
+ 	    # program-specific install script used by HP pwplus--don't use.
+ 	    :
  	  else
  	    ac_cv_path_install="$ac_dir/$ac_prog -c"
***************
*** 2075,2083 ****
      esac
    done
-   IFS="$ac_save_IFS"
  
  fi
    if test "${ac_cv_path_install+set}" = set; then
!     INSTALL="$ac_cv_path_install"
    else
      # As a last resort, use the slow shell script.  We don't cache a
--- 3376,3383 ----
      esac
    done
  
  fi
    if test "${ac_cv_path_install+set}" = set; then
!     INSTALL=$ac_cv_path_install
    else
      # As a last resort, use the slow shell script.  We don't cache a
***************
*** 2085,2092 ****
      # break other packages using the cache if that directory is
      # removed, or if the path is relative.
!     INSTALL="$ac_install_sh"
    fi
  fi
! echo "$ac_t""$INSTALL" 1>&6
  
  # Use test -z because SunOS4 sh mishandles braces in ${var-val}.
--- 3385,3393 ----
      # break other packages using the cache if that directory is
      # removed, or if the path is relative.
!     INSTALL=$ac_install_sh
    fi
  fi
! echo "$as_me:3390: result: $INSTALL" >&5
! echo "${ECHO_T}$INSTALL" >&6
  
  # Use test -z because SunOS4 sh mishandles braces in ${var-val}.
***************
*** 2094,2098 ****
  test -z "$INSTALL_PROGRAM" && INSTALL_PROGRAM='${INSTALL}'
  
! test -z "$INSTALL_SCRIPT" && INSTALL_SCRIPT='${INSTALL_PROGRAM}'
  
  test -z "$INSTALL_DATA" && INSTALL_DATA='${INSTALL} -m 644'
--- 3395,3399 ----
  test -z "$INSTALL_PROGRAM" && INSTALL_PROGRAM='${INSTALL}'
  
! test -z "$INSTALL_SCRIPT" && INSTALL_SCRIPT='${INSTALL}'
  
  test -z "$INSTALL_DATA" && INSTALL_DATA='${INSTALL} -m 644'
***************
*** 2100,2208 ****
  # Extract the first word of "ar", so it can be a program name with args.
  set dummy ar; ac_word=$2
! echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
! echo "configure:2104: checking for $ac_word" >&5
! if eval "test \"`echo '$''{'ac_cv_prog_AR'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
    if test -n "$AR"; then
    ac_cv_prog_AR="$AR" # Let the user override the test.
  else
!   IFS="${IFS= 	}"; ac_save_ifs="$IFS"; IFS=":"
!   ac_dummy="$PATH"
!   for ac_dir in $ac_dummy; do
!     test -z "$ac_dir" && ac_dir=.
!     if test -f $ac_dir/$ac_word; then
!       ac_cv_prog_AR="ar"
!       break
!     fi
!   done
!   IFS="$ac_save_ifs"
  fi
  fi
! AR="$ac_cv_prog_AR"
  if test -n "$AR"; then
!   echo "$ac_t""$AR" 1>&6
  else
!   echo "$ac_t""no" 1>&6
  fi
  
  test -n "$ARFLAGS" || ARFLAGS="cr"
! # Extract the first word of "ranlib", so it can be a program name with args.
! set dummy ranlib; ac_word=$2
! echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
! echo "configure:2134: checking for $ac_word" >&5
! if eval "test \"`echo '$''{'ac_cv_prog_RANLIB'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
    if test -n "$RANLIB"; then
    ac_cv_prog_RANLIB="$RANLIB" # Let the user override the test.
  else
!   IFS="${IFS= 	}"; ac_save_ifs="$IFS"; IFS=":"
!   ac_dummy="$PATH"
!   for ac_dir in $ac_dummy; do
!     test -z "$ac_dir" && ac_dir=.
!     if test -f $ac_dir/$ac_word; then
!       ac_cv_prog_RANLIB="ranlib"
!       break
!     fi
!   done
!   IFS="$ac_save_ifs"
!   test -z "$ac_cv_prog_RANLIB" && ac_cv_prog_RANLIB=":"
  fi
  fi
! RANLIB="$ac_cv_prog_RANLIB"
  if test -n "$RANLIB"; then
!   echo "$ac_t""$RANLIB" 1>&6
  else
!   echo "$ac_t""no" 1>&6
  fi
  
  for ac_prog in 'bison -y' byacc
  do
! # Extract the first word of "$ac_prog", so it can be a program name with args.
  set dummy $ac_prog; ac_word=$2
! echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
! echo "configure:2166: checking for $ac_word" >&5
! if eval "test \"`echo '$''{'ac_cv_prog_YACC'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
    if test -n "$YACC"; then
    ac_cv_prog_YACC="$YACC" # Let the user override the test.
  else
!   IFS="${IFS= 	}"; ac_save_ifs="$IFS"; IFS=":"
!   ac_dummy="$PATH"
!   for ac_dir in $ac_dummy; do
!     test -z "$ac_dir" && ac_dir=.
!     if test -f $ac_dir/$ac_word; then
!       ac_cv_prog_YACC="$ac_prog"
!       break
!     fi
!   done
!   IFS="$ac_save_ifs"
  fi
  fi
! YACC="$ac_cv_prog_YACC"
  if test -n "$YACC"; then
!   echo "$ac_t""$YACC" 1>&6
  else
!   echo "$ac_t""no" 1>&6
  fi
  
! test -n "$YACC" && break
  done
  test -n "$YACC" || YACC="yacc"
  
! echo $ac_n "checking whether ${MAKE-make} sets \${MAKE}""... $ac_c" 1>&6
! echo "configure:2197: checking whether ${MAKE-make} sets \${MAKE}" >&5
! set dummy ${MAKE-make}; ac_make=`echo "$2" | sed 'y%./+-%__p_%'`
! if eval "test \"`echo '$''{'ac_cv_prog_make_${ac_make}_set'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
!   cat > conftestmake <<\EOF
  all:
  	@echo 'ac_maketemp="${MAKE}"'
  EOF
  # GNU make sometimes prints "make[1]: Entering...", which would confuse us.
! eval `${MAKE-make} -f conftestmake 2>/dev/null | grep temp=`
  if test -n "$ac_maketemp"; then
    eval ac_cv_prog_make_${ac_make}_set=yes
--- 3401,3560 ----
  # Extract the first word of "ar", so it can be a program name with args.
  set dummy ar; ac_word=$2
! echo "$as_me:3403: checking for $ac_word" >&5
! echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
! if test "${ac_cv_prog_AR+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
    if test -n "$AR"; then
    ac_cv_prog_AR="$AR" # Let the user override the test.
  else
!   ac_save_IFS=$IFS; IFS=$ac_path_separator
! ac_dummy="$PATH"
! for ac_dir in $ac_dummy; do
!   IFS=$ac_save_IFS
!   test -z "$ac_dir" && ac_dir=.
!   $as_executable_p "$ac_dir/$ac_word" || continue
! ac_cv_prog_AR=""
! echo "$as_me:3418: found $ac_dir/$ac_word" >&5
! break
! done
! 
!   test -z "$ac_cv_prog_AR" && ac_cv_prog_AR="ar"
  fi
  fi
! AR=$ac_cv_prog_AR
  if test -n "$AR"; then
!   echo "$as_me:3427: result: $AR" >&5
! echo "${ECHO_T}$AR" >&6
  else
!   echo "$as_me:3430: result: no" >&5
! echo "${ECHO_T}no" >&6
  fi
  
  test -n "$ARFLAGS" || ARFLAGS="cr"
! if test -n "$ac_tool_prefix"; then
!   # Extract the first word of "${ac_tool_prefix}ranlib", so it can be a program name with args.
! set dummy ${ac_tool_prefix}ranlib; ac_word=$2
! echo "$as_me:3438: checking for $ac_word" >&5
! echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
! if test "${ac_cv_prog_RANLIB+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
    if test -n "$RANLIB"; then
    ac_cv_prog_RANLIB="$RANLIB" # Let the user override the test.
  else
!   ac_save_IFS=$IFS; IFS=$ac_path_separator
! ac_dummy="$PATH"
! for ac_dir in $ac_dummy; do
!   IFS=$ac_save_IFS
!   test -z "$ac_dir" && ac_dir=.
!   $as_executable_p "$ac_dir/$ac_word" || continue
! ac_cv_prog_RANLIB="${ac_tool_prefix}ranlib"
! echo "$as_me:3453: found $ac_dir/$ac_word" >&5
! break
! done
! 
  fi
  fi
! RANLIB=$ac_cv_prog_RANLIB
  if test -n "$RANLIB"; then
!   echo "$as_me:3461: result: $RANLIB" >&5
! echo "${ECHO_T}$RANLIB" >&6
! else
!   echo "$as_me:3464: result: no" >&5
! echo "${ECHO_T}no" >&6
! fi
! 
! fi
! if test -z "$ac_cv_prog_RANLIB"; then
!   ac_ct_RANLIB=$RANLIB
!   # Extract the first word of "ranlib", so it can be a program name with args.
! set dummy ranlib; ac_word=$2
! echo "$as_me:3473: checking for $ac_word" >&5
! echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
! if test "${ac_cv_prog_ac_ct_RANLIB+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
! else
!   if test -n "$ac_ct_RANLIB"; then
!   ac_cv_prog_ac_ct_RANLIB="$ac_ct_RANLIB" # Let the user override the test.
! else
!   ac_save_IFS=$IFS; IFS=$ac_path_separator
! ac_dummy="$PATH"
! for ac_dir in $ac_dummy; do
!   IFS=$ac_save_IFS
!   test -z "$ac_dir" && ac_dir=.
!   $as_executable_p "$ac_dir/$ac_word" || continue
! ac_cv_prog_ac_ct_RANLIB="ranlib"
! echo "$as_me:3488: found $ac_dir/$ac_word" >&5
! break
! done
! 
!   test -z "$ac_cv_prog_ac_ct_RANLIB" && ac_cv_prog_ac_ct_RANLIB=":"
! fi
! fi
! ac_ct_RANLIB=$ac_cv_prog_ac_ct_RANLIB
! if test -n "$ac_ct_RANLIB"; then
!   echo "$as_me:3497: result: $ac_ct_RANLIB" >&5
! echo "${ECHO_T}$ac_ct_RANLIB" >&6
! else
!   echo "$as_me:3500: result: no" >&5
! echo "${ECHO_T}no" >&6
! fi
! 
!   RANLIB=$ac_ct_RANLIB
  else
!   RANLIB="$ac_cv_prog_RANLIB"
  fi
  
  for ac_prog in 'bison -y' byacc
  do
!   # Extract the first word of "$ac_prog", so it can be a program name with args.
  set dummy $ac_prog; ac_word=$2
! echo "$as_me:3513: checking for $ac_word" >&5
! echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
! if test "${ac_cv_prog_YACC+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
    if test -n "$YACC"; then
    ac_cv_prog_YACC="$YACC" # Let the user override the test.
  else
!   ac_save_IFS=$IFS; IFS=$ac_path_separator
! ac_dummy="$PATH"
! for ac_dir in $ac_dummy; do
!   IFS=$ac_save_IFS
!   test -z "$ac_dir" && ac_dir=.
!   $as_executable_p "$ac_dir/$ac_word" || continue
! ac_cv_prog_YACC="$ac_prog"
! echo "$as_me:3528: found $ac_dir/$ac_word" >&5
! break
! done
! 
  fi
  fi
! YACC=$ac_cv_prog_YACC
  if test -n "$YACC"; then
!   echo "$as_me:3536: result: $YACC" >&5
! echo "${ECHO_T}$YACC" >&6
  else
!   echo "$as_me:3539: result: no" >&5
! echo "${ECHO_T}no" >&6
  fi
  
!   test -n "$YACC" && break
  done
  test -n "$YACC" || YACC="yacc"
  
! echo "$as_me:3547: checking whether ${MAKE-make} sets \${MAKE}" >&5
! echo $ECHO_N "checking whether ${MAKE-make} sets \${MAKE}... $ECHO_C" >&6
! set dummy ${MAKE-make}; ac_make=`echo "$2" | sed 'y,./+-,__p_,'`
! if eval "test \"\${ac_cv_prog_make_${ac_make}_set+set}\" = set"; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
!   cat >conftest.make <<\EOF
  all:
  	@echo 'ac_maketemp="${MAKE}"'
  EOF
  # GNU make sometimes prints "make[1]: Entering...", which would confuse us.
! eval `${MAKE-make} -f conftest.make 2>/dev/null | grep temp=`
  if test -n "$ac_maketemp"; then
    eval ac_cv_prog_make_${ac_make}_set=yes
***************
*** 2210,2224 ****
    eval ac_cv_prog_make_${ac_make}_set=no
  fi
! rm -f conftestmake
  fi
  if eval "test \"`echo '$ac_cv_prog_make_'${ac_make}_set`\" = yes"; then
!   echo "$ac_t""yes" 1>&6
    SET_MAKE=
  else
!   echo "$ac_t""no" 1>&6
    SET_MAKE="MAKE=${MAKE-make}"
  fi
  
- 
  case "$host_os" in
  opennt*|interix*)	MAKE_SHELL="$INTERIX_ROOT/bin/sh" ;;
--- 3562,3577 ----
    eval ac_cv_prog_make_${ac_make}_set=no
  fi
! rm -f conftest.make
  fi
  if eval "test \"`echo '$ac_cv_prog_make_'${ac_make}_set`\" = yes"; then
!   echo "$as_me:3567: result: yes" >&5
! echo "${ECHO_T}yes" >&6
    SET_MAKE=
  else
!   echo "$as_me:3571: result: no" >&5
! echo "${ECHO_T}no" >&6
    SET_MAKE="MAKE=${MAKE-make}"
  fi
  
  case "$host_os" in
  opennt*|interix*)	MAKE_SHELL="$INTERIX_ROOT/bin/sh" ;;
***************
*** 2226,3054 ****
  esac
  
  
! # The Ultrix 4.2 mips builtin alloca declared by alloca.h only works
! # for constant arguments.  Useless!
! echo $ac_n "checking for working alloca.h""... $ac_c" 1>&6
! echo "configure:2233: checking for working alloca.h" >&5
! if eval "test \"`echo '$''{'ac_cv_header_alloca_h'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
! else
!   cat > conftest.$ac_ext <<EOF
! #line 2238 "configure"
  #include "confdefs.h"
! #include <alloca.h>
! int main() {
! char *p = alloca(2 * sizeof(int));
! ; return 0; }
! EOF
! if { (eval echo configure:2245: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
!   rm -rf conftest*
!   ac_cv_header_alloca_h=yes
  else
!   echo "configure: failed program was:" >&5
!   cat conftest.$ac_ext >&5
!   rm -rf conftest*
!   ac_cv_header_alloca_h=no
! fi
! rm -f conftest*
  fi
! 
! echo "$ac_t""$ac_cv_header_alloca_h" 1>&6
! if test $ac_cv_header_alloca_h = yes; then
!   cat >> confdefs.h <<\EOF
! #define HAVE_ALLOCA_H 1
! EOF
  
  fi
  
! echo $ac_n "checking for alloca""... $ac_c" 1>&6
! echo "configure:2266: checking for alloca" >&5
! if eval "test \"`echo '$''{'ac_cv_func_alloca_works'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
!   cat > conftest.$ac_ext <<EOF
! #line 2271 "configure"
  #include "confdefs.h"
  
! #ifdef __GNUC__
! # define alloca __builtin_alloca
! #else
! # ifdef _MSC_VER
! #  include <malloc.h>
! #  define alloca _alloca
! # else
! #  if HAVE_ALLOCA_H
! #   include <alloca.h>
! #  else
! #   ifdef _AIX
!  #pragma alloca
! #   else
! #    ifndef alloca /* predefined by HP cc +Olibcalls */
! char *alloca ();
! #    endif
! #   endif
! #  endif
! # endif
  #endif
  
! int main() {
! char *p = (char *) alloca(1);
! ; return 0; }
! EOF
! if { (eval echo configure:2299: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
!   rm -rf conftest*
!   ac_cv_func_alloca_works=yes
! else
!   echo "configure: failed program was:" >&5
!   cat conftest.$ac_ext >&5
!   rm -rf conftest*
!   ac_cv_func_alloca_works=no
! fi
! rm -f conftest*
! fi
  
! echo "$ac_t""$ac_cv_func_alloca_works" 1>&6
! if test $ac_cv_func_alloca_works = yes; then
!   cat >> confdefs.h <<\EOF
! #define HAVE_ALLOCA 1
  EOF
  
  fi
  
! if test $ac_cv_func_alloca_works = no; then
!   # The SVR3 libPW and SVR4 libucb both contain incompatible functions
!   # that cause trouble.  Some versions do not even contain alloca or
!   # contain a buggy version.  If you still want to use their alloca,
!   # use ar to extract alloca.o from them instead of compiling alloca.c.
!   ALLOCA=alloca.${ac_objext}
!   cat >> confdefs.h <<\EOF
! #define C_ALLOCA 1
! EOF
  
  
! echo $ac_n "checking whether alloca needs Cray hooks""... $ac_c" 1>&6
! echo "configure:2331: checking whether alloca needs Cray hooks" >&5
! if eval "test \"`echo '$''{'ac_cv_os_cray'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
!   cat > conftest.$ac_ext <<EOF
! #line 2336 "configure"
  #include "confdefs.h"
! #if defined(CRAY) && ! defined(CRAY2)
! webecray
! #else
! wenotbecray
  #endif
  
! EOF
! if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
!   egrep "webecray" >/dev/null 2>&1; then
!   rm -rf conftest*
!   ac_cv_os_cray=yes
  else
!   rm -rf conftest*
!   ac_cv_os_cray=no
  fi
! rm -f conftest*
! 
  fi
! 
! echo "$ac_t""$ac_cv_os_cray" 1>&6
! if test $ac_cv_os_cray = yes; then
! for ac_func in _getb67 GETB67 getb67; do
!   echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
! echo "configure:2361: checking for $ac_func" >&5
! if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
!   cat > conftest.$ac_ext <<EOF
! #line 2366 "configure"
  #include "confdefs.h"
! /* System header to define __stub macros and hopefully few prototypes,
!     which can conflict with char $ac_func(); below.  */
! #include <assert.h>
! /* Override any gcc2 internal prototype to avoid an error.  */
! /* We use char because int might match the return type of a gcc2
!     builtin and then its argument prototype would still apply.  */
! char $ac_func();
  
! int main() {
  
! /* The GNU C library defines this for functions which it implements
!     to always fail with ENOSYS.  Some functions are actually named
!     something starting with __ and the normal name is an alias.  */
! #if defined (__stub_$ac_func) || defined (__stub___$ac_func)
! choke me
! #else
! $ac_func();
! #endif
  
! ; return 0; }
! EOF
! if { (eval echo configure:2389: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
!   rm -rf conftest*
!   eval "ac_cv_func_$ac_func=yes"
  else
!   echo "configure: failed program was:" >&5
!   cat conftest.$ac_ext >&5
!   rm -rf conftest*
!   eval "ac_cv_func_$ac_func=no"
  fi
  rm -f conftest*
  fi
  
! if eval "test \"`echo '$ac_cv_func_'$ac_func`\" = yes"; then
!   echo "$ac_t""yes" 1>&6
!   cat >> confdefs.h <<EOF
! #define CRAY_STACKSEG_END $ac_func
  EOF
  
-   break
- else
-   echo "$ac_t""no" 1>&6
  fi
  
! done
! fi
! 
! echo $ac_n "checking stack direction for C alloca""... $ac_c" 1>&6
! echo "configure:2416: checking stack direction for C alloca" >&5
! if eval "test \"`echo '$''{'ac_cv_c_stack_direction'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
!   if test "$cross_compiling" = yes; then
!   ac_cv_c_stack_direction=0
  else
!   cat > conftest.$ac_ext <<EOF
! #line 2424 "configure"
  #include "confdefs.h"
! find_stack_direction ()
! {
!   static char *addr = 0;
!   auto char dummy;
!   if (addr == 0)
!     {
!       addr = &dummy;
!       return find_stack_direction ();
!     }
!   else
!     return (&dummy > addr) ? 1 : -1;
! }
  main ()
  {
!   exit (find_stack_direction() < 0);
  }
! EOF
! if { (eval echo configure:2443: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
! then
!   ac_cv_c_stack_direction=1
  else
!   echo "configure: failed program was:" >&5
!   cat conftest.$ac_ext >&5
!   rm -fr conftest*
!   ac_cv_c_stack_direction=-1
  fi
- rm -fr conftest*
  fi
- 
  fi
  
! echo "$ac_t""$ac_cv_c_stack_direction" 1>&6
! cat >> confdefs.h <<EOF
! #define STACK_DIRECTION $ac_cv_c_stack_direction
  EOF
  
  fi
  
! echo $ac_n "checking whether getpgrp takes no argument""... $ac_c" 1>&6
! echo "configure:2465: checking whether getpgrp takes no argument" >&5
! if eval "test \"`echo '$''{'ac_cv_func_getpgrp_void'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
!   if test "$cross_compiling" = yes; then
!   { echo "configure: error: cannot check getpgrp if cross compiling" 1>&2; exit 1; }
  else
!   cat > conftest.$ac_ext <<EOF
! #line 2473 "configure"
  #include "confdefs.h"
  
! /*
!  * If this system has a BSD-style getpgrp(),
!  * which takes a pid argument, exit unsuccessfully.
!  *
!  * Snarfed from Chet Ramey's bash pgrp.c test program
!  */
! #include <stdio.h>
! #include <sys/types.h>
! 
! int     pid;
! int     pg1, pg2, pg3, pg4;
! int     ng, np, s, child;
  
! main()
! {
!         pid = getpid();
!         pg1 = getpgrp(0);
!         pg2 = getpgrp();
!         pg3 = getpgrp(pid);
!         pg4 = getpgrp(1);
! 
!         /*
!          * If all of these values are the same, it's pretty sure that
!          * we're on a system that ignores getpgrp's first argument.
!          */
!         if (pg2 == pg4 && pg1 == pg3 && pg2 == pg3)
!                 exit(0);
! 
!         child = fork();
!         if (child < 0)
!                 exit(1);
!         else if (child == 0) {
!                 np = getpid();
!                 /*
!                  * If this is Sys V, this will not work; pgrp will be
!                  * set to np because setpgrp just changes a pgrp to be
!                  * the same as the pid.
!                  */
!                 setpgrp(np, pg1);
!                 ng = getpgrp(0);        /* Same result for Sys V and BSD */
!                 if (ng == pg1) {
!                         exit(1);
!                 } else {
!                         exit(0);
!                 }
!         } else {
!                 wait(&s);
!                 exit(s>>8);
!         }
! }
  
! EOF
! if { (eval echo configure:2528: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
! then
!   ac_cv_func_getpgrp_void=yes
  else
!   echo "configure: failed program was:" >&5
!   cat conftest.$ac_ext >&5
!   rm -fr conftest*
!   ac_cv_func_getpgrp_void=no
  fi
! rm -fr conftest*
  fi
  
  
  fi
! 
! echo "$ac_t""$ac_cv_func_getpgrp_void" 1>&6
! if test $ac_cv_func_getpgrp_void = yes; then
!   cat >> confdefs.h <<\EOF
! #define GETPGRP_VOID 1
! EOF
  
  fi
  
! echo $ac_n "checking whether setvbuf arguments are reversed""... $ac_c" 1>&6
! echo "configure:2552: checking whether setvbuf arguments are reversed" >&5
! if eval "test \"`echo '$''{'ac_cv_func_setvbuf_reversed'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
! else
    if test "$cross_compiling" = yes; then
!     { echo "configure: error: can not run test program while cross compiling" 1>&2; exit 1; }
  else
!   cat > conftest.$ac_ext <<EOF
! #line 2560 "configure"
  #include "confdefs.h"
! #include <stdio.h>
! /* If setvbuf has the reversed format, exit 0. */
! main () {
!   /* This call has the arguments reversed.
!      A reversed system may check and see that the address of main
!      is not _IOLBF, _IONBF, or _IOFBF, and return nonzero.  */
!   if (setvbuf(stdout, _IOLBF, (char *) main, BUFSIZ) != 0)
!     exit(1);
!   putc('\r', stdout);
!   exit(0);			/* Non-reversed systems segv here.  */
! }
! EOF
! if { (eval echo configure:2574: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
! then
!   ac_cv_func_setvbuf_reversed=yes
  else
!   echo "configure: failed program was:" >&5
!   cat conftest.$ac_ext >&5
!   rm -fr conftest*
!   ac_cv_func_setvbuf_reversed=no
  fi
- rm -fr conftest*
  fi
  
- rm -f core core.* *.core
  fi
  
! echo "$ac_t""$ac_cv_func_setvbuf_reversed" 1>&6
! if test $ac_cv_func_setvbuf_reversed = yes; then
!   cat >> confdefs.h <<\EOF
! #define SETVBUF_REVERSED 1
  EOF
  
  fi
  
! echo $ac_n "checking for vprintf""... $ac_c" 1>&6
! echo "configure:2598: checking for vprintf" >&5
! if eval "test \"`echo '$''{'ac_cv_func_vprintf'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
!   cat > conftest.$ac_ext <<EOF
! #line 2603 "configure"
  #include "confdefs.h"
! /* System header to define __stub macros and hopefully few prototypes,
!     which can conflict with char vprintf(); below.  */
! #include <assert.h>
! /* Override any gcc2 internal prototype to avoid an error.  */
! /* We use char because int might match the return type of a gcc2
!     builtin and then its argument prototype would still apply.  */
! char vprintf();
! 
! int main() {
  
! /* The GNU C library defines this for functions which it implements
!     to always fail with ENOSYS.  Some functions are actually named
!     something starting with __ and the normal name is an alias.  */
! #if defined (__stub_vprintf) || defined (__stub___vprintf)
! choke me
! #else
! vprintf();
! #endif
  
! ; return 0; }
! EOF
! if { (eval echo configure:2626: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
!   rm -rf conftest*
!   eval "ac_cv_func_vprintf=yes"
  else
!   echo "configure: failed program was:" >&5
!   cat conftest.$ac_ext >&5
!   rm -rf conftest*
!   eval "ac_cv_func_vprintf=no"
! fi
! rm -f conftest*
! fi
  
! if eval "test \"`echo '$ac_cv_func_'vprintf`\" = yes"; then
!   echo "$ac_t""yes" 1>&6
!   cat >> confdefs.h <<\EOF
! #define HAVE_VPRINTF 1
  EOF
  
! else
!   echo "$ac_t""no" 1>&6
  fi
  
! if test "$ac_cv_func_vprintf" != yes; then
! echo $ac_n "checking for _doprnt""... $ac_c" 1>&6
! echo "configure:2650: checking for _doprnt" >&5
! if eval "test \"`echo '$''{'ac_cv_func__doprnt'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
!   cat > conftest.$ac_ext <<EOF
! #line 2655 "configure"
  #include "confdefs.h"
- /* System header to define __stub macros and hopefully few prototypes,
-     which can conflict with char _doprnt(); below.  */
- #include <assert.h>
- /* Override any gcc2 internal prototype to avoid an error.  */
- /* We use char because int might match the return type of a gcc2
-     builtin and then its argument prototype would still apply.  */
- char _doprnt();
- 
- int main() {
  
! /* The GNU C library defines this for functions which it implements
!     to always fail with ENOSYS.  Some functions are actually named
!     something starting with __ and the normal name is an alias.  */
! #if defined (__stub__doprnt) || defined (__stub____doprnt)
! choke me
! #else
! _doprnt();
  #endif
! 
! ; return 0; }
! EOF
! if { (eval echo configure:2678: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
!   rm -rf conftest*
!   eval "ac_cv_func__doprnt=yes"
! else
!   echo "configure: failed program was:" >&5
!   cat conftest.$ac_ext >&5
!   rm -rf conftest*
!   eval "ac_cv_func__doprnt=no"
! fi
! rm -f conftest*
  fi
  
- if eval "test \"`echo '$ac_cv_func_'_doprnt`\" = yes"; then
-   echo "$ac_t""yes" 1>&6
-   cat >> confdefs.h <<\EOF
- #define HAVE_DOPRNT 1
- EOF
- 
  else
!   echo "$ac_t""no" 1>&6
  fi
  
  fi
  
! echo $ac_n "checking for wait3 that fills in rusage""... $ac_c" 1>&6
! echo "configure:2703: checking for wait3 that fills in rusage" >&5
! if eval "test \"`echo '$''{'ac_cv_func_wait3_rusage'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
! else
!   if test "$cross_compiling" = yes; then
!   ac_cv_func_wait3_rusage=no
  else
!   cat > conftest.$ac_ext <<EOF
! #line 2711 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
  #include <sys/time.h>
! #include <sys/resource.h>
! #include <stdio.h>
! /* HP-UX has wait3 but does not fill in rusage at all.  */
! main() {
!   struct rusage r;
!   int i;
!   /* Use a field that we can force nonzero --
!      voluntary context switches.
!      For systems like NeXT and OSF/1 that don't set it,
!      also use the system CPU time.  And page faults (I/O) for Linux.  */
!   r.ru_nvcsw = 0;
!   r.ru_stime.tv_sec = 0;
!   r.ru_stime.tv_usec = 0;
!   r.ru_majflt = r.ru_minflt = 0;
!   switch (fork()) {
!   case 0: /* Child.  */
!     sleep(1); /* Give up the CPU.  */
!     _exit(0);
!   case -1: _exit(0); /* What can we do?  */
!   default: /* Parent.  */
!     wait3(&i, 0, &r);
!     sleep(2); /* Avoid "text file busy" from rm on fast HP-UX machines.  */
!     exit(r.ru_nvcsw == 0 && r.ru_majflt == 0 && r.ru_minflt == 0
! 	 && r.ru_stime.tv_sec == 0 && r.ru_stime.tv_usec == 0);
!   }
! }
! EOF
! if { (eval echo configure:2742: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
! then
!   ac_cv_func_wait3_rusage=yes
  else
!   echo "configure: failed program was:" >&5
!   cat conftest.$ac_ext >&5
!   rm -fr conftest*
!   ac_cv_func_wait3_rusage=no
  fi
! rm -fr conftest*
! fi
! 
  fi
  
! echo "$ac_t""$ac_cv_func_wait3_rusage" 1>&6
! if test $ac_cv_func_wait3_rusage = yes; then
!   cat >> confdefs.h <<\EOF
! #define HAVE_WAIT3 1
  EOF
  
  fi
  
! echo $ac_n "checking for working strcoll""... $ac_c" 1>&6
! echo "configure:2765: checking for working strcoll" >&5
! if eval "test \"`echo '$''{'ac_cv_func_strcoll_works'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
!   if test "$cross_compiling" = yes; then
!   ac_cv_func_strcoll_works=no
  else
!   cat > conftest.$ac_ext <<EOF
! #line 2773 "configure"
! #include "confdefs.h"
! #include <string.h>
! main ()
! {
!   exit (strcoll ("abc", "def") >= 0 ||
! 	strcoll ("ABC", "DEF") >= 0 ||
! 	strcoll ("123", "456") >= 0);
! }
  EOF
! if { (eval echo configure:2783: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
! then
!   ac_cv_func_strcoll_works=yes
  else
!   echo "configure: failed program was:" >&5
    cat conftest.$ac_ext >&5
!   rm -fr conftest*
!   ac_cv_func_strcoll_works=no
  fi
! rm -fr conftest*
  fi
  
  fi
  
! echo "$ac_t""$ac_cv_func_strcoll_works" 1>&6
! if test $ac_cv_func_strcoll_works = yes; then
!   cat >> confdefs.h <<\EOF
! #define HAVE_STRCOLL 1
  EOF
  
  fi
  
! 
! if test "$ac_cv_func_vprintf" = no; then
!     echo $ac_n "checking for declaration of vprintf in stdio.h""... $ac_c" 1>&6
! echo "configure:2808: checking for declaration of vprintf in stdio.h" >&5
!     cat > conftest.$ac_ext <<EOF
! #line 2810 "configure"
! #include "confdefs.h"
! #include <stdio.h>
  EOF
! if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
!   egrep "[int[ 	]*vprintf[^a-zA-Z0-9]]" >/dev/null 2>&1; then
!   rm -rf conftest*
!   ac_cv_func_vprintf=yes
  fi
! rm -f conftest*
  
!     echo "$ac_t""$ac_cv_func_vprintf" 1>&6
!     if test $ac_cv_func_vprintf = yes; then
! 	cat >> confdefs.h <<\EOF
! #define HAVE_VPRINTF 1
  EOF
  
-     fi
  fi
  
! echo $ac_n "checking return type of signal handlers""... $ac_c" 1>&6
! echo "configure:2831: checking return type of signal handlers" >&5
! if eval "test \"`echo '$''{'ac_cv_type_signal'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
!   cat > conftest.$ac_ext <<EOF
! #line 2836 "configure"
  #include "confdefs.h"
! #include <sys/types.h>
! #include <signal.h>
! #ifdef signal
! #undef signal
! #endif
! #ifdef __cplusplus
! extern "C" void (*signal (int, void (*)(int)))(int);
  #else
! void (*signal ()) ();
  #endif
  
! int main() {
! int i;
! ; return 0; }
! EOF
! if { (eval echo configure:2853: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
!   rm -rf conftest*
!   ac_cv_type_signal=void
  else
!   echo "configure: failed program was:" >&5
!   cat conftest.$ac_ext >&5
!   rm -rf conftest*
!   ac_cv_type_signal=int
  fi
! rm -f conftest*
  fi
  
! echo "$ac_t""$ac_cv_type_signal" 1>&6
! cat >> confdefs.h <<EOF
! #define RETSIGTYPE $ac_cv_type_signal
  EOF
  
  
  
! echo $ac_n "checking for __setostype""... $ac_c" 1>&6
! echo "configure:2873: checking for __setostype" >&5
! if eval "test \"`echo '$''{'ac_cv_func___setostype'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
!   cat > conftest.$ac_ext <<EOF
! #line 2878 "configure"
  #include "confdefs.h"
! /* System header to define __stub macros and hopefully few prototypes,
!     which can conflict with char __setostype(); below.  */
! #include <assert.h>
! /* Override any gcc2 internal prototype to avoid an error.  */
! /* We use char because int might match the return type of a gcc2
!     builtin and then its argument prototype would still apply.  */
! char __setostype();
! 
! int main() {
! 
! /* The GNU C library defines this for functions which it implements
!     to always fail with ENOSYS.  Some functions are actually named
!     something starting with __ and the normal name is an alias.  */
! #if defined (__stub___setostype) || defined (__stub_____setostype)
! choke me
  #else
! __setostype();
  #endif
  
! ; return 0; }
! EOF
! if { (eval echo configure:2901: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
!   rm -rf conftest*
!   eval "ac_cv_func___setostype=yes"
  else
!   echo "configure: failed program was:" >&5
!   cat conftest.$ac_ext >&5
!   rm -rf conftest*
!   eval "ac_cv_func___setostype=no"
  fi
  rm -f conftest*
- fi
- 
- if eval "test \"`echo '$ac_cv_func_'__setostype`\" = yes"; then
-   echo "$ac_t""yes" 1>&6
-   cat >> confdefs.h <<\EOF
- #define HAVE_SETOSTYPE 1
- EOF
  
- else
-   echo "$ac_t""no" 1>&6
  fi
! 
! echo $ac_n "checking for wait3""... $ac_c" 1>&6
! echo "configure:2924: checking for wait3" >&5
! if eval "test \"`echo '$''{'ac_cv_func_wait3'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
!   cat > conftest.$ac_ext <<EOF
! #line 2929 "configure"
  #include "confdefs.h"
  /* System header to define __stub macros and hopefully few prototypes,
!     which can conflict with char wait3(); below.  */
  #include <assert.h>
  /* Override any gcc2 internal prototype to avoid an error.  */
  /* We use char because int might match the return type of a gcc2
!     builtin and then its argument prototype would still apply.  */
! char wait3();
! 
! int main() {
  
  /* The GNU C library defines this for functions which it implements
      to always fail with ENOSYS.  Some functions are actually named
      something starting with __ and the normal name is an alias.  */
! #if defined (__stub_wait3) || defined (__stub___wait3)
  choke me
  #else
! wait3();
  #endif
  
! ; return 0; }
  EOF
! if { (eval echo configure:2952: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
!   rm -rf conftest*
!   eval "ac_cv_func_wait3=yes"
! else
!   echo "configure: failed program was:" >&5
!   cat conftest.$ac_ext >&5
!   rm -rf conftest*
!   eval "ac_cv_func_wait3=no"
  fi
! rm -f conftest*
  fi
  
! if eval "test \"`echo '$ac_cv_func_'wait3`\" = yes"; then
!   echo "$ac_t""yes" 1>&6
!   cat >> confdefs.h <<\EOF
! #define HAVE_WAIT3 1
! EOF
  
  else
!   echo "$ac_t""no" 1>&6
  fi
  
  
! echo $ac_n "checking for mkfifo""... $ac_c" 1>&6
! echo "configure:2976: checking for mkfifo" >&5
! if eval "test \"`echo '$''{'ac_cv_func_mkfifo'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
!   cat > conftest.$ac_ext <<EOF
! #line 2981 "configure"
  #include "confdefs.h"
! /* System header to define __stub macros and hopefully few prototypes,
!     which can conflict with char mkfifo(); below.  */
! #include <assert.h>
! /* Override any gcc2 internal prototype to avoid an error.  */
! /* We use char because int might match the return type of a gcc2
!     builtin and then its argument prototype would still apply.  */
! char mkfifo();
  
! int main() {
  
! /* The GNU C library defines this for functions which it implements
!     to always fail with ENOSYS.  Some functions are actually named
!     something starting with __ and the normal name is an alias.  */
! #if defined (__stub_mkfifo) || defined (__stub___mkfifo)
! choke me
! #else
! mkfifo();
! #endif
  
! ; return 0; }
! EOF
! if { (eval echo configure:3004: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
!   rm -rf conftest*
!   eval "ac_cv_func_mkfifo=yes"
  else
!   echo "configure: failed program was:" >&5
!   cat conftest.$ac_ext >&5
!   rm -rf conftest*
!   eval "ac_cv_func_mkfifo=no"
! fi
! rm -f conftest*
  fi
  
! if eval "test \"`echo '$ac_cv_func_'mkfifo`\" = yes"; then
!   echo "$ac_t""yes" 1>&6
!   cat >> confdefs.h <<\EOF
! #define HAVE_MKFIFO 1
  EOF
  
  else
!   echo "$ac_t""no" 1>&6
! cat >> confdefs.h <<\EOF
! #define MKFIFO_MISSING 1
  EOF
  
  fi
  
! 
! for ac_func in dup2 select getdtablesize getgroups gethostname \
! 		setdtablesize getpagesize killpg lstat getpeername sbrk \
! 		getrlimit getrusage gettimeofday waitpid tcgetpgrp \
! 		readlink rename
  do
! echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
! echo "configure:3037: checking for $ac_func" >&5
! if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
!   cat > conftest.$ac_ext <<EOF
! #line 3042 "configure"
  #include "confdefs.h"
  /* System header to define __stub macros and hopefully few prototypes,
!     which can conflict with char $ac_func(); below.  */
  #include <assert.h>
  /* Override any gcc2 internal prototype to avoid an error.  */
  /* We use char because int might match the return type of a gcc2
!     builtin and then its argument prototype would still apply.  */
! char $ac_func();
! 
! int main() {
  
  /* The GNU C library defines this for functions which it implements
      to always fail with ENOSYS.  Some functions are actually named
--- 3579,5238 ----
  esac
  
+ cat >>confdefs.h <<\EOF
+ #define _GNU_SOURCE 1
+ EOF
  
! echo "$as_me:3585: checking for $CC option to accept ANSI C" >&5
! echo $ECHO_N "checking for $CC option to accept ANSI C... $ECHO_C" >&6
! if test "${ac_cv_prog_cc_stdc+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
! else
!   ac_cv_prog_cc_stdc=no
! ac_save_CC=$CC
! cat >conftest.$ac_ext <<_ACEOF
! #line 3593 "configure"
  #include "confdefs.h"
! #include <stdarg.h>
! #include <stdio.h>
! #include <sys/types.h>
! #include <sys/stat.h>
! /* Most of the following tests are stolen from RCS 5.7's src/conf.sh.  */
! struct buf { int x; };
! FILE * (*rcsopen) (struct buf *, struct stat *, int);
! static char *e (p, i)
!      char **p;
!      int i;
! {
!   return p[i];
! }
! static char *f (char * (*g) (char **, int), char **p, ...)
! {
!   char *s;
!   va_list v;
!   va_start (v,p);
!   s = g (p, va_arg (v,int));
!   va_end (v);
!   return s;
! }
! int test (int i, double x);
! struct s1 {int (*f) (int a);};
! struct s2 {int (*f) (double a);};
! int pairnames (int, char **, FILE *(*)(struct buf *, struct stat *, int), int, int);
! int argc;
! char **argv;
! int
! main ()
! {
! return f (e, argv, 0) != argv[0]  ||  f (e, argv, 1) != argv[1];
!   ;
!   return 0;
! }
! _ACEOF
! # Don't try gcc -ansi; that turns off useful extensions and
! # breaks some systems' header files.
! # AIX			-qlanglvl=ansi
! # Ultrix and OSF/1	-std1
! # HP-UX 10.20 and later	-Ae
! # HP-UX older versions	-Aa -D_HPUX_SOURCE
! # SVR4			-Xc -D__EXTENSIONS__
! for ac_arg in "" -qlanglvl=ansi -std1 -Ae "-Aa -D_HPUX_SOURCE" "-Xc -D__EXTENSIONS__"
! do
!   CC="$ac_save_CC $ac_arg"
!   rm -f conftest.$ac_objext
! if { (eval echo "$as_me:3642: \"$ac_compile\"") >&5
!   (eval $ac_compile) 2>&5
!   ac_status=$?
!   echo "$as_me:3645: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest.$ac_objext'
!   { (eval echo "$as_me:3648: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:3651: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   ac_cv_prog_cc_stdc=$ac_arg
! break
  else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
  fi
! rm -f conftest.$ac_objext
! done
! rm -f conftest.$ac_ext conftest.$ac_objext
! CC=$ac_save_CC
  
  fi
  
! case "x$ac_cv_prog_cc_stdc" in
!   x|xno)
!     echo "$as_me:3668: result: none needed" >&5
! echo "${ECHO_T}none needed" >&6 ;;
!   *)
!     echo "$as_me:3671: result: $ac_cv_prog_cc_stdc" >&5
! echo "${ECHO_T}$ac_cv_prog_cc_stdc" >&6
!     CC="$CC $ac_cv_prog_cc_stdc" ;;
! esac
! 
! echo "$as_me:3676: checking for an ANSI C-conforming const" >&5
! echo $ECHO_N "checking for an ANSI C-conforming const... $ECHO_C" >&6
! if test "${ac_cv_c_const+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 3682 "configure"
  #include "confdefs.h"
  
! int
! main ()
! {
! /* FIXME: Include the comments suggested by Paul. */
! #ifndef __cplusplus
!   /* Ultrix mips cc rejects this.  */
!   typedef int charset[2];
!   const charset x;
!   /* SunOS 4.1.1 cc rejects this.  */
!   char const *const *ccp;
!   char **p;
!   /* NEC SVR4.0.2 mips cc rejects this.  */
!   struct point {int x, y;};
!   static struct point const zero = {0,0};
!   /* AIX XL C 1.02.0.0 rejects this.
!      It does not let you subtract one const X* pointer from another in
!      an arm of an if-expression whose if-part is not a constant
!      expression */
!   const char *g = "string";
!   ccp = &g + (g ? g-g : 0);
!   /* HPUX 7.0 cc rejects these. */
!   ++ccp;
!   p = (char**) ccp;
!   ccp = (char const *const *) p;
!   { /* SCO 3.2v4 cc rejects this.  */
!     char *t;
!     char const *s = 0 ? (char *) 0 : (char const *) 0;
! 
!     *t++ = 0;
!   }
!   { /* Someone thinks the Sun supposedly-ANSI compiler will reject this.  */
!     int x[] = {25, 17};
!     const int *foo = &x[0];
!     ++foo;
!   }
!   { /* Sun SC1.0 ANSI compiler rejects this -- but not the above. */
!     typedef const int *iptr;
!     iptr p = 0;
!     ++p;
!   }
!   { /* AIX XL C 1.02.0.0 rejects this saying
!        "k.c", line 2.27: 1506-025 (S) Operand must be a modifiable lvalue. */
!     struct s { int j; const int *ap[3]; };
!     struct s *b; b->j = 5;
!   }
!   { /* ULTRIX-32 V3.1 (Rev 9) vcc rejects this */
!     const int foo = 10;
!   }
  #endif
  
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext
! if { (eval echo "$as_me:3740: \"$ac_compile\"") >&5
!   (eval $ac_compile) 2>&5
!   ac_status=$?
!   echo "$as_me:3743: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest.$ac_objext'
!   { (eval echo "$as_me:3746: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:3749: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   ac_cv_c_const=yes
! else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! ac_cv_c_const=no
! fi
! rm -f conftest.$ac_objext conftest.$ac_ext
! fi
! echo "$as_me:3759: result: $ac_cv_c_const" >&5
! echo "${ECHO_T}$ac_cv_c_const" >&6
! if test $ac_cv_c_const = no; then
  
! cat >>confdefs.h <<\EOF
! #define const
  EOF
  
  fi
  
! echo "$as_me:3769: checking for inline" >&5
! echo $ECHO_N "checking for inline... $ECHO_C" >&6
! if test "${ac_cv_c_inline+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
! else
!   ac_cv_c_inline=no
! for ac_kw in inline __inline__ __inline; do
!   cat >conftest.$ac_ext <<_ACEOF
! #line 3777 "configure"
! #include "confdefs.h"
! #ifndef __cplusplus
! static $ac_kw int static_foo () {return 0; }
! $ac_kw int foo () {return 0; }
! #endif
! 
! _ACEOF
! rm -f conftest.$ac_objext
! if { (eval echo "$as_me:3786: \"$ac_compile\"") >&5
!   (eval $ac_compile) 2>&5
!   ac_status=$?
!   echo "$as_me:3789: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest.$ac_objext'
!   { (eval echo "$as_me:3792: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:3795: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   ac_cv_c_inline=$ac_kw; break
! else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! fi
! rm -f conftest.$ac_objext conftest.$ac_ext
! done
  
+ fi
+ echo "$as_me:3806: result: $ac_cv_c_inline" >&5
+ echo "${ECHO_T}$ac_cv_c_inline" >&6
+ case $ac_cv_c_inline in
+   inline | yes) ;;
+   no)
+ cat >>confdefs.h <<\EOF
+ #define inline
+ EOF
+  ;;
+   *)  cat >>confdefs.h <<EOF
+ #define inline $ac_cv_c_inline
+ EOF
+  ;;
+ esac
  
! echo "$as_me:3821: checking whether byte ordering is bigendian" >&5
! echo $ECHO_N "checking whether byte ordering is bigendian... $ECHO_C" >&6
! if test "${ac_cv_c_bigendian+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
!   ac_cv_c_bigendian=unknown
! # See if sys/param.h defines the BYTE_ORDER macro.
! cat >conftest.$ac_ext <<_ACEOF
! #line 3829 "configure"
  #include "confdefs.h"
! #include <sys/types.h>
! #include <sys/param.h>
! 
! int
! main ()
! {
! #if !BYTE_ORDER || !BIG_ENDIAN || !LITTLE_ENDIAN
!  bogus endian macros
  #endif
  
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext
! if { (eval echo "$as_me:3846: \"$ac_compile\"") >&5
!   (eval $ac_compile) 2>&5
!   ac_status=$?
!   echo "$as_me:3849: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest.$ac_objext'
!   { (eval echo "$as_me:3852: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:3855: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   # It does; now see whether it defined to BIG_ENDIAN or not.
! cat >conftest.$ac_ext <<_ACEOF
! #line 3859 "configure"
! #include "confdefs.h"
! #include <sys/types.h>
! #include <sys/param.h>
! 
! int
! main ()
! {
! #if BYTE_ORDER != BIG_ENDIAN
!  not big endian
! #endif
! 
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext
! if { (eval echo "$as_me:3876: \"$ac_compile\"") >&5
!   (eval $ac_compile) 2>&5
!   ac_status=$?
!   echo "$as_me:3879: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest.$ac_objext'
!   { (eval echo "$as_me:3882: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:3885: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   ac_cv_c_bigendian=yes
  else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! ac_cv_c_bigendian=no
  fi
! rm -f conftest.$ac_objext conftest.$ac_ext
! else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
  fi
! rm -f conftest.$ac_objext conftest.$ac_ext
! if test $ac_cv_c_bigendian = unknown; then
! if test "$cross_compiling" = yes; then
!   { { echo "$as_me:3901: error: cannot run test program while cross compiling" >&5
! echo "$as_me: error: cannot run test program while cross compiling" >&2;}
!    { (exit 1); exit 1; }; }
  else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 3906 "configure"
  #include "confdefs.h"
! int
! main ()
! {
!   /* Are we little or big endian?  From Harbison&Steele.  */
!   union
!   {
!     long l;
!     char c[sizeof (long)];
!   } u;
!   u.l = 1;
!   exit (u.c[sizeof (long) - 1] == 1);
! }
! _ACEOF
! rm -f conftest$ac_exeext
! if { (eval echo "$as_me:3922: \"$ac_link\"") >&5
!   (eval $ac_link) 2>&5
!   ac_status=$?
!   echo "$as_me:3925: \$? = $ac_status" >&5
!   (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
!   { (eval echo "$as_me:3927: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:3930: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   ac_cv_c_bigendian=no
! else
!   echo "$as_me: program exited with status $ac_status" >&5
! echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! ac_cv_c_bigendian=yes
! fi
! rm -f core core.* *.core conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
! fi
! fi
! fi
! echo "$as_me:3943: result: $ac_cv_c_bigendian" >&5
! echo "${ECHO_T}$ac_cv_c_bigendian" >&6
! if test $ac_cv_c_bigendian = yes; then
  
! cat >>confdefs.h <<\EOF
! #define WORDS_BIGENDIAN 1
! EOF
  
! fi
  
! echo "$as_me:3953: checking for preprocessor stringizing operator" >&5
! echo $ECHO_N "checking for preprocessor stringizing operator... $ECHO_C" >&6
! if test "${ac_cv_c_stringize+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 3959 "configure"
! #include "confdefs.h"
! #define x(y) #y
! 
! char *s = x(teststring);
! _ACEOF
! if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
!   egrep "#teststring" >/dev/null 2>&1; then
!   ac_cv_c_stringize=no
! else
!   ac_cv_c_stringize=yes
  fi
  rm -f conftest*
+ 
  fi
+ echo "$as_me:3974: result: $ac_cv_c_stringize" >&5
+ echo "${ECHO_T}$ac_cv_c_stringize" >&6
+ if test $ac_cv_c_stringize = yes; then
  
! cat >>confdefs.h <<\EOF
! #define HAVE_STRINGIZE 1
  EOF
  
  fi
  
! echo "$as_me:3984: checking for long double" >&5
! echo $ECHO_N "checking for long double... $ECHO_C" >&6
! if test "${ac_cv_c_long_double+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
!   if test "$GCC" = yes; then
!   ac_cv_c_long_double=yes
! else
! if test "$cross_compiling" = yes; then
!   { { echo "$as_me:3993: error: cannot run test program while cross compiling" >&5
! echo "$as_me: error: cannot run test program while cross compiling" >&2;}
!    { (exit 1); exit 1; }; }
  else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 3998 "configure"
  #include "confdefs.h"
! int
  main ()
  {
!   /* The Stardent Vistra knows sizeof(long double), but does not
!      support it.  */
!   long double foo = 0.0;
!   /* On Ultrix 4.3 cc, long double is 4 and double is 8.  */
!   exit (sizeof (long double) < sizeof (double));
  }
! _ACEOF
! rm -f conftest$ac_exeext
! if { (eval echo "$as_me:4011: \"$ac_link\"") >&5
!   (eval $ac_link) 2>&5
!   ac_status=$?
!   echo "$as_me:4014: \$? = $ac_status" >&5
!   (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
!   { (eval echo "$as_me:4016: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:4019: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   ac_cv_c_long_double=yes
  else
!   echo "$as_me: program exited with status $ac_status" >&5
! echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! ac_cv_c_long_double=no
! fi
! rm -f core core.* *.core conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
  fi
  fi
  fi
+ echo "$as_me:4032: result: $ac_cv_c_long_double" >&5
+ echo "${ECHO_T}$ac_cv_c_long_double" >&6
+ if test $ac_cv_c_long_double = yes; then
  
! cat >>confdefs.h <<\EOF
! #define HAVE_LONG_DOUBLE 1
  EOF
  
  fi
  
! echo "$as_me:4042: checking for function prototypes" >&5
! echo $ECHO_N "checking for function prototypes... $ECHO_C" >&6
! if test "$ac_cv_prog_cc_stdc" != no; then
!   echo "$as_me:4045: result: yes" >&5
! echo "${ECHO_T}yes" >&6
! 
! cat >>confdefs.h <<\EOF
! #define PROTOTYPES 1
! EOF
! 
  else
!   echo "$as_me:4053: result: no" >&5
! echo "${ECHO_T}no" >&6
! fi
! 
! echo "$as_me:4057: checking for ANSI C header files" >&5
! echo $ECHO_N "checking for ANSI C header files... $ECHO_C" >&6
! if test "${ac_cv_header_stdc+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 4063 "configure"
  #include "confdefs.h"
+ #include <stdlib.h>
+ #include <stdarg.h>
+ #include <string.h>
+ #include <float.h>
  
! _ACEOF
! if { (eval echo "$as_me:4071: \"$ac_cpp conftest.$ac_ext\"") >&5
!   (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
!   ac_status=$?
!   egrep -v '^ *\+' conftest.er1 >conftest.err
!   rm -f conftest.er1
!   cat conftest.err >&5
!   echo "$as_me:4077: \$? = $ac_status" >&5
!   (exit $ac_status); } >/dev/null; then
!   if test -s conftest.err; then
!     ac_cpp_err=$ac_c_preproc_warn_flag
!   else
!     ac_cpp_err=
!   fi
! else
!   ac_cpp_err=yes
! fi
! if test -z "$ac_cpp_err"; then
!   ac_cv_header_stdc=yes
! else
!   echo "$as_me: failed program was:" >&5
!   cat conftest.$ac_ext >&5
!   ac_cv_header_stdc=no
! fi
! rm -f conftest.err conftest.$ac_ext
  
! if test $ac_cv_header_stdc = yes; then
!   # SunOS 4.x string.h does not declare mem*, contrary to ANSI.
!   cat >conftest.$ac_ext <<_ACEOF
! #line 4099 "configure"
! #include "confdefs.h"
! #include <string.h>
  
! _ACEOF
! if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
!   egrep "memchr" >/dev/null 2>&1; then
!   :
  else
!   ac_cv_header_stdc=no
  fi
! rm -f conftest*
! 
  fi
  
+ if test $ac_cv_header_stdc = yes; then
+   # ISC 2.0.2 stdlib.h does not declare free, contrary to ANSI.
+   cat >conftest.$ac_ext <<_ACEOF
+ #line 4117 "configure"
+ #include "confdefs.h"
+ #include <stdlib.h>
  
+ _ACEOF
+ if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+   egrep "free" >/dev/null 2>&1; then
+   :
+ else
+   ac_cv_header_stdc=no
  fi
! rm -f conftest*
  
  fi
  
! if test $ac_cv_header_stdc = yes; then
!   # /bin/cc in Irix-4.0.5 gets non-ANSI ctype macros unless using -ansi.
    if test "$cross_compiling" = yes; then
!   :
  else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 4138 "configure"
  #include "confdefs.h"
! #include <ctype.h>
! #if ((' ' & 0x0FF) == 0x020)
! # define ISLOWER(c) ('a' <= (c) && (c) <= 'z')
! # define TOUPPER(c) (ISLOWER(c) ? 'A' + ((c) - 'a') : (c))
! #else
! # define ISLOWER(c) (('a' <= (c) && (c) <= 'i') \
!                      || ('j' <= (c) && (c) <= 'r') \
!                      || ('s' <= (c) && (c) <= 'z'))
! # define TOUPPER(c) (ISLOWER(c) ? ((c) | 0x40) : (c))
! #endif
! 
! #define XOR(e, f) (((e) && !(f)) || (!(e) && (f)))
! int
! main ()
! {
!   int i;
!   for (i = 0; i < 256; i++)
!     if (XOR (islower (i), ISLOWER (i))
!         || toupper (i) != TOUPPER (i))
!       exit(2);
!   exit (0);
! }
! _ACEOF
! rm -f conftest$ac_exeext
! if { (eval echo "$as_me:4164: \"$ac_link\"") >&5
!   (eval $ac_link) 2>&5
!   ac_status=$?
!   echo "$as_me:4167: \$? = $ac_status" >&5
!   (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
!   { (eval echo "$as_me:4169: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:4172: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   :
  else
!   echo "$as_me: program exited with status $ac_status" >&5
! echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! ac_cv_header_stdc=no
! fi
! rm -f core core.* *.core conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
  fi
  fi
+ fi
+ echo "$as_me:4185: result: $ac_cv_header_stdc" >&5
+ echo "${ECHO_T}$ac_cv_header_stdc" >&6
+ if test $ac_cv_header_stdc = yes; then
+ 
+ cat >>confdefs.h <<\EOF
+ #define STDC_HEADERS 1
+ EOF
  
  fi
  
! # On IRIX 5.3, sys/types and inttypes.h are conflicting.
! 
! for ac_header in sys/types.h sys/stat.h stdlib.h string.h memory.h strings.h \
!                   inttypes.h stdint.h unistd.h
! do
! as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
! echo "$as_me:4201: checking for $ac_header" >&5
! echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
! if eval "test \"\${$as_ac_Header+set}\" = set"; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
! else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 4207 "configure"
! #include "confdefs.h"
! $ac_includes_default
! #include <$ac_header>
! _ACEOF
! rm -f conftest.$ac_objext
! if { (eval echo "$as_me:4213: \"$ac_compile\"") >&5
!   (eval $ac_compile) 2>&5
!   ac_status=$?
!   echo "$as_me:4216: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest.$ac_objext'
!   { (eval echo "$as_me:4219: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:4222: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   eval "$as_ac_Header=yes"
! else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! eval "$as_ac_Header=no"
! fi
! rm -f conftest.$ac_objext conftest.$ac_ext
! fi
! echo "$as_me:4232: result: `eval echo '${'$as_ac_Header'}'`" >&5
! echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
! if test `eval echo '${'$as_ac_Header'}'` = yes; then
!   cat >>confdefs.h <<EOF
! #define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
  EOF
  
  fi
+ done
  
! echo "$as_me:4242: checking whether char is unsigned" >&5
! echo $ECHO_N "checking whether char is unsigned... $ECHO_C" >&6
! if test "${ac_cv_c_char_unsigned+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 4248 "configure"
  #include "confdefs.h"
! $ac_includes_default
! int
! main ()
! {
! int _array_ [1 - 2 * !(((char) -1) < 0)]
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext
! if { (eval echo "$as_me:4260: \"$ac_compile\"") >&5
!   (eval $ac_compile) 2>&5
!   ac_status=$?
!   echo "$as_me:4263: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest.$ac_objext'
!   { (eval echo "$as_me:4266: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:4269: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   ac_cv_c_char_unsigned=no
! else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! ac_cv_c_char_unsigned=yes
! fi
! rm -f conftest.$ac_objext conftest.$ac_ext
! fi
! echo "$as_me:4279: result: $ac_cv_c_char_unsigned" >&5
! echo "${ECHO_T}$ac_cv_c_char_unsigned" >&6
! if test $ac_cv_c_char_unsigned = yes && test "$GCC" != yes; then
!   cat >>confdefs.h <<\EOF
! #define __CHAR_UNSIGNED__ 1
! EOF
  
! fi
  
! ac_header_dirent=no
! for ac_hdr in dirent.h sys/ndir.h sys/dir.h ndir.h; do
!   as_ac_Header=`echo "ac_cv_header_dirent_$ac_hdr" | $as_tr_sh`
! echo "$as_me:4291: checking for $ac_hdr that defines DIR" >&5
! echo $ECHO_N "checking for $ac_hdr that defines DIR... $ECHO_C" >&6
! if eval "test \"\${$as_ac_Header+set}\" = set"; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 4297 "configure"
! #include "confdefs.h"
! #include <sys/types.h>
! #include <$ac_hdr>
  
! int
! main ()
! {
! if ((DIR *) 0)
! return 0;
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext
! if { (eval echo "$as_me:4312: \"$ac_compile\"") >&5
!   (eval $ac_compile) 2>&5
!   ac_status=$?
!   echo "$as_me:4315: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest.$ac_objext'
!   { (eval echo "$as_me:4318: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:4321: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   eval "$as_ac_Header=yes"
! else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! eval "$as_ac_Header=no"
! fi
! rm -f conftest.$ac_objext conftest.$ac_ext
! fi
! echo "$as_me:4331: result: `eval echo '${'$as_ac_Header'}'`" >&5
! echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
! if test `eval echo '${'$as_ac_Header'}'` = yes; then
!   cat >>confdefs.h <<EOF
! #define `echo "HAVE_$ac_hdr" | $as_tr_cpp` 1
  EOF
  
! ac_header_dirent=$ac_hdr; break
  fi
  
! done
! # Two versions of opendir et al. are in -ldir and -lx on SCO Xenix.
! if test $ac_header_dirent = dirent.h; then
!   echo "$as_me:4344: checking for opendir in -ldir" >&5
! echo $ECHO_N "checking for opendir in -ldir... $ECHO_C" >&6
! if test "${ac_cv_lib_dir_opendir+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
!   ac_check_lib_save_LIBS=$LIBS
! LIBS="-ldir  $LIBS"
! cat >conftest.$ac_ext <<_ACEOF
! #line 4352 "configure"
  #include "confdefs.h"
  
! /* Override any gcc2 internal prototype to avoid an error.  */
! #ifdef __cplusplus
! extern "C"
  #endif
! /* We use char because int might match the return type of a gcc2
!    builtin and then its argument prototype would still apply.  */
! char opendir ();
! int
! main ()
! {
! opendir ();
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext conftest$ac_exeext
! if { (eval echo "$as_me:4371: \"$ac_link\"") >&5
!   (eval $ac_link) 2>&5
!   ac_status=$?
!   echo "$as_me:4374: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest$ac_exeext'
!   { (eval echo "$as_me:4377: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:4380: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   ac_cv_lib_dir_opendir=yes
! else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! ac_cv_lib_dir_opendir=no
! fi
! rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
! LIBS=$ac_check_lib_save_LIBS
! fi
! echo "$as_me:4391: result: $ac_cv_lib_dir_opendir" >&5
! echo "${ECHO_T}$ac_cv_lib_dir_opendir" >&6
! if test $ac_cv_lib_dir_opendir = yes; then
!   LIBS="$LIBS -ldir"
  fi
  
  else
!   echo "$as_me:4398: checking for opendir in -lx" >&5
! echo $ECHO_N "checking for opendir in -lx... $ECHO_C" >&6
! if test "${ac_cv_lib_x_opendir+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
! else
!   ac_check_lib_save_LIBS=$LIBS
! LIBS="-lx  $LIBS"
! cat >conftest.$ac_ext <<_ACEOF
! #line 4406 "configure"
! #include "confdefs.h"
! 
! /* Override any gcc2 internal prototype to avoid an error.  */
! #ifdef __cplusplus
! extern "C"
! #endif
! /* We use char because int might match the return type of a gcc2
!    builtin and then its argument prototype would still apply.  */
! char opendir ();
! int
! main ()
! {
! opendir ();
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext conftest$ac_exeext
! if { (eval echo "$as_me:4425: \"$ac_link\"") >&5
!   (eval $ac_link) 2>&5
!   ac_status=$?
!   echo "$as_me:4428: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest$ac_exeext'
!   { (eval echo "$as_me:4431: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:4434: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   ac_cv_lib_x_opendir=yes
! else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! ac_cv_lib_x_opendir=no
! fi
! rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
! LIBS=$ac_check_lib_save_LIBS
! fi
! echo "$as_me:4445: result: $ac_cv_lib_x_opendir" >&5
! echo "${ECHO_T}$ac_cv_lib_x_opendir" >&6
! if test $ac_cv_lib_x_opendir = yes; then
!   LIBS="$LIBS -lx"
  fi
  
  fi
  
! echo "$as_me:4453: checking whether time.h and sys/time.h may both be included" >&5
! echo $ECHO_N "checking whether time.h and sys/time.h may both be included... $ECHO_C" >&6
! if test "${ac_cv_header_time+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 4459 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
  #include <sys/time.h>
! #include <time.h>
! 
! int
! main ()
! {
! if ((struct tm *) 0)
! return 0;
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext
! if { (eval echo "$as_me:4475: \"$ac_compile\"") >&5
!   (eval $ac_compile) 2>&5
!   ac_status=$?
!   echo "$as_me:4478: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest.$ac_objext'
!   { (eval echo "$as_me:4481: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:4484: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   ac_cv_header_time=yes
  else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! ac_cv_header_time=no
  fi
! rm -f conftest.$ac_objext conftest.$ac_ext
  fi
+ echo "$as_me:4494: result: $ac_cv_header_time" >&5
+ echo "${ECHO_T}$ac_cv_header_time" >&6
+ if test $ac_cv_header_time = yes; then
  
! cat >>confdefs.h <<\EOF
! #define TIME_WITH_SYS_TIME 1
  EOF
  
  fi
  
! for ac_header in inttypes.h
! do
! as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
! echo "$as_me:4507: checking for $ac_header" >&5
! echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
! if eval "test \"\${$as_ac_Header+set}\" = set"; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
! else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 4513 "configure"
! #include "confdefs.h"
! #include <$ac_header>
! _ACEOF
! if { (eval echo "$as_me:4517: \"$ac_cpp conftest.$ac_ext\"") >&5
!   (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
!   ac_status=$?
!   egrep -v '^ *\+' conftest.er1 >conftest.err
!   rm -f conftest.er1
!   cat conftest.err >&5
!   echo "$as_me:4523: \$? = $ac_status" >&5
!   (exit $ac_status); } >/dev/null; then
!   if test -s conftest.err; then
!     ac_cpp_err=$ac_c_preproc_warn_flag
!   else
!     ac_cpp_err=
!   fi
  else
!   ac_cpp_err=yes
! fi
! if test -z "$ac_cpp_err"; then
!   eval "$as_ac_Header=yes"
  else
!   echo "$as_me: failed program was:" >&5
!   cat conftest.$ac_ext >&5
!   eval "$as_ac_Header=no"
! fi
! rm -f conftest.err conftest.$ac_ext
! fi
! echo "$as_me:4542: result: `eval echo '${'$as_ac_Header'}'`" >&5
! echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
! if test `eval echo '${'$as_ac_Header'}'` = yes; then
!   cat >>confdefs.h <<EOF
! #define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
  EOF
! 
! fi
! done
! 
! for ac_header in unistd.h stdlib.h stdarg.h varargs.h limits.h string.h \
! 		 memory.h locale.h termcap.h termio.h termios.h dlfcn.h \
! 		 stddef.h stdint.h netdb.h grp.h strings.h
! do
! as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
! echo "$as_me:4557: checking for $ac_header" >&5
! echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
! if eval "test \"\${$as_ac_Header+set}\" = set"; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
! else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 4563 "configure"
! #include "confdefs.h"
! #include <$ac_header>
! _ACEOF
! if { (eval echo "$as_me:4567: \"$ac_cpp conftest.$ac_ext\"") >&5
!   (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
!   ac_status=$?
!   egrep -v '^ *\+' conftest.er1 >conftest.err
!   rm -f conftest.er1
!   cat conftest.err >&5
!   echo "$as_me:4573: \$? = $ac_status" >&5
!   (exit $ac_status); } >/dev/null; then
!   if test -s conftest.err; then
!     ac_cpp_err=$ac_c_preproc_warn_flag
!   else
!     ac_cpp_err=
!   fi
! else
!   ac_cpp_err=yes
! fi
! if test -z "$ac_cpp_err"; then
!   eval "$as_ac_Header=yes"
  else
!   echo "$as_me: failed program was:" >&5
    cat conftest.$ac_ext >&5
!   eval "$as_ac_Header=no"
  fi
! rm -f conftest.err conftest.$ac_ext
  fi
+ echo "$as_me:4592: result: `eval echo '${'$as_ac_Header'}'`" >&5
+ echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+ if test `eval echo '${'$as_ac_Header'}'` = yes; then
+   cat >>confdefs.h <<EOF
+ #define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
+ EOF
  
  fi
+ done
  
! for ac_header in sys/ptem.h sys/pte.h sys/stream.h sys/select.h sys/file.h \
! 		 sys/resource.h sys/param.h sys/socket.h \
! 		 sys/time.h sys/times.h sys/wait.h
! do
! as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
! echo "$as_me:4607: checking for $ac_header" >&5
! echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
! if eval "test \"\${$as_ac_Header+set}\" = set"; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
! else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 4613 "configure"
! #include "confdefs.h"
! #include <$ac_header>
! _ACEOF
! if { (eval echo "$as_me:4617: \"$ac_cpp conftest.$ac_ext\"") >&5
!   (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
!   ac_status=$?
!   egrep -v '^ *\+' conftest.er1 >conftest.err
!   rm -f conftest.er1
!   cat conftest.err >&5
!   echo "$as_me:4623: \$? = $ac_status" >&5
!   (exit $ac_status); } >/dev/null; then
!   if test -s conftest.err; then
!     ac_cpp_err=$ac_c_preproc_warn_flag
!   else
!     ac_cpp_err=
!   fi
! else
!   ac_cpp_err=yes
! fi
! if test -z "$ac_cpp_err"; then
!   eval "$as_ac_Header=yes"
! else
!   echo "$as_me: failed program was:" >&5
!   cat conftest.$ac_ext >&5
!   eval "$as_ac_Header=no"
! fi
! rm -f conftest.err conftest.$ac_ext
! fi
! echo "$as_me:4642: result: `eval echo '${'$as_ac_Header'}'`" >&5
! echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
! if test `eval echo '${'$as_ac_Header'}'` = yes; then
!   cat >>confdefs.h <<EOF
! #define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
  EOF
  
  fi
+ done
  
! for ac_header in netinet/in.h arpa/inet.h
! do
! as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
! echo "$as_me:4655: checking for $ac_header" >&5
! echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
! if eval "test \"\${$as_ac_Header+set}\" = set"; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
! else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 4661 "configure"
! #include "confdefs.h"
! #include <$ac_header>
! _ACEOF
! if { (eval echo "$as_me:4665: \"$ac_cpp conftest.$ac_ext\"") >&5
!   (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
!   ac_status=$?
!   egrep -v '^ *\+' conftest.er1 >conftest.err
!   rm -f conftest.er1
!   cat conftest.err >&5
!   echo "$as_me:4671: \$? = $ac_status" >&5
!   (exit $ac_status); } >/dev/null; then
!   if test -s conftest.err; then
!     ac_cpp_err=$ac_c_preproc_warn_flag
!   else
!     ac_cpp_err=
!   fi
! else
!   ac_cpp_err=yes
! fi
! if test -z "$ac_cpp_err"; then
!   eval "$as_ac_Header=yes"
! else
!   echo "$as_me: failed program was:" >&5
!   cat conftest.$ac_ext >&5
!   eval "$as_ac_Header=no"
! fi
! rm -f conftest.err conftest.$ac_ext
! fi
! echo "$as_me:4690: result: `eval echo '${'$as_ac_Header'}'`" >&5
! echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
! if test `eval echo '${'$as_ac_Header'}'` = yes; then
!   cat >>confdefs.h <<EOF
! #define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
  EOF
! 
  fi
! done
  
! # The Ultrix 4.2 mips builtin alloca declared by alloca.h only works
! # for constant arguments.  Useless!
! echo "$as_me:4702: checking for working alloca.h" >&5
! echo $ECHO_N "checking for working alloca.h... $ECHO_C" >&6
! if test "${ac_cv_working_alloca_h+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
! else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 4708 "configure"
! #include "confdefs.h"
! #include <alloca.h>
! int
! main ()
! {
! char *p = (char *) alloca (2 * sizeof (int));
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext conftest$ac_exeext
! if { (eval echo "$as_me:4720: \"$ac_link\"") >&5
!   (eval $ac_link) 2>&5
!   ac_status=$?
!   echo "$as_me:4723: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest$ac_exeext'
!   { (eval echo "$as_me:4726: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:4729: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   ac_cv_working_alloca_h=yes
! else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! ac_cv_working_alloca_h=no
! fi
! rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
! fi
! echo "$as_me:4739: result: $ac_cv_working_alloca_h" >&5
! echo "${ECHO_T}$ac_cv_working_alloca_h" >&6
! if test $ac_cv_working_alloca_h = yes; then
! 
! cat >>confdefs.h <<\EOF
! #define HAVE_ALLOCA_H 1
  EOF
  
  fi
  
! echo "$as_me:4749: checking for alloca" >&5
! echo $ECHO_N "checking for alloca... $ECHO_C" >&6
! if test "${ac_cv_func_alloca_works+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 4755 "configure"
  #include "confdefs.h"
! #ifdef __GNUC__
! # define alloca __builtin_alloca
  #else
! # ifdef _MSC_VER
! #  include <malloc.h>
! #  define alloca _alloca
! # else
! #  if HAVE_ALLOCA_H
! #   include <alloca.h>
! #  else
! #   ifdef _AIX
!  #pragma alloca
! #   else
! #    ifndef alloca /* predefined by HP cc +Olibcalls */
! char *alloca ();
! #    endif
! #   endif
! #  endif
! # endif
  #endif
  
! int
! main ()
! {
! char *p = (char *) alloca (1);
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext conftest$ac_exeext
! if { (eval echo "$as_me:4787: \"$ac_link\"") >&5
!   (eval $ac_link) 2>&5
!   ac_status=$?
!   echo "$as_me:4790: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest$ac_exeext'
!   { (eval echo "$as_me:4793: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:4796: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   ac_cv_func_alloca_works=yes
  else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! ac_cv_func_alloca_works=no
  fi
! rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
  fi
+ echo "$as_me:4806: result: $ac_cv_func_alloca_works" >&5
+ echo "${ECHO_T}$ac_cv_func_alloca_works" >&6
  
! if test $ac_cv_func_alloca_works = yes; then
! 
! cat >>confdefs.h <<\EOF
! #define HAVE_ALLOCA 1
  EOF
  
+ else
+   # The SVR3 libPW and SVR4 libucb both contain incompatible functions
+ # that cause trouble.  Some versions do not even contain alloca or
+ # contain a buggy version.  If you still want to use their alloca,
+ # use ar to extract alloca.o from them instead of compiling alloca.c.
+ 
+ ALLOCA=alloca.$ac_objext
  
+ cat >>confdefs.h <<\EOF
+ #define C_ALLOCA 1
+ EOF
  
! echo "$as_me:4827: checking whether \`alloca.c' needs Cray hooks" >&5
! echo $ECHO_N "checking whether \`alloca.c' needs Cray hooks... $ECHO_C" >&6
! if test "${ac_cv_os_cray+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 4833 "configure"
  #include "confdefs.h"
! #if defined(CRAY) && ! defined(CRAY2)
! webecray
  #else
! wenotbecray
  #endif
  
! _ACEOF
! if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
!   egrep "webecray" >/dev/null 2>&1; then
!   ac_cv_os_cray=yes
  else
!   ac_cv_os_cray=no
  fi
  rm -f conftest*
  
  fi
! echo "$as_me:4851: result: $ac_cv_os_cray" >&5
! echo "${ECHO_T}$ac_cv_os_cray" >&6
! if test $ac_cv_os_cray = yes; then
!   for ac_func in _getb67 GETB67 getb67; do
!     as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
! echo "$as_me:4856: checking for $ac_func" >&5
! echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
! if eval "test \"\${$as_ac_var+set}\" = set"; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 4862 "configure"
  #include "confdefs.h"
  /* System header to define __stub macros and hopefully few prototypes,
!     which can conflict with char $ac_func (); below.  */
  #include <assert.h>
  /* Override any gcc2 internal prototype to avoid an error.  */
+ #ifdef __cplusplus
+ extern "C"
+ #endif
  /* We use char because int might match the return type of a gcc2
!    builtin and then its argument prototype would still apply.  */
! char $ac_func ();
! char (*f) ();
  
+ int
+ main ()
+ {
  /* The GNU C library defines this for functions which it implements
      to always fail with ENOSYS.  Some functions are actually named
      something starting with __ and the normal name is an alias.  */
! #if defined (__stub_$ac_func) || defined (__stub___$ac_func)
  choke me
  #else
! f = $ac_func;
  #endif
  
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext conftest$ac_exeext
! if { (eval echo "$as_me:4893: \"$ac_link\"") >&5
!   (eval $ac_link) 2>&5
!   ac_status=$?
!   echo "$as_me:4896: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest$ac_exeext'
!   { (eval echo "$as_me:4899: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:4902: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   eval "$as_ac_var=yes"
! else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! eval "$as_ac_var=no"
! fi
! rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
! fi
! echo "$as_me:4912: result: `eval echo '${'$as_ac_var'}'`" >&5
! echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
! if test `eval echo '${'$as_ac_var'}'` = yes; then
! 
! cat >>confdefs.h <<EOF
! #define CRAY_STACKSEG_END $ac_func
  EOF
! 
!     break
  fi
! 
!   done
  fi
  
! echo "$as_me:4926: checking stack direction for C alloca" >&5
! echo $ECHO_N "checking stack direction for C alloca... $ECHO_C" >&6
! if test "${ac_cv_c_stack_direction+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
! else
!   if test "$cross_compiling" = yes; then
!   ac_cv_c_stack_direction=0
! else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 4935 "configure"
! #include "confdefs.h"
! int
! find_stack_direction ()
! {
!   static char *addr = 0;
!   auto char dummy;
!   if (addr == 0)
!     {
!       addr = &dummy;
!       return find_stack_direction ();
!     }
!   else
!     return (&dummy > addr) ? 1 : -1;
! }
  
+ int
+ main ()
+ {
+   exit (find_stack_direction () < 0);
+ }
+ _ACEOF
+ rm -f conftest$ac_exeext
+ if { (eval echo "$as_me:4958: \"$ac_link\"") >&5
+   (eval $ac_link) 2>&5
+   ac_status=$?
+   echo "$as_me:4961: \$? = $ac_status" >&5
+   (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
+   { (eval echo "$as_me:4963: \"$ac_try\"") >&5
+   (eval $ac_try) 2>&5
+   ac_status=$?
+   echo "$as_me:4966: \$? = $ac_status" >&5
+   (exit $ac_status); }; }; then
+   ac_cv_c_stack_direction=1
  else
!   echo "$as_me: program exited with status $ac_status" >&5
! echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! ac_cv_c_stack_direction=-1
! fi
! rm -f core core.* *.core conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
  fi
+ fi
+ echo "$as_me:4978: result: $ac_cv_c_stack_direction" >&5
+ echo "${ECHO_T}$ac_cv_c_stack_direction" >&6
+ 
+ cat >>confdefs.h <<EOF
+ #define STACK_DIRECTION $ac_cv_c_stack_direction
+ EOF
  
+ fi
  
! echo "$as_me:4987: checking whether getpgrp takes no argument" >&5
! echo $ECHO_N "checking whether getpgrp takes no argument... $ECHO_C" >&6
! if test "${ac_cv_func_getpgrp_void+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
! else
!   # Use it with a single arg.
! cat >conftest.$ac_ext <<_ACEOF
! #line 4994 "configure"
! #include "confdefs.h"
! $ac_includes_default
! int
! main ()
! {
! getpgrp (0);
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext
! if { (eval echo "$as_me:5006: \"$ac_compile\"") >&5
!   (eval $ac_compile) 2>&5
!   ac_status=$?
!   echo "$as_me:5009: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest.$ac_objext'
!   { (eval echo "$as_me:5012: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:5015: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   ac_func_getpgrp_1=yes
! else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! ac_func_getpgrp_1=no
! fi
! rm -f conftest.$ac_objext conftest.$ac_ext
! # Use it with no arg.
! cat >conftest.$ac_ext <<_ACEOF
! #line 5026 "configure"
! #include "confdefs.h"
! $ac_includes_default
! int
! main ()
! {
! getpgrp ();
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext
! if { (eval echo "$as_me:5038: \"$ac_compile\"") >&5
!   (eval $ac_compile) 2>&5
!   ac_status=$?
!   echo "$as_me:5041: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest.$ac_objext'
!   { (eval echo "$as_me:5044: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:5047: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   ac_func_getpgrp_0=yes
! else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! ac_func_getpgrp_0=no
! fi
! rm -f conftest.$ac_objext conftest.$ac_ext
! # If both static checks agree, we are done.
! case $ac_func_getpgrp_0:$ac_func_getpgrp_1 in
!   yes:no) ac_cv_func_getpgrp_void=yes;;
!   no:yes) ac_cv_func_getpgrp_void=false;;
!   *) if test "$cross_compiling" = yes; then
!   { { echo "$as_me:5061: error: cannot check getpgrp if cross compiling" >&5
! echo "$as_me: error: cannot check getpgrp if cross compiling" >&2;}
!    { (exit 1); exit 1; }; }
  else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 5066 "configure"
  #include "confdefs.h"
! $ac_includes_default
  
! /*
!  * If this system has a BSD-style getpgrp(),
!  * which takes a pid argument, exit unsuccessfully.
!  *
!  * Snarfed from Chet Ramey's bash pgrp.c test program
!  */
  
! int     pid;
! int     pg1, pg2, pg3, pg4;
! int     ng, np, s, child;
  
! int
! main ()
! {
!   pid = getpid ();
!   pg1 = getpgrp (0);
!   pg2 = getpgrp ();
!   pg3 = getpgrp (pid);
!   pg4 = getpgrp (1);
! 
!   /* If all of these values are the same, it's pretty sure that we're
!      on a system that ignores getpgrp's first argument.  */
!   if (pg2 == pg4 && pg1 == pg3 && pg2 == pg3)
!     exit (0);
! 
!   child = fork ();
!   if (child < 0)
!     exit(1);
!   else if (child == 0)
!     {
!       np = getpid ();
!       /*  If this is Sys V, this will not work; pgrp will be set to np
! 	 because setpgrp just changes a pgrp to be the same as the
! 	 pid.  */
!       setpgrp (np, pg1);
!       ng = getpgrp (0);        /* Same result for Sys V and BSD */
!       if (ng == pg1)
!   	exit (1);
!       else
!   	exit (0);
!     }
!   else
!     {
!       wait (&s);
!       exit (s>>8);
!     }
! }
! 
! _ACEOF
! rm -f conftest$ac_exeext
! if { (eval echo "$as_me:5120: \"$ac_link\"") >&5
!   (eval $ac_link) 2>&5
!   ac_status=$?
!   echo "$as_me:5123: \$? = $ac_status" >&5
!   (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
!   { (eval echo "$as_me:5125: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:5128: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   ac_cv_func_getpgrp_void=yes
  else
!   echo "$as_me: program exited with status $ac_status" >&5
! echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! ac_cv_func_getpgrp_void=no
! fi
! rm -f core core.* *.core conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
! fi;;
! esac # $ac_func_getpgrp_0:$ac_func_getpgrp_1
! 
  fi
+ echo "$as_me:5142: result: $ac_cv_func_getpgrp_void" >&5
+ echo "${ECHO_T}$ac_cv_func_getpgrp_void" >&6
+ if test $ac_cv_func_getpgrp_void = yes; then
  
! cat >>confdefs.h <<\EOF
! #define GETPGRP_VOID 1
  EOF
  
+ fi
+ 
+ echo "$as_me:5152: checking whether setvbuf arguments are reversed" >&5
+ echo $ECHO_N "checking whether setvbuf arguments are reversed... $ECHO_C" >&6
+ if test "${ac_cv_func_setvbuf_reversed+set}" = set; then
+   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
!   if test "$cross_compiling" = yes; then
!   { { echo "$as_me:5158: error: cannot run test program while cross compiling" >&5
! echo "$as_me: error: cannot run test program while cross compiling" >&2;}
!    { (exit 1); exit 1; }; }
! else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 5163 "configure"
! #include "confdefs.h"
! #include <stdio.h>
! /* If setvbuf has the reversed format, exit 0. */
! int
! main ()
! {
!   /* This call has the arguments reversed.
!      A reversed system may check and see that the address of main
!      is not _IOLBF, _IONBF, or _IOFBF, and return nonzero.  */
!   if (setvbuf(stdout, _IOLBF, (char *) main, BUFSIZ) != 0)
!     exit(1);
!   putc('\r', stdout);
!   exit(0);			/* Non-reversed systems segv here.  */
! }
! _ACEOF
! rm -f conftest$ac_exeext
! if { (eval echo "$as_me:5180: \"$ac_link\"") >&5
!   (eval $ac_link) 2>&5
!   ac_status=$?
!   echo "$as_me:5183: \$? = $ac_status" >&5
!   (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
!   { (eval echo "$as_me:5185: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:5188: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   ac_cv_func_setvbuf_reversed=yes
! else
!   echo "$as_me: program exited with status $ac_status" >&5
! echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! ac_cv_func_setvbuf_reversed=no
! fi
! rm -f core core.* *.core conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
! fi
! rm -f core core.* *.core
! fi
! echo "$as_me:5201: result: $ac_cv_func_setvbuf_reversed" >&5
! echo "${ECHO_T}$ac_cv_func_setvbuf_reversed" >&6
! if test $ac_cv_func_setvbuf_reversed = yes; then
! 
! cat >>confdefs.h <<\EOF
! #define SETVBUF_REVERSED 1
  EOF
  
  fi
  
! for ac_func in vprintf
  do
! as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
! echo "$as_me:5214: checking for $ac_func" >&5
! echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
! if eval "test \"\${$as_ac_var+set}\" = set"; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 5220 "configure"
  #include "confdefs.h"
  /* System header to define __stub macros and hopefully few prototypes,
!     which can conflict with char $ac_func (); below.  */
  #include <assert.h>
  /* Override any gcc2 internal prototype to avoid an error.  */
+ #ifdef __cplusplus
+ extern "C"
+ #endif
  /* We use char because int might match the return type of a gcc2
!    builtin and then its argument prototype would still apply.  */
! char $ac_func ();
! char (*f) ();
  
+ int
+ main ()
+ {
  /* The GNU C library defines this for functions which it implements
      to always fail with ENOSYS.  Some functions are actually named
***************
*** 3057,3421 ****
  choke me
  #else
! $ac_func();
  #endif
  
! ; return 0; }
! EOF
! if { (eval echo configure:3065: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
!   rm -rf conftest*
!   eval "ac_cv_func_$ac_func=yes"
! else
!   echo "configure: failed program was:" >&5
!   cat conftest.$ac_ext >&5
!   rm -rf conftest*
!   eval "ac_cv_func_$ac_func=no"
! fi
! rm -f conftest*
! fi
! 
! if eval "test \"`echo '$ac_cv_func_'$ac_func`\" = yes"; then
!   echo "$ac_t""yes" 1>&6
!     ac_tr_func=HAVE_`echo $ac_func | tr 'abcdefghijklmnopqrstuvwxyz' 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'`
!   cat >> confdefs.h <<EOF
! #define $ac_tr_func 1
! EOF
!  
! else
!   echo "$ac_t""no" 1>&6
! fi
! done
! 
! 
! for ac_func in bcopy bzero confstr getcwd strcasecmp setenv putenv \
! 		setlinebuf setlocale strchr strerror strtod strtol \
! 		strtoul tcgetattr uname sysconf ulimit times tzset \
! 		siginterrupt memmove ttyname gethostbyname getservbyname \
! 		inet_aton strpbrk setvbuf pathconf
! do
! echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
! echo "configure:3097: checking for $ac_func" >&5
! if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
!   cat > conftest.$ac_ext <<EOF
! #line 3102 "configure"
  #include "confdefs.h"
  /* System header to define __stub macros and hopefully few prototypes,
!     which can conflict with char $ac_func(); below.  */
  #include <assert.h>
  /* Override any gcc2 internal prototype to avoid an error.  */
  /* We use char because int might match the return type of a gcc2
!     builtin and then its argument prototype would still apply.  */
! char $ac_func();
! 
! int main() {
  
  /* The GNU C library defines this for functions which it implements
      to always fail with ENOSYS.  Some functions are actually named
      something starting with __ and the normal name is an alias.  */
! #if defined (__stub_$ac_func) || defined (__stub___$ac_func)
  choke me
  #else
! $ac_func();
  #endif
  
! ; return 0; }
  EOF
! if { (eval echo configure:3125: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
!   rm -rf conftest*
!   eval "ac_cv_func_$ac_func=yes"
  else
!   echo "configure: failed program was:" >&5
!   cat conftest.$ac_ext >&5
!   rm -rf conftest*
!   eval "ac_cv_func_$ac_func=no"
  fi
- rm -f conftest*
  fi
  
! if eval "test \"`echo '$ac_cv_func_'$ac_func`\" = yes"; then
!   echo "$ac_t""yes" 1>&6
!     ac_tr_func=HAVE_`echo $ac_func | tr 'abcdefghijklmnopqrstuvwxyz' 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'`
!   cat >> confdefs.h <<EOF
! #define $ac_tr_func 1
  EOF
!  
! else
!   echo "$ac_t""no" 1>&6
  fi
- done
  
  
! for ac_hdr in libintl.h
! do
! ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
! echo $ac_n "checking for $ac_hdr""... $ac_c" 1>&6
! echo "configure:3154: checking for $ac_hdr" >&5
! if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
! else
!   cat > conftest.$ac_ext <<EOF
! #line 3159 "configure"
  #include "confdefs.h"
! #include <$ac_hdr>
! EOF
! ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
! { (eval echo configure:3164: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
! ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
! if test -z "$ac_err"; then
!   rm -rf conftest*
!   eval "ac_cv_header_$ac_safe=yes"
! else
!   echo "$ac_err" >&5
!   echo "configure: failed program was:" >&5
!   cat conftest.$ac_ext >&5
!   rm -rf conftest*
!   eval "ac_cv_header_$ac_safe=no"
  fi
  rm -f conftest*
! fi
! if eval "test \"`echo '$ac_cv_header_'$ac_safe`\" = yes"; then
!   echo "$ac_t""yes" 1>&6
!     ac_tr_hdr=HAVE_`echo $ac_hdr | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
!   cat >> confdefs.h <<EOF
! #define $ac_tr_hdr 1
  EOF
!  
  else
!   echo "$ac_t""no" 1>&6
  fi
! done
  
! for ac_func in gettext textdomain bindtextdomain
! do
! echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
! echo "configure:3193: checking for $ac_func" >&5
! if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
!   cat > conftest.$ac_ext <<EOF
! #line 3198 "configure"
  #include "confdefs.h"
  /* System header to define __stub macros and hopefully few prototypes,
!     which can conflict with char $ac_func(); below.  */
  #include <assert.h>
  /* Override any gcc2 internal prototype to avoid an error.  */
  /* We use char because int might match the return type of a gcc2
!     builtin and then its argument prototype would still apply.  */
! char $ac_func();
! 
! int main() {
  
  /* The GNU C library defines this for functions which it implements
      to always fail with ENOSYS.  Some functions are actually named
      something starting with __ and the normal name is an alias.  */
! #if defined (__stub_$ac_func) || defined (__stub___$ac_func)
  choke me
  #else
! $ac_func();
  #endif
  
! ; return 0; }
  EOF
- if { (eval echo configure:3221: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
-   rm -rf conftest*
-   eval "ac_cv_func_$ac_func=yes"
- else
-   echo "configure: failed program was:" >&5
-   cat conftest.$ac_ext >&5
-   rm -rf conftest*
-   eval "ac_cv_func_$ac_func=no"
- fi
- rm -f conftest*
- fi
  
- if eval "test \"`echo '$ac_cv_func_'$ac_func`\" = yes"; then
-   echo "$ac_t""yes" 1>&6
-     ac_tr_func=HAVE_`echo $ac_func | tr 'abcdefghijklmnopqrstuvwxyz' 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'`
-   cat >> confdefs.h <<EOF
- #define $ac_tr_func 1
- EOF
-  
- else
-   echo "$ac_t""no" 1>&6
  fi
- done
  
! 
! if test "$ac_cv_func_bindtextdomain" = "no"; then
!     echo $ac_n "checking for bindtextdomain in -lintl""... $ac_c" 1>&6
! echo "configure:3248: checking for bindtextdomain in -lintl" >&5
! ac_lib_var=`echo intl'_'bindtextdomain | sed 'y%./+-%__p_%'`
! if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
!   ac_save_LIBS="$LIBS"
! LIBS="-lintl  $LIBS"
! cat > conftest.$ac_ext <<EOF
! #line 3256 "configure"
  #include "confdefs.h"
  /* Override any gcc2 internal prototype to avoid an error.  */
  /* We use char because int might match the return type of a gcc2
!     builtin and then its argument prototype would still apply.  */
! char bindtextdomain();
  
! int main() {
! bindtextdomain()
! ; return 0; }
! EOF
! if { (eval echo configure:3267: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
!   rm -rf conftest*
!   eval "ac_cv_lib_$ac_lib_var=yes"
! else
!   echo "configure: failed program was:" >&5
!   cat conftest.$ac_ext >&5
!   rm -rf conftest*
!   eval "ac_cv_lib_$ac_lib_var=no"
! fi
! rm -f conftest*
! LIBS="$ac_save_LIBS"
  
! fi
! if eval "test \"`echo '$ac_cv_lib_'$ac_lib_var`\" = yes"; then
!   echo "$ac_t""yes" 1>&6
!     ac_tr_lib=HAVE_LIB`echo intl | sed -e 's/[^a-zA-Z0-9_]/_/g' \
!     -e 'y/abcdefghijklmnopqrstuvwxyz/ABCDEFGHIJKLMNOPQRSTUVWXYZ/'`
!   cat >> confdefs.h <<EOF
! #define $ac_tr_lib 1
  EOF
  
-   LIBS="-lintl $LIBS"
- 
- else
-   echo "$ac_t""no" 1>&6
  fi
  
!     if test "$ac_cv_lib_intl" = "yes"; then
! 	for ac_func in gettext textdomain bindtextdomain
! do
! echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
! echo "configure:3298: checking for $ac_func" >&5
! if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
!   cat > conftest.$ac_ext <<EOF
! #line 3303 "configure"
  #include "confdefs.h"
  /* System header to define __stub macros and hopefully few prototypes,
!     which can conflict with char $ac_func(); below.  */
  #include <assert.h>
  /* Override any gcc2 internal prototype to avoid an error.  */
  /* We use char because int might match the return type of a gcc2
!     builtin and then its argument prototype would still apply.  */
! char $ac_func();
! 
! int main() {
  
  /* The GNU C library defines this for functions which it implements
      to always fail with ENOSYS.  Some functions are actually named
      something starting with __ and the normal name is an alias.  */
! #if defined (__stub_$ac_func) || defined (__stub___$ac_func)
  choke me
  #else
! $ac_func();
  #endif
  
! ; return 0; }
  EOF
- if { (eval echo configure:3326: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
-   rm -rf conftest*
-   eval "ac_cv_func_$ac_func=yes"
- else
-   echo "configure: failed program was:" >&5
-   cat conftest.$ac_ext >&5
-   rm -rf conftest*
-   eval "ac_cv_func_$ac_func=no"
- fi
- rm -f conftest*
- fi
  
- if eval "test \"`echo '$ac_cv_func_'$ac_func`\" = yes"; then
-   echo "$ac_t""yes" 1>&6
-     ac_tr_func=HAVE_`echo $ac_func | tr 'abcdefghijklmnopqrstuvwxyz' 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'`
-   cat >> confdefs.h <<EOF
- #define $ac_tr_func 1
- EOF
-  
  else
!   echo "$ac_t""no" 1>&6
! fi
! done
  
-     fi
  fi
  
! if test "$opt_static_link" != yes; then
! echo $ac_n "checking for dlopen in -ldl""... $ac_c" 1>&6
! echo "configure:3355: checking for dlopen in -ldl" >&5
! ac_lib_var=`echo dl'_'dlopen | sed 'y%./+-%__p_%'`
! if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
!   ac_save_LIBS="$LIBS"
! LIBS="-ldl  $LIBS"
! cat > conftest.$ac_ext <<EOF
! #line 3363 "configure"
  #include "confdefs.h"
  /* Override any gcc2 internal prototype to avoid an error.  */
  /* We use char because int might match the return type of a gcc2
!     builtin and then its argument prototype would still apply.  */
! char dlopen();
  
! int main() {
! dlopen()
! ; return 0; }
! EOF
! if { (eval echo configure:3374: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
!   rm -rf conftest*
!   eval "ac_cv_lib_$ac_lib_var=yes"
! else
!   echo "configure: failed program was:" >&5
!   cat conftest.$ac_ext >&5
!   rm -rf conftest*
!   eval "ac_cv_lib_$ac_lib_var=no"
! fi
! rm -f conftest*
! LIBS="$ac_save_LIBS"
  
! fi
! if eval "test \"`echo '$ac_cv_lib_'$ac_lib_var`\" = yes"; then
!   echo "$ac_t""yes" 1>&6
!     ac_tr_lib=HAVE_LIB`echo dl | sed -e 's/[^a-zA-Z0-9_]/_/g' \
!     -e 'y/abcdefghijklmnopqrstuvwxyz/ABCDEFGHIJKLMNOPQRSTUVWXYZ/'`
!   cat >> confdefs.h <<EOF
! #define $ac_tr_lib 1
  EOF
  
-   LIBS="-ldl $LIBS"
- 
- else
-   echo "$ac_t""no" 1>&6
  fi
  
! for ac_func in dlopen dlclose dlsym
  do
! echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
! echo "configure:3404: checking for $ac_func" >&5
! if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
!   cat > conftest.$ac_ext <<EOF
! #line 3409 "configure"
  #include "confdefs.h"
  /* System header to define __stub macros and hopefully few prototypes,
!     which can conflict with char $ac_func(); below.  */
  #include <assert.h>
  /* Override any gcc2 internal prototype to avoid an error.  */
  /* We use char because int might match the return type of a gcc2
!     builtin and then its argument prototype would still apply.  */
! char $ac_func();
! 
! int main() {
  
  /* The GNU C library defines this for functions which it implements
      to always fail with ENOSYS.  Some functions are actually named
--- 5241,5791 ----
  choke me
  #else
! f = $ac_func;
  #endif
  
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext conftest$ac_exeext
! if { (eval echo "$as_me:5251: \"$ac_link\"") >&5
!   (eval $ac_link) 2>&5
!   ac_status=$?
!   echo "$as_me:5254: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest$ac_exeext'
!   { (eval echo "$as_me:5257: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:5260: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   eval "$as_ac_var=yes"
! else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! eval "$as_ac_var=no"
! fi
! rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
! fi
! echo "$as_me:5270: result: `eval echo '${'$as_ac_var'}'`" >&5
! echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
! if test `eval echo '${'$as_ac_var'}'` = yes; then
!   cat >>confdefs.h <<EOF
! #define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
! EOF
! 
! echo "$as_me:5277: checking for _doprnt" >&5
! echo $ECHO_N "checking for _doprnt... $ECHO_C" >&6
! if test "${ac_cv_func__doprnt+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 5283 "configure"
  #include "confdefs.h"
  /* System header to define __stub macros and hopefully few prototypes,
!     which can conflict with char _doprnt (); below.  */
  #include <assert.h>
  /* Override any gcc2 internal prototype to avoid an error.  */
+ #ifdef __cplusplus
+ extern "C"
+ #endif
  /* We use char because int might match the return type of a gcc2
!    builtin and then its argument prototype would still apply.  */
! char _doprnt ();
! char (*f) ();
  
+ int
+ main ()
+ {
  /* The GNU C library defines this for functions which it implements
      to always fail with ENOSYS.  Some functions are actually named
      something starting with __ and the normal name is an alias.  */
! #if defined (__stub__doprnt) || defined (__stub____doprnt)
  choke me
  #else
! f = _doprnt;
  #endif
  
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext conftest$ac_exeext
! if { (eval echo "$as_me:5314: \"$ac_link\"") >&5
!   (eval $ac_link) 2>&5
!   ac_status=$?
!   echo "$as_me:5317: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest$ac_exeext'
!   { (eval echo "$as_me:5320: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:5323: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   ac_cv_func__doprnt=yes
! else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! ac_cv_func__doprnt=no
! fi
! rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
! fi
! echo "$as_me:5333: result: $ac_cv_func__doprnt" >&5
! echo "${ECHO_T}$ac_cv_func__doprnt" >&6
! if test $ac_cv_func__doprnt = yes; then
! 
! cat >>confdefs.h <<\EOF
! #define HAVE_DOPRNT 1
  EOF
! 
! fi
! 
! fi
! done
! 
! echo "$as_me:5346: checking for working strcoll" >&5
! echo $ECHO_N "checking for working strcoll... $ECHO_C" >&6
! if test "${ac_cv_func_strcoll_works+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
!   if test "$cross_compiling" = yes; then
!   ac_cv_func_strcoll_works=no
! else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 5355 "configure"
! #include "confdefs.h"
! $ac_includes_default
! int
! main ()
! {
! exit (strcoll ("abc", "def") >= 0 ||
! 	 strcoll ("ABC", "DEF") >= 0 ||
! 	 strcoll ("123", "456") >= 0)
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest$ac_exeext
! if { (eval echo "$as_me:5369: \"$ac_link\"") >&5
!   (eval $ac_link) 2>&5
!   ac_status=$?
!   echo "$as_me:5372: \$? = $ac_status" >&5
!   (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
!   { (eval echo "$as_me:5374: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:5377: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   ac_cv_func_strcoll_works=yes
! else
!   echo "$as_me: program exited with status $ac_status" >&5
! echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! ac_cv_func_strcoll_works=no
! fi
! rm -f core core.* *.core conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
  fi
  fi
+ echo "$as_me:5389: result: $ac_cv_func_strcoll_works" >&5
+ echo "${ECHO_T}$ac_cv_func_strcoll_works" >&6
+ if test $ac_cv_func_strcoll_works = yes; then
  
! cat >>confdefs.h <<\EOF
! #define HAVE_STRCOLL 1
  EOF
! 
  fi
  
+ if test "$ac_cv_func_alloca_works" = "no" && test "$opt_bash_malloc" = "no"; then
+ 	MALLOC_TARGET=alloca
+ 	MALLOC_SRC=alloca.c
+ 
+ 	MALLOC_LIB='-lmalloc'
+ 	MALLOC_LIBRARY='$(ALLOC_LIBDIR)/libmalloc.a'
+ 	MALLOC_LDFLAGS='-L$(ALLOC_LIBDIR)'
+ 	MALLOC_DEP='$(MALLOC_LIBRARY)'
+ fi
  
! if test "$ac_cv_func_vprintf" = no; then
!     echo "$as_me:5410: checking for declaration of vprintf in stdio.h" >&5
! echo $ECHO_N "checking for declaration of vprintf in stdio.h... $ECHO_C" >&6
!     cat >conftest.$ac_ext <<_ACEOF
! #line 5413 "configure"
  #include "confdefs.h"
! #include <stdio.h>
! 
! _ACEOF
! if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
!   egrep "[int[ 	]*vprintf[^a-zA-Z0-9]]" >/dev/null 2>&1; then
!   ac_cv_func_vprintf=yes
  fi
  rm -f conftest*
! 
!     echo "$as_me:5424: result: $ac_cv_func_vprintf" >&5
! echo "${ECHO_T}$ac_cv_func_vprintf" >&6
!     if test $ac_cv_func_vprintf = yes; then
! 	cat >>confdefs.h <<\EOF
! #define HAVE_VPRINTF 1
  EOF
! 
!     fi
! fi
! 
! if test "$ac_cv_func_vprintf" = no && test "$ac_cv_func__doprnt" = "yes"; then
!   LIBOBJS="$LIBOBJS vprint.$ac_objext"
! fi
! 
! echo "$as_me:5438: checking return type of signal handlers" >&5
! echo $ECHO_N "checking return type of signal handlers... $ECHO_C" >&6
! if test "${ac_cv_type_signal+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
! else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 5444 "configure"
! #include "confdefs.h"
! #include <sys/types.h>
! #include <signal.h>
! #ifdef signal
! # undef signal
! #endif
! #ifdef __cplusplus
! extern "C" void (*signal (int, void (*)(int)))(int);
! #else
! void (*signal ()) ();
! #endif
! 
! int
! main ()
! {
! int i;
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext
! if { (eval echo "$as_me:5466: \"$ac_compile\"") >&5
!   (eval $ac_compile) 2>&5
!   ac_status=$?
!   echo "$as_me:5469: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest.$ac_objext'
!   { (eval echo "$as_me:5472: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:5475: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   ac_cv_type_signal=void
  else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! ac_cv_type_signal=int
  fi
! rm -f conftest.$ac_objext conftest.$ac_ext
! fi
! echo "$as_me:5485: result: $ac_cv_type_signal" >&5
! echo "${ECHO_T}$ac_cv_type_signal" >&6
  
! cat >>confdefs.h <<EOF
! #define RETSIGTYPE $ac_cv_type_signal
! EOF
! 
! echo "$as_me:5492: checking for __setostype" >&5
! echo $ECHO_N "checking for __setostype... $ECHO_C" >&6
! if test "${ac_cv_func___setostype+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 5498 "configure"
  #include "confdefs.h"
  /* System header to define __stub macros and hopefully few prototypes,
!     which can conflict with char __setostype (); below.  */
  #include <assert.h>
  /* Override any gcc2 internal prototype to avoid an error.  */
+ #ifdef __cplusplus
+ extern "C"
+ #endif
  /* We use char because int might match the return type of a gcc2
!    builtin and then its argument prototype would still apply.  */
! char __setostype ();
! char (*f) ();
  
+ int
+ main ()
+ {
  /* The GNU C library defines this for functions which it implements
      to always fail with ENOSYS.  Some functions are actually named
      something starting with __ and the normal name is an alias.  */
! #if defined (__stub___setostype) || defined (__stub_____setostype)
  choke me
  #else
! f = __setostype;
  #endif
  
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext conftest$ac_exeext
! if { (eval echo "$as_me:5529: \"$ac_link\"") >&5
!   (eval $ac_link) 2>&5
!   ac_status=$?
!   echo "$as_me:5532: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest$ac_exeext'
!   { (eval echo "$as_me:5535: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:5538: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   ac_cv_func___setostype=yes
! else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! ac_cv_func___setostype=no
! fi
! rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
! fi
! echo "$as_me:5548: result: $ac_cv_func___setostype" >&5
! echo "${ECHO_T}$ac_cv_func___setostype" >&6
! if test $ac_cv_func___setostype = yes; then
!   cat >>confdefs.h <<\EOF
! #define HAVE_SETOSTYPE 1
  EOF
  
  fi
  
! echo "$as_me:5557: checking for wait3" >&5
! echo $ECHO_N "checking for wait3... $ECHO_C" >&6
! if test "${ac_cv_func_wait3+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 5563 "configure"
  #include "confdefs.h"
+ /* System header to define __stub macros and hopefully few prototypes,
+     which can conflict with char wait3 (); below.  */
+ #include <assert.h>
  /* Override any gcc2 internal prototype to avoid an error.  */
+ #ifdef __cplusplus
+ extern "C"
+ #endif
  /* We use char because int might match the return type of a gcc2
!    builtin and then its argument prototype would still apply.  */
! char wait3 ();
! char (*f) ();
  
! int
! main ()
! {
! /* The GNU C library defines this for functions which it implements
!     to always fail with ENOSYS.  Some functions are actually named
!     something starting with __ and the normal name is an alias.  */
! #if defined (__stub_wait3) || defined (__stub___wait3)
! choke me
! #else
! f = wait3;
! #endif
  
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext conftest$ac_exeext
! if { (eval echo "$as_me:5594: \"$ac_link\"") >&5
!   (eval $ac_link) 2>&5
!   ac_status=$?
!   echo "$as_me:5597: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest$ac_exeext'
!   { (eval echo "$as_me:5600: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:5603: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   ac_cv_func_wait3=yes
! else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! ac_cv_func_wait3=no
! fi
! rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
! fi
! echo "$as_me:5613: result: $ac_cv_func_wait3" >&5
! echo "${ECHO_T}$ac_cv_func_wait3" >&6
! if test $ac_cv_func_wait3 = yes; then
!   cat >>confdefs.h <<\EOF
! #define HAVE_WAIT3 1
  EOF
  
  fi
  
! echo "$as_me:5622: checking for mkfifo" >&5
! echo $ECHO_N "checking for mkfifo... $ECHO_C" >&6
! if test "${ac_cv_func_mkfifo+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 5628 "configure"
  #include "confdefs.h"
  /* System header to define __stub macros and hopefully few prototypes,
!     which can conflict with char mkfifo (); below.  */
  #include <assert.h>
  /* Override any gcc2 internal prototype to avoid an error.  */
+ #ifdef __cplusplus
+ extern "C"
+ #endif
  /* We use char because int might match the return type of a gcc2
!    builtin and then its argument prototype would still apply.  */
! char mkfifo ();
! char (*f) ();
  
+ int
+ main ()
+ {
  /* The GNU C library defines this for functions which it implements
      to always fail with ENOSYS.  Some functions are actually named
      something starting with __ and the normal name is an alias.  */
! #if defined (__stub_mkfifo) || defined (__stub___mkfifo)
  choke me
  #else
! f = mkfifo;
  #endif
  
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext conftest$ac_exeext
! if { (eval echo "$as_me:5659: \"$ac_link\"") >&5
!   (eval $ac_link) 2>&5
!   ac_status=$?
!   echo "$as_me:5662: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest$ac_exeext'
!   { (eval echo "$as_me:5665: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:5668: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   ac_cv_func_mkfifo=yes
! else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! ac_cv_func_mkfifo=no
! fi
! rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
! fi
! echo "$as_me:5678: result: $ac_cv_func_mkfifo" >&5
! echo "${ECHO_T}$ac_cv_func_mkfifo" >&6
! if test $ac_cv_func_mkfifo = yes; then
!   cat >>confdefs.h <<\EOF
! #define HAVE_MKFIFO 1
  EOF
  
  else
!   cat >>confdefs.h <<\EOF
! #define MKFIFO_MISSING 1
! EOF
  
  fi
  
! for ac_func in dup2 select getdtablesize getgroups gethostname \
! 		setdtablesize getpagesize killpg lstat getpeername sbrk \
! 		getrlimit getrusage gettimeofday waitpid tcgetpgrp \
! 		readlink
! do
! as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
! echo "$as_me:5698: checking for $ac_func" >&5
! echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
! if eval "test \"\${$as_ac_var+set}\" = set"; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 5704 "configure"
  #include "confdefs.h"
+ /* System header to define __stub macros and hopefully few prototypes,
+     which can conflict with char $ac_func (); below.  */
+ #include <assert.h>
  /* Override any gcc2 internal prototype to avoid an error.  */
+ #ifdef __cplusplus
+ extern "C"
+ #endif
  /* We use char because int might match the return type of a gcc2
!    builtin and then its argument prototype would still apply.  */
! char $ac_func ();
! char (*f) ();
  
! int
! main ()
! {
! /* The GNU C library defines this for functions which it implements
!     to always fail with ENOSYS.  Some functions are actually named
!     something starting with __ and the normal name is an alias.  */
! #if defined (__stub_$ac_func) || defined (__stub___$ac_func)
! choke me
! #else
! f = $ac_func;
! #endif
  
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext conftest$ac_exeext
! if { (eval echo "$as_me:5735: \"$ac_link\"") >&5
!   (eval $ac_link) 2>&5
!   ac_status=$?
!   echo "$as_me:5738: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest$ac_exeext'
!   { (eval echo "$as_me:5741: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:5744: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   eval "$as_ac_var=yes"
! else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! eval "$as_ac_var=no"
! fi
! rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
! fi
! echo "$as_me:5754: result: `eval echo '${'$as_ac_var'}'`" >&5
! echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
! if test `eval echo '${'$as_ac_var'}'` = yes; then
!   cat >>confdefs.h <<EOF
! #define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
  EOF
  
  fi
+ done
  
! for ac_func in rename
  do
! as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
! echo "$as_me:5767: checking for $ac_func" >&5
! echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
! if eval "test \"\${$as_ac_var+set}\" = set"; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 5773 "configure"
  #include "confdefs.h"
  /* System header to define __stub macros and hopefully few prototypes,
!     which can conflict with char $ac_func (); below.  */
  #include <assert.h>
  /* Override any gcc2 internal prototype to avoid an error.  */
+ #ifdef __cplusplus
+ extern "C"
+ #endif
  /* We use char because int might match the return type of a gcc2
!    builtin and then its argument prototype would still apply.  */
! char $ac_func ();
! char (*f) ();
  
+ int
+ main ()
+ {
  /* The GNU C library defines this for functions which it implements
      to always fail with ENOSYS.  Some functions are actually named
***************
*** 3424,4770 ****
  choke me
  #else
! $ac_func();
  #endif
  
! ; return 0; }
  EOF
- if { (eval echo configure:3432: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
-   rm -rf conftest*
-   eval "ac_cv_func_$ac_func=yes"
- else
-   echo "configure: failed program was:" >&5
-   cat conftest.$ac_ext >&5
-   rm -rf conftest*
-   eval "ac_cv_func_$ac_func=no"
- fi
- rm -f conftest*
- fi
  
- if eval "test \"`echo '$ac_cv_func_'$ac_func`\" = yes"; then
-   echo "$ac_t""yes" 1>&6
-     ac_tr_func=HAVE_`echo $ac_func | tr 'abcdefghijklmnopqrstuvwxyz' 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'`
-   cat >> confdefs.h <<EOF
- #define $ac_tr_func 1
- EOF
-  
  else
!   echo "$ac_t""no" 1>&6
  fi
  done
  
! fi
! 
! echo $ac_n "checking for sys_siglist declaration in signal.h or unistd.h""... $ac_c" 1>&6
! echo "configure:3459: checking for sys_siglist declaration in signal.h or unistd.h" >&5
! if eval "test \"`echo '$''{'ac_cv_decl_sys_siglist'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
!   cat > conftest.$ac_ext <<EOF
! #line 3464 "configure"
  #include "confdefs.h"
! #include <sys/types.h>
! #include <signal.h>
! /* NetBSD declares sys_siglist in unistd.h.  */
! #ifdef HAVE_UNISTD_H
! #include <unistd.h>
  #endif
! int main() {
! char *msg = *(sys_siglist + 1);
! ; return 0; }
! EOF
! if { (eval echo configure:3476: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
!   rm -rf conftest*
!   ac_cv_decl_sys_siglist=yes
! else
!   echo "configure: failed program was:" >&5
!   cat conftest.$ac_ext >&5
!   rm -rf conftest*
!   ac_cv_decl_sys_siglist=no
! fi
! rm -f conftest*
! fi
  
! echo "$ac_t""$ac_cv_decl_sys_siglist" 1>&6
! if test $ac_cv_decl_sys_siglist = yes; then
!   cat >> confdefs.h <<\EOF
! #define SYS_SIGLIST_DECLARED 1
  EOF
  
  fi
  
! 
! ac_header_dirent=no
! for ac_hdr in dirent.h sys/ndir.h sys/dir.h ndir.h
  do
! ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
! echo $ac_n "checking for $ac_hdr that defines DIR""... $ac_c" 1>&6
! echo "configure:3502: checking for $ac_hdr that defines DIR" >&5
! if eval "test \"`echo '$''{'ac_cv_header_dirent_$ac_safe'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
!   cat > conftest.$ac_ext <<EOF
! #line 3507 "configure"
  #include "confdefs.h"
! #include <sys/types.h>
! #include <$ac_hdr>
! int main() {
! DIR *dirp = 0;
! ; return 0; }
! EOF
! if { (eval echo configure:3515: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
!   rm -rf conftest*
!   eval "ac_cv_header_dirent_$ac_safe=yes"
! else
!   echo "configure: failed program was:" >&5
!   cat conftest.$ac_ext >&5
!   rm -rf conftest*
!   eval "ac_cv_header_dirent_$ac_safe=no"
! fi
! rm -f conftest*
! fi
! if eval "test \"`echo '$ac_cv_header_dirent_'$ac_safe`\" = yes"; then
!   echo "$ac_t""yes" 1>&6
!     ac_tr_hdr=HAVE_`echo $ac_hdr | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
!   cat >> confdefs.h <<EOF
! #define $ac_tr_hdr 1
  EOF
!  ac_header_dirent=$ac_hdr; break
! else
!   echo "$ac_t""no" 1>&6
  fi
  done
! # Two versions of opendir et al. are in -ldir and -lx on SCO Xenix.
! if test $ac_header_dirent = dirent.h; then
! echo $ac_n "checking for opendir in -ldir""... $ac_c" 1>&6
! echo "configure:3540: checking for opendir in -ldir" >&5
! ac_lib_var=`echo dir'_'opendir | sed 'y%./+-%__p_%'`
! if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
!   ac_save_LIBS="$LIBS"
! LIBS="-ldir  $LIBS"
! cat > conftest.$ac_ext <<EOF
! #line 3548 "configure"
  #include "confdefs.h"
  /* Override any gcc2 internal prototype to avoid an error.  */
  /* We use char because int might match the return type of a gcc2
!     builtin and then its argument prototype would still apply.  */
! char opendir();
  
! int main() {
! opendir()
! ; return 0; }
! EOF
! if { (eval echo configure:3559: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
!   rm -rf conftest*
!   eval "ac_cv_lib_$ac_lib_var=yes"
! else
!   echo "configure: failed program was:" >&5
!   cat conftest.$ac_ext >&5
!   rm -rf conftest*
!   eval "ac_cv_lib_$ac_lib_var=no"
! fi
! rm -f conftest*
! LIBS="$ac_save_LIBS"
  
- fi
- if eval "test \"`echo '$ac_cv_lib_'$ac_lib_var`\" = yes"; then
-   echo "$ac_t""yes" 1>&6
-   LIBS="$LIBS -ldir"
  else
!   echo "$ac_t""no" 1>&6
  fi
  
  else
! echo $ac_n "checking for opendir in -lx""... $ac_c" 1>&6
! echo "configure:3581: checking for opendir in -lx" >&5
! ac_lib_var=`echo x'_'opendir | sed 'y%./+-%__p_%'`
! if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
! else
!   ac_save_LIBS="$LIBS"
! LIBS="-lx  $LIBS"
! cat > conftest.$ac_ext <<EOF
! #line 3589 "configure"
  #include "confdefs.h"
  /* Override any gcc2 internal prototype to avoid an error.  */
  /* We use char because int might match the return type of a gcc2
!     builtin and then its argument prototype would still apply.  */
! char opendir();
  
! int main() {
! opendir()
! ; return 0; }
! EOF
! if { (eval echo configure:3600: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
!   rm -rf conftest*
!   eval "ac_cv_lib_$ac_lib_var=yes"
! else
!   echo "configure: failed program was:" >&5
!   cat conftest.$ac_ext >&5
!   rm -rf conftest*
!   eval "ac_cv_lib_$ac_lib_var=no"
! fi
! rm -f conftest*
! LIBS="$ac_save_LIBS"
  
! fi
! if eval "test \"`echo '$ac_cv_lib_'$ac_lib_var`\" = yes"; then
!   echo "$ac_t""yes" 1>&6
!   LIBS="$LIBS -lx"
! else
!   echo "$ac_t""no" 1>&6
! fi
  
  fi
  
! echo $ac_n "checking whether time.h and sys/time.h may both be included""... $ac_c" 1>&6
! echo "configure:3623: checking whether time.h and sys/time.h may both be included" >&5
! if eval "test \"`echo '$''{'ac_cv_header_time'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
!   cat > conftest.$ac_ext <<EOF
! #line 3628 "configure"
  #include "confdefs.h"
! #include <sys/types.h>
! #include <sys/time.h>
! #include <time.h>
! int main() {
! struct tm *tp;
! ; return 0; }
! EOF
! if { (eval echo configure:3637: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
!   rm -rf conftest*
!   ac_cv_header_time=yes
  else
!   echo "configure: failed program was:" >&5
!   cat conftest.$ac_ext >&5
!   rm -rf conftest*
!   ac_cv_header_time=no
  fi
! rm -f conftest*
  fi
  
! echo "$ac_t""$ac_cv_header_time" 1>&6
! if test $ac_cv_header_time = yes; then
!   cat >> confdefs.h <<\EOF
! #define TIME_WITH_SYS_TIME 1
  EOF
  
! fi
  
  
! for ac_hdr in unistd.h stdlib.h stdarg.h varargs.h limits.h string.h \
! 		 memory.h locale.h termcap.h termio.h termios.h dlfcn.h \
! 		 stddef.h netdb.h
! do
! ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
! echo $ac_n "checking for $ac_hdr""... $ac_c" 1>&6
! echo "configure:3664: checking for $ac_hdr" >&5
! if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
!   cat > conftest.$ac_ext <<EOF
! #line 3669 "configure"
  #include "confdefs.h"
! #include <$ac_hdr>
! EOF
! ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
! { (eval echo configure:3674: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
! ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
! if test -z "$ac_err"; then
!   rm -rf conftest*
!   eval "ac_cv_header_$ac_safe=yes"
  else
!   echo "$ac_err" >&5
!   echo "configure: failed program was:" >&5
!   cat conftest.$ac_ext >&5
!   rm -rf conftest*
!   eval "ac_cv_header_$ac_safe=no"
  fi
! rm -f conftest*
  fi
! if eval "test \"`echo '$ac_cv_header_'$ac_safe`\" = yes"; then
!   echo "$ac_t""yes" 1>&6
!     ac_tr_hdr=HAVE_`echo $ac_hdr | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
!   cat >> confdefs.h <<EOF
! #define $ac_tr_hdr 1
  EOF
!  
  else
!   echo "$ac_t""no" 1>&6
  fi
- done
  
! for ac_hdr in sys/ptem.h sys/pte.h sys/stream.h sys/select.h sys/file.h \
! 		 sys/resource.h sys/param.h sys/socket.h \
! 		 sys/time.h sys/times.h sys/wait.h
! do
! ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
! echo $ac_n "checking for $ac_hdr""... $ac_c" 1>&6
! echo "configure:3706: checking for $ac_hdr" >&5
! if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
!   cat > conftest.$ac_ext <<EOF
! #line 3711 "configure"
  #include "confdefs.h"
! #include <$ac_hdr>
! EOF
! ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
! { (eval echo configure:3716: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
! ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
! if test -z "$ac_err"; then
!   rm -rf conftest*
!   eval "ac_cv_header_$ac_safe=yes"
  else
!   echo "$ac_err" >&5
!   echo "configure: failed program was:" >&5
!   cat conftest.$ac_ext >&5
!   rm -rf conftest*
!   eval "ac_cv_header_$ac_safe=no"
  fi
! rm -f conftest*
  fi
! if eval "test \"`echo '$ac_cv_header_'$ac_safe`\" = yes"; then
!   echo "$ac_t""yes" 1>&6
!     ac_tr_hdr=HAVE_`echo $ac_hdr | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
!   cat >> confdefs.h <<EOF
! #define $ac_tr_hdr 1
  EOF
!  
  else
!   echo "$ac_t""no" 1>&6
  fi
- done
  
! for ac_hdr in netinet/in.h arpa/inet.h
! do
! ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
! echo $ac_n "checking for $ac_hdr""... $ac_c" 1>&6
! echo "configure:3746: checking for $ac_hdr" >&5
! if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
!   cat > conftest.$ac_ext <<EOF
! #line 3751 "configure"
  #include "confdefs.h"
! #include <$ac_hdr>
! EOF
! ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
! { (eval echo configure:3756: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
! ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
! if test -z "$ac_err"; then
!   rm -rf conftest*
!   eval "ac_cv_header_$ac_safe=yes"
  else
!   echo "$ac_err" >&5
!   echo "configure: failed program was:" >&5
!   cat conftest.$ac_ext >&5
!   rm -rf conftest*
!   eval "ac_cv_header_$ac_safe=no"
  fi
! rm -f conftest*
  fi
! if eval "test \"`echo '$ac_cv_header_'$ac_safe`\" = yes"; then
!   echo "$ac_t""yes" 1>&6
!     ac_tr_hdr=HAVE_`echo $ac_hdr | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
!   cat >> confdefs.h <<EOF
! #define $ac_tr_hdr 1
  EOF
-  
- else
-   echo "$ac_t""no" 1>&6
- fi
- done
  
  
! if test "$ac_cv_func_inet_aton" != 'yes'; then
  
! echo $ac_n "checking for inet_aton""... $ac_c" 1>&6
! echo "configure:3786: checking for inet_aton" >&5
! if eval "test \"`echo '$''{'bash_cv_func_inet_aton'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
!   cat > conftest.$ac_ext <<EOF
! #line 3791 "configure"
  #include "confdefs.h"
  
! #include <sys/types.h>
! #include <netinet/in.h>
! #include <arpa/inet.h>
! struct in_addr ap;
! int main() {
!  inet_aton("127.0.0.1", &ap); 
! ; return 0; }
! EOF
! if { (eval echo configure:3802: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
!   rm -rf conftest*
!   bash_cv_func_inet_aton=yes
  else
!   echo "configure: failed program was:" >&5
!   cat conftest.$ac_ext >&5
!   rm -rf conftest*
!   bash_cv_func_inet_aton=no
  fi
! rm -f conftest*
  fi
  
! echo "$ac_t""$bash_cv_func_inet_aton" 1>&6
! if test $bash_cv_func_inet_aton = yes; then
!   cat >> confdefs.h <<\EOF
! #define HAVE_INET_ATON 1
  EOF
  
! fi
  
  fi
  
! case "$host_os" in
! irix4*)	echo $ac_n "checking for getpwent in -lsun""... $ac_c" 1>&6
! echo "configure:3826: checking for getpwent in -lsun" >&5
! ac_lib_var=`echo sun'_'getpwent | sed 'y%./+-%__p_%'`
! if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
!   ac_save_LIBS="$LIBS"
! LIBS="-lsun  $LIBS"
! cat > conftest.$ac_ext <<EOF
! #line 3834 "configure"
  #include "confdefs.h"
- /* Override any gcc2 internal prototype to avoid an error.  */
- /* We use char because int might match the return type of a gcc2
-     builtin and then its argument prototype would still apply.  */
- char getpwent();
  
! int main() {
! getpwent()
! ; return 0; }
! EOF
! if { (eval echo configure:3845: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
!   rm -rf conftest*
!   eval "ac_cv_lib_$ac_lib_var=yes"
  else
!   echo "configure: failed program was:" >&5
!   cat conftest.$ac_ext >&5
!   rm -rf conftest*
!   eval "ac_cv_lib_$ac_lib_var=no"
  fi
! rm -f conftest*
! LIBS="$ac_save_LIBS"
! 
  fi
! if eval "test \"`echo '$ac_cv_lib_'$ac_lib_var`\" = yes"; then
!   echo "$ac_t""yes" 1>&6
!     ac_tr_lib=HAVE_LIB`echo sun | sed -e 's/[^a-zA-Z0-9_]/_/g' \
!     -e 'y/abcdefghijklmnopqrstuvwxyz/ABCDEFGHIJKLMNOPQRSTUVWXYZ/'`
!   cat >> confdefs.h <<EOF
! #define $ac_tr_lib 1
  EOF
  
-   LIBS="-lsun $LIBS"
- 
  else
!   echo "$ac_t""no" 1>&6
! fi
!  ;;
! esac
  
- if test "$ac_cv_func_getpeername" = no; then
- 	
- if test "X$bash_cv_have_socklib" = "X"; then
- _bash_needmsg=
- else
- echo $ac_n "checking for socket library""... $ac_c" 1>&6
- echo "configure:3880: checking for socket library" >&5
- _bash_needmsg=yes
  fi
! if eval "test \"`echo '$''{'bash_cv_have_socklib'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
! else
!   echo $ac_n "checking for getpeername in -lsocket""... $ac_c" 1>&6
! echo "configure:3887: checking for getpeername in -lsocket" >&5
! ac_lib_var=`echo socket'_'getpeername | sed 'y%./+-%__p_%'`
! if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
!   ac_save_LIBS="$LIBS"
! LIBS="-lsocket -lnsl $LIBS"
! cat > conftest.$ac_ext <<EOF
! #line 3895 "configure"
  #include "confdefs.h"
- /* Override any gcc2 internal prototype to avoid an error.  */
- /* We use char because int might match the return type of a gcc2
-     builtin and then its argument prototype would still apply.  */
- char getpeername();
  
! int main() {
! getpeername()
! ; return 0; }
! EOF
! if { (eval echo configure:3906: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
!   rm -rf conftest*
!   eval "ac_cv_lib_$ac_lib_var=yes"
  else
!   echo "configure: failed program was:" >&5
!   cat conftest.$ac_ext >&5
!   rm -rf conftest*
!   eval "ac_cv_lib_$ac_lib_var=no"
  fi
! rm -f conftest*
! LIBS="$ac_save_LIBS"
! 
  fi
! if eval "test \"`echo '$ac_cv_lib_'$ac_lib_var`\" = yes"; then
!   echo "$ac_t""yes" 1>&6
!   bash_cv_have_socklib=yes
  else
!   echo "$ac_t""no" 1>&6
! bash_cv_have_socklib=no
! fi
  
  fi
  
! if test "X$_bash_needmsg" = Xyes; then
!   echo "$ac_t""$bash_cv_have_socklib" 1>&6
!   _bash_needmsg=
! fi
! if test $bash_cv_have_socklib = yes; then
!   # check for libnsl, add it to LIBS if present
!   if test "X$bash_cv_have_libnsl" = "X"; then
!     _bash_needmsg=
!   else
!     echo $ac_n "checking for libnsl""... $ac_c" 1>&6
! echo "configure:3939: checking for libnsl" >&5
!     _bash_needmsg=yes
!   fi
!   if eval "test \"`echo '$''{'bash_cv_have_libnsl'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
! else
!   echo $ac_n "checking for t_open in -lnsl""... $ac_c" 1>&6
! echo "configure:3946: checking for t_open in -lnsl" >&5
! ac_lib_var=`echo nsl'_'t_open | sed 'y%./+-%__p_%'`
! if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
!   ac_save_LIBS="$LIBS"
! LIBS="-lnsl  $LIBS"
! cat > conftest.$ac_ext <<EOF
! #line 3954 "configure"
  #include "confdefs.h"
- /* Override any gcc2 internal prototype to avoid an error.  */
- /* We use char because int might match the return type of a gcc2
-     builtin and then its argument prototype would still apply.  */
- char t_open();
  
! int main() {
! t_open()
! ; return 0; }
! EOF
! if { (eval echo configure:3965: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
!   rm -rf conftest*
!   eval "ac_cv_lib_$ac_lib_var=yes"
  else
!   echo "configure: failed program was:" >&5
!   cat conftest.$ac_ext >&5
!   rm -rf conftest*
!   eval "ac_cv_lib_$ac_lib_var=no"
  fi
! rm -f conftest*
! LIBS="$ac_save_LIBS"
! 
  fi
! if eval "test \"`echo '$ac_cv_lib_'$ac_lib_var`\" = yes"; then
!   echo "$ac_t""yes" 1>&6
!   bash_cv_have_libnsl=yes
  else
!   echo "$ac_t""no" 1>&6
! bash_cv_have_libnsl=no
! fi
  
  fi
  
!   if test "X$_bash_needmsg" = Xyes; then
!     echo "$ac_t""$bash_cv_have_libnsl" 1>&6
!     _bash_needmsg=
!   fi
!   if test $bash_cv_have_libnsl = yes; then
!     LIBS="-lsocket -lnsl $LIBS"
!   else
!     LIBS="-lsocket $LIBS"
!   fi
!   cat >> confdefs.h <<\EOF
! #define HAVE_LIBSOCKET 1
! EOF
! 
!   cat >> confdefs.h <<\EOF
! #define HAVE_GETPEERNAME 1
! EOF
! 
! fi
! 
! fi
! if test "$ac_cv_func_gethostbyname" = no; then
! 	if test "X$bash_cv_have_gethostbyname" = "X"; then
! _bash_needmsg=yes
! else
! echo $ac_n "checking for gethostbyname in socket library""... $ac_c" 1>&6
! echo "configure:4013: checking for gethostbyname in socket library" >&5
! _bash_needmsg=
! fi
! if eval "test \"`echo '$''{'bash_cv_have_gethostbyname'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
!   cat > conftest.$ac_ext <<EOF
! #line 4020 "configure"
  #include "confdefs.h"
- #include <netdb.h>
- int main() {
-  struct hostent *hp;
-   hp = gethostbyname("localhost");
  
! ; return 0; }
! EOF
! if { (eval echo configure:4029: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
!   rm -rf conftest*
!   bash_cv_have_gethostbyname=yes
! else
!   echo "configure: failed program was:" >&5
!   cat conftest.$ac_ext >&5
!   rm -rf conftest*
!   bash_cv_have_gethostbyname=no
! fi
! rm -f conftest*
  
  fi
! 
! if test "X$_bash_needmsg" = Xyes; then
!     echo $ac_n "checking for gethostbyname in socket library""... $ac_c" 1>&6
! echo "configure:4044: checking for gethostbyname in socket library" >&5
  fi
! echo "$ac_t""$bash_cv_have_gethostbyname" 1>&6
! if test "$bash_cv_have_gethostbyname" = yes; then
! cat >> confdefs.h <<\EOF
! #define HAVE_GETHOSTBYNAME 1
  EOF
  
! fi
  
  fi
  
! echo $ac_n "checking for uid_t in sys/types.h""... $ac_c" 1>&6
! echo "configure:4057: checking for uid_t in sys/types.h" >&5
! if eval "test \"`echo '$''{'ac_cv_type_uid_t'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
!   cat > conftest.$ac_ext <<EOF
! #line 4062 "configure"
  #include "confdefs.h"
! #include <sys/types.h>
! EOF
! if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
!   egrep "uid_t" >/dev/null 2>&1; then
!   rm -rf conftest*
!   ac_cv_type_uid_t=yes
  else
!   rm -rf conftest*
!   ac_cv_type_uid_t=no
  fi
! rm -f conftest*
! 
  fi
! 
! echo "$ac_t""$ac_cv_type_uid_t" 1>&6
! if test $ac_cv_type_uid_t = no; then
!   cat >> confdefs.h <<\EOF
! #define uid_t int
  EOF
  
!   cat >> confdefs.h <<\EOF
! #define gid_t int
  EOF
  
  fi
  
! echo $ac_n "checking type of array argument to getgroups""... $ac_c" 1>&6
! echo "configure:4091: checking type of array argument to getgroups" >&5
! if eval "test \"`echo '$''{'ac_cv_type_getgroups'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
!   if test "$cross_compiling" = yes; then
!   ac_cv_type_getgroups=cross
! else
!   cat > conftest.$ac_ext <<EOF
! #line 4099 "configure"
  #include "confdefs.h"
  
! /* Thanks to Mike Rendell for this test.  */
! #include <sys/types.h>
! #define NGID 256
! #undef MAX
! #define MAX(x, y) ((x) > (y) ? (x) : (y))
! main()
! {
!   gid_t gidset[NGID];
!   int i, n;
!   union { gid_t gval; long lval; }  val;
  
!   val.lval = -1;
!   for (i = 0; i < NGID; i++)
!     gidset[i] = val.gval;
!   n = getgroups (sizeof (gidset) / MAX (sizeof (int), sizeof (gid_t)) - 1,
!                  gidset);
!   /* Exit non-zero if getgroups seems to require an array of ints.  This
!      happens when gid_t is short but getgroups modifies an array of ints.  */
!   exit ((n > 0 && gidset[n] != val.gval) ? 1 : 0);
  }
! 
! EOF
! if { (eval echo configure:4124: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
! then
!     ac_cv_type_getgroups=gid_t
  else
!   echo "configure: failed program was:" >&5
!   cat conftest.$ac_ext >&5
!   rm -fr conftest*
!   ac_cv_type_getgroups=int
  fi
! rm -fr conftest*
  fi
! 
! if test $ac_cv_type_getgroups = cross; then
!         cat > conftest.$ac_ext <<EOF
! #line 4138 "configure"
! #include "confdefs.h"
! #include <unistd.h>
  EOF
- if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
-   egrep "getgroups.*int.*gid_t" >/dev/null 2>&1; then
-   rm -rf conftest*
-   ac_cv_type_getgroups=gid_t
- else
-   rm -rf conftest*
-   ac_cv_type_getgroups=int
- fi
- rm -f conftest*
- 
- fi
- fi
  
! echo "$ac_t""$ac_cv_type_getgroups" 1>&6
! cat >> confdefs.h <<EOF
! #define GETGROUPS_T $ac_cv_type_getgroups
  EOF
  
  
! echo $ac_n "checking for ANSI C header files""... $ac_c" 1>&6
! echo "configure:4162: checking for ANSI C header files" >&5
! if eval "test \"`echo '$''{'ac_cv_header_stdc'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
!   cat > conftest.$ac_ext <<EOF
! #line 4167 "configure"
! #include "confdefs.h"
! #include <stdlib.h>
! #include <stdarg.h>
! #include <string.h>
! #include <float.h>
! EOF
! ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
! { (eval echo configure:4175: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
! ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
! if test -z "$ac_err"; then
!   rm -rf conftest*
!   ac_cv_header_stdc=yes
  else
!   echo "$ac_err" >&5
!   echo "configure: failed program was:" >&5
    cat conftest.$ac_ext >&5
!   rm -rf conftest*
!   ac_cv_header_stdc=no
  fi
! rm -f conftest*
! 
! if test $ac_cv_header_stdc = yes; then
!   # SunOS 4.x string.h does not declare mem*, contrary to ANSI.
! cat > conftest.$ac_ext <<EOF
! #line 4192 "configure"
! #include "confdefs.h"
! #include <string.h>
! EOF
! if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
!   egrep "memchr" >/dev/null 2>&1; then
!   :
! else
!   rm -rf conftest*
!   ac_cv_header_stdc=no
  fi
! rm -f conftest*
  
  fi
  
! if test $ac_cv_header_stdc = yes; then
!   # ISC 2.0.2 stdlib.h does not declare free, contrary to ANSI.
! cat > conftest.$ac_ext <<EOF
! #line 4210 "configure"
  #include "confdefs.h"
! #include <stdlib.h>
  EOF
- if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
-   egrep "free" >/dev/null 2>&1; then
-   :
- else
-   rm -rf conftest*
-   ac_cv_header_stdc=no
- fi
- rm -f conftest*
  
  fi
  
! if test $ac_cv_header_stdc = yes; then
!   # /bin/cc in Irix-4.0.5 gets non-ANSI ctype macros unless using -ansi.
! if test "$cross_compiling" = yes; then
!   :
  else
!   cat > conftest.$ac_ext <<EOF
! #line 4231 "configure"
  #include "confdefs.h"
- #include <ctype.h>
- #define ISLOWER(c) ('a' <= (c) && (c) <= 'z')
- #define TOUPPER(c) (ISLOWER(c) ? 'A' + ((c) - 'a') : (c))
- #define XOR(e, f) (((e) && !(f)) || (!(e) && (f)))
- int main () { int i; for (i = 0; i < 256; i++)
- if (XOR (islower (i), ISLOWER (i)) || toupper (i) != TOUPPER (i)) exit(2);
- exit (0); }
  
  EOF
- if { (eval echo configure:4242: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
- then
-   :
- else
-   echo "configure: failed program was:" >&5
-   cat conftest.$ac_ext >&5
-   rm -fr conftest*
-   ac_cv_header_stdc=no
- fi
- rm -fr conftest*
- fi
  
! fi
! fi
! 
! echo "$ac_t""$ac_cv_header_stdc" 1>&6
! if test $ac_cv_header_stdc = yes; then
!   cat >> confdefs.h <<\EOF
! #define STDC_HEADERS 1
! EOF
  
  fi
  
! echo $ac_n "checking for off_t""... $ac_c" 1>&6
! echo "configure:4266: checking for off_t" >&5
! if eval "test \"`echo '$''{'ac_cv_type_off_t'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
!   cat > conftest.$ac_ext <<EOF
! #line 4271 "configure"
  #include "confdefs.h"
! #include <sys/types.h>
! #if STDC_HEADERS
! #include <stdlib.h>
! #include <stddef.h>
  #endif
  EOF
- if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
-   egrep "(^|[^a-zA-Z_0-9])off_t[^a-zA-Z_0-9]" >/dev/null 2>&1; then
-   rm -rf conftest*
-   ac_cv_type_off_t=yes
- else
-   rm -rf conftest*
-   ac_cv_type_off_t=no
- fi
- rm -f conftest*
  
  fi
! echo "$ac_t""$ac_cv_type_off_t" 1>&6
! if test $ac_cv_type_off_t = no; then
!   cat >> confdefs.h <<\EOF
! #define off_t long
! EOF
  
  fi
  
! echo $ac_n "checking for mode_t""... $ac_c" 1>&6
! echo "configure:4299: checking for mode_t" >&5
! if eval "test \"`echo '$''{'ac_cv_type_mode_t'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
!   cat > conftest.$ac_ext <<EOF
! #line 4304 "configure"
  #include "confdefs.h"
- #include <sys/types.h>
- #if STDC_HEADERS
- #include <stdlib.h>
- #include <stddef.h>
- #endif
- EOF
- if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
-   egrep "(^|[^a-zA-Z_0-9])mode_t[^a-zA-Z_0-9]" >/dev/null 2>&1; then
-   rm -rf conftest*
-   ac_cv_type_mode_t=yes
- else
-   rm -rf conftest*
-   ac_cv_type_mode_t=no
- fi
- rm -f conftest*
  
! fi
! echo "$ac_t""$ac_cv_type_mode_t" 1>&6
! if test $ac_cv_type_mode_t = no; then
!   cat >> confdefs.h <<\EOF
! #define mode_t int
  EOF
  
  fi
  
! echo $ac_n "checking for uid_t in sys/types.h""... $ac_c" 1>&6
! echo "configure:4332: checking for uid_t in sys/types.h" >&5
! if eval "test \"`echo '$''{'ac_cv_type_uid_t'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
!   cat > conftest.$ac_ext <<EOF
! #line 4337 "configure"
  #include "confdefs.h"
! #include <sys/types.h>
! EOF
! if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
!   egrep "uid_t" >/dev/null 2>&1; then
!   rm -rf conftest*
!   ac_cv_type_uid_t=yes
! else
!   rm -rf conftest*
!   ac_cv_type_uid_t=no
! fi
! rm -f conftest*
  
! fi
  
! echo "$ac_t""$ac_cv_type_uid_t" 1>&6
! if test $ac_cv_type_uid_t = no; then
!   cat >> confdefs.h <<\EOF
! #define uid_t int
  EOF
  
!   cat >> confdefs.h <<\EOF
! #define gid_t int
! EOF
  
  fi
  
! echo $ac_n "checking for pid_t""... $ac_c" 1>&6
! echo "configure:4366: checking for pid_t" >&5
! if eval "test \"`echo '$''{'ac_cv_type_pid_t'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
!   cat > conftest.$ac_ext <<EOF
! #line 4371 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
! #if STDC_HEADERS
! #include <stdlib.h>
! #include <stddef.h>
  #endif
! EOF
! if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
!   egrep "(^|[^a-zA-Z_0-9])pid_t[^a-zA-Z_0-9]" >/dev/null 2>&1; then
!   rm -rf conftest*
!   ac_cv_type_pid_t=yes
  else
!   rm -rf conftest*
!   ac_cv_type_pid_t=no
  fi
! rm -f conftest*
! 
  fi
! echo "$ac_t""$ac_cv_type_pid_t" 1>&6
! if test $ac_cv_type_pid_t = no; then
!   cat >> confdefs.h <<\EOF
! #define pid_t int
  EOF
  
  fi
  
! echo $ac_n "checking for size_t""... $ac_c" 1>&6
! echo "configure:4399: checking for size_t" >&5
! if eval "test \"`echo '$''{'ac_cv_type_size_t'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
!   cat > conftest.$ac_ext <<EOF
! #line 4404 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
! #if STDC_HEADERS
! #include <stdlib.h>
! #include <stddef.h>
! #endif
! EOF
! if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
!   egrep "(^|[^a-zA-Z_0-9])size_t[^a-zA-Z_0-9]" >/dev/null 2>&1; then
!   rm -rf conftest*
!   ac_cv_type_size_t=yes
  else
!   rm -rf conftest*
!   ac_cv_type_size_t=no
  fi
! rm -f conftest*
! 
  fi
! echo "$ac_t""$ac_cv_type_size_t" 1>&6
! if test $ac_cv_type_size_t = no; then
!   cat >> confdefs.h <<\EOF
! #define size_t unsigned
  EOF
  
  fi
  
! echo $ac_n "checking for time_t""... $ac_c" 1>&6
! echo "configure:4432: checking for time_t" >&5
! if eval "test \"`echo '$''{'ac_cv_type_time_t'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
!   cat > conftest.$ac_ext <<EOF
! #line 4437 "configure"
  #include "confdefs.h"
! #include <sys/types.h>
! #if STDC_HEADERS
! #include <stdlib.h>
! #include <stddef.h>
  #endif
  EOF
! if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
!   egrep "(^|[^a-zA-Z_0-9])time_t[^a-zA-Z_0-9]" >/dev/null 2>&1; then
!   rm -rf conftest*
!   ac_cv_type_time_t=yes
! else
!   rm -rf conftest*
!   ac_cv_type_time_t=no
  fi
! rm -f conftest*
  
  fi
! echo "$ac_t""$ac_cv_type_time_t" 1>&6
! if test $ac_cv_type_time_t = no; then
!   cat >> confdefs.h <<\EOF
! #define time_t long
! EOF
  
  fi
  
  
! echo $ac_n "checking return type of signal handlers""... $ac_c" 1>&6
! echo "configure:4466: checking return type of signal handlers" >&5
! if eval "test \"`echo '$''{'ac_cv_type_signal'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
!   cat > conftest.$ac_ext <<EOF
! #line 4471 "configure"
  #include "confdefs.h"
! #include <sys/types.h>
! #include <signal.h>
! #ifdef signal
! #undef signal
! #endif
  #ifdef __cplusplus
! extern "C" void (*signal (int, void (*)(int)))(int);
! #else
! void (*signal ()) ();
  #endif
! 
! int main() {
! int i;
! ; return 0; }
! EOF
! if { (eval echo configure:4488: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
!   rm -rf conftest*
!   ac_cv_type_signal=void
  else
!   echo "configure: failed program was:" >&5
!   cat conftest.$ac_ext >&5
!   rm -rf conftest*
!   ac_cv_type_signal=int
  fi
! rm -f conftest*
  fi
  
! echo "$ac_t""$ac_cv_type_signal" 1>&6
! cat >> confdefs.h <<EOF
! #define RETSIGTYPE $ac_cv_type_signal
  EOF
  
  
  
! echo $ac_n "checking size of char""... $ac_c" 1>&6
! echo "configure:4508: checking size of char" >&5
! if eval "test \"`echo '$''{'ac_cv_sizeof_char'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
!   if test "$cross_compiling" = yes; then
!   ac_cv_sizeof_char=1
  else
!   cat > conftest.$ac_ext <<EOF
! #line 4516 "configure"
  #include "confdefs.h"
! #include <stdio.h>
! main()
  {
!   FILE *f=fopen("conftestval", "w");
!   if (!f) exit(1);
!   fprintf(f, "%d\n", sizeof(char));
!   exit(0);
  }
! EOF
! if { (eval echo configure:4527: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
! then
!   ac_cv_sizeof_char=`cat conftestval`
  else
!   echo "configure: failed program was:" >&5
!   cat conftest.$ac_ext >&5
!   rm -fr conftest*
!   ac_cv_sizeof_char=0
  fi
! rm -fr conftest*
  fi
  
  fi
! echo "$ac_t""$ac_cv_sizeof_char" 1>&6
! cat >> confdefs.h <<EOF
! #define SIZEOF_CHAR $ac_cv_sizeof_char
  EOF
  
  
! echo $ac_n "checking size of short""... $ac_c" 1>&6
! echo "configure:4547: checking size of short" >&5
! if eval "test \"`echo '$''{'ac_cv_sizeof_short'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
    if test "$cross_compiling" = yes; then
!   ac_cv_sizeof_short=2
  else
!   cat > conftest.$ac_ext <<EOF
! #line 4555 "configure"
  #include "confdefs.h"
! #include <stdio.h>
! main()
  {
!   FILE *f=fopen("conftestval", "w");
!   if (!f) exit(1);
!   fprintf(f, "%d\n", sizeof(short));
!   exit(0);
  }
  EOF
! if { (eval echo configure:4566: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
! then
!   ac_cv_sizeof_short=`cat conftestval`
  else
-   echo "configure: failed program was:" >&5
-   cat conftest.$ac_ext >&5
-   rm -fr conftest*
    ac_cv_sizeof_short=0
  fi
- rm -fr conftest*
  fi
! 
  fi
! echo "$ac_t""$ac_cv_sizeof_short" 1>&6
! cat >> confdefs.h <<EOF
! #define SIZEOF_SHORT $ac_cv_sizeof_short
  EOF
  
! 
! echo $ac_n "checking size of int""... $ac_c" 1>&6
! echo "configure:4586: checking size of int" >&5
! if eval "test \"`echo '$''{'ac_cv_sizeof_int'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
!   if test "$cross_compiling" = yes; then
!   ac_cv_sizeof_int=4
  else
!   cat > conftest.$ac_ext <<EOF
! #line 4594 "configure"
  #include "confdefs.h"
! #include <stdio.h>
! main()
  {
!   FILE *f=fopen("conftestval", "w");
!   if (!f) exit(1);
!   fprintf(f, "%d\n", sizeof(int));
!   exit(0);
! }
! EOF
! if { (eval echo configure:4605: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
! then
!   ac_cv_sizeof_int=`cat conftestval`
  else
!   echo "configure: failed program was:" >&5
!   cat conftest.$ac_ext >&5
!   rm -fr conftest*
!   ac_cv_sizeof_int=0
  fi
! rm -fr conftest*
  fi
! 
  fi
! echo "$ac_t""$ac_cv_sizeof_int" 1>&6
! cat >> confdefs.h <<EOF
! #define SIZEOF_INT $ac_cv_sizeof_int
! EOF
! 
! 
! echo $ac_n "checking size of long""... $ac_c" 1>&6
! echo "configure:4625: checking size of long" >&5
! if eval "test \"`echo '$''{'ac_cv_sizeof_long'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
    if test "$cross_compiling" = yes; then
!   ac_cv_sizeof_long=4
  else
!   cat > conftest.$ac_ext <<EOF
! #line 4633 "configure"
  #include "confdefs.h"
! #include <stdio.h>
! main()
  {
!   FILE *f=fopen("conftestval", "w");
!   if (!f) exit(1);
!   fprintf(f, "%d\n", sizeof(long));
!   exit(0);
! }
! EOF
! if { (eval echo configure:4644: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
! then
!   ac_cv_sizeof_long=`cat conftestval`
! else
!   echo "configure: failed program was:" >&5
!   cat conftest.$ac_ext >&5
!   rm -fr conftest*
!   ac_cv_sizeof_long=0
  fi
! rm -fr conftest*
  fi
- 
  fi
! echo "$ac_t""$ac_cv_sizeof_long" 1>&6
! cat >> confdefs.h <<EOF
! #define SIZEOF_LONG $ac_cv_sizeof_long
  EOF
  
! 
! echo $ac_n "checking size of char *""... $ac_c" 1>&6
! echo "configure:4664: checking size of char *" >&5
! if eval "test \"`echo '$''{'ac_cv_sizeof_char_p'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
!   if test "$cross_compiling" = yes; then
!   ac_cv_sizeof_char_p=4
  else
!   cat > conftest.$ac_ext <<EOF
! #line 4672 "configure"
  #include "confdefs.h"
! #include <stdio.h>
! main()
  {
!   FILE *f=fopen("conftestval", "w");
!   if (!f) exit(1);
!   fprintf(f, "%d\n", sizeof(char *));
!   exit(0);
! }
! EOF
! if { (eval echo configure:4683: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
! then
!   ac_cv_sizeof_char_p=`cat conftestval`
  else
!   echo "configure: failed program was:" >&5
!   cat conftest.$ac_ext >&5
!   rm -fr conftest*
!   ac_cv_sizeof_char_p=0
  fi
! rm -fr conftest*
  fi
! 
  fi
! echo "$ac_t""$ac_cv_sizeof_char_p" 1>&6
! cat >> confdefs.h <<EOF
! #define SIZEOF_CHAR_P $ac_cv_sizeof_char_p
! EOF
! 
! 
! echo $ac_n "checking size of double""... $ac_c" 1>&6
! echo "configure:4703: checking size of double" >&5
! if eval "test \"`echo '$''{'ac_cv_sizeof_double'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
    if test "$cross_compiling" = yes; then
!   ac_cv_sizeof_double=8
  else
!   cat > conftest.$ac_ext <<EOF
! #line 4711 "configure"
  #include "confdefs.h"
! #include <stdio.h>
! main()
  {
!   FILE *f=fopen("conftestval", "w");
!   if (!f) exit(1);
!   fprintf(f, "%d\n", sizeof(double));
!   exit(0);
  }
! EOF
! if { (eval echo configure:4722: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
! then
!   ac_cv_sizeof_double=`cat conftestval`
  else
!   echo "configure: failed program was:" >&5
!   cat conftest.$ac_ext >&5
!   rm -fr conftest*
!   ac_cv_sizeof_double=0
  fi
! rm -fr conftest*
  fi
- 
  fi
! echo "$ac_t""$ac_cv_sizeof_double" 1>&6
! cat >> confdefs.h <<EOF
! #define SIZEOF_DOUBLE $ac_cv_sizeof_double
  EOF
  
! 
! 
! echo $ac_n "checking for u_int""... $ac_c" 1>&6
! echo "configure:4743: checking for u_int" >&5
! if eval "test \"`echo '$''{'ac_cv_type_u_int'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
!   cat > conftest.$ac_ext <<EOF
! #line 4748 "configure"
  #include "confdefs.h"
! #include <sys/types.h>
! #if STDC_HEADERS
! #include <stdlib.h>
! #include <stddef.h>
! #endif
! EOF
! if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
!   egrep "(^|[^a-zA-Z_0-9])u_int[^a-zA-Z_0-9]" >/dev/null 2>&1; then
!   rm -rf conftest*
    ac_cv_type_u_int=yes
  else
!   rm -rf conftest*
!   ac_cv_type_u_int=no
! fi
! rm -f conftest*
  
! fi
! echo "$ac_t""$ac_cv_type_u_int" 1>&6
! if test $ac_cv_type_u_int = no; then
!   cat >> confdefs.h <<\EOF
  #define u_int unsigned int
  EOF
--- 5794,9846 ----
  choke me
  #else
! f = $ac_func;
  #endif
  
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext conftest$ac_exeext
! if { (eval echo "$as_me:5804: \"$ac_link\"") >&5
!   (eval $ac_link) 2>&5
!   ac_status=$?
!   echo "$as_me:5807: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest$ac_exeext'
!   { (eval echo "$as_me:5810: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:5813: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   eval "$as_ac_var=yes"
! else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! eval "$as_ac_var=no"
! fi
! rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
! fi
! echo "$as_me:5823: result: `eval echo '${'$as_ac_var'}'`" >&5
! echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
! if test `eval echo '${'$as_ac_var'}'` = yes; then
!   cat >>confdefs.h <<EOF
! #define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
  EOF
  
  else
!   LIBOBJS="$LIBOBJS $ac_func.$ac_objext"
  fi
  done
  
! for ac_func in bcopy bzero confstr sysconf pathconf setenv putenv \
! 		setlinebuf setvbuf setlocale strchr tcgetattr uname \
! 		ulimit tzset siginterrupt memmove ttyname times \
! 		getaddrinfo gethostbyname getservbyname inet_aton \
! 		vsnprintf snprintf vasprintf asprintf fnmatch
! do
! as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
! echo "$as_me:5842: checking for $ac_func" >&5
! echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
! if eval "test \"\${$as_ac_var+set}\" = set"; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 5848 "configure"
  #include "confdefs.h"
! /* System header to define __stub macros and hopefully few prototypes,
!     which can conflict with char $ac_func (); below.  */
! #include <assert.h>
! /* Override any gcc2 internal prototype to avoid an error.  */
! #ifdef __cplusplus
! extern "C"
  #endif
! /* We use char because int might match the return type of a gcc2
!    builtin and then its argument prototype would still apply.  */
! char $ac_func ();
! char (*f) ();
  
! int
! main ()
! {
! /* The GNU C library defines this for functions which it implements
!     to always fail with ENOSYS.  Some functions are actually named
!     something starting with __ and the normal name is an alias.  */
! #if defined (__stub_$ac_func) || defined (__stub___$ac_func)
! choke me
! #else
! f = $ac_func;
! #endif
! 
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext conftest$ac_exeext
! if { (eval echo "$as_me:5879: \"$ac_link\"") >&5
!   (eval $ac_link) 2>&5
!   ac_status=$?
!   echo "$as_me:5882: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest$ac_exeext'
!   { (eval echo "$as_me:5885: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:5888: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   eval "$as_ac_var=yes"
! else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! eval "$as_ac_var=no"
! fi
! rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
! fi
! echo "$as_me:5898: result: `eval echo '${'$as_ac_var'}'`" >&5
! echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
! if test `eval echo '${'$as_ac_var'}'` = yes; then
!   cat >>confdefs.h <<EOF
! #define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
  EOF
  
  fi
+ done
  
! for ac_func in isascii isblank isgraph isprint isspace isxdigit
  do
! as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
! echo "$as_me:5911: checking for $ac_func" >&5
! echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
! if eval "test \"\${$as_ac_var+set}\" = set"; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 5917 "configure"
  #include "confdefs.h"
! /* System header to define __stub macros and hopefully few prototypes,
!     which can conflict with char $ac_func (); below.  */
! #include <assert.h>
! /* Override any gcc2 internal prototype to avoid an error.  */
! #ifdef __cplusplus
! extern "C"
! #endif
! /* We use char because int might match the return type of a gcc2
!    builtin and then its argument prototype would still apply.  */
! char $ac_func ();
! char (*f) ();
! 
! int
! main ()
! {
! /* The GNU C library defines this for functions which it implements
!     to always fail with ENOSYS.  Some functions are actually named
!     something starting with __ and the normal name is an alias.  */
! #if defined (__stub_$ac_func) || defined (__stub___$ac_func)
! choke me
! #else
! f = $ac_func;
! #endif
! 
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext conftest$ac_exeext
! if { (eval echo "$as_me:5948: \"$ac_link\"") >&5
!   (eval $ac_link) 2>&5
!   ac_status=$?
!   echo "$as_me:5951: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest$ac_exeext'
!   { (eval echo "$as_me:5954: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:5957: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   eval "$as_ac_var=yes"
! else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! eval "$as_ac_var=no"
! fi
! rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
! fi
! echo "$as_me:5967: result: `eval echo '${'$as_ac_var'}'`" >&5
! echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
! if test `eval echo '${'$as_ac_var'}'` = yes; then
!   cat >>confdefs.h <<EOF
! #define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
  EOF
! 
  fi
  done
! 
! for ac_func in getcwd strcasecmp strerror strpbrk strtod
! do
! as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
! echo "$as_me:5980: checking for $ac_func" >&5
! echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
! if eval "test \"\${$as_ac_var+set}\" = set"; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 5986 "configure"
  #include "confdefs.h"
+ /* System header to define __stub macros and hopefully few prototypes,
+     which can conflict with char $ac_func (); below.  */
+ #include <assert.h>
  /* Override any gcc2 internal prototype to avoid an error.  */
+ #ifdef __cplusplus
+ extern "C"
+ #endif
  /* We use char because int might match the return type of a gcc2
!    builtin and then its argument prototype would still apply.  */
! char $ac_func ();
! char (*f) ();
  
! int
! main ()
! {
! /* The GNU C library defines this for functions which it implements
!     to always fail with ENOSYS.  Some functions are actually named
!     something starting with __ and the normal name is an alias.  */
! #if defined (__stub_$ac_func) || defined (__stub___$ac_func)
! choke me
! #else
! f = $ac_func;
! #endif
! 
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext conftest$ac_exeext
! if { (eval echo "$as_me:6017: \"$ac_link\"") >&5
!   (eval $ac_link) 2>&5
!   ac_status=$?
!   echo "$as_me:6020: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest$ac_exeext'
!   { (eval echo "$as_me:6023: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:6026: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   eval "$as_ac_var=yes"
! else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! eval "$as_ac_var=no"
! fi
! rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
! fi
! echo "$as_me:6036: result: `eval echo '${'$as_ac_var'}'`" >&5
! echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
! if test `eval echo '${'$as_ac_var'}'` = yes; then
!   cat >>confdefs.h <<EOF
! #define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
! EOF
  
  else
!   LIBOBJS="$LIBOBJS $ac_func.$ac_objext"
  fi
+ done
  
+ for ac_func in strtol strtoul strtoll strtoull strtoimax strtoumax
+ do
+ as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
+ echo "$as_me:6051: checking for $ac_func" >&5
+ echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
+ if eval "test \"\${$as_ac_var+set}\" = set"; then
+   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 6057 "configure"
  #include "confdefs.h"
+ /* System header to define __stub macros and hopefully few prototypes,
+     which can conflict with char $ac_func (); below.  */
+ #include <assert.h>
  /* Override any gcc2 internal prototype to avoid an error.  */
+ #ifdef __cplusplus
+ extern "C"
+ #endif
  /* We use char because int might match the return type of a gcc2
!    builtin and then its argument prototype would still apply.  */
! char $ac_func ();
! char (*f) ();
  
! int
! main ()
! {
! /* The GNU C library defines this for functions which it implements
!     to always fail with ENOSYS.  Some functions are actually named
!     something starting with __ and the normal name is an alias.  */
! #if defined (__stub_$ac_func) || defined (__stub___$ac_func)
! choke me
! #else
! f = $ac_func;
! #endif
  
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext conftest$ac_exeext
! if { (eval echo "$as_me:6088: \"$ac_link\"") >&5
!   (eval $ac_link) 2>&5
!   ac_status=$?
!   echo "$as_me:6091: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest$ac_exeext'
!   { (eval echo "$as_me:6094: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:6097: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   eval "$as_ac_var=yes"
! else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! eval "$as_ac_var=no"
! fi
! rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
! fi
! echo "$as_me:6107: result: `eval echo '${'$as_ac_var'}'`" >&5
! echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
! if test `eval echo '${'$as_ac_var'}'` = yes; then
!   cat >>confdefs.h <<EOF
! #define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
! EOF
  
+ else
+   LIBOBJS="$LIBOBJS $ac_func.$ac_objext"
  fi
+ done
  
! echo "$as_me:6119: checking whether strtold is declared" >&5
! echo $ECHO_N "checking whether strtold is declared... $ECHO_C" >&6
! if test "${ac_cv_have_decl_strtold+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 6125 "configure"
  #include "confdefs.h"
! $ac_includes_default
! int
! main ()
! {
! #ifndef strtold
!   char *p = (char *) strtold;
! #endif
! 
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext
! if { (eval echo "$as_me:6140: \"$ac_compile\"") >&5
!   (eval $ac_compile) 2>&5
!   ac_status=$?
!   echo "$as_me:6143: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest.$ac_objext'
!   { (eval echo "$as_me:6146: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:6149: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   ac_cv_have_decl_strtold=yes
  else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! ac_cv_have_decl_strtold=no
  fi
! rm -f conftest.$ac_objext conftest.$ac_ext
  fi
+ echo "$as_me:6159: result: $ac_cv_have_decl_strtold" >&5
+ echo "${ECHO_T}$ac_cv_have_decl_strtold" >&6
+ if test $ac_cv_have_decl_strtold = yes; then
  
! cat >>confdefs.h <<EOF
! #define HAVE_DECL_STRTOLD 1
  EOF
  
! else
!   cat >>confdefs.h <<EOF
! #define HAVE_DECL_STRTOLD 0
! EOF
  
+ fi
  
! echo "$as_me:6174: checking whether confstr is declared" >&5
! echo $ECHO_N "checking whether confstr is declared... $ECHO_C" >&6
! if test "${ac_cv_have_decl_confstr+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 6180 "configure"
  #include "confdefs.h"
! $ac_includes_default
! int
! main ()
! {
! #ifndef confstr
!   char *p = (char *) confstr;
! #endif
! 
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext
! if { (eval echo "$as_me:6195: \"$ac_compile\"") >&5
!   (eval $ac_compile) 2>&5
!   ac_status=$?
!   echo "$as_me:6198: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest.$ac_objext'
!   { (eval echo "$as_me:6201: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:6204: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   ac_cv_have_decl_confstr=yes
  else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! ac_cv_have_decl_confstr=no
  fi
! rm -f conftest.$ac_objext conftest.$ac_ext
  fi
! echo "$as_me:6214: result: $ac_cv_have_decl_confstr" >&5
! echo "${ECHO_T}$ac_cv_have_decl_confstr" >&6
! if test $ac_cv_have_decl_confstr = yes; then
! 
! cat >>confdefs.h <<EOF
! #define HAVE_DECL_CONFSTR 1
  EOF
! 
  else
!   cat >>confdefs.h <<EOF
! #define HAVE_DECL_CONFSTR 0
! EOF
! 
  fi
  
! echo "$as_me:6229: checking whether sbrk is declared" >&5
! echo $ECHO_N "checking whether sbrk is declared... $ECHO_C" >&6
! if test "${ac_cv_have_decl_sbrk+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 6235 "configure"
  #include "confdefs.h"
! $ac_includes_default
! int
! main ()
! {
! #ifndef sbrk
!   char *p = (char *) sbrk;
! #endif
! 
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext
! if { (eval echo "$as_me:6250: \"$ac_compile\"") >&5
!   (eval $ac_compile) 2>&5
!   ac_status=$?
!   echo "$as_me:6253: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest.$ac_objext'
!   { (eval echo "$as_me:6256: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:6259: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   ac_cv_have_decl_sbrk=yes
  else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! ac_cv_have_decl_sbrk=no
  fi
! rm -f conftest.$ac_objext conftest.$ac_ext
  fi
! echo "$as_me:6269: result: $ac_cv_have_decl_sbrk" >&5
! echo "${ECHO_T}$ac_cv_have_decl_sbrk" >&6
! if test $ac_cv_have_decl_sbrk = yes; then
! 
! cat >>confdefs.h <<EOF
! #define HAVE_DECL_SBRK 1
  EOF
! 
  else
!   cat >>confdefs.h <<EOF
! #define HAVE_DECL_SBRK 0
! EOF
! 
  fi
  
! echo "$as_me:6284: checking whether printf is declared" >&5
! echo $ECHO_N "checking whether printf is declared... $ECHO_C" >&6
! if test "${ac_cv_have_decl_printf+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 6290 "configure"
  #include "confdefs.h"
! $ac_includes_default
! int
! main ()
! {
! #ifndef printf
!   char *p = (char *) printf;
! #endif
! 
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext
! if { (eval echo "$as_me:6305: \"$ac_compile\"") >&5
!   (eval $ac_compile) 2>&5
!   ac_status=$?
!   echo "$as_me:6308: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest.$ac_objext'
!   { (eval echo "$as_me:6311: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:6314: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   ac_cv_have_decl_printf=yes
  else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! ac_cv_have_decl_printf=no
  fi
! rm -f conftest.$ac_objext conftest.$ac_ext
  fi
! echo "$as_me:6324: result: $ac_cv_have_decl_printf" >&5
! echo "${ECHO_T}$ac_cv_have_decl_printf" >&6
! if test $ac_cv_have_decl_printf = yes; then
! 
! cat >>confdefs.h <<EOF
! #define HAVE_DECL_PRINTF 1
  EOF
  
+ else
+   cat >>confdefs.h <<EOF
+ #define HAVE_DECL_PRINTF 0
+ EOF
  
! fi
  
! echo "$as_me:6339: checking whether strsignal is declared" >&5
! echo $ECHO_N "checking whether strsignal is declared... $ECHO_C" >&6
! if test "${ac_cv_have_decl_strsignal+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 6345 "configure"
  #include "confdefs.h"
+ $ac_includes_default
+ int
+ main ()
+ {
+ #ifndef strsignal
+   char *p = (char *) strsignal;
+ #endif
  
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext
! if { (eval echo "$as_me:6360: \"$ac_compile\"") >&5
!   (eval $ac_compile) 2>&5
!   ac_status=$?
!   echo "$as_me:6363: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest.$ac_objext'
!   { (eval echo "$as_me:6366: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:6369: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   ac_cv_have_decl_strsignal=yes
  else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! ac_cv_have_decl_strsignal=no
  fi
! rm -f conftest.$ac_objext conftest.$ac_ext
  fi
+ echo "$as_me:6379: result: $ac_cv_have_decl_strsignal" >&5
+ echo "${ECHO_T}$ac_cv_have_decl_strsignal" >&6
+ if test $ac_cv_have_decl_strsignal = yes; then
  
! cat >>confdefs.h <<EOF
! #define HAVE_DECL_STRSIGNAL 1
  EOF
  
! else
!   cat >>confdefs.h <<EOF
! #define HAVE_DECL_STRSIGNAL 0
! EOF
  
  fi
  
! echo "$as_me:6394: checking for declaration of strtoimax" >&5
! echo $ECHO_N "checking for declaration of strtoimax... $ECHO_C" >&6
! if test "${bash_cv_decl_strtoimax+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 6400 "configure"
  #include "confdefs.h"
  
! #if STDC_HEADERS
! #  include <stdlib.h>
! #endif
! #if HAVE_INTTYPES_H
! #  include <inttypes.h>
! #endif
! 
! int
! main ()
! {
! return !strtoimax;
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext conftest$ac_exeext
! if { (eval echo "$as_me:6419: \"$ac_link\"") >&5
!   (eval $ac_link) 2>&5
!   ac_status=$?
!   echo "$as_me:6422: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest$ac_exeext'
!   { (eval echo "$as_me:6425: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:6428: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   bash_cv_decl_strtoimax=yes
  else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! bash_cv_decl_strtoimax=no
  fi
! rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
  fi
! echo "$as_me:6438: result: $bash_cv_decl_strtoimax" >&5
! echo "${ECHO_T}$bash_cv_decl_strtoimax" >&6
! bash_tr_func=HAVE_DECL_`echo strtoimax | tr 'abcdefghijklmnopqrstuvwxyz' 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'`
! if test $bash_cv_decl_strtoimax = yes; then
!   cat >>confdefs.h <<EOF
! #define $bash_tr_func 1
  EOF
  
  else
!   cat >>confdefs.h <<EOF
! #define $bash_tr_func 0
! EOF
  
  fi
! 
! echo "$as_me:6453: checking for declaration of strtol" >&5
! echo $ECHO_N "checking for declaration of strtol... $ECHO_C" >&6
! if test "${bash_cv_decl_strtol+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 6459 "configure"
  #include "confdefs.h"
  
! #if STDC_HEADERS
! #  include <stdlib.h>
! #endif
! #if HAVE_INTTYPES_H
! #  include <inttypes.h>
! #endif
! 
! int
! main ()
! {
! return !strtol;
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext conftest$ac_exeext
! if { (eval echo "$as_me:6478: \"$ac_link\"") >&5
!   (eval $ac_link) 2>&5
!   ac_status=$?
!   echo "$as_me:6481: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest$ac_exeext'
!   { (eval echo "$as_me:6484: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:6487: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   bash_cv_decl_strtol=yes
  else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! bash_cv_decl_strtol=no
  fi
! rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
  fi
! echo "$as_me:6497: result: $bash_cv_decl_strtol" >&5
! echo "${ECHO_T}$bash_cv_decl_strtol" >&6
! bash_tr_func=HAVE_DECL_`echo strtol | tr 'abcdefghijklmnopqrstuvwxyz' 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'`
! if test $bash_cv_decl_strtol = yes; then
!   cat >>confdefs.h <<EOF
! #define $bash_tr_func 1
! EOF
! 
  else
!   cat >>confdefs.h <<EOF
! #define $bash_tr_func 0
! EOF
  
  fi
  
! echo "$as_me:6512: checking for declaration of strtoll" >&5
! echo $ECHO_N "checking for declaration of strtoll... $ECHO_C" >&6
! if test "${bash_cv_decl_strtoll+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 6518 "configure"
  #include "confdefs.h"
  
! #if STDC_HEADERS
! #  include <stdlib.h>
! #endif
! #if HAVE_INTTYPES_H
! #  include <inttypes.h>
! #endif
! 
! int
! main ()
! {
! return !strtoll;
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext conftest$ac_exeext
! if { (eval echo "$as_me:6537: \"$ac_link\"") >&5
!   (eval $ac_link) 2>&5
!   ac_status=$?
!   echo "$as_me:6540: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest$ac_exeext'
!   { (eval echo "$as_me:6543: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:6546: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   bash_cv_decl_strtoll=yes
  else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! bash_cv_decl_strtoll=no
  fi
! rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
  fi
! echo "$as_me:6556: result: $bash_cv_decl_strtoll" >&5
! echo "${ECHO_T}$bash_cv_decl_strtoll" >&6
! bash_tr_func=HAVE_DECL_`echo strtoll | tr 'abcdefghijklmnopqrstuvwxyz' 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'`
! if test $bash_cv_decl_strtoll = yes; then
!   cat >>confdefs.h <<EOF
! #define $bash_tr_func 1
! EOF
! 
  else
!   cat >>confdefs.h <<EOF
! #define $bash_tr_func 0
! EOF
  
  fi
  
! echo "$as_me:6571: checking for declaration of strtoul" >&5
! echo $ECHO_N "checking for declaration of strtoul... $ECHO_C" >&6
! if test "${bash_cv_decl_strtoul+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 6577 "configure"
  #include "confdefs.h"
  
! #if STDC_HEADERS
! #  include <stdlib.h>
! #endif
! #if HAVE_INTTYPES_H
! #  include <inttypes.h>
! #endif
  
+ int
+ main ()
+ {
+ return !strtoul;
+   ;
+   return 0;
+ }
+ _ACEOF
+ rm -f conftest.$ac_objext conftest$ac_exeext
+ if { (eval echo "$as_me:6596: \"$ac_link\"") >&5
+   (eval $ac_link) 2>&5
+   ac_status=$?
+   echo "$as_me:6599: \$? = $ac_status" >&5
+   (exit $ac_status); } &&
+          { ac_try='test -s conftest$ac_exeext'
+   { (eval echo "$as_me:6602: \"$ac_try\"") >&5
+   (eval $ac_try) 2>&5
+   ac_status=$?
+   echo "$as_me:6605: \$? = $ac_status" >&5
+   (exit $ac_status); }; }; then
+   bash_cv_decl_strtoul=yes
+ else
+   echo "$as_me: failed program was:" >&5
+ cat conftest.$ac_ext >&5
+ bash_cv_decl_strtoul=no
  fi
! rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
  fi
! echo "$as_me:6615: result: $bash_cv_decl_strtoul" >&5
! echo "${ECHO_T}$bash_cv_decl_strtoul" >&6
! bash_tr_func=HAVE_DECL_`echo strtoul | tr 'abcdefghijklmnopqrstuvwxyz' 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'`
! if test $bash_cv_decl_strtoul = yes; then
!   cat >>confdefs.h <<EOF
! #define $bash_tr_func 1
  EOF
  
! else
!   cat >>confdefs.h <<EOF
! #define $bash_tr_func 0
! EOF
  
  fi
  
! echo "$as_me:6630: checking for declaration of strtoull" >&5
! echo $ECHO_N "checking for declaration of strtoull... $ECHO_C" >&6
! if test "${bash_cv_decl_strtoull+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 6636 "configure"
  #include "confdefs.h"
! 
! #if STDC_HEADERS
! #  include <stdlib.h>
! #endif
! #if HAVE_INTTYPES_H
! #  include <inttypes.h>
! #endif
! 
! int
! main ()
! {
! return !strtoull;
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext conftest$ac_exeext
! if { (eval echo "$as_me:6655: \"$ac_link\"") >&5
!   (eval $ac_link) 2>&5
!   ac_status=$?
!   echo "$as_me:6658: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest$ac_exeext'
!   { (eval echo "$as_me:6661: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:6664: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   bash_cv_decl_strtoull=yes
  else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! bash_cv_decl_strtoull=no
  fi
! rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
  fi
! echo "$as_me:6674: result: $bash_cv_decl_strtoull" >&5
! echo "${ECHO_T}$bash_cv_decl_strtoull" >&6
! bash_tr_func=HAVE_DECL_`echo strtoull | tr 'abcdefghijklmnopqrstuvwxyz' 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'`
! if test $bash_cv_decl_strtoull = yes; then
!   cat >>confdefs.h <<EOF
! #define $bash_tr_func 1
  EOF
  
! else
!   cat >>confdefs.h <<EOF
! #define $bash_tr_func 0
  EOF
  
  fi
  
! echo "$as_me:6689: checking for declaration of strtoumax" >&5
! echo $ECHO_N "checking for declaration of strtoumax... $ECHO_C" >&6
! if test "${bash_cv_decl_strtoumax+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 6695 "configure"
  #include "confdefs.h"
  
! #if STDC_HEADERS
! #  include <stdlib.h>
! #endif
! #if HAVE_INTTYPES_H
! #  include <inttypes.h>
! #endif
  
! int
! main ()
! {
! return !strtoumax;
!   ;
!   return 0;
  }
! _ACEOF
! rm -f conftest.$ac_objext conftest$ac_exeext
! if { (eval echo "$as_me:6714: \"$ac_link\"") >&5
!   (eval $ac_link) 2>&5
!   ac_status=$?
!   echo "$as_me:6717: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest$ac_exeext'
!   { (eval echo "$as_me:6720: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:6723: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   bash_cv_decl_strtoumax=yes
  else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! bash_cv_decl_strtoumax=no
  fi
! rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
  fi
! echo "$as_me:6733: result: $bash_cv_decl_strtoumax" >&5
! echo "${ECHO_T}$bash_cv_decl_strtoumax" >&6
! bash_tr_func=HAVE_DECL_`echo strtoumax | tr 'abcdefghijklmnopqrstuvwxyz' 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'`
! if test $bash_cv_decl_strtoumax = yes; then
!   cat >>confdefs.h <<EOF
! #define $bash_tr_func 1
  EOF
  
! else
!   cat >>confdefs.h <<EOF
! #define $bash_tr_func 0
  EOF
  
+ fi
  
! for ac_header in libintl.h
! do
! as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
! echo "$as_me:6751: checking for $ac_header" >&5
! echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
! if eval "test \"\${$as_ac_Header+set}\" = set"; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
! else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 6757 "configure"
! #include "confdefs.h"
! #include <$ac_header>
! _ACEOF
! if { (eval echo "$as_me:6761: \"$ac_cpp conftest.$ac_ext\"") >&5
!   (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
!   ac_status=$?
!   egrep -v '^ *\+' conftest.er1 >conftest.err
!   rm -f conftest.er1
!   cat conftest.err >&5
!   echo "$as_me:6767: \$? = $ac_status" >&5
!   (exit $ac_status); } >/dev/null; then
!   if test -s conftest.err; then
!     ac_cpp_err=$ac_c_preproc_warn_flag
!   else
!     ac_cpp_err=
!   fi
  else
!   ac_cpp_err=yes
! fi
! if test -z "$ac_cpp_err"; then
!   eval "$as_ac_Header=yes"
  else
!   echo "$as_me: failed program was:" >&5
    cat conftest.$ac_ext >&5
!   eval "$as_ac_Header=no"
  fi
! rm -f conftest.err conftest.$ac_ext
  fi
! echo "$as_me:6786: result: `eval echo '${'$as_ac_Header'}'`" >&5
! echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
! if test `eval echo '${'$as_ac_Header'}'` = yes; then
!   cat >>confdefs.h <<EOF
! #define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
! EOF
  
  fi
+ done
  
! for ac_func in gettext textdomain bindtextdomain
! do
! as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
! echo "$as_me:6799: checking for $ac_func" >&5
! echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
! if eval "test \"\${$as_ac_var+set}\" = set"; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
! else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 6805 "configure"
  #include "confdefs.h"
! /* System header to define __stub macros and hopefully few prototypes,
!     which can conflict with char $ac_func (); below.  */
! #include <assert.h>
! /* Override any gcc2 internal prototype to avoid an error.  */
! #ifdef __cplusplus
! extern "C"
! #endif
! /* We use char because int might match the return type of a gcc2
!    builtin and then its argument prototype would still apply.  */
! char $ac_func ();
! char (*f) ();
! 
! int
! main ()
! {
! /* The GNU C library defines this for functions which it implements
!     to always fail with ENOSYS.  Some functions are actually named
!     something starting with __ and the normal name is an alias.  */
! #if defined (__stub_$ac_func) || defined (__stub___$ac_func)
! choke me
! #else
! f = $ac_func;
! #endif
! 
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext conftest$ac_exeext
! if { (eval echo "$as_me:6836: \"$ac_link\"") >&5
!   (eval $ac_link) 2>&5
!   ac_status=$?
!   echo "$as_me:6839: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest$ac_exeext'
!   { (eval echo "$as_me:6842: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:6845: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   eval "$as_ac_var=yes"
! else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! eval "$as_ac_var=no"
! fi
! rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
! fi
! echo "$as_me:6855: result: `eval echo '${'$as_ac_var'}'`" >&5
! echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
! if test `eval echo '${'$as_ac_var'}'` = yes; then
!   cat >>confdefs.h <<EOF
! #define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
  EOF
  
  fi
+ done
  
! if test "$ac_cv_func_bindtextdomain" = "no"; then
! 
! echo "$as_me:6867: checking for bindtextdomain in -lintl" >&5
! echo $ECHO_N "checking for bindtextdomain in -lintl... $ECHO_C" >&6
! if test "${ac_cv_lib_intl_bindtextdomain+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
!   ac_check_lib_save_LIBS=$LIBS
! LIBS="-lintl  $LIBS"
! cat >conftest.$ac_ext <<_ACEOF
! #line 6875 "configure"
  #include "confdefs.h"
  
+ /* Override any gcc2 internal prototype to avoid an error.  */
+ #ifdef __cplusplus
+ extern "C"
+ #endif
+ /* We use char because int might match the return type of a gcc2
+    builtin and then its argument prototype would still apply.  */
+ char bindtextdomain ();
+ int
+ main ()
+ {
+ bindtextdomain ();
+   ;
+   return 0;
+ }
+ _ACEOF
+ rm -f conftest.$ac_objext conftest$ac_exeext
+ if { (eval echo "$as_me:6894: \"$ac_link\"") >&5
+   (eval $ac_link) 2>&5
+   ac_status=$?
+   echo "$as_me:6897: \$? = $ac_status" >&5
+   (exit $ac_status); } &&
+          { ac_try='test -s conftest$ac_exeext'
+   { (eval echo "$as_me:6900: \"$ac_try\"") >&5
+   (eval $ac_try) 2>&5
+   ac_status=$?
+   echo "$as_me:6903: \$? = $ac_status" >&5
+   (exit $ac_status); }; }; then
+   ac_cv_lib_intl_bindtextdomain=yes
+ else
+   echo "$as_me: failed program was:" >&5
+ cat conftest.$ac_ext >&5
+ ac_cv_lib_intl_bindtextdomain=no
+ fi
+ rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+ LIBS=$ac_check_lib_save_LIBS
+ fi
+ echo "$as_me:6914: result: $ac_cv_lib_intl_bindtextdomain" >&5
+ echo "${ECHO_T}$ac_cv_lib_intl_bindtextdomain" >&6
+ if test $ac_cv_lib_intl_bindtextdomain = yes; then
+   cat >>confdefs.h <<EOF
+ #define HAVE_LIBINTL 1
  EOF
  
!   LIBS="-lintl $LIBS"
  
  fi
  
!     if test "$ac_cv_lib_intl" = "yes"; then
! 
! for ac_func in gettext textdomain bindtextdomain
! do
! as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
! echo "$as_me:6930: checking for $ac_func" >&5
! echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
! if eval "test \"\${$as_ac_var+set}\" = set"; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 6936 "configure"
  #include "confdefs.h"
! /* System header to define __stub macros and hopefully few prototypes,
!     which can conflict with char $ac_func (); below.  */
! #include <assert.h>
! /* Override any gcc2 internal prototype to avoid an error.  */
! #ifdef __cplusplus
! extern "C"
  #endif
+ /* We use char because int might match the return type of a gcc2
+    builtin and then its argument prototype would still apply.  */
+ char $ac_func ();
+ char (*f) ();
+ 
+ int
+ main ()
+ {
+ /* The GNU C library defines this for functions which it implements
+     to always fail with ENOSYS.  Some functions are actually named
+     something starting with __ and the normal name is an alias.  */
+ #if defined (__stub_$ac_func) || defined (__stub___$ac_func)
+ choke me
+ #else
+ f = $ac_func;
+ #endif
+ 
+   ;
+   return 0;
+ }
+ _ACEOF
+ rm -f conftest.$ac_objext conftest$ac_exeext
+ if { (eval echo "$as_me:6967: \"$ac_link\"") >&5
+   (eval $ac_link) 2>&5
+   ac_status=$?
+   echo "$as_me:6970: \$? = $ac_status" >&5
+   (exit $ac_status); } &&
+          { ac_try='test -s conftest$ac_exeext'
+   { (eval echo "$as_me:6973: \"$ac_try\"") >&5
+   (eval $ac_try) 2>&5
+   ac_status=$?
+   echo "$as_me:6976: \$? = $ac_status" >&5
+   (exit $ac_status); }; }; then
+   eval "$as_ac_var=yes"
+ else
+   echo "$as_me: failed program was:" >&5
+ cat conftest.$ac_ext >&5
+ eval "$as_ac_var=no"
+ fi
+ rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+ fi
+ echo "$as_me:6986: result: `eval echo '${'$as_ac_var'}'`" >&5
+ echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
+ if test `eval echo '${'$as_ac_var'}'` = yes; then
+   cat >>confdefs.h <<EOF
+ #define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
  EOF
  
  fi
! done
  
+     fi
  fi
  
! if test "$opt_static_link" != yes; then
! 
! echo "$as_me:7001: checking for dlopen in -ldl" >&5
! echo $ECHO_N "checking for dlopen in -ldl... $ECHO_C" >&6
! if test "${ac_cv_lib_dl_dlopen+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
!   ac_check_lib_save_LIBS=$LIBS
! LIBS="-ldl  $LIBS"
! cat >conftest.$ac_ext <<_ACEOF
! #line 7009 "configure"
  #include "confdefs.h"
  
! /* Override any gcc2 internal prototype to avoid an error.  */
! #ifdef __cplusplus
! extern "C"
! #endif
! /* We use char because int might match the return type of a gcc2
!    builtin and then its argument prototype would still apply.  */
! char dlopen ();
! int
! main ()
! {
! dlopen ();
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext conftest$ac_exeext
! if { (eval echo "$as_me:7028: \"$ac_link\"") >&5
!   (eval $ac_link) 2>&5
!   ac_status=$?
!   echo "$as_me:7031: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest$ac_exeext'
!   { (eval echo "$as_me:7034: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:7037: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   ac_cv_lib_dl_dlopen=yes
! else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! ac_cv_lib_dl_dlopen=no
! fi
! rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
! LIBS=$ac_check_lib_save_LIBS
! fi
! echo "$as_me:7048: result: $ac_cv_lib_dl_dlopen" >&5
! echo "${ECHO_T}$ac_cv_lib_dl_dlopen" >&6
! if test $ac_cv_lib_dl_dlopen = yes; then
!   cat >>confdefs.h <<EOF
! #define HAVE_LIBDL 1
  EOF
  
+   LIBS="-ldl $LIBS"
+ 
  fi
  
! for ac_func in dlopen dlclose dlsym
! do
! as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
! echo "$as_me:7062: checking for $ac_func" >&5
! echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
! if eval "test \"\${$as_ac_var+set}\" = set"; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 7068 "configure"
  #include "confdefs.h"
! /* System header to define __stub macros and hopefully few prototypes,
!     which can conflict with char $ac_func (); below.  */
! #include <assert.h>
! /* Override any gcc2 internal prototype to avoid an error.  */
! #ifdef __cplusplus
! extern "C"
! #endif
! /* We use char because int might match the return type of a gcc2
!    builtin and then its argument prototype would still apply.  */
! char $ac_func ();
! char (*f) ();
  
! int
! main ()
! {
! /* The GNU C library defines this for functions which it implements
!     to always fail with ENOSYS.  Some functions are actually named
!     something starting with __ and the normal name is an alias.  */
! #if defined (__stub_$ac_func) || defined (__stub___$ac_func)
! choke me
! #else
! f = $ac_func;
! #endif
  
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext conftest$ac_exeext
! if { (eval echo "$as_me:7099: \"$ac_link\"") >&5
!   (eval $ac_link) 2>&5
!   ac_status=$?
!   echo "$as_me:7102: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest$ac_exeext'
!   { (eval echo "$as_me:7105: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:7108: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   eval "$as_ac_var=yes"
! else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! eval "$as_ac_var=no"
! fi
! rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
! fi
! echo "$as_me:7118: result: `eval echo '${'$as_ac_var'}'`" >&5
! echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
! if test `eval echo '${'$as_ac_var'}'` = yes; then
!   cat >>confdefs.h <<EOF
! #define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
  EOF
  
! fi
! done
  
  fi
  
! echo "$as_me:7130: checking for sys_siglist declaration in signal.h or unistd.h" >&5
! echo $ECHO_N "checking for sys_siglist declaration in signal.h or unistd.h... $ECHO_C" >&6
! if test "${ac_cv_decl_sys_siglist+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 7136 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
! #include <signal.h>
! /* NetBSD declares sys_siglist in unistd.h.  */
! #if HAVE_UNISTD_H
! # include <unistd.h>
  #endif
! 
! int
! main ()
! {
! char *msg = *(sys_siglist + 1);
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext
! if { (eval echo "$as_me:7154: \"$ac_compile\"") >&5
!   (eval $ac_compile) 2>&5
!   ac_status=$?
!   echo "$as_me:7157: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest.$ac_objext'
!   { (eval echo "$as_me:7160: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:7163: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   ac_cv_decl_sys_siglist=yes
  else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! ac_cv_decl_sys_siglist=no
  fi
! rm -f conftest.$ac_objext conftest.$ac_ext
  fi
! echo "$as_me:7173: result: $ac_cv_decl_sys_siglist" >&5
! echo "${ECHO_T}$ac_cv_decl_sys_siglist" >&6
! if test $ac_cv_decl_sys_siglist = yes; then
! 
! cat >>confdefs.h <<\EOF
! #define SYS_SIGLIST_DECLARED 1
  EOF
  
  fi
  
! if test "$ac_cv_func_inet_aton" != 'yes'; then
! 
! echo "$as_me:7185: checking for inet_aton" >&5
! echo $ECHO_N "checking for inet_aton... $ECHO_C" >&6
! if test "${bash_cv_func_inet_aton+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 7191 "configure"
  #include "confdefs.h"
+ 
  #include <sys/types.h>
! #include <netinet/in.h>
! #include <arpa/inet.h>
! struct in_addr ap;
! int
! main ()
! {
!  inet_aton("127.0.0.1", &ap);
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext conftest$ac_exeext
! if { (eval echo "$as_me:7207: \"$ac_link\"") >&5
!   (eval $ac_link) 2>&5
!   ac_status=$?
!   echo "$as_me:7210: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest$ac_exeext'
!   { (eval echo "$as_me:7213: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:7216: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   bash_cv_func_inet_aton=yes
  else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! bash_cv_func_inet_aton=no
  fi
! rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
  fi
! echo "$as_me:7226: result: $bash_cv_func_inet_aton" >&5
! echo "${ECHO_T}$bash_cv_func_inet_aton" >&6
! if test $bash_cv_func_inet_aton = yes; then
!   cat >>confdefs.h <<\EOF
! #define HAVE_INET_ATON 1
  EOF
  
+ else
+   LIBOBJS="$LIBOBJS inet_aton.$ac_objext"
+ fi
+ 
  fi
  
! case "$host_os" in
! irix4*)
! echo "$as_me:7241: checking for getpwent in -lsun" >&5
! echo $ECHO_N "checking for getpwent in -lsun... $ECHO_C" >&6
! if test "${ac_cv_lib_sun_getpwent+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
!   ac_check_lib_save_LIBS=$LIBS
! LIBS="-lsun  $LIBS"
! cat >conftest.$ac_ext <<_ACEOF
! #line 7249 "configure"
  #include "confdefs.h"
! 
! /* Override any gcc2 internal prototype to avoid an error.  */
! #ifdef __cplusplus
! extern "C"
  #endif
+ /* We use char because int might match the return type of a gcc2
+    builtin and then its argument prototype would still apply.  */
+ char getpwent ();
+ int
+ main ()
+ {
+ getpwent ();
+   ;
+   return 0;
+ }
+ _ACEOF
+ rm -f conftest.$ac_objext conftest$ac_exeext
+ if { (eval echo "$as_me:7268: \"$ac_link\"") >&5
+   (eval $ac_link) 2>&5
+   ac_status=$?
+   echo "$as_me:7271: \$? = $ac_status" >&5
+   (exit $ac_status); } &&
+          { ac_try='test -s conftest$ac_exeext'
+   { (eval echo "$as_me:7274: \"$ac_try\"") >&5
+   (eval $ac_try) 2>&5
+   ac_status=$?
+   echo "$as_me:7277: \$? = $ac_status" >&5
+   (exit $ac_status); }; }; then
+   ac_cv_lib_sun_getpwent=yes
+ else
+   echo "$as_me: failed program was:" >&5
+ cat conftest.$ac_ext >&5
+ ac_cv_lib_sun_getpwent=no
+ fi
+ rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+ LIBS=$ac_check_lib_save_LIBS
+ fi
+ echo "$as_me:7288: result: $ac_cv_lib_sun_getpwent" >&5
+ echo "${ECHO_T}$ac_cv_lib_sun_getpwent" >&6
+ if test $ac_cv_lib_sun_getpwent = yes; then
+   cat >>confdefs.h <<EOF
+ #define HAVE_LIBSUN 1
  EOF
! 
!   LIBS="-lsun $LIBS"
! 
  fi
!  ;;
! esac
! 
! if test "$ac_cv_func_getpeername" = no; then
  
+ if test "X$bash_cv_have_socklib" = "X"; then
+ _bash_needmsg=
+ else
+ echo "$as_me:7306: checking for socket library" >&5
+ echo $ECHO_N "checking for socket library... $ECHO_C" >&6
+ _bash_needmsg=yes
  fi
! if test "${bash_cv_have_socklib+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
! else
!   echo "$as_me:7313: checking for getpeername in -lsocket" >&5
! echo $ECHO_N "checking for getpeername in -lsocket... $ECHO_C" >&6
! if test "${ac_cv_lib_socket_getpeername+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
! else
!   ac_check_lib_save_LIBS=$LIBS
! LIBS="-lsocket -lnsl $LIBS"
! cat >conftest.$ac_ext <<_ACEOF
! #line 7321 "configure"
! #include "confdefs.h"
  
+ /* Override any gcc2 internal prototype to avoid an error.  */
+ #ifdef __cplusplus
+ extern "C"
+ #endif
+ /* We use char because int might match the return type of a gcc2
+    builtin and then its argument prototype would still apply.  */
+ char getpeername ();
+ int
+ main ()
+ {
+ getpeername ();
+   ;
+   return 0;
+ }
+ _ACEOF
+ rm -f conftest.$ac_objext conftest$ac_exeext
+ if { (eval echo "$as_me:7340: \"$ac_link\"") >&5
+   (eval $ac_link) 2>&5
+   ac_status=$?
+   echo "$as_me:7343: \$? = $ac_status" >&5
+   (exit $ac_status); } &&
+          { ac_try='test -s conftest$ac_exeext'
+   { (eval echo "$as_me:7346: \"$ac_try\"") >&5
+   (eval $ac_try) 2>&5
+   ac_status=$?
+   echo "$as_me:7349: \$? = $ac_status" >&5
+   (exit $ac_status); }; }; then
+   ac_cv_lib_socket_getpeername=yes
+ else
+   echo "$as_me: failed program was:" >&5
+ cat conftest.$ac_ext >&5
+ ac_cv_lib_socket_getpeername=no
+ fi
+ rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+ LIBS=$ac_check_lib_save_LIBS
+ fi
+ echo "$as_me:7360: result: $ac_cv_lib_socket_getpeername" >&5
+ echo "${ECHO_T}$ac_cv_lib_socket_getpeername" >&6
+ if test $ac_cv_lib_socket_getpeername = yes; then
+   bash_cv_have_socklib=yes
+ else
+   bash_cv_have_socklib=no
  fi
  
+ fi
  
! if test "X$_bash_needmsg" = Xyes; then
!   echo "$as_me:7371: result: $bash_cv_have_socklib" >&5
! echo "${ECHO_T}$bash_cv_have_socklib" >&6
!   _bash_needmsg=
! fi
! if test $bash_cv_have_socklib = yes; then
!   # check for libnsl, add it to LIBS if present
!   if test "X$bash_cv_have_libnsl" = "X"; then
!     _bash_needmsg=
!   else
!     echo "$as_me:7380: checking for libnsl" >&5
! echo $ECHO_N "checking for libnsl... $ECHO_C" >&6
!     _bash_needmsg=yes
!   fi
!   if test "${bash_cv_have_libnsl+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
!   echo "$as_me:7387: checking for t_open in -lnsl" >&5
! echo $ECHO_N "checking for t_open in -lnsl... $ECHO_C" >&6
! if test "${ac_cv_lib_nsl_t_open+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
! else
!   ac_check_lib_save_LIBS=$LIBS
! LIBS="-lnsl  $LIBS"
! cat >conftest.$ac_ext <<_ACEOF
! #line 7395 "configure"
  #include "confdefs.h"
! 
! /* Override any gcc2 internal prototype to avoid an error.  */
  #ifdef __cplusplus
! extern "C"
  #endif
! /* We use char because int might match the return type of a gcc2
!    builtin and then its argument prototype would still apply.  */
! char t_open ();
! int
! main ()
! {
! t_open ();
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext conftest$ac_exeext
! if { (eval echo "$as_me:7414: \"$ac_link\"") >&5
!   (eval $ac_link) 2>&5
!   ac_status=$?
!   echo "$as_me:7417: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest$ac_exeext'
!   { (eval echo "$as_me:7420: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:7423: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   ac_cv_lib_nsl_t_open=yes
! else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! ac_cv_lib_nsl_t_open=no
! fi
! rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
! LIBS=$ac_check_lib_save_LIBS
! fi
! echo "$as_me:7434: result: $ac_cv_lib_nsl_t_open" >&5
! echo "${ECHO_T}$ac_cv_lib_nsl_t_open" >&6
! if test $ac_cv_lib_nsl_t_open = yes; then
!   bash_cv_have_libnsl=yes
  else
!   bash_cv_have_libnsl=no
  fi
! 
  fi
  
!   if test "X$_bash_needmsg" = Xyes; then
!     echo "$as_me:7445: result: $bash_cv_have_libnsl" >&5
! echo "${ECHO_T}$bash_cv_have_libnsl" >&6
!     _bash_needmsg=
!   fi
!   if test $bash_cv_have_libnsl = yes; then
!     LIBS="-lsocket -lnsl $LIBS"
!   else
!     LIBS="-lsocket $LIBS"
!   fi
!   cat >>confdefs.h <<\EOF
! #define HAVE_LIBSOCKET 1
  EOF
  
+   cat >>confdefs.h <<\EOF
+ #define HAVE_GETPEERNAME 1
+ EOF
  
+ fi
  
! fi
! if test "$ac_cv_func_gethostbyname" = no; then
! 	if test "X$bash_cv_have_gethostbyname" = "X"; then
! _bash_needmsg=yes
  else
! echo "$as_me:7469: checking for gethostbyname in socket library" >&5
! echo $ECHO_N "checking for gethostbyname in socket library... $ECHO_C" >&6
! _bash_needmsg=
! fi
! if test "${bash_cv_have_gethostbyname+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 7477 "configure"
  #include "confdefs.h"
! #include <netdb.h>
! int
! main ()
  {
!  struct hostent *hp;
!   hp = gethostbyname("localhost");
! 
!   ;
!   return 0;
  }
! _ACEOF
! rm -f conftest.$ac_objext conftest$ac_exeext
! if { (eval echo "$as_me:7491: \"$ac_link\"") >&5
!   (eval $ac_link) 2>&5
!   ac_status=$?
!   echo "$as_me:7494: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest$ac_exeext'
!   { (eval echo "$as_me:7497: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:7500: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   bash_cv_have_gethostbyname=yes
  else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! bash_cv_have_gethostbyname=no
! fi
! rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
! 
  fi
! 
! if test "X$_bash_needmsg" = Xyes; then
!     echo "$as_me:7513: checking for gethostbyname in socket library" >&5
! echo $ECHO_N "checking for gethostbyname in socket library... $ECHO_C" >&6
! fi
! echo "$as_me:7516: result: $bash_cv_have_gethostbyname" >&5
! echo "${ECHO_T}$bash_cv_have_gethostbyname" >&6
! if test "$bash_cv_have_gethostbyname" = yes; then
! cat >>confdefs.h <<\EOF
! #define HAVE_GETHOSTBYNAME 1
! EOF
! 
  fi
  
  fi
! 
! echo "$as_me:7527: checking for uid_t in sys/types.h" >&5
! echo $ECHO_N "checking for uid_t in sys/types.h... $ECHO_C" >&6
! if test "${ac_cv_type_uid_t+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
! else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 7533 "configure"
! #include "confdefs.h"
! #include <sys/types.h>
! 
! _ACEOF
! if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
!   egrep "uid_t" >/dev/null 2>&1; then
!   ac_cv_type_uid_t=yes
! else
!   ac_cv_type_uid_t=no
! fi
! rm -f conftest*
! 
! fi
! echo "$as_me:7547: result: $ac_cv_type_uid_t" >&5
! echo "${ECHO_T}$ac_cv_type_uid_t" >&6
! if test $ac_cv_type_uid_t = no; then
! 
! cat >>confdefs.h <<\EOF
! #define uid_t int
! EOF
! 
! cat >>confdefs.h <<\EOF
! #define gid_t int
  EOF
  
+ fi
  
! echo "$as_me:7561: checking type of array argument to getgroups" >&5
! echo $ECHO_N "checking type of array argument to getgroups... $ECHO_C" >&6
! if test "${ac_cv_type_getgroups+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
    if test "$cross_compiling" = yes; then
!   ac_cv_type_getgroups=cross
  else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 7570 "configure"
  #include "confdefs.h"
! /* Thanks to Mike Rendell for this test.  */
! #include <sys/types.h>
! #define NGID 256
! #undef MAX
! #define MAX(x, y) ((x) > (y) ? (x) : (y))
! 
! int
! main ()
  {
!   gid_t gidset[NGID];
!   int i, n;
!   union { gid_t gval; long lval; }  val;
! 
!   val.lval = -1;
!   for (i = 0; i < NGID; i++)
!     gidset[i] = val.gval;
!   n = getgroups (sizeof (gidset) / MAX (sizeof (int), sizeof (gid_t)) - 1,
!                  gidset);
!   /* Exit non-zero if getgroups seems to require an array of ints.  This
!      happens when gid_t is short but getgroups modifies an array of ints.  */
!   exit ((n > 0 && gidset[n] != val.gval) ? 1 : 0);
  }
+ _ACEOF
+ rm -f conftest$ac_exeext
+ if { (eval echo "$as_me:7596: \"$ac_link\"") >&5
+   (eval $ac_link) 2>&5
+   ac_status=$?
+   echo "$as_me:7599: \$? = $ac_status" >&5
+   (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
+   { (eval echo "$as_me:7601: \"$ac_try\"") >&5
+   (eval $ac_try) 2>&5
+   ac_status=$?
+   echo "$as_me:7604: \$? = $ac_status" >&5
+   (exit $ac_status); }; }; then
+   ac_cv_type_getgroups=gid_t
+ else
+   echo "$as_me: program exited with status $ac_status" >&5
+ echo "$as_me: failed program was:" >&5
+ cat conftest.$ac_ext >&5
+ ac_cv_type_getgroups=int
+ fi
+ rm -f core core.* *.core conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+ fi
+ if test $ac_cv_type_getgroups = cross; then
+         cat >conftest.$ac_ext <<_ACEOF
+ #line 7617 "configure"
+ #include "confdefs.h"
+ #include <unistd.h>
+ 
+ _ACEOF
+ if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+   egrep "getgroups.*int.*gid_t" >/dev/null 2>&1; then
+   ac_cv_type_getgroups=gid_t
+ else
+   ac_cv_type_getgroups=int
+ fi
+ rm -f conftest*
+ 
+ fi
+ fi
+ echo "$as_me:7632: result: $ac_cv_type_getgroups" >&5
+ echo "${ECHO_T}$ac_cv_type_getgroups" >&6
+ 
+ cat >>confdefs.h <<EOF
+ #define GETGROUPS_T $ac_cv_type_getgroups
  EOF
! 
! echo "$as_me:7639: checking for off_t" >&5
! echo $ECHO_N "checking for off_t... $ECHO_C" >&6
! if test "${ac_cv_type_off_t+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
! else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 7645 "configure"
! #include "confdefs.h"
! $ac_includes_default
! int
! main ()
! {
! if ((off_t *) 0)
!   return 0;
! if (sizeof (off_t))
!   return 0;
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext
! if { (eval echo "$as_me:7660: \"$ac_compile\"") >&5
!   (eval $ac_compile) 2>&5
!   ac_status=$?
!   echo "$as_me:7663: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest.$ac_objext'
!   { (eval echo "$as_me:7666: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:7669: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   ac_cv_type_off_t=yes
! else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! ac_cv_type_off_t=no
! fi
! rm -f conftest.$ac_objext conftest.$ac_ext
! fi
! echo "$as_me:7679: result: $ac_cv_type_off_t" >&5
! echo "${ECHO_T}$ac_cv_type_off_t" >&6
! if test $ac_cv_type_off_t = yes; then
!   :
! else
! 
! cat >>confdefs.h <<EOF
! #define off_t long
! EOF
! 
! fi
! 
! echo "$as_me:7691: checking for mode_t" >&5
! echo $ECHO_N "checking for mode_t... $ECHO_C" >&6
! if test "${ac_cv_type_mode_t+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
! else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 7697 "configure"
! #include "confdefs.h"
! $ac_includes_default
! int
! main ()
! {
! if ((mode_t *) 0)
!   return 0;
! if (sizeof (mode_t))
!   return 0;
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext
! if { (eval echo "$as_me:7712: \"$ac_compile\"") >&5
!   (eval $ac_compile) 2>&5
!   ac_status=$?
!   echo "$as_me:7715: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest.$ac_objext'
!   { (eval echo "$as_me:7718: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:7721: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   ac_cv_type_mode_t=yes
! else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! ac_cv_type_mode_t=no
! fi
! rm -f conftest.$ac_objext conftest.$ac_ext
! fi
! echo "$as_me:7731: result: $ac_cv_type_mode_t" >&5
! echo "${ECHO_T}$ac_cv_type_mode_t" >&6
! if test $ac_cv_type_mode_t = yes; then
!   :
! else
! 
! cat >>confdefs.h <<EOF
! #define mode_t int
! EOF
! 
! fi
! 
! echo "$as_me:7743: checking for uid_t in sys/types.h" >&5
! echo $ECHO_N "checking for uid_t in sys/types.h... $ECHO_C" >&6
! if test "${ac_cv_type_uid_t+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
! else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 7749 "configure"
! #include "confdefs.h"
! #include <sys/types.h>
! 
! _ACEOF
! if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
!   egrep "uid_t" >/dev/null 2>&1; then
!   ac_cv_type_uid_t=yes
! else
!   ac_cv_type_uid_t=no
! fi
! rm -f conftest*
! 
! fi
! echo "$as_me:7763: result: $ac_cv_type_uid_t" >&5
! echo "${ECHO_T}$ac_cv_type_uid_t" >&6
! if test $ac_cv_type_uid_t = no; then
! 
! cat >>confdefs.h <<\EOF
! #define uid_t int
! EOF
! 
! cat >>confdefs.h <<\EOF
! #define gid_t int
! EOF
! 
! fi
! 
! echo "$as_me:7777: checking for pid_t" >&5
! echo $ECHO_N "checking for pid_t... $ECHO_C" >&6
! if test "${ac_cv_type_pid_t+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
! else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 7783 "configure"
! #include "confdefs.h"
! $ac_includes_default
! int
! main ()
! {
! if ((pid_t *) 0)
!   return 0;
! if (sizeof (pid_t))
!   return 0;
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext
! if { (eval echo "$as_me:7798: \"$ac_compile\"") >&5
!   (eval $ac_compile) 2>&5
!   ac_status=$?
!   echo "$as_me:7801: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest.$ac_objext'
!   { (eval echo "$as_me:7804: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:7807: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   ac_cv_type_pid_t=yes
! else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! ac_cv_type_pid_t=no
! fi
! rm -f conftest.$ac_objext conftest.$ac_ext
! fi
! echo "$as_me:7817: result: $ac_cv_type_pid_t" >&5
! echo "${ECHO_T}$ac_cv_type_pid_t" >&6
! if test $ac_cv_type_pid_t = yes; then
!   :
! else
! 
! cat >>confdefs.h <<EOF
! #define pid_t int
! EOF
! 
! fi
! 
! echo "$as_me:7829: checking for size_t" >&5
! echo $ECHO_N "checking for size_t... $ECHO_C" >&6
! if test "${ac_cv_type_size_t+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
! else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 7835 "configure"
! #include "confdefs.h"
! $ac_includes_default
! int
! main ()
! {
! if ((size_t *) 0)
!   return 0;
! if (sizeof (size_t))
!   return 0;
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext
! if { (eval echo "$as_me:7850: \"$ac_compile\"") >&5
!   (eval $ac_compile) 2>&5
!   ac_status=$?
!   echo "$as_me:7853: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest.$ac_objext'
!   { (eval echo "$as_me:7856: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:7859: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   ac_cv_type_size_t=yes
! else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! ac_cv_type_size_t=no
! fi
! rm -f conftest.$ac_objext conftest.$ac_ext
! fi
! echo "$as_me:7869: result: $ac_cv_type_size_t" >&5
! echo "${ECHO_T}$ac_cv_type_size_t" >&6
! if test $ac_cv_type_size_t = yes; then
!   :
! else
! 
! cat >>confdefs.h <<EOF
! #define size_t unsigned
! EOF
! 
! fi
! 
! echo "$as_me:7881: checking for ssize_t" >&5
! echo $ECHO_N "checking for ssize_t... $ECHO_C" >&6
! if test "${ac_cv_type_ssize_t+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
! else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 7887 "configure"
! #include "confdefs.h"
! $ac_includes_default
! int
! main ()
! {
! if ((ssize_t *) 0)
!   return 0;
! if (sizeof (ssize_t))
!   return 0;
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext
! if { (eval echo "$as_me:7902: \"$ac_compile\"") >&5
!   (eval $ac_compile) 2>&5
!   ac_status=$?
!   echo "$as_me:7905: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest.$ac_objext'
!   { (eval echo "$as_me:7908: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:7911: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   ac_cv_type_ssize_t=yes
! else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! ac_cv_type_ssize_t=no
! fi
! rm -f conftest.$ac_objext conftest.$ac_ext
! fi
! echo "$as_me:7921: result: $ac_cv_type_ssize_t" >&5
! echo "${ECHO_T}$ac_cv_type_ssize_t" >&6
! if test $ac_cv_type_ssize_t = yes; then
!   :
! else
! 
! cat >>confdefs.h <<EOF
! #define ssize_t int
! EOF
! 
! fi
! 
! echo "$as_me:7933: checking for time_t" >&5
! echo $ECHO_N "checking for time_t... $ECHO_C" >&6
! if test "${ac_cv_type_time_t+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
! else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 7939 "configure"
! #include "confdefs.h"
! $ac_includes_default
! int
! main ()
! {
! if ((time_t *) 0)
!   return 0;
! if (sizeof (time_t))
!   return 0;
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext
! if { (eval echo "$as_me:7954: \"$ac_compile\"") >&5
!   (eval $ac_compile) 2>&5
!   ac_status=$?
!   echo "$as_me:7957: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest.$ac_objext'
!   { (eval echo "$as_me:7960: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:7963: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   ac_cv_type_time_t=yes
! else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! ac_cv_type_time_t=no
! fi
! rm -f conftest.$ac_objext conftest.$ac_ext
! fi
! echo "$as_me:7973: result: $ac_cv_type_time_t" >&5
! echo "${ECHO_T}$ac_cv_type_time_t" >&6
! if test $ac_cv_type_time_t = yes; then
!   :
! else
! 
! cat >>confdefs.h <<EOF
! #define time_t long
! EOF
! 
! fi
! 
! echo "$as_me:7985: checking for long long" >&5
! echo $ECHO_N "checking for long long... $ECHO_C" >&6
! if test "${bash_cv_type_long_long+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
! else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 7991 "configure"
! #include "confdefs.h"
! 
! long long ll = 1; int i = 63;
! int
! main ()
! {
! 
! long long llm = (long long) -1;
! return ll << i | ll >> i | llm / ll | llm % ll;
! 
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext conftest$ac_exeext
! if { (eval echo "$as_me:8007: \"$ac_link\"") >&5
!   (eval $ac_link) 2>&5
!   ac_status=$?
!   echo "$as_me:8010: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest$ac_exeext'
!   { (eval echo "$as_me:8013: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:8016: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   bash_cv_type_long_long='long long'
! else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! bash_cv_type_long_long='long'
! fi
! rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
! fi
! echo "$as_me:8026: result: $bash_cv_type_long_long" >&5
! echo "${ECHO_T}$bash_cv_type_long_long" >&6
! if test "$bash_cv_type_long_long" = 'long long'; then
!   cat >>confdefs.h <<\EOF
! #define HAVE_LONG_LONG 1
! EOF
! 
! fi
! 
! echo "$as_me:8035: checking for unsigned long long" >&5
! echo $ECHO_N "checking for unsigned long long... $ECHO_C" >&6
! if test "${bash_cv_type_unsigned_long_long+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
! else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 8041 "configure"
! #include "confdefs.h"
! 
! unsigned long long ull = 1; int i = 63;
! int
! main ()
! {
! 
! unsigned long long ullmax = (unsigned long long) -1;
! return ull << i | ull >> i | ullmax / ull | ullmax % ull;
! 
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext conftest$ac_exeext
! if { (eval echo "$as_me:8057: \"$ac_link\"") >&5
!   (eval $ac_link) 2>&5
!   ac_status=$?
!   echo "$as_me:8060: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest$ac_exeext'
!   { (eval echo "$as_me:8063: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:8066: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   bash_cv_type_unsigned_long_long='unsigned long long'
! else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! bash_cv_type_unsigned_long_long='unsigned long'
! fi
! rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
! fi
! echo "$as_me:8076: result: $bash_cv_type_unsigned_long_long" >&5
! echo "${ECHO_T}$bash_cv_type_unsigned_long_long" >&6
! if test "$bash_cv_type_unsigned_long_long" = 'unsigned long long'; then
!   cat >>confdefs.h <<\EOF
! #define HAVE_UNSIGNED_LONG_LONG 1
! EOF
! 
! fi
! 
! echo "$as_me:8085: checking return type of signal handlers" >&5
! echo $ECHO_N "checking return type of signal handlers... $ECHO_C" >&6
! if test "${ac_cv_type_signal+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
! else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 8091 "configure"
! #include "confdefs.h"
! #include <sys/types.h>
! #include <signal.h>
! #ifdef signal
! # undef signal
! #endif
! #ifdef __cplusplus
! extern "C" void (*signal (int, void (*)(int)))(int);
! #else
! void (*signal ()) ();
! #endif
! 
! int
! main ()
! {
! int i;
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext
! if { (eval echo "$as_me:8113: \"$ac_compile\"") >&5
!   (eval $ac_compile) 2>&5
!   ac_status=$?
!   echo "$as_me:8116: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest.$ac_objext'
!   { (eval echo "$as_me:8119: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:8122: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   ac_cv_type_signal=void
! else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! ac_cv_type_signal=int
! fi
! rm -f conftest.$ac_objext conftest.$ac_ext
! fi
! echo "$as_me:8132: result: $ac_cv_type_signal" >&5
! echo "${ECHO_T}$ac_cv_type_signal" >&6
! 
! cat >>confdefs.h <<EOF
! #define RETSIGTYPE $ac_cv_type_signal
! EOF
! 
! echo "$as_me:8139: checking for char" >&5
! echo $ECHO_N "checking for char... $ECHO_C" >&6
! if test "${ac_cv_type_char+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
! else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 8145 "configure"
! #include "confdefs.h"
! $ac_includes_default
! int
! main ()
! {
! if ((char *) 0)
!   return 0;
! if (sizeof (char))
!   return 0;
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext
! if { (eval echo "$as_me:8160: \"$ac_compile\"") >&5
!   (eval $ac_compile) 2>&5
!   ac_status=$?
!   echo "$as_me:8163: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest.$ac_objext'
!   { (eval echo "$as_me:8166: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:8169: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   ac_cv_type_char=yes
! else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! ac_cv_type_char=no
! fi
! rm -f conftest.$ac_objext conftest.$ac_ext
! fi
! echo "$as_me:8179: result: $ac_cv_type_char" >&5
! echo "${ECHO_T}$ac_cv_type_char" >&6
! 
! echo "$as_me:8182: checking size of char" >&5
! echo $ECHO_N "checking size of char... $ECHO_C" >&6
! if test "${ac_cv_sizeof_char+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
! else
!   if test "$ac_cv_type_char" = yes; then
!   if test "$cross_compiling" = yes; then
!   # Depending upon the size, compute the lo and hi bounds.
! cat >conftest.$ac_ext <<_ACEOF
! #line 8191 "configure"
! #include "confdefs.h"
! $ac_includes_default
! int
! main ()
! {
! int _array_ [1 - 2 * !((sizeof (char)) >= 0)]
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext
! if { (eval echo "$as_me:8203: \"$ac_compile\"") >&5
!   (eval $ac_compile) 2>&5
!   ac_status=$?
!   echo "$as_me:8206: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest.$ac_objext'
!   { (eval echo "$as_me:8209: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:8212: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   ac_lo=0 ac_mid=0
!   while :; do
!     cat >conftest.$ac_ext <<_ACEOF
! #line 8217 "configure"
! #include "confdefs.h"
! $ac_includes_default
! int
! main ()
! {
! int _array_ [1 - 2 * !((sizeof (char)) <= $ac_mid)]
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext
! if { (eval echo "$as_me:8229: \"$ac_compile\"") >&5
!   (eval $ac_compile) 2>&5
!   ac_status=$?
!   echo "$as_me:8232: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest.$ac_objext'
!   { (eval echo "$as_me:8235: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:8238: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   ac_hi=$ac_mid; break
! else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! ac_lo=`expr $ac_mid + 1`; ac_mid=`expr 2 '*' $ac_mid + 1`
! fi
! rm -f conftest.$ac_objext conftest.$ac_ext
!   done
! else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! ac_hi=-1 ac_mid=-1
!   while :; do
!     cat >conftest.$ac_ext <<_ACEOF
! #line 8254 "configure"
! #include "confdefs.h"
! $ac_includes_default
! int
! main ()
! {
! int _array_ [1 - 2 * !((sizeof (char)) >= $ac_mid)]
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext
! if { (eval echo "$as_me:8266: \"$ac_compile\"") >&5
!   (eval $ac_compile) 2>&5
!   ac_status=$?
!   echo "$as_me:8269: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest.$ac_objext'
!   { (eval echo "$as_me:8272: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:8275: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   ac_lo=$ac_mid; break
! else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! ac_hi=`expr $ac_mid - 1`; ac_mid=`expr 2 '*' $ac_mid`
! fi
! rm -f conftest.$ac_objext conftest.$ac_ext
!   done
! fi
! rm -f conftest.$ac_objext conftest.$ac_ext
! # Binary search between lo and hi bounds.
! while test "x$ac_lo" != "x$ac_hi"; do
!   ac_mid=`expr '(' $ac_hi - $ac_lo ')' / 2 + $ac_lo`
!   cat >conftest.$ac_ext <<_ACEOF
! #line 8291 "configure"
! #include "confdefs.h"
! $ac_includes_default
! int
! main ()
! {
! int _array_ [1 - 2 * !((sizeof (char)) <= $ac_mid)]
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext
! if { (eval echo "$as_me:8303: \"$ac_compile\"") >&5
!   (eval $ac_compile) 2>&5
!   ac_status=$?
!   echo "$as_me:8306: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest.$ac_objext'
!   { (eval echo "$as_me:8309: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:8312: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   ac_hi=$ac_mid
! else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! ac_lo=`expr $ac_mid + 1`
! fi
! rm -f conftest.$ac_objext conftest.$ac_ext
! done
! ac_cv_sizeof_char=$ac_lo
! else
!   if test "$cross_compiling" = yes; then
!   { { echo "$as_me:8325: error: cannot run test program while cross compiling" >&5
! echo "$as_me: error: cannot run test program while cross compiling" >&2;}
!    { (exit 1); exit 1; }; }
! else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 8330 "configure"
! #include "confdefs.h"
! $ac_includes_default
! int
! main ()
! {
! FILE *f = fopen ("conftest.val", "w");
! if (!f)
!   exit (1);
! fprintf (f, "%d", (sizeof (char)));
! fclose (f);
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest$ac_exeext
! if { (eval echo "$as_me:8346: \"$ac_link\"") >&5
!   (eval $ac_link) 2>&5
!   ac_status=$?
!   echo "$as_me:8349: \$? = $ac_status" >&5
!   (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
!   { (eval echo "$as_me:8351: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:8354: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   ac_cv_sizeof_char=`cat conftest.val`
! else
!   echo "$as_me: program exited with status $ac_status" >&5
! echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! fi
! rm -f core core.* *.core conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
! fi
! fi
! rm -f conftest.val
! else
!   ac_cv_sizeof_char=0
! fi
! fi
! echo "$as_me:8370: result: $ac_cv_sizeof_char" >&5
! echo "${ECHO_T}$ac_cv_sizeof_char" >&6
! cat >>confdefs.h <<EOF
! #define SIZEOF_CHAR $ac_cv_sizeof_char
! EOF
! 
! echo "$as_me:8376: checking for short" >&5
! echo $ECHO_N "checking for short... $ECHO_C" >&6
! if test "${ac_cv_type_short+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
! else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 8382 "configure"
! #include "confdefs.h"
! $ac_includes_default
! int
! main ()
! {
! if ((short *) 0)
!   return 0;
! if (sizeof (short))
!   return 0;
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext
! if { (eval echo "$as_me:8397: \"$ac_compile\"") >&5
!   (eval $ac_compile) 2>&5
!   ac_status=$?
!   echo "$as_me:8400: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest.$ac_objext'
!   { (eval echo "$as_me:8403: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:8406: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   ac_cv_type_short=yes
! else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! ac_cv_type_short=no
! fi
! rm -f conftest.$ac_objext conftest.$ac_ext
! fi
! echo "$as_me:8416: result: $ac_cv_type_short" >&5
! echo "${ECHO_T}$ac_cv_type_short" >&6
! 
! echo "$as_me:8419: checking size of short" >&5
! echo $ECHO_N "checking size of short... $ECHO_C" >&6
! if test "${ac_cv_sizeof_short+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
! else
!   if test "$ac_cv_type_short" = yes; then
!   if test "$cross_compiling" = yes; then
!   # Depending upon the size, compute the lo and hi bounds.
! cat >conftest.$ac_ext <<_ACEOF
! #line 8428 "configure"
! #include "confdefs.h"
! $ac_includes_default
! int
! main ()
! {
! int _array_ [1 - 2 * !((sizeof (short)) >= 0)]
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext
! if { (eval echo "$as_me:8440: \"$ac_compile\"") >&5
!   (eval $ac_compile) 2>&5
!   ac_status=$?
!   echo "$as_me:8443: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest.$ac_objext'
!   { (eval echo "$as_me:8446: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:8449: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   ac_lo=0 ac_mid=0
!   while :; do
!     cat >conftest.$ac_ext <<_ACEOF
! #line 8454 "configure"
! #include "confdefs.h"
! $ac_includes_default
! int
! main ()
! {
! int _array_ [1 - 2 * !((sizeof (short)) <= $ac_mid)]
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext
! if { (eval echo "$as_me:8466: \"$ac_compile\"") >&5
!   (eval $ac_compile) 2>&5
!   ac_status=$?
!   echo "$as_me:8469: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest.$ac_objext'
!   { (eval echo "$as_me:8472: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:8475: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   ac_hi=$ac_mid; break
! else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! ac_lo=`expr $ac_mid + 1`; ac_mid=`expr 2 '*' $ac_mid + 1`
! fi
! rm -f conftest.$ac_objext conftest.$ac_ext
!   done
! else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! ac_hi=-1 ac_mid=-1
!   while :; do
!     cat >conftest.$ac_ext <<_ACEOF
! #line 8491 "configure"
! #include "confdefs.h"
! $ac_includes_default
! int
! main ()
! {
! int _array_ [1 - 2 * !((sizeof (short)) >= $ac_mid)]
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext
! if { (eval echo "$as_me:8503: \"$ac_compile\"") >&5
!   (eval $ac_compile) 2>&5
!   ac_status=$?
!   echo "$as_me:8506: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest.$ac_objext'
!   { (eval echo "$as_me:8509: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:8512: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   ac_lo=$ac_mid; break
! else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! ac_hi=`expr $ac_mid - 1`; ac_mid=`expr 2 '*' $ac_mid`
! fi
! rm -f conftest.$ac_objext conftest.$ac_ext
!   done
! fi
! rm -f conftest.$ac_objext conftest.$ac_ext
! # Binary search between lo and hi bounds.
! while test "x$ac_lo" != "x$ac_hi"; do
!   ac_mid=`expr '(' $ac_hi - $ac_lo ')' / 2 + $ac_lo`
!   cat >conftest.$ac_ext <<_ACEOF
! #line 8528 "configure"
! #include "confdefs.h"
! $ac_includes_default
! int
! main ()
! {
! int _array_ [1 - 2 * !((sizeof (short)) <= $ac_mid)]
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext
! if { (eval echo "$as_me:8540: \"$ac_compile\"") >&5
!   (eval $ac_compile) 2>&5
!   ac_status=$?
!   echo "$as_me:8543: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest.$ac_objext'
!   { (eval echo "$as_me:8546: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:8549: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   ac_hi=$ac_mid
! else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! ac_lo=`expr $ac_mid + 1`
! fi
! rm -f conftest.$ac_objext conftest.$ac_ext
! done
! ac_cv_sizeof_short=$ac_lo
! else
!   if test "$cross_compiling" = yes; then
!   { { echo "$as_me:8562: error: cannot run test program while cross compiling" >&5
! echo "$as_me: error: cannot run test program while cross compiling" >&2;}
!    { (exit 1); exit 1; }; }
! else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 8567 "configure"
! #include "confdefs.h"
! $ac_includes_default
! int
! main ()
! {
! FILE *f = fopen ("conftest.val", "w");
! if (!f)
!   exit (1);
! fprintf (f, "%d", (sizeof (short)));
! fclose (f);
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest$ac_exeext
! if { (eval echo "$as_me:8583: \"$ac_link\"") >&5
!   (eval $ac_link) 2>&5
!   ac_status=$?
!   echo "$as_me:8586: \$? = $ac_status" >&5
!   (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
!   { (eval echo "$as_me:8588: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:8591: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   ac_cv_sizeof_short=`cat conftest.val`
! else
!   echo "$as_me: program exited with status $ac_status" >&5
! echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! fi
! rm -f core core.* *.core conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
! fi
! fi
! rm -f conftest.val
  else
    ac_cv_sizeof_short=0
  fi
  fi
! echo "$as_me:8607: result: $ac_cv_sizeof_short" >&5
! echo "${ECHO_T}$ac_cv_sizeof_short" >&6
! cat >>confdefs.h <<EOF
! #define SIZEOF_SHORT $ac_cv_sizeof_short
! EOF
! 
! echo "$as_me:8613: checking for int" >&5
! echo $ECHO_N "checking for int... $ECHO_C" >&6
! if test "${ac_cv_type_int+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
! else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 8619 "configure"
! #include "confdefs.h"
! $ac_includes_default
! int
! main ()
! {
! if ((int *) 0)
!   return 0;
! if (sizeof (int))
!   return 0;
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext
! if { (eval echo "$as_me:8634: \"$ac_compile\"") >&5
!   (eval $ac_compile) 2>&5
!   ac_status=$?
!   echo "$as_me:8637: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest.$ac_objext'
!   { (eval echo "$as_me:8640: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:8643: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   ac_cv_type_int=yes
! else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! ac_cv_type_int=no
! fi
! rm -f conftest.$ac_objext conftest.$ac_ext
! fi
! echo "$as_me:8653: result: $ac_cv_type_int" >&5
! echo "${ECHO_T}$ac_cv_type_int" >&6
! 
! echo "$as_me:8656: checking size of int" >&5
! echo $ECHO_N "checking size of int... $ECHO_C" >&6
! if test "${ac_cv_sizeof_int+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
! else
!   if test "$ac_cv_type_int" = yes; then
!   if test "$cross_compiling" = yes; then
!   # Depending upon the size, compute the lo and hi bounds.
! cat >conftest.$ac_ext <<_ACEOF
! #line 8665 "configure"
! #include "confdefs.h"
! $ac_includes_default
! int
! main ()
! {
! int _array_ [1 - 2 * !((sizeof (int)) >= 0)]
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext
! if { (eval echo "$as_me:8677: \"$ac_compile\"") >&5
!   (eval $ac_compile) 2>&5
!   ac_status=$?
!   echo "$as_me:8680: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest.$ac_objext'
!   { (eval echo "$as_me:8683: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:8686: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   ac_lo=0 ac_mid=0
!   while :; do
!     cat >conftest.$ac_ext <<_ACEOF
! #line 8691 "configure"
! #include "confdefs.h"
! $ac_includes_default
! int
! main ()
! {
! int _array_ [1 - 2 * !((sizeof (int)) <= $ac_mid)]
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext
! if { (eval echo "$as_me:8703: \"$ac_compile\"") >&5
!   (eval $ac_compile) 2>&5
!   ac_status=$?
!   echo "$as_me:8706: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest.$ac_objext'
!   { (eval echo "$as_me:8709: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:8712: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   ac_hi=$ac_mid; break
! else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! ac_lo=`expr $ac_mid + 1`; ac_mid=`expr 2 '*' $ac_mid + 1`
! fi
! rm -f conftest.$ac_objext conftest.$ac_ext
!   done
! else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! ac_hi=-1 ac_mid=-1
!   while :; do
!     cat >conftest.$ac_ext <<_ACEOF
! #line 8728 "configure"
! #include "confdefs.h"
! $ac_includes_default
! int
! main ()
! {
! int _array_ [1 - 2 * !((sizeof (int)) >= $ac_mid)]
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext
! if { (eval echo "$as_me:8740: \"$ac_compile\"") >&5
!   (eval $ac_compile) 2>&5
!   ac_status=$?
!   echo "$as_me:8743: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest.$ac_objext'
!   { (eval echo "$as_me:8746: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:8749: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   ac_lo=$ac_mid; break
! else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! ac_hi=`expr $ac_mid - 1`; ac_mid=`expr 2 '*' $ac_mid`
! fi
! rm -f conftest.$ac_objext conftest.$ac_ext
!   done
! fi
! rm -f conftest.$ac_objext conftest.$ac_ext
! # Binary search between lo and hi bounds.
! while test "x$ac_lo" != "x$ac_hi"; do
!   ac_mid=`expr '(' $ac_hi - $ac_lo ')' / 2 + $ac_lo`
!   cat >conftest.$ac_ext <<_ACEOF
! #line 8765 "configure"
! #include "confdefs.h"
! $ac_includes_default
! int
! main ()
! {
! int _array_ [1 - 2 * !((sizeof (int)) <= $ac_mid)]
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext
! if { (eval echo "$as_me:8777: \"$ac_compile\"") >&5
!   (eval $ac_compile) 2>&5
!   ac_status=$?
!   echo "$as_me:8780: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest.$ac_objext'
!   { (eval echo "$as_me:8783: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:8786: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   ac_hi=$ac_mid
! else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! ac_lo=`expr $ac_mid + 1`
! fi
! rm -f conftest.$ac_objext conftest.$ac_ext
! done
! ac_cv_sizeof_int=$ac_lo
! else
!   if test "$cross_compiling" = yes; then
!   { { echo "$as_me:8799: error: cannot run test program while cross compiling" >&5
! echo "$as_me: error: cannot run test program while cross compiling" >&2;}
!    { (exit 1); exit 1; }; }
! else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 8804 "configure"
! #include "confdefs.h"
! $ac_includes_default
! int
! main ()
! {
! FILE *f = fopen ("conftest.val", "w");
! if (!f)
!   exit (1);
! fprintf (f, "%d", (sizeof (int)));
! fclose (f);
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest$ac_exeext
! if { (eval echo "$as_me:8820: \"$ac_link\"") >&5
!   (eval $ac_link) 2>&5
!   ac_status=$?
!   echo "$as_me:8823: \$? = $ac_status" >&5
!   (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
!   { (eval echo "$as_me:8825: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:8828: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   ac_cv_sizeof_int=`cat conftest.val`
! else
!   echo "$as_me: program exited with status $ac_status" >&5
! echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! fi
! rm -f core core.* *.core conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
! fi
! fi
! rm -f conftest.val
! else
!   ac_cv_sizeof_int=0
! fi
! fi
! echo "$as_me:8844: result: $ac_cv_sizeof_int" >&5
! echo "${ECHO_T}$ac_cv_sizeof_int" >&6
! cat >>confdefs.h <<EOF
! #define SIZEOF_INT $ac_cv_sizeof_int
! EOF
! 
! echo "$as_me:8850: checking for long" >&5
! echo $ECHO_N "checking for long... $ECHO_C" >&6
! if test "${ac_cv_type_long+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
! else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 8856 "configure"
! #include "confdefs.h"
! $ac_includes_default
! int
! main ()
! {
! if ((long *) 0)
!   return 0;
! if (sizeof (long))
!   return 0;
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext
! if { (eval echo "$as_me:8871: \"$ac_compile\"") >&5
!   (eval $ac_compile) 2>&5
!   ac_status=$?
!   echo "$as_me:8874: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest.$ac_objext'
!   { (eval echo "$as_me:8877: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:8880: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   ac_cv_type_long=yes
! else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! ac_cv_type_long=no
! fi
! rm -f conftest.$ac_objext conftest.$ac_ext
! fi
! echo "$as_me:8890: result: $ac_cv_type_long" >&5
! echo "${ECHO_T}$ac_cv_type_long" >&6
! 
! echo "$as_me:8893: checking size of long" >&5
! echo $ECHO_N "checking size of long... $ECHO_C" >&6
! if test "${ac_cv_sizeof_long+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
! else
!   if test "$ac_cv_type_long" = yes; then
!   if test "$cross_compiling" = yes; then
!   # Depending upon the size, compute the lo and hi bounds.
! cat >conftest.$ac_ext <<_ACEOF
! #line 8902 "configure"
! #include "confdefs.h"
! $ac_includes_default
! int
! main ()
! {
! int _array_ [1 - 2 * !((sizeof (long)) >= 0)]
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext
! if { (eval echo "$as_me:8914: \"$ac_compile\"") >&5
!   (eval $ac_compile) 2>&5
!   ac_status=$?
!   echo "$as_me:8917: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest.$ac_objext'
!   { (eval echo "$as_me:8920: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:8923: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   ac_lo=0 ac_mid=0
!   while :; do
!     cat >conftest.$ac_ext <<_ACEOF
! #line 8928 "configure"
! #include "confdefs.h"
! $ac_includes_default
! int
! main ()
! {
! int _array_ [1 - 2 * !((sizeof (long)) <= $ac_mid)]
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext
! if { (eval echo "$as_me:8940: \"$ac_compile\"") >&5
!   (eval $ac_compile) 2>&5
!   ac_status=$?
!   echo "$as_me:8943: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest.$ac_objext'
!   { (eval echo "$as_me:8946: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:8949: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   ac_hi=$ac_mid; break
! else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! ac_lo=`expr $ac_mid + 1`; ac_mid=`expr 2 '*' $ac_mid + 1`
! fi
! rm -f conftest.$ac_objext conftest.$ac_ext
!   done
! else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! ac_hi=-1 ac_mid=-1
!   while :; do
!     cat >conftest.$ac_ext <<_ACEOF
! #line 8965 "configure"
! #include "confdefs.h"
! $ac_includes_default
! int
! main ()
! {
! int _array_ [1 - 2 * !((sizeof (long)) >= $ac_mid)]
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext
! if { (eval echo "$as_me:8977: \"$ac_compile\"") >&5
!   (eval $ac_compile) 2>&5
!   ac_status=$?
!   echo "$as_me:8980: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest.$ac_objext'
!   { (eval echo "$as_me:8983: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:8986: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   ac_lo=$ac_mid; break
! else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! ac_hi=`expr $ac_mid - 1`; ac_mid=`expr 2 '*' $ac_mid`
! fi
! rm -f conftest.$ac_objext conftest.$ac_ext
!   done
! fi
! rm -f conftest.$ac_objext conftest.$ac_ext
! # Binary search between lo and hi bounds.
! while test "x$ac_lo" != "x$ac_hi"; do
!   ac_mid=`expr '(' $ac_hi - $ac_lo ')' / 2 + $ac_lo`
!   cat >conftest.$ac_ext <<_ACEOF
! #line 9002 "configure"
! #include "confdefs.h"
! $ac_includes_default
! int
! main ()
! {
! int _array_ [1 - 2 * !((sizeof (long)) <= $ac_mid)]
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext
! if { (eval echo "$as_me:9014: \"$ac_compile\"") >&5
!   (eval $ac_compile) 2>&5
!   ac_status=$?
!   echo "$as_me:9017: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest.$ac_objext'
!   { (eval echo "$as_me:9020: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:9023: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   ac_hi=$ac_mid
! else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! ac_lo=`expr $ac_mid + 1`
! fi
! rm -f conftest.$ac_objext conftest.$ac_ext
! done
! ac_cv_sizeof_long=$ac_lo
! else
!   if test "$cross_compiling" = yes; then
!   { { echo "$as_me:9036: error: cannot run test program while cross compiling" >&5
! echo "$as_me: error: cannot run test program while cross compiling" >&2;}
!    { (exit 1); exit 1; }; }
! else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 9041 "configure"
! #include "confdefs.h"
! $ac_includes_default
! int
! main ()
! {
! FILE *f = fopen ("conftest.val", "w");
! if (!f)
!   exit (1);
! fprintf (f, "%d", (sizeof (long)));
! fclose (f);
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest$ac_exeext
! if { (eval echo "$as_me:9057: \"$ac_link\"") >&5
!   (eval $ac_link) 2>&5
!   ac_status=$?
!   echo "$as_me:9060: \$? = $ac_status" >&5
!   (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
!   { (eval echo "$as_me:9062: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:9065: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   ac_cv_sizeof_long=`cat conftest.val`
! else
!   echo "$as_me: program exited with status $ac_status" >&5
! echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! fi
! rm -f core core.* *.core conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
! fi
! fi
! rm -f conftest.val
! else
!   ac_cv_sizeof_long=0
! fi
! fi
! echo "$as_me:9081: result: $ac_cv_sizeof_long" >&5
! echo "${ECHO_T}$ac_cv_sizeof_long" >&6
! cat >>confdefs.h <<EOF
! #define SIZEOF_LONG $ac_cv_sizeof_long
! EOF
! 
! echo "$as_me:9087: checking for char *" >&5
! echo $ECHO_N "checking for char *... $ECHO_C" >&6
! if test "${ac_cv_type_char_p+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
! else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 9093 "configure"
! #include "confdefs.h"
! $ac_includes_default
! int
! main ()
! {
! if ((char * *) 0)
!   return 0;
! if (sizeof (char *))
!   return 0;
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext
! if { (eval echo "$as_me:9108: \"$ac_compile\"") >&5
!   (eval $ac_compile) 2>&5
!   ac_status=$?
!   echo "$as_me:9111: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest.$ac_objext'
!   { (eval echo "$as_me:9114: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:9117: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   ac_cv_type_char_p=yes
! else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! ac_cv_type_char_p=no
! fi
! rm -f conftest.$ac_objext conftest.$ac_ext
! fi
! echo "$as_me:9127: result: $ac_cv_type_char_p" >&5
! echo "${ECHO_T}$ac_cv_type_char_p" >&6
! 
! echo "$as_me:9130: checking size of char *" >&5
! echo $ECHO_N "checking size of char *... $ECHO_C" >&6
! if test "${ac_cv_sizeof_char_p+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
! else
!   if test "$ac_cv_type_char_p" = yes; then
!   if test "$cross_compiling" = yes; then
!   # Depending upon the size, compute the lo and hi bounds.
! cat >conftest.$ac_ext <<_ACEOF
! #line 9139 "configure"
! #include "confdefs.h"
! $ac_includes_default
! int
! main ()
! {
! int _array_ [1 - 2 * !((sizeof (char *)) >= 0)]
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext
! if { (eval echo "$as_me:9151: \"$ac_compile\"") >&5
!   (eval $ac_compile) 2>&5
!   ac_status=$?
!   echo "$as_me:9154: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest.$ac_objext'
!   { (eval echo "$as_me:9157: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:9160: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   ac_lo=0 ac_mid=0
!   while :; do
!     cat >conftest.$ac_ext <<_ACEOF
! #line 9165 "configure"
! #include "confdefs.h"
! $ac_includes_default
! int
! main ()
! {
! int _array_ [1 - 2 * !((sizeof (char *)) <= $ac_mid)]
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext
! if { (eval echo "$as_me:9177: \"$ac_compile\"") >&5
!   (eval $ac_compile) 2>&5
!   ac_status=$?
!   echo "$as_me:9180: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest.$ac_objext'
!   { (eval echo "$as_me:9183: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:9186: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   ac_hi=$ac_mid; break
! else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! ac_lo=`expr $ac_mid + 1`; ac_mid=`expr 2 '*' $ac_mid + 1`
! fi
! rm -f conftest.$ac_objext conftest.$ac_ext
!   done
! else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! ac_hi=-1 ac_mid=-1
!   while :; do
!     cat >conftest.$ac_ext <<_ACEOF
! #line 9202 "configure"
! #include "confdefs.h"
! $ac_includes_default
! int
! main ()
! {
! int _array_ [1 - 2 * !((sizeof (char *)) >= $ac_mid)]
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext
! if { (eval echo "$as_me:9214: \"$ac_compile\"") >&5
!   (eval $ac_compile) 2>&5
!   ac_status=$?
!   echo "$as_me:9217: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest.$ac_objext'
!   { (eval echo "$as_me:9220: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:9223: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   ac_lo=$ac_mid; break
! else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! ac_hi=`expr $ac_mid - 1`; ac_mid=`expr 2 '*' $ac_mid`
! fi
! rm -f conftest.$ac_objext conftest.$ac_ext
!   done
! fi
! rm -f conftest.$ac_objext conftest.$ac_ext
! # Binary search between lo and hi bounds.
! while test "x$ac_lo" != "x$ac_hi"; do
!   ac_mid=`expr '(' $ac_hi - $ac_lo ')' / 2 + $ac_lo`
!   cat >conftest.$ac_ext <<_ACEOF
! #line 9239 "configure"
! #include "confdefs.h"
! $ac_includes_default
! int
! main ()
! {
! int _array_ [1 - 2 * !((sizeof (char *)) <= $ac_mid)]
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext
! if { (eval echo "$as_me:9251: \"$ac_compile\"") >&5
!   (eval $ac_compile) 2>&5
!   ac_status=$?
!   echo "$as_me:9254: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest.$ac_objext'
!   { (eval echo "$as_me:9257: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:9260: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   ac_hi=$ac_mid
! else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! ac_lo=`expr $ac_mid + 1`
! fi
! rm -f conftest.$ac_objext conftest.$ac_ext
! done
! ac_cv_sizeof_char_p=$ac_lo
! else
!   if test "$cross_compiling" = yes; then
!   { { echo "$as_me:9273: error: cannot run test program while cross compiling" >&5
! echo "$as_me: error: cannot run test program while cross compiling" >&2;}
!    { (exit 1); exit 1; }; }
! else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 9278 "configure"
! #include "confdefs.h"
! $ac_includes_default
! int
! main ()
! {
! FILE *f = fopen ("conftest.val", "w");
! if (!f)
!   exit (1);
! fprintf (f, "%d", (sizeof (char *)));
! fclose (f);
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest$ac_exeext
! if { (eval echo "$as_me:9294: \"$ac_link\"") >&5
!   (eval $ac_link) 2>&5
!   ac_status=$?
!   echo "$as_me:9297: \$? = $ac_status" >&5
!   (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
!   { (eval echo "$as_me:9299: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:9302: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   ac_cv_sizeof_char_p=`cat conftest.val`
! else
!   echo "$as_me: program exited with status $ac_status" >&5
! echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! fi
! rm -f core core.* *.core conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
! fi
  fi
! rm -f conftest.val
! else
!   ac_cv_sizeof_char_p=0
! fi
! fi
! echo "$as_me:9318: result: $ac_cv_sizeof_char_p" >&5
! echo "${ECHO_T}$ac_cv_sizeof_char_p" >&6
! cat >>confdefs.h <<EOF
! #define SIZEOF_CHAR_P $ac_cv_sizeof_char_p
  EOF
  
! echo "$as_me:9324: checking for double" >&5
! echo $ECHO_N "checking for double... $ECHO_C" >&6
! if test "${ac_cv_type_double+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 9330 "configure"
! #include "confdefs.h"
! $ac_includes_default
! int
! main ()
! {
! if ((double *) 0)
!   return 0;
! if (sizeof (double))
!   return 0;
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext
! if { (eval echo "$as_me:9345: \"$ac_compile\"") >&5
!   (eval $ac_compile) 2>&5
!   ac_status=$?
!   echo "$as_me:9348: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest.$ac_objext'
!   { (eval echo "$as_me:9351: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:9354: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   ac_cv_type_double=yes
! else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! ac_cv_type_double=no
! fi
! rm -f conftest.$ac_objext conftest.$ac_ext
! fi
! echo "$as_me:9364: result: $ac_cv_type_double" >&5
! echo "${ECHO_T}$ac_cv_type_double" >&6
! 
! echo "$as_me:9367: checking size of double" >&5
! echo $ECHO_N "checking size of double... $ECHO_C" >&6
! if test "${ac_cv_sizeof_double+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
!   if test "$ac_cv_type_double" = yes; then
!   if test "$cross_compiling" = yes; then
!   # Depending upon the size, compute the lo and hi bounds.
! cat >conftest.$ac_ext <<_ACEOF
! #line 9376 "configure"
  #include "confdefs.h"
! $ac_includes_default
! int
! main ()
  {
! int _array_ [1 - 2 * !((sizeof (double)) >= 0)]
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext
! if { (eval echo "$as_me:9388: \"$ac_compile\"") >&5
!   (eval $ac_compile) 2>&5
!   ac_status=$?
!   echo "$as_me:9391: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest.$ac_objext'
!   { (eval echo "$as_me:9394: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:9397: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   ac_lo=0 ac_mid=0
!   while :; do
!     cat >conftest.$ac_ext <<_ACEOF
! #line 9402 "configure"
! #include "confdefs.h"
! $ac_includes_default
! int
! main ()
! {
! int _array_ [1 - 2 * !((sizeof (double)) <= $ac_mid)]
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext
! if { (eval echo "$as_me:9414: \"$ac_compile\"") >&5
!   (eval $ac_compile) 2>&5
!   ac_status=$?
!   echo "$as_me:9417: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest.$ac_objext'
!   { (eval echo "$as_me:9420: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:9423: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   ac_hi=$ac_mid; break
! else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! ac_lo=`expr $ac_mid + 1`; ac_mid=`expr 2 '*' $ac_mid + 1`
! fi
! rm -f conftest.$ac_objext conftest.$ac_ext
!   done
  else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! ac_hi=-1 ac_mid=-1
!   while :; do
!     cat >conftest.$ac_ext <<_ACEOF
! #line 9439 "configure"
! #include "confdefs.h"
! $ac_includes_default
! int
! main ()
! {
! int _array_ [1 - 2 * !((sizeof (double)) >= $ac_mid)]
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext
! if { (eval echo "$as_me:9451: \"$ac_compile\"") >&5
!   (eval $ac_compile) 2>&5
!   ac_status=$?
!   echo "$as_me:9454: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest.$ac_objext'
!   { (eval echo "$as_me:9457: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:9460: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   ac_lo=$ac_mid; break
! else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! ac_hi=`expr $ac_mid - 1`; ac_mid=`expr 2 '*' $ac_mid`
  fi
! rm -f conftest.$ac_objext conftest.$ac_ext
!   done
  fi
! rm -f conftest.$ac_objext conftest.$ac_ext
! # Binary search between lo and hi bounds.
! while test "x$ac_lo" != "x$ac_hi"; do
!   ac_mid=`expr '(' $ac_hi - $ac_lo ')' / 2 + $ac_lo`
!   cat >conftest.$ac_ext <<_ACEOF
! #line 9476 "configure"
! #include "confdefs.h"
! $ac_includes_default
! int
! main ()
! {
! int _array_ [1 - 2 * !((sizeof (double)) <= $ac_mid)]
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext
! if { (eval echo "$as_me:9488: \"$ac_compile\"") >&5
!   (eval $ac_compile) 2>&5
!   ac_status=$?
!   echo "$as_me:9491: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest.$ac_objext'
!   { (eval echo "$as_me:9494: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:9497: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   ac_hi=$ac_mid
! else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! ac_lo=`expr $ac_mid + 1`
  fi
! rm -f conftest.$ac_objext conftest.$ac_ext
! done
! ac_cv_sizeof_double=$ac_lo
  else
    if test "$cross_compiling" = yes; then
!   { { echo "$as_me:9510: error: cannot run test program while cross compiling" >&5
! echo "$as_me: error: cannot run test program while cross compiling" >&2;}
!    { (exit 1); exit 1; }; }
  else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 9515 "configure"
  #include "confdefs.h"
! $ac_includes_default
! int
! main ()
  {
! FILE *f = fopen ("conftest.val", "w");
! if (!f)
!   exit (1);
! fprintf (f, "%d", (sizeof (double)));
! fclose (f);
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest$ac_exeext
! if { (eval echo "$as_me:9531: \"$ac_link\"") >&5
!   (eval $ac_link) 2>&5
!   ac_status=$?
!   echo "$as_me:9534: \$? = $ac_status" >&5
!   (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
!   { (eval echo "$as_me:9536: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:9539: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   ac_cv_sizeof_double=`cat conftest.val`
! else
!   echo "$as_me: program exited with status $ac_status" >&5
! echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
  fi
! rm -f core core.* *.core conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
  fi
  fi
! rm -f conftest.val
! else
!   ac_cv_sizeof_double=0
! fi
! fi
! echo "$as_me:9555: result: $ac_cv_sizeof_double" >&5
! echo "${ECHO_T}$ac_cv_sizeof_double" >&6
! cat >>confdefs.h <<EOF
! #define SIZEOF_DOUBLE $ac_cv_sizeof_double
  EOF
  
! echo "$as_me:9561: checking for long long" >&5
! echo $ECHO_N "checking for long long... $ECHO_C" >&6
! if test "${ac_cv_type_long_long+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 9567 "configure"
! #include "confdefs.h"
! $ac_includes_default
! int
! main ()
! {
! if ((long long *) 0)
!   return 0;
! if (sizeof (long long))
!   return 0;
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext
! if { (eval echo "$as_me:9582: \"$ac_compile\"") >&5
!   (eval $ac_compile) 2>&5
!   ac_status=$?
!   echo "$as_me:9585: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest.$ac_objext'
!   { (eval echo "$as_me:9588: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:9591: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   ac_cv_type_long_long=yes
! else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! ac_cv_type_long_long=no
! fi
! rm -f conftest.$ac_objext conftest.$ac_ext
! fi
! echo "$as_me:9601: result: $ac_cv_type_long_long" >&5
! echo "${ECHO_T}$ac_cv_type_long_long" >&6
! 
! echo "$as_me:9604: checking size of long long" >&5
! echo $ECHO_N "checking size of long long... $ECHO_C" >&6
! if test "${ac_cv_sizeof_long_long+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
!   if test "$ac_cv_type_long_long" = yes; then
!   if test "$cross_compiling" = yes; then
!   # Depending upon the size, compute the lo and hi bounds.
! cat >conftest.$ac_ext <<_ACEOF
! #line 9613 "configure"
  #include "confdefs.h"
! $ac_includes_default
! int
! main ()
  {
! int _array_ [1 - 2 * !((sizeof (long long)) >= 0)]
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext
! if { (eval echo "$as_me:9625: \"$ac_compile\"") >&5
!   (eval $ac_compile) 2>&5
!   ac_status=$?
!   echo "$as_me:9628: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest.$ac_objext'
!   { (eval echo "$as_me:9631: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:9634: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   ac_lo=0 ac_mid=0
!   while :; do
!     cat >conftest.$ac_ext <<_ACEOF
! #line 9639 "configure"
! #include "confdefs.h"
! $ac_includes_default
! int
! main ()
! {
! int _array_ [1 - 2 * !((sizeof (long long)) <= $ac_mid)]
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext
! if { (eval echo "$as_me:9651: \"$ac_compile\"") >&5
!   (eval $ac_compile) 2>&5
!   ac_status=$?
!   echo "$as_me:9654: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest.$ac_objext'
!   { (eval echo "$as_me:9657: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:9660: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   ac_hi=$ac_mid; break
! else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! ac_lo=`expr $ac_mid + 1`; ac_mid=`expr 2 '*' $ac_mid + 1`
! fi
! rm -f conftest.$ac_objext conftest.$ac_ext
!   done
  else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! ac_hi=-1 ac_mid=-1
!   while :; do
!     cat >conftest.$ac_ext <<_ACEOF
! #line 9676 "configure"
! #include "confdefs.h"
! $ac_includes_default
! int
! main ()
! {
! int _array_ [1 - 2 * !((sizeof (long long)) >= $ac_mid)]
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext
! if { (eval echo "$as_me:9688: \"$ac_compile\"") >&5
!   (eval $ac_compile) 2>&5
!   ac_status=$?
!   echo "$as_me:9691: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest.$ac_objext'
!   { (eval echo "$as_me:9694: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:9697: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   ac_lo=$ac_mid; break
! else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! ac_hi=`expr $ac_mid - 1`; ac_mid=`expr 2 '*' $ac_mid`
  fi
! rm -f conftest.$ac_objext conftest.$ac_ext
!   done
  fi
! rm -f conftest.$ac_objext conftest.$ac_ext
! # Binary search between lo and hi bounds.
! while test "x$ac_lo" != "x$ac_hi"; do
!   ac_mid=`expr '(' $ac_hi - $ac_lo ')' / 2 + $ac_lo`
!   cat >conftest.$ac_ext <<_ACEOF
! #line 9713 "configure"
! #include "confdefs.h"
! $ac_includes_default
! int
! main ()
! {
! int _array_ [1 - 2 * !((sizeof (long long)) <= $ac_mid)]
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext
! if { (eval echo "$as_me:9725: \"$ac_compile\"") >&5
!   (eval $ac_compile) 2>&5
!   ac_status=$?
!   echo "$as_me:9728: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest.$ac_objext'
!   { (eval echo "$as_me:9731: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:9734: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   ac_hi=$ac_mid
! else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! ac_lo=`expr $ac_mid + 1`
  fi
! rm -f conftest.$ac_objext conftest.$ac_ext
! done
! ac_cv_sizeof_long_long=$ac_lo
  else
    if test "$cross_compiling" = yes; then
!   { { echo "$as_me:9747: error: cannot run test program while cross compiling" >&5
! echo "$as_me: error: cannot run test program while cross compiling" >&2;}
!    { (exit 1); exit 1; }; }
  else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 9752 "configure"
  #include "confdefs.h"
! $ac_includes_default
! int
! main ()
  {
! FILE *f = fopen ("conftest.val", "w");
! if (!f)
!   exit (1);
! fprintf (f, "%d", (sizeof (long long)));
! fclose (f);
!   ;
!   return 0;
  }
! _ACEOF
! rm -f conftest$ac_exeext
! if { (eval echo "$as_me:9768: \"$ac_link\"") >&5
!   (eval $ac_link) 2>&5
!   ac_status=$?
!   echo "$as_me:9771: \$? = $ac_status" >&5
!   (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
!   { (eval echo "$as_me:9773: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:9776: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   ac_cv_sizeof_long_long=`cat conftest.val`
  else
!   echo "$as_me: program exited with status $ac_status" >&5
! echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
  fi
! rm -f core core.* *.core conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
  fi
  fi
! rm -f conftest.val
! else
!   ac_cv_sizeof_long_long=0
! fi
! fi
! echo "$as_me:9792: result: $ac_cv_sizeof_long_long" >&5
! echo "${ECHO_T}$ac_cv_sizeof_long_long" >&6
! cat >>confdefs.h <<EOF
! #define SIZEOF_LONG_LONG $ac_cv_sizeof_long_long
  EOF
  
! echo "$as_me:9798: checking for u_int" >&5
! echo $ECHO_N "checking for u_int... $ECHO_C" >&6
! if test "${ac_cv_type_u_int+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 9804 "configure"
  #include "confdefs.h"
! $ac_includes_default
! int
! main ()
! {
! if ((u_int *) 0)
!   return 0;
! if (sizeof (u_int))
!   return 0;
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext
! if { (eval echo "$as_me:9819: \"$ac_compile\"") >&5
!   (eval $ac_compile) 2>&5
!   ac_status=$?
!   echo "$as_me:9822: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest.$ac_objext'
!   { (eval echo "$as_me:9825: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:9828: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
    ac_cv_type_u_int=yes
  else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! ac_cv_type_u_int=no
! fi
! rm -f conftest.$ac_objext conftest.$ac_ext
! fi
! echo "$as_me:9838: result: $ac_cv_type_u_int" >&5
! echo "${ECHO_T}$ac_cv_type_u_int" >&6
! if test $ac_cv_type_u_int = yes; then
!   :
! else
  
! cat >>confdefs.h <<EOF
  #define u_int unsigned int
  EOF
***************
*** 4772,4803 ****
  fi
  
! echo $ac_n "checking for u_long""... $ac_c" 1>&6
! echo "configure:4776: checking for u_long" >&5
! if eval "test \"`echo '$''{'ac_cv_type_u_long'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
!   cat > conftest.$ac_ext <<EOF
! #line 4781 "configure"
  #include "confdefs.h"
! #include <sys/types.h>
! #if STDC_HEADERS
! #include <stdlib.h>
! #include <stddef.h>
! #endif
! EOF
! if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
!   egrep "(^|[^a-zA-Z_0-9])u_long[^a-zA-Z_0-9]" >/dev/null 2>&1; then
!   rm -rf conftest*
    ac_cv_type_u_long=yes
  else
!   rm -rf conftest*
!   ac_cv_type_u_long=no
! fi
! rm -f conftest*
  
! fi
! echo "$ac_t""$ac_cv_type_u_long" 1>&6
! if test $ac_cv_type_u_long = no; then
!   cat >> confdefs.h <<\EOF
  #define u_long unsigned long
  EOF
--- 9848,9898 ----
  fi
  
! echo "$as_me:9850: checking for u_long" >&5
! echo $ECHO_N "checking for u_long... $ECHO_C" >&6
! if test "${ac_cv_type_u_long+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 9856 "configure"
  #include "confdefs.h"
! $ac_includes_default
! int
! main ()
! {
! if ((u_long *) 0)
!   return 0;
! if (sizeof (u_long))
!   return 0;
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext
! if { (eval echo "$as_me:9871: \"$ac_compile\"") >&5
!   (eval $ac_compile) 2>&5
!   ac_status=$?
!   echo "$as_me:9874: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest.$ac_objext'
!   { (eval echo "$as_me:9877: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:9880: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
    ac_cv_type_u_long=yes
  else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! ac_cv_type_u_long=no
! fi
! rm -f conftest.$ac_objext conftest.$ac_ext
! fi
! echo "$as_me:9890: result: $ac_cv_type_u_long" >&5
! echo "${ECHO_T}$ac_cv_type_u_long" >&6
! if test $ac_cv_type_u_long = yes; then
!   :
! else
  
! cat >>confdefs.h <<EOF
  #define u_long unsigned long
  EOF
***************
*** 4805,4839 ****
  fi
  
- 
- 
  if test "$ac_cv_sizeof_short" = 2; then
!   echo $ac_n "checking for bits16_t""... $ac_c" 1>&6
! echo "configure:4812: checking for bits16_t" >&5
! if eval "test \"`echo '$''{'ac_cv_type_bits16_t'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
!   cat > conftest.$ac_ext <<EOF
! #line 4817 "configure"
  #include "confdefs.h"
! #include <sys/types.h>
! #if STDC_HEADERS
! #include <stdlib.h>
! #include <stddef.h>
! #endif
! EOF
! if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
!   egrep "(^|[^a-zA-Z_0-9])bits16_t[^a-zA-Z_0-9]" >/dev/null 2>&1; then
!   rm -rf conftest*
    ac_cv_type_bits16_t=yes
  else
!   rm -rf conftest*
!   ac_cv_type_bits16_t=no
! fi
! rm -f conftest*
  
! fi
! echo "$ac_t""$ac_cv_type_bits16_t" 1>&6
! if test $ac_cv_type_bits16_t = no; then
!   cat >> confdefs.h <<\EOF
  #define bits16_t short
  EOF
--- 9900,9951 ----
  fi
  
  if test "$ac_cv_sizeof_short" = 2; then
!   echo "$as_me:9903: checking for bits16_t" >&5
! echo $ECHO_N "checking for bits16_t... $ECHO_C" >&6
! if test "${ac_cv_type_bits16_t+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 9909 "configure"
  #include "confdefs.h"
! $ac_includes_default
! int
! main ()
! {
! if ((bits16_t *) 0)
!   return 0;
! if (sizeof (bits16_t))
!   return 0;
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext
! if { (eval echo "$as_me:9924: \"$ac_compile\"") >&5
!   (eval $ac_compile) 2>&5
!   ac_status=$?
!   echo "$as_me:9927: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest.$ac_objext'
!   { (eval echo "$as_me:9930: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:9933: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
    ac_cv_type_bits16_t=yes
  else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! ac_cv_type_bits16_t=no
! fi
! rm -f conftest.$ac_objext conftest.$ac_ext
! fi
! echo "$as_me:9943: result: $ac_cv_type_bits16_t" >&5
! echo "${ECHO_T}$ac_cv_type_bits16_t" >&6
! if test $ac_cv_type_bits16_t = yes; then
!   :
! else
  
! cat >>confdefs.h <<EOF
  #define bits16_t short
  EOF
***************
*** 4842,4873 ****
  
  elif test "$ac_cv_sizeof_char" = 2; then
!   echo $ac_n "checking for bits16_t""... $ac_c" 1>&6
! echo "configure:4846: checking for bits16_t" >&5
! if eval "test \"`echo '$''{'ac_cv_type_bits16_t'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
!   cat > conftest.$ac_ext <<EOF
! #line 4851 "configure"
  #include "confdefs.h"
! #include <sys/types.h>
! #if STDC_HEADERS
! #include <stdlib.h>
! #include <stddef.h>
! #endif
! EOF
! if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
!   egrep "(^|[^a-zA-Z_0-9])bits16_t[^a-zA-Z_0-9]" >/dev/null 2>&1; then
!   rm -rf conftest*
    ac_cv_type_bits16_t=yes
  else
!   rm -rf conftest*
!   ac_cv_type_bits16_t=no
! fi
! rm -f conftest*
  
! fi
! echo "$ac_t""$ac_cv_type_bits16_t" 1>&6
! if test $ac_cv_type_bits16_t = no; then
!   cat >> confdefs.h <<\EOF
  #define bits16_t char
  EOF
--- 9954,10004 ----
  
  elif test "$ac_cv_sizeof_char" = 2; then
!   echo "$as_me:9956: checking for bits16_t" >&5
! echo $ECHO_N "checking for bits16_t... $ECHO_C" >&6
! if test "${ac_cv_type_bits16_t+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 9962 "configure"
  #include "confdefs.h"
! $ac_includes_default
! int
! main ()
! {
! if ((bits16_t *) 0)
!   return 0;
! if (sizeof (bits16_t))
!   return 0;
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext
! if { (eval echo "$as_me:9977: \"$ac_compile\"") >&5
!   (eval $ac_compile) 2>&5
!   ac_status=$?
!   echo "$as_me:9980: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest.$ac_objext'
!   { (eval echo "$as_me:9983: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:9986: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
    ac_cv_type_bits16_t=yes
  else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! ac_cv_type_bits16_t=no
! fi
! rm -f conftest.$ac_objext conftest.$ac_ext
! fi
! echo "$as_me:9996: result: $ac_cv_type_bits16_t" >&5
! echo "${ECHO_T}$ac_cv_type_bits16_t" >&6
! if test $ac_cv_type_bits16_t = yes; then
!   :
! else
  
! cat >>confdefs.h <<EOF
  #define bits16_t char
  EOF
***************
*** 4876,4907 ****
  
  else
!   echo $ac_n "checking for bits16_t""... $ac_c" 1>&6
! echo "configure:4880: checking for bits16_t" >&5
! if eval "test \"`echo '$''{'ac_cv_type_bits16_t'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
!   cat > conftest.$ac_ext <<EOF
! #line 4885 "configure"
  #include "confdefs.h"
! #include <sys/types.h>
! #if STDC_HEADERS
! #include <stdlib.h>
! #include <stddef.h>
! #endif
! EOF
! if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
!   egrep "(^|[^a-zA-Z_0-9])bits16_t[^a-zA-Z_0-9]" >/dev/null 2>&1; then
!   rm -rf conftest*
    ac_cv_type_bits16_t=yes
  else
!   rm -rf conftest*
!   ac_cv_type_bits16_t=no
! fi
! rm -f conftest*
  
! fi
! echo "$ac_t""$ac_cv_type_bits16_t" 1>&6
! if test $ac_cv_type_bits16_t = no; then
!   cat >> confdefs.h <<\EOF
  #define bits16_t short
  EOF
--- 10007,10057 ----
  
  else
!   echo "$as_me:10009: checking for bits16_t" >&5
! echo $ECHO_N "checking for bits16_t... $ECHO_C" >&6
! if test "${ac_cv_type_bits16_t+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 10015 "configure"
  #include "confdefs.h"
! $ac_includes_default
! int
! main ()
! {
! if ((bits16_t *) 0)
!   return 0;
! if (sizeof (bits16_t))
!   return 0;
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext
! if { (eval echo "$as_me:10030: \"$ac_compile\"") >&5
!   (eval $ac_compile) 2>&5
!   ac_status=$?
!   echo "$as_me:10033: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest.$ac_objext'
!   { (eval echo "$as_me:10036: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:10039: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
    ac_cv_type_bits16_t=yes
  else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! ac_cv_type_bits16_t=no
! fi
! rm -f conftest.$ac_objext conftest.$ac_ext
! fi
! echo "$as_me:10049: result: $ac_cv_type_bits16_t" >&5
! echo "${ECHO_T}$ac_cv_type_bits16_t" >&6
! if test $ac_cv_type_bits16_t = yes; then
!   :
! else
  
! cat >>confdefs.h <<EOF
  #define bits16_t short
  EOF
***************
*** 4911,4944 ****
  fi
  
- 
  if test "$ac_cv_sizeof_short" = 2; then
!   echo $ac_n "checking for u_bits16_t""... $ac_c" 1>&6
! echo "configure:4917: checking for u_bits16_t" >&5
! if eval "test \"`echo '$''{'ac_cv_type_u_bits16_t'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
!   cat > conftest.$ac_ext <<EOF
! #line 4922 "configure"
  #include "confdefs.h"
! #include <sys/types.h>
! #if STDC_HEADERS
! #include <stdlib.h>
! #include <stddef.h>
! #endif
! EOF
! if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
!   egrep "(^|[^a-zA-Z_0-9])u_bits16_t[^a-zA-Z_0-9]" >/dev/null 2>&1; then
!   rm -rf conftest*
    ac_cv_type_u_bits16_t=yes
  else
!   rm -rf conftest*
!   ac_cv_type_u_bits16_t=no
! fi
! rm -f conftest*
  
! fi
! echo "$ac_t""$ac_cv_type_u_bits16_t" 1>&6
! if test $ac_cv_type_u_bits16_t = no; then
!   cat >> confdefs.h <<\EOF
  #define u_bits16_t unsigned short
  EOF
--- 10061,10112 ----
  fi
  
  if test "$ac_cv_sizeof_short" = 2; then
!   echo "$as_me:10064: checking for u_bits16_t" >&5
! echo $ECHO_N "checking for u_bits16_t... $ECHO_C" >&6
! if test "${ac_cv_type_u_bits16_t+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 10070 "configure"
  #include "confdefs.h"
! $ac_includes_default
! int
! main ()
! {
! if ((u_bits16_t *) 0)
!   return 0;
! if (sizeof (u_bits16_t))
!   return 0;
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext
! if { (eval echo "$as_me:10085: \"$ac_compile\"") >&5
!   (eval $ac_compile) 2>&5
!   ac_status=$?
!   echo "$as_me:10088: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest.$ac_objext'
!   { (eval echo "$as_me:10091: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:10094: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
    ac_cv_type_u_bits16_t=yes
  else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! ac_cv_type_u_bits16_t=no
! fi
! rm -f conftest.$ac_objext conftest.$ac_ext
! fi
! echo "$as_me:10104: result: $ac_cv_type_u_bits16_t" >&5
! echo "${ECHO_T}$ac_cv_type_u_bits16_t" >&6
! if test $ac_cv_type_u_bits16_t = yes; then
!   :
! else
  
! cat >>confdefs.h <<EOF
  #define u_bits16_t unsigned short
  EOF
***************
*** 4947,4978 ****
  
  elif test "$ac_cv_sizeof_char" = 2; then
!   echo $ac_n "checking for u_bits16_t""... $ac_c" 1>&6
! echo "configure:4951: checking for u_bits16_t" >&5
! if eval "test \"`echo '$''{'ac_cv_type_u_bits16_t'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
!   cat > conftest.$ac_ext <<EOF
! #line 4956 "configure"
  #include "confdefs.h"
! #include <sys/types.h>
! #if STDC_HEADERS
! #include <stdlib.h>
! #include <stddef.h>
! #endif
! EOF
! if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
!   egrep "(^|[^a-zA-Z_0-9])u_bits16_t[^a-zA-Z_0-9]" >/dev/null 2>&1; then
!   rm -rf conftest*
    ac_cv_type_u_bits16_t=yes
  else
!   rm -rf conftest*
!   ac_cv_type_u_bits16_t=no
! fi
! rm -f conftest*
  
! fi
! echo "$ac_t""$ac_cv_type_u_bits16_t" 1>&6
! if test $ac_cv_type_u_bits16_t = no; then
!   cat >> confdefs.h <<\EOF
  #define u_bits16_t unsigned char
  EOF
--- 10115,10165 ----
  
  elif test "$ac_cv_sizeof_char" = 2; then
!   echo "$as_me:10117: checking for u_bits16_t" >&5
! echo $ECHO_N "checking for u_bits16_t... $ECHO_C" >&6
! if test "${ac_cv_type_u_bits16_t+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 10123 "configure"
  #include "confdefs.h"
! $ac_includes_default
! int
! main ()
! {
! if ((u_bits16_t *) 0)
!   return 0;
! if (sizeof (u_bits16_t))
!   return 0;
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext
! if { (eval echo "$as_me:10138: \"$ac_compile\"") >&5
!   (eval $ac_compile) 2>&5
!   ac_status=$?
!   echo "$as_me:10141: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest.$ac_objext'
!   { (eval echo "$as_me:10144: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:10147: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
    ac_cv_type_u_bits16_t=yes
  else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! ac_cv_type_u_bits16_t=no
! fi
! rm -f conftest.$ac_objext conftest.$ac_ext
! fi
! echo "$as_me:10157: result: $ac_cv_type_u_bits16_t" >&5
! echo "${ECHO_T}$ac_cv_type_u_bits16_t" >&6
! if test $ac_cv_type_u_bits16_t = yes; then
!   :
! else
  
! cat >>confdefs.h <<EOF
  #define u_bits16_t unsigned char
  EOF
***************
*** 4981,5012 ****
  
  else
!   echo $ac_n "checking for u_bits16_t""... $ac_c" 1>&6
! echo "configure:4985: checking for u_bits16_t" >&5
! if eval "test \"`echo '$''{'ac_cv_type_u_bits16_t'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
!   cat > conftest.$ac_ext <<EOF
! #line 4990 "configure"
  #include "confdefs.h"
! #include <sys/types.h>
! #if STDC_HEADERS
! #include <stdlib.h>
! #include <stddef.h>
! #endif
! EOF
! if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
!   egrep "(^|[^a-zA-Z_0-9])u_bits16_t[^a-zA-Z_0-9]" >/dev/null 2>&1; then
!   rm -rf conftest*
    ac_cv_type_u_bits16_t=yes
  else
!   rm -rf conftest*
!   ac_cv_type_u_bits16_t=no
! fi
! rm -f conftest*
  
! fi
! echo "$ac_t""$ac_cv_type_u_bits16_t" 1>&6
! if test $ac_cv_type_u_bits16_t = no; then
!   cat >> confdefs.h <<\EOF
  #define u_bits16_t unsigned short
  EOF
--- 10168,10218 ----
  
  else
!   echo "$as_me:10170: checking for u_bits16_t" >&5
! echo $ECHO_N "checking for u_bits16_t... $ECHO_C" >&6
! if test "${ac_cv_type_u_bits16_t+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 10176 "configure"
  #include "confdefs.h"
! $ac_includes_default
! int
! main ()
! {
! if ((u_bits16_t *) 0)
!   return 0;
! if (sizeof (u_bits16_t))
!   return 0;
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext
! if { (eval echo "$as_me:10191: \"$ac_compile\"") >&5
!   (eval $ac_compile) 2>&5
!   ac_status=$?
!   echo "$as_me:10194: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest.$ac_objext'
!   { (eval echo "$as_me:10197: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:10200: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
    ac_cv_type_u_bits16_t=yes
  else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! ac_cv_type_u_bits16_t=no
! fi
! rm -f conftest.$ac_objext conftest.$ac_ext
! fi
! echo "$as_me:10210: result: $ac_cv_type_u_bits16_t" >&5
! echo "${ECHO_T}$ac_cv_type_u_bits16_t" >&6
! if test $ac_cv_type_u_bits16_t = yes; then
!   :
! else
  
! cat >>confdefs.h <<EOF
  #define u_bits16_t unsigned short
  EOF
***************
*** 5016,5049 ****
  fi
  
- 
  if test "$ac_cv_sizeof_int" = 4; then
!   echo $ac_n "checking for bits32_t""... $ac_c" 1>&6
! echo "configure:5022: checking for bits32_t" >&5
! if eval "test \"`echo '$''{'ac_cv_type_bits32_t'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
!   cat > conftest.$ac_ext <<EOF
! #line 5027 "configure"
  #include "confdefs.h"
! #include <sys/types.h>
! #if STDC_HEADERS
! #include <stdlib.h>
! #include <stddef.h>
! #endif
! EOF
! if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
!   egrep "(^|[^a-zA-Z_0-9])bits32_t[^a-zA-Z_0-9]" >/dev/null 2>&1; then
!   rm -rf conftest*
    ac_cv_type_bits32_t=yes
  else
!   rm -rf conftest*
!   ac_cv_type_bits32_t=no
! fi
! rm -f conftest*
  
! fi
! echo "$ac_t""$ac_cv_type_bits32_t" 1>&6
! if test $ac_cv_type_bits32_t = no; then
!   cat >> confdefs.h <<\EOF
  #define bits32_t int
  EOF
--- 10222,10273 ----
  fi
  
  if test "$ac_cv_sizeof_int" = 4; then
!   echo "$as_me:10225: checking for bits32_t" >&5
! echo $ECHO_N "checking for bits32_t... $ECHO_C" >&6
! if test "${ac_cv_type_bits32_t+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 10231 "configure"
  #include "confdefs.h"
! $ac_includes_default
! int
! main ()
! {
! if ((bits32_t *) 0)
!   return 0;
! if (sizeof (bits32_t))
!   return 0;
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext
! if { (eval echo "$as_me:10246: \"$ac_compile\"") >&5
!   (eval $ac_compile) 2>&5
!   ac_status=$?
!   echo "$as_me:10249: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest.$ac_objext'
!   { (eval echo "$as_me:10252: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:10255: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
    ac_cv_type_bits32_t=yes
  else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! ac_cv_type_bits32_t=no
! fi
! rm -f conftest.$ac_objext conftest.$ac_ext
! fi
! echo "$as_me:10265: result: $ac_cv_type_bits32_t" >&5
! echo "${ECHO_T}$ac_cv_type_bits32_t" >&6
! if test $ac_cv_type_bits32_t = yes; then
!   :
! else
  
! cat >>confdefs.h <<EOF
  #define bits32_t int
  EOF
***************
*** 5052,5083 ****
  
  elif test "$ac_cv_sizeof_long" = 4; then
!   echo $ac_n "checking for bits32_t""... $ac_c" 1>&6
! echo "configure:5056: checking for bits32_t" >&5
! if eval "test \"`echo '$''{'ac_cv_type_bits32_t'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
!   cat > conftest.$ac_ext <<EOF
! #line 5061 "configure"
  #include "confdefs.h"
! #include <sys/types.h>
! #if STDC_HEADERS
! #include <stdlib.h>
! #include <stddef.h>
! #endif
! EOF
! if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
!   egrep "(^|[^a-zA-Z_0-9])bits32_t[^a-zA-Z_0-9]" >/dev/null 2>&1; then
!   rm -rf conftest*
    ac_cv_type_bits32_t=yes
  else
!   rm -rf conftest*
!   ac_cv_type_bits32_t=no
! fi
! rm -f conftest*
  
! fi
! echo "$ac_t""$ac_cv_type_bits32_t" 1>&6
! if test $ac_cv_type_bits32_t = no; then
!   cat >> confdefs.h <<\EOF
  #define bits32_t long
  EOF
--- 10276,10326 ----
  
  elif test "$ac_cv_sizeof_long" = 4; then
!   echo "$as_me:10278: checking for bits32_t" >&5
! echo $ECHO_N "checking for bits32_t... $ECHO_C" >&6
! if test "${ac_cv_type_bits32_t+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 10284 "configure"
  #include "confdefs.h"
! $ac_includes_default
! int
! main ()
! {
! if ((bits32_t *) 0)
!   return 0;
! if (sizeof (bits32_t))
!   return 0;
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext
! if { (eval echo "$as_me:10299: \"$ac_compile\"") >&5
!   (eval $ac_compile) 2>&5
!   ac_status=$?
!   echo "$as_me:10302: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest.$ac_objext'
!   { (eval echo "$as_me:10305: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:10308: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
    ac_cv_type_bits32_t=yes
  else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! ac_cv_type_bits32_t=no
! fi
! rm -f conftest.$ac_objext conftest.$ac_ext
! fi
! echo "$as_me:10318: result: $ac_cv_type_bits32_t" >&5
! echo "${ECHO_T}$ac_cv_type_bits32_t" >&6
! if test $ac_cv_type_bits32_t = yes; then
!   :
! else
  
! cat >>confdefs.h <<EOF
  #define bits32_t long
  EOF
***************
*** 5086,5117 ****
  
  else
!   echo $ac_n "checking for bits32_t""... $ac_c" 1>&6
! echo "configure:5090: checking for bits32_t" >&5
! if eval "test \"`echo '$''{'ac_cv_type_bits32_t'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
!   cat > conftest.$ac_ext <<EOF
! #line 5095 "configure"
  #include "confdefs.h"
! #include <sys/types.h>
! #if STDC_HEADERS
! #include <stdlib.h>
! #include <stddef.h>
! #endif
! EOF
! if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
!   egrep "(^|[^a-zA-Z_0-9])bits32_t[^a-zA-Z_0-9]" >/dev/null 2>&1; then
!   rm -rf conftest*
    ac_cv_type_bits32_t=yes
  else
!   rm -rf conftest*
!   ac_cv_type_bits32_t=no
! fi
! rm -f conftest*
  
! fi
! echo "$ac_t""$ac_cv_type_bits32_t" 1>&6
! if test $ac_cv_type_bits32_t = no; then
!   cat >> confdefs.h <<\EOF
  #define bits32_t int
  EOF
--- 10329,10379 ----
  
  else
!   echo "$as_me:10331: checking for bits32_t" >&5
! echo $ECHO_N "checking for bits32_t... $ECHO_C" >&6
! if test "${ac_cv_type_bits32_t+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 10337 "configure"
  #include "confdefs.h"
! $ac_includes_default
! int
! main ()
! {
! if ((bits32_t *) 0)
!   return 0;
! if (sizeof (bits32_t))
!   return 0;
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext
! if { (eval echo "$as_me:10352: \"$ac_compile\"") >&5
!   (eval $ac_compile) 2>&5
!   ac_status=$?
!   echo "$as_me:10355: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest.$ac_objext'
!   { (eval echo "$as_me:10358: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:10361: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
    ac_cv_type_bits32_t=yes
  else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! ac_cv_type_bits32_t=no
! fi
! rm -f conftest.$ac_objext conftest.$ac_ext
! fi
! echo "$as_me:10371: result: $ac_cv_type_bits32_t" >&5
! echo "${ECHO_T}$ac_cv_type_bits32_t" >&6
! if test $ac_cv_type_bits32_t = yes; then
!   :
! else
  
! cat >>confdefs.h <<EOF
  #define bits32_t int
  EOF
***************
*** 5121,5154 ****
  fi
  
- 
  if test "$ac_cv_sizeof_int" = 4; then
!   echo $ac_n "checking for u_bits32_t""... $ac_c" 1>&6
! echo "configure:5127: checking for u_bits32_t" >&5
! if eval "test \"`echo '$''{'ac_cv_type_u_bits32_t'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
!   cat > conftest.$ac_ext <<EOF
! #line 5132 "configure"
  #include "confdefs.h"
! #include <sys/types.h>
! #if STDC_HEADERS
! #include <stdlib.h>
! #include <stddef.h>
! #endif
! EOF
! if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
!   egrep "(^|[^a-zA-Z_0-9])u_bits32_t[^a-zA-Z_0-9]" >/dev/null 2>&1; then
!   rm -rf conftest*
    ac_cv_type_u_bits32_t=yes
  else
!   rm -rf conftest*
!   ac_cv_type_u_bits32_t=no
! fi
! rm -f conftest*
  
! fi
! echo "$ac_t""$ac_cv_type_u_bits32_t" 1>&6
! if test $ac_cv_type_u_bits32_t = no; then
!   cat >> confdefs.h <<\EOF
  #define u_bits32_t unsigned int
  EOF
--- 10383,10434 ----
  fi
  
  if test "$ac_cv_sizeof_int" = 4; then
!   echo "$as_me:10386: checking for u_bits32_t" >&5
! echo $ECHO_N "checking for u_bits32_t... $ECHO_C" >&6
! if test "${ac_cv_type_u_bits32_t+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 10392 "configure"
  #include "confdefs.h"
! $ac_includes_default
! int
! main ()
! {
! if ((u_bits32_t *) 0)
!   return 0;
! if (sizeof (u_bits32_t))
!   return 0;
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext
! if { (eval echo "$as_me:10407: \"$ac_compile\"") >&5
!   (eval $ac_compile) 2>&5
!   ac_status=$?
!   echo "$as_me:10410: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest.$ac_objext'
!   { (eval echo "$as_me:10413: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:10416: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
    ac_cv_type_u_bits32_t=yes
  else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! ac_cv_type_u_bits32_t=no
! fi
! rm -f conftest.$ac_objext conftest.$ac_ext
! fi
! echo "$as_me:10426: result: $ac_cv_type_u_bits32_t" >&5
! echo "${ECHO_T}$ac_cv_type_u_bits32_t" >&6
! if test $ac_cv_type_u_bits32_t = yes; then
!   :
! else
  
! cat >>confdefs.h <<EOF
  #define u_bits32_t unsigned int
  EOF
***************
*** 5157,5188 ****
  
  elif test "$ac_cv_sizeof_long" = 4; then
!   echo $ac_n "checking for u_bits32_t""... $ac_c" 1>&6
! echo "configure:5161: checking for u_bits32_t" >&5
! if eval "test \"`echo '$''{'ac_cv_type_u_bits32_t'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
!   cat > conftest.$ac_ext <<EOF
! #line 5166 "configure"
  #include "confdefs.h"
! #include <sys/types.h>
! #if STDC_HEADERS
! #include <stdlib.h>
! #include <stddef.h>
! #endif
! EOF
! if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
!   egrep "(^|[^a-zA-Z_0-9])u_bits32_t[^a-zA-Z_0-9]" >/dev/null 2>&1; then
!   rm -rf conftest*
    ac_cv_type_u_bits32_t=yes
  else
!   rm -rf conftest*
!   ac_cv_type_u_bits32_t=no
! fi
! rm -f conftest*
  
! fi
! echo "$ac_t""$ac_cv_type_u_bits32_t" 1>&6
! if test $ac_cv_type_u_bits32_t = no; then
!   cat >> confdefs.h <<\EOF
  #define u_bits32_t unsigned long
  EOF
--- 10437,10487 ----
  
  elif test "$ac_cv_sizeof_long" = 4; then
!   echo "$as_me:10439: checking for u_bits32_t" >&5
! echo $ECHO_N "checking for u_bits32_t... $ECHO_C" >&6
! if test "${ac_cv_type_u_bits32_t+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 10445 "configure"
  #include "confdefs.h"
! $ac_includes_default
! int
! main ()
! {
! if ((u_bits32_t *) 0)
!   return 0;
! if (sizeof (u_bits32_t))
!   return 0;
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext
! if { (eval echo "$as_me:10460: \"$ac_compile\"") >&5
!   (eval $ac_compile) 2>&5
!   ac_status=$?
!   echo "$as_me:10463: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest.$ac_objext'
!   { (eval echo "$as_me:10466: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:10469: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
    ac_cv_type_u_bits32_t=yes
  else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! ac_cv_type_u_bits32_t=no
! fi
! rm -f conftest.$ac_objext conftest.$ac_ext
! fi
! echo "$as_me:10479: result: $ac_cv_type_u_bits32_t" >&5
! echo "${ECHO_T}$ac_cv_type_u_bits32_t" >&6
! if test $ac_cv_type_u_bits32_t = yes; then
!   :
! else
  
! cat >>confdefs.h <<EOF
  #define u_bits32_t unsigned long
  EOF
***************
*** 5191,5222 ****
  
  else
!   echo $ac_n "checking for u_bits32_t""... $ac_c" 1>&6
! echo "configure:5195: checking for u_bits32_t" >&5
! if eval "test \"`echo '$''{'ac_cv_type_u_bits32_t'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
!   cat > conftest.$ac_ext <<EOF
! #line 5200 "configure"
  #include "confdefs.h"
! #include <sys/types.h>
! #if STDC_HEADERS
! #include <stdlib.h>
! #include <stddef.h>
! #endif
! EOF
! if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
!   egrep "(^|[^a-zA-Z_0-9])u_bits32_t[^a-zA-Z_0-9]" >/dev/null 2>&1; then
!   rm -rf conftest*
    ac_cv_type_u_bits32_t=yes
  else
!   rm -rf conftest*
!   ac_cv_type_u_bits32_t=no
! fi
! rm -f conftest*
  
! fi
! echo "$ac_t""$ac_cv_type_u_bits32_t" 1>&6
! if test $ac_cv_type_u_bits32_t = no; then
!   cat >> confdefs.h <<\EOF
  #define u_bits32_t unsigned int
  EOF
--- 10490,10540 ----
  
  else
!   echo "$as_me:10492: checking for u_bits32_t" >&5
! echo $ECHO_N "checking for u_bits32_t... $ECHO_C" >&6
! if test "${ac_cv_type_u_bits32_t+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 10498 "configure"
  #include "confdefs.h"
! $ac_includes_default
! int
! main ()
! {
! if ((u_bits32_t *) 0)
!   return 0;
! if (sizeof (u_bits32_t))
!   return 0;
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext
! if { (eval echo "$as_me:10513: \"$ac_compile\"") >&5
!   (eval $ac_compile) 2>&5
!   ac_status=$?
!   echo "$as_me:10516: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest.$ac_objext'
!   { (eval echo "$as_me:10519: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:10522: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
    ac_cv_type_u_bits32_t=yes
  else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! ac_cv_type_u_bits32_t=no
! fi
! rm -f conftest.$ac_objext conftest.$ac_ext
! fi
! echo "$as_me:10532: result: $ac_cv_type_u_bits32_t" >&5
! echo "${ECHO_T}$ac_cv_type_u_bits32_t" >&6
! if test $ac_cv_type_u_bits32_t = yes; then
!   :
! else
  
! cat >>confdefs.h <<EOF
  #define u_bits32_t unsigned int
  EOF
***************
*** 5226,5259 ****
  fi
  
! 
! if test "$ac_sv_sizeof_char_p" = 8; then
!   echo $ac_n "checking for bits64_t""... $ac_c" 1>&6
! echo "configure:5232: checking for bits64_t" >&5
! if eval "test \"`echo '$''{'ac_cv_type_bits64_t'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
!   cat > conftest.$ac_ext <<EOF
! #line 5237 "configure"
  #include "confdefs.h"
! #include <sys/types.h>
! #if STDC_HEADERS
! #include <stdlib.h>
! #include <stddef.h>
! #endif
! EOF
! if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
!   egrep "(^|[^a-zA-Z_0-9])bits64_t[^a-zA-Z_0-9]" >/dev/null 2>&1; then
!   rm -rf conftest*
    ac_cv_type_bits64_t=yes
  else
!   rm -rf conftest*
!   ac_cv_type_bits64_t=no
! fi
! rm -f conftest*
  
! fi
! echo "$ac_t""$ac_cv_type_bits64_t" 1>&6
! if test $ac_cv_type_bits64_t = no; then
!   cat >> confdefs.h <<\EOF
  #define bits64_t char *
  EOF
--- 10544,10595 ----
  fi
  
! if test "$ac_cv_sizeof_char_p" = 8; then
!   echo "$as_me:10547: checking for bits64_t" >&5
! echo $ECHO_N "checking for bits64_t... $ECHO_C" >&6
! if test "${ac_cv_type_bits64_t+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 10553 "configure"
  #include "confdefs.h"
! $ac_includes_default
! int
! main ()
! {
! if ((bits64_t *) 0)
!   return 0;
! if (sizeof (bits64_t))
!   return 0;
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext
! if { (eval echo "$as_me:10568: \"$ac_compile\"") >&5
!   (eval $ac_compile) 2>&5
!   ac_status=$?
!   echo "$as_me:10571: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest.$ac_objext'
!   { (eval echo "$as_me:10574: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:10577: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
    ac_cv_type_bits64_t=yes
  else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! ac_cv_type_bits64_t=no
! fi
! rm -f conftest.$ac_objext conftest.$ac_ext
! fi
! echo "$as_me:10587: result: $ac_cv_type_bits64_t" >&5
! echo "${ECHO_T}$ac_cv_type_bits64_t" >&6
! if test $ac_cv_type_bits64_t = yes; then
!   :
! else
  
! cat >>confdefs.h <<EOF
  #define bits64_t char *
  EOF
***************
*** 5262,5293 ****
  
  elif test "$ac_cv_sizeof_double" = 8; then
!   echo $ac_n "checking for bits64_t""... $ac_c" 1>&6
! echo "configure:5266: checking for bits64_t" >&5
! if eval "test \"`echo '$''{'ac_cv_type_bits64_t'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
!   cat > conftest.$ac_ext <<EOF
! #line 5271 "configure"
  #include "confdefs.h"
! #include <sys/types.h>
! #if STDC_HEADERS
! #include <stdlib.h>
! #include <stddef.h>
! #endif
! EOF
! if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
!   egrep "(^|[^a-zA-Z_0-9])bits64_t[^a-zA-Z_0-9]" >/dev/null 2>&1; then
!   rm -rf conftest*
    ac_cv_type_bits64_t=yes
  else
!   rm -rf conftest*
!   ac_cv_type_bits64_t=no
! fi
! rm -f conftest*
  
! fi
! echo "$ac_t""$ac_cv_type_bits64_t" 1>&6
! if test $ac_cv_type_bits64_t = no; then
!   cat >> confdefs.h <<\EOF
  #define bits64_t double
  EOF
--- 10598,10648 ----
  
  elif test "$ac_cv_sizeof_double" = 8; then
!   echo "$as_me:10600: checking for bits64_t" >&5
! echo $ECHO_N "checking for bits64_t... $ECHO_C" >&6
! if test "${ac_cv_type_bits64_t+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 10606 "configure"
  #include "confdefs.h"
! $ac_includes_default
! int
! main ()
! {
! if ((bits64_t *) 0)
!   return 0;
! if (sizeof (bits64_t))
!   return 0;
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext
! if { (eval echo "$as_me:10621: \"$ac_compile\"") >&5
!   (eval $ac_compile) 2>&5
!   ac_status=$?
!   echo "$as_me:10624: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest.$ac_objext'
!   { (eval echo "$as_me:10627: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:10630: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
    ac_cv_type_bits64_t=yes
  else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! ac_cv_type_bits64_t=no
! fi
! rm -f conftest.$ac_objext conftest.$ac_ext
! fi
! echo "$as_me:10640: result: $ac_cv_type_bits64_t" >&5
! echo "${ECHO_T}$ac_cv_type_bits64_t" >&6
! if test $ac_cv_type_bits64_t = yes; then
!   :
! else
  
! cat >>confdefs.h <<EOF
  #define bits64_t double
  EOF
***************
*** 5295,5327 ****
  fi
  
! elif test "$ac_cv_sizeof_long" = 8; then
!   echo $ac_n "checking for bits64_t""... $ac_c" 1>&6
! echo "configure:5300: checking for bits64_t" >&5
! if eval "test \"`echo '$''{'ac_cv_type_bits64_t'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
!   cat > conftest.$ac_ext <<EOF
! #line 5305 "configure"
  #include "confdefs.h"
! #include <sys/types.h>
! #if STDC_HEADERS
! #include <stdlib.h>
! #include <stddef.h>
! #endif
! EOF
! if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
!   egrep "(^|[^a-zA-Z_0-9])bits64_t[^a-zA-Z_0-9]" >/dev/null 2>&1; then
!   rm -rf conftest*
    ac_cv_type_bits64_t=yes
  else
!   rm -rf conftest*
!   ac_cv_type_bits64_t=no
! fi
! rm -f conftest*
  
  fi
! echo "$ac_t""$ac_cv_type_bits64_t" 1>&6
! if test $ac_cv_type_bits64_t = no; then
!   cat >> confdefs.h <<\EOF
  #define bits64_t long
  EOF
--- 10650,10754 ----
  fi
  
! elif test -n "$ac_cv_type_long_long" && test "$ac_cv_sizeof_long_long" = 8; then
!   echo "$as_me:10653: checking for bits64_t" >&5
! echo $ECHO_N "checking for bits64_t... $ECHO_C" >&6
! if test "${ac_cv_type_bits64_t+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 10659 "configure"
  #include "confdefs.h"
! $ac_includes_default
! int
! main ()
! {
! if ((bits64_t *) 0)
!   return 0;
! if (sizeof (bits64_t))
!   return 0;
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext
! if { (eval echo "$as_me:10674: \"$ac_compile\"") >&5
!   (eval $ac_compile) 2>&5
!   ac_status=$?
!   echo "$as_me:10677: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest.$ac_objext'
!   { (eval echo "$as_me:10680: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:10683: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
    ac_cv_type_bits64_t=yes
  else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! ac_cv_type_bits64_t=no
! fi
! rm -f conftest.$ac_objext conftest.$ac_ext
! fi
! echo "$as_me:10693: result: $ac_cv_type_bits64_t" >&5
! echo "${ECHO_T}$ac_cv_type_bits64_t" >&6
! if test $ac_cv_type_bits64_t = yes; then
!   :
! else
! 
! cat >>confdefs.h <<EOF
! #define bits64_t long long
! EOF
  
  fi
! 
! elif test "$ac_cv_sizeof_long" = 8; then
!   echo "$as_me:10706: checking for bits64_t" >&5
! echo $ECHO_N "checking for bits64_t... $ECHO_C" >&6
! if test "${ac_cv_type_bits64_t+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
! else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 10712 "configure"
! #include "confdefs.h"
! $ac_includes_default
! int
! main ()
! {
! if ((bits64_t *) 0)
!   return 0;
! if (sizeof (bits64_t))
!   return 0;
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext
! if { (eval echo "$as_me:10727: \"$ac_compile\"") >&5
!   (eval $ac_compile) 2>&5
!   ac_status=$?
!   echo "$as_me:10730: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest.$ac_objext'
!   { (eval echo "$as_me:10733: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:10736: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   ac_cv_type_bits64_t=yes
! else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! ac_cv_type_bits64_t=no
! fi
! rm -f conftest.$ac_objext conftest.$ac_ext
! fi
! echo "$as_me:10746: result: $ac_cv_type_bits64_t" >&5
! echo "${ECHO_T}$ac_cv_type_bits64_t" >&6
! if test $ac_cv_type_bits64_t = yes; then
!   :
! else
! 
! cat >>confdefs.h <<EOF
  #define bits64_t long
  EOF
***************
*** 5330,5361 ****
  
  else
!   echo $ac_n "checking for bits64_t""... $ac_c" 1>&6
! echo "configure:5334: checking for bits64_t" >&5
! if eval "test \"`echo '$''{'ac_cv_type_bits64_t'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
!   cat > conftest.$ac_ext <<EOF
! #line 5339 "configure"
  #include "confdefs.h"
! #include <sys/types.h>
! #if STDC_HEADERS
! #include <stdlib.h>
! #include <stddef.h>
! #endif
! EOF
! if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
!   egrep "(^|[^a-zA-Z_0-9])bits64_t[^a-zA-Z_0-9]" >/dev/null 2>&1; then
!   rm -rf conftest*
    ac_cv_type_bits64_t=yes
  else
!   rm -rf conftest*
!   ac_cv_type_bits64_t=no
! fi
! rm -f conftest*
  
! fi
! echo "$ac_t""$ac_cv_type_bits64_t" 1>&6
! if test $ac_cv_type_bits64_t = no; then
!   cat >> confdefs.h <<\EOF
  #define bits64_t double
  EOF
--- 10757,10807 ----
  
  else
!   echo "$as_me:10759: checking for bits64_t" >&5
! echo $ECHO_N "checking for bits64_t... $ECHO_C" >&6
! if test "${ac_cv_type_bits64_t+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 10765 "configure"
  #include "confdefs.h"
! $ac_includes_default
! int
! main ()
! {
! if ((bits64_t *) 0)
!   return 0;
! if (sizeof (bits64_t))
!   return 0;
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext
! if { (eval echo "$as_me:10780: \"$ac_compile\"") >&5
!   (eval $ac_compile) 2>&5
!   ac_status=$?
!   echo "$as_me:10783: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest.$ac_objext'
!   { (eval echo "$as_me:10786: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:10789: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
    ac_cv_type_bits64_t=yes
  else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! ac_cv_type_bits64_t=no
! fi
! rm -f conftest.$ac_objext conftest.$ac_ext
! fi
! echo "$as_me:10799: result: $ac_cv_type_bits64_t" >&5
! echo "${ECHO_T}$ac_cv_type_bits64_t" >&6
! if test $ac_cv_type_bits64_t = yes; then
!   :
! else
  
! cat >>confdefs.h <<EOF
  #define bits64_t double
  EOF
***************
*** 5365,5399 ****
  fi
  
- 
- 
  if test "$ac_cv_sizeof_int" = "$ac_cv_sizeof_char_p"; then
!   echo $ac_n "checking for ptrdiff_t""... $ac_c" 1>&6
! echo "configure:5372: checking for ptrdiff_t" >&5
! if eval "test \"`echo '$''{'ac_cv_type_ptrdiff_t'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
!   cat > conftest.$ac_ext <<EOF
! #line 5377 "configure"
  #include "confdefs.h"
! #include <sys/types.h>
! #if STDC_HEADERS
! #include <stdlib.h>
! #include <stddef.h>
! #endif
! EOF
! if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
!   egrep "(^|[^a-zA-Z_0-9])ptrdiff_t[^a-zA-Z_0-9]" >/dev/null 2>&1; then
!   rm -rf conftest*
    ac_cv_type_ptrdiff_t=yes
  else
!   rm -rf conftest*
!   ac_cv_type_ptrdiff_t=no
! fi
! rm -f conftest*
  
! fi
! echo "$ac_t""$ac_cv_type_ptrdiff_t" 1>&6
! if test $ac_cv_type_ptrdiff_t = no; then
!   cat >> confdefs.h <<\EOF
  #define ptrdiff_t int
  EOF
--- 10811,10862 ----
  fi
  
  if test "$ac_cv_sizeof_int" = "$ac_cv_sizeof_char_p"; then
!   echo "$as_me:10814: checking for ptrdiff_t" >&5
! echo $ECHO_N "checking for ptrdiff_t... $ECHO_C" >&6
! if test "${ac_cv_type_ptrdiff_t+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 10820 "configure"
  #include "confdefs.h"
! $ac_includes_default
! int
! main ()
! {
! if ((ptrdiff_t *) 0)
!   return 0;
! if (sizeof (ptrdiff_t))
!   return 0;
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext
! if { (eval echo "$as_me:10835: \"$ac_compile\"") >&5
!   (eval $ac_compile) 2>&5
!   ac_status=$?
!   echo "$as_me:10838: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest.$ac_objext'
!   { (eval echo "$as_me:10841: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:10844: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
    ac_cv_type_ptrdiff_t=yes
  else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! ac_cv_type_ptrdiff_t=no
! fi
! rm -f conftest.$ac_objext conftest.$ac_ext
! fi
! echo "$as_me:10854: result: $ac_cv_type_ptrdiff_t" >&5
! echo "${ECHO_T}$ac_cv_type_ptrdiff_t" >&6
! if test $ac_cv_type_ptrdiff_t = yes; then
!   :
! else
  
! cat >>confdefs.h <<EOF
  #define ptrdiff_t int
  EOF
***************
*** 5402,5433 ****
  
  elif test "$ac_cv_sizeof_long" = "$ac_cv_sizeof_char_p"; then
!   echo $ac_n "checking for ptrdiff_t""... $ac_c" 1>&6
! echo "configure:5406: checking for ptrdiff_t" >&5
! if eval "test \"`echo '$''{'ac_cv_type_ptrdiff_t'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
!   cat > conftest.$ac_ext <<EOF
! #line 5411 "configure"
  #include "confdefs.h"
! #include <sys/types.h>
! #if STDC_HEADERS
! #include <stdlib.h>
! #include <stddef.h>
! #endif
! EOF
! if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
!   egrep "(^|[^a-zA-Z_0-9])ptrdiff_t[^a-zA-Z_0-9]" >/dev/null 2>&1; then
!   rm -rf conftest*
    ac_cv_type_ptrdiff_t=yes
  else
!   rm -rf conftest*
!   ac_cv_type_ptrdiff_t=no
! fi
! rm -f conftest*
  
! fi
! echo "$ac_t""$ac_cv_type_ptrdiff_t" 1>&6
! if test $ac_cv_type_ptrdiff_t = no; then
!   cat >> confdefs.h <<\EOF
  #define ptrdiff_t long
  EOF
--- 10865,10915 ----
  
  elif test "$ac_cv_sizeof_long" = "$ac_cv_sizeof_char_p"; then
!   echo "$as_me:10867: checking for ptrdiff_t" >&5
! echo $ECHO_N "checking for ptrdiff_t... $ECHO_C" >&6
! if test "${ac_cv_type_ptrdiff_t+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 10873 "configure"
  #include "confdefs.h"
! $ac_includes_default
! int
! main ()
! {
! if ((ptrdiff_t *) 0)
!   return 0;
! if (sizeof (ptrdiff_t))
!   return 0;
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext
! if { (eval echo "$as_me:10888: \"$ac_compile\"") >&5
!   (eval $ac_compile) 2>&5
!   ac_status=$?
!   echo "$as_me:10891: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest.$ac_objext'
!   { (eval echo "$as_me:10894: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:10897: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
    ac_cv_type_ptrdiff_t=yes
  else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! ac_cv_type_ptrdiff_t=no
! fi
! rm -f conftest.$ac_objext conftest.$ac_ext
! fi
! echo "$as_me:10907: result: $ac_cv_type_ptrdiff_t" >&5
! echo "${ECHO_T}$ac_cv_type_ptrdiff_t" >&6
! if test $ac_cv_type_ptrdiff_t = yes; then
!   :
! else
  
! cat >>confdefs.h <<EOF
  #define ptrdiff_t long
  EOF
***************
*** 5435,5467 ****
  fi
  
  else
!   echo $ac_n "checking for ptrdiff_t""... $ac_c" 1>&6
! echo "configure:5440: checking for ptrdiff_t" >&5
! if eval "test \"`echo '$''{'ac_cv_type_ptrdiff_t'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
! else
!   cat > conftest.$ac_ext <<EOF
! #line 5445 "configure"
  #include "confdefs.h"
! #include <sys/types.h>
! #if STDC_HEADERS
! #include <stdlib.h>
! #include <stddef.h>
! #endif
! EOF
! if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
!   egrep "(^|[^a-zA-Z_0-9])ptrdiff_t[^a-zA-Z_0-9]" >/dev/null 2>&1; then
!   rm -rf conftest*
    ac_cv_type_ptrdiff_t=yes
  else
!   rm -rf conftest*
!   ac_cv_type_ptrdiff_t=no
! fi
! rm -f conftest*
  
  fi
! echo "$ac_t""$ac_cv_type_ptrdiff_t" 1>&6
! if test $ac_cv_type_ptrdiff_t = no; then
!   cat >> confdefs.h <<\EOF
  #define ptrdiff_t int
  EOF
--- 10917,11021 ----
  fi
  
+ elif test "$ac_cv_type_long_long" = yes && test "$ac_cv_sizeof_long_long" = "$ac_cv_sizeof_char_p"; then
+   echo "$as_me:10920: checking for ptrdiff_t" >&5
+ echo $ECHO_N "checking for ptrdiff_t... $ECHO_C" >&6
+ if test "${ac_cv_type_ptrdiff_t+set}" = set; then
+   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 10926 "configure"
  #include "confdefs.h"
! $ac_includes_default
! int
! main ()
! {
! if ((ptrdiff_t *) 0)
!   return 0;
! if (sizeof (ptrdiff_t))
!   return 0;
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext
! if { (eval echo "$as_me:10941: \"$ac_compile\"") >&5
!   (eval $ac_compile) 2>&5
!   ac_status=$?
!   echo "$as_me:10944: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest.$ac_objext'
!   { (eval echo "$as_me:10947: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:10950: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
    ac_cv_type_ptrdiff_t=yes
  else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! ac_cv_type_ptrdiff_t=no
! fi
! rm -f conftest.$ac_objext conftest.$ac_ext
! fi
! echo "$as_me:10960: result: $ac_cv_type_ptrdiff_t" >&5
! echo "${ECHO_T}$ac_cv_type_ptrdiff_t" >&6
! if test $ac_cv_type_ptrdiff_t = yes; then
!   :
! else
! 
! cat >>confdefs.h <<EOF
! #define ptrdiff_t long long
! EOF
  
  fi
! 
! else
!   echo "$as_me:10973: checking for ptrdiff_t" >&5
! echo $ECHO_N "checking for ptrdiff_t... $ECHO_C" >&6
! if test "${ac_cv_type_ptrdiff_t+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
! else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 10979 "configure"
! #include "confdefs.h"
! $ac_includes_default
! int
! main ()
! {
! if ((ptrdiff_t *) 0)
!   return 0;
! if (sizeof (ptrdiff_t))
!   return 0;
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext
! if { (eval echo "$as_me:10994: \"$ac_compile\"") >&5
!   (eval $ac_compile) 2>&5
!   ac_status=$?
!   echo "$as_me:10997: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest.$ac_objext'
!   { (eval echo "$as_me:11000: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:11003: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   ac_cv_type_ptrdiff_t=yes
! else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! ac_cv_type_ptrdiff_t=no
! fi
! rm -f conftest.$ac_objext conftest.$ac_ext
! fi
! echo "$as_me:11013: result: $ac_cv_type_ptrdiff_t" >&5
! echo "${ECHO_T}$ac_cv_type_ptrdiff_t" >&6
! if test $ac_cv_type_ptrdiff_t = yes; then
!   :
! else
! 
! cat >>confdefs.h <<EOF
  #define ptrdiff_t int
  EOF
***************
*** 5471,5482 ****
  fi
  
! 
! echo $ac_n "checking whether stat file-mode macros are broken""... $ac_c" 1>&6
! echo "configure:5476: checking whether stat file-mode macros are broken" >&5
! if eval "test \"`echo '$''{'ac_cv_header_stat_broken'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
!   cat > conftest.$ac_ext <<EOF
! #line 5481 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
--- 11025,11035 ----
  fi
  
! echo "$as_me:11027: checking whether stat file-mode macros are broken" >&5
! echo $ECHO_N "checking whether stat file-mode macros are broken... $ECHO_C" >&6
! if test "${ac_cv_header_stat_broken+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 11033 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
***************
*** 5503,5633 ****
  #if defined(S_ISSOCK) && defined(S_IFREG)
  # if S_ISSOCK (S_IFREG)
! You lose.
! # endif
! #endif
! 
! EOF
! if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
!   egrep "You lose" >/dev/null 2>&1; then
!   rm -rf conftest*
!   ac_cv_header_stat_broken=yes
! else
!   rm -rf conftest*
!   ac_cv_header_stat_broken=no
! fi
! rm -f conftest*
! 
! fi
! 
! echo "$ac_t""$ac_cv_header_stat_broken" 1>&6
! if test $ac_cv_header_stat_broken = yes; then
!   cat >> confdefs.h <<\EOF
! #define STAT_MACROS_BROKEN 1
! EOF
! 
! fi
! 
! 
! echo $ac_n "checking whether byte ordering is bigendian""... $ac_c" 1>&6
! echo "configure:5533: checking whether byte ordering is bigendian" >&5
! if eval "test \"`echo '$''{'ac_cv_c_bigendian'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
! else
!   ac_cv_c_bigendian=unknown
! # See if sys/param.h defines the BYTE_ORDER macro.
! cat > conftest.$ac_ext <<EOF
! #line 5540 "configure"
! #include "confdefs.h"
! #include <sys/types.h>
! #include <sys/param.h>
! int main() {
! 
! #if !BYTE_ORDER || !BIG_ENDIAN || !LITTLE_ENDIAN
!  bogus endian macros
! #endif
! ; return 0; }
! EOF
! if { (eval echo configure:5551: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
!   rm -rf conftest*
!   # It does; now see whether it defined to BIG_ENDIAN or not.
! cat > conftest.$ac_ext <<EOF
! #line 5555 "configure"
! #include "confdefs.h"
! #include <sys/types.h>
! #include <sys/param.h>
! int main() {
! 
! #if BYTE_ORDER != BIG_ENDIAN
!  not big endian
  #endif
! ; return 0; }
! EOF
! if { (eval echo configure:5566: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
!   rm -rf conftest*
!   ac_cv_c_bigendian=yes
! else
!   echo "configure: failed program was:" >&5
!   cat conftest.$ac_ext >&5
!   rm -rf conftest*
!   ac_cv_c_bigendian=no
! fi
! rm -f conftest*
  else
!   echo "configure: failed program was:" >&5
!   cat conftest.$ac_ext >&5
  fi
  rm -f conftest*
- if test $ac_cv_c_bigendian = unknown; then
- if test "$cross_compiling" = yes; then
-     { echo "configure: error: can not run test program while cross compiling" 1>&2; exit 1; }
- else
-   cat > conftest.$ac_ext <<EOF
- #line 5586 "configure"
- #include "confdefs.h"
- main () {
-   /* Are we little or big endian?  From Harbison&Steele.  */
-   union
-   {
-     long l;
-     char c[sizeof (long)];
-   } u;
-   u.l = 1;
-   exit (u.c[sizeof (long) - 1] == 1);
- }
- EOF
- if { (eval echo configure:5599: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
- then
-   ac_cv_c_bigendian=no
- else
-   echo "configure: failed program was:" >&5
-   cat conftest.$ac_ext >&5
-   rm -fr conftest*
-   ac_cv_c_bigendian=yes
- fi
- rm -fr conftest*
- fi
  
  fi
! fi
  
! echo "$ac_t""$ac_cv_c_bigendian" 1>&6
! if test $ac_cv_c_bigendian = yes; then
!   cat >> confdefs.h <<\EOF
! #define WORDS_BIGENDIAN 1
  EOF
  
  fi
  
! 
! # Pull the hash mark out of the macro call to avoid m4 problems.
! ac_msg="whether #! works in shell scripts"
! echo $ac_n "checking $ac_msg""... $ac_c" 1>&6
! echo "configure:5626: checking $ac_msg" >&5
! if eval "test \"`echo '$''{'ac_cv_sys_interpreter'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
    echo '#! /bin/cat
  exit 69
! ' > conftest
  chmod u+x conftest
  (SHELL=/bin/sh; export SHELL; ./conftest >/dev/null)
--- 11056,11091 ----
  #if defined(S_ISSOCK) && defined(S_IFREG)
  # if S_ISSOCK (S_IFREG)
! You lose.
! # endif
  #endif
! 
! _ACEOF
! if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
!   egrep "You lose" >/dev/null 2>&1; then
!   ac_cv_header_stat_broken=yes
  else
!   ac_cv_header_stat_broken=no
  fi
  rm -f conftest*
  
  fi
! echo "$as_me:11072: result: $ac_cv_header_stat_broken" >&5
! echo "${ECHO_T}$ac_cv_header_stat_broken" >&6
! if test $ac_cv_header_stat_broken = yes; then
  
! cat >>confdefs.h <<\EOF
! #define STAT_MACROS_BROKEN 1
  EOF
  
  fi
  
! echo "$as_me:11082: checking whether #! works in shell scripts" >&5
! echo $ECHO_N "checking whether #! works in shell scripts... $ECHO_C" >&6
! if test "${ac_cv_sys_interpreter+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
    echo '#! /bin/cat
  exit 69
! ' >conftest
  chmod u+x conftest
  (SHELL=/bin/sh; export SHELL; ./conftest >/dev/null)
***************
*** 5639,5710 ****
  rm -f conftest
  fi
! 
! echo "$ac_t""$ac_cv_sys_interpreter" 1>&6
! interpval="$ac_cv_sys_interpreter"
  
  if test $ac_cv_sys_interpreter = yes; then
! cat >> confdefs.h <<\EOF
  #define HAVE_HASH_BANG_EXEC 1
  EOF
  
  fi
- echo $ac_n "checking for restartable system calls""... $ac_c" 1>&6
- echo "configure:5653: checking for restartable system calls" >&5
- if eval "test \"`echo '$''{'ac_cv_sys_restartable_syscalls'+set}'`\" = set"; then
-   echo $ac_n "(cached) $ac_c" 1>&6
- else
-   if test "$cross_compiling" = yes; then
-     { echo "configure: error: can not run test program while cross compiling" 1>&2; exit 1; }
- else
-   cat > conftest.$ac_ext <<EOF
- #line 5661 "configure"
- #include "confdefs.h"
- /* Exit 0 (true) if wait returns something other than -1,
-    i.e. the pid of the child, which means that wait was restarted
-    after getting the signal.  */
- #include <sys/types.h>
- #include <signal.h>
- ucatch (isig) { }
- main () {
-   int i = fork (), status;
-   if (i == 0) { sleep (3); kill (getppid (), SIGINT); sleep (3); exit (0); }
-   signal (SIGINT, ucatch);
-   status = wait(&i);
-   if (status == -1) wait(&i);
-   exit (status == -1);
- }
- 
- EOF
- if { (eval echo configure:5679: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
- then
-   ac_cv_sys_restartable_syscalls=yes
- else
-   echo "configure: failed program was:" >&5
-   cat conftest.$ac_ext >&5
-   rm -fr conftest*
-   ac_cv_sys_restartable_syscalls=no
- fi
- rm -fr conftest*
- fi
- 
- fi
- 
- echo "$ac_t""$ac_cv_sys_restartable_syscalls" 1>&6
- if test $ac_cv_sys_restartable_syscalls = yes; then
-   cat >> confdefs.h <<\EOF
- #define HAVE_RESTARTABLE_SYSCALLS 1
- EOF
- 
- fi
- 
  
  if test "$ac_cv_func_lstat" = "no"; then
! echo $ac_n "checking for lstat""... $ac_c" 1>&6
! echo "configure:5704: checking for lstat" >&5
! if eval "test \"`echo '$''{'bash_cv_func_lstat'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
!   cat > conftest.$ac_ext <<EOF
! #line 5709 "configure"
  #include "confdefs.h"
  
--- 11097,11119 ----
  rm -f conftest
  fi
! echo "$as_me:11099: result: $ac_cv_sys_interpreter" >&5
! echo "${ECHO_T}$ac_cv_sys_interpreter" >&6
! interpval=$ac_cv_sys_interpreter
  
  if test $ac_cv_sys_interpreter = yes; then
! cat >>confdefs.h <<\EOF
  #define HAVE_HASH_BANG_EXEC 1
  EOF
  
  fi
  
  if test "$ac_cv_func_lstat" = "no"; then
! echo "$as_me:11111: checking for lstat" >&5
! echo $ECHO_N "checking for lstat... $ECHO_C" >&6
! if test "${bash_cv_func_lstat+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 11117 "configure"
  #include "confdefs.h"
  
***************
*** 5712,5734 ****
  #include <sys/stat.h>
  
! int main() {
!  lstat(".",(struct stat *)0); 
! ; return 0; }
! EOF
! if { (eval echo configure:5719: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
!   rm -rf conftest*
    bash_cv_func_lstat=yes
  else
!   echo "configure: failed program was:" >&5
!   cat conftest.$ac_ext >&5
!   rm -rf conftest*
!   bash_cv_func_lstat=no
  fi
! rm -f conftest*
  fi
! 
! echo "$ac_t""$bash_cv_func_lstat" 1>&6
  if test $bash_cv_func_lstat = yes; then
!   cat >> confdefs.h <<\EOF
  #define HAVE_LSTAT 1
  EOF
--- 11121,11156 ----
  #include <sys/stat.h>
  
! int
! main ()
! {
!  lstat(".",(struct stat *)0);
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext conftest$ac_exeext
! if { (eval echo "$as_me:11132: \"$ac_link\"") >&5
!   (eval $ac_link) 2>&5
!   ac_status=$?
!   echo "$as_me:11135: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest$ac_exeext'
!   { (eval echo "$as_me:11138: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:11141: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
    bash_cv_func_lstat=yes
  else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! bash_cv_func_lstat=no
  fi
! rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
  fi
! echo "$as_me:11151: result: $bash_cv_func_lstat" >&5
! echo "${ECHO_T}$bash_cv_func_lstat" >&6
  if test $bash_cv_func_lstat = yes; then
!   cat >>confdefs.h <<\EOF
  #define HAVE_LSTAT 1
  EOF
***************
*** 5738,5752 ****
  fi
  
! echo $ac_n "checking if dup2 fails to clear the close-on-exec flag""... $ac_c" 1>&6
! echo "configure:5742: checking if dup2 fails to clear the close-on-exec flag" >&5
! if eval "test \"`echo '$''{'bash_cv_dup2_broken'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
    if test "$cross_compiling" = yes; then
!   echo "configure: warning: cannot check dup2 if cross compiling -- defaulting to no" 1>&2
       bash_cv_dup2_broken=no
  else
!   cat > conftest.$ac_ext <<EOF
! #line 5751 "configure"
  #include "confdefs.h"
  
--- 11160,11175 ----
  fi
  
! echo "$as_me:11162: checking if dup2 fails to clear the close-on-exec flag" >&5
! echo $ECHO_N "checking if dup2 fails to clear the close-on-exec flag... $ECHO_C" >&6
! if test "${bash_cv_dup2_broken+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
    if test "$cross_compiling" = yes; then
!   { echo "$as_me:11168: WARNING: cannot check dup2 if cross compiling -- defaulting to no" >&5
! echo "$as_me: WARNING: cannot check dup2 if cross compiling -- defaulting to no" >&2;}
       bash_cv_dup2_broken=no
  else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 11173 "configure"
  #include "confdefs.h"
  
***************
*** 5767,5789 ****
  }
  
! EOF
! if { (eval echo configure:5771: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
! then
    bash_cv_dup2_broken=yes
  else
!   echo "configure: failed program was:" >&5
!   cat conftest.$ac_ext >&5
!   rm -fr conftest*
!   bash_cv_dup2_broken=no
  fi
! rm -fr conftest*
  fi
  
- 
  fi
  
! echo "$ac_t""$bash_cv_dup2_broken" 1>&6
  if test $bash_cv_dup2_broken = yes; then
! cat >> confdefs.h <<\EOF
  #define DUP2_BROKEN 1
  EOF
--- 11190,11221 ----
  }
  
! _ACEOF
! rm -f conftest$ac_exeext
! if { (eval echo "$as_me:11194: \"$ac_link\"") >&5
!   (eval $ac_link) 2>&5
!   ac_status=$?
!   echo "$as_me:11197: \$? = $ac_status" >&5
!   (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
!   { (eval echo "$as_me:11199: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:11202: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
    bash_cv_dup2_broken=yes
  else
!   echo "$as_me: program exited with status $ac_status" >&5
! echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! bash_cv_dup2_broken=no
  fi
! rm -f core core.* *.core conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
  fi
  
  fi
  
! echo "$as_me:11216: result: $bash_cv_dup2_broken" >&5
! echo "${ECHO_T}$bash_cv_dup2_broken" >&6
  if test $bash_cv_dup2_broken = yes; then
! cat >>confdefs.h <<\EOF
  #define DUP2_BROKEN 1
  EOF
***************
*** 5791,5806 ****
  fi
  
! 
! echo $ac_n "checking whether pgrps need synchronization""... $ac_c" 1>&6
! echo "configure:5796: checking whether pgrps need synchronization" >&5
! if eval "test \"`echo '$''{'bash_cv_pgrp_pipe'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
    if test "$cross_compiling" = yes; then
!   echo "configure: warning: cannot check pgrp synchronization if cross compiling -- defaulting to no" 1>&2
      bash_cv_pgrp_pipe=no
  else
!   cat > conftest.$ac_ext <<EOF
! #line 5805 "configure"
  #include "confdefs.h"
  
--- 11223,11238 ----
  fi
  
! echo "$as_me:11225: checking whether pgrps need synchronization" >&5
! echo $ECHO_N "checking whether pgrps need synchronization... $ECHO_C" >&6
! if test "${bash_cv_pgrp_pipe+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
    if test "$cross_compiling" = yes; then
!   { echo "$as_me:11231: WARNING: cannot check pgrp synchronization if cross compiling -- defaulting to no" >&5
! echo "$as_me: WARNING: cannot check pgrp synchronization if cross compiling -- defaulting to no" >&2;}
      bash_cv_pgrp_pipe=no
  else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 11236 "configure"
  #include "confdefs.h"
  
***************
*** 5853,5875 ****
  }
  
! EOF
! if { (eval echo configure:5857: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
! then
    bash_cv_pgrp_pipe=no
  else
!   echo "configure: failed program was:" >&5
!   cat conftest.$ac_ext >&5
!   rm -fr conftest*
!   bash_cv_pgrp_pipe=yes
  fi
! rm -fr conftest*
  fi
  
- 
  fi
  
! echo "$ac_t""$bash_cv_pgrp_pipe" 1>&6
  if test $bash_cv_pgrp_pipe = yes; then
! cat >> confdefs.h <<\EOF
  #define PGRP_PIPE 1
  EOF
--- 11285,11316 ----
  }
  
! _ACEOF
! rm -f conftest$ac_exeext
! if { (eval echo "$as_me:11289: \"$ac_link\"") >&5
!   (eval $ac_link) 2>&5
!   ac_status=$?
!   echo "$as_me:11292: \$? = $ac_status" >&5
!   (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
!   { (eval echo "$as_me:11294: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:11297: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
    bash_cv_pgrp_pipe=no
  else
!   echo "$as_me: program exited with status $ac_status" >&5
! echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! bash_cv_pgrp_pipe=yes
  fi
! rm -f core core.* *.core conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
  fi
  
  fi
  
! echo "$as_me:11311: result: $bash_cv_pgrp_pipe" >&5
! echo "${ECHO_T}$bash_cv_pgrp_pipe" >&6
  if test $bash_cv_pgrp_pipe = yes; then
! cat >>confdefs.h <<\EOF
  #define PGRP_PIPE 1
  EOF
***************
*** 5877,5892 ****
  fi
  
  
! echo $ac_n "checking for type of signal functions""... $ac_c" 1>&6
! echo "configure:5882: checking for type of signal functions" >&5
! if eval "test \"`echo '$''{'bash_cv_signal_vintage'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
! else
!   
!   cat > conftest.$ac_ext <<EOF
! #line 5888 "configure"
  #include "confdefs.h"
  #include <signal.h>
! int main() {
  
      sigset_t ss;
--- 11318,11334 ----
  fi
  
+ echo "$as_me:11320: checking for type of signal functions" >&5
+ echo $ECHO_N "checking for type of signal functions... $ECHO_C" >&6
+ if test "${bash_cv_signal_vintage+set}" = set; then
+   echo $ECHO_N "(cached) $ECHO_C" >&6
+ else
  
!   cat >conftest.$ac_ext <<_ACEOF
! #line 11327 "configure"
  #include "confdefs.h"
  #include <signal.h>
! int
! main ()
! {
  
      sigset_t ss;
***************
*** 5895,5975 ****
      sigaction(SIGINT, &sa, (struct sigaction *) 0);
      sigprocmask(SIG_BLOCK, &ss, (sigset_t *) 0);
!   
! ; return 0; }
! EOF
! if { (eval echo configure:5901: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
!   rm -rf conftest*
    bash_cv_signal_vintage=posix
  else
!   echo "configure: failed program was:" >&5
!   cat conftest.$ac_ext >&5
!   rm -rf conftest*
!   
!     cat > conftest.$ac_ext <<EOF
! #line 5910 "configure"
  #include "confdefs.h"
  #include <signal.h>
! int main() {
  
  	int mask = sigmask(SIGINT);
  	sigsetmask(mask); sigblock(mask); sigpause(mask);
!     
! ; return 0; }
! EOF
! if { (eval echo configure:5920: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
!   rm -rf conftest*
    bash_cv_signal_vintage=4.2bsd
  else
!   echo "configure: failed program was:" >&5
!   cat conftest.$ac_ext >&5
!   rm -rf conftest*
!   
!       cat > conftest.$ac_ext <<EOF
! #line 5929 "configure"
  #include "confdefs.h"
  
  	#include <signal.h>
  	RETSIGTYPE foo() { }
! int main() {
  
  		int mask = sigmask(SIGINT);
  		sigset(SIGINT, foo); sigrelse(SIGINT);
  		sighold(SIGINT); sigpause(SIGINT);
!         
! ; return 0; }
! EOF
! if { (eval echo configure:5942: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
!   rm -rf conftest*
    bash_cv_signal_vintage=svr3
  else
!   echo "configure: failed program was:" >&5
!   cat conftest.$ac_ext >&5
!   rm -rf conftest*
!   bash_cv_signal_vintage=v7
!     
  fi
! rm -f conftest*
!   
  fi
! rm -f conftest*
  
  fi
! rm -f conftest*
  
  fi
  
! echo "$ac_t""$bash_cv_signal_vintage" 1>&6
  if test "$bash_cv_signal_vintage" = posix; then
! cat >> confdefs.h <<\EOF
  #define HAVE_POSIX_SIGNALS 1
  EOF
  
  elif test "$bash_cv_signal_vintage" = "4.2bsd"; then
! cat >> confdefs.h <<\EOF
  #define HAVE_BSD_SIGNALS 1
  EOF
  
  elif test "$bash_cv_signal_vintage" = svr3; then
! cat >> confdefs.h <<\EOF
  #define HAVE_USG_SIGHOLD 1
  EOF
--- 11337,11455 ----
      sigaction(SIGINT, &sa, (struct sigaction *) 0);
      sigprocmask(SIG_BLOCK, &ss, (sigset_t *) 0);
! 
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext conftest$ac_exeext
! if { (eval echo "$as_me:11345: \"$ac_link\"") >&5
!   (eval $ac_link) 2>&5
!   ac_status=$?
!   echo "$as_me:11348: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest$ac_exeext'
!   { (eval echo "$as_me:11351: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:11354: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
    bash_cv_signal_vintage=posix
  else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! 
!     cat >conftest.$ac_ext <<_ACEOF
! #line 11362 "configure"
  #include "confdefs.h"
  #include <signal.h>
! int
! main ()
! {
  
  	int mask = sigmask(SIGINT);
  	sigsetmask(mask); sigblock(mask); sigpause(mask);
! 
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext conftest$ac_exeext
! if { (eval echo "$as_me:11377: \"$ac_link\"") >&5
!   (eval $ac_link) 2>&5
!   ac_status=$?
!   echo "$as_me:11380: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest$ac_exeext'
!   { (eval echo "$as_me:11383: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:11386: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
    bash_cv_signal_vintage=4.2bsd
  else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! 
!       cat >conftest.$ac_ext <<_ACEOF
! #line 11394 "configure"
  #include "confdefs.h"
  
  	#include <signal.h>
  	RETSIGTYPE foo() { }
! int
! main ()
! {
  
  		int mask = sigmask(SIGINT);
  		sigset(SIGINT, foo); sigrelse(SIGINT);
  		sighold(SIGINT); sigpause(SIGINT);
! 
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext conftest$ac_exeext
! if { (eval echo "$as_me:11412: \"$ac_link\"") >&5
!   (eval $ac_link) 2>&5
!   ac_status=$?
!   echo "$as_me:11415: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest$ac_exeext'
!   { (eval echo "$as_me:11418: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:11421: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
    bash_cv_signal_vintage=svr3
  else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! bash_cv_signal_vintage=v7
! 
  fi
! rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
! 
  fi
! rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
  
  fi
! rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
  
  fi
  
! echo "$as_me:11440: result: $bash_cv_signal_vintage" >&5
! echo "${ECHO_T}$bash_cv_signal_vintage" >&6
  if test "$bash_cv_signal_vintage" = posix; then
! cat >>confdefs.h <<\EOF
  #define HAVE_POSIX_SIGNALS 1
  EOF
  
  elif test "$bash_cv_signal_vintage" = "4.2bsd"; then
! cat >>confdefs.h <<\EOF
  #define HAVE_BSD_SIGNALS 1
  EOF
  
  elif test "$bash_cv_signal_vintage" = svr3; then
! cat >>confdefs.h <<\EOF
  #define HAVE_USG_SIGHOLD 1
  EOF
***************
*** 5977,6083 ****
  fi
  
! 
! if test "$ac_cv_sys_restartable_syscalls" = "no"; then
! 
! echo $ac_n "checking whether posix sigaction restarts system calls by default""... $ac_c" 1>&6
! echo "configure:5984: checking whether posix sigaction restarts system calls by default" >&5
! if eval "test \"`echo '$''{'bash_cv_sys_restartable_syscalls'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
! else
!   if test "$cross_compiling" = yes; then
!   echo "configure: warning: cannot check restartable syscalls if cross compiling" 1>&2
  else
!   cat > conftest.$ac_ext <<EOF
! #line 5992 "configure"
  #include "confdefs.h"
! /* Exit 0 (true) if wait returns something other than -1,
!    i.e. the pid of the child, which means that wait was restarted
!    after getting the signal.  */
! #ifdef HAVE_UNISTD_H
! #  include <unistd.h>
! #endif
! #include <sys/types.h>
! #include <signal.h>
! static int caught = 0;
! void ucatch (isig) int isig; { caught = 1; }
  main ()
  {
- #if !defined (_POSIX_VERSION) || !defined (HAVE_POSIX_SIGNALS)
-   exit (1);
- #else
-   struct sigaction act, oact;
-   int i, status;
- 
-   act.sa_handler = ucatch;
-   /* Might want to add SA_RESTART here, but bash's set_signal_handler
-      does not. */
-   act.sa_flags = 0;
-   sigemptyset(&act.sa_mask);
-   sigemptyset(&oact.sa_mask);
-   i = fork ();
-   /* A possible race condition here, but in practice it never happens. */
-   if (i == 0) { sleep (3); kill (getppid (), SIGINT); sleep (3); exit (0); }
-   sigaction(SIGINT, &act, &oact);
-   status = wait(&i);
-   if (status == -1) wait(&i);
-   exit (status == -1);
- #endif
- }
- 
- EOF
- if { (eval echo configure:6029: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
- then
-   bash_cv_sys_restartable_syscalls=yes
- else
-   echo "configure: failed program was:" >&5
-   cat conftest.$ac_ext >&5
-   rm -fr conftest*
-   bash_cv_sys_restartable_syscalls=no
- fi
- rm -fr conftest*
- fi
- 
- 
- fi
- 
- echo "$ac_t""$bash_cv_sys_restartable_syscalls" 1>&6
- if test $bash_cv_sys_restartable_syscalls = yes; then
-   cat >> confdefs.h <<\EOF
- #define HAVE_RESTARTABLE_SYSCALLS 1
- EOF
- 
- fi
- 
- fi
- 
- echo $ac_n "checking for sys_errlist and sys_nerr""... $ac_c" 1>&6
- echo "configure:6055: checking for sys_errlist and sys_nerr" >&5
- if eval "test \"`echo '$''{'bash_cv_sys_errlist'+set}'`\" = set"; then
-   echo $ac_n "(cached) $ac_c" 1>&6
- else
-   cat > conftest.$ac_ext <<EOF
- #line 6060 "configure"
- #include "confdefs.h"
- #include <errno.h>
- int main() {
  extern char *sys_errlist[];
   extern int sys_nerr;
   char *msg = sys_errlist[sys_nerr - 1];
! ; return 0; }
! EOF
! if { (eval echo configure:6069: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
!   rm -rf conftest*
    bash_cv_sys_errlist=yes
  else
!   echo "configure: failed program was:" >&5
!   cat conftest.$ac_ext >&5
!   rm -rf conftest*
!   bash_cv_sys_errlist=no
  fi
! rm -f conftest*
  fi
! echo "$ac_t""$bash_cv_sys_errlist" 1>&6
  if test $bash_cv_sys_errlist = yes; then
! cat >> confdefs.h <<\EOF
  #define HAVE_SYS_ERRLIST 1
  EOF
--- 11457,11503 ----
  fi
  
! echo "$as_me:11459: checking for sys_errlist and sys_nerr" >&5
! echo $ECHO_N "checking for sys_errlist and sys_nerr... $ECHO_C" >&6
! if test "${bash_cv_sys_errlist+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 11465 "configure"
  #include "confdefs.h"
! #include <errno.h>
! int
  main ()
  {
  extern char *sys_errlist[];
   extern int sys_nerr;
   char *msg = sys_errlist[sys_nerr - 1];
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext conftest$ac_exeext
! if { (eval echo "$as_me:11479: \"$ac_link\"") >&5
!   (eval $ac_link) 2>&5
!   ac_status=$?
!   echo "$as_me:11482: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest$ac_exeext'
!   { (eval echo "$as_me:11485: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:11488: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
    bash_cv_sys_errlist=yes
  else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! bash_cv_sys_errlist=no
  fi
! rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
  fi
! echo "$as_me:11498: result: $bash_cv_sys_errlist" >&5
! echo "${ECHO_T}$bash_cv_sys_errlist" >&6
  if test $bash_cv_sys_errlist = yes; then
! cat >>confdefs.h <<\EOF
  #define HAVE_SYS_ERRLIST 1
  EOF
***************
*** 6085,6100 ****
  fi
  
! 
! echo $ac_n "checking for sys_siglist in system C library""... $ac_c" 1>&6
! echo "configure:6090: checking for sys_siglist in system C library" >&5
! if eval "test \"`echo '$''{'bash_cv_sys_siglist'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
    if test "$cross_compiling" = yes; then
!   echo "configure: warning: cannot check for sys_siglist if cross compiling -- defaulting to no" 1>&2
  	 bash_cv_sys_siglist=no
  else
!   cat > conftest.$ac_ext <<EOF
! #line 6099 "configure"
  #include "confdefs.h"
  
--- 11505,11520 ----
  fi
  
! echo "$as_me:11507: checking for sys_siglist in system C library" >&5
! echo $ECHO_N "checking for sys_siglist in system C library... $ECHO_C" >&6
! if test "${bash_cv_sys_siglist+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
    if test "$cross_compiling" = yes; then
!   { echo "$as_me:11513: WARNING: cannot check for sys_siglist if cross compiling -- defaulting to no" >&5
! echo "$as_me: WARNING: cannot check for sys_siglist if cross compiling -- defaulting to no" >&2;}
  	 bash_cv_sys_siglist=no
  else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 11518 "configure"
  #include "confdefs.h"
  
***************
*** 6112,6133 ****
  exit(msg == 0);
  }
! EOF
! if { (eval echo configure:6116: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
! then
    bash_cv_sys_siglist=yes
  else
!   echo "configure: failed program was:" >&5
!   cat conftest.$ac_ext >&5
!   rm -fr conftest*
!   bash_cv_sys_siglist=no
  fi
! rm -fr conftest*
  fi
- 
  fi
  
! echo "$ac_t""$bash_cv_sys_siglist" 1>&6
  if test $bash_cv_sys_siglist = yes; then
! cat >> confdefs.h <<\EOF
  #define HAVE_SYS_SIGLIST 1
  EOF
--- 11532,11562 ----
  exit(msg == 0);
  }
! _ACEOF
! rm -f conftest$ac_exeext
! if { (eval echo "$as_me:11536: \"$ac_link\"") >&5
!   (eval $ac_link) 2>&5
!   ac_status=$?
!   echo "$as_me:11539: \$? = $ac_status" >&5
!   (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
!   { (eval echo "$as_me:11541: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:11544: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
    bash_cv_sys_siglist=yes
  else
!   echo "$as_me: program exited with status $ac_status" >&5
! echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! bash_cv_sys_siglist=no
  fi
! rm -f core core.* *.core conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
  fi
  fi
  
! echo "$as_me:11557: result: $bash_cv_sys_siglist" >&5
! echo "${ECHO_T}$bash_cv_sys_siglist" >&6
  if test $bash_cv_sys_siglist = yes; then
! cat >>confdefs.h <<\EOF
  #define HAVE_SYS_SIGLIST 1
  EOF
***************
*** 6135,6145 ****
  fi
  
! echo $ac_n "checking for _sys_siglist in signal.h or unistd.h""... $ac_c" 1>&6
! echo "configure:6139: checking for _sys_siglist in signal.h or unistd.h" >&5
! if eval "test \"`echo '$''{'bash_cv_decl_under_sys_siglist'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
!   cat > conftest.$ac_ext <<EOF
! #line 6144 "configure"
  #include "confdefs.h"
  
--- 11564,11574 ----
  fi
  
! echo "$as_me:11566: checking for _sys_siglist in signal.h or unistd.h" >&5
! echo $ECHO_N "checking for _sys_siglist in signal.h or unistd.h... $ECHO_C" >&6
! if test "${bash_cv_decl_under_sys_siglist+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 11572 "configure"
  #include "confdefs.h"
  
***************
*** 6149,6170 ****
  #include <unistd.h>
  #endif
! int main() {
!  char *msg = _sys_siglist[2]; 
! ; return 0; }
! EOF
! if { (eval echo configure:6156: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
!   rm -rf conftest*
    bash_cv_decl_under_sys_siglist=yes
  else
!   echo "configure: failed program was:" >&5
!   cat conftest.$ac_ext >&5
!   rm -rf conftest*
!   bash_cv_decl_under_sys_siglist=no
  fi
! rm -f conftest*
  fi
! echo "$ac_t""$bash_cv_decl_under_sys_siglist" 1>&6
  if test $bash_cv_decl_under_sys_siglist = yes; then
! cat >> confdefs.h <<\EOF
  #define UNDER_SYS_SIGLIST_DECLARED 1
  EOF
--- 11578,11613 ----
  #include <unistd.h>
  #endif
! int
! main ()
! {
!  char *msg = _sys_siglist[2];
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext
! if { (eval echo "$as_me:11589: \"$ac_compile\"") >&5
!   (eval $ac_compile) 2>&5
!   ac_status=$?
!   echo "$as_me:11592: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest.$ac_objext'
!   { (eval echo "$as_me:11595: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:11598: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
    bash_cv_decl_under_sys_siglist=yes
  else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! bash_cv_decl_under_sys_siglist=no
  fi
! rm -f conftest.$ac_objext conftest.$ac_ext
  fi
! echo "$as_me:11608: result: $bash_cv_decl_under_sys_siglist" >&5
! echo "${ECHO_T}$bash_cv_decl_under_sys_siglist" >&6
  if test $bash_cv_decl_under_sys_siglist = yes; then
! cat >>confdefs.h <<\EOF
  #define UNDER_SYS_SIGLIST_DECLARED 1
  EOF
***************
*** 6172,6187 ****
  fi
  
! 
! echo $ac_n "checking for _sys_siglist in system C library""... $ac_c" 1>&6
! echo "configure:6177: checking for _sys_siglist in system C library" >&5
! if eval "test \"`echo '$''{'bash_cv_under_sys_siglist'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
    if test "$cross_compiling" = yes; then
!   echo "configure: warning: cannot check for _sys_siglist if cross compiling -- defaulting to no" 1>&2
  	 bash_cv_under_sys_siglist=no
  else
!   cat > conftest.$ac_ext <<EOF
! #line 6186 "configure"
  #include "confdefs.h"
  
--- 11615,11630 ----
  fi
  
! echo "$as_me:11617: checking for _sys_siglist in system C library" >&5
! echo $ECHO_N "checking for _sys_siglist in system C library... $ECHO_C" >&6
! if test "${bash_cv_under_sys_siglist+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
    if test "$cross_compiling" = yes; then
!   { echo "$as_me:11623: WARNING: cannot check for _sys_siglist if cross compiling -- defaulting to no" >&5
! echo "$as_me: WARNING: cannot check for _sys_siglist if cross compiling -- defaulting to no" >&2;}
  	 bash_cv_under_sys_siglist=no
  else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 11628 "configure"
  #include "confdefs.h"
  
***************
*** 6199,6220 ****
  exit(msg == 0);
  }
! EOF
! if { (eval echo configure:6203: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
! then
    bash_cv_under_sys_siglist=yes
  else
!   echo "configure: failed program was:" >&5
!   cat conftest.$ac_ext >&5
!   rm -fr conftest*
!   bash_cv_under_sys_siglist=no
  fi
! rm -fr conftest*
  fi
- 
  fi
  
! echo "$ac_t""$bash_cv_under_sys_siglist" 1>&6
  if test $bash_cv_under_sys_siglist = yes; then
! cat >> confdefs.h <<\EOF
  #define HAVE_UNDER_SYS_SIGLIST 1
  EOF
--- 11642,11672 ----
  exit(msg == 0);
  }
! _ACEOF
! rm -f conftest$ac_exeext
! if { (eval echo "$as_me:11646: \"$ac_link\"") >&5
!   (eval $ac_link) 2>&5
!   ac_status=$?
!   echo "$as_me:11649: \$? = $ac_status" >&5
!   (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
!   { (eval echo "$as_me:11651: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:11654: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
    bash_cv_under_sys_siglist=yes
  else
!   echo "$as_me: program exited with status $ac_status" >&5
! echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! bash_cv_under_sys_siglist=no
  fi
! rm -f core core.* *.core conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
  fi
  fi
  
! echo "$as_me:11667: result: $bash_cv_under_sys_siglist" >&5
! echo "${ECHO_T}$bash_cv_under_sys_siglist" >&6
  if test $bash_cv_under_sys_siglist = yes; then
! cat >>confdefs.h <<\EOF
  #define HAVE_UNDER_SYS_SIGLIST 1
  EOF
***************
*** 6222,6233 ****
  fi
  
! 
! echo $ac_n "checking whether signal handlers are of type void""... $ac_c" 1>&6
! echo "configure:6227: checking whether signal handlers are of type void" >&5
! if eval "test \"`echo '$''{'bash_cv_void_sighandler'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
!   cat > conftest.$ac_ext <<EOF
! #line 6232 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
--- 11674,11684 ----
  fi
  
! echo "$as_me:11676: checking whether signal handlers are of type void" >&5
! echo $ECHO_N "checking whether signal handlers are of type void... $ECHO_C" >&6
! if test "${bash_cv_void_sighandler+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 11682 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
***************
*** 6240,6261 ****
  #endif
  void (*signal ()) ();
! int main() {
  int i;
! ; return 0; }
! EOF
! if { (eval echo configure:6247: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
!   rm -rf conftest*
    bash_cv_void_sighandler=yes
  else
!   echo "configure: failed program was:" >&5
!   cat conftest.$ac_ext >&5
!   rm -rf conftest*
!   bash_cv_void_sighandler=no
  fi
! rm -f conftest*
  fi
! echo "$ac_t""$bash_cv_void_sighandler" 1>&6
  if test $bash_cv_void_sighandler = yes; then
! cat >> confdefs.h <<\EOF
  #define VOID_SIGHANDLER 1
  EOF
--- 11691,11726 ----
  #endif
  void (*signal ()) ();
! int
! main ()
! {
  int i;
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext
! if { (eval echo "$as_me:11702: \"$ac_compile\"") >&5
!   (eval $ac_compile) 2>&5
!   ac_status=$?
!   echo "$as_me:11705: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest.$ac_objext'
!   { (eval echo "$as_me:11708: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:11711: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
    bash_cv_void_sighandler=yes
  else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! bash_cv_void_sighandler=no
  fi
! rm -f conftest.$ac_objext conftest.$ac_ext
  fi
! echo "$as_me:11721: result: $bash_cv_void_sighandler" >&5
! echo "${ECHO_T}$bash_cv_void_sighandler" >&6
  if test $bash_cv_void_sighandler = yes; then
! cat >>confdefs.h <<\EOF
  #define VOID_SIGHANDLER 1
  EOF
***************
*** 6263,6287 ****
  fi
  
! echo $ac_n "checking for clock_t""... $ac_c" 1>&6
! echo "configure:6267: checking for clock_t" >&5
! if eval "test \"`echo '$''{'bash_cv_type_clock_t'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
!   cat > conftest.$ac_ext <<EOF
! #line 6272 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
  #if STDC_HEADERS
  #include <stdlib.h>
  #endif
  #include <sys/times.h>
  
! EOF
  if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
    egrep "clock_t" >/dev/null 2>&1; then
-   rm -rf conftest*
    bash_cv_type_clock_t=yes
  else
-   rm -rf conftest*
    bash_cv_type_clock_t=no
  fi
--- 11728,11754 ----
  fi
  
! echo "$as_me:11730: checking for clock_t" >&5
! echo $ECHO_N "checking for clock_t... $ECHO_C" >&6
! if test "${bash_cv_type_clock_t+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 11736 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
  #if STDC_HEADERS
  #include <stdlib.h>
+ #include <stddef.h>
+ #endif
+ #if HAVE_INTTYPES_H
+ #include <inttypes.h>
  #endif
  #include <sys/times.h>
  
! _ACEOF
  if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
    egrep "clock_t" >/dev/null 2>&1; then
    bash_cv_type_clock_t=yes
  else
    bash_cv_type_clock_t=no
  fi
***************
*** 6290,6297 ****
  fi
  
! echo "$ac_t""$bash_cv_type_clock_t" 1>&6
  
  if test $bash_cv_type_clock_t = no; then
!   cat >> confdefs.h <<\EOF
  #define clock_t long
  EOF
--- 11757,11765 ----
  fi
  
! echo "$as_me:11759: result: $bash_cv_type_clock_t" >&5
! echo "${ECHO_T}$bash_cv_type_clock_t" >&6
  
  if test $bash_cv_type_clock_t = no; then
!   cat >>confdefs.h <<EOF
  #define clock_t long
  EOF
***************
*** 6299,6323 ****
  fi
  
! echo $ac_n "checking for sigset_t""... $ac_c" 1>&6
! echo "configure:6303: checking for sigset_t" >&5
! if eval "test \"`echo '$''{'bash_cv_type_sigset_t'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
!   cat > conftest.$ac_ext <<EOF
! #line 6308 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
  #if STDC_HEADERS
  #include <stdlib.h>
  #endif
  #include <signal.h>
  
! EOF
  if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
    egrep "sigset_t" >/dev/null 2>&1; then
-   rm -rf conftest*
    bash_cv_type_sigset_t=yes
  else
-   rm -rf conftest*
    bash_cv_type_sigset_t=no
  fi
--- 11767,11793 ----
  fi
  
! echo "$as_me:11769: checking for sigset_t" >&5
! echo $ECHO_N "checking for sigset_t... $ECHO_C" >&6
! if test "${bash_cv_type_sigset_t+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 11775 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
  #if STDC_HEADERS
  #include <stdlib.h>
+ #include <stddef.h>
+ #endif
+ #if HAVE_INTTYPES_H
+ #include <inttypes.h>
  #endif
  #include <signal.h>
  
! _ACEOF
  if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
    egrep "sigset_t" >/dev/null 2>&1; then
    bash_cv_type_sigset_t=yes
  else
    bash_cv_type_sigset_t=no
  fi
***************
*** 6326,6333 ****
  fi
  
! echo "$ac_t""$bash_cv_type_sigset_t" 1>&6
  
  if test $bash_cv_type_sigset_t = no; then
!   cat >> confdefs.h <<\EOF
  #define sigset_t int
  EOF
--- 11796,11804 ----
  fi
  
! echo "$as_me:11798: result: $bash_cv_type_sigset_t" >&5
! echo "${ECHO_T}$bash_cv_type_sigset_t" >&6
  
  if test $bash_cv_type_sigset_t = no; then
!   cat >>confdefs.h <<EOF
  #define sigset_t int
  EOF
***************
*** 6335,6360 ****
  fi
  
! echo $ac_n "checking for quad_t""... $ac_c" 1>&6
! echo "configure:6339: checking for quad_t" >&5
! if eval "test \"`echo '$''{'bash_cv_type_quad_t'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
!   cat > conftest.$ac_ext <<EOF
! #line 6344 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
  #if STDC_HEADERS
  #include <stdlib.h>
  #endif
  
  
! EOF
  if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
!   egrep "quad_t" >/dev/null 2>&1; then
!   rm -rf conftest*
!   bash_cv_type_quad_t=yes
  else
!   rm -rf conftest*
!   bash_cv_type_quad_t=no
  fi
  rm -f conftest*
--- 11806,11954 ----
  fi
  
! echo "$as_me:11808: checking for quad_t" >&5
! echo $ECHO_N "checking for quad_t... $ECHO_C" >&6
! if test "${bash_cv_type_quad_t+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
! else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 11814 "configure"
! #include "confdefs.h"
! #include <sys/types.h>
! #if STDC_HEADERS
! #include <stdlib.h>
! #include <stddef.h>
! #endif
! #if HAVE_INTTYPES_H
! #include <inttypes.h>
! #endif
! 
! _ACEOF
! if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
!   egrep "quad_t" >/dev/null 2>&1; then
!   bash_cv_type_quad_t=yes
! else
!   bash_cv_type_quad_t=no
! fi
! rm -f conftest*
! 
! fi
! 
! echo "$as_me:11836: result: $bash_cv_type_quad_t" >&5
! echo "${ECHO_T}$bash_cv_type_quad_t" >&6
! if test $bash_cv_type_quad_t = yes; then
! 	cat >>confdefs.h <<\EOF
! #define HAVE_QUAD_T 1
! EOF
! 
! 	fi
! if test $bash_cv_type_quad_t = no; then
!   cat >>confdefs.h <<EOF
! #define quad_t long
! EOF
! 
! fi
! 
! echo "$as_me:11851: checking for intmax_t" >&5
! echo $ECHO_N "checking for intmax_t... $ECHO_C" >&6
! if test "${bash_cv_type_intmax_t+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
! else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 11857 "configure"
! #include "confdefs.h"
! #include <sys/types.h>
! #if STDC_HEADERS
! #include <stdlib.h>
! #include <stddef.h>
! #endif
! #if HAVE_INTTYPES_H
! #include <inttypes.h>
! #endif
! 
! _ACEOF
! if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
!   egrep "intmax_t" >/dev/null 2>&1; then
!   bash_cv_type_intmax_t=yes
! else
!   bash_cv_type_intmax_t=no
! fi
! rm -f conftest*
! 
! fi
! 
! echo "$as_me:11879: result: $bash_cv_type_intmax_t" >&5
! echo "${ECHO_T}$bash_cv_type_intmax_t" >&6
! 
! if test $bash_cv_type_intmax_t = no; then
!   cat >>confdefs.h <<EOF
! #define intmax_t $bash_cv_type_long_long
! EOF
! 
! fi
! 
! echo "$as_me:11889: checking for uintmax_t" >&5
! echo $ECHO_N "checking for uintmax_t... $ECHO_C" >&6
! if test "${bash_cv_type_uintmax_t+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 11895 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
  #if STDC_HEADERS
  #include <stdlib.h>
+ #include <stddef.h>
  #endif
+ #if HAVE_INTTYPES_H
+ #include <inttypes.h>
+ #endif
+ 
+ _ACEOF
+ if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+   egrep "uintmax_t" >/dev/null 2>&1; then
+   bash_cv_type_uintmax_t=yes
+ else
+   bash_cv_type_uintmax_t=no
+ fi
+ rm -f conftest*
  
+ fi
+ 
+ echo "$as_me:11917: result: $bash_cv_type_uintmax_t" >&5
+ echo "${ECHO_T}$bash_cv_type_uintmax_t" >&6
+ 
+ if test $bash_cv_type_uintmax_t = no; then
+   cat >>confdefs.h <<EOF
+ #define uintmax_t $bash_cv_type_unsigned_long_long
+ EOF
+ 
+ fi
+ 
+ if test "$ac_cv_header_sys_socket_h" = "yes"; then
+ 
+ echo "$as_me:11929: checking for socklen_t" >&5
+ echo $ECHO_N "checking for socklen_t... $ECHO_C" >&6
+ if test "${bash_cv_type_socklen_t+set}" = set; then
+   echo $ECHO_N "(cached) $ECHO_C" >&6
+ else
+   cat >conftest.$ac_ext <<_ACEOF
+ #line 11935 "configure"
+ #include "confdefs.h"
+ #include <sys/types.h>
+ #if STDC_HEADERS
+ #include <stdlib.h>
+ #include <stddef.h>
+ #endif
+ #if HAVE_INTTYPES_H
+ #include <inttypes.h>
+ #endif
+ #include <sys/socket.h>
  
! _ACEOF
  if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
!   egrep "socklen_t" >/dev/null 2>&1; then
!   bash_cv_type_socklen_t=yes
  else
!   bash_cv_type_socklen_t=no
  fi
  rm -f conftest*
***************
*** 6362,6407 ****
  fi
  
! echo "$ac_t""$bash_cv_type_quad_t" 1>&6
! if test $bash_cv_type_quad_t = yes; then
! 	cat >> confdefs.h <<\EOF
! #define HAVE_QUAD_T 1
  EOF
  
  	fi
! if test $bash_cv_type_quad_t = no; then
!   cat >> confdefs.h <<\EOF
! #define quad_t long
  EOF
  
  fi
  
! echo $ac_n "checking for size and type of struct rlimit fields""... $ac_c" 1>&6
! echo "configure:6380: checking for size and type of struct rlimit fields" >&5
! if eval "test \"`echo '$''{'bash_cv_type_rlimit'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
!   cat > conftest.$ac_ext <<EOF
! #line 6385 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
  #include <sys/resource.h>
! int main() {
  rlim_t xxx;
! ; return 0; }
! EOF
! if { (eval echo configure:6393: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
!   rm -rf conftest*
    bash_cv_type_rlimit=rlim_t
  else
!   echo "configure: failed program was:" >&5
!   cat conftest.$ac_ext >&5
!   rm -rf conftest*
!   
  if test "$cross_compiling" = yes; then
!   echo "configure: warning: cannot check quad_t if cross compiling -- defaulting to long" 1>&2
           bash_cv_type_rlimit=long
  else
!   cat > conftest.$ac_ext <<EOF
! #line 6406 "configure"
  #include "confdefs.h"
  
--- 11956,12017 ----
  fi
  
! echo "$as_me:11958: result: $bash_cv_type_socklen_t" >&5
! echo "${ECHO_T}$bash_cv_type_socklen_t" >&6
! if test $bash_cv_type_socklen_t = yes; then
! 	cat >>confdefs.h <<\EOF
! #define HAVE_SOCKLEN_T 1
  EOF
  
  	fi
! if test $bash_cv_type_socklen_t = no; then
!   cat >>confdefs.h <<EOF
! #define socklen_t int
  EOF
  
  fi
  
! fi
! echo "$as_me:11974: checking for size and type of struct rlimit fields" >&5
! echo $ECHO_N "checking for size and type of struct rlimit fields... $ECHO_C" >&6
! if test "${bash_cv_type_rlimit+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 11980 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
  #include <sys/resource.h>
! int
! main ()
! {
  rlim_t xxx;
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext
! if { (eval echo "$as_me:11993: \"$ac_compile\"") >&5
!   (eval $ac_compile) 2>&5
!   ac_status=$?
!   echo "$as_me:11996: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest.$ac_objext'
!   { (eval echo "$as_me:11999: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:12002: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
    bash_cv_type_rlimit=rlim_t
  else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! 
  if test "$cross_compiling" = yes; then
!   { echo "$as_me:12010: WARNING: cannot check quad_t if cross compiling -- defaulting to long" >&5
! echo "$as_me: WARNING: cannot check quad_t if cross compiling -- defaulting to long" >&2;}
           bash_cv_type_rlimit=long
  else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 12015 "configure"
  #include "confdefs.h"
  
***************
*** 6418,6447 ****
    exit(1);
  }
! EOF
! if { (eval echo configure:6422: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
! then
    bash_cv_type_rlimit=quad_t
  else
!   echo "configure: failed program was:" >&5
!   cat conftest.$ac_ext >&5
!   rm -fr conftest*
!   bash_cv_type_rlimit=long
  fi
! rm -fr conftest*
  fi
- 
  fi
! rm -f conftest*
  
  fi
  
! echo "$ac_t""$bash_cv_type_rlimit" 1>&6
  if test $bash_cv_type_rlimit = quad_t; then
! cat >> confdefs.h <<\EOF
  #define RLIMTYPE quad_t
  EOF
  
  elif test $bash_cv_type_rlimit = rlim_t; then
! cat >> confdefs.h <<\EOF
  #define RLIMTYPE rlim_t
  EOF
--- 12028,12066 ----
    exit(1);
  }
! _ACEOF
! rm -f conftest$ac_exeext
! if { (eval echo "$as_me:12032: \"$ac_link\"") >&5
!   (eval $ac_link) 2>&5
!   ac_status=$?
!   echo "$as_me:12035: \$? = $ac_status" >&5
!   (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
!   { (eval echo "$as_me:12037: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:12040: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
    bash_cv_type_rlimit=quad_t
  else
!   echo "$as_me: program exited with status $ac_status" >&5
! echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! bash_cv_type_rlimit=long
  fi
! rm -f core core.* *.core conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
  fi
  fi
! rm -f conftest.$ac_objext conftest.$ac_ext
  
  fi
  
! echo "$as_me:12056: result: $bash_cv_type_rlimit" >&5
! echo "${ECHO_T}$bash_cv_type_rlimit" >&6
  if test $bash_cv_type_rlimit = quad_t; then
! cat >>confdefs.h <<\EOF
  #define RLIMTYPE quad_t
  EOF
  
  elif test $bash_cv_type_rlimit = rlim_t; then
! cat >>confdefs.h <<\EOF
  #define RLIMTYPE rlim_t
  EOF
***************
*** 6449,6481 ****
  fi
  
! 
! echo $ac_n "checking for a c_line member of struct termios""... $ac_c" 1>&6
! echo "configure:6454: checking for a c_line member of struct termios" >&5
! if eval "test \"`echo '$''{'bash_cv_termios_ldisc'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
!   cat > conftest.$ac_ext <<EOF
! #line 6459 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
  #include <termios.h>
! int main() {
! struct termios t; int i; i = t.c_line;
! ; return 0; }
! EOF
! if { (eval echo configure:6467: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
!   rm -rf conftest*
!   bash_cv_termios_ldisc=yes
! else
!   echo "configure: failed program was:" >&5
!   cat conftest.$ac_ext >&5
!   rm -rf conftest*
!   bash_cv_termios_ldisc=no
! fi
! rm -f conftest*
! fi
! echo "$ac_t""$bash_cv_termios_ldisc" 1>&6
! if test $bash_cv_termios_ldisc = yes; then
! cat >> confdefs.h <<\EOF
  #define TERMIOS_LDISC 1
  EOF
--- 12068,12117 ----
  fi
  
! echo "$as_me:12070: checking for struct termios.c_line" >&5
! echo $ECHO_N "checking for struct termios.c_line... $ECHO_C" >&6
! if test "${ac_cv_member_struct_termios_c_line+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 12076 "configure"
  #include "confdefs.h"
+ 
  #include <sys/types.h>
  #include <termios.h>
! 
! int
! main ()
! {
! static struct termios ac_aggr;
! if (ac_aggr.c_line)
! return 0;
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext
! if { (eval echo "$as_me:12093: \"$ac_compile\"") >&5
!   (eval $ac_compile) 2>&5
!   ac_status=$?
!   echo "$as_me:12096: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest.$ac_objext'
!   { (eval echo "$as_me:12099: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:12102: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   ac_cv_member_struct_termios_c_line=yes
! else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! ac_cv_member_struct_termios_c_line=no
! fi
! rm -f conftest.$ac_objext conftest.$ac_ext
! fi
! echo "$as_me:12112: result: $ac_cv_member_struct_termios_c_line" >&5
! echo "${ECHO_T}$ac_cv_member_struct_termios_c_line" >&6
! if test $ac_cv_member_struct_termios_c_line = yes; then
!   cat >>confdefs.h <<\EOF
  #define TERMIOS_LDISC 1
  EOF
***************
*** 6483,6514 ****
  fi
  
! echo $ac_n "checking for a c_line member of struct termio""... $ac_c" 1>&6
! echo "configure:6487: checking for a c_line member of struct termio" >&5
! if eval "test \"`echo '$''{'bash_cv_termio_ldisc'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
!   cat > conftest.$ac_ext <<EOF
! #line 6492 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
  #include <termio.h>
! int main() {
! struct termio t; int i; i = t.c_line;
! ; return 0; }
! EOF
! if { (eval echo configure:6500: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
!   rm -rf conftest*
!   bash_cv_termio_ldisc=yes
! else
!   echo "configure: failed program was:" >&5
!   cat conftest.$ac_ext >&5
!   rm -rf conftest*
!   bash_cv_termio_ldisc=no
! fi
! rm -f conftest*
! fi
! echo "$ac_t""$bash_cv_termio_ldisc" 1>&6
! if test $bash_cv_termio_ldisc = yes; then
! cat >> confdefs.h <<\EOF
  #define TERMIO_LDISC 1
  EOF
--- 12119,12168 ----
  fi
  
! echo "$as_me:12121: checking for struct termio.c_line" >&5
! echo $ECHO_N "checking for struct termio.c_line... $ECHO_C" >&6
! if test "${ac_cv_member_struct_termio_c_line+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 12127 "configure"
  #include "confdefs.h"
+ 
  #include <sys/types.h>
  #include <termio.h>
! 
! int
! main ()
! {
! static struct termio ac_aggr;
! if (ac_aggr.c_line)
! return 0;
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext
! if { (eval echo "$as_me:12144: \"$ac_compile\"") >&5
!   (eval $ac_compile) 2>&5
!   ac_status=$?
!   echo "$as_me:12147: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest.$ac_objext'
!   { (eval echo "$as_me:12150: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:12153: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   ac_cv_member_struct_termio_c_line=yes
! else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! ac_cv_member_struct_termio_c_line=no
! fi
! rm -f conftest.$ac_objext conftest.$ac_ext
! fi
! echo "$as_me:12163: result: $ac_cv_member_struct_termio_c_line" >&5
! echo "${ECHO_T}$ac_cv_member_struct_termio_c_line" >&6
! if test $ac_cv_member_struct_termio_c_line = yes; then
!   cat >>confdefs.h <<\EOF
  #define TERMIO_LDISC 1
  EOF
***************
*** 6516,6527 ****
  fi
  
! 
! echo $ac_n "checking if struct dirent has a d_ino member""... $ac_c" 1>&6
! echo "configure:6521: checking if struct dirent has a d_ino member" >&5
! if eval "test \"`echo '$''{'bash_cv_dirent_has_dino'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
!   cat > conftest.$ac_ext <<EOF
! #line 6526 "configure"
  #include "confdefs.h"
  
--- 12170,12180 ----
  fi
  
! echo "$as_me:12172: checking if struct dirent has a d_ino member" >&5
! echo $ECHO_N "checking if struct dirent has a d_ino member... $ECHO_C" >&6
! if test "${bash_cv_dirent_has_dino+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 12178 "configure"
  #include "confdefs.h"
  
***************
*** 6546,6570 ****
  #endif /* HAVE_DIRENT_H */
  
! int main() {
  
  struct dirent d; int z; z = d.d_ino;
  
! ; return 0; }
! EOF
! if { (eval echo configure:6555: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
!   rm -rf conftest*
    bash_cv_dirent_has_dino=yes
  else
!   echo "configure: failed program was:" >&5
!   cat conftest.$ac_ext >&5
!   rm -rf conftest*
!   bash_cv_dirent_has_dino=no
  fi
! rm -f conftest*
  fi
  
! echo "$ac_t""$bash_cv_dirent_has_dino" 1>&6
  if test $bash_cv_dirent_has_dino = yes; then
! cat >> confdefs.h <<\EOF
  #define STRUCT_DIRENT_HAS_D_INO 1
  EOF
--- 12199,12237 ----
  #endif /* HAVE_DIRENT_H */
  
! int
! main ()
! {
  
  struct dirent d; int z; z = d.d_ino;
  
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext
! if { (eval echo "$as_me:12212: \"$ac_compile\"") >&5
!   (eval $ac_compile) 2>&5
!   ac_status=$?
!   echo "$as_me:12215: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest.$ac_objext'
!   { (eval echo "$as_me:12218: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:12221: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
    bash_cv_dirent_has_dino=yes
  else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! bash_cv_dirent_has_dino=no
  fi
! rm -f conftest.$ac_objext conftest.$ac_ext
  fi
  
! echo "$as_me:12232: result: $bash_cv_dirent_has_dino" >&5
! echo "${ECHO_T}$bash_cv_dirent_has_dino" >&6
  if test $bash_cv_dirent_has_dino = yes; then
! cat >>confdefs.h <<\EOF
  #define STRUCT_DIRENT_HAS_D_INO 1
  EOF
***************
*** 6572,6583 ****
  fi
  
! 
! echo $ac_n "checking if struct dirent has a d_fileno member""... $ac_c" 1>&6
! echo "configure:6577: checking if struct dirent has a d_fileno member" >&5
! if eval "test \"`echo '$''{'bash_cv_dirent_has_d_fileno'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
!   cat > conftest.$ac_ext <<EOF
! #line 6582 "configure"
  #include "confdefs.h"
  
--- 12239,12249 ----
  fi
  
! echo "$as_me:12241: checking if struct dirent has a d_fileno member" >&5
! echo $ECHO_N "checking if struct dirent has a d_fileno member... $ECHO_C" >&6
! if test "${bash_cv_dirent_has_d_fileno+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 12247 "configure"
  #include "confdefs.h"
  
***************
*** 6602,6626 ****
  #endif /* HAVE_DIRENT_H */
  
! int main() {
  
  struct dirent d; int z; z = d.d_fileno;
  
! ; return 0; }
! EOF
! if { (eval echo configure:6611: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
!   rm -rf conftest*
    bash_cv_dirent_has_d_fileno=yes
  else
!   echo "configure: failed program was:" >&5
!   cat conftest.$ac_ext >&5
!   rm -rf conftest*
!   bash_cv_dirent_has_d_fileno=no
  fi
! rm -f conftest*
  fi
  
! echo "$ac_t""$bash_cv_dirent_has_d_fileno" 1>&6
  if test $bash_cv_dirent_has_d_fileno = yes; then
! cat >> confdefs.h <<\EOF
  #define STRUCT_DIRENT_HAS_D_FILENO 1
  EOF
--- 12268,12306 ----
  #endif /* HAVE_DIRENT_H */
  
! int
! main ()
! {
  
  struct dirent d; int z; z = d.d_fileno;
  
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext
! if { (eval echo "$as_me:12281: \"$ac_compile\"") >&5
!   (eval $ac_compile) 2>&5
!   ac_status=$?
!   echo "$as_me:12284: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest.$ac_objext'
!   { (eval echo "$as_me:12287: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:12290: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
    bash_cv_dirent_has_d_fileno=yes
  else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! bash_cv_dirent_has_d_fileno=no
  fi
! rm -f conftest.$ac_objext conftest.$ac_ext
  fi
  
! echo "$as_me:12301: result: $bash_cv_dirent_has_d_fileno" >&5
! echo "${ECHO_T}$bash_cv_dirent_has_d_fileno" >&6
  if test $bash_cv_dirent_has_d_fileno = yes; then
! cat >>confdefs.h <<\EOF
  #define STRUCT_DIRENT_HAS_D_FILENO 1
  EOF
***************
*** 6628,6720 ****
  fi
  
! echo $ac_n "checking for struct winsize in sys/ioctl.h and termios.h""... $ac_c" 1>&6
! echo "configure:6632: checking for struct winsize in sys/ioctl.h and termios.h" >&5
! if eval "test \"`echo '$''{'bash_cv_struct_winsize_header'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
!   cat > conftest.$ac_ext <<EOF
! #line 6637 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
  #include <sys/ioctl.h>
! int main() {
  struct winsize x;
! ; return 0; }
! EOF
! if { (eval echo configure:6645: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
!   rm -rf conftest*
    bash_cv_struct_winsize_header=ioctl_h
  else
!   echo "configure: failed program was:" >&5
!   cat conftest.$ac_ext >&5
!   rm -rf conftest*
!   cat > conftest.$ac_ext <<EOF
! #line 6653 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
  #include <termios.h>
! int main() {
  struct winsize x;
! ; return 0; }
! EOF
! if { (eval echo configure:6661: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
!   rm -rf conftest*
    bash_cv_struct_winsize_header=termios_h
  else
!   echo "configure: failed program was:" >&5
!   cat conftest.$ac_ext >&5
!   rm -rf conftest*
!   bash_cv_struct_winsize_header=other
  fi
! rm -f conftest*
  
  fi
! rm -f conftest*
  fi
  
  if test $bash_cv_struct_winsize_header = ioctl_h; then
!   echo "$ac_t""sys/ioctl.h" 1>&6
!   cat >> confdefs.h <<\EOF
  #define STRUCT_WINSIZE_IN_SYS_IOCTL 1
  EOF
  
  elif test $bash_cv_struct_winsize_header = termios_h; then
!   echo "$ac_t""termios.h" 1>&6
!   cat >> confdefs.h <<\EOF
  #define STRUCT_WINSIZE_IN_TERMIOS 1
  EOF
  
  else
!   echo "$ac_t""not found" 1>&6
  fi
  
! echo $ac_n "checking for struct timeval in sys/time.h and time.h""... $ac_c" 1>&6
! echo "configure:6693: checking for struct timeval in sys/time.h and time.h" >&5
! if eval "test \"`echo '$''{'bash_cv_struct_timeval'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
!   
! cat > conftest.$ac_ext <<EOF
! #line 6699 "configure"
  #include "confdefs.h"
  #include <sys/time.h>
! EOF
  if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
    egrep "struct timeval" >/dev/null 2>&1; then
-   rm -rf conftest*
    bash_cv_struct_timeval=yes
  else
!   rm -rf conftest*
!   cat > conftest.$ac_ext <<EOF
! #line 6710 "configure"
  #include "confdefs.h"
  #include <time.h>
! EOF
  if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
    egrep "struct timeval" >/dev/null 2>&1; then
-   rm -rf conftest*
    bash_cv_struct_timeval=yes
  else
-   rm -rf conftest*
    bash_cv_struct_timeval=no
  fi
--- 12308,12427 ----
  fi
  
! echo "$as_me:12310: checking for struct winsize in sys/ioctl.h and termios.h" >&5
! echo $ECHO_N "checking for struct winsize in sys/ioctl.h and termios.h... $ECHO_C" >&6
! if test "${bash_cv_struct_winsize_header+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 12316 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
  #include <sys/ioctl.h>
! int
! main ()
! {
  struct winsize x;
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext
! if { (eval echo "$as_me:12329: \"$ac_compile\"") >&5
!   (eval $ac_compile) 2>&5
!   ac_status=$?
!   echo "$as_me:12332: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest.$ac_objext'
!   { (eval echo "$as_me:12335: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:12338: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
    bash_cv_struct_winsize_header=ioctl_h
  else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! cat >conftest.$ac_ext <<_ACEOF
! #line 12345 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
  #include <termios.h>
! int
! main ()
! {
  struct winsize x;
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext
! if { (eval echo "$as_me:12358: \"$ac_compile\"") >&5
!   (eval $ac_compile) 2>&5
!   ac_status=$?
!   echo "$as_me:12361: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest.$ac_objext'
!   { (eval echo "$as_me:12364: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:12367: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
    bash_cv_struct_winsize_header=termios_h
  else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! bash_cv_struct_winsize_header=other
  fi
! rm -f conftest.$ac_objext conftest.$ac_ext
  
  fi
! rm -f conftest.$ac_objext conftest.$ac_ext
  fi
  
  if test $bash_cv_struct_winsize_header = ioctl_h; then
!   echo "$as_me:12382: result: sys/ioctl.h" >&5
! echo "${ECHO_T}sys/ioctl.h" >&6
!   cat >>confdefs.h <<\EOF
  #define STRUCT_WINSIZE_IN_SYS_IOCTL 1
  EOF
  
  elif test $bash_cv_struct_winsize_header = termios_h; then
!   echo "$as_me:12389: result: termios.h" >&5
! echo "${ECHO_T}termios.h" >&6
!   cat >>confdefs.h <<\EOF
  #define STRUCT_WINSIZE_IN_TERMIOS 1
  EOF
  
  else
!   echo "$as_me:12396: result: not found" >&5
! echo "${ECHO_T}not found" >&6
  fi
  
! echo "$as_me:12400: checking for struct timeval in sys/time.h and time.h" >&5
! echo $ECHO_N "checking for struct timeval in sys/time.h and time.h... $ECHO_C" >&6
! if test "${bash_cv_struct_timeval+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
! 
! cat >conftest.$ac_ext <<_ACEOF
! #line 12407 "configure"
  #include "confdefs.h"
  #include <sys/time.h>
! 
! _ACEOF
  if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
    egrep "struct timeval" >/dev/null 2>&1; then
    bash_cv_struct_timeval=yes
  else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 12417 "configure"
  #include "confdefs.h"
  #include <time.h>
! 
! _ACEOF
  if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
    egrep "struct timeval" >/dev/null 2>&1; then
    bash_cv_struct_timeval=yes
  else
    bash_cv_struct_timeval=no
  fi
***************
*** 6724,6733 ****
  rm -f conftest*
  
- 
  fi
  
! echo "$ac_t""$bash_cv_struct_timeval" 1>&6
  if test $bash_cv_struct_timeval = yes; then
!   cat >> confdefs.h <<\EOF
  #define HAVE_TIMEVAL 1
  EOF
--- 12431,12440 ----
  rm -f conftest*
  
  fi
  
! echo "$as_me:12435: result: $bash_cv_struct_timeval" >&5
! echo "${ECHO_T}$bash_cv_struct_timeval" >&6
  if test $bash_cv_struct_timeval = yes; then
!   cat >>confdefs.h <<\EOF
  #define HAVE_TIMEVAL 1
  EOF
***************
*** 6735,6768 ****
  fi
  
  
! echo $ac_n "checking for the existence of strsignal""... $ac_c" 1>&6
! echo "configure:6740: checking for the existence of strsignal" >&5
! if eval "test \"`echo '$''{'bash_cv_have_strsignal'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
!   cat > conftest.$ac_ext <<EOF
! #line 6745 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
  #include <signal.h>
! int main() {
  char *s = (char *)strsignal(2);
! ; return 0; }
! EOF
! if { (eval echo configure:6753: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
!   rm -rf conftest*
    bash_cv_have_strsignal=yes
  else
!   echo "configure: failed program was:" >&5
!   cat conftest.$ac_ext >&5
!   rm -rf conftest*
!   bash_cv_have_strsignal=no
  fi
! rm -f conftest*
  fi
  
! echo "$ac_t""$bash_cv_have_strsignal" 1>&6
  if test $bash_cv_have_strsignal = yes; then
! cat >> confdefs.h <<\EOF
  #define HAVE_STRSIGNAL 1
  EOF
--- 12442,12537 ----
  fi
  
+ echo "$as_me:12444: checking for struct stat.st_blocks" >&5
+ echo $ECHO_N "checking for struct stat.st_blocks... $ECHO_C" >&6
+ if test "${ac_cv_member_struct_stat_st_blocks+set}" = set; then
+   echo $ECHO_N "(cached) $ECHO_C" >&6
+ else
+   cat >conftest.$ac_ext <<_ACEOF
+ #line 12450 "configure"
+ #include "confdefs.h"
+ $ac_includes_default
+ int
+ main ()
+ {
+ static struct stat ac_aggr;
+ if (ac_aggr.st_blocks)
+ return 0;
+   ;
+   return 0;
+ }
+ _ACEOF
+ rm -f conftest.$ac_objext
+ if { (eval echo "$as_me:12464: \"$ac_compile\"") >&5
+   (eval $ac_compile) 2>&5
+   ac_status=$?
+   echo "$as_me:12467: \$? = $ac_status" >&5
+   (exit $ac_status); } &&
+          { ac_try='test -s conftest.$ac_objext'
+   { (eval echo "$as_me:12470: \"$ac_try\"") >&5
+   (eval $ac_try) 2>&5
+   ac_status=$?
+   echo "$as_me:12473: \$? = $ac_status" >&5
+   (exit $ac_status); }; }; then
+   ac_cv_member_struct_stat_st_blocks=yes
+ else
+   echo "$as_me: failed program was:" >&5
+ cat conftest.$ac_ext >&5
+ ac_cv_member_struct_stat_st_blocks=no
+ fi
+ rm -f conftest.$ac_objext conftest.$ac_ext
+ fi
+ echo "$as_me:12483: result: $ac_cv_member_struct_stat_st_blocks" >&5
+ echo "${ECHO_T}$ac_cv_member_struct_stat_st_blocks" >&6
+ if test $ac_cv_member_struct_stat_st_blocks = yes; then
+ 
+ cat >>confdefs.h <<EOF
+ #define HAVE_STRUCT_STAT_ST_BLOCKS 1
+ EOF
+ 
+ fi
  
! echo "$as_me:12493: checking for the existence of strsignal" >&5
! echo $ECHO_N "checking for the existence of strsignal... $ECHO_C" >&6
! if test "${bash_cv_have_strsignal+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 12499 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
  #include <signal.h>
! int
! main ()
! {
  char *s = (char *)strsignal(2);
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext conftest$ac_exeext
! if { (eval echo "$as_me:12512: \"$ac_link\"") >&5
!   (eval $ac_link) 2>&5
!   ac_status=$?
!   echo "$as_me:12515: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest$ac_exeext'
!   { (eval echo "$as_me:12518: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:12521: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
    bash_cv_have_strsignal=yes
  else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! bash_cv_have_strsignal=no
  fi
! rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
  fi
  
! echo "$as_me:12532: result: $bash_cv_have_strsignal" >&5
! echo "${ECHO_T}$bash_cv_have_strsignal" >&6
  if test $bash_cv_have_strsignal = yes; then
! cat >>confdefs.h <<\EOF
  #define HAVE_STRSIGNAL 1
  EOF
***************
*** 6770,6785 ****
  fi
  
! echo $ac_n "checking if opendir() opens non-directories""... $ac_c" 1>&6
! echo "configure:6774: checking if opendir() opens non-directories" >&5
! if eval "test \"`echo '$''{'bash_cv_opendir_not_robust'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
    if test "$cross_compiling" = yes; then
!   echo "configure: warning: cannot check opendir if cross compiling -- defaulting to no" 1>&2
       bash_cv_opendir_not_robust=no
  
  else
!   cat > conftest.$ac_ext <<EOF
! #line 6784 "configure"
  #include "confdefs.h"
  
--- 12539,12555 ----
  fi
  
! echo "$as_me:12541: checking if opendir() opens non-directories" >&5
! echo $ECHO_N "checking if opendir() opens non-directories... $ECHO_C" >&6
! if test "${bash_cv_opendir_not_robust+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
    if test "$cross_compiling" = yes; then
!   { echo "$as_me:12547: WARNING: cannot check opendir if cross compiling -- defaulting to no" >&5
! echo "$as_me: WARNING: cannot check opendir if cross compiling -- defaulting to no" >&2;}
       bash_cv_opendir_not_robust=no
  
  else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 12553 "configure"
  #include "confdefs.h"
  
***************
*** 6822,6843 ****
  exit (dir == 0);
  }
! EOF
! if { (eval echo configure:6826: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
! then
    bash_cv_opendir_not_robust=yes
  else
!   echo "configure: failed program was:" >&5
!   cat conftest.$ac_ext >&5
!   rm -fr conftest*
!   bash_cv_opendir_not_robust=no
  fi
! rm -fr conftest*
  fi
- 
  fi
  
! echo "$ac_t""$bash_cv_opendir_not_robust" 1>&6
  if test $bash_cv_opendir_not_robust = yes; then
! cat >> confdefs.h <<\EOF
  #define OPENDIR_NOT_ROBUST 1
  EOF
--- 12592,12622 ----
  exit (dir == 0);
  }
! _ACEOF
! rm -f conftest$ac_exeext
! if { (eval echo "$as_me:12596: \"$ac_link\"") >&5
!   (eval $ac_link) 2>&5
!   ac_status=$?
!   echo "$as_me:12599: \$? = $ac_status" >&5
!   (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
!   { (eval echo "$as_me:12601: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:12604: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
    bash_cv_opendir_not_robust=yes
  else
!   echo "$as_me: program exited with status $ac_status" >&5
! echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! bash_cv_opendir_not_robust=no
  fi
! rm -f core core.* *.core conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
  fi
  fi
  
! echo "$as_me:12617: result: $bash_cv_opendir_not_robust" >&5
! echo "${ECHO_T}$bash_cv_opendir_not_robust" >&6
  if test $bash_cv_opendir_not_robust = yes; then
! cat >>confdefs.h <<\EOF
  #define OPENDIR_NOT_ROBUST 1
  EOF
***************
*** 6845,6910 ****
  fi
  
! echo $ac_n "checking for declaration of printf in <stdio.h>""... $ac_c" 1>&6
! echo "configure:6849: checking for declaration of printf in <stdio.h>" >&5
! if eval "test \"`echo '$''{'bash_cv_printf_declared'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
! else
!   if test "$cross_compiling" = yes; then
!   echo "configure: warning: cannot check printf declaration if cross compiling -- defaulting to yes" 1>&2
!     bash_cv_printf_declared=yes
! 
! else
!   cat > conftest.$ac_ext <<EOF
! #line 6859 "configure"
! #include "confdefs.h"
! 
! #include <stdio.h>
! #ifdef __STDC__
! typedef int (*_bashfunc)(const char *, ...);
! #else
! typedef int (*_bashfunc)();
! #endif
! main()
! {
! _bashfunc pf;
! pf = (_bashfunc) printf;
! exit(pf == 0);
! }
! 
! EOF
! if { (eval echo configure:6876: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
! then
!   bash_cv_printf_declared=yes
! else
!   echo "configure: failed program was:" >&5
!   cat conftest.$ac_ext >&5
!   rm -fr conftest*
!   bash_cv_printf_declared=no
! fi
! rm -fr conftest*
! fi
! 
! fi
! 
! echo "$ac_t""$bash_cv_printf_declared" 1>&6
! if test $bash_cv_printf_declared = yes; then
! cat >> confdefs.h <<\EOF
! #define PRINTF_DECLARED 1
! EOF
! 
! fi
! 
! echo $ac_n "checking whether ulimit can substitute for getdtablesize""... $ac_c" 1>&6
! echo "configure:6899: checking whether ulimit can substitute for getdtablesize" >&5
! if eval "test \"`echo '$''{'bash_cv_ulimit_maxfds'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
    if test "$cross_compiling" = yes; then
!   echo "configure: warning: cannot check ulimit if cross compiling -- defaulting to no" 1>&2
      bash_cv_ulimit_maxfds=no
  
  else
!   cat > conftest.$ac_ext <<EOF
! #line 6909 "configure"
  #include "confdefs.h"
  
--- 12624,12640 ----
  fi
  
! echo "$as_me:12626: checking whether ulimit can substitute for getdtablesize" >&5
! echo $ECHO_N "checking whether ulimit can substitute for getdtablesize... $ECHO_C" >&6
! if test "${bash_cv_ulimit_maxfds+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
    if test "$cross_compiling" = yes; then
!   { echo "$as_me:12632: WARNING: cannot check ulimit if cross compiling -- defaulting to no" >&5
! echo "$as_me: WARNING: cannot check ulimit if cross compiling -- defaulting to no" >&2;}
      bash_cv_ulimit_maxfds=no
  
  else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 12638 "configure"
  #include "confdefs.h"
  
***************
*** 6915,6936 ****
  }
  
! EOF
! if { (eval echo configure:6919: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
! then
    bash_cv_ulimit_maxfds=yes
  else
!   echo "configure: failed program was:" >&5
!   cat conftest.$ac_ext >&5
!   rm -fr conftest*
!   bash_cv_ulimit_maxfds=no
  fi
! rm -fr conftest*
  fi
- 
  fi
  
! echo "$ac_t""$bash_cv_ulimit_maxfds" 1>&6
  if test $bash_cv_ulimit_maxfds = yes; then
! cat >> confdefs.h <<\EOF
  #define ULIMIT_MAXFDS 1
  EOF
--- 12645,12675 ----
  }
  
! _ACEOF
! rm -f conftest$ac_exeext
! if { (eval echo "$as_me:12649: \"$ac_link\"") >&5
!   (eval $ac_link) 2>&5
!   ac_status=$?
!   echo "$as_me:12652: \$? = $ac_status" >&5
!   (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
!   { (eval echo "$as_me:12654: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:12657: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
    bash_cv_ulimit_maxfds=yes
  else
!   echo "$as_me: program exited with status $ac_status" >&5
! echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! bash_cv_ulimit_maxfds=no
  fi
! rm -f core core.* *.core conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
  fi
  fi
  
! echo "$as_me:12670: result: $bash_cv_ulimit_maxfds" >&5
! echo "${ECHO_T}$bash_cv_ulimit_maxfds" >&6
  if test $bash_cv_ulimit_maxfds = yes; then
! cat >>confdefs.h <<\EOF
  #define ULIMIT_MAXFDS 1
  EOF
***************
*** 6938,6953 ****
  fi
  
! echo $ac_n "checking to see if getenv can be redefined""... $ac_c" 1>&6
! echo "configure:6942: checking to see if getenv can be redefined" >&5
! if eval "test \"`echo '$''{'bash_cv_getenv_redef'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
    if test "$cross_compiling" = yes; then
!   echo "configure: warning: cannot check getenv redefinition if cross compiling -- defaulting to yes" 1>&2
      bash_cv_getenv_redef=yes
  
  else
!   cat > conftest.$ac_ext <<EOF
! #line 6952 "configure"
  #include "confdefs.h"
  
--- 12677,12693 ----
  fi
  
! echo "$as_me:12679: checking to see if getenv can be redefined" >&5
! echo $ECHO_N "checking to see if getenv can be redefined... $ECHO_C" >&6
! if test "${bash_cv_getenv_redef+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
    if test "$cross_compiling" = yes; then
!   { echo "$as_me:12685: WARNING: cannot check getenv redefinition if cross compiling -- defaulting to yes" >&5
! echo "$as_me: WARNING: cannot check getenv redefinition if cross compiling -- defaulting to yes" >&2;}
      bash_cv_getenv_redef=yes
  
  else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 12691 "configure"
  #include "confdefs.h"
  
***************
*** 6983,7004 ****
  }
  
! EOF
! if { (eval echo configure:6987: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
! then
    bash_cv_getenv_redef=yes
  else
!   echo "configure: failed program was:" >&5
!   cat conftest.$ac_ext >&5
!   rm -fr conftest*
!   bash_cv_getenv_redef=no
  fi
! rm -fr conftest*
  fi
- 
  fi
  
! echo "$ac_t""$bash_cv_getenv_redef" 1>&6
  if test $bash_cv_getenv_redef = yes; then
! cat >> confdefs.h <<\EOF
  #define CAN_REDEFINE_GETENV 1
  EOF
--- 12723,12753 ----
  }
  
! _ACEOF
! rm -f conftest$ac_exeext
! if { (eval echo "$as_me:12727: \"$ac_link\"") >&5
!   (eval $ac_link) 2>&5
!   ac_status=$?
!   echo "$as_me:12730: \$? = $ac_status" >&5
!   (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
!   { (eval echo "$as_me:12732: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:12735: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
    bash_cv_getenv_redef=yes
  else
!   echo "$as_me: program exited with status $ac_status" >&5
! echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! bash_cv_getenv_redef=no
  fi
! rm -f core core.* *.core conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
  fi
  fi
  
! echo "$as_me:12748: result: $bash_cv_getenv_redef" >&5
! echo "${ECHO_T}$bash_cv_getenv_redef" >&6
  if test $bash_cv_getenv_redef = yes; then
! cat >>confdefs.h <<\EOF
  #define CAN_REDEFINE_GETENV 1
  EOF
***************
*** 7006,7021 ****
  fi
  
! echo $ac_n "checking if getcwd() calls popen()""... $ac_c" 1>&6
! echo "configure:7010: checking if getcwd() calls popen()" >&5
! if eval "test \"`echo '$''{'bash_cv_getcwd_calls_popen'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
    if test "$cross_compiling" = yes; then
!   echo "configure: warning: cannot check whether getcwd calls popen if cross compiling -- defaulting to no" 1>&2
      bash_cv_getcwd_calls_popen=no
  
  else
!   cat > conftest.$ac_ext <<EOF
! #line 7020 "configure"
  #include "confdefs.h"
  
--- 12755,12772 ----
  fi
  
! if test "$ac_func_getcwd" = "yes"; then
! echo "$as_me:12758: checking if getcwd() calls popen()" >&5
! echo $ECHO_N "checking if getcwd() calls popen()... $ECHO_C" >&6
! if test "${bash_cv_getcwd_calls_popen+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
    if test "$cross_compiling" = yes; then
!   { echo "$as_me:12764: WARNING: cannot check whether getcwd calls popen if cross compiling -- defaulting to no" >&5
! echo "$as_me: WARNING: cannot check whether getcwd calls popen if cross compiling -- defaulting to no" >&2;}
      bash_cv_getcwd_calls_popen=no
  
  else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 12770 "configure"
  #include "confdefs.h"
  
***************
*** 7071,7140 ****
  }
  
! EOF
! if { (eval echo configure:7075: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
! then
    bash_cv_getcwd_calls_popen=no
  else
!   echo "configure: failed program was:" >&5
!   cat conftest.$ac_ext >&5
!   rm -fr conftest*
!   bash_cv_getcwd_calls_popen=yes
  fi
! rm -fr conftest*
  fi
- 
  fi
  
! echo "$ac_t""$bash_cv_getcwd_calls_popen" 1>&6
  if test $bash_cv_getcwd_calls_popen = yes; then
! cat >> confdefs.h <<\EOF
  #define GETCWD_BROKEN 1
  EOF
  
  fi
  
- echo $ac_n "checking for declaration of sbrk in <unistd.h>""... $ac_c" 1>&6
- echo "configure:7098: checking for declaration of sbrk in <unistd.h>" >&5
- if eval "test \"`echo '$''{'bash_cv_sbrk_declared'+set}'`\" = set"; then
-   echo $ac_n "(cached) $ac_c" 1>&6
- else
-   cat > conftest.$ac_ext <<EOF
- #line 7103 "configure"
- #include "confdefs.h"
- #include <unistd.h>
- EOF
- if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
-   egrep "sbrk" >/dev/null 2>&1; then
-   rm -rf conftest*
-   bash_cv_sbrk_declared=yes
- else
-   rm -rf conftest*
-   bash_cv_sbrk_declared=no
- fi
- rm -f conftest*
- 
- fi
- 
- echo "$ac_t""$bash_cv_sbrk_declared" 1>&6
- if test $bash_cv_sbrk_declared = yes; then
- cat >> confdefs.h <<\EOF
- #define SBRK_DECLARED 1
- EOF
- 
  fi
  
! 
! echo $ac_n "checking for presence of POSIX-style sigsetjmp/siglongjmp""... $ac_c" 1>&6
! echo "configure:7129: checking for presence of POSIX-style sigsetjmp/siglongjmp" >&5
! if eval "test \"`echo '$''{'bash_cv_func_sigsetjmp'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
    if test "$cross_compiling" = yes; then
!   echo "configure: warning: cannot check for sigsetjmp/siglongjmp if cross-compiling -- defaulting to missing" 1>&2
       bash_cv_func_sigsetjmp=missing
  
  else
!   cat > conftest.$ac_ext <<EOF
! #line 7139 "configure"
  #include "confdefs.h"
  
--- 12822,12873 ----
  }
  
! _ACEOF
! rm -f conftest$ac_exeext
! if { (eval echo "$as_me:12826: \"$ac_link\"") >&5
!   (eval $ac_link) 2>&5
!   ac_status=$?
!   echo "$as_me:12829: \$? = $ac_status" >&5
!   (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
!   { (eval echo "$as_me:12831: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:12834: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
    bash_cv_getcwd_calls_popen=no
  else
!   echo "$as_me: program exited with status $ac_status" >&5
! echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! bash_cv_getcwd_calls_popen=yes
  fi
! rm -f core core.* *.core conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
  fi
  fi
  
! echo "$as_me:12847: result: $bash_cv_getcwd_calls_popen" >&5
! echo "${ECHO_T}$bash_cv_getcwd_calls_popen" >&6
  if test $bash_cv_getcwd_calls_popen = yes; then
! cat >>confdefs.h <<\EOF
  #define GETCWD_BROKEN 1
  EOF
  
+ LIBOBJS="$LIBOBJS getcwd.$ac_objext"
  fi
  
  fi
  
! echo "$as_me:12859: checking for presence of POSIX-style sigsetjmp/siglongjmp" >&5
! echo $ECHO_N "checking for presence of POSIX-style sigsetjmp/siglongjmp... $ECHO_C" >&6
! if test "${bash_cv_func_sigsetjmp+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
    if test "$cross_compiling" = yes; then
!   { echo "$as_me:12865: WARNING: cannot check for sigsetjmp/siglongjmp if cross-compiling -- defaulting to missing" >&5
! echo "$as_me: WARNING: cannot check for sigsetjmp/siglongjmp if cross-compiling -- defaulting to missing" >&2;}
       bash_cv_func_sigsetjmp=missing
  
  else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 12871 "configure"
  #include "confdefs.h"
  
***************
*** 7176,7197 ****
  #endif
  }
! EOF
! if { (eval echo configure:7180: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
! then
    bash_cv_func_sigsetjmp=present
  else
!   echo "configure: failed program was:" >&5
!   cat conftest.$ac_ext >&5
!   rm -fr conftest*
!   bash_cv_func_sigsetjmp=missing
  fi
! rm -fr conftest*
  fi
- 
  fi
  
! echo "$ac_t""$bash_cv_func_sigsetjmp" 1>&6
  if test $bash_cv_func_sigsetjmp = present; then
! cat >> confdefs.h <<\EOF
  #define HAVE_POSIX_SIGSETJMP 1
  EOF
--- 12909,12939 ----
  #endif
  }
! _ACEOF
! rm -f conftest$ac_exeext
! if { (eval echo "$as_me:12913: \"$ac_link\"") >&5
!   (eval $ac_link) 2>&5
!   ac_status=$?
!   echo "$as_me:12916: \$? = $ac_status" >&5
!   (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
!   { (eval echo "$as_me:12918: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:12921: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
    bash_cv_func_sigsetjmp=present
  else
!   echo "$as_me: program exited with status $ac_status" >&5
! echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! bash_cv_func_sigsetjmp=missing
  fi
! rm -f core core.* *.core conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
  fi
  fi
  
! echo "$as_me:12934: result: $bash_cv_func_sigsetjmp" >&5
! echo "${ECHO_T}$bash_cv_func_sigsetjmp" >&6
  if test $bash_cv_func_sigsetjmp = present; then
! cat >>confdefs.h <<\EOF
  #define HAVE_POSIX_SIGSETJMP 1
  EOF
***************
*** 7199,7215 ****
  fi
  
! 
! echo $ac_n "checking whether or not strcoll and strcmp differ""... $ac_c" 1>&6
! echo "configure:7204: checking whether or not strcoll and strcmp differ" >&5
! if eval "test \"`echo '$''{'bash_cv_func_strcoll_broken'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
    if test "$cross_compiling" = yes; then
!   echo "configure: warning: cannot check strcoll if cross compiling -- defaulting to no" 1>&2
      bash_cv_func_strcoll_broken=no
  
  else
!   cat > conftest.$ac_ext <<EOF
! #line 7214 "configure"
  #include "confdefs.h"
  
--- 12941,12957 ----
  fi
  
! echo "$as_me:12943: checking whether or not strcoll and strcmp differ" >&5
! echo $ECHO_N "checking whether or not strcoll and strcmp differ... $ECHO_C" >&6
! if test "${bash_cv_func_strcoll_broken+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
    if test "$cross_compiling" = yes; then
!   { echo "$as_me:12949: WARNING: cannot check strcoll if cross compiling -- defaulting to no" >&5
! echo "$as_me: WARNING: cannot check strcoll if cross compiling -- defaulting to no" >&2;}
      bash_cv_func_strcoll_broken=no
  
  else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 12955 "configure"
  #include "confdefs.h"
  
***************
*** 7249,7270 ****
  }
  
! EOF
! if { (eval echo configure:7253: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
! then
    bash_cv_func_strcoll_broken=yes
  else
!   echo "configure: failed program was:" >&5
!   cat conftest.$ac_ext >&5
!   rm -fr conftest*
!   bash_cv_func_strcoll_broken=no
  fi
! rm -fr conftest*
  fi
- 
  fi
  
! echo "$ac_t""$bash_cv_func_strcoll_broken" 1>&6
  if test $bash_cv_func_strcoll_broken = yes; then
! cat >> confdefs.h <<\EOF
  #define STRCOLL_BROKEN 1
  EOF
--- 12991,13021 ----
  }
  
! _ACEOF
! rm -f conftest$ac_exeext
! if { (eval echo "$as_me:12995: \"$ac_link\"") >&5
!   (eval $ac_link) 2>&5
!   ac_status=$?
!   echo "$as_me:12998: \$? = $ac_status" >&5
!   (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
!   { (eval echo "$as_me:13000: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:13003: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
    bash_cv_func_strcoll_broken=yes
  else
!   echo "$as_me: program exited with status $ac_status" >&5
! echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! bash_cv_func_strcoll_broken=no
  fi
! rm -f core core.* *.core conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
  fi
  fi
  
! echo "$as_me:13016: result: $bash_cv_func_strcoll_broken" >&5
! echo "${ECHO_T}$bash_cv_func_strcoll_broken" >&6
  if test $bash_cv_func_strcoll_broken = yes; then
! cat >>confdefs.h <<\EOF
  #define STRCOLL_BROKEN 1
  EOF
***************
*** 7272,7290 ****
  fi
  
  
  
  
! echo $ac_n "checking if signal handlers must be reinstalled when invoked""... $ac_c" 1>&6
! echo "configure:7279: checking if signal handlers must be reinstalled when invoked" >&5
! if eval "test \"`echo '$''{'bash_cv_must_reinstall_sighandlers'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
    if test "$cross_compiling" = yes; then
!   echo "configure: warning: cannot check signal handling if cross compiling -- defaulting to no" 1>&2
      bash_cv_must_reinstall_sighandlers=no
  
  else
!   cat > conftest.$ac_ext <<EOF
! #line 7289 "configure"
  #include "confdefs.h"
  
--- 13023,13099 ----
  fi
  
+ echo "$as_me:13025: checking for printf floating point output in hex notation" >&5
+ echo $ECHO_N "checking for printf floating point output in hex notation... $ECHO_C" >&6
+ if test "${bash_cv_printf_a_format+set}" = set; then
+   echo $ECHO_N "(cached) $ECHO_C" >&6
+ else
+   if test "$cross_compiling" = yes; then
+   { echo "$as_me:13031: WARNING: cannot check printf if cross compiling -- defaulting to no" >&5
+ echo "$as_me: WARNING: cannot check printf if cross compiling -- defaulting to no" >&2;}
+     bash_cv_printf_a_format=no
+ 
+ else
+   cat >conftest.$ac_ext <<_ACEOF
+ #line 13037 "configure"
+ #include "confdefs.h"
+ 
+ #include <stdio.h>
+ #include <string.h>
+ 
+ int
+ main()
+ {
+ 	double y = 0.0;
+ 	char abuf[1024];
+ 
+ 	sprintf(abuf, "%A", y);
+ 	exit(strchr(abuf, 'P') == (char *)0);
+ }
+ 
+ _ACEOF
+ rm -f conftest$ac_exeext
+ if { (eval echo "$as_me:13055: \"$ac_link\"") >&5
+   (eval $ac_link) 2>&5
+   ac_status=$?
+   echo "$as_me:13058: \$? = $ac_status" >&5
+   (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
+   { (eval echo "$as_me:13060: \"$ac_try\"") >&5
+   (eval $ac_try) 2>&5
+   ac_status=$?
+   echo "$as_me:13063: \$? = $ac_status" >&5
+   (exit $ac_status); }; }; then
+   bash_cv_printf_a_format=yes
+ else
+   echo "$as_me: program exited with status $ac_status" >&5
+ echo "$as_me: failed program was:" >&5
+ cat conftest.$ac_ext >&5
+ bash_cv_printf_a_format=no
+ fi
+ rm -f core core.* *.core conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+ fi
+ fi
  
+ echo "$as_me:13076: result: $bash_cv_printf_a_format" >&5
+ echo "${ECHO_T}$bash_cv_printf_a_format" >&6
+ if test $bash_cv_printf_a_format = yes; then
+ cat >>confdefs.h <<\EOF
+ #define HAVE_PRINTF_A_FORMAT 1
+ EOF
  
+ fi
  
! echo "$as_me:13085: checking if signal handlers must be reinstalled when invoked" >&5
! echo $ECHO_N "checking if signal handlers must be reinstalled when invoked... $ECHO_C" >&6
! if test "${bash_cv_must_reinstall_sighandlers+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
    if test "$cross_compiling" = yes; then
!   { echo "$as_me:13091: WARNING: cannot check signal handling if cross compiling -- defaulting to no" >&5
! echo "$as_me: WARNING: cannot check signal handling if cross compiling -- defaulting to no" >&2;}
      bash_cv_must_reinstall_sighandlers=no
  
  else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 13097 "configure"
  #include "confdefs.h"
  
***************
*** 7332,7353 ****
  }
  
! EOF
! if { (eval echo configure:7336: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
! then
    bash_cv_must_reinstall_sighandlers=no
  else
!   echo "configure: failed program was:" >&5
!   cat conftest.$ac_ext >&5
!   rm -fr conftest*
!   bash_cv_must_reinstall_sighandlers=yes
  fi
! rm -fr conftest*
  fi
- 
  fi
  
! echo "$ac_t""$bash_cv_must_reinstall_sighandlers" 1>&6
  if test $bash_cv_must_reinstall_sighandlers = yes; then
! cat >> confdefs.h <<\EOF
  #define MUST_REINSTALL_SIGHANDLERS 1
  EOF
--- 13141,13171 ----
  }
  
! _ACEOF
! rm -f conftest$ac_exeext
! if { (eval echo "$as_me:13145: \"$ac_link\"") >&5
!   (eval $ac_link) 2>&5
!   ac_status=$?
!   echo "$as_me:13148: \$? = $ac_status" >&5
!   (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
!   { (eval echo "$as_me:13150: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:13153: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
    bash_cv_must_reinstall_sighandlers=no
  else
!   echo "$as_me: program exited with status $ac_status" >&5
! echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! bash_cv_must_reinstall_sighandlers=yes
  fi
! rm -f core core.* *.core conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
  fi
  fi
  
! echo "$as_me:13166: result: $bash_cv_must_reinstall_sighandlers" >&5
! echo "${ECHO_T}$bash_cv_must_reinstall_sighandlers" >&6
  if test $bash_cv_must_reinstall_sighandlers = yes; then
! cat >>confdefs.h <<\EOF
  #define MUST_REINSTALL_SIGHANDLERS 1
  EOF
***************
*** 7355,7371 ****
  fi
  
! 
! echo $ac_n "checking for presence of necessary job control definitions""... $ac_c" 1>&6
! echo "configure:7360: checking for presence of necessary job control definitions" >&5
! if eval "test \"`echo '$''{'bash_cv_job_control_missing'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
    if test "$cross_compiling" = yes; then
!   echo "configure: warning: cannot check job control if cross-compiling -- defaulting to missing" 1>&2
       bash_cv_job_control_missing=missing
  
  else
!   cat > conftest.$ac_ext <<EOF
! #line 7370 "configure"
  #include "confdefs.h"
  
--- 13173,13189 ----
  fi
  
! echo "$as_me:13175: checking for presence of necessary job control definitions" >&5
! echo $ECHO_N "checking for presence of necessary job control definitions... $ECHO_C" >&6
! if test "${bash_cv_job_control_missing+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
    if test "$cross_compiling" = yes; then
!   { echo "$as_me:13181: WARNING: cannot check job control if cross-compiling -- defaulting to missing" >&5
! echo "$as_me: WARNING: cannot check job control if cross-compiling -- defaulting to missing" >&2;}
       bash_cv_job_control_missing=missing
  
  else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 13187 "configure"
  #include "confdefs.h"
  
***************
*** 7393,7397 ****
  
  /* process control */
! #if !defined (WNOHANG) || !defined (WUNTRACED) 
  exit(1);
  #endif
--- 13211,13215 ----
  
  /* process control */
! #if !defined (WNOHANG) || !defined (WUNTRACED)
  exit(1);
  #endif
***************
*** 7413,7434 ****
  exit(0);
  }
! EOF
! if { (eval echo configure:7417: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
! then
    bash_cv_job_control_missing=present
  else
!   echo "configure: failed program was:" >&5
!   cat conftest.$ac_ext >&5
!   rm -fr conftest*
!   bash_cv_job_control_missing=missing
  fi
! rm -fr conftest*
  fi
- 
  fi
  
! echo "$ac_t""$bash_cv_job_control_missing" 1>&6
  if test $bash_cv_job_control_missing = missing; then
! cat >> confdefs.h <<\EOF
  #define JOB_CONTROL_MISSING 1
  EOF
--- 13231,13261 ----
  exit(0);
  }
! _ACEOF
! rm -f conftest$ac_exeext
! if { (eval echo "$as_me:13235: \"$ac_link\"") >&5
!   (eval $ac_link) 2>&5
!   ac_status=$?
!   echo "$as_me:13238: \$? = $ac_status" >&5
!   (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
!   { (eval echo "$as_me:13240: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:13243: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
    bash_cv_job_control_missing=present
  else
!   echo "$as_me: program exited with status $ac_status" >&5
! echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! bash_cv_job_control_missing=missing
  fi
! rm -f core core.* *.core conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
  fi
  fi
  
! echo "$as_me:13256: result: $bash_cv_job_control_missing" >&5
! echo "${ECHO_T}$bash_cv_job_control_missing" >&6
  if test $bash_cv_job_control_missing = missing; then
! cat >>confdefs.h <<\EOF
  #define JOB_CONTROL_MISSING 1
  EOF
***************
*** 7436,7451 ****
  fi
  
! echo $ac_n "checking for presence of named pipes""... $ac_c" 1>&6
! echo "configure:7440: checking for presence of named pipes" >&5
! if eval "test \"`echo '$''{'bash_cv_sys_named_pipes'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
    if test "$cross_compiling" = yes; then
!   echo "configure: warning: cannot check for named pipes if cross-compiling -- defaulting to missing" 1>&2
       bash_cv_sys_named_pipes=missing
  
  else
!   cat > conftest.$ac_ext <<EOF
! #line 7450 "configure"
  #include "confdefs.h"
  
--- 13263,13279 ----
  fi
  
! echo "$as_me:13265: checking for presence of named pipes" >&5
! echo $ECHO_N "checking for presence of named pipes... $ECHO_C" >&6
! if test "${bash_cv_sys_named_pipes+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
    if test "$cross_compiling" = yes; then
!   { echo "$as_me:13271: WARNING: cannot check for named pipes if cross-compiling -- defaulting to missing" >&5
! echo "$as_me: WARNING: cannot check for named pipes if cross-compiling -- defaulting to missing" >&2;}
       bash_cv_sys_named_pipes=missing
  
  else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 13277 "configure"
  #include "confdefs.h"
  
***************
*** 7487,7508 ****
  exit(0);
  }
! EOF
! if { (eval echo configure:7491: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
! then
    bash_cv_sys_named_pipes=present
  else
!   echo "configure: failed program was:" >&5
!   cat conftest.$ac_ext >&5
!   rm -fr conftest*
!   bash_cv_sys_named_pipes=missing
  fi
! rm -fr conftest*
  fi
- 
  fi
  
! echo "$ac_t""$bash_cv_sys_named_pipes" 1>&6
  if test $bash_cv_sys_named_pipes = missing; then
! cat >> confdefs.h <<\EOF
  #define NAMED_PIPES_MISSING 1
  EOF
--- 13315,13345 ----
  exit(0);
  }
! _ACEOF
! rm -f conftest$ac_exeext
! if { (eval echo "$as_me:13319: \"$ac_link\"") >&5
!   (eval $ac_link) 2>&5
!   ac_status=$?
!   echo "$as_me:13322: \$? = $ac_status" >&5
!   (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
!   { (eval echo "$as_me:13324: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:13327: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
    bash_cv_sys_named_pipes=present
  else
!   echo "$as_me: program exited with status $ac_status" >&5
! echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! bash_cv_sys_named_pipes=missing
  fi
! rm -f core core.* *.core conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
  fi
  fi
  
! echo "$as_me:13340: result: $bash_cv_sys_named_pipes" >&5
! echo "${ECHO_T}$bash_cv_sys_named_pipes" >&6
  if test $bash_cv_sys_named_pipes = missing; then
! cat >>confdefs.h <<\EOF
  #define NAMED_PIPES_MISSING 1
  EOF
***************
*** 7510,7577 ****
  fi
  
  
! echo $ac_n "checking for TIOCGWINSZ in sys/ioctl.h""... $ac_c" 1>&6
! echo "configure:7515: checking for TIOCGWINSZ in sys/ioctl.h" >&5
! if eval "test \"`echo '$''{'bash_cv_tiocgwinsz_in_ioctl'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
!   cat > conftest.$ac_ext <<EOF
! #line 7520 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
  #include <sys/ioctl.h>
! int main() {
! int x = TIOCGWINSZ;
! ; return 0; }
! EOF
! if { (eval echo configure:7528: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
!   rm -rf conftest*
!   bash_cv_tiocgwinsz_in_ioctl=yes
  else
!   echo "configure: failed program was:" >&5
!   cat conftest.$ac_ext >&5
!   rm -rf conftest*
!   bash_cv_tiocgwinsz_in_ioctl=no
  fi
  rm -f conftest*
  fi
  
! echo "$ac_t""$bash_cv_tiocgwinsz_in_ioctl" 1>&6
! if test $bash_cv_tiocgwinsz_in_ioctl = yes; then   
! cat >> confdefs.h <<\EOF
  #define GWINSZ_IN_SYS_IOCTL 1
  EOF
  
  fi
  
! echo $ac_n "checking for TIOCSTAT in sys/ioctl.h""... $ac_c" 1>&6
! echo "configure:7549: checking for TIOCSTAT in sys/ioctl.h" >&5
! if eval "test \"`echo '$''{'bash_cv_tiocstat_in_ioctl'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
!   cat > conftest.$ac_ext <<EOF
! #line 7554 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
  #include <sys/ioctl.h>
! int main() {
  int x = TIOCSTAT;
! ; return 0; }
! EOF
! if { (eval echo configure:7562: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
!   rm -rf conftest*
    bash_cv_tiocstat_in_ioctl=yes
  else
!   echo "configure: failed program was:" >&5
!   cat conftest.$ac_ext >&5
!   rm -rf conftest*
!   bash_cv_tiocstat_in_ioctl=no
  fi
! rm -f conftest*
  fi
  
! echo "$ac_t""$bash_cv_tiocstat_in_ioctl" 1>&6
! if test $bash_cv_tiocstat_in_ioctl = yes; then   
! cat >> confdefs.h <<\EOF
  #define TIOCSTAT_IN_SYS_IOCTL 1
  EOF
--- 13347,13502 ----
  fi
  
+ echo "$as_me:13349: checking POSIX termios" >&5
+ echo $ECHO_N "checking POSIX termios... $ECHO_C" >&6
+ if test "${ac_cv_sys_posix_termios+set}" = set; then
+   echo $ECHO_N "(cached) $ECHO_C" >&6
+ else
+   cat >conftest.$ac_ext <<_ACEOF
+ #line 13355 "configure"
+ #include "confdefs.h"
+ #include <sys/types.h>
+ #include <unistd.h>
+ #include <termios.h>
+ int
+ main ()
+ {
+ /* SunOS 4.0.3 has termios.h but not the library calls.  */
+    tcgetattr(0, 0);
+   ;
+   return 0;
+ }
+ _ACEOF
+ rm -f conftest.$ac_objext conftest$ac_exeext
+ if { (eval echo "$as_me:13370: \"$ac_link\"") >&5
+   (eval $ac_link) 2>&5
+   ac_status=$?
+   echo "$as_me:13373: \$? = $ac_status" >&5
+   (exit $ac_status); } &&
+          { ac_try='test -s conftest$ac_exeext'
+   { (eval echo "$as_me:13376: \"$ac_try\"") >&5
+   (eval $ac_try) 2>&5
+   ac_status=$?
+   echo "$as_me:13379: \$? = $ac_status" >&5
+   (exit $ac_status); }; }; then
+   ac_cv_sys_posix_termios=yes
+ else
+   echo "$as_me: failed program was:" >&5
+ cat conftest.$ac_ext >&5
+ ac_cv_sys_posix_termios=no
+ fi
+ rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+ fi
+ echo "$as_me:13389: result: $ac_cv_sys_posix_termios" >&5
+ echo "${ECHO_T}$ac_cv_sys_posix_termios" >&6
+ 
+ if test $ac_cv_sys_posix_termios = yes; then
+   echo "$as_me:13393: checking whether termios.h defines TIOCGWINSZ" >&5
+ echo $ECHO_N "checking whether termios.h defines TIOCGWINSZ... $ECHO_C" >&6
+ if test "${ac_cv_sys_tiocgwinsz_in_termios_h+set}" = set; then
+   echo $ECHO_N "(cached) $ECHO_C" >&6
+ else
+   cat >conftest.$ac_ext <<_ACEOF
+ #line 13399 "configure"
+ #include "confdefs.h"
+ #include <sys/types.h>
+ #include <termios.h>
+ #ifdef TIOCGWINSZ
+   yes
+ #endif
+ 
+ _ACEOF
+ if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+   egrep "yes" >/dev/null 2>&1; then
+   ac_cv_sys_tiocgwinsz_in_termios_h=yes
+ else
+   ac_cv_sys_tiocgwinsz_in_termios_h=no
+ fi
+ rm -f conftest*
+ 
+ fi
+ echo "$as_me:13417: result: $ac_cv_sys_tiocgwinsz_in_termios_h" >&5
+ echo "${ECHO_T}$ac_cv_sys_tiocgwinsz_in_termios_h" >&6
  
! fi
! if test $ac_cv_sys_tiocgwinsz_in_termios_h != yes; then
!   echo "$as_me:13422: checking whether sys/ioctl.h defines TIOCGWINSZ" >&5
! echo $ECHO_N "checking whether sys/ioctl.h defines TIOCGWINSZ... $ECHO_C" >&6
! if test "${ac_cv_sys_tiocgwinsz_in_sys_ioctl_h+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 13428 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
  #include <sys/ioctl.h>
! #ifdef TIOCGWINSZ
!   yes
! #endif
! 
! _ACEOF
! if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
!   egrep "yes" >/dev/null 2>&1; then
!   ac_cv_sys_tiocgwinsz_in_sys_ioctl_h=yes
  else
!   ac_cv_sys_tiocgwinsz_in_sys_ioctl_h=no
  fi
  rm -f conftest*
+ 
  fi
+ echo "$as_me:13446: result: $ac_cv_sys_tiocgwinsz_in_sys_ioctl_h" >&5
+ echo "${ECHO_T}$ac_cv_sys_tiocgwinsz_in_sys_ioctl_h" >&6
+ 
+   if test $ac_cv_sys_tiocgwinsz_in_sys_ioctl_h = yes; then
  
! cat >>confdefs.h <<\EOF
  #define GWINSZ_IN_SYS_IOCTL 1
  EOF
  
+   fi
  fi
  
! echo "$as_me:13458: checking for TIOCSTAT in sys/ioctl.h" >&5
! echo $ECHO_N "checking for TIOCSTAT in sys/ioctl.h... $ECHO_C" >&6
! if test "${bash_cv_tiocstat_in_ioctl+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 13464 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
  #include <sys/ioctl.h>
! int
! main ()
! {
  int x = TIOCSTAT;
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext
! if { (eval echo "$as_me:13477: \"$ac_compile\"") >&5
!   (eval $ac_compile) 2>&5
!   ac_status=$?
!   echo "$as_me:13480: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest.$ac_objext'
!   { (eval echo "$as_me:13483: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:13486: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
    bash_cv_tiocstat_in_ioctl=yes
  else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! bash_cv_tiocstat_in_ioctl=no
  fi
! rm -f conftest.$ac_objext conftest.$ac_ext
  fi
  
! echo "$as_me:13497: result: $bash_cv_tiocstat_in_ioctl" >&5
! echo "${ECHO_T}$bash_cv_tiocstat_in_ioctl" >&6
! if test $bash_cv_tiocstat_in_ioctl = yes; then
! cat >>confdefs.h <<\EOF
  #define TIOCSTAT_IN_SYS_IOCTL 1
  EOF
***************
*** 7579,7611 ****
  fi
  
! echo $ac_n "checking for FIONREAD in sys/ioctl.h""... $ac_c" 1>&6
! echo "configure:7583: checking for FIONREAD in sys/ioctl.h" >&5
! if eval "test \"`echo '$''{'bash_cv_fionread_in_ioctl'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
!   cat > conftest.$ac_ext <<EOF
! #line 7588 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
  #include <sys/ioctl.h>
! int main() {
  int x = FIONREAD;
! ; return 0; }
! EOF
! if { (eval echo configure:7596: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
!   rm -rf conftest*
    bash_cv_fionread_in_ioctl=yes
  else
!   echo "configure: failed program was:" >&5
!   cat conftest.$ac_ext >&5
!   rm -rf conftest*
!   bash_cv_fionread_in_ioctl=no
  fi
! rm -f conftest*
  fi
  
! echo "$ac_t""$bash_cv_fionread_in_ioctl" 1>&6
! if test $bash_cv_fionread_in_ioctl = yes; then   
! cat >> confdefs.h <<\EOF
  #define FIONREAD_IN_SYS_IOCTL 1
  EOF
--- 13504,13550 ----
  fi
  
! echo "$as_me:13506: checking for FIONREAD in sys/ioctl.h" >&5
! echo $ECHO_N "checking for FIONREAD in sys/ioctl.h... $ECHO_C" >&6
! if test "${bash_cv_fionread_in_ioctl+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 13512 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
  #include <sys/ioctl.h>
! int
! main ()
! {
  int x = FIONREAD;
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext
! if { (eval echo "$as_me:13525: \"$ac_compile\"") >&5
!   (eval $ac_compile) 2>&5
!   ac_status=$?
!   echo "$as_me:13528: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest.$ac_objext'
!   { (eval echo "$as_me:13531: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:13534: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
    bash_cv_fionread_in_ioctl=yes
  else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! bash_cv_fionread_in_ioctl=no
  fi
! rm -f conftest.$ac_objext conftest.$ac_ext
  fi
  
! echo "$as_me:13545: result: $bash_cv_fionread_in_ioctl" >&5
! echo "${ECHO_T}$bash_cv_fionread_in_ioctl" >&6
! if test $bash_cv_fionread_in_ioctl = yes; then
! cat >>confdefs.h <<\EOF
  #define FIONREAD_IN_SYS_IOCTL 1
  EOF
***************
*** 7613,7645 ****
  fi
  
! 
! echo $ac_n "checking for speed_t in sys/types.h""... $ac_c" 1>&6
! echo "configure:7618: checking for speed_t in sys/types.h" >&5
! if eval "test \"`echo '$''{'bash_cv_speed_t_in_sys_types'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
!   cat > conftest.$ac_ext <<EOF
! #line 7623 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
! int main() {
  speed_t x;
! ; return 0; }
! EOF
! if { (eval echo configure:7630: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
!   rm -rf conftest*
    bash_cv_speed_t_in_sys_types=yes
  else
!   echo "configure: failed program was:" >&5
!   cat conftest.$ac_ext >&5
!   rm -rf conftest*
!   bash_cv_speed_t_in_sys_types=no
  fi
! rm -f conftest*
  fi
  
! echo "$ac_t""$bash_cv_speed_t_in_sys_types" 1>&6
! if test $bash_cv_speed_t_in_sys_types = yes; then   
! cat >> confdefs.h <<\EOF
  #define SPEED_T_IN_SYS_TYPES 1
  EOF
--- 13552,13597 ----
  fi
  
! echo "$as_me:13554: checking for speed_t in sys/types.h" >&5
! echo $ECHO_N "checking for speed_t in sys/types.h... $ECHO_C" >&6
! if test "${bash_cv_speed_t_in_sys_types+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 13560 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
! int
! main ()
! {
  speed_t x;
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext
! if { (eval echo "$as_me:13572: \"$ac_compile\"") >&5
!   (eval $ac_compile) 2>&5
!   ac_status=$?
!   echo "$as_me:13575: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest.$ac_objext'
!   { (eval echo "$as_me:13578: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:13581: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
    bash_cv_speed_t_in_sys_types=yes
  else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! bash_cv_speed_t_in_sys_types=no
  fi
! rm -f conftest.$ac_objext conftest.$ac_ext
  fi
  
! echo "$as_me:13592: result: $bash_cv_speed_t_in_sys_types" >&5
! echo "${ECHO_T}$bash_cv_speed_t_in_sys_types" >&6
! if test $bash_cv_speed_t_in_sys_types = yes; then
! cat >>confdefs.h <<\EOF
  #define SPEED_T_IN_SYS_TYPES 1
  EOF
***************
*** 7647,7657 ****
  fi
  
! echo $ac_n "checking whether getpw functions are declared in pwd.h""... $ac_c" 1>&6
! echo "configure:7651: checking whether getpw functions are declared in pwd.h" >&5
! if eval "test \"`echo '$''{'bash_cv_getpw_declared'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
!   cat > conftest.$ac_ext <<EOF
! #line 7656 "configure"
  #include "confdefs.h"
  
--- 13599,13609 ----
  fi
  
! echo "$as_me:13601: checking whether getpw functions are declared in pwd.h" >&5
! echo $ECHO_N "checking whether getpw functions are declared in pwd.h... $ECHO_C" >&6
! if test "${bash_cv_getpw_declared+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 13607 "configure"
  #include "confdefs.h"
  
***************
*** 7662,7672 ****
  #include <pwd.h>
  
! EOF
  if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
    egrep "getpwuid" >/dev/null 2>&1; then
-   rm -rf conftest*
    bash_cv_getpw_declared=yes
  else
-   rm -rf conftest*
    bash_cv_getpw_declared=no
  fi
--- 13614,13622 ----
  #include <pwd.h>
  
! _ACEOF
  if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
    egrep "getpwuid" >/dev/null 2>&1; then
    bash_cv_getpw_declared=yes
  else
    bash_cv_getpw_declared=no
  fi
***************
*** 7675,7681 ****
  fi
  
! echo "$ac_t""$bash_cv_getpw_declared" 1>&6
  if test $bash_cv_getpw_declared = yes; then
! cat >> confdefs.h <<\EOF
  #define HAVE_GETPW_DECLS 1
  EOF
--- 13625,13632 ----
  fi
  
! echo "$as_me:13627: result: $bash_cv_getpw_declared" >&5
! echo "${ECHO_T}$bash_cv_getpw_declared" >&6
  if test $bash_cv_getpw_declared = yes; then
! cat >>confdefs.h <<\EOF
  #define HAVE_GETPW_DECLS 1
  EOF
***************
*** 7683,7698 ****
  fi
  
! echo $ac_n "checking for unusable real-time signals due to large values""... $ac_c" 1>&6
! echo "configure:7687: checking for unusable real-time signals due to large values" >&5
! if eval "test \"`echo '$''{'bash_cv_unusable_rtsigs'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
    if test "$cross_compiling" = yes; then
!   echo "configure: warning: cannot check real-time signals if cross compiling -- defaulting to yes" 1>&2
       bash_cv_unusable_rtsigs=yes
  
  else
!   cat > conftest.$ac_ext <<EOF
! #line 7697 "configure"
  #include "confdefs.h"
  
--- 13634,13650 ----
  fi
  
! echo "$as_me:13636: checking for unusable real-time signals due to large values" >&5
! echo $ECHO_N "checking for unusable real-time signals due to large values... $ECHO_C" >&6
! if test "${bash_cv_unusable_rtsigs+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
    if test "$cross_compiling" = yes; then
!   { echo "$as_me:13642: WARNING: cannot check real-time signals if cross compiling -- defaulting to yes" >&5
! echo "$as_me: WARNING: cannot check real-time signals if cross compiling -- defaulting to yes" >&2;}
       bash_cv_unusable_rtsigs=yes
  
  else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 13648 "configure"
  #include "confdefs.h"
  
***************
*** 7715,7736 ****
    exit(rtmin < n_sigs);
  }
! EOF
! if { (eval echo configure:7719: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
! then
    bash_cv_unusable_rtsigs=yes
  else
!   echo "configure: failed program was:" >&5
!   cat conftest.$ac_ext >&5
!   rm -fr conftest*
!   bash_cv_unusable_rtsigs=no
  fi
! rm -fr conftest*
  fi
- 
  fi
  
! echo "$ac_t""$bash_cv_unusable_rtsigs" 1>&6
  if test $bash_cv_unusable_rtsigs = yes; then
! cat >> confdefs.h <<\EOF
  #define UNUSABLE_RT_SIGNALS 1
  EOF
--- 13667,13697 ----
    exit(rtmin < n_sigs);
  }
! _ACEOF
! rm -f conftest$ac_exeext
! if { (eval echo "$as_me:13671: \"$ac_link\"") >&5
!   (eval $ac_link) 2>&5
!   ac_status=$?
!   echo "$as_me:13674: \$? = $ac_status" >&5
!   (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
!   { (eval echo "$as_me:13676: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:13679: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
    bash_cv_unusable_rtsigs=yes
  else
!   echo "$as_me: program exited with status $ac_status" >&5
! echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! bash_cv_unusable_rtsigs=no
  fi
! rm -f core core.* *.core conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
  fi
  fi
  
! echo "$as_me:13692: result: $bash_cv_unusable_rtsigs" >&5
! echo "${ECHO_T}$bash_cv_unusable_rtsigs" >&6
  if test $bash_cv_unusable_rtsigs = yes; then
! cat >>confdefs.h <<\EOF
  #define UNUSABLE_RT_SIGNALS 1
  EOF
***************
*** 7738,7750 ****
  fi
  
  
  case "$host_os" in
! hpux*)	echo $ac_n "checking whether $host_os needs _KERNEL for RLIMIT defines""... $ac_c" 1>&6
! echo "configure:7744: checking whether $host_os needs _KERNEL for RLIMIT defines" >&5
! if eval "test \"`echo '$''{'bash_cv_kernel_rlimit'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
!   cat > conftest.$ac_ext <<EOF
! #line 7749 "configure"
  #include "confdefs.h"
  
--- 13699,13716 ----
  fi
  
+ if test "$bash_cv_sys_siglist" = no && test "$bash_cv_under_sys_siglist" = no && test "$bash_cv_have_strsignal" = no; then
+   SIGLIST_O=siglist.o
+ else
+   SIGLIST_O=
+ fi
  
  case "$host_os" in
! hpux*)	echo "$as_me:13708: checking whether $host_os needs _KERNEL for RLIMIT defines" >&5
! echo $ECHO_N "checking whether $host_os needs _KERNEL for RLIMIT defines... $ECHO_C" >&6
! if test "${bash_cv_kernel_rlimit+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 13714 "configure"
  #include "confdefs.h"
  
***************
*** 7752,7771 ****
  #include <sys/resource.h>
  
! int main() {
  
    int f;
    f = RLIMIT_DATA;
  
! ; return 0; }
! EOF
! if { (eval echo configure:7762: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
!   rm -rf conftest*
    bash_cv_kernel_rlimit=no
  else
!   echo "configure: failed program was:" >&5
!   cat conftest.$ac_ext >&5
!   rm -rf conftest*
!   cat > conftest.$ac_ext <<EOF
! #line 7770 "configure"
  #include "confdefs.h"
  
--- 13718,13750 ----
  #include <sys/resource.h>
  
! int
! main ()
! {
  
    int f;
    f = RLIMIT_DATA;
  
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext
! if { (eval echo "$as_me:13732: \"$ac_compile\"") >&5
!   (eval $ac_compile) 2>&5
!   ac_status=$?
!   echo "$as_me:13735: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest.$ac_objext'
!   { (eval echo "$as_me:13738: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:13741: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
    bash_cv_kernel_rlimit=no
  else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! cat >conftest.$ac_ext <<_ACEOF
! #line 13748 "configure"
  #include "confdefs.h"
  
***************
*** 7775,7803 ****
  #undef _KERNEL
  
! int main() {
  
  	int f;
          f = RLIMIT_DATA;
  
! ; return 0; }
! EOF
! if { (eval echo configure:7785: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
!   rm -rf conftest*
    bash_cv_kernel_rlimit=yes
  else
!   echo "configure: failed program was:" >&5
!   cat conftest.$ac_ext >&5
!   rm -rf conftest*
!   bash_cv_kernel_rlimit=no
  fi
! rm -f conftest*
  
  fi
! rm -f conftest*
  fi
  
! echo "$ac_t""$bash_cv_kernel_rlimit" 1>&6
  if test $bash_cv_kernel_rlimit = yes; then
! cat >> confdefs.h <<\EOF
  #define RLIMIT_NEEDS_KERNEL 1
  EOF
--- 13754,13796 ----
  #undef _KERNEL
  
! int
! main ()
! {
  
  	int f;
          f = RLIMIT_DATA;
  
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext
! if { (eval echo "$as_me:13768: \"$ac_compile\"") >&5
!   (eval $ac_compile) 2>&5
!   ac_status=$?
!   echo "$as_me:13771: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest.$ac_objext'
!   { (eval echo "$as_me:13774: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:13777: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
    bash_cv_kernel_rlimit=yes
  else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! bash_cv_kernel_rlimit=no
  fi
! rm -f conftest.$ac_objext conftest.$ac_ext
  
  fi
! rm -f conftest.$ac_objext conftest.$ac_ext
  fi
  
! echo "$as_me:13791: result: $bash_cv_kernel_rlimit" >&5
! echo "${ECHO_T}$bash_cv_kernel_rlimit" >&6
  if test $bash_cv_kernel_rlimit = yes; then
! cat >>confdefs.h <<\EOF
  #define RLIMIT_NEEDS_KERNEL 1
  EOF
***************
*** 7815,7941 ****
  _bash_needmsg=yes
  else
! echo $ac_n "checking which library has the termcap functions""... $ac_c" 1>&6
! echo "configure:7819: checking which library has the termcap functions" >&5
  _bash_needmsg=
  fi
! if eval "test \"`echo '$''{'bash_cv_termcap_lib'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
!   echo $ac_n "checking for tgetent in -ltermcap""... $ac_c" 1>&6
! echo "configure:7826: checking for tgetent in -ltermcap" >&5
! ac_lib_var=`echo termcap'_'tgetent | sed 'y%./+-%__p_%'`
! if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
!   ac_save_LIBS="$LIBS"
  LIBS="-ltermcap  $LIBS"
! cat > conftest.$ac_ext <<EOF
! #line 7834 "configure"
  #include "confdefs.h"
  /* Override any gcc2 internal prototype to avoid an error.  */
  /* We use char because int might match the return type of a gcc2
!     builtin and then its argument prototype would still apply.  */
! char tgetent();
! 
! int main() {
! tgetent()
! ; return 0; }
! EOF
! if { (eval echo configure:7845: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
!   rm -rf conftest*
!   eval "ac_cv_lib_$ac_lib_var=yes"
! else
!   echo "configure: failed program was:" >&5
!   cat conftest.$ac_ext >&5
!   rm -rf conftest*
!   eval "ac_cv_lib_$ac_lib_var=no"
! fi
! rm -f conftest*
! LIBS="$ac_save_LIBS"
! 
! fi
! if eval "test \"`echo '$ac_cv_lib_'$ac_lib_var`\" = yes"; then
!   echo "$ac_t""yes" 1>&6
    bash_cv_termcap_lib=libtermcap
  else
!   echo "$ac_t""no" 1>&6
! echo $ac_n "checking for tgetent in -lcurses""... $ac_c" 1>&6
! echo "configure:7864: checking for tgetent in -lcurses" >&5
! ac_lib_var=`echo curses'_'tgetent | sed 'y%./+-%__p_%'`
! if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
! else
!   ac_save_LIBS="$LIBS"
! LIBS="-lcurses  $LIBS"
! cat > conftest.$ac_ext <<EOF
! #line 7872 "configure"
  #include "confdefs.h"
  /* Override any gcc2 internal prototype to avoid an error.  */
  /* We use char because int might match the return type of a gcc2
!     builtin and then its argument prototype would still apply.  */
! char tgetent();
! 
! int main() {
! tgetent()
! ; return 0; }
! EOF
! if { (eval echo configure:7883: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
!   rm -rf conftest*
!   eval "ac_cv_lib_$ac_lib_var=yes"
  else
!   echo "configure: failed program was:" >&5
!   cat conftest.$ac_ext >&5
!   rm -rf conftest*
!   eval "ac_cv_lib_$ac_lib_var=no"
! fi
! rm -f conftest*
! LIBS="$ac_save_LIBS"
  
! fi
! if eval "test \"`echo '$ac_cv_lib_'$ac_lib_var`\" = yes"; then
!   echo "$ac_t""yes" 1>&6
    bash_cv_termcap_lib=libcurses
  else
!   echo "$ac_t""no" 1>&6
! echo $ac_n "checking for tgetent in -lncurses""... $ac_c" 1>&6
! echo "configure:7902: checking for tgetent in -lncurses" >&5
! ac_lib_var=`echo ncurses'_'tgetent | sed 'y%./+-%__p_%'`
! if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
!   ac_save_LIBS="$LIBS"
  LIBS="-lncurses  $LIBS"
! cat > conftest.$ac_ext <<EOF
! #line 7910 "configure"
  #include "confdefs.h"
  /* Override any gcc2 internal prototype to avoid an error.  */
  /* We use char because int might match the return type of a gcc2
!     builtin and then its argument prototype would still apply.  */
! char tgetent();
! 
! int main() {
! tgetent()
! ; return 0; }
! EOF
! if { (eval echo configure:7921: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
!   rm -rf conftest*
!   eval "ac_cv_lib_$ac_lib_var=yes"
  else
!   echo "configure: failed program was:" >&5
!   cat conftest.$ac_ext >&5
!   rm -rf conftest*
!   eval "ac_cv_lib_$ac_lib_var=no"
  fi
- rm -f conftest*
- LIBS="$ac_save_LIBS"
  
  fi
- if eval "test \"`echo '$ac_cv_lib_'$ac_lib_var`\" = yes"; then
-   echo "$ac_t""yes" 1>&6
-   bash_cv_termcap_lib=libncurses
- else
-   echo "$ac_t""no" 1>&6
- bash_cv_termcap_lib=gnutermcap
- fi
  
  fi
--- 13808,14030 ----
  _bash_needmsg=yes
  else
! echo "$as_me:13810: checking which library has the termcap functions" >&5
! echo $ECHO_N "checking which library has the termcap functions... $ECHO_C" >&6
  _bash_needmsg=
  fi
! if test "${bash_cv_termcap_lib+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
!   echo "$as_me:13817: checking for tgetent in -ltermcap" >&5
! echo $ECHO_N "checking for tgetent in -ltermcap... $ECHO_C" >&6
! if test "${ac_cv_lib_termcap_tgetent+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
!   ac_check_lib_save_LIBS=$LIBS
  LIBS="-ltermcap  $LIBS"
! cat >conftest.$ac_ext <<_ACEOF
! #line 13825 "configure"
  #include "confdefs.h"
+ 
  /* Override any gcc2 internal prototype to avoid an error.  */
+ #ifdef __cplusplus
+ extern "C"
+ #endif
  /* We use char because int might match the return type of a gcc2
!    builtin and then its argument prototype would still apply.  */
! char tgetent ();
! int
! main ()
! {
! tgetent ();
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext conftest$ac_exeext
! if { (eval echo "$as_me:13844: \"$ac_link\"") >&5
!   (eval $ac_link) 2>&5
!   ac_status=$?
!   echo "$as_me:13847: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest$ac_exeext'
!   { (eval echo "$as_me:13850: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:13853: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   ac_cv_lib_termcap_tgetent=yes
! else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! ac_cv_lib_termcap_tgetent=no
! fi
! rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
! LIBS=$ac_check_lib_save_LIBS
! fi
! echo "$as_me:13864: result: $ac_cv_lib_termcap_tgetent" >&5
! echo "${ECHO_T}$ac_cv_lib_termcap_tgetent" >&6
! if test $ac_cv_lib_termcap_tgetent = yes; then
    bash_cv_termcap_lib=libtermcap
  else
!   echo "$as_me:13869: checking for tgetent in -ltinfo" >&5
! echo $ECHO_N "checking for tgetent in -ltinfo... $ECHO_C" >&6
! if test "${ac_cv_lib_tinfo_tgetent+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
! else
!   ac_check_lib_save_LIBS=$LIBS
! LIBS="-ltinfo  $LIBS"
! cat >conftest.$ac_ext <<_ACEOF
! #line 13877 "configure"
  #include "confdefs.h"
+ 
  /* Override any gcc2 internal prototype to avoid an error.  */
+ #ifdef __cplusplus
+ extern "C"
+ #endif
  /* We use char because int might match the return type of a gcc2
!    builtin and then its argument prototype would still apply.  */
! char tgetent ();
! int
! main ()
! {
! tgetent ();
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext conftest$ac_exeext
! if { (eval echo "$as_me:13896: \"$ac_link\"") >&5
!   (eval $ac_link) 2>&5
!   ac_status=$?
!   echo "$as_me:13899: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest$ac_exeext'
!   { (eval echo "$as_me:13902: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:13905: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   ac_cv_lib_tinfo_tgetent=yes
! else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! ac_cv_lib_tinfo_tgetent=no
! fi
! rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
! LIBS=$ac_check_lib_save_LIBS
! fi
! echo "$as_me:13916: result: $ac_cv_lib_tinfo_tgetent" >&5
! echo "${ECHO_T}$ac_cv_lib_tinfo_tgetent" >&6
! if test $ac_cv_lib_tinfo_tgetent = yes; then
!   bash_cv_termcal_lib=libtinfo
! else
!   echo "$as_me:13921: checking for tgetent in -lcurses" >&5
! echo $ECHO_N "checking for tgetent in -lcurses... $ECHO_C" >&6
! if test "${ac_cv_lib_curses_tgetent+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
!   ac_check_lib_save_LIBS=$LIBS
! LIBS="-lcurses  $LIBS"
! cat >conftest.$ac_ext <<_ACEOF
! #line 13929 "configure"
! #include "confdefs.h"
  
! /* Override any gcc2 internal prototype to avoid an error.  */
! #ifdef __cplusplus
! extern "C"
! #endif
! /* We use char because int might match the return type of a gcc2
!    builtin and then its argument prototype would still apply.  */
! char tgetent ();
! int
! main ()
! {
! tgetent ();
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext conftest$ac_exeext
! if { (eval echo "$as_me:13948: \"$ac_link\"") >&5
!   (eval $ac_link) 2>&5
!   ac_status=$?
!   echo "$as_me:13951: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest$ac_exeext'
!   { (eval echo "$as_me:13954: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:13957: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   ac_cv_lib_curses_tgetent=yes
! else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! ac_cv_lib_curses_tgetent=no
! fi
! rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
! LIBS=$ac_check_lib_save_LIBS
! fi
! echo "$as_me:13968: result: $ac_cv_lib_curses_tgetent" >&5
! echo "${ECHO_T}$ac_cv_lib_curses_tgetent" >&6
! if test $ac_cv_lib_curses_tgetent = yes; then
    bash_cv_termcap_lib=libcurses
  else
!   echo "$as_me:13973: checking for tgetent in -lncurses" >&5
! echo $ECHO_N "checking for tgetent in -lncurses... $ECHO_C" >&6
! if test "${ac_cv_lib_ncurses_tgetent+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
!   ac_check_lib_save_LIBS=$LIBS
  LIBS="-lncurses  $LIBS"
! cat >conftest.$ac_ext <<_ACEOF
! #line 13981 "configure"
  #include "confdefs.h"
+ 
  /* Override any gcc2 internal prototype to avoid an error.  */
+ #ifdef __cplusplus
+ extern "C"
+ #endif
  /* We use char because int might match the return type of a gcc2
!    builtin and then its argument prototype would still apply.  */
! char tgetent ();
! int
! main ()
! {
! tgetent ();
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext conftest$ac_exeext
! if { (eval echo "$as_me:14000: \"$ac_link\"") >&5
!   (eval $ac_link) 2>&5
!   ac_status=$?
!   echo "$as_me:14003: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest$ac_exeext'
!   { (eval echo "$as_me:14006: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:14009: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   ac_cv_lib_ncurses_tgetent=yes
! else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! ac_cv_lib_ncurses_tgetent=no
! fi
! rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
! LIBS=$ac_check_lib_save_LIBS
! fi
! echo "$as_me:14020: result: $ac_cv_lib_ncurses_tgetent" >&5
! echo "${ECHO_T}$ac_cv_lib_ncurses_tgetent" >&6
! if test $ac_cv_lib_ncurses_tgetent = yes; then
!   bash_cv_termcap_lib=libncurses
  else
!   bash_cv_termcap_lib=gnutermcap
  fi
  
  fi
  
  fi
***************
*** 7946,7953 ****
  
  if test "X$_bash_needmsg" = "Xyes"; then
! echo $ac_n "checking which library has the termcap functions""... $ac_c" 1>&6
! echo "configure:7950: checking which library has the termcap functions" >&5
  fi
! echo "$ac_t""using $bash_cv_termcap_lib" 1>&6
  if test $bash_cv_termcap_lib = gnutermcap && test -z "$prefer_curses"; then
  LDFLAGS="$LDFLAGS -L./lib/termcap"
--- 14035,14043 ----
  
  if test "X$_bash_needmsg" = "Xyes"; then
! echo "$as_me:14037: checking which library has the termcap functions" >&5
! echo $ECHO_N "checking which library has the termcap functions... $ECHO_C" >&6
  fi
! echo "$as_me:14040: result: using $bash_cv_termcap_lib" >&5
! echo "${ECHO_T}using $bash_cv_termcap_lib" >&6
  if test $bash_cv_termcap_lib = gnutermcap && test -z "$prefer_curses"; then
  LDFLAGS="$LDFLAGS -L./lib/termcap"
***************
*** 7957,7960 ****
--- 14047,14053 ----
  TERMCAP_LIB=-ltermcap
  TERMCAP_DEP=
+ elif test $bash_cv_termcap_lib = libtinfo; then
+ TERMCAP_LIB=-ltinfo
+ TERMCAP_DEP=
  elif test $bash_cv_termcap_lib = libncurses; then
  TERMCAP_LIB=-lncurses
***************
*** 7967,7976 ****
  fi
  
! 
! 
! echo $ac_n "checking whether /dev/fd is available""... $ac_c" 1>&6
! echo "configure:7973: checking whether /dev/fd is available" >&5
! if eval "test \"`echo '$''{'bash_cv_dev_fd'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
    if test -d /dev/fd  && test -r /dev/fd/0; then
--- 14060,14067 ----
  fi
  
! echo "$as_me:14062: checking whether /dev/fd is available" >&5
! echo $ECHO_N "checking whether /dev/fd is available... $ECHO_C" >&6
! if test "${bash_cv_dev_fd+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
    if test -d /dev/fd  && test -r /dev/fd/0; then
***************
*** 7984,8003 ****
  fi
  
! echo "$ac_t""$bash_cv_dev_fd" 1>&6
  if test $bash_cv_dev_fd = "standard"; then
!   cat >> confdefs.h <<\EOF
  #define HAVE_DEV_FD 1
  EOF
  
!   cat >> confdefs.h <<\EOF
  #define DEV_FD_PREFIX "/dev/fd/"
  EOF
  
  elif test $bash_cv_dev_fd = "whacky"; then
!   cat >> confdefs.h <<\EOF
  #define HAVE_DEV_FD 1
  EOF
  
!   cat >> confdefs.h <<\EOF
  #define DEV_FD_PREFIX "/proc/self/fd/"
  EOF
--- 14075,14095 ----
  fi
  
! echo "$as_me:14077: result: $bash_cv_dev_fd" >&5
! echo "${ECHO_T}$bash_cv_dev_fd" >&6
  if test $bash_cv_dev_fd = "standard"; then
!   cat >>confdefs.h <<\EOF
  #define HAVE_DEV_FD 1
  EOF
  
!   cat >>confdefs.h <<\EOF
  #define DEV_FD_PREFIX "/dev/fd/"
  EOF
  
  elif test $bash_cv_dev_fd = "whacky"; then
!   cat >>confdefs.h <<\EOF
  #define HAVE_DEV_FD 1
  EOF
  
!   cat >>confdefs.h <<\EOF
  #define DEV_FD_PREFIX "/proc/self/fd/"
  EOF
***************
*** 8005,8012 ****
  fi
  
! echo $ac_n "checking whether /dev/stdin stdout stderr are available""... $ac_c" 1>&6
! echo "configure:8009: checking whether /dev/stdin stdout stderr are available" >&5
! if eval "test \"`echo '$''{'bash_cv_dev_stdin'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
    if test -d /dev/fd && test -r /dev/stdin; then
--- 14097,14104 ----
  fi
  
! echo "$as_me:14099: checking whether /dev/stdin stdout stderr are available" >&5
! echo $ECHO_N "checking whether /dev/stdin stdout stderr are available... $ECHO_C" >&6
! if test "${bash_cv_dev_stdin+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
    if test -d /dev/fd && test -r /dev/stdin; then
***************
*** 8020,8026 ****
  fi
  
! echo "$ac_t""$bash_cv_dev_stdin" 1>&6
  if test $bash_cv_dev_stdin = "present"; then
!   cat >> confdefs.h <<\EOF
  #define HAVE_DEV_STDIN 1
  EOF
--- 14112,14119 ----
  fi
  
! echo "$as_me:14114: result: $bash_cv_dev_stdin" >&5
! echo "${ECHO_T}$bash_cv_dev_stdin" >&6
  if test $bash_cv_dev_stdin = "present"; then
!   cat >>confdefs.h <<\EOF
  #define HAVE_DEV_STDIN 1
  EOF
***************
*** 8028,8035 ****
  fi
  
! echo $ac_n "checking for default mail directory""... $ac_c" 1>&6
! echo "configure:8032: checking for default mail directory" >&5
! if eval "test \"`echo '$''{'bash_cv_mail_dir'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
    if test -d /var/mail; then
--- 14121,14128 ----
  fi
  
! echo "$as_me:14123: checking for default mail directory" >&5
! echo $ECHO_N "checking for default mail directory... $ECHO_C" >&6
! if test "${bash_cv_mail_dir+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
    if test -d /var/mail; then
***************
*** 8047,8073 ****
  fi
  
! echo "$ac_t""$bash_cv_mail_dir" 1>&6
  if test $bash_cv_mail_dir = "/var/mail"; then
!    cat >> confdefs.h <<\EOF
  #define DEFAULT_MAIL_DIRECTORY "/var/mail"
  EOF
  
  elif test $bash_cv_mail_dir = "/usr/mail"; then
!    cat >> confdefs.h <<\EOF
  #define DEFAULT_MAIL_DIRECTORY "/usr/mail"
  EOF
  
  elif test $bash_cv_mail_dir = "/var/spool/mail"; then
!    cat >> confdefs.h <<\EOF
  #define DEFAULT_MAIL_DIRECTORY "/var/spool/mail"
  EOF
  
  elif test $bash_cv_mail_dir = "/usr/spool/mail"; then
!    cat >> confdefs.h <<\EOF
  #define DEFAULT_MAIL_DIRECTORY "/usr/spool/mail"
  EOF
  
  else
!    cat >> confdefs.h <<\EOF
  #define DEFAULT_MAIL_DIRECTORY "unknown"
  EOF
--- 14140,14167 ----
  fi
  
! echo "$as_me:14142: result: $bash_cv_mail_dir" >&5
! echo "${ECHO_T}$bash_cv_mail_dir" >&6
  if test $bash_cv_mail_dir = "/var/mail"; then
!    cat >>confdefs.h <<\EOF
  #define DEFAULT_MAIL_DIRECTORY "/var/mail"
  EOF
  
  elif test $bash_cv_mail_dir = "/usr/mail"; then
!    cat >>confdefs.h <<\EOF
  #define DEFAULT_MAIL_DIRECTORY "/usr/mail"
  EOF
  
  elif test $bash_cv_mail_dir = "/var/spool/mail"; then
!    cat >>confdefs.h <<\EOF
  #define DEFAULT_MAIL_DIRECTORY "/var/spool/mail"
  EOF
  
  elif test $bash_cv_mail_dir = "/usr/spool/mail"; then
!    cat >>confdefs.h <<\EOF
  #define DEFAULT_MAIL_DIRECTORY "/usr/spool/mail"
  EOF
  
  else
!    cat >>confdefs.h <<\EOF
  #define DEFAULT_MAIL_DIRECTORY "unknown"
  EOF
***************
*** 8075,8079 ****
  fi
  
- 
  if test "$bash_cv_job_control_missing" = missing; then
  	opt_job_control=no
--- 14169,14172 ----
***************
*** 8081,8085 ****
  
  if test "$opt_job_control" = yes; then
! cat >> confdefs.h <<\EOF
  #define JOB_CONTROL 1
  EOF
--- 14174,14178 ----
  
  if test "$opt_job_control" = yes; then
! cat >>confdefs.h <<\EOF
  #define JOB_CONTROL 1
  EOF
***************
*** 8090,8113 ****
  fi
  
- 
- 
- 
  LOCAL_DEFS=-DSHELL
  
- 
  case "${host_os}" in
! sysv4.2*)	cat >> confdefs.h <<\EOF
  #define SVR4_2 1
  EOF
  
! 		cat >> confdefs.h <<\EOF
  #define SVR4 1
  EOF
   ;;
! sysv4*)		cat >> confdefs.h <<\EOF
  #define SVR4 1
  EOF
   ;;
! sysv5*)		cat >> confdefs.h <<\EOF
  #define SVR5 1
  EOF
--- 14183,14202 ----
  fi
  
  LOCAL_DEFS=-DSHELL
  
  case "${host_os}" in
! sysv4.2*)	cat >>confdefs.h <<\EOF
  #define SVR4_2 1
  EOF
  
! 		cat >>confdefs.h <<\EOF
  #define SVR4 1
  EOF
   ;;
! sysv4*)		cat >>confdefs.h <<\EOF
  #define SVR4 1
  EOF
   ;;
! sysv5*)		cat >>confdefs.h <<\EOF
  #define SVR5 1
  EOF
***************
*** 8118,8121 ****
--- 14207,14211 ----
  isc*)		LOCAL_CFLAGS=-Disc386 ;;
  rhapsody*)	LOCAL_CFLAGS=-DRHAPSODY ;;
+ darwin*)	LOCAL_CFLAGS=-DMACOSX ;;
  sco3.2v5*)	LOCAL_CFLAGS="-b elf -DWAITPID_BROKEN -DNO_MEMSCRAMBLE -DPATH_MAX=1024" ;;
  sco3.2v4*)	LOCAL_CFLAGS="-DMUST_UNBLOCK_CHLD -DNO_MEMSCRAMBLE -DPATH_MAX=1024" ;;
***************
*** 8128,8132 ****
  powerux*)	LOCAL_LIBS="-lgen" ;;
  cygwin*)	LOCAL_LIBS="-luser32" ;;
! opennt*|interix*) LOCAL_CFLAGS="-DNO_MAIN_ENV_ARG" ;;
  esac
  
--- 14218,14222 ----
  powerux*)	LOCAL_LIBS="-lgen" ;;
  cygwin*)	LOCAL_LIBS="-luser32" ;;
! opennt*|interix*) LOCAL_CFLAGS="-DNO_MAIN_ENV_ARG -DBROKEN_DIRENT_D_INO" ;;
  esac
  
***************
*** 8164,8178 ****
  if test "$ac_cv_func_dlopen" = "yes" && test -f ${srcdir}/support/shobj-conf
  then
! 	echo $ac_n "checking shared object configuration for loadable builtins""... $ac_c" 1>&6
! echo "configure:8168: checking shared object configuration for loadable builtins" >&5
  	eval `${CONFIG_SHELL-/bin/sh} ${srcdir}/support/shobj-conf -C "${CC}" -c "${host_cpu}" -o "${host_os}" -v "${host_vendor}"`
! 	
! 	
! 	
! 	
! 	
! 	
! 	
! 	echo "$ac_t""$SHOBJ_STATUS" 1>&6
  fi
  
--- 14254,14263 ----
  if test "$ac_cv_func_dlopen" = "yes" && test -f ${srcdir}/support/shobj-conf
  then
! 	echo "$as_me:14256: checking shared object configuration for loadable builtins" >&5
! echo $ECHO_N "checking shared object configuration for loadable builtins... $ECHO_C" >&6
  	eval `${CONFIG_SHELL-/bin/sh} ${srcdir}/support/shobj-conf -C "${CC}" -c "${host_cpu}" -o "${host_os}" -v "${host_vendor}"`
! 
! 	echo "$as_me:14260: result: $SHOBJ_STATUS" >&5
! echo "${ECHO_T}$SHOBJ_STATUS" >&6
  fi
  
***************
*** 8194,8238 ****
  BUILD_DIR=`pwd`
  
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
  #AC_SUBST(ALLOCA_SOURCE)
  #AC_SUBST(ALLOCA_OBJECT)
  
! trap '' 1 2 15
! cat > confcache <<\EOF
  # This file is a shell script that caches the results of configure
  # tests run on this system so they can be shared between configure
! # scripts and configure runs.  It is not useful on other systems.
! # If it contains results you don't want to keep, you may remove or edit it.
  #
! # By default, configure uses ./config.cache as the cache file,
! # creating it if it does not exist already.  You can give configure
! # the --cache-file=FILE option to use a different cache file; that is
! # what configure does when it calls configure scripts in
! # subdirectories, so they share the cache.
! # Giving --cache-file=/dev/null disables caching, for debugging configure.
! # config.status only pays attention to the cache file if you give it the
! # --recheck option to rerun configure.
  #
! EOF
  # The following way of writing the cache mishandles newlines in values,
  # but we know of no workaround that is simple, portable, and efficient.
--- 14279,14303 ----
  BUILD_DIR=`pwd`
  
  #AC_SUBST(ALLOCA_SOURCE)
  #AC_SUBST(ALLOCA_OBJECT)
  
! ac_config_files="$ac_config_files Makefile builtins/Makefile lib/readline/Makefile lib/glob/Makefile lib/malloc/Makefile lib/sh/Makefile lib/termcap/Makefile lib/tilde/Makefile doc/Makefile support/Makefile examples/loadables/Makefile examples/loadables/perl/Makefile"
! ac_config_commands="$ac_config_commands default"
! cat >confcache <<\_ACEOF
  # This file is a shell script that caches the results of configure
  # tests run on this system so they can be shared between configure
! # scripts and configure runs, see configure's option --config-cache.
! # It is not useful on other systems.  If it contains results you don't
! # want to keep, you may remove or edit it.
  #
! # config.status only pays attention to the cache file if you give it
! # the --recheck option to rerun configure.
  #
! # `ac_cv_env_foo' variables (set or unset) will be overriden when
! # loading this file, other *unset* `ac_cv_foo' will be assigned the
! # following values.
! 
! _ACEOF
! 
  # The following way of writing the cache mishandles newlines in values,
  # but we know of no workaround that is simple, portable, and efficient.
***************
*** 8240,8263 ****
  # Ultrix sh set writes to stderr and can't be redirected directly,
  # and sets the high bit in the cache file unless we assign to the vars.
! (set) 2>&1 |
!   case `(ac_space=' '; set | grep ac_space) 2>&1` in
!   *ac_space=\ *)
!     # `set' does not quote correctly, so add quotes (double-quote substitution
!     # turns \\\\ into \\, and sed turns \\ into \).
!     sed -n \
!       -e "s/'/'\\\\''/g" \
!       -e "s/^\\([a-zA-Z0-9_]*_cv_[a-zA-Z0-9_]*\\)=\\(.*\\)/\\1=\${\\1='\\2'}/p"
!     ;;
!   *)
!     # `set' quotes correctly as required by POSIX, so do not add quotes.
!     sed -n -e 's/^\([a-zA-Z0-9_]*_cv_[a-zA-Z0-9_]*\)=\(.*\)/\1=${\1=\2}/p'
!     ;;
!   esac >> confcache
! if cmp -s $cache_file confcache; then
!   :
! else
    if test -w $cache_file; then
!     echo "updating cache $cache_file"
!     cat confcache > $cache_file
    else
      echo "not updating unwritable cache $cache_file"
--- 14305,14336 ----
  # Ultrix sh set writes to stderr and can't be redirected directly,
  # and sets the high bit in the cache file unless we assign to the vars.
! {
!   (set) 2>&1 |
!     case `(ac_space=' '; set | grep ac_space) 2>&1` in
!     *ac_space=\ *)
!       # `set' does not quote correctly, so add quotes (double-quote
!       # substitution turns \\\\ into \\, and sed turns \\ into \).
!       sed -n \
!         "s/'/'\\\\''/g;
!     	  s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1='\\2'/p"
!       ;;
!     *)
!       # `set' quotes correctly as required by POSIX, so do not add quotes.
!       sed -n \
!         "s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1=\\2/p"
!       ;;
!     esac;
! } |
!   sed '
!      t clear
!      : clear
!      s/^\([^=]*\)=\(.*[{}].*\)$/test "${\1+set}" = set || &/
!      t end
!      /^ac_cv_env/!s/^\([^=]*\)=\(.*\)$/\1=${\1=\2}/
!      : end' >>confcache
! if cmp -s $cache_file confcache; then :; else
    if test -w $cache_file; then
!     test "x$cache_file" != "x/dev/null" && echo "updating cache $cache_file"
!     cat confcache >$cache_file
    else
      echo "not updating unwritable cache $cache_file"
***************
*** 8266,8511 ****
  rm -f confcache
  
- trap 'rm -fr conftest* confdefs* core core.* *.core $ac_clean_files; exit 1' 1 2 15
- 
  test "x$prefix" = xNONE && prefix=$ac_default_prefix
  # Let make expand exec_prefix.
  test "x$exec_prefix" = xNONE && exec_prefix='${prefix}'
  
! # Any assignment to VPATH causes Sun make to only execute
! # the first set of double-colon rules, so remove it if not needed.
! # If there is a colon in the path, we need to keep it.
  if test "x$srcdir" = x.; then
!   ac_vpsub='/^[ 	]*VPATH[ 	]*=[^:]*$/d'
  fi
  
- trap 'rm -f $CONFIG_STATUS conftest*; exit 1' 1 2 15
- 
  DEFS=-DHAVE_CONFIG_H
  
- # Without the "./", some shells look in PATH for config.status.
  : ${CONFIG_STATUS=./config.status}
! 
! echo creating $CONFIG_STATUS
! rm -f $CONFIG_STATUS
! cat > $CONFIG_STATUS <<EOF
! #! /bin/sh
  # Generated automatically by configure.
  # Run this file to recreate the current configuration.
- # This directory was configured as follows,
- # on host `(hostname || uname -n) 2>/dev/null | sed 1q`:
- #
- # $0 $ac_configure_args
- #
  # Compiler output produced by configure, useful for debugging
! # configure, is in ./config.log if it exists.
  
! ac_cs_usage="Usage: $CONFIG_STATUS [--recheck] [--version] [--help]"
! for ac_option
  do
!   case "\$ac_option" in
    -recheck | --recheck | --rechec | --reche | --rech | --rec | --re | --r)
!     echo "running \${CONFIG_SHELL-/bin/sh} $0 $ac_configure_args --no-create --no-recursion"
!     exec \${CONFIG_SHELL-/bin/sh} $0 $ac_configure_args --no-create --no-recursion ;;
!   -version | --version | --versio | --versi | --vers | --ver | --ve | --v)
!     echo "$CONFIG_STATUS generated by autoconf version 2.13"
!     exit 0 ;;
!   -help | --help | --hel | --he | --h)
!     echo "\$ac_cs_usage"; exit 0 ;;
!   *) echo "\$ac_cs_usage"; exit 1 ;;
    esac
  done
  
! ac_given_srcdir=$srcdir
! ac_given_INSTALL="$INSTALL"
  
! trap 'rm -fr `echo "Makefile builtins/Makefile lib/readline/Makefile lib/glob/Makefile \
! 	  lib/malloc/Makefile lib/sh/Makefile lib/termcap/Makefile \
! 	  lib/tilde/Makefile doc/Makefile support/Makefile \
! 	  examples/loadables/Makefile examples/loadables/perl/Makefile config.h" | sed "s/:[^ ]*//g"` conftest*; exit 1' 1 2 15
! EOF
! cat >> $CONFIG_STATUS <<EOF
! 
! # Protect against being on the right side of a sed subst in config.status.
! sed 's/%@/@@/; s/@%/@@/; s/%g\$/@g/; /@g\$/s/[\\\\&%]/\\\\&/g;
!  s/@@/%@/; s/@@/@%/; s/@g\$/%g/' > conftest.subs <<\\CEOF
! $ac_vpsub
! $extrasub
! s%@SHELL@%$SHELL%g
! s%@CFLAGS@%$CFLAGS%g
! s%@CPPFLAGS@%$CPPFLAGS%g
! s%@CXXFLAGS@%$CXXFLAGS%g
! s%@FFLAGS@%$FFLAGS%g
! s%@DEFS@%$DEFS%g
! s%@LDFLAGS@%$LDFLAGS%g
! s%@LIBS@%$LIBS%g
! s%@exec_prefix@%$exec_prefix%g
! s%@prefix@%$prefix%g
! s%@program_transform_name@%$program_transform_name%g
! s%@bindir@%$bindir%g
! s%@sbindir@%$sbindir%g
! s%@libexecdir@%$libexecdir%g
! s%@datadir@%$datadir%g
! s%@sysconfdir@%$sysconfdir%g
! s%@sharedstatedir@%$sharedstatedir%g
! s%@localstatedir@%$localstatedir%g
! s%@libdir@%$libdir%g
! s%@includedir@%$includedir%g
! s%@oldincludedir@%$oldincludedir%g
! s%@infodir@%$infodir%g
! s%@mandir@%$mandir%g
! s%@host@%$host%g
! s%@host_alias@%$host_alias%g
! s%@host_cpu@%$host_cpu%g
! s%@host_vendor@%$host_vendor%g
! s%@host_os@%$host_os%g
! s%@TESTSCRIPT@%$TESTSCRIPT%g
! s%@PURIFY@%$PURIFY%g
! s%@MALLOC_TARGET@%$MALLOC_TARGET%g
! s%@MALLOC_SRC@%$MALLOC_SRC%g
! s%@htmldir@%$htmldir%g
! s%@CC@%$CC%g
! s%@CPP@%$CPP%g
! s%@EXEEXT@%$EXEEXT%g
! s%@SIGNAMES_H@%$SIGNAMES_H%g
! s%@CC_FOR_BUILD@%$CC_FOR_BUILD%g
! s%@STATIC_LD@%$STATIC_LD%g
! s%@READLINE_LIB@%$READLINE_LIB%g
! s%@READLINE_DEP@%$READLINE_DEP%g
! s%@RL_LIBDIR@%$RL_LIBDIR%g
! s%@RL_INCLUDE@%$RL_INCLUDE%g
! s%@HISTORY_LIB@%$HISTORY_LIB%g
! s%@HISTORY_DEP@%$HISTORY_DEP%g
! s%@HIST_LIBDIR@%$HIST_LIBDIR%g
! s%@INSTALL_PROGRAM@%$INSTALL_PROGRAM%g
! s%@INSTALL_SCRIPT@%$INSTALL_SCRIPT%g
! s%@INSTALL_DATA@%$INSTALL_DATA%g
! s%@AR@%$AR%g
! s%@RANLIB@%$RANLIB%g
! s%@YACC@%$YACC%g
! s%@SET_MAKE@%$SET_MAKE%g
! s%@MAKE_SHELL@%$MAKE_SHELL%g
! s%@ALLOCA@%$ALLOCA%g
! s%@TERMCAP_LIB@%$TERMCAP_LIB%g
! s%@TERMCAP_DEP@%$TERMCAP_DEP%g
! s%@JOBS_O@%$JOBS_O%g
! s%@SHOBJ_CC@%$SHOBJ_CC%g
! s%@SHOBJ_CFLAGS@%$SHOBJ_CFLAGS%g
! s%@SHOBJ_LD@%$SHOBJ_LD%g
! s%@SHOBJ_LDFLAGS@%$SHOBJ_LDFLAGS%g
! s%@SHOBJ_XLDFLAGS@%$SHOBJ_XLDFLAGS%g
! s%@SHOBJ_LIBS@%$SHOBJ_LIBS%g
! s%@SHOBJ_STATUS@%$SHOBJ_STATUS%g
! s%@PROFILE_FLAGS@%$PROFILE_FLAGS%g
! s%@incdir@%$incdir%g
! s%@BUILD_DIR@%$BUILD_DIR%g
! s%@ARFLAGS@%$ARFLAGS%g
! s%@BASHVERS@%$BASHVERS%g
! s%@BASHPATCH@%$BASHPATCH%g
! s%@LOCAL_LIBS@%$LOCAL_LIBS%g
! s%@LOCAL_CFLAGS@%$LOCAL_CFLAGS%g
! s%@LOCAL_LDFLAGS@%$LOCAL_LDFLAGS%g
! s%@LOCAL_DEFS@%$LOCAL_DEFS%g
  
! CEOF
  EOF
  
! cat >> $CONFIG_STATUS <<\EOF
! 
! # Split the substitutions into bite-sized pieces for seds with
! # small command number limits, like on Digital OSF/1 and HP-UX.
! ac_max_sed_cmds=90 # Maximum number of lines to put in a sed script.
! ac_file=1 # Number of current file.
! ac_beg=1 # First line for current file.
! ac_end=$ac_max_sed_cmds # Line after last line for current file.
! ac_more_lines=:
! ac_sed_cmds=""
! while $ac_more_lines; do
!   if test $ac_beg -gt 1; then
!     sed "1,${ac_beg}d; ${ac_end}q" conftest.subs > conftest.s$ac_file
!   else
!     sed "${ac_end}q" conftest.subs > conftest.s$ac_file
!   fi
!   if test ! -s conftest.s$ac_file; then
!     ac_more_lines=false
!     rm -f conftest.s$ac_file
!   else
!     if test -z "$ac_sed_cmds"; then
!       ac_sed_cmds="sed -f conftest.s$ac_file"
!     else
!       ac_sed_cmds="$ac_sed_cmds | sed -f conftest.s$ac_file"
!     fi
!     ac_file=`expr $ac_file + 1`
!     ac_beg=$ac_end
!     ac_end=`expr $ac_end + $ac_max_sed_cmds`
!   fi
  done
! if test -z "$ac_sed_cmds"; then
!   ac_sed_cmds=cat
  fi
  EOF
  
! cat >> $CONFIG_STATUS <<EOF
  
- CONFIG_FILES=\${CONFIG_FILES-"Makefile builtins/Makefile lib/readline/Makefile lib/glob/Makefile \
- 	  lib/malloc/Makefile lib/sh/Makefile lib/termcap/Makefile \
- 	  lib/tilde/Makefile doc/Makefile support/Makefile \
- 	  examples/loadables/Makefile examples/loadables/perl/Makefile"}
  EOF
! cat >> $CONFIG_STATUS <<\EOF
! for ac_file in .. $CONFIG_FILES; do if test "x$ac_file" != x..; then
    # Support "outfile[:infile[:infile...]]", defaulting infile="outfile.in".
!   case "$ac_file" in
!   *:*) ac_file_in=`echo "$ac_file"|sed 's%[^:]*:%%'`
!        ac_file=`echo "$ac_file"|sed 's%:.*%%'` ;;
!   *) ac_file_in="${ac_file}.in" ;;
    esac
  
!   # Adjust a relative srcdir, top_srcdir, and INSTALL for subdirectories.
! 
!   # Remove last slash and all that follows it.  Not all systems have dirname.
!   ac_dir=`echo $ac_file|sed 's%/[^/][^/]*$%%'`
    if test "$ac_dir" != "$ac_file" && test "$ac_dir" != .; then
!     # The file is in a subdirectory.
!     test ! -d "$ac_dir" && mkdir "$ac_dir"
!     ac_dir_suffix="/`echo $ac_dir|sed 's%^\./%%'`"
      # A "../" for each directory in $ac_dir_suffix.
!     ac_dots=`echo $ac_dir_suffix|sed 's%/[^/]*%../%g'`
    else
      ac_dir_suffix= ac_dots=
    fi
  
!   case "$ac_given_srcdir" in
!   .)  srcdir=.
!       if test -z "$ac_dots"; then top_srcdir=.
!       else top_srcdir=`echo $ac_dots|sed 's%/$%%'`; fi ;;
!   /*) srcdir="$ac_given_srcdir$ac_dir_suffix"; top_srcdir="$ac_given_srcdir" ;;
    *) # Relative path.
!     srcdir="$ac_dots$ac_given_srcdir$ac_dir_suffix"
!     top_srcdir="$ac_dots$ac_given_srcdir" ;;
    esac
  
!   case "$ac_given_INSTALL" in
!   [/$]*) INSTALL="$ac_given_INSTALL" ;;
!   *) INSTALL="$ac_dots$ac_given_INSTALL" ;;
    esac
  
!   echo creating "$ac_file"
!   rm -f "$ac_file"
!   configure_input="Generated automatically from `echo $ac_file_in|sed 's%.*/%%'` by configure."
!   case "$ac_file" in
!   *Makefile*) ac_comsub="1i\\
! # $configure_input" ;;
!   *) ac_comsub= ;;
!   esac
  
!   ac_file_inputs=`echo $ac_file_in|sed -e "s%^%$ac_given_srcdir/%" -e "s%:% $ac_given_srcdir/%g"`
!   sed -e "$ac_comsub
! s%@configure_input@%$configure_input%g
! s%@srcdir@%$srcdir%g
! s%@top_srcdir@%$top_srcdir%g
! s%@INSTALL@%$INSTALL%g
! " $ac_file_inputs | (eval "$ac_sed_cmds") > $ac_file
! fi; done
! rm -f conftest.s*
  
  # These sed commands are passed to sed as "A NAME B NAME C VALUE D", where
--- 14339,14941 ----
  rm -f confcache
  
  test "x$prefix" = xNONE && prefix=$ac_default_prefix
  # Let make expand exec_prefix.
  test "x$exec_prefix" = xNONE && exec_prefix='${prefix}'
  
! # VPATH may cause trouble with some makes, so we remove $(srcdir),
! # ${srcdir} and @srcdir@ from VPATH if srcdir is ".", strip leading and
! # trailing colons and then remove the whole line if VPATH becomes empty
! # (actually we leave an empty line to preserve line numbers).
  if test "x$srcdir" = x.; then
!   ac_vpsub='/^[ 	]*VPATH[ 	]*=/{
! s/:*\$(srcdir):*/:/;
! s/:*\${srcdir}:*/:/;
! s/:*@srcdir@:*/:/;
! s/^\([^=]*=[ 	]*\):*/\1/;
! s/:*$//;
! s/^[^=]*=[ 	]*$//;
! }'
  fi
  
  DEFS=-DHAVE_CONFIG_H
  
  : ${CONFIG_STATUS=./config.status}
! ac_clean_files_save=$ac_clean_files
! ac_clean_files="$ac_clean_files $CONFIG_STATUS"
! { echo "$as_me:14365: creating $CONFIG_STATUS" >&5
! echo "$as_me: creating $CONFIG_STATUS" >&6;}
! cat >$CONFIG_STATUS <<_ACEOF
! #! $SHELL
  # Generated automatically by configure.
  # Run this file to recreate the current configuration.
  # Compiler output produced by configure, useful for debugging
! # configure, is in config.log if it exists.
  
! debug=false
! SHELL=\${CONFIG_SHELL-$SHELL}
! ac_cs_invocation="\$0 \$@"
! 
! _ACEOF
! 
! cat >>$CONFIG_STATUS <<\_ACEOF
! # Be Bourne compatible
! if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then
!   emulate sh
!   NULLCMD=:
! elif test -n "${BASH_VERSION+set}" && (set -o posix) >/dev/null 2>&1; then
!   set -o posix
! fi
! 
! # Name of the executable.
! as_me=`echo "$0" |sed 's,.*[\\/],,'`
! 
! if expr a : '\(a\)' >/dev/null 2>&1; then
!   as_expr=expr
! else
!   as_expr=false
! fi
! 
! rm -f conf$$ conf$$.exe conf$$.file
! echo >conf$$.file
! if ln -s conf$$.file conf$$ 2>/dev/null; then
!   # We could just check for DJGPP; but this test a) works b) is more generic
!   # and c) will remain valid once DJGPP supports symlinks (DJGPP 2.04).
!   if test -f conf$$.exe; then
!     # Don't use ln at all; we don't have any links
!     as_ln_s='cp -p'
!   else
!     as_ln_s='ln -s'
!   fi
! elif ln conf$$.file conf$$ 2>/dev/null; then
!   as_ln_s=ln
! else
!   as_ln_s='cp -p'
! fi
! rm -f conf$$ conf$$.exe conf$$.file
! 
! as_executable_p="test -f"
! 
! # Support unset when possible.
! if (FOO=FOO; unset FOO) >/dev/null 2>&1; then
!   as_unset=unset
! else
!   as_unset=false
! fi
! 
! # NLS nuisances.
! $as_unset LANG || test "${LANG+set}" != set || { LANG=C; export LANG; }
! $as_unset LC_ALL || test "${LC_ALL+set}" != set || { LC_ALL=C; export LC_ALL; }
! $as_unset LC_TIME || test "${LC_TIME+set}" != set || { LC_TIME=C; export LC_TIME; }
! $as_unset LC_CTYPE || test "${LC_CTYPE+set}" != set || { LC_CTYPE=C; export LC_CTYPE; }
! $as_unset LANGUAGE || test "${LANGUAGE+set}" != set || { LANGUAGE=C; export LANGUAGE; }
! $as_unset LC_COLLATE || test "${LC_COLLATE+set}" != set || { LC_COLLATE=C; export LC_COLLATE; }
! $as_unset LC_NUMERIC || test "${LC_NUMERIC+set}" != set || { LC_NUMERIC=C; export LC_NUMERIC; }
! $as_unset LC_MESSAGES || test "${LC_MESSAGES+set}" != set || { LC_MESSAGES=C; export LC_MESSAGES; }
! 
! # IFS
! # We need space, tab and new line, in precisely that order.
! as_nl='
! '
! IFS=" 	$as_nl"
! 
! # CDPATH.
! $as_unset CDPATH || test "${CDPATH+set}" != set || { CDPATH=:; export CDPATH; }
! 
! exec 6>&1
! 
! _ACEOF
! 
! # Files that config.status was made for.
! if test -n "$ac_config_files"; then
!   echo "config_files=\"$ac_config_files\"" >>$CONFIG_STATUS
! fi
! 
! if test -n "$ac_config_headers"; then
!   echo "config_headers=\"$ac_config_headers\"" >>$CONFIG_STATUS
! fi
! 
! if test -n "$ac_config_links"; then
!   echo "config_links=\"$ac_config_links\"" >>$CONFIG_STATUS
! fi
! 
! if test -n "$ac_config_commands"; then
!   echo "config_commands=\"$ac_config_commands\"" >>$CONFIG_STATUS
! fi
! 
! cat >>$CONFIG_STATUS <<\EOF
! 
! ac_cs_usage="\
! \`$as_me' instantiates files from templates according to the
! current configuration.
! 
! Usage: $0 [OPTIONS] [FILE]...
! 
!   -h, --help       print this help, then exit
!   -V, --version    print version number, then exit
!   -d, --debug      don't remove temporary files
!       --recheck    update $as_me by reconfiguring in the same conditions
!   --file=FILE[:TEMPLATE]
!                    instantiate the configuration file FILE
!   --header=FILE[:TEMPLATE]
!                    instantiate the configuration header FILE
! 
! Configuration files:
! $config_files
! 
! Configuration headers:
! $config_headers
! 
! Configuration commands:
! $config_commands
! 
! Report bugs to <bug-autoconf@gnu.org>."
! EOF
! 
! cat >>$CONFIG_STATUS <<EOF
! ac_cs_version="\\
! bash config.status 2.05a
! configured by $0, generated by GNU Autoconf 2.52,
!   with options \\"`echo "$ac_configure_args" | sed 's/[\\""\`\$]/\\\\&/g'`\\"
! 
! Copyright 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001
! Free Software Foundation, Inc.
! This config.status script is free software; the Free Software Foundation
! gives unlimited permission to copy, distribute and modify it."
! srcdir=$srcdir
! INSTALL="$INSTALL"
! EOF
! 
! cat >>$CONFIG_STATUS <<\EOF
! # If no file are specified by the user, then we need to provide default
! # value.  By we need to know if files were specified by the user.
! ac_need_defaults=:
! while test $# != 0
  do
!   case $1 in
!   --*=*)
!     ac_option=`expr "x$1" : 'x\([^=]*\)='`
!     ac_optarg=`expr "x$1" : 'x[^=]*=\(.*\)'`
!     shift
!     set dummy "$ac_option" "$ac_optarg" ${1+"$@"}
!     shift
!     ;;
!   -*);;
!   *) # This is not an option, so the user has probably given explicit
!      # arguments.
!      ac_need_defaults=false;;
!   esac
! 
!   case $1 in
!   # Handling of the options.
! EOF
! cat >>$CONFIG_STATUS <<EOF
    -recheck | --recheck | --rechec | --reche | --rech | --rec | --re | --r)
!     echo "running $SHELL $0 " $ac_configure_args " --no-create --no-recursion"
!     exec $SHELL $0 $ac_configure_args --no-create --no-recursion ;;
! EOF
! cat >>$CONFIG_STATUS <<\EOF
!   --version | --vers* | -V )
!     echo "$ac_cs_version"; exit 0 ;;
!   --he | --h)
!     # Conflict between --help and --header
!     { { echo "$as_me:14541: error: ambiguous option: $1
! Try \`$0 --help' for more information." >&5
! echo "$as_me: error: ambiguous option: $1
! Try \`$0 --help' for more information." >&2;}
!    { (exit 1); exit 1; }; };;
!   --help | --hel | -h )
!     echo "$ac_cs_usage"; exit 0 ;;
!   --debug | --d* | -d )
!     debug=: ;;
!   --file | --fil | --fi | --f )
!     shift
!     CONFIG_FILES="$CONFIG_FILES $1"
!     ac_need_defaults=false;;
!   --header | --heade | --head | --hea )
!     shift
!     CONFIG_HEADERS="$CONFIG_HEADERS $1"
!     ac_need_defaults=false;;
! 
!   # This is an error.
!   -*) { { echo "$as_me:14560: error: unrecognized option: $1
! Try \`$0 --help' for more information." >&5
! echo "$as_me: error: unrecognized option: $1
! Try \`$0 --help' for more information." >&2;}
!    { (exit 1); exit 1; }; } ;;
! 
!   *) ac_config_targets="$ac_config_targets $1" ;;
! 
    esac
+   shift
  done
  
! exec 5>>config.log
! cat >&5 << _ACEOF
  
! ## ----------------------- ##
! ## Running config.status.  ##
! ## ----------------------- ##
! 
! This file was extended by $as_me (bash 2.05a) 2.52, executed with
!   CONFIG_FILES    = $CONFIG_FILES
!   CONFIG_HEADERS  = $CONFIG_HEADERS
!   CONFIG_LINKS    = $CONFIG_LINKS
!   CONFIG_COMMANDS = $CONFIG_COMMANDS
!   > $ac_cs_invocation
! on `(hostname || uname -n) 2>/dev/null | sed 1q`
  
! _ACEOF
  EOF
  
! cat >>$CONFIG_STATUS <<\EOF
! for ac_config_target in $ac_config_targets
! do
!   case "$ac_config_target" in
!   # Handling of arguments.
!   "Makefile" ) CONFIG_FILES="$CONFIG_FILES Makefile" ;;
!   "builtins/Makefile" ) CONFIG_FILES="$CONFIG_FILES builtins/Makefile" ;;
!   "lib/readline/Makefile" ) CONFIG_FILES="$CONFIG_FILES lib/readline/Makefile" ;;
!   "lib/glob/Makefile" ) CONFIG_FILES="$CONFIG_FILES lib/glob/Makefile" ;;
!   "lib/malloc/Makefile" ) CONFIG_FILES="$CONFIG_FILES lib/malloc/Makefile" ;;
!   "lib/sh/Makefile" ) CONFIG_FILES="$CONFIG_FILES lib/sh/Makefile" ;;
!   "lib/termcap/Makefile" ) CONFIG_FILES="$CONFIG_FILES lib/termcap/Makefile" ;;
!   "lib/tilde/Makefile" ) CONFIG_FILES="$CONFIG_FILES lib/tilde/Makefile" ;;
!   "doc/Makefile" ) CONFIG_FILES="$CONFIG_FILES doc/Makefile" ;;
!   "support/Makefile" ) CONFIG_FILES="$CONFIG_FILES support/Makefile" ;;
!   "examples/loadables/Makefile" ) CONFIG_FILES="$CONFIG_FILES examples/loadables/Makefile" ;;
!   "examples/loadables/perl/Makefile" ) CONFIG_FILES="$CONFIG_FILES examples/loadables/perl/Makefile" ;;
!   "default" ) CONFIG_COMMANDS="$CONFIG_COMMANDS default" ;;
!   "config.h" ) CONFIG_HEADERS="$CONFIG_HEADERS config.h" ;;
!   *) { { echo "$as_me:14609: error: invalid argument: $ac_config_target" >&5
! echo "$as_me: error: invalid argument: $ac_config_target" >&2;}
!    { (exit 1); exit 1; }; };;
!   esac
  done
! 
! # If the user did not use the arguments to specify the items to instantiate,
! # then the envvar interface is used.  Set only those that are not.
! # We use the long form for the default assignment because of an extremely
! # bizarre bug on SunOS 4.1.3.
! if $ac_need_defaults; then
!   test "${CONFIG_FILES+set}" = set || CONFIG_FILES=$config_files
!   test "${CONFIG_HEADERS+set}" = set || CONFIG_HEADERS=$config_headers
!   test "${CONFIG_COMMANDS+set}" = set || CONFIG_COMMANDS=$config_commands
  fi
+ 
+ # Create a temporary directory, and hook for its removal unless debugging.
+ $debug ||
+ {
+   trap 'exit_status=$?; rm -rf $tmp && exit $exit_status' 0
+   trap '{ (exit 1); exit 1; }' 1 2 13 15
+ }
+ 
+ # Create a (secure) tmp directory for tmp files.
+ : ${TMPDIR=/tmp}
+ {
+   tmp=`(umask 077 && mktemp -d -q "$TMPDIR/csXXXXXX") 2>/dev/null` &&
+   test -n "$tmp" && test -d "$tmp"
+ }  ||
+ {
+   tmp=$TMPDIR/cs$$-$RANDOM
+   (umask 077 && mkdir $tmp)
+ } ||
+ {
+    echo "$me: cannot create a temporary directory in $TMPDIR" >&2
+    { (exit 1); exit 1; }
+ }
+ 
+ EOF
+ 
+ cat >>$CONFIG_STATUS <<EOF
+ 
+ #
+ # CONFIG_FILES section.
+ #
+ 
+ # No need to generate the scripts if there are no CONFIG_FILES.
+ # This happens for instance when ./config.status config.h
+ if test -n "\$CONFIG_FILES"; then
+   # Protect against being on the right side of a sed subst in config.status.
+   sed 's/,@/@@/; s/@,/@@/; s/,;t t\$/@;t t/; /@;t t\$/s/[\\\\&,]/\\\\&/g;
+    s/@@/,@/; s/@@/@,/; s/@;t t\$/,;t t/' >\$tmp/subs.sed <<\\CEOF
+ s,@SHELL@,$SHELL,;t t
+ s,@exec_prefix@,$exec_prefix,;t t
+ s,@prefix@,$prefix,;t t
+ s,@program_transform_name@,$program_transform_name,;t t
+ s,@bindir@,$bindir,;t t
+ s,@sbindir@,$sbindir,;t t
+ s,@libexecdir@,$libexecdir,;t t
+ s,@datadir@,$datadir,;t t
+ s,@sysconfdir@,$sysconfdir,;t t
+ s,@sharedstatedir@,$sharedstatedir,;t t
+ s,@localstatedir@,$localstatedir,;t t
+ s,@libdir@,$libdir,;t t
+ s,@includedir@,$includedir,;t t
+ s,@oldincludedir@,$oldincludedir,;t t
+ s,@infodir@,$infodir,;t t
+ s,@mandir@,$mandir,;t t
+ s,@PACKAGE_NAME@,$PACKAGE_NAME,;t t
+ s,@PACKAGE_TARNAME@,$PACKAGE_TARNAME,;t t
+ s,@PACKAGE_VERSION@,$PACKAGE_VERSION,;t t
+ s,@PACKAGE_STRING@,$PACKAGE_STRING,;t t
+ s,@PACKAGE_BUGREPORT@,$PACKAGE_BUGREPORT,;t t
+ s,@build_alias@,$build_alias,;t t
+ s,@host_alias@,$host_alias,;t t
+ s,@target_alias@,$target_alias,;t t
+ s,@ECHO_C@,$ECHO_C,;t t
+ s,@ECHO_N@,$ECHO_N,;t t
+ s,@ECHO_T@,$ECHO_T,;t t
+ s,@PATH_SEPARATOR@,$PATH_SEPARATOR,;t t
+ s,@DEFS@,$DEFS,;t t
+ s,@LIBS@,$LIBS,;t t
+ s,@build@,$build,;t t
+ s,@build_cpu@,$build_cpu,;t t
+ s,@build_vendor@,$build_vendor,;t t
+ s,@build_os@,$build_os,;t t
+ s,@host@,$host,;t t
+ s,@host_cpu@,$host_cpu,;t t
+ s,@host_vendor@,$host_vendor,;t t
+ s,@host_os@,$host_os,;t t
+ s,@TESTSCRIPT@,$TESTSCRIPT,;t t
+ s,@PURIFY@,$PURIFY,;t t
+ s,@MALLOC_TARGET@,$MALLOC_TARGET,;t t
+ s,@MALLOC_SRC@,$MALLOC_SRC,;t t
+ s,@MALLOC_LIB@,$MALLOC_LIB,;t t
+ s,@MALLOC_LIBRARY@,$MALLOC_LIBRARY,;t t
+ s,@MALLOC_LDFLAGS@,$MALLOC_LDFLAGS,;t t
+ s,@MALLOC_DEP@,$MALLOC_DEP,;t t
+ s,@htmldir@,$htmldir,;t t
+ s,@CC@,$CC,;t t
+ s,@CFLAGS@,$CFLAGS,;t t
+ s,@LDFLAGS@,$LDFLAGS,;t t
+ s,@CPPFLAGS@,$CPPFLAGS,;t t
+ s,@ac_ct_CC@,$ac_ct_CC,;t t
+ s,@EXEEXT@,$EXEEXT,;t t
+ s,@OBJEXT@,$OBJEXT,;t t
+ s,@CPP@,$CPP,;t t
+ s,@SIGNAMES_H@,$SIGNAMES_H,;t t
+ s,@CC_FOR_BUILD@,$CC_FOR_BUILD,;t t
+ s,@STATIC_LD@,$STATIC_LD,;t t
+ s,@RL_VERSION@,$RL_VERSION,;t t
+ s,@RL_MAJOR@,$RL_MAJOR,;t t
+ s,@RL_MINOR@,$RL_MINOR,;t t
+ s,@READLINE_LIB@,$READLINE_LIB,;t t
+ s,@READLINE_DEP@,$READLINE_DEP,;t t
+ s,@RL_LIBDIR@,$RL_LIBDIR,;t t
+ s,@RL_INCLUDEDIR@,$RL_INCLUDEDIR,;t t
+ s,@RL_INCLUDE@,$RL_INCLUDE,;t t
+ s,@HISTORY_LIB@,$HISTORY_LIB,;t t
+ s,@HISTORY_DEP@,$HISTORY_DEP,;t t
+ s,@HIST_LIBDIR@,$HIST_LIBDIR,;t t
+ s,@INSTALL_PROGRAM@,$INSTALL_PROGRAM,;t t
+ s,@INSTALL_SCRIPT@,$INSTALL_SCRIPT,;t t
+ s,@INSTALL_DATA@,$INSTALL_DATA,;t t
+ s,@AR@,$AR,;t t
+ s,@RANLIB@,$RANLIB,;t t
+ s,@ac_ct_RANLIB@,$ac_ct_RANLIB,;t t
+ s,@YACC@,$YACC,;t t
+ s,@SET_MAKE@,$SET_MAKE,;t t
+ s,@MAKE_SHELL@,$MAKE_SHELL,;t t
+ s,@ALLOCA@,$ALLOCA,;t t
+ s,@LIBOBJS@,$LIBOBJS,;t t
+ s,@SIGLIST_O@,$SIGLIST_O,;t t
+ s,@TERMCAP_LIB@,$TERMCAP_LIB,;t t
+ s,@TERMCAP_DEP@,$TERMCAP_DEP,;t t
+ s,@JOBS_O@,$JOBS_O,;t t
+ s,@SHOBJ_CC@,$SHOBJ_CC,;t t
+ s,@SHOBJ_CFLAGS@,$SHOBJ_CFLAGS,;t t
+ s,@SHOBJ_LD@,$SHOBJ_LD,;t t
+ s,@SHOBJ_LDFLAGS@,$SHOBJ_LDFLAGS,;t t
+ s,@SHOBJ_XLDFLAGS@,$SHOBJ_XLDFLAGS,;t t
+ s,@SHOBJ_LIBS@,$SHOBJ_LIBS,;t t
+ s,@SHOBJ_STATUS@,$SHOBJ_STATUS,;t t
+ s,@PROFILE_FLAGS@,$PROFILE_FLAGS,;t t
+ s,@incdir@,$incdir,;t t
+ s,@BUILD_DIR@,$BUILD_DIR,;t t
+ s,@ARFLAGS@,$ARFLAGS,;t t
+ s,@BASHVERS@,$BASHVERS,;t t
+ s,@LOCAL_LIBS@,$LOCAL_LIBS,;t t
+ s,@LOCAL_CFLAGS@,$LOCAL_CFLAGS,;t t
+ s,@LOCAL_LDFLAGS@,$LOCAL_LDFLAGS,;t t
+ s,@LOCAL_DEFS@,$LOCAL_DEFS,;t t
+ CEOF
+ 
  EOF
  
!   cat >>$CONFIG_STATUS <<\EOF
!   # Split the substitutions into bite-sized pieces for seds with
!   # small command number limits, like on Digital OSF/1 and HP-UX.
!   ac_max_sed_lines=48
!   ac_sed_frag=1 # Number of current file.
!   ac_beg=1 # First line for current file.
!   ac_end=$ac_max_sed_lines # Line after last line for current file.
!   ac_more_lines=:
!   ac_sed_cmds=
!   while $ac_more_lines; do
!     if test $ac_beg -gt 1; then
!       sed "1,${ac_beg}d; ${ac_end}q" $tmp/subs.sed >$tmp/subs.frag
!     else
!       sed "${ac_end}q" $tmp/subs.sed >$tmp/subs.frag
!     fi
!     if test ! -s $tmp/subs.frag; then
!       ac_more_lines=false
!     else
!       # The purpose of the label and of the branching condition is to
!       # speed up the sed processing (if there are no `@' at all, there
!       # is no need to browse any of the substitutions).
!       # These are the two extra sed commands mentioned above.
!       (echo ':t
!   /@[a-zA-Z_][a-zA-Z_0-9]*@/!b' && cat $tmp/subs.frag) >$tmp/subs-$ac_sed_frag.sed
!       if test -z "$ac_sed_cmds"; then
!   	ac_sed_cmds="sed -f $tmp/subs-$ac_sed_frag.sed"
!       else
!   	ac_sed_cmds="$ac_sed_cmds | sed -f $tmp/subs-$ac_sed_frag.sed"
!       fi
!       ac_sed_frag=`expr $ac_sed_frag + 1`
!       ac_beg=$ac_end
!       ac_end=`expr $ac_end + $ac_max_sed_lines`
!     fi
!   done
!   if test -z "$ac_sed_cmds"; then
!     ac_sed_cmds=cat
!   fi
! fi # test -n "$CONFIG_FILES"
  
  EOF
! cat >>$CONFIG_STATUS <<\EOF
! for ac_file in : $CONFIG_FILES; do test "x$ac_file" = x: && continue
    # Support "outfile[:infile[:infile...]]", defaulting infile="outfile.in".
!   case $ac_file in
!   - | *:- | *:-:* ) # input from stdin
!         cat >$tmp/stdin
!         ac_file_in=`echo "$ac_file" | sed 's,[^:]*:,,'`
!         ac_file=`echo "$ac_file" | sed 's,:.*,,'` ;;
!   *:* ) ac_file_in=`echo "$ac_file" | sed 's,[^:]*:,,'`
!         ac_file=`echo "$ac_file" | sed 's,:.*,,'` ;;
!   * )   ac_file_in=$ac_file.in ;;
    esac
  
!   # Compute @srcdir@, @top_srcdir@, and @INSTALL@ for subdirectories.
!   ac_dir=`$as_expr X"$ac_file" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
!          X"$ac_file" : 'X\(//\)[^/]' \| \
!          X"$ac_file" : 'X\(//\)$' \| \
!          X"$ac_file" : 'X\(/\)' \| \
!          .     : '\(.\)' 2>/dev/null ||
! echo X"$ac_file" |
!     sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
!   	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
!   	  /^X\(\/\/\)$/{ s//\1/; q; }
!   	  /^X\(\/\).*/{ s//\1/; q; }
!   	  s/.*/./; q'`
    if test "$ac_dir" != "$ac_file" && test "$ac_dir" != .; then
!     { case "$ac_dir" in
!   [\\/]* | ?:[\\/]* ) as_incr_dir=;;
!   *)                      as_incr_dir=.;;
! esac
! as_dummy="$ac_dir"
! for as_mkdir_dir in `IFS='/\\'; set X $as_dummy; shift; echo "$@"`; do
!   case $as_mkdir_dir in
!     # Skip DOS drivespec
!     ?:) as_incr_dir=$as_mkdir_dir ;;
!     *)
!       as_incr_dir=$as_incr_dir/$as_mkdir_dir
!       test -d "$as_incr_dir" || mkdir "$as_incr_dir"
!     ;;
!   esac
! done; }
! 
!     ac_dir_suffix="/`echo $ac_dir|sed 's,^\./,,'`"
      # A "../" for each directory in $ac_dir_suffix.
!     ac_dots=`echo "$ac_dir_suffix" | sed 's,/[^/]*,../,g'`
    else
      ac_dir_suffix= ac_dots=
    fi
  
!   case $srcdir in
!   .)  ac_srcdir=.
!       if test -z "$ac_dots"; then
!          ac_top_srcdir=.
!       else
!          ac_top_srcdir=`echo $ac_dots | sed 's,/$,,'`
!       fi ;;
!   [\\/]* | ?:[\\/]* )
!       ac_srcdir=$srcdir$ac_dir_suffix;
!       ac_top_srcdir=$srcdir ;;
    *) # Relative path.
!     ac_srcdir=$ac_dots$srcdir$ac_dir_suffix
!     ac_top_srcdir=$ac_dots$srcdir ;;
    esac
  
!   case $INSTALL in
!   [\\/$]* | ?:[\\/]* ) ac_INSTALL=$INSTALL ;;
!   *) ac_INSTALL=$ac_dots$INSTALL ;;
    esac
  
!   if test x"$ac_file" != x-; then
!     { echo "$as_me:14875: creating $ac_file" >&5
! echo "$as_me: creating $ac_file" >&6;}
!     rm -f "$ac_file"
!   fi
!   # Let's still pretend it is `configure' which instantiates (i.e., don't
!   # use $as_me), people would be surprised to read:
!   #    /* config.h.  Generated automatically by config.status.  */
!   configure_input="Generated automatically from `echo $ac_file_in |
!                                                  sed 's,.*/,,'` by configure."
! 
!   # First look for the input files in the build tree, otherwise in the
!   # src tree.
!   ac_file_inputs=`IFS=:
!     for f in $ac_file_in; do
!       case $f in
!       -) echo $tmp/stdin ;;
!       [\\/$]*)
!          # Absolute (can't be DOS-style, as IFS=:)
!          test -f "$f" || { { echo "$as_me:14893: error: cannot find input file: $f" >&5
! echo "$as_me: error: cannot find input file: $f" >&2;}
!    { (exit 1); exit 1; }; }
!          echo $f;;
!       *) # Relative
!          if test -f "$f"; then
!            # Build tree
!            echo $f
!          elif test -f "$srcdir/$f"; then
!            # Source tree
!            echo $srcdir/$f
!          else
!            # /dev/null tree
!            { { echo "$as_me:14906: error: cannot find input file: $f" >&5
! echo "$as_me: error: cannot find input file: $f" >&2;}
!    { (exit 1); exit 1; }; }
!          fi;;
!       esac
!     done` || { (exit 1); exit 1; }
! EOF
! cat >>$CONFIG_STATUS <<EOF
!   sed "$ac_vpsub
! $extrasub
! EOF
! cat >>$CONFIG_STATUS <<\EOF
! :t
! /@[a-zA-Z_][a-zA-Z_0-9]*@/!b
! s,@configure_input@,$configure_input,;t t
! s,@srcdir@,$ac_srcdir,;t t
! s,@top_srcdir@,$ac_top_srcdir,;t t
! s,@INSTALL@,$ac_INSTALL,;t t
! " $ac_file_inputs | (eval "$ac_sed_cmds") >$tmp/out
!   rm -f $tmp/stdin
!   if test x"$ac_file" != x-; then
!     mv $tmp/out $ac_file
!   else
!     cat $tmp/out
!     rm -f $tmp/out
!   fi
! 
! done
! EOF
! cat >>$CONFIG_STATUS <<\EOF
  
! #
! # CONFIG_HEADER section.
! #
  
  # These sed commands are passed to sed as "A NAME B NAME C VALUE D", where
***************
*** 8513,8632 ****
  #
  # ac_d sets the value in "#define NAME VALUE" lines.
! ac_dA='s%^\([ 	]*\)#\([ 	]*define[ 	][ 	]*\)'
! ac_dB='\([ 	][ 	]*\)[^ 	]*%\1#\2'
! ac_dC='\3'
! ac_dD='%g'
! # ac_u turns "#undef NAME" with trailing blanks into "#define NAME VALUE".
! ac_uA='s%^\([ 	]*\)#\([ 	]*\)undef\([ 	][ 	]*\)'
! ac_uB='\([ 	]\)%\1#\2define\3'
  ac_uC=' '
! ac_uD='\4%g'
! # ac_e turns "#undef NAME" without trailing blanks into "#define NAME VALUE".
! ac_eA='s%^\([ 	]*\)#\([ 	]*\)undef\([ 	][ 	]*\)'
! ac_eB='$%\1#\2define\3'
! ac_eC=' '
! ac_eD='%g'
  
! if test "${CONFIG_HEADERS+set}" != set; then
! EOF
! cat >> $CONFIG_STATUS <<EOF
!   CONFIG_HEADERS="config.h"
! EOF
! cat >> $CONFIG_STATUS <<\EOF
! fi
! for ac_file in .. $CONFIG_HEADERS; do if test "x$ac_file" != x..; then
    # Support "outfile[:infile[:infile...]]", defaulting infile="outfile.in".
!   case "$ac_file" in
!   *:*) ac_file_in=`echo "$ac_file"|sed 's%[^:]*:%%'`
!        ac_file=`echo "$ac_file"|sed 's%:.*%%'` ;;
!   *) ac_file_in="${ac_file}.in" ;;
    esac
  
!   echo creating $ac_file
  
!   rm -f conftest.frag conftest.in conftest.out
!   ac_file_inputs=`echo $ac_file_in|sed -e "s%^%$ac_given_srcdir/%" -e "s%:% $ac_given_srcdir/%g"`
!   cat $ac_file_inputs > conftest.in
  
  EOF
  
! # Transform confdefs.h into a sed script conftest.vals that substitutes
! # the proper values into config.h.in to produce config.h.  And first:
! # Protect against being on the right side of a sed subst in config.status.
! # Protect against being in an unquoted here document in config.status.
! rm -f conftest.vals
! cat > conftest.hdr <<\EOF
! s/[\\&%]/\\&/g
! s%[\\$`]%\\&%g
! s%#define \([A-Za-z_][A-Za-z0-9_]*\) *\(.*\)%${ac_dA}\1${ac_dB}\1${ac_dC}\2${ac_dD}%gp
! s%ac_d%ac_u%gp
! s%ac_u%ac_e%gp
! EOF
! sed -n -f conftest.hdr confdefs.h > conftest.vals
! rm -f conftest.hdr
  
  # This sed command replaces #undef with comments.  This is necessary, for
  # example, in the case of _POSIX_SOURCE, which is predefined and required
  # on some systems where configure will not decide to define it.
! cat >> conftest.vals <<\EOF
! s%^[ 	]*#[ 	]*undef[ 	][ 	]*[a-zA-Z_][a-zA-Z_0-9]*%/* & */%
  EOF
  
! # Break up conftest.vals because some shells have a limit on
! # the size of here documents, and old seds have small limits too.
! 
  rm -f conftest.tail
! while :
  do
!   ac_lines=`grep -c . conftest.vals`
!   # grep -c gives empty output for an empty file on some AIX systems.
!   if test -z "$ac_lines" || test "$ac_lines" -eq 0; then break; fi
!   # Write a limited-size here document to conftest.frag.
!   echo '  cat > conftest.frag <<CEOF' >> $CONFIG_STATUS
!   sed ${ac_max_here_lines}q conftest.vals >> $CONFIG_STATUS
    echo 'CEOF
!   sed -f conftest.frag conftest.in > conftest.out
!   rm -f conftest.in
!   mv conftest.out conftest.in
! ' >> $CONFIG_STATUS
!   sed 1,${ac_max_here_lines}d conftest.vals > conftest.tail
!   rm -f conftest.vals
!   mv conftest.tail conftest.vals
! done
! rm -f conftest.vals
! 
! cat >> $CONFIG_STATUS <<\EOF
!   rm -f conftest.frag conftest.h
!   echo "/* $ac_file.  Generated automatically by configure.  */" > conftest.h
!   cat conftest.in >> conftest.h
!   rm -f conftest.in
!   if cmp -s $ac_file conftest.h 2>/dev/null; then
!     echo "$ac_file is unchanged"
!     rm -f conftest.h
    else
!     # Remove last slash and all that follows it.  Not all systems have dirname.
!       ac_dir=`echo $ac_file|sed 's%/[^/][^/]*$%%'`
        if test "$ac_dir" != "$ac_file" && test "$ac_dir" != .; then
!       # The file is in a subdirectory.
!       test ! -d "$ac_dir" && mkdir "$ac_dir"
      fi
!     rm -f $ac_file
!     mv conftest.h $ac_file
    fi
! fi; done
! 
  EOF
! cat >> $CONFIG_STATUS <<EOF
  
! EOF
! cat >> $CONFIG_STATUS <<\EOF
  
  # Makefile uses this timestamp file to record whether config.h is up to date.
  echo timestamp > stamp-h
  
! exit 0
  EOF
  chmod +x $CONFIG_STATUS
! rm -fr confdefs* $ac_clean_files
! test "$no_create" = yes || ${CONFIG_SHELL-/bin/sh} $CONFIG_STATUS || exit 1
  
--- 14943,15191 ----
  #
  # ac_d sets the value in "#define NAME VALUE" lines.
! ac_dA='s,^\([ 	]*\)#\([ 	]*define[ 	][ 	]*\)'
! ac_dB='[ 	].*$,\1#\2'
! ac_dC=' '
! ac_dD=',;t'
! # ac_u turns "#undef NAME" without trailing blanks into "#define NAME VALUE".
! ac_uA='s,^\([ 	]*\)#\([ 	]*\)undef\([ 	][ 	]*\)'
! ac_uB='$,\1#\2define\3'
  ac_uC=' '
! ac_uD=',;t'
  
! for ac_file in : $CONFIG_HEADERS; do test "x$ac_file" = x: && continue
    # Support "outfile[:infile[:infile...]]", defaulting infile="outfile.in".
!   case $ac_file in
!   - | *:- | *:-:* ) # input from stdin
!         cat >$tmp/stdin
!         ac_file_in=`echo "$ac_file" | sed 's,[^:]*:,,'`
!         ac_file=`echo "$ac_file" | sed 's,:.*,,'` ;;
!   *:* ) ac_file_in=`echo "$ac_file" | sed 's,[^:]*:,,'`
!         ac_file=`echo "$ac_file" | sed 's,:.*,,'` ;;
!   * )   ac_file_in=$ac_file.in ;;
    esac
  
!   test x"$ac_file" != x- && { echo "$as_me:14967: creating $ac_file" >&5
! echo "$as_me: creating $ac_file" >&6;}
  
!   # First look for the input files in the build tree, otherwise in the
!   # src tree.
!   ac_file_inputs=`IFS=:
!     for f in $ac_file_in; do
!       case $f in
!       -) echo $tmp/stdin ;;
!       [\\/$]*)
!          # Absolute (can't be DOS-style, as IFS=:)
!          test -f "$f" || { { echo "$as_me:14978: error: cannot find input file: $f" >&5
! echo "$as_me: error: cannot find input file: $f" >&2;}
!    { (exit 1); exit 1; }; }
!          echo $f;;
!       *) # Relative
!          if test -f "$f"; then
!            # Build tree
!            echo $f
!          elif test -f "$srcdir/$f"; then
!            # Source tree
!            echo $srcdir/$f
!          else
!            # /dev/null tree
!            { { echo "$as_me:14991: error: cannot find input file: $f" >&5
! echo "$as_me: error: cannot find input file: $f" >&2;}
!    { (exit 1); exit 1; }; }
!          fi;;
!       esac
!     done` || { (exit 1); exit 1; }
!   # Remove the trailing spaces.
!   sed 's/[ 	]*$//' $ac_file_inputs >$tmp/in
  
  EOF
  
! # Transform confdefs.h into two sed scripts, `conftest.defines' and
! # `conftest.undefs', that substitutes the proper values into
! # config.h.in to produce config.h.  The first handles `#define'
! # templates, and the second `#undef' templates.
! # And first: Protect against being on the right side of a sed subst in
! # config.status.  Protect against being in an unquoted here document
! # in config.status.
! rm -f conftest.defines conftest.undefs
! # Using a here document instead of a string reduces the quoting nightmare.
! # Putting comments in sed scripts is not portable.
! #
! # `end' is used to avoid that the second main sed command (meant for
! # 0-ary CPP macros) applies to n-ary macro definitions.
! # See the Autoconf documentation for `clear'.
! cat >confdef2sed.sed <<\EOF
! s/[\\&,]/\\&/g
! s,[\\$`],\\&,g
! t clear
! : clear
! s,^[ 	]*#[ 	]*define[ 	][ 	]*\(\([^ 	(][^ 	(]*\)([^)]*)\)[ 	]*\(.*\)$,${ac_dA}\2${ac_dB}\1${ac_dC}\3${ac_dD},gp
! t end
! s,^[ 	]*#[ 	]*define[ 	][ 	]*\([^ 	][^ 	]*\)[ 	]*\(.*\)$,${ac_dA}\1${ac_dB}\1${ac_dC}\2${ac_dD},gp
! : end
! EOF
! # If some macros were called several times there might be several times
! # the same #defines, which is useless.  Nevertheless, we may not want to
! # sort them, since we want the *last* AC-DEFINE to be honored.
! uniq confdefs.h | sed -n -f confdef2sed.sed >conftest.defines
! sed 's/ac_d/ac_u/g' conftest.defines >conftest.undefs
! rm -f confdef2sed.sed
  
  # This sed command replaces #undef with comments.  This is necessary, for
  # example, in the case of _POSIX_SOURCE, which is predefined and required
  # on some systems where configure will not decide to define it.
! cat >>conftest.undefs <<\EOF
! s,^[ 	]*#[ 	]*undef[ 	][ 	]*[a-zA-Z_][a-zA-Z_0-9]*,/* & */,
  EOF
  
! # Break up conftest.defines because some shells have a limit on the size
! # of here documents, and old seds have small limits too (100 cmds).
! echo '  # Handle all the #define templates only if necessary.' >>$CONFIG_STATUS
! echo '  if egrep "^[ 	]*#[ 	]*define" $tmp/in >/dev/null; then' >>$CONFIG_STATUS
! echo '  # If there are no defines, we may have an empty if/fi' >>$CONFIG_STATUS
! echo '  :' >>$CONFIG_STATUS
! rm -f conftest.tail
! while grep . conftest.defines >/dev/null
! do
!   # Write a limited-size here document to $tmp/defines.sed.
!   echo '  cat >$tmp/defines.sed <<CEOF' >>$CONFIG_STATUS
!   # Speed up: don't consider the non `#define' lines.
!   echo '/^[ 	]*#[ 	]*define/!b' >>$CONFIG_STATUS
!   # Work around the forget-to-reset-the-flag bug.
!   echo 't clr' >>$CONFIG_STATUS
!   echo ': clr' >>$CONFIG_STATUS
!   sed ${ac_max_here_lines}q conftest.defines >>$CONFIG_STATUS
!   echo 'CEOF
!   sed -f $tmp/defines.sed $tmp/in >$tmp/out
!   rm -f $tmp/in
!   mv $tmp/out $tmp/in
! ' >>$CONFIG_STATUS
!   sed 1,${ac_max_here_lines}d conftest.defines >conftest.tail
!   rm -f conftest.defines
!   mv conftest.tail conftest.defines
! done
! rm -f conftest.defines
! echo '  fi # egrep' >>$CONFIG_STATUS
! echo >>$CONFIG_STATUS
! 
! # Break up conftest.undefs because some shells have a limit on the size
! # of here documents, and old seds have small limits too (100 cmds).
! echo '  # Handle all the #undef templates' >>$CONFIG_STATUS
  rm -f conftest.tail
! while grep . conftest.undefs >/dev/null
  do
!   # Write a limited-size here document to $tmp/undefs.sed.
!   echo '  cat >$tmp/undefs.sed <<CEOF' >>$CONFIG_STATUS
!   # Speed up: don't consider the non `#undef'
!   echo '/^[ 	]*#[ 	]*undef/!b' >>$CONFIG_STATUS
!   # Work around the forget-to-reset-the-flag bug.
!   echo 't clr' >>$CONFIG_STATUS
!   echo ': clr' >>$CONFIG_STATUS
!   sed ${ac_max_here_lines}q conftest.undefs >>$CONFIG_STATUS
    echo 'CEOF
!   sed -f $tmp/undefs.sed $tmp/in >$tmp/out
!   rm -f $tmp/in
!   mv $tmp/out $tmp/in
! ' >>$CONFIG_STATUS
!   sed 1,${ac_max_here_lines}d conftest.undefs >conftest.tail
!   rm -f conftest.undefs
!   mv conftest.tail conftest.undefs
! done
! rm -f conftest.undefs
! 
! cat >>$CONFIG_STATUS <<\EOF
!   # Let's still pretend it is `configure' which instantiates (i.e., don't
!   # use $as_me), people would be surprised to read:
!   #    /* config.h.  Generated automatically by config.status.  */
!   if test x"$ac_file" = x-; then
!     echo "/* Generated automatically by configure.  */" >$tmp/config.h
    else
!     echo "/* $ac_file.  Generated automatically by configure.  */" >$tmp/config.h
!   fi
!   cat $tmp/in >>$tmp/config.h
!   rm -f $tmp/in
!   if test x"$ac_file" != x-; then
!     if cmp -s $ac_file $tmp/config.h 2>/dev/null; then
!       { echo "$as_me:15108: $ac_file is unchanged" >&5
! echo "$as_me: $ac_file is unchanged" >&6;}
!     else
!       ac_dir=`$as_expr X"$ac_file" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
!          X"$ac_file" : 'X\(//\)[^/]' \| \
!          X"$ac_file" : 'X\(//\)$' \| \
!          X"$ac_file" : 'X\(/\)' \| \
!          .     : '\(.\)' 2>/dev/null ||
! echo X"$ac_file" |
!     sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
!   	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
!   	  /^X\(\/\/\)$/{ s//\1/; q; }
!   	  /^X\(\/\).*/{ s//\1/; q; }
!   	  s/.*/./; q'`
        if test "$ac_dir" != "$ac_file" && test "$ac_dir" != .; then
!         { case "$ac_dir" in
!   [\\/]* | ?:[\\/]* ) as_incr_dir=;;
!   *)                      as_incr_dir=.;;
! esac
! as_dummy="$ac_dir"
! for as_mkdir_dir in `IFS='/\\'; set X $as_dummy; shift; echo "$@"`; do
!   case $as_mkdir_dir in
!     # Skip DOS drivespec
!     ?:) as_incr_dir=$as_mkdir_dir ;;
!     *)
!       as_incr_dir=$as_incr_dir/$as_mkdir_dir
!       test -d "$as_incr_dir" || mkdir "$as_incr_dir"
!     ;;
!   esac
! done; }
! 
!       fi
!       rm -f $ac_file
!       mv $tmp/config.h $ac_file
      fi
!   else
!     cat $tmp/config.h
!     rm -f $tmp/config.h
    fi
! done
  EOF
! cat >>$CONFIG_STATUS <<\EOF
  
! #
! # CONFIG_COMMANDS section.
! #
! for ac_file in : $CONFIG_COMMANDS; do test "x$ac_file" = x: && continue
!   ac_dest=`echo "$ac_file" | sed 's,:.*,,'`
!   ac_source=`echo "$ac_file" | sed 's,[^:]*:,,'`
  
+   case $ac_dest in
+     default )
  # Makefile uses this timestamp file to record whether config.h is up to date.
  echo timestamp > stamp-h
+  ;;
+   esac
+ done
+ EOF
+ 
+ cat >>$CONFIG_STATUS <<\EOF
  
! { (exit 0); exit 0; }
  EOF
  chmod +x $CONFIG_STATUS
! ac_clean_files=$ac_clean_files_save
! 
! # configure is writing to config.log, and then calls config.status.
! # config.status does its own redirection, appending to config.log.
! # Unfortunately, on DOS this fails, as config.log is still kept open
! # by configure, so config.status won't be able to write to it; its
! # output is simply discarded.  So we exec the FD to /dev/null,
! # effectively closing config.log, so it can be properly (re)opened and
! # appended to by config.status.  When coming back to configure, we
! # need to make the FD available again.
! if test "$no_create" != yes; then
!   ac_cs_success=:
!   exec 5>/dev/null
!   $SHELL $CONFIG_STATUS || ac_cs_success=false
!   exec 5>>config.log
!   # Use ||, not &&, to avoid exiting from the if with $? = 1, which
!   # would make configure fail if this is the last instruction.
!   $ac_cs_success || { (exit 1); exit 1; }
! fi
  
diff -Nrc2 bash-2.05/configure.in bash-2.05a/configure.in
*** bash-2.05/configure.in	Tue Jan 23 12:57:24 2001
--- bash-2.05a/configure.in	Mon Nov  5 15:45:35 2001
***************
*** 6,20 ****
  dnl Process this file with autoconf to produce a configure script.
  
! dnl checks for version info
! AC_REVISION([for Bash 2.05, version 2.90, from autoconf version] AC_ACVERSION)dnl
  
! AC_INIT(shell.h)
! AC_CONFIG_HEADER(config.h)
  
  dnl make sure we are using a recent autoconf version
! AC_PREREQ(2.12)
  
  dnl where to find install.sh, config.sub, and config.guess
  AC_CONFIG_AUX_DIR(./support)
  
  dnl canonicalize the host and os so we can do some tricky things before
--- 6,40 ----
  dnl Process this file with autoconf to produce a configure script.
  
! # Copyright (C) 1987-2001 Free Software Foundation, Inc.
! 
! # This program is free software; you can redistribute it and/or modify
! # it under the terms of the GNU General Public License as published by
! # the Free Software Foundation; either version 2, or (at your option)
! # any later version.
! 
! # This program is distributed in the hope that it will be useful,
! # but WITHOUT ANY WARRANTY; without even the implied warranty of
! # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! # GNU General Public License for more details.
! 
! # You should have received a copy of the GNU General Public License
! # along with this program; if not, write to the Free Software
! # Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
! # 02111-1307, USA.
  
! AC_REVISION([for Bash 2.05a, version 2.128, from autoconf version] AC_ACVERSION)dnl
! 
! AC_INIT(bash, 2.05a, bug-bash@gnu.org)
  
  dnl make sure we are using a recent autoconf version
! AC_PREREQ(2.50)
  
+ AC_CONFIG_SRCDIR(shell.h)
  dnl where to find install.sh, config.sub, and config.guess
  AC_CONFIG_AUX_DIR(./support)
+ AC_CONFIG_HEADERS(config.h)
+ 
+ dnl checks for version info
+ BASHVERS=2.05a
  
  dnl canonicalize the host and os so we can do some tricky things before
***************
*** 24,28 ****
  dnl configure defaults
  opt_bash_malloc=yes
- opt_glibc_malloc=no
  opt_purify=no
  opt_purecov=no
--- 44,47 ----
***************
*** 46,49 ****
--- 65,69 ----
  sparc-linux*)	opt_bash_malloc=no ;;	# sparc running linux; requires ELF
  #*-freebsd*)	opt_bash_malloc=no ;;	# they claim it's better
+ *-openbsd*)	opt_bash_malloc=no ;;	# they claim it needs eight-bit alignment
  *-aix*)		opt_bash_malloc=no ;;	# AIX machines
  *-nextstep*)	opt_bash_malloc=no ;;	# NeXT machines running NeXTstep
***************
*** 65,69 ****
  AC_ARG_WITH(bash-malloc, --with-bash-malloc	use the Bash version of malloc,opt_bash_malloc=$withval)
  AC_ARG_WITH(curses, --with-curses		use the curses library instead of the termcap library,opt_curses=$withval)
- AC_ARG_WITH(glibc-malloc, --with-glibc-malloc	use the GNU C library version of malloc,opt_glibc_malloc=$withval)
  AC_ARG_WITH(gnu-malloc, --with-gnu-malloc	synonym for --with-bash-malloc,opt_bash_malloc=$withval)
  AC_ARG_WITH(installed-readline, --with-installed-readline	use a version of the readline library that is already installed, opt_with_installed_readline=$withval)
--- 85,88 ----
***************
*** 71,85 ****
  AC_ARG_WITH(purify, --with-purify		configure to postprocess with purify, opt_purify=$withval)
  
! dnl test for glibc malloc first because it can override the default
! if test "$opt_glibc_malloc" = yes; then 
! 	MALLOC_TARGET=gmalloc
! 	MALLOC_SRC=gmalloc.c
! elif test "$opt_bash_malloc" = yes; then
  	MALLOC_TARGET=malloc
  	MALLOC_SRC=malloc.c
  	AC_DEFINE(USING_BASH_MALLOC)
  else
! 	MALLOC_TARGET=stubmalloc
! 	MALLOC_SRC=stub.c
  fi
  
--- 90,108 ----
  AC_ARG_WITH(purify, --with-purify		configure to postprocess with purify, opt_purify=$withval)
  
! if test "$opt_bash_malloc" = yes; then
  	MALLOC_TARGET=malloc
  	MALLOC_SRC=malloc.c
+ 
+ 	MALLOC_LIB='-lmalloc'
+ 	MALLOC_LIBRARY='$(ALLOC_LIBDIR)/libmalloc.a'
+ 	MALLOC_LDFLAGS='-L$(ALLOC_LIBDIR)'
+ 	MALLOC_DEP='$(MALLOC_LIBRARY)'
+ 
  	AC_DEFINE(USING_BASH_MALLOC)
  else
! 	MALLOC_LIB=
! 	MALLOC_LIBRARY=
! 	MALLOC_LDFLAGS=
! 	MALLOC_DEP=	
  fi
  
***************
*** 127,130 ****
--- 150,154 ----
  opt_net_redirs=yes
  opt_progcomp=yes
+ opt_largefile=yes
  
  dnl options that affect how bash is compiled and linked
***************
*** 161,164 ****
--- 185,189 ----
  AC_ARG_ENABLE(history, --enable-history	turn on command history, opt_history=$enableval)
  AC_ARG_ENABLE(job-control, --enable-job-control	enable job control features, opt_job_control=$enableval)
+ AC_ARG_ENABLE(largefile, --enable-largefile	enable support for large files, opt_largefile=$enableval)
  AC_ARG_ENABLE(net-redirections, --enable-net-redirections	enable /dev/tcp/host/port redirection, opt_net_redirs=$enableval)
  AC_ARG_ENABLE(process-substitution, --enable-process-substitution	enable process substitution, opt_process_subst=$enableval)
***************
*** 248,261 ****
  AC_SUBST(MALLOC_SRC)
  
! AC_SUBST(htmldir)
  
! dnl Use GNU m4 macros to get the distribution and patchlevel information
! dnl into configure without requiring the files to be distributed
! [BASHVERS=]dnl
! esyscmd(cat _distribution)dnl
! [BASHPATCH=]dnl
! esyscmd(cat _patchlevel)dnl
  
  echo "Beginning configuration for bash-$BASHVERS for ${host_cpu}-${host_vendor}-${host_os}"
  
  dnl compilation checks
--- 273,286 ----
  AC_SUBST(MALLOC_SRC)
  
! AC_SUBST(MALLOC_LIB)
! AC_SUBST(MALLOC_LIBRARY)
! AC_SUBST(MALLOC_LDFLAGS)
! AC_SUBST(MALLOC_DEP)
  
! AC_SUBST(htmldir)
  
+ echo ""
  echo "Beginning configuration for bash-$BASHVERS for ${host_cpu}-${host_vendor}-${host_os}"
+ echo ""
  
  dnl compilation checks
***************
*** 263,267 ****
  dnl different environment
  AC_PROG_CC
- BASH_LARGE_FILE_SUPPORT
  
  dnl test for Unix variants
--- 288,291 ----
***************
*** 272,276 ****
  AC_CYGWIN
  AC_MINGW32
! AC_EXEEXT
  
  dnl BEGIN changes for cross-building for cygwin and BeOS
--- 296,301 ----
  AC_CYGWIN
  AC_MINGW32
! 
! AC_SYS_LARGEFILE
  
  dnl BEGIN changes for cross-building for cygwin and BeOS
***************
*** 334,341 ****
  
  if test "$opt_static_link" = yes; then
! 	# if we're using gcc, add `-static' to LDFLAGS
  	if test -n "$GCC" || test "$ac_cv_prog_gcc" = "yes"; then
! 		STATIC_LD="-static"
! 		LDFLAGS="$LDFLAGS -static"	# XXX experimental
  	fi
  fi
--- 359,369 ----
  
  if test "$opt_static_link" = yes; then
! 	# if we're using gcc, add `-static' to LDFLAGS, except on Solaris >= 2
  	if test -n "$GCC" || test "$ac_cv_prog_gcc" = "yes"; then
! 		STATIC_LD="-static" 
! 		case "$host_os" in
! 		solaris2*)	;;
! 		*)		LDFLAGS="$LDFLAGS -static" ;;	# XXX experimental
! 		esac
  	fi
  fi
***************
*** 352,373 ****
  
  dnl first test that the readline version is new enough to link bash against
! if test "$opt_readline" = yes && test "$opt_with_installed_readline" = "yes"
  then
  
! dnl	we duplicate some work that's done later here so we can look in
! dnl	the correct directory for the readline library
! 
! 	if test -z "$TERMCAP_LIB" ; then
! 		BASH_CHECK_LIB_TERMCAP
! 	fi
  
! 	test "x$prefix" = xNONE && _rl_prefix=$ac_default_prefix || _rl_prefix=${prefix}
! 	test "x$exec_prefix" = xNONE && _rl_exec_prefix=${_rl_prefix} || _rl_exec_prefix=${exec_prefix}
! 
! 	AC_MSG_CHECKING(version of installed readline library)
! 	_rl_version=`exec_prefix=${_rl_exec_prefix} ${CONFIG_SHELL-/bin/sh} ${srcdir}/support/rlvers.sh -C "${CC}" -L ${libdir} -I ${includedir} -T ${TERMCAP_LIB}`
! 	AC_MSG_RESULT($_rl_version)
! 
! 	case "$_rl_version" in
  	4.[[2-9]]*|5*|6*|7*|8*|9*)	;;
  	*)	opt_with_installed_readline=no 
--- 380,393 ----
  
  dnl first test that the readline version is new enough to link bash against
! if test "$opt_readline" = yes && test "$opt_with_installed_readline" != "no"
  then
+ echo opt_with_installed_readline = $opt_with_installed_readline
+ 	# If the user specified --with-installed-readline=PREFIX and PREFIX
+ 	# is not `yes', set ac_cv_rl_prefix to PREFIX
+ 	test $opt_with_installed_readline != "yes" && ac_cv_rl_prefix=$opt_with_installed_readline
  
! 	RL_LIB_READLINE_VERSION
  
! 	case "$ac_cv_rl_version" in
  	4.[[2-9]]*|5*|6*|7*|8*|9*)	;;
  	*)	opt_with_installed_readline=no 
***************
*** 376,380 ****
  		;;
  	esac
- 	unset _rl_version _rl_prefix _rl_exec_prefix
  fi
  
--- 396,399 ----
***************
*** 382,389 ****
  	AC_DEFINE(READLINE)
  	READLINE_LIB=-lreadline
! 	if test "$opt_with_installed_readline" = "yes" ; then
! 		RL_LIBDIR='$(libdir)'
  		READLINE_DEP=
- 		RL_INCLUDE='-I$(includedir)'
  	else
  		RL_LIBDIR='$(dot)/$(LIBSUBDIR)/readline'
--- 401,410 ----
  	AC_DEFINE(READLINE)
  	READLINE_LIB=-lreadline
! 	if test "$opt_with_installed_readline" != "no" ; then
! 		case "$RL_INCLUDEDIR" in
! 		/usr/include)	;;
! 		*)		RL_INCLUDE='-I${RL_INCLUDEDIR}'
! 		esac
  		READLINE_DEP=
  	else
  		RL_LIBDIR='$(dot)/$(LIBSUBDIR)/readline'
***************
*** 402,409 ****
  	fi
  	HISTORY_LIB=-lhistory
!  	if test "$opt_with_installed_readline" = "yes"; then
! 		HIST_LIBDIR='$(libdir)'
  		HISTORY_DEP=
! 		RL_INCLUDE='-I$(includedir)'
  	else
  		HIST_LIBDIR='$(dot)/$(LIBSUBDIR)/readline'
--- 423,433 ----
  	fi
  	HISTORY_LIB=-lhistory
!  	if test "$opt_with_installed_readline" != "no"; then
! 		HIST_LIBDIR=$RL_LIBDIR
  		HISTORY_DEP=
! 		case "$RL_INCLUDEDIR" in
! 		/usr/include)	;;
! 		*)		RL_INCLUDE='-I${RL_INCLUDEDIR}'
! 		esac
  	else
  		HIST_LIBDIR='$(dot)/$(LIBSUBDIR)/readline'
***************
*** 417,420 ****
--- 441,445 ----
  AC_SUBST(READLINE_DEP)
  AC_SUBST(RL_LIBDIR)
+ AC_SUBST(RL_INCLUDEDIR)
  AC_SUBST(RL_INCLUDE)
  AC_SUBST(HISTORY_LIB)
***************
*** 426,430 ****
  dnl programs needed by the build and install process
  AC_PROG_INSTALL
! AC_CHECK_PROG(AR, ar, ar)
  dnl Set default for ARFLAGS, since autoconf does not have a macro for it.
  dnl This allows people to set it when running configure or make
--- 451,455 ----
  dnl programs needed by the build and install process
  AC_PROG_INSTALL
! AC_CHECK_PROG(AR, ar, , ar)
  dnl Set default for ARFLAGS, since autoconf does not have a macro for it.
  dnl This allows people to set it when running configure or make
***************
*** 440,443 ****
--- 465,494 ----
  AC_SUBST(MAKE_SHELL)
  
+ dnl Turn on any extensions available in the GNU C library.
+ AC_DEFINE(_GNU_SOURCE, 1)
+ 
+ dnl C compiler characteristics
+ AC_C_CONST
+ AC_C_INLINE
+ AC_C_BIGENDIAN
+ AC_C_STRINGIZE
+ AC_C_LONG_DOUBLE
+ AC_C_PROTOTYPES
+ AC_C_CHAR_UNSIGNED
+ 
+ dnl header files
+ AC_HEADER_DIRENT
+ AC_HEADER_TIME
+ 
+ BASH_HEADER_INTTYPES
+ 
+ AC_CHECK_HEADERS(unistd.h stdlib.h stdarg.h varargs.h limits.h string.h \
+ 		 memory.h locale.h termcap.h termio.h termios.h dlfcn.h \
+ 		 stddef.h stdint.h netdb.h grp.h strings.h)
+ AC_CHECK_HEADERS(sys/ptem.h sys/pte.h sys/stream.h sys/select.h sys/file.h \
+ 		 sys/resource.h sys/param.h sys/socket.h \
+ 		 sys/time.h sys/times.h sys/wait.h)
+ AC_CHECK_HEADERS(netinet/in.h arpa/inet.h)
+ 
  dnl special checks for libc functions
  AC_FUNC_ALLOCA
***************
*** 445,451 ****
  AC_FUNC_SETVBUF_REVERSED
  AC_FUNC_VPRINTF
- AC_FUNC_WAIT3
  AC_FUNC_STRCOLL
  
  dnl if vprintf is not in libc, see if it's defined in stdio.h
  if test "$ac_cv_func_vprintf" = no; then
--- 496,514 ----
  AC_FUNC_SETVBUF_REVERSED
  AC_FUNC_VPRINTF
  AC_FUNC_STRCOLL
  
+ dnl if we're not using the bash malloc but require the C alloca, set things
+ dnl up to build a libmalloc.a containing only alloca.o
+ 
+ if test "$ac_cv_func_alloca_works" = "no" && test "$opt_bash_malloc" = "no"; then
+ 	MALLOC_TARGET=alloca
+ 	MALLOC_SRC=alloca.c
+ 
+ 	MALLOC_LIB='-lmalloc'
+ 	MALLOC_LIBRARY='$(ALLOC_LIBDIR)/libmalloc.a'
+ 	MALLOC_LDFLAGS='-L$(ALLOC_LIBDIR)'
+ 	MALLOC_DEP='$(MALLOC_LIBRARY)'
+ fi
+ 
  dnl if vprintf is not in libc, see if it's defined in stdio.h
  if test "$ac_cv_func_vprintf" = no; then
***************
*** 458,463 ****
  fi
  
  dnl signal stuff
! AC_RETSIGTYPE
  
  dnl checks for certain version-specific system calls and libc functions
--- 521,530 ----
  fi
  
+ if test "$ac_cv_func_vprintf" = no && test "$ac_cv_func__doprnt" = "yes"; then
+   AC_LIBOBJ(vprint)
+ fi
+ 
  dnl signal stuff
! AC_TYPE_SIGNAL
  
  dnl checks for certain version-specific system calls and libc functions
***************
*** 472,483 ****
  		setdtablesize getpagesize killpg lstat getpeername sbrk \
  		getrlimit getrusage gettimeofday waitpid tcgetpgrp \
! 		readlink rename)
  
  dnl checks for c library functions
! AC_CHECK_FUNCS(bcopy bzero confstr getcwd strcasecmp setenv putenv \
! 		setlinebuf setlocale strchr strerror strtod strtol \
! 		strtoul tcgetattr uname sysconf ulimit times tzset \
! 		siginterrupt memmove ttyname gethostbyname getservbyname \
! 		inet_aton strpbrk setvbuf pathconf)
  
  dnl checks for locale functions
--- 539,567 ----
  		setdtablesize getpagesize killpg lstat getpeername sbrk \
  		getrlimit getrusage gettimeofday waitpid tcgetpgrp \
! 		readlink)
! AC_REPLACE_FUNCS(rename)
  
  dnl checks for c library functions
! AC_CHECK_FUNCS(bcopy bzero confstr sysconf pathconf setenv putenv \
! 		setlinebuf setvbuf setlocale strchr tcgetattr uname \
! 		ulimit tzset siginterrupt memmove ttyname times \
! 		getaddrinfo gethostbyname getservbyname inet_aton \
! 		vsnprintf snprintf vasprintf asprintf fnmatch)
! AC_CHECK_FUNCS(isascii isblank isgraph isprint isspace isxdigit)
! AC_REPLACE_FUNCS(getcwd strcasecmp strerror strpbrk strtod)
! AC_REPLACE_FUNCS(strtol strtoul strtoll strtoull strtoimax strtoumax)
! 
! AC_CHECK_DECLS([strtold])
! AC_CHECK_DECLS([confstr])
! AC_CHECK_DECLS([sbrk])
! AC_CHECK_DECLS([printf])
! AC_CHECK_DECLS([strsignal])
! 
! BASH_CHECK_DECL(strtoimax)
! BASH_CHECK_DECL(strtol)
! BASH_CHECK_DECL(strtoll)
! BASH_CHECK_DECL(strtoul)
! BASH_CHECK_DECL(strtoull)
! BASH_CHECK_DECL(strtoumax)
  
  dnl checks for locale functions
***************
*** 503,518 ****
  AC_DECL_SYS_SIGLIST
  
- dnl header files
- AC_HEADER_DIRENT
- AC_HEADER_TIME
- 
- AC_CHECK_HEADERS(unistd.h stdlib.h stdarg.h varargs.h limits.h string.h \
- 		 memory.h locale.h termcap.h termio.h termios.h dlfcn.h \
- 		 stddef.h netdb.h)
- AC_CHECK_HEADERS(sys/ptem.h sys/pte.h sys/stream.h sys/select.h sys/file.h \
- 		 sys/resource.h sys/param.h sys/socket.h \
- 		 sys/time.h sys/times.h sys/wait.h)
- AC_CHECK_HEADERS(netinet/in.h arpa/inet.h)
- 
  dnl network functions -- check for inet_aton again
  if test "$ac_cv_func_inet_aton" != 'yes'; then
--- 587,590 ----
***************
*** 528,532 ****
  dnl check for getpeername in the socket library only if it's not in libc
  if test "$ac_cv_func_getpeername" = no; then
! 	BASH_CHECK_SOCKLIB
  fi
  dnl check for gethostbyname in socket libraries if it's not in libc
--- 600,604 ----
  dnl check for getpeername in the socket library only if it's not in libc
  if test "$ac_cv_func_getpeername" = no; then
! 	BASH_CHECK_LIB_SOCKET
  fi
  dnl check for gethostbyname in socket libraries if it's not in libc
***************
*** 542,547 ****
--- 614,623 ----
  AC_TYPE_PID_T
  AC_TYPE_SIZE_T
+ AC_CHECK_TYPE(ssize_t, int)
  AC_CHECK_TYPE(time_t, long)
  
+ BASH_TYPE_LONG_LONG
+ BASH_TYPE_UNSIGNED_LONG_LONG
+ 
  AC_TYPE_SIGNAL
  
***************
*** 552,558 ****
  AC_CHECK_SIZEOF(char *, 4)
  AC_CHECK_SIZEOF(double, 8)
  
! AC_CHECK_TYPE(u_int, unsigned int)
! AC_CHECK_TYPE(u_long, unsigned long)
  
  BASH_TYPE_BITS16_T
--- 628,635 ----
  AC_CHECK_SIZEOF(char *, 4)
  AC_CHECK_SIZEOF(double, 8)
+ AC_CHECK_SIZEOF([long long], 8)
  
! AC_CHECK_TYPE(u_int, [unsigned int])
! AC_CHECK_TYPE(u_long, [unsigned long])
  
  BASH_TYPE_BITS16_T
***************
*** 567,573 ****
  AC_HEADER_STAT
  
- dnl C compiler characteristics
- AC_C_BIGENDIAN
- 
  dnl system services
  AC_SYS_INTERPRETER
--- 644,647 ----
***************
*** 575,580 ****
  AC_DEFINE(HAVE_HASH_BANG_EXEC)
  fi
- dnl we use NO_READ_RESTART_ON_SIGNAL
- AC_SYS_RESTARTABLE_SYSCALLS
  
  dnl Miscellaneous Bash tests
--- 649,652 ----
***************
*** 584,594 ****
  
  dnl behavior of system calls and library functions
! BASH_DUP2_CLOEXEC_CHECK
! BASH_PGRP_SYNC
! BASH_SIGNAL_CHECK
! 
! if test "$ac_cv_sys_restartable_syscalls" = "no"; then
! BASH_SYS_RESTARTABLE_SYSCALLS
! fi
  
  dnl checking for the presence of certain library symbols
--- 656,662 ----
  
  dnl behavior of system calls and library functions
! BASH_FUNC_DUP2_CLOEXEC_CHECK
! BASH_SYS_PGRP_SYNC
! BASH_SYS_SIGNAL_VINTAGE
  
  dnl checking for the presence of certain library symbols
***************
*** 602,606 ****
  BASH_CHECK_TYPE(sigset_t, [#include <signal.h>], int)
  BASH_CHECK_TYPE(quad_t, , long, HAVE_QUAD_T)
! BASH_RLIMIT_TYPE
  
  dnl presence and contents of structures used by system calls
--- 670,679 ----
  BASH_CHECK_TYPE(sigset_t, [#include <signal.h>], int)
  BASH_CHECK_TYPE(quad_t, , long, HAVE_QUAD_T)
! BASH_CHECK_TYPE(intmax_t, , $bash_cv_type_long_long)
! BASH_CHECK_TYPE(uintmax_t, , $bash_cv_type_unsigned_long_long)
! if test "$ac_cv_header_sys_socket_h" = "yes"; then
! BASH_CHECK_TYPE(socklen_t, [#include <sys/socket.h>], int, HAVE_SOCKLEN_T)
! fi
! BASH_TYPE_RLIMIT
  
  dnl presence and contents of structures used by system calls
***************
*** 611,644 ****
  BASH_STRUCT_WINSIZE
  BASH_STRUCT_TIMEVAL
  
  dnl presence and behavior of C library functions
  BASH_FUNC_STRSIGNAL
  BASH_FUNC_OPENDIR_CHECK
- BASH_FUNC_PRINTF
  BASH_FUNC_ULIMIT_MAXFDS
  BASH_FUNC_GETENV
  BASH_FUNC_GETCWD
! BASH_FUNC_SBRK_DECLARED
  BASH_FUNC_POSIX_SETJMP
  BASH_FUNC_STRCOLL
  
  dnl presence and behavior of OS functions
! BASH_REINSTALL_SIGHANDLERS
! BASH_JOB_CONTROL_MISSING
  BASH_SYS_NAMED_PIPES
  
  dnl presence of certain CPP defines
! BASH_HAVE_TIOCGWINSZ
  BASH_HAVE_TIOCSTAT
  BASH_HAVE_FIONREAD
  
  dnl miscellaneous
! BASH_MISC_SPEED_T
  BASH_CHECK_GETPW_FUNCS
  BASH_CHECK_RTSIGS
  
  dnl special checks
  case "$host_os" in
! hpux*)	BASH_KERNEL_RLIMIT_CHECK ;;
  esac
  
--- 684,733 ----
  BASH_STRUCT_WINSIZE
  BASH_STRUCT_TIMEVAL
+ AC_CHECK_MEMBERS([struct stat.st_blocks])
  
  dnl presence and behavior of C library functions
  BASH_FUNC_STRSIGNAL
  BASH_FUNC_OPENDIR_CHECK
  BASH_FUNC_ULIMIT_MAXFDS
  BASH_FUNC_GETENV
+ if test "$ac_func_getcwd" = "yes"; then
  BASH_FUNC_GETCWD
! fi
  BASH_FUNC_POSIX_SETJMP
  BASH_FUNC_STRCOLL
  
+ dnl I have removed this check.  The existing libc FNM_EXTMATCH implementation
+ dnl (glibc-2.2.4) disagrees with bash on the matching of incorrectly-formed
+ dnl patterns (bash treats them as strings or characters to be matched without
+ dnl any special meaning) and has one outright bug:  a[X-]b should match
+ dnl both a-b and aXb.
+ dnl
+ dnl Once Ulrich and I get together on this, the check can return
+ dnl
+ dnl chet 10/31/2001
+ dnl
+ dnl BASH_FUNC_FNMATCH_EXTMATCH
+ 
+ BASH_FUNC_PRINTF_A_FORMAT
+ 
  dnl presence and behavior of OS functions
! BASH_SYS_REINSTALL_SIGHANDLERS
! BASH_SYS_JOB_CONTROL_MISSING
  BASH_SYS_NAMED_PIPES
  
  dnl presence of certain CPP defines
! AC_HEADER_TIOCGWINSZ
  BASH_HAVE_TIOCSTAT
  BASH_HAVE_FIONREAD
  
  dnl miscellaneous
! BASH_CHECK_SPEED_T
  BASH_CHECK_GETPW_FUNCS
  BASH_CHECK_RTSIGS
+ BASH_CHECK_SYS_SIGLIST
  
  dnl special checks
  case "$host_os" in
! hpux*)	BASH_CHECK_KERNEL_RLIMIT ;;
  esac
  
***************
*** 655,659 ****
  BASH_CHECK_DEV_FD
  BASH_CHECK_DEV_STDIN
! BASH_DEFAULT_MAIL_DIR
  
  if test "$bash_cv_job_control_missing" = missing; then
--- 744,748 ----
  BASH_CHECK_DEV_FD
  BASH_CHECK_DEV_STDIN
! BASH_SYS_DEFAULT_MAIL_DIR
  
  if test "$bash_cv_job_control_missing" = missing; then
***************
*** 690,693 ****
--- 779,783 ----
  isc*)		LOCAL_CFLAGS=-Disc386 ;;
  rhapsody*)	LOCAL_CFLAGS=-DRHAPSODY ;;
+ darwin*)	LOCAL_CFLAGS=-DMACOSX ;;
  sco3.2v5*)	LOCAL_CFLAGS="-b elf -DWAITPID_BROKEN -DNO_MEMSCRAMBLE -DPATH_MAX=1024" ;;
  sco3.2v4*)	LOCAL_CFLAGS="-DMUST_UNBLOCK_CHLD -DNO_MEMSCRAMBLE -DPATH_MAX=1024" ;;
***************
*** 700,704 ****
  powerux*)	LOCAL_LIBS="-lgen" ;;
  cygwin*)	LOCAL_LIBS="-luser32" ;;
! opennt*|interix*) LOCAL_CFLAGS="-DNO_MAIN_ENV_ARG" ;;
  esac
  
--- 790,794 ----
  powerux*)	LOCAL_LIBS="-lgen" ;;
  cygwin*)	LOCAL_LIBS="-luser32" ;;
! opennt*|interix*) LOCAL_CFLAGS="-DNO_MAIN_ENV_ARG -DBROKEN_DIRENT_D_INO" ;;
  esac
  
***************
*** 777,781 ****
  
  AC_SUBST(BASHVERS)
- AC_SUBST(BASHPATCH)
  
  AC_SUBST(host_cpu)
--- 867,870 ----
diff -Nrc2 bash-2.05/conftypes.h bash-2.05a/conftypes.h
*** bash-2.05/conftypes.h	Wed Dec 31 19:00:00 1969
--- bash-2.05a/conftypes.h	Tue Apr 24 09:34:59 2001
***************
*** 0 ****
--- 1,58 ----
+ /* conftypes.h -- defines for build and host system. */
+ 
+ /* Copyright (C) 2001 Free Software Foundation, Inc.
+ 
+    This file is part of GNU Bash, the Bourne Again SHell.
+ 
+    Bash is free software; you can redistribute it and/or modify it
+    under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2, or (at your option)
+    any later version.
+ 
+    Bash is distributed in the hope that it will be useful, but WITHOUT
+    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+    or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+    License for more details.
+ 
+    You should have received a copy of the GNU General Public License
+    along with Bash; see the file COPYING.  If not, write to the Free
+    Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. */
+ 
+ #if !defined (_CONFTYPES_H_)
+ #define _CONFTYPES_H_
+ 
+ /* Placeholder for future modifications if cross-compiling or building a
+    `fat' binary, e.g. on Apple Rhapsody.  These values are used in multiple
+    files, so they appear here. */
+ #if !defined (RHAPSODY)
+ #  define HOSTTYPE	CONF_HOSTTYPE
+ #  define OSTYPE	CONF_OSTYPE
+ #  define MACHTYPE	CONF_MACHTYPE
+ #else /* RHAPSODY */
+ #  if   defined(__powerpc__) || defined(__ppc__)
+ #    define HOSTTYPE "powerpc"
+ #  elif defined(__i386__)
+ #    define HOSTTYPE "i386"
+ #  else
+ #    define HOSTTYPE CONF_HOSTTYPE
+ #  endif
+ 
+ #  define OSTYPE CONF_OSTYPE
+ #  define VENDOR CONF_VENDOR
+ 
+ #  define MACHTYPE HOSTTYPE "-" VENDOR "-" OSTYPE
+ #endif /* RHAPSODY */
+ 
+ #ifndef HOSTTYPE
+ #  define HOSTTYPE "unknown"
+ #endif
+ 
+ #ifndef OSTYPE
+ #  define OSTYPE "unknown"
+ #endif
+ 
+ #ifndef MACHTYPE
+ #  define MACHTYPE "unknown"
+ #endif
+ 
+ #endif /* _CONFTYPES_H_ */
diff -Nrc2 bash-2.05/copy_cmd.c bash-2.05a/copy_cmd.c
*** bash-2.05/copy_cmd.c	Wed Feb 14 16:58:19 2001
--- bash-2.05a/copy_cmd.c	Mon Oct 15 09:31:59 2001
***************
*** 33,36 ****
--- 33,56 ----
  #include "shell.h"
  
+ static PATTERN_LIST *copy_case_clause __P((PATTERN_LIST *));
+ static PATTERN_LIST *copy_case_clauses __P((PATTERN_LIST *));
+ static FOR_COM *copy_for_command __P((FOR_COM *));
+ #if defined (ARITH_FOR_COMMAND)
+ static ARITH_FOR_COM *copy_arith_for_command __P((ARITH_FOR_COM *));
+ #endif
+ static GROUP_COM *copy_group_command __P((GROUP_COM *));
+ static SUBSHELL_COM *copy_subshell_command __P((SUBSHELL_COM *));
+ static CASE_COM *copy_case_command __P((CASE_COM *));
+ static WHILE_COM *copy_while_command __P((WHILE_COM *));
+ static IF_COM *copy_if_command __P((IF_COM *));
+ #if defined (DPAREN_ARITHMETIC)
+ static ARITH_COM *copy_arith_command __P((ARITH_COM *));
+ #endif
+ #if defined (COND_COMMAND)
+ static COND_COM *copy_cond_command __P((COND_COM *));
+ #endif
+ static SIMPLE_COM *copy_simple_command __P((SIMPLE_COM *));
+ static FUNCTION_DEF *copy_function_def __P((FUNCTION_DEF *));
+ 
  WORD_DESC *
  copy_word (w)
diff -Nrc2 bash-2.05/cross-build/beos-sig.h bash-2.05a/cross-build/beos-sig.h
*** bash-2.05/cross-build/beos-sig.h	Thu Aug  6 14:39:03 1998
--- bash-2.05a/cross-build/beos-sig.h	Wed Oct 10 16:20:48 2001
***************
*** 9,13 ****
     some entries might wind up being NULL. */
  
! char *signal_names[NSIG + 2] = {
    [0]         "EXIT",
    [SIGHUP]    "SIGHUP",
--- 9,13 ----
     some entries might wind up being NULL. */
  
! char *signal_names[NSIG + 3] = {
    [0]         "EXIT",
    [SIGHUP]    "SIGHUP",
***************
*** 33,36 ****
    [SIGKILLTHR]        "SIGKILLTHR",
    [NSIG]      "DEBUG",
!   [NSIG + 1]  (char *)0x0,
  };
--- 33,37 ----
    [SIGKILLTHR]        "SIGKILLTHR",
    [NSIG]      "DEBUG",
!   [NSIG + 1]  "ERR",
!   [NSIG + 2]  (char *)0x0,
  };
diff -Nrc2 bash-2.05/cross-build/cygwin32.cache bash-2.05a/cross-build/cygwin32.cache
*** bash-2.05/cross-build/cygwin32.cache	Mon Jul 13 11:09:36 1998
--- bash-2.05a/cross-build/cygwin32.cache	Tue Nov 13 10:36:29 2001
***************
*** 1,42 ****
  # This file is a shell script that caches the results of configure
! # tests for CYGWIN32 so they don't need to be done when cross-compiling.
! 
! # AC_FUNC_GETPGRP should also define GETPGRP_VOID
  ac_cv_func_getpgrp_void=${ac_cv_func_getpgrp_void='yes'}
! # AC_FUNC_SETVBUF_REVERSED should not define anything else
  ac_cv_func_setvbuf_reversed=${ac_cv_func_setvbuf_reversed='no'}
! # on CYGWIN32, system calls do not restart
! ac_cv_sys_restartable_syscalls=${ac_cv_sys_restartable_syscalls='no'}
! bash_cv_sys_restartable_syscalls=${bash_cv_sys_restartable_syscalls='no'}
! 
! # these may be necessary, but they are currently commented out
! #ac_cv_c_bigendian=${ac_cv_c_bigendian='no'}
  ac_cv_sizeof_char_p=${ac_cv_sizeof_char_p='4'}
  ac_cv_sizeof_int=${ac_cv_sizeof_int='4'}
  ac_cv_sizeof_long=${ac_cv_sizeof_long='4'}
! ac_cv_sizeof_double=${ac_cv_sizeof_double='8'}
! 
! bash_cv_dup2_broken=${bash_cv_dup2_broken='no'}
! bash_cv_pgrp_pipe=${bash_cv_pgrp_pipe='no'}
! bash_cv_type_rlimit=${bash_cv_type_rlimit='long'}
  bash_cv_decl_under_sys_siglist=${bash_cv_decl_under_sys_siglist='no'}
! bash_cv_under_sys_siglist=${bash_cv_under_sys_siglist='no'}
! bash_cv_sys_siglist=${bash_cv_sys_siglist='no'}
! bash_cv_opendir_not_robust=${bash_cv_opendir_not_robust='no'}
  bash_cv_getenv_redef=${bash_cv_getenv_redef='yes'}
! bash_cv_printf_declared=${bash_cv_printf_declared='yes'}
! bash_cv_ulimit_maxfds=${bash_cv_ulimit_maxfds='no'}
! bash_cv_getcwd_calls_popen=${bash_cv_getcwd_calls_popen='no'}
! bash_cv_must_reinstall_sighandlers=${bash_cv_must_reinstall_sighandlers='no'}
  bash_cv_job_control_missing=${bash_cv_job_control_missing='present'}
- bash_cv_sys_named_pipes=${bash_cv_sys_named_pipes='missing'}
- bash_cv_func_sigsetjmp=${bash_cv_func_sigsetjmp='missing'}
  bash_cv_mail_dir=${bash_cv_mail_dir='unknown'}
! bash_cv_func_strcoll_broken=${bash_cv_func_strcoll_broken='no'}
! 
! bash_cv_type_int32_t=${bash_cv_type_int32_t='int'}
! bash_cv_type_u_int32_t=${bash_cv_type_u_int32_t='int'}
! 
! ac_cv_type_bits64_t=${ac_cv_type_bits64_t='no'}
! 
! # end of cross-build/cygwin32.cache
--- 1,251 ----
  # This file is a shell script that caches the results of configure
! # tests run on this system so they can be shared between configure
! # scripts and configure runs, see configure's option --config-cache.
! # It is not useful on other systems.  If it contains results you don't
! # want to keep, you may remove or edit it.
! #
! # config.status only pays attention to the cache file if you give it
! # the --recheck option to rerun configure.
! #
! # `ac_cv_env_foo' variables (set or unset) will be overriden when
! # loading this file, other *unset* `ac_cv_foo' will be assigned the
! # following values.
! 
! ac_cv_build=${ac_cv_build='i686-pc-cygwin'}
! ac_cv_build_alias=${ac_cv_build_alias='i686-pc-cygwin'}
! ac_cv_c_bigendian=${ac_cv_c_bigendian='no'}
! ac_cv_c_char_unsigned=${ac_cv_c_char_unsigned='no'}
! ac_cv_c_compiler_gnu=${ac_cv_c_compiler_gnu='yes'}
! ac_cv_c_const=${ac_cv_c_const='yes'}
! ac_cv_c_inline=${ac_cv_c_inline='inline'}
! ac_cv_c_long_double=${ac_cv_c_long_double='yes'}
! ac_cv_c_stringize=${ac_cv_c_stringize='yes'}
! ac_cv_decl_sys_siglist=${ac_cv_decl_sys_siglist='no'}
! ac_cv_exeext=${ac_cv_exeext='.exe'}
! ac_cv_func___setostype=${ac_cv_func___setostype='no'}
! ac_cv_func__doprnt=${ac_cv_func__doprnt='no'}
! ac_cv_func_alloca_works=${ac_cv_func_alloca_works='yes'}
! ac_cv_func_asprintf=${ac_cv_func_asprintf='no'}
! ac_cv_func_bcopy=${ac_cv_func_bcopy='yes'}
! ac_cv_func_bindtextdomain=${ac_cv_func_bindtextdomain='no'}
! ac_cv_func_bzero=${ac_cv_func_bzero='yes'}
! ac_cv_func_confstr=${ac_cv_func_confstr='no'}
! ac_cv_func_dlclose=${ac_cv_func_dlclose='yes'}
! ac_cv_func_dlopen=${ac_cv_func_dlopen='yes'}
! ac_cv_func_dlsym=${ac_cv_func_dlsym='yes'}
! ac_cv_func_dup2=${ac_cv_func_dup2='yes'}
! ac_cv_func_fnmatch=${ac_cv_func_fnmatch='no'}
! ac_cv_func_getaddrinfo=${ac_cv_func_getaddrinfo='no'}
! ac_cv_func_getcwd=${ac_cv_func_getcwd='yes'}
! ac_cv_func_getdtablesize=${ac_cv_func_getdtablesize='yes'}
! ac_cv_func_getgroups=${ac_cv_func_getgroups='yes'}
! ac_cv_func_gethostbyname=${ac_cv_func_gethostbyname='yes'}
! ac_cv_func_gethostname=${ac_cv_func_gethostname='yes'}
! ac_cv_func_getpagesize=${ac_cv_func_getpagesize='yes'}
! ac_cv_func_getpeername=${ac_cv_func_getpeername='yes'}
  ac_cv_func_getpgrp_void=${ac_cv_func_getpgrp_void='yes'}
! ac_cv_func_getrlimit=${ac_cv_func_getrlimit='yes'}
! ac_cv_func_getrusage=${ac_cv_func_getrusage='yes'}
! ac_cv_func_getservbyname=${ac_cv_func_getservbyname='yes'}
! ac_cv_func_gettext=${ac_cv_func_gettext='no'}
! ac_cv_func_gettimeofday=${ac_cv_func_gettimeofday='yes'}
! ac_cv_func_inet_aton=${ac_cv_func_inet_aton='yes'}
! ac_cv_func_isascii=${ac_cv_func_isascii='yes'}
! ac_cv_func_isblank=${ac_cv_func_isblank='no'}
! ac_cv_func_isgraph=${ac_cv_func_isgraph='yes'}
! ac_cv_func_isprint=${ac_cv_func_isprint='yes'}
! ac_cv_func_isspace=${ac_cv_func_isspace='yes'}
! ac_cv_func_isxdigit=${ac_cv_func_isxdigit='yes'}
! ac_cv_func_killpg=${ac_cv_func_killpg='yes'}
! ac_cv_func_lstat=${ac_cv_func_lstat='yes'}
! ac_cv_func_memmove=${ac_cv_func_memmove='yes'}
! ac_cv_func_mkfifo=${ac_cv_func_mkfifo='yes'}
! ac_cv_func_pathconf=${ac_cv_func_pathconf='yes'}
! ac_cv_func_putenv=${ac_cv_func_putenv='yes'}
! ac_cv_func_readlink=${ac_cv_func_readlink='yes'}
! ac_cv_func_rename=${ac_cv_func_rename='yes'}
! ac_cv_func_sbrk=${ac_cv_func_sbrk='yes'}
! ac_cv_func_select=${ac_cv_func_select='yes'}
! ac_cv_func_setdtablesize=${ac_cv_func_setdtablesize='yes'}
! ac_cv_func_setenv=${ac_cv_func_setenv='yes'}
! ac_cv_func_setlinebuf=${ac_cv_func_setlinebuf='no'}
! ac_cv_func_setlocale=${ac_cv_func_setlocale='yes'}
! ac_cv_func_setvbuf=${ac_cv_func_setvbuf='yes'}
  ac_cv_func_setvbuf_reversed=${ac_cv_func_setvbuf_reversed='no'}
! ac_cv_func_siginterrupt=${ac_cv_func_siginterrupt='no'}
! ac_cv_func_snprintf=${ac_cv_func_snprintf='yes'}
! ac_cv_func_strcasecmp=${ac_cv_func_strcasecmp='yes'}
! ac_cv_func_strchr=${ac_cv_func_strchr='yes'}
! ac_cv_func_strcoll_works=${ac_cv_func_strcoll_works='yes'}
! ac_cv_func_strerror=${ac_cv_func_strerror='yes'}
! ac_cv_func_strpbrk=${ac_cv_func_strpbrk='yes'}
! ac_cv_func_strtod=${ac_cv_func_strtod='yes'}
! ac_cv_func_strtoimax=${ac_cv_func_strtoimax='no'}
! ac_cv_func_strtol=${ac_cv_func_strtol='yes'}
! ac_cv_func_strtoll=${ac_cv_func_strtoll='no'}
! ac_cv_func_strtoul=${ac_cv_func_strtoul='yes'}
! ac_cv_func_strtoull=${ac_cv_func_strtoull='no'}
! ac_cv_func_strtoumax=${ac_cv_func_strtoumax='no'}
! ac_cv_func_sysconf=${ac_cv_func_sysconf='yes'}
! ac_cv_func_tcgetattr=${ac_cv_func_tcgetattr='yes'}
! ac_cv_func_tcgetpgrp=${ac_cv_func_tcgetpgrp='yes'}
! ac_cv_func_textdomain=${ac_cv_func_textdomain='no'}
! ac_cv_func_times=${ac_cv_func_times='yes'}
! ac_cv_func_ttyname=${ac_cv_func_ttyname='yes'}
! ac_cv_func_tzset=${ac_cv_func_tzset='yes'}
! ac_cv_func_ulimit=${ac_cv_func_ulimit='no'}
! ac_cv_func_uname=${ac_cv_func_uname='yes'}
! ac_cv_func_vasprintf=${ac_cv_func_vasprintf='no'}
! ac_cv_func_vprintf=${ac_cv_func_vprintf='yes'}
! ac_cv_func_vsnprintf=${ac_cv_func_vsnprintf='yes'}
! ac_cv_func_wait3=${ac_cv_func_wait3='yes'}
! ac_cv_func_waitpid=${ac_cv_func_waitpid='yes'}
! ac_cv_have_decl_confstr=${ac_cv_have_decl_confstr='no'}
! ac_cv_have_decl_printf=${ac_cv_have_decl_printf='yes'}
! ac_cv_have_decl_sbrk=${ac_cv_have_decl_sbrk='yes'}
! ac_cv_have_decl_strsignal=${ac_cv_have_decl_strsignal='yes'}
! ac_cv_have_decl_strtold=${ac_cv_have_decl_strtold='no'}
! ac_cv_header_arpa_inet_h=${ac_cv_header_arpa_inet_h='yes'}
! ac_cv_header_dirent_dirent_h=${ac_cv_header_dirent_dirent_h='yes'}
! ac_cv_header_dlfcn_h=${ac_cv_header_dlfcn_h='yes'}
! ac_cv_header_grp_h=${ac_cv_header_grp_h='yes'}
! ac_cv_header_inttypes_h=${ac_cv_header_inttypes_h='no'}
! ac_cv_header_libintl_h=${ac_cv_header_libintl_h='yes'}
! ac_cv_header_limits_h=${ac_cv_header_limits_h='yes'}
! ac_cv_header_locale_h=${ac_cv_header_locale_h='yes'}
! ac_cv_header_memory_h=${ac_cv_header_memory_h='yes'}
! ac_cv_header_minix_config_h=${ac_cv_header_minix_config_h='no'}
! ac_cv_header_netdb_h=${ac_cv_header_netdb_h='yes'}
! ac_cv_header_netinet_in_h=${ac_cv_header_netinet_in_h='yes'}
! ac_cv_header_stat_broken=${ac_cv_header_stat_broken='no'}
! ac_cv_header_stdarg_h=${ac_cv_header_stdarg_h='yes'}
! ac_cv_header_stdc=${ac_cv_header_stdc='yes'}
! ac_cv_header_stddef_h=${ac_cv_header_stddef_h='yes'}
! ac_cv_header_stdint_h=${ac_cv_header_stdint_h='no'}
! ac_cv_header_stdlib_h=${ac_cv_header_stdlib_h='yes'}
! ac_cv_header_string_h=${ac_cv_header_string_h='yes'}
! ac_cv_header_strings_h=${ac_cv_header_strings_h='yes'}
! ac_cv_header_sys_file_h=${ac_cv_header_sys_file_h='yes'}
! ac_cv_header_sys_param_h=${ac_cv_header_sys_param_h='yes'}
! ac_cv_header_sys_pte_h=${ac_cv_header_sys_pte_h='no'}
! ac_cv_header_sys_ptem_h=${ac_cv_header_sys_ptem_h='no'}
! ac_cv_header_sys_resource_h=${ac_cv_header_sys_resource_h='yes'}
! ac_cv_header_sys_select_h=${ac_cv_header_sys_select_h='yes'}
! ac_cv_header_sys_socket_h=${ac_cv_header_sys_socket_h='yes'}
! ac_cv_header_sys_stat_h=${ac_cv_header_sys_stat_h='yes'}
! ac_cv_header_sys_stream_h=${ac_cv_header_sys_stream_h='no'}
! ac_cv_header_sys_time_h=${ac_cv_header_sys_time_h='yes'}
! ac_cv_header_sys_times_h=${ac_cv_header_sys_times_h='yes'}
! ac_cv_header_sys_types_h=${ac_cv_header_sys_types_h='yes'}
! ac_cv_header_sys_wait_h=${ac_cv_header_sys_wait_h='yes'}
! ac_cv_header_termcap_h=${ac_cv_header_termcap_h='yes'}
! ac_cv_header_termio_h=${ac_cv_header_termio_h='yes'}
! ac_cv_header_termios_h=${ac_cv_header_termios_h='yes'}
! ac_cv_header_time=${ac_cv_header_time='yes'}
! ac_cv_header_unistd_h=${ac_cv_header_unistd_h='yes'}
! ac_cv_header_varargs_h=${ac_cv_header_varargs_h='yes'}
! ac_cv_host=${ac_cv_host='i686-pc-cygwin'}
! ac_cv_host_alias=${ac_cv_host_alias='i686-pc-cygwin'}
! ac_cv_lib_dir_opendir=${ac_cv_lib_dir_opendir='no'}
! ac_cv_lib_dl_dlopen=${ac_cv_lib_dl_dlopen='no'}
! ac_cv_lib_intl_bindtextdomain=${ac_cv_lib_intl_bindtextdomain='yes'}
! ac_cv_lib_termcap_tgetent=${ac_cv_lib_termcap_tgetent='yes'}
! ac_cv_member_struct_stat_st_blocks=${ac_cv_member_struct_stat_st_blocks='yes'}
! ac_cv_member_struct_termio_c_line=${ac_cv_member_struct_termio_c_line='yes'}
! ac_cv_member_struct_termios_c_line=${ac_cv_member_struct_termios_c_line='yes'}
! ac_cv_objext=${ac_cv_objext='o'}
! ac_cv_path_install=${ac_cv_path_install='/usr/bin/install -c'}
! ac_cv_prog_AR=${ac_cv_prog_AR='ar'}
! ac_cv_prog_CPP=${ac_cv_prog_CPP='gcc -E'}
! ac_cv_prog_YACC=${ac_cv_prog_YACC='bison -y'}
! ac_cv_prog_ac_ct_CC=${ac_cv_prog_ac_ct_CC='gcc'}
! ac_cv_prog_ac_ct_RANLIB=${ac_cv_prog_ac_ct_RANLIB='ranlib'}
! ac_cv_prog_cc_g=${ac_cv_prog_cc_g='yes'}
! ac_cv_prog_cc_stdc=${ac_cv_prog_cc_stdc=''}
! ac_cv_prog_gcc_traditional=${ac_cv_prog_gcc_traditional='no'}
! ac_cv_prog_make_make_set=${ac_cv_prog_make_make_set='yes'}
! ac_cv_sizeof_char=${ac_cv_sizeof_char='1'}
  ac_cv_sizeof_char_p=${ac_cv_sizeof_char_p='4'}
+ ac_cv_sizeof_double=${ac_cv_sizeof_double='8'}
  ac_cv_sizeof_int=${ac_cv_sizeof_int='4'}
  ac_cv_sizeof_long=${ac_cv_sizeof_long='4'}
! ac_cv_sizeof_long_long=${ac_cv_sizeof_long_long='8'}
! ac_cv_sizeof_short=${ac_cv_sizeof_short='2'}
! ac_cv_sys_file_offset_bits=${ac_cv_sys_file_offset_bits='no'}
! ac_cv_sys_interpreter=${ac_cv_sys_interpreter='yes'}
! ac_cv_sys_large_files=${ac_cv_sys_large_files='no'}
! ac_cv_sys_largefile_CC=${ac_cv_sys_largefile_CC='no'}
! ac_cv_sys_posix_termios=${ac_cv_sys_posix_termios='yes'}
! ac_cv_sys_tiocgwinsz_in_termios_h=${ac_cv_sys_tiocgwinsz_in_termios_h='yes'}
! ac_cv_type_bits16_t=${ac_cv_type_bits16_t='no'}
! ac_cv_type_bits32_t=${ac_cv_type_bits32_t='no'}
! ac_cv_type_bits64_t=${ac_cv_type_bits64_t='no'}
! ac_cv_type_char=${ac_cv_type_char='yes'}
! ac_cv_type_char_p=${ac_cv_type_char_p='yes'}
! ac_cv_type_double=${ac_cv_type_double='yes'}
! ac_cv_type_getgroups=${ac_cv_type_getgroups='gid_t'}
! ac_cv_type_int=${ac_cv_type_int='yes'}
! ac_cv_type_long=${ac_cv_type_long='yes'}
! ac_cv_type_long_long=${ac_cv_type_long_long='yes'}
! ac_cv_type_mode_t=${ac_cv_type_mode_t='yes'}
! ac_cv_type_off_t=${ac_cv_type_off_t='yes'}
! ac_cv_type_pid_t=${ac_cv_type_pid_t='yes'}
! ac_cv_type_ptrdiff_t=${ac_cv_type_ptrdiff_t='yes'}
! ac_cv_type_short=${ac_cv_type_short='yes'}
! ac_cv_type_signal=${ac_cv_type_signal='void'}
! ac_cv_type_size_t=${ac_cv_type_size_t='yes'}
! ac_cv_type_ssize_t=${ac_cv_type_ssize_t='yes'}
! ac_cv_type_time_t=${ac_cv_type_time_t='yes'}
! ac_cv_type_u_bits16_t=${ac_cv_type_u_bits16_t='no'}
! ac_cv_type_u_bits32_t=${ac_cv_type_u_bits32_t='no'}
! ac_cv_type_u_int=${ac_cv_type_u_int='yes'}
! ac_cv_type_u_long=${ac_cv_type_u_long='yes'}
! ac_cv_type_uid_t=${ac_cv_type_uid_t='yes'}
! ac_cv_working_alloca_h=${ac_cv_working_alloca_h='no'}
! 
! bash_cv_decl_strtoimax=${bash_cv_decl_strtoimax='no'}
! bash_cv_decl_strtol=${bash_cv_decl_strtol='yes'}
! bash_cv_decl_strtoll=${bash_cv_decl_strtoll='no'}
! bash_cv_decl_strtoul=${bash_cv_decl_strtoul='yes'}
! bash_cv_decl_strtoull=${bash_cv_decl_strtoull='no'}
! bash_cv_decl_strtoumax=${bash_cv_decl_strtoumax='no'}
  bash_cv_decl_under_sys_siglist=${bash_cv_decl_under_sys_siglist='no'}
! bash_cv_dev_fd=${bash_cv_dev_fd='absent'}
! bash_cv_dev_stdin=${bash_cv_dev_stdin='absent'}
! bash_cv_dirent_has_d_fileno=${bash_cv_dirent_has_d_fileno='no'}
! bash_cv_dirent_has_dino=${bash_cv_dirent_has_dino='yes'}
! bash_cv_dup2_broken=${bash_cv_dup2_broken='no'}
! bash_cv_fionread_in_ioctl=${bash_cv_fionread_in_ioctl='no'}
! bash_cv_func_sigsetjmp=${bash_cv_func_sigsetjmp='present'}
! bash_cv_func_strcoll_broken=${bash_cv_func_strcoll_broken='no'}
  bash_cv_getenv_redef=${bash_cv_getenv_redef='yes'}
! bash_cv_getpw_declared=${bash_cv_getpw_declared='yes'}
! bash_cv_have_strsignal=${bash_cv_have_strsignal='yes'}
  bash_cv_job_control_missing=${bash_cv_job_control_missing='present'}
  bash_cv_mail_dir=${bash_cv_mail_dir='unknown'}
! bash_cv_must_reinstall_sighandlers=${bash_cv_must_reinstall_sighandlers='no'}
! bash_cv_opendir_not_robust=${bash_cv_opendir_not_robust='no'}
! bash_cv_pgrp_pipe=${bash_cv_pgrp_pipe='no'}
! bash_cv_printf_a_format=${bash_cv_printf_a_format='no'}
! bash_cv_signal_vintage=${bash_cv_signal_vintage='posix'}
! bash_cv_speed_t_in_sys_types=${bash_cv_speed_t_in_sys_types='no'}
! bash_cv_struct_timeval=${bash_cv_struct_timeval='yes'}
! bash_cv_struct_winsize_header=${bash_cv_struct_winsize_header='termios_h'}
! bash_cv_sys_errlist=${bash_cv_sys_errlist='no'}
! bash_cv_sys_named_pipes=${bash_cv_sys_named_pipes='present'}
! bash_cv_sys_siglist=${bash_cv_sys_siglist='no'}
! bash_cv_termcap_lib=${bash_cv_termcap_lib='libtermcap'}
! bash_cv_tiocstat_in_ioctl=${bash_cv_tiocstat_in_ioctl='no'}
! bash_cv_type_clock_t=${bash_cv_type_clock_t='yes'}
! bash_cv_type_intmax_t=${bash_cv_type_intmax_t='no'}
! bash_cv_type_long_long=${bash_cv_type_long_long='long long'}
! bash_cv_type_quad_t=${bash_cv_type_quad_t='no'}
! bash_cv_type_rlimit=${bash_cv_type_rlimit='rlim_t'}
! bash_cv_type_sigset_t=${bash_cv_type_sigset_t='yes'}
! bash_cv_type_socklen_t=${bash_cv_type_socklen_t='no'}
! bash_cv_type_uintmax_t=${bash_cv_type_uintmax_t='no'}
! bash_cv_type_unsigned_long_long=${bash_cv_type_unsigned_long_long='unsigned long long'}
! bash_cv_ulimit_maxfds=${bash_cv_ulimit_maxfds='no'}
! bash_cv_under_sys_siglist=${bash_cv_under_sys_siglist='no'}
! bash_cv_unusable_rtsigs=${bash_cv_unusable_rtsigs='no'}
! bash_cv_void_sighandler=${bash_cv_void_sighandler='yes'}
diff -Nrc2 bash-2.05/cross-build/opennt.cache bash-2.05a/cross-build/opennt.cache
*** bash-2.05/cross-build/opennt.cache	Thu Feb 18 13:09:26 1999
--- bash-2.05a/cross-build/opennt.cache	Tue Apr 10 11:00:24 2001
***************
*** 103,107 ****
  ac_cv_lib_intl_bindtextdomain=${ac_cv_lib_intl_bindtextdomain=no}
  ac_cv_lib_termcap_tgetent=${ac_cv_lib_termcap_tgetent=yes}
! ac_cv_path_install=${ac_cv_path_install='//C/OpenNT21b3/bin/install -c'}
  ac_cv_prog_AR=${ac_cv_prog_AR=ar}
  ac_cv_prog_CC=${ac_cv_prog_CC=gcc}
--- 103,107 ----
  ac_cv_lib_intl_bindtextdomain=${ac_cv_lib_intl_bindtextdomain=no}
  ac_cv_lib_termcap_tgetent=${ac_cv_lib_termcap_tgetent=yes}
! ac_cv_path_install=${ac_cv_path_install='$INTERIX_ROOT/bin/install -c'}
  ac_cv_prog_AR=${ac_cv_prog_AR=ar}
  ac_cv_prog_CC=${ac_cv_prog_CC=gcc}
diff -Nrc2 bash-2.05/cross-build/win32sig.h bash-2.05a/cross-build/win32sig.h
*** bash-2.05/cross-build/win32sig.h	Tue Oct 14 12:25:43 1997
--- bash-2.05a/cross-build/win32sig.h	Tue Nov 13 10:34:16 2001
***************
*** 1,4 ****
  /* This file is used when cross-compiling for the CYGWIN32 environment on
!    a Unix machine. */
  #include <sys/types.h>
  #include <signal.h>
--- 1,4 ----
  /* This file is used when cross-compiling for the CYGWIN32 environment on
!    a Unix machine.  It gets copied to signames.h in the build directory. */
  #include <sys/types.h>
  #include <signal.h>
***************
*** 12,16 ****
     might wind up being NULL.  */
  
! char *signal_names[NSIG + 2] = {
    [0]		"EXIT",
  
--- 12,16 ----
     might wind up being NULL.  */
  
! char *signal_names[NSIG + 3] = {
    [0]		"EXIT",
  
***************
*** 251,254 ****
    [NSIG]	"DEBUG",
  
!   [NSIG + 1]	(char *)0x0
  };
--- 251,256 ----
    [NSIG]	"DEBUG",
  
!   [NSIG + 1]	"ERR",
! 
!   [NSIG + 2]	(char *)0x0
  };
diff -Nrc2 bash-2.05/doc/FAQ bash-2.05a/doc/FAQ
*** bash-2.05/doc/FAQ	Wed Apr  4 11:09:02 2001
--- bash-2.05a/doc/FAQ	Mon Oct 29 08:35:31 2001
***************
*** 1,3 ****
! This is the Bash FAQ, version 3.11, for Bash version 2.05.
  
  This document contains a set of frequently-asked questions concerning
--- 1,3 ----
! This is the Bash FAQ, version 3.16, for Bash version 2.05.
  
  This document contains a set of frequently-asked questions concerning
***************
*** 191,195 ****
  ftp://ftp.gnustep.org//pub/win32/bash-alpha-nt-1.01.tar.gz
  
! DJ Delorie has a port of bash-1.14.7 which runs under MS-DOS, as part
  of the DJGPP project.  For more information on the project, see
  
--- 191,195 ----
  ftp://ftp.gnustep.org//pub/win32/bash-alpha-nt-1.01.tar.gz
  
! DJ Delorie has a port of bash-2.x which runs under MS-DOS, as part
  of the DJGPP project.  For more information on the project, see
  
***************
*** 198,218 ****
  I have been told that the original DJGPP port was done by Daisuke Aoyama.
  
! I picked up a binary of bash-1.14.7 that is purported to work with
! the DJGPP V2 environment from
  
! ftp://ftp.simtel.net/pub/simtelnet/gnu/djgpp/v2gnu/bsh1147b.zip
  
! The corresponding source is
! 
! ftp://ftp.simtel.net/pub/simtelnet/gnu/djgpp/v2gnu/bsh1147s.zip
! 
! Mark Elbrecht <snowball3@bigfoot.com> has sent me notice that bash-2.03
! has become available for DJGPP V2.  The files are available as:
! 
! ftp://ftp.simtel.net/pub/simtelnet/gnu/djgpp/v2gnu/bsh203b.zip	binary
! ftp://ftp.simtel.net/pub/simtelnet/gnu/djgpp/v2gnu/bsh203d.zip	documentation
! ftp://ftp.simtel.net/pub/simtelnet/gnu/djgpp/v2gnu/bsh203s.zip	source
! 
! Mark has begun to work with bash-2.04.
  
  Ports of bash-1.12 and bash-2.0 are available for OS/2 from
--- 198,209 ----
  I have been told that the original DJGPP port was done by Daisuke Aoyama.
  
! Mark Elbrecht <snowball3@bigfoot.com> has sent me notice that bash-2.04
! is available for DJGPP V2.  The files are available as:
  
! ftp://ftp.simtel.net/pub/simtelnet/gnu/djgpp/v2gnu/bsh204b.zip	binary
! ftp://ftp.simtel.net/pub/simtelnet/gnu/djgpp/v2gnu/bsh204d.zip	documentation
! ftp://ftp.simtel.net/pub/simtelnet/gnu/djgpp/v2gnu/bsh204s.zip	source
  
! Mark has begun to work with bash-2.05.
  
  Ports of bash-1.12 and bash-2.0 are available for OS/2 from
***************
*** 286,291 ****
  will have to (apparently) live with CDE using the shell in the password
  file to run its startup scripts.  If you have changed your shell to bash,
! there is code in the CDE startup files (on Solaris, at least) to do the
! right thing. 
  
  `dtterm' claims to use $SHELL as the default program to start, so if you
--- 277,283 ----
  will have to (apparently) live with CDE using the shell in the password
  file to run its startup scripts.  If you have changed your shell to bash,
! there is code in the CDE startup files (on Solaris, at least) that attempts
! to do the right thing.  It is, however, often broken, and may require that
! you use the $BASH_ENV trick described below.
  
  `dtterm' claims to use $SHELL as the default program to start, so if you
***************
*** 305,308 ****
--- 297,310 ----
  	fi
  
+ If CDE starts its shells non-interactively during login, the login shell
+ startup files (~/.profile, ~/.bash_profile) will not be sourced at login.
+ To get around this problem, append a line similar to the following to your
+ ~/.dtprofile:
+ 
+ 	BASH_ENV=${HOME}/.bash_profile ; export BASH_ENV
+ 
+ and add the following line to the beginning of ~/.bash_profile:
+ 
+ 	unset BASH_ENV
  
  A8) I just changed my login shell to bash, and now I can't FTP into my
***************
*** 351,354 ****
--- 353,362 ----
  objections.
  
+ The Open Group has made an older version of its Single Unix
+ Specification (version 2), which is very similar to POSIX.2,
+ available on the web at
+ 
+ http://www.opengroup.org/onlinepubs/007908799/
+ 
  A10)  What is the bash `posix mode'?
  
***************
*** 675,681 ****
  	`**' arithmetic operator to do exponentiation
  	redirection to /dev/fd/N, /dev/stdin, /dev/stdout, /dev/stderr
  
  Things ksh88 has or uses that bash does not:
! 	tracked aliases
  	variables: ERRNO, FPATH, EDITOR, VISUAL
  	trap on ERR
--- 683,690 ----
  	`**' arithmetic operator to do exponentiation
  	redirection to /dev/fd/N, /dev/stdin, /dev/stdout, /dev/stderr
+ 	arrays of unlimited size
  
  Things ksh88 has or uses that bash does not:
! 	tracked aliases (alias -t)
  	variables: ERRNO, FPATH, EDITOR, VISUAL
  	trap on ERR
***************
*** 687,691 ****
  		  read -p/-s/-u/var?prompt, set -A/-o gmacs/
  		  -o bgnice/-o markdirs/-o nolog/-o trackall/-o viraw/-s,
! 		  typeset -H/-L/-R/-A/-ft/-fu/-fx/-l/-u/-t, whence
  
  Implementation differences:
--- 696,703 ----
  		  read -p/-s/-u/var?prompt, set -A/-o gmacs/
  		  -o bgnice/-o markdirs/-o nolog/-o trackall/-o viraw/-s,
! 		  typeset -H/-L/-R/-Z/-A/-ft/-fu/-fx/-l/-u/-t, whence
! 	using environment to pass attributes of exported variables
! 	arithmetic evaluation done on arguments to some builtins
! 	reads .profile from $PWD when invoked as login shell
  
  Implementation differences:
***************
*** 695,698 ****
--- 707,712 ----
  	bash has exported functions
  	bash command search finds functions before builtins
+ 	bash waits for all commands in pipeline to exit before returning status
+ 	emacs-mode editing has some slightly different key bindings
  
  C3)  Which new features in ksh-93 are not in bash, and which are?
***************
*** 700,704 ****
  New things in ksh-93 not in bash-2.05:
  	associative arrays
! 	floating point arithmetic
  	math library functions
  	${!name[sub]} name of subscript for associative array
--- 714,718 ----
  New things in ksh-93 not in bash-2.05:
  	associative arrays
! 	floating point arithmetic and variables
  	math library functions
  	${!name[sub]} name of subscript for associative array
***************
*** 711,720 ****
  	variables: .sh.edchar, .sh.edmode, .sh.edcol, .sh.edtext, .sh.version,
  		   .sh.name, .sh.subscript, .sh.value, HISTEDIT
! 	backreferences in pattern matching
  	print -f (bash uses printf)
  	`fc' has been renamed to `hist'
  	`.' can execute shell functions
  
! New things in ksh-93 present in bash-2.04:
          for (( expr1; expr2; expr3 )) ; do list; done - arithmetic for command
          ?:, ++, --, `expr1 , expr2' arithmetic operators
--- 725,745 ----
  	variables: .sh.edchar, .sh.edmode, .sh.edcol, .sh.edtext, .sh.version,
  		   .sh.name, .sh.subscript, .sh.value, HISTEDIT
! 	backreferences in pattern matching (\N)
! 	`&' operator in pattern lists for matching
  	print -f (bash uses printf)
  	`fc' has been renamed to `hist'
  	`.' can execute shell functions
+ 	exit statuses between 0 and 255
+ 	set -o pipefail
+ 	`+=' variable assignment operator
+ 	TMOUT is default timeout for `read' and `select'
+ 	<&N- and >&N- redirections (combination dup and close)
+ 	FPATH and PATH mixing
+ 	getopts -a
+ 	-I invocation option
+ 	DEBUG trap now executed before each simple command, instead of after
+ 	printf %H, %P, %T modifiers, output base for %d
  
! New things in ksh-93 present in bash-2.05:
          for (( expr1; expr2; expr3 )) ; do list; done - arithmetic for command
          ?:, ++, --, `expr1 , expr2' arithmetic operators
***************
*** 1042,1045 ****
--- 1067,1080 ----
  set $IFS to a different value.
  
+ Some other user-supplied alternatives include:
+ 
+ read A B C D << HERE
+     $(IFS=.; echo $(/usr/local/bin/ipaddr))
+ HERE
+ 
+ and, where process substitution is available,
+ 
+ read A B C D < <(IFS=.; echo $(/usr/local/bin/ipaddr))
+ 
  E5) I have a bunch of shell scripts that use backslash-escaped characters
      in arguments to `echo'.  Bash doesn't interpret these characters.  Why
***************
*** 1525,1529 ****
  H3) What's coming in future versions?
  
! These are features I plan to include in a future version of bash.
  
  a bash debugger (a minimally-tested version is included with bash-2.05)
--- 1560,1564 ----
  H3) What's coming in future versions?
  
! These are features I hope to include in a future version of bash.
  
  a bash debugger (a minimally-tested version is included with bash-2.05)
***************
*** 1533,1536 ****
--- 1568,1572 ----
  versions)
  an implementation of the ksh-like ERR trap
+ co-processes, but with a new-style syntax that looks like function declaration
  
  H4) What's on the bash `wish list' for future versions?
diff -Nrc2 bash-2.05/doc/Makefile.in bash-2.05a/doc/Makefile.in
*** bash-2.05/doc/Makefile.in	Mon Mar 19 10:14:11 2001
--- bash-2.05a/doc/Makefile.in	Wed May  2 11:43:33 2001
***************
*** 33,43 ****
  htmldir = @htmldir@
  
  mandir = @mandir@
  manpfx = man
  
! man1ext = 1
! man1dir = $(mandir)/$(manpfx)$(man1ext)
! man3ext = 3
! man3dir = $(mandir)/$(manpfx)$(man3ext) 
  
  INSTALL = @INSTALL@
--- 33,46 ----
  htmldir = @htmldir@
  
+ # Support an alternate destination root directory for package building
+ DESTDIR =
+ 
  mandir = @mandir@
  manpfx = man
  
! man1ext = .1
! man1dir = $(mandir)/$(manpfx)1
! man3ext = .3
! man3dir = $(mandir)/$(manpfx)3
  
  INSTALL = @INSTALL@
***************
*** 168,199 ****
  	-( cd ${BUILD_DIR}/support ; ${MAKE} ${MFLAGS} man2html)
  
- CREATED_FAQ = faq.news faq.news2 faq.mail faq.version
- 
- faq:	${CREATED_FAQ}
- 
- faq.version:	FAQ.version FAQ
- 	sh mkfaqvers FAQ.version > $@
- 
- faq.headers.mail: FAQ.headers.mail FAQ
- 	sh mkfaqvers FAQ.headers.mail > $@
- 
- faq.headers.news: FAQ.headers.news FAQ
- 	sh mkfaqvers FAQ.headers.news > $@
- 
- faq.headers.news2: FAQ.headers.news2 FAQ
- 	sh mkfaqvers FAQ.headers.news2 > $@
- 
- faq.news: FAQ faq.headers.news faq.version
- 	$(RM) $@
- 	cat faq.headers.news faq.version FAQ > $@
- 
- faq.news2: FAQ faq.headers.news2 faq.version
- 	$(RM) $@
- 	cat faq.headers.news2 faq.version FAQ > $@
- 
- faq.mail: FAQ faq.headers.mail faq.version
- 	$(RM) $@
- 	cat faq.headers.mail faq.version FAQ > $@
- 
  clean:
  	$(RM) *.aux *.bak *.cp *.fn *.ky *.log *.pg *.toc *.tp *.vr *.cps \
--- 171,174 ----
***************
*** 210,244 ****
  
  installdirs:
! 	-test -d $(man1dir) || $(SHELL) ${MKDIRS} $(man1dir)
! 	-test -d $(infodir) || $(SHELL) ${MKDIRS} $(infodir)
! 	-if [ -n "$(htmldir)" ]; then \
! 		test -d $(htmldir) || $(SHELL) ${MKDIRS} $(htmldir) ; \
  	fi
  	
  install: info installdirs
! 	-$(INSTALL_DATA) $(srcdir)/bash.1 $(man1dir)/bash.${man1ext}
! 	-$(INSTALL_DATA) $(srcdir)/bashbug.1 $(man1dir)/bashbug.${man1ext}
  # uncomment the next line to install the builtins man page
! #	$(INSTALL_DATA) $(srcdir)/builtins.1 $(man1dir)/bash_builtins.${man1ext}
! 	-$(INSTALL_DATA) $(srcdir)/bashref.info $(infodir)/bash.info
  # run install-info if it is present to update the info directory
  	if $(SHELL) -c 'install-info --version' >/dev/null 2>&1; then \
! 		install-info --dir-file=$(infodir)/dir $(infodir)/bash.info; \
  	else true; fi
  # if htmldir is set, install the html files into that directory
! 	-if [ -n "${htmldir}" ]; then \
! 		$(INSTALL_DATA) $(srcdir)/bash.html $(htmldir) ; \
! 		$(INSTALL_DATA) $(srcdir)/bashref.html $(htmldir) ; \
  	fi
  
  uninstall:
! 	-$(RM) $(man1dir)/bash.${man1ext} $(man1dir)/bashbug.${man1ext}
! 	$(RM) $(infodir)/bash.info
! 	-if [ -n "$(htmldir)" ]; then \
! 		$(RM) $(htmldir)/bash.html ; \
! 		$(RM) $(htmldir)/bashref.html ; \
  	fi
  
  # for use by chet
  inst:	bashref.texi
  	$(SHELL) ./mkinstall
--- 185,247 ----
  
  installdirs:
! 	-test -d $(man1dir) || $(SHELL) ${MKDIRS} $(DESTDIR)$(man1dir)
! 	-test -d $(infodir) || $(SHELL) ${MKDIRS} $(DESTDIR)$(infodir)
! 	-if test -n "$(htmldir)" ; then \
! 		test -d $(htmldir) || $(SHELL) ${MKDIRS} $(DESTDIR)$(htmldir) ; \
  	fi
  	
  install: info installdirs
! 	-$(INSTALL_DATA) $(srcdir)/bash.1 $(DESTDIR)$(man1dir)/bash${man1ext}
! 	-$(INSTALL_DATA) $(srcdir)/bashbug.1 $(DESTDIR)$(man1dir)/bashbug${man1ext}
  # uncomment the next line to install the builtins man page
! #	-$(INSTALL_DATA) $(srcdir)/builtins.1 $(DESTDIR)$(man1dir)/bash_builtins${man1ext}
! 	-$(INSTALL_DATA) $(srcdir)/bashref.info $(DESTDIR)$(infodir)/bash.info
  # run install-info if it is present to update the info directory
  	if $(SHELL) -c 'install-info --version' >/dev/null 2>&1; then \
! 		install-info --dir-file=$(DESTDIR)$(infodir)/dir $(DESTDIR)$(infodir)/bash.info; \
  	else true; fi
  # if htmldir is set, install the html files into that directory
! 	-if test -n "${htmldir}" ; then \
! 		$(INSTALL_DATA) $(srcdir)/bash.html $(DESTDIR)$(htmldir) ; \
! 		$(INSTALL_DATA) $(srcdir)/bashref.html $(DESTDIR)$(htmldir) ; \
  	fi
  
  uninstall:
! 	-$(RM) $(DESTDIR)$(man1dir)/bash${man1ext} $(DESTDIR)$(man1dir)/bashbug${man1ext}
! 	$(RM) $(DESTDIR)$(infodir)/bash.info
! 	-if test -n "$(htmldir)" ; then \
! 		$(RM) $(DESTDIR)$(htmldir)/bash.html ; \
! 		$(RM) $(DESTDIR)$(htmldir)/bashref.html ; \
  	fi
  
  # for use by chet
+ CREATED_FAQ = faq.news faq.news2 faq.mail faq.version
+ 
+ faq:	${CREATED_FAQ}
+ 
+ faq.version:	FAQ.version FAQ
+ 	sh mkfaqvers FAQ.version > $@
+ 
+ faq.headers.mail: FAQ.headers.mail FAQ
+ 	sh mkfaqvers FAQ.headers.mail > $@
+ 
+ faq.headers.news: FAQ.headers.news FAQ
+ 	sh mkfaqvers FAQ.headers.news > $@
+ 
+ faq.headers.news2: FAQ.headers.news2 FAQ
+ 	sh mkfaqvers FAQ.headers.news2 > $@
+ 
+ faq.news: FAQ faq.headers.news faq.version
+ 	$(RM) $@
+ 	cat faq.headers.news faq.version FAQ > $@
+ 
+ faq.news2: FAQ faq.headers.news2 faq.version
+ 	$(RM) $@
+ 	cat faq.headers.news2 faq.version FAQ > $@
+ 
+ faq.mail: FAQ faq.headers.mail faq.version
+ 	$(RM) $@
+ 	cat faq.headers.mail faq.version FAQ > $@
+ 
  inst:	bashref.texi
  	$(SHELL) ./mkinstall
diff -Nrc2 bash-2.05/doc/bash.1 bash-2.05a/doc/bash.1
*** bash-2.05/doc/bash.1	Mon Mar  5 14:41:30 2001
--- bash-2.05a/doc/bash.1	Tue Nov 13 12:55:59 2001
***************
*** 7,16 ****
  .\"	chet@ins.CWRU.Edu
  .\"
! .\"	Last Change: Mon Mar  5 10:19:14 EST 2001
  .\"
  .\" bash_builtins, strip all but Built-Ins section
  .if \n(zZ=1 .ig zZ
  .if \n(zY=1 .ig zY
! .TH BASH 1 "2001 Mar 5" "GNU Bash-2.05"
  .\"
  .\" There's some problem with having a `@'
--- 7,16 ----
  .\"	chet@ins.CWRU.Edu
  .\"
! .\"	Last Change: Tue Nov 13 12:55:51 EST 2001
  .\"
  .\" bash_builtins, strip all but Built-Ins section
  .if \n(zZ=1 .ig zZ
  .if \n(zY=1 .ig zY
! .TH BASH 1 "2001 November 13" "GNU Bash-2.05a"
  .\"
  .\" There's some problem with having a `@'
***************
*** 114,117 ****
--- 114,130 ----
  This implies the \fB\-n\fP option; no commands will be executed.
  .TP
+ .B [\-+]O [\fIshopt_option\fP]
+ \fIshopt_option\fP is one of the shell options accepted by the
+ \fBshopt\fP builtin (see
+ .SM
+ .B SHELL BUILTIN COMMANDS
+ below).
+ If \fIshopt_option\fP is present, \fB\-O\fP sets the value of that option;
+ \fB+O\fP unsets it.
+ If \fIshopt_option\fP is not supplied, the names and values of the shell
+ options accepted by \fBshopt\fP are printed on the standard output.
+ If the invocation option is \fB+O\fP, the output is displayed in a format
+ that may be reused as input.
+ .TP
  .B \-\-
  A
***************
*** 227,230 ****
--- 240,248 ----
  executed in the script.
  If no commands are executed, the exit status is 0.
+ An attempt is first made to open the file in the current directory, and,
+ if no file is found, then the shell searches the directories in
+ .SM
+ .B PATH
+ for the script.
  .SH INVOCATION
  A \fIlogin shell\fP is one whose first character of argument zero is a
***************
*** 391,396 ****
  If the shell is started with the effective user (group) id not equal to the
  real user (group) id, and the \fB\-p\fP option is not supplied, no startup
! files are read, shell functions are not inherited from the environment,
! the \fBSHELLOPTS\fP variable, if it appears in the environment, is ignored,
  and the effective user id is set to the real user id.
  If the \fB\-p\fP option is supplied at invocation, the startup behavior is
--- 409,416 ----
  If the shell is started with the effective user (group) id not equal to the
  real user (group) id, and the \fB\-p\fP option is not supplied, no startup
! files are read, shell functions are not inherited from the environment, the
! .SM
! .B SHELLOPTS
! variable, if it appears in the environment, is ignored,
  and the effective user id is set to the real user id.
  If the \fB\-p\fP option is supplied at invocation, the startup behavior is
***************
*** 461,466 ****
  followed by \fBblank\fP-separated words and redirections, and
  terminated by a \fIcontrol operator\fP.  The first word
! specifies the command to be executed.  The remaining words are
! passed as arguments to the invoked command.
  .PP
  The return value of a \fIsimple command\fP is its exit status, or
--- 481,486 ----
  followed by \fBblank\fP-separated words and redirections, and
  terminated by a \fIcontrol operator\fP.  The first word
! specifies the command to be executed, and is passed as argument zero.
! The remaining words are passed as arguments to the invoked command.
  .PP
  The return value of a \fIsimple command\fP is its exit status, or
***************
*** 480,484 ****
  The standard output of
  .I command
! is connected to the standard input of
  .IR command2 .
  This connection is performed before any redirections specified by the
--- 500,504 ----
  The standard output of
  .I command
! is connected via a pipe to the standard input of
  .IR command2 .
  This connection is performed before any redirections specified by the
***************
*** 596,599 ****
--- 616,623 ----
  The return status is the exit status of
  \fIlist\fP.
+ Note that unlike the metacharacters \fB(\fP and \fB\)\fP, \fB{\fP and
+ \fB}\fP are \fIreserved words\fP and must occur where a reserved
+ word is permitted to be recognized.  Since they do not cause a word
+ break, they must be separated from \fIlist\fP by whitespace.
  .TP
  ((\fIexpression\fP))
***************
*** 658,662 ****
  is true.
  .PD
- .RE
  .LP
  The \fB&&\fP and
--- 682,685 ----
***************
*** 666,669 ****
--- 689,693 ----
  \fIexpression1\fP is sufficient to determine the return value of
  the entire conditional expression.
+ .RE
  .TP
  \fBfor\fP \fIname\fP [ \fBin\fP \fIword\fP ] ; \fBdo\fP \fIlist\fP ; \fBdone\fP
***************
*** 717,722 ****
  is executed after each selection until a
  .B break
- or
- .B return
  command is executed.
  The exit status of
--- 741,744 ----
***************
*** 902,911 ****
  .TP   
  .B \e\fInnn\fP
! the character whose ASCII code is the octal value \fInnn\fP
  (one to three digits)
  .TP
! .B \ex\fInnn\fP
! the character whose ASCII code is the hexadecimal value \fInnn\fP
! (one to three digits)
  .PD
  .RE
--- 924,933 ----
  .TP   
  .B \e\fInnn\fP
! the eight-bit character whose value is the octal value \fInnn\fP
  (one to three digits)
  .TP
! .B \ex\fIHH\fP
! the eight-bit character whose value is the hexadecimal value \fIHH\fP
! (one or two hex digits)
  .PD
  .RE
***************
*** 932,935 ****
--- 954,965 ----
  is a parameter denoted by a
  .IR name .
+ A variable has a \fIvalue\fP and zero or more \fIattributes\fP.
+ Attributes are assigned using the
+ .B declare
+ builtin command (see
+ .B declare
+ below in
+ .SM
+ .BR "SHELL BUILTIN COMMANDS" ).
  .PP
  A parameter is set if it has been assigned a value.  The null string is
***************
*** 961,970 ****
  below).  If the variable has its
  .B integer
! attribute set (see
! .B declare
! below in
! .SM
! .BR "SHELL BUILTIN COMMANDS" )
! then
  .I value
  is subject to arithmetic expansion even if the $((...)) expansion is
--- 991,995 ----
  below).  If the variable has its
  .B integer
! attribute set, then
  .I value
  is subject to arithmetic expansion even if the $((...)) expansion is
***************
*** 976,979 ****
--- 1001,1012 ----
  .BR "Special Parameters" .
  Pathname expansion is not performed.
+ Assignment statements may also appear as arguments to the
+ .BR declare ,
+ .BR typeset ,
+ .BR export ,
+ .BR readonly ,
+ and
+ .B local
+ builtin commands.
  .SS Positional Parameters
  .PP
***************
*** 1093,1143 ****
  .PD 0
  .TP
- .B PPID
- The process ID of the shell's parent.  This variable is readonly.
- .TP
- .B PWD
- The current working directory as set by the
- .B cd
- command.
- .TP
- .B OLDPWD
- The previous working directory as set by the
- .B cd
- command.
- .TP
- .B REPLY
- Set to the line of input read by the
- .B read
- builtin command when no arguments are supplied.
- .TP
- .B UID
- Expands to the user ID of the current user, initialized at shell startup.
- This variable is readonly.
- .TP
- .B EUID
- Expands to the effective user ID of the current user, initialized at
- shell startup.  This variable is readonly.
- .TP
- .B GROUPS
- An array variable containing the list of groups of which the current
- user is a member.
- Assignments to    
- .SM
- .B GROUPS
- have no effect and return an error status.
- If
- .SM
- .B GROUPS
- is unset, it loses its special properties, even if it is
- subsequently reset.
- .TP
  .B BASH
  Expands to the full file name used to invoke this instance of
  .BR bash .
  .TP
- .B BASH_VERSION
- Expands to a string describing the version of this instance of
- .BR bash .
- .TP
  .B BASH_VERSINFO
  A readonly array variable whose members hold version information for
--- 1126,1133 ----
***************
*** 1169,1214 ****
  .RE
  .TP
! .B SHLVL
! Incremented by one each time an instance of
! .B bash
! is started.
  .TP
! .B RANDOM
! Each time this parameter is referenced, a random integer between
! 0 and 32767 is
! generated.  The sequence of random numbers may be initialized by assigning
! a value to
! .SM
! .BR RANDOM .
  If
  .SM
! .B RANDOM
  is unset, it loses its special properties, even if it is
  subsequently reset.
  .TP
! .B SECONDS
! Each time this parameter is
! referenced, the number of seconds since shell invocation is returned.  If a
! value is assigned to 
  .SM
! .BR SECONDS ,
! the value returned upon subsequent
! references is
! the number of seconds since the assignment plus the value assigned.
  If
  .SM
! .B SECONDS
  is unset, it loses its special properties, even if it is
  subsequently reset.
  .TP
! .B LINENO
! Each time this parameter is referenced, the shell substitutes
! a decimal number representing the current sequential line number
! (starting with 1) within a script or function.  When not in a
! script or function, the value substituted is not guaranteed to
! be meaningful.
  If
  .SM
! .B LINENO
  is unset, it loses its special properties, even if it is
  subsequently reset.
--- 1159,1244 ----
  .RE
  .TP
! .B BASH_VERSION
! Expands to a string describing the version of this instance of
! .BR bash .
  .TP
! .B COMP_CWORD
! An index into \fB${COMP_WORDS}\fP of the word containing the current
! cursor position.
! This variable is available only in shell functions invoked by the
! programmable completion facilities (see \fBProgrammable Completion\fP
! below).
! .TP
! .B COMP_LINE
! The current command line.
! This variable is available only in shell functions and external
! commands invoked by the
! programmable completion facilities (see \fBProgrammable Completion\fP
! below).
! .TP
! .B COMP_POINT
! The index of the current cursor position relative to the beginning of
! the current command.
! If the current cursor position is at the end of the current command,
! the value of this variable is equal to \fB${#COMP_LINE}\fP.
! This variable is available only in shell functions and external
! commands invoked by the
! programmable completion facilities (see \fBProgrammable Completion\fP
! below).
! .TP
! .B COMP_WORDS
! An array variable (see \fBArrays\fP below) consisting of the individual
! words in the current command line.
! This variable is available only in shell functions invoked by the
! programmable completion facilities (see \fBProgrammable Completion\fP
! below).
! .TP
! .B DIRSTACK
! An array variable (see
! .B Arrays
! below) containing the current contents of the directory stack.
! Directories appear in the stack in the order they are displayed by the
! .B dirs
! builtin.
! Assigning to members of this array variable may be used to modify
! directories already in the stack, but the
! .B pushd
! and
! .B popd
! builtins must be used to add and remove directories.
! Assignment to this variable will not change the current directory.
  If
  .SM
! .B DIRSTACK
  is unset, it loses its special properties, even if it is
  subsequently reset.
  .TP
! .B EUID
! Expands to the effective user ID of the current user, initialized at
! shell startup.  This variable is readonly.
! .TP
! .B FUNCNAME
! The name of any currently-executing shell function.
! This variable exists only when a shell function is executing.
! Assignments to
  .SM
! .B FUNCNAME
! have no effect and return an error status.
  If
  .SM
! .B FUNCNAME
  is unset, it loses its special properties, even if it is
  subsequently reset.
  .TP
! .B GROUPS
! An array variable containing the list of groups of which the current
! user is a member.
! Assignments to    
! .SM
! .B GROUPS
! have no effect and return an error status.
  If
  .SM
! .B GROUPS
  is unset, it loses its special properties, even if it is
  subsequently reset.
***************
*** 1223,1265 ****
  subsequently reset.
  .TP
! .B FUNCNAME
! The name of any currently-executing shell function.
! This variable exists only when a shell function is executing.
! Assignments to
! .SM
! .B FUNCNAME
! have no effect and return an error status.
! If
! .SM
! .B FUNCNAME
! is unset, it loses its special properties, even if it is
! subsequently reset.
  .TP
! .B DIRSTACK
! An array variable (see
! .B Arrays
! below) containing the current contents of the directory stack.
! Directories appear in the stack in the order they are displayed by the
! .B dirs
! builtin.
! Assigning to members of this array variable may be used to modify
! directories already in the stack, but the
! .B pushd
! and
! .B popd
! builtins must be used to add and remove directories.
! Assignment to this variable will not change the current directory.
  If
  .SM
! .B DIRSTACK
  is unset, it loses its special properties, even if it is
  subsequently reset.
  .TP
! .B PIPESTATUS
! An array variable (see
! .B Arrays
! below) containing a list of exit status values from the processes
! in the most-recently-executed foreground pipeline (which may
! contain only a single command).
  .TP
  .B OPTARG
--- 1253,1289 ----
  subsequently reset.
  .TP
! .B HOSTNAME
! Automatically set to the name of the current host.
  .TP
! .B HOSTTYPE
! Automatically set to a string that uniquely
! describes the type of machine on which
! .B bash
! is executing.
! The default is system-dependent.
! .TP
! .B LINENO
! Each time this parameter is referenced, the shell substitutes
! a decimal number representing the current sequential line number
! (starting with 1) within a script or function.  When not in a
! script or function, the value substituted is not guaranteed to
! be meaningful.
  If
  .SM
! .B LINENO
  is unset, it loses its special properties, even if it is
  subsequently reset.
  .TP
! .B MACHTYPE
! Automatically set to a string that fully describes the system
! type on which
! .B bash
! is executing, in the standard GNU \fIcpu-company-system\fP format.
! The default is system-dependent.
! .TP
! .B OLDPWD
! The previous working directory as set by the
! .B cd
! command.
  .TP
  .B OPTARG
***************
*** 1279,1292 ****
  below).
  .TP
- .B HOSTNAME
- Automatically set to the name of the current host.
- .TP
- .B HOSTTYPE
- Automatically set to a string that uniquely
- describes the type of machine on which
- .B bash
- is executing.
- The default is system-dependent.
- .TP
  .B OSTYPE
  Automatically set to a string that
--- 1303,1306 ----
***************
*** 1296,1316 ****
  The default is system-dependent.
  .TP
! .B MACHTYPE
! Automatically set to a string that fully describes the system
! type on which
! .B bash
! is executing, in the standard GNU \fIcpu-company-system\fP format.
! The default is system-dependent.
  .TP
! .B SHELLOPTS
! A colon-separated list of enabled shell options.  Each word in
! the list is a valid argument for the
! .B \-o
! option to the
! .B set
! builtin command (see
! .SM
! .B "SHELL BUILTIN COMMANDS"
! below).  The options appearing in
  .SM
  .B SHELLOPTS
--- 1310,1371 ----
  The default is system-dependent.
  .TP
! .B PIPESTATUS
! An array variable (see
! .B Arrays
! below) containing a list of exit status values from the processes
! in the most-recently-executed foreground pipeline (which may
! contain only a single command).
  .TP
! .B PPID
! The process ID of the shell's parent.  This variable is readonly.
! .TP
! .B PWD
! The current working directory as set by the
! .B cd
! command.
! .TP
! .B RANDOM
! Each time this parameter is referenced, a random integer between
! 0 and 32767 is
! generated.  The sequence of random numbers may be initialized by assigning
! a value to
! .SM
! .BR RANDOM .
! If
! .SM
! .B RANDOM
! is unset, it loses its special properties, even if it is
! subsequently reset.
! .TP
! .B REPLY
! Set to the line of input read by the
! .B read
! builtin command when no arguments are supplied.
! .TP
! .B SECONDS
! Each time this parameter is
! referenced, the number of seconds since shell invocation is returned.  If a
! value is assigned to 
! .SM
! .BR SECONDS ,
! the value returned upon subsequent
! references is
! the number of seconds since the assignment plus the value assigned.
! If
! .SM
! .B SECONDS
! is unset, it loses its special properties, even if it is
! subsequently reset.
! .TP
! .B SHELLOPTS
! A colon-separated list of enabled shell options.  Each word in
! the list is a valid argument for the
! .B \-o
! option to the
! .B set
! builtin command (see
! .SM
! .B "SHELL BUILTIN COMMANDS"
! below).  The options appearing in
  .SM
  .B SHELLOPTS
***************
*** 1324,1357 ****
  This variable is read-only.
  .TP
! .B COMP_WORDS
! An array variable (see \fBArrays\fP below) consisting of the individual
! words in the current command line.
! This variable is available only in shell functions invoked by the
! programmable completion facilities (see \fBProgrammable Completion\fP
! below).
! .TP
! .B COMP_CWORD
! An index into \fB${COMP_WORDS}\fP of the word containing the current
! cursor position.
! This variable is available only in shell functions invoked by the
! programmable completion facilities (see \fBProgrammable Completion\fP
! below).
! .TP
! .B COMP_LINE
! The current command line.
! This variable is available only in shell functions and external
! commands invoked by the
! programmable completion facilities (see \fBProgrammable Completion\fP
! below).
  .TP
! .B COMP_POINT
! The index of the current cursor position relative to the beginning of
! the current command.
! If the current cursor position is at the end of the current command,
! the value of this variable is equal to \fB${#COMP_LINE}\fP.
! This variable is available only in shell functions and external
! commands invoked by the
! programmable completion facilities (see \fBProgrammable Completion\fP
! below).
  .PD
  .PP
--- 1379,1390 ----
  This variable is read-only.
  .TP
! .B SHLVL
! Incremented by one each time an instance of
! .B bash
! is started.
  .TP
! .B UID
! Expands to the user ID of the current user, initialized at shell startup.
! This variable is readonly.
  .PD
  .PP
***************
*** 1363,1404 ****
  .PD 0
  .TP
- .B IFS
- The
- .I Internal Field Separator
- that is used
- for word splitting after expansion and to
- split lines into words with the
- .B read
- builtin command.  The default value is
- ``<space><tab><newline>''.
- .TP
- .B PATH
- The search path for commands.  It
- is a colon-separated list of directories in which
- the shell looks for commands (see
- .SM
- .B COMMAND EXECUTION
- below).  The default path is system-dependent,
- and is set by the administrator who installs
- .BR bash .
- A common value is
- .if t \f(CW/usr/gnu/bin:/usr/local/bin:/usr/ucb:/bin:/usr/bin:.\fP.
- .if n ``/usr/gnu/bin:/usr/local/bin:/usr/ucb:/bin:/usr/bin:.''.
- .TP
- .B HOME
- The home directory of the current user; the default argument for the
- \fBcd\fP builtin command.
- The value of this variable is also used when performing tilde expansion.
- .TP
- .B CDPATH
- The search path for the
- .B cd
- command.
- This is a colon-separated list of directories in which the shell looks
- for destination directories specified by the
- .B cd
- command.
- A sample value is ``.:~:/usr''.
- .TP
  .B BASH_ENV
  If this parameter is set when \fBbash\fP is executing a shell script,
--- 1396,1399 ----
***************
*** 1415,1535 ****
  is not used to search for the resultant file name.
  .TP
! .B MAIL
! If this parameter is set to a file name and the
! .SM
! .B MAILPATH
! variable is not set,
! .B bash
! informs the user of the arrival of mail in the specified file.
! .TP
! .B MAILCHECK
! Specifies how
! often (in seconds)
! .B bash
! checks for mail.  The default is 60 seconds.  When it is time to check
! for mail, the shell does so before displaying the primary prompt.
! If this variable is unset, or set to a value that is not a number
! greater than or equal to zero, the shell disables mail checking.
  .TP
! .B MAILPATH
! A colon-separated list of file names to be checked for mail. 
! The message to be printed when mail arrives in a particular file
! may be specified by separating the file name from the message with a `?'.
! When used in the text of the message, \fB$_\fP expands to the name of
! the current mailfile. 
! Example:
! .RS
! .PP
! \fBMAILPATH\fP='/var/mail/bfox?"You have mail":~/shell\-mail?"$_ has mail!"'
! .PP
! .B Bash
! supplies a default value for this variable, but the location of the user
! mail files that it uses is system dependent (e.g., /var/mail/\fB$USER\fP).
! .RE
  .TP
! .B PS1
! The value of this parameter is expanded (see
! .SM
! .B PROMPTING
! below) and used as the primary prompt string.  The default value is
! ``\fB\es\-\ev\e$ \fP''.
  .TP
! .B PS2
! The value of this parameter is expanded as with
! .B PS1
! and used as the secondary prompt string.  The default is
! ``\fB> \fP''.
  .TP
! .B PS3
! The value of this parameter is used as the prompt for the
! .B select
! command (see
  .SM
! .B SHELL GRAMMAR
! above).
! .TP
! .B PS4
! The value of this parameter is expanded as with
! .B PS1
! and the value is printed before each command
! .B bash
! displays during an execution trace.  The first character of
  .SM
! .B PS4
! is replicated multiple times, as necessary, to indicate multiple
! levels of indirection.  The default is ``\fB+ \fP''.
! .TP
! .B TIMEFORMAT
! The value of this parameter is used as a format string specifying
! how the timing information for pipelines prefixed with the
! .B time
! reserved word should be displayed.
! The \fB%\fP character introduces an escape sequence that is
! expanded to a time value or other information.
! The escape sequences and their meanings are as follows; the
! braces denote optional portions.
! .sp .5
! .RS
! .PD 0
! .TP 10
! .B %%
! A literal \fB%\fP.
! .TP
! .B %[\fIp\fP][l]R
! The elapsed time in seconds.
! .TP
! .B %[\fIp\fP][l]U
! The number of CPU seconds spent in user mode.
! .TP
! .B %[\fIp\fP][l]S
! The number of CPU seconds spent in system mode.
! .TP
! .B %P
! The CPU percentage, computed as (%U + %S) / %R.
! .PD
! .RE
! .IP
! The optional \fIp\fP is a digit specifying the \fIprecision\fP,
! the number of fractional digits after a decimal point.
! A value of 0 causes no decimal point or fraction to be output.
! At most three places after the decimal point may be specified;
! values of \fIp\fP greater than 3 are changed to 3.
! If \fIp\fP is not specified, the value 3 is used.
! .IP
! The optional \fBl\fP specifies a longer format, including
! minutes, of the form \fIMM\fPm\fISS\fP.\fIFF\fPs.
! The value of \fIp\fP determines whether or not the fraction is
! included.
! .IP
! If this variable is not set, \fBbash\fP acts as if it had the
! value \fB$'\enreal\et%3lR\enuser\et%3lU\ensys\t%3lS'\fP.
! If the value is null, no timing information is displayed.
! A trailing newline is added when the format string is displayed.
  .TP
! .B HISTSIZE
! The number of commands to remember in the command history (see
  .SM
! .B HISTORY
! below).  The default value is 500.
  .TP
  .B HISTFILE
--- 1410,1480 ----
  is not used to search for the resultant file name.
  .TP
! .B CDPATH
! The search path for the
! .B cd
! command.
! This is a colon-separated list of directories in which the shell looks
! for destination directories specified by the
! .B cd
! command.
! A sample value is ``.:~:/usr''.
  .TP
! .B COLUMNS
! Used by the \fBselect\fP builtin command to determine the terminal width
! when printing selection lists.  Automatically set upon receipt of a SIGWINCH.
  .TP
! .B COMPREPLY
! An array variable from which \fBbash\fP reads the possible completions
! generated by a shell function invoked by the programmable completion
! facility (see \fBProgrammable Completion\fP below).
  .TP
! .B FCEDIT
! The default editor for the
! .B fc
! builtin command.
  .TP
! .B FIGNORE
! A colon-separated list of suffixes to ignore when performing
! filename completion (see
  .SM
! .B READLINE
! below).
! A filename whose suffix matches one of the entries in 
  .SM
! .B FIGNORE
! is excluded from the list of matched filenames.
! A sample value is ``.o:~''.
  .TP
! .B GLOBIGNORE
! A colon-separated list of patterns defining the set of filenames to
! be ignored by pathname expansion.
! If a filename matched by a pathname expansion pattern also matches one
! of the patterns in
  .SM
! .BR GLOBIGNORE ,
! it is removed from the list of matches.
! .TP
! .B HISTCONTROL
! If set to a value of
! .IR ignorespace ,
! lines which begin with a
! .B space
! character are not entered on the history list.
! If set to a value of
! .IR ignoredups ,
! lines matching the last history line are not entered.
! A value of
! .I ignoreboth
! combines the two options.
! If unset, or if set to any other value than those above,
! all lines read
! by the parser are saved on the history list, subject to the value
! of
! .BR HISTIGNORE .
! This variable's function is superseded by
! .BR HISTIGNORE .
! The second and subsequent lines of a multi-line compound command are
! not tested, and are added to the history regardless of the value of
! .BR HISTCONTROL .
  .TP
  .B HISTFILE
***************
*** 1547,1563 ****
  writing it when an interactive shell exits.
  .TP
! .B OPTERR
! If set to the value 1,
  .B bash
! displays error messages generated by the
! .B getopts
! builtin command (see
  .SM
! .B SHELL BUILTIN COMMANDS
! below).
  .SM
! .B OPTERR
! is initialized to 1 each time the shell is invoked or a shell
! script is executed.
  .TP
  .B LANG
--- 1492,1580 ----
  writing it when an interactive shell exits.
  .TP
! .B HISTIGNORE
! A colon-separated list of patterns used to decide which command lines
! should be saved on the history list.  Each pattern is anchored at the
! beginning of the line and must match the complete line (no implicit
! `\fB*\fP' is appended).  Each pattern is tested against the line
! after the checks specified by
! .B HISTCONTROL
! are applied.
! In addition to the normal shell pattern matching characters, `\fB&\fP'
! matches the previous history line.  `\fB&\fP' may be escaped using a
! backslash; the backslash is removed before attempting a match.
! The second and subsequent lines of a multi-line compound command are
! not tested, and are added to the history regardless of the value of
! .BR HISTIGNORE .
! .TP
! .B HISTSIZE
! The number of commands to remember in the command history (see
! .SM
! .B HISTORY
! below).  The default value is 500.
! .TP
! .B HOME
! The home directory of the current user; the default argument for the
! \fBcd\fP builtin command.
! The value of this variable is also used when performing tilde expansion.
! .TP
! .B HOSTFILE
! Contains the name of a file in the same format as
! .FN /etc/hosts
! that should be read when the shell needs to complete a
! hostname.
! The list of possible hostname completions may be changed while the
! shell is running;
! the next time hostname completion is attempted after the
! value is changed,
  .B bash
! adds the contents of the new file to the existing list.
! If
  .SM
! .B HOSTFILE
! is set, but has no value, \fBbash\fP attempts to read
! .FN /etc/hosts
! to obtain the list of possible hostname completions.
! When
  .SM
! .B HOSTFILE
! is unset, the hostname list is cleared.
! .TP
! .B IFS
! The
! .I Internal Field Separator
! that is used
! for word splitting after expansion and to
! split lines into words with the
! .B read
! builtin command.  The default value is
! ``<space><tab><newline>''.
! .TP
! .B IGNOREEOF
! Controls the
! action of an interactive shell on receipt of an
! .SM
! .B EOF
! character as the sole input.  If set, the value is the number of
! consecutive
! .SM
! .B EOF
! characters which must be
! typed as the first characters on an input line before
! .B bash
! exits.  If the variable exists but does not have a numeric value, or
! has no value, the default value is 10.  If it does not exist,
! .SM
! .B EOF
! signifies the end of input to the shell.
! .TP
! .B INPUTRC
! The filename for the
! .B readline
! startup file, overriding the default of
! .FN ~/.inputrc
! (see
! .SM
! .B READLINE
! below).
  .TP
  .B LANG
***************
*** 1591,1741 ****
  for printing selection lists.  Automatically set upon receipt of a SIGWINCH.
  .TP
! .B COLUMNS
! Used by the \fBselect\fP builtin command to determine the terminal width
! when printing selection lists.  Automatically set upon receipt of a SIGWINCH.
! .TP
! .B PROMPT_COMMAND
! If set, the value is executed as a command prior to issuing each primary
! prompt.
! .TP
! .B IGNOREEOF
! Controls the
! action of an interactive shell on receipt of an
! .SM
! .B EOF
! character as the sole input.  If set, the value is the number of
! consecutive
  .SM
! .B EOF
! characters which must be
! typed as the first characters on an input line before
  .B bash
! exits.  If the variable exists but does not have a numeric value, or
! has no value, the default value is 10.  If it does not exist,
! .SM
! .B EOF
! signifies the end of input to the shell.
  .TP
! .B TMOUT
! If set to a value greater than zero, the value is interpreted as the
! number of seconds to wait for input after issuing the primary prompt.
! .B Bash
! terminates after waiting for that number of seconds if input does
! not arrive.
  .TP
! .B FCEDIT
! The default editor for the
! .B fc
! builtin command.
  .TP
! .B FIGNORE
! A colon-separated list of suffixes to ignore when performing
! filename completion (see
  .SM
! .B READLINE
  below).
- A filename whose suffix matches one of the entries in 
  .SM
! .B FIGNORE
! is excluded from the list of matched filenames.
! A sample value is ``.o:~''.
  .TP
! .B GLOBIGNORE
! A colon-separated list of patterns defining the set of filenames to
! be ignored by pathname expansion.
! If a filename matched by a pathname expansion pattern also matches one
! of the patterns in
  .SM
! .BR GLOBIGNORE ,
! it is removed from the list of matches.
  .TP
! .B INPUTRC
! The filename for the
! .B readline
! startup file, overriding the default of
! .FN ~/.inputrc
! (see
! .SM
! .B READLINE
! below).
  .TP
! .B HISTCONTROL
! If set to a value of
! .IR ignorespace ,
! lines which begin with a
! .B space
! character are not entered on the history list.
! If set to a value of
! .IR ignoredups ,
! lines matching the last history line are not entered.
! A value of
! .I ignoreboth
! combines the two options.
! If unset, or if set to any other value than those above,
! all lines read
! by the parser are saved on the history list, subject to the value
! of
! .BR HISTIGNORE .
! This variable's function is superseded by
! .BR HISTIGNORE .
! The second and subsequent lines of a multi-line compound command are
! not tested, and are added to the history regardless of the value of
! .BR HISTCONTROL .
  .TP
! .B HISTIGNORE
! A colon-separated list of patterns used to decide which command lines
! should be saved on the history list.  Each pattern is anchored at the
! beginning of the line and must match the complete line (no implicit
! `\fB*\fP' is appended).  Each pattern is tested against the line
! after the checks specified by
! .B HISTCONTROL
! are applied.
! In addition to the normal shell pattern matching characters, `\fB&\fP'
! matches the previous history line.  `\fB&\fP' may be escaped using a
! backslash; the backslash is removed before attempting a match.
! The second and subsequent lines of a multi-line compound command are
! not tested, and are added to the history regardless of the value of
! .BR HISTIGNORE .
  .TP
! .B histchars
! The two or three characters which control history expansion
! and tokenization (see
  .SM
! .B HISTORY EXPANSION
! below).  The first character is the \fIhistory expansion\fP character,
! the character which signals the start of a history
! expansion, normally `\fB!\fP'.
! The second character is the \fIquick substitution\fP
! character, which is used as shorthand for re-running the previous
! command entered, substituting one string for another in the command.
! The default is `\fB^\fP'.
! The optional third character is the character
! which indicates that the remainder of the line is a comment when found
! as the first character of a word, normally `\fB#\fP'.  The history
! comment character causes history substitution to be skipped for the
! remaining words on the line.  It does not necessarily cause the shell
! parser to treat the rest of the line as a comment.
  .TP
! .B HOSTFILE
! Contains the name of a file in the same format as
! .FN /etc/hosts
! that should be read when the shell needs to complete a
! hostname.
! The list of possible hostname completions may be changed while the
! shell is running;
! the next time hostname completion is attempted after the
! value is changed,
  .B bash
! adds the contents of the new file to the existing list.
! If
! .SM
! .B HOSTFILE
! is set, but has no value, \fBbash\fP attempts to read
! .FN /etc/hosts
! to obtain the list of possible hostname completions.
! When
  .SM
! .B HOSTFILE
! is unset, the hostname list is cleared.
  .TP
  .B auto_resume
--- 1608,1770 ----
  for printing selection lists.  Automatically set upon receipt of a SIGWINCH.
  .TP
! .B MAIL
! If this parameter is set to a file name and the
  .SM
! .B MAILPATH
! variable is not set,
  .B bash
! informs the user of the arrival of mail in the specified file.
  .TP
! .B MAILCHECK
! Specifies how
! often (in seconds)
! .B bash
! checks for mail.  The default is 60 seconds.  When it is time to check
! for mail, the shell does so before displaying the primary prompt.
! If this variable is unset, or set to a value that is not a number
! greater than or equal to zero, the shell disables mail checking.
  .TP
! .B MAILPATH
! A colon-separated list of file names to be checked for mail. 
! The message to be printed when mail arrives in a particular file
! may be specified by separating the file name from the message with a `?'.
! When used in the text of the message, \fB$_\fP expands to the name of
! the current mailfile. 
! Example:
! .RS
! .PP
! \fBMAILPATH\fP='/var/mail/bfox?"You have mail":~/shell\-mail?"$_ has mail!"'
! .PP
! .B Bash
! supplies a default value for this variable, but the location of the user
! mail files that it uses is system dependent (e.g., /var/mail/\fB$USER\fP).
! .RE
  .TP
! .B OPTERR
! If set to the value 1,
! .B bash
! displays error messages generated by the
! .B getopts
! builtin command (see
  .SM
! .B SHELL BUILTIN COMMANDS
  below).
  .SM
! .B OPTERR
! is initialized to 1 each time the shell is invoked or a shell
! script is executed.
  .TP
! .B PATH
! The search path for commands.  It
! is a colon-separated list of directories in which
! the shell looks for commands (see
  .SM
! .B COMMAND EXECUTION
! below).  The default path is system-dependent,
! and is set by the administrator who installs
! .BR bash .
! A common value is
! .if t \f(CW/usr/gnu/bin:/usr/local/bin:/usr/ucb:/bin:/usr/bin:.\fP.
! .if n ``/usr/gnu/bin:/usr/local/bin:/usr/ucb:/bin:/usr/bin:.''.
  .TP
! .B POSIXLY_CORRECT
! If this variable is in the environment when \fBbash\fP starts, the shell
! enters \fIposix mode\fP before reading the startup files, as if the
! .B \-\-posix
! invocation option had been supplied.  If it is set while the shell is
! running, \fBbash\fP enables \fIposix mode\fP, as if the command
! .if t \f(CWset -o posix\fP
! .if n \fIset -o posix\fP
! had been executed.
  .TP
! .B PROMPT_COMMAND
! If set, the value is executed as a command prior to issuing each primary
! prompt.
  .TP
! .B PS1
! The value of this parameter is expanded (see
! .SM
! .B PROMPTING
! below) and used as the primary prompt string.  The default value is
! ``\fB\es\-\ev\e$ \fP''.
  .TP
! .B PS2
! The value of this parameter is expanded as with
! .B PS1
! and used as the secondary prompt string.  The default is
! ``\fB> \fP''.
! .TP
! .B PS3
! The value of this parameter is used as the prompt for the
! .B select
! command (see
  .SM
! .B SHELL GRAMMAR
! above).
  .TP
! .B PS4
! The value of this parameter is expanded as with
! .B PS1
! and the value is printed before each command
  .B bash
! displays during an execution trace.  The first character of
  .SM
! .B PS4
! is replicated multiple times, as necessary, to indicate multiple
! levels of indirection.  The default is ``\fB+ \fP''.
! .TP
! .B TIMEFORMAT
! The value of this parameter is used as a format string specifying
! how the timing information for pipelines prefixed with the
! .B time
! reserved word should be displayed.
! The \fB%\fP character introduces an escape sequence that is
! expanded to a time value or other information.
! The escape sequences and their meanings are as follows; the
! braces denote optional portions.
! .sp .5
! .RS
! .PD 0
! .TP 10
! .B %%
! A literal \fB%\fP.
! .TP
! .B %[\fIp\fP][l]R
! The elapsed time in seconds.
! .TP
! .B %[\fIp\fP][l]U
! The number of CPU seconds spent in user mode.
! .TP
! .B %[\fIp\fP][l]S
! The number of CPU seconds spent in system mode.
! .TP
! .B %P
! The CPU percentage, computed as (%U + %S) / %R.
! .PD
! .RE
! .IP
! The optional \fIp\fP is a digit specifying the \fIprecision\fP,
! the number of fractional digits after a decimal point.
! A value of 0 causes no decimal point or fraction to be output.
! At most three places after the decimal point may be specified;
! values of \fIp\fP greater than 3 are changed to 3.
! If \fIp\fP is not specified, the value 3 is used.
! .IP
! The optional \fBl\fP specifies a longer format, including
! minutes, of the form \fIMM\fPm\fISS\fP.\fIFF\fPs.
! The value of \fIp\fP determines whether or not the fraction is
! included.
! .IP
! If this variable is not set, \fBbash\fP acts as if it had the
! value \fB$'\enreal\et%3lR\enuser\et%3lU\ensys\t%3lS'\fP.
! If the value is null, no timing information is displayed.
! A trailing newline is added when the format string is displayed.
! .TP
! .B TMOUT
! If set to a value greater than zero, the value is interpreted as the
! number of seconds to wait for input after issuing the primary prompt.
! .B Bash
! terminates after waiting for that number of seconds if input does
! not arrive.
  .TP
  .B auto_resume
***************
*** 1768,1775 ****
  job identifier.
  .TP
! .B COMPREPLY
! An array variable from which \fBbash\fP reads the possible completions
! generated by a shell function invoked by the programmable completion
! facility (see \fBProgrammable Completion\fP below).
  .PD
  .SS Arrays
--- 1797,1818 ----
  job identifier.
  .TP
! .B histchars
! The two or three characters which control history expansion
! and tokenization (see
! .SM
! .B HISTORY EXPANSION
! below).  The first character is the \fIhistory expansion\fP character,
! the character which signals the start of a history
! expansion, normally `\fB!\fP'.
! The second character is the \fIquick substitution\fP
! character, which is used as shorthand for re-running the previous
! command entered, substituting one string for another in the command.
! The default is `\fB^\fP'.
! The optional third character is the character
! which indicates that the remainder of the line is a comment when found
! as the first character of a word, normally `\fB#\fP'.  The history
! comment character causes history substitution to be skipped for the
! remaining words on the line.  It does not necessarily cause the shell
! parser to treat the rest of the line as a comment.
  .PD
  .SS Arrays
***************
*** 2687,2697 ****
  .B /dev/tcp/\fIhost\fP/\fIport\fP
  If \fIhost\fP is a valid hostname or Internet address, and \fIport\fP
! is an integer port number, \fBbash\fP attempts to open a TCP connection
! to the corresponding socket.
  .TP
  .B /dev/udp/\fIhost\fP/\fIport\fP
  If \fIhost\fP is a valid hostname or Internet address, and \fIport\fP
! is an integer port number, \fBbash\fP attempts to open a UDP connection
! to the corresponding socket.
  .PD
  .RE
--- 2730,2740 ----
  .B /dev/tcp/\fIhost\fP/\fIport\fP
  If \fIhost\fP is a valid hostname or Internet address, and \fIport\fP
! is an integer port number or service name, \fBbash\fP attempts to open
! a TCP connection to the corresponding socket.
  .TP
  .B /dev/udp/\fIhost\fP/\fIport\fP
  If \fIhost\fP is a valid hostname or Internet address, and \fIport\fP
! is an integer port number or service name, \fBbash\fP attempts to open
! a UDP connection to the corresponding socket.
  .PD
  .RE
***************
*** 2812,2816 ****
  .nf
  \fB<<\fP[\fB\-\fP]\fIword\fP
!         \fIhere\-document\fP
  \fIdelimiter\fP
  .fi
--- 2855,2859 ----
  .nf
  \fB<<\fP[\fB\-\fP]\fIword\fP
!         \fIhere-document\fP
  \fIdelimiter\fP
  .fi
***************
*** 3140,3144 ****
  If \fIbase#\fP is omitted, then base 10 is used.
  The digits greater than 9 are represented by the lowercase letters,
! the uppercase letters, _, and @, in that order.
  If \fIbase\fP is less than or equal to 36, lowercase and uppercase
  letters may be used interchangably to represent numbers between 10
--- 3183,3187 ----
  If \fIbase#\fP is omitted, then base 10 is used.
  The digits greater than 9 are represented by the lowercase letters,
! the uppercase letters, @, and _, in that order.
  If \fIbase\fP is less than or equal to 36, lowercase and uppercase
  letters may be used interchangably to represent numbers between 10
***************
*** 3455,3458 ****
--- 3498,3506 ----
  subshell environment.  Changes made to the subshell environment
  cannot affect the shell's execution environment.
+ .PP
+ If a command is followed by a \fB&\fP and job control is not active, the
+ default standard input for the command is the empty file \fI/dev/null\fP.
+ Otherwise, the invoked command inherits the file descriptors of the calling
+ shell as modified by redirections.
  .SH ENVIRONMENT
  When a program is invoked it is given an array of strings
***************
*** 3580,3584 ****
  .SM
  .BR SIGHUP .
! Before exiting, it resends the
  .SM
  .B SIGHUP
--- 3628,3632 ----
  .SM
  .BR SIGHUP .
! Before exiting, an interactive shell resends the
  .SM
  .B SIGHUP
***************
*** 3769,3772 ****
--- 3817,3824 ----
  .B bash
  reports such changes immediately.
+ Any trap on
+ .SM
+ .B SIGCHLD
+ is executed for each child that exits.
  .PP
  If an attempt to exit
***************
*** 3835,3838 ****
--- 3887,3893 ----
  the current time in 12-hour am/pm format
  .TP
+ .B \eA
+ the current time in 24-hour HH:MM format
+ .TP
  .B \eu
  the username of the current user
***************
*** 3842,3846 ****
  .TP
  .B \eV
! the release of \fBbash\fP, version + patchlevel (e.g., 2.00.0)
  .TP
  .B \ew
--- 3897,3901 ----
  .TP
  .B \eV
! the release of \fBbash\fP, version + patchelvel (e.g., 2.00.0)
  .TP
  .B \ew
***************
*** 4124,4133 ****
  .TP
  .B \e\fInnn\fP
! the character whose ASCII code is the octal value \fInnn\fP
  (one to three digits)
  .TP
! .B \ex\fInnn\fP
! the character whose ASCII code is the hexadecimal value \fInnn\fP
! (one to three digits)
  .RE
  .PD
--- 4179,4188 ----
  .TP
  .B \e\fInnn\fP
! the eight-bit character whose value is the octal value \fInnn\fP
  (one to three digits)
  .TP
! .B \ex\fIHH\fP
! the eight-bit character whose value is the hexadecimal value \fIHH\fP
! (one or two hex digits)
  .RE
  .PD
***************
*** 4231,4234 ****
--- 4286,4294 ----
  attempts word completion.
  .TP
+ .B history-preserve-point
+ If set to \fBon\fP, the history code attempts to place point at the
+ same location on each history line retrived with \fBprevious-history\fP
+ or \fBnext-history\fP.
+ .TP
  .B horizontal\-scroll\-mode (Off)
  When set to \fBOn\fP, makes readline use a single line for display,
***************
*** 4269,4272 ****
--- 4329,4338 ----
  with a preceding asterisk (\fB*\fP).
  .TP
+ .B match\-hidden\-files (On)
+ This variable, when set to \fBOn\fP, causes readline to match files whose
+ names begin with a `.' (hidden files) when performing filename 
+ completion, unless the leading `.' is
+ supplied by the user in the filename to be completed.
+ .TP
  .B output\-meta (Off)
  If set to \fBOn\fP, readline will display characters with the
***************
*** 4394,4397 ****
--- 4460,4467 ----
  the line, thereby executing the command from the history list.
  .PP
+ Readline remembers the last incremental search string.  If two
+ Control-Rs are typed without any intervening characters defining a
+ new search string, any remembered search string is used.
+ .PP
  Non-incremental searches read the entire search string before starting
  to search for matching history lines.  The search string may be
***************
*** 4567,4571 ****
  Delete the character under the cursor, unless the cursor is at the
  end of the line, in which case the character behind the cursor is
! deleted.  By default, this is not bound to a key.
  .TP
  .B quoted\-insert (C\-q, C\-v)
--- 4637,4641 ----
  Delete the character under the cursor, unless the cursor is at the
  end of the line, in which case the character behind the cursor is
! deleted.
  .TP
  .B quoted\-insert (C\-q, C\-v)
***************
*** 4589,4592 ****
--- 4659,4664 ----
  Drag the word before point past the word after point,
  moving point over that word as well.
+ If point is at the end of the line, this transposes
+ the last two words on the line.   
  .TP
  .B upcase\-word (M\-u)
***************
*** 4708,4712 ****
  of possible completions, inserting each match in turn.
  At the end of the list of completions, the bell is rung
! (subject to the setting of \Bbell\-style\fP)
  and the original text is restored.
  An argument of \fIn\fP moves \fIn\fP positions forward in the list
--- 4780,4784 ----
  of possible completions, inserting each match in turn.
  At the end of the list of completions, the bell is rung
! (subject to the setting of \fBbell\-style\fP)
  and the original text is restored.
  An argument of \fIn\fP moves \fIn\fP positions forward in the list
***************
*** 5673,5677 ****
  .TP
  .PD 0
! \fBcomplete\fP [\fB\-abcdefjkvu\fP] [\fB\-o\fP \fIcomp-option\fP] [\fB\-A\fP \fIaction\fP] [\fB\-G\fP \fIglobpat\fP] [\fB\-W\fP \fIwordlist\fP] [\fB\-P\fP \fIprefix\fP] [\fB\-S\fP \fIsuffix\fP]
  .br
  [\fB\-X\fP \fIfilterpat\fP] [\fB\-F\fP \fIfunction\fP] [\fB\-C\fP \fIcommand\fP] \fIname\fP [\fIname ...\fP]
--- 5745,5749 ----
  .TP
  .PD 0
! \fBcomplete\fP [\fB\-abcdefgjkvu\fP] [\fB\-o\fP \fIcomp-option\fP] [\fB\-A\fP \fIaction\fP] [\fB\-G\fP \fIglobpat\fP] [\fB\-W\fP \fIwordlist\fP] [\fB\-P\fP \fIprefix\fP] [\fB\-S\fP \fIsuffix\fP]
  .br
  [\fB\-X\fP \fIfilterpat\fP] [\fB\-F\fP \fIfunction\fP] [\fB\-C\fP \fIcommand\fP] \fIname\fP [\fIname ...\fP]
***************
*** 5755,5758 ****
--- 5827,5833 ----
  Names of shell functions.
  .TP 8
+ .B group
+ Group names.  May also be specified as \fB\-g\fP.
+ .TP 8
  .B helptopic
  Help topics as accepted by the \fBhelp\fP builtin.
***************
*** 6059,6068 ****
  .TP
  .B \e\fInnn\fP
! the character whose ASCII code is the octal value \fInnn\fP
  (one to three digits)
  .TP
! .B \ex\fInnn\fP
! the character whose ASCII code is the hexadecimal value \fInnn\fP
! (one to three digits)
  .PD
  .RE
--- 6134,6143 ----
  .TP
  .B \e\fInnn\fP
! the eight-bit character whose value is the octal value \fInnn\fP
  (one to three digits)
  .TP
! .B \ex\fIHH\fP
! the eight-bit character whose value is the hexadecimal value \fIHH\fP
! (one or two hex digits)
  .PD
  .RE
***************
*** 6393,6396 ****
--- 6468,6472 ----
  a question mark (\^\fB?\fP\^) is placed in
  .IR name ,
+ .SM
  .B OPTARG
  is unset, and a diagnostic message is printed.
***************
*** 6409,6413 ****
  error occurs.
  .TP
! \fBhash\fP [\fB\-r\fP] [\fB\-p\fP \fIfilename\fP] [\fIname\fP]
  For each
  .IR name ,
--- 6485,6489 ----
  error occurs.
  .TP
! \fBhash\fP [\fB\-r\fP] [\fB\-p\fP \fIfilename\fP] [\fB\-t\fP] [\fIname\fP]
  For each
  .IR name ,
***************
*** 6424,6429 ****
  .B \-r
  option causes the shell to forget all
! remembered locations.  If no arguments are given, information
! about remembered commands is printed.
  The return status is true unless a
  .I name
--- 6500,6510 ----
  .B \-r
  option causes the shell to forget all
! remembered locations.
! If the
! .B \-t
! option is supplied, the full pathname to which each \fIname\fP corresponds
! is printed.  If multiple \fIname\fP arguments are supplied with \fB\-t\fP,
! the \fIname\fP is printed before the hashed full pathname.
! If no arguments are given, information about remembered commands is printed.
  The return status is true unless a
  .I name
***************
*** 6714,6720 ****
  format specifications, each of which causes printing of the next successive
  \fIargument\fP.
! In addition to the standard \fIprintf\fP(1) formats, %b causes
  \fBprintf\fP to expand backslash escape sequences in the corresponding
! \fIargument\fP, and %q causes \fBprintf\fP to output the corresponding
  \fIargument\fP in a format that can be reused as shell input.
  .sp 1
--- 6795,6801 ----
  format specifications, each of which causes printing of the next successive
  \fIargument\fP.
! In addition to the standard \fIprintf\fP(1) formats, \fB%b\fP causes
  \fBprintf\fP to expand backslash escape sequences in the corresponding
! \fIargument\fP, and \fB%q\fP causes \fBprintf\fP to output the corresponding
  \fIargument\fP in a format that can be reused as shell input.
  .sp 1
***************
*** 6843,6847 ****
  .TP
  .B \-p \fIprompt\fP
! Display \fIprompt\fP, without a
  trailing newline, before attempting to read any input.  The prompt
  is displayed only if input is coming from a terminal.
--- 6924,6928 ----
  .TP
  .B \-p \fIprompt\fP
! Display \fIprompt\fP on standard error, without a
  trailing newline, before attempting to read any input.  The prompt
  is displayed only if input is coming from a terminal.
***************
*** 6965,6968 ****
--- 7046,7050 ----
  being inverted via
  .BR ! .
+ A trap on \fBERR\fP, if set, is executed before the shell exits.
  .TP 8
  .B \-f
***************
*** 7058,7061 ****
--- 7140,7145 ----
  Same as
  .BR \-f .
+ .B nolog
+ Currently ignored.
  .TP 8
  .B notify
***************
*** 7401,7404 ****
--- 7485,7495 ----
  embedded newlines rather than using semicolon separators where possible.
  .TP 8
+ .B login_shell
+ The shell sets this option if it is started as a login shell (see
+ .SM
+ .B "INVOCATION"
+ above).
+ The value may not be changed.
+ .TP 8
  .B mailwarn
  If set, and a file that \fBbash\fP is checking for mail has been  
***************
*** 7621,7625 ****
  (0) the command
  .I arg
! is executed on exit from the shell.  If a
  .I sigspec
  is
--- 7712,7717 ----
  (0) the command
  .I arg
! is executed on exit from the shell.
! If a
  .I sigspec
  is
***************
*** 7632,7635 ****
--- 7724,7752 ----
  .B SHELL GRAMMAR
  above).
+ If a
+ .I sigspec
+ is
+ .SM
+ .BR ERR ,
+ the command
+ .I arg
+ is executed whenever a simple command has a non\-zero exit status.
+ The
+ .SM
+ .BR ERR
+ trap is not executed if the failed command is part of an
+ .I until
+ or
+ .I while
+ loop,
+ part of an
+ .I if
+ statement, part of a
+ .B &&
+ or
+ .B \(bv\(bv
+ list, or if the command's return value is
+ being inverted via
+ .BR ! .
  The
  .B \-l
***************
*** 7708,7717 ****
  \fBulimit\fP [\fB\-SHacdflmnpstuv\fP [\fIlimit\fP]]
  Provides control over the resources available to the shell and to
! processes started by it, on systems that allow such control.  The
! value of
! .I limit
! can be a number in the unit specified for the resource, or the
! value
! .BR unlimited .
  The \fB\-H\fP and \fB\-S\fP options specify that the hard or soft limit is
  set for the given resource.  A hard limit cannot be increased once it
--- 7825,7829 ----
  \fBulimit\fP [\fB\-SHacdflmnpstuv\fP [\fIlimit\fP]]
  Provides control over the resources available to the shell and to
! processes started by it, on systems that allow such control.
  The \fB\-H\fP and \fB\-S\fP options specify that the hard or soft limit is
  set for the given resource.  A hard limit cannot be increased once it
***************
*** 7719,7722 ****
--- 7831,7844 ----
  If neither \fB\-H\fP nor \fB\-S\fP is specified, both the soft and hard
  limits are set.
+ The value of
+ .I limit
+ can be a number in the unit specified for the resource
+ or one of the special values
+ .BR hard ,
+ .BR soft ,
+ or
+ .BR unlimited ,
+ which stand for the current hard limit, the current soft limit, and
+ no limit, respectively.
  If
  .I limit
***************
*** 7782,7789 ****
  and
  .BR \-u ,
! which are unscaled values.  The return status is 0
! unless an invalid option is encountered, a non-numeric argument
! other than \fBunlimited\fP is supplied as \fIlimit\fP, or an
! error occurs while setting a new limit.
  .RE
  .TP
--- 7904,7910 ----
  and
  .BR \-u ,
! which are unscaled values.
! The return status is 0 unless an invalid option or argument is supplied,
! or an error occurs while setting a new limit.
  .RE
  .TP
diff -Nrc2 bash-2.05/doc/bashref.info bash-2.05a/doc/bashref.info
*** bash-2.05/doc/bashref.info	Wed Mar 28 15:13:37 2001
--- bash-2.05a/doc/bashref.info	Tue Nov 13 12:56:06 2001
***************
*** 10,18 ****
  the Bash shell.
  
! This is Edition 2.5, last updated 28 Mar 2001,
  of `The GNU Bash Reference Manual',
! for `Bash', Version 2.05.
  
! Copyright (C) 1991-1999 Free Software Foundation, Inc.
  
  Permission is granted to make and distribute verbatim copies of
--- 10,18 ----
  the Bash shell.
  
! This is Edition 2.5a, last updated 13 November 2001,
  of `The GNU Bash Reference Manual',
! for `Bash', Version 2.05a.
  
! Copyright (C) 1991-2001 Free Software Foundation, Inc.
  
  Permission is granted to make and distribute verbatim copies of
***************
*** 39,44 ****
  the Bash shell.
  
!    This is Edition 2.5, last updated 28 Mar 2001, of `The GNU Bash
! Reference Manual', for `Bash', Version 2.05.
  
     Copyright (C) 1991, 1993, 1996 Free Software Foundation, Inc.
--- 39,44 ----
  the Bash shell.
  
!    This is Edition 2.5a, last updated 13 November 2001, of `The GNU
! Bash Reference Manual', for `Bash', Version 2.05a.
  
     Copyright (C) 1991, 1993, 1996 Free Software Foundation, Inc.
***************
*** 203,207 ****
  
  `exit status'
!      The value returned by a command to its caller.
  
  `field'
--- 203,208 ----
  
  `exit status'
!      The value returned by a command to its caller.  The value is
!      restricted to eight bits, so the maximum value is 255.
  
  `field'
***************
*** 475,484 ****
  
  `\NNN'
!      the character whose `ASCII' code is the octal value NNN (one to
       three digits)
  
! `\xNNN'
!      the character whose `ASCII' code is the hexadecimal value NNN (one
!      to three digits)
  
  The expanded result is single-quoted, as if the dollar sign had not
--- 476,485 ----
  
  `\NNN'
!      the eight-bit character whose value is the octal value NNN (one to
       three digits)
  
! `\xHH'
!      the eight-bit character whose value is the hexadecimal value HH
!      (one or two hex digits)
  
  The expanded result is single-quoted, as if the dollar sign had not
***************
*** 501,504 ****
--- 502,507 ----
  `.mo'.  If you use the `TEXTDOMAIN' variable, you may need to set the
  `TEXTDOMAINDIR' variable to the location of the message catalog files.
+ Still others use both variables in this fashion:
+ `TEXTDOMAINDIR'/`LC_MESSAGES'/LC_MESSAGES/`TEXTDOMAIN'.mo.
  
  
***************
*** 568,574 ****
       [`time' [`-p']] [`!'] COMMAND1 [`|' COMMAND2 ...]
  
! The output of each command in the pipeline is connected to the input of
! the next command.  That is, each command reads the previous command's
! output.
  
     The reserved word `time' causes timing statistics to be printed for
--- 571,577 ----
       [`time' [`-p']] [`!'] COMMAND1 [`|' COMMAND2 ...]
  
! The output of each command in the pipeline is connected via a pipe to
! the input of the next command.  That is, each command reads the
! previous command's output.
  
     The reserved word `time' causes timing statistics to be printed for
***************
*** 771,777 ****
       null.  The line read is saved in the variable `REPLY'.
  
!      The COMMANDS are executed after each selection until a `break' or
!      `return' command is executed, at which point the `select' command
!      completes.
  
       Here is an example that allows the user to pick a filename from the
--- 774,779 ----
       null.  The line read is saved in the variable `REPLY'.
  
!      The COMMANDS are executed after each selection until a `break'
!      command is executed, at which point the `select' command completes.
  
       Here is an example that allows the user to pick a filename from the
***************
*** 913,917 ****
  values they had prior to the function's execution.  If a numeric
  argument is given to `return', that is the function's return status;
! otherwise the functions's return status is the exit status of the last
  command executed before the `return'.
  
--- 915,919 ----
  values they had prior to the function's execution.  If a numeric
  argument is given to `return', that is the function's return status;
! otherwise the function's return status is the exit status of the last
  command executed before the `return'.
  
***************
*** 936,940 ****
     A PARAMETER is an entity that stores values.  It can be a `name', a
  number, or one of the special characters listed below.  For the shell's
! purposes, a VARIABLE is a parameter denoted by a `name'.
  
     A parameter is set if it has been assigned a value.  The null string
--- 938,945 ----
     A PARAMETER is an entity that stores values.  It can be a `name', a
  number, or one of the special characters listed below.  For the shell's
! purposes, a VARIABLE is a parameter denoted by a `name'.  A variable
! has a VALUE and zero or more ATTRIBUTES.  Attributes are assigned using
! the `declare' builtin command (see the description of the `declare'
! builtin in *Note Bash Builtins::).
  
     A parameter is set if it has been assigned a value.  The null string
***************
*** 948,957 ****
  VALUEs undergo tilde expansion, parameter and variable expansion,
  command substitution, arithmetic expansion, and quote removal (detailed
! below).  If the variable has its `integer' attribute set (see the
! description of the `declare' builtin in *Note Bash Builtins::), then
! VALUE is subject to arithmetic expansion even if the `$((...))'
! expansion is not used (*note Arithmetic Expansion::).  Word splitting
! is not performed, with the exception of `"$@"' as explained below.
! Filename expansion is not performed.
  
  
--- 953,963 ----
  VALUEs undergo tilde expansion, parameter and variable expansion,
  command substitution, arithmetic expansion, and quote removal (detailed
! below).  If the variable has its `integer' attribute set, then VALUE is
! subject to arithmetic expansion even if the `$((...))' expansion is not
! used (*note Arithmetic Expansion::).  Word splitting is not performed,
! with the exception of `"$@"' as explained below.  Filename expansion is
! not performed.  Assignment statements may also appear as arguments to
! the `declare', `typeset', `export', `readonly', and `local' builtin
! commands.
  
  
***************
*** 1622,1632 ****
  `/dev/tcp/HOST/PORT'
       If HOST is a valid hostname or Internet address, and PORT is an
!      integer port number, Bash attempts to open a TCP connection to the
!      corresponding socket.
  
  `/dev/udp/HOST/PORT'
       If HOST is a valid hostname or Internet address, and PORT is an
!      integer port number, Bash attempts to open a UDP connection to the
!      corresponding socket.
  
     A failure to open or create a file causes the redirection to fail.
--- 1628,1638 ----
  `/dev/tcp/HOST/PORT'
       If HOST is a valid hostname or Internet address, and PORT is an
!      integer port number or service name, Bash attempts to open a TCP
!      connection to the corresponding socket.
  
  `/dev/udp/HOST/PORT'
       If HOST is a valid hostname or Internet address, and PORT is an
!      integer port number or service name, Bash attempts to open a UDP
!      connection to the corresponding socket.
  
     A failure to open or create a file causes the redirection to fail.
***************
*** 1928,1931 ****
--- 1934,1942 ----
  the shell's execution environment.
  
+    If a command is followed by a `&' and job control is not active, the
+ default standard input for the command is the empty file `/dev/null'.
+ Otherwise, the invoked command inherits the file descriptors of the
+ calling shell as modified by redirections.
+ 
  
  File: bashref.info,  Node: Environment,  Next: Exit Status,  Prev: Command Execution Environment,  Up: Executing Commands
***************
*** 2015,2022 ****
  
     The shell exits by default upon receipt of a `SIGHUP'.  Before
! exiting, it resends the `SIGHUP' to all jobs, running or stopped.
! Stopped jobs are sent `SIGCONT' to ensure that they receive the
! `SIGHUP'.  To prevent the shell from sending the `SIGHUP' signal to a
! particular job, it should be removed from the jobs table with the
  `disown' builtin (*note Job Control Builtins::) or marked to not
  receive `SIGHUP' using `disown -h'.
--- 2026,2033 ----
  
     The shell exits by default upon receipt of a `SIGHUP'.  Before
! exiting, an interactive shell resends the `SIGHUP' to all jobs, running
! or stopped.  Stopped jobs are sent `SIGCONT' to ensure that they receive
! the `SIGHUP'.  To prevent the shell from sending the `SIGHUP' signal to
! a particular job, it should be removed from the jobs table with the
  `disown' builtin (*note Job Control Builtins::) or marked to not
  receive `SIGHUP' using `disown -h'.
***************
*** 2044,2052 ****
  neither the `-c' nor `-s' option is supplied (*note Invoking Bash::),
  Bash reads and executes commands from the file, then exits.  This mode
! of operation creates a non-interactive shell.  When Bash runs a shell
! script, it sets the special parameter `0' to the name of the file,
! rather than the name of the shell, and the positional parameters are
! set to the remaining arguments, if any are given.  If no additional
! arguments are supplied, the positional parameters are unset.
  
     A shell script may be made executable by using the `chmod' command
--- 2055,2067 ----
  neither the `-c' nor `-s' option is supplied (*note Invoking Bash::),
  Bash reads and executes commands from the file, then exits.  This mode
! of operation creates a non-interactive shell.  The shell first searches
! for the file in the current directory, and looks in the directories in
! `$PATH' if not found there.
! 
!    When Bash runs a shell script, it sets the special parameter `0' to
! the name of the file, rather than the name of the shell, and the
! positional parameters are set to the remaining arguments, if any are
! given.  If no additional arguments are supplied, the positional
! parameters are unset.
  
     A shell script may be made executable by using the `chmod' command
***************
*** 2254,2258 ****
  
  `hash'
!           hash [-r] [-p FILENAME] [NAME]
       Remember the full pathnames of commands specified as NAME
       arguments, so they need not be searched for on subsequent
--- 2269,2273 ----
  
  `hash'
!           hash [-r] [-p FILENAME] [-t] [NAME]
       Remember the full pathnames of commands specified as NAME
       arguments, so they need not be searched for on subsequent
***************
*** 2260,2265 ****
       directories listed in `$PATH'.  The `-p' option inhibits the path
       search, and FILENAME is used as the location of NAME.  The `-r'
!      option causes the shell to forget all remembered locations.  If no
!      arguments are given, information about remembered commands is
       printed.  The return status is zero unless a NAME is not found or
       an invalid option is supplied.
--- 2275,2283 ----
       directories listed in `$PATH'.  The `-p' option inhibits the path
       search, and FILENAME is used as the location of NAME.  The `-r'
!      option causes the shell to forget all remembered locations.  If
!      the `-t' option is supplied, the full pathname to which each NAME
!      corresponds is printed.  If multiple NAME arguments are supplied
!      with `-t' the NAME is printed before the hashed full pathname.  If
!      no arguments are given, information about remembered commands is
       printed.  The return status is zero unless a NAME is not found or
       an invalid option is supplied.
***************
*** 2295,2300 ****
       `source') builtin, returning either N or the exit status of the
       last command executed within the script as the exit status of the
!      script.  The return status is false if `return' is used outside a
!      function and not during the execution of a script by `.' or
       `source'.
  
--- 2313,2318 ----
       `source') builtin, returning either N or the exit status of the
       last command executed within the script as the exit status of the
!      script.  The return status is non-zero if `return' is used outside
!      a function and not during the execution of a script by `.' or
       `source'.
  
***************
*** 2395,2401 ****
       signal number.  If a SIGSPEC is `0' or `EXIT', ARG is executed
       when the shell exits.  If a SIGSPEC is `DEBUG', the command ARG is
!      executed after every simple command.  The `-l' option causes the
!      shell to print a list of signal names and their corresponding
!      numbers.
  
       Signals ignored upon entry to the shell cannot be trapped or reset.
--- 2413,2423 ----
       signal number.  If a SIGSPEC is `0' or `EXIT', ARG is executed
       when the shell exits.  If a SIGSPEC is `DEBUG', the command ARG is
!      executed after every simple command.  If a SIGSPEC is `ERR', the
!      command ARG is executed whenever a simple command has a non-zero
!      exit status.  The `ERR' trap is not executed if the failed command
!      is part of an `until' or `while' loop, part of an `if' statement,
!      part of a `&&' or `||' list, or if the command's return status is
!      being inverted using `!'.  The `-l' option causes the shell to
!      print a list of signal names and their corresponding numbers.
  
       Signals ignored upon entry to the shell cannot be trapped or reset.
***************
*** 2635,2645 ****
  
      `\NNN'
!           the character whose `ASCII' code is the octal value NNN (one
!           to three digits)
! 
!     `\xNNN'
!           the character whose `ASCII' code is the hexadecimal value NNN
            (one to three digits)
  
  `enable'
            enable [-n] [-p] [-f FILENAME] [-ads] [NAME ...]
--- 2657,2667 ----
  
      `\NNN'
!           the eight-bit character whose value is the octal value NNN
            (one to three digits)
  
+     `\xHH'
+           the eight-bit character whose value is the hexadecimal value
+           HH (one or two hex digits)
+ 
  `enable'
            enable [-n] [-p] [-f FILENAME] [-ads] [NAME ...]
***************
*** 2892,2895 ****
--- 2914,2921 ----
            rather than using semicolon separators where possible.
  
+     `login_shell'
+           The shell sets this option if it is started as a login shell
+           (*note Invoking Bash::).  The value may not be changed.
+ 
      `mailwarn'
            If set, and a file that Bash is checking for mail has been
***************
*** 3025,3040 ****
            The maximum amount of virtual memory available to the process.
  
!      If LIMIT is given, it is the new value of the specified resource.
!      Otherwise, the current value of the soft limit for the specified
!      resource is printed, unless the `-H' option is supplied.  When
!      setting new limits, if neither `-H' nor `-S' is supplied, both the
!      hard and soft limits are set.  If no option is given, then `-f' is
!      assumed.  Values are in 1024-byte increments, except for `-t',
!      which is in seconds, `-p', which is in units of 512-byte blocks,
!      and `-n' and `-u', which are unscaled values.
! 
!      The return status is zero unless an invalid option is supplied, a
!      non-numeric argument other than `unlimited' is supplied as a
!      LIMIT, or an error occurs while setting a new limit.
  
  `unalias'
--- 3051,3067 ----
            The maximum amount of virtual memory available to the process.
  
!      If LIMIT is given, it is the new value of the specified resource;
!      the special LIMIT values `hard', `soft', and `unlimited' stand for
!      the current hard limit, the current soft limit, and no limit,
!      respectively.  Otherwise, the current value of the soft limit for
!      the specified resource is printed, unless the `-H' option is
!      supplied.  When setting new limits, if neither `-H' nor `-S' is
!      supplied, both the hard and soft limits are set.  If no option is
!      given, then `-f' is assumed.  Values are in 1024-byte increments,
!      except for `-t', which is in seconds, `-p', which is in units of
!      512-byte blocks, and `-n' and `-u', which are unscaled values.
! 
!      The return status is zero unless an invalid option or argument is
!      supplied, or an error occurs while setting a new limit.
  
  `unalias'
***************
*** 3076,3080 ****
            that fails is part of an `until' or `while' loop, part of an
            `if' statement, part of a `&&' or `||' list, or if the
!           command's return status is being inverted using `!'.
  
      `-f'
--- 3103,3108 ----
            that fails is part of an `until' or `while' loop, part of an
            `if' statement, part of a `&&' or `||' list, or if the
!           command's return status is being inverted using `!'.  A trap
!           on `ERR', if set, is executed before the shell exits.
  
      `-f'
***************
*** 3143,3146 ****
--- 3171,3177 ----
                 Same as `-f'.
  
+          `nolog'
+                Currently ignored.
+ 
           `notify'
                 Same as `-b'.
***************
*** 3402,3410 ****
            The value of `MACHTYPE'.
  
! `COMP_WORDS'
!      An array variable consisting of the individual words in the
!      current command line.  This variable is available only in shell
!      functions invoked by the programmable completion facilities (*note
!      Programmable Completion::).
  
  `COMP_CWORD'
--- 3433,3440 ----
            The value of `MACHTYPE'.
  
! `COLUMNS'
!      Used by the `select' builtin command to determine the terminal
!      width when printing selection lists.  Automatically set upon
!      receipt of a `SIGWINCH'.
  
  `COMP_CWORD'
***************
*** 3427,3430 ****
--- 3457,3466 ----
       completion facilities (*note Programmable Completion::).
  
+ `COMP_WORDS'
+      An array variable consisting of the individual words in the
+      current command line.  This variable is available only in shell
+      functions invoked by the programmable completion facilities (*note
+      Programmable Completion::).
+ 
  `COMPREPLY'
       An array variable from which Bash reads the possible completions
***************
*** 3456,3459 ****
--- 3492,3502 ----
       names.  A sample value is `.o:~'
  
+ `FUNCNAME'
+      The name of any currently-executing shell function.  This variable
+      exists only when a shell function is executing.  Assignments to
+      `FUNCNAME' have no effect and return an error status.  If
+      `FUNCNAME' is unset, it loses its special properties, even if it
+      is subsequently reset.
+ 
  `GLOBIGNORE'
       A colon-separated list of patterns defining the set of filenames to
***************
*** 3488,3498 ****
       even if it is subsequently reset.
  
- `FUNCNAME'
-      The name of any currently-executing shell function.  This variable
-      exists only when a shell function is executing.  Assignments to
-      `FUNCNAME' have no effect and return an error status.  If
-      `FUNCNAME' is unset, it loses its special properties, even if it
-      is subsequently reset.
- 
  `HISTCONTROL'
       A value of `ignorespace' means to not enter lines which begin with
--- 3531,3534 ----
***************
*** 3505,3508 ****
--- 3541,3555 ----
       regardless of the value of `HISTCONTROL'.
  
+ `HISTFILE'
+      The name of the file to which the command history is saved.  The
+      default value is `~/.bash_history'.
+ 
+ `HISTFILESIZE'
+      The maximum number of lines contained in the history file.  When
+      this variable is assigned a value, the history file is truncated,
+      if necessary, to contain no more than that number of lines.  The
+      history file is also truncated to this size after writing it when
+      an interactive shell exits.  The default value is 500.
+ 
  `HISTIGNORE'
       A colon-separated list of patterns used to decide which command
***************
*** 3524,3542 ****
       `ignoreboth'.
  
- `HISTFILE'
-      The name of the file to which the command history is saved.  The
-      default value is `~/.bash_history'.
- 
  `HISTSIZE'
       The maximum number of commands to remember on the history list.
       The default value is 500.
  
- `HISTFILESIZE'
-      The maximum number of lines contained in the history file.  When
-      this variable is assigned a value, the history file is truncated,
-      if necessary, to contain no more than that number of lines.  The
-      history file is also truncated to this size after writing it when
-      an interactive shell exits.  The default value is 500.
- 
  `HOSTFILE'
       Contains the name of a file in the same format as `/etc/hosts' that
--- 3571,3578 ----
***************
*** 3598,3601 ****
--- 3634,3641 ----
       formatting.
  
+ `LINENO'
+      The line number in the script or shell function currently
+      executing.
+ 
  `LINES'
       Used by the `select' builtin command to determine the column length
***************
*** 3603,3615 ****
       `SIGWINCH'.
  
- `COLUMNS'
-      Used by the `select' builtin command to determine the terminal
-      width when printing selection lists.  Automatically set upon
-      receipt of a `SIGWINCH'.
- 
- `LINENO'
-      The line number in the script or shell function currently
-      executing.
- 
  `MACHTYPE'
       A string that fully describes the system type on which Bash is
--- 3643,3646 ----
***************
*** 3639,3642 ****
--- 3670,3683 ----
       foreground pipeline (which may contain only a single command).
  
+ `POSIXLY_CORRECT'
+      If this variable is in the environment when `bash' starts, the
+      shell enters POSIX mode (*note Bash POSIX Mode::) before reading
+      the startup files, as if the `--posix' invocation option had been
+      supplied.  If it is set while the shell is running, `bash' enables
+      POSIX mode, as if the command
+           `set -o posix'
+ 
+      had been executed.
+ 
  `PPID'
       The process ID of the shell's parent process.  This variable is
***************
*** 3768,3774 ****
  =============
  
!      bash [long-opt] [-ir] [-abefhkmnptuvxdBCDHP] [-o OPTION] [ARGUMENT ...]
!      bash [long-opt] [-abefhkmnptuvxdBCDHP] [-o OPTION] -c STRING [ARGUMENT ...]
!      bash [long-opt] -s [-abefhkmnptuvxdBCDHP] [-o OPTION] [ARGUMENT ...]
  
     In addition to the single-character shell command-line options
--- 3809,3815 ----
  =============
  
!      bash [long-opt] [-ir] [-abefhkmnptuvxdBCDHP] [-o OPTION] [-O SHOPT_OPTION] [ARGUMENT ...]
!      bash [long-opt] [-abefhkmnptuvxdBCDHP] [-o OPTION] [-O SHOPT_OPTION] -c STRING [ARGUMENT ...]
!      bash [long-opt] -s [-abefhkmnptuvxdBCDHP] [-o OPTION] [-O SHOPT_OPTION] [ARGUMENT ...]
  
     In addition to the single-character shell command-line options
***************
*** 3861,3864 ****
--- 3902,3914 ----
       commands will be executed.
  
+ `[-+]O [SHOPT_OPTION]'
+      SHOPT_OPTION is one of the shell options accepted by the `shopt'
+      builtin (*note Shell Builtin Commands::).  If SHOPT_OPTION is
+      present, `-O' sets the value of that option; `+O' unsets it.  If
+      SHOPT_OPTION is not supplied, the names and values of the shell
+      options accepted by `shopt' are printed on the standard output.
+      If the invocation option is `+O', the output is displayed in a
+      format that may be reused as input.
+ 
  `--'
       A `--' signals the end of options and disables further option
***************
*** 3866,3869 ****
--- 3916,3922 ----
       and arguments.
  
+    A _login_ shell is one whose first character of argument zero is
+ `-', or one invoked with the `--login' option.
+ 
     An _interactive_ shell is one started without non-option arguments,
  unless `-s' is specified, without specifying the `-c' option, and whose
***************
*** 4333,4338 ****
  representing the arithmetic base, and N is a number in that base.  If
  BASE`#' is omitted, then base 10 is used.  The digits greater than 9
! are represented by the lowercase letters, the uppercase letters, `_',
! and `@', in that order.  If BASE is less than or equal to 36, lowercase
  and uppercase letters may be used interchangably to represent numbers
  between 10 and 35.
--- 4386,4391 ----
  representing the arithmetic base, and N is a number in that base.  If
  BASE`#' is omitted, then base 10 is used.  The digits greater than 9
! are represented by the lowercase letters, the uppercase letters, `@',
! and `_', in that order.  If BASE is less than or equal to 36, lowercase
  and uppercase letters may be used interchangably to represent numbers
  between 10 and 35.
***************
*** 4616,4619 ****
--- 4669,4675 ----
       The time, in 12-hour am/pm format.
  
+ `\A'
+      The time, in 24-hour HH:MM format.
+ 
  `\u'
       The username of the current user.
***************
*** 4822,4825 ****
--- 4878,4884 ----
       display shell function names and definitions.
  
+  31. When the `set' builtin is invoked without options, it displays
+      variable values without quotes, unless they contain shell
+      metacharacters, even if the result contains nonprinting characters.
  
     There is other POSIX 1003.2 behavior that Bash does not implement.
***************
*** 4929,4934 ****
  Normally, Bash waits until it is about to print a prompt before
  reporting changes in a job's status so as to not interrupt any other
! output.  If the the `-b' option to the `set' builtin is enabled, Bash
! reports such changes immediately (*note The Set Builtin::).
  
     If an attempt to exit Bash is while jobs are stopped, the shell
--- 4988,4994 ----
  Normally, Bash waits until it is about to print a prompt before
  reporting changes in a job's status so as to not interrupt any other
! output.  If the `-b' option to the `set' builtin is enabled, Bash
! reports such changes immediately (*note The Set Builtin::).  Any trap
! on `SIGCHLD' is executed for each child process that exits.
  
     If an attempt to exit Bash is while jobs are stopped, the shell
***************
*** 5261,5265 ****
  
  `M-<DEL>'
!      Kill from the cursor the start of the previous word, or, if between
       words, to the start of the previous word.  Word boundaries are the
       same as those used by `M-b'.
--- 5321,5325 ----
  
  `M-<DEL>'
!      Kill from the cursor the start of the current word, or, if between
       words, to the start of the previous word.  Word boundaries are the
       same as those used by `M-b'.
***************
*** 5335,5338 ****
--- 5395,5402 ----
  last line found the current line, and begin editing.
  
+    Readline remembers the last incremental search string.  If two
+ `C-r's are typed without any intervening characters defining a new
+ search string, any remembered search string is used.
+ 
     Non-incremental searches read the entire search string before
  starting to search for matching history lines.  The search string may be
***************
*** 5452,5455 ****
--- 5516,5523 ----
            attempts word completion.  The default is `off'.
  
+           If set to `on', the history code attempts to place point at
+           the same location on each history line retrived with
+           `previous-history' or `next-history'.
+ 
      `horizontal-scroll-mode'
            This variable can be set to either `on' or `off'.  Setting it
***************
*** 5491,5494 ****
--- 5559,5569 ----
            modified.  This variable is `off' by default.
  
+     `match-hidden-files'
+           This variable, when set to `on', causes Readline to match
+           files whose names begin with a `.' (hidden files) when
+           performing filename completion, unless the leading `.' is
+           supplied by the user in the filename to be completed.  This
+           variable is `on' by default.
+ 
      `output-meta'
            If set to `on', Readline will display characters with the
***************
*** 5615,5625 ****
  
      `\NNN'
!           the character whose ASCII code is the octal value NNN (one to
!           three digits)
! 
!     `\xNNN'
!           the character whose ASCII code is the hexadecimal value NNN
            (one to three digits)
  
       When entering the text of a macro, single or double quotes must be
       used to indicate a macro definition.  Unquoted text is assumed to
--- 5690,5700 ----
  
      `\NNN'
!           the eight-bit character whose value is the octal value NNN
            (one to three digits)
  
+     `\xHH'
+           the eight-bit character whose value is the hexadecimal value
+           HH (one or two hex digits)
+ 
       When entering the text of a macro, single or double quotes must be
       used to indicate a macro definition.  Unquoted text is assumed to
***************
*** 5965,5969 ****
  `transpose-words (M-t)'
       Drag the word before point past the word after point, moving point
!      past that word as well.
  
  `upcase-word (M-u)'
--- 6040,6045 ----
  `transpose-words (M-t)'
       Drag the word before point past the word after point, moving point
!      past that word as well.  If the insertion point is at the end of
!      the line, this transposes the last two words on the line.
  
  `upcase-word (M-u)'
***************
*** 6432,6436 ****
  
  `complete'
!           `complete [-abcdefjkvu] [-o COMP-OPTION] [-A ACTION] [-G GLOBPAT] [-W WORDLIST]
            [-P PREFIX] [-S SUFFIX] [-X FILTERPAT] [-F FUNCTION]
            [-C COMMAND] NAME [NAME ...]'
--- 6508,6512 ----
  
  `complete'
!           `complete [-abcdefgjkvu] [-o COMP-OPTION] [-A ACTION] [-G GLOBPAT] [-W WORDLIST]
            [-P PREFIX] [-S SUFFIX] [-X FILTERPAT] [-F FUNCTION]
            [-C COMMAND] NAME [NAME ...]'
***************
*** 6513,6516 ****
--- 6589,6595 ----
                 Names of shell functions.
  
+          `group'
+                Group names.  May also be specified as `-g'.
+ 
           `helptopic'
                 Help topics as accepted by the `help' builtin (*note
***************
*** 7034,7046 ****
  called Autoconf.  You only need `configure.in' if you want to change it
  or regenerate `configure' using a newer version of Autoconf.  If you do
! this, make sure you are using Autoconf version 2.10 or newer.
! 
!    If you need to change `configure.in' or regenerate `configure', you
! will need to create two files: `_distribution' and `_patchlevel'.
! `_distribution' should contain the major and minor version numbers of
! the Bash distribution, for example `2.01'.  `_patchlevel' should
! contain the patch level of the Bash distribution, `0' for example.  The
! script `support/mkconffiles' has been provided to automate the creation
! of these files.
  
     You can remove the program binaries and object files from the source
--- 7113,7117 ----
  called Autoconf.  You only need `configure.in' if you want to change it
  or regenerate `configure' using a newer version of Autoconf.  If you do
! this, make sure you are using Autoconf version 2.50 or newer.
  
     You can remove the program binaries and object files from the source
***************
*** 7111,7115 ****
     By default, `make install' will install into `/usr/local/bin',
  `/usr/local/man', etc.  You can specify an installation prefix other
! than `/usr/local' by giving `configure' the option `--prefix=PATH'.
  
     You can specify separate installation prefixes for
--- 7182,7188 ----
     By default, `make install' will install into `/usr/local/bin',
  `/usr/local/man', etc.  You can specify an installation prefix other
! than `/usr/local' by giving `configure' the option `--prefix=PATH', or
! by specifying a value for the `DESTDIR' `make' variable when running
! `make install'.
  
     You can specify separate installation prefixes for
***************
*** 7126,7135 ****
  
     There may be some features `configure' can not figure out
! automatically, but needs to determine by the type of host Bash will run
  on.  Usually `configure' can figure that out, but if it prints a
  message saying it can not guess the host type, give it the
  `--host=TYPE' option.  `TYPE' can either be a short name for the system
  type, such as `sun4', or a canonical name with three fields:
! `CPU-COMPANY-SYSTEM' (e.g., `sparc-sun-sunos4.1.2').
  
     See the file `support/config.sub' for the possible values of each
--- 7199,7208 ----
  
     There may be some features `configure' can not figure out
! automatically, but need to determine by the type of host Bash will run
  on.  Usually `configure' can figure that out, but if it prints a
  message saying it can not guess the host type, give it the
  `--host=TYPE' option.  `TYPE' can either be a short name for the system
  type, such as `sun4', or a canonical name with three fields:
! `CPU-COMPANY-SYSTEM' (e.g., `i386-unknown-freebsd4.2').
  
     See the file `support/config.sub' for the possible values of each
***************
*** 7217,7235 ****
       database.
  
- `--with-glibc-malloc'
-      Use the GNU libc version of `malloc' in `lib/malloc/gmalloc.c'.
-      This is not the version of `malloc' that appears in glibc version
-      2, but a modified version of the `malloc' from glibc version 1.
-      This is somewhat slower than the default `malloc', but wastes less
-      space on a per-allocation basis, and will return memory to the
-      operating system under certain circumstances.
- 
  `--with-gnu-malloc'
       A synonym for `--with-bash-malloc'.
  
! `--with-installed-readline'
       Define this to make Bash link with a locally-installed version of
       Readline rather than the version in `lib/readline'.  This works
!      only with Readline 4.1 and later versions.
  
  `--with-purify'
--- 7290,7309 ----
       database.
  
  `--with-gnu-malloc'
       A synonym for `--with-bash-malloc'.
  
! `--with-installed-readline[=PREFIX]'
       Define this to make Bash link with a locally-installed version of
       Readline rather than the version in `lib/readline'.  This works
!      only with Readline 4.2 and later versions.  If PREFIX is `yes' or
!      not supplied, `configure' uses the values of the make variables
!      `includedir' and `libdir', which are subdirectories of `prefix' by
!      default, to find the installed version of Readline if it is not in
!      the standard system include and library directories.  If PREFIX is
!      `no', Bash links with the version in `lib/readline'.  If PREFIX is
!      set to any other value, `configure' treats it as a directory
!      pathname and looks for the installed version of Readline in
!      subdirectories of that directory (include files in
!      PREFIX/`include' and the library in PREFIX/`lib').
  
  `--with-purify'
***************
*** 7244,7247 ****
--- 7318,7327 ----
  compiled and linked, rather than changing run-time features.
  
+ `--enable-largefile'
+      Enable support for large files
+      (http://www.sas.com/standards/large_file/x_open.20Mar96.html) if
+      the operating system requires special compiler options to build
+      programs which can access large files.
+ 
  `--enable-profiling'
       This builds a Bash binary that produces profiling information to be
***************
*** 7622,7626 ****
  
     * Bash includes the `shopt' builtin, for finer control of shell
!      optional capabilities (*note Bash Builtins::).
  
     * Bash has much more optional behavior controllable with the `set'
--- 7702,7708 ----
  
     * Bash includes the `shopt' builtin, for finer control of shell
!      optional capabilities (*note Bash Builtins::), and allows these
!      options to be set and unset at shell invocation (*note Invoking
!      Bash::).
  
     * Bash has much more optional behavior controllable with the `set'
***************
*** 7636,7639 ****
--- 7718,7727 ----
       command.  The `DEBUG' trap is not inherited by shell functions.
  
+      The `trap' builtin (*note Bourne Shell Builtins::) allows an `ERR'
+      pseudo-signal specification, similar to `EXIT' and `DEBUG'.
+      Commands specified with an `ERR' trap are executed after a simple
+      command fails, with a few exceptions.  The `ERR' trap is not
+      inherited by shell functions.
+ 
     * The Bash `type' builtin is more extensive and gives more
       information about the names it finds (*note Bash Builtins::).
***************
*** 7859,7862 ****
--- 7947,7951 ----
  * HISTFILESIZE:                          Bash Variables.
  * HISTIGNORE:                            Bash Variables.
+ * history-preserve-point:                Readline Init File Syntax.
  * HISTSIZE:                              Bash Variables.
  * HOME:                                  Bourne Shell Variables.
***************
*** 7875,7879 ****
  * LC_COLLATE:                            Bash Variables.
  * LC_CTYPE:                              Bash Variables.
! * LC_MESSAGES:                           Bash Variables.
  * LC_NUMERIC:                            Bash Variables.
  * LINENO:                                Bash Variables.
--- 7964,7969 ----
  * LC_COLLATE:                            Bash Variables.
  * LC_CTYPE:                              Bash Variables.
! * LC_MESSAGES <1>:                       Bash Variables.
! * LC_MESSAGES:                           Locale Translation.
  * LC_NUMERIC:                            Bash Variables.
  * LINENO:                                Bash Variables.
***************
*** 7884,7887 ****
--- 7974,7978 ----
  * MAILPATH:                              Bourne Shell Variables.
  * mark-modified-lines:                   Readline Init File Syntax.
+ * match-hidden-files:                    Readline Init File Syntax.
  * meta-flag:                             Readline Init File Syntax.
  * OLDPWD:                                Bash Variables.
***************
*** 7893,7896 ****
--- 7984,7988 ----
  * PATH:                                  Bourne Shell Variables.
  * PIPESTATUS:                            Bash Variables.
+ * POSIXLY_CORRECT:                       Bash Variables.
  * PPID:                                  Bash Variables.
  * PROMPT_COMMAND:                        Bash Variables.
***************
*** 7906,7909 ****
--- 7998,8003 ----
  * SHLVL:                                 Bash Variables.
  * show-all-if-ambiguous:                 Readline Init File Syntax.
+ * TEXTDOMAIN:                            Locale Translation.
+ * TEXTDOMAINDIR:                         Locale Translation.
  * TIMEFORMAT:                            Bash Variables.
  * TMOUT:                                 Bash Variables.
***************
*** 8032,8037 ****
  * event designators:                     Event Designators.
  * execution environment:                 Command Execution Environment.
! * exit status <1>:                       Definitions.
! * exit status:                           Exit Status.
  * expansion:                             Shell Expansions.
  * expansion, arithmetic:                 Arithmetic Expansion.
--- 8126,8131 ----
  * event designators:                     Event Designators.
  * execution environment:                 Command Execution Environment.
! * exit status <1>:                       Exit Status.
! * exit status:                           Definitions.
  * expansion:                             Shell Expansions.
  * expansion, arithmetic:                 Arithmetic Expansion.
***************
*** 8057,8071 ****
  * installation:                          Basic Installation.
  * interaction, readline:                 Readline Interaction.
! * interactive shell <1>:                 Interactive Shells.
! * interactive shell:                     Invoking Bash.
  * job:                                   Definitions.
! * job control <1>:                       Definitions.
! * job control:                           Job Control Basics.
  * kill ring:                             Readline Killing Commands.
  * killing text:                          Readline Killing Commands.
  * localization:                          Locale Translation.
  * matching, pattern:                     Pattern Matching.
  * metacharacter:                         Definitions.
  * name:                                  Definitions.
  * notation, readline:                    Readline Bare Essentials.
  * operator, shell:                       Definitions.
--- 8151,8168 ----
  * installation:                          Basic Installation.
  * interaction, readline:                 Readline Interaction.
! * interactive shell <1>:                 Invoking Bash.
! * interactive shell:                     Interactive Shells.
! * internationalization:                  Locale Translation.
  * job:                                   Definitions.
! * job control <1>:                       Job Control Basics.
! * job control:                           Definitions.
  * kill ring:                             Readline Killing Commands.
  * killing text:                          Readline Killing Commands.
  * localization:                          Locale Translation.
+ * login shell:                           Invoking Bash.
  * matching, pattern:                     Pattern Matching.
  * metacharacter:                         Definitions.
  * name:                                  Definitions.
+ * native languages:                      Locale Translation.
  * notation, readline:                    Readline Bare Essentials.
  * operator, shell:                       Definitions.
***************
*** 8098,8107 ****
  * signal:                                Definitions.
  * signal handling:                       Signals.
! * special builtin <1>:                   Definitions.
! * special builtin:                       Special Builtins.
  * startup files:                         Bash Startup Files.
  * suspending jobs:                       Job Control Basics.
  * tilde expansion:                       Tilde Expansion.
  * token:                                 Definitions.
  * variable, shell:                       Shell Parameters.
  * variables, readline:                   Readline Init File Syntax.
--- 8195,8205 ----
  * signal:                                Definitions.
  * signal handling:                       Signals.
! * special builtin <1>:                   Special Builtins.
! * special builtin:                       Definitions.
  * startup files:                         Bash Startup Files.
  * suspending jobs:                       Job Control Basics.
  * tilde expansion:                       Tilde Expansion.
  * token:                                 Definitions.
+ * translation, native languages:         Locale Translation.
  * variable, shell:                       Shell Parameters.
  * variables, readline:                   Readline Init File Syntax.
***************
*** 8113,8237 ****
  
  Tag Table:
! Node: Top1157
! Node: Introduction3286
! Node: What is Bash?3511
! Node: What is a shell?4612
! Node: Definitions6846
! Node: Basic Shell Features9512
! Node: Shell Syntax10736
! Node: Shell Operation11760
! Node: Quoting13045
! Node: Escape Character14304
! Node: Single Quotes14776
! Node: Double Quotes15111
! Node: ANSI-C Quoting16012
! Node: Locale Translation16915
! Node: Comments17690
! Node: Shell Commands18295
! Node: Simple Commands19176
! Node: Pipelines19797
! Node: Lists21322
! Node: Looping Constructs22835
! Node: Conditional Constructs25279
! Node: Command Grouping31220
! Node: Shell Functions32597
! Node: Shell Parameters35134
! Node: Positional Parameters36459
! Node: Special Parameters37350
! Node: Shell Expansions40008
! Node: Brace Expansion41928
! Node: Tilde Expansion43597
! Node: Shell Parameter Expansion45928
! Node: Command Substitution52728
! Node: Arithmetic Expansion54050
! Node: Process Substitution54894
! Node: Word Splitting55931
! Node: Filename Expansion57383
! Node: Pattern Matching59341
! Node: Quote Removal62472
! Node: Redirections62758
! Node: Executing Commands69629
! Node: Simple Command Expansion70296
! Node: Command Search and Execution72217
! Node: Command Execution Environment74214
! Node: Environment76667
! Node: Exit Status78318
! Node: Signals79513
! Node: Shell Scripts81405
! Node: Shell Builtin Commands83788
! Node: Bourne Shell Builtins85218
! Node: Bash Builtins100145
! Node: The Set Builtin124177
! Node: Special Builtins131034
! Node: Shell Variables132006
! Node: Bourne Shell Variables132442
! Node: Bash Variables134221
! Node: Bash Features149565
! Node: Invoking Bash150447
! Node: Bash Startup Files155232
! Node: Interactive Shells160102
! Node: What is an Interactive Shell?160504
! Node: Is this Shell Interactive?161139
! Node: Interactive Shell Behavior161945
! Node: Bash Conditional Expressions165212
! Node: Shell Arithmetic168506
! Node: Aliases170937
! Node: Arrays173440
! Node: The Directory Stack176460
! Node: Directory Stack Builtins177166
! Node: Printing a Prompt180044
! Node: The Restricted Shell182414
! Node: Bash POSIX Mode183892
! Node: Job Control189520
! Node: Job Control Basics189986
! Node: Job Control Builtins194200
! Node: Job Control Variables198495
! Node: Command Line Editing199644
! Node: Introduction and Notation200642
! Node: Readline Interaction202259
! Node: Readline Bare Essentials203445
! Node: Readline Movement Commands205225
! Node: Readline Killing Commands206181
! Node: Readline Arguments208090
! Node: Searching209125
! Node: Readline Init File211115
! Node: Readline Init File Syntax212169
! Node: Conditional Init Constructs222372
! Node: Sample Init File224896
! Node: Bindable Readline Commands228065
! Node: Commands For Moving229264
! Node: Commands For History230112
! Node: Commands For Text233000
! Node: Commands For Killing234933
! Node: Numeric Arguments236883
! Node: Commands For Completion238010
! Node: Keyboard Macros241590
! Node: Miscellaneous Commands242148
! Node: Readline vi Mode246510
! Node: Programmable Completion247419
! Node: Programmable Completion Builtins252467
! Node: Using History Interactively259374
! Node: Bash History Facilities260053
! Node: Bash History Builtins262613
! Node: History Interaction266179
! Node: Event Designators268730
! Node: Word Designators269657
! Node: Modifiers271286
! Node: Installing Bash272603
! Node: Basic Installation273745
! Node: Compilers and Options276863
! Node: Compiling For Multiple Architectures277597
! Node: Installation Names279254
! Node: Specifying the System Type279977
! Node: Sharing Defaults280684
! Node: Operation Controls281349
! Node: Optional Features282300
! Node: Reporting Bugs289705
! Node: Major Differences From The Bourne Shell290802
! Node: Builtin Index304814
! Node: Reserved Word Index308405
! Node: Variable Index309881
! Node: Function Index315667
! Node: Concept Index320157
  
  End Tag Table
--- 8211,8335 ----
  
  Tag Table:
! Node: Top1164
! Node: Introduction3300
! Node: What is Bash?3525
! Node: What is a shell?4626
! Node: Definitions6860
! Node: Basic Shell Features9600
! Node: Shell Syntax10824
! Node: Shell Operation11848
! Node: Quoting13133
! Node: Escape Character14392
! Node: Single Quotes14864
! Node: Double Quotes15199
! Node: ANSI-C Quoting16100
! Node: Locale Translation17009
! Node: Comments17892
! Node: Shell Commands18497
! Node: Simple Commands19378
! Node: Pipelines19999
! Node: Lists21535
! Node: Looping Constructs23048
! Node: Conditional Constructs25492
! Node: Command Grouping31416
! Node: Shell Functions32793
! Node: Shell Parameters35329
! Node: Positional Parameters36903
! Node: Special Parameters37794
! Node: Shell Expansions40452
! Node: Brace Expansion42372
! Node: Tilde Expansion44041
! Node: Shell Parameter Expansion46372
! Node: Command Substitution53172
! Node: Arithmetic Expansion54494
! Node: Process Substitution55338
! Node: Word Splitting56375
! Node: Filename Expansion57827
! Node: Pattern Matching59785
! Node: Quote Removal62916
! Node: Redirections63202
! Node: Executing Commands70105
! Node: Simple Command Expansion70772
! Node: Command Search and Execution72693
! Node: Command Execution Environment74690
! Node: Environment77397
! Node: Exit Status79048
! Node: Signals80243
! Node: Shell Scripts82154
! Node: Shell Builtin Commands84665
! Node: Bourne Shell Builtins86095
! Node: Bash Builtins101581
! Node: The Set Builtin125866
! Node: Special Builtins132847
! Node: Shell Variables133819
! Node: Bourne Shell Variables134255
! Node: Bash Variables136034
! Node: Bash Features151763
! Node: Invoking Bash152645
! Node: Bash Startup Files158078
! Node: Interactive Shells162948
! Node: What is an Interactive Shell?163350
! Node: Is this Shell Interactive?163985
! Node: Interactive Shell Behavior164791
! Node: Bash Conditional Expressions168058
! Node: Shell Arithmetic171352
! Node: Aliases173783
! Node: Arrays176286
! Node: The Directory Stack179306
! Node: Directory Stack Builtins180012
! Node: Printing a Prompt182890
! Node: The Restricted Shell185306
! Node: Bash POSIX Mode186784
! Node: Job Control192616
! Node: Job Control Basics193082
! Node: Job Control Builtins197362
! Node: Job Control Variables201657
! Node: Command Line Editing202806
! Node: Introduction and Notation203804
! Node: Readline Interaction205421
! Node: Readline Bare Essentials206607
! Node: Readline Movement Commands208387
! Node: Readline Killing Commands209343
! Node: Readline Arguments211251
! Node: Searching212286
! Node: Readline Init File214463
! Node: Readline Init File Syntax215517
! Node: Conditional Init Constructs226248
! Node: Sample Init File228772
! Node: Bindable Readline Commands231941
! Node: Commands For Moving233140
! Node: Commands For History233988
! Node: Commands For Text236876
! Node: Commands For Killing238913
! Node: Numeric Arguments240863
! Node: Commands For Completion241990
! Node: Keyboard Macros245570
! Node: Miscellaneous Commands246128
! Node: Readline vi Mode250490
! Node: Programmable Completion251399
! Node: Programmable Completion Builtins256447
! Node: Using History Interactively263433
! Node: Bash History Facilities264112
! Node: Bash History Builtins266672
! Node: History Interaction270238
! Node: Event Designators272789
! Node: Word Designators273716
! Node: Modifiers275345
! Node: Installing Bash276662
! Node: Basic Installation277804
! Node: Compilers and Options280489
! Node: Compiling For Multiple Architectures281223
! Node: Installation Names282880
! Node: Specifying the System Type283691
! Node: Sharing Defaults284400
! Node: Operation Controls285065
! Node: Optional Features286016
! Node: Reporting Bugs293871
! Node: Major Differences From The Bourne Shell294968
! Node: Builtin Index309390
! Node: Reserved Word Index312981
! Node: Variable Index314457
! Node: Function Index320619
! Node: Concept Index325109
  
  End Tag Table
diff -Nrc2 bash-2.05/doc/bashref.texi bash-2.05a/doc/bashref.texi
*** bash-2.05/doc/bashref.texi	Wed Mar 28 14:49:52 2001
--- bash-2.05a/doc/bashref.texi	Tue Nov 13 12:55:03 2001
***************
*** 6,16 ****
  
  @ignore
! Last Change: Wed Mar 28 14:48:38 EST 2001
  @end ignore
  
! @set EDITION 2.5
! @set VERSION 2.05
! @set UPDATED 28 Mar 2001
! @set UPDATE-MONTH Mar 2001
  
  @iftex
--- 6,16 ----
  
  @ignore
! Last Change: Tue Nov 13 12:48:51 EST 2001
  @end ignore
  
! @set EDITION 2.5a
! @set VERSION 2.05a
! @set UPDATED 13 November 2001
! @set UPDATE-MONTH November 2001
  
  @iftex
***************
*** 37,41 ****
  for @code{Bash}, Version @value{VERSION}.
  
! Copyright (C) 1991-1999 Free Software Foundation, Inc.
  
  Permission is granted to make and distribute verbatim copies of
--- 37,41 ----
  for @code{Bash}, Version @value{VERSION}.
  
! Copyright (C) 1991-2001 Free Software Foundation, Inc.
  
  Permission is granted to make and distribute verbatim copies of
***************
*** 268,272 ****
  @item exit status
  @cindex exit status
! The value returned by a command to its caller.
  
  @item field
--- 268,273 ----
  @item exit status
  @cindex exit status
! The value returned by a command to its caller.  The value is restricted
! to eight bits, so the maximum value is 255.
  
  @item field
***************
*** 543,551 ****
  single quote
  @item \@var{nnn}
! the character whose @code{ASCII} code is the octal value @var{nnn}
! (one to three digits)
! @item \x@var{nnn}
! the character whose @code{ASCII} code is the hexadecimal value @var{nnn}
  (one to three digits)
  @end table
  
--- 544,552 ----
  single quote
  @item \@var{nnn}
! the eight-bit character whose value is the octal value @var{nnn}
  (one to three digits)
+ @item \x@var{HH}
+ the eight-bit character whose value is the hexadecimal value @var{HH}
+ (one or two hex digits)
  @end table
  
***************
*** 557,560 ****
--- 558,564 ----
  @subsubsection Locale-Specific Translation
  @cindex localization
+ @cindex internationalization
+ @cindex native languages
+ @cindex translation, native languages
  
  A double-quoted string preceded by a dollar sign (@samp{$}) will cause
***************
*** 565,568 ****
--- 569,575 ----
  double-quoted.
  
+ @vindex LC_MESSAGES
+ @vindex TEXTDOMAIN
+ @vindex TEXTDOMAINDIR
  Some systems use the message catalog selected by the @env{LC_MESSAGES}
  shell variable.  Others create the name of the message catalog from the
***************
*** 570,574 ****
  suffix of @samp{.mo}.  If you use the @env{TEXTDOMAIN} variable, you
  may need to set the @env{TEXTDOMAINDIR} variable to the location of
! the message catalog files.
  
  @node Comments
--- 577,583 ----
  suffix of @samp{.mo}.  If you use the @env{TEXTDOMAIN} variable, you
  may need to set the @env{TEXTDOMAINDIR} variable to the location of
! the message catalog files.  Still others use both variables in this
! fashion:
! @env{TEXTDOMAINDIR}/@env{LC_MESSAGES}/LC_MESSAGES/@env{TEXTDOMAIN}.mo.
  
  @node Comments
***************
*** 641,647 ****
  
  @noindent
! The output of each command in the pipeline is connected to the input of
! the next command.  That is, each command reads the previous command's
! output.
  
  The reserved word @code{time} causes timing statistics
--- 650,656 ----
  
  @noindent
! The output of each command in the pipeline is connected via a pipe
! to the input of the next command.
! That is, each command reads the previous command's output.
  
  The reserved word @code{time} causes timing statistics
***************
*** 892,896 ****
  
  The @var{commands} are executed after each selection until a
! @code{break} or @code{return} command is executed, at which
  point the @code{select} command completes.
  
--- 901,905 ----
  
  The @var{commands} are executed after each selection until a
! @code{break} command is executed, at which
  point the @code{select} command completes.
  
***************
*** 1064,1068 ****
  are restored to the values they had prior to the function's
  execution.  If a numeric argument is given to @code{return},
! that is the function's return status; otherwise the functions's
  return status is the exit status of the last command executed
  before the @code{return}.
--- 1073,1077 ----
  are restored to the values they had prior to the function's
  execution.  If a numeric argument is given to @code{return},
! that is the function's return status; otherwise the function's
  return status is the exit status of the last command executed
  before the @code{return}.
***************
*** 1091,1094 ****
--- 1100,1106 ----
  For the shell's purposes, a @var{variable} is a parameter denoted by a
  @code{name}.
+ A variable has a @var{value} and zero or more @var{attributes}.
+ Attributes are assigned using the @code{declare} builtin command
+ (see the description of the @code{declare} builtin in @ref{Bash Builtins}).
  
  A parameter is set if it has been assigned a value.  The null string is
***************
*** 1106,1111 ****
  command substitution, arithmetic expansion, and quote
  removal (detailed below).  If the variable has its @code{integer}
! attribute set (see the description of the @code{declare} builtin in
! @ref{Bash Builtins}), then @var{value} 
  is subject to arithmetic expansion even if the @code{$((@dots{}))}
  expansion is not used (@pxref{Arithmetic Expansion}).
--- 1118,1122 ----
  command substitution, arithmetic expansion, and quote
  removal (detailed below).  If the variable has its @code{integer}
! attribute set, then @var{value} 
  is subject to arithmetic expansion even if the @code{$((@dots{}))}
  expansion is not used (@pxref{Arithmetic Expansion}).
***************
*** 1113,1116 ****
--- 1124,1130 ----
  of @code{"$@@"} as explained below.
  Filename expansion is not performed.
+ Assignment statements may also appear as arguments to the
+ @code{declare}, @code{typeset}, @code{export}, @code{readonly},
+ and @code{local} builtin commands.
  
  @node Positional Parameters
***************
*** 1871,1881 ****
  @item /dev/tcp/@var{host}/@var{port}
  If @var{host} is a valid hostname or Internet address, and @var{port}
! is an integer port number, Bash attempts to open a TCP connection
! to the corresponding socket.
  
  @item /dev/udp/@var{host}/@var{port}
  If @var{host} is a valid hostname or Internet address, and @var{port}
! is an integer port number, Bash attempts to open a UDP connection
! to the corresponding socket.
  
  @end table
--- 1885,1895 ----
  @item /dev/tcp/@var{host}/@var{port}
  If @var{host} is a valid hostname or Internet address, and @var{port}
! is an integer port number or service name, Bash attempts to open a TCP
! connection to the corresponding socket.
  
  @item /dev/udp/@var{host}/@var{port}
  If @var{host} is a valid hostname or Internet address, and @var{port}
! is an integer port number or service name, Bash attempts to open a UDP
! connection to the corresponding socket.
  
  @end table
***************
*** 2231,2234 ****
--- 2245,2253 ----
  cannot affect the shell's execution environment.
  
+ If a command is followed by a @samp{&} and job control is not active, the
+ default standard input for the command is the empty file @file{/dev/null}.
+ Otherwise, the invoked command inherits the file descriptors of the calling
+ shell as modified by redirections.
+ 
  @node Environment
  @subsection Environment
***************
*** 2320,2325 ****
  
  The shell exits by default upon receipt of a @code{SIGHUP}.
! Before exiting, it resends the @code{SIGHUP} to all jobs, running
! or stopped.
  Stopped jobs are sent @code{SIGCONT} to ensure that they receive
  the @code{SIGHUP}.
--- 2339,2344 ----
  
  The shell exits by default upon receipt of a @code{SIGHUP}.
! Before exiting, an interactive shell resends the @code{SIGHUP} to
! all jobs, running or stopped.
  Stopped jobs are sent @code{SIGCONT} to ensure that they receive
  the @code{SIGHUP}.
***************
*** 2352,2356 ****
  (@pxref{Invoking Bash}), 
  Bash reads and executes commands from the file, then exits.  This
! mode of operation creates a non-interactive shell.  When Bash runs
  a shell script, it sets the special parameter @code{0} to the name
  of the file, rather than the name of the shell, and the positional
--- 2371,2379 ----
  (@pxref{Invoking Bash}), 
  Bash reads and executes commands from the file, then exits.  This
! mode of operation creates a non-interactive shell.  The shell first
! searches for the file in the current directory, and looks in the
! directories in @env{$PATH} if not found there.
! 
! When Bash runs
  a shell script, it sets the special parameter @code{0} to the name
  of the file, rather than the name of the shell, and the positional
***************
*** 2615,2619 ****
  @btindex hash
  @example
! hash [-r] [-p @var{filename}] [@var{name}]
  @end example
  Remember the full pathnames of commands specified as @var{name} arguments,
--- 2638,2642 ----
  @btindex hash
  @example
! hash [-r] [-p @var{filename}] [-t] [@var{name}]
  @end example
  Remember the full pathnames of commands specified as @var{name} arguments,
***************
*** 2624,2627 ****
--- 2647,2654 ----
  used as the location of @var{name}.
  The @option{-r} option causes the shell to forget all remembered locations.
+ If the @option{-t} option is supplied, the full pathname to which each
+ @var{name} corresponds is printed.  If multiple @var{name} arguments are
+ supplied with @option{-t} the @var{name} is printed before the hashed
+ full pathname.
  If no arguments are given, information about remembered commands is printed.
  The return status is zero unless a @var{name} is not found or an invalid
***************
*** 2672,2676 ****
  the exit status of the last command executed within the script as the exit
  status of the script.
! The return status is false if @code{return} is used outside a function
  and not during the execution of a script by @code{.} or @code{source}.
  
--- 2699,2703 ----
  the exit status of the last command executed within the script as the exit
  status of the script.
! The return status is non-zero if @code{return} is used outside a function
  and not during the execution of a script by @code{.} or @code{source}.
  
***************
*** 2796,2799 ****
--- 2823,2832 ----
  If a @var{sigspec} is @code{DEBUG}, the command @var{arg} is executed
  after every simple command.
+ If a @var{sigspec} is @code{ERR}, the command @var{arg} 
+ is executed whenever a simple command has a non-zero exit status.
+ The @code{ERR} trap is not executed if the failed command is part of an
+ @code{until} or @code{while} loop, part of an @code{if} statement,
+ part of a @code{&&} or @code{||} list, or if the command's return
+ status is being inverted using @code{!}.
  The @option{-l} option causes the shell to print a list of signal names
  and their corresponding numbers.
***************
*** 3075,3083 ****
  backslash
  @item \@var{nnn}
! the character whose @code{ASCII} code is the octal value @var{nnn}
! (one to three digits)
! @item \x@var{nnn}
! the character whose @code{ASCII} code is the hexadecimal value @var{nnn}
  (one to three digits)
  @end table
  
--- 3108,3116 ----
  backslash
  @item \@var{nnn}
! the eight-bit character whose value is the octal value @var{nnn}
  (one to three digits)
+ @item \x@var{HH}
+ the eight-bit character whose value is the hexadecimal value @var{HH}
+ (one or two hex digits)
  @end table
  
***************
*** 3378,3381 ****
--- 3411,3419 ----
  embedded newlines rather than using semicolon separators where possible.
  
+ @item login_shell
+ The shell sets this option if it is started as a login shell
+ (@pxref{Invoking Bash}).
+ The value may not be changed.
+ 
  @item mailwarn
  If set, and a file that Bash is checking for mail has been  
***************
*** 3532,3536 ****
  @end table
  
! If @var{limit} is given, it is the new value of the specified resource.
  Otherwise, the current value of the soft limit for the specified resource
  is printed, unless the @option{-H} option is supplied.
--- 3570,3577 ----
  @end table
  
! If @var{limit} is given, it is the new value of the specified resource;
! the special @var{limit} values @code{hard}, @code{soft}, and
! @code{unlimited} stand for the current hard limit, the current soft limit,
! and no limit, respectively.
  Otherwise, the current value of the soft limit for the specified resource
  is printed, unless the @option{-H} option is supplied.
***************
*** 3542,3548 ****
  are unscaled values.
  
! The return status is zero unless an invalid option is supplied, a
! non-numeric argument other than @code{unlimited} is supplied as a
! @var{limit}, or an error occurs while setting a new limit.
  
  @item unalias
--- 3583,3588 ----
  are unscaled values.
  
! The return status is zero unless an invalid option or argument is supplied,
! or an error occurs while setting a new limit.
  
  @item unalias
***************
*** 3592,3595 ****
--- 3632,3636 ----
  part of a @code{&&} or @code{||} list, or if the command's return
  status is being inverted using @code{!}.
+ A trap on @code{ERR}, if set, is executed before the shell exits.
  
  @item -f
***************
*** 3658,3661 ****
--- 3699,3705 ----
  Same as @code{-f}.
  
+ @item nolog
+ Currently ignored.
+ 
  @item notify
  Same as @code{-b}.
***************
*** 3928,3936 ****
  @end table
  
! @item COMP_WORDS
! An array variable consisting of the individual
! words in the current command line.
! This variable is available only in shell functions invoked by the
! programmable completion facilities (@pxref{Programmable Completion}).
  
  @item COMP_CWORD
--- 3972,3979 ----
  @end table
  
! @item COLUMNS
! Used by the @code{select} builtin command to determine the terminal width
! when printing selection lists.  Automatically set upon receipt of a
! @code{SIGWINCH}.
  
  @item COMP_CWORD
***************
*** 3955,3958 ****
--- 3998,4007 ----
  programmable completion facilities (@pxref{Programmable Completion}).
  
+ @item COMP_WORDS
+ An array variable consisting of the individual
+ words in the current command line.
+ This variable is available only in shell functions invoked by the
+ programmable completion facilities (@pxref{Programmable Completion}).
+ 
  @item COMPREPLY
  An array variable from which Bash reads the possible completions
***************
*** 3987,3990 ****
--- 4036,4046 ----
  value is @samp{.o:~}
  
+ @item FUNCNAME
+ The name of any currently-executing shell function.      
+ This variable exists only when a shell function is executing.
+ Assignments to @env{FUNCNAME} have no effect and return an error status.
+ If @env{FUNCNAME} is unset, it loses its special properties, even if
+ it is subsequently reset.
+ 
  @item GLOBIGNORE
  A colon-separated list of patterns defining the set of filenames to
***************
*** 4020,4030 ****
  even if it is subsequently reset.
  
- @item FUNCNAME
- The name of any currently-executing shell function.      
- This variable exists only when a shell function is executing.
- Assignments to @env{FUNCNAME} have no effect and return an error status.
- If @env{FUNCNAME} is unset, it loses its special properties, even if
- it is subsequently reset.
- 
  @item HISTCONTROL
  A value of @samp{ignorespace} means to not enter lines which
--- 4076,4079 ----
***************
*** 4039,4042 ****
--- 4088,4103 ----
  @env{HISTCONTROL}.
  
+ @item HISTFILE
+ The name of the file to which the command history is saved.  The
+ default value is @file{~/.bash_history}.
+ 
+ @item HISTFILESIZE
+ The maximum number of lines contained in the history file.  When this
+ variable is assigned a value, the history file is truncated, if
+ necessary, to contain no more than that number of lines.
+ The history file is also truncated to this size after
+ writing it when an interactive shell exits.
+ The default value is 500.
+ 
  @item HISTIGNORE
  A colon-separated list of patterns used to decide which command
***************
*** 4059,4078 ****
  provides the functionality of @code{ignoreboth}. 
  
- @item HISTFILE
- The name of the file to which the command history is saved.  The
- default value is @file{~/.bash_history}.
- 
  @item HISTSIZE
  The maximum number of commands to remember on the history list.
  The default value is 500.
  
- @item HISTFILESIZE
- The maximum number of lines contained in the history file.  When this
- variable is assigned a value, the history file is truncated, if
- necessary, to contain no more than that number of lines.
- The history file is also truncated to this size after
- writing it when an interactive shell exits.
- The default value is 500.
- 
  @item HOSTFILE
  Contains the name of a file in the same format as @file{/etc/hosts} that
--- 4120,4127 ----
***************
*** 4134,4137 ****
--- 4183,4189 ----
  This variable determines the locale category used for number formatting.
  
+ @item LINENO
+ The line number in the script or shell function currently executing.
+ 
  @item LINES
  Used by the @code{select} builtin command to determine the column length
***************
*** 4139,4150 ****
  @code{SIGWINCH}.
  
- @item COLUMNS
- Used by the @code{select} builtin command to determine the terminal width
- when printing selection lists.  Automatically set upon receipt of a
- @code{SIGWINCH}.
- 
- @item LINENO
- The line number in the script or shell function currently executing.
- 
  @item MACHTYPE
  A string that fully describes the system type on which Bash
--- 4191,4194 ----
***************
*** 4175,4178 ****
--- 4219,4234 ----
  contain only a single command).
  
+ @item POSIXLY_CORRECT
+ If this variable is in the environment when @code{bash} starts, the shell
+ enters @sc{posix} mode (@pxref{Bash POSIX Mode}) before reading the
+ startup files, as if the @option{--posix} invocation option had been supplied.
+ If it is set while the shell is running, @code{bash} enables @sc{posix} mode,
+ as if the command
+ @example
+ @code{set -o posix}
+ @end example
+ @noindent
+ had been executed.  
+ 
  @item PPID
  The process @sc{id} of the shell's parent process.  This variable
***************
*** 4311,4317 ****
  
  @example
! bash [long-opt] [-ir] [-abefhkmnptuvxdBCDHP] [-o @var{option}] [@var{argument} @dots{}]
! bash [long-opt] [-abefhkmnptuvxdBCDHP] [-o @var{option}] -c @var{string} [@var{argument} @dots{}]
! bash [long-opt] -s [-abefhkmnptuvxdBCDHP] [-o @var{option}] [@var{argument} @dots{}]
  @end example
  
--- 4367,4373 ----
  
  @example
! bash [long-opt] [-ir] [-abefhkmnptuvxdBCDHP] [-o @var{option}] [-O @var{shopt_option}] [@var{argument} @dots{}]
! bash [long-opt] [-abefhkmnptuvxdBCDHP] [-o @var{option}] [-O @var{shopt_option}] -c @var{string} [@var{argument} @dots{}]
! bash [long-opt] -s [-abefhkmnptuvxdBCDHP] [-o @var{option}] [-O @var{shopt_option}] [@var{argument} @dots{}]
  @end example
  
***************
*** 4415,4418 ****
--- 4471,4484 ----
  This implies the @option{-n} option; no commands will be executed.
  
+ @item [-+]O [@var{shopt_option}]
+ @var{shopt_option} is one of the shell options accepted by the
+ @code{shopt} builtin (@pxref{Shell Builtin Commands}).
+ If @var{shopt_option} is present, @option{-O} sets the value of that option;
+ @option{+O} unsets it.  
+ If @var{shopt_option} is not supplied, the names and values of the shell
+ options accepted by @code{shopt} are printed on the standard output.
+ If the invocation option is @option{+O}, the output is displayed in a format
+ that may be reused as input.
+ 
  @item --
  A @code{--} signals the end of options and disables further option
***************
*** 4422,4425 ****
--- 4488,4495 ----
  @end table
  
+ @cindex login shell
+ A @emph{login} shell is one whose first character of argument zero is
+ @samp{-}, or one invoked with the @option{--login} option.
+ 
  @cindex interactive shell
  An @emph{interactive} shell is one started without non-option arguments,
***************
*** 4931,4935 ****
  omitted, then base 10 is used.
  The digits greater than 9 are represented by the lowercase letters,
! the uppercase letters, @samp{_}, and @samp{@@}, in that order.
  If @var{base} is less than or equal to 36, lowercase and uppercase
  letters may be used interchangably to represent numbers between 10
--- 5001,5005 ----
  omitted, then base 10 is used.
  The digits greater than 9 are represented by the lowercase letters,
! the uppercase letters, @samp{@@}, and @samp{_}, in that order.
  If @var{base} is less than or equal to 36, lowercase and uppercase
  letters may be used interchangably to represent numbers between 10
***************
*** 5066,5070 ****
  
  The @code{unset} builtin is used to destroy arrays.
! @code{unset} @var{name[subscript]}
  destroys the array element at index @var{subscript}.
  @code{unset} @var{name}, where @var{name} is an array, removes the
--- 5136,5140 ----
  
  The @code{unset} builtin is used to destroy arrays.
! @code{unset} @var{name}[@var{subscript}]
  destroys the array element at index @var{subscript}.
  @code{unset} @var{name}, where @var{name} is an array, removes the
***************
*** 5231,5234 ****
--- 5301,5306 ----
  @item \@@
  The time, in 12-hour am/pm format.
+ @item \A
+ The time, in 24-hour HH:MM format.
  @item \u
  The username of the current user.
***************
*** 5463,5466 ****
--- 5535,5542 ----
  shell function names and definitions.
  
+ @item
+ When the @code{set} builtin is invoked without options, it displays
+ variable values without quotes, unless they contain shell metacharacters,
+ even if the result contains nonprinting characters.
  @end enumerate
  
***************
*** 5586,5592 ****
  Normally, Bash waits until it is about to print a prompt
  before reporting changes in a job's status so as to not interrupt
! any other output.  If the 
! the @option{-b} option to the @code{set} builtin is enabled,
  Bash reports such changes immediately (@pxref{The Set Builtin}).
  
  If an attempt to exit Bash is while jobs are stopped, the
--- 5662,5670 ----
  Normally, Bash waits until it is about to print a prompt
  before reporting changes in a job's status so as to not interrupt
! any other output.
! If the @option{-b} option to the @code{set} builtin is enabled,
  Bash reports such changes immediately (@pxref{The Set Builtin}).
+ Any trap on @code{SIGCHLD} is executed for each child process
+ that exits.
  
  If an attempt to exit Bash is while jobs are stopped, the
***************
*** 5868,5883 ****
  @file{configure.in} if you want to change it or regenerate
  @code{configure} using a newer version of Autoconf.  If
! you do this, make sure you are using Autoconf version 2.10 or
  newer.
  
- If you need to change @file{configure.in} or regenerate
- @code{configure}, you will need to create two files: 
- @file{_distribution} and @file{_patchlevel}.  @file{_distribution}
- should contain the major and minor version numbers of the Bash
- distribution, for example @samp{2.01}.  @file{_patchlevel} should
- contain the patch level of the Bash distribution, @samp{0} for
- example.  The script @file{support/mkconffiles} has been provided
- to automate the creation of these files.
- 
  You can remove the program binaries and object files from the
  source code directory by typing @samp{make clean}.  To also remove the
--- 5946,5952 ----
  @file{configure.in} if you want to change it or regenerate
  @code{configure} using a newer version of Autoconf.  If
! you do this, make sure you are using Autoconf version 2.50 or
  newer.
  
  You can remove the program binaries and object files from the
  source code directory by typing @samp{make clean}.  To also remove the
***************
*** 5948,5952 ****
  @file{/usr/local/bin}, @file{/usr/local/man}, etc.  You can
  specify an installation prefix other than @file{/usr/local} by
! giving @code{configure} the option @option{--prefix=@var{PATH}}. 
  
  You can specify separate installation prefixes for
--- 6017,6023 ----
  @file{/usr/local/bin}, @file{/usr/local/man}, etc.  You can
  specify an installation prefix other than @file{/usr/local} by
! giving @code{configure} the option @option{--prefix=@var{PATH}},
! or by specifying a value for the @code{DESTDIR} @samp{make}
! variable when running @samp{make install}.
  
  You can specify separate installation prefixes for
***************
*** 5961,5965 ****
  
  There may be some features @code{configure} can not figure out
! automatically, but needs to determine by the type of host Bash
  will run on.  Usually @code{configure} can figure that
  out, but if it prints a message saying it can not guess the host
--- 6032,6036 ----
  
  There may be some features @code{configure} can not figure out
! automatically, but need to determine by the type of host Bash
  will run on.  Usually @code{configure} can figure that
  out, but if it prints a message saying it can not guess the host
***************
*** 5967,5971 ****
  either be a short name for the system type, such as @samp{sun4},
  or a canonical name with three fields: @samp{CPU-COMPANY-SYSTEM}
! (e.g., @samp{sparc-sun-sunos4.1.2}).
  
  See the file @file{support/config.sub} for the possible
--- 6038,6042 ----
  either be a short name for the system type, such as @samp{sun4},
  or a canonical name with three fields: @samp{CPU-COMPANY-SYSTEM}
! (e.g., @samp{i386-unknown-freebsd4.2}).
  
  See the file @file{support/config.sub} for the possible
***************
*** 6053,6072 ****
  database.
  
- @item --with-glibc-malloc
- Use the @sc{gnu} libc version of @code{malloc} in
- @file{lib/malloc/gmalloc.c}.  This is not the version of @code{malloc}
- that appears in glibc version 2, but a modified version of the
- @code{malloc} from glibc version 1.  This is somewhat slower than the
- default @code{malloc}, but wastes less space on a per-allocation
- basis, and will return memory to the operating system under
- certain circumstances.
- 
  @item --with-gnu-malloc
  A synonym for @code{--with-bash-malloc}.
  
! @item --with-installed-readline
  Define this to make Bash link with a locally-installed version of Readline
  rather than the version in @file{lib/readline}.  This works only with
! Readline 4.1 and later versions.
  
  @item --with-purify
--- 6124,6145 ----
  database.
  
  @item --with-gnu-malloc
  A synonym for @code{--with-bash-malloc}.
  
! @item --with-installed-readline[=@var{PREFIX}]
  Define this to make Bash link with a locally-installed version of Readline
  rather than the version in @file{lib/readline}.  This works only with
! Readline 4.2 and later versions.  If @var{PREFIX} is @code{yes} or not
! supplied, @code{configure} uses the values of the make variables
! @code{includedir} and @code{libdir}, which are subdirectories of @code{prefix}
! by default, to find the installed version of Readline if it is not in
! the standard system include and library directories.
! If @var{PREFIX} is @code{no}, Bash links with the version in
! @file{lib/readline}.
! If @var{PREFIX} is set to any other value, @code{configure} treats it as
! a directory pathname and looks for
! the installed version of Readline in subdirectories of that directory
! (include files in @var{PREFIX}/@code{include} and the library in
! @var{PREFIX}/@code{lib}).
  
  @item --with-purify
***************
*** 6083,6086 ****
--- 6156,6164 ----
  
  @table @code
+ @item --enable-largefile
+ Enable support for @uref{http://www.sas.com/standards/large_file/x_open.20Mar96.html,
+ large files} if the operating system requires special compiler options
+ to build programs which can access large files.
+ 
  @item --enable-profiling
  This builds a Bash binary that produces profiling information to be
***************
*** 6534,6538 ****
  @item
  Bash includes the @code{shopt} builtin, for finer control of shell
! optional capabilities (@pxref{Bash Builtins}).
  
  @item
--- 6612,6617 ----
  @item
  Bash includes the @code{shopt} builtin, for finer control of shell
! optional capabilities (@pxref{Bash Builtins}), and allows these options
! to be set and unset at shell invocation (@pxref{Invoking Bash}).
  
  @item
***************
*** 6546,6554 ****
  
  @item
! The @code{trap} builtin (@pxref{Bourne Shell Builtins})
! allows a @code{DEBUG} pseudo-signal specification,
! similar to @code{EXIT}.  Commands specified with a @code{DEBUG} trap are
! executed after every simple command.  The @code{DEBUG} trap is not
! inherited by shell functions.
  
  @item
--- 6625,6639 ----
  
  @item
! The @code{trap} builtin (@pxref{Bourne Shell Builtins}) allows a
! @code{DEBUG} pseudo-signal specification, similar to @code{EXIT}.
! Commands specified with a @code{DEBUG} trap are executed after every
! simple command.
! The @code{DEBUG} trap is not inherited by shell functions.
! 
! The @code{trap} builtin (@pxref{Bourne Shell Builtins}) allows an
! @code{ERR} pseudo-signal specification, similar to @code{EXIT} and @code{DEBUG}.
! Commands specified with an @code{ERR} trap are executed after a simple
! command fails, with a few exceptions.
! The @code{ERR} trap is not inherited by shell functions.
  
  @item
diff -Nrc2 bash-2.05/doc/builtins.1 bash-2.05a/doc/builtins.1
*** bash-2.05/doc/builtins.1	Mon Nov 29 16:30:13 1999
--- bash-2.05a/doc/builtins.1	Mon Oct 29 10:03:52 2001
***************
*** 1,10 ****
  .\" This is a hack to force bash builtins into the whatis database
  .\" and to get the list of builtins to come up with the man command.
! .TH BASH_BUILTINS 1 "1996 Mar 20" GNU
  .SH NAME
! bash, :, ., alias, bg, bind, break, builtin, case, cd, command,
  continue, declare, dirs, disown, echo, enable, eval, exec, exit,
  export, fc, fg, for, getopts, hash, help, history, if, jobs, kill,
! let, local, logout, popd, pushd, pwd, read, readonly, return, set,
  shift, shopt, source, suspend, test, times, trap, type, typeset,
  ulimit, umask, unalias, unset, until, wait, while \- bash built-in commands, see \fBbash\fR(1)
--- 1,11 ----
  .\" This is a hack to force bash builtins into the whatis database
  .\" and to get the list of builtins to come up with the man command.
! .TH BASH_BUILTINS 1 "2001 October 29" "GNU Bash-2.05a"
  .SH NAME
! bash, :, ., [, alias, bg, bind, break, builtin, case, cd, command, compgen,
! complete, 
  continue, declare, dirs, disown, echo, enable, eval, exec, exit,
  export, fc, fg, for, getopts, hash, help, history, if, jobs, kill,
! let, local, logout, popd, printf, pushd, pwd, read, readonly, return, set,
  shift, shopt, source, suspend, test, times, trap, type, typeset,
  ulimit, umask, unalias, unset, until, wait, while \- bash built-in commands, see \fBbash\fR(1)
diff -Nrc2 bash-2.05/error.c bash-2.05a/error.c
*** bash-2.05/error.c	Mon Mar 26 10:36:07 2001
--- bash-2.05a/error.c	Mon Oct 15 13:24:40 2001
***************
*** 59,63 ****
  #if defined (JOB_CONTROL)
  extern pid_t shell_pgrp;
! extern int give_terminal_to ();
  #endif /* JOB_CONTROL */
  
--- 59,63 ----
  #if defined (JOB_CONTROL)
  extern pid_t shell_pgrp;
! extern int give_terminal_to __P((pid_t, int));
  #endif /* JOB_CONTROL */
  
***************
*** 96,100 ****
  void
  file_error (filename)
!      char *filename;
  {
    report_error ("%s: %s", filename, strerror (errno));
--- 96,100 ----
  void
  file_error (filename)
!      const char *filename;
  {
    report_error ("%s: %s", filename, strerror (errno));
***************
*** 228,232 ****
  
  #if defined (JOB_CONTROL)
!   give_terminal_to (shell_pgrp);
  #endif /* JOB_CONTROL */
  
--- 228,232 ----
  
  #if defined (JOB_CONTROL)
!   give_terminal_to (shell_pgrp, 0);
  #endif /* JOB_CONTROL */
  
***************
*** 447,451 ****
    va_list args;
  
!   fprintf(stderr, "TRACE: pid %d: ", (int)getpid());
  
  #if defined (PREFER_STDARG)
--- 447,451 ----
    va_list args;
  
!   fprintf(stderr, "TRACE: pid %ld: ", (long)getpid());
  
  #if defined (PREFER_STDARG)
***************
*** 485,489 ****
      fcntl (fileno (tracefp), F_SETFD, 1);     /* close-on-exec */
  
!   fprintf(tracefp, "TRACE: pid %d: ", getpid());
  
  #if defined (PREFER_STDARG)
--- 485,489 ----
      fcntl (fileno (tracefp), F_SETFD, 1);     /* close-on-exec */
  
!   fprintf(tracefp, "TRACE: pid %ld: ", (long)getpid());
  
  #if defined (PREFER_STDARG)
diff -Nrc2 bash-2.05/error.h bash-2.05a/error.h
*** bash-2.05/error.h	Thu Aug  5 07:04:11 1999
--- bash-2.05a/error.h	Mon Oct 15 09:27:42 2001
***************
*** 25,53 ****
  
  /* Get the name of the shell or shell script for an error message. */
! extern char *get_name_for_error ();
  
  /* Report an error having to do with FILENAME. */
! extern void file_error __P((char *));
  
  /* Report a programmer's error, and abort.  Pass REASON, and ARG1 ... ARG5. */
! extern void programming_error __P((const char *, ...));
  
  /* General error reporting.  Pass FORMAT and ARG1 ... ARG5. */
! extern void report_error __P((const char *, ...));
  
  /* Error messages for parts of the parser that don't call report_syntax_error */
! extern void parser_error __P((int, const char *, ...));
  
  /* Report an unrecoverable error and exit.  Pass FORMAT and ARG1 ... ARG5. */
! extern void fatal_error __P((const char *, ...));
  
  /* Report a system error, like BSD warn(3). */
! extern void sys_error __P((const char *, ...));
  
  /* Report an internal error. */
! extern void internal_error __P((const char *, ...));
  
  /* Report an internal warning. */
! extern void internal_warning __P((const char *, ...));
  
  /* Report an error having to do with command parsing or execution. */
--- 25,53 ----
  
  /* Get the name of the shell or shell script for an error message. */
! extern char *get_name_for_error __P((void));
  
  /* Report an error having to do with FILENAME. */
! extern void file_error __P((const char *));
  
  /* Report a programmer's error, and abort.  Pass REASON, and ARG1 ... ARG5. */
! extern void programming_error __P((const char *, ...))  __attribute__((__format__ (printf, 1, 2)));
  
  /* General error reporting.  Pass FORMAT and ARG1 ... ARG5. */
! extern void report_error __P((const char *, ...))  __attribute__((__format__ (printf, 1, 2)));
  
  /* Error messages for parts of the parser that don't call report_syntax_error */
! extern void parser_error __P((int, const char *, ...))  __attribute__((__format__ (printf, 2, 3)));
  
  /* Report an unrecoverable error and exit.  Pass FORMAT and ARG1 ... ARG5. */
! extern void fatal_error __P((const char *, ...))  __attribute__((__format__ (printf, 1, 2)));
  
  /* Report a system error, like BSD warn(3). */
! extern void sys_error __P((const char *, ...))  __attribute__((__format__ (printf, 1, 2)));
  
  /* Report an internal error. */
! extern void internal_error __P((const char *, ...))  __attribute__((__format__ (printf, 1, 2)));
  
  /* Report an internal warning. */
! extern void internal_warning __P((const char *, ...))  __attribute__((__format__ (printf, 1, 2)));
  
  /* Report an error having to do with command parsing or execution. */
***************
*** 55,58 ****
--- 55,61 ----
  
  extern char *command_errstr __P((int));
+ 
+ /* Debugging function, not enabled in released version. */
+ extern void itrace __P((const char *, ...)) __attribute__ ((__format__ (printf, 1, 2)));
  
  #endif /* !_ERROR_H_ */
diff -Nrc2 bash-2.05/eval.c bash-2.05a/eval.c
*** bash-2.05/eval.c	Wed Feb 14 16:58:24 2001
--- bash-2.05a/eval.c	Mon Oct 29 13:52:11 2001
***************
*** 44,51 ****
  #endif
  
- extern int yyparse ();
- 
  extern int EOF_reached;
! extern int indirection_level, interactive, interactive_shell;
  extern int posixly_correct;
  extern int subshell_environment, running_under_emacs;
--- 44,49 ----
  #endif
  
  extern int EOF_reached;
! extern int indirection_level;
  extern int posixly_correct;
  extern int subshell_environment, running_under_emacs;
***************
*** 63,66 ****
--- 61,66 ----
    COMMAND *current_command = (COMMAND *)NULL;
  
+   USE_VAR(current_command);
+ 
    our_indirection_level = ++indirection_level;
  
***************
*** 235,243 ****
    tmout_var = (SHELL_VAR *)NULL;
    tmout_len = 0;
  
    if (interactive)
      {
        tmout_var = find_variable ("TMOUT");
-       old_alrm = (SigHandler *)NULL;
  
        if (tmout_var && tmout_var->value)
--- 235,243 ----
    tmout_var = (SHELL_VAR *)NULL;
    tmout_len = 0;
+   old_alrm = (SigHandler *)NULL;
  
    if (interactive)
      {
        tmout_var = find_variable ("TMOUT");
  
        if (tmout_var && tmout_var->value)
diff -Nrc2 bash-2.05/examples/complete/complete-examples bash-2.05a/examples/complete/complete-examples
*** bash-2.05/examples/complete/complete-examples	Mon Nov 20 11:33:57 2000
--- bash-2.05a/examples/complete/complete-examples	Wed May  9 11:08:08 2001
***************
*** 477,480 ****
--- 477,481 ----
  
  complete -u su
+ complete -g newgrp groupdel groupmod
  
  complete -f -X '!*.+(ps|PS)' gs gv ghostview psselect pswrap
diff -Nrc2 bash-2.05/examples/complete/complete.gnu-longopt bash-2.05a/examples/complete/complete.gnu-longopt
*** bash-2.05/examples/complete/complete.gnu-longopt	Wed Dec 31 19:00:00 1969
--- bash-2.05a/examples/complete/complete.gnu-longopt	Wed May 30 15:56:23 2001
***************
*** 0 ****
--- 1,43 ----
+ #
+ # Originally from:
+ #
+ #Message-ID: <3B13EC65.179451AE@wanadoo.fr>
+ #Date: Tue, 29 May 2001 20:37:25 +0200
+ #From: Manu Rouat <emmanuel.rouat@wanadoo.fr>
+ #Subject: [bash] Universal command options completion?
+ #
+ #
+ #In the recent versions of bash (after 2.04) programmable 
+ #completion is available. A useful completion function
+ #is , for a particular command, to enumerate all flags
+ #that can be used in the command. Now, most GNU unix 
+ #commands have so-called 'long options' for example:
+ #
+ #ls --color=always --no-group --size
+ #
+ #and these are all listed when you issue a '--help' flag.
+ #So the idea is to use that, then parse the output of the
+ #'--help' and reinject this to compgen. The basis of the 
+ #following 'universal' completion funtion was the _configure_func'
+ #written by Ian McDonnald (or is it Chet Ramey ?)
+ #A dedicated function will always be better, but this is quite
+ #convenient. I chose to use 'long options' because they are
+ #easy to parse and explicit too (it's the point I guess...)
+ #Lots of room for improvement !
+ 
+ _longopt_func ()
+ {
+     case "$2" in
+ 	-*)	;;
+ 	*)	return ;;
+     esac
+ 
+     case "$1" in
+ 	\~*)	eval cmd=$1 ;;
+ 	*)	cmd="$1" ;;
+     esac
+     COMPREPLY=( $("$cmd" --help | sed  -e '/--/!d' -e 's/.*--\([^ ]*\).*/--\1/'| \
+ grep ^"$2" |sort -u) )
+ }
+ 
+ complete  -o default -F _longopt_func ldd wget bash id info # some examples that work
diff -Nrc2 bash-2.05/examples/functions/autoload bash-2.05a/examples/functions/autoload
*** bash-2.05/examples/functions/autoload	Mon Sep 12 14:34:14 1994
--- bash-2.05a/examples/functions/autoload	Wed Oct 10 09:38:47 2001
***************
*** 52,56 ****
  	#
  	if [ $# -eq 0 ] ; then
! 		echo "usage: autoload function [function...]"
  		return 1
  	fi
--- 52,56 ----
  	#
  	if [ $# -eq 0 ] ; then
! 		echo "usage: autoload function [function...]" >&2
  		return 1
  	fi
***************
*** 61,65 ****
  
  	if [ -z "$FPATH" ] ; then
! 		echo autoload: FPATH not set
  		return 1
  	fi
--- 61,65 ----
  
  	if [ -z "$FPATH" ] ; then
! 		echo autoload: FPATH not set or null >&2
  		return 1
  	fi
***************
*** 72,86 ****
  	#
  
! 	fp=$(echo $FPATH | sed 's/^:/.:/
! 				s/::/:.:/g
! 				s/:$/:./
! 				s/:/ /g')
  
  	for FUNC in $args ; do
  		#
  		# We're blowing away the arguments to autoload here...
! 		# We have to; there are no arrays.
  		#
! 		set $fp
  
  		while [ $# -ne 0 ] ; do
--- 72,94 ----
  	#
  
! #	fp=$(echo $FPATH | sed 's/^:/.:/
! #				s/::/:.:/g
! #				s/:$/:./
! #				s/:/ /g')
! 
! 	# replaced with builtin mechanisms 2001 Oct 10
! 
! 	fp=${FPATH/#:/.:}
! 	fp=${fp//::/:.:}
! 	fp=${fp/%:/:.}
! 	fp=${fp//:/ }
  
  	for FUNC in $args ; do
  		#
  		# We're blowing away the arguments to autoload here...
! 		# We have to; there are no arrays (well, there are, but
! 		# this doesn't use them yet).
  		#
! 		set -- $fp
  
  		while [ $# -ne 0 ] ; do
***************
*** 92,96 ****
  
  		if [ $# -eq 0 ] ; then
! 			echo "$FUNC: autoload function not found"
  			continue
  		fi
--- 100,104 ----
  
  		if [ $# -eq 0 ] ; then
! 			echo "$FUNC: autoload function not found" >&2
  			continue
  		fi
diff -Nrc2 bash-2.05/examples/functions/autoload.v2 bash-2.05a/examples/functions/autoload.v2
*** bash-2.05/examples/functions/autoload.v2	Tue Oct  8 16:35:19 1996
--- bash-2.05a/examples/functions/autoload.v2	Wed Oct 10 09:35:11 2001
***************
*** 19,23 ****
  #	-u	unset each function and remove it from the autoload list
  #
! # The first cut of this was by Bill Trost, trost@reed.bitnet
  #
  # Chet Ramey
--- 19,23 ----
  #	-u	unset each function and remove it from the autoload list
  #
! # The first cut of this was by Bill Trost, trost@reed.edu
  #
  # Chet Ramey
diff -Nrc2 bash-2.05/examples/functions/coproc.bash bash-2.05a/examples/functions/coproc.bash
*** bash-2.05/examples/functions/coproc.bash	Wed Dec 31 19:00:00 1969
--- bash-2.05a/examples/functions/coproc.bash	Mon Sep 24 14:24:10 2001
***************
*** 0 ****
--- 1,109 ----
+ # coprocess.bash
+ #
+ # vi:set sts=2 sw=2 ai:
+ #
+ 
+ coprocess_pid=
+ 
+ #
+ # coprocess - Start, control, and end coprocesses.
+ #
+ function coprocess ()
+ {
+   while (( $# > 0 )) ; do
+     case "$1" in
+       #
+       # coprocess close
+       #
+       c|cl|clo|clos|close)
+ 	shift
+ 	exec 61>&- 62<&-
+ 	coprocess_pid=
+ 	if [ "$1" = "-SIGPIPE" ] ; then
+ 	  # Only print message in an interactive shell
+ 	  case "$-" in
+ 	    *i*)
+ 	      echo 'SIGPIPE' >&2
+ 	      ;;
+ 	  esac
+ 	  return 1
+ 	fi
+ 	return 0
+ 	;;
+ 
+       #
+       # coprocess open
+       #
+       o|op|ope|open)
+ 	shift
+ 	local fifo="/var/tmp/coprocess.$$.$RANDOM"
+ 
+ 	local cmd="/bin/bash"
+ 	if (( $# > 0 )) ; then
+ 	  cmd="$@"
+ 	fi
+ 
+ 	mkfifo "$fifo.in" || return $?
+ 	mkfifo "$fifo.out" || {
+ 	  ret=$?
+ 	  rm -f "$fifo.in"
+ 	  return $?
+ 	}
+ 
+ 	( "$@" <$fifo.in >$fifo.out ; rm -f "$fifo.in" "$fifo.out" ) &
+ 	coprocess_pid=$!
+ 	exec 61>$fifo.in 62<$fifo.out
+ 	return 0
+ 	;;
+ 
+       #
+       # coprocess print - write to the coprocess
+       #
+       p|pr|pri|prin|print)
+ 	shift
+ 	local old_trap=$(trap -p SIGPIPE)
+ 	trap 'coprocess close -SIGPIPE' SIGPIPE
+ 	if [ $# -eq 1 -a "$1" = "--stdin" ] ; then
+ 	  cat >&61
+ 	else
+ 	  echo "$@" >&61
+ 	fi
+ 	local ret=$?
+ 	eval "$old_trap"
+ 	return $ret
+ 	;;
+ 
+       #
+       # coprocess read - read from the coprocess
+       #
+       r|re|rea|read)
+ 	shift
+ 	local old_trap=$(trap -p SIGPIPE)
+ 	trap '_coprocess_close -SIGPIPE' SIGPIPE
+ 	builtin read "$@" <&62
+ 	local ret=$?
+ 	eval "$old_trap"
+ 	return $ret
+ 	;;
+ 
+       s|st|sta|stat|statu|status)
+ 	if [ -z "$coprocess_pid" ] ; then
+ 	  echo 'no active coprocess'
+ 	  return 1
+ 	else
+ 	  echo "  coprocess is active [$coprocess_pid]"
+ 	  return 0
+ 	fi
+ 	;;
+ 
+       *)
+ 	coprocess print "$@"
+ 	return $?
+ 	;;
+     esac
+     shift
+   done
+   coprocess status
+   return $?
+ }
+ 
diff -Nrc2 bash-2.05/examples/functions/coshell.README bash-2.05a/examples/functions/coshell.README
*** bash-2.05/examples/functions/coshell.README	Wed Dec 31 19:00:00 1969
--- bash-2.05a/examples/functions/coshell.README	Mon Sep 24 14:27:29 2001
***************
*** 0 ****
--- 1,53 ----
+ Date: Fri, 21 Sep 2001 14:50:29 -0400
+ From: "Jason M. Felice" <jfelice@cronosys.com>
+ To: bash-maintainers@gnu.org, chet@po.cwru.edu
+ Subject: Bash co-processes functions
+ Message-ID: <20010921145029.A6093@argo.eraserhead.net>
+ Mime-Version: 1.0
+ 
+ Attached to this message you will find coprocess.bash and coshell.bash.
+ Here's a brief synopsis of use:
+ 
+ coprocess open telnet localhost
+ while coprocess read il ; do
+   echo "$il"
+   case "$il" in
+     *ogin:*)
+       coprocess print 'user'
+       ;;
+     *ord:*)
+       echo 'pass' |coprocess print --stdin
+       ;;
+     *$ *)
+       coprocess print 'exit'
+       break
+       ;;
+   esac
+ done
+ coprocess close
+ 
+ And here's an example of the coshell function:
+ 
+ coshell open ssh -l root otherbox
+ coshell eval hostname
+ coshell ls -l
+ if coshell test -d /tmp ; then echo 'otherbox has a /tmp!' ; fi
+ 
+ coshell sendfile /var/lib/upgrade.rpm /tmp/test.rpm || exit $?
+ coshell eval rpm -ivh /tmp/test.rpm || exit $?
+ coshell eval rm -f /tmp/test.rpm || exit $?
+ coshell close
+ exit 0
+ 
+ There are a few minor issues that I'd like to work out, but it works well
+ enough for me ;-)  The issues are:
+ 
+ - Shell quoting issue with 'coshell eval' commands - need to somehow
+   re-quote words.
+ - Interactive commands hang 'coshell eval', tried redirecting in </dev/null
+   to executed command, but it caused strange shell exit problems.
+ - Some way to copy stdin from local coshell eval to remote shell.  Probably
+   logically impossible, but would be wonderfully useful.
+ 
+ I'm using it for writing scripts to publish websites and other scripts to
+ co-located servers.
diff -Nrc2 bash-2.05/examples/functions/coshell.bash bash-2.05a/examples/functions/coshell.bash
*** bash-2.05/examples/functions/coshell.bash	Wed Dec 31 19:00:00 1969
--- bash-2.05a/examples/functions/coshell.bash	Mon Sep 24 14:24:41 2001
***************
*** 0 ****
--- 1,127 ----
+ # vi:set sts=2 sw=2 ai:
+ #
+ # coshell.bash - Control shell coprocesses (see coprocess.bash).
+ #
+ 
+ function coshell ()
+ {
+   while (( $# > 0 )) ; do
+     case "$1" in
+       #
+       # coshell open
+       #
+       o|op|ope|open)
+ 	shift
+ 	coprocess open "$@"
+ 	local ret=$?
+ 
+ 	# This should eat any ssh error messages or what not.
+ 	coshell eval : >/dev/null 2>&1
+ 	return $ret
+ 	;;
+ 
+       #
+       # coshell close
+       #
+       c|cl|clo|close)
+ 	shift
+ 	coprocess close "$@"
+ 	return $?
+ 	;;
+ 
+       #
+       # coshell eval
+       #
+       e|ev|eva|eval)
+ 	shift
+ 	local cookie=$RANDOM
+ 	if (( $# == 0 )) ; then
+ 	  echo "coshell eval: no argumentsl" >&2
+ 	  return 1
+ 	fi
+ 	if [ x$coprocess_pid = x ] ; then
+ 	  echo "coshell eval: no active coshell" >&2
+ 	  return 1
+ 	fi
+ 
+ 	coprocess print "$@" 
+ 	coprocess print "coprocess_rc=\$?"
+ 	coprocess print "printf 'coprocess-$cookie----\n%d\n' \$coprocess_rc"
+ 	if [ x$coprocess_pid = x ] ; then
+ 	  return 0
+ 	fi
+ 
+ 	local ol
+ 	while coprocess read ol ; do
+ 	  case "$ol" in
+ 	    *coprocess-$cookie----*)
+ 	      ol="${ol%coprocess-$cookie----}"
+ 	      echo -n "$ol"
+ 	      break
+ 	      ;;
+ 	  esac
+ 	  echo "$ol"
+ 	done
+ 	coprocess read ol
+ 	return $ol
+ 	;;
+ 
+       #
+       # coshell sendfile
+       #
+       s|se|sen|send|sendf|sendfi|sendfil|sendfile)
+ 	shift
+ 	if (( $# != 2 )) ; then
+ 	  echo "coshell sendfile: syntax is 'coshell sendfile SRC TARGET'" >&2
+ 	  return 1
+ 	fi
+ 	if [ x$coprocess_pid = x ] ; then
+ 	  echo "coshell sendfile: no active coshell" >&2
+ 	  return 1
+ 	fi
+ 
+ 	local target=$2
+ 	if coshell test -d "$target" ; then
+ 	  target="$target/${1##*/}" 
+ 	fi
+ 
+ 	coprocess print "uudecode <<END_OF_FILE"
+ 	uuencode -m "$target" <$1 |coprocess print --stdin
+ 	coshell eval "END_OF_FILE"
+ 	return $?
+ 	;;
+ 
+       #
+       # coshell getfile
+       #
+       g|ge|get|getf|getfi|getfil|getfile)
+ 	shift
+ 	if (( $# != 2 )) ; then
+ 	  echo "coshell getfile: syntax is 'coshell getfile SRC TARGET'" >&2
+ 	  return 1
+ 	fi
+ 	if [ x$coprocess_pid = x ] ; then
+ 	  echo "coshell getfile: no active coshell" >&2
+ 	  return 1
+ 	fi
+ 
+ 	local target=$2
+ 	if test -d "$target" ; then
+ 	  target="$target/${1##*/}" 
+ 	fi
+ 
+ 	coshell eval uuencode -m "$target" "<" "$1" |uudecode
+ 	return $?
+ 	;;
+ 
+       *)
+ 	coshell eval "$@"
+ 	return $?
+ 	;;
+     esac
+     shift
+   done
+   coprocess status
+   return $?
+ }
+ 
diff -Nrc2 bash-2.05/examples/loadables/Makefile.in bash-2.05a/examples/loadables/Makefile.in
*** bash-2.05/examples/loadables/Makefile.in	Wed Dec  6 11:26:45 2000
--- bash-2.05a/examples/loadables/Makefile.in	Tue Aug 28 13:28:07 2001
***************
*** 67,73 ****
  
  ALLPROG = print truefalse sleep pushd finfo logname basename dirname \
! 	  tty pathchk tee head mkdir rmdir sprintf printenv id whoami \
! 	  uname sync push ln unlink cut realpath
! OTHERPROG = necho getconf hello cat
  
  all:	$(SHOBJ_STATUS)
--- 67,73 ----
  
  ALLPROG = print truefalse sleep pushd finfo logname basename dirname \
! 	  tty pathchk tee head mkdir rmdir printenv id whoami \
! 	  uname sync push ln unlink cut realpath getconf
! OTHERPROG = necho hello cat
  
  all:	$(SHOBJ_STATUS)
***************
*** 87,93 ****
  everything: supported others
  
- sprintf: sprintf.o
- 	$(SHOBJ_LD) $(SHOBJ_LDFLAGS) $(SHOBJ_XLDFLAGS) -o $@ sprintf.o $(SHOBJ_LIBS)
- 
  print:	print.o
  	$(SHOBJ_LD) $(SHOBJ_LDFLAGS) $(SHOBJ_XLDFLAGS) -o $@ print.o $(SHOBJ_LIBS)
--- 87,90 ----
***************
*** 208,212 ****
  head.o: head.c
  rmdir.o: rmdir.c
- sprintf.o: sprintf.c
  necho.o: necho.c
  getconf.o: getconf.c
--- 205,208 ----
diff -Nrc2 bash-2.05/examples/loadables/finfo.c bash-2.05a/examples/loadables/finfo.c
*** bash-2.05/examples/loadables/finfo.c	Thu Feb 15 10:41:38 2001
--- bash-2.05a/examples/loadables/finfo.c	Tue Aug 28 13:31:53 2001
***************
*** 349,352 ****
--- 349,353 ----
  
  #ifndef NOBUILTIN
+ int
  finfo_builtin(list)
       WORD_LIST *list;
diff -Nrc2 bash-2.05/examples/loadables/getconf.c bash-2.05a/examples/loadables/getconf.c
*** bash-2.05/examples/loadables/getconf.c	Fri May 19 12:13:38 2000
--- bash-2.05a/examples/loadables/getconf.c	Thu May 24 16:27:23 2001
***************
*** 41,44 ****
--- 41,52 ----
   */
  
+ #ifdef HAVE_CONFIG_H
+ #  include <config.h>
+ #endif
+ 
+ #ifdef HAVE_SYS_PARAM_H
+ #  include <sys/param.h>
+ #endif
+ 
  #include <stdio.h>
  #include <limits.h>
***************
*** 53,56 ****
--- 61,70 ----
  #include "bashgetopt.h"
  
+ #include "getconf.h"
+ 
+ #ifndef errno
+ extern int errno;
+ #endif
+ 
  struct conf_variable
  {
***************
*** 60,66 ****
  };
  
! /* Some systems do not define these; use POSIX.2 minimum recommended values. */
! #ifndef _POSIX2_COLL_WEIGHTS_MAX
! #  define _POSIX2_COLL_WEIGHTS_MAX 2
  #endif
  
--- 74,87 ----
  };
  
! #ifndef HAVE_CONFSTR
! static size_t confstr __P((int, char *, size_t));
! #endif
! 
! #ifndef HAVE_SYSCONF
! static long sysconf __P((int));
! #endif
! 
! #ifndef HAVE_PATHCONF
! static long pathconf __P((const char *, int));
  #endif
  
***************
*** 85,89 ****
  #endif
  
!   /* Single UNIX Specification version 2 Configurable Variable Values */
  #if defined (_CS_XBS5_ILP32_OFF32_CFLAGS)
    { "XBS5_ILP32_OFF32_CFLAGS",  	CONFSTR,	_CS_XBS5_ILP32_OFF32_CFLAGS },
--- 106,116 ----
  #endif
  
!   /* Single UNIX Specification version 2 Configurable Variable Values.  The
!      SYSCONF variables say whether or not the appropriate CONFSTR variables
!      are available. */
! #if defined (_SC_XBS5_ILP32_OFF32)
!   { "XBS5_ILP32_OFF32",			SYSCONF,	_SC_XBS5_ILP32_OFF32	},
!   { "_XBS5_ILP32_OFF32",		SYSCONF,	_SC_XBS5_ILP32_OFF32	},
! #endif
  #if defined (_CS_XBS5_ILP32_OFF32_CFLAGS)
    { "XBS5_ILP32_OFF32_CFLAGS",  	CONFSTR,	_CS_XBS5_ILP32_OFF32_CFLAGS },
***************
*** 91,107 ****
    { "XBS5_ILP32_OFF32_LIBS",    	CONFSTR,	_CS_XBS5_ILP32_OFF32_LIBS },
    { "XBS5_ILP32_OFF32_LINTFLAGS",       CONFSTR,	_CS_XBS5_ILP32_OFF32_LINTFLAGS },
    { "XBS5_ILP32_OFFBIG_CFLAGS", 	CONFSTR,	_CS_XBS5_ILP32_OFFBIG_CFLAGS },
    { "XBS5_ILP32_OFFBIG_LDFLAGS",	CONFSTR,	_CS_XBS5_ILP32_OFFBIG_LDFLAGS },
    { "XBS5_ILP32_OFFBIG_LIBS",   	CONFSTR,	_CS_XBS5_ILP32_OFFBIG_LIBS },
    { "XBS5_ILP32_OFFBIG_LINTFLAGS",      CONFSTR,	_CS_XBS5_ILP32_OFFBIG_LINTFLAGS },
    { "XBS5_LP64_OFF64_CFLAGS",   	CONFSTR,	_CS_XBS5_LP64_OFF64_CFLAGS },
    { "XBS5_LP64_OFF64_LDFLAGS",  	CONFSTR,	_CS_XBS5_LP64_OFF64_LDFLAGS },
    { "XBS5_LP64_OFF64_LIBS",     	CONFSTR,	_CS_XBS5_LP64_OFF64_LIBS },
    { "XBS5_LP64_OFF64_LINTFLAGS",	CONFSTR,	_CS_XBS5_LP64_OFF64_LINTFLAGS },
    { "XBS5_LPBIG_OFFBIG_CFLAGS", 	CONFSTR,	_CS_XBS5_LPBIG_OFFBIG_CFLAGS },
    { "XBS5_LPBIG_OFFBIG_LDFLAGS",	CONFSTR,	_CS_XBS5_LPBIG_OFFBIG_LDFLAGS },
    { "XBS5_LPBIG_OFFBIG_LIBS",   	CONFSTR,	_CS_XBS5_LPBIG_OFFBIG_LIBS },
    { "XBS5_LPBIG_OFFBIG_LINTFLAGS",      CONFSTR,	_CS_XBS5_LPBIG_OFFBIG_LINTFLAGS },
! #endif /* _CS_XBS5_ILP32_OFF32_CFLAGS */
  
    /* POSIX.2 Utility Limit Minimum Values */
--- 118,193 ----
    { "XBS5_ILP32_OFF32_LIBS",    	CONFSTR,	_CS_XBS5_ILP32_OFF32_LIBS },
    { "XBS5_ILP32_OFF32_LINTFLAGS",       CONFSTR,	_CS_XBS5_ILP32_OFF32_LINTFLAGS },
+ #endif
+ #if defined (_SC_XBS5_ILP32_OFFBIG)
+   { "XBS5_ILP32_OFFBIG",		SYSCONF,	_SC_XBS5_ILP32_OFFBIG	},
+   { "_XBS5_ILP32_OFFBIG",		SYSCONF,	_SC_XBS5_ILP32_OFFBIG	},
+ #endif
+ #if defined (_CS_XBS5_ILP32_OFFBIG_CFLAGS)
    { "XBS5_ILP32_OFFBIG_CFLAGS", 	CONFSTR,	_CS_XBS5_ILP32_OFFBIG_CFLAGS },
    { "XBS5_ILP32_OFFBIG_LDFLAGS",	CONFSTR,	_CS_XBS5_ILP32_OFFBIG_LDFLAGS },
    { "XBS5_ILP32_OFFBIG_LIBS",   	CONFSTR,	_CS_XBS5_ILP32_OFFBIG_LIBS },
    { "XBS5_ILP32_OFFBIG_LINTFLAGS",      CONFSTR,	_CS_XBS5_ILP32_OFFBIG_LINTFLAGS },
+ #endif
+ #if defined (_SC_XBS5_LP64_OFF64)
+   { "XBS5_LP64_OFF64",			SYSCONF,	_SC_XBS5_LP64_OFF64	},
+   { "_XBS5_LP64_OFF64",			SYSCONF,	_SC_XBS5_LP64_OFF64	},
+ #endif
+ #if defined (_CS_XBS5_LP64_OFF64_CFLAGS)
    { "XBS5_LP64_OFF64_CFLAGS",   	CONFSTR,	_CS_XBS5_LP64_OFF64_CFLAGS },
    { "XBS5_LP64_OFF64_LDFLAGS",  	CONFSTR,	_CS_XBS5_LP64_OFF64_LDFLAGS },
    { "XBS5_LP64_OFF64_LIBS",     	CONFSTR,	_CS_XBS5_LP64_OFF64_LIBS },
    { "XBS5_LP64_OFF64_LINTFLAGS",	CONFSTR,	_CS_XBS5_LP64_OFF64_LINTFLAGS },
+ #endif
+ #if defined (_SC_XBS5_LPBIG_OFFBIG)
+   { "XBS5_LPBIG_OFFBIG",		SYSCONF,	_SC_XBS5_LPBIG_OFFBIG	},
+   { "_XBS5_LPBIG_OFFBIG",		SYSCONF,	_SC_XBS5_LPBIG_OFFBIG	},
+ #endif
+ #if defined (_CS_XBS5_LPBIG_OFFBIG_CFLAGS)
    { "XBS5_LPBIG_OFFBIG_CFLAGS", 	CONFSTR,	_CS_XBS5_LPBIG_OFFBIG_CFLAGS },
    { "XBS5_LPBIG_OFFBIG_LDFLAGS",	CONFSTR,	_CS_XBS5_LPBIG_OFFBIG_LDFLAGS },
    { "XBS5_LPBIG_OFFBIG_LIBS",   	CONFSTR,	_CS_XBS5_LPBIG_OFFBIG_LIBS },
    { "XBS5_LPBIG_OFFBIG_LINTFLAGS",      CONFSTR,	_CS_XBS5_LPBIG_OFFBIG_LINTFLAGS },
! #endif
! 
!   /* Single UNIX Specification version 3 (POSIX.1-200x) Configurable Variable
!      Values.  The SYSCONF variables say whether or not the appropriate CONFSTR
!      variables are available. */
! 
! #if defined (_SC_POSIX_V6_ILP32_OFF32)
!   { "_POSIX_V6_ILP32_OFF32",		SYSCONF,	_SC_POSIX_V6_ILP32_OFF32  },
! #endif
! #if defined (_CS_POSIX_V6_ILP32_OFF32_CFLAGS)
!   { "POSIX_V6_ILP32_OFF32_CFLAGS",	CONFSTR,	_CS_POSIX_V6_ILP32_OFF32_CFLAGS },
!   { "POSIX_V6_ILP32_OFF32_LDFLAGS",	CONFSTR,	_CS_POSIX_V6_ILP32_OFF32_LDFLAGS },
!   { "POSIX_V6_ILP32_OFF32_LIBS",	CONFSTR,	_CS_POSIX_V6_ILP32_OFF32_LIBS },
!   { "POSIX_V6_ILP32_OFF32_LINTFLAGS",	CONFSTR,	_CS_POSIX_V6_ILP32_OFF32_LINTFLAGS },
! #endif
! #if defined (_SC_POSIX_V6_ILP32_OFFBIG)
!   { "_POSIX_V6_ILP32_OFFBIG",		SYSCONF,	_SC_POSIX_V6_ILP32_OFFBIG },
! #endif
! #if defined (_CS_POSIX_V6_ILP32_OFFBIG_CFLAGS)
!   { "POSIX_V6_ILP32_OFFBIG_CFLAGS",	CONFSTR,	_CS_POSIX_V6_ILP32_OFFBIG_CFLAGS },
!   { "POSIX_V6_ILP32_OFFBIG_LDFLAGS",	CONFSTR,	_CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS },
!   { "POSIX_V6_ILP32_OFFBIG_LIBS",	CONFSTR,	_CS_POSIX_V6_ILP32_OFFBIG_LIBS },
!   { "POSIX_V6_ILP32_OFFBIG_LINTFLAGS",	CONFSTR,	_CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS },
! #endif
! #if defined (_SC_POSIX_V6_LP64_OFF64)
!   { "_POSIX_V6_LP64_OFF64",		SYSCONF,	_SC_POSIX_V6_LP64_OFF64	  },
! #endif
! #if defined (_CS_POSIX_V6_LP64_OFF64_CFLAGS)
!   { "POSIX_V6_LP64_OFF64_CFLAGS",	CONFSTR,	_CS_POSIX_V6_LP64_OFF64_CFLAGS },
!   { "POSIX_V6_LP64_OFF64_LDFLAGS",	CONFSTR,	_CS_POSIX_V6_LP64_OFF64_LDFLAGS },
!   { "POSIX_V6_LP64_OFF64_LIBS",		CONFSTR,	_CS_POSIX_V6_LP64_OFF64_LIBS },
!   { "POSIX_V6_LP64_OFF64_LINTFLAGS",	CONFSTR,	_CS_POSIX_V6_LP64_OFF64_LINTFLAGS },
! #endif
! #if defined (_SC_POSIX_V6_LPBIG_OFFBIG)
!   { "_POSIX_V6_LPBIG_OFFBIG",	SYSCONF,	_SC_POSIX_V6_LPBIG_OFFBIG },
! #endif
! #if defined (_CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS)
!   { "POSIX_V6_LPBIG_OFFBIG_CFLAGS",	CONFSTR,	_CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS },
!   { "POSIX_V6_LPBIG_OFFBIG_LDFLAGS",	CONFSTR,	_CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS },
!   { "POSIX_V6_LPBIG_OFFBIG_LIBS",	CONFSTR,	_CS_POSIX_V6_LPBIG_OFFBIG_LIBS },
!   { "POSIX_V6_LPBIG_OFFBIG_LINTFLAGS",	CONFSTR,	_CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS },
! #endif
  
    /* POSIX.2 Utility Limit Minimum Values */
***************
*** 158,254 ****
  
    /* POSIX.1 Minimum Values */
    { "_POSIX_ARG_MAX",		CONSTANT,	_POSIX_ARG_MAX		},
    { "_POSIX_CHILD_MAX",		CONSTANT,	_POSIX_CHILD_MAX	},
    { "_POSIX_LINK_MAX",		CONSTANT,	_POSIX_LINK_MAX		},
    { "_POSIX_MAX_CANON",		CONSTANT,	_POSIX_MAX_CANON	},
    { "_POSIX_MAX_INPUT",		CONSTANT,	_POSIX_MAX_INPUT	},
    { "_POSIX_NAME_MAX",		CONSTANT,	_POSIX_NAME_MAX		},
    { "_POSIX_NGROUPS_MAX",	CONSTANT,	_POSIX_NGROUPS_MAX	},
    { "_POSIX_OPEN_MAX",		CONSTANT,	_POSIX_OPEN_MAX		},
!   { "_POSIX_PATH_MAX",		CONSTANT,	_POSIX_PIPE_BUF		},
    { "_POSIX_PIPE_BUF",		CONSTANT,	_POSIX_PIPE_BUF		},
    { "_POSIX_SSIZE_MAX",		CONSTANT,	_POSIX_SSIZE_MAX	},
    { "_POSIX_STREAM_MAX",	CONSTANT,	_POSIX_STREAM_MAX	},
    { "_POSIX_TZNAME_MAX",	CONSTANT,	_POSIX_TZNAME_MAX	},
  
!   /* POSIX.2 Symbolic Utility Limits */
    { "BC_BASE_MAX",		SYSCONF,	_SC_BC_BASE_MAX		},
    { "BC_DIM_MAX",		SYSCONF,	_SC_BC_DIM_MAX		},
    { "BC_SCALE_MAX",		SYSCONF,	_SC_BC_SCALE_MAX	},
    { "BC_STRING_MAX",		SYSCONF,	_SC_BC_STRING_MAX	},
    { "COLL_WEIGHTS_MAX",		SYSCONF,	_SC_COLL_WEIGHTS_MAX	},
    { "EXPR_NEST_MAX",		SYSCONF,	_SC_EXPR_NEST_MAX	},
    { "LINE_MAX",			SYSCONF,	_SC_LINE_MAX		},
    { "RE_DUP_MAX",		SYSCONF,	_SC_RE_DUP_MAX		},
  
    /* POSIX.2 Optional Facility Configuration Values */
  #ifdef _SC_2_C_BIND
!   { "POSIX2_C_BIND",		SYSCONF,	_SC_2_C_BIND		},
  #else
!   { "POSIX2_C_BIND",		G_UNDEF,	-1			},
  #endif
  #ifdef _SC_2_C_DEV
!   { "POSIX2_C_DEV",		SYSCONF,	_SC_2_C_DEV		},
  #else
!   { "POSIX2_C_DEV",		G_UNDEF,	-1			},
  #endif
  #if defined (_SC_2_C_VERSION)
!   { "POSIX2_C_VERSION",		SYSCONF,	_SC_2_C_VERSION		},
  #else
!   { "POSIX2_C_VERSION",		G_UNDEF,	-1			},
  #endif
  #if defined (_SC_2_CHAR_TERM)
!   { "POSIX2_CHAR_TERM",		SYSCONF,	_SC_2_CHAR_TERM		},
  #else
!   { "POSIX2_CHAR_TERM",		G_UNDEF,	-1			},
  #endif
  #ifdef _SC_2_FORT_DEV
!   { "POSIX2_FORT_DEV",		SYSCONF,	_SC_2_FORT_DEV		},
  #else
!   { "POSIX2_FORT_DEV",		G_UNDEF,	-1			},
  #endif
  #ifdef _SC_2_FORT_RUN
!   { "POSIX2_FORT_RUN",		SYSCONF,	_SC_2_FORT_RUN		},
  #else
!   { "POSIX2_FORT_RUN",		G_UNDEF,	-1			},
  #endif
  #ifdef _SC_2_LOCALEDEF
!   { "POSIX2_LOCALEDEF",		SYSCONF,	_SC_2_LOCALEDEF		},
  #else
!   { "POSIX2_LOCALEDEF",		G_UNDEF,	-1			},
  #endif
  #ifdef _SC_2_SW_DEV
!   { "POSIX2_SW_DEV",		SYSCONF,	_SC_2_SW_DEV		},
  #else
!   { "POSIX2_SW_DEV",		G_UNDEF,	-1			},
  #endif
  #if defined (_SC2_UPE)
!   { "POSIX2_UPE",		SYSCONF,	_SC_2_UPE		},
  #else
!   { "POSIX2_UPE",		G_UNDEF,	-1			},
  #endif
  #if !defined (_POSIX2_VERSION) && defined (_SC_2_VERSION)
!   { "POSIX2_VERSION"		SYSCONF,	_SC_2_VERSION		},
  #endif
  
    /* POSIX.1 Configurable System Variables */
    { "ARG_MAX",			SYSCONF,	_SC_ARG_MAX 		},
    { "CHILD_MAX",		SYSCONF,	_SC_CHILD_MAX		},
    { "CLK_TCK",			SYSCONF,	_SC_CLK_TCK		},
    { "NGROUPS_MAX",		SYSCONF,	_SC_NGROUPS_MAX		},
    { "OPEN_MAX",			SYSCONF,	_SC_OPEN_MAX		},
    { "STREAM_MAX",		SYSCONF,	_SC_STREAM_MAX		},
    { "TZNAME_MAX",		SYSCONF,	_SC_TZNAME_MAX		},
!   { "_POSIX_JOB_CONTROL",	SYSCONF,	_SC_JOB_CONTROL 	},
!   { "_POSIX_SAVED_IDS",		SYSCONF,	_SC_SAVED_IDS		},
!   { "_POSIX_VERSION",		SYSCONF,	_SC_VERSION		},
  
    /* POSIX.1 Optional Facility Configuration Values */
  #if defined (_SC_ASYNCHRONOUS_IO)
    { "_POSIX_ASYNCHRONOUS_IO",	SYSCONF,	_SC_ASYNCHRONOUS_IO	},
  #endif
  #if defined (_SC_FSYNC)
    { "_POSIX_FSYNC",		SYSCONF,	_SC_FSYNC		},
  #endif
  #if defined (_SC_MAPPED_FILES)
    { "_POSIX_MAPPED_FILES",	SYSCONF,	_SC_MAPPED_FILES	},
--- 244,515 ----
  
    /* POSIX.1 Minimum Values */
+ #ifdef _POSIX_ARG_MAX
    { "_POSIX_ARG_MAX",		CONSTANT,	_POSIX_ARG_MAX		},
+ #else
+   { "_POSIX_ARG_MAX",		G_UNDEF,	-1			},
+ #endif
+ #ifdef _POSIX_CHILD_MAX
    { "_POSIX_CHILD_MAX",		CONSTANT,	_POSIX_CHILD_MAX	},
+ #else
+   { "_POSIX_CHILD_MAX",		G_UNDEF,	-1		},
+ #endif  
+ #ifdef _POSIX_LINK_MAX
    { "_POSIX_LINK_MAX",		CONSTANT,	_POSIX_LINK_MAX		},
+ #else
+   { "_POSIX_LINK_MAX",		G_UNDEF,	-1			},
+ #endif  
+ #ifdef _POSIX_MAX_CANON
    { "_POSIX_MAX_CANON",		CONSTANT,	_POSIX_MAX_CANON	},
+ #else
+   { "_POSIX_MAX_CANON",		G_UNDEF,	-1			},
+ #endif  
+ #ifdef _POSIX_MAX_INPUT
    { "_POSIX_MAX_INPUT",		CONSTANT,	_POSIX_MAX_INPUT	},
+ #else
+   { "_POSIX_MAX_INPUT",		G_UNDEF,	-1			},
+ #endif  
+ #ifdef _POSIX_NAME_MAX
    { "_POSIX_NAME_MAX",		CONSTANT,	_POSIX_NAME_MAX		},
+ #else
+   { "_POSIX_NAME_MAX",		G_UNDEF,	-1			},
+ #endif  
+ #ifdef _POSIX_NGROUPS_MAX
    { "_POSIX_NGROUPS_MAX",	CONSTANT,	_POSIX_NGROUPS_MAX	},
+ #else
+   { "_POSIX_NGROUPS_MAX",	G_UNDEF,	-1			},
+ #endif  
+ #ifdef _POSIX_OPEN_MAX
    { "_POSIX_OPEN_MAX",		CONSTANT,	_POSIX_OPEN_MAX		},
! #else
!   { "_POSIX_OPEN_MAX",		G_UNDEF,	-1			},
! #endif  
! #ifdef _POSIX_PATH_MAX
!   { "_POSIX_PATH_MAX",		CONSTANT,	_POSIX_PATH_MAX		},
! #else
!   { "_POSIX_PATH_MAX",		G_UNDEF,	-1			},
! #endif  
! #ifdef _POSIX_PIPE_BUF
    { "_POSIX_PIPE_BUF",		CONSTANT,	_POSIX_PIPE_BUF		},
+ #else
+   { "_POSIX_PIPE_BUF",		G_UNDEF,	-1			},
+ #endif  
+ #ifdef _POSIX_SSIZE_MAX
    { "_POSIX_SSIZE_MAX",		CONSTANT,	_POSIX_SSIZE_MAX	},
+ #else
+   { "_POSIX_SSIZE_MAX",		G_UNDEF,	-1			},
+ #endif  
+ #ifdef _POSIX_STREAM_MAX
    { "_POSIX_STREAM_MAX",	CONSTANT,	_POSIX_STREAM_MAX	},
+ #else
+   { "_POSIX_STREAM_MAX",	G_UNDEF,	-1			},
+ #endif  
+ #ifdef _POSIX_TZNAME_MAX
    { "_POSIX_TZNAME_MAX",	CONSTANT,	_POSIX_TZNAME_MAX	},
+ #else
+   { "_POSIX_TZNAME_MAX",	G_UNDEF,	-1	},
+ #endif  
  
!   /* POSIX.2/XPG 4.2 (and later) Symbolic Utility Limits */
! #ifdef _SC_BC_BASE_MAX
    { "BC_BASE_MAX",		SYSCONF,	_SC_BC_BASE_MAX		},
+ #endif
+ #ifdef _SC_BC_DIM_MAX
    { "BC_DIM_MAX",		SYSCONF,	_SC_BC_DIM_MAX		},
+ #endif
+ #ifdef _SC_BC_SCALE_MAX
    { "BC_SCALE_MAX",		SYSCONF,	_SC_BC_SCALE_MAX	},
+ #endif
+ #ifdef _SC_BC_STRING_MAX
    { "BC_STRING_MAX",		SYSCONF,	_SC_BC_STRING_MAX	},
+ #endif
+ #ifdef CHARCLASS_NAME_MAX
+   { "CHARCLASS_NAME_MAX",	CONSTANT,	CHARCLASS_NAME_MAX	},
+ #endif
+ #ifdef _SC_COLL_WEIGHTS_MAX
    { "COLL_WEIGHTS_MAX",		SYSCONF,	_SC_COLL_WEIGHTS_MAX	},
+ #endif
+ #ifdef _SC_EXPR_NEST_MAX
    { "EXPR_NEST_MAX",		SYSCONF,	_SC_EXPR_NEST_MAX	},
+ #endif
+ #ifdef _SC_LINE_MAX
    { "LINE_MAX",			SYSCONF,	_SC_LINE_MAX		},
+ #endif
+ #  ifdef NL_ARGMAX
+   { "NL_ARGMAX",		CONSTANT,	NL_ARGMAX		},
+ #endif
+ #ifdef NL_LANGMAX
+   { "NL_LANGMAX",		CONSTANT,	NL_LANGMAX		},
+ #endif
+ #ifdef NL_MSGMAX
+   { "NL_MSGMAX",		CONSTANT,	NL_MSGMAX		},
+ #endif
+ #ifdef NL_NMAX
+   { "NL_NMAX",			CONSTANT,	NL_NMAX			},
+ #endif
+ #ifdef NL_SETMAX
+   { "NL_SETMAX",		CONSTANT,	NL_SETMAX		},
+ #endif
+ #ifdef NL_TEXTMAX
+   { "NL_TEXTMAX",		CONSTANT,	NL_TEXTMAX		},
+ #endif
+ #ifdef _SC_RE_DUP_MAX
    { "RE_DUP_MAX",		SYSCONF,	_SC_RE_DUP_MAX		},
+ #endif
  
    /* POSIX.2 Optional Facility Configuration Values */
  #ifdef _SC_2_C_BIND
!   { "_POSIX2_C_BIND",		SYSCONF,	_SC_2_C_BIND		},
  #else
!   { "_POSIX2_C_BIND",		G_UNDEF,	-1			},
  #endif
  #ifdef _SC_2_C_DEV
!   { "_POSIX2_C_DEV",		SYSCONF,	_SC_2_C_DEV		},
  #else
!   { "_POSIX2_C_DEV",		G_UNDEF,	-1			},
  #endif
  #if defined (_SC_2_C_VERSION)
!   { "_POSIX2_C_VERSION",		SYSCONF,	_SC_2_C_VERSION		},
  #else
!   { "_POSIX2_C_VERSION",		G_UNDEF,	-1			},
  #endif
  #if defined (_SC_2_CHAR_TERM)
!   { "_POSIX2_CHAR_TERM",		SYSCONF,	_SC_2_CHAR_TERM		},
  #else
!   { "_POSIX2_CHAR_TERM",		G_UNDEF,	-1			},
  #endif
  #ifdef _SC_2_FORT_DEV
!   { "_POSIX2_FORT_DEV",		SYSCONF,	_SC_2_FORT_DEV		},
  #else
!   { "_POSIX2_FORT_DEV",		G_UNDEF,	-1			},
  #endif
  #ifdef _SC_2_FORT_RUN
!   { "_POSIX2_FORT_RUN",		SYSCONF,	_SC_2_FORT_RUN		},
  #else
!   { "_POSIX2_FORT_RUN",		G_UNDEF,	-1			},
  #endif
  #ifdef _SC_2_LOCALEDEF
!   { "_POSIX2_LOCALEDEF",	SYSCONF,	_SC_2_LOCALEDEF		},
  #else
!   { "_POSIX2_LOCALEDEF",	G_UNDEF,	-1			},
  #endif
  #ifdef _SC_2_SW_DEV
!   { "_POSIX2_SW_DEV",		SYSCONF,	_SC_2_SW_DEV		},
  #else
!   { "_POSIX2_SW_DEV",		G_UNDEF,	-1			},
  #endif
  #if defined (_SC2_UPE)
!   { "_POSIX2_UPE",		SYSCONF,	_SC_2_UPE		},
  #else
!   { "_POSIX2_UPE",		G_UNDEF,	-1			},
  #endif
  #if !defined (_POSIX2_VERSION) && defined (_SC_2_VERSION)
!   { "_POSIX2_VERSION",		SYSCONF,	_SC_2_VERSION		},
! #else
!   { "_POSIX2_VERSION",		G_UNDEF,	-1			},
! #endif
! #if defined (_SC_REGEX_VERSION)
!   { "REGEX_VERSION",		SYSCONF,	_SC_REGEX_VERSION	},
! #else
!   { "REGEX_VERSION",		G_UNDEF,	-1			},
! #endif
! 
! #if defined (_SC_2_PBS)
!   { "_POSIX2_PBS",		SYSCONF,	_SC_2_PBS		},
!   { "_POSIX2_PBS_ACCOUNTING",	SYSCONF,	_SC_2_PBS_ACCOUNTING	},
!   { "_POSIX2_PBS_LOCATE",	SYSCONF,	_SC_2_PBS_LOCATE	},
!   { "_POSIX2_PBS_MESSAGE",	SYSCONF,	_SC_2_PBS_MESSAGE	},
!   { "_POSIX2_PBS_TRACK",	SYSCONF,	_SC_2_PBS_TRACK		},
  #endif
  
    /* POSIX.1 Configurable System Variables */
+ #ifdef _SC_ARG_MAX
    { "ARG_MAX",			SYSCONF,	_SC_ARG_MAX 		},
+ #endif
+ #ifdef _SC_CHILD_MAX
    { "CHILD_MAX",		SYSCONF,	_SC_CHILD_MAX		},
+ #endif
+ #ifdef _SC_CLK_TCK
    { "CLK_TCK",			SYSCONF,	_SC_CLK_TCK		},
+ #endif
+ #ifdef _SC_DELAYTIMER_MAX
+   { "DELAYTIMER_MAX",		SYSCONF,	_SC_DELAYTIMER_MAX	},
+ #endif
+ #ifdef _SC_NGROUPS_MAX
    { "NGROUPS_MAX",		SYSCONF,	_SC_NGROUPS_MAX		},
+ #endif
+ #ifdef NZERO
+   { "NZERO",			CONSTANT,	NZERO			},
+ #endif
+ #ifdef _SC_OPEN_MAX
    { "OPEN_MAX",			SYSCONF,	_SC_OPEN_MAX		},
+ #endif
+ #ifdef PASS_MAX
+   { "PASS_MAX",			CONSTANT,	PASS_MAX		},
+ #endif
+ #ifdef _SC_STREAM_MAX
    { "STREAM_MAX",		SYSCONF,	_SC_STREAM_MAX		},
+ #endif
+ #ifdef TMP_MAX
+   { "TMP_MAX",			CONSTANT,	TMP_MAX			},
+ #endif
+ #ifdef _SC_TZNAME_MAX
    { "TZNAME_MAX",		SYSCONF,	_SC_TZNAME_MAX		},
! #endif
  
    /* POSIX.1 Optional Facility Configuration Values */
+ #if defined (_SC_ADVISORY_INFO)
+   { "_POSIX_ADVISORY_INFO",	SYSCONF,	_SC_ADVISORY_INFO	},
+ #endif
  #if defined (_SC_ASYNCHRONOUS_IO)
    { "_POSIX_ASYNCHRONOUS_IO",	SYSCONF,	_SC_ASYNCHRONOUS_IO	},
  #endif
+ #if defined (_SC_BARRIERS)
+   { "_POSIX_BARRIERS",		SYSCONF,	_SC_BARRIERS		},
+ #endif
+ #if defined (_SC_BASE)
+   { "_POSIX_BASE",		SYSCONF,	_SC_BASE		},
+ #endif
+ #if defined (_SC_C_LANG_SUPPORT)
+   { "_POSIX_C_LANG_SUPPORT",	SYSCONF,	_SC_C_LANG_SUPPORT	},
+ #endif
+ #if defined (_SC_C_LANG_SUPPORT_R)
+   { "_POSIX_C_LANG_SUPPORT_R",	SYSCONF,	_SC_C_LANG_SUPPORT_R	},
+ #endif
+ #if defined (_SC_CLOCK_SELECTION)
+   { "_POSIX_CLOCK_SELECTION",	SYSCONF,	_SC_CLOCK_SELECTION	},
+ #endif
+ #if defined (_SC_CPUTIME)
+   { "_POSIX_CPUTIME",		SYSCONF,	_SC_CPUTIME		},
+ #endif
+ #if defined (_SC_DEVICE_IO)
+   { "_POSIX_DEVICE_IO",		SYSCONF,	_SC_DEVICE_IO		},
+ #endif
+ #if defined (_SC_DEVICE_SPECIFIC)
+   { "_POSIX_DEVICE_SPECIFIC",	SYSCONF,	_SC_DEVICE_SPECIFIC	},
+ #endif
+ #if defined (_SC_DEVICE_SPECIFIC_R)
+   { "_POSIX_DEVICE_SPECIFIC_R",	SYSCONF,	_SC_DEVICE_SPECIFIC_R	},
+ #endif
+ #if defined (_SC_FD_MGMT)
+   { "_POSIX_FD_MGMT",		SYSCONF,	_SC_FD_MGMT		},
+ #endif
+ #if defined (_SC_FIFO)
+   { "_POSIX_FIFO",		SYSCONF,	_SC_FIFO		},
+ #endif
+ #if defined (_SC_FILE_ATTRIBUTES)
+   { "_POSIX_FILE_ATTRIBUTES",	SYSCONF,	_SC_FILE_ATTRIBUTES	},
+ #endif
+ #if defined (_SC_FILE_LOCKING)
+   { "_POSIX_FILE_LOCKING",	SYSCONF,	_SC_FILE_LOCKING	},
+ #endif
+ #if defined (_SC_FILE_SYSTEM)
+   { "_POSIX_FILE_SYSTEM",	SYSCONF,	_SC_FILE_SYSTEM		},
+ #endif
  #if defined (_SC_FSYNC)
    { "_POSIX_FSYNC",		SYSCONF,	_SC_FSYNC		},
  #endif
+ #if defined (_SC_JOB_CONTROL)
+   { "_POSIX_JOB_CONTROL",	SYSCONF,	_SC_JOB_CONTROL 	},
+ #endif
  #if defined (_SC_MAPPED_FILES)
    { "_POSIX_MAPPED_FILES",	SYSCONF,	_SC_MAPPED_FILES	},
***************
*** 266,269 ****
--- 527,542 ----
    { "_POSIX_MESSAGE_PASSING",	SYSCONF,	_SC_MESSAGE_PASSING	},
  #endif
+ #if defined (_SC_MONOTONIC_CLOCK)
+   { "_POSIX_MONOTONIC_CLOCK",	SYSCONF,	_SC_MONOTONIC_CLOCK	},
+ #endif
+ #if defined (_SC_MULTI_PROCESS)
+   { "_POSIX_MULTI_PROCESS",	SYSCONF,	_SC_MULTI_PROCESS	},
+ #endif
+ #if defined (_SC_NETWORKING)
+   { "_POSIX_NETWORKING",	SYSCONF,	_SC_NETWORKING		},
+ #endif
+ #if defined (_SC_PIPE)
+   { "_POSIX_PIPE",		SYSCONF,	_SC_PIPE		},
+ #endif
  #if defined (SC_PRIORITIZED_IO)
    { "_POSIX_PRIORITIZED_IO",	SYSCONF,	_SC_PRIORITIZED_IO	},
***************
*** 272,278 ****
--- 545,560 ----
    { "_POSIX_PRIORITY_SCHEDULING", SYSCONF,	_SC_PRIORITY_SCHEDULING	},
  #endif
+ #if defined (_SC_READER_WRITER_LOCKS)
+   { "_POSIX_READER_WRITER_LOCKS", SYSCONF,	_SC_READER_WRITER_LOCKS	},
+ #endif
  #if defined (_SC_REALTIME_SIGNALS)
    { "_POSIX_REALTIME_SIGNALS",	SYSCONF,	_SC_REALTIME_SIGNALS	},
  #endif
+ #if defined (_SC_REGEXP)
+   { "_POSIX_REGEXP",		SYSCONF,	_SC_REGEXP		},
+ #endif
+ #if defined (_SC_SAVED_IDS)
+   { "_POSIX_SAVED_IDS",		SYSCONF,	_SC_SAVED_IDS		},
+ #endif
  #if defined (_SC_SEMAPHORES)
    { "_POSIX_SEMAPHORES",	SYSCONF,	_SC_SEMAPHORES		},
***************
*** 281,294 ****
    { "_POSIX_SHARED_MEMORY_OBJECTS", SYSCONF,	_SC_SHARED_MEMORY_OBJECTS },
  #endif
  #if defined (_SC_SYNCHRONIZED_IO)
    { "_POSIX_SYNCHRONIZED_IO",	SYSCONF,	_SC_SYNCHRONIZED_IO	},
  #endif
! #if defined (_SC_TIMERS)
!   { "_POSIX_TIMERS",		SYSCONF,	_SC_TIMERS		},
  #endif
! #if defined (_SC_THREADS)
!   { "_POSIX_THREADS",		SYSCONF,	_SC_THREADS		},
  #endif
! #if defined (_SC_THREADS)
    { "_POSIX_THREAD_ATTR_STACKADDR", SYSCONF,	_SC_THREAD_ATTR_STACKADDR },
  #endif
--- 563,592 ----
    { "_POSIX_SHARED_MEMORY_OBJECTS", SYSCONF,	_SC_SHARED_MEMORY_OBJECTS },
  #endif
+   { "_POSIX_SHELL",		CONSTANT,	1			},
+ #if defined (_SC_SIGNALS)
+   { "_POSIX_SIGNALS",		SYSCONF,	_SC_SIGNALS		},
+ #endif
+ #if defined (_SC_SINGLE_PROCESS)
+   { "_POSIX_SINGLE_PROCESS",	SYSCONF,	_SC_SINGLE_PROCESS	},
+ #endif
+ #if defined (_SC_SPAWN)
+   { "_POSIX_SPAWN",		SYSCONF,	_SC_SPAWN		},
+ #endif
+ #if defined (_SC_SPIN_LOCKS)
+   { "_POSIX_SPIN_LOCKS",	SYSCONF,	_SC_SPIN_LOCKS		},
+ #endif
+ #if defined (_SC_SPORADIC_SERVER)
+   { "_POSIX_SPORADIC_SERVER",	SYSCONF,	_SC_SPORADIC_SERVER	},
+ #endif
  #if defined (_SC_SYNCHRONIZED_IO)
    { "_POSIX_SYNCHRONIZED_IO",	SYSCONF,	_SC_SYNCHRONIZED_IO	},
  #endif
! #if defined (_SC_SYSTEM_DATABASE)
!   { "_POSIX_SYSTEM_DATABASE",	SYSCONF,	_SC_SYSTEM_DATABASE	},
  #endif
! #if defined (_SC_SYSTEM_DATABASE_R)
!   { "_POSIX_SYSTEM_DATABASE_R",	SYSCONF,	_SC_SYSTEM_DATABASE_R	},
  #endif
! #if defined (_SC_THREAD_ATTR_STACKADDR)
    { "_POSIX_THREAD_ATTR_STACKADDR", SYSCONF,	_SC_THREAD_ATTR_STACKADDR },
  #endif
***************
*** 296,301 ****
    { "_POSIX_THREAD_ATTR_STACKSIZE", SYSCONF,	_SC_THREAD_ATTR_STACKSIZE },
  #endif
! #if defined (_SC_THREAD_PRIORITY_SCHEDULING)
!   { "_POSIX_THREAD_PRIORITY_SCHEDULING", SYSCONF, _SC_THREAD_PRIORITY_SCHEDULING },
  #endif
  #if defined (_SC_THREAD_PRIO_INHERIT)
--- 594,599 ----
    { "_POSIX_THREAD_ATTR_STACKSIZE", SYSCONF,	_SC_THREAD_ATTR_STACKSIZE },
  #endif
! #if defined (_SC_THREAD_CPUTIME)
!   { "_POSIX_THREAD_CPUTIME",	SYSCONF,	_SC_THREAD_CPUTIME },
  #endif
  #if defined (_SC_THREAD_PRIO_INHERIT)
***************
*** 305,308 ****
--- 603,609 ----
    { "_POSIX_THREAD_PRIO_PROTECT", SYSCONF,	_SC_THREAD_PRIO_PROTECT	},
  #endif
+ #if defined (_SC_THREAD_PRIORITY_SCHEDULING)
+   { "_POSIX_THREAD_PRIORITY_SCHEDULING", SYSCONF, _SC_THREAD_PRIORITY_SCHEDULING },
+ #endif
  #if defined (_SC_THREAD_PROCESS_SHARED)
    { "_POSIX_THREAD_PROCESS_SHARED", SYSCONF,	_SC_THREAD_PROCESS_SHARED },
***************
*** 311,314 ****
--- 612,645 ----
    { "_POSIX_THREAD_SAFE_FUNCTIONS", SYSCONF,	_SC_THREAD_SAFE_FUNCTIONS },
  #endif
+ #if defined (_SC_THREAD_SPORADIC_SERVER)
+   { "_POSIX_THREAD_SPORADIC_SERVER", SYSCONF,	_SC_THREAD_SPORADIC_SERVER },
+ #endif
+ #if defined (_SC_THREADS)
+   { "_POSIX_THREADS",		SYSCONF,	_SC_THREADS		},
+ #endif
+ #if defined (_SC_TIMEOUTS)
+   { "_POSIX_TIMEOUTS",		SYSCONF,	_SC_TIMEOUTS		},
+ #endif
+ #if defined (_SC_TIMERS)
+   { "_POSIX_TIMERS",		SYSCONF,	_SC_TIMERS		},
+ #endif
+ #if defined (_SC_TRACE)
+   { "_POSIX_TRACE",		SYSCONF,	_SC_TRACE		},
+ #endif
+ #if defined (_SC_TRACE)
+   { "_POSIX_TRACE_EVENT_FILTER",SYSCONF,	_SC_TRACE_EVENT_FILTER	},
+ #endif
+ #if defined (_SC_TRACE)
+   { "_POSIX_TRACE_INHERIT",	SYSCONF,	_SC_TRACE_INHERIT	},
+ #endif
+ #if defined (_SC_TRACE)
+   { "_POSIX_TRACE_LOG",		SYSCONF,	_SC_TRACE_LOG		},
+ #endif
+ #if defined (_SC_TYPED_MEMORY_OBJECTS)
+   { "_POSIX_TYPED_MEMORY_OBJECTS", SYSCONF,	_SC_TYPED_MEMORY_OBJECTS },
+ #endif
+ #if defined (_SC_VERSION)
+   { "_POSIX_VERSION",		SYSCONF,	_SC_VERSION		},
+ #endif
  
    /* XPG 4.2 Configurable System Variables. */
***************
*** 316,322 ****
--- 647,668 ----
    { "ATEXIT_MAX",		SYSCONF,	_SC_ATEXIT_MAX		},
  #endif
+ #if defined (_SC_GETGR_R_SIZE_MAX)
+   { "GETGR_R_SIZE_MAX",		SYSCONF,	_SC_GETGR_R_SIZE_MAX	},
+ #endif
+ #if defined (_SC_GETPW_R_SIZE_MAX)
+   { "GETPW_R_SIZE_MAX",		SYSCONF,	_SC_GETPW_R_SIZE_MAX	},
+ #endif
+ #if defined (_SC_HOST_NAME_MAX)
+   { "HOST_NAME_MAX",		SYSCONF,	_SC_HOST_NAME_MAX	},
+ #endif
  #if defined (_SC_IOV_MAX)
    { "IOV_MAX",			SYSCONF,	_SC_IOV_MAX		},
  #endif
+ #if defined (_SC_LOGIN_NAME_MAX)
+   { "LOGIN_NAME_MAX",		SYSCONF,	_SC_LOGIN_NAME_MAX	},
+ #endif
+ #if defined (_SC_LOGNAME_MAX)
+   { "LOGNAME_MAX",		SYSCONF,	_SC_LOGNAME_MAX		},
+ #endif
  #if defined (_SC_PAGESIZE)
    { "PAGESIZE",			SYSCONF,	_SC_PAGESIZE		},
***************
*** 325,328 ****
--- 671,686 ----
    { "PAGE_SIZE",		SYSCONF,	_SC_PAGE_SIZE		},
  #endif
+ #if defined (_SC_SYMLOOP_MAX)
+   { "SYMLOOP_MAX",		SYSCONF,	_SC_SYMLOOP_MAX		},
+ #endif
+ #if defined (_SC_TTY_NAME_MAX)
+   { "TTY_NAME_MAX",		SYSCONF,	_SC_TTY_NAME_MAX	},
+ #endif
+ #if defined (_SC_USER_GROUPS)
+   { "_POSIX_USER_GROUPS",	SYSCONF,	_SC_USER_GROUPS		},
+ #endif
+ #if defined (_SC_USER_GROUPS_R)
+   { "_POSIX_USER_GROUPS_R",	SYSCONF,	_SC_USER_GROUPS_R	},
+ #endif
  
  #if defined (_SC_AIO_LISTIO_MAX)
***************
*** 338,347 ****
    { "DELAYTIMER_MAX",		SYSCONF,	_SC_DELAYTIMER_MAX	},
  #endif
- #if defined (_SC_GETGR_R_SIZE_MAX)
-   { "GETGR_R_SIZE_MAX",		SYSCONF,	_SC_GETGR_R_SIZE_MAX	},
- #endif
- #if defined (_SC_GETPW_R_SIZE_MAX)
-   { "GETPW_R_SIZE_MAX",		SYSCONF,	_SC_GETPW_R_SIZE_MAX	},
- #endif
  #if defined (_SC_MQ_OPEN_MAX)
    { "MQ_OPEN_MAX",		SYSCONF,	_SC_MQ_OPEN_MAX		},
--- 696,699 ----
***************
*** 366,379 ****
  #endif
  
- #if defined (_SC_LOGIN_NAME_MAX)
-   { "LOGIN_NAME_MAX",		SYSCONF,	_SC_LOGIN_NAME_MAX	},
- #endif
- #if defined (_SC_LOGNAME_MAX)
-   { "LOGNAME_MAX",		SYSCONF,	_SC_LOGNAME_MAX		},
- #endif
- #if defined (_SC_TTY_NAME_MAX)
-   { "TTY_NAME_MAX",		SYSCONF,	_SC_TTY_NAME_MAX	},
- #endif
- 
  #if defined (_SC_THREAD_DESTRUCTOR_ITERATIONS)
    { "PTHREAD_DESTRUCTOR_ITERATIONS", SYSCONF,	_SC_THREAD_DESTRUCTOR_ITERATIONS },
--- 718,721 ----
***************
*** 389,429 ****
  #endif
  
!   /* XPG 4.2 Optional Facility Configuration Values */
! #if defined (_SC_XOPEN_UNIX)
!   { "_XOPEN_UNIX",		SYSCONF,	_SC_XOPEN_UNIX		},
    { "_XOPEN_CRYPT",		SYSCONF,	_SC_XOPEN_CRYPT		},
    { "_XOPEN_ENH_I18N",		SYSCONF,	_SC_XOPEN_ENH_I18N	},
-   { "_XOPEN_SHM",		SYSCONF,	_SC_XOPEN_SHM		},
-   { "_XOPEN_VERSION",		SYSCONF,	_SC_XOPEN_VERSION	},
- #  if defined (_SC_XOPEN_XCU_VERSION)
-   { "_XOPEN_XCU_VERSION",	SYSCONF,	_SC_XOPEN_XCU_VERSION	},
- #  endif
  #endif
  #if defined (_SC_XOPEN_REALTIME)
    { "_XOPEN_REALTIME",		SYSCONF,	_SC_XOPEN_REALTIME	},
    { "_XOPEN_REALTIME_THREADS",	SYSCONF,	_SC_XOPEN_REALTIME_THREADS },
  #endif
! #if defined (_SC_XOPEN_LEGACY)
!   { "_XOPEN_LEGACY",		SYSCONF,	_SC_XOPEN_LEGACY	},
! #endif /* _SC_XOPEN_LEGACY */
! 
!   /* Single UNIX Specification version 2 Optional Facility Configuration Values */
! #if defined (_SC_XBS5_ILP32_OFF32)
!   { "_XBS5_ILP32_OFF32",	SYSCONF,	_SC_XBS5_ILP32_OFF32	},
!   { "_XBS5_ILP32_OFFBIG",	SYSCONF,	_SC_XBS5_ILP32_OFFBIG	},
!   { "_XBS5_LP64_OFF64",		SYSCONF,	_SC_XBS5_LP64_OFF64	},
!   { "_XBS5_LPBIG_OFFBIG",	SYSCONF,	_SC_XBS5_LPBIG_OFFBIG	},
! #endif /* _SC_XBS5_ILP32_OFF32 */
  
    /* POSIX.1 Configurable Pathname Values */
    { "LINK_MAX",			PATHCONF,	_PC_LINK_MAX		},
    { "MAX_CANON",		PATHCONF,	_PC_MAX_CANON		},
    { "MAX_INPUT",		PATHCONF,	_PC_MAX_INPUT		},
    { "NAME_MAX",			PATHCONF,	_PC_NAME_MAX		},
    { "PATH_MAX",			PATHCONF,	_PC_PATH_MAX		},
    { "PIPE_BUF",			PATHCONF,	_PC_PIPE_BUF		},
    { "_POSIX_CHOWN_RESTRICTED",	PATHCONF,	_PC_CHOWN_RESTRICTED	},
    { "_POSIX_NO_TRUNC",		PATHCONF,	_PC_NO_TRUNC		},
    { "_POSIX_VDISABLE",		PATHCONF,	_PC_VDISABLE		},
  
    /* XPG 4.2 Configurable Pathname Values */
--- 731,806 ----
  #endif
  
!   /* XPG 4.2 (and later) Optional Facility Configuration Values */
! #if defined (_SC_XOPEN_CRYPT)
    { "_XOPEN_CRYPT",		SYSCONF,	_SC_XOPEN_CRYPT		},
+ #endif
+ #if defined (_SC_XOPEN_ENH_I18N)
    { "_XOPEN_ENH_I18N",		SYSCONF,	_SC_XOPEN_ENH_I18N	},
  #endif
+ #if defined (_SC_XOPEN_LEGACY)
+   { "_XOPEN_LEGACY",		SYSCONF,	_SC_XOPEN_LEGACY	},
+ #endif /* _SC_XOPEN_LEGACY */
  #if defined (_SC_XOPEN_REALTIME)
    { "_XOPEN_REALTIME",		SYSCONF,	_SC_XOPEN_REALTIME	},
+ #endif
+ #if defined (_SC_XOPEN_REALTIME_THREADS)
    { "_XOPEN_REALTIME_THREADS",	SYSCONF,	_SC_XOPEN_REALTIME_THREADS },
  #endif
! #if defined (_SC_XOPEN_SHM)
!   { "_XOPEN_SHM",		SYSCONF,	_SC_XOPEN_SHM		},
! #endif
! #if defined (_SC_XOPEN_UNIX)
!   { "_XOPEN_UNIX",		SYSCONF,	_SC_XOPEN_UNIX		},
! #endif
! #if defined (_SC_XOPEN_VERSION)
!   { "_XOPEN_VERSION",		SYSCONF,	_SC_XOPEN_VERSION	},
! #endif
! #if defined (_SC_XOPEN_XCU_VERSION)
!   { "_XOPEN_XCU_VERSION",	SYSCONF,	_SC_XOPEN_XCU_VERSION	},
! #endif
! #if defined (_SC_XOPEN_XPG2)
!   { "_XOPEN_XPG2",		SYSCONF,	_SC_XOPEN_XPG2		},
! #endif
! #if defined (_SC_XOPEN_XPG3)
!   { "_XOPEN_XPG3",		SYSCONF,	_SC_XOPEN_XPG3		},
! #endif
! #if defined (_SC_XOPEN_XPG4)
!   { "_XOPEN_XPG4",		SYSCONF,	_SC_XOPEN_XPG4		},
! #endif
! #if defined (_SC_XOPEN_XPG5)
!   { "_XOPEN_XPG5",		SYSCONF,	_SC_XOPEN_XPG5		},
! #endif
  
    /* POSIX.1 Configurable Pathname Values */
+ #ifdef _PC_LINK_MAX
    { "LINK_MAX",			PATHCONF,	_PC_LINK_MAX		},
+ #endif
+ #ifdef _PC_MAX_CANON
    { "MAX_CANON",		PATHCONF,	_PC_MAX_CANON		},
+ #endif
+ #ifdef _PC_MAX_INPUT
    { "MAX_INPUT",		PATHCONF,	_PC_MAX_INPUT		},
+ #endif
+ #ifdef _PC_NAMW_MAX
    { "NAME_MAX",			PATHCONF,	_PC_NAME_MAX		},
+ #endif
+ #ifdef _PC_PATH_MAX
    { "PATH_MAX",			PATHCONF,	_PC_PATH_MAX		},
+ #endif
+ #ifdef _PC_PIPE_BUF
    { "PIPE_BUF",			PATHCONF,	_PC_PIPE_BUF		},
+ #endif
+ #ifdef _PC_SYMLINK_MAX
+   { "SYMLINK_MAX",		PATHCONF,	_PC_SYMLINK_MAX		},
+ #endif
+ #ifdef _PC_CHOWN_RESTRICTED
    { "_POSIX_CHOWN_RESTRICTED",	PATHCONF,	_PC_CHOWN_RESTRICTED	},
+ #endif
+ #ifdef _PC_NO_TRUNC
    { "_POSIX_NO_TRUNC",		PATHCONF,	_PC_NO_TRUNC		},
+ #endif
+ #ifdef _PC_VDISABLE
    { "_POSIX_VDISABLE",		PATHCONF,	_PC_VDISABLE		},
+ #endif
  
    /* XPG 4.2 Configurable Pathname Values */
***************
*** 441,444 ****
--- 818,855 ----
  #endif
  
+   /* POSIX.1-200x configurable pathname values */
+ #if defined (_PC_ALLOC_SIZE_MIN)
+   { "POSIX_ALLOC_SIZE_MIN",	PATHCONF,	_PC_ALLOC_SIZE_MIN },
+   { "POSIX_REC_INCR_XFER_SIZE",	PATHCONF,	_PC_REC_INCR_XFER_SIZE },
+   { "POSIX_REC_MAX_XFER_SIZE",	PATHCONF,	_PC_REC_MAX_XFER_SIZE },
+   { "POSIX_REC_MIN_XFER_SIZE",	PATHCONF,	_PC_REC_MIN_XFER_SIZE },
+   { "POSIX_REC_XFER_ALIGN",	PATHCONF,	_PC_REC_XFER_ALIGN },
+ #endif
+ 
+   /* ANSI/ISO C, POSIX.1-200x, XPG 4.2 (and later) C language type limits. */
+   { "CHAR_BIT",			CONSTANT,	CHAR_BIT	},
+   { "CHAR_MAX",			CONSTANT,	CHAR_MAX	},
+   { "CHAR_MIN",			CONSTANT,	CHAR_MIN	},
+   { "INT_BIT",			CONSTANT,	INT_BIT		},
+   { "INT_MAX",			CONSTANT,	INT_MAX		},
+   { "INT_MIN",			CONSTANT,	INT_MIN		},
+   { "LONG_BIT",			CONSTANT,	LONG_BIT	},
+   { "LONG_MAX",			CONSTANT,	LONG_MAX	},
+   { "LONG_MIN",			CONSTANT,	LONG_MIN	},
+ #ifdef MB_LEN_MAX
+   { "MB_LEN_MAX",		CONSTANT,	MB_LEN_MAX	},
+ #endif
+   { "SCHAR_MAX",		CONSTANT,	SCHAR_MAX	},
+   { "SCHAR_MIN",		CONSTANT,	SCHAR_MIN	},
+   { "SHRT_MAX",			CONSTANT,	SHRT_MAX	},
+   { "SHRT_MIN",			CONSTANT,	SHRT_MIN	},
+   { "SIZE_MAX",			CONSTANT,	SIZE_MAX	},
+   { "SSIZE_MAX",		CONSTANT,	SSIZE_MAX	},
+   { "UCHAR_MAX",		CONSTANT,	UCHAR_MAX	},
+   { "UINT_MAX",			CONSTANT,	UINT_MAX	},
+   { "ULONG_MAX",		CONSTANT,	ULONG_MAX	},
+   { "USHRT_MAX",		CONSTANT,	USHRT_MAX	},
+   { "WORD_BIT",			CONSTANT,	WORD_BIT	},
+ 
    { NULL }
  };
***************
*** 464,468 ****
    aflag = 0;
    reset_internal_getopt();
!   while ((opt = internal_getopt (list, "ah")) != -1) {
    	switch (opt) {
    	case 'a':
--- 875,879 ----
    aflag = 0;
    reset_internal_getopt();
!   while ((opt = internal_getopt (list, "ahv:")) != -1) {
    	switch (opt) {
    	case 'a':
***************
*** 472,475 ****
--- 883,888 ----
    		getconf_help();
    		return(EXECUTION_SUCCESS);
+   	case 'v':
+   		break;		/* ignored */
    	default:
    		builtin_usage();
***************
*** 521,525 ****
  
  	case CONSTANT:
! 		printf("%ld\n", cp->value);
  		break;
  
--- 934,954 ----
  
  	case CONSTANT:
! 		switch (cp->value) {
! 			case UCHAR_MAX:
! 			case USHRT_MAX:
! 			case UINT_MAX:
! #if (ULONG_MAX != UINT_MAX)			
! 			case ULONG_MAX:
! #endif
! #if (SIZE_MAX != UINT_MAX) && (SIZE_MAX != ULONG_MAX)
! 			case SIZE_MAX:
! #endif
! 
! 				printf("%lu\n", cp->value);
! 				break;
! 			default:
! 				printf("%ld\n", cp->value);
! 				break;
! 		}
  		break;
  
***************
*** 579,584 ****
  	}
  
! 	return ((ferror(stdout) || cp->type == G_UNDEF) ? EXECUTION_FAILURE
! 							: EXECUTION_SUCCESS);
  }
  
--- 1008,1012 ----
  	}
  
! 	return (ferror(stdout) ? EXECUTION_FAILURE : EXECUTION_SUCCESS);
  }
  
***************
*** 592,596 ****
  	for (cp = conf_table; cp->name != NULL; cp++) {
  		printf("%-35s", cp->name);
! 		if (getconf_print(cp, ".", 1) == EXECUTION_FAILURE)
  			ret = EXECUTION_FAILURE;
  	}
--- 1020,1024 ----
  	for (cp = conf_table; cp->name != NULL; cp++) {
  		printf("%-35s", cp->name);
! 		if (getconf_print(cp, "/", 1) == EXECUTION_FAILURE)
  			ret = EXECUTION_FAILURE;
  	}
***************
*** 644,648 ****
  	BUILTIN_ENABLED,
  	getconf_doc,
! 	"getconf -a or getconf -h or getconf sysvar or getconf pathvar pathname",
  	0
  };
--- 1072,1206 ----
  	BUILTIN_ENABLED,
  	getconf_doc,
! 	"getconf -[ah] or getconf [-v spec] sysvar or getconf [-v spec] pathvar pathname",
  	0
  };
+ 
+ #ifndef HAVE_CONFSTR
+ static size_t
+ confstr (name, buf, len)
+      int name;
+      char *buf;
+      size_t len;
+ {
+   switch (name)
+     {
+     case _CS_PATH:
+       if (len > 0 && buf)
+ 	{
+           strncpy (buf, STANDARD_UTILS_PATH, len - 1);
+           buf[len - 1] = '\0';
+ 	}
+       return (sizeof (STANDARD_UTILS_PATH) + 1);
+     default:
+       errno = EINVAL;
+       return 0;
+     }
+ }
+ #endif
+ 
+ #ifndef HAVE_SYSCONF
+ extern long get_clk_tck __P((void));
+ 
+ static long
+ sysconf (name)
+      int name;
+ {
+ #  if defined (_POSIX_VERSION)
+   switch (name)
+     {
+     case _SC_ARG_MAX:
+       return _POSIX_ARG_MAX;
+     case _SC_CHILD_MAX:
+       return _POSIX_CHILD_MAX;
+     case _SC_CLK_TCK:
+       return get_clk_tck();
+     case _SC_NGROUPS_MAX:
+       return _POSIX_NGROUPS_MAX;
+     case _SC_OPEN_MAX:
+       return _POSIX_OPEN_MAX;
+     case _SC_JOB_CONTROL:
+       return _POSIX_JOB_CONTROL;
+     case _SC_SAVED_IDS:
+       return _POSIX_SAVED_IDS;
+     case _SC_VERSION:
+       return _POSIX_VERSION;
+     case _SC_BC_BASE_MAX:
+       return _POSIX2_BC_BASE_MAX;
+     case _SC_BC_DIM_MAX:
+       return _POSIX2_BC_DIM_MAX;
+     case _SC_BC_SCALE_MAX:
+       return  _POSIX2_BC_SCALE_MAX;
+     case _SC_BC_STRING_MAX:
+       return _POSIX2_BC_STRING_MAX;
+     case _SC_COLL_WEIGHTS_MAX:
+       return  -1;
+     case _SC_EXPR_NEST_MAX:
+       return _POSIX2_EXPR_NEST_MAX;
+     case _SC_LINE_MAX:
+       return _POSIX2_LINE_MAX;
+     case _SC_RE_DUP_MAX:
+       return _POSIX2_RE_DUP_MAX;
+     case _SC_STREAM_MAX:
+       return _POSIX_STREAM_MAX;
+     case _SC_TZNAME_MAX:
+       return _POSIX_TZNAME_MAX;
+     default:
+       errno = EINVAL;
+       return -1;
+     }
+ #else
+   errno = EINVAL;
+   return -1;
+ #endif
+ }
+ #endif
+ 
+ #ifndef HAVE_PATHCONF
+ static long
+ pathconf (path, name)
+      const char *path;
+      int name;
+ {
+ #if defined (_POSIX_VERSION)
+   switch (name)
+     {
+     case _PC_LINK_MAX:
+       return _POSIX_LINK_MAX;
+     case _PC_MAX_CANON:
+       return _POSIX_MAX_CANON;
+     case _PC_MAX_INPUT:
+       return _POSIX_MAX_INPUT;
+     case _PC_NAME_MAX:
+       return _POSIX_NAME_MAX;
+     case _PC_PATH_MAX:
+       return _POSIX_PATH_MAX;
+     case _PC_PIPE_BUF:
+       return _POSIX_PIPE_BUF;
+     case _PC_CHOWN_RESTRICTED:
+ #ifdef _POSIX_CHOWN_RESTRICTED
+       return _POSIX_CHOWN_RESTRICTED;
+ #else
+       return -1;
+ #endif
+     case _PC_NO_TRUNC:
+ #ifdef _POSIX_NO_TRUNC
+       return _POSIX_NO_TRUNC;
+ #else
+       return -1;
+ #endif
+     case _PC_VDISABLE:
+ #ifdef _POSIX_VDISABLE
+       return _POSIX_VDISABLE;
+ #else
+       return -1;
+ #endif
+     default:
+       errno = EINVAL;
+       return -1;
+     }
+ #else
+   errno = EINVAL;
+   return -1;
+ #endif
+ }
+ #endif
diff -Nrc2 bash-2.05/examples/loadables/getconf.h bash-2.05a/examples/loadables/getconf.h
*** bash-2.05/examples/loadables/getconf.h	Wed Dec 31 19:00:00 1969
--- bash-2.05a/examples/loadables/getconf.h	Thu May 24 15:03:59 2001
***************
*** 0 ****
--- 1,214 ----
+ /* getconf.h -- replacement definitions for ones the system doesn't provide. */
+ 
+ #ifndef _GETCONF_H
+ #define _GETCONF_H
+ 
+ /* Some systems do not define these; use POSIX.2 minimum recommended values. */
+ #ifndef _POSIX2_COLL_WEIGHTS_MAX
+ #  define _POSIX2_COLL_WEIGHTS_MAX 2
+ #endif
+ 
+ /* If we're on a posix system, but the system doesn't define the necessary
+    constants, use posix.1 minimum values. */
+ #if defined (_POSIX_VERSION)
+ 
+ #ifndef _POSIX_ARG_MAX
+ #  define _POSIX_ARG_MAX	4096
+ #endif
+ #ifndef _POSIX_CHILD_MAX
+ #  define _POSIX_CHILD_MAX	6
+ #endif
+ #ifndef _POSIX_LINK_MAX
+ #  define _POSIX_LINK_MAX	8
+ #endif
+ #ifndef _POSIX_MAX_CANON
+ #  define _POSIX_MAX_CANON	255
+ #endif
+ #ifndef _POSIX_MAX_INPUT
+ #  define _POSIX_MAX_INPUT	255
+ #endif
+ #ifndef _POSIX_NAME_MAX
+ #  define _POSIX_NAME_MAX	14
+ #endif
+ #ifndef _POSIX_NGROUPS_MAX
+ #  define _POSIX_NGROUPS_MAX	0
+ #endif
+ #ifndef _POSIX_OPEN_MAX
+ #  define _POSIX_OPEN_MAX	16
+ #endif
+ #ifndef _POSIX_PATH_MAX
+ #  define _POSIX_PATH_MAX	255
+ #endif
+ #ifndef _POSIX_PIPE_BUF
+ #  define _POSIX_PIPE_BUF	512
+ #endif
+ #ifndef _POSIX_SSIZE_MAX
+ #  define _POSIX_SSIZE_MAX	32767
+ #endif
+ #ifndef _POSIX_STREAM_MAX
+ #  define _POSIX_STREAM_MAX	8
+ #endif
+ #ifndef _POSIX_TZNAME_MAX
+ #  define _POSIX_TZNAME_MAX	3
+ #endif
+ 
+ #ifndef _POSIX2_BC_BASE_MAX
+ #  define _POSIX2_BC_BASE_MAX     99
+ #endif
+ #ifndef _POSIX2_BC_DIM_MAX
+ #  define _POSIX2_BC_DIM_MAX      2048
+ #endif
+ #ifndef _POSIX2_BC_SCALE_MAX
+ #  define _POSIX2_BC_SCALE_MAX    99
+ #endif
+ #ifndef _POSIX2_BC_STRING_MAX
+ #  define _POSIX2_BC_STRING_MAX   1000
+ #endif
+ #ifndef _POSIX2_EQUIV_CLASS_MAX
+ #  define _POSIX2_EQUIV_CLASS_MAX 2
+ #endif
+ #ifndef _POSIX2_EXPR_NEST_MAX
+ #  define _POSIX2_EXPR_NEST_MAX   32
+ #endif
+ #ifndef _POSIX2_LINE_MAX
+ #  define _POSIX2_LINE_MAX        2048
+ #endif
+ #ifndef _POSIX2_RE_DUP_MAX
+ #  define _POSIX2_RE_DUP_MAX      255
+ #endif
+ 
+ /* configurable system variables */
+ #if !defined (HAVE_SYSCONF)
+ 
+ #ifndef _SC_ARG_MAX
+ #  define _SC_ARG_MAX              1
+ #  define _SC_CHILD_MAX            2
+ #  define _SC_CLK_TCK              3
+ #  define _SC_NGROUPS_MAX          4
+ #  define _SC_OPEN_MAX             5
+ #  define _SC_JOB_CONTROL          6
+ #  define _SC_SAVED_IDS            7
+ #  define _SC_VERSION              8
+ #  define _SC_BC_BASE_MAX          9
+ #  define _SC_BC_DIM_MAX          10
+ #  define _SC_BC_SCALE_MAX        11
+ #  define _SC_BC_STRING_MAX       12
+ #  define _SC_COLL_WEIGHTS_MAX    13
+ #  define _SC_EXPR_NEST_MAX       14
+ #  define _SC_LINE_MAX            15
+ #  define _SC_RE_DUP_MAX          16
+ #if 0
+ #  define _SC_2_VERSION           17
+ #  define _SC_2_C_BIND            18
+ #  define _SC_2_C_DEV             19
+ #  define _SC_2_CHAR_TERM         20
+ #  define _SC_2_FORT_DEV          21
+ #  define _SC_2_FORT_RUN          22
+ #  define _SC_2_LOCALEDEF         23
+ #  define _SC_2_SW_DEV            24
+ #  define _SC_2_UPE               25
+ #endif /* 0 */
+ 
+ #  define _SC_STREAM_MAX          26
+ #  define _SC_TZNAME_MAX          27
+ #endif /* !_SC_ARG_MAX */
+ 
+ #endif /* !HAVE_SYSCONF */
+ 
+ /* configurable pathname variables */
+ #if !defined (HAVE_PATHCONF)
+ 
+ #ifndef _PC_LINK_MAX
+ #define _PC_LINK_MAX             1
+ #define _PC_MAX_CANON            2
+ #define _PC_MAX_INPUT            3
+ #define _PC_NAME_MAX             4
+ #define _PC_PATH_MAX             5
+ #define _PC_PIPE_BUF             6
+ #define _PC_CHOWN_RESTRICTED     7
+ #define _PC_NO_TRUNC             8
+ #define _PC_VDISABLE             9
+ #endif /* !_PC_LINK_MAX */
+ 
+ #endif /* !HAVE_PATHCONF */
+ 
+ #endif /* _POSIX_VERSION */
+ 
+ #ifndef _CS_PATH
+ #  define _CS_PATH	1
+ #endif
+ 
+ /* ANSI/ISO C, POSIX.1-200x, XPG 4.2 (and later) C language type limits.
+    Defined only if the system include files don't.  Assume a 32-bit
+    environment with signed 8-bit characters. */
+ 
+ #ifndef CHAR_BIT
+ #  define CHAR_BIT	8
+ #endif
+ #ifndef CHAR_MAX
+ #  define CHAR_MAX	127
+ #endif
+ #ifndef CHAR_MIN
+ #  define CHAR_MIN	-128
+ #endif
+ 
+ #ifndef INT_BIT
+ #  define INT_BIT	(sizeof (int) * CHAR_BIT)
+ #endif
+ #ifndef INT_MAX
+ #  define INT_MAX	2147483647
+ #endif
+ #ifndef INT_MIN
+ #  define INT_MIN	(-2147483647-1)
+ #endif
+ 
+ #ifndef LONG_BIT
+ #  define LONG_BIT	(sizeof (long int) * CHAR_BIT)
+ #endif
+ #ifndef LONG_MAX
+ #  define LONG_MAX	2147483647L
+ #endif
+ #ifndef LONG_MIN
+ #  define LONG_MIN	(-2147483647L-1L)
+ #endif
+ 
+ #ifndef SCHAR_MAX
+ #  define SCHAR_MAX	CHAR_MAX
+ #endif
+ #ifndef SCHAR_MIN
+ #  define SCHAR_MIN	CHAR_MIN
+ #endif
+ 
+ #ifndef SHRT_MAX
+ #  define SHRT_MAX	32767
+ #endif
+ #ifndef SHRT_MIN
+ #  define SHRT_MIN	(-32768)
+ #endif
+ 
+ #ifndef UCHAR_MAX
+ #  define UCHAR_MAX	255
+ #endif
+ #ifndef UINT_MAX
+ #  define UINT_MAX	4294967295U
+ #endif
+ #ifndef ULONG_MAX
+ #  define ULONG_MAX	4294967295UL
+ #endif
+ #ifndef USHRT_MAX
+ #  define UCHAR_MAX	65535
+ #endif
+ 
+ /* assume size_t is `unsigned int'; ssize_t is `int' */
+ #ifndef SIZE_MAX
+ #  define SIZE_MAX	UINT_MAX
+ #endif
+ #ifndef SSIZE_MAX
+ #  define SSIZE_MAX	INT_MAX
+ #endif
+ 
+ #ifndef WORD_BIT
+ #  define WORD_BIT	(sizeof (int) * CHAR_BIT)
+ #endif
+ 
+ #endif /* _GETCONF_H */
diff -Nrc2 bash-2.05/examples/loadables/head.c bash-2.05a/examples/loadables/head.c
*** bash-2.05/examples/loadables/head.c	Tue May 14 14:20:47 1996
--- bash-2.05a/examples/loadables/head.c	Wed Sep 12 11:49:04 2001
***************
*** 17,21 ****
  #include <stdio.h>
  #include <errno.h>
! #include <ctype.h>
  
  #include "builtins.h"
--- 17,21 ----
  #include <stdio.h>
  #include <errno.h>
! #include "chartypes.h"
  
  #include "builtins.h"
***************
*** 38,42 ****
      {
        arg = l->word->word;
!       if (arg[0] != '-' || arg[1] == '-' || (isdigit(arg[1]) == 0))
          return;
        /* We have -[0-9]* */
--- 38,42 ----
      {
        arg = l->word->word;
!       if (arg[0] != '-' || arg[1] == '-' || (DIGIT(arg[1]) == 0))
          return;
        /* We have -[0-9]* */
diff -Nrc2 bash-2.05/examples/loadables/hello.c bash-2.05a/examples/loadables/hello.c
*** bash-2.05/examples/loadables/hello.c	Fri Nov 20 14:05:07 1998
--- bash-2.05a/examples/loadables/hello.c	Tue Aug 28 13:30:09 2001
***************
*** 32,35 ****
--- 32,36 ----
     A builtin command returns EXECUTION_SUCCESS for success and
     EXECUTION_FAILURE to indicate failure. */
+ int
  hello_builtin (list)
       WORD_LIST *list;
diff -Nrc2 bash-2.05/examples/loadables/ln.c bash-2.05a/examples/loadables/ln.c
*** bash-2.05/examples/loadables/ln.c	Fri Nov 13 13:10:04 1998
--- bash-2.05a/examples/loadables/ln.c	Tue Aug 28 13:26:52 2001
***************
*** 24,31 ****
  #endif
  
  #define LN_SYMLINK 0x01
  #define LN_UNLINK  0x02
  
! static Function *linkfn;
  static int dolink ();
  
--- 24,33 ----
  #endif
  
+ typedef int unix_link_syscall_t __P((const char *, const char *));
+ 
  #define LN_SYMLINK 0x01
  #define LN_UNLINK  0x02
  
! static unix_link_syscall_t *linkfn;
  static int dolink ();
  
diff -Nrc2 bash-2.05/examples/loadables/sleep.c bash-2.05a/examples/loadables/sleep.c
*** bash-2.05/examples/loadables/sleep.c	Mon May 11 11:44:02 1998
--- bash-2.05a/examples/loadables/sleep.c	Wed Sep 12 11:51:49 2001
***************
*** 24,27 ****
--- 24,28 ----
  
  #include <stdio.h>
+ #include "chartypes.h"
  
  #include "shell.h"
***************
*** 79,83 ****
  		if (*p == DECIMAL)		/* decimal point */
  			break;
! 		if (isdigit(*p) == 0)
  			RETURN(0);
  		sec = (sec * 10) + (*p - '0');
--- 80,84 ----
  		if (*p == DECIMAL)		/* decimal point */
  			break;
! 		if (DIGIT(*p) == 0)
  			RETURN(0);
  		sec = (sec * 10) + (*p - '0');
***************
*** 92,96 ****
  	/* Look for up to six digits past a decimal point. */
  	for (n = 0; n < 6 && p[n]; n++) {
! 		if (isdigit(p[n]) == 0)
  			RETURN(0);
  		usec = (usec * 10) + (p[n] - '0');
--- 93,97 ----
  	/* Look for up to six digits past a decimal point. */
  	for (n = 0; n < 6 && p[n]; n++) {
! 		if (DIGIT(p[n]) == 0)
  			RETURN(0);
  		usec = (usec * 10) + (p[n] - '0');
***************
*** 100,104 ****
  	usec *= multiplier[n];
  
! 	if (n == 6 && p[6] && isdigit(p[6]) && p[6] >= '5')	
  		usec++;			/* round up 1 */
  
--- 101,105 ----
  	usec *= multiplier[n];
  
! 	if (n == 6 && p[6] >= '5' && p[6] <= '9')
  		usec++;			/* round up 1 */
  
diff -Nrc2 bash-2.05/examples/loadables/sprintf.c bash-2.05a/examples/loadables/sprintf.c
*** bash-2.05/examples/loadables/sprintf.c	Wed Jun 26 15:43:49 1996
--- bash-2.05a/examples/loadables/sprintf.c	Wed Dec 31 19:00:00 1969
***************
*** 1,514 ****
- /*
-  * Copyright (c) 1989, 1993
-  *	The Regents of the University of California.  All rights reserved.
-  *
-  * Redistribution and use in source and binary forms, with or without
-  * modification, are permitted provided that the following conditions
-  * are met:
-  * 1. Redistributions of source code must retain the above copyright
-  *    notice, this list of conditions and the following disclaimer.
-  * 2. Redistributions in binary form must reproduce the above copyright
-  *    notice, this list of conditions and the following disclaimer in the
-  *    documentation and/or other materials provided with the distribution.
-  * 3. All advertising materials mentioning features or use of this software
-  *    must display the following acknowledgement:
-  *	This product includes software developed by the University of
-  *	California, Berkeley and its contributors.
-  * 4. Neither the name of the University nor the names of its contributors
-  *    may be used to endorse or promote products derived from this software
-  *    without specific prior written permission.
-  *
-  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
-  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
-  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
-  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
-  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
-  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
-  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
-  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
-  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
-  * SUCH DAMAGE.
-  */
- 
- #if !defined(BUILTIN) && !defined(SHELL)
- #ifndef lint
- static char copyright[] =
- "@(#) Copyright (c) 1989, 1993\n\
- 	The Regents of the University of California.  All rights reserved.\n";
- #endif /* not lint */
- #endif
- 
- #ifndef lint
- static char sccsid[] = "@(#)printf.c	8.1 (Berkeley) 7/20/93";
- #endif /* not lint */
- 
- #include <sys/types.h>
- 
- #include <errno.h>
- #include <limits.h>
- #include <stdio.h>
- 
- #include "bashansi.h"
- #include "shell.h"
- #include "builtins.h"
- #include "stdc.h"
- 
- #if !defined (errno)
- extern int errno;
- #endif
- 
- static char	sbuf[1024];
- static int	sblen;
- 
- /* Gee, I wish sprintf could be reliably counted upon to return the
-    number of characters written :-( */
- #define PF(f, func) \
- do { \
- 	if (fieldwidth) \
- 		if (precision) \
- 			sprintf(sbuf, f, fieldwidth, precision, func); \
- 		else \
- 			sprintf(sbuf, f, fieldwidth, func); \
- 	else if (precision) \
- 		sprintf(sbuf, f, precision, func); \
- 	else \
- 		sprintf(sbuf, f, func); \
- 	spaddstr (sbuf, strlen (sbuf)); \
- } while (0)
- 
- static int	 asciicode __P((void));
- static void	 escape __P((char *));
- static int	 getchr __P((void));
- static double	 getdouble __P((void));
- static int	 getint __P((int *));
- static int	 getlong __P((long *));
- static char	*getstr __P((void));
- static char	*mklong __P((char *, int));
- static void	 usage __P((void));
- 
- static char **gargv;
- 
- static char *outstr;
- static int outsize;
- static int outind;
- 
- int sprintf_builtin ();
- static int sprintf_main ();
- static void spaddstr ();
- 
- extern char *this_command_name;
- extern char *single_quote ();
- extern char **make_builtin_argv ();
- 
- static char *sprintf_doc[] = {
-   "sprintf formats and outputs its arguments, after the second, under control",
-   "of the format and assigns the result to the variable named by its first",
-   "argument. The format is a character string which contains three types",
-   "of objects: plain characters, which are simply copied to the output string,",
-   "character escape sequences which are converted and copied to the output",
-   "string, and format specifications, each of which causes printing of the",
-   "next successive argument.  In addition to the standard sprintf(3) formats,",
-   "%b means to expand escapes in the corresponding argument, and %q means",
-   "to quote the argument in a way that can be reused as shell input.  Each",
-   "one of the format specifications must not expand to more than 1024",
-   "characters, though there is no limit on the total size of the output",
-   "string.",
-   (char *)NULL
- };
- 
- struct builtin sprintf_struct = {
- 	"sprintf",
- 	sprintf_builtin,
- 	BUILTIN_ENABLED,
- 	sprintf_doc,
- 	"sprintf var format [arguments]",
- 	(char *)0
- };
- 
- int
- sprintf_builtin (list)
-      WORD_LIST *list;
- {
-   int c, r;
-   char **v, *varname;
-   WORD_LIST *l;
-   SHELL_VAR *var;
- 
-   if (list == 0)
-     {
-       builtin_usage ();
-       return (EXECUTION_FAILURE);
-     }
- 
-   varname = list->word->word;
-   list = list->next;
- 
-   if (legal_identifier (varname) == 0)
-     {
-       builtin_error ("%s: not a legal variable name", varname);
-       return (EXECUTION_FAILURE);
-     }
- 
-   outind = 0;
-   if (outstr == 0)
-     outstr = xmalloc (outsize = 64);
-   outstr[0] = '\0';
- 
-   v = make_builtin_argv (list, &c);
-   r = sprintf_main (c, v);
-   free (v);
- 
-   var = bind_variable (varname, outstr);
-   if (readonly_p (var))
-     {
-       builtin_error ("%s: readonly variable", varname);
-       return (EXECUTION_FAILURE);
-     }
- 
-   return r;
- }
- 
- static void
- spaddstr(str, len)
-      char *str;
-      int len;
- {
-   RESIZE_MALLOCED_BUFFER (outstr, outind, len, outsize, 64);
-   strcpy (outstr + outind, str);
-   outind += len;
- }
- 
- static int
- sprintf_main(argc, argv)
- 	int argc;
- 	char *argv[];
- {
- 	extern int optind;
- 	static char *skip1, *skip2;
- 	int ch, end, fieldwidth, precision;
- 	char convch, nextch, *format, *fmt, *start;
- 
- 	while ((ch = getopt(argc, argv, "")) != EOF)
- 		switch (ch) {
- 		case '?':
- 		default:
- 			usage();
- 			return (1);
- 		}
- 	argc -= optind;
- 	argv += optind;
- 
- 	if (argc < 1) {
- 		usage();
- 		return (1);
- 	}
- 
- 	/*
- 	 * Basic algorithm is to scan the format string for conversion
- 	 * specifications -- once one is found, find out if the field
- 	 * width or precision is a '*'; if it is, gather up value.  Note,
- 	 * format strings are reused as necessary to use up the provided
- 	 * arguments, arguments of zero/null string are provided to use
- 	 * up the format string.
- 	 */
- 	skip1 = "#-+ 0";
- 	skip2 = "*0123456789";
- 
- 	escape(fmt = format = *argv);		/* backslash interpretation */
- 	gargv = ++argv;
- 	for (;;) {
- 		end = 0;
- 		/* find next format specification */
- next:		for (start = fmt;; ++fmt) {
- 			if (!*fmt) {
- 				/* avoid infinite loop */
- 				if (end == 1) {
- 					warnx("missing format character",
- 					    NULL, NULL);
- 					return (1);
- 				}
- 				end = 1;
- 				if (fmt > start)
- 					(void)printf("%s", start);
- 				if (!*gargv)
- 					return (0);
- 				fmt = format;
- 				goto next;
- 			}
- 			/* %% prints a % */
- 			if (*fmt == '%') {
- 				if (*++fmt != '%')
- 					break;
- 				*fmt++ = '\0';
- 				(void)printf("%s", start);
- 				goto next;
- 			}
- 		}
- 
- 		/* skip to field width */
- 		for (; strchr(skip1, *fmt); ++fmt);
- 		if (*fmt == '*') {
- 			if (getint(&fieldwidth))
- 				return (1);
- 		} else
- 			fieldwidth = 0;
- 
- 		/* skip to possible '.', get following precision */
- 		for (; strchr(skip2, *fmt); ++fmt);
- 		if (*fmt == '.')
- 			++fmt;
- 		if (*fmt == '*') {
- 			if (getint(&precision))
- 				return (1);
- 		} else
- 			precision = 0;
- 
- 		/* skip to conversion char */
- 		for (; strchr(skip2, *fmt); ++fmt);
- 		if (!*fmt) {
- 			warnx("missing format character", NULL, NULL);
- 			return (1);
- 		}
- 
- 		convch = *fmt;
- 		nextch = *++fmt;
- 		*fmt = '\0';
- 		switch(convch) {
- 		case 'c': {
- 			char p;
- 
- 			p = getchr();
- 			PF(start, p);
- 			break;
- 		}
- 		case 's': {
- 			char *p;
- 
- 			p = getstr();
- 			PF(start, p);
- 			break;
- 		}
- 		case 'b': {		/* expand escapes in argument */
- 			char *p;
- 
- 			p = getstr();
- 			escape(p);
- 			PF("%s", p);
- 			break;
- 		}
- 		case 'q': {		/* print with shell single quoting */
- 			char *p, *p2;
- 
- 			p = getstr();
- 			p2 = single_quote(p);
- 			PF("%s", p2);
- 			free(p2);
- 			break;
- 		}
- 		case 'd': case 'i': case 'o': case 'u': case 'x': case 'X': {
- 			long p;
- 			char *f;
- 			
- 			if ((f = mklong(start, convch)) == NULL)
- 				return (1);
- 			if (getlong(&p))
- 				return (1);
- 			PF(f, p);
- 			break;
- 		}
- 		case 'e': case 'E': case 'f': case 'g': case 'G': {
- 			double p;
- 
- 			p = getdouble();
- 			PF(start, p);
- 			break;
- 		}
- 		default:
- 			warnx("illegal format character", NULL, NULL);
- 			return (1);
- 		}
- 		*fmt = nextch;
- 	}
- 	/* NOTREACHED */
- }
- 
- static char *
- mklong(str, ch)
- 	char *str;
- 	int ch;
- {
- 	static char copy[64];
- 	int len;
- 
- 	len = strlen(str) + 2;
- 	memmove(copy, str, len - 3);
- 	copy[len - 3] = 'l';
- 	copy[len - 2] = ch;
- 	copy[len - 1] = '\0';
- 	return (copy);
- }
- 
- static void
- escape(fmt)
- 	register char *fmt;
- {
- 	register char *store;
- 	register int value, c;
- 
- 	for (store = fmt; c = *fmt; ++fmt, ++store) {
- 		if (c != '\\') {
- 			*store = c;
- 			continue;
- 		}
- 		switch (*++fmt) {
- 		case '\0':		/* EOS, user error */
- 			*store = '\\';
- 			*++store = '\0';
- 			return;
- 		case '\\':		/* backslash */
- 		case '\'':		/* single quote */
- 			*store = *fmt;
- 			break;
- 		case 'a':		/* bell/alert */
- 			*store = '\7';
- 			break;
- 		case 'b':		/* backspace */
- 			*store = '\b';
- 			break;
- 		case 'c':
- 			return;
- 		case 'e':
- 		case 'E':
- 			*store = '\033';
- 			break;
- 		case 'f':		/* form-feed */
- 			*store = '\f';
- 			break;
- 		case 'n':		/* newline */
- 			*store = '\n';
- 			break;
- 		case 'r':		/* carriage-return */
- 			*store = '\r';
- 			break;
- 		case 't':		/* horizontal tab */
- 			*store = '\t';
- 			break;
- 		case 'v':		/* vertical tab */
- 			*store = '\13';
- 			break;
- 					/* octal constant */
- 		case '0': case '1': case '2': case '3':
- 		case '4': case '5': case '6': case '7':
- 			for (c = 3, value = 0;
- 			    c-- && *fmt >= '0' && *fmt <= '7'; ++fmt) {
- 				value <<= 3;
- 				value += *fmt - '0';
- 			}
- 			--fmt;
- 			*store = value;
- 			break;
- 		default:
- 			*store = *fmt;
- 			break;
- 		}
- 	}
- 	*store = '\0';
- }
- 
- static int
- getchr()
- {
- 	if (!*gargv)
- 		return ('\0');
- 	return ((int)**gargv++);
- }
- 
- static char *
- getstr()
- {
- 	if (!*gargv)
- 		return ("");
- 	return (*gargv++);
- }
- 
- static char *Number = "+-.0123456789";
- static int
- getint(ip)
- 	int *ip;
- {
- 	long val;
- 
- 	if (getlong(&val))
- 		return (1);
- 	if (val > INT_MAX) {
- 		warnx("%s: %s", *gargv, strerror(ERANGE));
- 		return (1);
- 	}
- 	*ip = val;
- 	return (0);
- }
- 
- static int
- getlong(lp)
- 	long *lp;
- {
- 	long val;
- 	char *ep;
- 
- 	if (!*gargv) {
- 		*lp = 0;
- 		return (0);
- 	}
- 	if (strchr(Number, **gargv)) {
- 		errno = 0;
- 		val = strtol(*gargv, &ep, 0);
- 		if (*ep != '\0') {
- 			warnx("%s: illegal number", *gargv, NULL);
- 			return (1);
- 		}
- 		if (errno == ERANGE)
- 			if (val == LONG_MAX) {
- 				warnx("%s: %s", *gargv, strerror(ERANGE));
- 				return (1);
- 			}
- 			if (val == LONG_MIN) {
- 				warnx("%s: %s", *gargv, strerror(ERANGE));
- 				return (1);
- 			}
- 			
- 		*lp = val;
- 		++gargv;
- 		return (0);
- 	}
- 	*lp =  (long)asciicode();
- 	return (0);
- }
- 
- static double
- getdouble()
- {
- 	if (!*gargv)
- 		return ((double)0);
- 	if (strchr(Number, **gargv))
- 		return (atof(*gargv++));
- 	return ((double)asciicode());
- }
- 
- static int
- asciicode()
- {
- 	register int ch;
- 
- 	ch = **gargv;
- 	if (ch == '\'' || ch == '"')
- 		ch = (*gargv)[1];
- 	++gargv;
- 	return (ch);
- }
- 
- static void
- usage()
- {
- 	(void)fprintf(stderr, "usage: printf format [arg ...]\n");
- }
--- 0 ----
diff -Nrc2 bash-2.05/execute_cmd.c bash-2.05a/execute_cmd.c
*** bash-2.05/execute_cmd.c	Thu Mar 22 10:17:23 2001
--- bash-2.05a/execute_cmd.c	Mon Oct 29 14:03:18 2001
***************
*** 25,29 ****
  
  #include <stdio.h>
! #include <ctype.h>
  #include "bashtypes.h"
  #ifndef _MINIX
--- 25,29 ----
  
  #include <stdio.h>
! #include "chartypes.h"
  #include "bashtypes.h"
  #ifndef _MINIX
***************
*** 41,48 ****
  #endif
  
- #if defined (HAVE_LIMITS_H)
- #  include <limits.h>
- #endif
- 
  #include "posixtime.h"
  
--- 41,44 ----
***************
*** 84,88 ****
  #include "builtins/builtext.h"	/* list of builtins */
  
! #include <glob/fnmatch.h>
  #include <tilde/tilde.h>
  
--- 80,84 ----
  #include "builtins/builtext.h"	/* list of builtins */
  
! #include <glob/strmatch.h>
  #include <tilde/tilde.h>
  
***************
*** 100,107 ****
  
  extern int posixly_correct;
! extern int executing, breaking, continuing, loop_level;
! extern int interactive, interactive_shell, login_shell, expand_aliases;
  extern int parse_and_execute_level, running_trap, trap_line_number;
! extern int command_string_index, variable_context, line_number;
  extern int dot_found_in_search;
  extern int already_making_children;
--- 96,103 ----
  
  extern int posixly_correct;
! extern int breaking, continuing, loop_level;
! extern int expand_aliases;
  extern int parse_and_execute_level, running_trap, trap_line_number;
! extern int command_string_index, line_number;
  extern int dot_found_in_search;
  extern int already_making_children;
***************
*** 109,154 ****
  extern char *the_printed_command, *shell_name;
  extern pid_t last_command_subst_pid;
! extern Function *last_shell_builtin, *this_shell_builtin;
  extern char **subshell_argv, **subshell_envp;
  extern int subshell_argc;
  extern char *glob_argv_flags;
  
! extern int getdtablesize ();
! extern int close ();
  
  /* Static functions defined and used in this file. */
! static void close_pipes (), do_piping (), bind_lastarg ();
! static void cleanup_redirects ();
  
! static int execute_for_command ();
  #if defined (SELECT_COMMAND)
! static int execute_select_command ();
  #endif
  #if defined (DPAREN_ARITHMETIC)
! static int execute_arith_command ();
  #endif
  #if defined (COND_COMMAND)
! static int execute_cond_command ();
  #endif
  #if defined (COMMAND_TIMING)
! static int time_command ();
  #endif
  #if defined (ARITH_FOR_COMMAND)
! static int execute_arith_for_command ();
  #endif
! static int execute_case_command ();
! static int execute_while_command (), execute_until_command ();
! static int execute_while_or_until ();
! static int execute_if_command ();
! static int execute_simple_command ();
! static int execute_builtin (), execute_function ();
! static int execute_builtin_or_function ();
! static int builtin_status ();
! static void execute_subshell_builtin_or_function ();
! static void execute_disk_command ();
! static int execute_connection ();
! static int execute_intern_function ();
  
- static int execute_in_subshell ();
  
  /* The line number that the currently executing function starts on. */
--- 105,191 ----
  extern char *the_printed_command, *shell_name;
  extern pid_t last_command_subst_pid;
! extern sh_builtin_func_t *last_shell_builtin, *this_shell_builtin;
  extern char **subshell_argv, **subshell_envp;
  extern int subshell_argc;
+ #if 0
  extern char *glob_argv_flags;
+ #endif
  
! extern int close __P((int));
  
  /* Static functions defined and used in this file. */
! static void close_pipes __P((int, int));
! static void do_piping __P((int, int));
! static void bind_lastarg __P((char *));
! static int shell_control_structure __P((enum command_type));
! static void cleanup_redirects __P((REDIRECT *));
! 
! #if defined (JOB_CONTROL)
! static int restore_signal_mask __P((sigset_t *));
! #endif
  
! static void async_redirect_stdin __P((void));
! 
! static int builtin_status __P((int));
! 
! static int execute_for_command __P((FOR_COM *));
  #if defined (SELECT_COMMAND)
! static int print_index_and_element __P((int, int, WORD_LIST *));
! static void indent __P((int, int));
! static void print_select_list __P((WORD_LIST *, int, int, int));
! static char *select_query __P((WORD_LIST *, int, char *));
! static int execute_select_command __P((SELECT_COM *));
  #endif
  #if defined (DPAREN_ARITHMETIC)
! static int execute_arith_command __P((ARITH_COM *));
  #endif
  #if defined (COND_COMMAND)
! static int execute_cond_node __P((COND_COM *));
! static int execute_cond_command __P((COND_COM *));
  #endif
  #if defined (COMMAND_TIMING)
! static int mkfmt __P((char *, int, int, time_t, int));
! static void print_formatted_time __P((FILE *, char *,
! 				      time_t, int, time_t, int,
! 				      time_t, int, int));
! static int time_command __P((COMMAND *, int, int, int, struct fd_bitmap *));
  #endif
  #if defined (ARITH_FOR_COMMAND)
! static long eval_arith_for_expr __P((WORD_LIST *, int *));
! static int execute_arith_for_command __P((ARITH_FOR_COM *));
  #endif
! static int execute_case_command __P((CASE_COM *));
! static int execute_while_command __P((WHILE_COM *));
! static int execute_until_command __P((WHILE_COM *));
! static int execute_while_or_until __P((WHILE_COM *, int));
! static int execute_if_command __P((IF_COM *));
! static int execute_null_command __P((REDIRECT *, int, int, int, pid_t));
! static void fix_assignment_words __P((WORD_LIST *));
! static int execute_simple_command __P((SIMPLE_COM *, int, int, int, struct fd_bitmap *));
! static int execute_builtin __P((sh_builtin_func_t *, WORD_LIST *, int, int));
! static int execute_function __P((SHELL_VAR *, WORD_LIST *, int, struct fd_bitmap *, int, int));
! static int execute_builtin_or_function __P((WORD_LIST *, sh_builtin_func_t *,
! 					    SHELL_VAR *,
! 					    REDIRECT *, struct fd_bitmap *, int));
! static void execute_subshell_builtin_or_function __P((WORD_LIST *, REDIRECT *,
! 						      sh_builtin_func_t *,
! 						      SHELL_VAR *,
! 						      int, int, int,
! 						      struct fd_bitmap *,
! 						      int));
! static void execute_disk_command __P((WORD_LIST *, REDIRECT *, char *,
! 				      int, int, int, struct fd_bitmap *, int));
! 
! static char *getinterp __P((char *, int, int *));
! static void initialize_subshell __P((void));
! static int execute_in_subshell __P((COMMAND *, int, int, int, struct fd_bitmap *));
! 
! static int execute_pipeline __P((COMMAND *, int, int, int, struct fd_bitmap *));
! 
! static int execute_connection __P((COMMAND *, int, int, int, struct fd_bitmap *));
! 
! static int execute_intern_function __P((WORD_DESC *, COMMAND *));
! 
  
  
  /* The line number that the currently executing function starts on. */
***************
*** 195,199 ****
  struct fd_bitmap *current_fds_to_close = (struct fd_bitmap *)NULL;
  
! #define FD_BITMAP_DEFAULT_SIZE 32L
  
  /* Functions to allocate and deallocate the structures used to pass
--- 232,236 ----
  struct fd_bitmap *current_fds_to_close = (struct fd_bitmap *)NULL;
  
! #define FD_BITMAP_DEFAULT_SIZE 32
  
  /* Functions to allocate and deallocate the structures used to pass
***************
*** 202,206 ****
  struct fd_bitmap *
  new_fd_bitmap (size)
!      long size;
  {
    struct fd_bitmap *ret;
--- 239,243 ----
  struct fd_bitmap *
  new_fd_bitmap (size)
!      int size;
  {
    struct fd_bitmap *ret;
***************
*** 212,216 ****
    if (size)
      {
!       ret->bitmap = xmalloc (size);
        bzero (ret->bitmap, size);
      }
--- 249,253 ----
    if (size)
      {
!       ret->bitmap = (char *)xmalloc (size);
        bzero (ret->bitmap, size);
      }
***************
*** 360,369 ****
  static int
  restore_signal_mask (set)
!      sigset_t set;
  {
!   return (sigprocmask (SIG_SETMASK, &set, (sigset_t *)NULL));
  }
  #endif /* JOB_CONTROL */
  
  /* A debugging function that can be called from gdb, for instance. */
  void
--- 397,407 ----
  static int
  restore_signal_mask (set)
!      sigset_t *set;
  {
!   return (sigprocmask (SIG_SETMASK, set, (sigset_t *)NULL));
  }
  #endif /* JOB_CONTROL */
  
+ #ifdef DEBUG
  /* A debugging function that can be called from gdb, for instance. */
  void
***************
*** 375,379 ****
    fd_table_size = getdtablesize ();
  
!   fprintf (stderr, "pid %d open files:", (int)getpid ());
    for (i = 3; i < fd_table_size; i++)
      {
--- 413,417 ----
    fd_table_size = getdtablesize ();
  
!   fprintf (stderr, "pid %ld open files:", (long)getpid ());
    for (i = 3; i < fd_table_size; i++)
      {
***************
*** 383,386 ****
--- 421,425 ----
    fprintf (stderr, "\n");
  }
+ #endif
  
  static void
***************
*** 421,425 ****
       struct fd_bitmap *fds_to_close;
  {
!   int exec_result, invert, ignore_return, was_debug_trap;
    REDIRECT *my_undo_list, *exec_undo_list;
    volatile pid_t last_pid;
--- 460,464 ----
       struct fd_bitmap *fds_to_close;
  {
!   int exec_result, invert, ignore_return, was_debug_trap, was_error_trap;
    REDIRECT *my_undo_list, *exec_undo_list;
    volatile pid_t last_pid;
***************
*** 576,579 ****
--- 615,619 ----
  	last_pid = last_made_pid;
  	was_debug_trap = signal_is_trapped (DEBUG_TRAP) && signal_is_ignored (DEBUG_TRAP) == 0;
+ 	was_error_trap = signal_is_trapped (ERROR_TRAP) && signal_is_ignored (ERROR_TRAP) == 0;
  
  	if (ignore_return && command->value.Simple)
***************
*** 635,638 ****
--- 675,684 ----
  	}
  
+       if (was_error_trap && ignore_return == 0 && invert == 0 && exec_result != EXECUTION_SUCCESS)
+ 	{
+ 	  last_command_exit_value = exec_result;
+ 	  run_error_trap ();
+ 	}
+ 
        if (ignore_return == 0 && invert == 0 &&
  	  ((posixly_correct && interactive == 0 && special_builtin_failed) ||
***************
*** 794,800 ****
  
  #if defined (HAVE_GETRUSAGE) && defined (HAVE_GETTIMEOFDAY)
! extern struct timeval *difftimeval();
! extern struct timeval *addtimeval();
! extern int timeval_to_cpu();
  #endif
  
--- 840,846 ----
  
  #if defined (HAVE_GETRUSAGE) && defined (HAVE_GETTIMEOFDAY)
! extern struct timeval *difftimeval __P((struct timeval *, struct timeval *, struct timeval *));
! extern struct timeval *addtimeval __P((struct timeval *, struct timeval *, struct timeval *));
! extern int timeval_to_cpu __P((struct timeval *, struct timeval *, struct timeval *));
  #endif
  
***************
*** 809,821 ****
       char *buf;
       int prec, lng;
!      long sec;
       int sec_fraction;
  {
!   long min;
!   char abuf[16];
    int ind, aind;
  
    ind = 0;
!   abuf[15] = '\0';
  
    /* If LNG is non-zero, we want to decompose SEC into minutes and seconds. */
--- 855,867 ----
       char *buf;
       int prec, lng;
!      time_t sec;
       int sec_fraction;
  {
!   time_t min;
!   char abuf[INT_STRLEN_BOUND(time_t) + 1];
    int ind, aind;
  
    ind = 0;
!   abuf[sizeof(abuf) - 1] = '\0';
  
    /* If LNG is non-zero, we want to decompose SEC into minutes and seconds. */
***************
*** 824,828 ****
        min = sec / 60;
        sec %= 60;
!       aind = 14;
        do
  	abuf[aind--] = (min % 10) + '0';
--- 870,874 ----
        min = sec / 60;
        sec %= 60;
!       aind = sizeof(abuf) - 2;
        do
  	abuf[aind--] = (min % 10) + '0';
***************
*** 835,839 ****
  
    /* Now add the seconds. */
!   aind = 14;
    do
      abuf[aind--] = (sec % 10) + '0';
--- 881,885 ----
  
    /* Now add the seconds. */
!   aind = sizeof (abuf) - 2;
    do
      abuf[aind--] = (sec % 10) + '0';
***************
*** 884,893 ****
       FILE *fp;
       char *format;
!      long rs, us, ss;
!      int rsf, usf, ssf, cpu;
  {
    int prec, lng, len;
!   char *str, *s, ts[32];
!   long sum;
    int sum_frac;
    int sindex, ssize;
--- 930,943 ----
       FILE *fp;
       char *format;
!      time_t rs;
!      int rsf;
!      time_t us;
!      int usf;
!      time_t ss;
!      int ssf, cpu;
  {
    int prec, lng, len;
!   char *str, *s, ts[INT_STRLEN_BOUND (time_t) + sizeof ("mSS.FFFF")];
!   time_t sum;
    int sum_frac;
    int sindex, ssize;
***************
*** 895,899 ****
    len = strlen (format);
    ssize = (len + 64) - (len % 64);
!   str = xmalloc (ssize);
    sindex = 0;
  
--- 945,949 ----
    len = strlen (format);
    ssize = (len + 64) - (len % 64);
!   str = (char *)xmalloc (ssize);
    sindex = 0;
  
***************
*** 928,932 ****
  	  lng = 0;	/* default is to not use minutes or append `s' */
  	  s++;
! 	  if (isdigit (*s))		/* `precision' */
  	    {
  	      prec = *s++ - '0';
--- 978,982 ----
  	  lng = 0;	/* default is to not use minutes or append `s' */
  	  s++;
! 	  if (DIGIT (*s))		/* `precision' */
  	    {
  	      prec = *s++ - '0';
***************
*** 970,974 ****
  {
    int rv, posix_time, old_flags;
!   long rs, us, ss;
    int rsf, usf, ssf;
    int cpu;
--- 1020,1024 ----
  {
    int rv, posix_time, old_flags;
!   time_t rs, us, ss;
    int rsf, usf, ssf;
    int cpu;
***************
*** 1004,1008 ****
    command->flags = old_flags;
  
!   rs = us = ss = 0L;
    rsf = usf = ssf = cpu = 0;
  
--- 1054,1058 ----
    command->flags = old_flags;
  
!   rs = us = ss = 0;
    rsf = usf = ssf = cpu = 0;
  
***************
*** 1040,1044 ****
  
  #  else
!   rs = us = ss = 0L;
    rsf = usf = ssf = cpu = 0;
  #  endif
--- 1090,1094 ----
  
  #  else
!   rs = us = ss = 0;
    rsf = usf = ssf = cpu = 0;
  #  endif
***************
*** 1071,1074 ****
--- 1121,1129 ----
    COMMAND *tcom;
  
+   USE_VAR(user_subshell);
+   USE_VAR(invert);
+   USE_VAR(tcom);
+   USE_VAR(asynchronous);
+ 
    should_redir_stdin = (asynchronous && (command->flags & CMD_STDIN_REDIR) &&
  			  pipe_in == NO_PIPE &&
***************
*** 1170,1173 ****
--- 1225,1232 ----
    tcom = (command->type == cm_subshell) ? command->value.Subshell->command : command;
  
+   /* Make sure the subshell inherits any CMD_IGNORE_RETURN flag. */
+   if ((command->flags & CMD_IGNORE_RETURN) && tcom != command)
+     tcom->flags |= CMD_IGNORE_RETURN;
+ 
    /* If this is a simple command, tell execute_disk_command that it
       might be able to get away without forking and simply exec.
***************
*** 1293,1297 ****
  
  #if defined (JOB_CONTROL)
!       add_unwind_protect (restore_signal_mask, oset);
  #endif /* JOB_CONTROL */
  
--- 1352,1356 ----
  
  #if defined (JOB_CONTROL)
!       add_unwind_protect (restore_signal_mask, &oset);
  #endif /* JOB_CONTROL */
  
***************
*** 1357,1367 ****
        tc->flags |= CMD_AMPERSAND;
  
!       /* If this shell was compiled without job control support, if
! 	 the shell is not running interactively, if we are currently
! 	 in a subshell via `( xxx )', or if job control is not active
! 	 then the standard input for an asynchronous command is
! 	 forced to /dev/null. */
  #if defined (JOB_CONTROL)
!       if ((!interactive_shell || subshell_environment || !job_control) && !stdin_redir)
  #else
        if (!stdin_redir)
--- 1416,1425 ----
        tc->flags |= CMD_AMPERSAND;
  
!       /* If this shell was compiled without job control support,
! 	 if we are currently in a subshell via `( xxx )', or if job
! 	 control is not active then the standard input for an
! 	 asynchronous command is forced to /dev/null. */
  #if defined (JOB_CONTROL)
!       if ((subshell_environment || !job_control) && !stdin_redir)
  #else
        if (!stdin_redir)
***************
*** 1613,1620 ****
  
    new = expand_words_no_vars (l);
!   if (echo_command_at_execute)
!     xtrace_print_arith_cmd (new);
!   expresult = evalexp (new->word->word, okp);
!   dispose_words (new);
    return (expresult);
  }
--- 1671,1687 ----
  
    new = expand_words_no_vars (l);
!   if (new)
!     {
!       if (echo_command_at_execute)
! 	xtrace_print_arith_cmd (new);
!       expresult = evalexp (new->word->word, okp);
!       dispose_words (new);
!     }
!   else
!     {
!       expresult = 0;
!       if (okp)
! 	*okp = 1;
!     }
    return (expresult);
  }
***************
*** 1625,1629 ****
  {
    long expresult;
!   int expok, result, body_status;
  
    body_status = EXECUTION_SUCCESS;
--- 1692,1696 ----
  {
    long expresult;
!   int expok, body_status;
  
    body_status = EXECUTION_SUCCESS;
***************
*** 1864,1869 ****
    SHELL_VAR *v;
    char *identifier, *ps3_prompt, *selection;
!   int retval, list_len, return_val;
! 
    if (check_identifier (select_command->name, 1) == 0)
      return (EXECUTION_FAILURE);
--- 1931,1936 ----
    SHELL_VAR *v;
    char *identifier, *ps3_prompt, *selection;
!   int retval, list_len;
!  
    if (check_identifier (select_command->name, 1) == 0)
      return (EXECUTION_FAILURE);
***************
*** 1891,1898 ****
    retval = EXECUTION_SUCCESS;
  
-   unwind_protect_int (return_catch_flag);
-   unwind_protect_jmp_buf (return_catch);
-   return_catch_flag++;
- 
    while (1)
      {
--- 1958,1961 ----
***************
*** 1922,1934 ****
  	}
  
!       return_val = setjmp (return_catch);
! 
!       if (return_val)
! 	{
! 	  retval = return_catch_value;
! 	  break;
! 	}
!       else
! 	retval = execute_command (select_command->action);
  
        REAP ();
--- 1985,1989 ----
  	}
  
!       retval = execute_command (select_command->action);
  
        REAP ();
***************
*** 2010,2021 ****
  	  else
  	    {
! 	      pattern = xmalloc (1);
  	      pattern[0] = '\0';
  	    }
  
  	  /* Since the pattern does not undergo quote removal (as per
! 	     Posix.2, section 3.9.4.3), the fnmatch () call must be able
  	     to recognize backslashes as escape characters. */
! 	  match = fnmatch (pattern, word, FNMATCH_EXTFLAG) != FNM_NOMATCH;
  	  free (pattern);
  
--- 2065,2076 ----
  	  else
  	    {
! 	      pattern = (char *)xmalloc (1);
  	      pattern[0] = '\0';
  	    }
  
  	  /* Since the pattern does not undergo quote removal (as per
! 	     Posix.2, section 3.9.4.3), the strmatch () call must be able
  	     to recognize backslashes as escape characters. */
! 	  match = strmatch (pattern, word, FNMATCH_EXTFLAG) != FNM_NOMATCH;
  	  free (pattern);
  
***************
*** 2085,2092 ****
        REAP ();
  
        if (type == CMD_WHILE && return_value != EXECUTION_SUCCESS)
! 	break;
        if (type == CMD_UNTIL && return_value == EXECUTION_SUCCESS)
! 	break;
  
        QUIT;
--- 2140,2160 ----
        REAP ();
  
+       /* Need to handle `break' in the test when we would break out of the
+          loop.  The job control code will set `breaking' to loop_level
+          when a job in a loop is stopped with SIGTSTP.  If the stopped job
+          is in the loop test, `breaking' will not be reset unless we do
+          this, and the shell will cease to execute commands. */
        if (type == CMD_WHILE && return_value != EXECUTION_SUCCESS)
! 	{
! 	  if (breaking)
! 	    breaking--;
! 	  break;
! 	}
        if (type == CMD_UNTIL && return_value == EXECUTION_SUCCESS)
! 	{
! 	  if (breaking)
! 	    breaking--;
! 	  break;
! 	}
  
        QUIT;
***************
*** 2149,2157 ****
       ARITH_COM *arith_command;
  {
!   int result, expok, expresult;
!   WORD_LIST *new, *p, *printit;
!   WORD_DESC *w;
  
!   result = 0;
  
    this_command_name = "((";	/* )) */
--- 2217,2225 ----
       ARITH_COM *arith_command;
  {
!   int expok;
!   long expresult;
!   WORD_LIST *new;
  
!   expresult = 0;
  
    this_command_name = "((";	/* )) */
***************
*** 2167,2171 ****
      xtrace_print_arith_cmd (new);
  
!   result = evalexp (new->word->word, &expok);
    dispose_words (new);
  
--- 2235,2239 ----
      xtrace_print_arith_cmd (new);
  
!   expresult = evalexp (new->word->word, &expok);
    dispose_words (new);
  
***************
*** 2173,2177 ****
      return (EXECUTION_FAILURE);
  
!   return (result == 0 ? EXECUTION_FAILURE : EXECUTION_SUCCESS);
  }
  #endif /* DPAREN_ARITHMETIC */
--- 2241,2245 ----
      return (EXECUTION_FAILURE);
  
!   return (expresult == 0 ? EXECUTION_FAILURE : EXECUTION_SUCCESS);
  }
  #endif /* DPAREN_ARITHMETIC */
***************
*** 2185,2190 ****
       COND_COM *cond;
  {
!   int result, invert, patmatch, flags;
!   char *arg1, *arg2, *print2;
  
    invert = (cond->flags & CMD_INVERT_RETURN);
--- 2253,2258 ----
       COND_COM *cond;
  {
!   int result, invert, patmatch;
!   char *arg1, *arg2;
  
    invert = (cond->flags & CMD_INVERT_RETURN);
***************
*** 2373,2377 ****
    int first_word_quoted, result, builtin_is_special, already_forked, dofork;
    pid_t old_last_command_subst_pid, old_last_async_pid;
!   Function *builtin;
    SHELL_VAR *func;
  
--- 2441,2445 ----
    int first_word_quoted, result, builtin_is_special, already_forked, dofork;
    pid_t old_last_command_subst_pid, old_last_async_pid;
!   sh_builtin_func_t *builtin;
    SHELL_VAR *func;
  
***************
*** 2435,2439 ****
  
  	  do_piping (pipe_in, pipe_out);
! 	  pipe_in = pipe_out = -1;
  
  	  last_asynchronous_pid = old_last_async_pid;
--- 2503,2507 ----
  
  	  do_piping (pipe_in, pipe_out);
! 	  pipe_in = pipe_out = NO_PIPE;
  
  	  last_asynchronous_pid = old_last_async_pid;
***************
*** 2489,2493 ****
      xtrace_print_word_list (words);
  
!   builtin = (Function *)NULL;
    func = (SHELL_VAR *)NULL;
    if ((simple_command->flags & CMD_NO_FUNCTIONS) == 0)
--- 2557,2561 ----
      xtrace_print_word_list (words);
  
!   builtin = (sh_builtin_func_t *)NULL;
    func = (SHELL_VAR *)NULL;
    if ((simple_command->flags & CMD_NO_FUNCTIONS) == 0)
***************
*** 2542,2551 ****
        char *word;
        register int i;
!       int wl, cl, exact, substring, match, started_status;
        register PROCESS *p;
  
        word = words->word->word;
!       exact = STREQ (temp, "exact");
!       substring = STREQ (temp, "substring");
        wl = strlen (word);
        for (i = job_slots - 1; i > -1; i--)
--- 2610,2619 ----
        char *word;
        register int i;
!       int wl, cl, exact_p, substring_p, match, started_status;
        register PROCESS *p;
  
        word = words->word->word;
!       exact_p = STREQ (temp, "exact");
!       substring_p = STREQ (temp, "substring");
        wl = strlen (word);
        for (i = job_slots - 1; i > -1; i--)
***************
*** 2557,2566 ****
  	  do
  	    {
! 	      if (exact)
  		{
  		  cl = strlen (p->command);
  		  match = STREQN (p->command, word, cl);
  		}
! 	      else if (substring)
  		match = strindex (p->command, word) != (char *)0;
  	      else
--- 2625,2634 ----
  	  do
  	    {
! 	      if (exact_p)
  		{
  		  cl = strlen (p->command);
  		  match = STREQN (p->command, word, cl);
  		}
! 	      else if (substring_p)
  		match = strindex (p->command, word) != (char *)0;
  	      else
***************
*** 2699,2703 ****
  static int
  execute_builtin (builtin, words, flags, subshell)
!      Function *builtin;
       WORD_LIST *words;
       int flags, subshell;
--- 2767,2771 ----
  static int
  execute_builtin (builtin, words, flags, subshell)
!      sh_builtin_func_t *builtin;
       WORD_LIST *words;
       int flags, subshell;
***************
*** 2781,2791 ****
       SHELL_VAR *var;
       WORD_LIST *words;
!      int flags, subshell, async;
       struct fd_bitmap *fds_to_close;
  {
    int return_val, result;
    COMMAND *tc, *fc;
!   char *debug_trap;
!   SHELL_VAR *old_shell_function;
  
    tc = (COMMAND *)copy_command (function_cell (var));
--- 2849,2861 ----
       SHELL_VAR *var;
       WORD_LIST *words;
!      int flags;
       struct fd_bitmap *fds_to_close;
+      int async, subshell;
  {
    int return_val, result;
    COMMAND *tc, *fc;
!   char *debug_trap, *error_trap;
! 
!   USE_VAR(fc);
  
    tc = (COMMAND *)copy_command (function_cell (var));
***************
*** 2809,2815 ****
    make_funcname_visible (1);
  
!   debug_trap = (signal_is_trapped (DEBUG_TRAP) && signal_is_ignored (DEBUG_TRAP) == 0)
! 			? trap_list[DEBUG_TRAP]
! 			: (char *)NULL;
    if (debug_trap)
      {
--- 2879,2889 ----
    make_funcname_visible (1);
  
!   debug_trap = TRAP_STRING(DEBUG_TRAP);
!   error_trap = TRAP_STRING(ERROR_TRAP);
!   
!   /* The order of the unwind protects for debug_trap and error_trap is
!      important here!  unwind-protect commands are run in reverse order
!      of registration.  If this causes problems, take out the xfree
!      unwind-protect calls and live with the small memory leak. */
    if (debug_trap)
      {
***************
*** 2817,2824 ****
  	{
  	  debug_trap = savestring (debug_trap);
- 	  /* XXX order is important here!  unwind-protect commands are run
- 	     in reverse order of registering.  If this causes problems,
- 	     take out the xfree unwind-protect and live with the small
- 	     memory leak. */
  	  add_unwind_protect (xfree, debug_trap);
  	  add_unwind_protect (set_debug_trap, debug_trap);
--- 2891,2894 ----
***************
*** 2827,2830 ****
--- 2897,2911 ----
      }
  
+   if (error_trap)
+     {
+       if (subshell == 0)
+ 	{
+ 	  error_trap = savestring (error_trap);
+ 	  add_unwind_protect (xfree, error_trap);
+ 	  add_unwind_protect (set_error_trap, error_trap);
+ 	}
+       restore_default_signal (ERROR_TRAP);
+     }
+ 
    /* The temporary environment for a function is supposed to apply to
       all commands executed within the function body. */
***************
*** 2917,2921 ****
       WORD_LIST *words;
       REDIRECT *redirects;
!      Function *builtin;
       SHELL_VAR *var;
       int pipe_in, pipe_out, async;
--- 2998,3002 ----
       WORD_LIST *words;
       REDIRECT *redirects;
!      sh_builtin_func_t *builtin;
       SHELL_VAR *var;
       int pipe_in, pipe_out, async;
***************
*** 2996,3000 ****
  			     fds_to_close, flags)
       WORD_LIST *words;
!      Function *builtin;
       SHELL_VAR *var;
       REDIRECT *redirects;
--- 3077,3081 ----
  			     fds_to_close, flags)
       WORD_LIST *words;
!      sh_builtin_func_t *builtin;
       SHELL_VAR *var;
       REDIRECT *redirects;
***************
*** 3004,3008 ****
    int result;
    REDIRECT *saved_undo_list;
!   Function *saved_this_shell_builtin;
  
    if (do_redirections (redirects, 1, 1, 0) != 0)
--- 3085,3089 ----
    int result;
    REDIRECT *saved_undo_list;
!   sh_builtin_func_t *saved_this_shell_builtin;
  
    if (do_redirections (redirects, 1, 1, 0) != 0)
***************
*** 3156,3160 ****
  #if !defined (ARG_MAX) || ARG_MAX >= 10240
        if (posixly_correct == 0)
! 	put_gnu_argv_flags_into_env ((int)getpid (), glob_argv_flags);
  #endif
  #endif
--- 3237,3241 ----
  #if !defined (ARG_MAX) || ARG_MAX >= 10240
        if (posixly_correct == 0)
! 	put_gnu_argv_flags_into_env ((long)getpid (), glob_argv_flags);
  #endif
  #endif
***************
*** 3185,3193 ****
        do_piping (pipe_in, pipe_out);
  
        if (async)
! 	{
! 	  old_interactive = interactive;
! 	  interactive = 0;
! 	}
  
        subshell_environment = SUBSHELL_FORK;
--- 3266,3272 ----
        do_piping (pipe_in, pipe_out);
  
+       old_interactive = interactive;
        if (async)
! 	interactive = 0;
  
        subshell_environment = SUBSHELL_FORK;
***************
*** 3229,3243 ****
  }
  
- #if !defined (HAVE_HASH_BANG_EXEC)
- /* If the operating system on which we're running does not handle
-    the #! executable format, then help out.  SAMPLE is the text read
-    from the file, SAMPLE_LEN characters.  COMMAND is the name of
-    the script; it and ARGS, the arguments given by the user, will
-    become arguments to the specified interpreter.  ENV is the environment
-    to pass to the interpreter.
- 
-    The word immediately following the #! is the interpreter to execute.
-    A single argument to the interpreter is allowed. */
- 
  /* CPP defines to decide whether a particular index into the #! line
     corresponds to a valid interpreter name or argument character, or
--- 3308,3311 ----
***************
*** 3247,3273 ****
  #if !defined (MSDOS)
  #  define STRINGCHAR(ind) \
!     (!whitespace (sample[ind]) && sample[ind] != '\n' && ind < sample_len)
  #  define WHITECHAR(ind) \
!     (whitespace (sample[ind]) && sample[ind] != '\n' && ind < sample_len)
  #else	/* MSDOS */
  #  define STRINGCHAR(ind) \
!     (!whitespace (sample[ind]) && sample[ind] != '\n' && sample[ind] != '\r' && ind < sample_len)
  #  define WHITECHAR(ind) \
!     (whitespace (sample[ind]) && sample[ind] != '\n' && sample[ind] != '\r' && ind < sample_len)
  #endif	/* MSDOS */
  
! static int
! execute_shell_script (sample, sample_len, command, args, env)
!      unsigned char *sample;
!      int sample_len;
!      char *command;
!      char **args, **env;
  {
    register int i;
!   char *execname, *firstarg;
!   int start, size_increment, larry;
  
    /* Find the name of the interpreter to exec. */
!   for (i = 2; whitespace (sample[i]) && i < sample_len; i++)
      ;
  
--- 3315,3339 ----
  #if !defined (MSDOS)
  #  define STRINGCHAR(ind) \
!     (ind < sample_len && !whitespace (sample[ind]) && sample[ind] != '\n')
  #  define WHITECHAR(ind) \
!     (ind < sample_len && whitespace (sample[ind]))
  #else	/* MSDOS */
  #  define STRINGCHAR(ind) \
!     (ind < sample_len && !whitespace (sample[ind]) && sample[ind] != '\n' && sample[ind] != '\r')
  #  define WHITECHAR(ind) \
!     (ind < sample_len && whitespace (sample[ind]))
  #endif	/* MSDOS */
  
! static char *
! getinterp (sample, sample_len, endp)
!      char *sample;
!      int sample_len, *endp;
  {
    register int i;
!   char *execname;
!   int start;
  
    /* Find the name of the interpreter to exec. */
!   for (i = 2; i < sample_len && whitespace (sample[i]); i++)
      ;
  
***************
*** 3275,3279 ****
      ;
  
!   execname = substring ((char *)sample, start, i);
    size_increment = 1;
  
--- 3341,3374 ----
      ;
  
!   execname = substring (sample, start, i);
! 
!   if (endp)
!     *endp = i;
!   return execname;
! }
! 
! #if !defined (HAVE_HASH_BANG_EXEC)
! /* If the operating system on which we're running does not handle
!    the #! executable format, then help out.  SAMPLE is the text read
!    from the file, SAMPLE_LEN characters.  COMMAND is the name of
!    the script; it and ARGS, the arguments given by the user, will
!    become arguments to the specified interpreter.  ENV is the environment
!    to pass to the interpreter.
! 
!    The word immediately following the #! is the interpreter to execute.
!    A single argument to the interpreter is allowed. */
! 
! static int
! execute_shell_script (sample, sample_len, command, args, env)
!      char *sample;
!      int sample_len;
!      char *command;
!      char **args, **env;
! {
!   char *execname, *firstarg;
!   int i, start, size_increment, larry;
! 
!   /* Find the name of the interpreter to exec. */
!   execname = getinterp (sample, sample_len, &i);
    size_increment = 1;
  
***************
*** 3372,3376 ****
        if (fd >= 0) \
  	{ \
! 	  len = read (fd, (char *)buf, 80); \
  	  close (fd); \
  	} \
--- 3467,3471 ----
        if (fd >= 0) \
  	{ \
! 	  len = read (fd, buf, 80); \
  	  close (fd); \
  	} \
***************
*** 3389,3393 ****
    struct stat finfo;
    int larray, i, fd;
!   unsigned char sample[80];
    int sample_len;
  
--- 3484,3488 ----
    struct stat finfo;
    int larray, i, fd;
!   char sample[80];
    int sample_len;
  
***************
*** 3409,3414 ****
  	  if (sample_len > 2 && sample[0] == '#' && sample[1] == '!')
  	    {
  	      errno = i;
! 	      sys_error ("%s: bad interpreter", command);
  	      return (EX_NOEXEC);
  	    }
--- 3504,3513 ----
  	  if (sample_len > 2 && sample[0] == '#' && sample[1] == '!')
  	    {
+ 	      char *interp;
+ 
+ 	      interp = getinterp (sample, sample_len, (int *)NULL);
  	      errno = i;
! 	      sys_error ("%s: %s: bad interpreter", command, interp ? interp : "");
! 	      FREE (interp);
  	      return (EX_NOEXEC);
  	    }
***************
*** 3495,3498 ****
--- 3594,3598 ----
  
    longjmp (subshell_top_level, 1);
+   /*NOTREACHED*/
  }
  
diff -Nrc2 bash-2.05/execute_cmd.h bash-2.05a/execute_cmd.h
*** bash-2.05/execute_cmd.h	Thu Aug  5 07:05:25 1999
--- bash-2.05a/execute_cmd.h	Mon May  7 10:39:37 2001
***************
*** 24,28 ****
  #include "stdc.h"
  
! extern struct fd_bitmap *new_fd_bitmap __P((long));
  extern void dispose_fd_bitmap __P((struct fd_bitmap *));
  extern void close_fd_bitmap __P((struct fd_bitmap *));
--- 24,28 ----
  #include "stdc.h"
  
! extern struct fd_bitmap *new_fd_bitmap __P((int));
  extern void dispose_fd_bitmap __P((struct fd_bitmap *));
  extern void close_fd_bitmap __P((struct fd_bitmap *));
diff -Nrc2 bash-2.05/expr.c bash-2.05a/expr.c
*** bash-2.05/expr.c	Wed Feb 14 16:58:32 2001
--- bash-2.05a/expr.c	Mon Oct 15 14:19:21 2001
***************
*** 78,82 ****
  #endif
  
! #include <ctype.h>
  
  #include "shell.h"
--- 78,82 ----
  #endif
  
! #include "chartypes.h"
  
  #include "shell.h"
***************
*** 143,157 ****
  static int	assigntok;	/* the OP in OP= */
  static char	*tokstr;	/* current token string */
! static int	tokval;		/* current token value */
  static int	noeval;		/* set to 1 if no assignment to be done */
  static procenv_t evalbuf;
  
! static void	readtok ();	/* lexical analyzer */
! static long	subexpr (), expassign (), exp0 (), exp1 (), exp2 (), exp3 (),
! 		exp4 (), exp5 (), expshift (), expland (), explor (),
! 		expband (), expbor (), expbxor (), expcond (), exppower (),
! 		expcomma ();
! static long	strlong ();
! static void	evalerror ();
  
  /* A structure defining a single expression context. */
--- 143,175 ----
  static int	assigntok;	/* the OP in OP= */
  static char	*tokstr;	/* current token string */
! static long	tokval;		/* current token value */
  static int	noeval;		/* set to 1 if no assignment to be done */
  static procenv_t evalbuf;
  
! static void	readtok __P((void));	/* lexical analyzer */
! static long	strlong __P((char *));
! static void	evalerror __P((char *));
! 
! static void	pushexp __P((void));
! static void	popexp __P((void));
! 
! static long 	subexpr __P((char *));
! 
! static long	expcomma __P((void));
! static long 	expassign __P((void));
! static long	expcond __P((void));
! static long 	explor __P((void));
! static long 	expland __P((void));
! static long	expbor __P((void));
! static long	expbxor __P((void));
! static long	expband __P((void));
! static long 	exp5 __P((void));
! static long 	exp4 __P((void));
! static long 	expshift __P((void));
! static long 	exp3 __P((void));
! static long 	exp2 __P((void));
! static long	exppower __P((void));
! static long 	exp1 __P((void));
! static long 	exp0 __P((void));
  
  /* A structure defining a single expression context. */
***************
*** 159,171 ****
    int curtok, lasttok;
    char *expression, *tp, *lasttp;
!   int tokval;
    char *tokstr;
    int noeval;
  } EXPR_CONTEXT;
  
  typedef struct {
    char *tokstr;
!   int tokval;
  } LVALUE;
  
  /* Global var which contains the stack of expression contexts. */
--- 177,192 ----
    int curtok, lasttok;
    char *expression, *tp, *lasttp;
!   long tokval;
    char *tokstr;
    int noeval;
  } EXPR_CONTEXT;
  
+ #ifdef INCLUDE_UNUSED
+ /* Not used yet. */
  typedef struct {
    char *tokstr;
!   long tokval;
  } LVALUE;
+ #endif
  
  /* Global var which contains the stack of expression contexts. */
***************
*** 210,216 ****
    if (expr_depth >= expr_stack_size)
      {
!       expr_stack = (EXPR_CONTEXT **)
! 	xrealloc (expr_stack, (expr_stack_size += EXPR_STACK_GROW_SIZE)
! 		  * sizeof (EXPR_CONTEXT *));
      }
  
--- 231,236 ----
    if (expr_depth >= expr_stack_size)
      {
!       expr_stack_size += EXPR_STACK_GROW_SIZE;
!       expr_stack = (EXPR_CONTEXT **)xrealloc (expr_stack, expr_stack_size * sizeof (EXPR_CONTEXT *));
      }
  
***************
*** 264,268 ****
  #endif
  
!   val = 0L;
  
  #if 0
--- 284,288 ----
  #endif
  
!   val = 0;
  
  #if 0
***************
*** 292,296 ****
        if (validp)
  	*validp = 0;
!       return (0L);
      }
  
--- 312,316 ----
        if (validp)
  	*validp = 0;
!       return (0);
      }
  
***************
*** 320,324 ****
  
    if (p == NULL || *p == '\0')
!     return (0L);
  
    pushexp ();
--- 340,344 ----
  
    if (p == NULL || *p == '\0')
!     return (0);
  
    pushexp ();
***************
*** 328,332 ****
  
    tokstr = (char *)NULL;
!   tokval = 0L;
  
    readtok ();
--- 348,352 ----
  
    tokstr = (char *)NULL;
!   tokval = 0;
  
    readtok ();
***************
*** 459,467 ****
  	  noeval++;
  	}
! #if 0
!       val1 = explor ();
! #else
        val1 = EXP_HIGHEST ();
! #endif
        if (set_noeval)
  	noeval--;
--- 479,485 ----
  	  noeval++;
  	}
! 
        val1 = EXP_HIGHEST ();
! 
        if (set_noeval)
  	noeval--;
***************
*** 732,736 ****
        val2 = exp1 ();
        if (val2 == 0)
! 	return (1L);
        if (val2 < 0)
  	evalerror ("exponent less than 0");
--- 750,754 ----
        val2 = exp1 ();
        if (val2 == 0)
! 	return (1);
        if (val2 < 0)
  	evalerror ("exponent less than 0");
***************
*** 766,770 ****
  exp0 ()
  {
!   register long val = 0L, v2;
    char *vincdec;
    int stok;
--- 784,788 ----
  exp0 ()
  {
!   register long val = 0, v2;
    char *vincdec;
    int stok;
***************
*** 815,819 ****
        val = tokval;
        if (curtok == STR && (*tp == '+' || *tp == '-') && tp[1] == *tp &&
! 		(tp[2] == '\0' || (isalnum (tp[2]) == 0)))
  	{
  	  /* post-increment or post-decrement */
--- 833,837 ----
        val = tokval;
        if (curtok == STR && (*tp == '+' || *tp == '-') && tp[1] == *tp &&
! 		(tp[2] == '\0' || (ISALNUM ((unsigned char)tp[2]) == 0)))
  	{
  	  /* post-increment or post-decrement */
***************
*** 843,847 ****
  {
    register char *cp;
!   register int c, c1, e;
  
    /* Skip leading whitespace. */
--- 861,866 ----
  {
    register char *cp;
!   register unsigned char c, c1;
!   register int e;
  
    /* Skip leading whitespace. */
***************
*** 930,936 ****
        curtok = STR;
      }
!   else if (digit(c))
      {
!       while (digit (c) || isletter (c) || c == '#' || c == '@' || c == '_')
  	c = *cp++;
  
--- 949,955 ----
        curtok = STR;
      }
!   else if (DIGIT(c))
      {
!       while (ISALNUM (c) || c == '#' || c == '@' || c == '_')
  	c = *cp++;
  
***************
*** 982,988 ****
        else if ((c == '*') && (c1 == '*'))
  	c = POWER;
!       else if ((c == '-') && (c1 == '-') && legal_variable_starter (*cp))
  	c = PREDEC;
!       else if ((c == '+') && (c1 == '+') && legal_variable_starter (*cp))
  	c = PREINC;
        else if (c1 == EQ && member (c, "*/%+-&^|"))
--- 1001,1007 ----
        else if ((c == '*') && (c1 == '*'))
  	c = POWER;
!       else if ((c == '-') && (c1 == '-') && legal_variable_starter ((unsigned char)*cp))
  	c = PREDEC;
!       else if ((c == '+') && (c1 == '+') && legal_variable_starter ((unsigned char)*cp))
  	c = PREINC;
        else if (c1 == EQ && member (c, "*/%+-&^|"))
***************
*** 1030,1040 ****
  {
    register char *s;
!   register int c;
    int base, foundbase;
!   long val = 0L;
  
    s = num;
-   if (s == NULL || *s == '\0')
-     return 0L;
  
    base = 10;
--- 1049,1057 ----
  {
    register char *s;
!   register unsigned char c;
    int base, foundbase;
!   long val;
  
    s = num;
  
    base = 10;
***************
*** 1044,1049 ****
        s++;
  
!       if (s == NULL || *s == '\0')
! 	return 0L;
  
         /* Base 16? */
--- 1061,1066 ----
        s++;
  
!       if (*s == '\0')
! 	return 0;
  
         /* Base 16? */
***************
*** 1058,1062 ****
      }
  
!   val = 0L;
    for (c = *s++; c; c = *s++)
      {
--- 1075,1079 ----
      }
  
!   val = 0;
    for (c = *s++; c; c = *s++)
      {
***************
*** 1066,1089 ****
  	    evalerror ("bad number");
  
- 	  base = (int)val;
- 
  	  /* Illegal base specifications raise an evaluation error. */
! 	  if (base < 2 || base > 64)
  	    evalerror ("illegal arithmetic base");
  
! 	  val = 0L;
  	  foundbase++;
  	}
!       else if (isletter(c) || digit(c) || (c == '_') || (c == '@'))
  	{
! 	  if (digit(c))
! 	    c = digit_value(c);
  	  else if (c >= 'a' && c <= 'z')
  	    c -= 'a' - 10;
  	  else if (c >= 'A' && c <= 'Z')
  	    c -= 'A' - ((base <= 36) ? 10 : 36);
- 	  else if (c == '_')
- 	    c = 62;
  	  else if (c == '@')
  	    c = 63;
  
--- 1083,1105 ----
  	    evalerror ("bad number");
  
  	  /* Illegal base specifications raise an evaluation error. */
! 	  if (val < 2 || val > 64)
  	    evalerror ("illegal arithmetic base");
  
! 	  base = val;
! 	  val = 0;
  	  foundbase++;
  	}
!       else if (ISALNUM(c) || (c == '_') || (c == '@'))
  	{
! 	  if (DIGIT(c))
! 	    c = TODIGIT(c);
  	  else if (c >= 'a' && c <= 'z')
  	    c -= 'a' - 10;
  	  else if (c >= 'A' && c <= 'Z')
  	    c -= 'A' - ((base <= 36) ? 10 : 36);
  	  else if (c == '@')
+ 	    c = 62;
+ 	  else if (c == '_')
  	    c = 63;
  
***************
*** 1100,1104 ****
  
  #if defined (EXPR_TEST)
! char *
  xmalloc (n)
       int n;
--- 1116,1120 ----
  
  #if defined (EXPR_TEST)
! void *
  xmalloc (n)
       int n;
***************
*** 1107,1111 ****
  }
  
! char *
  xrealloc (s, n)
       char *s;
--- 1123,1127 ----
  }
  
! void *
  xrealloc (s, n)
       char *s;
***************
*** 1156,1160 ****
  char *
  itos (n)
!      int n;
  {
    return ("42");
--- 1172,1176 ----
  char *
  itos (n)
!      long n;
  {
    return ("42");
diff -Nrc2 bash-2.05/externs.h bash-2.05a/externs.h
*** bash-2.05/externs.h	Fri Nov  3 11:25:31 2000
--- bash-2.05a/externs.h	Wed Oct 31 15:46:51 2001
***************
*** 45,49 ****
  
  /* Functions from shell.c. */
! extern void exit_shell __P((int));
  extern void disable_priv_mode __P((void));
  extern void unbind_args __P((void));
--- 45,49 ----
  
  /* Functions from shell.c. */
! extern void exit_shell __P((int)) __attribute__((__noreturn__));
  extern void disable_priv_mode __P((void));
  extern void unbind_args __P((void));
***************
*** 69,81 ****
  /* Miscellaneous functions from parse.y */
  extern int yyparse __P((void));
  extern void reset_parser __P((void));
! extern WORD_LIST *parse_string_to_word_list __P((char *, char *));
  
  extern int get_current_prompt_level __P((void));
  extern void set_current_prompt_level __P((int));
  
! /* Functions from version.c. */
! extern char *shell_version_string __P((void));
! extern void show_shell_version __P((int));
  
  /* Declarations for functions defined in locale.c */
--- 69,82 ----
  /* Miscellaneous functions from parse.y */
  extern int yyparse __P((void));
+ extern int return_EOF __P((void));
  extern void reset_parser __P((void));
! extern WORD_LIST *parse_string_to_word_list __P((char *, const char *));
  
  extern int get_current_prompt_level __P((void));
  extern void set_current_prompt_level __P((int));
  
! #if defined (HISTORY)
! extern char *history_delimiting_chars __P((void));
! #endif
  
  /* Declarations for functions defined in locale.c */
***************
*** 88,93 ****
  
  /* Declarations for functions defined in list.c. */
! extern void map_over_list __P((GENERIC_LIST *, Function *));
! extern void map_over_words __P((WORD_LIST *, Function *));
  extern GENERIC_LIST *reverse_list ();
  extern int list_length ();
--- 89,94 ----
  
  /* Declarations for functions defined in list.c. */
! extern void map_over_list __P((GENERIC_LIST *, sh_glist_func_t *));
! extern void map_over_words __P((WORD_LIST *, sh_icpfunc_t *));
  extern GENERIC_LIST *reverse_list ();
  extern int list_length ();
***************
*** 117,120 ****
--- 118,134 ----
  extern void print_clock_t ();
  
+ /* Declarations for functions defined in lib/sh/fmtulong.c */
+ #define FL_PREFIX     0x01    /* add 0x, 0X, or 0 prefix as appropriate */
+ #define FL_ADDBASE    0x02    /* add base# prefix to converted value */
+ #define FL_HEXUPPER   0x04    /* use uppercase when converting to hex */
+ #define FL_UNSIGNED   0x08    /* don't add any sign */
+ 
+ extern char *fmtulong __P((unsigned long int, int, char *, size_t, int));
+ 
+ /* Declarations for functions defined in lib/sh/fmtulong.c */
+ #if defined (HAVE_LONG_LONG)
+ extern char *fmtullong __P((unsigned long long int, int, char *, size_t, int));
+ #endif
+ 
  /* Declarations for functions defined in lib/sh/getcwd.c */
  #if !defined (HAVE_GETCWD)
***************
*** 123,128 ****
  
  /* Declarations for functions defined in lib/sh/itos.c */
! extern char *inttostr __P((int, char *, int));
! extern char *itos __P((int));
  
  /* declarations for functions defined in lib/sh/makepath.c */
--- 137,144 ----
  
  /* Declarations for functions defined in lib/sh/itos.c */
! extern char *inttostr __P((long, char *, size_t));
! extern char *itos __P((long));
! extern char *uinttostr __P((unsigned long, char *, size_t));
! extern char *uitos __P((unsigned long));
  
  /* declarations for functions defined in lib/sh/makepath.c */
***************
*** 131,135 ****
  #define MP_RMDOT	0x04
  
! extern char *sh_makepath __P((char *, char *, int));
  
  /* declarations for functions defined in lib/sh/netopen.c */
--- 147,151 ----
  #define MP_RMDOT	0x04
  
! extern char *sh_makepath __P((const char *, const char *, int));
  
  /* declarations for functions defined in lib/sh/netopen.c */
***************
*** 161,166 ****
  
  /* declarations for functions defined in lib/sh/setlinebuf.c */
! #if !defined (HAVE_SETLINEBUF)
! extern int setlinebuf ();
  #endif
  
--- 177,182 ----
  
  /* declarations for functions defined in lib/sh/setlinebuf.c */
! #ifdef NEED_SH_SETLINEBUF_DECL
! extern int sh_setlinebuf __P((FILE *));
  #endif
  
***************
*** 217,221 ****
  extern void free_array __P((char **));
  extern char **copy_array __P((char **));
! extern int qsort_string_compare ();
  extern void sort_char_array __P((char **));
  
--- 233,237 ----
  extern void free_array __P((char **));
  extern char **copy_array __P((char **));
! extern int qsort_string_compare __P((char **, char **));
  extern void sort_char_array __P((char **));
  
***************
*** 226,241 ****
  
  /* declarations for functions defined in lib/sh/strtol.c */
! #if !defined (HAVE_STRTOL)
  extern long strtol __P((const char *, char **, int));
  #endif
  
  /* declarations for functions defined in lib/sh/strtoul.c */
! #if !defined (HAVE_STRTOUL)
  extern unsigned long strtoul __P((const char *, char **, int));
  #endif
  
  /* declarations for functions defined in lib/sh/strtrans.c */
  extern char *ansicstr __P((char *, int, int, int *, int *));
  extern char *ansic_quote __P((char *, int, int *));
  
  /* declarations for functions defined in lib/sh/timeval.c.  No prototypes
--- 242,282 ----
  
  /* declarations for functions defined in lib/sh/strtol.c */
! #if !HAVE_DECL_STRTOL
  extern long strtol __P((const char *, char **, int));
  #endif
  
+ /* declarations for functions defined in lib/sh/strtoll.c */
+ #if defined (HAVE_LONG_LONG) && !HAVE_DECL_STRTOLL
+ extern long long strtoll __P((const char *, char **, int));
+ #endif
+ 
  /* declarations for functions defined in lib/sh/strtoul.c */
! #if !HAVE_DECL_STRTOUL
  extern unsigned long strtoul __P((const char *, char **, int));
  #endif
  
+ /* declarations for functions defined in lib/sh/strtoull.c */
+ #if defined (HAVE_LONG_LONG) && !HAVE_DECL_STRTOULL
+ extern unsigned long long strtoull __P((const char *, char **, int));
+ #endif
+ 
+ /* declarations for functions defined in lib/sh/strimax.c */
+ #ifdef NEED_STRTOIMAX_DECL
+ 
+ #if !HAVE_DECL_STRTOIMAX
+ extern intmax_t strtoimax __P((const char *, char **, int));
+ #endif
+ 
+ /* declarations for functions defined in lib/sh/strumax.c */
+ #if !HAVE_DECL_STRTOUMAX
+ extern uintmax_t strtoumax __P((const char *, char **, int));
+ #endif
+ 
+ #endif /* NEED_STRTOIMAX_DECL */
+ 
  /* declarations for functions defined in lib/sh/strtrans.c */
  extern char *ansicstr __P((char *, int, int, int *, int *));
  extern char *ansic_quote __P((char *, int, int *));
+ extern int ansic_shouldquote __P((const char *));
  
  /* declarations for functions defined in lib/sh/timeval.c.  No prototypes
***************
*** 255,266 ****
  
  /* declarations for functions defined in lib/sh/zread.c */
! extern int zread __P((int, char *, size_t));
! extern int zread1 __P((int, char *, size_t));
! extern int zreadc __P((int, char *));
  extern void zreset __P((void));
  extern void zsyncfd __P((int));
  
  /* declarations for functions defined in lib/sh/zwrite.c */
! extern int zwrite __P((int, unsigned char *, size_t));
  
  #endif /* _EXTERNS_H_ */
--- 296,307 ----
  
  /* declarations for functions defined in lib/sh/zread.c */
! extern ssize_t zread __P((int, char *, size_t));
! extern ssize_t zread1 __P((int, char *, size_t));
! extern ssize_t zreadc __P((int, char *));
  extern void zreset __P((void));
  extern void zsyncfd __P((int));
  
  /* declarations for functions defined in lib/sh/zwrite.c */
! extern int zwrite __P((int, char *, size_t));
  
  #endif /* _EXTERNS_H_ */
diff -Nrc2 bash-2.05/findcmd.c bash-2.05a/findcmd.c
*** bash-2.05/findcmd.c	Tue Feb 20 15:19:10 2001
--- bash-2.05a/findcmd.c	Thu Sep 13 15:51:06 2001
***************
*** 23,27 ****
  
  #include <stdio.h>
! #include <ctype.h>
  #include "bashtypes.h"
  #ifndef _MINIX
--- 23,27 ----
  
  #include <stdio.h>
! #include "chartypes.h"
  #include "bashtypes.h"
  #ifndef _MINIX
***************
*** 35,42 ****
  #endif
  
- #if defined (HAVE_LIMITS_H)
- #  include <limits.h>
- #endif
- 
  #include "bashansi.h"
  
--- 35,38 ----
***************
*** 47,56 ****
  #include "pathexp.h"
  #include "hashcmd.h"
  
  extern int posixly_correct;
  
  /* Static functions defined and used in this file. */
! static char *find_user_command_internal (), *find_user_command_in_path ();
! static char *find_in_path_element (), *find_absolute_program ();
  
  /* The file name which we would try to execute, except that it isn't
--- 43,58 ----
  #include "pathexp.h"
  #include "hashcmd.h"
+ #include "findcmd.h"	/* matching prototypes and declarations */
  
  extern int posixly_correct;
  
  /* Static functions defined and used in this file. */
! static char *_find_user_command_internal __P((const char *, int));
! static char *find_user_command_internal __P((const char *, int));
! static char *find_user_command_in_path __P((const char *, char *, int));
! static char *find_in_path_element __P((const char *, char *, int, int, struct stat *));
! static char *find_absolute_program __P((const char *, int));
! 
! static char *get_next_path_element __P((char *, int *));
  
  /* The file name which we would try to execute, except that it isn't
***************
*** 82,86 ****
  int
  file_status (name)
!      char *name;
  {
    struct stat finfo;
--- 84,88 ----
  int
  file_status (name)
!      const char *name;
  {
    struct stat finfo;
***************
*** 146,150 ****
  int
  executable_file (file)
!      char *file;
  {
    int s;
--- 148,152 ----
  int
  executable_file (file)
!      const char *file;
  {
    int s;
***************
*** 156,160 ****
  int
  is_directory (file)
!      char *file;
  {
    return (file_status (file) & FS_DIRECTORY);
--- 158,162 ----
  int
  is_directory (file)
!      const char *file;
  {
    return (file_status (file) & FS_DIRECTORY);
***************
*** 163,167 ****
  int
  executable_or_directory (file)
!      char *file;
  {
    int s;
--- 165,169 ----
  int
  executable_or_directory (file)
!      const char *file;
  {
    int s;
***************
*** 178,182 ****
  char *
  find_user_command (name)
!      char *name;
  {
    return (find_user_command_internal (name, FS_EXEC_PREFERRED|FS_NODIRS));
--- 180,184 ----
  char *
  find_user_command (name)
!      const char *name;
  {
    return (find_user_command_internal (name, FS_EXEC_PREFERRED|FS_NODIRS));
***************
*** 189,193 ****
  char *
  find_path_file (name)
!      char *name;
  {
    return (find_user_command_internal (name, FS_EXISTS));
--- 191,195 ----
  char *
  find_path_file (name)
!      const char *name;
  {
    return (find_user_command_internal (name, FS_EXISTS));
***************
*** 196,200 ****
  static char *
  _find_user_command_internal (name, flags)
!      char *name;
       int flags;
  {
--- 198,202 ----
  static char *
  _find_user_command_internal (name, flags)
!      const char *name;
       int flags;
  {
***************
*** 222,226 ****
  static char *
  find_user_command_internal (name, flags)
!      char *name;
       int flags;
  {
--- 224,228 ----
  static char *
  find_user_command_internal (name, flags)
!      const char *name;
       int flags;
  {
***************
*** 228,232 ****
    char *res, *dotexe;
  
!   dotexe = xmalloc (strlen (name) + 5);
    strcpy (dotexe, name);
    strcat (dotexe, ".exe");
--- 230,234 ----
    char *res, *dotexe;
  
!   dotexe = (char *)xmalloc (strlen (name) + 5);
    strcpy (dotexe, name);
    strcat (dotexe, ".exe");
***************
*** 271,275 ****
  char *
  search_for_command (pathname)
!      char *pathname;
  {
    char *hashed_file, *command;
--- 273,277 ----
  char *
  search_for_command (pathname)
!      const char *pathname;
  {
    char *hashed_file, *command;
***************
*** 325,329 ****
  	command = find_user_command (pathname);
        if (command && hashing_enabled && temp_path == 0)
! 	remember_filename (pathname, command, dot_found_in_search, 1);
      }
    return (command);
--- 327,331 ----
  	command = find_user_command (pathname);
        if (command && hashing_enabled && temp_path == 0)
! 	remember_filename ((char *)pathname, command, dot_found_in_search, 1);	/* XXX fix const later */
      }
    return (command);
***************
*** 332,336 ****
  char *
  user_command_matches (name, flags, state)
!      char *name;
       int flags, state;
  {
--- 334,338 ----
  char *
  user_command_matches (name, flags, state)
!      const char *name;
       int flags, state;
  {
***************
*** 415,419 ****
  static char *
  find_absolute_program (name, flags)
!      char *name;
       int flags;
  {
--- 417,421 ----
  static char *
  find_absolute_program (name, flags)
!      const char *name;
       int flags;
  {
***************
*** 432,441 ****
      return (savestring (name));
  
!   return ((char *)NULL);
  }
  
  static char *
  find_in_path_element (name, path, flags, name_len, dotinfop)
!      char *name, *path;
       int flags, name_len;
       struct stat *dotinfop;
--- 434,444 ----
      return (savestring (name));
  
!   return (NULL);
  }
  
  static char *
  find_in_path_element (name, path, flags, name_len, dotinfop)
!      const char *name;
!      char *path;
       int flags, name_len;
       struct stat *dotinfop;
***************
*** 510,514 ****
  static char *
  find_user_command_in_path (name, path_list, flags)
!      char *name;
       char *path_list;
       int flags;
--- 513,517 ----
  static char *
  find_user_command_in_path (name, path_list, flags)
!      const char *name;
       char *path_list;
       int flags;
diff -Nrc2 bash-2.05/findcmd.h bash-2.05a/findcmd.h
*** bash-2.05/findcmd.h	Tue Feb 20 15:14:09 2001
--- bash-2.05a/findcmd.h	Thu Sep 13 15:24:53 2001
***************
*** 24,35 ****
  #include "stdc.h"
  
! extern int file_status __P((char *));
! extern int executable_file __P((char *));
! extern int is_directory __P((char *));
! extern int executable_or_directory __P((char *));
! extern char *find_user_command __P((char *));
! extern char *find_path_file __P((char *));
! extern char *search_for_command __P((char *));
! extern char *user_command_matches __P((char *, int, int));
  
  #endif /* _FINDCMD_H_ */
--- 24,35 ----
  #include "stdc.h"
  
! extern int file_status __P((const char *));
! extern int executable_file __P((const char *));
! extern int is_directory __P((const char *));
! extern int executable_or_directory __P((const char *));
! extern char *find_user_command __P((const char *));
! extern char *find_path_file __P((const char *));
! extern char *search_for_command __P((const char *));
! extern char *user_command_matches __P((const char *, int, int));
  
  #endif /* _FINDCMD_H_ */
diff -Nrc2 bash-2.05/flags.c bash-2.05a/flags.c
*** bash-2.05/flags.c	Wed Feb 14 16:58:48 2001
--- bash-2.05a/flags.c	Mon Sep 24 08:16:35 2001
***************
*** 29,34 ****
  #include "flags.h"
  
  #if defined (JOB_CONTROL)
! extern int set_job_control ();
  #endif
  
--- 29,38 ----
  #include "flags.h"
  
+ #if defined (BANG_HISTORY)
+ #  include "bashhist.h"
+ #endif
+ 
  #if defined (JOB_CONTROL)
! extern int set_job_control __P((int));
  #endif
  
***************
*** 68,72 ****
  /* Non-zero means read commands, but don't execute them.  This is useful
     for debugging shell scripts that should do something hairy and possibly
!    desctructive. */
  int read_but_dont_execute = 0;
  
--- 72,76 ----
  /* Non-zero means read commands, but don't execute them.  This is useful
     for debugging shell scripts that should do something hairy and possibly
!    destructive. */
  int read_but_dont_execute = 0;
  
***************
*** 241,244 ****
--- 245,255 ----
    switch (flag)
      {
+ #if defined (BANG_HISTORY)
+     case 'H':
+       if (on_or_off == FLAG_ON)
+ 	bash_initialize_history ();
+       break;
+ #endif
+ 
  #if defined (JOB_CONTROL)
      case 'm':
***************
*** 247,269 ****
  #endif /* JOB_CONTROL */
  
! #if defined (RESTRICTED_SHELL)
!     case 'r':
!       if (on_or_off == FLAG_ON)
! 	maybe_make_restricted (shell_name);
        break;
- #endif
- 
- #if defined (BANG_HISTORY)
-     case 'H':
-       if (on_or_off == FLAG_ON)
- 	bash_initialize_history ();
-       break;
- #endif
  
      case 'p':
        if (on_or_off == FLAG_OFF)
  	disable_priv_mode ();
  
        break;
      }
  
--- 258,278 ----
  #endif /* JOB_CONTROL */
  
!     case 'n':
!       if (interactive_shell)
! 	read_but_dont_execute = 0;
        break;
  
      case 'p':
        if (on_or_off == FLAG_OFF)
  	disable_priv_mode ();
+       break;
  
+ #if defined (RESTRICTED_SHELL)
+     case 'r':
+       if (on_or_off == FLAG_ON)
+ 	maybe_make_restricted (shell_name);
        break;
+ #endif
+ 
      }
  
***************
*** 279,283 ****
    int i, string_index;
  
!   temp = xmalloc (1 + NUM_SHELL_FLAGS + read_from_stdin + want_pending_command);
    for (i = string_index = 0; shell_flags[i].name; i++)
      if (*(shell_flags[i].value))
--- 288,292 ----
    int i, string_index;
  
!   temp = (char *)xmalloc (1 + NUM_SHELL_FLAGS + read_from_stdin + want_pending_command);
    for (i = string_index = 0; shell_flags[i].name; i++)
      if (*(shell_flags[i].value))
diff -Nrc2 bash-2.05/general.c bash-2.05a/general.c
*** bash-2.05/general.c	Wed Feb 28 13:23:24 2001
--- bash-2.05a/general.c	Mon Nov  5 17:14:19 2001
***************
*** 34,38 ****
  #include "bashansi.h"
  #include <stdio.h>
! #include <ctype.h>
  #include <errno.h>
  
--- 34,38 ----
  #include "bashansi.h"
  #include <stdio.h>
! #include "chartypes.h"
  #include <errno.h>
  
***************
*** 40,55 ****
  #include <tilde/tilde.h>
  
- #include "maxpath.h"
- 
  #if !defined (errno)
  extern int errno;
  #endif /* !errno */
  
! #ifndef to_upper
! #  define to_upper(c) (islower(c) ? toupper(c) : (c))
! #  define to_lower(c) (isupper(c) ? tolower(c) : (c))
! #endif
! 
! extern int interactive_shell, expand_aliases;
  extern int interrupt_immediately;
  extern int interactive_comments;
--- 40,48 ----
  #include <tilde/tilde.h>
  
  #if !defined (errno)
  extern int errno;
  #endif /* !errno */
  
! extern int expand_aliases;
  extern int interrupt_immediately;
  extern int interactive_comments;
***************
*** 103,108 ****
        s++;
      }
!   for ( ; s && *s && digit (*s); s++)
!     ret = (ret * 10) + digit_value (*s);
    return (neg ? -ret : ret);
  }
--- 96,101 ----
        s++;
      }
!   for ( ; s && *s && DIGIT (*s); s++)
!     ret = (ret * 10) + TODIGIT (*s);
    return (neg ? -ret : ret);
  }
***************
*** 113,136 ****
       int addnl;
  {
!   char s[sizeof (RLIMTYPE) * 3 + 1];
!   int len;
  
!   if (n == 0)
!     {
!       printf ("0%s", addnl ? "\n" : "");
!       return;
!     }
  
    if (n < 0)
      {
!       putchar ('-');
!       n = -n;
      }
  
!   len = sizeof (RLIMTYPE) * 3 + 1;
!   s[--len] = '\0';
!   for ( ; n != 0; n /= 10)
!     s[--len] = n % 10 + '0';
!   printf ("%s%s", s + len, addnl ? "\n" : "");
  }
  #endif /* RLIMTYPE */
--- 106,130 ----
       int addnl;
  {
!   char s[INT_STRLEN_BOUND (RLIMTYPE) + 1], *p;
  
!   p = s + sizeof(s);
!   *--p = '\0';
  
    if (n < 0)
      {
!       do
! 	*--p = '0' - n % 10;
!       while ((n /= 10) != 0);
! 
!       *--p = '-';
!     }
!   else
!     {
!       do
! 	*--p = '0' + n % 10;
!       while ((n /= 10) != 0);
      }
  
!   printf ("%s%s", p, addnl ? "\n" : "");
  }
  #endif /* RLIMTYPE */
***************
*** 150,154 ****
  
    for (s = string; *s; s++)
!     if (isdigit (*s) == 0)
        return (0);
  
--- 144,148 ----
  
    for (s = string; *s; s++)
!     if (DIGIT (*s) == 0)
        return (0);
  
***************
*** 158,162 ****
  /* Return non-zero if the characters pointed to by STRING constitute a
     valid number.  Stuff the converted number into RESULT if RESULT is
!    a non-null pointer to a long. */
  int
  legal_number (string, result)
--- 152,156 ----
  /* Return non-zero if the characters pointed to by STRING constitute a
     valid number.  Stuff the converted number into RESULT if RESULT is
!    not null. */
  int
  legal_number (string, result)
***************
*** 170,174 ****
--- 164,171 ----
      *result = 0;
  
+   errno = 0;
    value = strtol (string, &ep, 10);
+   if (errno)
+     return 0;	/* errno is set on overflow or underflow */
  
    /* Skip any trailing whitespace, since strtol does not. */
***************
*** 199,209 ****
  {
    register char *s;
  
!   if (!name || !*name || (legal_variable_starter (*name) == 0))
      return (0);
  
!   for (s = name + 1; *s; s++)
      {
!       if (legal_variable_char (*s) == 0)
  	return (0);
      }
--- 196,207 ----
  {
    register char *s;
+   unsigned char c;
  
!   if (!name || !(c = *name) || (legal_variable_starter (c) == 0))
      return (0);
  
!   for (s = name + 1; (c = *s) != 0; s++)
      {
!       if (legal_variable_char (c) == 0)
  	return (0);
      }
***************
*** 380,404 ****
     All of the characters must be printable or whitespace. */
  
- #if !defined (isspace)
- #define isspace(c) ((c) == ' ' || (c) == '\t' || (c) == '\n' || (c) == '\f')
- #endif
- 
- #if !defined (isprint)
- #define isprint(c) (isletter(c) || digit(c) || ispunct(c))
- #endif
- 
  int
  check_binary_file (sample, sample_len)
!      unsigned char *sample;
       int sample_len;
  {
    register int i;
  
    for (i = 0; i < sample_len; i++)
      {
!       if (sample[i] == '\n')
  	return (0);
  
!       if (isspace (sample[i]) == 0 && isprint (sample[i]) == 0)
  	return (1);
      }
--- 378,396 ----
     All of the characters must be printable or whitespace. */
  
  int
  check_binary_file (sample, sample_len)
!      char *sample;
       int sample_len;
  {
    register int i;
+   unsigned char c;
  
    for (i = 0; i < sample_len; i++)
      {
!       c = sample[i];
!       if (c == '\n')
  	return (0);
  
!       if (ISSPACE (c) == 0 && ISPRINT (c) == 0)
  	return (1);
      }
***************
*** 435,439 ****
  int
  absolute_pathname (string)
!      char *string;
  {
    if (string == 0 || *string == '\0')
--- 427,431 ----
  int
  absolute_pathname (string)
!      const char *string;
  {
    if (string == 0 || *string == '\0')
***************
*** 457,461 ****
  int
  absolute_program (string)
!      char *string;
  {
    return ((char *)strchr (string, '/') != (char *)NULL);
--- 449,453 ----
  int
  absolute_program (string)
!      const char *string;
  {
    return ((char *)strchr (string, '/') != (char *)NULL);
***************
*** 562,566 ****
  	(*p_index)++;
        /* Return "" in the case of a trailing `:'. */
!       value = xmalloc (1);
        value[0] = '\0';
      }
--- 554,558 ----
  	(*p_index)++;
        /* Return "" in the case of a trailing `:'. */
!       value = (char *)xmalloc (1);
        value[0] = '\0';
      }
***************
*** 581,584 ****
--- 573,580 ----
  #endif
  
+ /* Reserved for post-bash-2.05a */
+ static char **bash_tilde_prefixes;
+ static char **bash_tilde_suffixes;
+ 
  /* If tilde_expand hasn't been able to expand the text, perhaps it
     is a special shell expansion.  This function is installed as the
***************
*** 599,603 ****
      result = get_string_value ("OLDPWD");
  #if defined (PUSHD_AND_POPD)
!   else if (isdigit (*text) || ((*text == '+' || *text == '-') && isdigit (text[1])))
      result = get_dirstack_from_string (text);
  #endif
--- 595,599 ----
      result = get_string_value ("OLDPWD");
  #if defined (PUSHD_AND_POPD)
!   else if (DIGIT (*text) || ((*text == '+' || *text == '-') && DIGIT (text[1])))
      result = get_dirstack_from_string (text);
  #endif
***************
*** 615,619 ****
  
    /* Tell the tilde expander that we want a crack first. */
!   tilde_expansion_preexpansion_hook = (CPFunction *)bash_special_tilde_expansions;
  
    /* Tell the tilde expander about special strings which start a tilde
--- 611,615 ----
  
    /* Tell the tilde expander that we want a crack first. */
!   tilde_expansion_preexpansion_hook = bash_special_tilde_expansions;
  
    /* Tell the tilde expander about special strings which start a tilde
***************
*** 622,647 ****
    if (times_called++ == 0)
      {
!       tilde_additional_prefixes = alloc_array (3);
!       tilde_additional_prefixes[0] = "=~";
!       tilde_additional_prefixes[1] = ":~";
!       tilde_additional_prefixes[2] = (char *)NULL;
! 
!       tilde_additional_suffixes = alloc_array (3);
!       tilde_additional_suffixes[0] = ":";
!       tilde_additional_suffixes[1] = "=~";
!       tilde_additional_suffixes[2] = (char *)NULL;
      }
  }
  
  char *
  bash_tilde_expand (s)
!      char *s;
  {
!   int old_immed;
    char *ret;
  
    old_immed = interrupt_immediately;
    interrupt_immediately = 1;
!   ret = tilde_expand (s);
    interrupt_immediately = old_immed;
    return (ret);
--- 618,677 ----
    if (times_called++ == 0)
      {
!       bash_tilde_prefixes = alloc_array (3);
!       bash_tilde_prefixes[0] = "=~";
!       bash_tilde_prefixes[1] = ":~";
!       bash_tilde_prefixes[2] = (char *)NULL;
! 
!       tilde_additional_prefixes = bash_tilde_prefixes;
! 
!       bash_tilde_suffixes = alloc_array (3);
!       bash_tilde_suffixes[0] = ":";
!       bash_tilde_suffixes[1] = "=~";	/* XXX - ?? */
!       bash_tilde_suffixes[2] = (char *)NULL;
! 
!       tilde_additional_suffixes = bash_tilde_suffixes;
      }
  }
  
+ /* POSIX.2, 3.6.1:  A tilde-prefix consists of an unquoted tilde character
+    at the beginning of the word, followed by all of the characters preceding
+    the first unquoted slash in the word, or all the characters in the word
+    if there is no slash...If none of the characters in the tilde-prefix are
+    quoted, the characters in the tilde-prefix following the tilde shell be
+    treated as a possible login name. */
+ 
+ #define TILDE_END(c)	((c) == '\0' || (c) == '/' || (c) == ':')
+ 
+ static int
+ unquoted_tilde_word (s)
+      const char *s;
+ {
+   const char *r;
+ 
+   for (r = s; TILDE_END(*r) == 0; r++)
+     {
+       switch (*r)
+ 	{
+ 	case '\\':
+ 	case '\'':
+ 	case '"':
+ 	  return 0;
+ 	}
+     }
+   return 1;
+ }
+ 
+ /* Tilde-expand S by running it through the tilde expansion library. */
  char *
  bash_tilde_expand (s)
!      const char *s;
  {
!   int old_immed, r;
    char *ret;
  
    old_immed = interrupt_immediately;
    interrupt_immediately = 1;
!   r = (*s == '~') ? unquoted_tilde_word (s) : 1;
!   ret = r ? tilde_expand (s) : savestring (s);
    interrupt_immediately = old_immed;
    return (ret);
***************
*** 791,795 ****
    for (i = 0; i < ngroups; i++)
      {
!       nbuf = itos ((int)group_array[i]);
        group_vector[i] = nbuf;
      }
--- 821,825 ----
    for (i = 0; i < ngroups; i++)
      {
!       nbuf = itos (group_array[i]);
        group_vector[i] = nbuf;
      }
diff -Nrc2 bash-2.05/general.h bash-2.05a/general.h
*** bash-2.05/general.h	Wed Feb 14 16:53:05 2001
--- bash-2.05a/general.h	Mon Oct 15 13:52:31 2001
***************
*** 39,49 ****
  #endif /* !HAVE_STRING_H */
  
! /* Generic pointer type. */
! #if defined (__STDC__)
! #  define PTR_T	void *
! #else
! #  define PTR_T char *
  #endif
  
  /* NULL pointer type. */
  #if !defined (NULL)
--- 39,48 ----
  #endif /* !HAVE_STRING_H */
  
! #if defined (HAVE_LIMITS_H)
! #  include <limits.h>
  #endif
  
+ #include "xmalloc.h"
+ 
  /* NULL pointer type. */
  #if !defined (NULL)
***************
*** 57,62 ****
  #define pointer_to_int(x) (int)((long)(x))
  
- extern char *xmalloc (), *xrealloc ();
- 
  #if defined (alpha) && defined (__GNUC__) && !defined (strchr) && !defined (__STDC__)
  extern char *strchr (), *strrchr ();
--- 56,59 ----
***************
*** 64,68 ****
  
  #if !defined (strcpy)
! extern char *strcpy ();
  #endif
  
--- 61,65 ----
  
  #if !defined (strcpy)
! extern char *strcpy __P((char *, const char *));
  #endif
  
***************
*** 79,101 ****
  #endif
  
! #ifndef digit
! #define digit(c)  (isdigit(c))
  #endif
  
! #ifndef isletter
! #define isletter(c) (isalpha(c))
  #endif
  
! #ifndef digit_value
! #define digit_value(c) ((c) - '0')
! #endif
  
- #ifndef ISOCTAL
- #define ISOCTAL(c)  ((c) >= '0' && (c) <= '7')
- #endif
  
  /* Define exactly what a legal shell identifier consists of. */
! #define legal_variable_starter(c) (isletter(c) || (c == '_'))
! #define legal_variable_char(c)	(isletter (c) || digit (c) || c == '_')
  
  /* Definitions used in subst.c and by the `read' builtin for field
--- 76,107 ----
  #endif
  
! #ifndef CHAR_MAX
! #  ifdef __CHAR_UNSIGNED__
! #    define CHAR_MAX	0xff
! #  else
! #    define CHAR_MAX	0x7f
! #  endif
  #endif
  
! #ifndef CHAR_BIT
! #  define CHAR_BIT 8
  #endif
  
! /* Nonzero if the integer type T is signed.  */
! #define TYPE_SIGNED(t) (! ((t) 0 < (t) -1))
! 
! /* Bound on length of the string representing an integer value of type T.
!    Subtract one for the sign bit if T is signed;
!    302 / 1000 is log10 (2) rounded up;
!    add one for integer division truncation;
!    add one more for a minus sign if t is signed.  */
! #define INT_STRLEN_BOUND(t) \
!   ((sizeof (t) * CHAR_BIT - TYPE_SIGNED (t)) * 302 / 1000 \
!    + 1 + TYPE_SIGNED (t))
  
  
  /* Define exactly what a legal shell identifier consists of. */
! #define legal_variable_starter(c) (ISALPHA(c) || (c == '_'))
! #define legal_variable_char(c)	(ISALNUM(c) || c == '_')
  
  /* Definitions used in subst.c and by the `read' builtin for field
***************
*** 169,176 ****
  typedef int Function ();
  typedef void VFunction ();
! typedef char *CPFunction ();
! typedef char **CPPFunction ();
  #endif /* _FUNCTION_DEF */
  
  #define NOW	((time_t) time ((time_t *) 0))
  
--- 175,224 ----
  typedef int Function ();
  typedef void VFunction ();
! typedef char *CPFunction ();		/* no longer used */
! typedef char **CPPFunction ();		/* no longer used */
  #endif /* _FUNCTION_DEF */
  
+ #ifndef SH_FUNCTION_TYPEDEF
+ #  define SH_FUNCTION_TYPEDEF
+ 
+ /* Shell function typedefs with prototypes */
+ /* `Generic' function pointer typedefs */
+ 
+ typedef int sh_intfunc_t __P((int));
+ typedef int sh_ivoidfunc_t __P((void));
+ typedef int sh_icpfunc_t __P((char *));
+ typedef int sh_icppfunc_t __P((char **));
+ typedef int sh_iptrfunc_t __P((PTR_T));
+ 
+ typedef void sh_voidfunc_t __P((void));
+ typedef void sh_vintfunc_t __P((int));
+ typedef void sh_vcpfunc_t __P((char *));
+ typedef void sh_vcppfunc_t __P((char **));
+ typedef void sh_vptrfunc_t __P((PTR_T));
+ 
+ typedef int sh_wdesc_func_t __P((WORD_DESC *));
+ typedef int sh_wlist_func_t __P((WORD_LIST *));
+ 
+ typedef int sh_glist_func_t __P((GENERIC_LIST *));
+ 
+ typedef char *sh_string_func_t __P((char *));	/* like savestring, et al. */
+ 
+ typedef int sh_msg_func_t __P((const char *, ...));	/* printf(3)-like */
+ typedef void sh_vmsg_func_t __P((const char *, ...));	/* printf(3)-like */
+ 
+ /* Specific function pointer typedefs.  Most of these could be done
+    with #defines. */
+ typedef void sh_sv_func_t __P((char *));	/* sh_vcpfunc_t */
+ typedef void sh_free_func_t __P((PTR_T));	/* sh_vptrfunc_t */
+ typedef void sh_resetsig_func_t __P((int));	/* sh_vintfunc_t */
+ 
+ typedef int sh_ignore_func_t __P((const char *));	/* sh_icpfunc_t */
+ 
+ typedef int sh_assign_func_t __P((const char *));	/* sh_icpfunc_t */
+ 
+ typedef int sh_builtin_func_t __P((WORD_LIST *)); /* sh_wlist_func_t */
+ 
+ #endif /* SH_FUNCTION_TYPEDEF */
+ 
  #define NOW	((time_t) time ((time_t *) 0))
  
***************
*** 183,186 ****
--- 231,241 ----
  #define FS_NODIRS	  0x20
  
+ /* The type of function passed as the fourth argument to qsort(3). */
+ #ifdef __STDC__
+ typedef int QSFUNC (const void *, const void *);
+ #else
+ typedef int QSFUNC ();
+ #endif 
+ 
  /* Some useful definitions for Unix pathnames.  Argument convention:
     x == string, c == character */
***************
*** 190,194 ****
  #  define RELPATH(x)	((x)[0] != '/')
  #else /* __CYGWIN__ */
! #  define ABSPATH(x)	(((x)[0] && isalpha((x)[0]) && (x)[1] == ':' && (x)[2] == '/') || (x)[0] == '/')
  #  define RELPATH(x)	(!(x)[0] || ((x)[1] != ':' && (x)[0] != '/'))
  #endif /* __CYGWIN__ */
--- 245,249 ----
  #  define RELPATH(x)	((x)[0] != '/')
  #else /* __CYGWIN__ */
! #  define ABSPATH(x)	(((x)[0] && ISALPHA((unsigned char)(x)[0]) && (x)[1] == ':' && (x)[2] == '/') || (x)[0] == '/')
  #  define RELPATH(x)	(!(x)[0] || ((x)[1] != ':' && (x)[0] != '/'))
  #endif /* __CYGWIN__ */
***************
*** 200,207 ****
  #define PATHSEP(c)	(ISDIRSEP(c) || (c) == 0)
  
  /* Declarations for functions defined in xmalloc.c */
! extern char *xmalloc __P((size_t));
! extern char *xrealloc __P((void *, size_t));
  extern void xfree __P((void *));
  
  /* Declarations for functions defined in general.c */
--- 255,264 ----
  #define PATHSEP(c)	(ISDIRSEP(c) || (c) == 0)
  
+ #if 0
  /* Declarations for functions defined in xmalloc.c */
! extern PTR_T xmalloc __P((size_t));
! extern PTR_T xrealloc __P((void *, size_t));
  extern void xfree __P((void *));
+ #endif
  
  /* Declarations for functions defined in general.c */
***************
*** 220,230 ****
  extern int sh_unset_nodelay_mode __P((int));
  extern void check_dev_tty __P((void));
- extern int same_file ();	/* too many problems with prototype */
  extern int move_to_high_fd __P((int, int, int));
! extern int check_binary_file __P((unsigned char *, int));
  
  extern char *make_absolute __P((char *, char *));
! extern int absolute_pathname __P((char *));
! extern int absolute_program __P((char *));
  extern char *base_pathname __P((char *));
  extern char *full_pathname __P((char *));
--- 277,290 ----
  extern int sh_unset_nodelay_mode __P((int));
  extern void check_dev_tty __P((void));
  extern int move_to_high_fd __P((int, int, int));
! extern int check_binary_file __P((char *, int));
! 
! #ifdef _POSIXSTAT_H_
! extern int same_file __P((char *, char *, struct stat *, struct stat *));
! #endif
  
  extern char *make_absolute __P((char *, char *));
! extern int absolute_pathname __P((const char *));
! extern int absolute_program __P((const char *));
  extern char *base_pathname __P((char *));
  extern char *full_pathname __P((char *));
***************
*** 234,238 ****
  
  extern void tilde_initialize __P((void));
! extern char *bash_tilde_expand __P((char *));
  
  extern int group_member __P((gid_t));
--- 294,298 ----
  
  extern void tilde_initialize __P((void));
! extern char *bash_tilde_expand __P((const char *));
  
  extern int group_member __P((gid_t));
diff -Nrc2 bash-2.05/hashcmd.c bash-2.05a/hashcmd.c
*** bash-2.05/hashcmd.c	Thu Aug  5 07:20:39 1999
--- bash-2.05a/hashcmd.c	Wed Sep 19 09:50:46 2001
***************
*** 53,57 ****
  static void
  free_filename_data (data)
!      char *data;
  {
    free (((PATH_DATA *)data)->path);
--- 53,57 ----
  static void
  free_filename_data (data)
!      PTR_T data;
  {
    free (((PATH_DATA *)data)->path);
***************
*** 69,73 ****
  void
  remove_hashed_filename (filename)
!      char *filename;
  {
    register BUCKET_CONTENTS *item;
--- 69,73 ----
  void
  remove_hashed_filename (filename)
!      const char *filename;
  {
    register BUCKET_CONTENTS *item;
***************
*** 86,90 ****
  }
  
! /* Place FILENAME (key) and FULL_PATHNAME (data->path) into the
     hash table.  CHECK_DOT if non-null is for future calls to
     find_hashed_filename (); it means that this file was found
--- 86,90 ----
  }
  
! /* Place FILENAME (key) and FULL_PATH (data->path) into the
     hash table.  CHECK_DOT if non-null is for future calls to
     find_hashed_filename (); it means that this file was found
***************
*** 92,97 ****
     FOUND is the initial value for times_found. */
  void
! remember_filename (filename, full_pathname, check_dot, found)
!      char *filename, *full_pathname;
       int check_dot, found;
  {
--- 92,97 ----
     FOUND is the initial value for times_found. */
  void
! remember_filename (filename, full_path, check_dot, found)
!      char *filename, *full_path;
       int check_dot, found;
  {
***************
*** 110,120 ****
      {
        item->key = savestring (filename);
!       item->data = xmalloc (sizeof (PATH_DATA));
      }
!   pathdata(item)->path = savestring (full_pathname);
    pathdata(item)->flags = 0;
    if (check_dot)
      pathdata(item)->flags |= HASH_CHKDOT;
!   if (*full_pathname != '/')
      pathdata(item)->flags |= HASH_RELPATH;
    item->times_found = found;
--- 110,120 ----
      {
        item->key = savestring (filename);
!       item->data = (char *)xmalloc (sizeof (PATH_DATA));
      }
!   pathdata(item)->path = savestring (full_path);
    pathdata(item)->flags = 0;
    if (check_dot)
      pathdata(item)->flags |= HASH_CHKDOT;
!   if (*full_path != '/')
      pathdata(item)->flags |= HASH_RELPATH;
    item->times_found = found;
***************
*** 128,132 ****
  char *
  find_hashed_filename (filename)
!      char *filename;
  {
    register BUCKET_CONTENTS *item;
--- 128,132 ----
  char *
  find_hashed_filename (filename)
!      const char *filename;
  {
    register BUCKET_CONTENTS *item;
***************
*** 148,156 ****
    if (pathdata(item)->flags & (HASH_CHKDOT|HASH_RELPATH))
      {
!       tail = (pathdata(item)->flags & HASH_RELPATH) ? path : filename;
        /* If the pathname does not start with a `./', add a `./' to it. */
        if (tail[0] != '.' || tail[1] != '/')
  	{
! 	  dotted_filename = xmalloc (3 + strlen (tail));
  	  dotted_filename[0] = '.'; dotted_filename[1] = '/';
  	  strcpy (dotted_filename + 2, tail);
--- 148,156 ----
    if (pathdata(item)->flags & (HASH_CHKDOT|HASH_RELPATH))
      {
!       tail = (pathdata(item)->flags & HASH_RELPATH) ? path : (char *)filename;	/* XXX - fix const later */
        /* If the pathname does not start with a `./', add a `./' to it. */
        if (tail[0] != '.' || tail[1] != '/')
  	{
! 	  dotted_filename = (char *)xmalloc (3 + strlen (tail));
  	  dotted_filename[0] = '.'; dotted_filename[1] = '/';
  	  strcpy (dotted_filename + 2, tail);
diff -Nrc2 bash-2.05/hashcmd.h bash-2.05a/hashcmd.h
*** bash-2.05/hashcmd.h	Thu Aug  5 07:07:26 1999
--- bash-2.05a/hashcmd.h	Thu Sep 13 15:49:59 2001
***************
*** 38,42 ****
  extern void initialize_filename_hashing __P((void));
  extern void flush_hashed_filenames __P((void));
! extern void remove_hashed_filename __P((char *));
  extern void remember_filename __P((char *, char *, int, int));
! extern char *find_hashed_filename __P((char *));
--- 38,42 ----
  extern void initialize_filename_hashing __P((void));
  extern void flush_hashed_filenames __P((void));
! extern void remove_hashed_filename __P((const char *));
  extern void remember_filename __P((char *, char *, int, int));
! extern char *find_hashed_filename __P((const char *));
diff -Nrc2 bash-2.05/hashlib.c bash-2.05a/hashlib.c
*** bash-2.05/hashlib.c	Wed Feb 14 16:58:55 2001
--- bash-2.05a/hashlib.c	Thu Sep 13 15:44:28 2001
***************
*** 35,38 ****
--- 35,41 ----
  #include "hashlib.h"
  
+ static void initialize_hash_table __P((HASH_TABLE *));
+ static BUCKET_CONTENTS *copy_bucket_array __P((BUCKET_CONTENTS *, sh_string_func_t *));
+ 
  /* Zero the buckets in TABLE. */
  static void
***************
*** 65,71 ****
--- 68,135 ----
  }
  
+ int
+ hash_table_nentries (table)
+      HASH_TABLE *table;
+ {
+   return (HASH_ENTRIES(table));
+ }
+ 
+ static BUCKET_CONTENTS *
+ copy_bucket_array (ba, cpdata)
+      BUCKET_CONTENTS *ba;
+      sh_string_func_t *cpdata;	/* data copy function */
+ {
+   BUCKET_CONTENTS *new_bucket, *n, *e;
+ 
+   if (ba == 0)
+     return ((BUCKET_CONTENTS *)0);
+ 
+   for (n = (BUCKET_CONTENTS *)0, e = ba; e; e = e->next)
+     {
+       if (n == 0)
+         {
+           new_bucket = (BUCKET_CONTENTS *)xmalloc (sizeof (BUCKET_CONTENTS));
+           n = new_bucket;
+         }
+       else
+         {
+           n->next = (BUCKET_CONTENTS *)xmalloc (sizeof (BUCKET_CONTENTS));
+           n = n->next;
+         }
+ 
+       n->key = savestring (e->key);
+       n->data = e->data ? (cpdata ? (*cpdata) (e->data) : savestring (e->data))
+ 			: (char *)NULL;
+       n->times_found = e->times_found;
+       n->next = (BUCKET_CONTENTS *)NULL;
+     }
+ 
+   return new_bucket;  
+ }
+ 
+ HASH_TABLE *
+ copy_hash_table (table, cpdata)
+      HASH_TABLE *table;
+      sh_string_func_t *cpdata;
+ {
+   HASH_TABLE *new_table;
+   int i;
+ 
+   if (table == 0)
+     return ((HASH_TABLE *)NULL);
+ 
+   new_table = make_hash_table (table->nbuckets);
+ 
+   for (i = 0; i < table->nbuckets; i++)
+     new_table->bucket_array[i] = copy_bucket_array (table->bucket_array[i], cpdata);
+ 
+   new_table->nentries = table->nentries;
+   return new_table;
+ }
+ 
  /* Return the location of the bucket which should contain the data
     for STRING.  TABLE is a pointer to a HASH_TABLE. */
  
+ #if 0
  /* A possibly better distribution may be obtained by initializing i to
     ~0UL and using i = (i * 31) + *string++ as the step */
***************
*** 73,80 ****
  #define ALL_ONES (~((unsigned long) 0))
  #define BITS(h, n) ((unsigned long)(h) & ~(ALL_ONES << (n)))
  
  int
  hash_string (string, table)
!      char *string;
       HASH_TABLE *table;
  {
--- 137,145 ----
  #define ALL_ONES (~((unsigned long) 0))
  #define BITS(h, n) ((unsigned long)(h) & ~(ALL_ONES << (n)))
+ #endif
  
  int
  hash_string (string, table)
!      const char *string;
       HASH_TABLE *table;
  {
***************
*** 84,88 ****
--- 149,159 ----
      i = (i << 2) + *string++;
  
+ #if 0
    return (BITS (i, 31) % table->nbuckets);
+ #else
+   /* Rely on properties of unsigned division (unsigned/int -> unsigned) and
+      don't discard the upper 32 bits of the value, if present. */
+   return (i % table->nbuckets);
+ #endif
  }
  
***************
*** 91,95 ****
  BUCKET_CONTENTS *
  find_hash_item (string, table)
!      char *string;
       HASH_TABLE *table;
  {
--- 162,166 ----
  BUCKET_CONTENTS *
  find_hash_item (string, table)
!      const char *string;
       HASH_TABLE *table;
  {
***************
*** 118,122 ****
  BUCKET_CONTENTS *
  remove_hash_item (string, table)
!      char *string;
       HASH_TABLE *table;
  {
--- 189,193 ----
  BUCKET_CONTENTS *
  remove_hash_item (string, table)
!      const char *string;
       HASH_TABLE *table;
  {
***************
*** 195,199 ****
  flush_hash_table (table, free_data)
       HASH_TABLE *table;
!      VFunction *free_data;
  {
    int i;
--- 266,270 ----
  flush_hash_table (table, free_data)
       HASH_TABLE *table;
!      sh_free_func_t *free_data;
  {
    int i;
***************
*** 283,294 ****
  #include <stdio.h>
  
! HASH_TABLE *table;
  #define NBUCKETS 107
  
! char *
  xmalloc (bytes)
!      int bytes;
  {
!   char *result = (char *)malloc (bytes);
    if (!result)
      {
--- 354,369 ----
  #include <stdio.h>
  
! #ifndef NULL
! #define NULL 0
! #endif
! 
! HASH_TABLE *table, *ntable;
  #define NBUCKETS 107
  
! void *
  xmalloc (bytes)
!      size_t bytes;
  {
!   void *result = malloc (bytes);
    if (!result)
      {
***************
*** 328,331 ****
--- 403,411 ----
  
    print_table_stats (table, "hash test");
+ 
+   ntable = copy_hash_table (table, (sh_string_func_t *)NULL);
+   flush_hash_table (table, (sh_free_func_t *)NULL);
+   print_table_stats (ntable, "hash copy test");
+ 
    exit (0);
  }
diff -Nrc2 bash-2.05/hashlib.h bash-2.05a/hashlib.h
*** bash-2.05/hashlib.h	Mon Dec  6 10:24:25 1999
--- bash-2.05a/hashlib.h	Thu Sep 13 15:44:54 2001
***************
*** 37,46 ****
  } HASH_TABLE;
  
! extern int hash_string __P((char *, HASH_TABLE *));
  extern HASH_TABLE *make_hash_table __P((int));
! extern BUCKET_CONTENTS *find_hash_item __P((char *, HASH_TABLE *));
! extern BUCKET_CONTENTS *remove_hash_item __P((char *, HASH_TABLE *));
  extern BUCKET_CONTENTS *add_hash_item __P((char *, HASH_TABLE *));
! extern void flush_hash_table __P((HASH_TABLE *, VFunction *));
  extern void dispose_hash_table __P((HASH_TABLE *));
  
--- 37,48 ----
  } HASH_TABLE;
  
! extern int hash_string __P((const char *, HASH_TABLE *));
! extern int hash_table_nentries __P((HASH_TABLE *));
  extern HASH_TABLE *make_hash_table __P((int));
! extern HASH_TABLE *copy_hash_table __P((HASH_TABLE *, sh_string_func_t *));
! extern BUCKET_CONTENTS *find_hash_item __P((const char *, HASH_TABLE *));
! extern BUCKET_CONTENTS *remove_hash_item __P((const char *, HASH_TABLE *));
  extern BUCKET_CONTENTS *add_hash_item __P((char *, HASH_TABLE *));
! extern void flush_hash_table __P((HASH_TABLE *, sh_free_func_t *));
  extern void dispose_hash_table __P((HASH_TABLE *));
  
***************
*** 54,58 ****
  #define DEFAULT_HASH_BUCKETS 53	/* was 107 */
  
! #define HASH_ENTRIES(ht)	(ht)->nentries
  
  #if !defined (NULL)
--- 56,60 ----
  #define DEFAULT_HASH_BUCKETS 53	/* was 107 */
  
! #define HASH_ENTRIES(ht)	((ht) ? (ht)->nentries : 0)
  
  #if !defined (NULL)
diff -Nrc2 bash-2.05/include/ansi_stdlib.h bash-2.05a/include/ansi_stdlib.h
*** bash-2.05/include/ansi_stdlib.h	Thu Sep  7 12:07:49 2000
--- bash-2.05a/include/ansi_stdlib.h	Wed Oct 17 16:08:40 2001
***************
*** 26,30 ****
  /* String conversion functions. */
  extern int atoi ();
- extern long int atol ();
  
  extern double atof ();
--- 26,29 ----
***************
*** 32,37 ****
  
  /* Memory allocation functions. */
! extern char *malloc ();
! extern char *realloc ();
  extern void free ();
  
--- 31,47 ----
  
  /* Memory allocation functions. */
! /* Generic pointer type. */
! #ifndef PTR_T
! 
! #if defined (__STDC__)
! #  define PTR_T	void *
! #else
! #  define PTR_T char *
! #endif
! 
! #endif /* PTR_T */
! 
! extern PTR_T malloc ();
! extern PTR_T realloc ();
  extern void free ();
  
diff -Nrc2 bash-2.05/include/chartypes.h bash-2.05a/include/chartypes.h
*** bash-2.05/include/chartypes.h	Wed Dec 31 19:00:00 1969
--- bash-2.05a/include/chartypes.h	Wed Nov  7 08:44:21 2001
***************
*** 0 ****
--- 1,119 ----
+ /* chartypes.h -- extend ctype.h */
+ 
+ /* Copyright (C) 2001 Free Software Foundation, Inc.
+ 
+    This file is part of GNU Bash, the Bourne Again SHell.
+ 
+    Bash is free software; you can redistribute it and/or modify it under
+    the terms of the GNU General Public License as published by the Free
+    Software Foundation; either version 2, or (at your option) any later
+    version.
+ 
+    Bash is distributed in the hope that it will be useful, but WITHOUT ANY
+    WARRANTY; without even the implied warranty of MERCHANTABILITY or
+    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+    for more details.
+ 
+    You should have received a copy of the GNU General Public License along
+    with Bash; see the file COPYING.  If not, write to the Free Software
+    Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. */
+ 
+ #ifndef _SH_CHARTYPES_H
+ #define _SH_CHARTYPES_H
+ 
+ #include <ctype.h>
+ 
+ /* Jim Meyering writes:
+ 
+    "... Some ctype macros are valid only for character codes that
+    isascii says are ASCII (SGI's IRIX-4.0.5 is one such system --when
+    using /bin/cc or gcc but without giving an ansi option).  So, all
+    ctype uses should be through macros like ISPRINT...  If
+    STDC_HEADERS is defined, then autoconf has verified that the ctype
+    macros don't need to be guarded with references to isascii. ...
+    Defining IN_CTYPE_DOMAIN to 1 should let any compiler worth its salt
+    eliminate the && through constant folding."
+    Solaris defines some of these symbols so we must undefine them first.  */
+ 
+ #if defined STDC_HEADERS || (!defined isascii && !defined HAVE_ISASCII)
+ #  define IN_CTYPE_DOMAIN(c) 1
+ #else
+ #  define IN_CTYPE_DOMAIN(c) isascii(c)
+ #endif
+ 
+ #if !defined (isspace) && !defined (HAVE_ISSPACE)
+ #  define isspace(c) ((c) == ' ' || (c) == '\t' || (c) == '\n' || (c) == '\f')
+ #endif
+ 
+ #if !defined (isprint) && !defined (HAVE_ISPRINT)
+ #  define isprint(c) (isalpha(c) || isdigit(c) || ispunct(c))
+ #endif
+ 
+ #if defined (isblank) || defined (HAVE_ISBLANK)
+ #  define ISBLANK(c) (IN_CTYPE_DOMAIN (c) && isblank (c))
+ #else
+ #  define ISBLANK(c) ((c) == ' ' || (c) == '\t')
+ #endif
+ 
+ #if defined (isgraph) || defined (HAVE_ISGRAPH)
+ #  define ISGRAPH(c) (IN_CTYPE_DOMAIN (c) && isgraph (c))
+ #else
+ #  define ISGRAPH(c) (IN_CTYPE_DOMAIN (c) && isprint (c) && !isspace (c))
+ #endif
+ 
+ #if !defined (isxdigit) && !defined (HAVE_ISXDIGIT)
+ #  define isxdigit(c)	(((c) >= '0' && (c) <= '9') || ((c) >= 'a' && (c) <= 'f') || ((c) >= 'A' && (c) <= 'F'))
+ #endif
+ 
+ #undef ISPRINT
+ 
+ #define ISPRINT(c) (IN_CTYPE_DOMAIN (c) && isprint (c))
+ #define ISDIGIT(c) (IN_CTYPE_DOMAIN (c) && isdigit (c))
+ #define ISALNUM(c) (IN_CTYPE_DOMAIN (c) && isalnum (c))
+ #define ISALPHA(c) (IN_CTYPE_DOMAIN (c) && isalpha (c))
+ #define ISCNTRL(c) (IN_CTYPE_DOMAIN (c) && iscntrl (c))
+ #define ISLOWER(c) (IN_CTYPE_DOMAIN (c) && islower (c))
+ #define ISPUNCT(c) (IN_CTYPE_DOMAIN (c) && ispunct (c))
+ #define ISSPACE(c) (IN_CTYPE_DOMAIN (c) && isspace (c))
+ #define ISUPPER(c) (IN_CTYPE_DOMAIN (c) && isupper (c))
+ #define ISXDIGIT(c) (IN_CTYPE_DOMAIN (c) && isxdigit (c))
+ 
+ #define ISLETTER(c)	(ISALPHA(c))
+ 
+ #define DIGIT(c)	((c) >= '0' && (c) <= '9')
+ 
+ #define HEXVALUE(c) \
+   (((c) >= 'a' && (c) <= 'f') \
+ 	? (c)-'a'+10 \
+ 	: (c) >= 'A' && (c) <= 'F' ? (c)-'A'+10 : (c)-'0')
+                   
+ #ifndef ISOCTAL
+ #  define ISOCTAL(c)	((c) >= '0' && (c) <= '7')
+ #endif
+ #define OCTVALUE(c)	((c) - '0')
+ 
+ #define TODIGIT(c)	((c) - '0')
+ #define TOCHAR(c)	((c) + '0')
+ 
+ #define TOLOWER(c)	(ISUPPER(c) ? tolower(c) : (c))
+ #define TOUPPER(c)	(ISLOWER(c) ? toupper(c) : (c))
+ 
+ #ifdef toascii
+ #  define TOASCII(c)	(toascii(c))
+ #else
+ #  define TOASCII(c)	((c) & 0x7F)
+ #endif
+ 
+ /* We remove any previous definition of `SIGN_EXTEND_CHAR',
+    since ours (we hope) works properly with all combinations of
+    machines, compilers, `char' and `unsigned char' argument types.
+    (Per Bothner suggested the basic approach.)  */
+ #undef SIGN_EXTEND_CHAR
+ #if __STDC__
+ #  define SIGN_EXTEND_CHAR(c) ((signed char) (c))
+ #else  /* not __STDC__ */
+    /* As in Harbison and Steele.  */
+ #  define SIGN_EXTEND_CHAR(c) ((((unsigned char) (c)) ^ 128) - 128)
+ #endif
+ 
+ #endif /* _SH_CHARTYPES_H */
diff -Nrc2 bash-2.05/include/memalloc.h bash-2.05a/include/memalloc.h
*** bash-2.05/include/memalloc.h	Thu Aug  5 07:50:01 1999
--- bash-2.05a/include/memalloc.h	Tue Sep 18 13:16:15 2001
***************
*** 31,35 ****
  #endif
  
! #if defined (HAVE_ALLOCA_H) && !defined (HAVE_ALLOCA)
  #  define HAVE_ALLOCA
  #endif /* HAVE_ALLOCA_H && !HAVE_ALLOCA */
--- 31,35 ----
  #endif
  
! #if defined (HAVE_ALLOCA_H) && !defined (HAVE_ALLOCA) && !defined (C_ALLOCA)
  #  define HAVE_ALLOCA
  #endif /* HAVE_ALLOCA_H && !HAVE_ALLOCA */
***************
*** 50,54 ****
--- 50,58 ----
  #    else
  #      if !defined (alloca)
+ #        if defined (__STDC__)
+ extern void *alloca (size_t);
+ #        else
  extern char *alloca ();
+ #        endif /* !__STDC__ */
  #      endif /* !alloca */
  #    endif /* !__hpux || !__STDC__ && !alloca */
diff -Nrc2 bash-2.05/include/stdc.h bash-2.05a/include/stdc.h
*** bash-2.05/include/stdc.h	Thu Aug  5 07:51:40 1999
--- bash-2.05a/include/stdc.h	Wed Sep 26 14:01:29 2001
***************
*** 37,59 ****
  #endif
  
! #if defined (__STDC__)
! 
  #  define __STRING(x) #x
! 
! #  if !defined (__GNUC__)
! #    define inline
! #  endif
! 
! #else /* !__STDC__ */
! 
  #  define __STRING(x) "x"
  
  #if defined (__GNUC__)		/* gcc with -traditional */
- #  if !defined (const)
- #    define const  __const
- #  endif
- #  if !defined (inline)
- #    define inline __inline
- #  endif
  #  if !defined (signed)
  #    define signed __signed
--- 37,49 ----
  #endif
  
! #if defined (HAVE_STRINGIZE)
  #  define __STRING(x) #x
! #else
  #  define __STRING(x) "x"
+ #endif
+ 
+ #if !defined (__STDC__)
  
  #if defined (__GNUC__)		/* gcc with -traditional */
  #  if !defined (signed)
  #    define signed __signed
***************
*** 63,69 ****
  #  endif
  #else /* !__GNUC__ */
- #  if !defined (const)
- #    define const
- #  endif
  #  if !defined (inline)
  #    define inline
--- 53,56 ----
***************
*** 78,81 ****
--- 65,74 ----
  
  #endif /* !__STDC__ */
+ 
+ #ifndef __attribute__
+ #  if __GNUC__ < 2 || (__GNUC__ == 2 && __GNUC_MINOR__ < 8) || __STRICT_ANSI__
+ #    define __attribute__(x)
+ #  endif
+ #endif
  
  #endif /* !_STDC_H_ */
diff -Nrc2 bash-2.05/include/typemax.h bash-2.05a/include/typemax.h
*** bash-2.05/include/typemax.h	Wed Dec 31 19:00:00 1969
--- bash-2.05a/include/typemax.h	Thu Oct 18 16:21:40 2001
***************
*** 0 ****
--- 1,80 ----
+ /* typemax.h -- encapsulate max values for long, long long, etc. */
+ 
+ /* Copyright (C) 2001 Free Software Foundation, Inc.
+ 
+    This file is part of GNU Bash, the Bourne Again SHell.
+ 
+    Bash is free software; you can redistribute it and/or modify it under
+    the terms of the GNU General Public License as published by the Free
+    Software Foundation; either version 2, or (at your option) any later
+    version.
+ 
+    Bash is distributed in the hope that it will be useful, but WITHOUT ANY
+    WARRANTY; without even the implied warranty of MERCHANTABILITY or
+    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+    for more details.
+ 
+    You should have received a copy of the GNU General Public License along
+    with Bash; see the file COPYING.  If not, write to the Free Software
+    Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. */
+ 
+ /*
+  * NOTE:  This should be included after config.h, limits.h, stdint.h, and
+  *	  inttypes.h
+  */
+ 
+ #ifndef _SH_TYPEMAX_H
+ #define _SH_TYPEMAX_H
+ 
+ #ifndef CHAR_BIT
+ #  define CHAR_BIT 8
+ #endif
+ 
+ /* Nonzero if the integer type T is signed.  */
+ #ifndef TYPE_SIGNED
+ #  define TYPE_SIGNED(t)	(! ((t) 0 < (t) -1))
+ #endif
+ 
+ #ifndef TYPE_MINIMUM
+ #  define TYPE_MINIMUM(t) ((t) (TYPE_SIGNED (t) \
+ 				? ~ (t) 0 << (sizeof (t) * CHAR_BIT - 1) \
+ 				: (t) 0))
+ #endif
+ 
+ #ifndef TYPE_MAXIMUM
+ #  define TYPE_MAXIMUM(t) ((t) (~ (t) 0 - TYPE_MINIMUM (t)))
+ #endif
+ 
+ #ifdef HAVE_LONG_LONG
+ #  ifndef LLONG_MAX
+ #    define LLONG_MAX   TYPE_MAXIMUM(long long int)
+ #    define LLONG_MIN	TYPE_MINIMUM(long long int)
+ #  endif
+ #  ifndef ULLONG_MAX
+ #    define ULLONG_MAX  TYPE_MAXIMUM(unsigned long long int)
+ #  endif
+ #endif
+ 
+ #ifndef ULONG_MAX
+ #  define ULONG_MAX	((unsigned long) ~(unsigned long) 0)
+ #endif
+ 
+ #ifndef LONG_MAX
+ #  define LONG_MAX	((long int) (ULONG_MAX >> 1))
+ #  define LONG_MIN	((long int) (-LONG_MAX - 1L))
+ #endif
+ 
+ #ifndef INT_MAX		/* ouch */
+ #  define INT_MAX	TYPE_MAXIMUM(int)
+ #  define INT_MIN	TYPE_MINIMUM(int)
+ #  define UINT_MAX	((unsigned int) ~(unsigned int)0)
+ #endif
+ 
+ /* workaround for gcc bug in versions < 2.7 */
+ #if defined (HAVE_LONG_LONG) && __GNUC__ == 2 && __GNUC_MINOR__ < 7
+ static const unsigned long long int maxquad = ULLONG_MAX;
+ #  undef ULLONG_MAX
+ #  define ULLONG_MAX maxquad
+ #endif
+ 
+ #endif /* _SH_TYPEMAX_H */
diff -Nrc2 bash-2.05/input.c bash-2.05a/input.c
*** bash-2.05/input.c	Tue Feb 13 15:39:59 2001
--- bash-2.05a/input.c	Mon Sep 10 13:26:48 2001
***************
*** 48,52 ****
     if a signal is received. */
  
! static unsigned char localbuf[128];
  static int local_index, local_bufused;
  
--- 48,52 ----
     if a signal is received. */
  
! static char localbuf[128];
  static int local_index, local_bufused;
  
***************
*** 58,61 ****
--- 58,63 ----
       FILE *stream;
  {
+   unsigned char uc;
+ 
    /* Try local buffering to reduce the number of read(2) calls. */
    if (local_index == local_bufused || local_bufused == 0)
***************
*** 74,78 ****
        local_index = 0;
      }
!   return (localbuf[local_index++]);
  }
  
--- 76,81 ----
        local_index = 0;
      }
!   uc = localbuf[local_index++];
!   return uc;
  }
  
***************
*** 84,88 ****
    if (local_index == 0 || c == EOF)
      return EOF;
!   return (localbuf[--local_index] = c);
  }
  
--- 87,92 ----
    if (local_index == 0 || c == EOF)
      return EOF;
!   localbuf[--local_index] = c;
!   return c;
  }
  
***************
*** 110,115 ****
  #define min(a, b)	((a) > (b) ? (b) : (a))
  
- extern int return_EOF ();
- 
  extern int interactive_shell;
  
--- 114,117 ----
***************
*** 275,280 ****
       int fd;
  {
-   int nfd;
- 
    if (fd > 0 && fd_is_bash_input (fd))
      return ((save_bash_input (fd, -1) == -1) ? -1 : 0);
--- 277,280 ----
***************
*** 403,406 ****
--- 403,411 ----
       int fd;
  {
+   if (fd < 0)
+     {
+       errno = EBADF;
+       return -1;
+     }
    if (fd >= nbuffers || !buffers || !buffers[fd])
      return (close (fd));
***************
*** 427,440 ****
       BUFFERED_STREAM *bp;
  {
!   bp->b_used = zread (bp->b_fd, bp->b_buffer, bp->b_size);
! #if defined (__CYGWIN__)
!   /* If on cygwin, translate \r\n to \n. */
!   if (bp->b_buffer[bp->b_used - 1] == '\r' && bp->b_buffer[bp->b_used] == '\n')
!     bp->b_buffer[--bp->b_used] = '\n';
! #endif
!   if (bp->b_used <= 0)
      {
        bp->b_buffer[0] = 0;
!       if (bp->b_used == 0)
  	bp->b_flag |= B_EOF;
        else
--- 432,443 ----
       BUFFERED_STREAM *bp;
  {
!   ssize_t nr;
! 
!   nr = zread (bp->b_fd, bp->b_buffer, bp->b_size);
!   if (nr <= 0)
      {
+       bp->b_used = 0;
        bp->b_buffer[0] = 0;
!       if (nr == 0)
  	bp->b_flag |= B_EOF;
        else
***************
*** 442,445 ****
--- 445,459 ----
        return (EOF);
      }
+ 
+ #if defined (__CYGWIN__)
+   /* If on cygwin, translate \r\n to \n. */
+   if (nr >= 2 && bp->b_buffer[nr - 2] == '\r' && bp->b_buffer[nr - 1] == '\n')
+     {
+       bp->b_buffer[nr - 2] = '\n';
+       nr--;
+     }
+ #endif
+ 
+   bp->b_used = nr;
    bp->b_inputp = 0;
    return (bp->b_buffer[bp->b_inputp++] & 0xFF);
***************
*** 522,533 ****
  
  #if defined (TEST)
! char *
  xmalloc(s)
  int s;
  {
! 	return ((char *)malloc (s));
  }
  
! char *
  xrealloc(s, size)
  char	*s;
--- 536,547 ----
  
  #if defined (TEST)
! void *
  xmalloc(s)
  int s;
  {
! 	return (malloc (s));
  }
  
! void *
  xrealloc(s, size)
  char	*s;
***************
*** 535,541 ****
  {
  	if (!s)
! 		return((char *)malloc (size));
  	else
! 		return((char *)realloc (s, size));
  }
  
--- 549,555 ----
  {
  	if (!s)
! 		return(malloc (size));
  	else
! 		return(realloc (s, size));
  }
  
diff -Nrc2 bash-2.05/input.h bash-2.05a/input.h
*** bash-2.05/input.h	Tue Feb 13 15:02:25 2001
--- bash-2.05a/input.h	Tue Sep 11 12:27:29 2001
***************
*** 28,35 ****
  typedef int Function ();
  typedef void VFunction ();
! typedef char *CPFunction ();
! typedef char **CPPFunction ();
  #endif /* _FUNCTION_DEF */
  
  enum stream_type {st_none, st_stdin, st_stream, st_string, st_bstream};
  
--- 28,38 ----
  typedef int Function ();
  typedef void VFunction ();
! typedef char *CPFunction ();		/* no longer used */
! typedef char **CPPFunction ();		/* no longer used */
  #endif /* _FUNCTION_DEF */
  
+ typedef int sh_cget_func_t __P((void));		/* sh_ivoidfunc_t */
+ typedef int sh_cunget_func_t __P((int));	/* sh_intfunc_t */
+ 
  enum stream_type {st_none, st_stdin, st_stream, st_string, st_bstream};
  
***************
*** 50,59 ****
  typedef struct BSTREAM
  {
!   int	b_fd;
    char	*b_buffer;		/* The buffer that holds characters read. */
    size_t b_size;		/* How big the buffer is. */
!   int	b_used;			/* How much of the buffer we're using, */
!   int	b_flag;			/* Flag values. */
!   int	b_inputp;		/* The input pointer, index into b_buffer. */
  } BUFFERED_STREAM;
  
--- 53,62 ----
  typedef struct BSTREAM
  {
!   int	 b_fd;
    char	*b_buffer;		/* The buffer that holds characters read. */
    size_t b_size;		/* How big the buffer is. */
!   size_t b_used;		/* How much of the buffer we're using, */
!   int	 b_flag;		/* Flag values. */
!   size_t b_inputp;		/* The input pointer, index into b_buffer. */
  } BUFFERED_STREAM;
  
***************
*** 78,83 ****
    char *name;
    INPUT_STREAM location;
!   Function *getter;
!   Function *ungetter;
  } BASH_INPUT;
  
--- 81,86 ----
    char *name;
    INPUT_STREAM location;
!   sh_cget_func_t *getter;
!   sh_cunget_func_t *ungetter;
  } BASH_INPUT;
  
***************
*** 86,93 ****
  /* Functions from parse.y. */
  extern void initialize_bash_input __P((void));
! extern void init_yy_io __P((Function *, Function *, enum stream_type, char *, INPUT_STREAM));
  extern void with_input_from_stdin __P((void));
! extern void with_input_from_string __P((char *, char *));
! extern void with_input_from_stream __P((FILE *, char *));
  extern void push_stream __P((int));
  extern void pop_stream __P((void));
--- 89,96 ----
  /* Functions from parse.y. */
  extern void initialize_bash_input __P((void));
! extern void init_yy_io __P((sh_cget_func_t *, sh_cunget_func_t *, enum stream_type, const char *, INPUT_STREAM));
  extern void with_input_from_stdin __P((void));
! extern void with_input_from_string __P((char *, const char *));
! extern void with_input_from_stream __P((FILE *, const char *));
  extern void push_stream __P((int));
  extern void pop_stream __P((void));
***************
*** 103,108 ****
  
  /* Functions from input.c */
! extern int getc_with_restart ();
! extern int ungetc_with_restart ();
  
  #if defined (BUFFERED_INPUT)
--- 106,111 ----
  
  /* Functions from input.c */
! extern int getc_with_restart __P((FILE *));
! extern int ungetc_with_restart __P((int, FILE *));
  
  #if defined (BUFFERED_INPUT)
diff -Nrc2 bash-2.05/jobs.c bash-2.05a/jobs.c
*** bash-2.05/jobs.c	Mon Mar 26 13:08:24 2001
--- bash-2.05a/jobs.c	Mon Nov  5 09:56:17 2001
***************
*** 34,40 ****
  #endif
  
! #if defined (HAVE_SYS_TIME_H)
! #  include <sys/time.h>
! #endif
  
  #if defined (HAVE_SYS_RESOURCE_H) && defined (HAVE_WAIT3) && !defined (_POSIX_VERSION) && !defined (RLIMTYPE)
--- 34,38 ----
  #endif
  
! #include "posixtime.h"
  
  #if defined (HAVE_SYS_RESOURCE_H) && defined (HAVE_WAIT3) && !defined (_POSIX_VERSION) && !defined (RLIMTYPE)
***************
*** 128,134 ****
--- 126,140 ----
  #endif /* !MUST_REINSTALL_SIGHANDLERS */
  
+ /* Some systems let waitpid(2) tell callers about stopped children. */
+ #if !defined (WCONTINUED)
+ #  define WCONTINUED 0
+ #  define WIFCONTINUED(s)	(0)
+ #endif
+ 
  /* The number of additional slots to allocate when we run out. */
  #define JOB_SLOTS 8
  
+ typedef int sh_job_map_func_t __P((JOB *, int, int, int));
+ 
  #if defined (READLINE)
  extern void rl_set_screen_size __P((int, int));
***************
*** 136,146 ****
  
  /* Variables used here but defined in other files. */
- extern int interactive, interactive_shell, asynchronous_notification;
  extern int startup_state, subshell_environment, line_number;
! extern int posixly_correct, no_symbolic_links, shell_level;
  extern int interrupt_immediately, last_command_exit_value;
  extern int loop_level, breaking;
  extern int sourcelevel;
! extern Function *this_shell_builtin;
  extern char *shell_name, *this_command_name;
  extern sigset_t top_level_mask;
--- 142,151 ----
  
  /* Variables used here but defined in other files. */
  extern int startup_state, subshell_environment, line_number;
! extern int posixly_correct, shell_level;
  extern int interrupt_immediately, last_command_exit_value;
  extern int loop_level, breaking;
  extern int sourcelevel;
! extern sh_builtin_func_t *this_shell_builtin;
  extern char *shell_name, *this_command_name;
  extern sigset_t top_level_mask;
***************
*** 152,159 ****
  static int statsize;
  #endif
- static int set_job_status_and_cleanup ();
- static void setjstatus ();
- static void get_new_window_size ();
- static void run_sigchld_trap ();
  
  /* The array of known jobs. */
--- 157,160 ----
***************
*** 211,231 ****
  
  /* Functions local to this file. */
! static sighandler sigchld_handler ();
! static int waitchld ();
! static PROCESS *find_pipeline ();
! static char *current_working_directory ();
! static char *job_working_directory ();
! static pid_t find_last_pid (), last_pid ();
! static int set_new_line_discipline (), map_over_jobs ();
! static int job_last_running (), job_last_stopped ();
! static int most_recent_job_in_state (), find_job ();
! static void notify_of_job_status (), cleanup_dead_jobs (), discard_pipeline ();
! static void add_process (), set_current_job (), reset_current ();
! static void print_pipeline ();
! static void pretty_print_job ();
! static void mark_all_jobs_as_dead ();
! static void mark_dead_jobs_as_notified ();
  #if defined (PGRP_PIPE)
! static void pipe_read (), pipe_close ();
  #endif
  
--- 212,266 ----
  
  /* Functions local to this file. */
! 
! static void get_new_window_size __P((int));
! 
! static void run_sigchld_trap __P((int));
! 
! static sighandler wait_sigint_handler __P((int));
! static sighandler sigchld_handler __P((int));
! static sighandler sigwinch_sighandler __P((int));
! static sighandler sigcont_sighandler __P((int));
! static sighandler sigstop_sighandler __P((int));
! 
! static int waitchld __P((pid_t, int));
! 
! static PROCESS *find_pipeline __P((pid_t));
! 
! static char *current_working_directory __P((void));
! static char *job_working_directory __P((void));
! static char *printable_job_status __P((int, PROCESS *, int));
! 
! static pid_t find_last_pid __P((int));
! static pid_t last_pid __P((int));
! 
! static int set_new_line_discipline __P((int));
! static int map_over_jobs __P((sh_job_map_func_t *, int, int));
! static int job_last_stopped __P((int));
! static int job_last_running __P((int));
! static int most_recent_job_in_state __P((int, JOB_STATE));
! static int find_job __P((pid_t));
! static int print_job __P((JOB *, int, int, int));
! static int process_exit_status __P((WAIT));
! static int job_exit_status __P((int));
! static int set_job_status_and_cleanup __P((int));
! 
! static WAIT raw_job_exit_status __P((int));
! 
! static void notify_of_job_status __P((void));
! static void cleanup_dead_jobs __P((void));
! static void discard_pipeline __P((PROCESS *));
! static void add_process __P((char *, pid_t));
! static void print_pipeline __P((PROCESS *, int, int, FILE *));
! static void pretty_print_job __P((int, int, FILE *));
! static void set_current_job __P((int));
! static void reset_current __P((void));
! static void set_job_running __P((int));
! static void setjstatus __P((int));
! static void mark_all_jobs_as_dead __P((void));
! static void mark_dead_jobs_as_notified __P((int));
! static void restore_sigint_handler __P((void));
  #if defined (PGRP_PIPE)
! static void pipe_read __P((int *));
! static void pipe_close __P((int *));
  #endif
  
***************
*** 244,250 ****
  static int jobs_list_frozen;
  
- static sigset_t empty_sigset;
- static sigset_t sigchld_sigset;
- 
  static char retcode_name_buffer[64];
  
--- 279,282 ----
***************
*** 485,489 ****
        newjob->deferred = deferred;
  
!       newjob->j_cleanup = (VFunction *)NULL;
        newjob->cleanarg = (PTR_T) NULL;
  
--- 517,521 ----
        newjob->deferred = deferred;
  
!       newjob->j_cleanup = (sh_vptrfunc_t *)NULL;
        newjob->cleanarg = (PTR_T) NULL;
  
***************
*** 556,560 ****
  
    if (warn_stopped && subshell_environment == 0 && STOPPED (job_index))
!     internal_warning ("deleting stopped job %d with process group %d", job_index+1, jobs[job_index]->pgrp);
  
    temp = jobs[job_index];
--- 588,592 ----
  
    if (warn_stopped && subshell_environment == 0 && STOPPED (job_index))
!     internal_warning ("deleting stopped job %d with process group %ld", job_index+1, (long)jobs[job_index]->pgrp);
  
    temp = jobs[job_index];
***************
*** 678,682 ****
  static int
  map_over_jobs (func, arg1, arg2)
!      Function *func;
       int arg1, arg2;
  {
--- 710,714 ----
  static int
  map_over_jobs (func, arg1, arg2)
!      sh_job_map_func_t *func;
       int arg1, arg2;
  {
***************
*** 848,854 ****
  
    if (job != NO_JOB)
!     printf ("[%d] %d\n", job + 1, (int)pid);
    else
!     programming_error ("describe_pid: %d: no such pid", (int)pid);
  
    UNBLOCK_CHILD (oset);
--- 880,886 ----
  
    if (job != NO_JOB)
!     printf ("[%d] %ld\n", job + 1, (long)pid);
    else
!     programming_error ("describe_pid: %ld: no such pid", (long)pid);
  
    UNBLOCK_CHILD (oset);
***************
*** 881,887 ****
      {
        if (WIFSTOPPED (p->status))
! 	temp = (char *)strsignal (WSTOPSIG (p->status));
        else if (WIFSIGNALED (p->status))
! 	temp = (char *)strsignal (WTERMSIG (p->status));
        else if (WIFEXITED (p->status))
  	{
--- 913,919 ----
      {
        if (WIFSTOPPED (p->status))
! 	temp = strsignal (WSTOPSIG (p->status));
        else if (WIFSIGNALED (p->status))
! 	temp = strsignal (WTERMSIG (p->status));
        else if (WIFEXITED (p->status))
  	{
***************
*** 948,952 ****
  
        if (format != JLIST_STANDARD)
! 	fprintf (stream, "%5d", (int)p->pid);
  
        fprintf (stream, " ");
--- 980,984 ----
  
        if (format != JLIST_STANDARD)
! 	fprintf (stream, "%5ld", (long)p->pid);
  
        fprintf (stream, " ");
***************
*** 980,984 ****
  	      fprintf (stream, "%*s", name_padding, "");
  
! 	      if ((WIFSTOPPED (show->status) == 0) && WIFCORED (show->status))
  		fprintf (stream, "(core dumped) ");
  	    }
--- 1012,1018 ----
  	      fprintf (stream, "%*s", name_padding, "");
  
! 	      if ((WIFSTOPPED (show->status) == 0) &&
! 		  (WIFCONTINUED (show->status) == 0) &&
! 		  WIFCORED (show->status))
  		fprintf (stream, "(core dumped) ");
  	    }
***************
*** 1036,1040 ****
    if (format == JLIST_PID_ONLY)
      {
!       fprintf (stream, "%d\n", (int)jobs[job_index]->pipe->pid);
        UNBLOCK_CHILD (oset);
        return;
--- 1070,1074 ----
    if (format == JLIST_PID_ONLY)
      {
!       fprintf (stream, "%ld\n", (long)jobs[job_index]->pipe->pid);
        UNBLOCK_CHILD (oset);
        return;
***************
*** 1199,1203 ****
  	     shells. */
  	  if (setpgid (mypid, pipeline_pgrp) < 0)
! 	    sys_error ("child setpgid (%d to %d)", mypid, pipeline_pgrp);
  #if defined (PGRP_PIPE)
  	  if (pipeline_pgrp == mypid)
--- 1233,1237 ----
  	     shells. */
  	  if (setpgid (mypid, pipeline_pgrp) < 0)
! 	    sys_error ("child setpgid (%ld to %ld)", (long)mypid, (long)pipeline_pgrp);
  #if defined (PGRP_PIPE)
  	  if (pipeline_pgrp == mypid)
***************
*** 1383,1387 ****
  	     this time. */
  	  if (interactive)
! 	    sys_error ("[%d: %d] tcgetattr", getpid (), shell_level);
  #endif
  	  return -1;
--- 1417,1421 ----
  	     this time. */
  	  if (interactive)
! 	    sys_error ("[%ld: %d] tcgetattr", (long)getpid (), shell_level);
  #endif
  	  return -1;
***************
*** 1422,1426 ****
  	     this time. */
  	  if (interactive)
! 	    sys_error ("[%d: %d] tcsetattr", getpid (), shell_level);
  	  return -1;
  	}
--- 1456,1460 ----
  	     this time. */
  	  if (interactive)
! 	    sys_error ("[%ld: %d] tcsetattr", (long)getpid (), shell_level);
  	  return -1;
  	}
***************
*** 1479,1483 ****
    if (child == 0)
      {
!       internal_error ("wait: pid %d is not a child of this shell", pid);
        return (127);
      }
--- 1513,1517 ----
    if (child == 0)
      {
!       internal_error ("wait: pid %ld is not a child of this shell", (long)pid);
        return (127);
      }
***************
*** 1617,1620 ****
--- 1651,1655 ----
  static WAIT
  raw_job_exit_status (job)
+      int job;
  {
    register PROCESS *p;
***************
*** 1627,1631 ****
     (rightmost) process in the job's pipeline, modified if the job was killed
     by a signal or stopped. */
! static WAIT
  job_exit_status (job)
       int job;
--- 1662,1666 ----
     (rightmost) process in the job's pipeline, modified if the job was killed
     by a signal or stopped. */
! static int
  job_exit_status (job)
       int job;
***************
*** 1642,1646 ****
  	  give_terminal_to (shell_pgrp, 0); \
  	  UNBLOCK_CHILD (oset); \
! 	  internal_error ("wait_for: No record of process %d", pid); \
  	  restore_sigint_handler (); \
  	  return (termination_state = 127); \
--- 1677,1681 ----
  	  give_terminal_to (shell_pgrp, 0); \
  	  UNBLOCK_CHILD (oset); \
! 	  internal_error ("wait_for: No record of process %ld", (long)pid); \
  	  restore_sigint_handler (); \
  	  return (termination_state = 127); \
***************
*** 1784,1788 ****
  #if 0
  if (job == NO_JOB)
!   itrace("wait_for: job == NO_JOB, giving the terminal to shell_pgrp (%d)", shell_pgrp);
  #endif
  
--- 1819,1823 ----
  #if 0
  if (job == NO_JOB)
!   itrace("wait_for: job == NO_JOB, giving the terminal to shell_pgrp (%ld)", (long)shell_pgrp);
  #endif
  
***************
*** 2210,2220 ****
    sigset_t set, oset;
  
-   BLOCK_CHILD (set, oset);
-   p = find_pipeline (pid);
-   job = find_job (pid);
- 
    result = EXECUTION_SUCCESS;
    if (group)
      {
        if (job != NO_JOB)
  	{
--- 2245,2255 ----
    sigset_t set, oset;
  
    result = EXECUTION_SUCCESS;
    if (group)
      {
+       BLOCK_CHILD (set, oset);
+       p = find_pipeline (pid);
+       job = find_job (pid);
+ 
        if (job != NO_JOB)
  	{
***************
*** 2252,2260 ****
        else
  	result = killpg (pid, sig);
      }
    else
      result = kill (pid, sig);
  
-   UNBLOCK_CHILD (oset);
    return (result);
  }
--- 2287,2296 ----
        else
  	result = killpg (pid, sig);
+ 
+       UNBLOCK_CHILD (oset);
      }
    else
      result = kill (pid, sig);
  
    return (result);
  }
***************
*** 2303,2311 ****
  	 is not active.  XXX - was interactive_shell instead of job_control */
        waitpid_flags = (job_control && subshell_environment == 0)
! 			? WUNTRACED
  			: 0;
        if (sigchld || block == 0)
  	waitpid_flags |= WNOHANG;
        pid = WAITPID (-1, &status, waitpid_flags);
        /* The check for WNOHANG is to make sure we decrement sigchld only
  	 if it was non-zero before we called waitpid. */
--- 2339,2348 ----
  	 is not active.  XXX - was interactive_shell instead of job_control */
        waitpid_flags = (job_control && subshell_environment == 0)
! 			? (WUNTRACED|WCONTINUED)
  			: 0;
        if (sigchld || block == 0)
  	waitpid_flags |= WNOHANG;
        pid = WAITPID (-1, &status, waitpid_flags);
+ 
        /* The check for WNOHANG is to make sure we decrement sigchld only
  	 if it was non-zero before we called waitpid. */
***************
*** 2328,2332 ****
  	continue;	/* jumps right to the test */
  
!       children_exited++;
  
        /* Locate our PROCESS for this pid. */
--- 2365,2372 ----
  	continue;	/* jumps right to the test */
  
!       /* children_exited is used to run traps on SIGCHLD.  We don't want to
!          run the trap if a process is just being continued. */
!       if (WIFCONTINUED(status) == 0)
! 	children_exited++;
  
        /* Locate our PROCESS for this pid. */
***************
*** 2343,2349 ****
  	child = child->next;
  
!       /* Remember status, and fact that process is not running. */
        child->status = status;
!       child->running = 0;
  
        job = find_job (pid);
--- 2383,2389 ----
  	child = child->next;
  
!       /* Remember status, and whether or not the process is running. */
        child->status = status;
!       child->running = WIFCONTINUED(status) ? 1 : 0;
  
        job = find_job (pid);
***************
*** 2425,2430 ****
  
    /* If job_state != 0, the job is still running, so don't bother with
!      setting the process exit status and job state. */
!   if (job_state != 0)
      return 0;
  
--- 2465,2471 ----
  
    /* If job_state != 0, the job is still running, so don't bother with
!      setting the process exit status and job state unless we're
!      transitioning from stopped to running. */
!   if (job_state != 0 && JOBSTATE(job) != JSTOPPED)
      return 0;
  
***************
*** 2443,2446 ****
--- 2484,2492 ----
  	breaking = loop_level;
      }
+   else if (job_state != 0)	/* was stopped, now running */
+     {
+       jobs[job]->state = JRUNNING;
+       call_set_current++;
+     }
    else
      {
***************
*** 2457,2461 ****
  	{
  	  (*jobs[job]->j_cleanup) (jobs[job]->cleanarg);
! 	  jobs[job]->j_cleanup = (VFunction *)NULL;
  	}
      }
--- 2503,2507 ----
  	{
  	  (*jobs[job]->j_cleanup) (jobs[job]->cleanarg);
! 	  jobs[job]->j_cleanup = (sh_vptrfunc_t *)NULL;
  	}
      }
***************
*** 2589,2596 ****
    begin_unwind_frame ("SIGCHLD trap");
    unwind_protect_int (last_command_exit_value);
!   if (sizeof (pid_t) == sizeof (short))
!     unwind_protect_short (last_made_pid);
!   else
!     unwind_protect_int (last_made_pid);
    unwind_protect_int (interrupt_immediately);
    unwind_protect_int (jobs_list_frozen);
--- 2635,2639 ----
    begin_unwind_frame ("SIGCHLD trap");
    unwind_protect_int (last_command_exit_value);
!   unwind_protect_var (last_made_pid);
    unwind_protect_int (interrupt_immediately);
    unwind_protect_int (jobs_list_frozen);
***************
*** 2846,2853 ****
  debug_print_pgrps ()
  {
!   itrace("original_pgrp = %d shell_pgrp = %d terminal_pgrp = %d",
! 	 original_pgrp, shell_pgrp, terminal_pgrp);
!   itrace("tcgetpgrp(%d) -> %d, getpgid(0) -> %d",
! 	 shell_tty, tcgetpgrp (shell_tty), getpgid(0));
  }
  #endif
--- 2889,2896 ----
  debug_print_pgrps ()
  {
!   itrace("original_pgrp = %ld shell_pgrp = %ld terminal_pgrp = %ld",
! 	 (long)original_pgrp, (long)shell_pgrp, (long)terminal_pgrp);
!   itrace("tcgetpgrp(%d) -> %ld, getpgid(0) -> %ld",
! 	 shell_tty, (long)tcgetpgrp (shell_tty), (long)getpgid(0));
  }
  #endif
***************
*** 2912,2916 ****
  static SigHandler *old_tstp, *old_ttou, *old_ttin;
  static SigHandler *old_cont = (SigHandler *)SIG_DFL;
- static sighandler sigstop_sighandler (), sigcont_sighandler ();
  
  #if defined (TIOCGWINSZ) && defined (SIGWINCH)
--- 2955,2958 ----
***************
*** 3046,3051 ****
  	  /* Maybe we should print an error message? */
  #if 0
! 	  sys_error ("tcsetpgrp(%d) failed: pid %d to pgrp %d",
! 	    shell_tty, getpid(), pgrp);
  #endif
  	  r = -1;
--- 3088,3093 ----
  	  /* Maybe we should print an error message? */
  #if 0
! 	  sys_error ("tcsetpgrp(%d) failed: pid %ld to pgrp %ld",
! 	    shell_tty, (long)getpid(), (long)pgrp);
  #endif
  	  r = -1;
diff -Nrc2 bash-2.05/jobs.h bash-2.05a/jobs.h
*** bash-2.05/jobs.h	Mon Mar 26 11:03:37 2001
--- bash-2.05a/jobs.h	Tue Aug 28 09:50:11 2001
***************
*** 43,46 ****
--- 43,51 ----
     the group leader. */
  
+ /* Values for the `running' field of a struct process. */
+ #define PS_DONE		0
+ #define PS_RUNNING	1
+ #define PS_STOPPED	2
+ 
  /* Each child of the shell is remembered in a STRUCT PROCESS.  A chain of
     such structures is a pipeline.  The chain is circular. */
***************
*** 79,83 ****
  #if defined (JOB_CONTROL)
    COMMAND *deferred;	/* Commands that will execute when this job is done. */
!   VFunction *j_cleanup; /* Cleanup function to call when job marked JDEAD */
    PTR_T cleanarg;	/* Argument passed to (*j_cleanup)() */
  #endif /* JOB_CONTROL */
--- 84,88 ----
  #if defined (JOB_CONTROL)
    COMMAND *deferred;	/* Commands that will execute when this job is done. */
!   sh_vptrfunc_t *j_cleanup; /* Cleanup function to call when job marked JDEAD */
    PTR_T cleanarg;	/* Argument passed to (*j_cleanup)() */
  #endif /* JOB_CONTROL */
diff -Nrc2 bash-2.05/lib/glob/ChangeLog bash-2.05a/lib/glob/ChangeLog
*** bash-2.05/lib/glob/ChangeLog	Tue Mar 23 12:44:35 1993
--- bash-2.05a/lib/glob/ChangeLog	Wed Dec 31 19:00:00 1969
***************
*** 1,13 ****
- Thu Oct 29 08:58:12 1992  Brian Fox  (bfox@cubit)
- 
- 	* glob.c (glob_filename): Fix tiny memory leak.  Rework some
- 	comments.
- 
- Mon Jul 20 10:57:36 1992  Brian Fox  (bfox@cubit)
- 
- 	* glob.c: (glob_filename) Change use of rindex () to strrchr ().
- 
- Thu Jul  9 10:02:47 1992  Brian Fox  (bfox@cubit)
- 
- 	* fnmatch.c: (fnmatch) Only process `[' as the start of a bracket
- 	expression if there is a closing `]' present in the string.
--- 0 ----
diff -Nrc2 bash-2.05/lib/glob/Makefile.in bash-2.05a/lib/glob/Makefile.in
*** bash-2.05/lib/glob/Makefile.in	Thu Aug  5 10:52:57 1999
--- bash-2.05a/lib/glob/Makefile.in	Wed Sep 12 10:37:00 2001
***************
*** 63,72 ****
  
  # The C code source files for this library.
! CSOURCES = $(srcdir)/glob.c $(srcdir)/fnmatch.c
  
  # The header files for this library.
! HSOURCES = $(srcdir)/fnmatch.h
  
! OBJECTS = glob.o fnmatch.o
  
  # The texinfo files which document this library.
--- 63,72 ----
  
  # The C code source files for this library.
! CSOURCES = $(srcdir)/glob.c $(srcdir)/strmatch.c
  
  # The header files for this library.
! HSOURCES = $(srcdir)/strmatch.h
  
! OBJECTS = glob.o strmatch.o
  
  # The texinfo files which document this library.
***************
*** 122,134 ****
  ######################################################################
  
! fnmatch.o: fnmatch.h
! fnmatch.o: $(BUILD_DIR)/config.h
  
  glob.o: $(BUILD_DIR)/config.h
  glob.o: $(topdir)/bashtypes.h $(BASHINCDIR)/ansi_stdlib.h $(topdir)/bashansi.h
  glob.o: $(BASHINCDIR)/posixstat.h $(BASHINCDIR)/memalloc.h
! glob.o: fnmatch.h
  
  # Rules for deficient makes, like SunOS and Solaris
! fnmatch.o: fnmatch.c
  glob.o: glob.c
--- 122,135 ----
  ######################################################################
  
! strmatch.o: strmatch.h
! strmatch.o: $(BUILD_DIR)/config.h
! strmatch.o: $(BASHINCDIR)/chartypes.h
  
  glob.o: $(BUILD_DIR)/config.h
  glob.o: $(topdir)/bashtypes.h $(BASHINCDIR)/ansi_stdlib.h $(topdir)/bashansi.h
  glob.o: $(BASHINCDIR)/posixstat.h $(BASHINCDIR)/memalloc.h
! glob.o: strmatch.h
  
  # Rules for deficient makes, like SunOS and Solaris
! strmatch.o: strmatch.c
  glob.o: glob.c
diff -Nrc2 bash-2.05/lib/glob/collsyms.h bash-2.05a/lib/glob/collsyms.h
*** bash-2.05/lib/glob/collsyms.h	Thu Aug  5 07:56:04 1999
--- bash-2.05a/lib/glob/collsyms.h	Tue Oct  2 16:55:59 2001
***************
*** 35,128 ****
  static COLLSYM posix_collsyms[] =
  {
!   "NUL",	'\0',
!   "SOH",	'\001',
!   "STX",	'\002',
!   "ETX",	'\003',
!   "EOT",	'\004',
!   "ENQ",	'\005',
!   "ACK",	'\006',
  #ifdef __STDC__
!   "alert",	'\a',
  #else
!   "alert",	'\007',
  #endif
!   "backspace",	'\b',
!   "tab",	'\t',
!   "newline",	'\n',
!   "vertical-tab",	'\v',
!   "form-feed",	'\f',
!   "carriage-return",	'\r',
!   "SO",		'\016',
!   "SI",		'\017',
!   "DLE",	'\020',
!   "DC1",	'\021',
!   "DC2",	'\022',
!   "DC3",	'\023',
!   "DC4",	'\024',
!   "NAK",	'\025',
!   "SYN",	'\026',
!   "ETB",	'\027',
!   "CAN",	'\030',
!   "EM",		'\031',
!   "SUB",	'\032',
!   "ESC",	'\033',
!   "IS4",	'\034',
!   "IS3",	'\035',
!   "IS2",	'\036',
!   "IS1",	'\037',
!   "space",		' ',
!   "exclamation-mark",	'!',
!   "quotation-mark",	'"',
!   "number-sign",	'#',
!   "dollar-sign",	'$',
!   "percent-sign",	'%',
!   "ampersand",		'&',
!   "apostrophe",		'\'',
!   "left-parenthesis",	'(',
!   "right-parenthesis",	')',
!   "asterisk",	'*',
!   "plus-sign",	'+',
!   "comma",	',',
!   "hyphen",	'-',
!   "minus",	'-',		/* extension from POSIX.2 */
!   "dash",	'-',		/* extension from POSIX.2 */
!   "period",	'.',
!   "slash",	'/',
!   "solidus",	'/',		/* extension from POSIX.2 */
!   "zero",	'0',
!   "one",	'1',
!   "two",	'2',
!   "three",	'3',
!   "four",	'4',
!   "five",	'5',
!   "six",	'6',
!   "seven",	'7',
!   "eight",	'8',
!   "nine",	'9',
!   "colon",	':',
!   "semicolon",	';',
!   "less-than-sign",	'<',
!   "equals-sign",	'=',
!   "greater-than-sign",	'>',
!   "question-mark",	'?',
!   "commercial-at",	'@',
!   /* upper-case letters omitted */
!   "left-square-bracket",'[',
!   "backslash",		'\\',
!   "reverse-solidus",	'\\',
!   "right-square-bracket",	']',
!   "circumflex",		'^',
!   "circumflex-accent",	'^',		/* extension from POSIX.2 */
!   "underscore",		'_',
!   "grave-accent",		'`',
!   /* lower-case letters omitted */
!   "left-brace",		'{',		/* extension from POSIX.2 */
!   "left-curly-bracket",	'{',
!   "vertical-line",	'|',
!   "right-brace",		'}',	/* extension from POSIX.2 */
!   "right-curly-bracket",	'}',
!   "tilde",		'~',
!   "DEL",	'\177',
!   0,	0,
  };
  
--- 35,140 ----
  static COLLSYM posix_collsyms[] =
  {
! 	{  "NUL",		'\0' },
! 	{  "SOH",		'\001' },
! 	{  "STX",		'\002' },
! 	{  "ETX",		'\003' },
! 	{  "EOT",		'\004' },
! 	{  "ENQ",		'\005' },
! 	{  "ACK",		'\006' },
  #ifdef __STDC__
! 	{  "alert",		'\a' },
  #else
! 	{  "alert",		'\007' },
  #endif
! 	{  "BS",		'\010' },
! 	{  "backspace",		'\b' },
! 	{  "HT",		'\011' },
! 	{  "tab",		'\t' },
! 	{  "LF",		'\012' },
! 	{  "newline",		'\n' },
! 	{  "VT",		'\013' },
! 	{  "vertical-tab",	'\v' },
! 	{  "FF",		'\014' },
! 	{  "form-feed",		'\f' },
! 	{  "CR",		'\015' },
! 	{  "carriage-return",	'\r' },
! 	{  "SO",		'\016' },
! 	{  "SI",		'\017' },
! 	{  "DLE",		'\020' },
! 	{  "DC1",		'\021' },
! 	{  "DC2",		'\022' },
! 	{  "DC3",		'\023' },
! 	{  "DC4",		'\024' },
! 	{  "NAK",		'\025' },
! 	{  "SYN",		'\026' },
! 	{  "ETB",		'\027' },
! 	{  "CAN",		'\030' },
! 	{  "EM",		'\031' },
! 	{  "SUB",		'\032' },
! 	{  "ESC",		'\033' },
! 	{  "IS4",		'\034' },
! 	{  "FS",		'\034' },
! 	{  "IS3",		'\035' },
! 	{  "GS",		'\035' },
! 	{  "IS2",		'\036' },
! 	{  "RS",		'\036' },
! 	{  "IS1",		'\037' },
! 	{  "US",		'\037' },
! 	{  "space",		' ' },
! 	{  "exclamation-mark",	'!' },
! 	{  "quotation-mark",	'"' },
! 	{  "number-sign",	'#' },
! 	{  "dollar-sign",	'$' },
! 	{  "percent-sign",	'%' },
! 	{  "ampersand",		'&' },
! 	{  "apostrophe",	'\'' },
! 	{  "left-parenthesis",	'(' },
! 	{  "right-parenthesis",	')' },
! 	{  "asterisk",		'*' },
! 	{  "plus-sign",		'+' },
! 	{  "comma",		',' },
! 	{  "hyphen",		'-' },
! 	{  "hyphen-minus",	'-' },
! 	{  "minus",		'-' },		/* extension from POSIX.2 */
! 	{  "dash",		'-' },		/* extension from POSIX.2 */
! 	{  "period",		'.' },
! 	{  "full-stop",		'.' },
! 	{  "slash",		'/' },
! 	{  "solidus",		'/' },		/* extension from POSIX.2 */
! 	{  "zero",		'0' },
! 	{  "one",		'1' },
! 	{  "two",		'2' },
! 	{  "three",		'3' },
! 	{  "four",		'4' },
! 	{  "five",		'5' },
! 	{  "six",		'6' },
! 	{  "seven",		'7' },
! 	{  "eight",		'8' },
! 	{  "nine",		'9' },
! 	{  "colon",		':' },
! 	{  "semicolon",		';' },
! 	{  "less-than-sign",	'<' },
! 	{  "equals-sign",	'=' },
! 	{  "greater-than-sign",	'>' },
! 	{  "question-mark",	'?' },
! 	{  "commercial-at",	'@' },
! 	/* upper-case letters omitted */
! 	{  "left-square-bracket",'[' },
! 	{  "backslash",		'\\' },
! 	{  "reverse-solidus",	'\\' },
! 	{  "right-square-bracket",']' },
! 	{  "circumflex",	'^' },
! 	{  "circumflex-accent",	'^' },		/* extension from POSIX.2 */
! 	{  "underscore",	'_' },
! 	{  "grave-accent",	'`' },
! 	/* lower-case letters omitted */
! 	{  "left-brace",	'{' },		/* extension from POSIX.2 */
! 	{  "left-curly-bracket",'{' },
! 	{  "vertical-line",	'|' },
! 	{  "right-brace",	'}' },	/* extension from POSIX.2 */
! 	{  "right-curly-bracket",'}' },
! 	{  "tilde",		'~' },
! 	{  "DEL",		'\177' },
! 	{  0,	0 },
  };
  
diff -Nrc2 bash-2.05/lib/glob/fnmatch.c bash-2.05a/lib/glob/fnmatch.c
*** bash-2.05/lib/glob/fnmatch.c	Fri Mar 16 13:24:27 2001
--- bash-2.05a/lib/glob/fnmatch.c	Wed Dec 31 19:00:00 1969
***************
*** 1,842 ****
- /* fnmatch.c -- ksh-like extended pattern matching for the shell and filename
- 		globbing. */
- 
- /* Copyright (C) 1991, 1997 Free Software Foundation, Inc.
- 
-    This file is part of GNU Bash, the Bourne Again SHell.
-    
-    Bash is free software; you can redistribute it and/or modify it under
-    the terms of the GNU General Public License as published by the Free
-    Software Foundation; either version 2, or (at your option) any later
-    version.
- 	      
-    Bash is distributed in the hope that it will be useful, but WITHOUT ANY
-    WARRANTY; without even the implied warranty of MERCHANTABILITY or
-    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-    for more details.
- 			 
-    You should have received a copy of the GNU General Public License along
-    with Bash; see the file COPYING.  If not, write to the Free Software
-    Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. */
- 
- #include <config.h>
- 
- #include <stdio.h>	/* for debugging */
- 				
- #include "fnmatch.h"
- #include "collsyms.h"
- #include <ctype.h>
- 
- #if defined (HAVE_STRING_H)
- #  include <string.h>
- #else
- #  include <strings.h>
- #endif /* HAVE_STRING_H */
- 
- static int gmatch ();
- static char *brackmatch ();
- #ifdef EXTENDED_GLOB
- static int extmatch ();
- static char *patscan ();
- #endif
-   
- #if !defined (isascii)
- #  define isascii(c)	((unsigned int)(c) <= 0177)
- #endif
- 
- /* Note that these evaluate C many times.  */
- 
- #ifndef isblank
- #  define isblank(c)	((c) == ' ' || (c) == '\t')
- #endif
- 
- #ifndef isgraph
- #  define isgraph(c)	((c) != ' ' && isprint((c)))
- #endif
- 
- #ifndef isxdigit
- #  define isxdigit(c)	(((c) >= '0' && (c) <= '9') || ((c) >= 'a' && (c) <= 'f') || ((c) >= 'A' && (c) <= 'F'))
- #endif
- 
- /* The result of FOLD is an `unsigned char' */
- # define FOLD(c) ((flags & FNM_CASEFOLD) && isupper ((unsigned char)c) \
- 	? tolower ((unsigned char)c) \
- 	: ((unsigned char)c))
- 
- #ifndef STREQ
- #define STREQ(a, b) ((a)[0] == (b)[0] && strcmp(a, b) == 0)
- #define STREQN(a, b, n) ((a)[0] == (b)[0] && strncmp(a, b, n) == 0)
- #endif
- 
- /* We use strcoll(3) for range comparisons in bracket expressions,
-    even though it can have unwanted side effects in locales
-    other than POSIX or US.  For instance, in the de locale, [A-Z] matches
-    all characters. */
- 
- #if defined (HAVE_STRCOLL)
- /* Helper function for collating symbol equivalence. */
- static int rangecmp (c1, c2)
-      int c1, c2;
- {
-   static char s1[2] = { ' ', '\0' };
-   static char s2[2] = { ' ', '\0' };
-   int ret;
- 
-   /* Eight bits only.  Period. */
-   c1 &= 0xFF;
-   c2 &= 0xFF;
- 
-   if (c1 == c2)
-     return (0);
- 
-   s1[0] = c1;
-   s2[0] = c2;
- 
-   if ((ret = strcoll (s1, s2)) != 0)
-     return ret;
-   return (c1 - c2);
- }
- #else /* !HAVE_STRCOLL */
- #  define rangecmp(c1, c2)	((int)(c1) - (int)(c2))
- #endif /* !HAVE_STRCOLL */
- 
- #if defined (HAVE_STRCOLL)
- static int collequiv (c1, c2)
-      int c1, c2;
- {
-   return (rangecmp (c1, c2) == 0);
- }
- #else
- #  define collequiv(c1, c2)	((c1) == (c2))
- #endif
- 
- static int
- collsym (s, len)
-      char *s;
-      int len;
- {
-   register struct _collsym *csp;
- 
-   for (csp = posix_collsyms; csp->name; csp++)
-     {
-       if (STREQN(csp->name, s, len) && csp->name[len] == '\0')
- 	return (csp->code);
-     }
-   if (len == 1)
-     return s[0];
-   return -1;
- }
- 
- int
- fnmatch (pattern, string, flags)
-      char *pattern;
-      char *string;
-      int flags;
- {
-   char *se, *pe;
- 
-   if (string == 0 || pattern == 0)
-     return FNM_NOMATCH;
- 
-   se = string + strlen (string);
-   pe = pattern + strlen (pattern);
- 
-   return (gmatch (string, se, pattern, pe, flags));
- }
- 
- /* Match STRING against the filename pattern PATTERN, returning zero if
-    it matches, FNM_NOMATCH if not.  */
- static int
- gmatch (string, se, pattern, pe, flags)
-      char *string, *se;
-      char *pattern, *pe;
-      int flags;
- {
-   register char *p, *n;		/* pattern, string */
-   register char c;		/* current pattern character */
-   register char sc;		/* current string character */
- 
-   p = pattern;
-   n = string;
- 
-   if (string == 0 || pattern == 0)
-     return FNM_NOMATCH;
- 
- #if DEBUG_MATCHING
- fprintf(stderr, "gmatch: string = %s; se = %s\n", string, se);
- fprintf(stderr, "gmatch: pattern = %s; pe = %s\n", pattern, pe);
- #endif
- 
-   while (p < pe)
-     {
-       c = *p++;
-       c = FOLD (c);
- 
-       sc = n < se ? *n : '\0';
- 
- #ifdef EXTENDED_GLOB
-       /* extmatch () will handle recursively calling gmatch, so we can
- 	 just return what extmatch() returns. */
-       if ((flags & FNM_EXTMATCH) && *p == '(' &&
- 	  (c == '+' || c == '*' || c == '?' || c == '@' || c == '!')) /* ) */
- 	{
- 	  int lflags;
- 	  /* If we're not matching the start of the string, we're not
- 	     concerned about the special cases for matching `.' */
- 	  lflags = (n == string) ? flags : (flags & ~FNM_PERIOD);
- 	  return (extmatch (c, n, se, p, pe, lflags));
- 	}
- #endif
- 
-       switch (c)
- 	{
- 	case '?':		/* Match single character */
- 	  if (sc == '\0')
- 	    return FNM_NOMATCH;
- 	  else if ((flags & FNM_PATHNAME) && sc == '/')
- 	    /* If we are matching a pathname, `?' can never match a `/'. */
- 	    return FNM_NOMATCH;
- 	  else if ((flags & FNM_PERIOD) && sc == '.' &&
- 		   (n == string || ((flags & FNM_PATHNAME) && n[-1] == '/')))
- 	    /* `?' cannot match a `.' if it is the first character of the
- 	       string or if it is the first character following a slash and
- 	       we are matching a pathname. */
- 	    return FNM_NOMATCH;
- 	  break;
- 
- 	case '\\':		/* backslash escape removes special meaning */
- 	  if (p == pe)
- 	    return FNM_NOMATCH;
- 
- 	  if ((flags & FNM_NOESCAPE) == 0)
- 	    {
- 	      c = *p++;
- 	      /* A trailing `\' cannot match. */
- 	      if (p > pe)
- 		return FNM_NOMATCH;
- 	      c = FOLD (c);
- 	    }
- 	  if (FOLD (sc) != (unsigned char)c)
- 	    return FNM_NOMATCH;
- 	  break;
- 
- 	case '*':		/* Match zero or more characters */
- 	  if (p == pe)
- 	    return 0;
- 	  
- 	  if ((flags & FNM_PERIOD) && sc == '.' &&
- 	      (n == string || ((flags & FNM_PATHNAME) && n[-1] == '/')))
- 	    /* `*' cannot match a `.' if it is the first character of the
- 	       string or if it is the first character following a slash and
- 	       we are matching a pathname. */
- 	    return FNM_NOMATCH;
- 
- 	  /* Collapse multiple consecutive, `*' and `?', but make sure that
- 	     one character of the string is consumed for each `?'. */
- 	  for (c = *p++; (c == '?' || c == '*'); c = *p++)
- 	    {
- 	      if ((flags & FNM_PATHNAME) && sc == '/')
- 		/* A slash does not match a wildcard under FNM_PATHNAME. */
- 		return FNM_NOMATCH;
- 	      else if (c == '?')
- 		{
- 		  if (sc == '\0')
- 		    return FNM_NOMATCH;
- 		  /* One character of the string is consumed in matching
- 		     this ? wildcard, so *??? won't match if there are
- 		     fewer than three characters. */
- 		  n++;
- 		  sc = n < se ? *n : '\0';
- 		}
- 
- #ifdef EXTENDED_GLOB
- 	      /* Handle ******(patlist) */
- 	      if ((flags & FNM_EXTMATCH) && c == '*' && *p == '(')  /*)*/
- 		{
- 		  char *newn;
- 		  /* We need to check whether or not the extended glob
- 		     pattern matches the remainder of the string.
- 		     If it does, we match the entire pattern. */
- 		  for (newn = n; newn < se; ++newn)
- 		    {
- 		      if (extmatch (c, newn, se, p, pe, flags) == 0)
- 			return (0);
- 		    }
- 		  /* We didn't match the extended glob pattern, but
- 		     that's OK, since we can match 0 or more occurrences.
- 		     We need to skip the glob pattern and see if we
- 		     match the rest of the string. */
- 		  newn = patscan (p + 1, pe, 0);
- 		  p = newn;
- 		}
- #endif
- 	      if (p == pe)
- 		break;
- 	    }
- 
- 	  /* If we've hit the end of the pattern and the last character of
- 	     the pattern was handled by the loop above, we've succeeded.
- 	     Otherwise, we need to match that last character. */
- 	  if (p == pe && (c == '?' || c == '*'))
- 	    return (0);
- 
- 	  /* General case, use recursion. */
- 	  {
- 	    unsigned char c1;
- 
- 	    c1 = (unsigned char)((flags & FNM_NOESCAPE) == 0 && c == '\\') ? *p : c;
- 	    c1 = FOLD (c1);
- 	    for (--p; n < se; ++n)
- 	      {
- 		/* Only call fnmatch if the first character indicates a
- 		   possible match.  We can check the first character if
- 		   we're not doing an extended glob match. */
- 		if ((flags & FNM_EXTMATCH) == 0 && c != '[' && FOLD (*n) != c1) /*]*/
- 		  continue;
- 
- 		/* If we're doing an extended glob match and the pattern is not
- 		   one of the extended glob patterns, we can check the first
- 		   character. */
- 		if ((flags & FNM_EXTMATCH) && p[1] != '(' && /*)*/
- 		    strchr ("?*+@!", *p) == 0 && c != '[' && FOLD (*n) != c1) /*]*/
- 		  continue;
- 
- 		/* Otherwise, we just recurse. */
- 		if (gmatch (n, se, p, pe, flags & ~FNM_PERIOD) == 0)
- 		  return (0);
- 	      }
- 	    return FNM_NOMATCH;
- 	  }
- 
- 	case '[':
- 	  {
- 	    if (sc == '\0' || n == se)
- 	      return FNM_NOMATCH;
- 
- 	    /* A character class cannot match a `.' if it is the first
- 	       character of the string or if it is the first character
- 	       following a slash and we are matching a pathname. */
- 	    if ((flags & FNM_PERIOD) && sc == '.' &&
- 		(n == string || ((flags & FNM_PATHNAME) && n[-1] == '/')))
- 	      return (FNM_NOMATCH);
- 
- 	    p = brackmatch (p, sc, flags);
- 	    if (p == 0)
- 	      return FNM_NOMATCH;
- 	  }
- 	  break;
- 
- 	default:
- 	  if ((unsigned char)c != FOLD (sc))
- 	    return (FNM_NOMATCH);
- 	}
- 
-       ++n;
-     }
- 
-   if (n == se)
-     return (0);
- 
-   if ((flags & FNM_LEADING_DIR) && *n == '/')
-     /* The FNM_LEADING_DIR flag says that "foo*" matches "foobar/frobozz".  */
-     return 0;
- 	  
-   return (FNM_NOMATCH);
- }
- 
- /* Parse a bracket expression collating symbol ([.sym.]) starting at P, find
-    the value of the symbol, and move P past the collating symbol expression.
-    The value is returned in *VP, if VP is not null. */
- static char *
- parse_collsym (p, vp)
-      char *p;
-      int *vp;
- {
-   register int pc;
-   int val;
- 
-   p++;				/* move past the `.' */
- 	  
-   for (pc = 0; p[pc]; pc++)
-     if (p[pc] == '.' && p[pc+1] == ']')
-       break;
-    val = collsym (p, pc);
-    if (vp)
-      *vp = val;
-    return (p + pc + 2);
- }
- 
- static char *
- brackmatch (p, test, flags)
-      char *p;
-      unsigned char test;
-      int flags;
- {
-   register char cstart, cend, c;
-   register int not;    /* Nonzero if the sense of the character class is inverted.  */
-   int pc, brcnt;
-   char *savep;
- 
-   test = FOLD (test);
- 
-   savep = p;
- 
-   /* POSIX.2 3.13.1 says that an exclamation mark (`!') shall replace the
-      circumflex (`^') in its role in a `nonmatching list'.  A bracket
-      expression starting with an unquoted circumflex character produces
-      unspecified results.  This implementation treats the two identically. */
-   if (not = (*p == '!' || *p == '^'))
-     ++p;
- 
-   c = *p++;
-   for (;;)
-     {
-       /* Initialize cstart and cend in case `-' is the last
- 	 character of the pattern. */
-       cstart = cend = c;
- 
-       /* POSIX.2 equivalence class:  [=c=].  See POSIX.2 2.8.3.2.  Find
- 	 the end of the equivalence class, move the pattern pointer past
- 	 it, and check for equivalence.  XXX - this handles only
- 	 single-character equivalence classes, which is wrong, or at
- 	 least incomplete. */
-       if (c == '[' && *p == '=' && p[2] == '=' && p[3] == ']')
- 	{
- 	  pc = FOLD (p[1]);
- 	  p += 4;
- 	  if (collequiv (test, pc))
- 	    {
- /*[*/	      /* Move past the closing `]', since the first thing we do at
- 		 the `matched:' label is back p up one. */
- 	      p++;
- 	      goto matched;
- 	    }
- 	  else
- 	    {
- 	      c = *p++;
- 	      if (c == '\0')
- 		return ((test == '[') ? savep : (char *)0); /*]*/
- 	      c = FOLD (c);
- 	      continue;
- 	    }
- 	}
- 
-       /* POSIX.2 character class expression.  See POSIX.2 2.8.3.2. */
-       if (c == '[' && *p == ':')	/*]*/
- 	{
- 	  pc = 0;	/* make sure invalid char classes don't match. */
- 	  if (STREQN (p+1, "alnum:]", 7))
- 	    { pc = isalnum (test); p += 8; }
- 	  else if (STREQN (p+1, "alpha:]", 7))
- 	    { pc = isalpha (test); p += 8; }
- 	  else if (STREQN (p+1, "blank:]", 7))
- 	    { pc = isblank (test); p += 8; }
- 	  else if (STREQN (p+1, "cntrl:]", 7))
- 	    { pc = iscntrl (test); p += 8; }
- 	  else if (STREQN (p+1, "digit:]", 7))
- 	    { pc = isdigit (test); p += 8; }
- 	  else if (STREQN (p+1, "graph:]", 7))
- 	    { pc = isgraph (test); p += 8; }
- 	  else if (STREQN (p+1, "lower:]", 7))
- 	    { pc = islower (test); p += 8; }
- 	  else if (STREQN (p+1, "print:]", 7))
- 	    { pc = isprint (test); p += 8; }
- 	  else if (STREQN (p+1, "punct:]", 7))
- 	    { pc = ispunct (test); p += 8; }
- 	  else if (STREQN (p+1, "space:]", 7))
- 	    { pc = isspace (test); p += 8; }
- 	  else if (STREQN (p+1, "upper:]", 7))
- 	    { pc = isupper (test); p += 8; }
- 	  else if (STREQN (p+1, "xdigit:]", 8))
- 	    { pc = isxdigit (test); p += 9; }
- 	  else if (STREQN (p+1, "ascii:]", 7))
- 	    { pc = isascii (test); p += 8; }
- 	  if (pc)
- 	    {
- /*[*/	      /* Move past the closing `]', since the first thing we do at
- 		 the `matched:' label is back p up one. */
- 	      p++;
- 	      goto matched;
- 	    }
- 	  else
- 	    {
- 	      /* continue the loop here, since this expression can't be
- 		 the first part of a range expression. */
- 	      c = *p++;
- 	      if (c == '\0')
- 		return ((test == '[') ? savep : (char *)0);
- 	      else if (c == ']')
- 		break;
- 	      c = FOLD (c);
- 	      continue;
- 	    }
- 	}
-  
-       /* POSIX.2 collating symbols.  See POSIX.2 2.8.3.2.  Find the end of
- 	 the symbol name, make sure it is terminated by `.]', translate
- 	 the name to a character using the external table, and do the
- 	 comparison. */
-       if (c == '[' && *p == '.')
- 	{
- 	  p = parse_collsym (p, &pc);
- 	  /* An invalid collating symbol cannot be the first point of a
- 	     range.  If it is, we set cstart to one greater than `test',
- 	     so any comparisons later will fail. */
- 	  cstart = (pc == -1) ? test + 1 : pc;
- 	}
- 
-       if (!(flags & FNM_NOESCAPE) && c == '\\')
- 	{
- 	  if (*p == '\0')
- 	    return (char *)0;
- 	  cstart = cend = *p++;
- 	}
- 
-       cstart = cend = FOLD (cstart);
- 
-       /* POSIX.2 2.8.3.1.2 says: `An expression containing a `[' that
- 	 is not preceded by a backslash and is not part of a bracket
- 	 expression produces undefined results.'  This implementation
- 	 treats the `[' as just a character to be matched if there is
- 	 not a closing `]'. */
-       if (c == '\0')
- 	return ((test == '[') ? savep : (char *)0);
- 
-       c = *p++;
-       c = FOLD (c);
- 
-       if ((flags & FNM_PATHNAME) && c == '/')
- 	/* [/] can never match when matching a pathname.  */
- 	return (char *)0;
- 
-       /* This introduces a range, unless the `-' is the last
- 	 character of the class.  Find the end of the range
- 	 and move past it. */
-       if (c == '-' && *p != ']')
- 	{
- 	  cend = *p++;
- 	  if (!(flags & FNM_NOESCAPE) && cend == '\\')
- 	    cend = *p++;
- 	  if (cend == '\0')
- 	    return (char *)0;
- 	  if (cend == '[' && *p == '.')
- 	    {
- 	      p = parse_collsym (p, &pc);
- 	      /* An invalid collating symbol cannot be the second part of a
- 		 range expression.  If we get one, we set cend to one fewer
- 		 than the test character to make sure the range test fails. */
- 	      cend = (pc == -1) ? test - 1 : pc;
- 	    }
- 	  cend = FOLD (cend);
- 
- 	  c = *p++;
- 
- 	  /* POSIX.2 2.8.3.2:  ``The ending range point shall collate
- 	     equal to or higher than the starting range point; otherwise
- 	     the expression shall be treated as invalid.''  Note that this
- 	     applies to only the range expression; the rest of the bracket
- 	     expression is still checked for matches. */
- 	  if (rangecmp (cstart, cend) > 0)
- 	    {
- 	      if (c == ']')
- 		break;
- 	      c = FOLD (c);
- 	      continue;
- 	    }
- 	}
- 
-       if (rangecmp (test, cstart) >= 0 && rangecmp (test, cend) <= 0)
- 	goto matched;
- 
-       if (c == ']')
- 	break;
-     }
-   /* No match. */
-   return (!not ? (char *)0 : p);
- 
- matched:
-   /* Skip the rest of the [...] that already matched.  */
- #if 0
-   brcnt = (c != ']') + (c == '[' && (*p == '=' || *p == ':' || *p == '.'));
- #else
-   c = *--p;
-   brcnt = 1;
- #endif
-   while (brcnt > 0)
-     {
-       /* A `[' without a matching `]' is just another character to match. */
-       if (c == '\0')
- 	return ((test == '[') ? savep : (char *)0);
- 
-       c = *p++;
-       if (c == '[' && (*p == '=' || *p == ':' || *p == '.'))
- 	brcnt++;
-       else if (c == ']')
- 	brcnt--;
-       else if (!(flags & FNM_NOESCAPE) && c == '\\')
- 	{
- 	  if (*p == '\0')
- 	    return (char *)0;
- 	  /* XXX 1003.2d11 is unclear if this is right. */
- 	  ++p;
- 	}
-     }
-   return (not ? (char *)0 : p);
- }
- 
- #if defined (EXTENDED_GLOB)
- /* ksh-like extended pattern matching:
- 
- 	[?*+@!](pat-list)
- 
-    where pat-list is a list of one or patterns separated by `|'.  Operation
-    is as follows:
- 
- 	?(patlist)	match zero or one of the given patterns
- 	*(patlist)	match zero or more of the given patterns
- 	+(patlist)	match one or more of the given patterns
- 	@(patlist)	match exactly one of the given patterns
- 	!(patlist)	match anything except one of the given patterns
- */
- 
- /* Scan a pattern starting at STRING and ending at END, keeping track of
-    embedded () and [].  If DELIM is 0, we scan until a matching `)'
-    because we're scanning a `patlist'.  Otherwise, we scan until we see
-    DELIM.  In all cases, we never scan past END.  The return value is the
-    first character after the matching DELIM. */
- static char *
- patscan (string, end, delim)
-      char *string, *end;
-      int delim;
- {
-   int pnest, bnest, cchar;
-   char *s, c, *bfirst;
- 
-   pnest = bnest = cchar = 0;
-   bfirst = 0;
-   for (s = string; c = *s; s++)
-     {
-       if (s >= end)
- 	return (s);
-       switch (c)
- 	{
- 	case '\0':
- 	  return ((char *)0);
- 
- 	/* `[' is not special inside a bracket expression, but it may
- 	   introduce one of the special POSIX bracket expressions
- 	   ([.SYM.], [=c=], [: ... :]) that needs special handling. */
- 	case '[':
- 	  if (bnest == 0)
- 	    {
- 	      bfirst = s + 1;
- 	      if (*bfirst == '!' || *bfirst == '^')
- 		bfirst++;
- 	      bnest++;
- 	    }
- 	  else if (s[1] == ':' || s[1] == '.' || s[1] == '=')
- 	    cchar = s[1];
- 	  break;
- 
- 	/* `]' is not special if it's the first char (after a leading `!'
- 	   or `^') in a bracket expression or if it's part of one of the
- 	   special POSIX bracket expressions ([.SYM.], [=c=], [: ... :]) */
- 	case ']':
- 	  if (bnest)
- 	    {
- 	      if (cchar && s[-1] == cchar)
- 		cchar = 0;
- 	      else if (s != bfirst)
- 		{
- 		  bnest--;
- 		  bfirst = 0;
- 		}
- 	    }
- 	  break;
- 
- 	case '(':
- 	  if (bnest == 0)
- 	    pnest++;
- 	  break;
- 
- 	case ')':
- #if 0
- 	  if (bnest == 0)
- 	    pnest--;
- 	  if (pnest <= 0)
- 	    return ++s;
- #else
- 	  if (bnest == 0 && pnest-- <= 0)
- 	    return ++s;
- #endif
- 	  break;
- 
- 	case '|':
- 	  if (bnest == 0 && pnest == 0 && delim == '|')
- 	    return ++s;
- 	  break;
- 	}
-     }
- 
-   return (char *)0;
- }
- 
- /* Return 0 if dequoted pattern matches S in the current locale. */
- static int
- strcompare (p, pe, s, se)
-      char *p, *pe, *s, *se;
- {
-   int ret;
-   char c1, c2;
- 
-   c1 = *pe;
-   c2 = *se;
- 
-   *pe = *se = '\0';
- #if defined (HAVE_STRCOLL)
-   ret = strcoll (p, s);
- #else
-   ret = strcmp (p, s);
- #endif
- 
-   *pe = c1;
-   *se = c2;
- 
-   return (ret == 0 ? ret : FNM_NOMATCH);
- }
- 
- /* Match a ksh extended pattern specifier.  Return FNM_NOMATCH on failure or
-    0 on success.  This is handed the entire rest of the pattern and string
-    the first time an extended pattern specifier is encountered, so it calls
-    gmatch recursively. */
- static int
- extmatch (xc, s, se, p, pe, flags)
-      int xc;		/* select which operation */
-      char *s, *se;
-      char *p, *pe;
-      int flags;
- {
-   char *prest;			/* pointer to rest of pattern */
-   char *psub;			/* pointer to sub-pattern */
-   char *pnext;			/* pointer to next sub-pattern */
-   char *srest;			/* pointer to rest of string */
-   int m1, m2;
- 
- #if DEBUG_MATCHING
- fprintf(stderr, "extmatch: xc = %c\n", xc);
- fprintf(stderr, "extmatch: s = %s; se = %s\n", s, se);
- fprintf(stderr, "extmatch: p = %s; pe = %s\n", p, pe);
- #endif
- 
-   prest = patscan (p + (*p == '('), pe, 0); /* ) */
-   if (prest == 0)
-     /* If PREST is 0, we failed to scan a valid pattern.  In this
-        case, we just want to compare the two as strings. */
-     return (strcompare (p - 1, pe, s, se));
- 
-   switch (xc)
-     {
-     case '+':			/* match one or more occurrences */
-     case '*':			/* match zero or more occurrences */
-       /* If we can get away with no matches, don't even bother.  Just
- 	 call gmatch on the rest of the pattern and return success if
- 	 it succeeds. */
-       if (xc == '*' && (gmatch (s, se, prest, pe, flags) == 0))
- 	return 0;
- 
-       /* OK, we have to do this the hard way.  First, we make sure one of
- 	 the subpatterns matches, then we try to match the rest of the
- 	 string. */
-       for (psub = p + 1; ; psub = pnext)
- 	{
- 	  pnext = patscan (psub, pe, '|');
- 	  for (srest = s; srest <= se; srest++)
- 	    {
- 	      /* Match this substring (S -> SREST) against this
- 		 subpattern (psub -> pnext - 1) */
- 	      m1 = gmatch (s, srest, psub, pnext - 1, flags) == 0;
- 	      /* OK, we matched a subpattern, so make sure the rest of the
- 		 string matches the rest of the pattern.  Also handle
- 		 multiple matches of the pattern. */
- 	      if (m1)
- 		m2 = (gmatch (srest, se, prest, pe, flags) == 0) ||
- 		      (s != srest && gmatch (srest, se, p - 1, pe, flags) == 0);
- 	      if (m1 && m2)
- 		return (0);
- 	    }
- 	  if (pnext == prest)
- 	    break;
- 	}
-       return (FNM_NOMATCH);
- 
-     case '?':		/* match zero or one of the patterns */
-     case '@':		/* match exactly one of the patterns */
-       /* If we can get away with no matches, don't even bother.  Just
- 	 call gmatch on the rest of the pattern and return success if
- 	 it succeeds. */
-       if (xc == '?' && (gmatch (s, se, prest, pe, flags) == 0))
- 	return 0;
- 
-       /* OK, we have to do this the hard way.  First, we see if one of
- 	 the subpatterns matches, then, if it does, we try to match the
- 	 rest of the string. */
-       for (psub = p + 1; ; psub = pnext)
- 	{
- 	  pnext = patscan (psub, pe, '|');
- 	  srest = (prest == pe) ? se : s;
- 	  for ( ; srest <= se; srest++)
- 	    {
- 	      if (gmatch (s, srest, psub, pnext - 1, flags) == 0 &&
- 		  gmatch (srest, se, prest, pe, flags) == 0)
- 		return (0);
- 	    }
- 	  if (pnext == prest)
- 	    break;
- 	}
-       return (FNM_NOMATCH);
- 
-     case '!':		/* match anything *except* one of the patterns */
-       for (srest = s; srest <= se; srest++)
- 	{
- 	  m1 = 0;
- 	  for (psub = p + 1; ; psub = pnext)
- 	    {
- 	      pnext = patscan (psub, pe, '|');
- 	      /* If one of the patterns matches, just bail immediately. */
- 	      if (m1 = (gmatch (s, srest, psub, pnext - 1, flags) == 0))
- 		break;
- 	      if (pnext == prest)
- 		break;
- 	    }
- 	  if (m1 == 0 && gmatch (srest, se, prest, pe, flags) == 0)
- 	    return (0);
- 	}
-       return (FNM_NOMATCH);
-     }
- 
-   return (FNM_NOMATCH);
- }
- #endif /* EXTENDED_GLOB */
- 
- #ifdef TEST
- main (c, v)
-      int c;
-      char **v;
- {
-   char *string, *pat;
- 
-   string = v[1];
-   pat = v[2];
- 
-   if (fnmatch (pat, string, 0) == 0)
-     {
-       printf ("%s matches %s\n", string, pat);
-       exit (0);
-     }
-   else
-     {
-       printf ("%s does not match %s\n", string, pat);
-       exit (1);
-     }
- }
- #endif
--- 0 ----
diff -Nrc2 bash-2.05/lib/glob/fnmatch.h bash-2.05a/lib/glob/fnmatch.h
*** bash-2.05/lib/glob/fnmatch.h	Thu Aug  5 07:56:38 1999
--- bash-2.05a/lib/glob/fnmatch.h	Wed Dec 31 19:00:00 1969
***************
*** 1,48 ****
- /* Copyright (C) 1991 Free Software Foundation, Inc.
- This file is part of the GNU C Library.
- 
- The GNU C Library is free software; you can redistribute it and/or
- modify it under the terms of the GNU Library General Public License as
- published by the Free Software Foundation; either version 2 of the
- License, or (at your option) any later version.
- 
- The GNU C Library is distributed in the hope that it will be useful,
- but WITHOUT ANY WARRANTY; without even the implied warranty of
- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- Library General Public License for more details.
- 
- You should have received a copy of the GNU Library General Public
- License along with the GNU C Library; see the file COPYING.LIB.  If
- not, write to the Free Software Foundation, Inc.,
- 59 Temple Place, Suite 330, Boston, MA 02111 USA.  */
- 
- #ifndef	_FNMATCH_H
- #define	_FNMATCH_H	1
- 
- #include "stdc.h"
- 
- /* We #undef these before defining them because some losing systems
-    (HP-UX A.08.07 for example) define these in <unistd.h>.  */
- #undef  FNM_PATHNAME
- #undef  FNM_NOESCAPE
- #undef  FNM_PERIOD
- 
- /* Bits set in the FLAGS argument to `fnmatch'.  */
- /* standard flags */
- #define	FNM_PATHNAME	(1 << 0) /* No wildcard can ever match `/'.  */
- #define	FNM_NOESCAPE	(1 << 1) /* Backslashes don't quote special chars.  */
- #define	FNM_PERIOD	(1 << 2) /* Leading `.' is matched only explicitly.  */
- 
- /* extended flags */
- #define FNM_LEADING_DIR	(1 << 3) /* Ignore `/...' after a match. */
- #define FNM_CASEFOLD	(1 << 4) /* Compare without regard to case. */
- #define FNM_EXTMATCH	(1 << 5) /* Use ksh-like extended matching. */
- 
- /* Value returned by `fnmatch' if STRING does not match PATTERN.  */
- #define	FNM_NOMATCH	1
- 
- /* Match STRING against the filename pattern PATTERN,
-    returning zero if it matches, FNM_NOMATCH if not.  */
- extern int fnmatch __P((char *, char *, int));
- 
- #endif /* _FNMATCH_H */
--- 0 ----
diff -Nrc2 bash-2.05/lib/glob/glob.c bash-2.05a/lib/glob/glob.c
*** bash-2.05/lib/glob/glob.c	Wed Feb 14 16:53:39 2001
--- bash-2.05a/lib/glob/glob.c	Thu Sep 13 15:13:24 2001
***************
*** 68,72 ****
  #endif /* !HAVE_DIRENT_H */
  
! #if defined (_POSIX_SOURCE) && !defined (STRUCT_DIRENT_HAS_D_INO)
  /* Posix does not require that the d_ino field be present, and some
     systems do not provide it. */
--- 68,72 ----
  #endif /* !HAVE_DIRENT_H */
  
! #if defined (_POSIX_SOURCE) && !defined (STRUCT_DIRENT_HAS_D_INO) || defined (BROKEN_DIRENT_D_INO)
  /* Posix does not require that the d_ino field be present, and some
     systems do not provide it. */
***************
*** 95,99 ****
  #endif
  
! #include "fnmatch.h"
  
  #if !defined (HAVE_STDLIB_H) && !defined (SHELL)
--- 95,99 ----
  #endif
  
! #include "strmatch.h"
  
  #if !defined (HAVE_STDLIB_H) && !defined (SHELL)
***************
*** 132,138 ****
  int
  glob_pattern_p (pattern)
!      char *pattern;
  {
!   register char *p;
    register char c;
    int bopen;
--- 132,138 ----
  int
  glob_pattern_p (pattern)
!      const char *pattern;
  {
!   register const char *p;
    register char c;
    int bopen;
***************
*** 257,261 ****
    register char **name_vector;
    register unsigned int i;
!   int flags;		/* Flags passed to fnmatch (). */
  
    lastlink = 0;
--- 257,261 ----
    register char **name_vector;
    register unsigned int i;
!   int flags;		/* Flags passed to strmatch (). */
  
    lastlink = 0;
***************
*** 343,347 ****
  	return ((char **) &glob_error_return);
  
!       /* Compute the flags that will be passed to fnmatch().  We don't
  	 need to do this every time through the loop. */
        flags = (noglob_dot_filenames ? FNM_PERIOD : 0) | FNM_PATHNAME;
--- 343,347 ----
  	return ((char **) &glob_error_return);
  
!       /* Compute the flags that will be passed to strmatch().  We don't
  	 need to do this every time through the loop. */
        flags = (noglob_dot_filenames ? FNM_PERIOD : 0) | FNM_PATHNAME;
***************
*** 395,399 ****
  	    continue;
  
! 	  if (fnmatch (pat, dp->d_name, flags) != FNM_NOMATCH)
  	    {
  	      nextlink = (struct globval *) alloca (sizeof (struct globval));
--- 395,399 ----
  	    continue;
  
! 	  if (strmatch (pat, dp->d_name, flags) != FNM_NOMATCH)
  	    {
  	      nextlink = (struct globval *) alloca (sizeof (struct globval));
diff -Nrc2 bash-2.05/lib/glob/glob.h bash-2.05a/lib/glob/glob.h
*** bash-2.05/lib/glob/glob.h	Thu Aug  5 07:57:11 1999
--- bash-2.05a/lib/glob/glob.h	Thu Sep 13 15:12:20 2001
***************
*** 21,25 ****
  #include "stdc.h"
  
! extern int glob_pattern_p __P((char *));
  extern char **glob_vector __P((char *, char *));
  extern char **glob_filename __P((char *));
--- 21,25 ----
  #include "stdc.h"
  
! extern int glob_pattern_p __P((const char *));
  extern char **glob_vector __P((char *, char *));
  extern char **glob_filename __P((char *));
diff -Nrc2 bash-2.05/lib/glob/strmatch.c bash-2.05a/lib/glob/strmatch.c
*** bash-2.05/lib/glob/strmatch.c	Wed Dec 31 19:00:00 1969
--- bash-2.05a/lib/glob/strmatch.c	Mon Oct 22 10:04:52 2001
***************
*** 0 ****
--- 1,845 ----
+ /* strmatch.c -- ksh-like extended pattern matching for the shell and filename
+ 		globbing. */
+ 
+ /* Copyright (C) 1991, 1997 Free Software Foundation, Inc.
+ 
+    This file is part of GNU Bash, the Bourne Again SHell.
+    
+    Bash is free software; you can redistribute it and/or modify it under
+    the terms of the GNU General Public License as published by the Free
+    Software Foundation; either version 2, or (at your option) any later
+    version.
+ 	      
+    Bash is distributed in the hope that it will be useful, but WITHOUT ANY
+    WARRANTY; without even the implied warranty of MERCHANTABILITY or
+    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+    for more details.
+ 			 
+    You should have received a copy of the GNU General Public License along
+    with Bash; see the file COPYING.  If not, write to the Free Software
+    Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. */
+ 
+ #include <config.h>
+ 
+ #include <stdio.h>	/* for debugging */
+ 				
+ #include "strmatch.h"
+ #include "collsyms.h"
+ #include <chartypes.h>
+ 
+ #if defined (HAVE_STRING_H)
+ #  include <string.h>
+ #else
+ #  include <strings.h>
+ #endif /* HAVE_STRING_H */
+ 
+ static int gmatch ();
+ static char *brackmatch ();
+ #ifdef EXTENDED_GLOB
+ static int extmatch ();
+ static char *patscan ();
+ #endif
+   
+ #if !defined (isascii) && !defined (HAVE_ISASCII)
+ #  define isascii(c)	((unsigned int)(c) <= 0177)
+ #endif
+ 
+ /* The result of FOLD is an `unsigned char' */
+ # define FOLD(c) ((flags & FNM_CASEFOLD) \
+ 	? TOLOWER ((unsigned char)c) \
+ 	: ((unsigned char)c))
+ 
+ #ifndef STREQ
+ #define STREQ(a, b) ((a)[0] == (b)[0] && strcmp(a, b) == 0)
+ #define STREQN(a, b, n) ((a)[0] == (b)[0] && strncmp(a, b, n) == 0)
+ #endif
+ 
+ /* We use strcoll(3) for range comparisons in bracket expressions,
+    even though it can have unwanted side effects in locales
+    other than POSIX or US.  For instance, in the de locale, [A-Z] matches
+    all characters. */
+ 
+ #if defined (HAVE_STRCOLL)
+ /* Helper function for collating symbol equivalence. */
+ static int rangecmp (c1, c2)
+      int c1, c2;
+ {
+   static char s1[2] = { ' ', '\0' };
+   static char s2[2] = { ' ', '\0' };
+   int ret;
+ 
+   /* Eight bits only.  Period. */
+   c1 &= 0xFF;
+   c2 &= 0xFF;
+ 
+   if (c1 == c2)
+     return (0);
+ 
+   s1[0] = c1;
+   s2[0] = c2;
+ 
+   if ((ret = strcoll (s1, s2)) != 0)
+     return ret;
+   return (c1 - c2);
+ }
+ #else /* !HAVE_STRCOLL */
+ #  define rangecmp(c1, c2)	((int)(c1) - (int)(c2))
+ #endif /* !HAVE_STRCOLL */
+ 
+ #if defined (HAVE_STRCOLL)
+ static int collequiv (c1, c2)
+      int c1, c2;
+ {
+   return (rangecmp (c1, c2) == 0);
+ }
+ #else
+ #  define collequiv(c1, c2)	((c1) == (c2))
+ #endif
+ 
+ static int
+ collsym (s, len)
+      char *s;
+      int len;
+ {
+   register struct _collsym *csp;
+ 
+   for (csp = posix_collsyms; csp->name; csp++)
+     {
+       if (STREQN(csp->name, s, len) && csp->name[len] == '\0')
+ 	return (csp->code);
+     }
+   if (len == 1)
+     return s[0];
+   return -1;
+ }
+ 
+ #ifdef HAVE_LIBC_FNM_EXTMATCH
+ int
+ strmatch (pattern, string, flags)
+      char *pattern;
+      char *string;
+      int flags;
+ {
+   char *se, *pe;
+ 
+   if (string == 0 || pattern == 0)
+     return FNM_NOMATCH;
+ 
+   return (fnmatch (pattern, string, flags));
+ }
+ #else /* !HAVE_LIBC_FNM_EXTMATCH */
+ int
+ strmatch (pattern, string, flags)
+      char *pattern;
+      char *string;
+      int flags;
+ {
+   char *se, *pe;
+ 
+   if (string == 0 || pattern == 0)
+     return FNM_NOMATCH;
+ 
+   se = string + strlen (string);
+   pe = pattern + strlen (pattern);
+ 
+   return (gmatch (string, se, pattern, pe, flags));
+ }
+ #endif /* !HAVE_LIBC_FNM_EXTMATCH */
+ 
+ /* Match STRING against the filename pattern PATTERN, returning zero if
+    it matches, FNM_NOMATCH if not.  */
+ static int
+ gmatch (string, se, pattern, pe, flags)
+      char *string, *se;
+      char *pattern, *pe;
+      int flags;
+ {
+   register char *p, *n;		/* pattern, string */
+   register char c;		/* current pattern character */
+   register char sc;		/* current string character */
+ 
+   p = pattern;
+   n = string;
+ 
+   if (string == 0 || pattern == 0)
+     return FNM_NOMATCH;
+ 
+ #if DEBUG_MATCHING
+ fprintf(stderr, "gmatch: string = %s; se = %s\n", string, se);
+ fprintf(stderr, "gmatch: pattern = %s; pe = %s\n", pattern, pe);
+ #endif
+ 
+   while (p < pe)
+     {
+       c = *p++;
+       c = FOLD (c);
+ 
+       sc = n < se ? *n : '\0';
+ 
+ #ifdef EXTENDED_GLOB
+       /* extmatch () will handle recursively calling gmatch, so we can
+ 	 just return what extmatch() returns. */
+       if ((flags & FNM_EXTMATCH) && *p == '(' &&
+ 	  (c == '+' || c == '*' || c == '?' || c == '@' || c == '!')) /* ) */
+ 	{
+ 	  int lflags;
+ 	  /* If we're not matching the start of the string, we're not
+ 	     concerned about the special cases for matching `.' */
+ 	  lflags = (n == string) ? flags : (flags & ~FNM_PERIOD);
+ 	  return (extmatch (c, n, se, p, pe, lflags));
+ 	}
+ #endif
+ 
+       switch (c)
+ 	{
+ 	case '?':		/* Match single character */
+ 	  if (sc == '\0')
+ 	    return FNM_NOMATCH;
+ 	  else if ((flags & FNM_PATHNAME) && sc == '/')
+ 	    /* If we are matching a pathname, `?' can never match a `/'. */
+ 	    return FNM_NOMATCH;
+ 	  else if ((flags & FNM_PERIOD) && sc == '.' &&
+ 		   (n == string || ((flags & FNM_PATHNAME) && n[-1] == '/')))
+ 	    /* `?' cannot match a `.' if it is the first character of the
+ 	       string or if it is the first character following a slash and
+ 	       we are matching a pathname. */
+ 	    return FNM_NOMATCH;
+ 	  break;
+ 
+ 	case '\\':		/* backslash escape removes special meaning */
+ 	  if (p == pe)
+ 	    return FNM_NOMATCH;
+ 
+ 	  if ((flags & FNM_NOESCAPE) == 0)
+ 	    {
+ 	      c = *p++;
+ 	      /* A trailing `\' cannot match. */
+ 	      if (p > pe)
+ 		return FNM_NOMATCH;
+ 	      c = FOLD (c);
+ 	    }
+ 	  if (FOLD (sc) != (unsigned char)c)
+ 	    return FNM_NOMATCH;
+ 	  break;
+ 
+ 	case '*':		/* Match zero or more characters */
+ 	  if (p == pe)
+ 	    return 0;
+ 	  
+ 	  if ((flags & FNM_PERIOD) && sc == '.' &&
+ 	      (n == string || ((flags & FNM_PATHNAME) && n[-1] == '/')))
+ 	    /* `*' cannot match a `.' if it is the first character of the
+ 	       string or if it is the first character following a slash and
+ 	       we are matching a pathname. */
+ 	    return FNM_NOMATCH;
+ 
+ 	  /* Collapse multiple consecutive `*' and `?', but make sure that
+ 	     one character of the string is consumed for each `?'. */
+ 	  for (c = *p++; (c == '?' || c == '*'); c = *p++)
+ 	    {
+ 	      if ((flags & FNM_PATHNAME) && sc == '/')
+ 		/* A slash does not match a wildcard under FNM_PATHNAME. */
+ 		return FNM_NOMATCH;
+ 	      else if (c == '?')
+ 		{
+ 		  if (sc == '\0')
+ 		    return FNM_NOMATCH;
+ 		  /* One character of the string is consumed in matching
+ 		     this ? wildcard, so *??? won't match if there are
+ 		     fewer than three characters. */
+ 		  n++;
+ 		  sc = n < se ? *n : '\0';
+ 		}
+ 
+ #ifdef EXTENDED_GLOB
+ 	      /* Handle ******(patlist) */
+ 	      if ((flags & FNM_EXTMATCH) && c == '*' && *p == '(')  /*)*/
+ 		{
+ 		  char *newn;
+ 		  /* We need to check whether or not the extended glob
+ 		     pattern matches the remainder of the string.
+ 		     If it does, we match the entire pattern. */
+ 		  for (newn = n; newn < se; ++newn)
+ 		    {
+ 		      if (extmatch (c, newn, se, p, pe, flags) == 0)
+ 			return (0);
+ 		    }
+ 		  /* We didn't match the extended glob pattern, but
+ 		     that's OK, since we can match 0 or more occurrences.
+ 		     We need to skip the glob pattern and see if we
+ 		     match the rest of the string. */
+ 		  newn = patscan (p + 1, pe, 0);
+ 		  /* If NEWN is 0, we have an ill-formed pattern. */
+ 		  p = newn ? newn : pe;
+ 		}
+ #endif
+ 	      if (p == pe)
+ 		break;
+ 	    }
+ 
+ 	  /* If we've hit the end of the pattern and the last character of
+ 	     the pattern was handled by the loop above, we've succeeded.
+ 	     Otherwise, we need to match that last character. */
+ 	  if (p == pe && (c == '?' || c == '*'))
+ 	    return (0);
+ 
+ 	  /* General case, use recursion. */
+ 	  {
+ 	    unsigned char c1;
+ 
+ 	    c1 = (unsigned char)((flags & FNM_NOESCAPE) == 0 && c == '\\') ? *p : c;
+ 	    c1 = FOLD (c1);
+ 	    for (--p; n < se; ++n)
+ 	      {
+ 		/* Only call strmatch if the first character indicates a
+ 		   possible match.  We can check the first character if
+ 		   we're not doing an extended glob match. */
+ 		if ((flags & FNM_EXTMATCH) == 0 && c != '[' && FOLD (*n) != c1) /*]*/
+ 		  continue;
+ 
+ 		/* If we're doing an extended glob match and the pattern is not
+ 		   one of the extended glob patterns, we can check the first
+ 		   character. */
+ 		if ((flags & FNM_EXTMATCH) && p[1] != '(' && /*)*/
+ 		    strchr ("?*+@!", *p) == 0 && c != '[' && FOLD (*n) != c1) /*]*/
+ 		  continue;
+ 
+ 		/* Otherwise, we just recurse. */
+ 		if (gmatch (n, se, p, pe, flags & ~FNM_PERIOD) == 0)
+ 		  return (0);
+ 	      }
+ 	    return FNM_NOMATCH;
+ 	  }
+ 
+ 	case '[':
+ 	  {
+ 	    if (sc == '\0' || n == se)
+ 	      return FNM_NOMATCH;
+ 
+ 	    /* A character class cannot match a `.' if it is the first
+ 	       character of the string or if it is the first character
+ 	       following a slash and we are matching a pathname. */
+ 	    if ((flags & FNM_PERIOD) && sc == '.' &&
+ 		(n == string || ((flags & FNM_PATHNAME) && n[-1] == '/')))
+ 	      return (FNM_NOMATCH);
+ 
+ 	    p = brackmatch (p, sc, flags);
+ 	    if (p == 0)
+ 	      return FNM_NOMATCH;
+ 	  }
+ 	  break;
+ 
+ 	default:
+ 	  if ((unsigned char)c != FOLD (sc))
+ 	    return (FNM_NOMATCH);
+ 	}
+ 
+       ++n;
+     }
+ 
+   if (n == se)
+     return (0);
+ 
+   if ((flags & FNM_LEADING_DIR) && *n == '/')
+     /* The FNM_LEADING_DIR flag says that "foo*" matches "foobar/frobozz".  */
+     return 0;
+ 	  
+   return (FNM_NOMATCH);
+ }
+ 
+ /* Parse a bracket expression collating symbol ([.sym.]) starting at P, find
+    the value of the symbol, and move P past the collating symbol expression.
+    The value is returned in *VP, if VP is not null. */
+ static char *
+ parse_collsym (p, vp)
+      char *p;
+      int *vp;
+ {
+   register int pc;
+   int val;
+ 
+   p++;				/* move past the `.' */
+ 	  
+   for (pc = 0; p[pc]; pc++)
+     if (p[pc] == '.' && p[pc+1] == ']')
+       break;
+    val = collsym (p, pc);
+    if (vp)
+      *vp = val;
+    return (p + pc + 2);
+ }
+ 
+ static char *
+ brackmatch (p, test, flags)
+      char *p;
+      unsigned char test;
+      int flags;
+ {
+   register char cstart, cend, c;
+   register int not;    /* Nonzero if the sense of the character class is inverted.  */
+   int pc, brcnt;
+   char *savep;
+ 
+   test = FOLD (test);
+ 
+   savep = p;
+ 
+   /* POSIX.2 3.13.1 says that an exclamation mark (`!') shall replace the
+      circumflex (`^') in its role in a `nonmatching list'.  A bracket
+      expression starting with an unquoted circumflex character produces
+      unspecified results.  This implementation treats the two identically. */
+   if (not = (*p == '!' || *p == '^'))
+     ++p;
+ 
+   c = *p++;
+   for (;;)
+     {
+       /* Initialize cstart and cend in case `-' is the last
+ 	 character of the pattern. */
+       cstart = cend = c;
+ 
+       /* POSIX.2 equivalence class:  [=c=].  See POSIX.2 2.8.3.2.  Find
+ 	 the end of the equivalence class, move the pattern pointer past
+ 	 it, and check for equivalence.  XXX - this handles only
+ 	 single-character equivalence classes, which is wrong, or at
+ 	 least incomplete. */
+       if (c == '[' && *p == '=' && p[2] == '=' && p[3] == ']')
+ 	{
+ 	  pc = FOLD (p[1]);
+ 	  p += 4;
+ 	  if (collequiv (test, pc))
+ 	    {
+ /*[*/	      /* Move past the closing `]', since the first thing we do at
+ 		 the `matched:' label is back p up one. */
+ 	      p++;
+ 	      goto matched;
+ 	    }
+ 	  else
+ 	    {
+ 	      c = *p++;
+ 	      if (c == '\0')
+ 		return ((test == '[') ? savep : (char *)0); /*]*/
+ 	      c = FOLD (c);
+ 	      continue;
+ 	    }
+ 	}
+ 
+       /* POSIX.2 character class expression.  See POSIX.2 2.8.3.2. */
+       if (c == '[' && *p == ':')	/*]*/
+ 	{
+ 	  pc = 0;	/* make sure invalid char classes don't match. */
+ 	  if (STREQN (p+1, "alnum:]", 7))
+ 	    { pc = ISALNUM (test); p += 8; }
+ 	  else if (STREQN (p+1, "alpha:]", 7))
+ 	    { pc = ISALPHA (test); p += 8; }
+ 	  else if (STREQN (p+1, "blank:]", 7))
+ 	    { pc = ISBLANK (test); p += 8; }
+ 	  else if (STREQN (p+1, "cntrl:]", 7))
+ 	    { pc = ISCNTRL (test); p += 8; }
+ 	  else if (STREQN (p+1, "digit:]", 7))
+ 	    { pc = ISDIGIT (test); p += 8; }
+ 	  else if (STREQN (p+1, "graph:]", 7))
+ 	    { pc = ISGRAPH (test); p += 8; }
+ 	  else if (STREQN (p+1, "lower:]", 7))
+ 	    { pc = ISLOWER (test); p += 8; }
+ 	  else if (STREQN (p+1, "print:]", 7))
+ 	    { pc = ISPRINT (test); p += 8; }
+ 	  else if (STREQN (p+1, "punct:]", 7))
+ 	    { pc = ISPUNCT (test); p += 8; }
+ 	  else if (STREQN (p+1, "space:]", 7))
+ 	    { pc = ISSPACE (test); p += 8; }
+ 	  else if (STREQN (p+1, "upper:]", 7))
+ 	    { pc = ISUPPER (test); p += 8; }
+ 	  else if (STREQN (p+1, "xdigit:]", 8))
+ 	    { pc = ISXDIGIT (test); p += 9; }
+ 	  else if (STREQN (p+1, "ascii:]", 7))
+ 	    { pc = isascii (test); p += 8; }
+ 	  if (pc)
+ 	    {
+ /*[*/	      /* Move past the closing `]', since the first thing we do at
+ 		 the `matched:' label is back p up one. */
+ 	      p++;
+ 	      goto matched;
+ 	    }
+ 	  else
+ 	    {
+ 	      /* continue the loop here, since this expression can't be
+ 		 the first part of a range expression. */
+ 	      c = *p++;
+ 	      if (c == '\0')
+ 		return ((test == '[') ? savep : (char *)0);
+ 	      else if (c == ']')
+ 		break;
+ 	      c = FOLD (c);
+ 	      continue;
+ 	    }
+ 	}
+  
+       /* POSIX.2 collating symbols.  See POSIX.2 2.8.3.2.  Find the end of
+ 	 the symbol name, make sure it is terminated by `.]', translate
+ 	 the name to a character using the external table, and do the
+ 	 comparison. */
+       if (c == '[' && *p == '.')
+ 	{
+ 	  p = parse_collsym (p, &pc);
+ 	  /* An invalid collating symbol cannot be the first point of a
+ 	     range.  If it is, we set cstart to one greater than `test',
+ 	     so any comparisons later will fail. */
+ 	  cstart = (pc == -1) ? test + 1 : pc;
+ 	}
+ 
+       if (!(flags & FNM_NOESCAPE) && c == '\\')
+ 	{
+ 	  if (*p == '\0')
+ 	    return (char *)0;
+ 	  cstart = cend = *p++;
+ 	}
+ 
+       cstart = cend = FOLD (cstart);
+ 
+       /* POSIX.2 2.8.3.1.2 says: `An expression containing a `[' that
+ 	 is not preceded by a backslash and is not part of a bracket
+ 	 expression produces undefined results.'  This implementation
+ 	 treats the `[' as just a character to be matched if there is
+ 	 not a closing `]'. */
+       if (c == '\0')
+ 	return ((test == '[') ? savep : (char *)0);
+ 
+       c = *p++;
+       c = FOLD (c);
+ 
+       if ((flags & FNM_PATHNAME) && c == '/')
+ 	/* [/] can never match when matching a pathname.  */
+ 	return (char *)0;
+ 
+       /* This introduces a range, unless the `-' is the last
+ 	 character of the class.  Find the end of the range
+ 	 and move past it. */
+       if (c == '-' && *p != ']')
+ 	{
+ 	  cend = *p++;
+ 	  if (!(flags & FNM_NOESCAPE) && cend == '\\')
+ 	    cend = *p++;
+ 	  if (cend == '\0')
+ 	    return (char *)0;
+ 	  if (cend == '[' && *p == '.')
+ 	    {
+ 	      p = parse_collsym (p, &pc);
+ 	      /* An invalid collating symbol cannot be the second part of a
+ 		 range expression.  If we get one, we set cend to one fewer
+ 		 than the test character to make sure the range test fails. */
+ 	      cend = (pc == -1) ? test - 1 : pc;
+ 	    }
+ 	  cend = FOLD (cend);
+ 
+ 	  c = *p++;
+ 
+ 	  /* POSIX.2 2.8.3.2:  ``The ending range point shall collate
+ 	     equal to or higher than the starting range point; otherwise
+ 	     the expression shall be treated as invalid.''  Note that this
+ 	     applies to only the range expression; the rest of the bracket
+ 	     expression is still checked for matches. */
+ 	  if (rangecmp (cstart, cend) > 0)
+ 	    {
+ 	      if (c == ']')
+ 		break;
+ 	      c = FOLD (c);
+ 	      continue;
+ 	    }
+ 	}
+ 
+       if (rangecmp (test, cstart) >= 0 && rangecmp (test, cend) <= 0)
+ 	goto matched;
+ 
+       if (c == ']')
+ 	break;
+     }
+   /* No match. */
+   return (!not ? (char *)0 : p);
+ 
+ matched:
+   /* Skip the rest of the [...] that already matched.  */
+ #if 0
+   brcnt = (c != ']') + (c == '[' && (*p == '=' || *p == ':' || *p == '.'));
+ #else
+   c = *--p;
+   brcnt = 1;
+ #endif
+   while (brcnt > 0)
+     {
+       /* A `[' without a matching `]' is just another character to match. */
+       if (c == '\0')
+ 	return ((test == '[') ? savep : (char *)0);
+ 
+       c = *p++;
+       if (c == '[' && (*p == '=' || *p == ':' || *p == '.'))
+ 	brcnt++;
+       else if (c == ']')
+ 	brcnt--;
+       else if (!(flags & FNM_NOESCAPE) && c == '\\')
+ 	{
+ 	  if (*p == '\0')
+ 	    return (char *)0;
+ 	  /* XXX 1003.2d11 is unclear if this is right. */
+ 	  ++p;
+ 	}
+     }
+   return (not ? (char *)0 : p);
+ }
+ 
+ #if defined (EXTENDED_GLOB)
+ /* ksh-like extended pattern matching:
+ 
+ 	[?*+@!](pat-list)
+ 
+    where pat-list is a list of one or patterns separated by `|'.  Operation
+    is as follows:
+ 
+ 	?(patlist)	match zero or one of the given patterns
+ 	*(patlist)	match zero or more of the given patterns
+ 	+(patlist)	match one or more of the given patterns
+ 	@(patlist)	match exactly one of the given patterns
+ 	!(patlist)	match anything except one of the given patterns
+ */
+ 
+ /* Scan a pattern starting at STRING and ending at END, keeping track of
+    embedded () and [].  If DELIM is 0, we scan until a matching `)'
+    because we're scanning a `patlist'.  Otherwise, we scan until we see
+    DELIM.  In all cases, we never scan past END.  The return value is the
+    first character after the matching DELIM. */
+ static char *
+ patscan (string, end, delim)
+      char *string, *end;
+      int delim;
+ {
+   int pnest, bnest, cchar;
+   char *s, c, *bfirst;
+ 
+   pnest = bnest = cchar = 0;
+   bfirst = 0;
+   for (s = string; c = *s; s++)
+     {
+       if (s >= end)
+ 	return (s);
+       switch (c)
+ 	{
+ 	case '\0':
+ 	  return ((char *)0);
+ 
+ 	/* `[' is not special inside a bracket expression, but it may
+ 	   introduce one of the special POSIX bracket expressions
+ 	   ([.SYM.], [=c=], [: ... :]) that needs special handling. */
+ 	case '[':
+ 	  if (bnest == 0)
+ 	    {
+ 	      bfirst = s + 1;
+ 	      if (*bfirst == '!' || *bfirst == '^')
+ 		bfirst++;
+ 	      bnest++;
+ 	    }
+ 	  else if (s[1] == ':' || s[1] == '.' || s[1] == '=')
+ 	    cchar = s[1];
+ 	  break;
+ 
+ 	/* `]' is not special if it's the first char (after a leading `!'
+ 	   or `^') in a bracket expression or if it's part of one of the
+ 	   special POSIX bracket expressions ([.SYM.], [=c=], [: ... :]) */
+ 	case ']':
+ 	  if (bnest)
+ 	    {
+ 	      if (cchar && s[-1] == cchar)
+ 		cchar = 0;
+ 	      else if (s != bfirst)
+ 		{
+ 		  bnest--;
+ 		  bfirst = 0;
+ 		}
+ 	    }
+ 	  break;
+ 
+ 	case '(':
+ 	  if (bnest == 0)
+ 	    pnest++;
+ 	  break;
+ 
+ 	case ')':
+ #if 0
+ 	  if (bnest == 0)
+ 	    pnest--;
+ 	  if (pnest <= 0)
+ 	    return ++s;
+ #else
+ 	  if (bnest == 0 && pnest-- <= 0)
+ 	    return ++s;
+ #endif
+ 	  break;
+ 
+ 	case '|':
+ 	  if (bnest == 0 && pnest == 0 && delim == '|')
+ 	    return ++s;
+ 	  break;
+ 	}
+     }
+ 
+   return (char *)0;
+ }
+ 
+ /* Return 0 if dequoted pattern matches S in the current locale. */
+ static int
+ strcompare (p, pe, s, se)
+      char *p, *pe, *s, *se;
+ {
+   int ret;
+   char c1, c2;
+ 
+   c1 = *pe;
+   c2 = *se;
+ 
+   *pe = *se = '\0';
+ #if defined (HAVE_STRCOLL)
+   ret = strcoll (p, s);
+ #else
+   ret = strcmp (p, s);
+ #endif
+ 
+   *pe = c1;
+   *se = c2;
+ 
+   return (ret == 0 ? ret : FNM_NOMATCH);
+ }
+ 
+ /* Match a ksh extended pattern specifier.  Return FNM_NOMATCH on failure or
+    0 on success.  This is handed the entire rest of the pattern and string
+    the first time an extended pattern specifier is encountered, so it calls
+    gmatch recursively. */
+ static int
+ extmatch (xc, s, se, p, pe, flags)
+      int xc;		/* select which operation */
+      char *s, *se;
+      char *p, *pe;
+      int flags;
+ {
+   char *prest;			/* pointer to rest of pattern */
+   char *psub;			/* pointer to sub-pattern */
+   char *pnext;			/* pointer to next sub-pattern */
+   char *srest;			/* pointer to rest of string */
+   int m1, m2;
+ 
+ #if DEBUG_MATCHING
+ fprintf(stderr, "extmatch: xc = %c\n", xc);
+ fprintf(stderr, "extmatch: s = %s; se = %s\n", s, se);
+ fprintf(stderr, "extmatch: p = %s; pe = %s\n", p, pe);
+ #endif
+ 
+   prest = patscan (p + (*p == '('), pe, 0); /* ) */
+   if (prest == 0)
+     /* If PREST is 0, we failed to scan a valid pattern.  In this
+        case, we just want to compare the two as strings. */
+     return (strcompare (p - 1, pe, s, se));
+ 
+   switch (xc)
+     {
+     case '+':			/* match one or more occurrences */
+     case '*':			/* match zero or more occurrences */
+       /* If we can get away with no matches, don't even bother.  Just
+ 	 call gmatch on the rest of the pattern and return success if
+ 	 it succeeds. */
+       if (xc == '*' && (gmatch (s, se, prest, pe, flags) == 0))
+ 	return 0;
+ 
+       /* OK, we have to do this the hard way.  First, we make sure one of
+ 	 the subpatterns matches, then we try to match the rest of the
+ 	 string. */
+       for (psub = p + 1; ; psub = pnext)
+ 	{
+ 	  pnext = patscan (psub, pe, '|');
+ 	  for (srest = s; srest <= se; srest++)
+ 	    {
+ 	      /* Match this substring (S -> SREST) against this
+ 		 subpattern (psub -> pnext - 1) */
+ 	      m1 = gmatch (s, srest, psub, pnext - 1, flags) == 0;
+ 	      /* OK, we matched a subpattern, so make sure the rest of the
+ 		 string matches the rest of the pattern.  Also handle
+ 		 multiple matches of the pattern. */
+ 	      if (m1)
+ 		m2 = (gmatch (srest, se, prest, pe, flags) == 0) ||
+ 		      (s != srest && gmatch (srest, se, p - 1, pe, flags) == 0);
+ 	      if (m1 && m2)
+ 		return (0);
+ 	    }
+ 	  if (pnext == prest)
+ 	    break;
+ 	}
+       return (FNM_NOMATCH);
+ 
+     case '?':		/* match zero or one of the patterns */
+     case '@':		/* match exactly one of the patterns */
+       /* If we can get away with no matches, don't even bother.  Just
+ 	 call gmatch on the rest of the pattern and return success if
+ 	 it succeeds. */
+       if (xc == '?' && (gmatch (s, se, prest, pe, flags) == 0))
+ 	return 0;
+ 
+       /* OK, we have to do this the hard way.  First, we see if one of
+ 	 the subpatterns matches, then, if it does, we try to match the
+ 	 rest of the string. */
+       for (psub = p + 1; ; psub = pnext)
+ 	{
+ 	  pnext = patscan (psub, pe, '|');
+ 	  srest = (prest == pe) ? se : s;
+ 	  for ( ; srest <= se; srest++)
+ 	    {
+ 	      if (gmatch (s, srest, psub, pnext - 1, flags) == 0 &&
+ 		  gmatch (srest, se, prest, pe, flags) == 0)
+ 		return (0);
+ 	    }
+ 	  if (pnext == prest)
+ 	    break;
+ 	}
+       return (FNM_NOMATCH);
+ 
+     case '!':		/* match anything *except* one of the patterns */
+       for (srest = s; srest <= se; srest++)
+ 	{
+ 	  m1 = 0;
+ 	  for (psub = p + 1; ; psub = pnext)
+ 	    {
+ 	      pnext = patscan (psub, pe, '|');
+ 	      /* If one of the patterns matches, just bail immediately. */
+ 	      if (m1 = (gmatch (s, srest, psub, pnext - 1, flags) == 0))
+ 		break;
+ 	      if (pnext == prest)
+ 		break;
+ 	    }
+ 	  if (m1 == 0 && gmatch (srest, se, prest, pe, flags) == 0)
+ 	    return (0);
+ 	}
+       return (FNM_NOMATCH);
+     }
+ 
+   return (FNM_NOMATCH);
+ }
+ #endif /* EXTENDED_GLOB */
+ 
+ #ifdef TEST
+ main (c, v)
+      int c;
+      char **v;
+ {
+   char *string, *pat;
+ 
+   string = v[1];
+   pat = v[2];
+ 
+   if (strmatch (pat, string, 0) == 0)
+     {
+       printf ("%s matches %s\n", string, pat);
+       exit (0);
+     }
+   else
+     {
+       printf ("%s does not match %s\n", string, pat);
+       exit (1);
+     }
+ }
+ #endif
diff -Nrc2 bash-2.05/lib/glob/strmatch.h bash-2.05a/lib/glob/strmatch.h
*** bash-2.05/lib/glob/strmatch.h	Wed Dec 31 19:00:00 1969
--- bash-2.05a/lib/glob/strmatch.h	Tue Sep 11 15:12:57 2001
***************
*** 0 ****
--- 1,64 ----
+ /* Copyright (C) 1991 Free Software Foundation, Inc.
+ This file is part of the GNU C Library.
+ 
+ The GNU C Library is free software; you can redistribute it and/or
+ modify it under the terms of the GNU Library General Public License as
+ published by the Free Software Foundation; either version 2 of the
+ License, or (at your option) any later version.
+ 
+ The GNU C Library is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ Library General Public License for more details.
+ 
+ You should have received a copy of the GNU Library General Public
+ License along with the GNU C Library; see the file COPYING.LIB.  If
+ not, write to the Free Software Foundation, Inc.,
+ 59 Temple Place, Suite 330, Boston, MA 02111 USA.  */
+ 
+ #ifndef	_STRMATCH_H
+ #define	_STRMATCH_H	1
+ 
+ #ifdef HAVE_LIBC_FNM_EXTMATCH
+ 
+ #include <fnmatch.h>
+ 
+ #else /* !HAVE_LIBC_FNM_EXTMATCH */
+ 
+ #include "stdc.h"
+ 
+ /* We #undef these before defining them because some losing systems
+    (HP-UX A.08.07 for example) define these in <unistd.h>.  */
+ #undef  FNM_PATHNAME
+ #undef  FNM_NOESCAPE
+ #undef  FNM_PERIOD
+ 
+ /* Bits set in the FLAGS argument to `strmatch'.  */
+ 
+ /* standard flags are like fnmatch(3). */
+ #define	FNM_PATHNAME	(1 << 0) /* No wildcard can ever match `/'.  */
+ #define	FNM_NOESCAPE	(1 << 1) /* Backslashes don't quote special chars.  */
+ #define	FNM_PERIOD	(1 << 2) /* Leading `.' is matched only explicitly.  */
+ 
+ /* extended flags not available in most libc fnmatch versions, but we undef
+    them to avoid any possible warnings. */
+ #undef FNM_LEADING_DIR
+ #undef FNM_CASEFOLD
+ #undef FNM_EXTMATCH
+ 
+ #define FNM_LEADING_DIR	(1 << 3) /* Ignore `/...' after a match. */
+ #define FNM_CASEFOLD	(1 << 4) /* Compare without regard to case. */
+ #define FNM_EXTMATCH	(1 << 5) /* Use ksh-like extended matching. */
+ 
+ /* Value returned by `strmatch' if STRING does not match PATTERN.  */
+ #undef FNM_NOMATCH
+ 
+ #define	FNM_NOMATCH	1
+ 
+ /* Match STRING against the filename pattern PATTERN,
+    returning zero if it matches, FNM_NOMATCH if not.  */
+ extern int strmatch __P((char *, char *, int));
+ 
+ #endif /* !HAVE_LIBC_FNM_EXTMATCH */
+ 
+ #endif /* _STRMATCH_H */
diff -Nrc2 bash-2.05/lib/malloc/Makefile.in bash-2.05a/lib/malloc/Makefile.in
*** bash-2.05/lib/malloc/Makefile.in	Thu Aug  5 10:53:09 1999
--- bash-2.05a/lib/malloc/Makefile.in	Tue Oct 30 16:32:01 2001
***************
*** 61,66 ****
  
  MALLOC_SOURCE = malloc.c
- GMALLOC_SOURCE = gmalloc.c
- NMALLOC_SOURCE = nmalloc.c
  STUB_SOURCE = stub.c
  
--- 61,64 ----
***************
*** 72,83 ****
  ALLOCA = @ALLOCA@
  
! MALLOC_OBJS = malloc.o $(ALLOCA) stub.o
! GMALLOC_OBJS = gmalloc.o $(ALLOCA) stub.o
! NMALLOC_OBJS = nmalloc.o $(ALLOCA) stub.o
! NMALLOC2_OBJS = nmalloc2.o $(ALLOCA) stub.o
! NGMALLOC_OBJS = ngmalloc.o $(ALLOCA) stub.o
  STUB_OBJS = $(ALLOCA) stub.o
  
! .PHONY:		malloc gmalloc stubmalloc nmalloc ngmalloc nmalloc2
  
  all:		malloc
--- 70,77 ----
  ALLOCA = @ALLOCA@
  
! MALLOC_OBJS = malloc.o $(ALLOCA) trace.o stats.o table.o
  STUB_OBJS = $(ALLOCA) stub.o
  
! .PHONY:		malloc stubmalloc
  
  all:		malloc
***************
*** 88,114 ****
  	-test -n "$(RANLIB)" && $(RANLIB) libmalloc.a
  
! nmalloc: ${NMALLOC_OBJS}
! 	${RM} libmalloc.a
! 	${AR} ${ARFLAGS} libmalloc.a ${NMALLOC_OBJS}
! 	-test -n "$(RANLIB)" && $(RANLIB) libmalloc.a
! 
! nmalloc2: ${NMALLOC2_OBJS}
! 	${RM} libmalloc.a
! 	${AR} ${ARFLAGS} libmalloc.a ${NMALLOC2_OBJS}
! 	-test -n "$(RANLIB)" && $(RANLIB) libmalloc.a
! 
! gmalloc: ${GMALLOC_OBJS}
! 	${RM} libmalloc.a
! 	${AR} ${ARFLAGS} libmalloc.a ${GMALLOC_OBJS}
! 	-test -n "$(RANLIB)" && $(RANLIB) libmalloc.a
! 
! ngmalloc: ${NGMALLOC_OBJS}
  	${RM} libmalloc.a
! 	${AR} ${ARFLAGS} libmalloc.a ${NGMALLOC_OBJS}
  	-test -n "$(RANLIB)" && $(RANLIB) libmalloc.a
  
! stubmalloc: ${STUB_OBJS}
  	${RM} libmalloc.a
! 	${AR} ${ARFLAGS} libmalloc.a ${STUB_OBJS}
  	-test -n "$(RANLIB)" && $(RANLIB) libmalloc.a
  
--- 82,93 ----
  	-test -n "$(RANLIB)" && $(RANLIB) libmalloc.a
  
! stubmalloc: ${STUB_OBJS}
  	${RM} libmalloc.a
! 	${AR} ${ARFLAGS} libmalloc.a ${STUB_OBJS}
  	-test -n "$(RANLIB)" && $(RANLIB) libmalloc.a
  
! alloca: ${ALLOCA}
  	${RM} libmalloc.a
! 	${AR} ${ARFLAGS} libmalloc.a ${ALLOCA}
  	-test -n "$(RANLIB)" && $(RANLIB) libmalloc.a
  
***************
*** 127,137 ****
  alloca.o: $(BUILD_DIR)/config.h
  malloc.o: $(BUILD_DIR)/config.h $(topdir)/bashtypes.h getpagesize.h
- nmalloc.o: $(BUILD_DIR)/config.h $(topdir)/bashtypes.h getpagesize.h
- nmalloc2.o: $(BUILD_DIR)/config.h $(topdir)/bashtypes.h getpagesize.h
  xmalloc.o: $(BUILD_DIR)/config.h $(BASHINCDIR)/ansi_stdlib.h
! gmalloc.o: $(BUILD_DIR)/config.h
  
  # Rules for deficient makes, like SunOS and Solaris
  stub.o: stub.c
  malloc.o: malloc.c
! gmalloc.o: gmalloc.c
--- 106,122 ----
  alloca.o: $(BUILD_DIR)/config.h
  malloc.o: $(BUILD_DIR)/config.h $(topdir)/bashtypes.h getpagesize.h
  xmalloc.o: $(BUILD_DIR)/config.h $(BASHINCDIR)/ansi_stdlib.h
! trace.o: ${BUILD_DIR}/config.h
! table.o: ${BUILD_DIR}/config.h
! 
! malloc.o: ${srcdir}/imalloc.h ${srcdir}/mstats.h
! stats.o: ${srcdir}/imalloc.h ${srcdir}/mstats.h
! trace.o: ${srcdir}/imalloc.h
! table.o: ${srcdir}/imalloc.h ${srcdir}/table.h
  
  # Rules for deficient makes, like SunOS and Solaris
  stub.o: stub.c
  malloc.o: malloc.c
! table.o: table.c
! trace.o: trace.c
! stats.o: stats.c
diff -Nrc2 bash-2.05/lib/malloc/alloca.c bash-2.05a/lib/malloc/alloca.c
*** bash-2.05/lib/malloc/alloca.c	Fri Dec 10 16:22:05 1993
--- bash-2.05a/lib/malloc/alloca.c	Tue Oct 16 09:12:16 2001
***************
*** 29,32 ****
--- 29,34 ----
  #if !defined (__GNUC__) || __GNUC__ < 2
  
+ #include <bashtypes.h>		/* for size_t */
+ 
  /* If alloca is defined somewhere, this file is not needed. */
  #ifndef alloca
***************
*** 156,160 ****
  pointer
  alloca (size)
!      unsigned size;
  {
    auto char probe;		/* Probes stack depth: */
--- 158,162 ----
  pointer
  alloca (size)
!      size_t size;
  {
    auto char probe;		/* Probes stack depth: */
diff -Nrc2 bash-2.05/lib/malloc/gmalloc.c bash-2.05a/lib/malloc/gmalloc.c
*** bash-2.05/lib/malloc/gmalloc.c	Wed Feb 14 17:01:40 2001
--- bash-2.05a/lib/malloc/gmalloc.c	Wed Dec 31 19:00:00 1969
***************
*** 1,1486 ****
- /* The malloc headers and source files from the C library follow here.  */
- 
- /* Declarations for `malloc' and friends.
-    Copyright 1990, 91, 92, 93, 95, 96 Free Software Foundation, Inc.
- 		  Written May 1989 by Mike Haertel.
- 
- This library is free software; you can redistribute it and/or
- modify it under the terms of the GNU Library General Public License as
- published by the Free Software Foundation; either version 2 of the
- License, or (at your option) any later version.
- 
- This library is distributed in the hope that it will be useful,
- but WITHOUT ANY WARRANTY; without even the implied warranty of
- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- Library General Public License for more details.
- 
- You should have received a copy of the GNU Library General Public
- License along with this library; see the file COPYING.LIB.  If
- ot, write to the Free Software Foundation, Inc.,
- 59 Temple Place, Suite 330, Boston, MA 02111 USA.
- 
-    The author may be reached (Email) at the address mike@ai.mit.edu,
-    or (US mail) as Mike Haertel c/o Free Software Foundation.  */
- 
- /* XXX NOTES:
-     1.	Augment the mstats struct so we can see how many blocks for fragments
- 	and how many blocks for large requests were allocated.
- */
- 
- /* CHANGES:
-     1.	Reorganized the source for my benefit.
-     2.	Integrated the range-checking code by default.
-     3.  free(0) no longer dumps core.
-     4.  Extended the statistics.
-     5.  Fixed a couple of places where the stats were not kept correctly.
- */
- 
- #ifdef	HAVE_CONFIG_H
- #include <config.h>
- #endif
- 
- #if defined (HAVE_STRING_H)
- #  include <string.h>
- #else
- #  include <strings.h>
- #endif
- 
- #if defined (HAVE_LIMITS_H)
- #  include <limits.h>
- #endif
- 
- #if defined (HAVE_UNISTD_H)
- #  ifdef _MINIX
- #    include <sys/types.h>
- #  endif
- #  include <unistd.h>
- #endif
- 
- #if defined (HAVE_STDDEF_H)
- #  include <stddef.h>
- #endif
- #include <errno.h>
- 
- #if defined (RCHECK) && !defined (botch)
- #  include <stdio.h>
- #  define STDIO_H_INCLUDED
- #endif
- 
- #include "stdc.h"
- 
- #ifndef errno
- extern int errno;
- #endif
- 
- /* Need an autoconf test for this. */
- #if __STDC__
- #  undef  genptr_t
- #  define genptr_t	void *
- #else
- #  undef  genptr_t
- #  define genptr_t	char *
- #endif /* !__STDC__ */
- 
- #if !defined (HAVE_MEMSET)
- #  define	memset(s, zero, n)	bzero ((s), (n))
- #endif
- #if !defined (HAVE_MEMCPY)
- #  define	memcpy(d, s, n)		bcopy ((s), (d), (n))
- #endif
- 
- /* Cope with systems lacking `memmove'.    */
- #if !defined (HAVE_MEMMOVE) && !defined (memmove)
- static void malloc_safe_bcopy __P ((genptr_t, genptr_t, size_t));
- #  define memmove(to, from, size)	malloc_safe_bcopy ((from), (to), (size))
- #endif
- 
- #ifndef	NULL
- #define	NULL	0
- #endif
- 
- #ifndef min
- #define min(A, B) ((A) < (B) ? (A) : (B))
- #endif
- 
- /* Return values for `mprobe': these are the kinds of inconsistencies that
-    `mcheck' enables detection of.  */
- enum mcheck_status
-   {
-     MCHECK_DISABLED = -1,	/* Consistency checking is not turned on.  */
-     MCHECK_OK,			/* Block is fine.  */
-     MCHECK_FREE,		/* Block freed twice.  */
-     MCHECK_HEAD,		/* Memory before the block was clobbered.  */
-     MCHECK_TAIL			/* Memory after the block was clobbered.  */
-   };
- 
- /* Statistics available to the user.  */
- struct mstats
-   {
-     size_t bytes_total; /* Total size of the heap. */
-     size_t chunks_used; /* Chunks allocated by the user. */
-     size_t bytes_used;	/* Byte total of user-allocated chunks. */
-     size_t chunks_free; /* Chunks in the free list. */
-     size_t bytes_free;	/* Byte total of chunks in the free list. */
-     int nmalloc;	/* Total number of calls to malloc. */
-     int nfree;		/* Total number of calls to free. */
-     int nrealloc;	/* Total number of calls to realloc. */
-     int nsbrk;		/* Total number of calls to sbrk. */
-     size_t tsbrk;	/* Total number of bytes allocated via sbrk. */
-     int negsbrk;	/* Total number of calls to sbrk with a negative arg */
-     size_t tnegsbrk;	/* Total number of bytes returned to the kernel. */
-   };
- 
- #ifdef RCHECK
- /* Arbitrary magical numbers.  */
- #define MAGICWORD	0xfedabeeb
- #define MAGICFREE	0xd8675309
- #define MAGICBYTE	((char) 0xd7)
- #define MALLOCFLOOD	((char) 0x93)
- #define FREEFLOOD	((char) 0x95)
- 
- struct hdr
-   {
-     size_t size;		/* Exact size requested by user.  */
-     u_bits32_t magic;		/* Magic number to check header integrity.  */
-   };
- #endif /* RCHECK */
- 
- /* Functions exported by this library. */
- /* Allocate SIZE bytes of memory.  */
- extern genptr_t malloc __P ((size_t __size));
- 
- /* Re-allocate the previously allocated block
-    in genptr_t, making the new block SIZE bytes long.  */
- extern genptr_t realloc __P ((genptr_t __ptr, size_t __size));
- 
- /* Allocate NMEMB elements of SIZE bytes each, all initialized to 0.  */
- extern genptr_t calloc __P ((size_t __nmemb, size_t __size));
- 
- /* Free a block allocated by `malloc', `realloc' or `calloc'.  */
- extern void free __P ((genptr_t __ptr));
- 
- /* Allocate SIZE bytes allocated to ALIGNMENT bytes.  */
- extern genptr_t memalign __P ((size_t __alignment, size_t __size));
- 
- /* Pick up the current statistics. */
- extern struct mstats mstats __P ((void));
- 
- #ifdef RCHECK
- extern enum mcheck_status mprobe __P((genptr_t ptr));
- #endif
- 
- /* End of exported functions. */
- 
- /* The allocator divides the heap into blocks of fixed size; large
-    requests receive one or more whole blocks, and small requests
-    receive a fragment of a block.  Fragment sizes are powers of two,
-    and all fragments of a block are the same size.  When all the
-    fragments in a block have been freed, the block itself is freed.  */
- #define BLOCKLOG	12
- #define BLOCKSIZE	4096		/* 1 << BLOCKLOG */
- #define BLOCKIFY(SIZE)	(((SIZE) + BLOCKSIZE - 1) / BLOCKSIZE)
- 
- /* Determine the amount of memory spanned by the initial heap table
-    (not an absolute limit).  */
- #define HEAP		4194304		/* 1 << 22 */
- 
- /* Number of contiguous free blocks allowed to build up at the end of
-    memory before they will be returned to the system.  */
- #define FINAL_FREE_BLOCKS	8
- 
- /* Data structure giving per-block information.  */
- typedef union
-   {
-     /* Heap information for a busy block.  */
-     struct
-       {
- 	/* Zero for a large (multiblock) object, or positive giving the
- 	   logarithm to the base two of the fragment size.  */
- 	int type;
- 	union
- 	  {
- 	    struct
- 	      {
- 		size_t nfree; /* Free frags in a fragmented block.  */
- 		size_t first; /* First free fragment of the block.  */
- 	      } frag;
- 	    /* For a large object, in its first block, this has the number
- 	       of blocks in the object.  In the other blocks, this has a
- 	       negative number which says how far back the first block is.  */
- 	    ptrdiff_t size;
- 	  } info;
-       } busy;
-     /* Heap information for a free block (that may be the first of a
-        free cluster).  */
-     struct
-       {
- 	size_t size;	/* Size (in blocks) of a free cluster.  */
- 	size_t next;	/* Index of next free cluster.  */
- 	size_t prev;	/* Index of previous free cluster.  */
-       } free;
-   } malloc_info;
- 
- /* Pointer to first block of the heap.  */
- static char *_heapbase;
- 
- /* Table indexed by block number giving per-block information.  */
- static malloc_info *_heapinfo;
- 
- /* Address to block number and vice versa.  */
- #define BLOCK(A)	(((char *) (A) - _heapbase) / BLOCKSIZE + 1)
- #define ADDRESS(B)	((genptr_t) (((B) - 1) * BLOCKSIZE + _heapbase))
- 
- /* Number of info entries.  */
- static size_t heapsize;
- 
- /* Current search index for the heap table.  */
- static size_t _heapindex;
- 
- /* Limit of valid info table indices.  */
- static size_t _heaplimit;
- 
- /* Doubly linked lists of free fragments.  */
- struct list
-   {
-     struct list *next;
-     struct list *prev;
-   };
- 
- /* Free list headers for each fragment size.  */
- static struct list _fraghead[BLOCKLOG];
- 
- /* List of blocks allocated with `memalign'.  */
- struct alignlist
-   {
-     struct alignlist *next;
-     genptr_t aligned;		/* The address that memaligned returned.  */
-     genptr_t exact;		/* The address that malloc returned.  */
-   };
- 
- /* List of blocks allocated by memalign.  */
- static struct alignlist *_aligned_blocks = NULL;
- 
- /* Internal versions of `malloc', `realloc', and `free'
-    used when these functions need to call each other. */
- static genptr_t imalloc __P ((size_t __size));
- static genptr_t irealloc __P ((genptr_t __ptr, size_t __size));
- static void ifree __P ((genptr_t __ptr));
- 
- /* Given an address in the middle of a malloc'd object,
-    return the address of the beginning of the object.  */
- static genptr_t malloc_find_object_address __P ((genptr_t __ptr));
- 
- /* Underlying allocation function; successive calls should
-    return contiguous pieces of memory.  */
- static genptr_t default_morecore __P ((ptrdiff_t __size));
- 
- /* Number of extra blocks to get each time we ask for more core.
-    This reduces the frequency of calling `default_morecore'.  */
- static size_t malloc_extra_blocks;
- 
- /* Nonzero if `malloc' has been called and done its initialization.  */
- static int malloc_initialized;
- /* Function called to initialize malloc data structures.  */
- static int malloc_initialize __P ((void));
- 
- #ifdef RCHECK
- static void zmemset __P((genptr_t, int, size_t));
- static enum mcheck_status checkhdr __P((const struct hdr *));
- static void mabort __P((enum mcheck_status));
- #endif
- 
- /* Instrumentation.  */
- static size_t chunks_used;
- static size_t bytes_used;
- static size_t chunks_free;
- static size_t bytes_free;
- static int nmalloc, nfree, nrealloc;
- static int nsbrk;
- static size_t tsbrk;
- static int negsbrk;
- static size_t tnegsbrk;
- 
- /* Aligned allocation.  */
- static genptr_t
- align (size)
-      size_t size;
- {
-   genptr_t result;
-   unsigned long int adj;
- 
-   result = default_morecore (size);
-   adj = (unsigned long int) ((unsigned long int) ((char *) result -
- 						  (char *) NULL)) % BLOCKSIZE;
-   if (adj != 0)
-     {
-       genptr_t new;
-       adj = BLOCKSIZE - adj;
-       new = default_morecore (adj);
-       result = (char *) result + adj;
-     }
- 
-   return result;
- }
- 
- /* Get SIZE bytes, if we can get them starting at END.
-    Return the address of the space we got.
-    If we cannot get space at END, fail and return -1.  */
- static genptr_t
- get_contiguous_space (size, position)
-      ptrdiff_t size;
-      genptr_t position;
- {
-   genptr_t before;
-   genptr_t after;
- 
-   before = default_morecore (0);
-   /* If we can tell in advance that the break is at the wrong place,
-      fail now.  */
-   if (before != position)
-     return 0;
- 
-   /* Allocate SIZE bytes and get the address of them.  */
-   after = default_morecore (size);
-   if (!after)
-     return 0;
- 
-   /* It was not contiguous--reject it.  */
-   if (after != position)
-     {
-       default_morecore (- size);
-       return 0;
-     }
- 
-   return after;
- }
- 
- /* This is called when `_heapinfo' and `heapsize' have just
-    been set to describe a new info table.  Set up the table
-    to describe itself and account for it in the statistics.  */
- inline static void
- register_heapinfo ()
- {
-   size_t block, blocks;
- 
-   block = BLOCK (_heapinfo);
-   blocks = BLOCKIFY (heapsize * sizeof (malloc_info));
- 
-   /* Account for the _heapinfo block itself in the statistics.  */
-   bytes_used += blocks * BLOCKSIZE;
-   ++chunks_used;
- 
-   /* Describe the heapinfo block itself in the heapinfo.  */
-   _heapinfo[block].busy.type = 0;
-   _heapinfo[block].busy.info.size = blocks;
-   /* Leave back-pointers for malloc_find_address.  */
-   while (--blocks > 0)
-     _heapinfo[block + blocks].busy.info.size = -blocks;
- }
- 
- /* Set everything up and remember that we have.  */
- static int
- malloc_initialize ()
- {
-   if (malloc_initialized)
-     return 0;
- 
-   heapsize = HEAP / BLOCKSIZE;
-   _heapinfo = (malloc_info *) align (heapsize * sizeof (malloc_info));
-   if (_heapinfo == NULL)
-     return 0;
-   memset (_heapinfo, 0, heapsize * sizeof (malloc_info));
-   _heapinfo[0].free.size = 0;
-   _heapinfo[0].free.next = _heapinfo[0].free.prev = 0;
-   _heapindex = 0;
-   _heapbase = (char *) _heapinfo;
-   _heaplimit = BLOCK (_heapbase + heapsize * sizeof (malloc_info));
- 
-   register_heapinfo ();
- 
-   malloc_initialized = 1;
-   return 1;
- }
- 
- /* Allocate INCREMENT more bytes of data space,
-    and return the start of data space, or NULL on errors.
-    If INCREMENT is negative, shrink data space.  */
- static genptr_t
- default_morecore (increment)
-      ptrdiff_t increment;
- {
-   genptr_t result;
- 
-   nsbrk++;
-   tsbrk += increment;
-   if (increment < 0)
-     {
-       negsbrk++;
-       tnegsbrk += -increment;
-     }
-   result = (genptr_t) sbrk (increment);
-   if ((long)result == -1L)
-     return NULL;
-   return result;
- }
- 
- static int morecore_recursing;
- 
- /* Get neatly aligned memory, initializing or
-    growing the heap info table as necessary. */
- static genptr_t
- morecore (size)
-      size_t size;
- {
-   genptr_t result;
-   malloc_info *newinfo, *oldinfo;
-   size_t newsize;
- 
-   if (morecore_recursing)
-     /* Avoid recursion.  The caller will know how to handle a null return.  */
-     return NULL;
- 
-   result = align (size);
-   if (result == NULL)
-     return NULL;
- 
-   /* Check if we need to grow the info table.  */
-   if ((size_t) BLOCK ((char *) result + size) > heapsize)
-     {
-       /* Calculate the new _heapinfo table size.  We do not account for the
- 	 added blocks in the table itself, as we hope to place them in
- 	 existing free space, which is already covered by part of the
- 	 existing table.  */
-       newsize = heapsize;
-       do
- 	newsize <<= 1;
-       while ((size_t) BLOCK ((char *) result + size) > newsize);
- 
-       /* We must not reuse existing core for the new info table when called
- 	 from realloc in the case of growing a large block, because the
- 	 block being grown is momentarily marked as free.  In this case
- 	 _heaplimit is zero so we know not to reuse space for internal
- 	 allocation.  */
-       if (_heaplimit != 0)
- 	{
- 	  /* First try to allocate the new info table in core we already
- 	     have, in the usual way using realloc.  If realloc cannot
- 	     extend it in place or relocate it to existing sufficient core,
- 	     we will get called again, and the code above will notice the
- 	     `morecore_recursing' flag and return null.  */
- 	  int save = errno;	/* Don't want to clobber errno with ENOMEM.  */
- 	  morecore_recursing = 1;
- 	  newinfo = (malloc_info *) irealloc (_heapinfo, newsize * sizeof (malloc_info));
- 	  morecore_recursing = 0;
- 	  if (newinfo == NULL)
- 	    errno = save;
- 	  else
- 	    {
- 	      /* We found some space in core, and realloc has put the old
- 		 table's blocks on the free list.  Now zero the new part
- 		 of the table and install the new table location.  */
- 	      memset (&newinfo[heapsize], 0, (newsize - heapsize) * sizeof (malloc_info));
- 	      _heapinfo = newinfo;
- 	      heapsize = newsize;
- 	      goto got_heap;
- 	    }
- 	}
- 
-       /* Allocate new space for the malloc info table.  */
-       while (1)
-   	{
-  	  newinfo = (malloc_info *) align (newsize * sizeof (malloc_info));
- 
-  	  /* Did it fail?  */
-  	  if (newinfo == NULL)
-  	    {
-  	      default_morecore (-size);
-  	      return NULL;
-  	    }
- 
-  	  /* Is it big enough to record status for its own space?
-  	     If so, we win.  */
-  	  if ((size_t) BLOCK ((char *) newinfo + newsize * sizeof (malloc_info)) < newsize)
-  	    break;
- 
-  	  /* Must try again.  First give back most of what we just got.  */
-  	  default_morecore (- newsize * sizeof (malloc_info));
-  	  newsize *= 2;
-   	}
- 
-       /* Copy the old table to the beginning of the new,
- 	 and zero the rest of the new table.  */
-       memcpy (newinfo, _heapinfo, heapsize * sizeof (malloc_info));
-       memset (&newinfo[heapsize], 0, (newsize - heapsize) * sizeof (malloc_info));
-       oldinfo = _heapinfo;
-       _heapinfo = newinfo;
-       heapsize = newsize;
- 
-       register_heapinfo ();
- 
-       /* Reset _heaplimit so ifree never decides
- 	 it can relocate or resize the info table.  */
-       _heaplimit = 0;
-       ifree (oldinfo);
- 
-       /* The new heap limit includes the new table just allocated.  */
-       _heaplimit = BLOCK ((char *) newinfo + heapsize * sizeof (malloc_info));
-       return result;
-     }
- 
-  got_heap:
-   _heaplimit = BLOCK ((char *) result + size);
-   return result;
- }
- 
- /* Allocate memory from the heap.  */
- static genptr_t
- imalloc (size)
-      size_t size;
- {
-   genptr_t result;
-   size_t block, blocks, lastblocks, start;
-   register size_t i;
-   struct list *next;
- 
-   /* ANSI C allows `malloc (0)' to either return NULL, or to return a
-      valid address you can realloc and free (though not dereference).
- 
-      It turns out that some extant code (sunrpc, at least Ultrix's version)
-      expects `malloc (0)' to return non-NULL and breaks otherwise.
-      Be compatible.  */
- 
- #if 0
-   if (size == 0)
-     return NULL;
- #endif
- 
-   if (size < sizeof (struct list))
-     size = sizeof (struct list);
- 
- #ifdef SUNOS_LOCALTIME_BUG
-   if (size < 16)
-     size = 16;
- #endif
- 
-   /* Determine the allocation policy based on the request size.  */
-   if (size <= BLOCKSIZE / 2)
-     {
-       /* Small allocation to receive a fragment of a block.
- 	 Determine the logarithm to base two of the fragment size. */
-       register size_t log = 1;
-       --size;
-       while ((size /= 2) != 0)
- 	++log;
- 
-       /* Look in the fragment lists for a
- 	 free fragment of the desired size. */
-       next = _fraghead[log].next;
-       if (next != NULL)
- 	{
- 	  /* There are free fragments of this size.
- 	     Pop a fragment out of the fragment list and return it.
- 	     Update the block's nfree and first counters. */
- 	  result = (genptr_t) next;
- 	  next->prev->next = next->next;
- 	  if (next->next != NULL)
- 	    next->next->prev = next->prev;
- 	  block = BLOCK (result);
- 	  if (--_heapinfo[block].busy.info.frag.nfree != 0)
- 	    _heapinfo[block].busy.info.frag.first = (unsigned long int)
- 	      ((unsigned long int) ((char *) next->next - (char *) NULL)
- 	       % BLOCKSIZE) >> log;
- 
- 	  /* Update the statistics.  */
- 	  ++chunks_used;
- 	  bytes_used += 1 << log;
- 	  --chunks_free;
- 	  bytes_free -= 1 << log;
- 	}
-       else
- 	{
- 	  /* No free fragments of the desired size, so get a new block
- 	     and break it into fragments, returning the first.  */
- 	  result = imalloc (BLOCKSIZE);
- 	  if (result == NULL)
- 	    return NULL;
- 
- 	  /* Link all fragments but the first into the free list.  */
- 	  next = (struct list *) ((char *) result + (1 << log));
- 	  next->next = NULL;
- 	  next->prev = &_fraghead[log];
- 	  _fraghead[log].next = next;
- 
- 	  for (i = 2; i < (size_t) (BLOCKSIZE >> log); ++i)
- 	    {
- 	      next = (struct list *) ((char *) result + (i << log));
- 	      next->next = _fraghead[log].next;
- 	      next->prev = &_fraghead[log];
- 	      next->prev->next = next;
- 	      next->next->prev = next;
- 	    }
- 
- 	  /* Initialize the nfree and first counters for this block.  */
- 	  block = BLOCK (result);
- 	  _heapinfo[block].busy.type = log;
- 	  _heapinfo[block].busy.info.frag.nfree = i - 1;
- 	  _heapinfo[block].busy.info.frag.first = i - 1;
- 
- 	  chunks_free += (BLOCKSIZE >> log) - 1;
- 	  bytes_free += BLOCKSIZE - (1 << log);
- 	  bytes_used -= BLOCKSIZE - (1 << log);
- 	}
-     }
-   else
-     {
-       /* Large allocation to receive one or more blocks.
- 	 Search the free list in a circle starting at the last place visited.
- 	 If we loop completely around without finding a large enough
- 	 space we will have to get more memory from the system.  */
-       blocks = BLOCKIFY (size);
-       start = block = _heapindex;
-       while (_heapinfo[block].free.size < blocks)
- 	{
- 	  block = _heapinfo[block].free.next;
- 	  if (block == start)
- 	    {
- 	      /* Need to get more from the system.  Get a little extra.  */
- 	      size_t wantblocks = blocks + malloc_extra_blocks;
- 	      block = _heapinfo[0].free.prev;
- 	      lastblocks = _heapinfo[block].free.size;
- 	      /* Check to see if the new core will be contiguous with the
- 		 final free block; if so we don't need to get as much.  */
- 	      if (_heaplimit != 0 && block + lastblocks == _heaplimit &&
- 		  /* We can't do this if we will have to make the heap info
- 		     table bigger to accomodate the new space.  */
- 		  block + wantblocks <= heapsize &&
- 		  get_contiguous_space ((wantblocks - lastblocks) * BLOCKSIZE,
- 					ADDRESS (block + lastblocks)))
- 		{
-  		  /* We got it contiguously.  Which block we are extending
- 		     (the `final free block' referred to above) might have
- 		     changed, if it got combined with a freed info table.  */
-  		  block = _heapinfo[0].free.prev;
-   		  _heapinfo[block].free.size += (wantblocks - lastblocks);
- 		  bytes_free += (wantblocks - lastblocks) * BLOCKSIZE;
-  		  _heaplimit += wantblocks - lastblocks;
- 		  continue;
- 		}
- 	      result = morecore (wantblocks * BLOCKSIZE);
- 	      if (result == NULL)
- 		return NULL;
- 	      block = BLOCK (result);
- 	      /* Put the new block at the end of the free list.  */
- 	      _heapinfo[block].free.size = wantblocks;
- 	      _heapinfo[block].free.prev = _heapinfo[0].free.prev;
- 	      _heapinfo[block].free.next = 0;
- 	      _heapinfo[0].free.prev = block;
- 	      _heapinfo[_heapinfo[block].free.prev].free.next = block;
- 	      ++chunks_free;
- 	      bytes_free += wantblocks * BLOCKSIZE;
- 	      /* Now loop to use some of that block for this allocation.  */
- 	    }
- 	}
- 
-       /* At this point we have found a suitable free list entry.
- 	 Figure out how to remove what we need from the list. */
-       result = ADDRESS (block);
-       if (_heapinfo[block].free.size > blocks)
- 	{
- 	  /* The block we found has a bit left over,
- 	     so relink the tail end back into the free list. */
- 	  _heapinfo[block + blocks].free.size
- 	    = _heapinfo[block].free.size - blocks;
- 	  _heapinfo[block + blocks].free.next
- 	    = _heapinfo[block].free.next;
- 	  _heapinfo[block + blocks].free.prev
- 	    = _heapinfo[block].free.prev;
- 	  _heapinfo[_heapinfo[block].free.prev].free.next
- 	    = _heapinfo[_heapinfo[block].free.next].free.prev
- 	    = _heapindex = block + blocks;
- 	}
-       else
- 	{
- 	  /* The block exactly matches our requirements,
- 	     so just remove it from the list. */
- 	  _heapinfo[_heapinfo[block].free.next].free.prev
- 	    = _heapinfo[block].free.prev;
- 	  _heapinfo[_heapinfo[block].free.prev].free.next
- 	    = _heapindex = _heapinfo[block].free.next;
- 	  --chunks_free;
- 	}
- 
-       _heapinfo[block].busy.type = 0;
-       _heapinfo[block].busy.info.size = blocks;
-       ++chunks_used;
-       bytes_used += blocks * BLOCKSIZE;
-       bytes_free -= blocks * BLOCKSIZE;
- 
-       /* Mark all the blocks of the object just allocated except for the
- 	 first with a negative number so you can find the first block by
- 	 adding that adjustment.  */
-       while (--blocks > 0)
- 	_heapinfo[block + blocks].busy.info.size = -blocks;
-     }
- 
-   return result;
- }
- 
- genptr_t
- malloc (size)
-      size_t size;
- {
- #ifdef RCHECK
-   struct hdr *hdr;
- #endif
- 
-   nmalloc++;
- 
-   if (malloc_initialized == 0 && malloc_initialize () == 0)
-     return NULL;
- 
- #ifdef RCHECK
-   hdr = (struct hdr *) imalloc (sizeof (struct hdr) + size + 1);
-   if (hdr == NULL)
-     return NULL;
- 
-   hdr->size = size;
-   hdr->magic = MAGICWORD;
-   ((char *) &hdr[1])[size] = MAGICBYTE;
-   zmemset ((genptr_t) (hdr + 1), MALLOCFLOOD, size);
-   return (genptr_t) (hdr + 1);
- #else
-   return (imalloc (size));
- #endif
- }
- 
- /* Free a block of memory allocated by `malloc'. */
- 
- /* Return memory to the heap. */
- static void
- ifree (ptr)
-      genptr_t ptr;
- {
-   int type;
-   size_t block, blocks;
-   register size_t i;
-   struct list *prev, *next;
-   genptr_t curbrk;
-   size_t lesscore_threshold;
-   register struct alignlist *l;
- 
-   if (ptr == NULL)
-     return;
- 
-   /* Threshold of free space at which we will return some to the system.  */
-   lesscore_threshold = FINAL_FREE_BLOCKS + 2 * malloc_extra_blocks;
- 
-   for (l = _aligned_blocks; l != NULL; l = l->next)
-     if (l->aligned == ptr)
-       {
- 	l->aligned = NULL;	/* Mark the slot in the list as free.  */
- 	ptr = l->exact;
- 	break;
-       }
- 
-   block = BLOCK (ptr);
- 
-   type = _heapinfo[block].busy.type;
-   switch (type)
-     {
-     case 0:
-       /* Get as many statistics as early as we can.  */
-       --chunks_used;
-       bytes_used -= _heapinfo[block].busy.info.size * BLOCKSIZE;
-       bytes_free += _heapinfo[block].busy.info.size * BLOCKSIZE;
- 
-       /* Find the free cluster previous to this one in the free list.
- 	 Start searching at the last block referenced; this may benefit
- 	 programs with locality of allocation.  */
-       i = _heapindex;
-       if (i > block)
- 	while (i > block)
- 	  i = _heapinfo[i].free.prev;
-       else
- 	{
- 	  do
- 	    i = _heapinfo[i].free.next;
- 	  while (i > 0 && i < block);
- 	  i = _heapinfo[i].free.prev;
- 	}
- 
-       /* Determine how to link this block into the free list.  */
-       if (block == i + _heapinfo[i].free.size)
- 	{
- 	  /* Coalesce this block with its predecessor.  */
- 	  _heapinfo[i].free.size += _heapinfo[block].busy.info.size;
- 	  block = i;
- 	}
-       else
- 	{
- 	  /* Really link this block back into the free list.  */
- 	  _heapinfo[block].free.size = _heapinfo[block].busy.info.size;
- 	  _heapinfo[block].free.next = _heapinfo[i].free.next;
- 	  _heapinfo[block].free.prev = i;
- 	  _heapinfo[i].free.next = block;
- 	  _heapinfo[_heapinfo[block].free.next].free.prev = block;
- 	  ++chunks_free;
- 	}
- 
-       /* Now that the block is linked in, see if we can coalesce it
- 	 with its successor (by deleting its successor from the list
- 	 and adding in its size).  */
-       if (block + _heapinfo[block].free.size == _heapinfo[block].free.next)
- 	{
- 	  _heapinfo[block].free.size
- 	    += _heapinfo[_heapinfo[block].free.next].free.size;
- 	  _heapinfo[block].free.next
- 	    = _heapinfo[_heapinfo[block].free.next].free.next;
- 	  _heapinfo[_heapinfo[block].free.next].free.prev = block;
- 	  --chunks_free;
- 	}
- 
-       /* How many trailing free blocks are there now?  */
-       blocks = _heapinfo[block].free.size;
- 
-       /* Where is the current end of accessible core?  */
-       curbrk = default_morecore (0);
- 
-       if (_heaplimit != 0 && curbrk == ADDRESS (_heaplimit))
- 	{
- 	  /* The end of the malloc heap is at the end of accessible core.
- 	     It's possible that moving _heapinfo will allow us to
- 	     return some space to the system.  */
- 
-  	  size_t info_block = BLOCK (_heapinfo);
-  	  size_t info_blocks = _heapinfo[info_block].busy.info.size;
-  	  size_t prev_block = _heapinfo[block].free.prev;
-  	  size_t prev_blocks = _heapinfo[prev_block].free.size;
-  	  size_t next_block = _heapinfo[block].free.next;
-  	  size_t next_blocks = _heapinfo[next_block].free.size;
- 
- 	  if (/* Win if this block being freed is last in core, the info table
- 		 is just before it, the previous free block is just before the
- 		 info table, and the two free blocks together form a useful
- 		 amount to return to the system.  */
- 	      (block + blocks == _heaplimit &&
- 	       info_block + info_blocks == block &&
- 	       prev_block != 0 && prev_block + prev_blocks == info_block &&
- 	       blocks + prev_blocks >= lesscore_threshold) ||
- 	      /* Nope, not the case.  We can also win if this block being
- 		 freed is just before the info table, and the table extends
- 		 to the end of core or is followed only by a free block,
- 		 and the total free space is worth returning to the system.  */
- 	      (block + blocks == info_block &&
- 	       ((info_block + info_blocks == _heaplimit &&
- 		 blocks >= lesscore_threshold) ||
- 		(info_block + info_blocks == next_block &&
- 		 next_block + next_blocks == _heaplimit &&
- 		 blocks + next_blocks >= lesscore_threshold)))
- 	      )
- 	    {
- 	      malloc_info *newinfo;
- 	      size_t oldlimit = _heaplimit;
- 
- 	      /* Free the old info table, clearing _heaplimit to avoid
- 		 recursion into this code.  We don't want to return the
- 		 table's blocks to the system before we have copied them to
- 		 the new location.  */
- 	      _heaplimit = 0;
- 	      ifree (_heapinfo);
- 	      _heaplimit = oldlimit;
- 
- 	      /* Tell malloc to search from the beginning of the heap for
- 		 free blocks, so it doesn't reuse the ones just freed.  */
- 	      _heapindex = 0;
- 
- 	      /* Allocate new space for the info table and move its data.  */
- 	      newinfo = (malloc_info *) imalloc (info_blocks
- 							  * BLOCKSIZE);
- 	      memmove (newinfo, _heapinfo, info_blocks * BLOCKSIZE);
- 	      _heapinfo = newinfo;
- 
- 	      /* We should now have coalesced the free block with the
- 		 blocks freed from the old info table.  Examine the entire
- 		 trailing free block to decide below whether to return some
- 		 to the system.  */
- 	      block = _heapinfo[0].free.prev;
- 	      blocks = _heapinfo[block].free.size;
-  	    }
- 
- 	  /* Now see if we can return stuff to the system.  */
- 	  if (block + blocks == _heaplimit && blocks >= lesscore_threshold)
- 	    {
- 	      register size_t bytes = blocks * BLOCKSIZE;
- 	      _heaplimit -= blocks;
- 	      default_morecore (-bytes);
- 	      _heapinfo[_heapinfo[block].free.prev].free.next
- 		= _heapinfo[block].free.next;
- 	      _heapinfo[_heapinfo[block].free.next].free.prev
- 		= _heapinfo[block].free.prev;
- 	      block = _heapinfo[block].free.prev;
- 	      --chunks_free;
- 	      bytes_free -= bytes;
- 	    }
- 	}
- 
-       /* Set the next search to begin at this block.  */
-       _heapindex = block;
-       break;
- 
-     default:
-       /* Do some of the statistics.  */
-       --chunks_used;
-       bytes_used -= 1 << type;
-       ++chunks_free;
-       bytes_free += 1 << type;
- 
-       /* Get the address of the first free fragment in this block.  */
-       prev = (struct list *) ((char *) ADDRESS (block) +
- 			      (_heapinfo[block].busy.info.frag.first << type));
- 
-       if (_heapinfo[block].busy.info.frag.nfree == (BLOCKSIZE >> type) - 1)
- 	{
- 	  /* If all fragments of this block are free, remove them
- 	     from the fragment list and free the whole block.  */
- 	  next = prev;
- 	  for (i = 1; i < (size_t) (BLOCKSIZE >> type); ++i)
- 	    next = next->next;
- 	  prev->prev->next = next;
- 	  if (next != NULL)
- 	    next->prev = prev->prev;
- 	  _heapinfo[block].busy.type = 0;
- 	  _heapinfo[block].busy.info.size = 1;
- 
- 	  /* Keep the statistics accurate.  */
- 	  ++chunks_used;
- 	  bytes_used += BLOCKSIZE;
- 	  chunks_free -= BLOCKSIZE >> type;
- 	  bytes_free -= BLOCKSIZE;
- 
- 	  ifree (ADDRESS (block));
- 	}
-       else if (_heapinfo[block].busy.info.frag.nfree != 0)
- 	{
- 	  /* If some fragments of this block are free, link this
- 	     fragment into the fragment list after the first free
- 	     fragment of this block. */
- 	  next = (struct list *) ptr;
- 	  next->next = prev->next;
- 	  next->prev = prev;
- 	  prev->next = next;
- 	  if (next->next != NULL)
- 	    next->next->prev = next;
- 	  ++_heapinfo[block].busy.info.frag.nfree;
- 	}
-       else
- 	{
- 	  /* No fragments of this block are free, so link this
- 	     fragment into the fragment list and announce that
- 	     it is the first free fragment of this block. */
- 	  prev = (struct list *) ptr;
- 	  _heapinfo[block].busy.info.frag.nfree = 1;
- 	  _heapinfo[block].busy.info.frag.first = (unsigned long int)
- 	    ((unsigned long int) ((char *) ptr - (char *) NULL)
- 	     % BLOCKSIZE >> type);
- 	  prev->next = _fraghead[type].next;
- 	  prev->prev = &_fraghead[type];
- 	  prev->prev->next = prev;
- 	  if (prev->next != NULL)
- 	    prev->next->prev = prev;
- 	}
-       break;
-     }
- }
- 
- /* Return memory to the heap.  */
- void
- free (ptr)
-      genptr_t ptr;
- {
- #ifdef RCHECK
-   struct hdr *hdr;
- #endif
- 
-   nfree++;
- 
-   if (ptr == 0)
-     return;
- 
- #ifdef RCHECK
-   hdr = ((struct hdr *) ptr) - 1;
-   checkhdr (hdr);
-   hdr->magic = MAGICFREE;
-   zmemset (ptr, FREEFLOOD, hdr->size);
-   ifree (hdr);
- #else
-   ifree (ptr);
- #endif
- }
- 
- /* Change the size of a block allocated by `malloc'. */
- 
- #ifndef HAVE_MEMMOVE
- /* Snarfed directly from Emacs src/dispnew.c:
-    XXX Should use system bcopy if it handles overlap.  */
- 
- /* Like bcopy except never gets confused by overlap.  */
- 
- static void
- malloc_safe_bcopy (afrom, ato, size)
-      genptr_t afrom;
-      genptr_t ato;
-      size_t size;
- {
-   char *from, *to;
- 
-   from = afrom;
-   to = ato;
-   if (size <= 0 || from == to)
-     return;
- 
-   /* If the source and destination don't overlap, then bcopy can
-      handle it.  If they do overlap, but the destination is lower in
-      memory than the source, we'll assume bcopy can handle that.  */
-   if (to < from || from + size <= to)
-     bcopy (from, to, size);
- 
-   /* Otherwise, we'll copy from the end.  */
-   else
-     {
-       register char *endf = from + size;
-       register char *endt = to + size;
- 
-       /* If TO - FROM is large, then we should break the copy into
- 	 nonoverlapping chunks of TO - FROM bytes each.  However, if
- 	 TO - FROM is small, then the bcopy function call overhead
- 	 makes this not worth it.  The crossover point could be about
- 	 anywhere.  Since I don't think the obvious copy loop is too
- 	 bad, I'm trying to err in its favor.  */
-       if (to - from < 64)
- 	{
- 	  do
- 	    *--endt = *--endf;
- 	  while (endf != from);
- 	}
-       else
- 	{
- 	  for (;;)
- 	    {
- 	      endt -= (to - from);
- 	      endf -= (to - from);
- 
- 	      if (endt < to)
- 		break;
- 
- 	      bcopy (endf, endt, to - from);
- 	    }
- 
- 	  /* If SIZE wasn't a multiple of TO - FROM, there will be a
- 	     little left over.  The amount left over is
- 	     (endt + (to - from)) - to, which is endt - from.  */
- 	  bcopy (from, to, endt - from);
- 	}
-     }
- }
- #endif /* !HAVE_MEMMOVE */
- 
- /* Resize the given region to the new size, returning a pointer
-    to the (possibly moved) region.  This is optimized for speed;
-    some benchmarks seem to indicate that greater compactness is
-    achieved by unconditionally allocating and copying to a
-    new region.  This module has incestuous knowledge of the
-    internals of both free and malloc. */
- static genptr_t
- irealloc (ptr, size)
-      genptr_t ptr;
-      size_t size;
- {
-   genptr_t result;
-   int type;
-   size_t block, blocks, oldlimit;
- 
-   if (size == 0)
-     {
-       ifree (ptr);
-       return imalloc (0);
-     }
-   else if (ptr == NULL)
-     return imalloc (size);
- 
-   block = BLOCK (ptr);
- 
-   type = _heapinfo[block].busy.type;
-   switch (type)
-     {
-     case 0:
-       /* Maybe reallocate a large block to a small fragment.  */
-       if (size <= BLOCKSIZE / 2)
- 	{
- 	  result = imalloc (size);
- 	  if (result != NULL)
- 	    {
- 	      memcpy (result, ptr, size);
- 	      ifree (ptr);
- 	      return result;
- 	    }
- 	}
- 
-       /* The new size is a large allocation as well;
- 	 see if we can hold it in place. */
-       blocks = BLOCKIFY (size);
-       if (blocks < _heapinfo[block].busy.info.size)
- 	{
- 	  /* The new size is smaller; return
- 	     excess memory to the free list. */
- 	  _heapinfo[block + blocks].busy.type = 0;
- 	  _heapinfo[block + blocks].busy.info.size
- 	    = _heapinfo[block].busy.info.size - blocks;
- 	  _heapinfo[block].busy.info.size = blocks;
- 	  /* We have just created a new chunk by splitting a chunk in two.
- 	     Now we will free this chunk; increment the statistics counter
- 	     so it doesn't become wrong when ifree decrements it.  */
- 	  ++chunks_used;
- 	  ifree (ADDRESS (block + blocks));
- 	  result = ptr;
- 	}
-       else if (blocks == _heapinfo[block].busy.info.size)
- 	/* No size change necessary.  */
- 	result = ptr;
-       else
- 	{
- 	  /* Won't fit, so allocate a new region that will.
- 	     Free the old region first in case there is sufficient
- 	     adjacent free space to grow without moving. */
- 	  blocks = _heapinfo[block].busy.info.size;
- 	  /* Prevent free from actually returning memory to the system.  */
- 	  oldlimit = _heaplimit;
- 	  _heaplimit = 0;
- 	  ifree (ptr);
- 	  result = imalloc (size);
- 	  if (_heaplimit == 0)
- 	    _heaplimit = oldlimit;
- 	  if (result == NULL)
- 	    {
- 	      /* Now we're really in trouble.  We have to unfree
- 		 the thing we just freed.  Unfortunately it might
- 		 have been coalesced with its neighbors.  */
- 	      if (_heapindex == block)
- 		(void) imalloc (blocks * BLOCKSIZE);
- 	      else
- 		{
- 		  genptr_t previous;
- 		  previous  = imalloc ((block - _heapindex) * BLOCKSIZE);
- 		  (void) imalloc (blocks * BLOCKSIZE);
- 		  ifree (previous);
- 		}
- 	      return NULL;
- 	    }
- 	  if (ptr != result)
- 	    memmove (result, ptr, blocks * BLOCKSIZE);
- 	}
-       break;
- 
-     default:
-       /* Old size is a fragment; type is logarithm
- 	 to base two of the fragment size.  */
-       if (size > (size_t) (1 << (type - 1)) &&
- 	  size <= (size_t) (1 << type))
- 	/* The new size is the same kind of fragment.  */
- 	result = ptr;
-       else
- 	{
- 	  /* The new size is different; allocate a new space,
- 	     and copy the lesser of the new size and the old. */
- 	  result = imalloc (size);
- 	  if (result == NULL)
- 	    return NULL;
- 	  memcpy (result, ptr, min (size, (size_t) 1 << type));
- 	  ifree (ptr);
- 	}
-       break;
-     }
- 
-   return result;
- }
- 
- genptr_t
- realloc (ptr, size)
-      genptr_t ptr;
-      size_t size;
- {
- #ifdef RCHECK
-   struct hdr *hdr;
-   size_t osize;
- #endif
- 
-   if (malloc_initialized == 0 && malloc_initialize () == 0)
-     return NULL;
- 
-   nrealloc++;
- 
- #ifdef RCHECK
-   hdr = ((struct hdr *) ptr) - 1;
-   osize = hdr->size;
- 
-   checkhdr (hdr);
-   if (size < osize)
-     zmemset ((char *) ptr + size, FREEFLOOD, osize - size);
-   hdr = (struct hdr *) irealloc ((genptr_t) hdr, sizeof (struct hdr) + size + 1);
-   if (hdr == NULL)
-     return NULL;
- 
-   hdr->size = size;
-   hdr->magic = MAGICWORD;
-   ((char *) &hdr[1])[size] = MAGICBYTE;
-   if (size > osize)
-     zmemset ((char *) (hdr + 1) + osize, MALLOCFLOOD, size - osize);
-   return (genptr_t) (hdr + 1);
- #else
-   return (irealloc (ptr, size));
- #endif
- }
- 
- /* Allocate an array of NMEMB elements each SIZE bytes long.
-    The entire array is initialized to zeros.  */
- genptr_t
- calloc (nmemb, size)
-      register size_t nmemb;
-      register size_t size;
- {
-   register genptr_t result;
- 
-   result = malloc (nmemb * size);
-   if (result != NULL)
-     (void) memset (result, 0, nmemb * size);
- 
-   return result;
- }
- 
- /* Define the `cfree' alias for `free'.  */
- void
- cfree (ptr)
-      genptr_t ptr;
- {
-   free (ptr);
- }
- 
- genptr_t
- memalign (alignment, size)
-      size_t alignment;
-      size_t size;
- {
-   genptr_t result;
-   unsigned long int adj, lastadj;
- 
-   /* Allocate a block with enough extra space to pad the block with up to
-      (ALIGNMENT - 1) bytes if necessary.  */
-   result = malloc (size + alignment - 1);
-   if (result == NULL)
-     return NULL;
- 
-   /* Figure out how much we will need to pad this particular block
-      to achieve the required alignment.  */
-   adj = (unsigned long int) ((char *) result - (char *) NULL) % alignment;
- 
-   do
-     {
-       /* Reallocate the block with only as much excess as it needs.  */
-       free (result);
-       result = malloc (adj + size);
-       if (result == NULL)	/* Impossible unless interrupted.  */
- 	return NULL;
- 
-       lastadj = adj;
-       adj = (unsigned long int) ((char *) result - (char *) NULL) % alignment;
-       /* It's conceivable we might have been so unlucky as to get a
- 	 different block with weaker alignment.  If so, this block is too
- 	 short to contain SIZE after alignment correction.  So we must
- 	 try again and get another block, slightly larger.  */
-     } while (adj > lastadj);
- 
-   if (adj != 0)
-     {
-       /* Record this block in the list of aligned blocks, so that `free'
- 	 can identify the pointer it is passed, which will be in the middle
- 	 of an allocated block.  */
- 
-       struct alignlist *l;
-       for (l = _aligned_blocks; l != NULL; l = l->next)
- 	if (l->aligned == NULL)
- 	  /* This slot is free.  Use it.  */
- 	  break;
-       if (l == NULL)
- 	{
- 	  l = (struct alignlist *) imalloc (sizeof (struct alignlist));
- 	  if (l == NULL)
- 	    {
- 	      free (result);
- 	      return NULL;
- 	    }
- 	  l->next = _aligned_blocks;
- 	  _aligned_blocks = l;
- 	}
-       l->exact = result;
-       result = l->aligned = (char *) result + alignment - adj;
-     }
- 
-   return result;
- }
- 
- /* On some ANSI C systems, some libc functions call _malloc, _free
-    and _realloc.  Make them use the GNU functions.  */
- 
- genptr_t
- _malloc (size)
-      size_t size;
- {
-   return malloc (size);
- }
- 
- void
- _free (ptr)
-      genptr_t ptr;
- {
-   free (ptr);
- }
- 
- genptr_t
- _realloc (ptr, size)
-      genptr_t ptr;
-      size_t size;
- {
-   return realloc (ptr, size);
- }
- 
- struct mstats
- mstats ()
- {
-   struct mstats result;
- 	  
-   result.bytes_total = (char *) default_morecore (0) - _heapbase;
-   result.chunks_used = chunks_used;
-   result.bytes_used = bytes_used;
-   result.chunks_free = chunks_free;
-   result.bytes_free = bytes_free;
-   result.nmalloc = nmalloc;
-   result.nrealloc = nrealloc;
-   result.nfree = nfree;
-   result.nsbrk = nsbrk;
-   result.tsbrk = tsbrk;
-   result.negsbrk = negsbrk;
-   result.tnegsbrk = tnegsbrk;
- 
-   return result;
- }
- 
- #ifdef RCHECK
- /* Standard debugging hooks for `malloc'. */
- 
- static void
- zmemset (ptr, val, size)
-      genptr_t ptr;
-      int val;
-      size_t size;
- {
-   char *cp = ptr;
- 
-   while (size--)
-     *cp++ = val;
- }
- 
- static enum mcheck_status
- checkhdr (hdr)
-      const struct hdr *hdr;
- {
-   enum mcheck_status status;
- 
-   switch (hdr->magic)
-     {
-     default:
-       status = MCHECK_HEAD;
-       break;
-     case MAGICFREE:
-       status = MCHECK_FREE;
-       break;
-     case MAGICWORD:
-       if (((char *) &hdr[1])[hdr->size] != MAGICBYTE)
- 	status = MCHECK_TAIL;
-       else
- 	status = MCHECK_OK;
-       break;
-     }
-   if (status != MCHECK_OK)
-     mabort (status);
-   return status;
- }
- 
- #ifndef botch
- botch (msg)
-      char *msg;
- {
-   fprintf (stderr, "mcheck: %s\n", msg);
-   fflush (stderr);
-   abort ();
- }
- #endif
- 
- static void
- mabort (status)
-      enum mcheck_status status;
- {
-   const char *msg;
- 
-   switch (status)
-     {
-     case MCHECK_OK:
-       msg = "memory is consistent, library is buggy";
-       break;
-     case MCHECK_HEAD:
-       msg = "memory clobbered before allocated block";
-       break;
-     case MCHECK_TAIL:
-       msg = "memory clobbered past end of allocated block";
-       break;
-     case MCHECK_FREE:
-       msg = "block freed twice";
-       break;
-     default:
-       msg = "bogus mcheck_status, library is buggy";
-       break;
-     }
- 
-   botch (msg);
- }
- 
- enum mcheck_status
- mprobe (ptr)
-      genptr_t ptr;
- {
-   return checkhdr ((struct hdr *)ptr);
- }
- 
- #ifndef STDIO_H_INCLUDED
- #  include <stdio.h>
- #endif
- 
- void
- print_malloc_stats (s)
-      char *s;
- {
-   struct mstats ms;
- 
-   ms = mstats ();
-   fprintf (stderr, "Memory allocation statistics: %s\n", s ? s : "");
-   fprintf (stderr, "\nTotal chunks in use: %d, total chunks free: %d\n",
- 	   ms.chunks_used, ms.chunks_free);
-   fprintf (stderr, "Total bytes in use: %u, total bytes free: %u\n",
- 	   ms.bytes_used, ms.bytes_free);
-   fprintf (stderr, "Total bytes (from heapbase): %d\n", ms.bytes_total);
-   fprintf (stderr, "Total mallocs: %d, total frees: %d, total reallocs: %d\n",
- 	   ms.nmalloc, ms.nfree, ms.nrealloc);
-   fprintf (stderr, "Total sbrks: %d, total bytes via sbrk: %d\n",
-   	   ms.nsbrk, ms.tsbrk);
-   fprintf (stderr, "Total negative sbrks: %d, total bytes returned to kernel: %d\n",
-   	   ms.negsbrk, ms.tnegsbrk);
- }
- #endif /* RCHECK */
--- 0 ----
diff -Nrc2 bash-2.05/lib/malloc/imalloc.h bash-2.05a/lib/malloc/imalloc.h
*** bash-2.05/lib/malloc/imalloc.h	Wed Dec 31 19:00:00 1969
--- bash-2.05a/lib/malloc/imalloc.h	Fri Oct  5 14:51:48 2001
***************
*** 0 ****
--- 1,67 ----
+ /* imalloc.h -- internal malloc definitions shared by source files. */
+ 
+ /* Copyright (C) 2001 Free Software Foundation, Inc.
+ 
+    This file is part of GNU Bash, the Bourne Again SHell.
+ 
+    Bash is free software; you can redistribute it and/or modify it under
+    the terms of the GNU General Public License as published by the Free
+    Software Foundation; either version 2, or (at your option) any later
+    version.
+ 
+    Bash is distributed in the hope that it will be useful, but WITHOUT ANY
+    WARRANTY; without even the implied warranty of MERCHANTABILITY or
+    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+    for more details.
+ 
+    You should have received a copy of the GNU General Public License along
+    with Bash; see the file COPYING.  If not, write to the Free Software
+    Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. */
+ 
+ /* Must be included *after* config.h */
+ 
+ #ifndef _IMALLOC_H_
+ #define _IMALLOC_H
+ 
+ #ifdef MALLOC_DEBUG
+ #define MALLOC_STATS
+ #define MALLOC_TRACE
+ #define MALLOC_REGISTER
+ #endif
+ 
+ /* Generic pointer type. */
+ #ifndef PTR_T
+ #  if defined (__STDC__)
+ #    define PTR_T void *
+ #  else
+ #    define PTR_T char *
+ #  endif
+ #endif
+ 
+ #if !defined (NULL)
+ #  define NULL 0
+ #endif
+ 
+ #if !defined (__STRING)
+ #  if defined (HAVE_STRINGIZE)
+ #    define __STRING(x) #x
+ #  else
+ #    define __STRING(x) "x"
+ #  endif /* !HAVE_STRINGIZE */
+ #endif /* !__STRING */
+ 
+ #if __GNUC__ > 1
+ #  define FASTCOPY(s, d, n)  __builtin_memcpy (d, s, n)
+ #else /* !__GNUC__ */
+ #  if !defined (HAVE_BCOPY)
+ #    if !defined (HAVE_MEMMOVE)
+ #      define FASTCOPY(s, d, n)  memcpy (d, s, n)
+ #    else
+ #      define FASTCOPY(s, d, n)  memmove (d, s, n)
+ #    endif /* !HAVE_MEMMOVE */
+ #  else /* HAVE_BCOPY */
+ #    define FASTCOPY(s, d, n)  bcopy (s, d, n)
+ #  endif /* HAVE_BCOPY */
+ #endif /* !__GNUC__ */
+ 
+ #endif
diff -Nrc2 bash-2.05/lib/malloc/malloc.c bash-2.05a/lib/malloc/malloc.c
*** bash-2.05/lib/malloc/malloc.c	Wed Feb 14 17:01:50 2001
--- bash-2.05a/lib/malloc/malloc.c	Thu Oct  4 08:13:16 2001
***************
*** 46,50 ****
   * if the power of 2 is correct.
   */
- #define MALLOC_STATS		/* for the time being */
  
  /*
--- 46,49 ----
***************
*** 68,73 ****
--- 67,82 ----
  #if defined (SHELL)
  #  include "bashtypes.h"
+ #  include "stdc.h"
  #else
  #  include <sys/types.h>
+ 
+ #  ifndef __P
+ #    if defined (__STDC__) || defined (__GNUC__) || defined (__cplusplus)
+ #      define __P(protos) protos
+ #    else
+ #      define __P(protos) ()
+ #    endif
+ #  endif
+ 
  #endif
  
***************
*** 85,91 ****
  #endif
  
! #if defined (MALLOC_STATS) || !defined (botch)
! #  include <stdio.h>
! #endif /* MALLOC_STATS || !botch */
  
  /* Define getpagesize () if the system does not.  */
--- 94,98 ----
  #endif
  
! #include <stdio.h>
  
  /* Define getpagesize () if the system does not.  */
***************
*** 94,122 ****
  #endif
  
! #if __GNUC__ > 1
! #  define FASTCOPY(s, d, n)  __builtin_memcpy (d, s, n)
! #else /* !__GNUC__ */
! #  if !defined (HAVE_BCOPY)
! #    if !defined (HAVE_MEMMOVE)
! #      define FASTCOPY(s, d, n)  memcpy (d, s, n)
! #    else
! #      define FASTCOPY(s, d, n)  memmove (d, s, n)
! #    endif /* !HAVE_MEMMOVE */
! #  else /* HAVE_BCOPY */
! #    define FASTCOPY(s, d, n)  bcopy (s, d, n)
! #  endif /* HAVE_BCOPY */
! #endif /* !__GNUC__ */
! 
! /* Generic pointer type. */
! #ifndef PTR_T
! #  if defined (__STDC__)
! #    define PTR_T void *
! #  else
! #    define PTR_T char *
! #  endif
  #endif
  
! #if !defined (NULL)
! #  define NULL 0
  #endif
  
--- 101,115 ----
  #endif
  
! #include "imalloc.h"
! #ifdef MALLOC_STATS
! #  include "mstats.h"
! #endif
! #ifdef MALLOC_REGISTER
! #  include "table.h"
  #endif
  
! /* System-specific omissions. */
! #ifdef HPUX
! #  define NO_VALLOC
  #endif
  
***************
*** 131,194 ****
  				     beginning of the block.  */
  
- #if !defined (SBRK_DECLARED)
- extern char *sbrk ();
- #endif /* !SBRK_DECLARED */
- 
- #ifdef MALLOC_STATS
- /*
-  * NMALLOC[i] is the difference between the number of mallocs and frees
-  * for a given block size.  TMALLOC[i] is the total number of mallocs for
-  * a given block size.  NMORECORE[i] is the total number of calls to
-  * morecore(i).  NMAL and NFRE are counts of the number of calls to malloc()
-  * and free(), respectively.  NREALLOC is the total number of calls to
-  * realloc(); NRCOPY is the number of times realloc() had to allocate new
-  * memory and copy to it.  NRECURSE is a count of the number of recursive
-  * calls to malloc() for the same bucket size, which can be caused by calls
-  * to malloc() from a signal handler.  NSBRK is the number of calls to sbrk()
-  * (whether by morecore() or for alignment); TSBRK is the total number of
-  * bytes requested from the kernel with sbrk().  BYTESUSED is the total
-  * number of bytes consumed by blocks currently in use; BYTESFREE is the
-  * total number of bytes currently on all of the free lists.  TBSPLIT is
-  * the number of times a larger block was split to satisfy a smaller request.
-  * NSPLIT[i] is the number of times a block of size I was split.
-  * TBCOALESCE is the number of times two adjacent smaller blocks off the free
-  * list were combined to satisfy a larger request.
-  */
- struct _malstats {
-   int nmalloc[NBUCKETS];
-   int tmalloc[NBUCKETS];
-   int nmorecore[NBUCKETS];
-   int nmal;
-   int nfre;
-   int nrealloc;
-   int nrcopy;
-   int nrecurse;
-   int nsbrk;
-   bits32_t tsbrk;
-   bits32_t bytesused;
-   bits32_t bytesfree;
-   int tbsplit;
-   int nsplit[NBUCKETS];
-   int tbcoalesce;
- };
- 
- static struct _malstats _mstats;
- 
- /* Return statistics describing allocation of blocks of size BLOCKSIZE.
-    NFREE is the number of free blocks for this allocation size.  NUSED
-    is the number of blocks in use.  NMAL is the number of requests for
-    blocks of size BLOCKSIZE.  NMORECORE is the number of times we had
-    to call MORECORE to repopulate the free list for this bucket.  NSPLIT
-    is the number of times a block of this size was split to satisfy a
-    smaller request. */
- struct bucket_stats {
-   u_bits32_t blocksize;
-   int nfree;
-   int nused;
-   int nmal;
-   int nmorecore;
-   int nsplit;
- };
- #endif /* MALLOC_STATS */
  
  /* We have a flag indicating whether memory is allocated, an index in
--- 124,127 ----
***************
*** 199,209 ****
     done. */
  union mhead {
!   bits64_t mh_align;					/* 8 */
    struct {
!     char     mi_alloc;	/* ISALLOC or ISFREE */		/* 1 */
!     char     mi_index;	/* index in nextf[] */		/* 1 */
      /* Remainder are valid only when block is allocated */
!     u_bits32_t mi_nbytes;  /* # of bytes allocated */	/* 4 */
!     u_bits16_t mi_magic2;/* should be == MAGIC2 */	/* 2 */
    } minfo;
  };
--- 132,142 ----
     done. */
  union mhead {
!   bits64_t mh_align;						/* 8 */
    struct {
!     char mi_alloc; 		/* ISALLOC or ISFREE */		/* 1 */
!     char mi_index;		/* index in nextf[] */		/* 1 */
      /* Remainder are valid only when block is allocated */
!     u_bits16_t mi_magic2;	/* should be == MAGIC2 */	/* 2 */
!     u_bits32_t mi_nbytes;	/* # of bytes allocated */	/* 4 */
    } minfo;
  };
***************
*** 223,247 ****
    (*(union mhead **) (sizeof (char *) + (char *) (a)))
  
- #if defined (botch)
- extern void botch ();
- #else
- static void
- botch (s)
-      char *s;
- {
-   fprintf (stderr, "\r\nmalloc: assertion botched: %s\r\n", s);
-   (void)fflush (stderr);
-   abort ();
- }
- #endif /* !botch */
- 
- #if !defined (__STRING)
- #  if defined (__STDC__)
- #    define __STRING(x) #x
- #  else
- #    define __STRING(x) "x"
- #  endif
- #endif /* !__STRING */
- 
  /* To implement range checking, we write magic values in at the beginning
     and end of each allocated block, and make sure they are undisturbed
--- 156,159 ----
***************
*** 250,258 ****
  /* Written in each of the 4 bytes following the block's real space */
  #define MAGIC1 0x55
! /* Written in the 2 bytes before the block's real space */
  #define MAGIC2 0x5555
- #define ASSERT(p) do { if (!(p)) botch(__STRING(p)); } while (0)
  #define MSLOP  4		/* 4 bytes extra for MAGIC1s */
  
  /* Minimum and maximum bucket indices for block splitting (and to bound
     the search for a block to split). */
--- 162,181 ----
  /* Written in each of the 4 bytes following the block's real space */
  #define MAGIC1 0x55
! /* Written in the 2 bytes before the block's real space (-4 bytes) */
  #define MAGIC2 0x5555
  #define MSLOP  4		/* 4 bytes extra for MAGIC1s */
  
+ /* How many bytes are actually allocated for a request of size N --
+    rounded up to nearest multiple of 8 after accounting for malloc
+    overhead. */
+ #define ALLOCATED_BYTES(n)  (((n) + sizeof (union mhead) + MSLOP + 7) & ~7)
+ 
+ #define ASSERT(p) \
+   do \
+     { \
+       if (!(p)) xbotch((PTR_T)0, ERR_ASSERT_FAILED, __STRING(p), file, line); \
+     } \
+   while (0)
+ 
  /* Minimum and maximum bucket indices for block splitting (and to bound
     the search for a block to split). */
***************
*** 267,270 ****
--- 190,210 ----
  #define MIN_COMBINE_FREE	4
  
+ /* Flags for the internal functions. */
+ #define MALLOC_WRAPPER	0x01	/* wrapper function */
+ #define MALLOC_INTERNAL	0x02	/* internal function calling another */
+ #define MALLOC_NOTRACE	0x04	/* don't trace this allocation or free */
+ #define MALLOC_NOREG	0x08	/* don't register this allocation or free */
+ 
+ /* Future use. */
+ #define ERR_DUPFREE		0x01
+ #define ERR_UNALLOC		0x02
+ #define ERR_UNDERFLOW		0x04	
+ #define ERR_ASSERT_FAILED	0x08
+ 
+ /* Evaluates to true if NB is appropriate for bucket NU.  NB is adjusted
+    appropriately by the caller to account for malloc overhead. */
+ #define IN_BUCKET(nb, nu) \
+   ((nb) > (4 << (nu)) && ((nb) <= (8 << (nu))))
+ 
  /* nextf[i] is free list of blocks of size 2**(i + 3)  */
  
***************
*** 279,287 ****
  static int maxbuck;	/* highest bucket receiving allocation request. */
  
  #ifdef SHELL
  extern int interrupt_immediately;
! extern int signal_is_trapped ();
  #endif
  
  #if 0
  /* Coalesce two adjacent free blocks off the free list for size NU - 1,
--- 219,290 ----
  static int maxbuck;	/* highest bucket receiving allocation request. */
  
+ /* Declarations for internal functions */
+ static PTR_T internal_malloc __P((size_t, const char *, int, int));
+ static PTR_T internal_realloc __P((PTR_T, size_t, const char *, int, int));
+ static void internal_free __P((PTR_T, const char *, int, int));
+ static PTR_T internal_memalign __P((unsigned int, size_t, const char *, int, int));
+ #ifndef NO_CALLOC
+ static PTR_T internal_calloc __P((size_t, size_t, const char *, int, int));
+ static void internal_cfree __P((PTR_T, const char *, int, int));
+ #endif
+ #ifndef NO_VALLOC
+ static PTR_T internal_valloc __P((size_t, const char *, int, int));
+ #endif
+ 
+ #if defined (botch)
+ extern void botch ();
+ #else
+ static void botch __P((const char *, const char *, int));
+ #endif
+ static void xbotch __P((PTR_T, int, const char *, const char *, int));
+ 
+ #ifdef MALLOC_STATS
+ extern struct _malstats _mstats;
+ #endif /* MALLOC_STATS */
+ 
+ #if !HAVE_DECL_SBRK
+ extern char *sbrk ();
+ #endif /* !HAVE_DECL_SBRK */
+ 
  #ifdef SHELL
  extern int interrupt_immediately;
! extern int signal_is_trapped __P((int));
  #endif
  
+ /* Debugging variables available to applications. */
+ int malloc_flags = 0;	/* future use */
+ int malloc_trace = 0;	/* trace allocations and frees to stderr */
+ int malloc_register = 0;	/* future use */
+ 
+ #if !defined (botch)
+ static void
+ botch (s, file, line)
+ {
+   fprintf (stderr, "malloc: failed assertion: %s\n", s);
+   (void)fflush (stderr);
+   abort ();
+ }
+ #endif
+ 
+ /* print the file and line number that caused the assertion failure and
+    call botch() to do whatever the application wants with the information */
+ static void
+ xbotch (mem, e, s, file, line)
+      PTR_T mem;
+      int e;
+      const char *s;
+      const char *file;
+      int line;
+ {
+   fprintf (stderr, "\r\nmalloc: %s:%d: assertion botched\r\n",
+ 			file ? file : "unknown", line);
+ #ifdef MALLOC_REGISTER
+   if (mem != NULL && malloc_register)
+     mregister_describe_mem (mem, stderr);
+ #endif
+   (void)fflush (stderr);
+   botch(s, file, line);
+ }
+ 
  #if 0
  /* Coalesce two adjacent free blocks off the free list for size NU - 1,
***************
*** 320,324 ****
       CHAIN(mp2) must equal mp1.  Check that mp1 and mp are adjacent. */
    if (CHAIN(mp2) != mp1)
!     botch ("bcoalesce: CHAIN(mp2) != mp1");
    siz = 1 << (nbuck + 3);
    if (CHAIN (mp1) != (union mhead *)((char *)mp1 + siz))
--- 323,327 ----
       CHAIN(mp2) must equal mp1.  Check that mp1 and mp are adjacent. */
    if (CHAIN(mp2) != mp1)
!     xbotch ((PTR_T)0, 0, "bcoalesce: CHAIN(mp2) != mp1", (char *)NULL, 0);
    siz = 1 << (nbuck + 3);
    if (CHAIN (mp1) != (union mhead *)((char *)mp1 + siz))
***************
*** 465,473 ****
    /* Try to split a larger block here, if we're within the range of sizes
       to split. */
- #if 0
-   if (nu >= SPLIT_MIN && nu < SPLIT_MAX)
- #else
    if (nu >= SPLIT_MIN)
- #endif
      {
        bsplit (nu);
--- 468,472 ----
***************
*** 523,527 ****
    if ((long)mp & 7)
      {
!       mp = (union mhead *) (((long)mp + 8) & ~7);
        nblks--;
      }
--- 522,526 ----
    if ((long)mp & 7)
      {
!       mp = (union mhead *) (((long)mp + 7) & ~7);
        nblks--;
      }
***************
*** 566,572 ****
  }
  
! PTR_T
! malloc (n)		/* get a block */
       size_t n;
  {
    register union mhead *p;
--- 565,573 ----
  }
  
! static PTR_T
! internal_malloc (n, file, line, flags)		/* get a block */
       size_t n;
+      const char *file;
+      int line, flags;
  {
    register union mhead *p;
***************
*** 611,618 ****
   
    /* Figure out how many bytes are required, rounding up to the nearest
!      multiple of 4, then figure out which nextf[] area to use.  Try to
       be smart about where to start searching -- if the number of bytes
       needed is greater than the page size, we can start at pagebucket. */
!   nbytes = (n + sizeof *p + MSLOP + 3) & ~3;
    nunits = 0;
    if (nbytes <= (pagesz >> 1))
--- 612,619 ----
   
    /* Figure out how many bytes are required, rounding up to the nearest
!      multiple of 8, then figure out which nextf[] area to use.  Try to
       be smart about where to start searching -- if the number of bytes
       needed is greater than the page size, we can start at pagebucket. */
!   nbytes = ALLOCATED_BYTES(n);
    nunits = 0;
    if (nbytes <= (pagesz >> 1))
***************
*** 637,640 ****
--- 638,645 ----
      }
  
+   /* Silently reject too-large requests. */
+   if (nunits >= NBUCKETS)
+     return ((PTR_T) NULL);
+ 
    /* In case this is reentrant use of malloc from signal handler,
       pick a block size that no other malloc level is currently
***************
*** 667,676 ****
       and bomb out on the NEXT allocate of this size block */
    if (p->mh_alloc != ISFREE || p->mh_index != nunits)
!     botch ("malloc: block on free list clobbered");
  
!   /* Fill in the info, and if range checking, set up the magic numbers */
    p->mh_alloc = ISALLOC;
-   p->mh_nbytes = n;
    p->mh_magic2 = MAGIC2;
    {
      register char  *m = (char *) (p + 1) + n;
--- 672,681 ----
       and bomb out on the NEXT allocate of this size block */
    if (p->mh_alloc != ISFREE || p->mh_index != nunits)
!     xbotch ((PTR_T)0, 0, "malloc: block on free list clobbered", file, line);
  
!   /* Fill in the info, and set up the magic numbers for range checking. */
    p->mh_alloc = ISALLOC;
    p->mh_magic2 = MAGIC2;
+   p->mh_nbytes = n;
    {
      register char  *m = (char *) (p + 1) + n;
***************
*** 687,700 ****
    _mstats.nmal++;
  #endif /* MALLOC_STATS */
    return (char *) (p + 1);	/* XXX - should be cast to PTR_T? */
  }
  
! void
! free (mem)
       PTR_T mem;
  {
    register union mhead *p;
    register char *ap;
    register int nunits;
  
    if ((ap = (char *)mem) == 0)
--- 692,720 ----
    _mstats.nmal++;
  #endif /* MALLOC_STATS */
+ 
+ #ifdef MALLOC_TRACE
+   if (malloc_trace && (flags & MALLOC_NOTRACE) == 0)
+     mtrace_alloc ("malloc", p + 1, n, file, line);
+ #endif
+ 
+ #ifdef MALLOC_REGISTER
+   if (malloc_register && (flags & MALLOC_NOREG) == 0)
+     mregister_alloc ("malloc", p + 1, n, file, line);
+ #endif
+ 
    return (char *) (p + 1);	/* XXX - should be cast to PTR_T? */
  }
  
! static void
! internal_free (mem, file, line, flags)
       PTR_T mem;
+      const char *file;
+      int line, flags;
  {
    register union mhead *p;
    register char *ap;
    register int nunits;
+   register unsigned int nbytes;
+   int ubytes;		/* caller-requested size */
  
    if ((ap = (char *)mem) == 0)
***************
*** 709,721 ****
      }
  
    if (p->mh_alloc != ISALLOC)
      {
        if (p->mh_alloc == ISFREE)
! 	botch ("free: called with already freed block argument");
        else
! 	botch ("free: called with unallocated block argument");
      }
  
    ASSERT (p->mh_magic2 == MAGIC2);
    ap += p->mh_nbytes;
    ASSERT (*ap++ == MAGIC1); ASSERT (*ap++ == MAGIC1);
--- 729,763 ----
      }
  
+ #if defined (MALLOC_TRACE) || defined (MALLOC_REGISTER)
+   if (malloc_trace || malloc_register)
+     ubytes = p->mh_nbytes;
+ #endif
+ 
    if (p->mh_alloc != ISALLOC)
      {
        if (p->mh_alloc == ISFREE)
! 	xbotch (mem, ERR_DUPFREE,
! 		"free: called with already freed block argument", file, line);
        else
! 	xbotch (mem, ERR_UNALLOC,
! 		"free: called with unallocated block argument", file, line);
      }
  
    ASSERT (p->mh_magic2 == MAGIC2);
+ 
+   nunits = p->mh_index;
+   nbytes = ALLOCATED_BYTES(p->mh_nbytes);
+   /* Since the sizeof(u_bits32_t) bytes before the memory handed to the user
+      are now used for the number of bytes allocated, a simple check of
+      mh_magic2 is no longer sufficient to catch things like p[-1] = 'x'.
+      We sanity-check the value of mh_nbytes against the size of the blocks
+      in the appropriate bucket before we use it.  This can still cause problems
+      and obscure errors if mh_nbytes is wrong but still within range; the
+      checks against MAGIC1 will probably fail then.  Using MALLOC_REGISTER
+      will help here, since it saves the original number of bytes requested. */
+   if (IN_BUCKET(nbytes, nunits) == 0)
+     xbotch (mem, ERR_UNDERFLOW,
+ 	    "free: underflow detected; mh_nbytes out of range", file, line);
+ 
    ap += p->mh_nbytes;
    ASSERT (*ap++ == MAGIC1); ASSERT (*ap++ == MAGIC1);
***************
*** 726,738 ****
  #endif
  
-   nunits = p->mh_index;
- 
    ASSERT (nunits < NBUCKETS);
    p->mh_alloc = ISFREE;
  
- #if 0
    if (busy[nunits] == 1)
!     botch ("calling free %d while in malloc for %d", nunits, nunits);    
! #endif
  
    /* Protect against signal handlers calling malloc.  */
--- 768,776 ----
  #endif
  
    ASSERT (nunits < NBUCKETS);
    p->mh_alloc = ISFREE;
  
    if (busy[nunits] == 1)
!     return;	/* this is bogus, but at least it won't corrupt the chains */
  
    /* Protect against signal handlers calling malloc.  */
***************
*** 747,756 ****
    _mstats.nfre++;
  #endif /* MALLOC_STATS */
  }
  
! PTR_T
! realloc (mem, n)
       PTR_T mem;
       register size_t n;
  {
    register union mhead *p;
--- 785,806 ----
    _mstats.nfre++;
  #endif /* MALLOC_STATS */
+ 
+ #ifdef MALLOC_TRACE
+   if (malloc_trace && (flags & MALLOC_NOTRACE) == 0)
+     mtrace_free (mem, ubytes, file, line);
+ #endif
+ 
+ #ifdef MALLOC_REGISTER
+   if (malloc_register && (flags & MALLOC_NOREG) == 0)
+     mregister_free (mem, ubytes, file, line);
+ #endif
  }
  
! static PTR_T
! internal_realloc (mem, n, file, line, flags)
       PTR_T mem;
       register size_t n;
+      const char *file;
+      int line, flags;
  {
    register union mhead *p;
***************
*** 766,778 ****
    if (n == 0)
      {
!       free (mem);
        return (NULL);
      }
    if ((p = (union mhead *) mem) == 0)
!     return malloc (n);
    p--;
    nunits = p->mh_index;
!   ASSERT (p->mh_alloc == ISALLOC);
    ASSERT (p->mh_magic2 == MAGIC2);
  
    m = (char *)mem + (tocopy = p->mh_nbytes);
--- 816,846 ----
    if (n == 0)
      {
!       internal_free (mem, file, line, MALLOC_INTERNAL);
        return (NULL);
      }
    if ((p = (union mhead *) mem) == 0)
!     return internal_malloc (n, file, line, MALLOC_INTERNAL);
! 
    p--;
    nunits = p->mh_index;
!   ASSERT (nunits < NBUCKETS);
! 
!   if (p->mh_alloc != ISALLOC)
!     xbotch (mem, ERR_UNALLOC,
! 	    "realloc: called with unallocated block argument", file, line);
! 
    ASSERT (p->mh_magic2 == MAGIC2);
+   nbytes = ALLOCATED_BYTES(p->mh_nbytes);
+   /* Since the sizeof(u_bits32_t) bytes before the memory handed to the user
+      are now used for the number of bytes allocated, a simple check of
+      mh_magic2 is no longer sufficient to catch things like p[-1] = 'x'.
+      We sanity-check the value of mh_nbytes against the size of the blocks
+      in the appropriate bucket before we use it.  This can still cause problems
+      and obscure errors if mh_nbytes is wrong but still within range; the
+      checks against MAGIC1 will probably fail then.  Using MALLOC_REGISTER
+      will help here, since it saves the original number of bytes requested. */
+   if (IN_BUCKET(nbytes, nunits) == 0)
+     xbotch (mem, ERR_UNDERFLOW,
+ 	    "realloc: underflow detected; mh_nbytes out of range", file, line);
  
    m = (char *)mem + (tocopy = p->mh_nbytes);
***************
*** 781,788 ****
  
    /* See if desired size rounds to same power of 2 as actual size. */
!   nbytes = (n + sizeof *p + MSLOP + 7) & ~7;
  
    /* If ok, use the same block, just marking its size as changed.  */
!   if (nbytes > (4 << nunits) && nbytes <= (8 << nunits))
      {
        m = (char *)mem + tocopy;
--- 849,856 ----
  
    /* See if desired size rounds to same power of 2 as actual size. */
!   nbytes = ALLOCATED_BYTES(n);
  
    /* If ok, use the same block, just marking its size as changed.  */
!   if (IN_BUCKET(nbytes, nunits))
      {
        m = (char *)mem + tocopy;
***************
*** 801,815 ****
      tocopy = n;
  
!   if ((m = malloc (n)) == 0)
      return 0;
    FASTCOPY (mem, m, tocopy);
!   free (mem);
    return m;
  }
  
! PTR_T
! memalign (alignment, size)
       unsigned int alignment;
       size_t size;
  {
    register char *ptr;
--- 869,896 ----
      tocopy = n;
  
!   if ((m = internal_malloc (n, file, line, MALLOC_INTERNAL|MALLOC_NOTRACE|MALLOC_NOREG)) == 0)
      return 0;
    FASTCOPY (mem, m, tocopy);
!   internal_free (mem, file, line, MALLOC_INTERNAL);
! 
! #ifdef MALLOC_TRACE
!   if (malloc_trace && (flags & MALLOC_NOTRACE) == 0)
!     mtrace_alloc ("realloc", m, n, file, line);
! #endif
! 
! #ifdef MALLOC_REGISTER
!   if (malloc_register && (flags & MALLOC_NOREG) == 0)
!     mregister_alloc ("realloc", m, n, file, line);
! #endif
! 
    return m;
  }
  
! static PTR_T
! internal_memalign (alignment, size, file, line, flags)
       unsigned int alignment;
       size_t size;
+      const char *file;
+      int line, flags;
  {
    register char *ptr;
***************
*** 817,829 ****
    register union mhead *p;
  
!   ptr = malloc (size + alignment);
  
    if (ptr == 0)
      return 0;
    /* If entire block has the desired alignment, just accept it.  */
!   if (((int) ptr & (alignment - 1)) == 0)
      return ptr;
    /* Otherwise, get address of byte in the block that has that alignment.  */
!   aligned = (char *) (((int) ptr + alignment - 1) & -alignment);
  
    /* Store a suitable indication of how to free the block,
--- 898,914 ----
    register union mhead *p;
  
!   ptr = internal_malloc (size + alignment, file, line, MALLOC_INTERNAL);
  
    if (ptr == 0)
      return 0;
    /* If entire block has the desired alignment, just accept it.  */
!   if (((long) ptr & (alignment - 1)) == 0)
      return ptr;
    /* Otherwise, get address of byte in the block that has that alignment.  */
! #if 0
!   aligned = (char *) (((long) ptr + alignment - 1) & -alignment);
! #else
!   aligned = (char *) (((long) ptr + alignment - 1) & (~alignment + 1));
! #endif
  
    /* Store a suitable indication of how to free the block,
***************
*** 832,859 ****
    p->mh_nbytes = aligned - ptr;
    p->mh_alloc = ISMEMALIGN;
    return aligned;
  }
  
! #if !defined (HPUX)
  /* This runs into trouble with getpagesize on HPUX, and Multimax machines.
     Patching out seems cleaner than the ugly fix needed.  */
! PTR_T
! valloc (size)
       size_t size;
  {
!   return memalign (getpagesize (), size);
  }
! #endif /* !HPUX */
  
  #ifndef NO_CALLOC
! PTR_T
! calloc (n, s)
       size_t n, s;
  {
    size_t total;
!   char *result;
  
    total = n * s;
!   result = malloc (total);
    if (result)
      zmemset (result, 0, total);
--- 917,949 ----
    p->mh_nbytes = aligned - ptr;
    p->mh_alloc = ISMEMALIGN;
+ 
    return aligned;
  }
  
! #if !defined (NO_VALLOC)
  /* This runs into trouble with getpagesize on HPUX, and Multimax machines.
     Patching out seems cleaner than the ugly fix needed.  */
! static PTR_T
! internal_valloc (size, file, line, flags)
       size_t size;
+      const char *file;
+      int line, flags;
  {
!   return internal_memalign (getpagesize (), size, file, line, flags|MALLOC_INTERNAL);
  }
! #endif /* !NO_VALLOC */
  
  #ifndef NO_CALLOC
! static PTR_T
! internal_calloc (n, s, file, line, flags)
       size_t n, s;
+      const char *file;
+      int line, flags;
  {
    size_t total;
!   PTR_T result;
  
    total = n * s;
!   result = internal_malloc (total, file, line, flags|MALLOC_INTERNAL);
    if (result)
      zmemset (result, 0, total);
***************
*** 861,869 ****
  }
  
! void
! cfree (p)
       PTR_T p;
  {
!   free (p);
  }
  #endif /* !NO_CALLOC */
--- 951,961 ----
  }
  
! static void
! internal_cfree (p, file, line, flags)
       PTR_T p;
+      const char *file;
+      int line, flags;
  {
!   internal_free (p, file, line, flags|MALLOC_INTERNAL);
  }
  #endif /* !NO_CALLOC */
***************
*** 871,981 ****
  #ifdef MALLOC_STATS
  
! struct bucket_stats
! malloc_bucket_stats (size)
       int size;
  {
!   struct bucket_stats v;
    register union mhead *p;
  
!   v.nfree = 0;
  
!   if (size < 0 || size >= NBUCKETS)
!     {
!       v.blocksize = 0;
!       v.nused = v.nmal = v.nmorecore = v.nsplit = 0;
!       return v;
!     }
  
!   v.blocksize = 1 << (size + 3);
!   v.nused = _mstats.nmalloc[size];
!   v.nmal = _mstats.tmalloc[size];
!   v.nmorecore = _mstats.nmorecore[size];
!   v.nsplit = _mstats.nsplit[size];
  
!   for (p = nextf[size]; p; p = CHAIN (p))
!     v.nfree++;
  
!   return v;
  }
  
! /* Return a copy of _MSTATS, with two additional fields filled in:
!    BYTESFREE is the total number of bytes on free lists.  BYTESUSED
!    is the total number of bytes in use.  These two fields are fairly
!    expensive to compute, so we do it only when asked to. */
! struct _malstats
! malloc_stats ()
  {
!   struct _malstats result;
!   struct bucket_stats v;
!   register int i;
  
!   result = _mstats;
!   result.bytesused = result.bytesfree = 0;
!   for (i = 0; i < NBUCKETS; i++)
!     {
!       v = malloc_bucket_stats (i);
!       result.bytesfree += v.nfree * v.blocksize;
!       result.bytesused += v.nused * v.blocksize;
!     }
!   return (result);
  }
  
! static void
! _print_malloc_stats (s, fp)
!      char *s;
!      FILE *fp;
  {
!   register int i;
!   int totused, totfree;
!   struct bucket_stats v;
! 
!   fprintf (fp, "Memory allocation statistics: %s\n\tsize\tfree\tin use\ttotal\tmorecore\tsplit\n", s ? s : "");
!   for (i = totused = totfree = 0; i < NBUCKETS; i++)
!     {
!       v = malloc_bucket_stats (i);
!       fprintf (fp, "%12lu\t%4d\t%6d\t%5d\t%8d\t%5d\n", v.blocksize, v.nfree, v.nused, v.nmal, v.nmorecore, v.nsplit);
!       totfree += v.nfree * v.blocksize;
!       totused += v.nused * v.blocksize;
!     }
!   fprintf (fp, "\nTotal bytes in use: %d, total bytes free: %d\n",
! 	   totused, totfree);
!   fprintf (fp, "Total mallocs: %d, total frees: %d, total reallocs: %d (%d copies)\n",
! 	   _mstats.nmal, _mstats.nfre, _mstats.nrealloc, _mstats.nrcopy);
!   fprintf (fp, "Total sbrks: %d, total bytes via sbrk: %d\n",
!   	   _mstats.nsbrk, _mstats.tsbrk);
!   fprintf (fp, "Total blocks split: %d, total block coalesces: %d\n",
!   	   _mstats.tbsplit, _mstats.tbcoalesce);
  }
  
  void
! print_malloc_stats (s)
!      char *s;
  {
!   _print_malloc_stats (s, stderr);
  }
  
! #define TRACEROOT "/var/tmp/maltrace/trace."
! extern char *inttostr ();
  
  void
! trace_malloc_stats (s)
!      char *s;
  {
!   char ibuf[32], *ip;
!   char fname[64];
!   int p;
!   FILE *fp;
! 
!   p = (int)getpid();
!   ip = inttostr(p, ibuf, sizeof(ibuf));
!   strcpy (fname, TRACEROOT);
!   strcat (fname, ip);
!   fp = fopen(fname, "w");
!   if (fp)
!     {
!       _print_malloc_stats (s, fp);
!       fflush(fp);
!       fclose(fp);
!     }
  }
! #endif /* MALLOC_STATS */
--- 963,1107 ----
  #ifdef MALLOC_STATS
  
! int
! malloc_free_blocks (size)
       int size;
  {
!   int nfree;
    register union mhead *p;
  
!   nfree = 0;
!   for (p = nextf[size]; p; p = CHAIN (p))
!     nfree++;
  
!   return nfree;
! }
! #endif
  
! #if defined (SHELL)
! PTR_T
! sh_malloc (bytes, file, line)
!      size_t bytes;
!      const char *file;
!      int line;
! {
!   return internal_malloc (bytes, file, line, MALLOC_WRAPPER);
! }
  
! PTR_T
! sh_realloc (ptr, size, file, line)
!      PTR_T ptr;
!      size_t size;
!      const char *file;
!      int line;
! {
!   return internal_realloc (ptr, size, file, line, MALLOC_WRAPPER);
! }
  
! void
! sh_free (mem, file, line)
!      PTR_T mem;
!      const char *file;
!      int line;
! {
!   internal_free (mem, file, line, MALLOC_WRAPPER);
  }
  
! PTR_T
! sh_memalign (alignment, size, file, line)
!      unsigned int alignment;
!      size_t size;
!      const char *file;
!      int line;
  {
!   return internal_memalign (alignment, size, file, line, MALLOC_WRAPPER);
! }
  
! #ifndef NO_CALLOC
! PTR_T
! sh_calloc (n, s, file, line)
!      size_t n, s;
!      const char *file;
!      int line;
! {
!   return internal_calloc (n, s, file, line, MALLOC_WRAPPER);
  }
  
! void
! sh_cfree (mem, file, line)
!      PTR_T mem;
!      const char *file;
!      int line;
  {
!   internal_cfree (mem, file, line, MALLOC_WRAPPER);
! }
! #endif
! 
! #ifndef NO_VALLOC
! PTR_T
! sh_valloc (size, file, line)
!      size_t size;
!      const char *file;
!      int line;
! {
!   return internal_valloc (size, file, line, MALLOC_WRAPPER);
! }
! #endif
! 
! #endif
! 
! /* Externally-available functions that call their internal counterparts. */
! 
! PTR_T
! malloc (size)
!      size_t size;
! {
!   return internal_malloc (size, (char *)NULL, 0, 0);
! }
! 
! PTR_T
! realloc (mem, nbytes)
!      PTR_T mem;
!      size_t nbytes;
! {
!   return internal_realloc (mem, nbytes, (char *)NULL, 0, 0);
  }
  
  void
! free (mem)
!      PTR_T mem;
! {
!   internal_free (mem,  (char *)NULL, 0, 0);
! }
! 
! PTR_T
! memalign (alignment, size)
!      unsigned int alignment;
!      size_t size;
! {
!   return internal_memalign (alignment, size, (char *)NULL, 0, 0);
! }
! 
! #ifndef NO_VALLOC
! PTR_T
! valloc (size)
!      size_t size;
  {
!   return internal_valloc (size, (char *)NULL, 0, 0);
  }
+ #endif
  
! #ifndef NO_CALLOC
! PTR_T
! calloc (n, s)
!      size_t n, s;
! {
!   return internal_calloc (n, s, (char *)NULL, 0, 0);
! }
  
  void
! cfree (mem)
!      PTR_T mem;
  {
!   internal_cfree (mem, (char *)NULL, 0, 0);
  }
! #endif
diff -Nrc2 bash-2.05/lib/malloc/mstats.h bash-2.05a/lib/malloc/mstats.h
*** bash-2.05/lib/malloc/mstats.h	Wed Dec 31 19:00:00 1969
--- bash-2.05a/lib/malloc/mstats.h	Thu Sep  6 10:28:19 2001
***************
*** 0 ****
--- 1,90 ----
+ /* mstats.h - definitions for malloc statistics */
+ 
+ /*  Copyright (C) 2001 Free Software Foundation, Inc.
+ 
+     This program is free software; you can redistribute it and/or modify
+     it under the terms of the GNU General Public License as published by
+     the Free Software Foundation; either version 2, or (at your option)
+     any later version.
+ 
+     This program is distributed in the hope that it will be useful,
+     but WITHOUT ANY WARRANTY; without even the implied warranty of
+     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+     GNU General Public License for more details.
+ 
+     You should have received a copy of the GNU General Public License
+     along with this program; if not, write to the Free Software
+     Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111 USA. */
+ 
+ #ifndef _MSTATS_H
+ #define _MSTATS_H
+ 
+ #include "imalloc.h"
+ 
+ #ifdef MALLOC_STATS
+ 
+ #ifndef NBUCKETS
+ #  define NBUCKETS 30
+ #endif
+ 
+ /*
+  * NMALLOC[i] is the difference between the number of mallocs and frees
+  * for a given block size.  TMALLOC[i] is the total number of mallocs for
+  * a given block size.  NMORECORE[i] is the total number of calls to
+  * morecore(i).  NMAL and NFRE are counts of the number of calls to malloc()
+  * and free(), respectively.  NREALLOC is the total number of calls to
+  * realloc(); NRCOPY is the number of times realloc() had to allocate new
+  * memory and copy to it.  NRECURSE is a count of the number of recursive
+  * calls to malloc() for the same bucket size, which can be caused by calls
+  * to malloc() from a signal handler.  NSBRK is the number of calls to sbrk()
+  * (whether by morecore() or for alignment); TSBRK is the total number of
+  * bytes requested from the kernel with sbrk().  BYTESUSED is the total
+  * number of bytes consumed by blocks currently in use; BYTESFREE is the
+  * total number of bytes currently on all of the free lists.  TBSPLIT is
+  * the number of times a larger block was split to satisfy a smaller request.
+  * NSPLIT[i] is the number of times a block of size I was split.
+  * TBCOALESCE is the number of times two adjacent smaller blocks off the free
+  * list were combined to satisfy a larger request.
+  */
+ struct _malstats {
+   int nmalloc[NBUCKETS];
+   int tmalloc[NBUCKETS];
+   int nmorecore[NBUCKETS];
+   int nmal;
+   int nfre;
+   int nrealloc;
+   int nrcopy;
+   int nrecurse;
+   int nsbrk;
+   bits32_t tsbrk;
+   bits32_t bytesused;
+   bits32_t bytesfree;
+   int tbsplit;
+   int nsplit[NBUCKETS];
+   int tbcoalesce;
+ };
+ 
+ /* Return statistics describing allocation of blocks of size BLOCKSIZE.
+    NFREE is the number of free blocks for this allocation size.  NUSED
+    is the number of blocks in use.  NMAL is the number of requests for
+    blocks of size BLOCKSIZE.  NMORECORE is the number of times we had
+    to call MORECORE to repopulate the free list for this bucket.  NSPLIT
+    is the number of times a block of this size was split to satisfy a
+    smaller request. */
+ struct bucket_stats {
+   u_bits32_t blocksize;
+   int nfree;
+   int nused;
+   int nmal;
+   int nmorecore;
+   int nsplit;
+ };
+ 
+ extern struct bucket_stats malloc_bucket_stats ();
+ extern struct _malstats malloc_stats ();
+ extern void print_malloc_stats ();
+ extern void trace_malloc_stats ();
+ 
+ #endif /* MALLOC_STATS */
+ 
+ #endif /* _MSTATS_H */
diff -Nrc2 bash-2.05/lib/malloc/ogmalloc.c bash-2.05a/lib/malloc/ogmalloc.c
*** bash-2.05/lib/malloc/ogmalloc.c	Thu Aug  5 08:40:32 1999
--- bash-2.05a/lib/malloc/ogmalloc.c	Wed Dec 31 19:00:00 1969
***************
*** 1,1579 ****
- /* DO NOT EDIT THIS FILE -- it is automagically generated.  -*- C -*- */
- 
- #define _MALLOC_INTERNAL
- 
- /* The malloc headers and source files from the C library follow here.  */
- 
- /* Declarations for `malloc' and friends.
-    Copyright 1990, 91, 92, 93, 95, 96 Free Software Foundation, Inc.
- 		  Written May 1989 by Mike Haertel.
- 
- This library is free software; you can redistribute it and/or
- modify it under the terms of the GNU Library General Public License as
- published by the Free Software Foundation; either version 2 of the
- License, or (at your option) any later version.
- 
- This library is distributed in the hope that it will be useful,
- but WITHOUT ANY WARRANTY; without even the implied warranty of
- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- Library General Public License for more details.
- 
- You should have received a copy of the GNU Library General Public
- License along with this library; see the file COPYING.LIB.  If
- not, write to the Free Software Foundation, Inc.,
- 59 Temple Place, Suite 330, Boston, MA 02111 USA.
- 
-    The author may be reached (Email) at the address mike@ai.mit.edu,
-    or (US mail) as Mike Haertel c/o Free Software Foundation.  */
- 
- #ifndef _MALLOC_H
- 
- #define _MALLOC_H	1
- 
- #ifdef _MALLOC_INTERNAL
- 
- #ifdef	HAVE_CONFIG_H
- #include <config.h>
- #endif
- 
- #if	defined(_LIBC) || defined(STDC_HEADERS) || defined(USG)
- #include <string.h>
- #else
- #ifndef memset
- #define	memset(s, zero, n)	bzero ((s), (n))
- #endif
- #ifndef memcpy
- #define	memcpy(d, s, n)		bcopy ((s), (d), (n))
- #endif
- #endif
- 
- #if	defined (__GNU_LIBRARY__) || (defined (__STDC__) && __STDC__)
- #include <limits.h>
- #else
- #ifndef CHAR_BIT
- #define	CHAR_BIT	8
- #endif
- #endif
- 
- #ifdef	HAVE_UNISTD_H
- #include <unistd.h>
- #endif
- 
- #endif	/* _MALLOC_INTERNAL.  */
- 
- 
- #ifdef	__cplusplus
- extern "C"
- {
- #endif
- 
- #if defined (__cplusplus) || (defined (__STDC__) && __STDC__)
- #undef	__P
- #define	__P(args)	args
- #undef	__ptr_t
- #define	__ptr_t		void *
- #else /* Not C++ or ANSI C.  */
- #undef	__P
- #define	__P(args)	()
- #undef	const
- #define	const
- #undef	__ptr_t
- #define	__ptr_t		char *
- #endif /* C++ or ANSI C.  */
- 
- #if defined (__STDC__) && __STDC__
- #include <stddef.h>
- #define	__malloc_size_t		size_t
- #define	__malloc_ptrdiff_t	ptrdiff_t
- #else
- #define	__malloc_size_t		unsigned int
- #define	__malloc_ptrdiff_t	int
- #endif
- 
- #ifndef	NULL
- #define	NULL	0
- #endif
- 
- 
- /* Allocate SIZE bytes of memory.  */
- extern __ptr_t malloc __P ((__malloc_size_t __size));
- /* Re-allocate the previously allocated block
-    in __ptr_t, making the new block SIZE bytes long.  */
- extern __ptr_t realloc __P ((__ptr_t __ptr, __malloc_size_t __size));
- /* Allocate NMEMB elements of SIZE bytes each, all initialized to 0.  */
- extern __ptr_t calloc __P ((__malloc_size_t __nmemb, __malloc_size_t __size));
- /* Free a block allocated by `malloc', `realloc' or `calloc'.  */
- extern void free __P ((__ptr_t __ptr));
- 
- /* Allocate SIZE bytes allocated to ALIGNMENT bytes.  */
- #if ! (defined (_MALLOC_INTERNAL) && __DJGPP__ - 0 == 1) /* Avoid conflict.  */
- extern __ptr_t memalign __P ((__malloc_size_t __alignment,
- 			      __malloc_size_t __size));
- #endif
- 
- /* Allocate SIZE bytes on a page boundary.  */
- #if ! (defined (_MALLOC_INTERNAL) && defined (emacs)) /* Avoid conflict.  */
- extern __ptr_t valloc __P ((__malloc_size_t __size));
- #endif
- 
- 
- #ifdef _MALLOC_INTERNAL
- 
- /* The allocator divides the heap into blocks of fixed size; large
-    requests receive one or more whole blocks, and small requests
-    receive a fragment of a block.  Fragment sizes are powers of two,
-    and all fragments of a block are the same size.  When all the
-    fragments in a block have been freed, the block itself is freed.  */
- #define INT_BIT		(CHAR_BIT * sizeof(int))
- #define BLOCKLOG	(INT_BIT > 16 ? 12 : 9)
- #define BLOCKSIZE	(1 << BLOCKLOG)
- #define BLOCKIFY(SIZE)	(((SIZE) + BLOCKSIZE - 1) / BLOCKSIZE)
- 
- /* Determine the amount of memory spanned by the initial heap table
-    (not an absolute limit).  */
- #define HEAP		(INT_BIT > 16 ? 4194304 : 65536)
- 
- /* Number of contiguous free blocks allowed to build up at the end of
-    memory before they will be returned to the system.  */
- #define FINAL_FREE_BLOCKS	8
- 
- /* Data structure giving per-block information.  */
- typedef union
-   {
-     /* Heap information for a busy block.  */
-     struct
-       {
- 	/* Zero for a large (multiblock) object, or positive giving the
- 	   logarithm to the base two of the fragment size.  */
- 	int type;
- 	union
- 	  {
- 	    struct
- 	      {
- 		__malloc_size_t nfree; /* Free frags in a fragmented block.  */
- 		__malloc_size_t first; /* First free fragment of the block.  */
- 	      } frag;
- 	    /* For a large object, in its first block, this has the number
- 	       of blocks in the object.  In the other blocks, this has a
- 	       negative number which says how far back the first block is.  */
- 	    __malloc_ptrdiff_t size;
- 	  } info;
-       } busy;
-     /* Heap information for a free block
-        (that may be the first of a free cluster).  */
-     struct
-       {
- 	__malloc_size_t size;	/* Size (in blocks) of a free cluster.  */
- 	__malloc_size_t next;	/* Index of next free cluster.  */
- 	__malloc_size_t prev;	/* Index of previous free cluster.  */
-       } free;
-   } malloc_info;
- 
- /* Pointer to first block of the heap.  */
- extern char *_heapbase;
- 
- /* Table indexed by block number giving per-block information.  */
- extern malloc_info *_heapinfo;
- 
- /* Address to block number and vice versa.  */
- #define BLOCK(A)	(((char *) (A) - _heapbase) / BLOCKSIZE + 1)
- #define ADDRESS(B)	((__ptr_t) (((B) - 1) * BLOCKSIZE + _heapbase))
- 
- /* Current search index for the heap table.  */
- extern __malloc_size_t _heapindex;
- 
- /* Limit of valid info table indices.  */
- extern __malloc_size_t _heaplimit;
- 
- /* Doubly linked lists of free fragments.  */
- struct list
-   {
-     struct list *next;
-     struct list *prev;
-   };
- 
- /* Free list headers for each fragment size.  */
- extern struct list _fraghead[];
- 
- /* List of blocks allocated with `memalign' (or `valloc').  */
- struct alignlist
-   {
-     struct alignlist *next;
-     __ptr_t aligned;		/* The address that memaligned returned.  */
-     __ptr_t exact;		/* The address that malloc returned.  */
-   };
- extern struct alignlist *_aligned_blocks;
- 
- /* Instrumentation.  */
- extern __malloc_size_t _chunks_used;
- extern __malloc_size_t _bytes_used;
- extern __malloc_size_t _chunks_free;
- extern __malloc_size_t _bytes_free;
- 
- /* Internal versions of `malloc', `realloc', and `free'
-    used when these functions need to call each other.
-    They are the same but don't call the hooks.  */
- extern __ptr_t _malloc_internal __P ((__malloc_size_t __size));
- extern __ptr_t _realloc_internal __P ((__ptr_t __ptr, __malloc_size_t __size));
- extern void _free_internal __P ((__ptr_t __ptr));
- 
- #endif /* _MALLOC_INTERNAL.  */
- 
- /* Given an address in the middle of a malloc'd object,
-    return the address of the beginning of the object.  */
- extern __ptr_t malloc_find_object_address __P ((__ptr_t __ptr));
- 
- /* Underlying allocation function; successive calls should
-    return contiguous pieces of memory.  */
- extern __ptr_t (*__morecore) __P ((__malloc_ptrdiff_t __size));
- 
- /* Default value of `__morecore'.  */
- extern __ptr_t __default_morecore __P ((__malloc_ptrdiff_t __size));
- 
- /* If not NULL, this function is called after each time
-    `__morecore' is called to increase the data size.  */
- extern void (*__after_morecore_hook) __P ((void));
- 
- /* Number of extra blocks to get each time we ask for more core.
-    This reduces the frequency of calling `(*__morecore)'.  */
- extern __malloc_size_t __malloc_extra_blocks;
- 
- /* Nonzero if `malloc' has been called and done its initialization.  */
- extern int __malloc_initialized;
- /* Function called to initialize malloc data structures.  */
- extern int __malloc_initialize __P ((void));
- 
- /* Hooks for debugging versions.  */
- extern void (*__malloc_initialize_hook) __P ((void));
- extern void (*__free_hook) __P ((__ptr_t __ptr));
- extern __ptr_t (*__malloc_hook) __P ((__malloc_size_t __size));
- extern __ptr_t (*__realloc_hook) __P ((__ptr_t __ptr, __malloc_size_t __size));
- extern __ptr_t (*__memalign_hook) __P ((__malloc_size_t __size,
- 					__malloc_size_t __alignment));
- 
- /* Return values for `mprobe': these are the kinds of inconsistencies that
-    `mcheck' enables detection of.  */
- enum mcheck_status
-   {
-     MCHECK_DISABLED = -1,	/* Consistency checking is not turned on.  */
-     MCHECK_OK,			/* Block is fine.  */
-     MCHECK_FREE,		/* Block freed twice.  */
-     MCHECK_HEAD,		/* Memory before the block was clobbered.  */
-     MCHECK_TAIL			/* Memory after the block was clobbered.  */
-   };
- 
- /* Activate a standard collection of debugging hooks.  This must be called
-    before `malloc' is ever called.  ABORTFUNC is called with an error code
-    (see enum above) when an inconsistency is detected.  If ABORTFUNC is
-    null, the standard function prints on stderr and then calls `abort'.  */
- extern int mcheck __P ((void (*__abortfunc) __P ((enum mcheck_status))));
- 
- /* Check for aberrations in a particular malloc'd block.  You must have
-    called `mcheck' already.  These are the same checks that `mcheck' does
-    when you free or reallocate a block.  */
- extern enum mcheck_status mprobe __P ((__ptr_t __ptr));
- 
- /* Activate a standard collection of tracing hooks.  */
- extern void mtrace __P ((void));
- extern void muntrace __P ((void));
- 
- /* Statistics available to the user.  */
- struct mstats
-   {
-     __malloc_size_t bytes_total; /* Total size of the heap. */
-     __malloc_size_t chunks_used; /* Chunks allocated by the user. */
-     __malloc_size_t bytes_used;	/* Byte total of user-allocated chunks. */
-     __malloc_size_t chunks_free; /* Chunks in the free list. */
-     __malloc_size_t bytes_free;	/* Byte total of chunks in the free list. */
-   };
- 
- /* Pick up the current statistics. */
- extern struct mstats mstats __P ((void));
- 
- /* Call WARNFUN with a warning message when memory usage is high.  */
- extern void memory_warnings __P ((__ptr_t __start,
- 				  void (*__warnfun) __P ((const char *))));
- 
- 
- /* Relocating allocator.  */
- 
- /* Allocate SIZE bytes, and store the address in *HANDLEPTR.  */
- extern __ptr_t r_alloc __P ((__ptr_t *__handleptr, __malloc_size_t __size));
- 
- /* Free the storage allocated in HANDLEPTR.  */
- extern void r_alloc_free __P ((__ptr_t *__handleptr));
- 
- /* Adjust the block at HANDLEPTR to be SIZE bytes long.  */
- extern __ptr_t r_re_alloc __P ((__ptr_t *__handleptr, __malloc_size_t __size));
- 
- 
- #ifdef	__cplusplus
- }
- #endif
- 
- #endif /* malloc.h  */
- /* Memory allocator `malloc'.
-    Copyright 1990, 1991, 1992, 1993, 1994, 1995 Free Software Foundation, Inc.
- 		  Written May 1989 by Mike Haertel.
- 
- This library is free software; you can redistribute it and/or
- modify it under the terms of the GNU Library General Public License as
- published by the Free Software Foundation; either version 2 of the
- License, or (at your option) any later version.
- 
- This library is distributed in the hope that it will be useful,
- but WITHOUT ANY WARRANTY; without even the implied warranty of
- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- Library General Public License for more details.
- 
- You should have received a copy of the GNU Library General Public
- License along with this library; see the file COPYING.LIB.  If
- not, write to the Free Software Foundation, Inc.,
- 59 Temple Place, Suite 330, Boston, MA 02111 USA.
- 
-    The author may be reached (Email) at the address mike@ai.mit.edu,
-    or (US mail) as Mike Haertel c/o Free Software Foundation.  */
- 
- #ifndef	_MALLOC_INTERNAL
- #define _MALLOC_INTERNAL
- #include <malloc.h>
- #endif
- #include <errno.h>
- 
- /* How to really get more memory.  */
- __ptr_t (*__morecore) __P ((ptrdiff_t __size)) = __default_morecore;
- 
- /* Debugging hook for `malloc'.  */
- __ptr_t (*__malloc_hook) __P ((__malloc_size_t __size));
- 
- /* Pointer to the base of the first block.  */
- char *_heapbase;
- 
- /* Block information table.  Allocated with align/__free (not malloc/free).  */
- malloc_info *_heapinfo;
- 
- /* Number of info entries.  */
- static __malloc_size_t heapsize;
- 
- /* Search index in the info table.  */
- __malloc_size_t _heapindex;
- 
- /* Limit of valid info table indices.  */
- __malloc_size_t _heaplimit;
- 
- /* Free lists for each fragment size.  */
- struct list _fraghead[BLOCKLOG];
- 
- /* Instrumentation.  */
- __malloc_size_t _chunks_used;
- __malloc_size_t _bytes_used;
- __malloc_size_t _chunks_free;
- __malloc_size_t _bytes_free;
- 
- /* Are you experienced?  */
- int __malloc_initialized;
- 
- __malloc_size_t __malloc_extra_blocks;
- 
- void (*__malloc_initialize_hook) __P ((void));
- void (*__after_morecore_hook) __P ((void));
- 
- 
- /* Aligned allocation.  */
- static __ptr_t align __P ((__malloc_size_t));
- static __ptr_t
- align (size)
-      __malloc_size_t size;
- {
-   __ptr_t result;
-   unsigned long int adj;
- 
-   result = (*__morecore) (size);
-   adj = (unsigned long int) ((unsigned long int) ((char *) result -
- 						  (char *) NULL)) % BLOCKSIZE;
-   if (adj != 0)
-     {
-       __ptr_t new;
-       adj = BLOCKSIZE - adj;
-       new = (*__morecore) (adj);
-       result = (char *) result + adj;
-     }
- 
-   if (__after_morecore_hook)
-     (*__after_morecore_hook) ();
- 
-   return result;
- }
- 
- /* Get SIZE bytes, if we can get them starting at END.
-    Return the address of the space we got.
-    If we cannot get space at END, fail and return -1.  */
- static __ptr_t get_contiguous_space __P ((__malloc_ptrdiff_t, __ptr_t));
- static __ptr_t
- get_contiguous_space (size, position)
-      __malloc_ptrdiff_t size;
-      __ptr_t position;
- {
-   __ptr_t before;
-   __ptr_t after;
- 
-   before = (*__morecore) (0);
-   /* If we can tell in advance that the break is at the wrong place,
-      fail now.  */
-   if (before != position)
-     return 0;
- 
-   /* Allocate SIZE bytes and get the address of them.  */
-   after = (*__morecore) (size);
-   if (!after)
-     return 0;
- 
-   /* It was not contiguous--reject it.  */
-   if (after != position)
-     {
-       (*__morecore) (- size);
-       return 0;
-     }
- 
-   return after;
- }
- 
- 
- /* This is called when `_heapinfo' and `heapsize' have just
-    been set to describe a new info table.  Set up the table
-    to describe itself and account for it in the statistics.  */
- static void register_heapinfo __P ((void));
- #ifdef __GNUC__
- __inline__
- #endif
- static void
- register_heapinfo ()
- {
-   __malloc_size_t block, blocks;
- 
-   block = BLOCK (_heapinfo);
-   blocks = BLOCKIFY (heapsize * sizeof (malloc_info));
- 
-   /* Account for the _heapinfo block itself in the statistics.  */
-   _bytes_used += blocks * BLOCKSIZE;
-   ++_chunks_used;
- 
-   /* Describe the heapinfo block itself in the heapinfo.  */
-   _heapinfo[block].busy.type = 0;
-   _heapinfo[block].busy.info.size = blocks;
-   /* Leave back-pointers for malloc_find_address.  */
-   while (--blocks > 0)
-     _heapinfo[block + blocks].busy.info.size = -blocks;
- }
- 
- /* Set everything up and remember that we have.  */
- int
- __malloc_initialize ()
- {
-   if (__malloc_initialized)
-     return 0;
- 
-   if (__malloc_initialize_hook)
-     (*__malloc_initialize_hook) ();
- 
-   heapsize = HEAP / BLOCKSIZE;
-   _heapinfo = (malloc_info *) align (heapsize * sizeof (malloc_info));
-   if (_heapinfo == NULL)
-     return 0;
-   memset (_heapinfo, 0, heapsize * sizeof (malloc_info));
-   _heapinfo[0].free.size = 0;
-   _heapinfo[0].free.next = _heapinfo[0].free.prev = 0;
-   _heapindex = 0;
-   _heapbase = (char *) _heapinfo;
-   _heaplimit = BLOCK (_heapbase + heapsize * sizeof (malloc_info));
- 
-   register_heapinfo ();
- 
-   __malloc_initialized = 1;
-   return 1;
- }
- 
- static int morecore_recursing;
- 
- /* Get neatly aligned memory, initializing or
-    growing the heap info table as necessary. */
- static __ptr_t morecore __P ((__malloc_size_t));
- static __ptr_t
- morecore (size)
-      __malloc_size_t size;
- {
-   __ptr_t result;
-   malloc_info *newinfo, *oldinfo;
-   __malloc_size_t newsize;
- 
-   if (morecore_recursing)
-     /* Avoid recursion.  The caller will know how to handle a null return.  */
-     return NULL;
- 
-   result = align (size);
-   if (result == NULL)
-     return NULL;
- 
-   /* Check if we need to grow the info table.  */
-   if ((__malloc_size_t) BLOCK ((char *) result + size) > heapsize)
-     {
-       /* Calculate the new _heapinfo table size.  We do not account for the
- 	 added blocks in the table itself, as we hope to place them in
- 	 existing free space, which is already covered by part of the
- 	 existing table.  */
-       newsize = heapsize;
-       do
- 	newsize *= 2;
-       while ((__malloc_size_t) BLOCK ((char *) result + size) > newsize);
- 
-       /* We must not reuse existing core for the new info table when called
- 	 from realloc in the case of growing a large block, because the
- 	 block being grown is momentarily marked as free.  In this case
- 	 _heaplimit is zero so we know not to reuse space for internal
- 	 allocation.  */
-       if (_heaplimit != 0)
- 	{
- 	  /* First try to allocate the new info table in core we already
- 	     have, in the usual way using realloc.  If realloc cannot
- 	     extend it in place or relocate it to existing sufficient core,
- 	     we will get called again, and the code above will notice the
- 	     `morecore_recursing' flag and return null.  */
- 	  int save = errno;	/* Don't want to clobber errno with ENOMEM.  */
- 	  morecore_recursing = 1;
- 	  newinfo = (malloc_info *) _realloc_internal
- 	    (_heapinfo, newsize * sizeof (malloc_info));
- 	  morecore_recursing = 0;
- 	  if (newinfo == NULL)
- 	    errno = save;
- 	  else
- 	    {
- 	      /* We found some space in core, and realloc has put the old
- 		 table's blocks on the free list.  Now zero the new part
- 		 of the table and install the new table location.  */
- 	      memset (&newinfo[heapsize], 0,
- 		      (newsize - heapsize) * sizeof (malloc_info));
- 	      _heapinfo = newinfo;
- 	      heapsize = newsize;
- 	      goto got_heap;
- 	    }
- 	}
- 
-       /* Allocate new space for the malloc info table.  */
-       while (1)
-   	{
-  	  newinfo = (malloc_info *) align (newsize * sizeof (malloc_info));
- 
-  	  /* Did it fail?  */
-  	  if (newinfo == NULL)
-  	    {
-  	      (*__morecore) (-size);
-  	      return NULL;
-  	    }
- 
-  	  /* Is it big enough to record status for its own space?
-  	     If so, we win.  */
-  	  if ((__malloc_size_t) BLOCK ((char *) newinfo
-  				       + newsize * sizeof (malloc_info))
-  	      < newsize)
-  	    break;
- 
-  	  /* Must try again.  First give back most of what we just got.  */
-  	  (*__morecore) (- newsize * sizeof (malloc_info));
-  	  newsize *= 2;
-   	}
- 
-       /* Copy the old table to the beginning of the new,
- 	 and zero the rest of the new table.  */
-       memcpy (newinfo, _heapinfo, heapsize * sizeof (malloc_info));
-       memset (&newinfo[heapsize], 0,
- 	      (newsize - heapsize) * sizeof (malloc_info));
-       oldinfo = _heapinfo;
-       _heapinfo = newinfo;
-       heapsize = newsize;
- 
-       register_heapinfo ();
- 
-       /* Reset _heaplimit so _free_internal never decides
- 	 it can relocate or resize the info table.  */
-       _heaplimit = 0;
-       _free_internal (oldinfo);
- 
-       /* The new heap limit includes the new table just allocated.  */
-       _heaplimit = BLOCK ((char *) newinfo + heapsize * sizeof (malloc_info));
-       return result;
-     }
- 
-  got_heap:
-   _heaplimit = BLOCK ((char *) result + size);
-   return result;
- }
- 
- /* Allocate memory from the heap.  */
- __ptr_t
- _malloc_internal (size)
-      __malloc_size_t size;
- {
-   __ptr_t result;
-   __malloc_size_t block, blocks, lastblocks, start;
-   register __malloc_size_t i;
-   struct list *next;
- 
-   /* ANSI C allows `malloc (0)' to either return NULL, or to return a
-      valid address you can realloc and free (though not dereference).
- 
-      It turns out that some extant code (sunrpc, at least Ultrix's version)
-      expects `malloc (0)' to return non-NULL and breaks otherwise.
-      Be compatible.  */
- 
- #if	0
-   if (size == 0)
-     return NULL;
- #endif
- 
-   if (size < sizeof (struct list))
-     size = sizeof (struct list);
- 
- #ifdef SUNOS_LOCALTIME_BUG
-   if (size < 16)
-     size = 16;
- #endif
- 
-   /* Determine the allocation policy based on the request size.  */
-   if (size <= BLOCKSIZE / 2)
-     {
-       /* Small allocation to receive a fragment of a block.
- 	 Determine the logarithm to base two of the fragment size. */
-       register __malloc_size_t log = 1;
-       --size;
-       while ((size /= 2) != 0)
- 	++log;
- 
-       /* Look in the fragment lists for a
- 	 free fragment of the desired size. */
-       next = _fraghead[log].next;
-       if (next != NULL)
- 	{
- 	  /* There are free fragments of this size.
- 	     Pop a fragment out of the fragment list and return it.
- 	     Update the block's nfree and first counters. */
- 	  result = (__ptr_t) next;
- 	  next->prev->next = next->next;
- 	  if (next->next != NULL)
- 	    next->next->prev = next->prev;
- 	  block = BLOCK (result);
- 	  if (--_heapinfo[block].busy.info.frag.nfree != 0)
- 	    _heapinfo[block].busy.info.frag.first = (unsigned long int)
- 	      ((unsigned long int) ((char *) next->next - (char *) NULL)
- 	       % BLOCKSIZE) >> log;
- 
- 	  /* Update the statistics.  */
- 	  ++_chunks_used;
- 	  _bytes_used += 1 << log;
- 	  --_chunks_free;
- 	  _bytes_free -= 1 << log;
- 	}
-       else
- 	{
- 	  /* No free fragments of the desired size, so get a new block
- 	     and break it into fragments, returning the first.  */
- 	  result = malloc (BLOCKSIZE);
- 	  if (result == NULL)
- 	    return NULL;
- 
- 	  /* Link all fragments but the first into the free list.  */
- 	  next = (struct list *) ((char *) result + (1 << log));
- 	  next->next = NULL;
- 	  next->prev = &_fraghead[log];
- 	  _fraghead[log].next = next;
- 
- 	  for (i = 2; i < (__malloc_size_t) (BLOCKSIZE >> log); ++i)
- 	    {
- 	      next = (struct list *) ((char *) result + (i << log));
- 	      next->next = _fraghead[log].next;
- 	      next->prev = &_fraghead[log];
- 	      next->prev->next = next;
- 	      next->next->prev = next;
- 	    }
- 
- 	  /* Initialize the nfree and first counters for this block.  */
- 	  block = BLOCK (result);
- 	  _heapinfo[block].busy.type = log;
- 	  _heapinfo[block].busy.info.frag.nfree = i - 1;
- 	  _heapinfo[block].busy.info.frag.first = i - 1;
- 
- 	  _chunks_free += (BLOCKSIZE >> log) - 1;
- 	  _bytes_free += BLOCKSIZE - (1 << log);
- 	  _bytes_used -= BLOCKSIZE - (1 << log);
- 	}
-     }
-   else
-     {
-       /* Large allocation to receive one or more blocks.
- 	 Search the free list in a circle starting at the last place visited.
- 	 If we loop completely around without finding a large enough
- 	 space we will have to get more memory from the system.  */
-       blocks = BLOCKIFY (size);
-       start = block = _heapindex;
-       while (_heapinfo[block].free.size < blocks)
- 	{
- 	  block = _heapinfo[block].free.next;
- 	  if (block == start)
- 	    {
- 	      /* Need to get more from the system.  Get a little extra.  */
- 	      __malloc_size_t wantblocks = blocks + __malloc_extra_blocks;
- 	      block = _heapinfo[0].free.prev;
- 	      lastblocks = _heapinfo[block].free.size;
- 	      /* Check to see if the new core will be contiguous with the
- 		 final free block; if so we don't need to get as much.  */
- 	      if (_heaplimit != 0 && block + lastblocks == _heaplimit &&
- 		  /* We can't do this if we will have to make the heap info
-                      table bigger to accomodate the new space.  */
- 		  block + wantblocks <= heapsize &&
- 		  get_contiguous_space ((wantblocks - lastblocks) * BLOCKSIZE,
- 					ADDRESS (block + lastblocks)))
- 		{
-  		  /* We got it contiguously.  Which block we are extending
- 		     (the `final free block' referred to above) might have
- 		     changed, if it got combined with a freed info table.  */
-  		  block = _heapinfo[0].free.prev;
-   		  _heapinfo[block].free.size += (wantblocks - lastblocks);
- 		  _bytes_free += (wantblocks - lastblocks) * BLOCKSIZE;
-  		  _heaplimit += wantblocks - lastblocks;
- 		  continue;
- 		}
- 	      result = morecore (wantblocks * BLOCKSIZE);
- 	      if (result == NULL)
- 		return NULL;
- 	      block = BLOCK (result);
- 	      /* Put the new block at the end of the free list.  */
- 	      _heapinfo[block].free.size = wantblocks;
- 	      _heapinfo[block].free.prev = _heapinfo[0].free.prev;
- 	      _heapinfo[block].free.next = 0;
- 	      _heapinfo[0].free.prev = block;
- 	      _heapinfo[_heapinfo[block].free.prev].free.next = block;
- 	      ++_chunks_free;
- 	      /* Now loop to use some of that block for this allocation.  */
- 	    }
- 	}
- 
-       /* At this point we have found a suitable free list entry.
- 	 Figure out how to remove what we need from the list. */
-       result = ADDRESS (block);
-       if (_heapinfo[block].free.size > blocks)
- 	{
- 	  /* The block we found has a bit left over,
- 	     so relink the tail end back into the free list. */
- 	  _heapinfo[block + blocks].free.size
- 	    = _heapinfo[block].free.size - blocks;
- 	  _heapinfo[block + blocks].free.next
- 	    = _heapinfo[block].free.next;
- 	  _heapinfo[block + blocks].free.prev
- 	    = _heapinfo[block].free.prev;
- 	  _heapinfo[_heapinfo[block].free.prev].free.next
- 	    = _heapinfo[_heapinfo[block].free.next].free.prev
- 	    = _heapindex = block + blocks;
- 	}
-       else
- 	{
- 	  /* The block exactly matches our requirements,
- 	     so just remove it from the list. */
- 	  _heapinfo[_heapinfo[block].free.next].free.prev
- 	    = _heapinfo[block].free.prev;
- 	  _heapinfo[_heapinfo[block].free.prev].free.next
- 	    = _heapindex = _heapinfo[block].free.next;
- 	  --_chunks_free;
- 	}
- 
-       _heapinfo[block].busy.type = 0;
-       _heapinfo[block].busy.info.size = blocks;
-       ++_chunks_used;
-       _bytes_used += blocks * BLOCKSIZE;
-       _bytes_free -= blocks * BLOCKSIZE;
- 
-       /* Mark all the blocks of the object just allocated except for the
- 	 first with a negative number so you can find the first block by
- 	 adding that adjustment.  */
-       while (--blocks > 0)
- 	_heapinfo[block + blocks].busy.info.size = -blocks;
-     }
- 
-   return result;
- }
- 
- __ptr_t
- malloc (size)
-      __malloc_size_t size;
- {
-   if (!__malloc_initialized && !__malloc_initialize ())
-     return NULL;
- 
-   return (__malloc_hook != NULL ? *__malloc_hook : _malloc_internal) (size);
- }
- 
- #ifndef _LIBC
- 
- /* On some ANSI C systems, some libc functions call _malloc, _free
-    and _realloc.  Make them use the GNU functions.  */
- 
- __ptr_t
- _malloc (size)
-      __malloc_size_t size;
- {
-   return malloc (size);
- }
- 
- void
- _free (ptr)
-      __ptr_t ptr;
- {
-   free (ptr);
- }
- 
- __ptr_t
- _realloc (ptr, size)
-      __ptr_t ptr;
-      __malloc_size_t size;
- {
-   return realloc (ptr, size);
- }
- 
- #endif
- /* Free a block of memory allocated by `malloc'.
-    Copyright 1990, 1991, 1992, 1994, 1995 Free Software Foundation, Inc.
- 		  Written May 1989 by Mike Haertel.
- 
- This library is free software; you can redistribute it and/or
- modify it under the terms of the GNU Library General Public License as
- published by the Free Software Foundation; either version 2 of the
- License, or (at your option) any later version.
- 
- This library is distributed in the hope that it will be useful,
- but WITHOUT ANY WARRANTY; without even the implied warranty of
- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- Library General Public License for more details.
- 
- You should have received a copy of the GNU Library General Public
- License along with this library; see the file COPYING.LIB.  If
- not, write to the Free Software Foundation, Inc.,
- 59 Temple Place, Suite 330, Boston, MA 02111 USA.
- 
-    The author may be reached (Email) at the address mike@ai.mit.edu,
-    or (US mail) as Mike Haertel c/o Free Software Foundation.  */
- 
- #ifndef	_MALLOC_INTERNAL
- #define _MALLOC_INTERNAL
- #include <malloc.h>
- #endif
- 
- 
- /* Cope with systems lacking `memmove'.    */
- #ifndef memmove
- #if  (defined (MEMMOVE_MISSING) || \
-       !defined(_LIBC) && !defined(STDC_HEADERS) && !defined(USG))
- #ifdef emacs
- #undef	__malloc_safe_bcopy
- #define __malloc_safe_bcopy safe_bcopy
- #endif
- /* This function is defined in realloc.c.  */
- extern void __malloc_safe_bcopy __P ((__ptr_t, __ptr_t, __malloc_size_t));
- #define memmove(to, from, size)	__malloc_safe_bcopy ((from), (to), (size))
- #endif
- #endif
- 
- 
- /* Debugging hook for free.  */
- void (*__free_hook) __P ((__ptr_t __ptr));
- 
- /* List of blocks allocated by memalign.  */
- struct alignlist *_aligned_blocks = NULL;
- 
- /* Return memory to the heap.
-    Like `free' but don't call a __free_hook if there is one.  */
- void
- _free_internal (ptr)
-      __ptr_t ptr;
- {
-   int type;
-   __malloc_size_t block, blocks;
-   register __malloc_size_t i;
-   struct list *prev, *next;
-   __ptr_t curbrk;
-   const __malloc_size_t lesscore_threshold
-     /* Threshold of free space at which we will return some to the system.  */
-     = FINAL_FREE_BLOCKS + 2 * __malloc_extra_blocks;
- 
-   register struct alignlist *l;
- 
-   if (ptr == NULL)
-     return;
- 
-   for (l = _aligned_blocks; l != NULL; l = l->next)
-     if (l->aligned == ptr)
-       {
- 	l->aligned = NULL;	/* Mark the slot in the list as free.  */
- 	ptr = l->exact;
- 	break;
-       }
- 
-   block = BLOCK (ptr);
- 
-   type = _heapinfo[block].busy.type;
-   switch (type)
-     {
-     case 0:
-       /* Get as many statistics as early as we can.  */
-       --_chunks_used;
-       _bytes_used -= _heapinfo[block].busy.info.size * BLOCKSIZE;
-       _bytes_free += _heapinfo[block].busy.info.size * BLOCKSIZE;
- 
-       /* Find the free cluster previous to this one in the free list.
- 	 Start searching at the last block referenced; this may benefit
- 	 programs with locality of allocation.  */
-       i = _heapindex;
-       if (i > block)
- 	while (i > block)
- 	  i = _heapinfo[i].free.prev;
-       else
- 	{
- 	  do
- 	    i = _heapinfo[i].free.next;
- 	  while (i > 0 && i < block);
- 	  i = _heapinfo[i].free.prev;
- 	}
- 
-       /* Determine how to link this block into the free list.  */
-       if (block == i + _heapinfo[i].free.size)
- 	{
- 	  /* Coalesce this block with its predecessor.  */
- 	  _heapinfo[i].free.size += _heapinfo[block].busy.info.size;
- 	  block = i;
- 	}
-       else
- 	{
- 	  /* Really link this block back into the free list.  */
- 	  _heapinfo[block].free.size = _heapinfo[block].busy.info.size;
- 	  _heapinfo[block].free.next = _heapinfo[i].free.next;
- 	  _heapinfo[block].free.prev = i;
- 	  _heapinfo[i].free.next = block;
- 	  _heapinfo[_heapinfo[block].free.next].free.prev = block;
- 	  ++_chunks_free;
- 	}
- 
-       /* Now that the block is linked in, see if we can coalesce it
- 	 with its successor (by deleting its successor from the list
- 	 and adding in its size).  */
-       if (block + _heapinfo[block].free.size == _heapinfo[block].free.next)
- 	{
- 	  _heapinfo[block].free.size
- 	    += _heapinfo[_heapinfo[block].free.next].free.size;
- 	  _heapinfo[block].free.next
- 	    = _heapinfo[_heapinfo[block].free.next].free.next;
- 	  _heapinfo[_heapinfo[block].free.next].free.prev = block;
- 	  --_chunks_free;
- 	}
- 
-       /* How many trailing free blocks are there now?  */
-       blocks = _heapinfo[block].free.size;
- 
-       /* Where is the current end of accessible core?  */
-       curbrk = (*__morecore) (0);
- 
-       if (_heaplimit != 0 && curbrk == ADDRESS (_heaplimit))
- 	{
- 	  /* The end of the malloc heap is at the end of accessible core.
- 	     It's possible that moving _heapinfo will allow us to
- 	     return some space to the system.  */
- 
-  	  __malloc_size_t info_block = BLOCK (_heapinfo);
-  	  __malloc_size_t info_blocks = _heapinfo[info_block].busy.info.size;
-  	  __malloc_size_t prev_block = _heapinfo[block].free.prev;
-  	  __malloc_size_t prev_blocks = _heapinfo[prev_block].free.size;
-  	  __malloc_size_t next_block = _heapinfo[block].free.next;
-  	  __malloc_size_t next_blocks = _heapinfo[next_block].free.size;
- 
- 	  if (/* Win if this block being freed is last in core, the info table
- 		 is just before it, the previous free block is just before the
- 		 info table, and the two free blocks together form a useful
- 		 amount to return to the system.  */
- 	      (block + blocks == _heaplimit &&
- 	       info_block + info_blocks == block &&
- 	       prev_block != 0 && prev_block + prev_blocks == info_block &&
- 	       blocks + prev_blocks >= lesscore_threshold) ||
- 	      /* Nope, not the case.  We can also win if this block being
- 		 freed is just before the info table, and the table extends
- 		 to the end of core or is followed only by a free block,
- 		 and the total free space is worth returning to the system.  */
- 	      (block + blocks == info_block &&
- 	       ((info_block + info_blocks == _heaplimit &&
- 		 blocks >= lesscore_threshold) ||
- 		(info_block + info_blocks == next_block &&
- 		 next_block + next_blocks == _heaplimit &&
- 		 blocks + next_blocks >= lesscore_threshold)))
- 	      )
- 	    {
- 	      malloc_info *newinfo;
- 	      __malloc_size_t oldlimit = _heaplimit;
- 
- 	      /* Free the old info table, clearing _heaplimit to avoid
- 		 recursion into this code.  We don't want to return the
- 		 table's blocks to the system before we have copied them to
- 		 the new location.  */
- 	      _heaplimit = 0;
- 	      _free_internal (_heapinfo);
- 	      _heaplimit = oldlimit;
- 
- 	      /* Tell malloc to search from the beginning of the heap for
- 		 free blocks, so it doesn't reuse the ones just freed.  */
- 	      _heapindex = 0;
- 
- 	      /* Allocate new space for the info table and move its data.  */
- 	      newinfo = (malloc_info *) _malloc_internal (info_blocks
- 							  * BLOCKSIZE);
- 	      memmove (newinfo, _heapinfo, info_blocks * BLOCKSIZE);
- 	      _heapinfo = newinfo;
- 
- 	      /* We should now have coalesced the free block with the
- 		 blocks freed from the old info table.  Examine the entire
- 		 trailing free block to decide below whether to return some
- 		 to the system.  */
- 	      block = _heapinfo[0].free.prev;
- 	      blocks = _heapinfo[block].free.size;
-  	    }
- 
- 	  /* Now see if we can return stuff to the system.  */
- 	  if (block + blocks == _heaplimit && blocks >= lesscore_threshold)
- 	    {
- 	      register __malloc_size_t bytes = blocks * BLOCKSIZE;
- 	      _heaplimit -= blocks;
- 	      (*__morecore) (-bytes);
- 	      _heapinfo[_heapinfo[block].free.prev].free.next
- 		= _heapinfo[block].free.next;
- 	      _heapinfo[_heapinfo[block].free.next].free.prev
- 		= _heapinfo[block].free.prev;
- 	      block = _heapinfo[block].free.prev;
- 	      --_chunks_free;
- 	      _bytes_free -= bytes;
- 	    }
- 	}
- 
-       /* Set the next search to begin at this block.  */
-       _heapindex = block;
-       break;
- 
-     default:
-       /* Do some of the statistics.  */
-       --_chunks_used;
-       _bytes_used -= 1 << type;
-       ++_chunks_free;
-       _bytes_free += 1 << type;
- 
-       /* Get the address of the first free fragment in this block.  */
-       prev = (struct list *) ((char *) ADDRESS (block) +
- 			      (_heapinfo[block].busy.info.frag.first << type));
- 
-       if (_heapinfo[block].busy.info.frag.nfree == (BLOCKSIZE >> type) - 1)
- 	{
- 	  /* If all fragments of this block are free, remove them
- 	     from the fragment list and free the whole block.  */
- 	  next = prev;
- 	  for (i = 1; i < (__malloc_size_t) (BLOCKSIZE >> type); ++i)
- 	    next = next->next;
- 	  prev->prev->next = next;
- 	  if (next != NULL)
- 	    next->prev = prev->prev;
- 	  _heapinfo[block].busy.type = 0;
- 	  _heapinfo[block].busy.info.size = 1;
- 
- 	  /* Keep the statistics accurate.  */
- 	  ++_chunks_used;
- 	  _bytes_used += BLOCKSIZE;
- 	  _chunks_free -= BLOCKSIZE >> type;
- 	  _bytes_free -= BLOCKSIZE;
- 
- 	  free (ADDRESS (block));
- 	}
-       else if (_heapinfo[block].busy.info.frag.nfree != 0)
- 	{
- 	  /* If some fragments of this block are free, link this
- 	     fragment into the fragment list after the first free
- 	     fragment of this block. */
- 	  next = (struct list *) ptr;
- 	  next->next = prev->next;
- 	  next->prev = prev;
- 	  prev->next = next;
- 	  if (next->next != NULL)
- 	    next->next->prev = next;
- 	  ++_heapinfo[block].busy.info.frag.nfree;
- 	}
-       else
- 	{
- 	  /* No fragments of this block are free, so link this
- 	     fragment into the fragment list and announce that
- 	     it is the first free fragment of this block. */
- 	  prev = (struct list *) ptr;
- 	  _heapinfo[block].busy.info.frag.nfree = 1;
- 	  _heapinfo[block].busy.info.frag.first = (unsigned long int)
- 	    ((unsigned long int) ((char *) ptr - (char *) NULL)
- 	     % BLOCKSIZE >> type);
- 	  prev->next = _fraghead[type].next;
- 	  prev->prev = &_fraghead[type];
- 	  prev->prev->next = prev;
- 	  if (prev->next != NULL)
- 	    prev->next->prev = prev;
- 	}
-       break;
-     }
- }
- 
- /* Return memory to the heap.  */
- void
- free (ptr)
-      __ptr_t ptr;
- {
-   if (__free_hook != NULL)
-     (*__free_hook) (ptr);
-   else
-     _free_internal (ptr);
- }
- 
- /* Define the `cfree' alias for `free'.  */
- #ifdef weak_alias
- weak_alias (free, cfree)
- #else
- void
- cfree (ptr)
-      __ptr_t ptr;
- {
-   free (ptr);
- }
- #endif
- /* Change the size of a block allocated by `malloc'.
-    Copyright 1990, 1991, 1992, 1993, 1994, 1995 Free Software Foundation, Inc.
- 		     Written May 1989 by Mike Haertel.
- 
- This library is free software; you can redistribute it and/or
- modify it under the terms of the GNU Library General Public License as
- published by the Free Software Foundation; either version 2 of the
- License, or (at your option) any later version.
- 
- This library is distributed in the hope that it will be useful,
- but WITHOUT ANY WARRANTY; without even the implied warranty of
- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- Library General Public License for more details.
- 
- You should have received a copy of the GNU Library General Public
- License along with this library; see the file COPYING.LIB.  If
- not, write to the Free Software Foundation, Inc.,
- 59 Temple Place, Suite 330, Boston, MA 02111 USA.
- 
-    The author may be reached (Email) at the address mike@ai.mit.edu,
-    or (US mail) as Mike Haertel c/o Free Software Foundation.  */
- 
- #ifndef	_MALLOC_INTERNAL
- #define _MALLOC_INTERNAL
- #include <malloc.h>
- #endif
- 
- 
- 
- /* Cope with systems lacking `memmove'.    */
- #if  (defined (MEMMOVE_MISSING) || \
-       !defined(_LIBC) && !defined(STDC_HEADERS) && !defined(USG))
- 
- #ifdef emacs
- #undef	__malloc_safe_bcopy
- #define __malloc_safe_bcopy safe_bcopy
- #else
- 
- /* Snarfed directly from Emacs src/dispnew.c:
-    XXX Should use system bcopy if it handles overlap.  */
- 
- /* Like bcopy except never gets confused by overlap.  */
- 
- void
- __malloc_safe_bcopy (afrom, ato, size)
-      __ptr_t afrom;
-      __ptr_t ato;
-      __malloc_size_t size;
- {
-   char *from = afrom, *to = ato;
- 
-   if (size <= 0 || from == to)
-     return;
- 
-   /* If the source and destination don't overlap, then bcopy can
-      handle it.  If they do overlap, but the destination is lower in
-      memory than the source, we'll assume bcopy can handle that.  */
-   if (to < from || from + size <= to)
-     bcopy (from, to, size);
- 
-   /* Otherwise, we'll copy from the end.  */
-   else
-     {
-       register char *endf = from + size;
-       register char *endt = to + size;
- 
-       /* If TO - FROM is large, then we should break the copy into
- 	 nonoverlapping chunks of TO - FROM bytes each.  However, if
- 	 TO - FROM is small, then the bcopy function call overhead
- 	 makes this not worth it.  The crossover point could be about
- 	 anywhere.  Since I don't think the obvious copy loop is too
- 	 bad, I'm trying to err in its favor.  */
-       if (to - from < 64)
- 	{
- 	  do
- 	    *--endt = *--endf;
- 	  while (endf != from);
- 	}
-       else
- 	{
- 	  for (;;)
- 	    {
- 	      endt -= (to - from);
- 	      endf -= (to - from);
- 
- 	      if (endt < to)
- 		break;
- 
- 	      bcopy (endf, endt, to - from);
- 	    }
- 
- 	  /* If SIZE wasn't a multiple of TO - FROM, there will be a
- 	     little left over.  The amount left over is
- 	     (endt + (to - from)) - to, which is endt - from.  */
- 	  bcopy (from, to, endt - from);
- 	}
-     }
- }
- #endif /* emacs */
- 
- #ifndef memmove
- extern void __malloc_safe_bcopy __P ((__ptr_t, __ptr_t, __malloc_size_t));
- #define memmove(to, from, size) __malloc_safe_bcopy ((from), (to), (size))
- #endif
- 
- #endif
- 
- 
- #define min(A, B) ((A) < (B) ? (A) : (B))
- 
- /* Debugging hook for realloc.  */
- __ptr_t (*__realloc_hook) __P ((__ptr_t __ptr, __malloc_size_t __size));
- 
- /* Resize the given region to the new size, returning a pointer
-    to the (possibly moved) region.  This is optimized for speed;
-    some benchmarks seem to indicate that greater compactness is
-    achieved by unconditionally allocating and copying to a
-    new region.  This module has incestuous knowledge of the
-    internals of both free and malloc. */
- __ptr_t
- _realloc_internal (ptr, size)
-      __ptr_t ptr;
-      __malloc_size_t size;
- {
-   __ptr_t result;
-   int type;
-   __malloc_size_t block, blocks, oldlimit;
- 
-   if (size == 0)
-     {
-       _free_internal (ptr);
-       return _malloc_internal (0);
-     }
-   else if (ptr == NULL)
-     return _malloc_internal (size);
- 
-   block = BLOCK (ptr);
- 
-   type = _heapinfo[block].busy.type;
-   switch (type)
-     {
-     case 0:
-       /* Maybe reallocate a large block to a small fragment.  */
-       if (size <= BLOCKSIZE / 2)
- 	{
- 	  result = _malloc_internal (size);
- 	  if (result != NULL)
- 	    {
- 	      memcpy (result, ptr, size);
- 	      _free_internal (ptr);
- 	      return result;
- 	    }
- 	}
- 
-       /* The new size is a large allocation as well;
- 	 see if we can hold it in place. */
-       blocks = BLOCKIFY (size);
-       if (blocks < _heapinfo[block].busy.info.size)
- 	{
- 	  /* The new size is smaller; return
- 	     excess memory to the free list. */
- 	  _heapinfo[block + blocks].busy.type = 0;
- 	  _heapinfo[block + blocks].busy.info.size
- 	    = _heapinfo[block].busy.info.size - blocks;
- 	  _heapinfo[block].busy.info.size = blocks;
- 	  /* We have just created a new chunk by splitting a chunk in two.
- 	     Now we will free this chunk; increment the statistics counter
- 	     so it doesn't become wrong when _free_internal decrements it.  */
- 	  ++_chunks_used;
- 	  _free_internal (ADDRESS (block + blocks));
- 	  result = ptr;
- 	}
-       else if (blocks == _heapinfo[block].busy.info.size)
- 	/* No size change necessary.  */
- 	result = ptr;
-       else
- 	{
- 	  /* Won't fit, so allocate a new region that will.
- 	     Free the old region first in case there is sufficient
- 	     adjacent free space to grow without moving. */
- 	  blocks = _heapinfo[block].busy.info.size;
- 	  /* Prevent free from actually returning memory to the system.  */
- 	  oldlimit = _heaplimit;
- 	  _heaplimit = 0;
- 	  _free_internal (ptr);
- 	  result = _malloc_internal (size);
- 	  if (_heaplimit == 0)
- 	    _heaplimit = oldlimit;
- 	  if (result == NULL)
- 	    {
- 	      /* Now we're really in trouble.  We have to unfree
- 		 the thing we just freed.  Unfortunately it might
- 		 have been coalesced with its neighbors.  */
- 	      if (_heapindex == block)
- 	        (void) _malloc_internal (blocks * BLOCKSIZE);
- 	      else
- 		{
- 		  __ptr_t previous
- 		    = _malloc_internal ((block - _heapindex) * BLOCKSIZE);
- 		  (void) _malloc_internal (blocks * BLOCKSIZE);
- 		  _free_internal (previous);
- 		}
- 	      return NULL;
- 	    }
- 	  if (ptr != result)
- 	    memmove (result, ptr, blocks * BLOCKSIZE);
- 	}
-       break;
- 
-     default:
-       /* Old size is a fragment; type is logarithm
- 	 to base two of the fragment size.  */
-       if (size > (__malloc_size_t) (1 << (type - 1)) &&
- 	  size <= (__malloc_size_t) (1 << type))
- 	/* The new size is the same kind of fragment.  */
- 	result = ptr;
-       else
- 	{
- 	  /* The new size is different; allocate a new space,
- 	     and copy the lesser of the new size and the old. */
- 	  result = _malloc_internal (size);
- 	  if (result == NULL)
- 	    return NULL;
- 	  memcpy (result, ptr, min (size, (__malloc_size_t) 1 << type));
- 	  _free_internal (ptr);
- 	}
-       break;
-     }
- 
-   return result;
- }
- 
- __ptr_t
- realloc (ptr, size)
-      __ptr_t ptr;
-      __malloc_size_t size;
- {
-   if (!__malloc_initialized && !__malloc_initialize ())
-     return NULL;
- 
-   return (__realloc_hook != NULL ? *__realloc_hook : _realloc_internal)
-     (ptr, size);
- }
- /* Copyright (C) 1991, 1992, 1994 Free Software Foundation, Inc.
- 
- This library is free software; you can redistribute it and/or
- modify it under the terms of the GNU Library General Public License as
- published by the Free Software Foundation; either version 2 of the
- License, or (at your option) any later version.
- 
- This library is distributed in the hope that it will be useful,
- but WITHOUT ANY WARRANTY; without even the implied warranty of
- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- Library General Public License for more details.
- 
- You should have received a copy of the GNU Library General Public
- License along with this library; see the file COPYING.LIB.  If
- not, write to the Free Software Foundation, Inc.,
- 59 Temple Place, Suite 330, Boston, MA 02111 USA.
- 
-    The author may be reached (Email) at the address mike@ai.mit.edu,
-    or (US mail) as Mike Haertel c/o Free Software Foundation.  */
- 
- #ifndef	_MALLOC_INTERNAL
- #define	_MALLOC_INTERNAL
- #include <malloc.h>
- #endif
- 
- /* Allocate an array of NMEMB elements each SIZE bytes long.
-    The entire array is initialized to zeros.  */
- __ptr_t
- calloc (nmemb, size)
-      register __malloc_size_t nmemb;
-      register __malloc_size_t size;
- {
-   register __ptr_t result = malloc (nmemb * size);
- 
-   if (result != NULL)
-     (void) memset (result, 0, nmemb * size);
- 
-   return result;
- }
- /* Copyright (C) 1991, 1992, 1993, 1994, 1995 Free Software Foundation, Inc.
- This file is part of the GNU C Library.
- 
- The GNU C Library is free software; you can redistribute it and/or modify
- it under the terms of the GNU General Public License as published by
- the Free Software Foundation; either version 2, or (at your option)
- any later version.
- 
- The GNU C Library is distributed in the hope that it will be useful,
- but WITHOUT ANY WARRANTY; without even the implied warranty of
- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- GNU General Public License for more details.
- 
- You should have received a copy of the GNU General Public License
- along with the GNU C Library; see the file COPYING.  If not, write to
- the Free Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.  */
- 
- #ifndef	_MALLOC_INTERNAL
- #define	_MALLOC_INTERNAL
- #include <malloc.h>
- #endif
- 
- #ifndef	__GNU_LIBRARY__
- #define	__sbrk	sbrk
- #endif
- 
- #ifdef __GNU_LIBRARY__
- /* It is best not to declare this and cast its result on foreign operating
-    systems with potentially hostile include files.  */
- 
- #include <stddef.h>
- extern __ptr_t __sbrk __P ((ptrdiff_t increment));
- #endif
- 
- #ifndef NULL
- #define NULL 0
- #endif
- 
- /* Allocate INCREMENT more bytes of data space,
-    and return the start of data space, or NULL on errors.
-    If INCREMENT is negative, shrink data space.  */
- __ptr_t
- __default_morecore (increment)
-      __malloc_ptrdiff_t increment;
- {
-   __ptr_t result = (__ptr_t) __sbrk (increment);
-   if (result == (__ptr_t) -1)
-     return NULL;
-   return result;
- }
- /* Copyright (C) 1991, 92, 93, 94, 95, 96 Free Software Foundation, Inc.
- 
- This library is free software; you can redistribute it and/or
- modify it under the terms of the GNU Library General Public License as
- published by the Free Software Foundation; either version 2 of the
- License, or (at your option) any later version.
- 
- This library is distributed in the hope that it will be useful,
- but WITHOUT ANY WARRANTY; without even the implied warranty of
- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- Library General Public License for more details.
- 
- You should have received a copy of the GNU Library General Public
- License along with this library; see the file COPYING.LIB.  If
- not, write to the Free Software Foundation, Inc.,
- 59 Temple Place, Suite 330, Boston, MA 02111 USA.  */
- 
- #ifndef	_MALLOC_INTERNAL
- #define _MALLOC_INTERNAL
- #include <malloc.h>
- #endif
- 
- #if __DJGPP__ - 0 == 1
- 
- /* There is some problem with memalign in DJGPP v1 and we are supposed
-    to omit it.  Noone told me why, they just told me to do it.  */
- 
- #else
- 
- __ptr_t (*__memalign_hook) __P ((size_t __size, size_t __alignment));
- 
- __ptr_t
- memalign (alignment, size)
-      __malloc_size_t alignment;
-      __malloc_size_t size;
- {
-   __ptr_t result;
-   unsigned long int adj, lastadj;
- 
-   if (__memalign_hook)
-     return (*__memalign_hook) (alignment, size);
- 
-   /* Allocate a block with enough extra space to pad the block with up to
-      (ALIGNMENT - 1) bytes if necessary.  */
-   result = malloc (size + alignment - 1);
-   if (result == NULL)
-     return NULL;
- 
-   /* Figure out how much we will need to pad this particular block
-      to achieve the required alignment.  */
-   adj = (unsigned long int) ((char *) result - (char *) NULL) % alignment;
- 
-   do
-     {
-       /* Reallocate the block with only as much excess as it needs.  */
-       free (result);
-       result = malloc (adj + size);
-       if (result == NULL)	/* Impossible unless interrupted.  */
- 	return NULL;
- 
-       lastadj = adj;
-       adj = (unsigned long int) ((char *) result - (char *) NULL) % alignment;
-       /* It's conceivable we might have been so unlucky as to get a
- 	 different block with weaker alignment.  If so, this block is too
- 	 short to contain SIZE after alignment correction.  So we must
- 	 try again and get another block, slightly larger.  */
-     } while (adj > lastadj);
- 
-   if (adj != 0)
-     {
-       /* Record this block in the list of aligned blocks, so that `free'
- 	 can identify the pointer it is passed, which will be in the middle
- 	 of an allocated block.  */
- 
-       struct alignlist *l;
-       for (l = _aligned_blocks; l != NULL; l = l->next)
- 	if (l->aligned == NULL)
- 	  /* This slot is free.  Use it.  */
- 	  break;
-       if (l == NULL)
- 	{
- 	  l = (struct alignlist *) malloc (sizeof (struct alignlist));
- 	  if (l == NULL)
- 	    {
- 	      free (result);
- 	      return NULL;
- 	    }
- 	  l->next = _aligned_blocks;
- 	  _aligned_blocks = l;
- 	}
-       l->exact = result;
-       result = l->aligned = (char *) result + alignment - adj;
-     }
- 
-   return result;
- }
- 
- #endif /* Not DJGPP v1 */
--- 0 ----
diff -Nrc2 bash-2.05/lib/malloc/omalloc.c bash-2.05a/lib/malloc/omalloc.c
*** bash-2.05/lib/malloc/omalloc.c	Thu Aug  5 07:59:21 1999
--- bash-2.05a/lib/malloc/omalloc.c	Wed Dec 31 19:00:00 1969
***************
*** 1,759 ****
- /* dynamic memory allocation for GNU. */
- 
- /*  Copyright (C) 1985, 1987 Free Software Foundation, Inc.
- 
-     This program is free software; you can redistribute it and/or modify
-     it under the terms of the GNU General Public License as published by
-     the Free Software Foundation; either version 2, or (at your option)
-     any later version.
- 
-     This program is distributed in the hope that it will be useful,
-     but WITHOUT ANY WARRANTY; without even the implied warranty of
-     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-     GNU General Public License for more details.
- 
-     You should have received a copy of the GNU General Public License
-     along with this program; if not, write to the Free Software
-     Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111 USA.
- 
- In other words, you are welcome to use, share and improve this program.
- You are forbidden to forbid anyone else to use, share and improve
- what you give them.   Help stamp out software-hoarding!  */
- 
- /*
-  * @(#)nmalloc.c 1 (Caltech) 2/21/82
-  *
-  *	U of M Modified: 20 Jun 1983 ACT: strange hacks for Emacs
-  *
-  *	Nov 1983, Mike@BRL, Added support for 4.1C/4.2 BSD.
-  *
-  * This is a very fast storage allocator.  It allocates blocks of a small 
-  * number of different sizes, and keeps free lists of each size.  Blocks
-  * that don't exactly fit are passed up to the next larger size.  In this 
-  * implementation, the available sizes are (2^n)-4 (or -16) bytes long.
-  * This is designed for use in a program that uses vast quantities of
-  * memory, but bombs when it runs out.  To make it a little better, it
-  * warns the user when he starts to get near the end.
-  *
-  * June 84, ACT: modified rcheck code to check the range given to malloc,
-  * rather than the range determined by the 2-power used.
-  *
-  * Jan 85, RMS: calls malloc_warning to issue warning on nearly full.
-  * No longer Emacs-specific; can serve as all-purpose malloc for GNU.
-  * You should call malloc_init to reinitialize after loading dumped Emacs.
-  * Call malloc_stats to get info on memory stats if MSTATS turned on.
-  * realloc knows how to return same block given, just changing its size,
-  * if the power of 2 is correct.
-  */
- 
- /*
-  * nextf[i] is the pointer to the next free block of size 2^(i+3).  The
-  * smallest allocatable block is 8 bytes.  The overhead information will
-  * go in the first int of the block, and the returned pointer will point
-  * to the second.
-  *
- #ifdef MSTATS
-  * nmalloc[i] is the difference between the number of mallocs and frees
-  * for a given block size.
- #endif
-  */
- 
- /* Define this to have free() write 0xcf into memory as it's freed, to
-    uncover callers that refer to freed memory. */
- /* SCO 3.2v4 getcwd and possibly other libc routines fail with MEMSCRAMBLE */
- #if !defined (NO_MEMSCRAMBLE)
- #  define MEMSCRAMBLE
- #endif
- 
- #if defined (emacs) || defined (HAVE_CONFIG_H)
- #  include <config.h>
- #endif /* emacs */
- 
- #if defined (HAVE_UNISTD_H)
- #  include <unistd.h>
- #endif
- 
- /* Determine which kind of system this is.  */
- #if defined (SHELL)
- #  include "bashtypes.h"
- #else
- #  include <sys/types.h>
- #endif
- #include <signal.h>
- 
- /* Define getpagesize () if the system does not.  */
- #ifndef HAVE_GETPAGESIZE
- #  include "getpagesize.h"
- #endif
- 
- #if defined (HAVE_RESOURCE)
- #  include <sys/time.h>
- #  include <sys/resource.h>
- #endif /* HAVE_RESOURCE */
- 
- /* Check for the needed symbols.  If they aren't present, this
-    system's <sys/resource.h> isn't very useful to us. */
- #if !defined (RLIMIT_DATA)
- #  undef HAVE_RESOURCE
- #endif
- 
- #if __GNUC__ > 1
- #  define FASTCOPY(s, d, n)  __builtin_memcpy (d, s, n)
- #else /* !__GNUC__ */
- #  if !defined (HAVE_BCOPY)
- #    if !defined (HAVE_MEMMOVE)
- #      define FASTCOPY(s, d, n)  memcpy (d, s, n)
- #    else
- #      define FASTCOPY(s, d, n)  memmove (d, s, n)
- #    endif /* !HAVE_MEMMOVE */
- #  else /* HAVE_BCOPY */
- #    define FASTCOPY(s, d, n)  bcopy (s, d, n)
- #  endif /* HAVE_BCOPY */
- #endif /* !__GNUC__ */
- 
- #if !defined (NULL)
- #  define NULL 0
- #endif
- 
- #define start_of_data() &etext
- 
- #define ISALLOC ((char) 0xf7)	/* magic byte that implies allocation */
- #define ISFREE ((char) 0x54)	/* magic byte that implies free block */
- 				/* this is for error checking only */
- #define ISMEMALIGN ((char) 0xd6)  /* Stored before the value returned by
- 				     memalign, with the rest of the word
- 				     being the distance to the true
- 				     beginning of the block.  */
- extern char etext;
- 
- #if !defined (SBRK_DECLARED)
- extern char *sbrk ();
- #endif /* !SBRK_DECLARED */
- 
- /* These two are for user programs to look at, when they are interested.  */
- unsigned int malloc_sbrk_used;       /* amount of data space used now */
- unsigned int malloc_sbrk_unused;     /* amount more we can have */
- 
- /* start of data space; can be changed by calling init_malloc */
- static char *data_space_start;
- 
- static void get_lim_data ();
- 
- #ifdef MSTATS
- static int nmalloc[30];
- static int nmal, nfre;
- #endif /* MSTATS */
- 
- /* If range checking is not turned on, all we have is a flag indicating
-    whether memory is allocated, an index in nextf[], and a size field; to
-    realloc() memory we copy either size bytes or 1<<(index+3) bytes depending
-    on whether the former can hold the exact size (given the value of
-    'index').  If range checking is on, we always need to know how much space
-    is allocated, so the 'size' field is never used. */
- 
- struct mhead {
- 	char     mh_alloc;	/* ISALLOC or ISFREE */
- 	char     mh_index;	/* index in nextf[] */
- /* Remainder are valid only when block is allocated */
- 	unsigned short mh_size;	/* size, if < 0x10000 */
- #ifdef RCHECK
- 	unsigned int mh_nbytes;	/* number of bytes allocated */
- 	int      mh_magic4;	/* should be == MAGIC4 */
- #endif /* RCHECK */
- };
- 
- /* Access free-list pointer of a block.
-   It is stored at block + 4.
-   This is not a field in the mhead structure
-   because we want sizeof (struct mhead)
-   to describe the overhead for when the block is in use,
-   and we do not want the free-list pointer to count in that.  */
- 
- #define CHAIN(a) \
-   (*(struct mhead **) (sizeof (char *) + (char *) (a)))
- 
- #ifdef RCHECK
- #  include <stdio.h>
- #  if !defined (botch)
- #    define botch(x) abort ()
- #  else
- extern void botch();
- #  endif /* botch */
- 
- #  if !defined (__STRING)
- #    if defined (__STDC__)
- #      define __STRING(x) #x
- #    else
- #      define __STRING(x) "x"
- #    endif
- #  endif
- 
-   /* To implement range checking, we write magic values in at the beginning
-      and end of each allocated block, and make sure they are undisturbed
-      whenever a free or a realloc occurs. */
- 
-   /* Written in each of the 4 bytes following the block's real space */
- #  define MAGIC1 0x55
-   /* Written in the 4 bytes before the block's real space */
- #  define MAGIC4 0x55555555
- #  define ASSERT(p) if (!(p)) botch(__STRING(p)); else
- #  define EXTRA  4		/* 4 bytes extra for MAGIC1s */
- #else /* !RCHECK */
- #  define ASSERT(p)
- #  define EXTRA  0
- #endif /* RCHECK */
- 
- /* nextf[i] is free list of blocks of size 2**(i + 3)  */
- 
- static struct mhead *nextf[30];
- 
- /* busy[i] is nonzero while allocation of block size i is in progress.  */
- 
- static char busy[30];
- 
- /* Number of bytes of writable memory we can expect to be able to get */
- static unsigned int lim_data;
- 
- /* Level number of warnings already issued.
-   0 -- no warnings issued.
-   1 -- 75% warning already issued.
-   2 -- 85% warning already issued.
- */
- static int warnlevel;
- 
- /* Function to call to issue a warning;
-    0 means don't issue them.  */
- static void (*warnfunction) ();
- 
- /* nonzero once initial bunch of free blocks made */
- static int gotpool;
- 
- char *_malloc_base;
- 
- static void getpool ();
- 
- /* Cause reinitialization based on job parameters;
-   also declare where the end of pure storage is. */
- void
- malloc_init (start, warnfun)
-      char *start;
-      void (*warnfun) ();
- {
-   if (start)
-     data_space_start = start;
-   lim_data = 0;
-   warnlevel = 0;
-   warnfunction = warnfun;
- }
- 
- /* Return the maximum size to which MEM can be realloc'd
-    without actually requiring copying.  */
- 
- int
- malloc_usable_size (mem)
-      char *mem;
- {
-   int blocksize = 8 << (((struct mhead *) mem) - 1) -> mh_index;
- 
-   return blocksize - sizeof (struct mhead) - EXTRA;
- }
- 
- static void
- morecore (nu)			/* ask system for more memory */
-      register int nu;		/* size index to get more of  */
- {
-   register char *cp;
-   register int nblks;
-   register unsigned int siz;
- 
-   /* Block all signals in case we are executed from a signal handler. */
- #if defined (HAVE_BSD_SIGNALS)
-   int oldmask;
-   oldmask = sigsetmask (-1);
- #else
- #  if defined (HAVE_POSIX_SIGNALS)
-   sigset_t set, oset;
-   sigfillset (&set);
-   sigemptyset (&oset);
-   sigprocmask (SIG_BLOCK, &set, &oset);
- #  endif /* HAVE_POSIX_SIGNALS */
- #endif /* HAVE_BSD_SIGNALS */
- 
-   if (!data_space_start)
-     {
-       data_space_start = start_of_data ();
-     }
- 
-   if (lim_data == 0)
-     get_lim_data ();
- 
-  /* On initial startup, get two blocks of each size up to 1k bytes */
-   if (!gotpool)
-     { getpool (); getpool (); gotpool = 1; }
- 
-   /* Find current end of memory and issue warning if getting near max */
- 
-   cp = sbrk (0);
-   siz = cp - data_space_start;
-   malloc_sbrk_used = siz;
-   malloc_sbrk_unused = lim_data - siz;
- 
-   if (warnfunction)
-     switch (warnlevel)
-       {
-       case 0: 
- 	if (siz > (lim_data / 4) * 3)
- 	  {
- 	    warnlevel++;
- 	    (*warnfunction) ("Warning: past 75% of memory limit");
- 	  }
- 	break;
-       case 1: 
- 	if (siz > (lim_data / 20) * 17)
- 	  {
- 	    warnlevel++;
- 	    (*warnfunction) ("Warning: past 85% of memory limit");
- 	  }
- 	break;
-       case 2: 
- 	if (siz > (lim_data / 20) * 19)
- 	  {
- 	    warnlevel++;
- 	    (*warnfunction) ("Warning: past 95% of memory limit");
- 	  }
- 	break;
-       }
- 
-   if ((int) cp & 0x3ff)	/* land on 1K boundaries */
-     sbrk (1024 - ((int) cp & 0x3ff));
- 
-  /* Take at least 2k, and figure out how many blocks of the desired size
-     we're about to get */
-   nblks = 1;
-   if ((siz = nu) < 8)
-     nblks = 1 << ((siz = 8) - nu);
- 
-   if ((cp = sbrk (1 << (siz + 3))) == (char *) -1)
-     return;			/* no more room! */
- 
-   if ((int) cp & 7)
-     {		/* shouldn't happen, but just in case */
-       cp = (char *) (((int) cp + 8) & ~7);
-       nblks--;
-     }
- 
-  /* save new header and link the nblks blocks together */
-   nextf[nu] = (struct mhead *) cp;
-   siz = 1 << (nu + 3);
-   while (1)
-     {
-       ((struct mhead *) cp) -> mh_alloc = ISFREE;
-       ((struct mhead *) cp) -> mh_index = nu;
-       if (--nblks <= 0) break;
-       CHAIN ((struct mhead *) cp) = (struct mhead *) (cp + siz);
-       cp += siz;
-     }
-   CHAIN ((struct mhead *) cp) = 0;
- 
- #if defined (HAVE_BSD_SIGNALS)
-   sigsetmask (oldmask);
- #else
- #  if defined (HAVE_POSIX_SIGNALS)
-   sigprocmask (SIG_SETMASK, &oset, (sigset_t *)NULL);
- #  endif
- #endif /* HAVE_BSD_SIGNALS */
- }
- 
- static void
- getpool ()
- {
-   register int nu;
-   register char *cp = sbrk (0);
- 
-   if ((int) cp & 0x3ff)	/* land on 1K boundaries */
-     sbrk (1024 - ((int) cp & 0x3ff));
- 
-   /* Record address of start of space allocated by malloc.  */
-   if (_malloc_base == 0)
-     _malloc_base = cp;
- 
-   /* Get 2k of storage */
- 
-   cp = sbrk (04000);
-   if (cp == (char *) -1)
-     return;
- 
-   /* Divide it into an initial 8-word block
-      plus one block of size 2**nu for nu = 3 ... 10.  */
- 
-   CHAIN (cp) = nextf[0];
-   nextf[0] = (struct mhead *) cp;
-   ((struct mhead *) cp) -> mh_alloc = ISFREE;
-   ((struct mhead *) cp) -> mh_index = 0;
-   cp += 8;
- 
-   for (nu = 0; nu < 7; nu++)
-     {
-       CHAIN (cp) = nextf[nu];
-       nextf[nu] = (struct mhead *) cp;
-       ((struct mhead *) cp) -> mh_alloc = ISFREE;
-       ((struct mhead *) cp) -> mh_index = nu;
-       cp += 8 << nu;
-     }
- }
- 
- #if defined (MEMSCRAMBLE) || !defined (NO_CALLOC)
- static char *
- zmemset (s, c, n)
-      char *s;
-      int c;
-      register int n;
- {
-   register char *sp;
- 
-   sp = s;
-   while (--n >= 0)
-     *sp++ = c;
-   return (s);
- }
- #endif /* MEMSCRAMBLE || !NO_CALLOC */
- 
- char *
- malloc (n)		/* get a block */
-      unsigned int n;
- {
-   register struct mhead *p;
-   register unsigned int nbytes;
-   register int nunits = 0;
- 
-   /* Figure out how many bytes are required, rounding up to the nearest
-      multiple of 4, then figure out which nextf[] area to use */
-   nbytes = (n + sizeof *p + EXTRA + 3) & ~3;
-   {
-     register unsigned int   shiftr = (nbytes - 1) >> 2;
- 
-     while (shiftr >>= 1)
-       nunits++;
-   }
- 
-   /* In case this is reentrant use of malloc from signal handler,
-      pick a block size that no other malloc level is currently
-      trying to allocate.  That's the easiest harmless way not to
-      interfere with the other level of execution.  */
-   while (busy[nunits]) nunits++;
-   busy[nunits] = 1;
- 
-   /* If there are no blocks of the appropriate size, go get some */
-   /* COULD SPLIT UP A LARGER BLOCK HERE ... ACT */
-   if (nextf[nunits] == 0)
-     morecore (nunits);
- 
-   /* Get one block off the list, and set the new list head */
-   if ((p = nextf[nunits]) == 0)
-     {
-       busy[nunits] = 0;
-       return 0;
-     }
-   nextf[nunits] = CHAIN (p);
-   busy[nunits] = 0;
- 
-   /* Check for free block clobbered */
-   /* If not for this check, we would gobble a clobbered free chain ptr */
-   /* and bomb out on the NEXT allocate of this size block */
-   if (p -> mh_alloc != ISFREE || p -> mh_index != nunits)
- #ifdef RCHECK
-     botch ("block on free list clobbered");
- #else /* not RCHECK */
-     abort ();
- #endif /* not RCHECK */
- 
-   /* Fill in the info, and if range checking, set up the magic numbers */
-   p -> mh_alloc = ISALLOC;
- #ifdef RCHECK
-   p -> mh_nbytes = n;
-   p -> mh_magic4 = MAGIC4;
-   {
-     register char  *m = (char *) (p + 1) + n;
- 
-     *m++ = MAGIC1, *m++ = MAGIC1, *m++ = MAGIC1, *m = MAGIC1;
-   }
- #else /* not RCHECK */
-   p -> mh_size = n;
- #endif /* not RCHECK */
- #ifdef MEMSCRAMBLE
-   zmemset ((char *)(p + 1), 0xdf, n);	/* scramble previous contents */
- #endif
- #ifdef MSTATS
-   nmalloc[nunits]++;
-   nmal++;
- #endif /* MSTATS */
-   return (char *) (p + 1);
- }
- 
- void
- free (mem)
-      char *mem;
- {
-   register struct mhead *p;
-   {
-     register char *ap = mem;
- 
-     if (ap == 0)
-       return;
- 
-     p = (struct mhead *) ap - 1;
- 
-     if (p -> mh_alloc == ISMEMALIGN)
-       {
- #ifdef RCHECK
- 	ap -= p->mh_nbytes;
- #else
- 	ap -= p->mh_size;	/* XXX */
- #endif
- 	p = (struct mhead *) ap - 1;
-       }
- 
- #ifndef RCHECK
-     if (p -> mh_alloc != ISALLOC)
-       abort ();
- 
- #else /* RCHECK */
-     if (p -> mh_alloc != ISALLOC)
-       {
- 	if (p -> mh_alloc == ISFREE)
- 	  botch ("free: Called with already freed block argument\n");
- 	else
- 	  botch ("free: Called with unallocated block argument\n");
-       }
- 
-     ASSERT (p -> mh_magic4 == MAGIC4);
-     ap += p -> mh_nbytes;
-     ASSERT (*ap++ == MAGIC1); ASSERT (*ap++ == MAGIC1);
-     ASSERT (*ap++ == MAGIC1); ASSERT (*ap   == MAGIC1);
- #endif /* RCHECK */
-   }
- #ifdef MEMSCRAMBLE
-   {
-     register int n;
-     
- #ifdef RCHECK
-     n = p->mh_nbytes;
- #else /* not RCHECK */
-     n = p->mh_size;
- #endif /* not RCHECK */
-     zmemset (mem, 0xcf, n);
-   }
- #endif
-   {
-     register int nunits = p -> mh_index;
- 
-     ASSERT (nunits <= 29);
-     p -> mh_alloc = ISFREE;
- 
-     /* Protect against signal handlers calling malloc.  */
-     busy[nunits] = 1;
-     /* Put this block on the free list.  */
-     CHAIN (p) = nextf[nunits];
-     nextf[nunits] = p;
-     busy[nunits] = 0;
- 
- #ifdef MSTATS
-     nmalloc[nunits]--;
-     nfre++;
- #endif /* MSTATS */
-   }
- }
- 
- char *
- realloc (mem, n)
-      char *mem;
-      register unsigned int n;
- {
-   register struct mhead *p;
-   register unsigned int tocopy;
-   register unsigned int nbytes;
-   register int nunits;
- 
-   if ((p = (struct mhead *) mem) == 0)
-     return malloc (n);
-   p--;
-   nunits = p -> mh_index;
-   ASSERT (p -> mh_alloc == ISALLOC);
- #ifdef RCHECK
-   ASSERT (p -> mh_magic4 == MAGIC4);
-   {
-     register char *m = mem + (tocopy = p -> mh_nbytes);
-     ASSERT (*m++ == MAGIC1); ASSERT (*m++ == MAGIC1);
-     ASSERT (*m++ == MAGIC1); ASSERT (*m   == MAGIC1);
-   }
- #else /* not RCHECK */
-   if (p -> mh_index >= 13)
-     tocopy = (1 << (p -> mh_index + 3)) - sizeof *p;
-   else
-     tocopy = p -> mh_size;
- #endif /* not RCHECK */
- 
-   /* See if desired size rounds to same power of 2 as actual size. */
-   nbytes = (n + sizeof *p + EXTRA + 7) & ~7;
- 
-   /* If ok, use the same block, just marking its size as changed.  */
-   if (nbytes > (4 << nunits) && nbytes <= (8 << nunits))
-     {
- #ifdef RCHECK
-       register char *m = mem + tocopy;
-       *m++ = 0;  *m++ = 0;  *m++ = 0;  *m++ = 0;
-       p-> mh_nbytes = n;
-       m = mem + n;
-       *m++ = MAGIC1;  *m++ = MAGIC1;  *m++ = MAGIC1;  *m++ = MAGIC1;
- #else /* not RCHECK */
-       p -> mh_size = n;
- #endif /* not RCHECK */
-       return mem;
-     }
- 
-   if (n < tocopy)
-     tocopy = n;
-   {
-     register char *new;
- 
-     if ((new = malloc (n)) == 0)
-       return 0;
-     FASTCOPY (mem, new, tocopy);
-     free (mem);
-     return new;
-   }
- }
- 
- char *
- memalign (alignment, size)
-      unsigned int alignment, size;
- {
-   register char *ptr;
-   register char *aligned;
-   register struct mhead *p;
- 
-   ptr = malloc (size + alignment);
- 
-   if (ptr == 0)
-     return 0;
-   /* If entire block has the desired alignment, just accept it.  */
-   if (((int) ptr & (alignment - 1)) == 0)
-     return ptr;
-   /* Otherwise, get address of byte in the block that has that alignment.  */
-   aligned = (char *) (((int) ptr + alignment - 1) & -alignment);
- 
-   /* Store a suitable indication of how to free the block,
-      so that free can find the true beginning of it.  */
-   p = (struct mhead *) aligned - 1;
-   p -> mh_size = aligned - ptr;
-   p -> mh_alloc = ISMEMALIGN;
-   return aligned;
- }
- 
- #if !defined (HPUX)
- /* This runs into trouble with getpagesize on HPUX, and Multimax machines.
-    Patching out seems cleaner than the ugly fix needed.  */
- #if defined (__STDC__)
- void *
- #else
- char *
- #endif
- valloc (size)
-      size_t size;
- {
-   return memalign (getpagesize (), size);
- }
- #endif /* !HPUX */
- 
- #ifndef NO_CALLOC
- char *
- calloc (n, s)
-      size_t n, s;
- {
-   size_t total;
-   char *result;
- 
-   total = n * s;
-   result = malloc (total);
-   if (result)
-     zmemset (result, 0, total);
-   return result;  
- }
- 
- void
- cfree (p)
-      char *p;
- {
-   free (p);
- }
- #endif /* !NO_CALLOC */
- 
- #ifdef MSTATS
- /* Return statistics describing allocation of blocks of size 2**n. */
- 
- struct mstats_value
-   {
-     int blocksize;
-     int nfree;
-     int nused;
-   };
- 
- struct mstats_value
- malloc_stats (size)
-      int size;
- {
-   struct mstats_value v;
-   register int i;
-   register struct mhead *p;
- 
-   v.nfree = 0;
- 
-   if (size < 0 || size >= 30)
-     {
-       v.blocksize = 0;
-       v.nused = 0;
-       return v;
-     }
- 
-   v.blocksize = 1 << (size + 3);
-   v.nused = nmalloc[size];
- 
-   for (p = nextf[size]; p; p = CHAIN (p))
-     v.nfree++;
- 
-   return v;
- }
- #endif /* MSTATS */
- 
- /*
-  *	This function returns the total number of bytes that the process
-  *	will be allowed to allocate via the sbrk(2) system call.  On
-  *	BSD systems this is the total space allocatable to stack and
-  *	data.  On USG systems this is the data space only.
-  */
- 
- #if !defined (HAVE_RESOURCE)
- extern long ulimit ();
- 
- static void
- get_lim_data ()
- {    
-   lim_data = ulimit (3, 0);
-   lim_data -= (long) data_space_start;
- }
- 
- #else /* HAVE_RESOURCE */
- static void
- get_lim_data ()
- {
-   struct rlimit XXrlimit;
- 
-   getrlimit (RLIMIT_DATA, &XXrlimit);
- #ifdef RLIM_INFINITY
-   lim_data = XXrlimit.rlim_cur & RLIM_INFINITY; /* soft limit */
- #else
-   lim_data = XXrlimit.rlim_cur;	/* soft limit */
- #endif
- }
- 
- #endif /* HAVE_RESOURCE */
--- 0 ----
diff -Nrc2 bash-2.05/lib/malloc/shmalloc.h bash-2.05a/lib/malloc/shmalloc.h
*** bash-2.05/lib/malloc/shmalloc.h	Wed Dec 31 19:00:00 1969
--- bash-2.05a/lib/malloc/shmalloc.h	Mon Oct 15 09:53:04 2001
***************
*** 0 ****
--- 1,67 ----
+ /* Functions (currently) for use by the shell to do malloc debugging and
+    tracking. */
+ /* Copyright (C) 2001 Free Software Foundation, Inc.
+ 
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2 of the License, or
+ (at your option) any later version.
+ 
+ This program is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+ 
+ You should have received a copy of the GNU General Public License
+ along with this program; if not, write to the Free Software
+ Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111 USA.  */
+ 
+ #ifndef _SH_MALLOC_H
+ #define _SH_MALLOC_H
+ 
+ #ifndef __P
+ #  if defined (__STDC__) || defined (__GNUC__) || defined (__cplusplus)
+ #    define __P(protos) protos
+ #  else
+ #    define __P(protos) ()
+ #  endif
+ #endif
+ 
+ /* Generic pointer type. */
+ #ifndef PTR_T
+ 
+ #if defined (__STDC__)
+ #  define PTR_T void *
+ #else
+ #  define PTR_T char *
+ #endif
+ 
+ #endif /* PTR_T */
+ 
+ 
+ extern PTR_T sh_malloc __P((size_t, const char *, int));
+ extern PTR_T sh_realloc __P((PTR_T, size_t, const char *, int));
+ extern void sh_free __P((PTR_T, const char *, int));
+ 
+ extern PTR_T sh_memalign __P((unsigned int, size_t, const char *, int));
+ 
+ extern PTR_T sh_calloc __P((size_t, size_t, const char *, int));
+ extern void sh_cfree __P((PTR_T, const char *, int));
+ 
+ extern PTR_T sh_valloc __P((size_t, const char *, int));
+ 
+ /* trace.c */
+ extern int malloc_set_trace __P((int));
+ extern void malloc_set_tracefp ();	/* full prototype requires stdio.h */
+ 
+ /* table.c */
+ extern void mregister_dump_table __P((void));
+ extern void mregister_table_init __P((void));
+ extern int malloc_set_register __P((int));
+ 
+ /* stats.c */
+ extern void print_malloc_stats __P((char *));
+ extern void fprint_malloc_stats ();	/* full prototype requires stdio.h */
+ extern void trace_malloc_stats __P((char *));
+ 
+ #endif
diff -Nrc2 bash-2.05/lib/malloc/stats.c bash-2.05a/lib/malloc/stats.c
*** bash-2.05/lib/malloc/stats.c	Wed Dec 31 19:00:00 1969
--- bash-2.05a/lib/malloc/stats.c	Mon Oct 15 09:36:26 2001
***************
*** 0 ****
--- 1,147 ----
+ /* stats.c - malloc statistics */
+ 
+ /*  Copyright (C) 2001 Free Software Foundation, Inc.
+ 
+     This program is free software; you can redistribute it and/or modify
+     it under the terms of the GNU General Public License as published by
+     the Free Software Foundation; either version 2, or (at your option)
+     any later version.
+ 
+     This program is distributed in the hope that it will be useful,
+     but WITHOUT ANY WARRANTY; without even the implied warranty of
+     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+     GNU General Public License for more details.
+ 
+     You should have received a copy of the GNU General Public License
+     along with this program; if not, write to the Free Software
+     Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111 USA. */
+ 
+ #ifdef HAVE_CONFIG_H
+ #  include <config.h>
+ #endif
+ 
+ #include "imalloc.h"
+ 
+ #ifdef MALLOC_STATS
+ 
+ #include <stdio.h>
+ #include "mstats.h"
+ 
+ struct _malstats _mstats;
+ 
+ struct bucket_stats
+ malloc_bucket_stats (size)
+      int size;
+ {
+   struct bucket_stats v;
+ 
+   v.nfree = 0;
+ 
+   if (size < 0 || size >= NBUCKETS)
+     {
+       v.blocksize = 0;
+       v.nused = v.nmal = v.nmorecore = v.nsplit = 0;
+       return v;
+     }
+ 
+   v.blocksize = 1 << (size + 3);
+   v.nused = _mstats.nmalloc[size];
+   v.nmal = _mstats.tmalloc[size];
+   v.nmorecore = _mstats.nmorecore[size];
+   v.nsplit = _mstats.nsplit[size];
+ 
+   v.nfree = malloc_free_blocks (size);	/* call back to malloc.c */
+ 
+   return v;
+ }
+ 
+ /* Return a copy of _MSTATS, with two additional fields filled in:
+    BYTESFREE is the total number of bytes on free lists.  BYTESUSED
+    is the total number of bytes in use.  These two fields are fairly
+    expensive to compute, so we do it only when asked to. */
+ struct _malstats
+ malloc_stats ()
+ {
+   struct _malstats result;
+   struct bucket_stats v;
+   register int i;
+ 
+   result = _mstats;
+   result.bytesused = result.bytesfree = 0;
+   for (i = 0; i < NBUCKETS; i++)
+     {
+       v = malloc_bucket_stats (i);
+       result.bytesfree += v.nfree * v.blocksize;
+       result.bytesused += v.nused * v.blocksize;
+     }
+   return (result);
+ }
+ 
+ static void
+ _print_malloc_stats (s, fp)
+      char *s;
+      FILE *fp;
+ {
+   register int i;
+   unsigned long totused, totfree;
+   struct bucket_stats v;
+ 
+   fprintf (fp, "Memory allocation statistics: %s\n\tsize\tfree\tin use\ttotal\tmorecore\tsplit\n", s ? s : "");
+   for (i = totused = totfree = 0; i < NBUCKETS; i++)
+     {
+       v = malloc_bucket_stats (i);
+       fprintf (fp, "%12lu\t%4d\t%6d\t%5d\t%8d\t%5d\n", (unsigned long)v.blocksize, v.nfree, v.nused, v.nmal, v.nmorecore, v.nsplit);
+       totfree += v.nfree * v.blocksize;
+       totused += v.nused * v.blocksize;
+     }
+   fprintf (fp, "\nTotal bytes in use: %lu, total bytes free: %lu\n",
+ 	   totused, totfree);
+   fprintf (fp, "Total mallocs: %d, total frees: %d, total reallocs: %d (%d copies)\n",
+ 	   _mstats.nmal, _mstats.nfre, _mstats.nrealloc, _mstats.nrcopy);
+   fprintf (fp, "Total sbrks: %d, total bytes via sbrk: %d\n",
+   	   _mstats.nsbrk, _mstats.tsbrk);
+   fprintf (fp, "Total blocks split: %d, total block coalesces: %d\n",
+   	   _mstats.tbsplit, _mstats.tbcoalesce);
+ }
+ 
+ void
+ print_malloc_stats (s)
+      char *s;
+ {
+   _print_malloc_stats (s, stderr);
+ }
+ 
+ void
+ fprint_malloc_stats (s, fp)
+      char *s;
+      FILE *fp;
+ {
+   _print_malloc_stats (s, fp);
+ }
+ 
+ #define TRACEROOT "/var/tmp/maltrace/trace."
+ extern char *inttostr ();
+ 
+ void
+ trace_malloc_stats (s)
+      char *s;
+ {
+   char ibuf[32], *ip;
+   char fname[64];
+   long p;
+   FILE *fp;
+ 
+   p = getpid();
+   ip = inttostr(p, ibuf, sizeof(ibuf));
+   strcpy (fname, TRACEROOT);
+   strcat (fname, ip);
+   fp = fopen(fname, "w");
+   if (fp)
+     {
+       _print_malloc_stats (s, fp);
+       fflush(fp);
+       fclose(fp);
+     }
+ }
+ 
+ #endif /* MALLOC_STATS */
diff -Nrc2 bash-2.05/lib/malloc/table.c bash-2.05a/lib/malloc/table.c
*** bash-2.05/lib/malloc/table.c	Wed Dec 31 19:00:00 1969
--- bash-2.05a/lib/malloc/table.c	Wed Oct 10 15:54:14 2001
***************
*** 0 ****
--- 1,267 ----
+ /* table.c - bookkeeping functions for allocated memory */
+ 
+ /* Copyright (C) 2001 Free Software Foundation, Inc.
+ 
+    This file is part of GNU Bash, the Bourne Again SHell.
+ 
+    Bash is free software; you can redistribute it and/or modify it under
+    the terms of the GNU General Public License as published by the Free
+    Software Foundation; either version 2, or (at your option) any later
+    version.
+ 
+    Bash is distributed in the hope that it will be useful, but WITHOUT ANY
+    WARRANTY; without even the implied warranty of MERCHANTABILITY or
+    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+    for more details.
+ 
+    You should have received a copy of the GNU General Public License along
+    with Bash; see the file COPYING.  If not, write to the Free Software
+    Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. */
+ #ifdef HAVE_CONFIG_H
+ #  include <config.h>
+ #endif
+ 
+ #include <stdio.h>
+ 
+ #include "imalloc.h"
+ #include "table.h"
+ 
+ extern int malloc_register;
+ 
+ #ifdef MALLOC_REGISTER
+ 
+ #define FIND_ALLOC	0x01	/* allocate new entry or find existing */
+ #define FIND_EXIST	0x02	/* find existing entry */
+ 
+ static int table_count = 0;
+ static mr_table_t mem_table[REG_TABLE_SIZE];
+ 
+ /*
+  * NOTE: taken from dmalloc (http://dmalloc.com) and modified.
+  */
+ static unsigned int
+ mt_hash (key)
+      const PTR_T key;
+ {
+   unsigned int a, b, c, len;
+   unsigned long x;
+ 
+   /* set up the internal state */
+   a = 0x9e3779b9;	/* the golden ratio; an arbitrary value */
+   x = (unsigned long)key;		/* truncation is OK */
+   b = x >> 8;
+   c = x >> 3;				/* XXX - was >> 4 */
+ 
+   HASH_MIX(a, b, c);
+   return c;
+ }
+ 
+ #if 0
+ static unsigned int
+ which_bucket (mem)
+      PTR_T mem;
+ {
+   return (mt_hash ((unsigned char *)mem) % REG_TABLE_SIZE);
+ }
+ #else
+ #define which_bucket(mem) (mt_hash ((unsigned char *)(mem)) % REG_TABLE_SIZE);
+ #endif
+ 
+ static mr_table_t *
+ find_entry (mem, flags)
+      PTR_T mem;
+      int flags;
+ {
+   unsigned int bucket;
+   register mr_table_t *tp;
+   mr_table_t *endp, *lastp;
+ 
+   bucket = which_bucket (mem);	/* get initial hash */
+   tp = endp = mem_table + bucket;
+   lastp = mem_table + REG_TABLE_SIZE;
+ 
+   while (1)
+     {
+       if (tp->mem == mem)
+ 	return (tp);
+       if (tp->mem == 0 && (flags & FIND_ALLOC))
+ 	{
+ 	  table_count++;
+ 	  return (tp);
+ 	}
+ 
+       tp++;
+ 
+       if (tp == lastp)		/* wrap around */
+         tp = mem_table;
+ 
+       if (tp == endp && (flags & FIND_EXIST))
+         return ((mr_table_t *)NULL);
+ 
+       if (tp == endp && (flags & FIND_ALLOC))
+         break;
+     }
+ 
+   /* oops.  table is full.  replace an existing free entry. */
+   do
+     {
+       if (tp->flags & MT_FREE)
+ 	{
+ 	  memset(tp, 0, sizeof (mr_table_t));
+ 	  return (tp);
+ 	}
+       tp++;
+     }
+   while (tp != endp);
+ 
+   /* wow. entirely full.  return NULL. */
+   return ((mr_table_t *)NULL);
+ }
+ 
+ mr_table_t *
+ mr_table_entry (mem)
+      PTR_T mem;
+ {
+   return (find_entry (mem, FIND_EXIST));
+ }
+ 
+ void
+ mregister_describe_mem (mem, fp)
+      PTR_T mem;
+      FILE *fp;
+ {
+   mr_table_t *entry;
+ 
+   entry = find_entry (mem, FIND_EXIST);
+   if (entry == 0)
+     return;
+   fprintf (fp, "malloc: %p: %s: last %s from %s:%d\n",
+   		mem,
+ 		(entry->flags & MT_ALLOC) ? "allocated" : "free",
+ 		(entry->flags & MT_ALLOC) ? "allocated" : "freed",
+ 		entry->file ? entry->file : "unknown",
+ 		entry->line);
+ }
+ 
+ void
+ mregister_alloc (tag, mem, size, file, line)
+      const char *tag;
+      PTR_T mem;
+      size_t size;
+      const char *file;
+      int line;
+ {
+   mr_table_t *tentry;
+ 
+   tentry = find_entry (mem, FIND_ALLOC);
+ 
+   if (tentry == 0)
+     {
+       /* oops.  table is full.  punt. */
+       fprintf (stderr, "register_alloc: alloc table is full?\n");
+       return;
+     }
+   
+   if (tentry->flags & MT_ALLOC)
+     {
+       /* oops.  bad bookkeeping. ignore for now */
+       fprintf (stderr, "register_alloc: %p already in table as allocated?\n", mem);
+     }
+ 
+   tentry->mem = mem;
+   tentry->size = size;
+   tentry->func = tag;
+   tentry->flags = MT_ALLOC;
+   tentry->file = file;
+   tentry->line = line;
+   tentry->nalloc++;
+ }
+ 
+ void
+ mregister_free (mem, size, file, line)
+      PTR_T mem;
+      int size;
+      const char *file;
+      int line;
+ {
+   mr_table_t *tentry;
+ 
+   tentry = find_entry (mem, FIND_EXIST);
+   if (tentry == 0)
+     {
+       /* oops.  not found. */
+       fprintf (stderr, "register_free: %p not in allocation table?\n", mem);
+       return;
+     }
+   if (tentry->flags & MT_FREE)
+     {
+       /* oops.  bad bookkeeping. ignore for now */
+       fprintf (stderr, "register_free: %p already in table as free?\n", mem);
+     }
+     	
+   tentry->flags = MT_FREE;
+   tentry->func = "free";
+   tentry->file = file;
+   tentry->line = line;
+   tentry->nfree++;
+ }
+ 
+ /* If we ever add more flags, this will require changes. */
+ static char *
+ _entry_flags(x)
+      int x;
+ {
+   if (x & MT_FREE)
+     return "free";
+   else if (x & MT_ALLOC)
+     return "allocated";
+   else
+     return "undetermined?";
+ }
+ 
+ static void
+ _register_dump_table(fp)
+      FILE *fp;
+ {
+   register int i;
+   mr_table_t entry;
+ 
+   for (i = 0; i < REG_TABLE_SIZE; i++)
+     {
+       entry = mem_table[i];
+       if (entry.mem)
+ 	fprintf (fp, "[%d] %p:%d:%s:%s:%s:%d:%d:%d\n", i,
+ 						entry.mem, entry.size,
+ 						_entry_flags(entry.flags),
+ 						entry.func ? entry.func : "unknown",
+ 						entry.file ? entry.file : "unknown",
+ 						entry.line,
+ 						entry.nalloc, entry.nfree);
+     }
+ }
+  
+ void
+ mregister_dump_table()
+ {
+   _register_dump_table (stderr);
+ }
+ 
+ void
+ mregister_table_init ()
+ {
+   memset (mem_table, 0, sizeof(mr_table_t) * REG_TABLE_SIZE);
+   table_count = 0;
+ }
+ 
+ #endif /* MALLOC_REGISTER */
+ 
+ int
+ malloc_set_register(n)
+      int n;
+ {
+   int old;
+ 
+   old = malloc_register;
+   malloc_register = n;
+   return old;
+ }
diff -Nrc2 bash-2.05/lib/malloc/table.h bash-2.05a/lib/malloc/table.h
*** bash-2.05/lib/malloc/table.h	Wed Dec 31 19:00:00 1969
--- bash-2.05a/lib/malloc/table.h	Thu Oct  4 08:12:14 2001
***************
*** 0 ****
--- 1,103 ----
+ /* table.h - definitions for tables for keeping track of allocated memory */
+ 
+ /*  Copyright (C) 2001 Free Software Foundation, Inc.
+ 
+     This program is free software; you can redistribute it and/or modify
+     it under the terms of the GNU General Public License as published by
+     the Free Software Foundation; either version 2, or (at your option)
+     any later version.
+ 
+     This program is distributed in the hope that it will be useful,
+     but WITHOUT ANY WARRANTY; without even the implied warranty of
+     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+     GNU General Public License for more details.
+ 
+     You should have received a copy of the GNU General Public License
+     along with this program; if not, write to the Free Software
+     Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111 USA. */
+ 
+ #ifndef _MTABLE_H
+ #define _MTABLE_H
+ 
+ #include "imalloc.h"
+ 
+ #ifdef MALLOC_REGISTER
+ 
+ /* values for flags byte. */
+ #define MT_ALLOC	0x01
+ #define MT_FREE		0x02
+ 
+ /*
+  * Memory table entry.
+  *
+  * MEM is the address of the allocated pointer.
+  * SIZE is the requested allocation size.
+  * FLAGS includes either MT_ALLOC (MEM is allocated) or MT_FREE (MEM is
+  * not allocated).  Other flags later.
+  * FUNC is set to the name of the function doing the allocation (from the
+  * `tag' argument to register_alloc().
+  * FILE and LINE are the filename and line number of the last allocation
+  * and free (depending on STATUS) of MEM.
+  * NALLOC and NFREE are incremented on each allocation that returns MEM or
+  * each free of MEM, respectively (way to keep track of memory reuse
+  * and how well the free lists are working).
+  *
+  */
+ typedef struct mr_table {
+ 	PTR_T mem;
+ 	size_t size;
+ 	char flags;
+ 	const char *func;
+ 	const char *file;
+ 	int line;
+ 	int nalloc, nfree;
+ } mr_table_t;
+ 
+ #define REG_TABLE_SIZE	8192
+ 
+ extern mr_table_t *mr_table_entry ();
+ extern void mregister_alloc ();
+ extern void mregister_free ();
+ extern void mregister_describe_mem ();
+ extern void mregister_dump_table ();
+ extern void mregister_table_init ();
+ 
+ /* NOTE:  HASH_MIX taken from dmalloc (http://dmalloc.com) */
+ 
+ /*
+  * void HASH_MIX
+  *
+  * DESCRIPTION:
+  *
+  * Mix 3 32-bit values reversibly.  For every delta with one or two
+  * bits set, and the deltas of all three high bits or all three low
+  * bits, whether the original value of a,b,c is almost all zero or is
+  * uniformly distributed.
+  *
+  * If HASH_MIX() is run forward or backward, at least 32 bits in a,b,c
+  * have at least 1/4 probability of changing.  If mix() is run
+  * forward, every bit of c will change between 1/3 and 2/3 of the
+  * time.  (Well, 22/100 and 78/100 for some 2-bit deltas.)
+  *
+  * HASH_MIX() takes 36 machine instructions, but only 18 cycles on a
+  * superscalar machine (like a Pentium or a Sparc).  No faster mixer
+  * seems to work, that's the result of my brute-force search.  There
+  * were about 2^68 hashes to choose from.  I only tested about a
+  * billion of those.
+  */
+ #define HASH_MIX(a, b, c) \
+  do { \
+    a -= b; a -= c; a ^= (c >> 13); \
+    b -= c; b -= a; b ^= (a << 8); \
+    c -= a; c -= b; c ^= (b >> 13); \
+    a -= b; a -= c; a ^= (c >> 12); \
+    b -= c; b -= a; b ^= (a << 16); \
+    c -= a; c -= b; c ^= (b >> 5); \
+    a -= b; a -= c; a ^= (c >> 3); \
+    b -= c; b -= a; b ^= (a << 10); \
+    c -= a; c -= b; c ^= (b >> 15); \
+  } while(0)
+ 
+ #endif /* MALLOC_REGISTER */
+ 
+ #endif /* _MTABLE_H */
diff -Nrc2 bash-2.05/lib/malloc/trace.c bash-2.05a/lib/malloc/trace.c
*** bash-2.05/lib/malloc/trace.c	Wed Dec 31 19:00:00 1969
--- bash-2.05a/lib/malloc/trace.c	Wed Oct 10 11:45:45 2001
***************
*** 0 ****
--- 1,93 ----
+ /* trace.c - tracing functions for malloc */
+ 
+ /* Copyright (C) 2001 Free Software Foundation, Inc.
+ 
+    This file is part of GNU Bash, the Bourne Again SHell.
+ 
+    Bash is free software; you can redistribute it and/or modify it under
+    the terms of the GNU General Public License as published by the Free
+    Software Foundation; either version 2, or (at your option) any later
+    version.
+ 
+    Bash is distributed in the hope that it will be useful, but WITHOUT ANY
+    WARRANTY; without even the implied warranty of MERCHANTABILITY or
+    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+    for more details.
+ 
+    You should have received a copy of the GNU General Public License along
+    with Bash; see the file COPYING.  If not, write to the Free Software
+    Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. */
+ #ifdef HAVE_CONFIG_H
+ #  include <config.h>
+ #endif
+ 
+ #include <stdio.h>
+ 
+ #include "imalloc.h"
+ 
+ extern int malloc_trace;
+ 
+ static int _mtrace_verbose = 0;
+ 
+ #ifdef MALLOC_TRACE
+ 
+ FILE *_mtrace_fp = NULL;
+ 
+ void
+ mtrace_alloc (tag, mem, size, file, line)
+      const char *tag;
+      PTR_T mem;
+      size_t size;
+      const char *file;
+      int line;
+ {
+   if (_mtrace_fp == NULL)
+     _mtrace_fp = stderr;
+ 
+   if (_mtrace_verbose)
+     fprintf (_mtrace_fp, "alloc: %s: %p (%d bytes) from '%s:%d'\n",
+ 		tag, mem, size, file ? file : "unknown", line);
+   else
+     fprintf (_mtrace_fp, "alloc:%p:%d:%s:%d\n",
+ 		mem, size, file ? file : "unknown", line);
+ }
+ 
+ void
+ mtrace_free (mem, size, file, line)
+      PTR_T mem;
+      int size;
+      const char *file;
+      int line;
+ {
+   if (_mtrace_fp == NULL)
+     _mtrace_fp = stderr;
+ 
+   if (_mtrace_verbose)
+     fprintf (_mtrace_fp, "free: %p (%d bytes) from '%s:%d'\n",
+ 		mem, size, file ? file : "unknown", line);
+   else
+     fprintf (_mtrace_fp, "free:%p:%d:%s:%d\n",
+ 		mem, size, file ? file : "unknown", line);
+ }
+ #endif /* MALLOC_TRACE */
+ 
+ int
+ malloc_set_trace(n)
+      int n;
+ {
+   int old;
+ 
+   old = malloc_trace;
+   malloc_trace = n;
+   _mtrace_verbose = (n > 1);
+   return old;
+ }
+ 
+ void
+ malloc_set_tracefp(fp)
+      FILE *fp;
+ {
+ #ifdef MALLOC_TRACE
+   _mtrace_fp = fp ? fp : stderr;
+ #endif
+ }
diff -Nrc2 bash-2.05/lib/malloc/xleaktrace bash-2.05a/lib/malloc/xleaktrace
*** bash-2.05/lib/malloc/xleaktrace	Wed Dec 31 19:00:00 1969
--- bash-2.05a/lib/malloc/xleaktrace	Thu Sep 27 14:13:05 2001
***************
*** 0 ****
--- 1,43 ----
+ #! /usr/bin/awk -f
+ #
+ # xleaktrace - print unfreed memory using input generated by compact malloc
+ #	       tracing (malloc_set_trace(1))
+ #
+ # NOTE: we ignore `realloc' tags because they're just extra information
+ #
+ # Chet Ramey
+ # chet@po.cwru.edu
+ #
+ BEGIN {
+ 	FS=":";
+ }
+ 
+ $1 == "alloc"	{
+ 			alloc[$2] = 1;
+ 
+ 			size[$2] = $3;
+ 			file[$2] = $4;
+ 			line[$2] = $5;
+ 
+ #			printf "allocated: %s %d %d %s %d\n", $2, alloc[$2], size[$2], file[$2], line[$2];
+ 		}
+ 
+ $1 == "free"	{
+ 			if ($2 in alloc) {
+ 				alloc[$2] = 0;
+ #				printf "freed: %s %d\n", $2, alloc[$2];
+ 			} else
+ 				printf "freeing unallocated pointer: %s\n", $2;
+ 				
+ 		}
+ 
+ END {
+ 	printf "unfreed memory\n";
+ 	for (ptr in alloc) {
+ 		if (alloc[ptr] == 1) {
+ 			printf "%s (%d) from %s:%d\n", ptr, size[ptr], file[ptr], line[ptr];
+ 		}
+ 	}
+ }
+ 	
+ 	
diff -Nrc2 bash-2.05/lib/malloc/xmalloc.c bash-2.05a/lib/malloc/xmalloc.c
*** bash-2.05/lib/malloc/xmalloc.c	Thu Aug  5 07:59:39 1999
--- bash-2.05a/lib/malloc/xmalloc.c	Thu Sep 27 12:43:41 2001
***************
*** 32,36 ****
  #endif /* HAVE_STDLIB_H */
  
! static void memory_error_and_abort ();
  
  /* **************************************************************** */
--- 32,45 ----
  #endif /* HAVE_STDLIB_H */
  
! /* Generic pointer type. */
! #ifndef PTR_T
! 
! #if defined (__STDC__)
! #  define PTR_T void *
! #else
! #  define PTR_T char *
! #endif
! 
! #endif /* PTR_T */
  
  /* **************************************************************** */
***************
*** 40,53 ****
  /* **************************************************************** */
  
  /* Return a pointer to free()able block of memory large enough
     to hold BYTES number of bytes.  If the memory cannot be allocated,
     print an error message and abort. */
! char *
  xmalloc (bytes)
!      int bytes;
  {
!   char *temp;
  
!   temp = (char *)malloc (bytes);
    if (temp == 0)
      memory_error_and_abort ("xmalloc");
--- 49,70 ----
  /* **************************************************************** */
  
+ static void
+ memory_error_and_abort (fname)
+      char *fname;
+ {
+   fprintf (stderr, "%s: out of virtual memory\n", fname);
+   exit (2);
+ }
+ 
  /* Return a pointer to free()able block of memory large enough
     to hold BYTES number of bytes.  If the memory cannot be allocated,
     print an error message and abort. */
! PTR_T
  xmalloc (bytes)
!      size_t bytes;
  {
!   PTR_T temp;
  
!   temp = malloc (bytes);
    if (temp == 0)
      memory_error_and_abort ("xmalloc");
***************
*** 55,66 ****
  }
  
! char *
  xrealloc (pointer, bytes)
!      char *pointer;
!      int bytes;
  {
!   char *temp;
  
!   temp = pointer ? (char *)realloc (pointer, bytes) : (char *)malloc (bytes);
  
    if (temp == 0)
--- 72,83 ----
  }
  
! PTR_T
  xrealloc (pointer, bytes)
!      PTR_T pointer;
!      size_t bytes;
  {
!   PTR_T temp;
  
!   temp = pointer ? realloc (pointer, bytes) : malloc (bytes);
  
    if (temp == 0)
***************
*** 69,85 ****
  }
  
- static void
- memory_error_and_abort (fname)
-      char *fname;
- {
-   fprintf (stderr, "%s: out of virtual memory\n", fname);
-   exit (2);
- }
- 
- /* Use this as the function to call when adding unwind protects so we
-    don't need to know what free() returns. */
  void
  xfree (string)
!      char *string;
  {
    if (string)
--- 86,92 ----
  }
  
  void
  xfree (string)
!      PTR_T string;
  {
    if (string)
diff -Nrc2 bash-2.05/lib/readline/Makefile.in bash-2.05a/lib/readline/Makefile.in
*** bash-2.05/lib/readline/Makefile.in	Mon Nov 27 12:09:48 2000
--- bash-2.05a/lib/readline/Makefile.in	Mon Sep 10 10:04:57 2001
***************
*** 122,125 ****
--- 122,131 ----
  	-( cd doc && $(MAKE) $(MFLAGS) )
  
+ # Since tilde.c is shared between readline and bash, make sure we compile
+ # it with the right flags when it's built as part of readline
+ tilde.o:	tilde.c
+ 	rm -f $@
+ 	$(CC) $(CCFLAGS) -DREADLINE_LIBRARY -c $(srcdir)/tilde.c
+ 
  force:
  
***************
*** 153,157 ****
  bind.o: readline.h keymaps.h rltypedefs.h chardefs.h tilde.h
  bind.o: history.h rlstdc.h
! callback.o: rlconf.h
  callback.o: rldefs.h ${BUILD_DIR}/config.h rlconf.h
  callback.o: readline.h keymaps.h rltypedefs.h chardefs.h tilde.h rlstdc.h
--- 159,163 ----
  bind.o: readline.h keymaps.h rltypedefs.h chardefs.h tilde.h
  bind.o: history.h rlstdc.h
! callback.o: rlconf.h ansi_stdlib.h
  callback.o: rldefs.h ${BUILD_DIR}/config.h rlconf.h
  callback.o: readline.h keymaps.h rltypedefs.h chardefs.h tilde.h rlstdc.h
***************
*** 229,233 ****
  undo.o: rldefs.h ${BUILD_DIR}/config.h rlconf.h
  undo.o: readline.h keymaps.h rltypedefs.h chardefs.h tilde.h
! undo.o: history.h rlstdc.h
  util.o: posixjmp.h ansi_stdlib.h
  util.o: rldefs.h ${BUILD_DIR}/config.h rlconf.h
--- 235,239 ----
  undo.o: rldefs.h ${BUILD_DIR}/config.h rlconf.h
  undo.o: readline.h keymaps.h rltypedefs.h chardefs.h tilde.h
! undo.o: history.h rlstdc.h xmalloc.h
  util.o: posixjmp.h ansi_stdlib.h
  util.o: rldefs.h ${BUILD_DIR}/config.h rlconf.h
diff -Nrc2 bash-2.05/lib/readline/ansi_stdlib.h bash-2.05a/lib/readline/ansi_stdlib.h
*** bash-2.05/lib/readline/ansi_stdlib.h	Thu Sep  7 12:07:49 2000
--- bash-2.05a/lib/readline/ansi_stdlib.h	Wed Oct 17 16:08:40 2001
***************
*** 26,30 ****
  /* String conversion functions. */
  extern int atoi ();
- extern long int atol ();
  
  extern double atof ();
--- 26,29 ----
***************
*** 32,37 ****
  
  /* Memory allocation functions. */
! extern char *malloc ();
! extern char *realloc ();
  extern void free ();
  
--- 31,47 ----
  
  /* Memory allocation functions. */
! /* Generic pointer type. */
! #ifndef PTR_T
! 
! #if defined (__STDC__)
! #  define PTR_T	void *
! #else
! #  define PTR_T char *
! #endif
! 
! #endif /* PTR_T */
! 
! extern PTR_T malloc ();
! extern PTR_T realloc ();
  extern void free ();
  
diff -Nrc2 bash-2.05/lib/readline/bind.c bash-2.05a/lib/readline/bind.c
*** bash-2.05/lib/readline/bind.c	Mon Mar  5 10:10:07 2001
--- bash-2.05a/lib/readline/bind.c	Mon Oct 15 14:30:43 2001
***************
*** 69,75 ****
  Keymap rl_binding_keymap;
  
! static int _rl_read_init_file __P((const char *, int));
! static int glean_key_from_name __P((char *));
! static int substring_member_of_array __P((char *, const char **));
  
  static int currently_reading_init_file;
--- 69,75 ----
  Keymap rl_binding_keymap;
  
! static int _rl_read_init_file PARAMS((const char *, int));
! static int glean_key_from_name PARAMS((char *));
! static int substring_member_of_array PARAMS((char *, const char **));
  
  static int currently_reading_init_file;
***************
*** 256,260 ****
      }
  
!   keys = xmalloc (1 + (2 * strlen (keyseq)));
  
    /* Translate the ASCII representation of KEYSEQ into an array of
--- 256,260 ----
      }
  
!   keys = (char *)xmalloc (1 + (2 * strlen (keyseq)));
  
    /* Translate the ASCII representation of KEYSEQ into an array of
***************
*** 270,274 ****
    for (i = 0; i < keys_len; i++)
      {
!       int ic = (int) ((unsigned char)keys[i]);
  
        if (_rl_convert_meta_chars_to_ascii && META_CHAR (ic))
--- 270,274 ----
    for (i = 0; i < keys_len; i++)
      {
!       unsigned char ic = keys[i];
  
        if (_rl_convert_meta_chars_to_ascii && META_CHAR (ic))
***************
*** 394,407 ****
  	        c = (c * 8) + OCTVALUE (seq[i]);
  	      i--;	/* auto-increment in for loop */
! 	      array[l++] = c % (largest_char + 1);
  	      break;
  	    case 'x':
  	      i++;
! 	      for (temp = 3, c = 0; isxdigit (seq[i]) && temp--; i++)
  	        c = (c * 16) + HEXVALUE (seq[i]);
! 	      if (temp == 3)
  	        c = 'x';
  	      i--;	/* auto-increment in for loop */
! 	      array[l++] = c % (largest_char + 1);
  	      break;
  	    default:	/* backslashes before non-special chars just add the char */
--- 394,407 ----
  	        c = (c * 8) + OCTVALUE (seq[i]);
  	      i--;	/* auto-increment in for loop */
! 	      array[l++] = c & largest_char;
  	      break;
  	    case 'x':
  	      i++;
! 	      for (temp = 2, c = 0; ISXDIGIT ((unsigned char)seq[i]) && temp--; i++)
  	        c = (c * 16) + HEXVALUE (seq[i]);
! 	      if (temp == 2)
  	        c = 'x';
  	      i--;	/* auto-increment in for loop */
! 	      array[l++] = c & largest_char;
  	      break;
  	    default:	/* backslashes before non-special chars just add the char */
***************
*** 473,477 ****
    int c;
  
!   r = ret = xmalloc (7 * strlen (seq) + 1);
    for (s = seq; *s; s++)
      {
--- 473,477 ----
    int c;
  
!   r = ret = (char *)xmalloc (7 * strlen (seq) + 1);
    for (s = seq; *s; s++)
      {
***************
*** 548,552 ****
    for (i = 0; keyseq && keyseq[i]; i++)
      {
!       int ic = keyseq[i];
  
        if (META_CHAR (ic) && _rl_convert_meta_chars_to_ascii)
--- 548,552 ----
    for (i = 0; keyseq && keyseq[i]; i++)
      {
!       unsigned char ic = keyseq[i];
  
        if (META_CHAR (ic) && _rl_convert_meta_chars_to_ascii)
***************
*** 783,787 ****
  /* **************************************************************** */
  
! typedef int _rl_parser_func_t __P((char *));
  
  /* Things that mean `Control'. */
--- 783,787 ----
  /* **************************************************************** */
  
! typedef int _rl_parser_func_t PARAMS((char *));
  
  /* Things that mean `Control'. */
***************
*** 1146,1150 ****
        register int j, k, passc;
  
!       seq = xmalloc (1 + strlen (string));
        for (j = 1, k = passc = 0; string[j]; j++)
  	{
--- 1146,1150 ----
        register int j, k, passc;
  
!       seq = (char *)xmalloc (1 + strlen (string));
        for (j = 1, k = passc = 0; string[j]; j++)
  	{
***************
*** 1204,1208 ****
    if (*funname == '\'' || *funname == '"')
      {
!       unsigned char useq[2];
        int fl = strlen (funname);
  
--- 1204,1208 ----
    if (*funname == '\'' || *funname == '"')
      {
!       char useq[2];
        int fl = strlen (funname);
  
***************
*** 1246,1253 ****
--- 1246,1255 ----
    { "enable-keypad",		&_rl_enable_keypad,		0 },
    { "expand-tilde",		&rl_complete_with_tilde_expansion, 0 },
+   { "history-preserve-point",	&_rl_history_preserve_point,	0 },
    { "horizontal-scroll-mode",	&_rl_horizontal_scroll_mode,	0 },
    { "input-meta",		&_rl_meta_flag,			0 },
    { "mark-directories",		&_rl_complete_mark_directories,	0 },
    { "mark-modified-lines",	&_rl_mark_modified_lines,	0 },
+   { "match-hidden-files",	&_rl_match_hidden_files,	0 },
    { "meta-flag",		&_rl_meta_flag,			0 },
    { "output-meta",		&_rl_output_meta_chars,		0 },
***************
*** 1295,1299 ****
  }
  
! typedef int _rl_sv_func_t __P((const char *));
  
  /* These *must* correspond to the array indices for the appropriate
--- 1297,1301 ----
  }
  
! typedef int _rl_sv_func_t PARAMS((const char *));
  
  /* These *must* correspond to the array indices for the appropriate
***************
*** 1309,1318 ****
  
  /* Forward declarations */
! static int sv_bell_style __P((const char *));
! static int sv_combegin __P((const char *));
! static int sv_compquery __P((const char *));
! static int sv_editmode __P((const char *));
! static int sv_isrchterm __P((const char *));
! static int sv_keymap __P((const char *));
  
  static struct {
--- 1311,1320 ----
  
  /* Forward declarations */
! static int sv_bell_style PARAMS((const char *));
! static int sv_combegin PARAMS((const char *));
! static int sv_compquery PARAMS((const char *));
! static int sv_editmode PARAMS((const char *));
! static int sv_isrchterm PARAMS((const char *));
! static int sv_keymap PARAMS((const char *));
  
  static struct {
***************
*** 1447,1452 ****
  }
  
- #define _SET_BELL(v)	do { _rl_bell_preference = v; return 0; } while (0)
- 
  static int
  sv_bell_style (value)
--- 1449,1452 ----
***************
*** 1454,1468 ****
  {
    if (value == 0 || *value == '\0')
!     _SET_BELL (AUDIBLE_BELL);
    else if (_rl_stricmp (value, "none") == 0 || _rl_stricmp (value, "off") == 0)
!     _SET_BELL (NO_BELL);
    else if (_rl_stricmp (value, "audible") == 0 || _rl_stricmp (value, "on") == 0)
!     _SET_BELL (AUDIBLE_BELL);
    else if (_rl_stricmp (value, "visible") == 0)
!     _SET_BELL (VISIBLE_BELL);
    else
      return 1;
  }
- #undef _SET_BELL
  
  static int
--- 1454,1468 ----
  {
    if (value == 0 || *value == '\0')
!     _rl_bell_preference = AUDIBLE_BELL;
    else if (_rl_stricmp (value, "none") == 0 || _rl_stricmp (value, "off") == 0)
!     _rl_bell_preference = NO_BELL;
    else if (_rl_stricmp (value, "audible") == 0 || _rl_stricmp (value, "on") == 0)
!     _rl_bell_preference = AUDIBLE_BELL;
    else if (_rl_stricmp (value, "visible") == 0)
!     _rl_bell_preference = VISIBLE_BELL;
    else
      return 1;
+   return 0;
  }
  
  static int
***************
*** 1494,1498 ****
  
    /* The value starts at v + beg.  Translate it into a character string. */
!   _rl_isearch_terminators = (unsigned char *)xmalloc (2 * strlen (v) + 1);
    rl_translate_keyseq (v + beg, _rl_isearch_terminators, &end);
    _rl_isearch_terminators[end] = '\0';
--- 1494,1498 ----
  
    /* The value starts at v + beg.  Translate it into a character string. */
!   _rl_isearch_terminators = (char *)xmalloc (2 * strlen (v) + 1);
    rl_translate_keyseq (v + beg, _rl_isearch_terminators, &end);
    _rl_isearch_terminators[end] = '\0';
***************
*** 1752,1756 ****
  	        {
  	          result_size += 10;
! 		  result = (char **) xrealloc (result, result_size * sizeof (char *));
  	        }
  
--- 1752,1756 ----
  	        {
  	          result_size += 10;
! 		  result = (char **)xrealloc (result, result_size * sizeof (char *));
  	        }
  
***************
*** 1804,1808 ****
  		  {
  		    result_size += 10;
! 		    result = (char **) xrealloc (result, result_size * sizeof (char *));
  		  }
  
--- 1804,1808 ----
  		  {
  		    result_size += 10;
! 		    result = (char **)xrealloc (result, result_size * sizeof (char *));
  		  }
  
***************
*** 1952,1956 ****
  	  if (key == ESC)
  	    {
! 	      keyname = xmalloc (3 + prefix_len);
  	      if (prefix)
  		strcpy (keyname, prefix);
--- 1952,1956 ----
  	  if (key == ESC)
  	    {
! 	      keyname = (char *)xmalloc (3 + prefix_len);
  	      if (prefix)
  		strcpy (keyname, prefix);
***************
*** 1964,1968 ****
  	      if (prefix)
  		{
! 		  out = xmalloc (strlen (keyname) + prefix_len + 1);
  		  strcpy (out, prefix);
  		  strcpy (out + prefix_len, keyname);
--- 1964,1968 ----
  	      if (prefix)
  		{
! 		  out = (char *)xmalloc (strlen (keyname) + prefix_len + 1);
  		  strcpy (out, prefix);
  		  strcpy (out + prefix_len, keyname);
diff -Nrc2 bash-2.05/lib/readline/callback.c bash-2.05a/lib/readline/callback.c
*** bash-2.05/lib/readline/callback.c	Tue Dec 12 14:48:21 2000
--- bash-2.05a/lib/readline/callback.c	Mon Sep 10 10:05:28 2001
***************
*** 31,34 ****
--- 31,41 ----
  
  #include <sys/types.h>
+ 
+ #ifdef HAVE_STDLIB_H
+ #  include <stdlib.h>
+ #else
+ #  include "ansi_stdlib.h"
+ #endif
+ 
  #include <stdio.h>
  
diff -Nrc2 bash-2.05/lib/readline/chardefs.h bash-2.05a/lib/readline/chardefs.h
*** bash-2.05/lib/readline/chardefs.h	Wed Sep 13 17:20:15 2000
--- bash-2.05a/lib/readline/chardefs.h	Thu Nov  8 08:17:21 2001
***************
*** 28,35 ****
  #if defined (HAVE_CONFIG_H)
  #  if defined (HAVE_STRING_H)
  #    include <string.h>
- #  else
- #    include <strings.h>
  #  endif /* HAVE_STRING_H */
  #else
  #  include <string.h>
--- 28,39 ----
  #if defined (HAVE_CONFIG_H)
  #  if defined (HAVE_STRING_H)
+ #    if ! defined (STDC_HEADERS) && defined (HAVE_MEMORY_H)
+ #      include <memory.h>
+ #    endif
  #    include <string.h>
  #  endif /* HAVE_STRING_H */
+ #  if defined (HAVE_STRINGS_H)
+ #    include <strings.h>
+ #  endif /* HAVE_STRINGS_H */
  #else
  #  include <string.h>
***************
*** 61,91 ****
  #define UNCTRL(c) _rl_to_upper(((c)|control_character_bit))
  
! /* Old versions
! #define _rl_lowercase_p(c) (((c) > ('a' - 1) && (c) < ('z' + 1)))
! #define _rl_uppercase_p(c) (((c) > ('A' - 1) && (c) < ('Z' + 1)))
! #define _rl_digit_p(c)  ((c) >= '0' && (c) <= '9')
! */
! 
! #define _rl_lowercase_p(c) (islower(c))
! #define _rl_uppercase_p(c) (isupper(c))
! #define _rl_digit_p(x)  (isdigit (x))
! 
! #define _rl_pure_alphabetic(c) (_rl_lowercase_p(c) || _rl_uppercase_p(c))
! #define ALPHABETIC(c)	(_rl_lowercase_p(c) || _rl_uppercase_p(c) || _rl_digit_p(c))
! 
! /* Old versions
! #  define _rl_to_upper(c) (_rl_lowercase_p(c) ? ((c) - 32) : (c))
! #  define _rl_to_lower(c) (_rl_uppercase_p(c) ? ((c) + 32) : (c))
! */
  
  #ifndef _rl_to_upper
! #  define _rl_to_upper(c) (islower(c) ? toupper(c) : (c))
! #  define _rl_to_lower(c) (isupper(c) ? tolower(c) : (c))
  #endif
  
  #ifndef _rl_digit_value
! #define _rl_digit_value(x) ((x) - '0')
  #endif
  
  #ifndef NEWLINE
  #define NEWLINE '\n'
--- 65,118 ----
  #define UNCTRL(c) _rl_to_upper(((c)|control_character_bit))
  
! #if defined STDC_HEADERS || (!defined (isascii) && !defined (HAVE_ISASCII))
! #  define IN_CTYPE_DOMAIN(c) 1
! #else
! #  define IN_CTYPE_DOMAIN(c) isascii(c)
! #endif
! 
! #if !defined (isxdigit) && !defined (HAVE_ISXDIGIT)
! #  define isxdigit(c)   (isdigit((c)) || ((c) >= 'a' && (c) <= 'f') || ((c) >= 'A' && (c) <= 'F'))
! #endif
! 
! #define NON_NEGATIVE(c)	((unsigned char)(c) == (c))
! 
! #define ISALNUM(c)	(IN_CTYPE_DOMAIN (c) && isalnum (c))
! #define ISALPHA(c)	(IN_CTYPE_DOMAIN (c) && isalpha (c))
! #define ISDIGIT(c)	(IN_CTYPE_DOMAIN (c) && isdigit (c))
! #define ISLOWER(c)	(IN_CTYPE_DOMAIN (c) && islower (c))
! #define ISPRINT(c)	(IN_CTYPE_DOMAIN (c) && isprint (c))
! #define ISUPPER(c)	(IN_CTYPE_DOMAIN (c) && isupper (c))
! #define ISXDIGIT(c)	(IN_CTYPE_DOMAIN (c) && isxdigit (c))
! 
! #define _rl_lowercase_p(c)	(NON_NEGATIVE(c) && ISLOWER(c))
! #define _rl_uppercase_p(c)	(NON_NEGATIVE(c) && ISUPPER(c))
! #define _rl_digit_p(c)		((c) >= '0' && (c) <= '9')
! 
! #define _rl_pure_alphabetic(c)	(NON_NEGATIVE(c) && ISALPHA(c))
! #define ALPHABETIC(c)		(NON_NEGATIVE(c) && ISALNUM(c))
  
  #ifndef _rl_to_upper
! #  define _rl_to_upper(c) (_rl_lowercase_p(c) ? toupper((unsigned char)c) : (c))
! #  define _rl_to_lower(c) (_rl_uppercase_p(c) ? tolower((unsigned char)c) : (c))
  #endif
  
  #ifndef _rl_digit_value
! #  define _rl_digit_value(x) ((x) - '0')
! #endif
! 
! #ifndef _rl_isident
! #  define _rl_isident(c) (ISALNUM(c) || (c) == '_')
  #endif
  
+ #ifndef ISOCTAL
+ #  define ISOCTAL(c)	((c) >= '0' && (c) <= '7')
+ #endif
+ #define OCTVALUE(c)	((c) - '0')
+ 
+ #define HEXVALUE(c) \
+   (((c) >= 'a' && (c) <= 'f') \
+   	? (c)-'a'+10 \
+   	: (c) >= 'A' && (c) <= 'F' ? (c)-'A'+10 : (c)-'0')
+ 
  #ifndef NEWLINE
  #define NEWLINE '\n'
***************
*** 123,140 ****
  #endif
  #define ESC CTRL('[')
- 
- #ifndef ISOCTAL
- #define ISOCTAL(c)      ((c) >= '0' && (c) <= '7')
- #endif
- #define OCTVALUE(c)     ((c) - '0')
- 
- #ifndef isxdigit
- #  define isxdigit(c)   (isdigit((c)) || ((c) >= 'a' && (c) <= 'f') || ((c) >= 'A' && (c) <= 'F'))
- #endif
- 
- #define HEXVALUE(c) \
-   (((c) >= 'a' && (c) <= 'f') \
-   	? (c)-'a'+10 \
-   	: (c) >= 'A' && (c) <= 'F' ? (c)-'A'+10 : (c)-'0')
  
  #endif  /* _CHARDEFS_H_ */
--- 150,153 ----
diff -Nrc2 bash-2.05/lib/readline/compat.c bash-2.05a/lib/readline/compat.c
*** bash-2.05/lib/readline/compat.c	Tue Feb  6 14:15:13 2001
--- bash-2.05a/lib/readline/compat.c	Wed Aug 22 09:38:45 2001
***************
*** 31,46 ****
  #include "rltypedefs.h"
  
! extern void rl_free_undo_list __P((void));
! extern int rl_maybe_save_line __P((void));
! extern int rl_maybe_unsave_line __P((void));
! extern int rl_maybe_replace_line __P((void));
  
! extern int rl_crlf __P((void));
! extern int rl_ding __P((void));
! extern int rl_alphabetic __P((int));
  
! extern char **rl_completion_matches __P((const char *, rl_compentry_func_t *));
! extern char *rl_username_completion_function __P((const char *, int));
! extern char *rl_filename_completion_function __P((const char *, int));
  
  /* Provide backwards-compatible entry points for old function names. */
--- 31,46 ----
  #include "rltypedefs.h"
  
! extern void rl_free_undo_list PARAMS((void));
! extern int rl_maybe_save_line PARAMS((void));
! extern int rl_maybe_unsave_line PARAMS((void));
! extern int rl_maybe_replace_line PARAMS((void));
  
! extern int rl_crlf PARAMS((void));
! extern int rl_ding PARAMS((void));
! extern int rl_alphabetic PARAMS((int));
  
! extern char **rl_completion_matches PARAMS((const char *, rl_compentry_func_t *));
! extern char *rl_username_completion_function PARAMS((const char *, int));
! extern char *rl_filename_completion_function PARAMS((const char *, int));
  
  /* Provide backwards-compatible entry points for old function names. */
diff -Nrc2 bash-2.05/lib/readline/complete.c bash-2.05a/lib/readline/complete.c
*** bash-2.05/lib/readline/complete.c	Wed Feb 14 07:47:18 2001
--- bash-2.05a/lib/readline/complete.c	Mon Oct 15 14:31:41 2001
***************
*** 68,75 ****
  #endif
  
  /* Most systems don't declare getpwent in <pwd.h> if _POSIX_SOURCE is
     defined. */
  #if !defined (HAVE_GETPW_DECLS) || defined (_POSIX_SOURCE)
! extern struct passwd *getpwent __P((void));
  #endif /* !HAVE_GETPW_DECLS || _POSIX_SOURCE */
  
--- 68,84 ----
  #endif
  
+ #ifdef HAVE_LSTAT
+ #  define LSTAT lstat
+ #else
+ #  define LSTAT stat
+ #endif
+ 
+ /* Unix version of a hidden file.  Could be different on other systems. */
+ #define HIDDEN_FILE(fname)	((fname)[0] == '.')
+ 
  /* Most systems don't declare getpwent in <pwd.h> if _POSIX_SOURCE is
     defined. */
  #if !defined (HAVE_GETPW_DECLS) || defined (_POSIX_SOURCE)
! extern struct passwd *getpwent PARAMS((void));
  #endif /* !HAVE_GETPW_DECLS || _POSIX_SOURCE */
  
***************
*** 87,101 ****
  #    define X_OK 1
  #  endif
! static int stat_char __P((char *));
  #endif
  
! static char *rl_quote_filename __P((char *, int, char *));
  
! static char **remove_duplicate_matches __P((char **));
! static void insert_match __P((char *, int, int, char *));
! static int append_to_match __P((char *, int, int));
! static void insert_all_matches __P((char **, int, char *));
! static void display_matches __P((char **));
! static int compute_lcd_of_matches __P((char **, int, const char *));
  
  /* **************************************************************** */
--- 96,121 ----
  #    define X_OK 1
  #  endif
! static int stat_char PARAMS((char *));
  #endif
  
! static char *rl_quote_filename PARAMS((char *, int, char *));
! 
! static int get_y_or_n PARAMS((void));
! static char *printable_part PARAMS((char *));
! static int print_filename PARAMS((char *, char *));
! static char find_completion_word PARAMS((int *, int *));
! 
! static char **gen_completion_matches PARAMS((char *, int, int, rl_compentry_func_t *, int, int));
! 
! static char **remove_duplicate_matches PARAMS((char **));
! static void insert_match PARAMS((char *, int, int, char *));
! static int append_to_match PARAMS((char *, int, int, int));
! static void insert_all_matches PARAMS((char **, int, char *));
! static void display_matches PARAMS((char **));
! static int compute_lcd_of_matches PARAMS((char **, int, const char *));
! static int postprocess_matches PARAMS((char ***, int));
  
! static char *make_quoted_replacement PARAMS((char *, int, char *));
! static void free_match_list PARAMS((char **));
  
  /* **************************************************************** */
***************
*** 124,127 ****
--- 144,151 ----
  #endif
  
+ /* If non-zero, don't match hidden files (filenames beginning with a `.' on
+    Unix) when doing filename completion. */
+ int _rl_match_hidden_files = 1;
+ 
  /* Global variables available to applications using readline. */
  
***************
*** 388,392 ****
    temp = rl_filename_completion_desired ? strrchr (pathname, '/') : (char *)NULL;
  #if defined (__MSDOS__)
!   if (rl_filename_completion_desired && temp == 0 && isalpha (pathname[0]) && pathname[1] == ':')
      temp = pathname + 1;
  #endif
--- 412,416 ----
    temp = rl_filename_completion_desired ? strrchr (pathname, '/') : (char *)NULL;
  #if defined (__MSDOS__)
!   if (rl_filename_completion_desired && temp == 0 && ISALPHA ((unsigned char)pathname[0]) && pathname[1] == ':')
      temp = pathname + 1;
  #endif
***************
*** 462,466 ****
  	  slen = strlen (s);
  	  tlen = strlen (to_print);
! 	  new_full_pathname = xmalloc (slen + tlen + 2);
  	  strcpy (new_full_pathname, s);
  	  new_full_pathname[slen] = '/';
--- 486,490 ----
  	  slen = strlen (s);
  	  tlen = strlen (to_print);
! 	  new_full_pathname = (char *)xmalloc (slen + tlen + 2);
  	  strcpy (new_full_pathname, s);
  	  new_full_pathname[slen] = '/';
***************
*** 497,501 ****
    char *r;
  
!   r = xmalloc (strlen (s) + 2);
    *r = *rl_completer_quote_characters;
    strcpy (r + 1, s);
--- 521,525 ----
    char *r;
  
!   r = (char *)xmalloc (strlen (s) + 2);
    *r = *rl_completer_quote_characters;
    strcpy (r + 1, s);
***************
*** 508,512 ****
     rl_point set to the end of the word.  This function skips quoted
     substrings (characters between matched pairs of characters in
!    rl_completer_quote_characters.  First we try to find an unclosed
     quoted substring on which to do matching.  If one is not found, we use
     the word break characters to find the boundaries of the current word.
--- 532,536 ----
     rl_point set to the end of the word.  This function skips quoted
     substrings (characters between matched pairs of characters in
!    rl_completer_quote_characters).  First we try to find an unclosed
     quoted substring on which to do matching.  If one is not found, we use
     the word break characters to find the boundaries of the current word.
***************
*** 798,808 ****
    if (low == 0 && text && *text)
      {
!       match_list[0] = xmalloc (strlen (text) + 1);
        strcpy (match_list[0], text);
      }
    else
      {
!       match_list[0] = xmalloc (low + 1);
!       strncpy (match_list[0], match_list[1], low);
        match_list[0][low] = '\0';
      }
--- 822,859 ----
    if (low == 0 && text && *text)
      {
!       match_list[0] = (char *)xmalloc (strlen (text) + 1);
        strcpy (match_list[0], text);
      }
    else
      {
!       match_list[0] = (char *)xmalloc (low + 1);
! 
!       /* If we are ignoring case, try to preserve the case of the string
! 	 the user typed in the face of multiple matches differing in case. */
!       if (_rl_completion_case_fold)
! 	{
! 	  /* sort the list to get consistent answers. */
! 	  qsort (match_list+1, matches, sizeof(char *), (QSFUNC *)_rl_qsort_string_compare);
! 
! 	  si = strlen (text);
! 	  if (si <= low)
! 	    {
! 	      for (i = 1; i <= matches; i++)
! 		if (strncmp (match_list[i], text, si) == 0)
! 		  {
! 		    strncpy (match_list[0], match_list[i], low);
! 		    break;
! 		  }
! 	      /* no casematch, use first entry */
! 	      if (i > matches)
! 		strncpy (match_list[0], match_list[1], low);
! 	    }
! 	  else
! 	    /* otherwise, just use the text the user typed. */
! 	    strncpy (match_list[0], text, low);
! 	}
!       else
!         strncpy (match_list[0], match_list[1], low);
! 
        match_list[0][low] = '\0';
      }
***************
*** 1103,1114 ****
     should be marked by a trailing `/', append one of those instead.  The
     default trailing character is a space.  Returns the number of characters
!    appended. */
  static int
! append_to_match (text, delimiter, quote_char)
       char *text;
!      int delimiter, quote_char;
  {
    char temp_string[4], *filename;
!   int temp_string_index;
    struct stat finfo;
  
--- 1154,1167 ----
     should be marked by a trailing `/', append one of those instead.  The
     default trailing character is a space.  Returns the number of characters
!    appended.  If NONTRIVIAL_MATCH is set, we test for a symlink (if the OS
!    has them) and don't add a suffix for a symlink to a directory.  A
!    nontrivial match is one that actually adds to the word being completed.  */
  static int
! append_to_match (text, delimiter, quote_char, nontrivial_match)
       char *text;
!      int delimiter, quote_char, nontrivial_match;
  {
    char temp_string[4], *filename;
!   int temp_string_index, s;
    struct stat finfo;
  
***************
*** 1127,1135 ****
      {
        filename = tilde_expand (text);
!       if (stat (filename, &finfo) == 0 && S_ISDIR (finfo.st_mode))
  	{
  	  if (_rl_complete_mark_directories && rl_line_buffer[rl_point] != '/')
  	    rl_insert_text ("/");
  	}
        else
  	{
--- 1180,1196 ----
      {
        filename = tilde_expand (text);
!       s = nontrivial_match ? LSTAT (filename, &finfo) : stat (filename, &finfo);
!       if (s == 0 && S_ISDIR (finfo.st_mode))
  	{
  	  if (_rl_complete_mark_directories && rl_line_buffer[rl_point] != '/')
  	    rl_insert_text ("/");
  	}
+ #ifdef S_ISLNK
+       /* Don't add anything if the filename is a symlink and resolves to a
+ 	 directory. */
+       else if (s == 0 && S_ISLNK (finfo.st_mode) &&
+ 	       stat (filename, &finfo) == 0 && S_ISDIR (finfo.st_mode))
+ 	;
+ #endif
        else
  	{
***************
*** 1211,1215 ****
    char **matches;
    rl_compentry_func_t *our_func;
!   int start, end, delimiter, found_quote, i;
    char *text, *saved_line_buffer;
    char quote_char;
--- 1272,1276 ----
    char **matches;
    rl_compentry_func_t *our_func;
!   int start, end, delimiter, found_quote, i, nontrivial_lcd;
    char *text, *saved_line_buffer;
    char quote_char;
***************
*** 1241,1244 ****
--- 1302,1308 ----
    text = rl_copy_text (start, end);
    matches = gen_completion_matches (text, start, end, our_func, found_quote, quote_char);
+   /* nontrivial_lcd is set if the common prefix adds something to the word
+      being completed. */
+   nontrivial_lcd = matches && strcmp (text, matches[0]) != 0;
    free (text);
  
***************
*** 1292,1296 ****
  	}
        else
! 	append_to_match (matches[0], delimiter, quote_char);
  
        break;
--- 1356,1360 ----
  	}
        else
! 	append_to_match (matches[0], delimiter, quote_char, nontrivial_lcd);
  
        break;
***************
*** 1429,1433 ****
    else
      {
!       value = xmalloc (2 + strlen (entry->pw_name));
  
        *value = *text;
--- 1493,1497 ----
    else
      {
!       value = (char *)xmalloc (2 + strlen (entry->pw_name));
  
        *value = *text;
***************
*** 1484,1488 ****
  #if defined (__MSDOS__)
        /* special hack for //X/... */
!       if (dirname[0] == '/' && dirname[1] == '/' && isalpha (dirname[2]) && dirname[3] == '/')
          temp = strrchr (dirname + 3, '/');
  #endif
--- 1548,1552 ----
  #if defined (__MSDOS__)
        /* special hack for //X/... */
!       if (dirname[0] == '/' && dirname[1] == '/' && ISALPHA ((unsigned char)dirname[2]) && dirname[3] == '/')
          temp = strrchr (dirname + 3, '/');
  #endif
***************
*** 1495,1499 ****
  #if defined (__MSDOS__)
        /* searches from current directory on the drive */
!       else if (isalpha (dirname[0]) && dirname[1] == ':')
          {
            strcpy (filename, dirname + 2);
--- 1559,1563 ----
  #if defined (__MSDOS__)
        /* searches from current directory on the drive */
!       else if (ISALPHA ((unsigned char)dirname[0]) && dirname[1] == ':')
          {
            strcpy (filename, dirname + 2);
***************
*** 1545,1552 ****
    while (directory && (entry = readdir (directory)))
      {
!       /* Special case for no filename.
! 	 All entries except "." and ".." match. */
        if (filename_len == 0)
  	{
  	  if (entry->d_name[0] != '.' ||
  	       (entry->d_name[1] &&
--- 1609,1620 ----
    while (directory && (entry = readdir (directory)))
      {
!       /* Special case for no filename.  If the user has disabled the
!          `match-hidden-files' variable, skip filenames beginning with `.'.
! 	 All other entries except "." and ".." match. */
        if (filename_len == 0)
  	{
+ 	  if (_rl_match_hidden_files == 0 && HIDDEN_FILE (entry->d_name))
+ 	    continue;
+ 
  	  if (entry->d_name[0] != '.' ||
  	       (entry->d_name[1] &&
***************
*** 1608,1612 ****
  	    {
  	      dirlen = strlen (dirname);
! 	      temp = xmalloc (2 + dirlen + D_NAMLEN (entry));
  	      strcpy (temp, dirname);
  	      /* Canonicalization cuts off any final slash present.  We
--- 1676,1680 ----
  	    {
  	      dirlen = strlen (dirname);
! 	      temp = (char *)xmalloc (2 + dirlen + D_NAMLEN (entry));
  	      strcpy (temp, dirname);
  	      /* Canonicalization cuts off any final slash present.  We
***************
*** 1621,1625 ****
  	    {
  	      dirlen = strlen (users_dirname);
! 	      temp = xmalloc (2 + dirlen + D_NAMLEN (entry));
  	      strcpy (temp, users_dirname);
  	      /* Make sure that temp has a trailing slash here. */
--- 1689,1693 ----
  	    {
  	      dirlen = strlen (users_dirname);
! 	      temp = (char *)xmalloc (2 + dirlen + D_NAMLEN (entry));
  	      strcpy (temp, users_dirname);
  	      /* Make sure that temp has a trailing slash here. */
***************
*** 1746,1750 ****
      {
        insert_match (matches[match_list_index], orig_start, SINGLE_MATCH, &quote_char);
!       append_to_match (matches[match_list_index], delimiter, quote_char);
      }
  
--- 1814,1819 ----
      {
        insert_match (matches[match_list_index], orig_start, SINGLE_MATCH, &quote_char);
!       append_to_match (matches[match_list_index], delimiter, quote_char,
! 		       strcmp (orig_text, matches[match_list_index]));
      }
  
diff -Nrc2 bash-2.05/lib/readline/display.c bash-2.05a/lib/readline/display.c
*** bash-2.05/lib/readline/display.c	Fri Feb  2 13:25:10 2001
--- bash-2.05a/lib/readline/display.c	Tue Oct 30 16:11:44 2001
***************
*** 63,71 ****
  #endif
  
! static void update_line __P((char *, char *, int, int, int, int));
! static void space_to_eol __P((int));
! static void delete_chars __P((int));
! static void insert_some_chars __P((char *, int));
! static void cr __P((void));
  
  static int *inv_lbreaks, *vis_lbreaks;
--- 63,71 ----
  #endif
  
! static void update_line PARAMS((char *, char *, int, int, int, int));
! static void space_to_eol PARAMS((int));
! static void delete_chars PARAMS((int));
! static void insert_some_chars PARAMS((char *, int));
! static void cr PARAMS((void));
  
  static int *inv_lbreaks, *vis_lbreaks;
***************
*** 203,207 ****
  
    l = strlen (pmt);
!   r = ret = xmalloc (l + 1);
  
    invfl = 0;	/* invisible chars in first line of prompt */
--- 203,207 ----
  
    l = strlen (pmt);
!   r = ret = (char *)xmalloc (l + 1);
  
    invfl = 0;	/* invisible chars in first line of prompt */
***************
*** 336,341 ****
        if (line_size < minsize)
  	line_size = minsize;
!       visible_line = xmalloc (line_size);
!       invisible_line = xmalloc (line_size);
      }
    else if (line_size < minsize)	/* ensure it can hold MINSIZE chars */
--- 336,341 ----
        if (line_size < minsize)
  	line_size = minsize;
!       visible_line = (char *)xmalloc (line_size);
!       invisible_line = (char *)xmalloc (line_size);
      }
    else if (line_size < minsize)	/* ensure it can hold MINSIZE chars */
***************
*** 344,349 ****
        if (line_size < minsize)
  	line_size = minsize;
!       visible_line = xrealloc (visible_line, line_size);
!       invisible_line = xrealloc (invisible_line, line_size);
      }
  
--- 344,349 ----
        if (line_size < minsize)
  	line_size = minsize;
!       visible_line = (char *)xrealloc (visible_line, line_size);
!       invisible_line = (char *)xrealloc (invisible_line, line_size);
      }
  
***************
*** 422,427 ****
  	    {
  	      line_size = (temp + 1024) - (temp % 1024);
! 	      visible_line = xrealloc (visible_line, line_size);
! 	      line = invisible_line = xrealloc (invisible_line, line_size);
  	    }
  	  strncpy (line + out, local_prompt, local_len);
--- 422,427 ----
  	    {
  	      line_size = (temp + 1024) - (temp % 1024);
! 	      visible_line = (char *)xrealloc (visible_line, line_size);
! 	      line = invisible_line = (char *)xrealloc (invisible_line, line_size);
  	    }
  	  strncpy (line + out, local_prompt, local_len);
***************
*** 456,461 ****
  	{
  	  line_size = (temp + 1024) - (temp % 1024);
! 	  visible_line = xrealloc (visible_line, line_size);
! 	  line = invisible_line = xrealloc (invisible_line, line_size);
  	}
        strncpy (line + out,  prompt_this_line, pmtlen);
--- 456,461 ----
  	{
  	  line_size = (temp + 1024) - (temp % 1024);
! 	  visible_line = (char *)xrealloc (visible_line, line_size);
! 	  line = invisible_line = (char *)xrealloc (invisible_line, line_size);
  	}
        strncpy (line + out,  prompt_this_line, pmtlen);
***************
*** 531,536 ****
  	{
  	  line_size *= 2;
! 	  visible_line = xrealloc (visible_line, line_size);
! 	  invisible_line = xrealloc (invisible_line, line_size);
  	  line = invisible_line;
  	}
--- 531,536 ----
  	{
  	  line_size *= 2;
! 	  visible_line = (char *)xrealloc (visible_line, line_size);
! 	  invisible_line = (char *)xrealloc (invisible_line, line_size);
  	  line = invisible_line;
  	}
***************
*** 1331,1335 ****
      return (2);
  
!   return ((isprint (uc)) ? 1 : 2);
  }
  
--- 1331,1335 ----
      return (2);
  
!   return ((ISPRINT (uc)) ? 1 : 2);
  }
  
***************
*** 1358,1362 ****
--- 1358,1367 ----
  #endif
  
+ #if defined (HAVE_VSNPRINTF)
+   vsnprintf (msg_buf, sizeof (msg_buf) - 1, format, args);
+ #else
    vsprintf (msg_buf, format, args);
+   msg_buf[sizeof(msg_buf) - 1] = '\0';	/* overflow? */
+ #endif
    va_end (args);
  
***************
*** 1371,1374 ****
--- 1376,1380 ----
  {
    sprintf (msg_buf, format, arg1, arg2);
+   msg_buf[sizeof(msg_buf) - 1] = '\0';	/* overflow? */
    rl_display_prompt = msg_buf;
    (*rl_redisplay_function) ();
***************
*** 1437,1441 ****
      {
        len = (rl_prompt && *rl_prompt) ? strlen (rl_prompt) : 0;
!       pmt = xmalloc (len + 2);
        if (len)
  	strcpy (pmt, rl_prompt);
--- 1443,1447 ----
      {
        len = (rl_prompt && *rl_prompt) ? strlen (rl_prompt) : 0;
!       pmt = (char *)xmalloc (len + 2);
        if (len)
  	strcpy (pmt, rl_prompt);
***************
*** 1446,1450 ****
      {
        len = *saved_local_prompt ? strlen (saved_local_prompt) : 0;
!       pmt = xmalloc (len + 2);
        if (len)
  	strcpy (pmt, saved_local_prompt);
--- 1452,1456 ----
      {
        len = *saved_local_prompt ? strlen (saved_local_prompt) : 0;
!       pmt = (char *)xmalloc (len + 2);
        if (len)
  	strcpy (pmt, saved_local_prompt);
diff -Nrc2 bash-2.05/lib/readline/doc/hstech.texinfo bash-2.05a/lib/readline/doc/hstech.texinfo
*** bash-2.05/lib/readline/doc/hstech.texinfo	Mon Mar 12 05:37:38 2001
--- bash-2.05a/lib/readline/doc/hstech.texinfo	Tue Jul 24 16:42:23 2001
***************
*** 423,427 ****
  
  @deftypevar {char *} history_word_delimiters
! The characters that separate tokens for \fBhistory_tokenize()\fP.
  The default value is @code{" \t\n()<>;&|"}.
  @end deftypevar
--- 423,427 ----
  
  @deftypevar {char *} history_word_delimiters
! The characters that separate tokens for @code{history_tokenize()}.
  The default value is @code{" \t\n()<>;&|"}.
  @end deftypevar
diff -Nrc2 bash-2.05/lib/readline/doc/manvers.texinfo bash-2.05a/lib/readline/doc/manvers.texinfo
*** bash-2.05/lib/readline/doc/manvers.texinfo	Mon Mar 12 05:36:47 2001
--- bash-2.05a/lib/readline/doc/manvers.texinfo	Tue Oct  9 15:06:21 2001
***************
*** 1,6 ****
! @set EDITION 4.2-beta
! @set VERSION 4.2-beta
! @set UPDATED 2001 Mar 12
! @set UPDATE-MONTH Mar 2001
  
! @set LASTCHANGE Mon Mar 12 05:36:44 EST 2001
--- 1,6 ----
! @set EDITION 4.2a
! @set VERSION 4.2a
! @set UPDATED 2001 October 9
! @set UPDATE-MONTH October 2001
  
! @set LASTCHANGE Tue Oct  9 15:03:34 EDT 2001
diff -Nrc2 bash-2.05/lib/readline/doc/rltech.texinfo bash-2.05a/lib/readline/doc/rltech.texinfo
*** bash-2.05/lib/readline/doc/rltech.texinfo	Mon Mar 12 05:42:09 2001
--- bash-2.05a/lib/readline/doc/rltech.texinfo	Tue May  1 12:53:55 2001
***************
*** 177,180 ****
--- 177,190 ----
  @code{<stdio.h>} should be included before @code{readline.h}.
  
+ @code{readline.h} defines a C preprocessor variable that should
+ be treated as an integer, @code{RL_READLINE_VERSION}, which may
+ be used to conditionally compile application code depending on
+ the installed Readline version.  The value is a hexadecimal
+ encoding of the major and minor version numbers of the library,
+ of the form 0x@var{MMmm}.  @var{MM} is the two-digit major
+ version number; @var{mm} is the two-digit minor version number. 
+ For Readline 4.2, for example, the value of
+ @code{RL_READLINE_VERSION} would be @code{0x0402}. 
+ 
  @menu
  * Readline Typedefs::	C declarations to make code readable.
***************
*** 349,352 ****
--- 359,370 ----
  @end deftypevar
  
+ @deftypevar int rl_readline_version
+ An integer encoding the current version of the library.  The encoding is
+ of the form 0x@var{MMmm}, where @var{MM} is the two-digit major version
+ number, and @var{mm} is the two-digit minor version number.
+ For example, for Readline-4.2, @code{rl_readline_version} would have the
+ value 0x0402.
+ @end deftypevar
+ 
  @deftypevar {int} rl_gnu_readline_p
  Always set to 1, denoting that this is @sc{gnu} readline rather than some
***************
*** 1075,1078 ****
--- 1093,1105 ----
  Set the time interval (in microseconds) that Readline waits when showing
  a balancing character when @code{blink-matching-paren} has been enabled.
+ @end deftypefun
+ 
+ @deftypefun {char *} rl_get_termcap (const char *cap)
+ Retrieve the string value of the termcap capability @var{cap}.
+ Readline fetches the termcap entry for the current terminal name and
+ uses those capabilities to move around the screen line and perform other
+ terminal-specific operations, like erasing a line.  Readline does not
+ use all of a terminal's capabilities, and this function will return
+ values for only those capabilities Readline uses.
  @end deftypefun
  
diff -Nrc2 bash-2.05/lib/readline/doc/rluser.texinfo bash-2.05a/lib/readline/doc/rluser.texinfo
*** bash-2.05/lib/readline/doc/rluser.texinfo	Mon Mar  5 11:11:53 2001
--- bash-2.05a/lib/readline/doc/rluser.texinfo	Tue Oct  9 15:05:53 2001
***************
*** 11,15 ****
  GNU Readline Library.
  
! Copyright (C) 1988-2000 Free Software Foundation, Inc.
  
  Authored by Brian Fox and Chet Ramey.
--- 11,15 ----
  GNU Readline Library.
  
! Copyright (C) 1988-2001 Free Software Foundation, Inc.
  
  Authored by Brian Fox and Chet Ramey.
***************
*** 236,240 ****
  
  @item M-@key{DEL}
! Kill from the cursor the start of the previous word, or, if between
  words, to the start of the previous word.
  Word boundaries are the same as those used by @kbd{M-b}.
--- 236,240 ----
  
  @item M-@key{DEL}
! Kill from the cursor the start of the current word, or, if between
  words, to the start of the previous word.
  Word boundaries are the same as those used by @kbd{M-b}.
***************
*** 313,316 ****
--- 313,320 ----
  the current line, and begin editing.
  
+ Readline remembers the last incremental search string.  If two
+ @kbd{C-r}s are typed without any intervening characters defining a new
+ search string, any remembered search string is used.
+ 
  Non-incremental searches read the entire search string before starting
  to search for matching history lines.  The search string may be
***************
*** 453,456 ****
--- 457,465 ----
  attempts word completion.  The default is @samp{off}.
  
+ @vindex history-preserve-point
+ If set to @samp{on}, the history code attempts to place point at the
+ same location on each history line retrived with @code{previous-history}
+ or @code{next-history}.
+ 
  @item horizontal-scroll-mode
  @vindex horizontal-scroll-mode
***************
*** 504,507 ****
--- 513,524 ----
  This variable is @samp{off} by default.
  
+ @item match-hidden-files
+ @vindex match-hidden-files
+ This variable, when set to @samp{on}, causes Readline to match files whose
+ names begin with a @samp{.} (hidden files) when performing filename
+ completion, unless the leading @samp{.} is
+ supplied by the user in the filename to be completed.
+ This variable is @samp{on} by default.
+ 
  @item output-meta
  @vindex output-meta
***************
*** 645,653 ****
  vertical tab
  @item \@var{nnn}
! the character whose @sc{ascii} code is the octal value @var{nnn}
! (one to three digits)
! @item \x@var{nnn}
! the character whose @sc{ascii} code is the hexadecimal value @var{nnn}
  (one to three digits)
  @end table
  
--- 662,670 ----
  vertical tab
  @item \@var{nnn}
! the eight-bit character whose value is the octal value @var{nnn}
  (one to three digits)
+ @item \x@var{HH}
+ the eight-bit character whose value is the hexadecimal value @var{HH}
+ (one or two hex digits)
  @end table
  
***************
*** 1022,1025 ****
--- 1039,1044 ----
  Drag the word before point past the word after point,
  moving point past that word as well.
+ If the insertion point is at the end of the line, this transposes
+ the last two words on the line.
  
  @item upcase-word (M-u)
***************
*** 1535,1539 ****
  @btindex complete
  @example
! @code{complete [-abcdefjkvu] [-o @var{comp-option}] [-A @var{action}] [-G @var{globpat}] [-W @var{wordlist}]
  [-P @var{prefix}] [-S @var{suffix}] [-X @var{filterpat}] [-F @var{function}]
  [-C @var{command}] @var{name} [@var{name} @dots{}]}
--- 1554,1558 ----
  @btindex complete
  @example
! @code{complete [-abcdefgjkvu] [-o @var{comp-option}] [-A @var{action}] [-G @var{globpat}] [-W @var{wordlist}]
  [-P @var{prefix}] [-S @var{suffix}] [-X @var{filterpat}] [-F @var{function}]
  [-C @var{command}] @var{name} [@var{name} @dots{}]}
***************
*** 1617,1620 ****
--- 1636,1642 ----
  @item function
  Names of shell functions.
+ 
+ @item group
+ Group names.  May also be specified as @option{-g}.
  
  @item helptopic
diff -Nrc2 bash-2.05/lib/readline/examples/fileman.c bash-2.05a/lib/readline/examples/fileman.c
*** bash-2.05/lib/readline/examples/fileman.c	Tue Dec 12 15:05:24 2000
--- bash-2.05a/lib/readline/examples/fileman.c	Wed Aug 22 15:32:23 2001
***************
*** 42,54 ****
  
  /* The names of functions that actually do the manipulation. */
! int com_list __P((char *));
! int com_view __P((char *));
! int com_rename __P((char *));
! int com_stat __P((char *));
! int com_pwd __P((char *));
! int com_delete __P((char *));
! int com_help __P((char *));
! int com_cd __P((char *));
! int com_quit __P((char *));
  
  /* A structure which contains information on the commands this program
--- 42,54 ----
  
  /* The names of functions that actually do the manipulation. */
! int com_list PARAMS((char *));
! int com_view PARAMS((char *));
! int com_rename PARAMS((char *));
! int com_stat PARAMS((char *));
! int com_pwd PARAMS((char *));
! int com_delete PARAMS((char *));
! int com_help PARAMS((char *));
! int com_cd PARAMS((char *));
! int com_quit PARAMS((char *));
  
  /* A structure which contains information on the commands this program
***************
*** 213,218 ****
  /* **************************************************************** */
  
! char *command_generator __P((const char *, int));
! char **fileman_completion __P((const char *, int, int));
  
  /* Tell the GNU Readline library how to complete.  We want to try to complete
--- 213,218 ----
  /* **************************************************************** */
  
! char *command_generator PARAMS((const char *, int));
! char **fileman_completion PARAMS((const char *, int, int));
  
  /* Tell the GNU Readline library how to complete.  We want to try to complete
diff -Nrc2 bash-2.05/lib/readline/funmap.c bash-2.05a/lib/readline/funmap.c
*** bash-2.05/lib/readline/funmap.c	Wed Nov  8 12:38:13 2000
--- bash-2.05a/lib/readline/funmap.c	Wed Aug 22 09:39:01 2001
***************
*** 47,51 ****
  #endif
  
! extern int _rl_qsort_string_compare __P((char **, char **));
  
  FUNMAP **funmap;
--- 47,51 ----
  #endif
  
! extern int _rl_qsort_string_compare PARAMS((char **, char **));
  
  FUNMAP **funmap;
diff -Nrc2 bash-2.05/lib/readline/histexpand.c bash-2.05a/lib/readline/histexpand.c
*** bash-2.05/lib/readline/histexpand.c	Tue Mar  6 14:09:25 2001
--- bash-2.05a/lib/readline/histexpand.c	Wed Aug 22 09:39:07 2001
***************
*** 57,61 ****
  #define HISTORY_QUOTE_CHARACTERS	"\"'`"
  
! typedef int _hist_search_func_t __P((const char *, int));
  
  static char error_pointer;
--- 57,61 ----
  #define HISTORY_QUOTE_CHARACTERS	"\"'`"
  
! typedef int _hist_search_func_t PARAMS((const char *, int));
  
  static char error_pointer;
***************
*** 66,73 ****
  static int subst_rhs_len;
  
! static char *get_history_word_specifier __P((char *, char *, int *));
! static char *history_find_word __P((char *, int));
  
! static char *quote_breaks __P((char *));
  
  /* Variables exported by this file. */
--- 66,73 ----
  static int subst_rhs_len;
  
! static char *get_history_word_specifier PARAMS((char *, char *, int *));
! static char *history_find_word PARAMS((char *, int));
  
! static char *quote_breaks PARAMS((char *));
  
  /* Variables exported by this file. */
***************
*** 213,217 ****
  
    which = i - local_index;
!   temp = xmalloc (1 + which);
    if (which)
      strncpy (temp, string + local_index, which);
--- 213,217 ----
  
    which = i - local_index;
!   temp = (char *)xmalloc (1 + which);
    if (which)
      strncpy (temp, string + local_index, which);
***************
*** 315,319 ****
      }
  
!   r = ret = xmalloc (len);
    *r++ = '\'';
    for (p = s; p && *p; )
--- 315,319 ----
      }
  
!   r = ret = (char *)xmalloc (len);
    *r++ = '\'';
    for (p = s; p && *p; )
***************
*** 380,384 ****
      }
  
!   temp = xmalloc (ll + elen + 3);
    strncpy (temp, s + start, ll);
    temp[ll] = ':';
--- 380,384 ----
      }
  
!   temp = (char *)xmalloc (ll + elen + 3);
    strncpy (temp, s + start, ll);
    temp[ll] = ':';
***************
*** 416,420 ****
    if (si > i || is_rhs)
      {
!       s = xmalloc (si - i + 1);
        for (j = 0, k = i; k < si; j++, k++)
  	{
--- 416,420 ----
    if (si > i || is_rhs)
      {
!       s = (char *)xmalloc (si - i + 1);
        for (j = 0, k = i; k < si; j++, k++)
  	{
***************
*** 443,447 ****
    int i, j, new_size;
  
!   new = xmalloc (new_size = subst_rhs_len + subst_lhs_len);
    for (i = j = 0; i < subst_rhs_len; i++)
      {
--- 443,447 ----
    int i, j, new_size;
  
!   new = (char *)xmalloc (new_size = subst_rhs_len + subst_lhs_len);
    for (i = j = 0; i < subst_rhs_len; i++)
      {
***************
*** 449,453 ****
  	{
  	  if (j + subst_lhs_len >= new_size)
! 	    new = xrealloc (new, (new_size = new_size * 2 + subst_lhs_len));
  	  strcpy (new + j, subst_lhs);
  	  j += subst_lhs_len;
--- 449,453 ----
  	{
  	  if (j + subst_lhs_len >= new_size)
! 	    new = (char *)xrealloc (new, (new_size = new_size * 2 + subst_lhs_len));
  	  strcpy (new + j, subst_lhs);
  	  j += subst_lhs_len;
***************
*** 459,463 ****
  	    i++;
  	  if (j >= new_size)
! 	    new = xrealloc (new, new_size *= 2);
  	  new[j++] = subst_rhs[i];
  	}
--- 459,463 ----
  	    i++;
  	  if (j >= new_size)
! 	    new = (char *)xrealloc (new, new_size *= 2);
  	  new[j++] = subst_rhs[i];
  	}
***************
*** 486,490 ****
    int result_len;
  
!   result = xmalloc (result_len = 128);
  
    i = start;
--- 486,490 ----
    int result_len;
  
!   result = (char *)xmalloc (result_len = 128);
  
    i = start;
***************
*** 699,703 ****
  		{
  		  int len = subst_rhs_len - subst_lhs_len + l_temp;
! 		  new_event = xmalloc (1 + len);
  		  strncpy (new_event, temp, si);
  		  strncpy (new_event + si, subst_rhs, subst_rhs_len);
--- 699,703 ----
  		{
  		  int len = subst_rhs_len - subst_lhs_len + l_temp;
! 		  new_event = (char *)xmalloc (1 + len);
  		  strncpy (new_event, temp, si);
  		  strncpy (new_event + si, subst_rhs, subst_rhs_len);
***************
*** 760,764 ****
    n = strlen (temp);
    if (n >= result_len)
!     result = xrealloc (result, n + 2);
    strcpy (result, temp);
    free (temp);
--- 760,764 ----
    n = strlen (temp);
    if (n >= result_len)
!     result = (char *)xrealloc (result, n + 2);
    strcpy (result, temp);
    free (temp);
***************
*** 791,795 ****
  		while (j >= result_len) \
  		  result_len += 128; \
! 		result = xrealloc (result, result_len); \
  	      } \
  	    strcpy (result + j - sl, s); \
--- 791,795 ----
  		while (j >= result_len) \
  		  result_len += 128; \
! 		result = (char *)xrealloc (result, result_len); \
  	      } \
  	    strcpy (result + j - sl, s); \
***************
*** 801,805 ****
  	  { \
  	    if (j >= result_len - 1) \
! 	      result = xrealloc (result, result_len += 64); \
  	    result[j++] = c; \
  	    result[j] = '\0'; \
--- 801,805 ----
  	  { \
  	    if (j >= result_len - 1) \
! 	      result = (char *)xrealloc (result, result_len += 64); \
  	    result[j++] = c; \
  	    result[j] = '\0'; \
***************
*** 835,839 ****
      
    /* Prepare the buffer for printing error messages. */
!   result = xmalloc (result_len = 256);
    result[0] = '\0';
  
--- 835,839 ----
      
    /* Prepare the buffer for printing error messages. */
!   result = (char *)xmalloc (result_len = 256);
    result[0] = '\0';
  
***************
*** 852,856 ****
    if (hstring[0] == history_subst_char)
      {
!       string = xmalloc (l + 5);
  
        string[0] = string[1] = history_expansion_char;
--- 852,856 ----
    if (hstring[0] == history_subst_char)
      {
!       string = (char *)xmalloc (l + 5);
  
        string[0] = string[1] = history_expansion_char;
***************
*** 961,965 ****
  
  		slen = i - quote + 2;
! 		temp = xmalloc (slen);
  		strncpy (temp, string + quote, slen);
  		temp[slen - 1] = '\0';
--- 961,965 ----
  
  		slen = i - quote + 2;
! 		temp = (char *)xmalloc (slen);
  		strncpy (temp, string + quote, slen);
  		temp[slen - 1] = '\0';
***************
*** 975,979 ****
  	  if (i == 0 || member (string[i - 1], history_word_delimiters))
  	    {
! 	      temp = xmalloc (l - i + 1);
  	      strcpy (temp, string + i);
  	      ADD_STRING (temp);
--- 975,979 ----
  	  if (i == 0 || member (string[i - 1], history_word_delimiters))
  	    {
! 	      temp = (char *)xmalloc (l - i + 1);
  	      strcpy (temp, string + i);
  	      ADD_STRING (temp);
***************
*** 1007,1011 ****
  	      if (result)
  		{
! 		  temp = xmalloc (1 + strlen (result));
  		  strcpy (temp, result);
  		  ADD_STRING (temp);
--- 1007,1011 ----
  	      if (result)
  		{
! 		  temp = (char *)xmalloc (1 + strlen (result));
  		  strcpy (temp, result);
  		  ADD_STRING (temp);
***************
*** 1141,1145 ****
  	  last = '$';
  	}
!       else if (!spec[i] || spec[i] == ':')  /* could be modifier separator */
  	last = -1;		/* x- abbreviates x-$ omitting word `$' */
      }
--- 1141,1152 ----
  	  last = '$';
  	}
! #if 0
!       else if (!spec[i] || spec[i] == ':')
! 	/* check against `:' because there could be a modifier separator */
! #else
!       else
! 	/* csh seems to allow anything to terminate the word spec here,
! 	   leaving it as an abbreviation. */
! #endif
  	last = -1;		/* x- abbreviates x-$ omitting word `$' */
      }
***************
*** 1197,1201 ****
        for (size = 0, i = first; i < last; i++)
  	size += strlen (list[i]) + 1;
!       result = xmalloc (size + 1);
        result[0] = '\0';
  
--- 1204,1208 ----
        for (size = 0, i = first; i < last; i++)
  	size += strlen (list[i]) + 1;
!       result = (char *)xmalloc (size + 1);
        result[0] = '\0';
  
***************
*** 1330,1334 ****
        if (result_index + 2 >= size)
  	result = (char **)xrealloc (result, ((size += 10) * sizeof (char *)));
!       result[result_index] = xmalloc (1 + len);
        strncpy (result[result_index], string + start, len);
        result[result_index][len] = '\0';
--- 1337,1341 ----
        if (result_index + 2 >= size)
  	result = (char **)xrealloc (result, ((size += 10) * sizeof (char *)));
!       result[result_index] = (char *)xmalloc (1 + len);
        strncpy (result[result_index], string + start, len);
        result[result_index][len] = '\0';
diff -Nrc2 bash-2.05/lib/readline/histfile.c bash-2.05a/lib/readline/histfile.c
*** bash-2.05/lib/readline/histfile.c	Tue Mar  6 13:14:27 2001
--- bash-2.05a/lib/readline/histfile.c	Thu Aug  2 13:01:26 2001
***************
*** 106,110 ****
      home_len = strlen (home);
  
!   return_val = xmalloc (2 + home_len + 8); /* strlen(".history") == 8 */
    strcpy (return_val, home);
    return_val[home_len] = '/';
--- 106,110 ----
      home_len = strlen (home);
  
!   return_val = (char *)xmalloc (2 + home_len + 8); /* strlen(".history") == 8 */
    strcpy (return_val, home);
    return_val[home_len] = '/';
***************
*** 162,166 ****
      }
  
!   buffer = xmalloc (file_size + 1);
  
    chars_read = read (file, buffer, file_size);
--- 162,166 ----
      }
  
!   buffer = (char *)xmalloc (file_size + 1);
  
    chars_read = read (file, buffer, file_size);
***************
*** 277,281 ****
      }
  
!   buffer = xmalloc (file_size + 1);
    chars_read = read (file, buffer, file_size);
    close (file);
--- 277,281 ----
      }
  
!   buffer = (char *)xmalloc (file_size + 1);
    chars_read = read (file, buffer, file_size);
    close (file);
***************
*** 368,372 ****
  
      /* Allocate the buffer, and fill it. */
!     buffer = xmalloc (buffer_size);
  
      for (j = 0, i = history_length - nelements; i < history_length; i++)
--- 368,372 ----
  
      /* Allocate the buffer, and fill it. */
!     buffer = (char *)xmalloc (buffer_size);
  
      for (j = 0, i = history_length - nelements; i < history_length; i++)
diff -Nrc2 bash-2.05/lib/readline/history.c bash-2.05a/lib/readline/history.c
*** bash-2.05/lib/readline/history.c	Tue Mar  6 13:34:44 2001
--- bash-2.05a/lib/readline/history.c	Wed May  9 09:18:59 2001
***************
*** 72,75 ****
--- 72,78 ----
  static int history_stifled;
  
+ /* The current number of slots allocated to the input_history. */
+ static int history_size;
+ 
  /* If HISTORY_STIFLED is non-zero, then this is the maximum number of
     entries to remember. */
***************
*** 83,89 ****
  /* The number of strings currently stored in the history list. */
  int history_length;
- 
- /* The current number of slots allocated to the input_history. */
- static int history_size;
  
  /* The logical `base' of the history array.  It defaults to 1. */
--- 86,89 ----
diff -Nrc2 bash-2.05/lib/readline/history.h bash-2.05a/lib/readline/history.h
*** bash-2.05/lib/readline/history.h	Tue Mar  6 13:54:26 2001
--- bash-2.05a/lib/readline/history.h	Wed Aug 22 09:37:23 2001
***************
*** 63,73 ****
  /* Begin a session in which the history functions might be used.  This
     just initializes the interactive variables. */
! extern void using_history __P((void));
  
  /* Return the current HISTORY_STATE of the history. */
! extern HISTORY_STATE *history_get_history_state __P((void));
  
  /* Set the state of the current history array to STATE. */
! extern void history_set_history_state __P((HISTORY_STATE *));
  
  /* Manage the history list. */
--- 63,73 ----
  /* Begin a session in which the history functions might be used.  This
     just initializes the interactive variables. */
! extern void using_history PARAMS((void));
  
  /* Return the current HISTORY_STATE of the history. */
! extern HISTORY_STATE *history_get_history_state PARAMS((void));
  
  /* Set the state of the current history array to STATE. */
! extern void history_set_history_state PARAMS((HISTORY_STATE *));
  
  /* Manage the history list. */
***************
*** 75,103 ****
  /* Place STRING at the end of the history list.
     The associated data field (if any) is set to NULL. */
! extern void add_history __P((const char *));
  
  /* A reasonably useless function, only here for completeness.  WHICH
     is the magic number that tells us which element to delete.  The
     elements are numbered from 0. */
! extern HIST_ENTRY *remove_history __P((int));
  
  /* Make the history entry at WHICH have LINE and DATA.  This returns
     the old entry so you can dispose of the data.  In the case of an
     invalid WHICH, a NULL pointer is returned. */
! extern HIST_ENTRY *replace_history_entry __P((int, const char *, histdata_t));
  
  /* Clear the history list and start over. */
! extern void clear_history __P((void));
  
  /* Stifle the history list, remembering only MAX number of entries. */
! extern void stifle_history __P((int));
  
  /* Stop stifling the history.  This returns the previous amount the
     history was stifled by.  The value is positive if the history was
     stifled, negative if it wasn't. */
! extern int unstifle_history __P((void));
  
  /* Return 1 if the history is stifled, 0 if it is not. */
! extern int history_is_stifled __P((void));
  
  /* Information about the history list. */
--- 75,103 ----
  /* Place STRING at the end of the history list.
     The associated data field (if any) is set to NULL. */
! extern void add_history PARAMS((const char *));
  
  /* A reasonably useless function, only here for completeness.  WHICH
     is the magic number that tells us which element to delete.  The
     elements are numbered from 0. */
! extern HIST_ENTRY *remove_history PARAMS((int));
  
  /* Make the history entry at WHICH have LINE and DATA.  This returns
     the old entry so you can dispose of the data.  In the case of an
     invalid WHICH, a NULL pointer is returned. */
! extern HIST_ENTRY *replace_history_entry PARAMS((int, const char *, histdata_t));
  
  /* Clear the history list and start over. */
! extern void clear_history PARAMS((void));
  
  /* Stifle the history list, remembering only MAX number of entries. */
! extern void stifle_history PARAMS((int));
  
  /* Stop stifling the history.  This returns the previous amount the
     history was stifled by.  The value is positive if the history was
     stifled, negative if it wasn't. */
! extern int unstifle_history PARAMS((void));
  
  /* Return 1 if the history is stifled, 0 if it is not. */
! extern int history_is_stifled PARAMS((void));
  
  /* Information about the history list. */
***************
*** 106,141 ****
     history.  Element 0 of this list is the beginning of time.  If there
     is no history, return NULL. */
! extern HIST_ENTRY **history_list __P((void));
  
  /* Returns the number which says what history element we are now
     looking at.  */
! extern int where_history __P((void));
    
  /* Return the history entry at the current position, as determined by
     history_offset.  If there is no entry there, return a NULL pointer. */
! extern HIST_ENTRY *current_history __P((void));
  
  /* Return the history entry which is logically at OFFSET in the history
     array.  OFFSET is relative to history_base. */
! extern HIST_ENTRY *history_get __P((int));
  
  /* Return the number of bytes that the primary history entries are using.
     This just adds up the lengths of the_history->lines. */
! extern int history_total_bytes __P((void));
  
  /* Moving around the history list. */
  
  /* Set the position in the history list to POS. */
! extern int history_set_pos __P((int));
  
  /* Back up history_offset to the previous history entry, and return
     a pointer to that entry.  If there is no previous entry, return
     a NULL pointer. */
! extern HIST_ENTRY *previous_history __P((void));
  
  /* Move history_offset forward to the next item in the input_history,
     and return the a pointer to that entry.  If there is no next entry,
     return a NULL pointer. */
! extern HIST_ENTRY *next_history __P((void));
  
  /* Searching the history list. */
--- 106,141 ----
     history.  Element 0 of this list is the beginning of time.  If there
     is no history, return NULL. */
! extern HIST_ENTRY **history_list PARAMS((void));
  
  /* Returns the number which says what history element we are now
     looking at.  */
! extern int where_history PARAMS((void));
    
  /* Return the history entry at the current position, as determined by
     history_offset.  If there is no entry there, return a NULL pointer. */
! extern HIST_ENTRY *current_history PARAMS((void));
  
  /* Return the history entry which is logically at OFFSET in the history
     array.  OFFSET is relative to history_base. */
! extern HIST_ENTRY *history_get PARAMS((int));
  
  /* Return the number of bytes that the primary history entries are using.
     This just adds up the lengths of the_history->lines. */
! extern int history_total_bytes PARAMS((void));
  
  /* Moving around the history list. */
  
  /* Set the position in the history list to POS. */
! extern int history_set_pos PARAMS((int));
  
  /* Back up history_offset to the previous history entry, and return
     a pointer to that entry.  If there is no previous entry, return
     a NULL pointer. */
! extern HIST_ENTRY *previous_history PARAMS((void));
  
  /* Move history_offset forward to the next item in the input_history,
     and return the a pointer to that entry.  If there is no next entry,
     return a NULL pointer. */
! extern HIST_ENTRY *next_history PARAMS((void));
  
  /* Searching the history list. */
***************
*** 147,156 ****
     is the offset in the line of that history entry that the string was
     found in.  Otherwise, nothing is changed, and a -1 is returned. */
! extern int history_search __P((const char *, int));
  
  /* Search the history for STRING, starting at history_offset.
     The search is anchored: matching lines must begin with string.
     DIRECTION is as in history_search(). */
! extern int history_search_prefix __P((const char *, int));
  
  /* Search for STRING in the history list, starting at POS, an
--- 147,156 ----
     is the offset in the line of that history entry that the string was
     found in.  Otherwise, nothing is changed, and a -1 is returned. */
! extern int history_search PARAMS((const char *, int));
  
  /* Search the history for STRING, starting at history_offset.
     The search is anchored: matching lines must begin with string.
     DIRECTION is as in history_search(). */
! extern int history_search_prefix PARAMS((const char *, int));
  
  /* Search for STRING in the history list, starting at POS, an
***************
*** 159,163 ****
     Returns the absolute index of the history element where STRING
     was found, or -1 otherwise. */
! extern int history_search_pos __P((const char *, int, int));
  
  /* Managing the history file. */
--- 159,163 ----
     Returns the absolute index of the history element where STRING
     was found, or -1 otherwise. */
! extern int history_search_pos PARAMS((const char *, int, int));
  
  /* Managing the history file. */
***************
*** 166,170 ****
     If FILENAME is NULL, then read from ~/.history.  Returns 0 if
     successful, or errno if not. */
! extern int read_history __P((const char *));
  
  /* Read a range of lines from FILENAME, adding them to the history list.
--- 166,170 ----
     If FILENAME is NULL, then read from ~/.history.  Returns 0 if
     successful, or errno if not. */
! extern int read_history PARAMS((const char *));
  
  /* Read a range of lines from FILENAME, adding them to the history list.
***************
*** 173,189 ****
     until the end of the file.  If FILENAME is NULL, then read from
     ~/.history.  Returns 0 if successful, or errno if not. */
! extern int read_history_range __P((const char *, int, int));
  
  /* Write the current history to FILENAME.  If FILENAME is NULL,
     then write the history list to ~/.history.  Values returned
     are as in read_history ().  */
! extern int write_history __P((const char *));
  
  /* Append NELEMENT entries to FILENAME.  The entries appended are from
     the end of the list minus NELEMENTs up to the end of the list. */
! extern int append_history __P((int, const char *));
  
  /* Truncate the history file, leaving only the last NLINES lines. */
! extern int history_truncate_file __P((const char *, int));
  
  /* History expansion. */
--- 173,189 ----
     until the end of the file.  If FILENAME is NULL, then read from
     ~/.history.  Returns 0 if successful, or errno if not. */
! extern int read_history_range PARAMS((const char *, int, int));
  
  /* Write the current history to FILENAME.  If FILENAME is NULL,
     then write the history list to ~/.history.  Values returned
     are as in read_history ().  */
! extern int write_history PARAMS((const char *));
  
  /* Append NELEMENT entries to FILENAME.  The entries appended are from
     the end of the list minus NELEMENTs up to the end of the list. */
! extern int append_history PARAMS((int, const char *));
  
  /* Truncate the history file, leaving only the last NLINES lines. */
! extern int history_truncate_file PARAMS((const char *, int));
  
  /* History expansion. */
***************
*** 201,210 ****
    If an error ocurred in expansion, then OUTPUT contains a descriptive
    error message. */
! extern int history_expand __P((char *, char **));
  
  /* Extract a string segment consisting of the FIRST through LAST
     arguments present in STRING.  Arguments are broken up as in
     the shell. */
! extern char *history_arg_extract __P((int, int, const char *));
  
  /* Return the text of the history event beginning at the current
--- 201,210 ----
    If an error ocurred in expansion, then OUTPUT contains a descriptive
    error message. */
! extern int history_expand PARAMS((char *, char **));
  
  /* Extract a string segment consisting of the FIRST through LAST
     arguments present in STRING.  Arguments are broken up as in
     the shell. */
! extern char *history_arg_extract PARAMS((int, int, const char *));
  
  /* Return the text of the history event beginning at the current
***************
*** 214,222 ****
     specification for what to search for in addition to the normal
     characters `:', ` ', `\t', `\n', and sometimes `?'. */
! extern char *get_history_event __P((const char *, int *, int));
  
  /* Return an array of tokens, much as the shell might.  The tokens are
     parsed out of STRING. */
! extern char **history_tokenize __P((const char *));
  
  /* Exported history variables. */
--- 214,222 ----
     specification for what to search for in addition to the normal
     characters `:', ` ', `\t', `\n', and sometimes `?'. */
! extern char *get_history_event PARAMS((const char *, int *, int));
  
  /* Return an array of tokens, much as the shell might.  The tokens are
     parsed out of STRING. */
! extern char **history_tokenize PARAMS((const char *));
  
  /* Exported history variables. */
diff -Nrc2 bash-2.05/lib/readline/histsearch.c bash-2.05a/lib/readline/histsearch.c
*** bash-2.05/lib/readline/histsearch.c	Thu Sep 28 14:15:52 2000
--- bash-2.05a/lib/readline/histsearch.c	Wed Aug 22 09:39:12 2001
***************
*** 52,55 ****
--- 52,57 ----
  char *history_search_delimiter_chars = (char *)NULL;
  
+ static int history_search_internal PARAMS((const char *, int, int));
+ 
  /* Search the history for STRING, starting at history_offset.
     If DIRECTION < 0, then the search is through previous entries, else
diff -Nrc2 bash-2.05/lib/readline/input.c bash-2.05a/lib/readline/input.c
*** bash-2.05/lib/readline/input.c	Tue Mar 27 10:15:04 2001
--- bash-2.05a/lib/readline/input.c	Wed Sep 12 10:55:50 2001
***************
*** 85,88 ****
--- 85,93 ----
  static int _keyboard_input_timeout = 100000;		/* 0.1 seconds; it's in usec */
  
+ static int ibuffer_space PARAMS((void));
+ static int rl_get_char PARAMS((int *));
+ static int rl_unget_char PARAMS((int));
+ static void rl_gather_tyi PARAMS((void));
+ 
  /* **************************************************************** */
  /*								    */
***************
*** 246,250 ****
    struct timeval timeout;
  #endif
! #if defined(FIONREAD)
    int chars_avail;
  #endif
--- 251,255 ----
    struct timeval timeout;
  #endif
! #if !defined (HAVE_SELECT) && defined(FIONREAD)
    int chars_avail;
  #endif
***************
*** 261,265 ****
    timeout.tv_usec = _keyboard_input_timeout;
    return (select (tty + 1, &readfds, (fd_set *)NULL, &exceptfds, &timeout) > 0);
! #endif
  
  #if defined (FIONREAD)
--- 266,270 ----
    timeout.tv_usec = _keyboard_input_timeout;
    return (select (tty + 1, &readfds, (fd_set *)NULL, &exceptfds, &timeout) > 0);
! #else
  
  #if defined (FIONREAD)
***************
*** 268,271 ****
--- 273,278 ----
  #endif
  
+ #endif
+ 
    return 0;
  }
***************
*** 279,283 ****
  
    i = key = 0;
!   string = xmalloc (ibuffer_len + 1);
    string[i++] = (char) c;
  
--- 286,290 ----
  
    i = key = 0;
!   string = (char *)xmalloc (ibuffer_len + 1);
    string[i++] = (char) c;
  
diff -Nrc2 bash-2.05/lib/readline/isearch.c bash-2.05a/lib/readline/isearch.c
*** bash-2.05/lib/readline/isearch.c	Wed Feb 14 07:37:01 2001
--- bash-2.05a/lib/readline/isearch.c	Mon Oct 15 12:25:17 2001
***************
*** 53,57 ****
  
  /* Variables exported to other files in the readline library. */
! unsigned char *_rl_isearch_terminators = (unsigned char *)NULL;
  
  /* Variables imported from other files in the readline library. */
--- 53,57 ----
  
  /* Variables exported to other files in the readline library. */
! char *_rl_isearch_terminators = (char *)NULL;
  
  /* Variables imported from other files in the readline library. */
***************
*** 59,63 ****
  
  /* Forward declarations */
! static int rl_search_history __P((int, int));
  
  /* Last line found by the current incremental search, so we don't `find'
--- 59,63 ----
  
  /* Forward declarations */
! static int rl_search_history PARAMS((int, int));
  
  /* Last line found by the current incremental search, so we don't `find'
***************
*** 65,69 ****
  static char *prev_line_found;
  
! static unsigned char *default_isearch_terminators = "\033\012";
  
  /* Search backwards through the history looking for a string which is typed
--- 65,73 ----
  static char *prev_line_found;
  
! /* Last search string and its length. */
! static char *last_isearch_string;
! static int last_isearch_string_len;
! 
! static char *default_isearch_terminators = "\033\012";
  
  /* Search backwards through the history looking for a string which is typed
***************
*** 100,104 ****
    searchlen = (search_string && *search_string) ? strlen (search_string) : 0;
  
!   message = xmalloc (searchlen + 33);
    msglen = 0;
  
--- 104,108 ----
    searchlen = (search_string && *search_string) ? strlen (search_string) : 0;
  
!   message = (char *)xmalloc (searchlen + 33);
    msglen = 0;
  
***************
*** 130,134 ****
    strcpy (message + msglen, "': ");
  
!   rl_message ("%s", message, 0);
    free (message);
    (*rl_redisplay_function) ();
--- 134,138 ----
    strcpy (message + msglen, "': ");
  
!   rl_message ("%s", message);
    free (message);
    (*rl_redisplay_function) ();
***************
*** 177,181 ****
       subsequently executed.  If the variable isearch-terminators has
       been set, we use that value, otherwise we use ESC and C-J. */
!   unsigned char *isearch_terminators;
  
    RL_SETSTATE(RL_STATE_ISEARCH);
--- 181,185 ----
       subsequently executed.  If the variable isearch-terminators has
       been set, we use that value, otherwise we use ESC and C-J. */
!   char *isearch_terminators;
  
    RL_SETSTATE(RL_STATE_ISEARCH);
***************
*** 206,210 ****
      {
        /* Keep track of this so we can free it. */
!       allocated_line = xmalloc (1 + strlen (rl_line_buffer));
        strcpy (allocated_line, &rl_line_buffer[0]);
        lines[i] = allocated_line;
--- 210,214 ----
      {
        /* Keep track of this so we can free it. */
!       allocated_line = (char *)xmalloc (1 + strlen (rl_line_buffer));
        strcpy (allocated_line, &rl_line_buffer[0]);
        lines[i] = allocated_line;
***************
*** 219,223 ****
  
    /* Initialize search parameters. */
!   search_string = xmalloc (search_string_size = 128);
    *search_string = '\0';
    search_string_index = 0;
--- 223,227 ----
  
    /* Initialize search parameters. */
!   search_string = (char *)xmalloc (search_string_size = 128);
    *search_string = '\0';
    search_string_index = 0;
***************
*** 243,247 ****
        RL_UNSETSTATE(RL_STATE_MOREINPUT);
  
!       if (_rl_keymap[c].type == ISFUNC)
  	{
  	  f = _rl_keymap[c].function;
--- 247,251 ----
        RL_UNSETSTATE(RL_STATE_MOREINPUT);
  
!       if (c >= 0 && _rl_keymap[c].type == ISFUNC)
  	{
  	  f = _rl_keymap[c].function;
***************
*** 289,293 ****
  	case -1:
  	  if (search_string_index == 0)
! 	    continue;
  	  else if (reverse)
  	    --line_index;
--- 293,308 ----
  	case -1:
  	  if (search_string_index == 0)
! 	    {
! 	      if (last_isearch_string)
! 		{
! 		  search_string_size = 64 + last_isearch_string_len;
! 		  search_string = (char *)xrealloc (search_string, search_string_size);
! 		  strcpy (search_string, last_isearch_string);
! 		  search_string_index = last_isearch_string_len;
! 		  rl_display_search (search_string, reverse, -1);
! 		  break;
! 		}
! 	      continue;
! 	    }
  	  else if (reverse)
  	    --line_index;
***************
*** 336,340 ****
  	    {
  	      search_string_size += 128;
! 	      search_string = xrealloc (search_string, search_string_size);
  	    }
  	  search_string[search_string_index++] = c;
--- 351,355 ----
  	    {
  	      search_string_size += 128;
! 	      search_string = (char *)xrealloc (search_string, search_string_size);
  	    }
  	  search_string[search_string_index++] = c;
***************
*** 429,434 ****
--- 444,456 ----
    rl_restore_prompt ();
  
+ #if 1
+   /* Save the search string for possible later use. */
+   FREE (last_isearch_string);
+   last_isearch_string = search_string;
+   last_isearch_string_len = search_string_index;
+ #else
    /* Free the search string. */
    free (search_string);
+ #endif
  
    if (last_found_line < orig_line)
***************
*** 443,448 ****
    rl_clear_message ();
  
!   if (allocated_line)
!     free (allocated_line);
    free (lines);
  
--- 465,469 ----
    rl_clear_message ();
  
!   FREE (allocated_line);
    free (lines);
  
diff -Nrc2 bash-2.05/lib/readline/keymaps.h bash-2.05a/lib/readline/keymaps.h
*** bash-2.05/lib/readline/keymaps.h	Mon Oct 30 13:23:23 2000
--- bash-2.05a/lib/readline/keymaps.h	Wed Aug 22 09:37:28 2001
***************
*** 71,86 ****
  /* Return a new, empty keymap.
     Free it with free() when you are done. */
! extern Keymap rl_make_bare_keymap __P((void));
  
  /* Return a new keymap which is a copy of MAP. */
! extern Keymap rl_copy_keymap __P((Keymap));
  
  /* Return a new keymap with the printing characters bound to rl_insert,
     the lowercase Meta characters bound to run their equivalents, and
     the Meta digits bound to produce numeric arguments. */
! extern Keymap rl_make_keymap __P((void));
  
  /* Free the storage associated with a keymap. */
! extern void rl_discard_keymap __P((Keymap));
  
  /* These functions actually appear in bind.c */
--- 71,86 ----
  /* Return a new, empty keymap.
     Free it with free() when you are done. */
! extern Keymap rl_make_bare_keymap PARAMS((void));
  
  /* Return a new keymap which is a copy of MAP. */
! extern Keymap rl_copy_keymap PARAMS((Keymap));
  
  /* Return a new keymap with the printing characters bound to rl_insert,
     the lowercase Meta characters bound to run their equivalents, and
     the Meta digits bound to produce numeric arguments. */
! extern Keymap rl_make_keymap PARAMS((void));
  
  /* Free the storage associated with a keymap. */
! extern void rl_discard_keymap PARAMS((Keymap));
  
  /* These functions actually appear in bind.c */
***************
*** 88,98 ****
  /* Return the keymap corresponding to a given name.  Names look like
     `emacs' or `emacs-meta' or `vi-insert'.  */
! extern Keymap rl_get_keymap_by_name __P((const char *));
  
  /* Return the current keymap. */
! extern Keymap rl_get_keymap __P((void));
  
  /* Set the current keymap to MAP. */
! extern void rl_set_keymap __P((Keymap));
  
  #ifdef __cplusplus
--- 88,98 ----
  /* Return the keymap corresponding to a given name.  Names look like
     `emacs' or `emacs-meta' or `vi-insert'.  */
! extern Keymap rl_get_keymap_by_name PARAMS((const char *));
  
  /* Return the current keymap. */
! extern Keymap rl_get_keymap PARAMS((void));
  
  /* Set the current keymap to MAP. */
! extern void rl_set_keymap PARAMS((Keymap));
  
  #ifdef __cplusplus
diff -Nrc2 bash-2.05/lib/readline/kill.c bash-2.05a/lib/readline/kill.c
*** bash-2.05/lib/readline/kill.c	Thu Nov  2 12:36:25 2000
--- bash-2.05a/lib/readline/kill.c	Wed Aug 22 09:39:28 2001
***************
*** 71,74 ****
--- 71,79 ----
  static int rl_kill_ring_length;
  
+ static int _rl_copy_to_kill_ring PARAMS((char *, int));
+ static int region_kill_internal PARAMS((int));
+ static int _rl_copy_word_as_kill PARAMS((int, int));
+ static int rl_yank_nth_arg_internal PARAMS((int, int, int));
+ 
  /* How to say that you only want to save a certain amount
     of kill material. */
***************
*** 130,134 ****
      {
        old = rl_kill_ring[slot];
!       new = xmalloc (1 + strlen (old) + strlen (text));
  
        if (append)
--- 135,139 ----
      {
        old = rl_kill_ring[slot];
!       new = (char *)xmalloc (1 + strlen (old) + strlen (text));
  
        if (append)
***************
*** 613,617 ****
  	{
  	  len = ptr - data;
! 	  ptr = xmalloc (len + 1);
  	  ptr[len] = '\0';
  	  strncpy (ptr, data, len);
--- 618,622 ----
  	{
  	  len = ptr - data;
! 	  ptr = (char *)xmalloc (len + 1);
  	  ptr[len] = '\0';
  	  strncpy (ptr, data, len);
diff -Nrc2 bash-2.05/lib/readline/macro.c bash-2.05a/lib/readline/macro.c
*** bash-2.05/lib/readline/macro.c	Thu Nov  2 12:36:37 2000
--- bash-2.05a/lib/readline/macro.c	Thu Aug  2 12:59:16 2001
***************
*** 164,170 ****
      {
        if (current_macro == 0)
! 	current_macro = xmalloc (current_macro_size = 25);
        else
! 	current_macro = xrealloc (current_macro, current_macro_size += 25);
      }
  
--- 164,170 ----
      {
        if (current_macro == 0)
! 	current_macro = (char *)xmalloc (current_macro_size = 25);
        else
! 	current_macro = (char *)xrealloc (current_macro, current_macro_size += 25);
      }
  
diff -Nrc2 bash-2.05/lib/readline/nls.c bash-2.05a/lib/readline/nls.c
*** bash-2.05/lib/readline/nls.c	Fri Nov  3 11:44:27 2000
--- bash-2.05a/lib/readline/nls.c	Mon Oct 15 14:32:29 2001
***************
*** 72,77 ****
  };
  
! static char *normalize_codeset __P((char *));
! static char *find_codeset __P((char *, size_t *));
  #endif /* !HAVE_SETLOCALE */
  
--- 72,77 ----
  };
  
! static char *normalize_codeset PARAMS((char *));
! static char *find_codeset PARAMS((char *, size_t *));
  #endif /* !HAVE_SETLOCALE */
  
***************
*** 142,149 ****
    for (len = 0, i = 0; i < namelen; i++)
      {
!       if (isalnum (codeset[i]))
  	{
  	  len++;
! 	  all_digits &= isdigit (codeset[i]);
  	}
      }
--- 142,149 ----
    for (len = 0, i = 0; i < namelen; i++)
      {
!       if (ISALNUM ((unsigned char)codeset[i]))
  	{
  	  len++;
! 	  all_digits &= _rl_digit_p (codeset[i]);
  	}
      }
***************
*** 163,169 ****
  
    for (i = 0; i < namelen; i++)
!     if (isalpha (codeset[i]))
!       *wp++ = (isupper (codeset[i])) ? tolower (codeset[i]) : codeset[i];
!     else if (isdigit (codeset[i]))
        *wp++ = codeset[i];
    *wp = '\0';
--- 163,169 ----
  
    for (i = 0; i < namelen; i++)
!     if (ISALPHA ((unsigned char)codeset[i]))
!       *wp++ = _rl_to_lower (codeset[i]);
!     else if (_rl_digit_p (codeset[i]))
        *wp++ = codeset[i];
    *wp = '\0';
diff -Nrc2 bash-2.05/lib/readline/parens.c bash-2.05a/lib/readline/parens.c
*** bash-2.05/lib/readline/parens.c	Wed Aug 30 15:10:45 2000
--- bash-2.05a/lib/readline/parens.c	Wed Aug 22 09:39:38 2001
***************
*** 55,59 ****
  #include "rlprivate.h"
  
! static int find_matching_open __P((char *, int, int));
  
  /* Non-zero means try to blink the matching open parenthesis when the
--- 55,59 ----
  #include "rlprivate.h"
  
! static int find_matching_open PARAMS((char *, int, int));
  
  /* Non-zero means try to blink the matching open parenthesis when the
diff -Nrc2 bash-2.05/lib/readline/readline.c bash-2.05a/lib/readline/readline.c
*** bash-2.05/lib/readline/readline.c	Mon Apr  2 15:56:20 2001
--- bash-2.05a/lib/readline/readline.c	Wed Nov  7 17:01:58 2001
***************
*** 68,72 ****
  
  #ifndef RL_LIBRARY_VERSION
! #  define RL_LIBRARY_VERSION "4.2"
  #endif
  
--- 68,76 ----
  
  #ifndef RL_LIBRARY_VERSION
! #  define RL_LIBRARY_VERSION "4.2a"
! #endif
! 
! #ifndef RL_READLINE_VERSION
! #  define RL_READLINE_VERSION	0x0402
  #endif
  
***************
*** 75,87 ****
  
  /* Forward declarations used in this file. */
! void _rl_free_history_entry __P((HIST_ENTRY *));
  
! static char *readline_internal __P((void));
! static void readline_initialize_everything __P((void));
! static void start_using_history __P((void));
! static void bind_arrow_keys __P((void));
! static int rl_change_case __P((int, int));
  
! static void readline_default_bindings __P((void));
  
  /* **************************************************************** */
--- 79,91 ----
  
  /* Forward declarations used in this file. */
! void _rl_free_history_entry PARAMS((HIST_ENTRY *));
  
! static char *readline_internal PARAMS((void));
! static void readline_initialize_everything PARAMS((void));
! static void start_using_history PARAMS((void));
! static void bind_arrow_keys PARAMS((void));
! static int rl_change_case PARAMS((int, int));
  
! static void readline_default_bindings PARAMS((void));
  
  /* **************************************************************** */
***************
*** 93,96 ****
--- 97,102 ----
  const char *rl_library_version = RL_LIBRARY_VERSION;
  
+ int rl_readline_version = RL_READLINE_VERSION;
+ 
  /* True if this is `real' readline as opposed to some stub substitute. */
  int rl_gnu_readline_p = 1;
***************
*** 156,161 ****
  FILE *rl_outstream = (FILE *)NULL;
  
! /* Non-zero means echo characters as they are read. */
! int readline_echoing_p = 1;
  
  /* Current prompt. */
--- 162,170 ----
  FILE *rl_outstream = (FILE *)NULL;
  
! /* Non-zero means echo characters as they are read.  Defaults to no echo;
!    set to 1 if there is a controlling terminal, we can get its attributes,
!    and the attributes include `echo'.  Look at rltty.c:prepare_terminal_settings
!    for the code that sets it. */
! int readline_echoing_p = 0;
  
  /* Current prompt. */
***************
*** 220,224 ****
  int rl_line_buffer_len = 0;
  
! /* Forward declarations used by the display and termcap code. */
  
  /* **************************************************************** */
--- 229,233 ----
  int rl_line_buffer_len = 0;
  
! /* Forward declarations used by the display, termcap, and history code. */
  
  /* **************************************************************** */
***************
*** 241,244 ****
--- 250,261 ----
  int _rl_output_meta_chars = 0;
  
+ /* If non-zero, rl_get_previous_history and rl_get_next_history attempt
+    to preserve the value of rl_point from line to line. */
+ int _rl_history_preserve_point = 0;
+ 
+ /* Saved target point for when _rl_history_preserve_point is set.  Special
+    value of -1 means that point is at the end of the line. */
+ static int _rl_history_saved_point = -1;
+ 
  /* **************************************************************** */
  /*								    */
***************
*** 259,265 ****
    rl_prompt = prompt ? savestring (prompt) : (char *)NULL;
  
!   rl_visible_prompt_length = (rl_prompt && *rl_prompt)
! 				? rl_expand_prompt (rl_prompt)
! 				: 0;
    return 0;
  }
--- 276,280 ----
    rl_prompt = prompt ? savestring (prompt) : (char *)NULL;
  
!   rl_visible_prompt_length = rl_expand_prompt (rl_prompt);
    return 0;
  }
***************
*** 584,587 ****
--- 599,608 ----
  	    RL_UNSETSTATE(RL_STATE_METANEXT);
  
+ 	  if (newkey < 0)
+ 	    {
+ 	      _rl_abort_internal ();
+ 	      return -1;
+ 	    }
+ 
  	  r = _rl_dispatch (newkey, FUNCTION_TO_KEYMAP (map, key));
  	}
***************
*** 715,719 ****
    /* Allocate data structures. */
    if (rl_line_buffer == 0)
!     rl_line_buffer = xmalloc (rl_line_buffer_len = DEFAULT_BUFFER_SIZE);
  
    /* Initialize the terminal interface. */
--- 736,740 ----
    /* Allocate data structures. */
    if (rl_line_buffer == 0)
!     rl_line_buffer = (char *)xmalloc (rl_line_buffer_len = DEFAULT_BUFFER_SIZE);
  
    /* Initialize the terminal interface. */
***************
*** 856,859 ****
--- 877,886 ----
        RL_UNSETSTATE(RL_STATE_MOREINPUT);
  
+       if (c < 0)
+ 	{
+ 	  _rl_abort_internal ();
+ 	  return -1;
+ 	}
+ 
        /* If we see a key bound to `universal-argument' after seeing digits,
  	 it ends the argument but is otherwise ignored. */
***************
*** 902,907 ****
      }
  
!   RL_UNSETSTATE(RL_STATE_NUMERICARG);
!   return 0;
  }
  
--- 929,933 ----
      }
  
!   /*NOTREACHED*/
  }
  
***************
*** 1140,1143 ****
--- 1166,1173 ----
          rl_point -= count;
      }
+ 
+   if (rl_point < 0)
+     rl_point = 0;
+ 
    return 0;
  }
***************
*** 1345,1349 ****
    if (count > 1 && count <= 1024)
      {
!       string = xmalloc (1 + count);
  
        for (i = 0; i < count; i++)
--- 1375,1379 ----
    if (count > 1 && count <= 1024)
      {
!       string = (char *)xmalloc (1 + count);
  
        for (i = 0; i < count; i++)
***************
*** 1432,1435 ****
--- 1462,1469 ----
  {
    rl_done = 1;
+ 
+   if (_rl_history_preserve_point)
+     _rl_history_saved_point = (rl_point == rl_end) ? -1 : rl_point;
+ 
    RL_SETSTATE(RL_STATE_DONE);
  
***************
*** 1488,1495 ****
    else
      {
!       int c = the_line[--rl_point];
        rl_delete_text (rl_point, rl_point + 1);
  
!       if (rl_point == rl_end && isprint (c) && _rl_last_c_pos)
  	{
  	  int l;
--- 1522,1529 ----
    else
      {
!       unsigned char c = the_line[--rl_point];
        rl_delete_text (rl_point, rl_point + 1);
  
!       if (rl_point == rl_end && ISPRINT (c) && _rl_last_c_pos)
  	{
  	  int l;
***************
*** 1686,1690 ****
  /* **************************************************************** */
  
! /* Transpose the words at point. */
  int
  rl_transpose_words (count, key)
--- 1720,1725 ----
  /* **************************************************************** */
  
! /* Transpose the words at point.  If point is at the end of the line,
!    transpose the two words before point. */
  int
  rl_transpose_words (count, key)
***************
*** 2001,2004 ****
--- 2036,2043 ----
    rl_maybe_replace_line ();
  
+   /* either not saved by rl_newline or at end of line, so set appropriately. */
+   if (_rl_history_saved_point == -1 && (rl_point || rl_end))
+     _rl_history_saved_point = (rl_point == rl_end) ? -1 : rl_point;
+ 
    temp = (HIST_ENTRY *)NULL;
    while (count)
***************
*** 2021,2025 ****
        strcpy (the_line, temp->line);
        rl_undo_list = (UNDO_LIST *)temp->data;
!       rl_end = rl_point = strlen (the_line);
  #if defined (VI_MODE)
        if (rl_editing_mode == vi_mode)
--- 2060,2069 ----
        strcpy (the_line, temp->line);
        rl_undo_list = (UNDO_LIST *)temp->data;
!       rl_end = strlen (the_line);
!       rl_point = (_rl_history_preserve_point && _rl_history_saved_point != -1)
! 			? _rl_history_saved_point
! 			: rl_end;
!       if (rl_point > rl_end)
! 	rl_point = rl_end;
  #if defined (VI_MODE)
        if (rl_editing_mode == vi_mode)
***************
*** 2045,2048 ****
--- 2089,2096 ----
      return 0;
  
+   /* either not saved by rl_newline or at end of line, so set appropriately. */
+   if (_rl_history_saved_point == -1 && (rl_point || rl_end))
+     _rl_history_saved_point = (rl_point == rl_end) ? -1 : rl_point;
+ 
    /* If we don't have a line saved, then save this one. */
    rl_maybe_save_line ();
***************
*** 2078,2082 ****
        strcpy (the_line, temp->line);
        rl_undo_list = (UNDO_LIST *)temp->data;
!       rl_end = rl_point = line_len;
  
  #if defined (VI_MODE)
--- 2126,2135 ----
        strcpy (the_line, temp->line);
        rl_undo_list = (UNDO_LIST *)temp->data;
!       rl_end = line_len;
!       rl_point = (_rl_history_preserve_point && _rl_history_saved_point != -1)
! 			? _rl_history_saved_point
! 			: rl_end;
!       if (rl_point > rl_end)
! 	rl_point = rl_end;
  
  #if defined (VI_MODE)
diff -Nrc2 bash-2.05/lib/readline/readline.h bash-2.05a/lib/readline/readline.h
*** bash-2.05/lib/readline/readline.h	Wed Feb 14 16:27:54 2001
--- bash-2.05a/lib/readline/readline.h	Wed Sep 12 10:05:55 2001
***************
*** 38,41 ****
--- 38,46 ----
  #endif
  
+ /* Hex-encoded Readline version number. */
+ #define RL_READLINE_VERSION	0x0402		/* Readline 4.2 */
+ #define RL_VERSION_MAJOR	4
+ #define RL_VERSION_MINOR	2
+ 
  /* Readline data structures. */
  
***************
*** 74,255 ****
  
  /* Bindable commands for numeric arguments. */
! extern int rl_digit_argument __P((int, int));
! extern int rl_universal_argument __P((int, int));
  
  /* Bindable commands for moving the cursor. */
! extern int rl_forward __P((int, int));
! extern int rl_backward __P((int, int));
! extern int rl_beg_of_line __P((int, int));
! extern int rl_end_of_line __P((int, int));
! extern int rl_forward_word __P((int, int));
! extern int rl_backward_word __P((int, int));
! extern int rl_refresh_line __P((int, int));
! extern int rl_clear_screen __P((int, int));
! extern int rl_arrow_keys __P((int, int));
  
  /* Bindable commands for inserting and deleting text. */
! extern int rl_insert __P((int, int));
! extern int rl_quoted_insert __P((int, int));
! extern int rl_tab_insert __P((int, int));
! extern int rl_newline __P((int, int));
! extern int rl_do_lowercase_version __P((int, int));
! extern int rl_rubout __P((int, int));
! extern int rl_delete __P((int, int));
! extern int rl_rubout_or_delete __P((int, int));
! extern int rl_delete_horizontal_space __P((int, int));
! extern int rl_delete_or_show_completions __P((int, int));
! extern int rl_insert_comment __P((int, int));
  
  /* Bindable commands for changing case. */
! extern int rl_upcase_word __P((int, int));
! extern int rl_downcase_word __P((int, int));
! extern int rl_capitalize_word __P((int, int));
  
  /* Bindable commands for transposing characters and words. */
! extern int rl_transpose_words __P((int, int));
! extern int rl_transpose_chars __P((int, int));
  
  /* Bindable commands for searching within a line. */
! extern int rl_char_search __P((int, int));
! extern int rl_backward_char_search __P((int, int));
  
  /* Bindable commands for readline's interface to the command history. */
! extern int rl_beginning_of_history __P((int, int));
! extern int rl_end_of_history __P((int, int));
! extern int rl_get_next_history __P((int, int));
! extern int rl_get_previous_history __P((int, int));
  
  /* Bindable commands for managing the mark and region. */
! extern int rl_set_mark __P((int, int));
! extern int rl_exchange_point_and_mark __P((int, int));
  
  /* Bindable commands to set the editing mode (emacs or vi). */
! extern int rl_vi_editing_mode __P((int, int));
! extern int rl_emacs_editing_mode __P((int, int));
  
  /* Bindable commands for managing key bindings. */
! extern int rl_re_read_init_file __P((int, int));
! extern int rl_dump_functions __P((int, int));
! extern int rl_dump_macros __P((int, int));
! extern int rl_dump_variables __P((int, int));
  
  /* Bindable commands for word completion. */
! extern int rl_complete __P((int, int));
! extern int rl_possible_completions __P((int, int));
! extern int rl_insert_completions __P((int, int));
! extern int rl_menu_complete __P((int, int));
  
  /* Bindable commands for killing and yanking text, and managing the kill ring. */
! extern int rl_kill_word __P((int, int));
! extern int rl_backward_kill_word __P((int, int));
! extern int rl_kill_line __P((int, int));
! extern int rl_backward_kill_line __P((int, int));
! extern int rl_kill_full_line __P((int, int));
! extern int rl_unix_word_rubout __P((int, int));
! extern int rl_unix_line_discard __P((int, int));
! extern int rl_copy_region_to_kill __P((int, int));
! extern int rl_kill_region __P((int, int));
! extern int rl_copy_forward_word __P((int, int));
! extern int rl_copy_backward_word __P((int, int));
! extern int rl_yank __P((int, int));
! extern int rl_yank_pop __P((int, int));
! extern int rl_yank_nth_arg __P((int, int));
! extern int rl_yank_last_arg __P((int, int));
  /* Not available unless __CYGWIN__ is defined. */
  #ifdef __CYGWIN__
! extern int rl_paste_from_clipboard __P((int, int));
  #endif
  
  /* Bindable commands for incremental searching. */
! extern int rl_reverse_search_history __P((int, int));
! extern int rl_forward_search_history __P((int, int));
  
  /* Bindable keyboard macro commands. */
! extern int rl_start_kbd_macro __P((int, int));
! extern int rl_end_kbd_macro __P((int, int));
! extern int rl_call_last_kbd_macro __P((int, int));
  
  /* Bindable undo commands. */
! extern int rl_revert_line __P((int, int));
! extern int rl_undo_command __P((int, int));
  
  /* Bindable tilde expansion commands. */
! extern int rl_tilde_expand __P((int, int));
  
  /* Bindable terminal control commands. */
! extern int rl_restart_output __P((int, int));
! extern int rl_stop_output __P((int, int));
  
  /* Miscellaneous bindable commands. */
! extern int rl_abort __P((int, int));
! extern int rl_tty_status __P((int, int));
  
  /* Bindable commands for incremental and non-incremental history searching. */
! extern int rl_history_search_forward __P((int, int));
! extern int rl_history_search_backward __P((int, int));
! extern int rl_noninc_forward_search __P((int, int));
! extern int rl_noninc_reverse_search __P((int, int));
! extern int rl_noninc_forward_search_again __P((int, int));
! extern int rl_noninc_reverse_search_again __P((int, int));
  
  /* Bindable command used when inserting a matching close character. */
! extern int rl_insert_close __P((int, int));
  
  /* Not available unless READLINE_CALLBACKS is defined. */
! extern void rl_callback_handler_install __P((const char *, rl_vcpfunc_t *));
! extern void rl_callback_read_char __P((void));
! extern void rl_callback_handler_remove __P((void));
  
  /* Things for vi mode. Not available unless readline is compiled -DVI_MODE. */
  /* VI-mode bindable commands. */
! extern int rl_vi_redo __P((int, int));
! extern int rl_vi_undo __P((int, int));
! extern int rl_vi_yank_arg __P((int, int));
! extern int rl_vi_fetch_history __P((int, int));
! extern int rl_vi_search_again __P((int, int));
! extern int rl_vi_search __P((int, int));
! extern int rl_vi_complete __P((int, int));
! extern int rl_vi_tilde_expand __P((int, int));
! extern int rl_vi_prev_word __P((int, int));
! extern int rl_vi_next_word __P((int, int));
! extern int rl_vi_end_word __P((int, int));
! extern int rl_vi_insert_beg __P((int, int));
! extern int rl_vi_append_mode __P((int, int));
! extern int rl_vi_append_eol __P((int, int));
! extern int rl_vi_eof_maybe __P((int, int));
! extern int rl_vi_insertion_mode __P((int, int));
! extern int rl_vi_movement_mode __P((int, int));
! extern int rl_vi_arg_digit __P((int, int));
! extern int rl_vi_change_case __P((int, int));
! extern int rl_vi_put __P((int, int));
! extern int rl_vi_column __P((int, int));
! extern int rl_vi_delete_to __P((int, int));
! extern int rl_vi_change_to __P((int, int));
! extern int rl_vi_yank_to __P((int, int));
! extern int rl_vi_delete __P((int, int));
! extern int rl_vi_back_to_indent __P((int, int));
! extern int rl_vi_first_print __P((int, int));
! extern int rl_vi_char_search __P((int, int));
! extern int rl_vi_match __P((int, int));
! extern int rl_vi_change_char __P((int, int));
! extern int rl_vi_subst __P((int, int));
! extern int rl_vi_overstrike __P((int, int));
! extern int rl_vi_overstrike_delete __P((int, int));
! extern int rl_vi_replace __P((int, int));
! extern int rl_vi_set_mark __P((int, int));
! extern int rl_vi_goto_mark __P((int, int));
  
  /* VI-mode utility functions. */
! extern int rl_vi_check __P((void));
! extern int rl_vi_domove __P((int, int *));
! extern int rl_vi_bracktype __P((int));
  
  /* VI-mode pseudo-bindable commands, used as utility functions. */
! extern int rl_vi_fWord __P((int, int));
! extern int rl_vi_bWord __P((int, int));
! extern int rl_vi_eWord __P((int, int));
! extern int rl_vi_fword __P((int, int));
! extern int rl_vi_bword __P((int, int));
! extern int rl_vi_eword __P((int, int));
  
  /* **************************************************************** */
--- 79,260 ----
  
  /* Bindable commands for numeric arguments. */
! extern int rl_digit_argument PARAMS((int, int));
! extern int rl_universal_argument PARAMS((int, int));
  
  /* Bindable commands for moving the cursor. */
! extern int rl_forward PARAMS((int, int));
! extern int rl_backward PARAMS((int, int));
! extern int rl_beg_of_line PARAMS((int, int));
! extern int rl_end_of_line PARAMS((int, int));
! extern int rl_forward_word PARAMS((int, int));
! extern int rl_backward_word PARAMS((int, int));
! extern int rl_refresh_line PARAMS((int, int));
! extern int rl_clear_screen PARAMS((int, int));
! extern int rl_arrow_keys PARAMS((int, int));
  
  /* Bindable commands for inserting and deleting text. */
! extern int rl_insert PARAMS((int, int));
! extern int rl_quoted_insert PARAMS((int, int));
! extern int rl_tab_insert PARAMS((int, int));
! extern int rl_newline PARAMS((int, int));
! extern int rl_do_lowercase_version PARAMS((int, int));
! extern int rl_rubout PARAMS((int, int));
! extern int rl_delete PARAMS((int, int));
! extern int rl_rubout_or_delete PARAMS((int, int));
! extern int rl_delete_horizontal_space PARAMS((int, int));
! extern int rl_delete_or_show_completions PARAMS((int, int));
! extern int rl_insert_comment PARAMS((int, int));
  
  /* Bindable commands for changing case. */
! extern int rl_upcase_word PARAMS((int, int));
! extern int rl_downcase_word PARAMS((int, int));
! extern int rl_capitalize_word PARAMS((int, int));
  
  /* Bindable commands for transposing characters and words. */
! extern int rl_transpose_words PARAMS((int, int));
! extern int rl_transpose_chars PARAMS((int, int));
  
  /* Bindable commands for searching within a line. */
! extern int rl_char_search PARAMS((int, int));
! extern int rl_backward_char_search PARAMS((int, int));
  
  /* Bindable commands for readline's interface to the command history. */
! extern int rl_beginning_of_history PARAMS((int, int));
! extern int rl_end_of_history PARAMS((int, int));
! extern int rl_get_next_history PARAMS((int, int));
! extern int rl_get_previous_history PARAMS((int, int));
  
  /* Bindable commands for managing the mark and region. */
! extern int rl_set_mark PARAMS((int, int));
! extern int rl_exchange_point_and_mark PARAMS((int, int));
  
  /* Bindable commands to set the editing mode (emacs or vi). */
! extern int rl_vi_editing_mode PARAMS((int, int));
! extern int rl_emacs_editing_mode PARAMS((int, int));
  
  /* Bindable commands for managing key bindings. */
! extern int rl_re_read_init_file PARAMS((int, int));
! extern int rl_dump_functions PARAMS((int, int));
! extern int rl_dump_macros PARAMS((int, int));
! extern int rl_dump_variables PARAMS((int, int));
  
  /* Bindable commands for word completion. */
! extern int rl_complete PARAMS((int, int));
! extern int rl_possible_completions PARAMS((int, int));
! extern int rl_insert_completions PARAMS((int, int));
! extern int rl_menu_complete PARAMS((int, int));
  
  /* Bindable commands for killing and yanking text, and managing the kill ring. */
! extern int rl_kill_word PARAMS((int, int));
! extern int rl_backward_kill_word PARAMS((int, int));
! extern int rl_kill_line PARAMS((int, int));
! extern int rl_backward_kill_line PARAMS((int, int));
! extern int rl_kill_full_line PARAMS((int, int));
! extern int rl_unix_word_rubout PARAMS((int, int));
! extern int rl_unix_line_discard PARAMS((int, int));
! extern int rl_copy_region_to_kill PARAMS((int, int));
! extern int rl_kill_region PARAMS((int, int));
! extern int rl_copy_forward_word PARAMS((int, int));
! extern int rl_copy_backward_word PARAMS((int, int));
! extern int rl_yank PARAMS((int, int));
! extern int rl_yank_pop PARAMS((int, int));
! extern int rl_yank_nth_arg PARAMS((int, int));
! extern int rl_yank_last_arg PARAMS((int, int));
  /* Not available unless __CYGWIN__ is defined. */
  #ifdef __CYGWIN__
! extern int rl_paste_from_clipboard PARAMS((int, int));
  #endif
  
  /* Bindable commands for incremental searching. */
! extern int rl_reverse_search_history PARAMS((int, int));
! extern int rl_forward_search_history PARAMS((int, int));
  
  /* Bindable keyboard macro commands. */
! extern int rl_start_kbd_macro PARAMS((int, int));
! extern int rl_end_kbd_macro PARAMS((int, int));
! extern int rl_call_last_kbd_macro PARAMS((int, int));
  
  /* Bindable undo commands. */
! extern int rl_revert_line PARAMS((int, int));
! extern int rl_undo_command PARAMS((int, int));
  
  /* Bindable tilde expansion commands. */
! extern int rl_tilde_expand PARAMS((int, int));
  
  /* Bindable terminal control commands. */
! extern int rl_restart_output PARAMS((int, int));
! extern int rl_stop_output PARAMS((int, int));
  
  /* Miscellaneous bindable commands. */
! extern int rl_abort PARAMS((int, int));
! extern int rl_tty_status PARAMS((int, int));
  
  /* Bindable commands for incremental and non-incremental history searching. */
! extern int rl_history_search_forward PARAMS((int, int));
! extern int rl_history_search_backward PARAMS((int, int));
! extern int rl_noninc_forward_search PARAMS((int, int));
! extern int rl_noninc_reverse_search PARAMS((int, int));
! extern int rl_noninc_forward_search_again PARAMS((int, int));
! extern int rl_noninc_reverse_search_again PARAMS((int, int));
  
  /* Bindable command used when inserting a matching close character. */
! extern int rl_insert_close PARAMS((int, int));
  
  /* Not available unless READLINE_CALLBACKS is defined. */
! extern void rl_callback_handler_install PARAMS((const char *, rl_vcpfunc_t *));
! extern void rl_callback_read_char PARAMS((void));
! extern void rl_callback_handler_remove PARAMS((void));
  
  /* Things for vi mode. Not available unless readline is compiled -DVI_MODE. */
  /* VI-mode bindable commands. */
! extern int rl_vi_redo PARAMS((int, int));
! extern int rl_vi_undo PARAMS((int, int));
! extern int rl_vi_yank_arg PARAMS((int, int));
! extern int rl_vi_fetch_history PARAMS((int, int));
! extern int rl_vi_search_again PARAMS((int, int));
! extern int rl_vi_search PARAMS((int, int));
! extern int rl_vi_complete PARAMS((int, int));
! extern int rl_vi_tilde_expand PARAMS((int, int));
! extern int rl_vi_prev_word PARAMS((int, int));
! extern int rl_vi_next_word PARAMS((int, int));
! extern int rl_vi_end_word PARAMS((int, int));
! extern int rl_vi_insert_beg PARAMS((int, int));
! extern int rl_vi_append_mode PARAMS((int, int));
! extern int rl_vi_append_eol PARAMS((int, int));
! extern int rl_vi_eof_maybe PARAMS((int, int));
! extern int rl_vi_insertion_mode PARAMS((int, int));
! extern int rl_vi_movement_mode PARAMS((int, int));
! extern int rl_vi_arg_digit PARAMS((int, int));
! extern int rl_vi_change_case PARAMS((int, int));
! extern int rl_vi_put PARAMS((int, int));
! extern int rl_vi_column PARAMS((int, int));
! extern int rl_vi_delete_to PARAMS((int, int));
! extern int rl_vi_change_to PARAMS((int, int));
! extern int rl_vi_yank_to PARAMS((int, int));
! extern int rl_vi_delete PARAMS((int, int));
! extern int rl_vi_back_to_indent PARAMS((int, int));
! extern int rl_vi_first_print PARAMS((int, int));
! extern int rl_vi_char_search PARAMS((int, int));
! extern int rl_vi_match PARAMS((int, int));
! extern int rl_vi_change_char PARAMS((int, int));
! extern int rl_vi_subst PARAMS((int, int));
! extern int rl_vi_overstrike PARAMS((int, int));
! extern int rl_vi_overstrike_delete PARAMS((int, int));
! extern int rl_vi_replace PARAMS((int, int));
! extern int rl_vi_set_mark PARAMS((int, int));
! extern int rl_vi_goto_mark PARAMS((int, int));
  
  /* VI-mode utility functions. */
! extern int rl_vi_check PARAMS((void));
! extern int rl_vi_domove PARAMS((int, int *));
! extern int rl_vi_bracktype PARAMS((int));
  
  /* VI-mode pseudo-bindable commands, used as utility functions. */
! extern int rl_vi_fWord PARAMS((int, int));
! extern int rl_vi_bWord PARAMS((int, int));
! extern int rl_vi_eWord PARAMS((int, int));
! extern int rl_vi_fword PARAMS((int, int));
! extern int rl_vi_bword PARAMS((int, int));
! extern int rl_vi_eword PARAMS((int, int));
  
  /* **************************************************************** */
***************
*** 261,429 ****
  /* Readline functions. */
  /* Read a line of input.  Prompt with PROMPT.  A NULL PROMPT means none. */
! extern char *readline __P((const char *));
  
! extern int rl_set_prompt __P((const char *));
! extern int rl_expand_prompt __P((char *));
  
! extern int rl_initialize __P((void));
  
  /* Undocumented; unused by readline */
! extern int rl_discard_argument __P((void));
  
  /* Utility functions to bind keys to readline commands. */
! extern int rl_add_defun __P((const char *, rl_command_func_t *, int));
! extern int rl_bind_key __P((int, rl_command_func_t *));
! extern int rl_bind_key_in_map __P((int, rl_command_func_t *, Keymap));
! extern int rl_unbind_key __P((int));
! extern int rl_unbind_key_in_map __P((int, Keymap));
! extern int rl_unbind_function_in_map __P((rl_command_func_t *, Keymap));
! extern int rl_unbind_command_in_map __P((const char *, Keymap));
! extern int rl_set_key __P((const char *, rl_command_func_t *, Keymap));
! extern int rl_generic_bind __P((int, const char *, char *, Keymap));
! extern int rl_variable_bind __P((const char *, const char *));
  
  /* Backwards compatibility, use rl_generic_bind instead. */
! extern int rl_macro_bind __P((const char *, const char *, Keymap));
  
  /* Undocumented in the texinfo manual; not really useful to programs. */
! extern int rl_translate_keyseq __P((const char *, char *, int *));
! extern char *rl_untranslate_keyseq __P((int));
  
! extern rl_command_func_t *rl_named_function __P((const char *));
! extern rl_command_func_t *rl_function_of_keyseq __P((const char *, Keymap, int *));
  
! extern void rl_list_funmap_names __P((void));
! extern char **rl_invoking_keyseqs_in_map __P((rl_command_func_t *, Keymap));
! extern char **rl_invoking_keyseqs __P((rl_command_func_t *));
   
! extern void rl_function_dumper __P((int));
! extern void rl_macro_dumper __P((int));
! extern void rl_variable_dumper __P((int));
  
! extern int rl_read_init_file __P((const char *));
! extern int rl_parse_and_bind __P((char *));
  
  /* Functions for manipulating keymaps. */
! extern Keymap rl_make_bare_keymap __P((void));
! extern Keymap rl_copy_keymap __P((Keymap));
! extern Keymap rl_make_keymap __P((void));
! extern void rl_discard_keymap __P((Keymap));
! 
! extern Keymap rl_get_keymap_by_name __P((const char *));
! extern char *rl_get_keymap_name __P((Keymap));
! extern void rl_set_keymap __P((Keymap));
! extern Keymap rl_get_keymap __P((void));
  /* Undocumented; used internally only. */
! extern void rl_set_keymap_from_edit_mode __P((void));
! extern char *rl_get_keymap_name_from_edit_mode __P((void));
  
  /* Functions for manipulating the funmap, which maps command names to functions. */
! extern int rl_add_funmap_entry __P((const char *, rl_command_func_t *));
! extern const char **rl_funmap_names __P((void));
  /* Undocumented, only used internally -- there is only one funmap, and this
     function may be called only once. */
! extern void rl_initialize_funmap __P((void));
  
  /* Utility functions for managing keyboard macros. */
! extern void rl_push_macro_input __P((char *));
  
  /* Functions for undoing, from undo.c */
! extern void rl_add_undo __P((enum undo_code, int, int, char *));
! extern void rl_free_undo_list __P((void));
! extern int rl_do_undo __P((void));
! extern int rl_begin_undo_group __P((void));
! extern int rl_end_undo_group __P((void));
! extern int rl_modifying __P((int, int));
  
  /* Functions for redisplay. */
! extern void rl_redisplay __P((void));
! extern int rl_on_new_line __P((void));
! extern int rl_on_new_line_with_prompt __P((void));
! extern int rl_forced_update_display __P((void));
! extern int rl_clear_message __P((void));
! extern int rl_reset_line_state __P((void));
! extern int rl_crlf __P((void));
  
  #if (defined (__STDC__) || defined (__cplusplus)) && defined (USE_VARARGS) && defined (PREFER_STDARG)
! extern int rl_message (const char *, ...);
  #else
  extern int rl_message ();
  #endif
  
! extern int rl_show_char __P((int));
  
  /* Undocumented in texinfo manual. */
! extern int rl_character_len __P((int, int));
  
  /* Save and restore internal prompt redisplay information. */
! extern void rl_save_prompt __P((void));
! extern void rl_restore_prompt __P((void));
  
  /* Modifying text. */
! extern int rl_insert_text __P((const char *));
! extern int rl_delete_text __P((int, int));
! extern int rl_kill_text __P((int, int));
! extern char *rl_copy_text __P((int, int));
  
  /* Terminal and tty mode management. */
! extern void rl_prep_terminal __P((int));
! extern void rl_deprep_terminal __P((void));
! extern void rl_tty_set_default_bindings __P((Keymap));
! 
! extern int rl_reset_terminal __P((const char *));
! extern void rl_resize_terminal __P((void));
! extern void rl_set_screen_size __P((int, int));
! extern void rl_get_screen_size __P((int *, int *));
  
  /* Functions for character input. */
! extern int rl_stuff_char __P((int));
! extern int rl_execute_next __P((int));
! extern int rl_clear_pending_input __P((void));
! extern int rl_read_key __P((void));
! extern int rl_getc __P((FILE *));
! extern int rl_set_keyboard_input_timeout __P((int));
  
  /* `Public' utility functions . */
! extern void rl_extend_line_buffer __P((int));
! extern int rl_ding __P((void));
! extern int rl_alphabetic __P((int));
  
  /* Readline signal handling, from signals.c */
! extern int rl_set_signals __P((void));
! extern int rl_clear_signals __P((void));
! extern void rl_cleanup_after_signal __P((void));
! extern void rl_reset_after_signal __P((void));
! extern void rl_free_line_state __P((void));
   
! /* Undocumented. */
! extern int rl_set_paren_blink_timeout __P((int));
  
  /* Undocumented. */
! extern int rl_maybe_save_line __P((void));
! extern int rl_maybe_unsave_line __P((void));
! extern int rl_maybe_replace_line __P((void));
  
  /* Completion functions. */
! extern int rl_complete_internal __P((int));
! extern void rl_display_match_list __P((char **, int, int));
  
! extern char **rl_completion_matches __P((const char *, rl_compentry_func_t *));
! extern char *rl_username_completion_function __P((const char *, int));
! extern char *rl_filename_completion_function __P((const char *, int));
  
  #if 0
  /* Backwards compatibility (compat.c).  These will go away sometime. */
! extern void free_undo_list __P((void));
! extern int maybe_save_line __P((void));
! extern int maybe_unsave_line __P((void));
! extern int maybe_replace_line __P((void));
! 
! extern int ding __P((void));
! extern int alphabetic __P((int));
! extern int crlf __P((void));
! 
! extern char **completion_matches __P((char *, rl_compentry_func_t *));
! extern char *username_completion_function __P((const char *, int));
! extern char *filename_completion_function __P((const char *, int));
  #endif
  
--- 266,435 ----
  /* Readline functions. */
  /* Read a line of input.  Prompt with PROMPT.  A NULL PROMPT means none. */
! extern char *readline PARAMS((const char *));
  
! extern int rl_set_prompt PARAMS((const char *));
! extern int rl_expand_prompt PARAMS((char *));
  
! extern int rl_initialize PARAMS((void));
  
  /* Undocumented; unused by readline */
! extern int rl_discard_argument PARAMS((void));
  
  /* Utility functions to bind keys to readline commands. */
! extern int rl_add_defun PARAMS((const char *, rl_command_func_t *, int));
! extern int rl_bind_key PARAMS((int, rl_command_func_t *));
! extern int rl_bind_key_in_map PARAMS((int, rl_command_func_t *, Keymap));
! extern int rl_unbind_key PARAMS((int));
! extern int rl_unbind_key_in_map PARAMS((int, Keymap));
! extern int rl_unbind_function_in_map PARAMS((rl_command_func_t *, Keymap));
! extern int rl_unbind_command_in_map PARAMS((const char *, Keymap));
! extern int rl_set_key PARAMS((const char *, rl_command_func_t *, Keymap));
! extern int rl_generic_bind PARAMS((int, const char *, char *, Keymap));
! extern int rl_variable_bind PARAMS((const char *, const char *));
  
  /* Backwards compatibility, use rl_generic_bind instead. */
! extern int rl_macro_bind PARAMS((const char *, const char *, Keymap));
  
  /* Undocumented in the texinfo manual; not really useful to programs. */
! extern int rl_translate_keyseq PARAMS((const char *, char *, int *));
! extern char *rl_untranslate_keyseq PARAMS((int));
  
! extern rl_command_func_t *rl_named_function PARAMS((const char *));
! extern rl_command_func_t *rl_function_of_keyseq PARAMS((const char *, Keymap, int *));
  
! extern void rl_list_funmap_names PARAMS((void));
! extern char **rl_invoking_keyseqs_in_map PARAMS((rl_command_func_t *, Keymap));
! extern char **rl_invoking_keyseqs PARAMS((rl_command_func_t *));
   
! extern void rl_function_dumper PARAMS((int));
! extern void rl_macro_dumper PARAMS((int));
! extern void rl_variable_dumper PARAMS((int));
  
! extern int rl_read_init_file PARAMS((const char *));
! extern int rl_parse_and_bind PARAMS((char *));
  
  /* Functions for manipulating keymaps. */
! extern Keymap rl_make_bare_keymap PARAMS((void));
! extern Keymap rl_copy_keymap PARAMS((Keymap));
! extern Keymap rl_make_keymap PARAMS((void));
! extern void rl_discard_keymap PARAMS((Keymap));
! 
! extern Keymap rl_get_keymap_by_name PARAMS((const char *));
! extern char *rl_get_keymap_name PARAMS((Keymap));
! extern void rl_set_keymap PARAMS((Keymap));
! extern Keymap rl_get_keymap PARAMS((void));
  /* Undocumented; used internally only. */
! extern void rl_set_keymap_from_edit_mode PARAMS((void));
! extern char *rl_get_keymap_name_from_edit_mode PARAMS((void));
  
  /* Functions for manipulating the funmap, which maps command names to functions. */
! extern int rl_add_funmap_entry PARAMS((const char *, rl_command_func_t *));
! extern const char **rl_funmap_names PARAMS((void));
  /* Undocumented, only used internally -- there is only one funmap, and this
     function may be called only once. */
! extern void rl_initialize_funmap PARAMS((void));
  
  /* Utility functions for managing keyboard macros. */
! extern void rl_push_macro_input PARAMS((char *));
  
  /* Functions for undoing, from undo.c */
! extern void rl_add_undo PARAMS((enum undo_code, int, int, char *));
! extern void rl_free_undo_list PARAMS((void));
! extern int rl_do_undo PARAMS((void));
! extern int rl_begin_undo_group PARAMS((void));
! extern int rl_end_undo_group PARAMS((void));
! extern int rl_modifying PARAMS((int, int));
  
  /* Functions for redisplay. */
! extern void rl_redisplay PARAMS((void));
! extern int rl_on_new_line PARAMS((void));
! extern int rl_on_new_line_with_prompt PARAMS((void));
! extern int rl_forced_update_display PARAMS((void));
! extern int rl_clear_message PARAMS((void));
! extern int rl_reset_line_state PARAMS((void));
! extern int rl_crlf PARAMS((void));
  
  #if (defined (__STDC__) || defined (__cplusplus)) && defined (USE_VARARGS) && defined (PREFER_STDARG)
! extern int rl_message (const char *, ...)  __attribute__((__format__ (printf, 1, 2)));
  #else
  extern int rl_message ();
  #endif
  
! extern int rl_show_char PARAMS((int));
  
  /* Undocumented in texinfo manual. */
! extern int rl_character_len PARAMS((int, int));
  
  /* Save and restore internal prompt redisplay information. */
! extern void rl_save_prompt PARAMS((void));
! extern void rl_restore_prompt PARAMS((void));
  
  /* Modifying text. */
! extern int rl_insert_text PARAMS((const char *));
! extern int rl_delete_text PARAMS((int, int));
! extern int rl_kill_text PARAMS((int, int));
! extern char *rl_copy_text PARAMS((int, int));
  
  /* Terminal and tty mode management. */
! extern void rl_prep_terminal PARAMS((int));
! extern void rl_deprep_terminal PARAMS((void));
! extern void rl_tty_set_default_bindings PARAMS((Keymap));
! 
! extern int rl_reset_terminal PARAMS((const char *));
! extern void rl_resize_terminal PARAMS((void));
! extern void rl_set_screen_size PARAMS((int, int));
! extern void rl_get_screen_size PARAMS((int *, int *));
! 
! extern char *rl_get_termcap PARAMS((const char *));
  
  /* Functions for character input. */
! extern int rl_stuff_char PARAMS((int));
! extern int rl_execute_next PARAMS((int));
! extern int rl_clear_pending_input PARAMS((void));
! extern int rl_read_key PARAMS((void));
! extern int rl_getc PARAMS((FILE *));
! extern int rl_set_keyboard_input_timeout PARAMS((int));
  
  /* `Public' utility functions . */
! extern void rl_extend_line_buffer PARAMS((int));
! extern int rl_ding PARAMS((void));
! extern int rl_alphabetic PARAMS((int));
  
  /* Readline signal handling, from signals.c */
! extern int rl_set_signals PARAMS((void));
! extern int rl_clear_signals PARAMS((void));
! extern void rl_cleanup_after_signal PARAMS((void));
! extern void rl_reset_after_signal PARAMS((void));
! extern void rl_free_line_state PARAMS((void));
   
! extern int rl_set_paren_blink_timeout PARAMS((int));
  
  /* Undocumented. */
! extern int rl_maybe_save_line PARAMS((void));
! extern int rl_maybe_unsave_line PARAMS((void));
! extern int rl_maybe_replace_line PARAMS((void));
  
  /* Completion functions. */
! extern int rl_complete_internal PARAMS((int));
! extern void rl_display_match_list PARAMS((char **, int, int));
  
! extern char **rl_completion_matches PARAMS((const char *, rl_compentry_func_t *));
! extern char *rl_username_completion_function PARAMS((const char *, int));
! extern char *rl_filename_completion_function PARAMS((const char *, int));
  
  #if 0
  /* Backwards compatibility (compat.c).  These will go away sometime. */
! extern void free_undo_list PARAMS((void));
! extern int maybe_save_line PARAMS((void));
! extern int maybe_unsave_line PARAMS((void));
! extern int maybe_replace_line PARAMS((void));
! 
! extern int ding PARAMS((void));
! extern int alphabetic PARAMS((int));
! extern int crlf PARAMS((void));
! 
! extern char **completion_matches PARAMS((char *, rl_compentry_func_t *));
! extern char *username_completion_function PARAMS((const char *, int));
! extern char *filename_completion_function PARAMS((const char *, int));
  #endif
  
***************
*** 435,439 ****
  
  /* The version of this incarnation of the readline library. */
! extern const char *rl_library_version;
  
  /* True if this is real GNU readline. */
--- 441,446 ----
  
  /* The version of this incarnation of the readline library. */
! extern const char *rl_library_version;		/* e.g., "4.2" */
! extern int rl_readline_version;			/* e.g., 0x0402 */
  
  /* True if this is real GNU readline. */
***************
*** 552,557 ****
  /* Completion variables. */
  /* Pointer to the generator function for completion_matches ().
!    NULL means to use filename_entry_function (), the default filename
!    completer. */
  extern rl_compentry_func_t *rl_completion_entry_function;
  
--- 559,564 ----
  /* Completion variables. */
  /* Pointer to the generator function for completion_matches ().
!    NULL means to use rl_filename_completion_function (), the default
!    filename completer. */
  extern rl_compentry_func_t *rl_completion_entry_function;
  
diff -Nrc2 bash-2.05/lib/readline/rldefs.h bash-2.05a/lib/readline/rldefs.h
*** bash-2.05/lib/readline/rldefs.h	Wed Nov  8 10:50:32 2000
--- bash-2.05a/lib/readline/rldefs.h	Mon Oct 29 10:26:39 2001
***************
*** 74,79 ****
  #define _rl_strnicmp strncasecmp
  #else
! extern int _rl_stricmp __P((char *, char *);
! extern int _rl_strnicmp __P((char *, char *));
  #endif
  
--- 74,85 ----
  #define _rl_strnicmp strncasecmp
  #else
! extern int _rl_stricmp PARAMS((char *, char *));
! extern int _rl_strnicmp PARAMS((char *, char *));
! #endif
! 
! #if defined (HAVE_STRPBRK)
! #  define _rl_strpbrk(a,b)	strpbrk((a),(b))
! #else
! extern char *_rl_strpbrk PARAMS((const char *, const char *));
  #endif
  
***************
*** 98,103 ****
  
  #ifndef savestring
! extern char *xmalloc __P((int));
! #define savestring(x) strcpy (xmalloc (1 + strlen (x)), (x))
  #endif
  
--- 104,108 ----
  
  #ifndef savestring
! #define savestring(x) strcpy ((char *)xmalloc (1 + strlen (x)), (x))
  #endif
  
diff -Nrc2 bash-2.05/lib/readline/rlprivate.h bash-2.05a/lib/readline/rlprivate.h
*** bash-2.05/lib/readline/rlprivate.h	Wed Feb 14 07:43:14 2001
--- bash-2.05a/lib/readline/rlprivate.h	Mon Oct 29 10:24:34 2001
***************
*** 27,31 ****
  #include "rlconf.h"	/* for VISIBLE_STATS */
  #include "rlstdc.h"
! #include "posixjmp.h" /* defines procenv_t */
  
  /*************************************************************************
--- 27,31 ----
  #include "rlconf.h"	/* for VISIBLE_STATS */
  #include "rlstdc.h"
! #include "posixjmp.h"	/* defines procenv_t */
  
  /*************************************************************************
***************
*** 35,41 ****
   *************************************************************************/
  
- /* terminal.c */
- extern char *rl_get_termcap __P((const char *));
- 
  /*************************************************************************
   *									 *
--- 35,38 ----
***************
*** 70,92 ****
  
  /* bind.c */
! extern char *rl_untranslate_keyseq __P((int));
  
  /* kill.c */
! extern int rl_set_retained_kills __P((int));
  
  /* readline.c */
! extern int rl_discard_argument __P((void));
  
  /* rltty.c */
! extern int rl_stop_output __P((int, int));
  
  /* terminal.c */
! extern void _rl_set_screen_size __P((int, int));
  
  /* undo.c */
! extern int _rl_fix_last_undo_of_type __P((int, int, int));
  
  /* util.c */
! extern char *_rl_savestring __P((const char *));
  
  /*************************************************************************
--- 67,89 ----
  
  /* bind.c */
! extern char *rl_untranslate_keyseq PARAMS((int));
  
  /* kill.c */
! extern int rl_set_retained_kills PARAMS((int));
  
  /* readline.c */
! extern int rl_discard_argument PARAMS((void));
  
  /* rltty.c */
! extern int rl_stop_output PARAMS((int, int));
  
  /* terminal.c */
! extern void _rl_set_screen_size PARAMS((int, int));
  
  /* undo.c */
! extern int _rl_fix_last_undo_of_type PARAMS((int, int, int));
  
  /* util.c */
! extern char *_rl_savestring PARAMS((const char *));
  
  /*************************************************************************
***************
*** 108,203 ****
  
  /* readline.c */
! extern void readline_internal_setup __P((void));
! extern char *readline_internal_teardown __P((int));
! extern int readline_internal_char __P((void));
  
  #endif /* READLINE_CALLBACKS */
  
  /* bind.c */
! extern void _rl_bind_if_unbound __P((const char *, rl_command_func_t *));
  
  /* display.c */
! extern char *_rl_strip_prompt __P((char *));
! extern void _rl_move_cursor_relative __P((int, const char *));
! extern void _rl_move_vert __P((int));
! extern void _rl_save_prompt __P((void));
! extern void _rl_restore_prompt __P((void));
! extern char *_rl_make_prompt_for_search __P((int));
! extern void _rl_erase_at_end_of_line __P((int));
! extern void _rl_clear_to_eol __P((int));
! extern void _rl_clear_screen __P((void));
! extern void _rl_update_final __P((void));
! extern void _rl_redisplay_after_sigwinch __P((void));
! extern void _rl_clean_up_for_exit __P((void));
! extern void _rl_erase_entire_line __P((void));
! extern int _rl_current_display_line __P((void));
  
  /* input.c */
! extern int _rl_any_typein __P((void));
! extern int _rl_input_available __P((void));
! extern void _rl_insert_typein __P((int));
  
  /* macro.c */
! extern void _rl_with_macro_input __P((char *));
! extern int _rl_next_macro_key __P((void));
! extern void _rl_push_executing_macro __P((void));
! extern void _rl_pop_executing_macro __P((void));
! extern void _rl_add_macro_char __P((int));
! extern void _rl_kill_kbd_macro __P((void));
  
  /* nls.c */
! extern int _rl_init_eightbit __P((void));
  
  /* parens.c */
! extern void _rl_enable_paren_matching __P((int));
  
  /* readline.c */
! extern void _rl_init_line_state __P((void));
! extern void _rl_set_the_line __P((void));
! extern int _rl_dispatch __P((int, Keymap));
! extern int _rl_init_argument __P((void));
! extern void _rl_fix_point __P((int));
! extern void _rl_replace_text __P((const char *, int, int));
! extern int _rl_char_search_internal __P((int, int, int));
! extern int _rl_set_mark_at_pos __P((int));
! extern int _rl_free_saved_history_line __P((void));
  
  /* rltty.c */
! extern int _rl_disable_tty_signals __P((void));
! extern int _rl_restore_tty_signals __P((void));
  
  /* terminal.c */
! extern void _rl_get_screen_size __P((int, int));
! extern int _rl_init_terminal_io __P((const char *));
  #ifdef _MINIX
! extern void _rl_output_character_function __P((int));
  #else
! extern int _rl_output_character_function __P((int));
  #endif
! extern void _rl_output_some_chars __P((const char *, int));
! extern int _rl_backspace __P((int));
! extern void _rl_enable_meta_key __P((void));
! extern void _rl_control_keypad __P((int));
  
  /* util.c */
! extern int rl_alphabetic __P((int));
! extern int _rl_abort_internal __P((void));
! extern char *_rl_strindex __P((const char *, const char *));
! extern char *_rl_strpbrk __P((const char *, const char *));
! extern int _rl_qsort_string_compare __P((char **, char **));
! extern int (_rl_uppercase_p) __P((int));
! extern int (_rl_lowercase_p) __P((int));
! extern int (_rl_pure_alphabetic) __P((int));
! extern int (_rl_digit_p) __P((int));
! extern int (_rl_to_lower) __P((int));
! extern int (_rl_to_upper) __P((int));
! extern int (_rl_digit_value) __P((int));
  
  /* vi_mode.c */
! extern void _rl_vi_initialize_line __P((void));
! extern void _rl_vi_reset_last __P((void));
! extern void _rl_vi_set_last __P((int, int, int));
! extern int _rl_vi_textmod_command __P((int));
! extern void _rl_vi_done_inserting __P((void));
  
  /*************************************************************************
--- 105,199 ----
  
  /* readline.c */
! extern void readline_internal_setup PARAMS((void));
! extern char *readline_internal_teardown PARAMS((int));
! extern int readline_internal_char PARAMS((void));
  
  #endif /* READLINE_CALLBACKS */
  
  /* bind.c */
! extern void _rl_bind_if_unbound PARAMS((const char *, rl_command_func_t *));
  
  /* display.c */
! extern char *_rl_strip_prompt PARAMS((char *));
! extern void _rl_move_cursor_relative PARAMS((int, const char *));
! extern void _rl_move_vert PARAMS((int));
! extern void _rl_save_prompt PARAMS((void));
! extern void _rl_restore_prompt PARAMS((void));
! extern char *_rl_make_prompt_for_search PARAMS((int));
! extern void _rl_erase_at_end_of_line PARAMS((int));
! extern void _rl_clear_to_eol PARAMS((int));
! extern void _rl_clear_screen PARAMS((void));
! extern void _rl_update_final PARAMS((void));
! extern void _rl_redisplay_after_sigwinch PARAMS((void));
! extern void _rl_clean_up_for_exit PARAMS((void));
! extern void _rl_erase_entire_line PARAMS((void));
! extern int _rl_current_display_line PARAMS((void));
  
  /* input.c */
! extern int _rl_any_typein PARAMS((void));
! extern int _rl_input_available PARAMS((void));
! extern void _rl_insert_typein PARAMS((int));
  
  /* macro.c */
! extern void _rl_with_macro_input PARAMS((char *));
! extern int _rl_next_macro_key PARAMS((void));
! extern void _rl_push_executing_macro PARAMS((void));
! extern void _rl_pop_executing_macro PARAMS((void));
! extern void _rl_add_macro_char PARAMS((int));
! extern void _rl_kill_kbd_macro PARAMS((void));
  
  /* nls.c */
! extern int _rl_init_eightbit PARAMS((void));
  
  /* parens.c */
! extern void _rl_enable_paren_matching PARAMS((int));
  
  /* readline.c */
! extern void _rl_init_line_state PARAMS((void));
! extern void _rl_set_the_line PARAMS((void));
! extern int _rl_dispatch PARAMS((int, Keymap));
! extern int _rl_init_argument PARAMS((void));
! extern void _rl_fix_point PARAMS((int));
! extern void _rl_replace_text PARAMS((const char *, int, int));
! extern int _rl_char_search_internal PARAMS((int, int, int));
! extern int _rl_set_mark_at_pos PARAMS((int));
! extern int _rl_free_saved_history_line PARAMS((void));
  
  /* rltty.c */
! extern int _rl_disable_tty_signals PARAMS((void));
! extern int _rl_restore_tty_signals PARAMS((void));
  
  /* terminal.c */
! extern void _rl_get_screen_size PARAMS((int, int));
! extern int _rl_init_terminal_io PARAMS((const char *));
  #ifdef _MINIX
! extern void _rl_output_character_function PARAMS((int));
  #else
! extern int _rl_output_character_function PARAMS((int));
  #endif
! extern void _rl_output_some_chars PARAMS((const char *, int));
! extern int _rl_backspace PARAMS((int));
! extern void _rl_enable_meta_key PARAMS((void));
! extern void _rl_control_keypad PARAMS((int));
  
  /* util.c */
! extern int rl_alphabetic PARAMS((int));
! extern int _rl_abort_internal PARAMS((void));
! extern char *_rl_strindex PARAMS((const char *, const char *));
! extern int _rl_qsort_string_compare PARAMS((char **, char **));
! extern int (_rl_uppercase_p) PARAMS((int));
! extern int (_rl_lowercase_p) PARAMS((int));
! extern int (_rl_pure_alphabetic) PARAMS((int));
! extern int (_rl_digit_p) PARAMS((int));
! extern int (_rl_to_lower) PARAMS((int));
! extern int (_rl_to_upper) PARAMS((int));
! extern int (_rl_digit_value) PARAMS((int));
  
  /* vi_mode.c */
! extern void _rl_vi_initialize_line PARAMS((void));
! extern void _rl_vi_reset_last PARAMS((void));
! extern void _rl_vi_set_last PARAMS((int, int, int));
! extern int _rl_vi_textmod_command PARAMS((int));
! extern void _rl_vi_done_inserting PARAMS((void));
  
  /*************************************************************************
***************
*** 214,217 ****
--- 210,214 ----
  extern int _rl_print_completions_horizontally;
  extern int _rl_completion_case_fold;
+ extern int _rl_match_hidden_files;
  
  /* display.c */
***************
*** 222,226 ****
  
  /* isearch.c */
! extern unsigned char *_rl_isearch_terminators;
  
  /* macro.c */
--- 219,223 ----
  
  /* isearch.c */
! extern char *_rl_isearch_terminators;
  
  /* macro.c */
***************
*** 235,238 ****
--- 232,236 ----
  extern int _rl_convert_meta_chars_to_ascii;
  extern int _rl_output_meta_chars;
+ extern int _rl_history_preserve_point;
  extern char *_rl_comment_begin;
  extern unsigned char _rl_parsing_conditionalized_out;
diff -Nrc2 bash-2.05/lib/readline/rlshell.h bash-2.05a/lib/readline/rlshell.h
*** bash-2.05/lib/readline/rlshell.h	Wed Nov  8 10:51:03 2000
--- bash-2.05a/lib/readline/rlshell.h	Wed Aug 22 09:37:56 2001
***************
*** 26,34 ****
  #include "rlstdc.h"
  
! extern char *sh_single_quote __P((char *));
! extern void sh_set_lines_and_columns __P((int, int));
! extern char *sh_get_env_value __P((const char *));
! extern char *sh_get_home_dir __P((void));
! extern int sh_unset_nodelay_mode __P((int));
  
  #endif /* _RL_SHELL_H_ */
--- 26,34 ----
  #include "rlstdc.h"
  
! extern char *sh_single_quote PARAMS((char *));
! extern void sh_set_lines_and_columns PARAMS((int, int));
! extern char *sh_get_env_value PARAMS((const char *));
! extern char *sh_get_home_dir PARAMS((void));
! extern int sh_unset_nodelay_mode PARAMS((int));
  
  #endif /* _RL_SHELL_H_ */
diff -Nrc2 bash-2.05/lib/readline/rlstdc.h bash-2.05a/lib/readline/rlstdc.h
*** bash-2.05/lib/readline/rlstdc.h	Wed Sep 13 14:10:14 2000
--- bash-2.05a/lib/readline/rlstdc.h	Wed Sep 12 09:57:31 2001
***************
*** 27,51 ****
  /* A function can be defined using prototypes and compile on both ANSI C
     and traditional C compilers with something like this:
! 	extern char *func __P((char *, char *, int)); */
  
! #if !defined (__P)
  #  if defined (__STDC__) || defined (__GNUC__) || defined (__cplusplus)
! #    define __P(protos) protos
  #  else
! #    define __P(protos) ()
  #  endif
  #endif
  
! #if !defined (__STDC__) && !defined (__cplusplus)
! #  if defined (__GNUC__)	/* gcc with -traditional */
! #    if !defined (const)
! #      define const __const
! #    endif /* !const */
! #  else /* !__GNUC__ */
! #    if !defined (const)
! #      define const
! #    endif /* !const */
! #  endif /* !__GNUC__ */
! #endif /* !__STDC__ && !__cplusplus */
  
  #endif /* !_RL_STDC_H_ */
--- 27,45 ----
  /* A function can be defined using prototypes and compile on both ANSI C
     and traditional C compilers with something like this:
! 	extern char *func PARAMS((char *, char *, int)); */
  
! #if !defined (PARAMS)
  #  if defined (__STDC__) || defined (__GNUC__) || defined (__cplusplus)
! #    define PARAMS(protos) protos
  #  else
! #    define PARAMS(protos) ()
  #  endif
  #endif
  
! #ifndef __attribute__
! #  if __GNUC__ < 2 || (__GNUC__ == 2 && __GNUC_MINOR__ < 8) || __STRICT_ANSI__
! #    define __attribute__(x)
! #  endif
! #endif
  
  #endif /* !_RL_STDC_H_ */
diff -Nrc2 bash-2.05/lib/readline/rltty.c bash-2.05a/lib/readline/rltty.c
*** bash-2.05/lib/readline/rltty.c	Fri Feb  2 13:13:01 2001
--- bash-2.05a/lib/readline/rltty.c	Mon Oct 15 09:26:34 2001
***************
*** 53,56 ****
--- 53,61 ----
  rl_voidfunc_t *rl_deprep_term_function = rl_deprep_terminal;
  
+ static void block_sigint PARAMS((void));
+ static void release_sigint PARAMS((void));
+ 
+ static void set_winsize PARAMS((int));
+ 
  /* **************************************************************** */
  /*								    */
***************
*** 174,177 ****
--- 179,190 ----
  static TIOTYPE otio;
  
+ static void save_tty_chars PARAMS((TIOTYPE *));
+ static int _get_tty_settings PARAMS((int, TIOTYPE *));
+ static int get_tty_settings PARAMS((int, TIOTYPE *));
+ static int _set_tty_settings PARAMS((int, TIOTYPE *));
+ static int set_tty_settings PARAMS((int, TIOTYPE *));
+ 
+ static void prepare_terminal_settings PARAMS((int, TIOTYPE, TIOTYPE *));
+ 
  static void
  save_tty_chars (tiop)
***************
*** 380,383 ****
--- 393,404 ----
  static TIOTYPE otio;
  
+ static void save_tty_chars PARAMS((TIOTYPE *));
+ static int _get_tty_settings PARAMS((int, TIOTYPE *));
+ static int get_tty_settings PARAMS((int, TIOTYPE *));
+ static int _set_tty_settings PARAMS((int, TIOTYPE *));
+ static int set_tty_settings PARAMS((int, TIOTYPE *));
+ 
+ static void prepare_terminal_settings PARAMS((int, TIOTYPE, TIOTYPE *));
+ 
  #if defined (FLUSHO)
  #  define OUTPUT_BEING_FLUSHED(tp)  (tp->c_lflag & FLUSHO)
***************
*** 627,630 ****
--- 648,652 ----
      {
        release_sigint ();
+ fprintf(stderr, "readline: warning: rl_prep_terminal: cannot get terminal settings");
        return;
      }
***************
*** 772,777 ****
        int ic; \
        ic = sc; \
!       if (ic != -1 && kmap[ic].type == ISFUNC) \
! 	kmap[ic].function = func; \
      } \
    while (0)
--- 794,799 ----
        int ic; \
        ic = sc; \
!       if (ic != -1 && kmap[(unsigned char)ic].type == ISFUNC) \
! 	kmap[(unsigned char)ic].function = func; \
      } \
    while (0)
***************
*** 862,865 ****
--- 884,888 ----
  
    nosigstty.c_lflag &= ~ISIG;
+   nosigstty.c_iflag &= ~IXON;
  
    if (_set_tty_settings (fileno (rl_instream), &nosigstty) < 0)
***************
*** 873,880 ****
  _rl_restore_tty_signals ()
  {
    if (tty_sigs_disabled == 0)
      return 0;
  
!   return (_set_tty_settings (fileno (rl_instream), &sigstty));
  }
  #endif /* !NEW_TTY_DRIVER */
--- 896,910 ----
  _rl_restore_tty_signals ()
  {
+   int r;
+ 
    if (tty_sigs_disabled == 0)
      return 0;
  
!   r = _set_tty_settings (fileno (rl_instream), &sigstty);
! 
!   if (r == 0)
!     tty_sigs_disabled = 0;
! 
!   return r;
  }
  #endif /* !NEW_TTY_DRIVER */
diff -Nrc2 bash-2.05/lib/readline/rltypedefs.h bash-2.05a/lib/readline/rltypedefs.h
*** bash-2.05/lib/readline/rltypedefs.h	Mon Nov 27 11:52:04 2000
--- bash-2.05a/lib/readline/rltypedefs.h	Wed Aug 22 09:38:02 2001
***************
*** 46,83 ****
  
  /* Bindable functions */
! typedef int rl_command_func_t __P((int, int));
  
  /* Typedefs for the completion system */
! typedef char *rl_compentry_func_t __P((const char *, int));
! typedef char **rl_completion_func_t __P((const char *, int, int));
  
! typedef char *rl_quote_func_t __P((char *, int, char *));
! typedef char *rl_dequote_func_t __P((char *, int));
  
! typedef int rl_compignore_func_t __P((char **));
  
! typedef void rl_compdisp_func_t __P((char **, int, int));
  
  /* Type for input and pre-read hook functions like rl_event_hook */
! typedef int rl_hook_func_t __P((void));
  
  /* Input function type */
! typedef int rl_getc_func_t __P((FILE *));
  
  /* Generic function that takes a character buffer (which could be the readline
     line buffer) and an index into it (which could be rl_point) and returns
     an int. */
! typedef int rl_linebuf_func_t __P((char *, int));
  
  /* `Generic' function pointer typedefs */
! typedef int rl_intfunc_t __P((int));
  #define rl_ivoidfunc_t rl_hook_func_t
! typedef int rl_icpfunc_t __P((char *));
! typedef int rl_icppfunc_t __P((char **));
  
! typedef void rl_voidfunc_t __P((void));
! typedef void rl_vintfunc_t __P((int));
! typedef void rl_vcpfunc_t __P((char *));
! typedef void rl_vcppfunc_t __P((char **));
  #endif /* _RL_FUNCTION_TYPEDEF */
  
--- 46,83 ----
  
  /* Bindable functions */
! typedef int rl_command_func_t PARAMS((int, int));
  
  /* Typedefs for the completion system */
! typedef char *rl_compentry_func_t PARAMS((const char *, int));
! typedef char **rl_completion_func_t PARAMS((const char *, int, int));
  
! typedef char *rl_quote_func_t PARAMS((char *, int, char *));
! typedef char *rl_dequote_func_t PARAMS((char *, int));
  
! typedef int rl_compignore_func_t PARAMS((char **));
  
! typedef void rl_compdisp_func_t PARAMS((char **, int, int));
  
  /* Type for input and pre-read hook functions like rl_event_hook */
! typedef int rl_hook_func_t PARAMS((void));
  
  /* Input function type */
! typedef int rl_getc_func_t PARAMS((FILE *));
  
  /* Generic function that takes a character buffer (which could be the readline
     line buffer) and an index into it (which could be rl_point) and returns
     an int. */
! typedef int rl_linebuf_func_t PARAMS((char *, int));
  
  /* `Generic' function pointer typedefs */
! typedef int rl_intfunc_t PARAMS((int));
  #define rl_ivoidfunc_t rl_hook_func_t
! typedef int rl_icpfunc_t PARAMS((char *));
! typedef int rl_icppfunc_t PARAMS((char **));
  
! typedef void rl_voidfunc_t PARAMS((void));
! typedef void rl_vintfunc_t PARAMS((int));
! typedef void rl_vcpfunc_t PARAMS((char *));
! typedef void rl_vcppfunc_t PARAMS((char **));
  #endif /* _RL_FUNCTION_TYPEDEF */
  
diff -Nrc2 bash-2.05/lib/readline/savestring.c bash-2.05a/lib/readline/savestring.c
*** bash-2.05/lib/readline/savestring.c	Thu Sep 14 14:58:41 2000
--- bash-2.05a/lib/readline/savestring.c	Mon Sep 10 10:07:46 2001
***************
*** 21,26 ****
     59 Temple Place, Suite 330, Boston, MA 02111 USA. */
  
! extern char *strcpy ();
! extern char *xmalloc ();
  
  /* Backwards compatibility, now that savestring has been removed from
--- 21,29 ----
     59 Temple Place, Suite 330, Boston, MA 02111 USA. */
  
! #include <config.h>
! #ifdef HAVE_STRING_H
! #  include <string.h>
! #endif
! #include "xmalloc.h"
  
  /* Backwards compatibility, now that savestring has been removed from
***************
*** 30,33 ****
       const char *s;
  {
!   return ((char *)strcpy (xmalloc (1 + (int)strlen (s)), (s)));
  }
--- 33,36 ----
       const char *s;
  {
!   return ((char *)strcpy ((char *)xmalloc (1 + strlen (s)), (s)));
  }
diff -Nrc2 bash-2.05/lib/readline/search.c bash-2.05a/lib/readline/search.c
*** bash-2.05/lib/readline/search.c	Thu Nov  2 13:13:25 2000
--- bash-2.05a/lib/readline/search.c	Wed Aug 22 09:39:52 2001
***************
*** 55,59 ****
  
  /* Functions imported from the rest of the library. */
! extern int _rl_free_history_entry __P((HIST_ENTRY *));
  
  static char *noninc_search_string = (char *) NULL;
--- 55,59 ----
  
  /* Functions imported from the rest of the library. */
! extern int _rl_free_history_entry PARAMS((HIST_ENTRY *));
  
  static char *noninc_search_string = (char *) NULL;
***************
*** 67,70 ****
--- 67,77 ----
  static int history_string_size;
  
+ static void make_history_line_current PARAMS((HIST_ENTRY *));
+ static int noninc_search_from_pos PARAMS((char *, int, int));
+ static void noninc_dosearch PARAMS((char *, int));
+ static void noninc_search PARAMS((int, int));
+ static int rl_history_search_internal PARAMS((int, int));
+ static void rl_history_search_reinit PARAMS((void));
+ 
  /* Make the data from the history entry ENTRY be the contents of the
     current line.  This doesn't do anything with rl_point; the caller
***************
*** 392,396 ****
  	{
  	  history_string_size = rl_history_search_len + 2;
! 	  history_search_string = xrealloc (history_search_string, history_string_size);
  	}
        history_search_string[0] = '^';
--- 399,403 ----
  	{
  	  history_string_size = rl_history_search_len + 2;
! 	  history_search_string = (char *)xrealloc (history_search_string, history_string_size);
  	}
        history_search_string[0] = '^';
diff -Nrc2 bash-2.05/lib/readline/shell.c bash-2.05a/lib/readline/shell.c
*** bash-2.05/lib/readline/shell.c	Wed Nov  8 12:12:45 2000
--- bash-2.05a/lib/readline/shell.c	Wed Aug 22 09:39:58 2001
***************
*** 45,48 ****
--- 45,52 ----
  #endif /* !HAVE_STRING_H */
  
+ #if defined (HAVE_LIMITS_H)
+ #  include <limits.h>
+ #endif
+ 
  #include <fcntl.h>
  #include <pwd.h>
***************
*** 55,59 ****
  
  #if !defined (HAVE_GETPW_DECLS)
! extern struct passwd *getpwuid __P((uid_t));
  #endif /* !HAVE_GETPW_DECLS */
  
--- 59,63 ----
  
  #if !defined (HAVE_GETPW_DECLS)
! extern struct passwd *getpwuid PARAMS((uid_t));
  #endif /* !HAVE_GETPW_DECLS */
  
***************
*** 62,65 ****
--- 66,85 ----
  #endif
  
+ #ifndef CHAR_BIT
+ #  define CHAR_BIT 8
+ #endif
+ 
+ /* Nonzero if the integer type T is signed.  */
+ #define TYPE_SIGNED(t) (! ((t) 0 < (t) -1))
+ 
+ /* Bound on length of the string representing an integer value of type T.
+    Subtract one for the sign bit if T is signed;
+    302 / 1000 is log10 (2) rounded up;
+    add one for integer division truncation;
+    add one more for a minus sign if t is signed.  */
+ #define INT_STRLEN_BOUND(t) \
+   ((sizeof (t) * CHAR_BIT - TYPE_SIGNED (t)) * 302 / 1000 \
+    + 1 + TYPE_SIGNED (t))
+ 
  /* All of these functions are resolved from bash if we are linking readline
     as part of bash. */
***************
*** 104,119 ****
  
  #if defined (HAVE_PUTENV)
!   b = xmalloc (24);
    sprintf (b, "LINES=%d", lines);
    putenv (b);
!   b = xmalloc (24);
    sprintf (b, "COLUMNS=%d", cols);
    putenv (b);
  #else /* !HAVE_PUTENV */
  #  if defined (HAVE_SETENV)
!   b = xmalloc (8);
    sprintf (b, "%d", lines);
    setenv ("LINES", b, 1);
!   b = xmalloc (8);
    sprintf (b, "%d", cols);
    setenv ("COLUMNS", b, 1);
--- 124,139 ----
  
  #if defined (HAVE_PUTENV)
!   b = (char *)xmalloc (INT_STRLEN_BOUND (int) + sizeof ("LINES=") + 1);
    sprintf (b, "LINES=%d", lines);
    putenv (b);
!   b = (char *)xmalloc (INT_STRLEN_BOUND (int) + sizeof ("COLUMNS=") + 1);
    sprintf (b, "COLUMNS=%d", cols);
    putenv (b);
  #else /* !HAVE_PUTENV */
  #  if defined (HAVE_SETENV)
!   b = (char *)xmalloc (INT_STRLEN_BOUND (int) + 1);
    sprintf (b, "%d", lines);
    setenv ("LINES", b, 1);
!   b = (char *)xmalloc (INT_STRLEN_BOUND (int) + 1);
    sprintf (b, "%d", cols);
    setenv ("COLUMNS", b, 1);
diff -Nrc2 bash-2.05/lib/readline/signals.c bash-2.05a/lib/readline/signals.c
*** bash-2.05/lib/readline/signals.c	Tue Dec 12 15:01:45 2000
--- bash-2.05a/lib/readline/signals.c	Wed Aug 22 09:40:04 2001
***************
*** 74,78 ****
  #endif /* !HAVE_POSIX_SIGNALS */
  
! static SigHandler *rl_set_sighandler __P((int, SigHandler *, sighandler_cxt *));
  
  /* Exported variables for use by applications. */
--- 74,78 ----
  #endif /* !HAVE_POSIX_SIGNALS */
  
! static SigHandler *rl_set_sighandler PARAMS((int, SigHandler *, sighandler_cxt *));
  
  /* Exported variables for use by applications. */
diff -Nrc2 bash-2.05/lib/readline/terminal.c bash-2.05a/lib/readline/terminal.c
*** bash-2.05/lib/readline/terminal.c	Tue Feb  6 15:39:22 2001
--- bash-2.05a/lib/readline/terminal.c	Thu Sep 20 15:33:30 2001
***************
*** 65,68 ****
--- 65,69 ----
  #include "rlprivate.h"
  #include "rlshell.h"
+ #include "xmalloc.h"
  
  /* **************************************************************** */
***************
*** 327,331 ****
--- 328,336 ----
  
    for (i = 0; i < NUM_TC_STRINGS; i++)
+ #  ifdef __LCC__
+     *(tc_strings[i].tc_value) = tgetstr ((char *)tc_strings[i].tc_var, bp);
+ #  else
      *(tc_strings[i].tc_value) = tgetstr (tc_strings[i].tc_var, bp);
+ #  endif
  #endif
    tcap_initialized = 1;
***************
*** 362,369 ****
      {
        if (term_string_buffer == 0)
! 	term_string_buffer = xmalloc(2032);
  
        if (term_buffer == 0)
! 	term_buffer = xmalloc(4080);
  
        buffer = term_string_buffer;
--- 367,374 ----
      {
        if (term_string_buffer == 0)
! 	term_string_buffer = (char *)xmalloc(2032);
  
        if (term_buffer == 0)
! 	term_buffer = (char *)xmalloc(4080);
  
        buffer = term_string_buffer;
diff -Nrc2 bash-2.05/lib/readline/tilde.c bash-2.05a/lib/readline/tilde.c
*** bash-2.05/lib/readline/tilde.c	Wed Feb 14 17:04:21 2001
--- bash-2.05a/lib/readline/tilde.c	Wed Aug 22 09:35:59 2001
***************
*** 49,61 ****
  
  #if defined (TEST) || defined (STATIC_MALLOC)
! static char *xmalloc (), *xrealloc ();
  #else
! extern char *xmalloc __P((int));
! extern char *xrealloc __P((void *, int));
  #endif /* TEST || STATIC_MALLOC */
  
  #if !defined (HAVE_GETPW_DECLS)
! extern struct passwd *getpwuid __P((uid_t));
! extern struct passwd *getpwnam __P((const char *));
  #endif /* !HAVE_GETPW_DECLS */
  
--- 49,60 ----
  
  #if defined (TEST) || defined (STATIC_MALLOC)
! static void *xmalloc (), *xrealloc ();
  #else
! #  include "xmalloc.h"
  #endif /* TEST || STATIC_MALLOC */
  
  #if !defined (HAVE_GETPW_DECLS)
! extern struct passwd *getpwuid PARAMS((uid_t));
! extern struct passwd *getpwnam PARAMS((const char *));
  #endif /* !HAVE_GETPW_DECLS */
  
***************
*** 64,68 ****
  extern char *strcpy ();
  #  endif
! #define savestring(x) strcpy (xmalloc (1 + strlen (x)), (x))
  #endif /* !savestring */
  
--- 63,67 ----
  extern char *strcpy ();
  #  endif
! #define savestring(x) strcpy ((char *)xmalloc (1 + strlen (x)), (x))
  #endif /* !savestring */
  
***************
*** 78,83 ****
     variables.o.  If being compiled as part of readline, they will
     be satisfied from shell.o. */
! extern char *sh_get_home_dir __P((void));
! extern char *sh_get_env_value __P((const char *));
  
  /* The default value of tilde_additional_prefixes.  This is set to
--- 77,82 ----
     variables.o.  If being compiled as part of readline, they will
     be satisfied from shell.o. */
! extern char *sh_get_home_dir PARAMS((void));
! extern char *sh_get_env_value PARAMS((const char *));
  
  /* The default value of tilde_additional_prefixes.  This is set to
***************
*** 115,118 ****
--- 114,122 ----
  char **tilde_additional_suffixes = (char **)default_suffixes;
  
+ static int tilde_find_prefix PARAMS((const char *, int *));
+ static int tilde_find_suffix PARAMS((const char *));
+ static char *isolate_tilde_prefix PARAMS((const char *, int *));
+ static char *glue_prefix_and_suffix PARAMS((char *, const char *, int));
+ 
  /* Find the start of a tilde expansion in STRING, and return the index of
     the tilde which starts the expansion.  Place the length of the text
***************
*** 120,124 ****
  static int
  tilde_find_prefix (string, len)
!      char *string;
       int *len;
  {
--- 124,128 ----
  static int
  tilde_find_prefix (string, len)
!      const char *string;
       int *len;
  {
***************
*** 155,159 ****
  static int
  tilde_find_suffix (string)
!      char *string;
  {
    register int i, j, string_len;
--- 159,163 ----
  static int
  tilde_find_suffix (string)
!      const char *string;
  {
    register int i, j, string_len;
***************
*** 191,197 ****
    result_index = result_size = 0;
    if (result = strchr (string, '~'))
!     result = xmalloc (result_size = (strlen (string) + 16));
    else
!     result = xmalloc (result_size = (strlen (string) + 1));
  
    /* Scan through STRING expanding tildes as we come to them. */
--- 195,201 ----
    result_index = result_size = 0;
    if (result = strchr (string, '~'))
!     result = (char *)xmalloc (result_size = (strlen (string) + 16));
    else
!     result = (char *)xmalloc (result_size = (strlen (string) + 1));
  
    /* Scan through STRING expanding tildes as we come to them. */
***************
*** 207,211 ****
        /* Copy the skipped text into the result. */
        if ((result_index + start + 1) > result_size)
! 	result = xrealloc (result, 1 + (result_size += (start + 20)));
  
        strncpy (result + result_index, string, start);
--- 211,215 ----
        /* Copy the skipped text into the result. */
        if ((result_index + start + 1) > result_size)
! 	result = (char *)xrealloc (result, 1 + (result_size += (start + 20)));
  
        strncpy (result + result_index, string, start);
***************
*** 224,228 ****
  
        /* Expand the entire tilde word, and copy it into RESULT. */
!       tilde_word = xmalloc (1 + end);
        strncpy (tilde_word, string, end);
        tilde_word[end] = '\0';
--- 228,232 ----
  
        /* Expand the entire tilde word, and copy it into RESULT. */
!       tilde_word = (char *)xmalloc (1 + end);
        strncpy (tilde_word, string, end);
        tilde_word[end] = '\0';
***************
*** 240,244 ****
  	{
  	  if ((result_index + len + 1) > result_size)
! 	    result = xrealloc (result, 1 + (result_size += (len + 20)));
  
  	  strcpy (result + result_index, expansion);
--- 244,248 ----
  	{
  	  if ((result_index + len + 1) > result_size)
! 	    result = (char *)xrealloc (result, 1 + (result_size += (len + 20)));
  
  	  strcpy (result + result_index, expansion);
***************
*** 258,262 ****
  static char *
  isolate_tilde_prefix (fname, lenp)
!      char *fname;
       int *lenp;
  {
--- 262,266 ----
  static char *
  isolate_tilde_prefix (fname, lenp)
!      const char *fname;
       int *lenp;
  {
***************
*** 264,268 ****
    int i;
  
!   ret = xmalloc (strlen (fname));
  #if defined (__MSDOS__)
    for (i = 1; fname[i] && fname[i] != '/' && fname[i] != '\\'; i++)
--- 268,272 ----
    int i;
  
!   ret = (char *)xmalloc (strlen (fname));
  #if defined (__MSDOS__)
    for (i = 1; fname[i] && fname[i] != '/' && fname[i] != '\\'; i++)
***************
*** 281,285 ****
  static char *
  glue_prefix_and_suffix (prefix, suffix, suffind)
!      char *prefix, *suffix;
       int suffind;
  {
--- 285,290 ----
  static char *
  glue_prefix_and_suffix (prefix, suffix, suffind)
!      char *prefix;
!      const char *suffix;
       int suffind;
  {
***************
*** 289,293 ****
    plen = (prefix && *prefix) ? strlen (prefix) : 0;
    slen = strlen (suffix + suffind);
!   ret = xmalloc (plen + slen + 1);
    if (plen)
      strcpy (ret, prefix);
--- 294,298 ----
    plen = (prefix && *prefix) ? strlen (prefix) : 0;
    slen = strlen (suffix + suffind);
!   ret = (char *)xmalloc (plen + slen + 1);
    if (plen)
      strcpy (ret, prefix);
***************
*** 413,421 ****
  static void memory_error_and_abort ();
  
! static char *
  xmalloc (bytes)
!      int bytes;
  {
!   char *temp = (char *)malloc (bytes);
  
    if (!temp)
--- 418,426 ----
  static void memory_error_and_abort ();
  
! static void *
  xmalloc (bytes)
!      size_t bytes;
  {
!   void *temp = (char *)malloc (bytes);
  
    if (!temp)
***************
*** 424,438 ****
  }
  
! static char *
  xrealloc (pointer, bytes)
!      char *pointer;
       int bytes;
  {
!   char *temp;
  
    if (!pointer)
!     temp = (char *)malloc (bytes);
    else
!     temp = (char *)realloc (pointer, bytes);
  
    if (!temp)
--- 429,443 ----
  }
  
! static void *
  xrealloc (pointer, bytes)
!      void *pointer;
       int bytes;
  {
!   void *temp;
  
    if (!pointer)
!     temp = malloc (bytes);
    else
!     temp = realloc (pointer, bytes);
  
    if (!temp)
diff -Nrc2 bash-2.05/lib/readline/tilde.h bash-2.05a/lib/readline/tilde.h
*** bash-2.05/lib/readline/tilde.h	Mon Oct 30 14:31:04 2000
--- bash-2.05a/lib/readline/tilde.h	Wed Aug 22 09:36:06 2001
***************
*** 25,28 ****
--- 25,32 ----
  #  define _TILDE_H_
  
+ #if defined (HAVE_CONFIG_H)
+ #  include <config.h>
+ #endif
+ 
  #ifdef __cplusplus
  extern "C" {
***************
*** 31,57 ****
  /* A function can be defined using prototypes and compile on both ANSI C
     and traditional C compilers with something like this:
! 	extern char *func __P((char *, char *, int)); */
  
! #if !defined (__P)
  #  if defined (__STDC__) || defined (__GNUC__) || defined (__cplusplus)
! #    define __P(protos) protos
  #  else
! #    define __P(protos) ()
  #  endif
  #endif
  
! #if !defined (__STDC__) && !defined (__cplusplus)
! #  if defined (__GNUC__)	/* gcc with -traditional */
! #    if !defined (const)
! #      define const __const
! #    endif /* !const */
! #  else /* !__GNUC__ */
! #    if !defined (const)
! #      define const
! #    endif /* !const */
! #  endif /* !__GNUC__ */
! #endif /* !__STDC__ && !__cplusplus */
! 
! typedef char *tilde_hook_func_t __P((char *));
  
  /* If non-null, this contains the address of a function that the application
--- 35,49 ----
  /* A function can be defined using prototypes and compile on both ANSI C
     and traditional C compilers with something like this:
! 	extern char *func PARAMS((char *, char *, int)); */
  
! #if !defined (PARAMS)
  #  if defined (__STDC__) || defined (__GNUC__) || defined (__cplusplus)
! #    define PARAMS(protos) protos
  #  else
! #    define PARAMS(protos) ()
  #  endif
  #endif
  
! typedef char *tilde_hook_func_t PARAMS((char *));
  
  /* If non-null, this contains the address of a function that the application
***************
*** 78,86 ****
  
  /* Return a new string which is the result of tilde expanding STRING. */
! extern char *tilde_expand __P((const char *));
  
  /* Do the work of tilde expansion on FILENAME.  FILENAME starts with a
     tilde.  If there is no expansion, call tilde_expansion_failure_hook. */
! extern char *tilde_expand_word __P((const char *));
  
  #ifdef __cplusplus
--- 70,78 ----
  
  /* Return a new string which is the result of tilde expanding STRING. */
! extern char *tilde_expand PARAMS((const char *));
  
  /* Do the work of tilde expansion on FILENAME.  FILENAME starts with a
     tilde.  If there is no expansion, call tilde_expansion_failure_hook. */
! extern char *tilde_expand_word PARAMS((const char *));
  
  #ifdef __cplusplus
diff -Nrc2 bash-2.05/lib/readline/undo.c bash-2.05a/lib/readline/undo.c
*** bash-2.05/lib/readline/undo.c	Tue Feb  6 14:14:45 2001
--- bash-2.05a/lib/readline/undo.c	Tue Aug 28 08:53:32 2001
***************
*** 49,52 ****
--- 49,53 ----
  
  #include "rlprivate.h"
+ #include "xmalloc.h"
  
  #define SWAP(s, e)  do { int t; t = s; s = e; e = t; } while (0)
diff -Nrc2 bash-2.05/lib/readline/util.c bash-2.05a/lib/readline/util.c
*** bash-2.05/lib/readline/util.c	Wed Feb 14 07:43:19 2001
--- bash-2.05a/lib/readline/util.c	Mon Oct 29 10:23:36 2001
***************
*** 133,137 ****
  
    length = to - from;
!   copy = xmalloc (1 + length);
    strncpy (copy, rl_line_buffer + from, length);
    copy[length] = '\0';
--- 133,137 ----
  
    length = to - from;
!   copy = (char *)xmalloc (1 + length);
    strncpy (copy, rl_line_buffer + from, length);
    copy[length] = '\0';
***************
*** 148,152 ****
      {
        rl_line_buffer_len += DEFAULT_BUFFER_SIZE;
!       rl_line_buffer = xrealloc (rl_line_buffer, rl_line_buffer_len);
      }
  
--- 148,152 ----
      {
        rl_line_buffer_len += DEFAULT_BUFFER_SIZE;
!       rl_line_buffer = (char *)xrealloc (rl_line_buffer, rl_line_buffer_len);
      }
  
***************
*** 194,198 ****
      {
        len = end - start + 1;
!       temp = xmalloc (len + 1);
        strncpy (temp, rl_line_buffer + start, len);
        temp[len] = '\0';
--- 194,198 ----
      {
        len = end - start + 1;
!       temp = (char *)xmalloc (len + 1);
        strncpy (temp, rl_line_buffer + start, len);
        temp[len] = '\0';
***************
*** 226,229 ****
--- 226,230 ----
  }
  
+ #ifndef HAVE_STRPBRK
  /* Find the first occurrence in STRING1 of any character from STRING2.
     Return a pointer to the character in STRING1. */
***************
*** 244,247 ****
--- 245,249 ----
    return ((char *)NULL);
  }
+ #endif
  
  #if !defined (HAVE_STRCASECMP)
***************
*** 303,362 ****
  }
  
! /* Function equivalents for the macros defined in chartypes.h. */
! #undef _rl_uppercase_p
! int
! _rl_uppercase_p (c)
!      int c;
! {
!   return (isupper (c));
! }
! 
! #undef _rl_lowercase_p
! int
! _rl_lowercase_p (c)
!      int c;
! {
!   return (islower (c));
! }
! 
! #undef _rl_pure_alphabetic
! int
! _rl_pure_alphabetic (c)
!      int c;
! {
!   return (isupper (c) || islower (c));
! }
  
! #undef _rl_digit_p
! int
! _rl_digit_p (c)
!      int c;
! {
!   return (isdigit (c));
! }
! 
! #undef _rl_to_lower
! int
! _rl_to_lower (c)
!      int c;
! {
!   return (isupper (c) ? tolower (c) : c);
! }
! 
! #undef _rl_to_upper
! int
! _rl_to_upper (c)
!      int c;
! {
!   return (islower (c) ? toupper (c) : c);
! }
! 
! #undef _rl_digit_value
! int
! _rl_digit_value (c)
!      int c;
! {
!   return (isdigit (c) ? c - '0' : c);
! }
  
  /* Backwards compatibility, now that savestring has been removed from
--- 305,318 ----
  }
  
! /* Function equivalents for the macros defined in chardefs.h. */
! #define FUNCTION_FOR_MACRO(f)	int (f) (c) int c; { return f (c); }
  
! FUNCTION_FOR_MACRO (_rl_digit_p)
! FUNCTION_FOR_MACRO (_rl_digit_value)
! FUNCTION_FOR_MACRO (_rl_lowercase_p)
! FUNCTION_FOR_MACRO (_rl_pure_alphabetic)
! FUNCTION_FOR_MACRO (_rl_to_lower)
! FUNCTION_FOR_MACRO (_rl_to_upper)
! FUNCTION_FOR_MACRO (_rl_uppercase_p)
  
  /* Backwards compatibility, now that savestring has been removed from
***************
*** 367,370 ****
       const char *s;
  {
!   return (strcpy (xmalloc (1 + (int)strlen (s)), (s)));
  }
--- 323,326 ----
       const char *s;
  {
!   return (strcpy ((char *)xmalloc (1 + (int)strlen (s)), (s)));
  }
diff -Nrc2 bash-2.05/lib/readline/vi_mode.c bash-2.05a/lib/readline/vi_mode.c
*** bash-2.05/lib/readline/vi_mode.c	Wed Nov  8 11:47:02 2000
--- bash-2.05a/lib/readline/vi_mode.c	Wed Nov  7 08:43:05 2001
***************
*** 58,77 ****
  #include "xmalloc.h"
  
- #ifndef _rl_digit_p
- #define _rl_digit_p(c)  ((c) >= '0' && (c) <= '9')
- #endif
- 
- #ifndef _rl_digit_value
- #define _rl_digit_value(c) ((c) - '0')
- #endif
- 
  #ifndef member
  #define member(c, s) ((c) ? (char *)strchr ((s), (c)) != (char *)NULL : 0)
  #endif
  
- #ifndef isident
- #define isident(c) ((_rl_pure_alphabetic (c) || _rl_digit_p (c) || c == '_'))
- #endif
- 
  #ifndef exchange
  #define exchange(x, y) do {int temp = x; x = y; y = temp;} while (0)
--- 58,65 ----
***************
*** 82,86 ****
  
  /* Command keys which do movement for xxx_to commands. */
! static const char *vi_motion = " hl^$0ftFt;,%wbeWBE|";
  
  /* Keymap used for vi replace characters.  Created dynamically since
--- 70,74 ----
  
  /* Command keys which do movement for xxx_to commands. */
! static const char *vi_motion = " hl^$0ftFT;,%wbeWBE|";
  
  /* Keymap used for vi replace characters.  Created dynamically since
***************
*** 113,119 ****
  
  /* Arrays for the saved marks. */
! static int vi_mark_chars[27];
  
! static int rl_digit_loop1 __P((void));
  
  void
--- 101,109 ----
  
  /* Arrays for the saved marks. */
! static int vi_mark_chars['z' - 'a' + 1];
  
! static void _rl_vi_stuff_insert PARAMS((int));
! static void _rl_vi_save_insert PARAMS((UNDO_LIST *));
! static int rl_digit_loop1 PARAMS((void));
  
  void
***************
*** 461,472 ****
      {
        /* Move to white space (really non-identifer). */
!       if (isident (rl_line_buffer[rl_point]))
  	{
! 	  while (isident (rl_line_buffer[rl_point]) && rl_point < rl_end)
  	    rl_point++;
  	}
        else /* if (!whitespace (rl_line_buffer[rl_point])) */
  	{
! 	  while (!isident (rl_line_buffer[rl_point]) &&
  		 !whitespace (rl_line_buffer[rl_point]) && rl_point < rl_end)
  	    rl_point++;
--- 451,462 ----
      {
        /* Move to white space (really non-identifer). */
!       if (_rl_isident (rl_line_buffer[rl_point]))
  	{
! 	  while (_rl_isident (rl_line_buffer[rl_point]) && rl_point < rl_end)
  	    rl_point++;
  	}
        else /* if (!whitespace (rl_line_buffer[rl_point])) */
  	{
! 	  while (!_rl_isident (rl_line_buffer[rl_point]) &&
  		 !whitespace (rl_line_buffer[rl_point]) && rl_point < rl_end)
  	    rl_point++;
***************
*** 498,504 ****
  	 the while loop.  Without this code, words like `l;' screw up the
  	 function. */
!       last_is_ident = isident (rl_line_buffer[rl_point - 1]);
!       if ((isident (rl_line_buffer[rl_point]) && !last_is_ident) ||
! 	  (!isident (rl_line_buffer[rl_point]) && last_is_ident))
  	rl_point--;
  
--- 488,494 ----
  	 the while loop.  Without this code, words like `l;' screw up the
  	 function. */
!       last_is_ident = _rl_isident (rl_line_buffer[rl_point - 1]);
!       if ((_rl_isident (rl_line_buffer[rl_point]) && !last_is_ident) ||
! 	  (!_rl_isident (rl_line_buffer[rl_point]) && last_is_ident))
  	rl_point--;
  
***************
*** 508,515 ****
        if (rl_point > 0)
  	{
! 	  if (isident (rl_line_buffer[rl_point]))
! 	    while (--rl_point >= 0 && isident (rl_line_buffer[rl_point]));
  	  else
! 	    while (--rl_point >= 0 && !isident (rl_line_buffer[rl_point]) &&
  		   !whitespace (rl_line_buffer[rl_point]));
  	  rl_point++;
--- 498,505 ----
        if (rl_point > 0)
  	{
! 	  if (_rl_isident (rl_line_buffer[rl_point]))
! 	    while (--rl_point >= 0 && _rl_isident (rl_line_buffer[rl_point]));
  	  else
! 	    while (--rl_point >= 0 && !_rl_isident (rl_line_buffer[rl_point]) &&
  		   !whitespace (rl_line_buffer[rl_point]));
  	  rl_point++;
***************
*** 533,540 ****
        if (rl_point < rl_end)
  	{
! 	  if (isident (rl_line_buffer[rl_point]))
! 	    while (++rl_point < rl_end && isident (rl_line_buffer[rl_point]));
  	  else
! 	    while (++rl_point < rl_end && !isident (rl_line_buffer[rl_point])
  		   && !whitespace (rl_line_buffer[rl_point]));
  	}
--- 523,530 ----
        if (rl_point < rl_end)
  	{
! 	  if (_rl_isident (rl_line_buffer[rl_point]))
! 	    while (++rl_point < rl_end && _rl_isident (rl_line_buffer[rl_point]));
  	  else
! 	    while (++rl_point < rl_end && !_rl_isident (rl_line_buffer[rl_point])
  		   && !whitespace (rl_line_buffer[rl_point]));
  	}
***************
*** 612,616 ****
      {
        vi_insert_buffer_size += (len + 32) - (len % 32);
!       vi_insert_buffer = xrealloc (vi_insert_buffer, vi_insert_buffer_size);
      }
    strncpy (vi_insert_buffer, rl_line_buffer + start, len - 1);
--- 602,606 ----
      {
        vi_insert_buffer_size += (len + 32) - (len % 32);
!       vi_insert_buffer = (char *)xrealloc (vi_insert_buffer, vi_insert_buffer_size);
      }
    strncpy (vi_insert_buffer, rl_line_buffer + start, len - 1);
***************
*** 848,857 ****
  	  return 1;
  	}
!       rl_message ("(arg: %d) ", rl_arg_sign * rl_numeric_arg, 0);
        RL_SETSTATE(RL_STATE_MOREINPUT);
        key = c = rl_read_key ();
        RL_UNSETSTATE(RL_STATE_MOREINPUT);
  
!       if (_rl_keymap[c].type == ISFUNC &&
  	  _rl_keymap[c].function == rl_universal_argument)
  	{
--- 838,847 ----
  	  return 1;
  	}
!       rl_message ("(arg: %d) ", rl_arg_sign * rl_numeric_arg);
        RL_SETSTATE(RL_STATE_MOREINPUT);
        key = c = rl_read_key ();
        RL_UNSETSTATE(RL_STATE_MOREINPUT);
  
!       if (c >= 0 && _rl_keymap[c].type == ISFUNC &&
  	  _rl_keymap[c].function == rl_universal_argument)
  	{
***************
*** 1357,1361 ****
    RL_UNSETSTATE(RL_STATE_MOREINPUT);
  
!   if (_rl_lowercase_p (ch) == 0)
      {
        rl_ding ();
--- 1347,1351 ----
    RL_UNSETSTATE(RL_STATE_MOREINPUT);
  
!   if (ch < 'a' || ch > 'z')
      {
        rl_ding ();
***************
*** 1382,1386 ****
        return 0;
      }
!   else if (_rl_lowercase_p (ch) == 0)
      {
        rl_ding ();
--- 1372,1376 ----
        return 0;
      }
!   else if (ch < 'a' || ch > 'z')
      {
        rl_ding ();
diff -Nrc2 bash-2.05/lib/readline/xmalloc.c bash-2.05a/lib/readline/xmalloc.c
*** bash-2.05/lib/readline/xmalloc.c	Thu Aug  5 08:16:53 1999
--- bash-2.05a/lib/readline/xmalloc.c	Thu Aug  2 12:48:30 2001
***************
*** 52,62 ****
     to hold BYTES number of bytes.  If the memory cannot be allocated,
     print an error message and abort. */
! char *
  xmalloc (bytes)
!      int bytes;
  {
!   char *temp;
  
!   temp = (char *)malloc (bytes);
    if (temp == 0)
      memory_error_and_abort ("xmalloc");
--- 52,62 ----
     to hold BYTES number of bytes.  If the memory cannot be allocated,
     print an error message and abort. */
! PTR_T
  xmalloc (bytes)
!      size_t bytes;
  {
!   PTR_T temp;
  
!   temp = malloc (bytes);
    if (temp == 0)
      memory_error_and_abort ("xmalloc");
***************
*** 64,75 ****
  }
  
! char *
  xrealloc (pointer, bytes)
       PTR_T pointer;
!      int bytes;
  {
!   char *temp;
  
!   temp = pointer ? (char *)realloc (pointer, bytes) : (char *)malloc (bytes);
  
    if (temp == 0)
--- 64,75 ----
  }
  
! PTR_T
  xrealloc (pointer, bytes)
       PTR_T pointer;
!      size_t bytes;
  {
!   PTR_T temp;
  
!   temp = pointer ? realloc (pointer, bytes) : malloc (bytes);
  
    if (temp == 0)
diff -Nrc2 bash-2.05/lib/readline/xmalloc.h bash-2.05a/lib/readline/xmalloc.h
*** bash-2.05/lib/readline/xmalloc.h	Thu Aug  5 08:17:06 1999
--- bash-2.05a/lib/readline/xmalloc.h	Wed Aug 22 16:34:32 2001
***************
*** 40,46 ****
  #endif /* !PTR_T */
  
! extern char *xmalloc __P((int));
! extern char *xrealloc __P((void *, int));
! extern void xfree __P((void *));
  
  #endif /* _XMALLOC_H_ */
--- 40,46 ----
  #endif /* !PTR_T */
  
! extern PTR_T xmalloc PARAMS((size_t));
! extern PTR_T xrealloc PARAMS((void *, size_t));
! extern void xfree PARAMS((void *));
  
  #endif /* _XMALLOC_H_ */
diff -Nrc2 bash-2.05/lib/sh/Makefile.in bash-2.05a/lib/sh/Makefile.in
*** bash-2.05/lib/sh/Makefile.in	Sat Oct 14 17:35:54 2000
--- bash-2.05a/lib/sh/Makefile.in	Tue Oct 23 14:32:08 2001
***************
*** 41,45 ****
  
  CFLAGS = @CFLAGS@
! LOCAL_CFLAGS = @LOCAL_CFLAGS@
  CPPFLAGS = @CPPFLAGS@
  LDFLAGS = @LDFLAGS@ @LOCAL_LDFLAGS@
--- 41,45 ----
  
  CFLAGS = @CFLAGS@
! LOCAL_CFLAGS = @LOCAL_CFLAGS@ ${DEBUG}
  CPPFLAGS = @CPPFLAGS@
  LDFLAGS = @LDFLAGS@ @LOCAL_LDFLAGS@
***************
*** 55,58 ****
--- 55,62 ----
  	  $(CFLAGS) $(CPPFLAGS) 
  
+ GCC_LINT_FLAGS = -Wall -Wshadow -Wpointer-arith -Wcast-qual \
+ 		 -Wcast-align -Wstrict-prototypes -Wconversion \
+ 		 -Wmissing-prototypes -Wtraditional -Wredundant-decls -pedantic
+ 
  .c.o:
  	$(CC) -c $(CCFLAGS) $<
***************
*** 67,71 ****
  	   inet_aton.c netopen.c strpbrk.c timeval.c makepath.c pathcanon.c \
  	   pathphys.c tmpfile.c stringlist.c stringvec.c spell.c \
! 	   shquote.c strtrans.c strindex.c
  
  # The header files for this library.
--- 71,76 ----
  	   inet_aton.c netopen.c strpbrk.c timeval.c makepath.c pathcanon.c \
  	   pathphys.c tmpfile.c stringlist.c stringvec.c spell.c \
! 	   shquote.c strtrans.c strindex.c snprintf.c mailstat.c fmtulong.c \
! 	   fmtullong.c strtoll.c strtoull.c strtoimax.c strtoumax.c
  
  # The header files for this library.
***************
*** 73,82 ****
  
  # The object files contained in $(LIBRARY_NAME)
! OBJECTS = clktck.o clock.o getcwd.o getenv.o oslib.o setlinebuf.o \
! 	  strcasecmp.o strerror.o strtod.o strtol.o strtoul.o \
! 	  vprint.o itos.o rename.o zread.o zwrite.o shtty.o \
! 	  inet_aton.o netopen.o strpbrk.o timeval.o makepath.o pathcanon.o \
  	  pathphys.o tmpfile.o stringlist.o stringvec.o spell.o shquote.o \
! 	  strtrans.o strindex.o
  
  SUPPORT = Makefile
--- 78,88 ----
  
  # The object files contained in $(LIBRARY_NAME)
! LIBOBJS = @LIBOBJS@
! OBJECTS = clktck.o clock.o getenv.o oslib.o setlinebuf.o \
! 	  itos.o zread.o zwrite.o shtty.o \
! 	  netopen.o timeval.o makepath.o pathcanon.o \
  	  pathphys.o tmpfile.o stringlist.o stringvec.o spell.o shquote.o \
! 	  strtrans.o strindex.o snprintf.o mailstat.o fmtulong.o \
! 	  fmtullong.o ${LIBOBJS}
  
  SUPPORT = Makefile
***************
*** 109,116 ****
--- 115,125 ----
  clktck.o: clktck.c
  clock.o: clock.c
+ fmtullong.o: fmtullong.c
+ fmtulong.o: fmtulong.c
  getcwd.o: getcwd.c
  getenv.o: getenv.c
  inet_aton.o: inet_aton.c
  itos.o: itos.c
+ mailstat.o: mailstat.c
  makepath.o: makepath.c
  netopen.o: netopen.c
***************
*** 122,125 ****
--- 131,135 ----
  shquote.o: shquote.c
  shtty.o: shtty.c
+ snprintf.o: snprintf.c
  spell.o: spell.c
  strcasecmp.o: strcasecmp.c
***************
*** 130,135 ****
--- 140,149 ----
  strpbrk.o: strpbrk.c
  strtod.o: strtod.c
+ strtoimax.o: strtoimax.c
  strtol.o: strtol.c
+ strtoll.o: strtoll.c
  strtoul.o: strtoul.c
+ strtoull.o: strtoull.c
+ strtoumax.o: strtoumax.c
  strtrans.o: strtrans.c
  times.o: times.c
***************
*** 140,150 ****
--- 154,173 ----
  zwrite.o: zwrite.c
  
+ # dependencies for c files that include other c files
+ fmtullong.o: fmtulong.c
+ strtoll.o: strtol.c
+ strtoul.o: strtol.c
+ strtoull.o: strtol.c
+ 
  # all files in the library depend on config.h
  clktck.o: ${BUILD_DIR}/config.h
  clock.o: ${BUILD_DIR}/config.h
+ fmtullong.o: ${BUILD_DIR}/config.h
+ fmtulong.o: ${BUILD_DIR}/config.h
  getcwd.o: ${BUILD_DIR}/config.h
  getenv.o: ${BUILD_DIR}/config.h
  inet_aton.o: ${BUILD_DIR}/config.h
  itos.o: ${BUILD_DIR}/config.h
+ mailstat.o: ${BUILD_DIR}/config.h
  makepath.o: ${BUILD_DIR}/config.h
  netopen.o: ${BUILD_DIR}/config.h
***************
*** 156,159 ****
--- 179,183 ----
  shquote.o: ${BUILD_DIR}/config.h
  shtty.o: ${BUILD_DIR}/config.h
+ snprintf.o: ${BUILD_DIR}/config.h
  spell.o: ${BUILD_DIR}/config.h
  strcasecmp.o: ${BUILD_DIR}/config.h
***************
*** 164,169 ****
--- 188,197 ----
  strpbrk.o: ${BUILD_DIR}/config.h
  strtod.o: ${BUILD_DIR}/config.h
+ strtoimax.o: ${BUILD_DIR}/config.h
  strtol.o: ${BUILD_DIR}/config.h
+ strtoll.o: ${BUILD_DIR}/config.h
  strtoul.o: ${BUILD_DIR}/config.h
+ strtoull.o: ${BUILD_DIR}/config.h
+ strtoumax.o: ${BUILD_DIR}/config.h
  strtrans.o: ${BUILD_DIR}/config.h
  times.o: ${BUILD_DIR}/config.h
***************
*** 183,187 ****
  getenv.o: ${topdir}/shell.h ${topdir}/syntax.h ${topdir}/bashjmp.h ${BASHINCDIR}/posixjmp.h
  getenv.o: ${topdir}/command.h ${BASHINCDIR}/stdc.h ${topdir}/error.h
! getenv.o: ${topdir}/general.h ${topdir}/bashtypes.h ${topdir}/variables.h
  getenv.o: ${topdir}/array.h ${topdir}/hashlib.h ${topdir}/quit.h
  getenv.o: ${topdir}/unwind_prot.h ${topdir}/dispose_cmd.h
--- 211,215 ----
  getenv.o: ${topdir}/shell.h ${topdir}/syntax.h ${topdir}/bashjmp.h ${BASHINCDIR}/posixjmp.h
  getenv.o: ${topdir}/command.h ${BASHINCDIR}/stdc.h ${topdir}/error.h
! getenv.o: ${topdir}/general.h ${topdir}/bashtypes.h ${topdir}/variables.h ${topdir}/conftypes.h
  getenv.o: ${topdir}/array.h ${topdir}/hashlib.h ${topdir}/quit.h
  getenv.o: ${topdir}/unwind_prot.h ${topdir}/dispose_cmd.h
***************
*** 195,199 ****
  itos.o: ${topdir}/shell.h ${topdir}/syntax.h ${topdir}/bashjmp.h ${BASHINCDIR}/posixjmp.h
  itos.o: ${topdir}/command.h ${BASHINCDIR}/stdc.h ${topdir}/error.h
! itos.o: ${topdir}/general.h ${topdir}/bashtypes.h ${topdir}/variables.h
  itos.o: ${topdir}/array.h ${topdir}/hashlib.h ${topdir}/quit.h
  itos.o: ${topdir}/unwind_prot.h ${topdir}/dispose_cmd.h
--- 223,227 ----
  itos.o: ${topdir}/shell.h ${topdir}/syntax.h ${topdir}/bashjmp.h ${BASHINCDIR}/posixjmp.h
  itos.o: ${topdir}/command.h ${BASHINCDIR}/stdc.h ${topdir}/error.h
! itos.o: ${topdir}/general.h ${topdir}/bashtypes.h ${topdir}/variables.h ${topdir}/conftypes.h
  itos.o: ${topdir}/array.h ${topdir}/hashlib.h ${topdir}/quit.h
  itos.o: ${topdir}/unwind_prot.h ${topdir}/dispose_cmd.h
***************
*** 204,208 ****
  makepath.o: ${topdir}/shell.h ${topdir}/syntax.h ${topdir}/bashjmp.h ${BASHINCDIR}/posixjmp.h
  makepath.o: ${topdir}/command.h ${BASHINCDIR}/stdc.h ${topdir}/error.h
! makepath.o: ${topdir}/general.h ${topdir}/bashtypes.h ${topdir}/variables.h
  makepath.o: ${topdir}/array.h ${topdir}/hashlib.h ${topdir}/quit.h
  makepath.o: ${topdir}/unwind_prot.h ${topdir}/dispose_cmd.h
--- 232,236 ----
  makepath.o: ${topdir}/shell.h ${topdir}/syntax.h ${topdir}/bashjmp.h ${BASHINCDIR}/posixjmp.h
  makepath.o: ${topdir}/command.h ${BASHINCDIR}/stdc.h ${topdir}/error.h
! makepath.o: ${topdir}/general.h ${topdir}/bashtypes.h ${topdir}/variables.h ${topdir}/conftypes.h
  makepath.o: ${topdir}/array.h ${topdir}/hashlib.h ${topdir}/quit.h
  makepath.o: ${topdir}/unwind_prot.h ${topdir}/dispose_cmd.h
***************
*** 210,219 ****
  makepath.o: ${topdir}/pathnames.h ${topdir}/externs.h
  
! netopen.o: ${topdir}/bashansi.h ${BASHINCDIR}/ansi_stdlib.h
  
  oslib.o: ${topdir}/bashtypes.h ${topdir}/bashansi.h ${BASHINCDIR}/maxpath.h
  oslib.o: ${topdir}/shell.h ${topdir}/syntax.h ${topdir}/bashjmp.h ${BASHINCDIR}/posixjmp.h
  oslib.o: ${topdir}/command.h ${BASHINCDIR}/stdc.h ${topdir}/error.h
! oslib.o: ${topdir}/general.h ${topdir}/bashtypes.h ${topdir}/variables.h
  oslib.o: ${topdir}/array.h ${topdir}/hashlib.h ${topdir}/quit.h
  oslib.o: ${topdir}/unwind_prot.h ${topdir}/dispose_cmd.h
--- 238,254 ----
  makepath.o: ${topdir}/pathnames.h ${topdir}/externs.h
  
! netopen.o: ${topdir}/bashansi.h ${BASHINCDIR}/ansi_stdlib.h ${topdir}/xmalloc.h
! netopen.o: ${topdir}/shell.h ${topdir}/syntax.h ${topdir}/bashjmp.h ${BASHINCDIR}/posixjmp.h
! netopen.o: ${topdir}/command.h ${BASHINCDIR}/stdc.h ${topdir}/error.h
! netopen.o: ${topdir}/general.h ${topdir}/bashtypes.h ${topdir}/variables.h ${topdir}/conftypes.h
! netopen.o: ${topdir}/array.h ${topdir}/hashlib.h ${topdir}/quit.h
! netopen.o: ${topdir}/unwind_prot.h ${topdir}/dispose_cmd.h
! netopen.o: ${topdir}/make_cmd.h ${topdir}/subst.h ${topdir}/sig.h
! netopen.o: ${topdir}/pathnames.h ${topdir}/externs.h
  
  oslib.o: ${topdir}/bashtypes.h ${topdir}/bashansi.h ${BASHINCDIR}/maxpath.h
  oslib.o: ${topdir}/shell.h ${topdir}/syntax.h ${topdir}/bashjmp.h ${BASHINCDIR}/posixjmp.h
  oslib.o: ${topdir}/command.h ${BASHINCDIR}/stdc.h ${topdir}/error.h
! oslib.o: ${topdir}/general.h ${topdir}/bashtypes.h ${topdir}/variables.h ${topdir}/conftypes.h
  oslib.o: ${topdir}/array.h ${topdir}/hashlib.h ${topdir}/quit.h
  oslib.o: ${topdir}/unwind_prot.h ${topdir}/dispose_cmd.h
***************
*** 221,230 ****
  oslib.o: ${topdir}/pathnames.h ${topdir}/externs.h
  oslib.o: ${BASHINCDIR}/posixstat.h ${BASHINCDIR}/filecntl.h
! oslib.o: ${BASHINCDIR}/ansi_stdlib.h
  
  pathcanon.o: ${topdir}/bashtypes.h ${topdir}/bashansi.h ${BASHINCDIR}/maxpath.h
  pathcanon.o: ${topdir}/shell.h ${topdir}/syntax.h ${topdir}/bashjmp.h ${BASHINCDIR}/posixjmp.h
  pathcanon.o: ${topdir}/command.h ${BASHINCDIR}/stdc.h ${topdir}/error.h
! pathcanon.o: ${topdir}/general.h ${topdir}/bashtypes.h ${topdir}/variables.h
  pathcanon.o: ${topdir}/array.h ${topdir}/hashlib.h ${topdir}/quit.h
  pathcanon.o: ${topdir}/unwind_prot.h ${topdir}/dispose_cmd.h
--- 256,265 ----
  oslib.o: ${topdir}/pathnames.h ${topdir}/externs.h
  oslib.o: ${BASHINCDIR}/posixstat.h ${BASHINCDIR}/filecntl.h
! oslib.o: ${BASHINCDIR}/ansi_stdlib.h ${BASHINCDIR}/chartypes.h
  
  pathcanon.o: ${topdir}/bashtypes.h ${topdir}/bashansi.h ${BASHINCDIR}/maxpath.h
  pathcanon.o: ${topdir}/shell.h ${topdir}/syntax.h ${topdir}/bashjmp.h ${BASHINCDIR}/posixjmp.h
  pathcanon.o: ${topdir}/command.h ${BASHINCDIR}/stdc.h ${topdir}/error.h
! pathcanon.o: ${topdir}/general.h ${topdir}/bashtypes.h ${topdir}/variables.h ${topdir}/conftypes.h
  pathcanon.o: ${topdir}/array.h ${topdir}/hashlib.h ${topdir}/quit.h
  pathcanon.o: ${topdir}/unwind_prot.h ${topdir}/dispose_cmd.h
***************
*** 232,241 ****
  pathcanon.o: ${topdir}/pathnames.h ${topdir}/externs.h
  pathcanon.o: ${BASHINCDIR}/posixstat.h ${BASHINCDIR}/filecntl.h
! pathcanon.o: ${BASHINCDIR}/ansi_stdlib.h
  
  pathphys.o: ${topdir}/bashtypes.h ${topdir}/bashansi.h ${BASHINCDIR}/maxpath.h
  pathphys.o: ${topdir}/shell.h ${topdir}/syntax.h ${topdir}/bashjmp.h ${BASHINCDIR}/posixjmp.h
  pathphys.o: ${topdir}/command.h ${BASHINCDIR}/stdc.h ${topdir}/error.h
! pathphys.o: ${topdir}/general.h ${topdir}/bashtypes.h ${topdir}/variables.h
  pathphys.o: ${topdir}/array.h ${topdir}/hashlib.h ${topdir}/quit.h
  pathphys.o: ${topdir}/unwind_prot.h ${topdir}/dispose_cmd.h
--- 267,276 ----
  pathcanon.o: ${topdir}/pathnames.h ${topdir}/externs.h
  pathcanon.o: ${BASHINCDIR}/posixstat.h ${BASHINCDIR}/filecntl.h
! pathcanon.o: ${BASHINCDIR}/ansi_stdlib.h ${BASHINCDIR}/chartypes.h
  
  pathphys.o: ${topdir}/bashtypes.h ${topdir}/bashansi.h ${BASHINCDIR}/maxpath.h
  pathphys.o: ${topdir}/shell.h ${topdir}/syntax.h ${topdir}/bashjmp.h ${BASHINCDIR}/posixjmp.h
  pathphys.o: ${topdir}/command.h ${BASHINCDIR}/stdc.h ${topdir}/error.h
! pathphys.o: ${topdir}/general.h ${topdir}/bashtypes.h ${topdir}/variables.h ${topdir}/conftypes.h
  pathphys.o: ${topdir}/array.h ${topdir}/hashlib.h ${topdir}/quit.h
  pathphys.o: ${topdir}/unwind_prot.h ${topdir}/dispose_cmd.h
***************
*** 243,253 ****
  pathphys.o: ${topdir}/pathnames.h ${topdir}/externs.h
  pathphys.o: ${BASHINCDIR}/posixstat.h ${BASHINCDIR}/filecntl.h
! pathphys.o: ${BASHINCDIR}/ansi_stdlib.h
  
  rename.o: ${topdir}/bashtypes.h ${BASHINCDIR}/stdc.h
  
  shtty.o: ${BASHINCDIR}/shtty.h
  shtty.o: ${BASHINCDIR}/stdc.h
  
  spell.o: ${topdir}/bashtypes.h
  spell.o: ${BASHINCDIR}/posixstat.h ${BASHINCDIR}/posixdir.h
--- 278,298 ----
  pathphys.o: ${topdir}/pathnames.h ${topdir}/externs.h
  pathphys.o: ${BASHINCDIR}/posixstat.h ${BASHINCDIR}/filecntl.h
! pathphys.o: ${BASHINCDIR}/ansi_stdlib.h ${BASHINCDIR}/chartypes.h
  
  rename.o: ${topdir}/bashtypes.h ${BASHINCDIR}/stdc.h
  
+ setlinebuf.o: ${topdir}/xmalloc.h ${topdir}/bashansi.h
+ setlinebuf.o: ${BASHINCDIR}/ansi_stdlib.h ${BASHINCDIR}/stdc.h
+ 
+ shquote.o: ${BASHINCDIR}/stdc.h ${topdir}/bashansi.h
+ shquote.o: ${BASHINCDIR}/ansi_stdlib.h ${topdir}/xmalloc.h
+ 
  shtty.o: ${BASHINCDIR}/shtty.h
  shtty.o: ${BASHINCDIR}/stdc.h
  
+ snprintf.o: ${BASHINCDIR}/stdc.h ${topdir}/bashansi.h ${topdir}/xmalloc.h
+ snprintf.o: ${BASHINCDIR}/ansi_stdlib.h ${BASHINCDIR}/chartypes.h
+ snprintf.o: ${BASHINCDIR}/typemax.h
+ 
  spell.o: ${topdir}/bashtypes.h
  spell.o: ${BASHINCDIR}/posixstat.h ${BASHINCDIR}/posixdir.h
***************
*** 255,264 ****
  
  strcasecmp.o: ${BASHINCDIR}/stdc.h ${topdir}/bashansi.h
! strcasecmp.o: ${BASHINCDIR}/ansi_stdlib.h
  
  strerror.o: ${topdir}/bashtypes.h
  strerror.o: ${topdir}/shell.h ${topdir}/syntax.h ${topdir}/bashjmp.h ${BASHINCDIR}/posixjmp.h
  strerror.o: ${topdir}/command.h ${BASHINCDIR}/stdc.h ${topdir}/error.h
! strerror.o: ${topdir}/general.h ${topdir}/bashtypes.h ${topdir}/variables.h
  strerror.o: ${topdir}/array.h ${topdir}/hashlib.h ${topdir}/quit.h
  strerror.o: ${topdir}/unwind_prot.h ${topdir}/dispose_cmd.h
--- 300,309 ----
  
  strcasecmp.o: ${BASHINCDIR}/stdc.h ${topdir}/bashansi.h
! strcasecmp.o: ${BASHINCDIR}/ansi_stdlib.h ${BASHINCDIR}/chartypes.h
  
  strerror.o: ${topdir}/bashtypes.h
  strerror.o: ${topdir}/shell.h ${topdir}/syntax.h ${topdir}/bashjmp.h ${BASHINCDIR}/posixjmp.h
  strerror.o: ${topdir}/command.h ${BASHINCDIR}/stdc.h ${topdir}/error.h
! strerror.o: ${topdir}/general.h ${topdir}/bashtypes.h ${topdir}/variables.h ${topdir}/conftypes.h
  strerror.o: ${topdir}/array.h ${topdir}/hashlib.h ${topdir}/quit.h
  strerror.o: ${topdir}/unwind_prot.h ${topdir}/dispose_cmd.h
***************
*** 267,276 ****
  
  strindex.o: ${BASHINCDIR}/stdc.h ${topdir}/bashansi.h
! strindex.o: ${BASHINCDIR}/ansi_stdlib.h
  
  stringlist.o: ${topdir}/bashansi.h
  stringlist.o: ${topdir}/shell.h ${topdir}/syntax.h ${topdir}/bashjmp.h ${BASHINCDIR}/posixjmp.h
  stringlist.o: ${topdir}/command.h ${BASHINCDIR}/stdc.h ${topdir}/error.h
! stringlist.o: ${topdir}/general.h ${topdir}/bashtypes.h ${topdir}/variables.h
  stringlist.o: ${topdir}/array.h ${topdir}/hashlib.h ${topdir}/quit.h
  stringlist.o: ${topdir}/unwind_prot.h ${topdir}/dispose_cmd.h
--- 312,321 ----
  
  strindex.o: ${BASHINCDIR}/stdc.h ${topdir}/bashansi.h
! strindex.o: ${BASHINCDIR}/ansi_stdlib.h ${BASHINCDIR}/chartypes.h
  
  stringlist.o: ${topdir}/bashansi.h
  stringlist.o: ${topdir}/shell.h ${topdir}/syntax.h ${topdir}/bashjmp.h ${BASHINCDIR}/posixjmp.h
  stringlist.o: ${topdir}/command.h ${BASHINCDIR}/stdc.h ${topdir}/error.h
! stringlist.o: ${topdir}/general.h ${topdir}/bashtypes.h ${topdir}/variables.h ${topdir}/conftypes.h
  stringlist.o: ${topdir}/array.h ${topdir}/hashlib.h ${topdir}/quit.h
  stringlist.o: ${topdir}/unwind_prot.h ${topdir}/dispose_cmd.h
***************
*** 278,285 ****
  stringlist.o: ${topdir}/pathnames.h ${topdir}/externs.h
  
! stringvec.o: ${topdir}/bashansi.h
  stringvec.o: ${topdir}/shell.h ${topdir}/syntax.h ${topdir}/bashjmp.h ${BASHINCDIR}/posixjmp.h
  stringvec.o: ${topdir}/command.h ${BASHINCDIR}/stdc.h ${topdir}/error.h
! stringvec.o: ${topdir}/general.h ${topdir}/bashtypes.h ${topdir}/variables.h
  stringvec.o: ${topdir}/array.h ${topdir}/hashlib.h ${topdir}/quit.h
  stringvec.o: ${topdir}/unwind_prot.h ${topdir}/dispose_cmd.h
--- 323,330 ----
  stringlist.o: ${topdir}/pathnames.h ${topdir}/externs.h
  
! stringvec.o: ${topdir}/bashansi.h ${BASHINCDIR}/chartypes.h
  stringvec.o: ${topdir}/shell.h ${topdir}/syntax.h ${topdir}/bashjmp.h ${BASHINCDIR}/posixjmp.h
  stringvec.o: ${topdir}/command.h ${BASHINCDIR}/stdc.h ${topdir}/error.h
! stringvec.o: ${topdir}/general.h ${topdir}/bashtypes.h ${topdir}/variables.h ${topdir}/conftypes.h
  stringvec.o: ${topdir}/array.h ${topdir}/hashlib.h ${topdir}/quit.h
  stringvec.o: ${topdir}/unwind_prot.h ${topdir}/dispose_cmd.h
***************
*** 290,306 ****
  
  strtod.o: ${topdir}/bashansi.h
! strtod.o: ${BASHINCDIR}/ansi_stdlib.h
  
  strtol.o: ${topdir}/bashansi.h
! strtol.o: ${BASHINCDIR}/ansi_stdlib.h
  
  strtoul.o: ${topdir}/bashansi.h
! strtoul.o: ${BASHINCDIR}/ansi_stdlib.h
  
  strtrans.o: ${topdir}/bashansi.h
! strtrans.o: ${BASHINCDIR}/ansi_stdlib.h
  strtrans.o: ${topdir}/shell.h ${topdir}/syntax.h ${topdir}/bashjmp.h ${BASHINCDIR}/posixjmp.h
  strtrans.o: ${topdir}/command.h ${BASHINCDIR}/stdc.h ${topdir}/error.h
! strtrans.o: ${topdir}/general.h ${topdir}/bashtypes.h ${topdir}/variables.h
  strtrans.o: ${topdir}/array.h ${topdir}/hashlib.h ${topdir}/quit.h
  strtrans.o: ${topdir}/unwind_prot.h ${topdir}/dispose_cmd.h
--- 335,365 ----
  
  strtod.o: ${topdir}/bashansi.h
! strtod.o: ${BASHINCDIR}/ansi_stdlib.h ${BASHINCDIR}/chartypes.h
! 
! strtoimax.o: ${BASHINCDIR}/stdc.h
  
  strtol.o: ${topdir}/bashansi.h
! strtol.o: ${BASHINCDIR}/ansi_stdlib.h ${BASHINCDIR}/chartypes.h
! strtol.o: ${BASHINCDIR}/typemax.h
! 
! strtoll.o: ${topdir}/bashansi.h
! strtoll.o: ${BASHINCDIR}/ansi_stdlib.h ${BASHINCDIR}/chartypes.h
! strtoll.o: ${BASHINCDIR}/typemax.h
  
  strtoul.o: ${topdir}/bashansi.h
! strtoul.o: ${BASHINCDIR}/ansi_stdlib.h ${BASHINCDIR}/chartypes.h
! strtoul.o: ${BASHINCDIR}/typemax.h
! 
! strtoull.o: ${topdir}/bashansi.h
! strtoull.o: ${BASHINCDIR}/ansi_stdlib.h ${BASHINCDIR}/chartypes.h
! strtoull.o: ${BASHINCDIR}/typemax.h
! 
! strtoumax.o: ${BASHINCDIR}/stdc.h
  
  strtrans.o: ${topdir}/bashansi.h
! strtrans.o: ${BASHINCDIR}/ansi_stdlib.h ${BASHINCDIR}/chartypes.h
  strtrans.o: ${topdir}/shell.h ${topdir}/syntax.h ${topdir}/bashjmp.h ${BASHINCDIR}/posixjmp.h
  strtrans.o: ${topdir}/command.h ${BASHINCDIR}/stdc.h ${topdir}/error.h
! strtrans.o: ${topdir}/general.h ${topdir}/bashtypes.h ${topdir}/variables.h ${topdir}/conftypes.h
  strtrans.o: ${topdir}/array.h ${topdir}/hashlib.h ${topdir}/quit.h
  strtrans.o: ${topdir}/unwind_prot.h ${topdir}/dispose_cmd.h
***************
*** 318,319 ****
--- 377,397 ----
  
  clock.o: ${BASHINCDIR}/posixtime.h
+ 
+ mailstat.o: ${topdir}/bashansi.h
+ mailstat.o: ${topdir}/bashtypes.h
+ mailstat.o: ${BASHINCDIR}/ansi_stdlib.h
+ mailstat.o: ${BASHINCDIR}/posixstat.h
+ mailstat.o: ${BASHINCDIR}/posixdir.h
+ mailstat.o: ${BASHINCDIR}/maxpath.h
+ 
+ fmtulong.o: ${topdir}/bashansi.h
+ fmtulong.o: ${BASHINCDIR}/ansi_stdlib.h
+ fmtulong.o: ${BASHINCDIR}/chartypes.h
+ fmtulong.o: ${BASHINCDIR}/stdc.h
+ fmtulong.o: ${BASHINCDIR}/typemax.h
+ 
+ fmtullong.o: ${topdir}/bashansi.h
+ fmtullong.o: ${BASHINCDIR}/ansi_stdlib.h
+ fmtullong.o: ${BASHINCDIR}/chartypes.h
+ fmtullong.o: ${BASHINCDIR}/stdc.h
+ fmtullong.o: ${BASHINCDIR}/typemax.h
diff -Nrc2 bash-2.05/lib/sh/clock.c bash-2.05a/lib/sh/clock.c
*** bash-2.05/lib/sh/clock.c	Mon Aug 16 12:20:39 1999
--- bash-2.05a/lib/sh/clock.c	Mon Oct 15 09:53:43 2001
***************
*** 31,39 ****
  
  #include <stdio.h>
  
  void
  clock_t_to_secs (t, sp, sfp)
       clock_t t;
!      long *sp;
       int *sfp;
  {
--- 31,42 ----
  
  #include <stdio.h>
+ #include <stdc.h>
+ 
+ extern long get_clk_tck __P((void));
  
  void
  clock_t_to_secs (t, sp, sfp)
       clock_t t;
!      time_t *sp;
       int *sfp;
  {
***************
*** 65,78 ****
       clock_t t;
  {
!   int minutes, seconds_fraction;
!   long seconds;
  
!   clock_t_to_secs (t, &seconds, &seconds_fraction);
  
!   minutes = seconds / 60;
!   seconds %= 60;
  
!   fprintf (fp, "%0dm%0ld.%03ds",  minutes, seconds, seconds_fraction);
  }
  #endif /* HAVE_TIMES */
- 
--- 68,81 ----
       clock_t t;
  {
!   time_t timestamp;
!   long minutes;
!   int seconds, seconds_fraction;
  
!   clock_t_to_secs (t, &timestamp, &seconds_fraction);
  
!   minutes = timestamp / 60;
!   seconds = timestamp % 60;
  
!   fprintf (fp, "%ldm%d.%03ds",  minutes, seconds, seconds_fraction);
  }
  #endif /* HAVE_TIMES */
diff -Nrc2 bash-2.05/lib/sh/fmtullong.c bash-2.05a/lib/sh/fmtullong.c
*** bash-2.05/lib/sh/fmtullong.c	Wed Dec 31 19:00:00 1969
--- bash-2.05a/lib/sh/fmtullong.c	Fri Oct 12 14:41:07 2001
***************
*** 0 ****
--- 1,24 ----
+ /* Copyright (C) 2001 Free Software Foundation, Inc.
+ 
+ This program is free software; you can redistribute it and/or modify it
+ under the terms of the GNU General Public License as published by the
+ Free Software Foundation; either version 2, or (at your option) any
+ later version.
+ 
+ This program is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+ 
+ You should have received a copy of the GNU General Public License
+ along with this program; if not, write to the Free Software Foundation,
+ Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+ 
+ #include <config.h>
+ 
+ #ifdef HAVE_LONG_LONG
+ 
+ #define QUAD 1
+ #include "fmtulong.c"
+ 
+ #endif
diff -Nrc2 bash-2.05/lib/sh/fmtulong.c bash-2.05a/lib/sh/fmtulong.c
*** bash-2.05/lib/sh/fmtulong.c	Wed Dec 31 19:00:00 1969
--- bash-2.05a/lib/sh/fmtulong.c	Thu Oct 18 16:17:53 2001
***************
*** 0 ****
--- 1,196 ----
+ /* fmtulong.c -- Convert unsigned long int to string. */
+ 
+ /* Copyright (C) 1998, Free Software Foundation, Inc.
+ 
+    This file is part of GNU Bash, the Bourne Again SHell.
+ 
+    Bash is free software; you can redistribute it and/or modify it under
+    the terms of the GNU General Public License as published by the Free
+    Software Foundation; either version 2, or (at your option) any later
+    version.
+ 
+    Bash is distributed in the hope that it will be useful, but WITHOUT ANY
+    WARRANTY; without even the implied warranty of MERCHANTABILITY or
+    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+    for more details.
+ 
+    You should have received a copy of the GNU General Public License along
+    with Bash; see the file COPYING.  If not, write to the Free Software
+    Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. */
+ 
+ #ifdef HAVE_CONFIG_H
+ #  include <config.h>
+ #endif
+ 
+ #if defined (HAVE_UNISTD_H)
+ #  include <unistd.h>
+ #endif
+ 
+ #if defined (HAVE_LIMITS_H)
+ #  include <limits.h>
+ #endif
+ 
+ #include <bashansi.h>
+ #ifdef HAVE_STDDEF_H
+ #  include <stddef.h>
+ #endif
+ 
+ #ifdef HAVE_STDINT_H
+ #  include <stdint.h>
+ #endif
+ #include <chartypes.h>
+ #include <errno.h>
+ 
+ #include "stdc.h"
+ 
+ #include <typemax.h>
+ 
+ #ifndef errno
+ extern int errno;
+ #endif
+ 
+ #define x_digs  "0123456789abcdef"
+ #define X_digs  "0123456789ABCDEF"
+ 
+ /* XXX -- assumes uppercase letters, lowercase letters, and digits are
+    contiguous */
+ #define FMTCHAR(x) \
+   ((x) < 10) ? (x) + '0' \
+ 	     : (((x) < 36) ? (x) - 10 + 'a' \
+ 			   : (((x) < 62) ? (x) - 36 + 'A' \
+ 					 : (((x) == 62) ? '@' : '_')))
+ 
+ #ifndef FL_PREFIX
+ #  define FL_PREFIX	0x01	/* add 0x, 0X, or 0 prefix as appropriate */
+ #  define FL_ADDBASE	0x02	/* add base# prefix to converted value */
+ #  define FL_HEXUPPER	0x04	/* use uppercase when converting to hex */
+ #  define FL_UNSIGNED	0x08	/* don't add any sign */
+ #endif
+ 
+ #ifdef QUAD
+    /* fmtullong */
+ #  define LONG	long long
+ #  define FMTUL_LONG_MAX	LLONG_MAX
+ #  define FMTUL_ULONG_MAX	ULLONG_MAX
+ #else
+ #  define LONG	long
+ #  define FMTUL_LONG_MAX	LONG_MAX
+ #  define FMTUL_ULONG_MAX	ULONG_MAX
+ #endif
+ 
+ /* Set the name */
+ #ifdef QUAD
+ #  define fmtulong	fmtullong
+ #endif
+ 
+ /* `unsigned long' (or unsigned long long) to string conversion for a given
+    base.  The caller passes the output buffer and the size.  This should
+    check for buffer underflow, but currently does not. */
+ char *
+ fmtulong (ui, base, buf, len, flags)
+      unsigned LONG ui;
+      int base;
+      char *buf;
+      size_t len;
+      int flags;
+ {
+   char *p;
+   int sign;
+   LONG si;
+ 
+   if (base == 0)
+     base = 10;
+ 
+   if (base < 2 || base > 64)
+     {
+ #if 1
+       strncpy (buf, "invalid base", len - 1);
+       buf[len] = '\0';
+       errno = EINVAL;
+       return (p = buf);
+ #else
+       base = 10;
+ #endif
+     }
+ 
+   sign = 0;
+   if ((flags & FL_UNSIGNED) == 0 && (LONG)ui < 0)
+     {
+       ui = -ui;
+       sign = '-';
+     }
+ 
+   p = buf + len - 2;
+   p[1] = '\0';
+ 
+   /* handle common cases explicitly */
+   switch (base)
+     {
+     case 10:
+       if (ui < 10)
+ 	{
+ 	  *p-- = TOCHAR (ui);
+ 	  break;
+ 	}
+       /* Favor signed arithmetic over unsigned arithmetic; it is faster on
+ 	 many machines. */
+       if (ui > FMTUL_LONG_MAX)
+ 	{
+ 	  *p-- = TOCHAR (ui % 10);
+ 	  si = ui / 10;
+ 	}
+       else
+         si = ui;
+       do
+ 	*p-- = TOCHAR (si % 10);
+       while (si /= 10);
+       break;
+ 
+     case 8:
+       do
+ 	*p-- = TOCHAR (ui & 7);
+       while (ui >>= 3);
+       break;
+ 
+     case 16:
+       do
+ 	*p-- = (flags & FL_HEXUPPER) ? X_digs[ui & 15] : x_digs[ui & 15];
+       while (ui >>= 4);
+       break;
+ 
+     case 2:
+       do
+ 	*p-- = TOCHAR (ui & 1);
+       while (ui >>= 1);
+       break;
+ 
+     default:
+       do
+ 	*p-- = FMTCHAR (ui % base);
+       while (ui /= base);
+       break;
+     }
+ 
+   if ((flags & FL_PREFIX) && (base == 8 || base == 16))
+     {
+       if (base == 16)
+ 	{
+ 	  *p-- = (flags & FL_HEXUPPER) ? 'X' : 'x';
+ 	  *p-- = '0';
+ 	}
+       else if (p[1] != '0')
+ 	*p-- = '0';
+     }
+   else if ((flags & FL_ADDBASE) && base != 10)
+     {
+       *p-- = '#';
+       *p-- = TOCHAR (base % 10);
+       if (base > 10)
+         *p-- = TOCHAR (base / 10);
+     }
+ 
+   if (sign)
+     *p-- = '-';
+ 
+   return (p + 1);
+ }
diff -Nrc2 bash-2.05/lib/sh/getcwd.c bash-2.05a/lib/sh/getcwd.c
*** bash-2.05/lib/sh/getcwd.c	Thu Aug  5 08:20:44 1999
--- bash-2.05a/lib/sh/getcwd.c	Tue Sep  4 09:18:33 2001
***************
*** 41,64 ****
  #include <bashansi.h>
  
  #if !defined (errno)
  extern int errno;
  #endif /* !errno */
  
- #if defined (__STDC__)
- #  define CONST const
- #  define PTR void *
- #else /* !__STDC__ */
- #  define CONST
- #  define PTR char *
- #endif /* !__STDC__ */
- 
- #if !defined (PATH_MAX)
- #  if defined (MAXPATHLEN)
- #    define PATH_MAX MAXPATHLEN
- #  else /* !MAXPATHLEN */
- #    define PATH_MAX 1024
- #  endif /* !MAXPATHLEN */
- #endif /* !PATH_MAX */
- 
  #if !defined (HAVE_LSTAT)
  #  define lstat stat
--- 41,50 ----
  #include <bashansi.h>
  
+ #include <xmalloc.h>
+ 
  #if !defined (errno)
  extern int errno;
  #endif /* !errno */
  
  #if !defined (HAVE_LSTAT)
  #  define lstat stat
***************
*** 86,94 ****
  #endif /* !__STDC__ */
  {
!   static CONST char dots[]
      = "../../../../../../../../../../../../../../../../../../../../../../../\
  ../../../../../../../../../../../../../../../../../../../../../../../../../../\
  ../../../../../../../../../../../../../../../../../../../../../../../../../..";
!   CONST char *dotp, *dotlist;
    size_t dotsize;
    dev_t rootdev, thisdev;
--- 72,80 ----
  #endif /* !__STDC__ */
  {
!   static const char dots[]
      = "../../../../../../../../../../../../../../../../../../../../../../../\
  ../../../../../../../../../../../../../../../../../../../../../../../../../../\
  ../../../../../../../../../../../../../../../../../../../../../../../../../..";
!   const char *dotp, *dotlist;
    size_t dotsize;
    dev_t rootdev, thisdev;
***************
*** 150,154 ****
  	  else
  	    {
! 	      new = (char *)realloc ((PTR) dotlist, dotsize * 2 + 1);
  	      if (new == NULL)
  		goto lose;
--- 136,140 ----
  	  else
  	    {
! 	      new = (char *)realloc ((PTR_T) dotlist, dotsize * 2 + 1);
  	      if (new == NULL)
  		goto lose;
***************
*** 233,237 ****
  	      else
  		{
! 		  new = (char *)realloc ((PTR) pathbuf, (pathsize * 2));
  		  if (!new)
  		    goto lose;
--- 219,223 ----
  	      else
  		{
! 		  new = (char *)realloc ((PTR_T) pathbuf, (pathsize * 2));
  		  if (!new)
  		    goto lose;
***************
*** 258,262 ****
  
    if (dotlist != dots)
!     free ((PTR) dotlist);
  
    {
--- 244,248 ----
  
    if (dotlist != dots)
!     free ((PTR_T) dotlist);
  
    {
***************
*** 275,279 ****
  	goto lose2;
        }
!     (void) memcpy((PTR) buf, (PTR) pathp, len);
    }
  
--- 261,265 ----
  	goto lose2;
        }
!     (void) memcpy((PTR_T) buf, (PTR_T) pathp, len);
    }
  
***************
*** 287,291 ****
      {
        int e = errno;
!       free ((PTR) dotlist);
        errno = e;
      }
--- 273,277 ----
      {
        int e = errno;
!       free ((PTR_T) dotlist);
        errno = e;
      }
***************
*** 295,299 ****
      {
        int e = errno;
!       free ((PTR) pathbuf);
        errno = e;
      }
--- 281,285 ----
      {
        int e = errno;
!       free ((PTR_T) pathbuf);
        errno = e;
      }
diff -Nrc2 bash-2.05/lib/sh/inet_aton.c bash-2.05a/lib/sh/inet_aton.c
*** bash-2.05/lib/sh/inet_aton.c	Mon Feb 14 15:51:19 2000
--- bash-2.05a/lib/sh/inet_aton.c	Mon Oct 15 12:04:50 2001
***************
*** 116,120 ****
  	register u_bits32_t val;
  	register int base, n;
! 	register char c;
  	u_int parts[4];
  	register u_int *pp = parts;
--- 116,120 ----
  	register u_bits32_t val;
  	register int base, n;
! 	register unsigned char c;
  	u_int parts[4];
  	register u_int *pp = parts;
***************
*** 127,131 ****
--- 127,136 ----
  		 * 0x=hex, 0=octal, isdigit=decimal.
  		 */
+ #if 0
  		if (!isdigit(c))
+ #else
+ 		if (c != '0' && c != '1' && c != '2' && c != '3' && c != '4' &&
+ 		    c != '5' && c != '6' && c != '7' && c != '8' && c != '9')
+ #endif
  			return (0);
  		val = 0; base = 10;
diff -Nrc2 bash-2.05/lib/sh/itos.c bash-2.05a/lib/sh/itos.c
*** bash-2.05/lib/sh/itos.c	Thu Aug  5 08:21:11 1999
--- bash-2.05a/lib/sh/itos.c	Mon Oct 15 16:10:57 2001
***************
*** 19,23 ****
     Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. */
  
! #include <config.h>
  
  #if defined (HAVE_UNISTD_H)
--- 19,25 ----
     Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. */
  
! #ifdef HAVE_CONFIG_H
! #  include <config.h>
! #endif
  
  #if defined (HAVE_UNISTD_H)
***************
*** 25,67 ****
  #endif
  
! #include "bashansi.h"
  #include "shell.h"
  
- /* Number of characters that can appear in a string representation
-    of an integer.  32 is larger than the string rep of 2^^31 - 1. */
- #define MAX_INT_LEN 32
- 
- /* Integer to string conversion.  The caller passes the buffer and
-    the size.  This should check for buffer underflow, but currently
-    does not. */
  char *
  inttostr (i, buf, len)
!      int i;
       char *buf;
!      int len;
  {
!   char *p;
!   int negative = 0;
!   unsigned int ui;
! 
!   if (i < 0)
!     {
!       negative++;
!       i = -i;
!     }
! 
!   ui = (unsigned int) i;
! 
!   p = buf + len - 2;
!   p[1] = '\0';
  
!   do
!     *p-- = (ui % 10) + '0';
!   while (ui /= 10);
  
!   if (negative)
!     *p-- = '-';
  
!   return (p + 1);
  }
  
--- 27,62 ----
  #endif
  
! #include <bashansi.h>
! #include <chartypes.h>
  #include "shell.h"
  
  char *
  inttostr (i, buf, len)
!      long i;
       char *buf;
!      size_t len;
  {
!   return (fmtulong (i, 10, buf, len, 0));
! }
  
! /* Integer to string conversion.  This conses the string; the
!    caller should free it. */
! char *
! itos (i)
!      long i;
! {
!   char *p, lbuf[INT_STRLEN_BOUND(long) + 1];
  
!   p = fmtulong (i, 10, lbuf, sizeof(lbuf), 0);
!   return (savestring (p));
! }
  
! char *
! uinttostr (i, buf, len)
!      unsigned long i;
!      char *buf;
!      size_t len;
! {
!   return (fmtulong (i, 10, buf, len, FL_UNSIGNED));
  }
  
***************
*** 69,78 ****
     caller should free it. */
  char *
! itos (i)
!      int i;
  {
!   char *p, lbuf[MAX_INT_LEN];
  
!   p = inttostr (i, lbuf, sizeof(lbuf));
    return (savestring (p));
  }
--- 64,73 ----
     caller should free it. */
  char *
! uitos (i)
!      unsigned long i;
  {
!   char *p, lbuf[INT_STRLEN_BOUND(long) + 1];
  
!   p = fmtulong (i, 10, lbuf, sizeof(lbuf), FL_UNSIGNED);
    return (savestring (p));
  }
diff -Nrc2 bash-2.05/lib/sh/mailstat.c bash-2.05a/lib/sh/mailstat.c
*** bash-2.05/lib/sh/mailstat.c	Wed Dec 31 19:00:00 1969
--- bash-2.05a/lib/sh/mailstat.c	Mon Oct 15 13:46:48 2001
***************
*** 0 ****
--- 1,159 ----
+ /* mailstat.c -- stat a mailbox file, handling maildir-type mail directories */
+ 
+ /* Copyright (C) 2001 Free Software Foundation, Inc.
+ 
+    This file is part of GNU Bash, the Bourne Again SHell.
+ 
+    Bash is free software; you can redistribute it and/or modify it under
+    the terms of the GNU General Public License as published by the Free
+    Software Foundation; either version 2, or (at your option) any later
+    version.
+ 
+    Bash is distributed in the hope that it will be useful, but WITHOUT ANY
+    WARRANTY; without even the implied warranty of MERCHANTABILITY or
+    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+    for more details.
+ 
+    You should have received a copy of the GNU General Public License along
+    with Bash; see the file COPYING.  If not, write to the Free Software
+    Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. */
+ 
+ #include <config.h>
+  
+ #include <stdio.h>
+ #include <errno.h>
+ 
+ #include <bashtypes.h>
+ #include <posixstat.h>
+ #include <posixdir.h>
+ #include <bashansi.h>
+ 
+ #ifndef _MINIX
+ #  include <sys/param.h>
+ #endif
+ 
+ #include <maxpath.h>
+ 
+ /*
+  *     Stat a file. If it's a maildir, check all messages
+  *     in the maildir and present the grand total as a file.
+  *     The fields in the 'struct stat' are from the mail directory.
+  *     The following fields are emulated:
+  *
+  *     st_nlink	always 1, unless st_blocks is not present, in which case it's
+  *		the total number of messages
+  *     st_size	 total number of bytes in all files
+  *     st_blocks       total number of messages, if present in struct stat
+  *     st_atime	access time of newest file in maildir
+  *     st_mtime	modify time of newest file in maildir
+  *     st_mode	 S_IFDIR changed to S_IFREG
+  *
+  *     This is good enough for most mail-checking applications.
+  */
+ 
+ int
+ mailstat(path, st)
+      const char *path;
+      struct stat *st;
+ {
+   static struct stat st_new_last, st_ret_last;
+   struct stat st_ret, st_tmp;
+   DIR *dd;
+   struct dirent *fn;
+   char dir[PATH_MAX * 2], file[PATH_MAX * 2];
+   int i, l;
+   time_t atime, mtime;
+ 
+   atime = mtime = 0;
+ 
+   /* First see if it's a directory. */
+   if ((i = stat(path, st)) != 0 || S_ISDIR(st->st_mode) == 0)
+     return i;
+ 
+   if (strlen(path) > sizeof(dir) - 5)
+     {
+ #ifdef ENAMETOOLONG
+       errno = ENAMETOOLONG;
+ #else
+       errno = EINVAL;
+ #endif
+       return -1;
+     }
+ 
+   st_ret = *st;
+   st_ret.st_nlink = 1;
+   st_ret.st_size  = 0;
+ #ifdef HAVE_STRUCT_STAT_ST_BLOCKS
+   st_ret.st_blocks  = 0;
+ #else
+   st_ret.st_nlink = 0;
+ #endif
+   st_ret.st_mode  &= ~S_IFDIR;
+   st_ret.st_mode  |= S_IFREG;
+ 
+   /* See if cur/ is present */
+   sprintf(dir, "%s/cur", path);
+   if (stat(dir, &st_tmp) || S_ISDIR(st_tmp.st_mode) == 0)
+     return 0;
+   st_ret.st_atime = st_tmp.st_atime;
+ 
+   /* See if tmp/ is present */
+   sprintf(dir, "%s/tmp", path);
+   if (stat(dir, &st_tmp) || S_ISDIR(st_tmp.st_mode) == 0)
+     return 0;
+   st_ret.st_mtime = st_tmp.st_mtime;
+ 
+   /* And new/ */
+   sprintf(dir, "%s/new", path);
+   if (stat(dir, &st_tmp) || S_ISDIR(st_tmp.st_mode) == 0)
+     return 0;
+   st_ret.st_mtime = st_tmp.st_mtime;
+ 
+   /* Optimization - if new/ didn't change, nothing else did. */
+   if (st_tmp.st_dev == st_new_last.st_dev &&
+       st_tmp.st_ino == st_new_last.st_ino &&
+       st_tmp.st_atime == st_new_last.st_atime &&
+       st_tmp.st_mtime == st_new_last.st_mtime)
+     {
+       *st = st_ret_last;
+       return 0;
+     }
+   st_new_last = st_tmp;
+ 
+   /* Loop over new/ and cur/ */
+   for (i = 0; i < 2; i++)
+     {
+       sprintf(dir, "%s/%s", path, i ? "cur" : "new");
+       sprintf(file, "%s/", dir);
+       l = strlen(file);
+       if ((dd = opendir(dir)) == NULL)
+ 	return 0;
+       while ((fn = readdir(dd)) != NULL)
+ 	{
+ 	  if (fn->d_name[0] == '.' || strlen(fn->d_name) + l >= sizeof(file))
+ 	    continue;
+ 	  strcpy(file + l, fn->d_name);
+ 	  if (stat(file, &st_tmp) != 0)
+ 	    continue;
+ 	  st_ret.st_size += st_tmp.st_size;
+ #ifdef HAVE_STRUCT_STAT_ST_BLOCKS
+ 	  st_ret.st_blocks++;
+ #else
+ 	  st_ret.st_nlink++;
+ #endif
+ 	  if (st_tmp.st_atime != st_tmp.st_mtime && st_tmp.st_atime > atime)
+ 	    atime = st_tmp.st_atime;
+ 	  if (st_tmp.st_mtime > mtime)
+ 	    mtime = st_tmp.st_mtime;
+ 	}
+       closedir(dd);
+     }
+ 
+     if (atime)
+       st_ret.st_atime = atime;
+     if (mtime)
+       st_ret.st_mtime = mtime;
+ 
+     *st = st_ret_last = st_ret;
+     return 0;
+ }
diff -Nrc2 bash-2.05/lib/sh/makepath.c bash-2.05a/lib/sh/makepath.c
*** bash-2.05/lib/sh/makepath.c	Mon Sep 11 10:07:19 2000
--- bash-2.05a/lib/sh/makepath.c	Thu Sep 13 15:38:35 2001
***************
*** 28,32 ****
  #endif
  
! #include "bashansi.h"
  #include "shell.h"
  
--- 28,32 ----
  #endif
  
! #include <bashansi.h>
  #include "shell.h"
  
***************
*** 57,61 ****
  #define MAKEDOT() \
    do { \
!     xpath = xmalloc (2); \
      xpath[0] = '.'; \
      xpath[1] = '\0'; \
--- 57,61 ----
  #define MAKEDOT() \
    do { \
!     xpath = (char *)xmalloc (2); \
      xpath[0] = '.'; \
      xpath[1] = '\0'; \
***************
*** 65,73 ****
  char *
  sh_makepath (path, dir, flags)
!      char *path, *dir;
       int flags;
  {
    int dirlen, pathlen;
!   char *ret, *xpath, *r, *s;
  
    if (path == 0 || *path == '\0')
--- 65,73 ----
  char *
  sh_makepath (path, dir, flags)
!      const char *path, *dir;
       int flags;
  {
    int dirlen, pathlen;
!   char *ret, *xpath, *xdir, *r, *s;
  
    if (path == 0 || *path == '\0')
***************
*** 92,107 ****
    else
      {
!       xpath = ((flags & MP_DOTILDE) && *path == '~') ? bash_tilde_expand (path) : path;
        pathlen = strlen (xpath);
      }
  
!   dirlen = strlen (dir);
    if ((flags & MP_RMDOT) && dir[0] == '.' && dir[1] == '/')
      {
!       dir += 2;
        dirlen -= 2;
      }
  
!   r = ret = xmalloc (2 + dirlen + pathlen);
    s = xpath;
    while (*s)
--- 92,108 ----
    else
      {
!       xpath = ((flags & MP_DOTILDE) && *path == '~') ? bash_tilde_expand (path) : (char *)path;
        pathlen = strlen (xpath);
      }
  
!   xdir = (char *)dir;
!   dirlen = strlen (xdir);
    if ((flags & MP_RMDOT) && dir[0] == '.' && dir[1] == '/')
      {
!       xdir += 2;
        dirlen -= 2;
      }
  
!   r = ret = (char *)xmalloc (2 + dirlen + pathlen);
    s = xpath;
    while (*s)
***************
*** 109,113 ****
    if (s[-1] != '/')
      *r++ = '/';      
!   s = dir;
    while (*r++ = *s++)
      ;
--- 110,114 ----
    if (s[-1] != '/')
      *r++ = '/';      
!   s = xdir;
    while (*r++ = *s++)
      ;
diff -Nrc2 bash-2.05/lib/sh/netopen.c bash-2.05a/lib/sh/netopen.c
*** bash-2.05/lib/sh/netopen.c	Tue Aug  1 14:59:59 2000
--- bash-2.05a/lib/sh/netopen.c	Tue Oct 23 14:30:25 2001
***************
*** 28,31 ****
--- 28,35 ----
  #if defined (HAVE_NETWORK)
  
+ #if defined (HAVE_UNISTD_H)
+ #  include <unistd.h>
+ #endif
+ 
  #include <stdio.h> 
  #include <sys/types.h>
***************
*** 48,54 ****
  
  #include <bashansi.h>
- #include <ctype.h>
  #include <errno.h>
  
  #ifndef errno
  extern int errno;
--- 52,60 ----
  
  #include <bashansi.h>
  #include <errno.h>
  
+ #include <shell.h>
+ #include <xmalloc.h>
+ 
  #ifndef errno
  extern int errno;
***************
*** 56,64 ****
  
  #if !defined (HAVE_INET_ATON)
! extern int inet_aton ();
  #endif
  
! extern char *xmalloc ();
! 
  /* Stuff the internet address corresponding to HOST into AP, in network
     byte order.  Return 1 on success, 0 on failure. */
--- 62,69 ----
  
  #if !defined (HAVE_INET_ATON)
! extern int inet_aton __P((const char *, struct in_addr *));
  #endif
  
! #ifndef HAVE_GETADDRINFO
  /* Stuff the internet address corresponding to HOST into AP, in network
     byte order.  Return 1 on success, 0 on failure. */
***************
*** 73,77 ****
  
    r = 0;
!   if (isdigit (host[0]))
      {
        /* If the first character is a digit, guess that it's an
--- 78,82 ----
  
    r = 0;
!   if (host[0] >= '0' && host[0] <= '9')
      {
        /* If the first character is a digit, guess that it's an
***************
*** 108,114 ****
    if (legal_number (serv, &l))
      {
-       if (l > 65535)
- 	return 0;
        s = (unsigned short)(l & 0xFFFF);
        s = htons (s);
        if (pp)
--- 113,119 ----
    if (legal_number (serv, &l))
      {
        s = (unsigned short)(l & 0xFFFF);
+       if (s != l)
+ 	return (0);
        s = htons (s);
        if (pp)
***************
*** 133,138 ****
  }
  
  static int 
! _netopen(host, serv, typ)
       char *host, *serv;
       int typ;
--- 138,147 ----
  }
  
+ /*
+  * Open a TCP or UDP connection to HOST on port SERV.  Uses the
+  * traditional BSD mechanisms.  Returns the connected socket or -1 on error.
+  */
  static int 
! _netopen4(host, serv, typ)
       char *host, *serv;
       int typ;
***************
*** 142,146 ****
    unsigned short p;
    int s, e;
-   char **cp;
  
    if (_getaddr(host, &ina) == 0)
--- 151,154 ----
***************
*** 181,184 ****
--- 189,276 ----
    return(s);
  }
+ #endif /* ! HAVE_GETADDRINFO */
+ 
+ #ifdef HAVE_GETADDRINFO
+ /*
+  * Open a TCP or UDP connection to HOST on port SERV.  Uses getaddrinfo(3)
+  * which provides support for IPv6.  Returns the connected socket or -1
+  * on error.
+  */
+ static int
+ _netopen6 (host, serv, typ)
+      char *host, *serv;
+      int typ;
+ {
+   int s, e;
+   struct addrinfo hints, *res, *res0;
+   int gerr;
+ 
+   bzero ((char *)&hints, sizeof (hints));
+   /* XXX -- if problems with IPv6, set to PF_INET for IPv4 only */
+ #ifdef DEBUG	/* PF_INET is the one that works for me */
+   hints.ai_family = PF_INET;
+ #else
+   hints.ai_family = PF_UNSPEC;
+ #endif
+   hints.ai_socktype = (typ == 't') ? SOCK_STREAM : SOCK_DGRAM;
+ 
+   gerr = getaddrinfo (host, serv, &hints, &res0);
+   if (gerr)
+     {
+       if (gerr == EAI_SERVICE)
+ 	internal_error ("%s: %s", serv, gai_strerror (gerr));
+       else
+ 	internal_error ("%s: %s", host, gai_strerror (gerr));
+       errno = EINVAL;
+       return -1;
+     }
+ 
+   for (res = res0; res; res = res->ai_next)
+     {
+       if ((s = socket (res->ai_family, res->ai_socktype, res->ai_protocol)) < 0)
+ 	{
+ 	  if (res->ai_next)
+ 	    continue;
+ 	  sys_error ("socket");
+ 	  freeaddrinfo (res0);
+ 	  return -1;
+ 	}
+       if (connect (s, res->ai_addr, res->ai_addrlen) < 0)
+ 	{
+ 	  if (res->ai_next)
+ 	    {
+ 	      close (s);
+ 	      continue;
+ 	    }
+ 	  e = errno;
+ 	  sys_error ("connect");
+ 	  close (s);
+ 	  freeaddrinfo (res0);
+ 	  errno = e;
+ 	  return -1;
+ 	}
+       freeaddrinfo (res0);
+       break;
+     }
+   return s;
+ }
+ #endif /* HAVE_GETADDRINFO */
+ 
+ /*
+  * Open a TCP or UDP connection to HOST on port SERV.  Uses getaddrinfo(3)
+  * if available, falling back to the traditional BSD mechanisms otherwise.
+  * Returns the connected socket or -1 on error.
+  */
+ static int 
+ _netopen(host, serv, typ)
+      char *host, *serv;
+      int typ;
+ {
+ #ifdef HAVE_GETADDRINFO
+   return (_netopen6 (host, serv, typ));
+ #else
+   return (_netopen4 (host, serv, typ));
+ #endif
+ }
  
  /*
***************
*** 193,197 ****
    int fd;
  
!   np = xmalloc (strlen (path) + 1);
    strcpy (np, path);
  
--- 285,289 ----
    int fd;
  
!   np = (char *)xmalloc (strlen (path) + 1);
    strcpy (np, path);
  
diff -Nrc2 bash-2.05/lib/sh/oslib.c bash-2.05a/lib/sh/oslib.c
*** bash-2.05/lib/sh/oslib.c	Tue Aug 25 11:37:00 1998
--- bash-2.05a/lib/sh/oslib.c	Wed Sep 12 10:32:22 2001
***************
*** 36,40 ****
  #include <stdio.h>
  #include <errno.h>
! #include <ctype.h>
  
  #include <shell.h>
--- 36,40 ----
  #include <stdio.h>
  #include <errno.h>
! #include <chartypes.h>
  
  #include <shell.h>
diff -Nrc2 bash-2.05/lib/sh/pathcanon.c bash-2.05a/lib/sh/pathcanon.c
*** bash-2.05/lib/sh/pathcanon.c	Wed Feb 14 17:02:38 2001
--- bash-2.05a/lib/sh/pathcanon.c	Mon Oct 29 14:13:29 2001
***************
*** 19,29 ****
     Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. */
  
! #include "config.h"
  
! #include "bashtypes.h"
  #ifndef _MINIX
  #  include <sys/param.h>
  #endif
! #include "posixstat.h"
  
  #if defined (HAVE_UNISTD_H)
--- 19,29 ----
     Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. */
  
! #include <config.h>
  
! #include <bashtypes.h>
  #ifndef _MINIX
  #  include <sys/param.h>
  #endif
! #include <posixstat.h>
  
  #if defined (HAVE_UNISTD_H)
***************
*** 31,42 ****
  #endif
  
! #include "filecntl.h"
! #include "bashansi.h"
  #include <stdio.h>
  
  #include "shell.h"
  
- #include "maxpath.h"
- 
  /* Return 1 if PATH corresponds to a directory.  A function for debugging. */
  static int
--- 31,41 ----
  #endif
  
! #include <filecntl.h>
! #include <bashansi.h>
  #include <stdio.h>
+ #include <chartypes.h>
  
  #include "shell.h"
  
  /* Return 1 if PATH corresponds to a directory.  A function for debugging. */
  static int
***************
*** 81,85 ****
        stub_char = DIRSEP;
  #if defined (__CYGWIN__)
!       base = (isalpha(result[0]) && result[1] == ':') ? result + 3 : result + 1;
  #else
        base = result + 1;
--- 80,84 ----
        stub_char = DIRSEP;
  #if defined (__CYGWIN__)
!       base = (ISALPHA((unsigned char)result[0]) && result[1] == ':') ? result + 3 : result + 1;
  #else
        base = result + 1;
***************
*** 92,99 ****
        stub_char = '.';
  #if defined (__CYGWIN__)
!       base = (isalpha(result[0]) && result[1] == ':') ? result + 2 : result;
  #else
        base = result;
  #endif
      }
  
--- 91,99 ----
        stub_char = '.';
  #if defined (__CYGWIN__)
!       base = (ISALPHA((unsigned char)result[0]) && result[1] == ':') ? result + 2 : result;
  #else
        base = result;
  #endif
+       double_slash_path = 0;
      }
  
diff -Nrc2 bash-2.05/lib/sh/pathphys.c bash-2.05a/lib/sh/pathphys.c
*** bash-2.05/lib/sh/pathphys.c	Wed Feb 14 17:02:43 2001
--- bash-2.05a/lib/sh/pathphys.c	Mon Oct 15 14:34:20 2001
***************
*** 19,29 ****
     Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. */
  
! #include "config.h"
  
! #include "bashtypes.h"
  #ifndef _MINIX
  #  include <sys/param.h>
  #endif
! #include "posixstat.h"
  
  #if defined (HAVE_UNISTD_H)
--- 19,29 ----
     Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. */
  
! #include <config.h>
  
! #include <bashtypes.h>
  #ifndef _MINIX
  #  include <sys/param.h>
  #endif
! #include <posixstat.h>
  
  #if defined (HAVE_UNISTD_H)
***************
*** 31,43 ****
  #endif
  
! #include "filecntl.h"
! #include "bashansi.h"
  #include <stdio.h>
  #include <errno.h>
  
  #include "shell.h"
  
- #include "maxpath.h"
- 
  #if !defined (MAXSYMLINKS)
  #  define MAXSYMLINKS 32
--- 31,42 ----
  #endif
  
! #include <filecntl.h>
! #include <bashansi.h>
  #include <stdio.h>
+ #include <chartypes.h>
  #include <errno.h>
  
  #include "shell.h"
  
  #if !defined (MAXSYMLINKS)
  #  define MAXSYMLINKS 32
***************
*** 83,89 ****
  
    nlink = 0;
!   q = result = xmalloc (PATH_MAX + 1);
  
!   workpath = xmalloc (PATH_MAX + 1);
    strcpy (workpath, path);
  
--- 82,88 ----
  
    nlink = 0;
!   q = result = (char *)xmalloc (PATH_MAX + 1);
  
!   workpath = (char *)xmalloc (PATH_MAX + 1);
    strcpy (workpath, path);
  
***************
*** 93,97 ****
       leading `x:' (dos drive name). */
  #if defined (__CYGWIN__)
!   qbase = (isalpha(workpath[0]) && workpath[1] == ':') ? workpath + 3 : workpath + 1;
  #else
    qbase = workpath + 1;
--- 92,96 ----
       leading `x:' (dos drive name). */
  #if defined (__CYGWIN__)
!   qbase = (ISALPHA((unsigned char)workpath[0]) && workpath[1] == ':') ? workpath + 3 : workpath + 1;
  #else
    qbase = workpath + 1;
***************
*** 177,181 ****
  	      /* Duplicating some code here... */
  #if defined (__CYGWIN__)
! 	      qbase = (isalpha(workpath[0]) && workpath[1] == ':') ? workpath + 3 : workpath + 1;
  #else
  	      qbase = workpath + 1;
--- 176,180 ----
  	      /* Duplicating some code here... */
  #if defined (__CYGWIN__)
! 	      qbase = (ISALPHA((unsigned char)workpath[0]) && workpath[1] == ':') ? workpath + 3 : workpath + 1;
  #else
  	      qbase = workpath + 1;
diff -Nrc2 bash-2.05/lib/sh/setlinebuf.c bash-2.05a/lib/sh/setlinebuf.c
*** bash-2.05/lib/sh/setlinebuf.c	Thu Sep 30 15:07:28 1999
--- bash-2.05a/lib/sh/setlinebuf.c	Wed Oct 17 09:33:23 2001
***************
*** 23,27 ****
  #include <stdio.h>
  
! extern char *xmalloc();
  
  #if defined (USING_BASH_MALLOC)
--- 23,27 ----
  #include <stdio.h>
  
! #include <xmalloc.h>
  
  #if defined (USING_BASH_MALLOC)
***************
*** 43,47 ****
  
  #if defined (USING_BASH_MALLOC)
!   local_linebuf = xmalloc (LBUF_BUFSIZE);
  #else
    local_linebuf = (char *)NULL;
--- 43,47 ----
  
  #if defined (USING_BASH_MALLOC)
!   local_linebuf = (char *)xmalloc (LBUF_BUFSIZE);
  #else
    local_linebuf = (char *)NULL;
***************
*** 57,61 ****
  # else /* !HAVE_SETVBUF */
  
!   setlinebuf (stream));
    return (0);
  
--- 57,61 ----
  # else /* !HAVE_SETVBUF */
  
!   setlinebuf (stream);
    return (0);
  
diff -Nrc2 bash-2.05/lib/sh/shquote.c bash-2.05a/lib/sh/shquote.c
*** bash-2.05/lib/sh/shquote.c	Wed Feb 14 17:03:13 2001
--- bash-2.05a/lib/sh/shquote.c	Mon Oct 22 12:51:14 2001
***************
*** 29,34 ****
  
  #include "syntax.h"
! 
! extern char *xmalloc ();
  
  /* **************************************************************** */
--- 29,33 ----
  
  #include "syntax.h"
! #include <xmalloc.h>
  
  /* **************************************************************** */
***************
*** 47,51 ****
    char *result, *r, *s;
  
!   result = xmalloc (3 + (4 * strlen (string)));
    r = result;
    *r++ = '\'';
--- 46,50 ----
    char *result, *r, *s;
  
!   result = (char *)xmalloc (3 + (4 * strlen (string)));
    r = result;
    *r++ = '\'';
***************
*** 74,81 ****
       char *string;
  {
!   register int c;
    char *result, *r, *s;
  
!   result = xmalloc (3 + (2 * strlen (string)));
    r = result;
    *r++ = '"';
--- 73,80 ----
       char *string;
  {
!   register unsigned char c;
    char *result, *r, *s;
  
!   result = (char *)xmalloc (3 + (2 * strlen (string)));
    r = result;
    *r++ = '"';
***************
*** 104,108 ****
    char *result, *r, *s;
  
!   r = result = xmalloc (strlen (string) + 1);
  
    for (pass_next = 0, s = string; s && (c = *s); s++)
--- 103,107 ----
    char *result, *r, *s;
  
!   r = result = (char *)xmalloc (strlen (string) + 1);
  
    for (pass_next = 0, s = string; s && (c = *s); s++)
***************
*** 114,118 ****
  	  continue;
  	}
!       if (c == '\\' && (sh_syntaxtab[s[1]] & CBSDQUOTE))
  	{
  	  pass_next = 1;
--- 113,117 ----
  	  continue;
  	}
!       if (c == '\\' && (sh_syntaxtab[(unsigned char) s[1]] & CBSDQUOTE))
  	{
  	  pass_next = 1;
***************
*** 135,139 ****
    char *result, *r, *s;
  
!   result = xmalloc (2 * strlen (string) + 1);
  
    for (r = result, s = string; s && (c = *s); s++)
--- 134,138 ----
    char *result, *r, *s;
  
!   result = (char *)xmalloc (2 * strlen (string) + 1);
  
    for (r = result, s = string; s && (c = *s); s++)
***************
*** 180,187 ****
       char *string;
  {
!   int c;
    char *result, *r, *s;
  
!   result = xmalloc (2 * strlen (string) + 1);
  
    for (r = result, s = string; s && (c = *s); s++)
--- 179,186 ----
       char *string;
  {
!   unsigned char c;
    char *result, *r, *s;
  
!   result = (char *)xmalloc (2 * strlen (string) + 1);
  
    for (r = result, s = string; s && (c = *s); s++)
***************
*** 220,223 ****
--- 219,223 ----
  	  if (s == string || s[-1] == '=' || s[-1] == ':')
  	    return (1);
+ 	  break;
  	case '#':
  	  if (s == string)			/* comment char */
diff -Nrc2 bash-2.05/lib/sh/snprintf.c bash-2.05a/lib/sh/snprintf.c
*** bash-2.05/lib/sh/snprintf.c	Wed Dec 31 19:00:00 1969
--- bash-2.05a/lib/sh/snprintf.c	Wed Nov  7 16:00:04 2001
***************
*** 0 ****
--- 1,1665 ----
+ /*
+  build a test version with
+    gcc -g -DDRIVER -I../.. -I../../include -o test-snprintf snprintf.c fmtu*long.o
+ */
+  
+ /*
+    Unix snprintf implementation.
+    derived from inetutils/libinetutils/snprintf.c Version 1.1
+ 
+    Copyright (C) 2001 Free Software Foundation, Inc.
+ 
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+    
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General License for more details.
+    
+    You should have received a copy of the GNU General License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+    
+    Revision History:
+ 
+    1.1:
+       *  added changes from Miles Bader
+       *  corrected a bug with %f
+       *  added support for %#g
+       *  added more comments :-)
+    1.0:
+       *  supporting must ANSI syntaxic_sugars
+    0.0:
+       *  support %s %c %d
+ 
+  THANKS(for the patches and ideas):
+      Miles Bader
+      Cyrille Rustom
+      Jacek Slabocewiz
+      Mike Parker(mouse)
+ 
+ */
+ 
+ /*
+  * Currently doesn't handle (and bash/readline doesn't use):
+  *	*M$ width, precision specifications
+  *	%N$ numbered argument conversions
+  *	inf, nan floating values (could use isinf(), isnan())
+  *	`,', `'' flags 
+  *	`C', `S' conversions
+  *	support for `F' is imperfect, since underlying printf may not handle it
+  */
+ 
+ #define FLOATING_POINT
+ 
+ #ifdef HAVE_CONFIG_H
+ #  include <config.h>
+ #endif
+ 
+ #if defined(DRIVER) && !defined(HAVE_CONFIG_H)
+ #define HAVE_LONG_LONG
+ #define HAVE_LONG_DOUBLE
+ #ifdef __linux__
+ #define HAVE_PRINTF_A_FORMAT
+ #endif
+ #define PREFER_STDARG
+ #define HAVE_STRINGIZE
+ #define HAVE_LIMITS_H
+ #define HAVE_STDDEF_H
+ #define intmax_t long
+ #endif
+ 
+ #if !defined (HAVE_SNPRINTF) || !defined (HAVE_ASPRINTF)
+ 
+ #include <bashtypes.h>
+ 
+ #if defined(PREFER_STDARG)
+ #  include <stdarg.h>
+ #else
+ #  include <varargs.h>
+ #endif
+ 
+ #ifdef HAVE_LIMITS_H
+ #  include <limits.h>
+ #endif
+ #include <bashansi.h>
+ #ifdef HAVE_STDDEF_H
+ #  include <stddef.h>
+ #endif
+ #include <chartypes.h>
+ 
+ #ifdef HAVE_STDINT_H
+ #  include <stdint.h>
+ #endif
+ 
+ #ifdef FLOATING_POINT
+ #  include <stdio.h>	/* for sprintf */
+ #endif
+ 
+ #include <typemax.h>
+ 
+ #include "stdc.h"
+ 
+ #ifndef DRIVER
+ #  include "shell.h"
+ #else
+ #  define FL_PREFIX     0x01    /* add 0x, 0X, or 0 prefix as appropriate */
+ #  define FL_ADDBASE    0x02    /* add base# prefix to converted value */
+ #  define FL_HEXUPPER   0x04    /* use uppercase when converting to hex */
+ #  define FL_UNSIGNED   0x08    /* don't add any sign */
+ extern char *fmtulong __P((unsigned long int, int, char *, size_t, int));
+ extern char *fmtullong __P((unsigned long long int, int, char *, size_t, int));
+ #endif
+ 
+ /* Bound on length of the string representing an integer value of type T.
+    Subtract one for the sign bit if T is signed;
+    302 / 1000 is log10 (2) rounded up;
+    add one for integer division truncation;
+    add one more for a minus sign if t is signed.  */
+ #define INT_STRLEN_BOUND(t) \
+   ((sizeof (t) * CHAR_BIT - TYPE_SIGNED (t)) * 302 / 1000 \
+      + 1 + TYPE_SIGNED (t))
+ 
+ /* conversion flags */
+ #define PF_ALTFORM	0x00001		/* # */
+ #define PF_HEXPREFIX	0x00002		/* 0[Xx] */
+ #define PF_LADJUST	0x00004		/* - */
+ #define PF_ZEROPAD	0x00008		/* 0 */
+ #define PF_PLUS		0x00010		/* + */
+ #define PF_SPACE	0x00020		/* ' ' */
+ #define PF_COMMA	0x00040		/* , */
+ 
+ #define PF_DOT		0x00080		/* `.precision' */
+ #define PF_STAR_P	0x00100		/* `*' after precision */
+ #define PF_STAR_W	0x00200		/* `*' before or without precision */
+ 
+ /* length modifiers */
+ #define PF_SIGNEDCHAR	0x00400		/* hh */
+ #define PF_SHORTINT	0x00800		/* h */
+ #define PF_LONGINT	0x01000		/* l */
+ #define PF_LONGLONG	0x02000		/* ll */
+ #define PF_LONGDBL	0x04000		/* L */
+ #define PF_INTMAX_T	0x08000		/* j */
+ #define PF_SIZE_T	0x10000		/* z */
+ #define PF_PTRDIFF_T	0x20000		/* t */
+ 
+ #define PF_ALLOCBUF	0x40000		/* for asprintf, vasprintf */
+ 
+ #define PFM_SN		0x01		/* snprintf, vsnprintf */
+ #define PFM_AS		0x02		/* asprintf, vasprintf */
+ 
+ #define ASBUFSIZE	128
+ 
+ #define x_digs	"0123456789abcdef"
+ #define X_digs	"0123456789ABCDEF"
+ 
+ static char intbuf[INT_STRLEN_BOUND(unsigned long) + 1];
+ 
+ /* 
+  * For the FLOATING POINT FORMAT :
+  *  the challenge was finding a way to
+  *  manipulate the Real numbers without having
+  *  to resort to mathematical function(it
+  *  would require to link with -lm) and not
+  *  going down to the bit pattern(not portable)
+  *
+  *  so a number, a real is:
+ 
+       real = integral + fraction
+ 
+       integral = ... + a(2)*10^2 + a(1)*10^1 + a(0)*10^0
+       fraction = b(1)*10^-1 + b(2)*10^-2 + ...
+ 
+       where:
+        0 <= a(i) => 9 
+        0 <= b(i) => 9 
+  
+     from then it was simple math
+  */
+ 
+ /*
+  * size of the buffer for the integral part
+  * and the fraction part 
+  */
+ #define MAX_INT  99 + 1 /* 1 for the null */
+ #define MAX_FRACT 307 + 1
+ 
+ /* 
+  * These functions use static buffers to store the results,
+  * and so are not reentrant
+  */
+ #define itoa(n) fmtulong(n, 10, intbuf, sizeof(intbuf), 0);
+ #define dtoa(n, p, f) numtoa(n, 10, p, f)
+ 
+ #define SWAP_INT(a,b) {int t; t = (a); (a) = (b); (b) = t;}
+ 
+ /* Macros that do proper sign extension and handle length modifiers.  Used
+    for the integer conversion specifiers. */
+ #define GETSIGNED(p) \
+   (((p)->flags & PF_LONGINT) \
+ 	? va_arg(args, long) \
+   	: (((p)->flags & PF_SHORTINT) ? (long)(short)va_arg(args, int) \
+ 				      : (long)va_arg(args, int)))
+ 
+ #define GETUNSIGNED(p) \
+   (((p)->flags & PF_LONGINT) \
+ 	? va_arg(args, unsigned long) \
+ 	: (((p)->flags & PF_SHORTINT) ? (unsigned long)(unsigned short)va_arg(args, int) \
+ 				      : (unsigned long)va_arg(args, unsigned int)))
+ 
+ 
+ #ifdef HAVE_LONG_DOUBLE
+ #define GETLDOUBLE(p) va_arg(args, long double)
+ #endif
+ #define GETDOUBLE(p) va_arg(args, double)
+ 
+ #define SET_SIZE_FLAGS(p, type) \
+   if (sizeof (type) > sizeof (int)) \
+     (p)->flags |= PF_LONGINT; \
+   if (sizeof (type) > sizeof (long)) \
+     (p)->flags |= PF_LONGLONG;
+ 
+ /* this struct holds everything we need */
+ struct DATA
+ {
+   int length;
+   char *base;		/* needed for [v]asprintf */
+   char *holder;
+   int counter;
+   const char *pf;
+ 
+ /* FLAGS */
+   int flags;
+   int justify;
+   int width, precision;
+   char pad;
+ };
+ 
+ /* the floating point stuff */
+ #ifdef FLOATING_POINT
+ static double pow_10 __P((int));
+ static int log_10 __P((double));
+ static double integral __P((double, double *));
+ static char *numtoa __P((double, int, int, char **));
+ #endif
+ 
+ static void init_data __P((struct DATA *, char *, size_t, const char *, int));
+ static void init_conv_flag __P((struct DATA *));
+ 
+ /* for the format */
+ #ifdef FLOATING_POINT
+ static void floating __P((struct DATA *, double));
+ static void exponent __P((struct DATA *, double));
+ #endif
+ static void number __P((struct DATA *, unsigned long, int));
+ #ifdef HAVE_LONG_LONG
+ static void lnumber __P((struct DATA *, unsigned long long, int));
+ #endif
+ static void pointer __P((struct DATA *, unsigned long));
+ static void strings __P((struct DATA *, char *));
+ 
+ #ifdef FLOATING_POINT
+ #  define FALLBACK_FMTSIZE	32
+ #  define FALLBACK_BASE		4096
+ #  define LFALLBACK_BASE	5120
+ #  ifdef HAVE_LONG_DOUBLE
+ static void ldfallback __P((struct DATA *, const char *, const char *, long double));
+ #  endif
+ static void dfallback __P((struct DATA *, const char *, const char *, double));
+ #endif
+ 
+ #ifdef DRIVER
+ static void memory_error_and_abort ();
+ static void *xmalloc __P((size_t));
+ static void *xrealloc __P((void *, size_t));
+ static void xfree __P((void *));
+ #else
+ #  include <xmalloc.h>
+ #endif
+ 
+ /* those are defines specific to snprintf to hopefully
+  * make the code clearer :-)
+  */
+ #define RIGHT 1
+ #define LEFT  0
+ #define NOT_FOUND -1
+ #define FOUND 1
+ #define MAX_FIELD 15
+ 
+ /* round off to the precision */
+ #define ROUND(d, p) \
+ 	    (d < 0.) ? \
+ 	     d - pow_10(-(p)->precision) * 0.5 : \
+ 	     d + pow_10(-(p)->precision) * 0.5
+ 
+ /* set default precision */
+ #define DEF_PREC(p) \
+ 	    if ((p)->precision == NOT_FOUND) \
+ 	      (p)->precision = 6
+ 
+ /* put a char.  increment the number of chars written even if we've exceeded
+    the vsnprintf/snprintf buffer size (for the return value) */
+ #define PUT_CHAR(c, p) \
+ 	do \
+ 	  { \
+ 	    if (((p)->flags & PF_ALLOCBUF) && ((p)->counter >= (p)->length - 1)) \
+ 	      { \
+ 		(p)->length += ASBUFSIZE; \
+ 		(p)->base = (char *)xrealloc((p)->base, (p)->length); \
+ 		(p)->holder = (p)->base + (p)->counter; /* in case reallocated */ \
+ 	      } \
+ 	    if ((p)->counter < (p)->length) \
+ 	      *(p)->holder++ = (c); \
+ 	    (p)->counter++; \
+ 	  } \
+ 	while (0)
+ 
+ #define PUT_PLUS(d, p, zero) \
+ 	    if ((d) > zero && (p)->justify == RIGHT) \
+ 	      PUT_CHAR('+', p)
+ 
+ #define PUT_SPACE(d, p, zero) \
+ 	    if (((p)->flags & PF_SPACE) && (d) > zero) \
+ 	      PUT_CHAR(' ', p)
+ 
+ /* pad right */ 
+ #define PAD_RIGHT(p) \
+ 	    if ((p)->width > 0 && (p)->justify != LEFT) \
+ 	      for (; (p)->width > 0; (p)->width--) \
+ 		 PUT_CHAR((p)->pad, p)
+ 
+ /* pad left */
+ #define PAD_LEFT(p) \
+ 	    if ((p)->width > 0 && (p)->justify == LEFT) \
+ 	      for (; (p)->width > 0; (p)->width--) \
+ 		 PUT_CHAR((p)->pad, p)
+ 
+ /* if width and prec. in the args */
+ #define STAR_ARGS(p) \
+ 	    if ((p)->flags & PF_STAR_W) \
+ 	      (p)->width = va_arg(args, int); \
+ 	    if ((p)->flags & PF_STAR_P) \
+ 	      (p)->precision = va_arg(args, int)
+ 
+ #ifdef FLOATING_POINT
+ /*
+  * Find the nth power of 10
+  */
+ static double
+ pow_10(n)
+      int n;
+ { 
+   double P;
+ 
+   /* handle common cases with fast switch statement. */
+   switch (n)
+     {
+     case -3:	return .001;
+     case -2:	return .01;
+     case -1:	return .1;
+     case 0:	return 1.;
+     case 1:	return 10.;
+     case 2:	return 100.;
+     case 3:	return 1000.;
+     }
+ 
+   if (n < 0)
+     {
+       P = .0001;
+       for (n += 4; n < 0; n++)
+ 	P /= 10.;
+     }
+   else
+     {
+       P = 10000.;
+       for (n -= 4; n > 0; n--)
+ 	P *= 10.;
+     }
+ 
+   return P;
+ }
+ 
+ /*
+  * Find the integral part of the log in base 10 
+  * Note: this not a real log10()
+ 	 I just need and approximation(integerpart) of x in:
+ 	  10^x ~= r
+  * log_10(200) = 2;
+  * log_10(250) = 2;
+  */
+ static int
+ log_10(r)
+      double r;
+ { 
+   int i = 0;
+   double result = 1.;
+ 
+   if (r < 0.)
+     r = -r;
+ 
+   if (r < 1.)
+     {
+       while (result >= r)
+ 	{
+ 	  result /= 10.;
+ 	  i++;
+ 	}
+       return (-i);
+     }
+   else
+     {
+       while (result <= r)
+ 	{
+ 	  result *= 10.;
+ 	  i++;
+ 	}
+       return (i - 1);
+     }
+ }
+ 
+ /*
+  * This function return the fraction part of a double
+  * and set in ip the integral part.
+  * In many ways it resemble the modf() found on most Un*x
+  */
+ static double
+ integral(real, ip)
+      double real;
+      double *ip;
+ { 
+   int j;
+   double i, s, p;
+   double real_integral = 0.;
+ 
+   /* take care of the obvious */
+   /* equal to zero ? */
+   if (real == 0.)
+     {
+       *ip = 0.;
+       return (0.);
+     }
+ 
+   /* negative number ? */
+   if (real < 0.)
+     real = -real;
+ 
+   /* a fraction ? */
+   if ( real < 1.)
+     {
+       *ip = 0.;
+       return real;
+     }
+ 
+   /* the real work :-) */
+   for (j = log_10(real); j >= 0; j--)
+     {
+       p = pow_10(j);
+       s = (real - real_integral)/p;
+       i = 0.;
+       while (i + 1. <= s)
+ 	i++;
+       real_integral += i*p;
+     }
+   *ip = real_integral;
+   return (real - real_integral);
+ }
+ 
+ #define PRECISION 1.e-6
+ /* 
+  * return an ascii representation of the integral part of the number
+  * and set fract to be an ascii representation of the fraction part
+  * the container for the fraction and the integral part or staticly
+  * declare with fix size 
+  */
+ static char *
+ numtoa(number, base, precision, fract)
+      double number;
+      int base, precision;
+      char **fract;
+ {
+   register int i, j;
+   double ip, fp; /* integer and fraction part */
+   double fraction;
+   int digits = MAX_INT - 1;
+   static char integral_part[MAX_INT];
+   static char fraction_part[MAX_FRACT];
+   double sign;
+   int ch;
+ 
+   /* taking care of the obvious case: 0.0 */
+   if (number == 0.)
+     { 
+       integral_part[0] = '0';
+       integral_part[1] = '\0';
+       fraction_part[0] = '0';
+       fraction_part[1] = '\0';
+       return integral_part;
+     }
+ 
+   /* for negative numbers */
+   if ((sign = number) < 0.)
+     {
+       number = -number;
+       digits--; /* sign consume one digit */
+     }
+ 
+   fraction = integral(number, &ip);
+   number = ip;
+ 
+   /* do the integral part */
+   if (ip == 0.)
+     {
+       integral_part[0] = '0';
+       i = 1;
+     }
+   else
+     {
+       for ( i = 0; i < digits && number != 0.; ++i)
+ 	{
+ 	  number /= base;
+ 	  fp = integral(number, &ip);
+ 	  ch = (int)((fp + PRECISION)*base); /* force to round */
+ 	  integral_part[i] = (ch <= 9) ? ch + '0' : ch + 'a' - 10;
+ 	  if (! ISXDIGIT((unsigned char)integral_part[i]))
+ 	    break;	/* bail out overflow !! */
+ 	  number = ip;
+ 	 }
+     }
+      
+   /* Oh No !! out of bound, ho well fill it up ! */
+   if (number != 0.)
+     for (i = 0; i < digits; ++i)
+       integral_part[i] = '9';
+ 
+   /* put the sign ? */
+   if (sign < 0.)
+     integral_part[i++] = '-';
+ 
+   integral_part[i] = '\0';
+ 
+   /* reverse every thing */
+   for ( i--, j = 0; j < i; j++, i--)
+     SWAP_INT(integral_part[i], integral_part[j]);  
+ 
+   /* the fractional part */
+   for (i=0, fp=fraction; precision > 0 && i < MAX_FRACT ; i++, precision--)
+     {
+       fraction_part[i] = (int)((fp + PRECISION)*10. + '0');
+       if (! DIGIT(fraction_part[i])) /* underflow ? */
+ 	break;
+       fp = (fp*10.0) - (double)(long)((fp + PRECISION)*10.);
+     }
+   fraction_part[i] = '\0';
+ 
+   if (fract != (char **)0)
+     *fract = fraction_part;
+ 
+   return integral_part;
+ }
+ #endif
+ 
+ /* for %d and friends, it puts in holder
+  * the representation with the right padding
+  */
+ static void
+ number(p, d, base)
+      struct DATA *p;
+      unsigned long d;
+      int base;
+ {
+   char *tmp;
+   long sd;
+   int flags;
+ 
+   sd = d;	/* signed for ' ' padding in base 10 */
+   flags = (*p->pf == 'u' || *p->pf == 'U') ? FL_UNSIGNED : 0;
+   if (*p->pf == 'X')
+     flags |= FL_HEXUPPER;
+ 
+   tmp = fmtulong (d, base, intbuf, sizeof(intbuf), flags);
+   p->width -= strlen(tmp);
+   PAD_RIGHT(p);
+ 
+   switch (base)
+     {
+     case 10:
+       PUT_PLUS(sd, p, 0);
+       PUT_SPACE(sd, p, 0);
+       break;
+     case 8:
+       if (p->flags & PF_ALTFORM)
+ 	PUT_CHAR('0', p);
+       break;
+     case 16:
+       if (p->flags & PF_ALTFORM)
+ 	{
+ 	  PUT_CHAR('0', p);
+ 	  PUT_CHAR(*p->pf, p);
+ 	}
+       break;
+     }
+ 
+   while (*tmp)
+     {
+       PUT_CHAR(*tmp, p);
+       tmp++;
+     }
+ 
+   PAD_LEFT(p);
+ }
+ 
+ #ifdef HAVE_LONG_LONG
+ /*
+  * identical to number() but works for `long long'
+  */
+ static void
+ lnumber(p, d, base)
+      struct DATA *p;
+      unsigned long long d;
+      int base;
+ {
+   char *tmp;
+   long long sd;
+   int flags;
+ 
+   sd = d;	/* signed for ' ' padding in base 10 */
+   flags = (*p->pf == 'u' || *p->pf == 'U') ? FL_UNSIGNED : 0;
+   if (*p->pf == 'X')
+     flags |= FL_HEXUPPER;
+ 
+   tmp = fmtullong (d, base, intbuf, sizeof(intbuf), flags);
+   p->width -= strlen(tmp);
+   PAD_RIGHT(p);
+ 
+   switch (base)
+     {
+     case 10:
+       PUT_PLUS(sd, p, 0);
+       PUT_SPACE(sd, p, 0);
+       break;
+     case 8:
+       if (p->flags & PF_ALTFORM)
+ 	PUT_CHAR('0', p);
+       break;
+     case 16:
+       if (p->flags & PF_ALTFORM)
+ 	{
+ 	  PUT_CHAR('0', p);
+ 	  PUT_CHAR(*p->pf, p);
+ 	}
+       break;
+     }
+ 
+   while (*tmp)
+     {
+       PUT_CHAR(*tmp, p);
+       tmp++;
+     }
+ 
+   PAD_LEFT(p);
+ }
+ #endif
+ 
+ static void
+ pointer(p, d)
+      struct DATA *p;
+      unsigned long d;
+ {
+   char *tmp;
+ 
+   tmp = fmtulong(d, 16, intbuf, sizeof(intbuf), 0);
+   p->width -= strlen(tmp);
+   PAD_RIGHT(p);
+ 
+   /* prefix '0x' for pointers */
+   PUT_CHAR('0', p);
+   PUT_CHAR('x', p);
+ 
+   while (*tmp)
+     {
+       PUT_CHAR(*tmp, p);
+       tmp++;
+     }
+   PAD_LEFT(p);
+ }
+ 
+ /* %s strings */
+ static void
+ strings(p, tmp)
+      struct DATA *p;
+      char *tmp;
+ {
+   int i;
+ 
+   i = strlen(tmp);
+   if (p->precision != NOT_FOUND) /* the smallest number */
+     i = (i < p->precision ? i : p->precision);
+   p->width -= i;
+   PAD_RIGHT(p);
+   while (i-- > 0)
+     { /* put the sting */
+       PUT_CHAR(*tmp, p);
+       tmp++;
+     }
+   PAD_LEFT(p);
+ }
+ 
+ #ifdef FLOATING_POINT
+ /* %f %F %g %G floating point representation */
+ static void
+ floating(p, d)
+      struct DATA *p;
+      double d;
+ {
+   char *tmp, *tmp2;
+   int i;
+ 
+   DEF_PREC(p);
+   d = ROUND(d, p);
+   tmp = dtoa(d, p->precision, &tmp2);
+   /* calculate the padding. 1 for the dot */
+   p->width = p->width -
+ 	    ((d > 0. && p->justify == RIGHT) ? 1:0) -
+ 	    ((p->flags & PF_SPACE) ? 1:0) -
+ 	    strlen(tmp) - p->precision - 1;
+   PAD_RIGHT(p);  
+   PUT_PLUS(d, p, 0.);
+   PUT_SPACE(d, p, 0.);
+   while (*tmp)
+     { /* the integral */
+       PUT_CHAR(*tmp, p);
+       tmp++;
+     }
+   if (p->precision != 0 || (p->flags & PF_ALTFORM))
+     PUT_CHAR('.', p);  /* put the '.' */
+   if ((*p->pf == 'g' || *p->pf == 'G') && (p->flags & PF_ALTFORM) == 0)
+     /* smash the trailing zeros unless altform */
+     for (i = strlen(tmp2) - 1; i >= 0 && tmp2[i] == '0'; i--)
+        tmp2[i] = '\0'; 
+   for (; *tmp2; tmp2++)
+     PUT_CHAR(*tmp2, p); /* the fraction */
+   
+   PAD_LEFT(p);
+ } 
+ 
+ /* %e %E %g %G exponent representation */
+ static void
+ exponent(p, d)
+      struct DATA *p;
+      double d;
+ {
+   char *tmp, *tmp2;
+   int j, i, nsig, ndig;
+ 
+   DEF_PREC(p);
+   j = log_10(d);
+   d = d / pow_10(j);  /* get the Mantissa */
+   d = ROUND(d, p);		  
+   tmp = dtoa(d, p->precision, &tmp2);
+   /* 1 for unit, 1 for the '.', 1 for 'e|E',
+    * 1 for '+|-', 2 for 'exp' */
+   /* calculate how much padding need */
+   p->width = p->width - 
+ 	     ((d > 0. && p->justify == RIGHT) ? 1:0) -
+ 	     ((p->flags & PF_SPACE) ? 1:0) - p->precision - 6;
+   PAD_RIGHT(p);
+   PUT_PLUS(d, p, 0.);
+   PUT_SPACE(d, p, 0.);
+   /*
+    * When supplied %g or %G, an optional precision is the number of
+    * significant digits to print.
+    *
+    * nsig = number of significant digits we've printed (leading zeros are
+    *	    never significant)
+    * ndig = if non-zero, max number of significant digits to print (only
+    *	    applicable to %g/%G)
+    */
+   nsig = ndig = 0;
+   if ((*p->pf == 'g' || *p->pf == 'G') && (p->flags & PF_DOT))
+     ndig = (p->precision == 0) ? 1 : p->precision;
+ 
+   while (*tmp)
+     {
+       PUT_CHAR(*tmp, p);
+       tmp++;
+       if (ndig && (++nsig >= ndig))
+ 	break;
+     }
+ 
+   if ((p->precision != 0 || (p->flags & PF_ALTFORM)) && (ndig == 0 || nsig < ndig))
+       PUT_CHAR('.', p);  /* the '.' */
+   if ((*p->pf == 'g' || *p->pf == 'G') && (p->flags & PF_ALTFORM) == 0)
+     /* smash the trailing zeros unless altform */
+     for (i = strlen(tmp2) - 1; i >= 0 && tmp2[i] == '0'; i--)
+        tmp2[i] = '\0'; 
+   for (; *tmp2; tmp2++)
+     {
+       if (ndig && (nsig++ >= ndig))
+ 	break;
+       PUT_CHAR(*tmp2, p); /* the fraction */
+     }
+ 
+   /* the exponent put the 'e|E' */
+   if (*p->pf == 'g' || *p->pf == 'e')
+     {
+       PUT_CHAR('e', p);
+     }
+   else
+      PUT_CHAR('E', p);
+ 
+   /* the sign of the exp */
+   if (j > 0)
+     {
+       PUT_CHAR('+', p);
+     }
+   else
+     {
+       PUT_CHAR('-', p);
+       j = -j;
+     }
+ 
+    tmp = itoa(j);
+    /* pad out to at least two spaces.  pad with `0' if the exponent is a
+       single digit. */
+    if (j <= 9)
+      {
+        PUT_CHAR('0', p);
+      }
+ 
+    /* the exponent */
+    while (*tmp)
+      {
+        PUT_CHAR(*tmp, p);
+        tmp++;
+      }
+    PAD_LEFT(p);
+ }
+ #endif
+ 
+ /* initialize the conversion specifiers */
+ static void
+ init_conv_flag (p)
+      struct DATA *p;
+ {
+   p->flags &= PF_ALLOCBUF;		/* preserve PF_ALLOCBUF flag */
+   p->precision = p->width = NOT_FOUND;
+   p->justify = NOT_FOUND;
+   p->pad = ' ';
+ }
+ 
+ static void
+ init_data (p, string, length, format, mode)
+      struct DATA *p;
+      char *string;
+      size_t length;
+      const char *format;
+      int mode;
+ {
+   p->length = length - 1; /* leave room for '\0' */
+   p->holder = p->base = string;
+   p->pf = format;
+   p->counter = 0;
+   p->flags = (mode == PFM_AS) ? PF_ALLOCBUF : 0;
+ }
+ 
+ static int
+ #if defined (__STDC__)
+ vsnprintf_internal(struct DATA *data, char *string, size_t length, const char *format, va_list args)
+ #else
+ vsnprintf_internal(data, string, length, format, args)
+      struct DATA *data;
+      char *string;
+      size_t length;
+      const char *format;
+      va_list args;
+ #endif
+ {
+   double d; /* temporary holder */
+ #ifdef HAVE_LONG_DOUBLE
+   long double ld;	/* for later */
+ #endif
+   unsigned long ul;
+ #ifdef HAVE_LONG_LONG
+   unsigned long long ull;
+ #endif
+   int state, i, c, n;
+   char *s;
+   const char *convstart;
+ 
+   /* Sanity check, the string must be > 1.  C99 actually says that LENGTH
+      can be zero here, in the case of snprintf/vsnprintf (it's never 0 in
+      the case of asprintf/vasprintf), and the return value is the number
+      of characters that would have been written. */
+   if (length < 1)
+     return -1;
+ 
+   if (format == 0)
+     return 0;
+ 
+   for (; c = *(data->pf); data->pf++)
+     {
+       if (c != '%')
+ 	{
+ 	  PUT_CHAR (c, data);
+ 	  continue;
+ 	}
+ 
+       convstart = data->pf;
+       init_conv_flag (data); /* initialise format flags */
+ 
+       state = 1;
+       for (state = 1; state && *data->pf; )
+ 	{
+ 	  c = *(++data->pf);
+ 	      /* fmtend = data->pf */
+ #if defined (FLOATING_POINT) && defined (HAVE_LONG_DOUBLE)
+ 	  if (data->flags & PF_LONGDBL)
+ 	    {
+ 	      switch (c)
+ 		{
+ 		case 'f': case 'F':
+ 		case 'e': case 'E':
+ 		case 'g': case 'G':
+ #  ifdef HAVE_PRINTF_A_FORMAT
+ 		case 'a': case 'A':
+ #  endif
+ 		  STAR_ARGS (data);
+ 		  ld = GETLDOUBLE (data);
+ 		  ldfallback (data, convstart, data->pf, ld);
+ 		  goto conv_break;
+ 		}
+ 	    }
+ #endif /* FLOATING_POINT && HAVE_LONG_DOUBLE */
+ 
+ 	  switch (c)
+ 	    {
+ 	      /* Parse format flags */
+ 	      case '\0': /* a NULL here ? ? bail out */
+ 		*data->holder = '\0';
+ 		return data->counter;
+ 		break;
+ 	      case '#':
+ 		data->flags |= PF_ALTFORM;
+ 		continue;
+ 	      case '0':
+ 		data->flags |= PF_ZEROPAD;
+ 		data->pad = '0';
+ 		continue;
+ 	      case '*':
+ 		if (data->flags & PF_DOT)
+ 		  data->flags |= PF_STAR_P;
+ 		else
+ 		  data->flags |= PF_STAR_W;
+ 		continue;
+ 	      case '-':
+ 		data->flags |= PF_LADJUST;
+ 		data->justify = LEFT;
+ 		continue;
+ 	      case ' ':
+ 		if ((data->flags & PF_PLUS) == 0)
+ 		  data->flags |= PF_SPACE;
+ 		continue;
+ 	      case '+':
+ 		data->flags |= PF_PLUS;
+ 		data->justify = RIGHT;
+ 		continue;
+ 	      case ',':
+ 		data->flags |= PF_COMMA;		/* not implemented yet */
+ 		continue;
+ 
+ 	      case '1': case '2': case '3':
+ 	      case '4': case '5': case '6':
+ 	      case '7': case '8': case '9':
+ 		n = 0;
+ 		do
+ 		  {
+ 		    n = n * 10 + TODIGIT(c);
+ 		    c = *(++data->pf);
+ 		  }
+ 		while (DIGIT(c));
+ 		data->pf--;		/* went too far */
+ 		if (n < 0)
+ 		  n = 0;
+ 		if (data->flags & PF_DOT)
+ 		  data->precision = n;
+ 		else
+ 		  data->width = n;
+ 		continue;
+ 
+ 	      /* optional precision */
+ 	      case '.':
+ 		data->flags |= PF_DOT;
+ 		data->precision = 0;
+ 		continue;
+ 
+ 	      /* length modifiers */
+ 	      case 'h':
+ 		data->flags |= (data->flags & PF_SHORTINT) ? PF_SIGNEDCHAR : PF_SHORTINT;
+ 		continue;
+ 	      case 'l':
+ 		data->flags |= (data->flags & PF_LONGINT) ? PF_LONGLONG : PF_LONGINT;
+ 		continue;
+ 	      case 'L':
+ 		data->flags |= PF_LONGDBL;
+ 		continue;
+ 	      case 'q':
+ 		data->flags |= PF_LONGLONG;
+ 		continue;
+ 	      case 'j':
+ 		data->flags |= PF_INTMAX_T;
+ 		SET_SIZE_FLAGS(data, intmax_t);
+ 		continue;
+ 	      case 'z':
+ 		data->flags |= PF_SIZE_T;
+ 		SET_SIZE_FLAGS(data, size_t);
+ 		continue;
+ 	      case 't':
+ 		data->flags |= PF_PTRDIFF_T;
+ 		SET_SIZE_FLAGS(data, ptrdiff_t);
+ 		continue;
+ 		
+ 	      /* Conversion specifiers */
+ #ifdef FLOATING_POINT
+ 	      case 'f':  /* float, double */
+ 	      case 'F':
+ 		STAR_ARGS(data);
+ 		d = GETDOUBLE(data);
+ 		floating(data, d);
+ conv_break:		
+ 		state = 0;
+ 		break;
+ 	      case 'g': 
+ 	      case 'G':
+ 		STAR_ARGS(data);
+ 		DEF_PREC(data);
+ 		d = GETDOUBLE(data);
+ 		i = log_10(d);
+ 		/*
+ 		 * for '%g|%G' ANSI: use f if exponent
+ 		 * is in the range or [-4,p] exclusively
+ 		 * else use %e|%E
+ 		 */
+ 		if (-4 < i && i < data->precision)
+ 		  floating(data, d);
+ 		else
+ 		  exponent(data, d);
+ 		state = 0;
+ 		break;
+ 	      case 'e':
+ 	      case 'E':  /* Exponent double */
+ 		STAR_ARGS(data);
+ 		d = GETDOUBLE(data);
+ 		exponent(data, d);
+ 		state = 0;
+ 		break;
+ #  ifdef HAVE_PRINTF_A_FORMAT
+ 	      case 'a':
+ 	      case 'A':
+ 		STAR_ARGS(data);
+ 		d = GETDOUBLE(data);
+ 		dfallback(data, convstart, data->pf, d);
+ 		state = 0;
+ 		break;
+ #  endif /* HAVE_PRINTF_A_FORMAT */
+ #endif /* FLOATING_POINT */
+ 	      case 'U':
+ 		data->flags |= PF_LONGINT;
+ 		/* FALLTHROUGH */
+ 	      case 'u':
+ 		STAR_ARGS(data);
+ #ifdef HAVE_LONG_LONG
+ 		if (data->flags & PF_LONGLONG)
+ 		  {
+ 		    ull = va_arg(args, unsigned long long);
+ 		    lnumber(data, ull, 10);
+ 		  }
+ 		else
+ #endif
+ 		  {
+ 		    ul = GETUNSIGNED(data);
+ 		    number(data, ul, 10);
+ 		  }
+ 		state = 0;
+ 		break;
+ 	      case 'D':
+ 		data->flags |= PF_LONGINT;
+ 		/* FALLTHROUGH */
+ 	      case 'd':  /* decimal */
+ 	      case 'i':
+ 		STAR_ARGS(data);
+ #ifdef HAVE_LONG_LONG
+ 		if (data->flags & PF_LONGLONG)
+ 		  {
+ 		    ull = va_arg(args, long long);
+ 		    lnumber(data, ull, 10);
+ 		  }
+ 		else
+ #endif
+ 		  {
+ 		    ul = GETSIGNED(data);
+ 		    number(data, ul, 10);
+ 		  }
+ 		state = 0;
+ 		break;
+ 	      case 'o':  /* octal */
+ 		STAR_ARGS(data);
+ #ifdef HAVE_LONG_LONG
+ 		if (data->flags & PF_LONGLONG)
+ 		  {
+ 		    ull = va_arg(args, unsigned long long);
+ 		    lnumber(data, ull, 8);
+ 		  }
+ 		else
+ #endif
+ 		  {
+ 		    ul = GETUNSIGNED(data);
+ 		    number(data, ul, 8);
+ 		  }
+ 		state = 0;
+ 		break;
+ 	      case 'x': 
+ 	      case 'X':  /* hexadecimal */
+ 		STAR_ARGS(data);
+ #ifdef HAVE_LONG_LONG
+ 		if (data->flags & PF_LONGLONG)
+ 		  {
+ 		    ull = va_arg(args, unsigned long long);
+ 		    lnumber(data, ull, 16);
+ 		  }
+ 		else
+ #endif
+ 		  {
+ 		    ul = GETUNSIGNED(data);
+ 		    number(data, ul, 16);
+ 		  }
+ 		state = 0;
+ 		break;
+ 	      case 'p':
+ 		STAR_ARGS(data);
+ 		ul = (unsigned long)va_arg(args, void *);
+ 		pointer(data, ul);
+ 		state = 0;
+ 		break;
+ 	      case 'c': /* character */
+ 		ul = va_arg(args, int);
+ 		PUT_CHAR(ul, data);
+ 		state = 0;
+ 		break;
+ 	      case 's':  /* string */
+ 		STAR_ARGS(data);
+ 		s = va_arg(args, char *);
+ 		strings(data, s);
+ 		state = 0;
+ 		break;
+ 	      case 'n':
+ #ifdef HAVE_LONG_LONG
+ 		if (data->flags & PF_LONGLONG)
+ 		  *(va_arg(args, long long *)) = data->counter;
+ 		else
+ #endif
+ 		if (data->flags & PF_LONGINT)
+ 		  *(va_arg(args, long *)) = data->counter;
+ 		else if (data->flags & PF_SHORTINT)
+ 		  *(va_arg(args, short *)) = data->counter;
+ 		else
+ 		  *(va_arg(args, int *)) = data->counter;
+ 		state = 0;
+ 		break;
+ 	      case '%':  /* nothing just % */
+ 		PUT_CHAR('%', data);
+ 		state = 0;
+ 		break;
+   	      default:
+ 		/* is this an error ? maybe bail out */
+ 		state = 0;
+ 		break;
+ 	} /* end switch */
+       } /* end of `%' for loop */
+     } /* end of format string for loop */
+ 
+   if (data->length >= 0)
+     *data->holder = '\0'; /* the end ye ! */
+ 
+   return data->counter;
+ }
+ 
+ #if defined (FLOATING_POINT) && defined (HAVE_LONG_DOUBLE)
+ /*
+  * Printing floating point numbers accurately is an art.  I'm not good
+  * at it.  Fall back to sprintf for long double formats.
+  */
+ static void
+ ldfallback (data, fs, fe, ld)
+      struct DATA *data;
+      const char *fs, *fe;
+      long double ld;
+ {
+   register char *x;
+   char fmtbuf[FALLBACK_FMTSIZE], *obuf;
+   int fl;
+ 
+   obuf = xmalloc(LFALLBACK_BASE + (data->precision < 6 ? 6 : data->precision) + 2);
+   fl = fe - fs + 1;
+   strncpy (fmtbuf, fs, fl);
+   fmtbuf[fl] = '\0';
+   sprintf (obuf, fmtbuf, ld);
+   for (x = obuf; *x; x++)
+     PUT_CHAR (*x, data);    
+   xfree (obuf);
+ }
+ #endif /* FLOATING_POINT && HAVE_LONG_DOUBLE */
+ 
+ #ifdef FLOATING_POINT
+ /* Used for %a, %A if the libc printf supports them. */
+ static void
+ dfallback (data, fs, fe, d)
+      struct DATA *data;
+      const char *fs, *fe;
+      double d;
+ {
+   register char *x;
+   char fmtbuf[FALLBACK_FMTSIZE], obuf[FALLBACK_BASE];
+   int fl;
+ 
+   fl = fe - fs + 1;
+   strncpy (fmtbuf, fs, fl);
+   fmtbuf[fl] = '\0';
+   sprintf (obuf, fmtbuf, d);
+   for (x = obuf; *x; x++)
+     PUT_CHAR (*x, data);    
+ }
+ #endif /* FLOATING_POINT */
+ 
+ #ifndef HAVE_SNPRINTF
+ 
+ int
+ #if defined (__STDC__)
+ vsnprintf(char *string, size_t length, const char *format, va_list args)
+ #else
+ vsnprintf(string, length, format, args)
+      char *string;
+      size_t length;
+      const char *format;
+      va_list args;
+ #endif
+ {
+   struct DATA data;
+ 
+   init_data (&data, string, length, format, PFM_SN);
+   return (vsnprintf_internal(&data, string, length, format, args));
+ }
+ 
+ int
+ #if defined(PREFER_STDARG)
+ snprintf(char *string, size_t length, const char * format, ...)
+ #else
+ snprintf(string, length, format, va_alist)
+      char *string;
+      size_t length;
+      const char *format;
+      va_dcl
+ #endif
+ {
+   struct DATA data;
+   int rval;
+   va_list args;
+ 
+ #if defined(PREFER_STDARG)
+   va_start(args, format);
+ #else
+   va_start(args);
+ #endif
+ 
+   init_data (&data, string, length, format, PFM_SN);
+   rval = vsnprintf_internal (&data, string, length, format, args);
+ 
+   va_end(args);
+ 
+   return rval;
+ }
+ 
+ #endif /* HAVE_SNPRINTF */
+ 
+ #ifndef HAVE_ASPRINTF
+ 
+ int
+ #if defined (__STDC__)
+ vasprintf(char **stringp, const char *format, va_list args)
+ #else
+ vasprintf(stringp, format, args)
+      char **stringp;
+      const char *format;
+      va_list args;
+ #endif
+ {
+   struct DATA data;
+   char *string;
+   int r;
+ 
+   string = (char *)xmalloc(ASBUFSIZE);
+   init_data (&data, string, ASBUFSIZE, format, PFM_AS);
+   r = vsnprintf_internal(&data, string, ASBUFSIZE, format, args);
+   *stringp = data.base;		/* not string in case reallocated */
+   return r;
+ }
+ 
+ int
+ #if defined(PREFER_STDARG)
+ asprintf(char **stringp, const char * format, ...)
+ #else
+ asprintf(stringp, format, va_alist)
+      char **stringp;
+      const char *format;
+      va_dcl
+ #endif
+ {
+   int rval;
+   va_list args;
+ 
+ #if defined(PREFER_STDARG)
+   va_start(args, format);
+ #else
+   va_start(args);
+ #endif
+ 
+   rval = vasprintf (stringp, format, args);
+ 
+   va_end(args);
+ 
+   return rval;
+ }
+ 
+ #endif
+ 
+ #endif
+ 
+ #ifdef DRIVER
+ 
+ static void
+ memory_error_and_abort ()
+ {
+   write (2, "out of virtual memory\n", 22);
+   abort ();
+ }
+ 
+ static void *
+ xmalloc(bytes)
+      size_t bytes;
+ {
+   void *ret;
+ 
+   ret = malloc(bytes);
+   if (ret == 0)
+     memory_error_and_abort ();
+   return ret;
+ }
+ 
+ static void *
+ xrealloc (pointer, bytes)
+      void *pointer;
+      size_t bytes;
+ {
+   void *ret;
+ 
+   ret = pointer ? realloc(pointer, bytes) : malloc(bytes);
+   if (ret == 0)
+     memory_error_and_abort ();
+   return ret;
+ }
+ 
+ static void
+ xfree(x)
+      void *x;
+ {
+   if (x)
+     free (x);
+ }
+ 
+ #ifdef FLOATING_POINT
+ #  include <float.h>
+ #endif
+ 
+ /* set of small tests for snprintf() */
+ main()
+ {
+   char holder[100];
+   char *h;
+   int i, si, ai;
+ 
+ /*
+   printf("Suite of test for snprintf:\n");
+   printf("a_format\n");
+   printf("printf() format\n");
+   printf("snprintf() format\n\n");
+ */
+ /* Checking the field widths */
+ 
+   printf("/%%ld %%ld/, 336, 336\n");
+   snprintf(holder, sizeof holder, "/%ld %ld/\n", 336, 336);
+   asprintf(&h, "/%ld %ld/\n", 336, 336);
+   printf("/%ld %ld/\n", 336, 336);
+   printf("%s", holder);
+   printf("%s\n", h);
+ 
+   printf("/%%d/, 336\n");
+   snprintf(holder, sizeof holder, "/%d/\n", 336);
+   asprintf(&h, "/%d/\n", 336);
+   printf("/%d/\n", 336);
+   printf("%s", holder);
+   printf("%s\n", h);
+ 
+   printf("/%%2d/, 336\n");
+   snprintf(holder, sizeof holder, "/%2d/\n", 336);
+   asprintf(&h, "/%2d/\n", 336);
+   printf("/%2d/\n", 336);
+   printf("%s", holder);
+   printf("%s\n", h);
+ 
+   printf("/%%10d/, 336\n");
+   snprintf(holder, sizeof holder, "/%10d/\n", 336);
+   asprintf(&h, "/%10d/\n", 336);
+   printf("/%10d/\n", 336);
+   printf("%s", holder);
+   printf("%s\n", h);
+ 
+   printf("/%%-10d/, 336\n");
+   snprintf(holder, sizeof holder, "/%-10d/\n", 336);
+   asprintf(&h, "/%-10d/\n", 336);
+   printf("/%-10d/\n", 336);
+   printf("%s", holder);
+   printf("%s\n", h);
+ 
+ 
+ /* floating points */
+ 
+   printf("/%%f/, 1234.56\n");
+   snprintf(holder, sizeof holder, "/%f/\n", 1234.56);
+   asprintf(&h, "/%f/\n", 1234.56);
+   printf("/%f/\n", 1234.56);
+   printf("%s", holder);
+   printf("%s\n", h);
+ 
+   printf("/%%e/, 1234.56\n");
+   snprintf(holder, sizeof holder, "/%e/\n", 1234.56);
+   asprintf(&h, "/%e/\n", 1234.56);
+   printf("/%e/\n", 1234.56);
+   printf("%s", holder);
+   printf("%s\n", h);
+ 
+   printf("/%%4.2f/, 1234.56\n");
+   snprintf(holder, sizeof holder, "/%4.2f/\n", 1234.56);
+   asprintf(&h, "/%4.2f/\n", 1234.56);
+   printf("/%4.2f/\n", 1234.56);
+   printf("%s", holder);
+   printf("%s\n", h);
+ 
+   printf("/%%3.1f/, 1234.56\n");
+   snprintf(holder, sizeof holder, "/%3.1f/\n", 1234.56);
+   asprintf(&h, "/%3.1f/\n", 1234.56);
+   printf("/%3.1f/\n", 1234.56);
+   printf("%s", holder);
+   printf("%s\n", h);
+ 
+   printf("/%%10.3f/, 1234.56\n");
+   snprintf(holder, sizeof holder, "/%10.3f/\n", 1234.56);
+   asprintf(&h, "/%10.3f/\n", 1234.56);
+   printf("/%10.3f/\n", 1234.56);
+   printf("%s", holder);
+   printf("%s\n", h);
+ 
+   printf("/%%10.3e/, 1234.56\n");
+   snprintf(holder, sizeof holder, "/%10.3e/\n", 1234.56);
+   asprintf(&h, "/%10.3e/\n", 1234.56);
+   printf("/%10.3e/\n", 1234.56);
+   printf("%s", holder);
+   printf("%s\n", h);
+ 
+   printf("/%%+4.2f/, 1234.56\n");
+   snprintf(holder, sizeof holder, "/%+4.2f/\n", 1234.56);
+   asprintf(&h, "/%+4.2f/\n", 1234.56);
+   printf("/%+4.2f/\n", 1234.56);
+   printf("%s", holder);
+   printf("%s\n", h);
+ 
+   printf("/%%010.2f/, 1234.56\n");
+   snprintf(holder, sizeof holder, "/%010.2f/\n", 1234.56);
+   asprintf(&h, "/%010.2f/\n", 1234.56);
+   printf("/%010.2f/\n", 1234.56);
+   printf("%s", holder);
+   printf("%s\n", h);
+ 
+ #define BLURB "Outstanding acting !"
+ /* strings precisions */
+ 
+   printf("/%%2s/, \"%s\"\n", BLURB);
+   snprintf(holder, sizeof holder, "/%2s/\n", BLURB);
+   asprintf(&h, "/%2s/\n", BLURB);
+   printf("/%2s/\n", BLURB);
+   printf("%s", holder);
+   printf("%s\n", h);
+ 
+   printf("/%%22s/ %s\n", BLURB);
+   snprintf(holder, sizeof holder, "/%22s/\n", BLURB);
+   asprintf(&h, "/%22s/\n", BLURB);
+   printf("/%22s/\n", BLURB);
+   printf("%s", holder);
+   printf("%s\n", h);
+ 
+   printf("/%%22.5s/ %s\n", BLURB);
+   snprintf(holder, sizeof holder, "/%22.5s/\n", BLURB);
+   asprintf(&h, "/%22.5s/\n", BLURB);
+   printf("/%22.5s/\n", BLURB);
+   printf("%s", holder);
+   printf("%s\n", h);
+ 
+   printf("/%%-22.5s/ %s\n", BLURB);
+   snprintf(holder, sizeof holder, "/%-22.5s/\n", BLURB);
+   asprintf(&h, "/%-22.5s/\n", BLURB);
+   printf("/%-22.5s/\n", BLURB);
+   printf("%s", holder);
+   printf("%s\n", h);
+ 
+ /* see some flags */
+ 
+   printf("%%x %%X %%#x, 31, 31, 31\n");
+   snprintf(holder, sizeof holder, "%x %X %#x\n", 31, 31, 31);
+   asprintf(&h, "%x %X %#x\n", 31, 31, 31);
+   printf("%x %X %#x\n", 31, 31, 31);
+   printf("%s", holder);
+   printf("%s\n", h);
+ 
+   printf("**%%d**%% d**%% d**, 42, 42, -42\n");
+   snprintf(holder, sizeof holder, "**%d**% d**% d**\n", 42, 42, -42);
+   asprintf(&h, "**%d**% d**% d**\n", 42, 42, -42);
+   printf("**%d**% d**% d**\n", 42, 42, -42);
+   printf("%s", holder);
+   printf("%s\n", h);
+ 
+ /* other flags */
+ 
+   printf("/%%g/, 31.4\n");
+   snprintf(holder, sizeof holder, "/%g/\n", 31.4);
+   asprintf(&h, "/%g/\n", 31.4);
+   printf("/%g/\n", 31.4);
+   printf("%s", holder);
+   printf("%s\n", h);
+ 
+   printf("/%%.6g/, 31.4\n");
+   snprintf(holder, sizeof holder, "/%.6g/\n", 31.4);
+   asprintf(&h, "/%.6g/\n", 31.4);
+   printf("/%.6g/\n", 31.4);
+   printf("%s", holder);
+   printf("%s\n", h);
+ 
+   printf("/%%.1G/, 31.4\n");
+   snprintf(holder, sizeof holder, "/%.1G/\n", 31.4);
+   asprintf(&h, "/%.1G/\n", 31.4);
+   printf("/%.1G/\n", 31.4);
+   printf("%s", holder);
+   printf("%s\n", h);
+ 
+   printf("/%%.1G/, 3100000000.4\n");
+   snprintf(holder, sizeof holder, "/%.1G/\n", 3100000000.4);  
+   asprintf(&h, "/%.1G/\n", 3100000000.4);  
+   printf("/%.1G/\n", 3100000000.4); 
+   printf("%s", holder);
+   printf("%s\n", h);
+ 
+   printf("abc%%n\n");
+   printf("abc%n", &i); printf("%d\n", i);
+   snprintf(holder, sizeof holder, "abc%n", &i);
+   printf("%s", holder); printf("%d\n\n", i);
+   asprintf(&h, "abc%n", &i);
+   printf("%s", h); printf("%d\n\n", i);
+   
+   printf("%%*.*s --> 10.10\n");
+   snprintf(holder, sizeof holder, "%*.*s\n", 10, 10, BLURB);
+   asprintf(&h, "%*.*s\n", 10, 10, BLURB);
+   printf("%*.*s\n", 10, 10, BLURB);
+   printf("%s", holder);
+   printf("%s\n", h);
+ 
+   printf("%%%%%%%%\n");
+   snprintf(holder, sizeof holder, "%%%%\n");
+   asprintf(&h, "%%%%\n");
+   printf("%%%%\n");
+   printf("%s", holder);
+   printf("%s\n", h);
+ 
+ #define BIG "Hello this is a too big string for the buffer"
+ /*  printf("A buffer to small of 10, trying to put this:\n");*/
+   printf("<%%>, %s\n", BIG); 
+   i = snprintf(holder, 10, "%s\n", BIG);
+   i = asprintf(&h, "%s", BIG);
+   printf("<%s>\n", BIG);
+   printf("<%s>\n", holder);
+   printf("<%s>\n\n", h);
+ 
+   printf ("<%%p> vsnprintf\n");
+   i = snprintf(holder, 100, "%p", vsnprintf);
+   i = asprintf(&h, "%p", vsnprintf);
+   printf("<%p>\n", vsnprintf);
+   printf("<%s>\n", holder);  
+   printf("<%s>\n\n", h);
+ 
+   printf ("<%%lu> LONG_MAX+1\n");
+   i = snprintf(holder, 100, "%lu", (unsigned long)(LONG_MAX)+1);
+   i = asprintf(&h, "%lu", (unsigned long)(LONG_MAX)+1);
+   printf("<%lu>\n", (unsigned long)(LONG_MAX)+1);
+   printf("<%s>\n", holder);
+   printf("<%s>\n\n", h);
+ 
+ #ifdef HAVE_LONG_LONG
+   printf ("<%%llu> LLONG_MAX+1\n");
+   i = snprintf(holder, 100, "%llu", (unsigned long long)(LLONG_MAX)+1);
+   i = asprintf(&h, "%llu", (unsigned long long)(LLONG_MAX)+1);
+   printf("<%llu>\n", (unsigned long long)(LLONG_MAX)+1);
+   printf("<%s>\n", holder);
+   printf("<%s>\n\n", h);
+ #endif
+ 
+ #ifdef HAVE_LONG_DOUBLE
+   printf ("<%%6.2LE> 42.42\n");
+   i = snprintf(holder, 100, "%6.2LE", (long double)42.42);
+   i = asprintf(&h, "%6.2LE", (long double)42.42);
+   printf ("<%6.2LE>\n", (long double)42.42);
+   printf ("<%s>\n", holder);
+   printf ("<%s>\n\n", h);
+ #endif
+ 
+ #ifdef HAVE_PRINTF_A_FORMAT
+   printf ("<%%6.2A> 42.42\n");
+   i = snprintf(holder, 100, "%6.2A", 42.42);
+   i = asprintf(&h, "%6.2A", 42.42);
+   printf ("<%6.2A>\n", 42.42);
+   printf ("<%s>\n", holder);
+   printf ("<%s>\n\n", h);
+ 
+   printf ("<%%6.2LA> 42.42\n");
+   i = snprintf(holder, 100, "%6.2LA", (long double)42.42);
+   i = asprintf(&h, "%6.2LA", (long double)42.42);
+   printf ("<%6.2LA>\n", (long double)42.42);
+   printf ("<%s>\n", holder);
+   printf ("<%s>\n\n", h);
+ #endif
+ 
+   printf ("<%%.10240f> DBL_MAX\n");
+   si = snprintf(holder, 100, "%.10240f", DBL_MAX);
+   ai = asprintf(&h, "%.10240f", DBL_MAX);
+   printf ("<%.10240f>\n", DBL_MAX);
+   printf ("<%d> <%s>\n", si, holder);
+   printf ("<%d> <%s>\n\n", ai, h);
+ 
+   printf ("<%%.10240Lf> LDBL_MAX\n");
+   si = snprintf(holder, 100, "%.10240Lf", (long double)LDBL_MAX);
+   ai = asprintf(&h, "%.10240Lf", (long double)LDBL_MAX);
+   printf ("<%.10240Lf>\n", (long double)LDBL_MAX);
+   printf ("<%d> <%s>\n", si, holder);
+   printf ("<%d> <%s>\n\n", ai, h);
+ 
+   exit (0);
+ }
+ #endif
diff -Nrc2 bash-2.05/lib/sh/strcasecmp.c bash-2.05a/lib/sh/strcasecmp.c
*** bash-2.05/lib/sh/strcasecmp.c	Wed Feb 14 17:03:19 2001
--- bash-2.05a/lib/sh/strcasecmp.c	Mon Oct 15 12:58:23 2001
***************
*** 25,33 ****
  #include <stdc.h>
  #include <bashansi.h>
! #include <ctype.h>
! 
! #if !defined (to_lower)
! #  define to_lower(c) (islower(c) ? (c) : tolower(c))
! #endif /* to_lower */
  
  /* Compare at most COUNT characters from string1 to string2.  Case
--- 25,29 ----
  #include <stdc.h>
  #include <bashansi.h>
! #include <chartypes.h>
  
  /* Compare at most COUNT characters from string1 to string2.  Case
***************
*** 50,54 ****
    do
      {
!       if ((r = to_lower (*s1) - to_lower (*s2)) != 0)
  	return r;
        if (*s1++ == '\0')
--- 46,50 ----
    do
      {
!       if ((r = TOLOWER ((unsigned char) *s1) - TOLOWER ((unsigned char) *s2)) != 0)
  	return r;
        if (*s1++ == '\0')
***************
*** 77,81 ****
      return (0);
  
!   while ((r = to_lower (*s1) - to_lower (*s2)) == 0)
      {
        if (*s1++ == '\0')
--- 73,77 ----
      return (0);
  
!   while ((r = TOLOWER ((unsigned char)*s1) - TOLOWER ((unsigned char)*s2)) == 0)
      {
        if (*s1++ == '\0')
diff -Nrc2 bash-2.05/lib/sh/strindex.c bash-2.05a/lib/sh/strindex.c
*** bash-2.05/lib/sh/strindex.c	Fri Oct 13 12:40:39 2000
--- bash-2.05a/lib/sh/strindex.c	Mon Oct 15 14:36:31 2001
***************
*** 23,36 ****
  #include <config.h>
  
! #include "bashansi.h"
! #include <ctype.h>
  
  #include <stdc.h>
  
- #ifndef to_upper
- #  define to_upper(c) (islower(c) ? toupper(c) : (c))
- #  define to_lower(c) (isupper(c) ? tolower(c) : (c))
- #endif
- 
  /* Determine if s2 occurs in s1.  If so, return a pointer to the
     match in s1.  The compare is case insensitive.  This is a
--- 23,31 ----
  #include <config.h>
  
! #include <bashansi.h>
! #include <chartypes.h>
  
  #include <stdc.h>
  
  /* Determine if s2 occurs in s1.  If so, return a pointer to the
     match in s1.  The compare is case insensitive.  This is a
***************
*** 43,51 ****
    register int i, l, len, c;
  
!   c = to_upper (s2[0]);
    len = strlen (s1);
    l = strlen (s2);
    for (i = 0; (len - i) >= l; i++)
!     if ((to_upper (s1[i]) == c) && (strncasecmp (s1 + i, s2, l) == 0))
        return ((char *)s1 + i);
    return ((char *)0);
--- 38,46 ----
    register int i, l, len, c;
  
!   c = TOLOWER ((unsigned char)s2[0]);
    len = strlen (s1);
    l = strlen (s2);
    for (i = 0; (len - i) >= l; i++)
!     if ((TOLOWER ((unsigned char)s1[i]) == c) && (strncasecmp (s1 + i, s2, l) == 0))
        return ((char *)s1 + i);
    return ((char *)0);
diff -Nrc2 bash-2.05/lib/sh/stringlist.c bash-2.05a/lib/sh/stringlist.c
*** bash-2.05/lib/sh/stringlist.c	Fri Sep 15 12:39:59 2000
--- bash-2.05a/lib/sh/stringlist.c	Mon Nov  5 13:25:19 2001
***************
*** 26,30 ****
  
  #include <stdio.h>
! #include "bashansi.h"
  
  #include "shell.h"
--- 26,30 ----
  
  #include <stdio.h>
! #include <bashansi.h>
  
  #include "shell.h"
***************
*** 68,71 ****
--- 68,74 ----
    register int i;
  
+   if (sl == 0)
+     return (sl = alloc_stringlist(n));
+ 
    if (n > sl->list_size)
      {
***************
*** 96,99 ****
--- 99,104 ----
    register int i;
  
+   if (sl == 0)
+     return ((STRINGLIST *)0);
    new = alloc_stringlist (sl->list_size);
    /* I'd like to use copy_array, but that doesn't copy everything. */
***************
*** 130,133 ****
--- 135,139 ----
    sl->list_len = n;
    sl->list[n] = (char *)NULL;
+   return (sl);
  }
  
***************
*** 140,147 ****
  
    if (m1 == 0)
!     {
!       m1 = copy_stringlist (m2);
!       return m1;
!     }
  
    len1 = m1->list_len;
--- 146,150 ----
  
    if (m1 == 0)
!     return (m2 ? copy_stringlist (m2) : (STRINGLIST *)0);
  
    len1 = m1->list_len;
***************
*** 181,185 ****
        llen = STRLEN (sl->list[i]);
        tlen = plen + llen + slen + 1;
!       t = xmalloc (tlen + 1);
        if (plen)
  	strcpy (t, prefix);
--- 184,188 ----
        llen = STRLEN (sl->list[i]);
        tlen = plen + llen + slen + 1;
!       t = (char *)xmalloc (tlen + 1);
        if (plen)
  	strcpy (t, prefix);
***************
*** 224,227 ****
--- 227,236 ----
    int slen, len;
  
+   if (list == 0)
+     {
+       if (ip)
+         *ip = 0;
+       return ((STRINGLIST *)0);
+     }
    slen = list_length (list);
    ret = (STRINGLIST *)xmalloc (sizeof (STRINGLIST));
diff -Nrc2 bash-2.05/lib/sh/stringvec.c bash-2.05a/lib/sh/stringvec.c
*** bash-2.05/lib/sh/stringvec.c	Fri Sep 15 12:43:45 2000
--- bash-2.05a/lib/sh/stringvec.c	Wed Sep 12 10:33:19 2001
***************
*** 19,25 ****
     Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. */
  
! #include "config.h"
  
! #include "bashtypes.h"
  
  #if defined (HAVE_UNISTD_H)
--- 19,25 ----
     Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. */
  
! #include <config.h>
  
! #include <bashtypes.h>
  
  #if defined (HAVE_UNISTD_H)
***************
*** 27,33 ****
  #endif
  
! #include "bashansi.h"
  #include <stdio.h>
! #include <ctype.h>
  
  #include "shell.h"
--- 27,33 ----
  #endif
  
! #include <bashansi.h>
  #include <stdio.h>
! #include <chartypes.h>
  
  #include "shell.h"
***************
*** 101,114 ****
    register int i;
    int len;
!   char **new_array;
  
    len = array_len (array);
  
!   new_array = (char **)xmalloc ((len + 1) * sizeof (char *));
    for (i = 0; array[i]; i++)
!     new_array[i] = savestring (array[i]);
!   new_array[i] = (char *)NULL;
  
!   return (new_array);
  }
  
--- 101,114 ----
    register int i;
    int len;
!   char **ret;
  
    len = array_len (array);
  
!   ret = (char **)xmalloc ((len + 1) * sizeof (char *));
    for (i = 0; array[i]; i++)
!     ret[i] = savestring (array[i]);
!   ret[i] = (char *)NULL;
  
!   return (ret);
  }
  
***************
*** 136,141 ****
       char **array;
  {
!   qsort (array, array_len (array), sizeof (char *),
! 	 (Function *)qsort_string_compare);
  }
- 
--- 136,139 ----
       char **array;
  {
!   qsort (array, array_len (array), sizeof (char *), (QSFUNC *)qsort_string_compare);
  }
diff -Nrc2 bash-2.05/lib/sh/strtod.c bash-2.05a/lib/sh/strtod.c
*** bash-2.05/lib/sh/strtod.c	Thu Oct  9 12:02:20 1997
--- bash-2.05a/lib/sh/strtod.c	Mon Oct 15 14:36:55 2001
***************
*** 26,30 ****
  #endif
  
! #include <ctype.h>
  #include <math.h>
  
--- 26,30 ----
  #endif
  
! #include <chartypes.h>
  #include <math.h>
  
***************
*** 74,78 ****
  
    /* Eat whitespace.  */
!   while (isspace (*s))
      ++s;
  
--- 74,78 ----
  
    /* Eat whitespace.  */
!   while (ISSPACE ((unsigned char)*s))
      ++s;
  
***************
*** 88,92 ****
    for (;; ++s)
      {
!       if (isdigit (*s))
  	{
  	  got_digit = 1;
--- 88,92 ----
    for (;; ++s)
      {
!       if (DIGIT (*s))
  	{
  	  got_digit = 1;
***************
*** 121,125 ****
      goto noconv;
  
!   if (tolower (*s) == 'e')
      {
        /* Get the exponent specified after the `e' or `E'.  */
--- 121,125 ----
      goto noconv;
  
!   if (TOLOWER ((unsigned char)*s) == 'e')
      {
        /* Get the exponent specified after the `e' or `E'.  */
diff -Nrc2 bash-2.05/lib/sh/strtoimax.c bash-2.05a/lib/sh/strtoimax.c
*** bash-2.05/lib/sh/strtoimax.c	Wed Dec 31 19:00:00 1969
--- bash-2.05a/lib/sh/strtoimax.c	Wed Nov  7 09:31:16 2001
***************
*** 0 ****
--- 1,102 ----
+ /* Convert string representation of a number into an intmax_t value.
+    Copyright 1999, 2001 Free Software Foundation, Inc.
+ 
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2, or (at your option)
+    any later version.
+ 
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+ 
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software Foundation,
+    Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+ 
+ /* Written by Paul Eggert.  Modified by Chet Ramey for Bash. */
+ 
+ #if HAVE_CONFIG_H
+ #  include <config.h>
+ #endif
+ 
+ #if HAVE_INTTYPES_H
+ #  include <inttypes.h>
+ #endif
+ 
+ #if HAVE_STDLIB_H
+ #  include <stdlib.h>
+ #endif
+ 
+ #include <stdc.h>
+ 
+ /* Verify a requirement at compile-time (unlike assert, which is runtime).  */
+ #define verify(name, assertion) struct name { char a[(assertion) ? 1 : -1]; }
+ 
+ #ifndef HAVE_DECL_STRTOL
+ "this configure-time declaration test was not run"
+ #endif
+ #if !HAVE_DECL_STRTOL
+ extern long strtol __P((const char *, char **, int));
+ #endif
+ 
+ #ifndef HAVE_DECL_STRTOLL
+ "this configure-time declaration test was not run"
+ #endif
+ #if !HAVE_DECL_STRTOLL && HAVE_LONG_LONG
+ extern long long strtoll __P((const char *, char **, int));
+ #endif
+ 
+ intmax_t
+ strtoimax (ptr, endptr, base)
+      const char *ptr;
+      char **endptr;
+      int base;
+ {
+ #if HAVE_LONG_LONG
+   verify(size_is_that_of_long_or_long_long,
+ 	 (sizeof (intmax_t) == sizeof (long) ||
+ 	  sizeof (intmax_t) == sizeof (long long)));
+ 
+   if (sizeof (intmax_t) != sizeof (long))
+     return (strtoll (ptr, endptr, base));
+ #else
+   verify (size_is_that_of_long, sizeof (intmax_t) == sizeof (long));
+ #endif
+ 
+   return (strtol (ptr, endptr, base));
+ }
+ 
+ #ifdef TESTING
+ # include <stdio.h>
+ int
+ main ()
+ {
+   char *p, *endptr;
+   intmax_t x;
+ #if HAVE_LONG_LONG
+   long long y;
+ #endif
+   long z;
+   
+   printf ("sizeof intmax_t: %d\n", sizeof (intmax_t));
+ 
+ #if HAVE_LONG_LONG
+   printf ("sizeof long long: %d\n", sizeof (long long));
+ #endif
+   printf ("sizeof long: %d\n", sizeof (long));
+ 
+   x = strtoimax("42", &endptr, 10);
+ #if HAVE_LONG_LONG
+   y = strtoll("42", &endptr, 10);
+ #else
+   y = -1;
+ #endif
+   z = strtol("42", &endptr, 10);
+ 
+   printf ("%lld %lld %ld\n", x, y, z);
+ 
+   exit (0);
+ }
+ #endif
diff -Nrc2 bash-2.05/lib/sh/strtol.c bash-2.05a/lib/sh/strtol.c
*** bash-2.05/lib/sh/strtol.c	Wed Feb 14 17:03:24 2001
--- bash-2.05a/lib/sh/strtol.c	Thu Nov  8 08:12:37 2001
***************
*** 1,18 ****
! /* strtol - Convert string representation of a number into an integer value.
!    Copyright (C) 1997 Free Software Foundation, Inc.
  
!    This program is free software; you can redistribute it and/or modify it
!    under the terms of the GNU General Public License as published by the
!    Free Software Foundation; either version 2, or (at your option) any
!    later version.
! 
!    This program is distributed in the hope that it will be useful,
     but WITHOUT ANY WARRANTY; without even the implied warranty of
!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!    GNU General Public License for more details.
  
!    You should have received a copy of the GNU General Public License
!    along with this program; if not, write to the Free Software Foundation,
!    Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
  
  #include <config.h>
--- 1,20 ----
! /* Convert string representation of a number into an integer value.
!    Copyright (C) 1991,92,94,95,96,97,98,99,2000,2001 Free Software Foundation, Inc.
!    This file is part of the GNU C Library.
! 
!    The GNU C Library is free software; you can redistribute it and/or
!    modify it under the terms of the GNU Lesser General Public
!    License as published by the Free Software Foundation; either
!    version 2.1 of the License, or (at your option) any later version.
  
!    The GNU C Library is distributed in the hope that it will be useful,
     but WITHOUT ANY WARRANTY; without even the implied warranty of
!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
!    Lesser General Public License for more details.
  
!    You should have received a copy of the GNU Lesser General Public
!    License along with the GNU C Library; if not, write to the Free
!    Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
!    02111-1307 USA.  */
  
  #include <config.h>
***************
*** 20,24 ****
  #if !defined (HAVE_STRTOL)
  
! #include <ctype.h>
  #include <errno.h>
  
--- 22,26 ----
  #if !defined (HAVE_STRTOL)
  
! #include <chartypes.h>
  #include <errno.h>
  
***************
*** 35,38 ****
--- 37,42 ----
  #endif
  
+ #include <typemax.h>
+ 
  #include <stdc.h>
  #include <bashansi.h>
***************
*** 42,70 ****
  #endif
  
! /* Nonzero if we are defining `strtoul', operating on unsigned integers.  */
  #ifndef UNSIGNED
! # define UNSIGNED 0
! # define RETTYPE long
  #else
! # define RETTYPE unsigned long
  #endif
  
- /* Determine the name.  */
  #if UNSIGNED
! #  define strtol strtoul
! #endif
! 
! #ifndef CHAR_BIT
! #  define CHAR_BIT 8
! #endif
! 
! #ifndef ULONG_MAX
! #  define ULONG_MAX ((unsigned long) ~(unsigned long) 0)
! #  define ULONG_MIN ((unsigned long) 0 - ULONG_MAX)
! #endif
! 
! #ifndef LONG_MAX
! #  define LONG_MAX ((long) (ULONG_MAX >> 1))
! #  define LONG_MIN ((long) (0 - LONG_MAX))
  #endif
  
--- 46,83 ----
  #endif
  
! /* Nonzero if we are defining `strtoul' or `strtoull', operating on
!    unsigned integers.  */
  #ifndef UNSIGNED
! #  define UNSIGNED 0
! #  define INT LONG int
  #else
! #  define INT unsigned LONG int
  #endif
  
  #if UNSIGNED
! #  ifdef QUAD
! #    define strtol strtoull
! #  else
! #    define strtol strtoul
! #  endif
! #else
! #  ifdef QUAD
! #    define strtol strtoll
! #  endif
! #endif
! 
! /* If QUAD is defined, we are defining `strtoll' or `strtoull',
!    operating on `long long ints.  */
! 
! #ifdef QUAD
! #  define LONG long long
! #  define STRTOL_LONG_MIN LLONG_MIN
! #  define STRTOL_LONG_MAX LLONG_MAX
! #  define STRTOL_ULONG_MAX ULLONG_MAX
! #else	/* !QUAD */
! #  define LONG long
! #  define STRTOL_LONG_MIN LONG_MIN
! #  define STRTOL_LONG_MAX LONG_MAX
! #  define STRTOL_ULONG_MAX ULONG_MAX
  #endif
  
***************
*** 72,80 ****
     If BASE is 0 the base is determined by the presence of a leading
     zero, indicating octal or a leading "0x" or "0X", indicating hexadecimal.
!    If BASE is < 2 or > 36, it is reset to 10.
     If ENDPTR is not NULL, a pointer to the character after the last
     one converted is stored in *ENDPTR.  */
  
! RETTYPE
  strtol (nptr, endptr, base)
       const char *nptr;
--- 85,93 ----
     If BASE is 0 the base is determined by the presence of a leading
     zero, indicating octal or a leading "0x" or "0X", indicating hexadecimal.
!    If BASE is < 2 or > 36, it is no longer reset to 10; EINVAL is returned.
     If ENDPTR is not NULL, a pointer to the character after the last
     one converted is stored in *ENDPTR.  */
  
! INT
  strtol (nptr, endptr, base)
       const char *nptr;
***************
*** 83,88 ****
  {
    int negative;
!   register unsigned long cutoff, i;
    register unsigned int cutlim;
    register const char *s;
    register unsigned char c;
--- 96,102 ----
  {
    int negative;
!   register unsigned LONG int cutoff;
    register unsigned int cutlim;
+   register unsigned LONG int i;
    register const char *s;
    register unsigned char c;
***************
*** 91,100 ****
  
    if (base < 0 || base == 1 || base > 36)
!     base = 10;
  
    save = s = nptr;
  
    /* Skip white space.  */
!   while (isspace (*s))
      ++s;
    if (*s == '\0')
--- 105,117 ----
  
    if (base < 0 || base == 1 || base > 36)
!     {
!       __set_errno (EINVAL);
!       return 0;
!     }
  
    save = s = nptr;
  
    /* Skip white space.  */
!   while (ISSPACE ((unsigned char)*s))
      ++s;
    if (*s == '\0')
***************
*** 110,130 ****
      negative = 0;
  
!   if (base == 16 && *s == '0' && toupper (s[1]) == 'X')
!     s += 2;
! 
!   /* If BASE is zero, figure it out ourselves.  */
!   if (base == 0)
!     if (*s == '0')
!       {
! 	if (toupper (s[1]) == 'X')
! 	  {
! 	    s += 2;
! 	    base = 16;
! 	  }
! 	else
! 	  base = 8;
!       }
!     else
!       base = 10;
  
    /* Save the pointer so we can check later if anything happened.  */
--- 127,143 ----
      negative = 0;
  
!   /* Recognize number prefix and if BASE is zero, figure it out ourselves.  */
!   if (*s == '0')
!     {
!       if ((base == 0 || base == 16) && TOUPPER ((unsigned char) s[1]) == 'X')
! 	{
! 	  s += 2;
! 	  base = 16;
! 	}
!       else if (base == 0)
! 	base = 8;
!     }
!   else if (base == 0)
!     base = 10;
  
    /* Save the pointer so we can check later if anything happened.  */
***************
*** 133,165 ****
    end = NULL;
  
!   cutoff = ULONG_MAX / (unsigned long int) base;
!   cutlim = ULONG_MAX % (unsigned long int) base;
  
    overflow = 0;
    i = 0;
!   for (c = *s; c != '\0'; c = *++s)
      {
!       if (s == end)
! 	break;
  
!       if (c >= '0' && c <= '9')
! 	c -= '0';
!       else if (isalpha (c))
! 	c = toupper (c) - 'A' + 10;
!       else
! 	break;
! 
!       if ((int) c >= base)
! 	break;
! 
!       /* Check for overflow.  */
!       if (i > cutoff || (i == cutoff && c > cutlim))
! 	overflow = 1;
!       else
  	{
! 	  i *= (unsigned long int) base;
! 	  i += c;
  	}
      }
  
    /* Check if anything actually happened.  */
--- 146,209 ----
    end = NULL;
  
!   cutoff = STRTOL_ULONG_MAX / (unsigned LONG int) base;
!   cutlim = STRTOL_ULONG_MAX % (unsigned LONG int) base;
  
    overflow = 0;
    i = 0;
!   c = *s;
!   if (sizeof (long int) != sizeof (LONG int))
      {
!       unsigned long int j = 0;
!       unsigned long int jmax = ULONG_MAX / base;
  
!       for (;c != '\0'; c = *++s)
  	{
! 	  if (s == end)
! 	    break;
! 	  if (DIGIT (c))
! 	    c -= '0';
! 	  else if (ISALPHA (c))
! 	    c = TOUPPER (c) - 'A' + 10;
! 	  else
! 	    break;
! 
! 	  if ((int) c >= base)
! 	    break;
! 	  /* Note that we never can have an overflow.  */
! 	  else if (j >= jmax)
! 	    {
! 	      /* We have an overflow.  Now use the long representation.  */
! 	      i = (unsigned LONG int) j;
! 	      goto use_long;
! 	    }
! 	  else
! 	    j = j * (unsigned long int) base + c;
  	}
+ 
+       i = (unsigned LONG int) j;
      }
+   else
+     for (;c != '\0'; c = *++s)
+       {
+ 	if (s == end)
+ 	  break;
+ 	if (DIGIT (c))
+ 	  c -= '0';
+ 	else if (ISALPHA (c))
+ 	  c = TOUPPER (c) - 'A' + 10;
+ 	else
+ 	  break;
+ 	if ((int) c >= base)
+ 	  break;
+ 	/* Check for overflow.  */
+ 	if (i > cutoff || (i == cutoff && c > cutlim))
+ 	  overflow = 1;
+ 	else
+ 	  {
+ 	  use_long:
+ 	    i *= (unsigned LONG int) base;
+ 	    i += c;
+ 	  }
+       }
  
    /* Check if anything actually happened.  */
***************
*** 174,182 ****
  #if !UNSIGNED
    /* Check for a value that is within the range of
!      `unsigned long int', but outside the range of `long int'.  */
    if (overflow == 0
        && i > (negative
! 	      ? -((unsigned long) (LONG_MIN + 1)) + 1
! 	      : (unsigned long) LONG_MAX))
      overflow = 1;
  #endif
--- 218,226 ----
  #if !UNSIGNED
    /* Check for a value that is within the range of
!      `unsigned LONG int', but outside the range of `LONG int'.  */
    if (overflow == 0
        && i > (negative
! 	      ? -((unsigned LONG int) (STRTOL_LONG_MIN + 1)) + 1
! 	      : (unsigned LONG int) STRTOL_LONG_MAX))
      overflow = 1;
  #endif
***************
*** 186,197 ****
        __set_errno (ERANGE);
  #if UNSIGNED
!       return ULONG_MAX;
  #else
!       return negative ? LONG_MIN : LONG_MAX;
  #endif
      }
  
!   /* Return the result with the appropriate sign.  */
!   return (negative ? -i : i);
  
  noconv:
--- 230,241 ----
        __set_errno (ERANGE);
  #if UNSIGNED
!       return STRTOL_ULONG_MAX;
  #else
!       return negative ? STRTOL_LONG_MIN : STRTOL_LONG_MAX;
  #endif
      }
  
!   /* Return the result of the appropriate sign.  */
!   return negative ? -i : i;
  
  noconv:
***************
*** 199,206 ****
       first two characters are '0' and 'x', but the rest are no
       hexadecimal digits.  This is no error case.  We return 0 and
!      ENDPTR points to the `x'.  */
    if (endptr != NULL)
      {
!       if (save - nptr >= 2 && toupper (save[-1]) == 'X' && save[-2] == '0')
  	*endptr = (char *) &save[-1];
        else
--- 243,250 ----
       first two characters are '0' and 'x', but the rest are no
       hexadecimal digits.  This is no error case.  We return 0 and
!      ENDPTR points to the `x`.  */
    if (endptr != NULL)
      {
!       if (save - nptr >= 2 && TOUPPER ((unsigned char) save[-1]) == 'X' && save[-2] == '0')
  	*endptr = (char *) &save[-1];
        else
diff -Nrc2 bash-2.05/lib/sh/strtoll.c bash-2.05a/lib/sh/strtoll.c
*** bash-2.05/lib/sh/strtoll.c	Wed Dec 31 19:00:00 1969
--- bash-2.05a/lib/sh/strtoll.c	Tue Oct 16 11:41:07 2001
***************
*** 0 ****
--- 1,26 ----
+ /* Copyright (C) 1997 Free Software Foundation, Inc.
+ 
+ This program is free software; you can redistribute it and/or modify it
+ under the terms of the GNU General Public License as published by the
+ Free Software Foundation; either version 2, or (at your option) any
+ later version.
+ 
+ This program is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+ 
+ You should have received a copy of the GNU General Public License
+ along with this program; if not, write to the Free Software Foundation,
+ Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+ 
+ #include <config.h>
+ 
+ #if defined (HAVE_LONG_LONG) && !defined (HAVE_STRTOLL)
+ 
+ #define QUAD		1
+ #undef HAVE_STRTOL
+ 
+ #include "strtol.c"
+ 
+ #endif /* HAVE_LONG_LONG && !HAVE_STRTOLL */
diff -Nrc2 bash-2.05/lib/sh/strtoull.c bash-2.05a/lib/sh/strtoull.c
*** bash-2.05/lib/sh/strtoull.c	Wed Dec 31 19:00:00 1969
--- bash-2.05a/lib/sh/strtoull.c	Fri Oct 12 14:44:13 2001
***************
*** 0 ****
--- 1,27 ----
+ /* Copyright (C) 1997 Free Software Foundation, Inc.
+ 
+ This program is free software; you can redistribute it and/or modify it
+ under the terms of the GNU General Public License as published by the
+ Free Software Foundation; either version 2, or (at your option) any
+ later version.
+ 
+ This program is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+ 
+ You should have received a copy of the GNU General Public License
+ along with this program; if not, write to the Free Software Foundation,
+ Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+ 
+ #include <config.h>
+ 
+ #if defined (HAVE_LONG_LONG) && !defined (HAVE_STRTOULL)
+ 
+ #define QUAD		1
+ #define	UNSIGNED	1
+ #undef HAVE_STRTOL
+ 
+ #include "strtol.c"
+ 
+ #endif /* HAVE_LONG_LONG && !HAVE_STRTOULL */
diff -Nrc2 bash-2.05/lib/sh/strtoumax.c bash-2.05a/lib/sh/strtoumax.c
*** bash-2.05/lib/sh/strtoumax.c	Wed Dec 31 19:00:00 1969
--- bash-2.05a/lib/sh/strtoumax.c	Wed Nov  7 09:15:29 2001
***************
*** 0 ****
--- 1,102 ----
+ /* Convert string representation of a number into an uintmax_t value.
+    Copyright 1999, 2001 Free Software Foundation, Inc.
+ 
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2, or (at your option)
+    any later version.
+ 
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+ 
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software Foundation,
+    Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+ 
+ /* Written by Paul Eggert.  Modified by Chet Ramey for Bash. */
+ 
+ #if HAVE_CONFIG_H
+ #  include <config.h>
+ #endif
+ 
+ #if HAVE_INTTYPES_H
+ #  include <inttypes.h>
+ #endif
+ 
+ #if HAVE_STDLIB_H
+ #  include <stdlib.h>
+ #endif
+ 
+ #include <stdc.h>
+ 
+ /* Verify a requirement at compile-time (unlike assert, which is runtime).  */
+ #define verify(name, assertion) struct name { char a[(assertion) ? 1 : -1]; }
+ 
+ #ifndef HAVE_DECL_STRTOUL
+ "this configure-time declaration test was not run"
+ #endif
+ #if !HAVE_DECL_STRTOUL
+ extern unsigned long strtoul __P((const char *, char **, int));
+ #endif
+ 
+ #ifndef HAVE_DECL_STRTOULL
+ "this configure-time declaration test was not run"
+ #endif
+ #if !HAVE_DECL_STRTOULL && HAVE_UNSIGNED_LONG_LONG
+ extern unsigned long long strtoull __P((const char *, char **, int));
+ #endif
+ 
+ uintmax_t
+ strtoumax (ptr, endptr, base)
+      const char *ptr;
+      char **endptr;
+      int base;
+ {
+ #if HAVE_UNSIGNED_LONG_LONG
+   verify (size_is_that_of_unsigned_long_or_unsigned_long_long,
+ 	  (sizeof (uintmax_t) == sizeof (unsigned long) ||
+ 	   sizeof (uintmax_t) == sizeof (unsigned long long)));
+ 
+   if (sizeof (uintmax_t) != sizeof (unsigned long))
+     return (strtoull (ptr, endptr, base));
+ #else
+   verify (size_is_that_of_unsigned_long, sizeof (uintmax_t) == sizeof (unsigned long));
+ #endif
+ 
+   return (strtoul (ptr, endptr, base));
+ }
+ 
+ #ifdef TESTING
+ # include <stdio.h>
+ int
+ main ()
+ {
+   char *p, *endptr;
+   uintmax_t x;
+ #if HAVE_UNSIGNED_LONG_LONG
+   unsigned long long y;
+ #endif
+   unsigned long z;
+ 
+   printf ("sizeof uintmax_t: %d\n", sizeof (uintmax_t));
+ 
+ #if HAVE_UNSIGNED_LONG_LONG
+   printf ("sizeof unsigned long long: %d\n", sizeof (unsigned long long));
+ #endif
+   printf ("sizeof unsigned long: %d\n", sizeof (unsigned long));
+ 
+   x = strtoumax("42", &endptr, 10);
+ #if HAVE_LONG_LONG
+   y = strtoull("42", &endptr, 10);
+ #else
+   y = 0;
+ #endif
+   z = strtoul("42", &endptr, 10);
+ 
+   printf ("%llu %llu %lu\n", x, y, z);
+ 
+   exit (0);
+ }
+ #endif
diff -Nrc2 bash-2.05/lib/sh/strtrans.c bash-2.05a/lib/sh/strtrans.c
*** bash-2.05/lib/sh/strtrans.c	Wed Feb 14 17:03:32 2001
--- bash-2.05a/lib/sh/strtrans.c	Mon Oct 22 12:42:50 2001
***************
*** 27,33 ****
  #endif
  
! #include "bashansi.h"
  #include <stdio.h>
! #include <ctype.h>
  
  #include "shell.h"
--- 27,33 ----
  #endif
  
! #include <bashansi.h>
  #include <stdio.h>
! #include <chartypes.h>
  
  #include "shell.h"
***************
*** 38,56 ****
  #define ESC '\033'	/* ASCII */
  
- #ifndef ISOCTAL
- #define ISOCTAL(c)	((c) >= '0' && (c) <= '7')
- #endif
- 
- #ifndef OCTVALUE
- #define OCTVALUE(c)	((c) - '0')
- #endif
- 
- #ifndef isxdigit
- #  define isxdigit(c)	(isdigit((c)) || ((c) >= 'a' && (c) <= 'f') || ((c) >= 'A' && (c) <= 'F'))
- #endif
- 
- #define HEXVALUE(c) \
-   ((c) >= 'a' && (c) <= 'f' ? (c)-'a'+10 : (c) >= 'A' && (c) <= 'F' ? (c)-'A'+10 : (c)-'0')
- 
  /* Convert STRING by expanding the escape sequences specified by the
     ANSI C standard.  If SAWC is non-null, recognize `\c' and use that
--- 38,41 ----
***************
*** 71,75 ****
      return ((char *)NULL);
  
!   ret = xmalloc (len + 1);
    for (r = ret, s = string; s && *s; )
      {
--- 56,60 ----
      return ((char *)NULL);
  
!   ret = (char *)xmalloc (len + 1);
    for (r = ret, s = string; s && *s; )
      {
***************
*** 99,112 ****
  	      for (temp = 2, c -= '0'; ISOCTAL (*s) && temp--; s++)
  		c = (c * 8) + OCTVALUE (*s);
  	      break;
  	    case 'x':			/* Hex digit -- non-ANSI */
! 	      for (temp = 3, c = 0; isxdigit (*s) && temp--; s++)
  		c = (c * 16) + HEXVALUE (*s);
  	      /* \x followed by non-hex digits is passed through unchanged */
! 	      if (temp == 3)
  		{
  		  *r++ = '\\';
  		  c = 'x';
  		}
  	      break;
  	    case '\\':
--- 84,99 ----
  	      for (temp = 2, c -= '0'; ISOCTAL (*s) && temp--; s++)
  		c = (c * 8) + OCTVALUE (*s);
+ 	      c &= 0xFF;
  	      break;
  	    case 'x':			/* Hex digit -- non-ANSI */
! 	      for (temp = 2, c = 0; ISXDIGIT ((unsigned char)*s) && temp--; s++)
  		c = (c * 16) + HEXVALUE (*s);
  	      /* \x followed by non-hex digits is passed through unchanged */
! 	      if (temp == 2)
  		{
  		  *r++ = '\\';
  		  c = 'x';
  		}
+ 	      c &= 0xFF;
  	      break;
  	    case '\\':
***************
*** 144,148 ****
  {
    char *r, *ret, *s, obuf[8];
!   int l, c, rsize, t;
  
    if (str == 0 || *str == 0)
--- 131,136 ----
  {
    char *r, *ret, *s, obuf[8];
!   int l, rsize, t;
!   unsigned char c;
  
    if (str == 0 || *str == 0)
***************
*** 151,155 ****
    l = strlen (str);
    rsize = 2 * l + 4;
!   r = ret = xmalloc (rsize);
  
    *r++ = '$';
--- 139,143 ----
    l = strlen (str);
    rsize = 2 * l + 4;
!   r = ret = (char *)xmalloc (rsize);
  
    *r++ = '$';
***************
*** 158,162 ****
    for (s = str, l = 0; *s; s++)
      {
!       c = *(unsigned char *)s;
        l = 1;		/* 1 == add backslash; 0 == no backslash */
        switch (c)
--- 146,150 ----
    for (s = str, l = 0; *s; s++)
      {
!       c = *s;
        l = 1;		/* 1 == add backslash; 0 == no backslash */
        switch (c)
***************
*** 180,184 ****
  	  break;
  	default:
! 	  if (isprint (c) == 0)
  	    {
  	      sprintf (obuf, "\\%.3o", c);
--- 168,172 ----
  	  break;
  	default:
! 	  if (ISPRINT (c) == 0)
  	    {
  	      sprintf (obuf, "\\%.3o", c);
***************
*** 203,205 ****
--- 191,210 ----
      *rlen = r - ret;
    return ret;
+ }
+ 
+ /* return 1 if we need to quote with $'...' because of non-printing chars. */
+ ansic_shouldquote (string)
+      const char *string;
+ {
+   const char *s;
+   unsigned char c;
+ 
+   if (string == 0)
+     return 0;
+ 
+   for (s = string; c = *s; s++)
+     if (ISPRINT (c) == 0)
+       return 1;
+ 
+   return 0;
  }
diff -Nrc2 bash-2.05/lib/sh/times.c bash-2.05a/lib/sh/times.c
*** bash-2.05/lib/sh/times.c	Wed Feb 14 17:03:47 2001
--- bash-2.05a/lib/sh/times.c	Mon Oct 29 14:08:59 2001
***************
*** 31,35 ****
  #endif /* HAVE_SYS_RESOURCE_H && HAVE_GETRUSAGE */
  
! extern long	get_clk_tck();
  
  #define CONVTCK(r)      (r.tv_sec * clk_tck + r.tv_usec / (1000000 / clk_tck))
--- 31,35 ----
  #endif /* HAVE_SYS_RESOURCE_H && HAVE_GETRUSAGE */
  
! extern long	get_clk_tck __P((void));
  
  #define CONVTCK(r)      (r.tv_sec * clk_tck + r.tv_usec / (1000000 / clk_tck))
diff -Nrc2 bash-2.05/lib/sh/timeval.c bash-2.05a/lib/sh/timeval.c
*** bash-2.05/lib/sh/timeval.c	Mon Aug 16 12:01:47 1999
--- bash-2.05a/lib/sh/timeval.c	Tue Oct  2 14:30:37 2001
***************
*** 104,108 ****
  timeval_to_secs (tvp, sp, sfp)
       struct timeval *tvp;
!      long *sp;
       int *sfp;
  {
--- 104,108 ----
  timeval_to_secs (tvp, sp, sfp)
       struct timeval *tvp;
!      time_t *sp;
       int *sfp;
  {
***************
*** 132,144 ****
       struct timeval *tvp;
  {
!   int minutes, seconds_fraction;
!   long seconds;
  
!   timeval_to_secs (tvp, &seconds, &seconds_fraction);
  
!   minutes = seconds / 60;
!   seconds %= 60;
  
!   fprintf (fp, "%0dm%0ld.%03ds",  minutes, seconds, seconds_fraction);
  }
  #endif /* HAVE_TIMEVAL */
--- 132,145 ----
       struct timeval *tvp;
  {
!   time_t timestamp;
!   long minutes;
!   int seconds, seconds_fraction;
  
!   timeval_to_secs (tvp, &timestamp, &seconds_fraction);
  
!   minutes = timestamp / 60;
!   seconds = timestamp % 60;
  
!   fprintf (fp, "%ldm%d.%03ds",  minutes, seconds, seconds_fraction);
  }
  #endif /* HAVE_TIMEVAL */
diff -Nrc2 bash-2.05/lib/sh/tmpfile.c bash-2.05a/lib/sh/tmpfile.c
*** bash-2.05/lib/sh/tmpfile.c	Wed Feb 14 17:03:53 2001
--- bash-2.05a/lib/sh/tmpfile.c	Tue Oct 30 14:03:47 2001
***************
*** 45,49 ****
  #define DEFAULT_NAMEROOT	"shtmp"
  
! extern int dollar_dollar_pid;
  
  static char *sys_tmpdir = (char *)NULL;
--- 45,49 ----
  #define DEFAULT_NAMEROOT	"shtmp"
  
! extern pid_t dollar_dollar_pid;
  
  static char *sys_tmpdir = (char *)NULL;
***************
*** 60,63 ****
--- 60,69 ----
      return sys_tmpdir;
  
+ #ifdef P_tmpdir
+   sys_tmpdir = P_tmpdir;
+   if (stat (sys_tmpdir, &sb) == 0)
+     return sys_tmpdir;
+ #endif
+ 
    sys_tmpdir = "/tmp";
    if (stat (sys_tmpdir, &sb) == 0)
***************
*** 72,80 ****
      return sys_tmpdir;
  
- #ifdef P_tmpdir
-   sys_tmpdir = P_tmpdir;
- #else
    sys_tmpdir = DEFAULT_TMPDIR;
- #endif
  
    return sys_tmpdir;
--- 78,82 ----
***************
*** 106,135 ****
       int flags;
  {
!   char *filename, *tdir;
    struct stat sb;
    int r, tdlen;
  
!   filename = xmalloc (PATH_MAX + 1);
    tdir = get_tmpdir (flags);
    tdlen = strlen (tdir);
  
!   if (nameroot == 0)
!     nameroot = DEFAULT_NAMEROOT;
  
    while (1)
      {
!       filenum *= (int)time ((time_t *)0) * dollar_dollar_pid *
! 		((flags & MT_USERANDOM) ? get_random_number () : ntmpfiles++);
!       sprintf (filename, "%s/%s-%lu", tdir, nameroot, filenum);
        if (tmpnamelen > 0 && tmpnamelen < 32)
  	filename[tdlen + 1 + tmpnamelen] = '\0';
! #ifdef HAVE_LSTAT
        r = lstat (filename, &sb);
! #else
        r = stat (filename, &sb);
! #endif
        if (r < 0 && errno == ENOENT)
  	break;
      }
  
    return filename;
--- 108,147 ----
       int flags;
  {
!   char *filename, *tdir, *lroot;
    struct stat sb;
    int r, tdlen;
  
!   filename = (char *)xmalloc (PATH_MAX + 1);
    tdir = get_tmpdir (flags);
    tdlen = strlen (tdir);
  
!   lroot = nameroot ? nameroot : DEFAULT_NAMEROOT;
  
+ #ifdef USE_MKTEMP
+   sprintf (filename, "%s/%s.XXXXXX", tdir, lroot);
+   if (mktemp (filename) == 0)
+     {
+       free (filename);
+       filename = NULL;
+     }
+ #else  /* !USE_MKTEMP */
    while (1)
      {
!       filenum = (filenum << 1) ^
! 		(unsigned long) time ((time_t *)0) ^
! 		(unsigned long) dollar_dollar_pid ^
! 		(unsigned long) ((flags & MT_USERANDOM) ? get_random_number () : ntmpfiles++);
!       sprintf (filename, "%s/%s-%lu", tdir, lroot, filenum);
        if (tmpnamelen > 0 && tmpnamelen < 32)
  	filename[tdlen + 1 + tmpnamelen] = '\0';
! #  ifdef HAVE_LSTAT
        r = lstat (filename, &sb);
! #  else
        r = stat (filename, &sb);
! #  endif
        if (r < 0 && errno == ENOENT)
  	break;
      }
+ #endif /* !USE_MKTEMP */
  
    return filename;
***************
*** 142,160 ****
       char **namep;
  {
!   char *filename, *tdir;
    int fd, tdlen;
  
!   filename = xmalloc (PATH_MAX + 1);
    tdir = get_tmpdir (flags);
    tdlen = strlen (tdir);
  
!   if (nameroot == 0)
!     nameroot = DEFAULT_NAMEROOT;
  
    do
      {
!       filenum *= (int)time ((time_t *)0) * dollar_dollar_pid *
! 		((flags & MT_USERANDOM) ? get_random_number () : ntmpfiles++);
!       sprintf (filename, "%s/%s-%lu", tdir, nameroot, filenum);
        if (tmpnamelen > 0 && tmpnamelen < 32)
  	filename[tdlen + 1 + tmpnamelen] = '\0';
--- 154,185 ----
       char **namep;
  {
!   char *filename, *tdir, *lroot;
    int fd, tdlen;
  
!   filename = (char *)xmalloc (PATH_MAX + 1);
    tdir = get_tmpdir (flags);
    tdlen = strlen (tdir);
  
!   lroot = nameroot ? nameroot : DEFAULT_NAMEROOT;
  
+ #ifdef USE_MKSTEMP
+   sprintf (filename, "%s/%s.XXXXXX", tdir, lroot);
+   fd = mkstemp (filename);
+   if (fd < 0 || namep == 0)
+     {
+       free (filename);
+       filename = NULL;
+     }
+   if (namep)
+     *namep = filename;
+   return fd;
+ #else /* !USE_MKSTEMP */
    do
      {
!       filenum = (filenum << 1) ^
! 		(unsigned long) time ((time_t *)0) ^
! 		(unsigned long) dollar_dollar_pid ^
! 		(unsigned long) ((flags & MT_USERANDOM) ? get_random_number () : ntmpfiles++);
!       sprintf (filename, "%s/%s-%lu", tdir, lroot, filenum);
        if (tmpnamelen > 0 && tmpnamelen < 32)
  	filename[tdlen + 1 + tmpnamelen] = '\0';
***************
*** 169,172 ****
--- 194,198 ----
  
    return fd;
+ #endif /* !USE_MKSTEMP */
  }
  
***************
*** 178,183 ****
  {
    int fd;
  
    fd = sh_mktmpfd (nameroot, flags, namep);
!   return ((fd >= 0) ? (fdopen (fd, (flags & MT_READWRITE) ? "w+" : "w")) : (FILE *)NULL);
  }
--- 204,215 ----
  {
    int fd;
+   FILE *fp;
  
    fd = sh_mktmpfd (nameroot, flags, namep);
!   if (fd < 0)
!     return ((FILE *)NULL);
!   fp = fdopen (fd, (flags & MT_READWRITE) ? "w+" : "w");
!   if (fp == 0)
!     close (fd);
!   return fp;
  }
diff -Nrc2 bash-2.05/lib/sh/zread.c bash-2.05a/lib/sh/zread.c
*** bash-2.05/lib/sh/zread.c	Wed Feb 14 17:03:59 2001
--- bash-2.05a/lib/sh/zread.c	Thu May 10 09:16:40 2001
***************
*** 37,41 ****
  /* Read LEN bytes from FD into BUF.  Retry the read on EINTR.  Any other
     error causes the loop to break. */
! int
  zread (fd, buf, len)
       int fd;
--- 37,41 ----
  /* Read LEN bytes from FD into BUF.  Retry the read on EINTR.  Any other
     error causes the loop to break. */
! ssize_t
  zread (fd, buf, len)
       int fd;
***************
*** 43,47 ****
       size_t len;
  {
!   int r;
  
    while ((r = read (fd, buf, len)) < 0 && errno == EINTR)
--- 43,47 ----
       size_t len;
  {
!   ssize_t r;
  
    while ((r = read (fd, buf, len)) < 0 && errno == EINTR)
***************
*** 58,62 ****
  #define NUM_INTR 3
  
! int
  zread1 (fd, buf, len)
       int fd;
--- 58,62 ----
  #define NUM_INTR 3
  
! ssize_t
  zread1 (fd, buf, len)
       int fd;
***************
*** 64,68 ****
       size_t len;
  {
!   int r, nintr;
  
    for (nintr = 0; ; )
--- 64,69 ----
       size_t len;
  {
!   ssize_t r;
!   int nintr;
  
    for (nintr = 0; ; )
***************
*** 85,107 ****
     calls to read(2), like those the `read' builtin performs. */
  
! static unsigned char lbuf[128];
! static int lind, lused;
  
! int
  zreadc (fd, cp)
       int fd;
       char *cp;
  {
!   int r;
  
    if (lind == lused || lused == 0)
      {
!       lused = zread (fd, lbuf, sizeof (lbuf));
        lind = 0;
!       if (lused <= 0)
! 	return (lused);
      }
    if (cp)
!     *cp = (char)lbuf[lind++];
    return 1;
  }
--- 86,112 ----
     calls to read(2), like those the `read' builtin performs. */
  
! static char lbuf[128];
! static size_t lind, lused;
  
! ssize_t
  zreadc (fd, cp)
       int fd;
       char *cp;
  {
!   ssize_t nr;
  
    if (lind == lused || lused == 0)
      {
!       nr = zread (fd, lbuf, sizeof (lbuf));
        lind = 0;
!       if (nr <= 0)
! 	{
! 	  lused = 0;
! 	  return nr;
! 	}
!       lused = nr;
      }
    if (cp)
!     *cp = lbuf[lind++];
    return 1;
  }
***************
*** 119,123 ****
       int fd;
  {
!   int off;
  
    off = lused - lind;
--- 124,128 ----
       int fd;
  {
!   off_t off;
  
    off = lused - lind;
diff -Nrc2 bash-2.05/lib/sh/zwrite.c bash-2.05a/lib/sh/zwrite.c
*** bash-2.05/lib/sh/zwrite.c	Tue Oct 31 10:52:03 2000
--- bash-2.05a/lib/sh/zwrite.c	Thu May 10 11:49:29 2001
***************
*** 37,41 ****
  zwrite (fd, buf, nb)
       int fd;
!      unsigned char *buf;
       size_t nb;
  {
--- 37,41 ----
  zwrite (fd, buf, nb)
       int fd;
!      char *buf;
       size_t nb;
  {
diff -Nrc2 bash-2.05/lib/termcap/Makefile.in bash-2.05a/lib/termcap/Makefile.in
*** bash-2.05/lib/termcap/Makefile.in	Thu Aug  5 10:54:03 1999
--- bash-2.05a/lib/termcap/Makefile.in	Wed May  2 10:49:51 2001
***************
*** 26,29 ****
--- 26,31 ----
  BUILD_DIR = @BUILD_DIR@
  
+ libdir = @libdir@
+ 
  INSTALL = @INSTALL@
  INSTALL_PROGRAM = @INSTALL_PROGRAM@
***************
*** 81,85 ****
  	$(RM) Makefile
  
! $(DESTDIR)/libtermcap.a: libtermcap.a
  	${INSTALL_DATA} -c -m 644 libtermcap.a $@
  	-test -n "$(RANLIB)" && $(RANLIB) -t $@
--- 83,87 ----
  	$(RM) Makefile
  
! $(DESTDIR)$(libdir)/libtermcap.a: libtermcap.a
  	${INSTALL_DATA} -c -m 644 libtermcap.a $@
  	-test -n "$(RANLIB)" && $(RANLIB) -t $@
diff -Nrc2 bash-2.05/lib/tilde/ChangeLog bash-2.05a/lib/tilde/ChangeLog
*** bash-2.05/lib/tilde/ChangeLog	Wed Sep  9 11:06:46 1992
--- bash-2.05a/lib/tilde/ChangeLog	Wed Dec 31 19:00:00 1969
***************
*** 1,6 ****
- Mon Jul 13 12:01:51 1992  Brian Fox  (bfox@cubit)
- 
- 	* tilde.c: (tilde_expand_word) If there is no variable $HOME, then
- 	look up the user's home directory in the password database.
- 
- 
--- 0 ----
diff -Nrc2 bash-2.05/lib/tilde/Makefile.in bash-2.05a/lib/tilde/Makefile.in
*** bash-2.05/lib/tilde/Makefile.in	Thu Aug  5 10:53:46 1999
--- bash-2.05a/lib/tilde/Makefile.in	Wed May  2 10:51:27 2001
***************
*** 98,103 ****
  # include files.
  install:
! 	$(INSTALL_DATA) -c -m 644 $(LIBRARY_NAME) $(bindir)/$(LIBRARY_NAME)
! 	-test -n "$(RANLIB)" && $(RANLIB) -t $(bindir)/$(LIBRARY_NAME)
  
  clean:
--- 98,103 ----
  # include files.
  install:
! 	$(INSTALL_DATA) -c -m 644 $(LIBRARY_NAME) $(libdir)/$(LIBRARY_NAME)
! 	-test -n "$(RANLIB)" && $(RANLIB) -t $(libdir)/$(LIBRARY_NAME)
  
  clean:
diff -Nrc2 bash-2.05/lib/tilde/tilde.c bash-2.05a/lib/tilde/tilde.c
*** bash-2.05/lib/tilde/tilde.c	Wed Feb 14 17:04:21 2001
--- bash-2.05a/lib/tilde/tilde.c	Wed Aug 22 09:35:59 2001
***************
*** 49,61 ****
  
  #if defined (TEST) || defined (STATIC_MALLOC)
! static char *xmalloc (), *xrealloc ();
  #else
! extern char *xmalloc __P((int));
! extern char *xrealloc __P((void *, int));
  #endif /* TEST || STATIC_MALLOC */
  
  #if !defined (HAVE_GETPW_DECLS)
! extern struct passwd *getpwuid __P((uid_t));
! extern struct passwd *getpwnam __P((const char *));
  #endif /* !HAVE_GETPW_DECLS */
  
--- 49,60 ----
  
  #if defined (TEST) || defined (STATIC_MALLOC)
! static void *xmalloc (), *xrealloc ();
  #else
! #  include "xmalloc.h"
  #endif /* TEST || STATIC_MALLOC */
  
  #if !defined (HAVE_GETPW_DECLS)
! extern struct passwd *getpwuid PARAMS((uid_t));
! extern struct passwd *getpwnam PARAMS((const char *));
  #endif /* !HAVE_GETPW_DECLS */
  
***************
*** 64,68 ****
  extern char *strcpy ();
  #  endif
! #define savestring(x) strcpy (xmalloc (1 + strlen (x)), (x))
  #endif /* !savestring */
  
--- 63,67 ----
  extern char *strcpy ();
  #  endif
! #define savestring(x) strcpy ((char *)xmalloc (1 + strlen (x)), (x))
  #endif /* !savestring */
  
***************
*** 78,83 ****
     variables.o.  If being compiled as part of readline, they will
     be satisfied from shell.o. */
! extern char *sh_get_home_dir __P((void));
! extern char *sh_get_env_value __P((const char *));
  
  /* The default value of tilde_additional_prefixes.  This is set to
--- 77,82 ----
     variables.o.  If being compiled as part of readline, they will
     be satisfied from shell.o. */
! extern char *sh_get_home_dir PARAMS((void));
! extern char *sh_get_env_value PARAMS((const char *));
  
  /* The default value of tilde_additional_prefixes.  This is set to
***************
*** 115,118 ****
--- 114,122 ----
  char **tilde_additional_suffixes = (char **)default_suffixes;
  
+ static int tilde_find_prefix PARAMS((const char *, int *));
+ static int tilde_find_suffix PARAMS((const char *));
+ static char *isolate_tilde_prefix PARAMS((const char *, int *));
+ static char *glue_prefix_and_suffix PARAMS((char *, const char *, int));
+ 
  /* Find the start of a tilde expansion in STRING, and return the index of
     the tilde which starts the expansion.  Place the length of the text
***************
*** 120,124 ****
  static int
  tilde_find_prefix (string, len)
!      char *string;
       int *len;
  {
--- 124,128 ----
  static int
  tilde_find_prefix (string, len)
!      const char *string;
       int *len;
  {
***************
*** 155,159 ****
  static int
  tilde_find_suffix (string)
!      char *string;
  {
    register int i, j, string_len;
--- 159,163 ----
  static int
  tilde_find_suffix (string)
!      const char *string;
  {
    register int i, j, string_len;
***************
*** 191,197 ****
    result_index = result_size = 0;
    if (result = strchr (string, '~'))
!     result = xmalloc (result_size = (strlen (string) + 16));
    else
!     result = xmalloc (result_size = (strlen (string) + 1));
  
    /* Scan through STRING expanding tildes as we come to them. */
--- 195,201 ----
    result_index = result_size = 0;
    if (result = strchr (string, '~'))
!     result = (char *)xmalloc (result_size = (strlen (string) + 16));
    else
!     result = (char *)xmalloc (result_size = (strlen (string) + 1));
  
    /* Scan through STRING expanding tildes as we come to them. */
***************
*** 207,211 ****
        /* Copy the skipped text into the result. */
        if ((result_index + start + 1) > result_size)
! 	result = xrealloc (result, 1 + (result_size += (start + 20)));
  
        strncpy (result + result_index, string, start);
--- 211,215 ----
        /* Copy the skipped text into the result. */
        if ((result_index + start + 1) > result_size)
! 	result = (char *)xrealloc (result, 1 + (result_size += (start + 20)));
  
        strncpy (result + result_index, string, start);
***************
*** 224,228 ****
  
        /* Expand the entire tilde word, and copy it into RESULT. */
!       tilde_word = xmalloc (1 + end);
        strncpy (tilde_word, string, end);
        tilde_word[end] = '\0';
--- 228,232 ----
  
        /* Expand the entire tilde word, and copy it into RESULT. */
!       tilde_word = (char *)xmalloc (1 + end);
        strncpy (tilde_word, string, end);
        tilde_word[end] = '\0';
***************
*** 240,244 ****
  	{
  	  if ((result_index + len + 1) > result_size)
! 	    result = xrealloc (result, 1 + (result_size += (len + 20)));
  
  	  strcpy (result + result_index, expansion);
--- 244,248 ----
  	{
  	  if ((result_index + len + 1) > result_size)
! 	    result = (char *)xrealloc (result, 1 + (result_size += (len + 20)));
  
  	  strcpy (result + result_index, expansion);
***************
*** 258,262 ****
  static char *
  isolate_tilde_prefix (fname, lenp)
!      char *fname;
       int *lenp;
  {
--- 262,266 ----
  static char *
  isolate_tilde_prefix (fname, lenp)
!      const char *fname;
       int *lenp;
  {
***************
*** 264,268 ****
    int i;
  
!   ret = xmalloc (strlen (fname));
  #if defined (__MSDOS__)
    for (i = 1; fname[i] && fname[i] != '/' && fname[i] != '\\'; i++)
--- 268,272 ----
    int i;
  
!   ret = (char *)xmalloc (strlen (fname));
  #if defined (__MSDOS__)
    for (i = 1; fname[i] && fname[i] != '/' && fname[i] != '\\'; i++)
***************
*** 281,285 ****
  static char *
  glue_prefix_and_suffix (prefix, suffix, suffind)
!      char *prefix, *suffix;
       int suffind;
  {
--- 285,290 ----
  static char *
  glue_prefix_and_suffix (prefix, suffix, suffind)
!      char *prefix;
!      const char *suffix;
       int suffind;
  {
***************
*** 289,293 ****
    plen = (prefix && *prefix) ? strlen (prefix) : 0;
    slen = strlen (suffix + suffind);
!   ret = xmalloc (plen + slen + 1);
    if (plen)
      strcpy (ret, prefix);
--- 294,298 ----
    plen = (prefix && *prefix) ? strlen (prefix) : 0;
    slen = strlen (suffix + suffind);
!   ret = (char *)xmalloc (plen + slen + 1);
    if (plen)
      strcpy (ret, prefix);
***************
*** 413,421 ****
  static void memory_error_and_abort ();
  
! static char *
  xmalloc (bytes)
!      int bytes;
  {
!   char *temp = (char *)malloc (bytes);
  
    if (!temp)
--- 418,426 ----
  static void memory_error_and_abort ();
  
! static void *
  xmalloc (bytes)
!      size_t bytes;
  {
!   void *temp = (char *)malloc (bytes);
  
    if (!temp)
***************
*** 424,438 ****
  }
  
! static char *
  xrealloc (pointer, bytes)
!      char *pointer;
       int bytes;
  {
!   char *temp;
  
    if (!pointer)
!     temp = (char *)malloc (bytes);
    else
!     temp = (char *)realloc (pointer, bytes);
  
    if (!temp)
--- 429,443 ----
  }
  
! static void *
  xrealloc (pointer, bytes)
!      void *pointer;
       int bytes;
  {
!   void *temp;
  
    if (!pointer)
!     temp = malloc (bytes);
    else
!     temp = realloc (pointer, bytes);
  
    if (!temp)
diff -Nrc2 bash-2.05/lib/tilde/tilde.h bash-2.05a/lib/tilde/tilde.h
*** bash-2.05/lib/tilde/tilde.h	Mon Oct 30 14:31:04 2000
--- bash-2.05a/lib/tilde/tilde.h	Wed Aug 22 09:36:06 2001
***************
*** 25,28 ****
--- 25,32 ----
  #  define _TILDE_H_
  
+ #if defined (HAVE_CONFIG_H)
+ #  include <config.h>
+ #endif
+ 
  #ifdef __cplusplus
  extern "C" {
***************
*** 31,57 ****
  /* A function can be defined using prototypes and compile on both ANSI C
     and traditional C compilers with something like this:
! 	extern char *func __P((char *, char *, int)); */
  
! #if !defined (__P)
  #  if defined (__STDC__) || defined (__GNUC__) || defined (__cplusplus)
! #    define __P(protos) protos
  #  else
! #    define __P(protos) ()
  #  endif
  #endif
  
! #if !defined (__STDC__) && !defined (__cplusplus)
! #  if defined (__GNUC__)	/* gcc with -traditional */
! #    if !defined (const)
! #      define const __const
! #    endif /* !const */
! #  else /* !__GNUC__ */
! #    if !defined (const)
! #      define const
! #    endif /* !const */
! #  endif /* !__GNUC__ */
! #endif /* !__STDC__ && !__cplusplus */
! 
! typedef char *tilde_hook_func_t __P((char *));
  
  /* If non-null, this contains the address of a function that the application
--- 35,49 ----
  /* A function can be defined using prototypes and compile on both ANSI C
     and traditional C compilers with something like this:
! 	extern char *func PARAMS((char *, char *, int)); */
  
! #if !defined (PARAMS)
  #  if defined (__STDC__) || defined (__GNUC__) || defined (__cplusplus)
! #    define PARAMS(protos) protos
  #  else
! #    define PARAMS(protos) ()
  #  endif
  #endif
  
! typedef char *tilde_hook_func_t PARAMS((char *));
  
  /* If non-null, this contains the address of a function that the application
***************
*** 78,86 ****
  
  /* Return a new string which is the result of tilde expanding STRING. */
! extern char *tilde_expand __P((const char *));
  
  /* Do the work of tilde expansion on FILENAME.  FILENAME starts with a
     tilde.  If there is no expansion, call tilde_expansion_failure_hook. */
! extern char *tilde_expand_word __P((const char *));
  
  #ifdef __cplusplus
--- 70,78 ----
  
  /* Return a new string which is the result of tilde expanding STRING. */
! extern char *tilde_expand PARAMS((const char *));
  
  /* Do the work of tilde expansion on FILENAME.  FILENAME starts with a
     tilde.  If there is no expansion, call tilde_expansion_failure_hook. */
! extern char *tilde_expand_word PARAMS((const char *));
  
  #ifdef __cplusplus
diff -Nrc2 bash-2.05/list.c bash-2.05a/list.c
*** bash-2.05/list.c	Thu Aug  5 07:08:33 1999
--- bash-2.05a/list.c	Tue Aug 28 11:32:16 2001
***************
*** 39,43 ****
  map_over_list (list, function)
       GENERIC_LIST *list;
!      Function *function;
  {
    for ( ; list; list = list->next)
--- 39,43 ----
  map_over_list (list, function)
       GENERIC_LIST *list;
!      sh_glist_func_t *function;
  {
    for ( ; list; list = list->next)
***************
*** 49,53 ****
  map_over_words (words, function)
       WORD_LIST *words;
!      Function *function;
  {
    for ( ; words; words = words->next)
--- 49,53 ----
  map_over_words (words, function)
       WORD_LIST *words;
!      sh_icpfunc_t *function;
  {
    for ( ; words; words = words->next)
diff -Nrc2 bash-2.05/locale.c bash-2.05a/locale.c
*** bash-2.05/locale.c	Wed Feb 14 16:59:09 2001
--- bash-2.05a/locale.c	Mon Oct 29 08:37:32 2001
***************
*** 30,34 ****
  #include "bashansi.h"
  #include <stdio.h>
! #include <ctype.h>
  
  #include "shell.h"
--- 30,34 ----
  #include "bashansi.h"
  #include <stdio.h>
! #include "chartypes.h"
  
  #include "shell.h"
***************
*** 139,143 ****
        else
  	{
! 	  lc_all = xmalloc (1);
  	  lc_all[0] = '\0';
  	}
--- 139,143 ----
        else
  	{
! 	  lc_all = (char *)xmalloc (1);
  	  lc_all[0] = '\0';
  	}
***************
*** 169,173 ****
  #  endif /* LC_MESSAGES */
      }
!   else if (var[3] = 'N' && var[4] == 'U')	/* LC_NUMERIC */
      {
  #  if defined (LC_NUMERIC)
--- 169,173 ----
  #  endif /* LC_MESSAGES */
      }
!   else if (var[3] == 'N' && var[4] == 'U')	/* LC_NUMERIC */
      {
  #  if defined (LC_NUMERIC)
***************
*** 249,253 ****
  #endif
      {
!       t = xmalloc (len + 1);
        strcpy (t, string);
        if (lenp)
--- 249,253 ----
  #endif
      {
!       t = (char *)xmalloc (len + 1);
        strcpy (t, string);
        if (lenp)
***************
*** 261,265 ****
    if (translated == string)	/* gettext returns its argument if untranslatable */
      {
!       t = xmalloc (len + 1);
        strcpy (t, string);
        if (lenp)
--- 261,265 ----
    if (translated == string)	/* gettext returns its argument if untranslatable */
      {
!       t = (char *)xmalloc (len + 1);
        strcpy (t, string);
        if (lenp)
***************
*** 269,273 ****
      {
        tlen = strlen (translated);
!       t = xmalloc (tlen + 1);
        strcpy (t, translated);
        if (lenp)
--- 269,273 ----
      {
        tlen = strlen (translated);
!       t = (char *)xmalloc (tlen + 1);
        strcpy (t, translated);
        if (lenp)
diff -Nrc2 bash-2.05/mailcheck.c bash-2.05a/mailcheck.c
*** bash-2.05/mailcheck.c	Wed Feb 14 16:59:15 2001
--- bash-2.05a/mailcheck.c	Mon Oct 29 13:03:30 2001
***************
*** 30,44 ****
  #  include <unistd.h>
  #endif
  #include "bashansi.h"
  
  #include "shell.h"
- #include "maxpath.h"
  #include "execute_cmd.h"
  #include "mailcheck.h"
  #include <tilde/tilde.h>
  
! #ifndef NOW
! #define NOW ((time_t)time ((time_t *)0))
! #endif
  
  typedef struct {
--- 30,42 ----
  #  include <unistd.h>
  #endif
+ #include "posixtime.h"
  #include "bashansi.h"
  
  #include "shell.h"
  #include "execute_cmd.h"
  #include "mailcheck.h"
  #include <tilde/tilde.h>
  
! extern int mailstat __P((const char *, struct stat *));
  
  typedef struct {
***************
*** 57,65 ****
  
  /* The last known time that mail was checked. */
! static int last_time_mail_checked;
  
  /* Non-zero means warn if a mail file has been read since last checked. */
  int mail_warning;
  
  /* Returns non-zero if it is time to check mail. */
  int
--- 55,73 ----
  
  /* The last known time that mail was checked. */
! static time_t last_time_mail_checked;
  
  /* Non-zero means warn if a mail file has been read since last checked. */
  int mail_warning;
  
+ static int find_mail_file __P((char *));
+ static void update_mail_file __P((int));
+ static int add_mail_file __P((char *, char *));
+ 
+ static int file_mod_date_changed __P((int));
+ static int file_access_date_changed __P((int));
+ static int file_has_grown __P((int));
+ 
+ static char *parse_mailpath_spec __P((char *));
+ 
  /* Returns non-zero if it is time to check mail. */
  int
***************
*** 71,88 ****
  
    temp = get_string_value ("MAILCHECK");
-   seconds = -1L;
- 
-   /* Skip leading whitespace in MAILCHECK. */
-   if (temp)
-     {
-       while (whitespace (*temp))
- 	temp++;
- 
-       seconds = atoi (temp);
-     }
  
    /* Negative number, or non-numbers (such as empty string) cause no
       checking to take place. */
!   if (seconds < 0)
      return (0);
  
--- 79,86 ----
  
    temp = get_string_value ("MAILCHECK");
  
    /* Negative number, or non-numbers (such as empty string) cause no
       checking to take place. */
!   if (temp == 0 || legal_number (temp, &seconds) == 0 || seconds < 0)
      return (0);
  
***************
*** 132,136 ****
  
    file = mailfiles[i]->name;
!   if (stat (file, &finfo) == 0)
      {
        mailfiles[i]->access_time = finfo.st_atime;
--- 130,134 ----
  
    file = mailfiles[i]->name;
!   if (mailstat (file, &finfo) == 0)
      {
        mailfiles[i]->access_time = finfo.st_atime;
***************
*** 156,160 ****
    if (i >= 0)
      {
!       if (stat (filename, &finfo) == 0)
  	{
  	  mailfiles[i]->mod_time = finfo.st_mtime;
--- 154,158 ----
    if (i >= 0)
      {
!       if (mailstat (filename, &finfo) == 0)
  	{
  	  mailfiles[i]->mod_time = finfo.st_mtime;
***************
*** 222,226 ****
    mtime = mailfiles[i]->mod_time;
  
!   if ((stat (file, &finfo) == 0) && (finfo.st_size > 0))
      return (mtime != finfo.st_mtime);
  
--- 220,224 ----
    mtime = mailfiles[i]->mod_time;
  
!   if ((mailstat (file, &finfo) == 0) && (finfo.st_size > 0))
      return (mtime != finfo.st_mtime);
  
***************
*** 240,244 ****
    atime = mailfiles[i]->access_time;
  
!   if ((stat (file, &finfo) == 0) && (finfo.st_size > 0))
      return (atime != finfo.st_atime);
  
--- 238,242 ----
    atime = mailfiles[i]->access_time;
  
!   if ((mailstat (file, &finfo) == 0) && (finfo.st_size > 0))
      return (atime != finfo.st_atime);
  
***************
*** 258,262 ****
    size = mailfiles[i]->file_size;
  
!   return ((stat (file, &finfo) == 0) && (finfo.st_size > size));
  }
  
--- 256,260 ----
    size = mailfiles[i]->file_size;
  
!   return ((mailstat (file, &finfo) == 0) && (finfo.st_size > size));
  }
  
***************
*** 295,299 ****
  
    get_current_user_info ();
!   mp = xmalloc (2 + sizeof (DEFAULT_MAIL_DIRECTORY) + strlen (current_user.user_name));
    strcpy (mp, DEFAULT_MAIL_DIRECTORY);
    mp[sizeof(DEFAULT_MAIL_DIRECTORY) - 1] = '/';
--- 293,297 ----
  
    get_current_user_info ();
!   mp = (char *)xmalloc (2 + sizeof (DEFAULT_MAIL_DIRECTORY) + strlen (current_user.user_name));
    strcpy (mp, DEFAULT_MAIL_DIRECTORY);
    mp[sizeof(DEFAULT_MAIL_DIRECTORY) - 1] = '/';
***************
*** 357,361 ****
    int i, use_user_notification;
    char *dollar_underscore, *temp;
-   WORD_LIST *tlist;
  
    dollar_underscore = get_string_value ("_");
--- 355,358 ----
***************
*** 404,413 ****
  #undef mtime
  
! 	  if ((tlist = expand_string (message, Q_DOUBLE_QUOTES)))
  	    {
- 	      temp = string_list (tlist);
  	      puts (temp);
  	      free (temp);
- 	      dispose_words (tlist);
  	    }
  	  else
--- 401,408 ----
  #undef mtime
  
! 	  if (temp = expand_string_to_string (message, Q_DOUBLE_QUOTES))
  	    {
  	      puts (temp);
  	      free (temp);
  	    }
  	  else
diff -Nrc2 bash-2.05/make_cmd.c bash-2.05a/make_cmd.c
*** bash-2.05/make_cmd.c	Wed Feb 14 16:54:04 2001
--- bash-2.05a/make_cmd.c	Tue Oct 30 11:26:03 2001
***************
*** 49,59 ****
  
  extern int line_number, current_command_line_count;
- extern int disallow_filename_globbing;
  extern int last_command_exit_value;
  
  
  WORD_DESC *
  make_bare_word (string)
!      char *string;
  {
    WORD_DESC *temp;
--- 49,63 ----
  
  extern int line_number, current_command_line_count;
  extern int last_command_exit_value;
  
+ static COMMAND *make_for_or_select __P((enum command_type, WORD_DESC *, WORD_LIST *, COMMAND *));
+ #if defined (ARITH_FOR_COMMAND)
+ static WORD_LIST *make_arith_for_expr __P((char *));
+ #endif
+ static COMMAND *make_until_or_while __P((enum command_type, COMMAND *, COMMAND *));
  
  WORD_DESC *
  make_bare_word (string)
!      const char *string;
  {
    WORD_DESC *temp;
***************
*** 64,68 ****
    else
      {
!       temp->word = xmalloc (1);
        temp->word[0] = '\0';
      }
--- 68,72 ----
    else
      {
!       temp->word = (char *)xmalloc (1);
        temp->word[0] = '\0';
      }
***************
*** 75,81 ****
  make_word_flags (w, string)
       WORD_DESC *w;
!      char *string;
  {
!   register char *s;
  
    for (s = string; *s; s++)
--- 79,85 ----
  make_word_flags (w, string)
       WORD_DESC *w;
!      const char *string;
  {
!   register const char *s;
  
    for (s = string; *s; s++)
***************
*** 98,102 ****
  WORD_DESC *
  make_word (string)
!      char *string;
  {
    WORD_DESC *temp;
--- 102,106 ----
  WORD_DESC *
  make_word (string)
!      const char *string;
  {
    WORD_DESC *temp;
***************
*** 119,125 ****
  
  WORD_LIST *
! make_word_list (word, link)
       WORD_DESC *word;
!      WORD_LIST *link;
  {
    WORD_LIST *temp;
--- 123,129 ----
  
  WORD_LIST *
! make_word_list (word, wlink)
       WORD_DESC *word;
!      WORD_LIST *wlink;
  {
    WORD_LIST *temp;
***************
*** 127,131 ****
    temp = (WORD_LIST *)xmalloc (sizeof (WORD_LIST));
    temp->word = word;
!   temp->next = link;
    return (temp);
  }
--- 131,135 ----
    temp = (WORD_LIST *)xmalloc (sizeof (WORD_LIST));
    temp->word = word;
!   temp->next = wlink;
    return (temp);
  }
***************
*** 239,243 ****
    WORD_LIST *init, *test, *step;
    char *s, *t, *start;
!   int nsemi, l;
  
    init = test = step = (WORD_LIST *)NULL;
--- 243,247 ----
    WORD_LIST *init, *test, *step;
    char *s, *t, *start;
!   int nsemi;
  
    init = test = step = (WORD_LIST *)NULL;
***************
*** 543,547 ****
    else
      {
!       temp->here_doc_eof = xmalloc (1);
        temp->here_doc_eof[0] = '\0';
        goto document_done;
--- 547,551 ----
    else
      {
!       temp->here_doc_eof = (char *)xmalloc (1);
        temp->here_doc_eof[0] = '\0';
        goto document_done;
***************
*** 592,596 ****
  	{
  	  document_size = document_size ? 2 * (document_size + len) : len + 2;
! 	  document = xrealloc (document, document_size);
  	}
  
--- 596,600 ----
  	{
  	  document_size = document_size ? 2 * (document_size + len) : len + 2;
! 	  document = (char *)xrealloc (document, document_size);
  	}
  
***************
*** 606,610 ****
    else
      {
!       document = xmalloc (1);
        document[0] = '\0';
      }
--- 610,614 ----
    else
      {
!       document = (char *)xmalloc (1);
        document[0] = '\0';
      }
diff -Nrc2 bash-2.05/make_cmd.h bash-2.05a/make_cmd.h
*** bash-2.05/make_cmd.h	Thu Aug  5 07:24:14 1999
--- bash-2.05a/make_cmd.h	Tue Sep 11 14:58:25 2001
***************
*** 27,32 ****
  extern WORD_LIST *add_string_to_list __P((char *, WORD_LIST *));
  
! extern WORD_DESC *make_bare_word __P((char *));
! extern WORD_DESC *make_word __P((char *));
  extern WORD_DESC *make_word_from_token __P((int));
  
--- 27,33 ----
  extern WORD_LIST *add_string_to_list __P((char *, WORD_LIST *));
  
! extern WORD_DESC *make_bare_word __P((const char *));
! extern WORD_DESC *make_word_flags __P((WORD_DESC *, const char *));
! extern WORD_DESC *make_word __P((const char *));
  extern WORD_DESC *make_word_from_token __P((int));
  
diff -Nrc2 bash-2.05/mksyntax.c bash-2.05a/mksyntax.c
*** bash-2.05/mksyntax.c	Wed Feb 14 16:59:25 2001
--- bash-2.05a/mksyntax.c	Mon Oct 29 14:18:46 2001
***************
*** 22,30 ****
  
  #include "config.h"
  #include <stdio.h>
  #include "bashansi.h"
! #include <ctype.h>
  #include <errno.h>
  
  #include "syntax.h"
  
--- 22,35 ----
  
  #include "config.h"
+ 
  #include <stdio.h>
  #include "bashansi.h"
! #include "chartypes.h"
  #include <errno.h>
  
+ #ifdef HAVE_UNISTD_H
+ #  include <unistd.h>
+ #endif
+ 
  #include "syntax.h"
  
***************
*** 83,86 ****
--- 88,92 ----
  }
  
+ #ifdef INCLUDE_UNUSED
  static int
  getcflag (s)
***************
*** 94,97 ****
--- 100,104 ----
    return -1;
  }
+ #endif
  
  static char *
***************
*** 103,107 ****
    if (i == ' ')
      return "SPC";
!   else if (isprint (i))
      {
        xbuf[0] = i;
--- 110,114 ----
    if (i == ' ')
      return "SPC";
!   else if (ISPRINT (i))
      {
        xbuf[0] = i;
***************
*** 151,166 ****
       int flag;
  {
!   unsigned char *s;
!   char *fstr;
  
!   for (s = (unsigned char *)str; s && *s; s++)
      {
        if (debug)
  	{
  	  fstr = getcstr (flag);
! 	  fprintf(stderr, "added %s for character %s\n", fstr, cdesc(*s));
  	}
  	
!       lsyntax[*s] |= flag;
      }
  }
--- 158,175 ----
       int flag;
  {
!   char *s, *fstr;
!   unsigned char uc;
  
!   for (s = str; s && *s; s++)
      {
+       uc = *s;
+ 
        if (debug)
  	{
  	  fstr = getcstr (flag);
! 	  fprintf(stderr, "added %s for character %s\n", fstr, cdesc(uc));
  	}
  	
!       lsyntax[uc] |= flag;
      }
  }
***************
*** 257,262 ****
       FILE *fp;
  {
!   int i, cflag;
!   char *cstr;
  
    fprintf (fp, "const int sh_syntaxtab[%d] = {\n", SYNSIZE);
--- 266,270 ----
       FILE *fp;
  {
!   int i;
  
    fprintf (fp, "const int sh_syntaxtab[%d] = {\n", SYNSIZE);
***************
*** 274,277 ****
--- 282,286 ----
  }
  
+ int
  main(argc, argv)
       int argc;
diff -Nrc2 bash-2.05/nojobs.c bash-2.05a/nojobs.c
*** bash-2.05/nojobs.c	Tue Apr  3 15:29:48 2001
--- bash-2.05a/nojobs.c	Mon Oct 22 14:12:45 2001
***************
*** 91,95 ****
  extern int last_command_exit_value;
  extern int interrupt_immediately;
! extern Function *this_shell_builtin;
  #if defined (HAVE_POSIX_SIGNALS)
  extern sigset_t top_level_mask;
--- 91,95 ----
  extern int last_command_exit_value;
  extern int interrupt_immediately;
! extern sh_builtin_func_t *this_shell_builtin;
  #if defined (HAVE_POSIX_SIGNALS)
  extern sigset_t top_level_mask;
***************
*** 110,119 ****
  int check_window_size;
  
- #if defined (HAVE_WAITPID)
- static void reap_zombie_children ();
- #endif
- 
- static int wait_sigint_received;
- 
  /* STATUS and FLAGS are only valid if pid != NO_PID
     STATUS is only valid if (flags & PROC_RUNNING) == 0 */
--- 110,113 ----
***************
*** 129,139 ****
  #define PROC_ASYNC	0x04
  
- static struct proc_status *pid_list = (struct proc_status *)NULL;
- static int pid_list_size;
- 
  /* Return values from find_status_by_pid */
  #define PROC_BAD	 -1
  #define PROC_STILL_ALIVE -2
  
  /* Allocate new, or grow existing PID_LIST. */
  static void
--- 123,155 ----
  #define PROC_ASYNC	0x04
  
  /* Return values from find_status_by_pid */
  #define PROC_BAD	 -1
  #define PROC_STILL_ALIVE -2
  
+ static struct proc_status *pid_list = (struct proc_status *)NULL;
+ static int pid_list_size;
+ static int wait_sigint_received;
+ 
+ static void alloc_pid_list __P((void));
+ static int find_proc_slot __P((void));
+ static int find_index_by_pid __P((pid_t));
+ static int find_status_by_pid __P((pid_t));
+ static int process_exit_status __P((WAIT));
+ static void set_pid_status __P((pid_t, WAIT));
+ static void set_pid_flags __P((pid_t, int));
+ static void unset_pid_flags __P((pid_t, int));
+ static void add_pid __P((pid_t, int));
+ static void mark_dead_jobs_as_notified __P((int));
+ 
+ static void get_new_window_size __P((int));
+ static sighandler sigwinch_sighandler __P((int));
+ static sighandler wait_signal_handler __P((int));
+ 
+ #if defined (HAVE_WAITPID)
+ static void reap_zombie_children __P((void));
+ #endif
+ 
+ static void restore_sigint_handler __P((void));
+ 
  /* Allocate new, or grow existing PID_LIST. */
  static void
***************
*** 144,149 ****
  
    pid_list_size += 10;
!   pid_list = (struct proc_status *)
!     xrealloc (pid_list, pid_list_size * sizeof (struct proc_status));
  
    /* None of the newly allocated slots have process id's yet. */
--- 160,164 ----
  
    pid_list_size += 10;
!   pid_list = (struct proc_status *)xrealloc (pid_list, pid_list_size * sizeof (struct proc_status));
  
    /* None of the newly allocated slots have process id's yet. */
***************
*** 539,542 ****
--- 554,558 ----
  /* Wait for a single pid (PID) and return its exit status.  Called by
     the wait builtin. */
+ int
  wait_for_single_pid (pid)
       pid_t pid;
***************
*** 550,554 ****
    if (pstatus == PROC_BAD)
      {
!       internal_error ("wait: pid %d is not a child of this shell", pid);
        return (127);
      }
--- 566,570 ----
    if (pstatus == PROC_BAD)
      {
!       internal_error ("wait: pid %ld is not a child of this shell", (long)pid);
        return (127);
      }
***************
*** 699,703 ****
  	}
        else if (got_pid < 0 && errno != EINTR)
! 	programming_error ("wait_for(%d): %s", pid, strerror(errno));
        else if (got_pid > 0)
  	set_pid_status (got_pid, status);
--- 715,719 ----
  	}
        else if (got_pid < 0 && errno != EINTR)
! 	programming_error ("wait_for(%ld): %s", (long)pid, strerror(errno));
        else if (got_pid > 0)
  	set_pid_status (got_pid, status);
***************
*** 819,822 ****
--- 835,839 ----
  
  /* Stop a pipeline. */
+ int
  stop_pipeline (async, ignore)
       int async;
***************
*** 824,827 ****
--- 841,845 ----
  {
    already_making_children = 0;
+   return 0;
  }
  
***************
*** 832,835 ****
--- 850,859 ----
  }
  
+ void
+ stop_making_children ()
+ {
+   already_making_children = 0;
+ }
+ 
  int
  get_job_by_pid (pid, block)
***************
*** 848,852 ****
       pid_t pid;
  {
!   fprintf (stderr, "%d\n", (int) pid);
  }
  
--- 872,876 ----
       pid_t pid;
  {
!   fprintf (stderr, "%ld\n", (long) pid);
  }
  
diff -Nrc2 bash-2.05/parse.y bash-2.05a/parse.y
*** bash-2.05/parse.y	Tue Mar 27 10:06:12 2001
--- bash-2.05a/parse.y	Tue Oct 30 11:23:35 2001
***************
*** 36,39 ****
--- 36,40 ----
  
  #include <stdio.h>
+ #include "chartypes.h"
  #include <signal.h>
  
***************
*** 45,48 ****
--- 46,50 ----
  #include "parser.h"
  #include "mailcheck.h"
+ #include "test.h"
  #include "builtins/common.h"
  #include "builtins/builtext.h"
***************
*** 86,90 ****
  extern int no_line_editing, running_under_emacs;
  extern int current_command_number;
- extern int interactive, interactive_shell, login_shell;
  extern int sourcelevel;
  extern int posixly_correct;
--- 88,91 ----
***************
*** 95,99 ****
  extern int patch_level;
  extern int dump_translatable_strings, dump_po_strings;
! extern Function *last_shell_builtin, *this_shell_builtin;
  #if defined (BUFFERED_INPUT)
  extern int bash_input_fd_changed;
--- 96,100 ----
  extern int patch_level;
  extern int dump_translatable_strings, dump_po_strings;
! extern sh_builtin_func_t *last_shell_builtin, *this_shell_builtin;
  #if defined (BUFFERED_INPUT)
  extern int bash_input_fd_changed;
***************
*** 107,135 ****
  /* **************************************************************** */
  
! static char *ansiexpand ();
! static char *localeexpand ();
! static int reserved_word_acceptable ();
! static int read_token ();
! static int yylex ();
! static int parse_arith_cmd ();
  #if defined (COND_COMMAND)
! static COMMAND *parse_cond_command ();
  #endif
! static int read_token_word ();
! static void discard_parser_constructs ();
  
! static void report_syntax_error ();
! static void handle_eof_input_unit ();
! static void prompt_again ();
  #if 0
! static void reset_readline_prompt ();
  #endif
! static void print_prompt ();
  
  #if defined (HISTORY)
! char *history_delimiting_chars ();
  #endif
  
! extern int yyerror ();
  
  /* Default prompt strings */
--- 108,177 ----
  /* **************************************************************** */
  
! #ifdef DEBUG
! static void debug_parser __P((int));
! #endif
! 
! static int yy_getc __P((void));
! static int yy_ungetc __P((int));
! 
! #if defined (READLINE)
! static int yy_readline_get __P((void));
! static int yy_readline_unget __P((int));
! #endif
! 
! static int yy_string_get __P((void));
! static int yy_string_unget __P((int));
! static int yy_stream_get __P((void));
! static int yy_stream_unget __P((int));
! 
! static int shell_getc __P((int));
! static void shell_ungetc __P((int));
! static void discard_until __P((int));
! 
! #if defined (ALIAS) || defined (DPAREN_ARITHMETIC)
! static void push_string __P((char *, int, alias_t *));
! static void pop_string __P((void));
! static void free_string_list __P((void));
! #endif
! 
! static char *read_a_line __P((int));
! 
! static char *ansiexpand __P((char *, int, int, int *));
! static char *mk_msgstr __P((char *, int *));
! static char *localeexpand __P((char *, int, int, int, int *));
! static int reserved_word_acceptable __P((int));
! static int yylex __P((void));
! static int alias_expand_token __P((char *));
! static int time_command_acceptable __P((void));
! static int special_case_tokens __P((char *));
! static int read_token __P((int));
! static char *parse_matched_pair __P((int, int, int, int *, int));
! #if defined (DPAREN_ARITHMETIC) || defined (ARITH_FOR_COMMAND)
! static int parse_arith_cmd __P((char **));
! #endif
  #if defined (COND_COMMAND)
! static COND_COM *cond_expr __P((void));
! static COND_COM *cond_or __P((void));
! static COND_COM *cond_and __P((void));
! static COND_COM *cond_term __P((void));
! static int cond_skip_newlines __P((void));
! static COMMAND *parse_cond_command __P((void));
  #endif
! static int read_token_word __P((int));
! static void discard_parser_constructs __P((int));
  
! static void report_syntax_error __P((char *));
! static void handle_eof_input_unit __P((void));
! static void prompt_again __P((void));
  #if 0
! static void reset_readline_prompt __P((void));
  #endif
! static void print_prompt __P((void));
  
  #if defined (HISTORY)
! char *history_delimiting_chars __P((void));
  #endif
  
! extern int yyerror __P((const char *));
  
  /* Default prompt strings */
***************
*** 383,402 ****
  	|	GREATER_AND '-'
  			{
! 			  redir.dest = 0L;
  			  $$ = make_redirection (1, r_close_this, redir);
  			}
  	|	NUMBER GREATER_AND '-'
  			{
! 			  redir.dest = 0L;
  			  $$ = make_redirection ($1, r_close_this, redir);
  			}
  	|	LESS_AND '-'
  			{
! 			  redir.dest = 0L;
  			  $$ = make_redirection (0, r_close_this, redir);
  			}
  	|	NUMBER LESS_AND '-'
  			{
! 			  redir.dest = 0L;
  			  $$ = make_redirection ($1, r_close_this, redir);
  			}
--- 425,444 ----
  	|	GREATER_AND '-'
  			{
! 			  redir.dest = 0;
  			  $$ = make_redirection (1, r_close_this, redir);
  			}
  	|	NUMBER GREATER_AND '-'
  			{
! 			  redir.dest = 0;
  			  $$ = make_redirection ($1, r_close_this, redir);
  			}
  	|	LESS_AND '-'
  			{
! 			  redir.dest = 0;
  			  $$ = make_redirection (0, r_close_this, redir);
  			}
  	|	NUMBER LESS_AND '-'
  			{
! 			  redir.dest = 0;
  			  $$ = make_redirection ($1, r_close_this, redir);
  			}
***************
*** 517,520 ****
--- 559,566 ----
  	|	FOR WORD newline_list IN word_list list_terminator newline_list '{' compound_list '}'
  			{ $$ = make_for_command ($2, REVERSE_LIST ($5, WORD_LIST *), $9); }
+ 	|	FOR WORD newline_list IN list_terminator newline_list DO compound_list DONE
+ 			{ $$ = make_for_command ($2, (WORD_LIST *)NULL, $8); }
+ 	|	FOR WORD newline_list IN list_terminator newline_list '{' compound_list '}'
+ 			{ $$ = make_for_command ($2, (WORD_LIST *)NULL, $8); }
  	;
  
***************
*** 858,862 ****
  int EOF_Reached = 0;
  
! void
  debug_parser (i)
       int i;
--- 904,909 ----
  int EOF_Reached = 0;
  
! #ifdef DEBUG
! static void
  debug_parser (i)
       int i;
***************
*** 866,869 ****
--- 913,917 ----
  #endif
  }
+ #endif
  
  /* yy_getc () returns the next available character from input or EOF.
***************
*** 896,901 ****
    bash_input.location.file = (FILE *)NULL;
    bash_input.location.string = (char *)NULL;
!   bash_input.getter = (Function *)NULL;
!   bash_input.ungetter = (Function *)NULL;
  }
  
--- 944,949 ----
    bash_input.location.file = (FILE *)NULL;
    bash_input.location.string = (char *)NULL;
!   bash_input.getter = (sh_cget_func_t *)NULL;
!   bash_input.ungetter = (sh_cunget_func_t *)NULL;
  }
  
***************
*** 904,910 ****
  void
  init_yy_io (get, unget, type, name, location)
!      Function *get, *unget;
       enum stream_type type;
!      char *name;
       INPUT_STREAM location;
  {
--- 952,959 ----
  void
  init_yy_io (get, unget, type, name, location)
!      sh_cget_func_t *get;
!      sh_cunget_func_t *unget;
       enum stream_type type;
!      const char *name;
       INPUT_STREAM location;
  {
***************
*** 924,928 ****
  
  /* Call this to get the next character of input. */
! int
  yy_getc ()
  {
--- 973,977 ----
  
  /* Call this to get the next character of input. */
! static int
  yy_getc ()
  {
***************
*** 932,936 ****
  /* Call this to unget C.  That is, to make C the next character
     to be read. */
! int
  yy_ungetc (c)
       int c;
--- 981,985 ----
  /* Call this to unget C.  That is, to make C the next character
     to be read. */
! static int
  yy_ungetc (c)
       int c;
***************
*** 940,943 ****
--- 989,993 ----
  
  #if defined (BUFFERED_INPUT)
+ #ifdef INCLUDE_UNUSED
  int
  input_file_descriptor ()
***************
*** 954,957 ****
--- 1004,1008 ----
      }
  }
+ #endif
  #endif /* BUFFERED_INPUT */
  
***************
*** 971,975 ****
  {
    SigHandler *old_sigint;
!   int line_len, c;
  
    if (!current_readline_line)
--- 1022,1027 ----
  {
    SigHandler *old_sigint;
!   int line_len;
!   unsigned char c;
  
    if (!current_readline_line)
***************
*** 983,986 ****
--- 1035,1039 ----
  #endif /* JOB_CONTROL */
  
+       old_sigint = (SigHandler *)NULL;
        if (signal_is_ignored (SIGINT) == 0)
  	{
***************
*** 992,996 ****
        					  current_readline_prompt : "");
  
!       if (signal_is_ignored (SIGINT) == 0)
  	{
  	  interrupt_immediately--;
--- 1045,1049 ----
        					  current_readline_prompt : "");
  
!       if (signal_is_ignored (SIGINT) == 0 && old_sigint)
  	{
  	  interrupt_immediately--;
***************
*** 1009,1013 ****
        line_len = strlen (current_readline_line);
  
!       current_readline_line = xrealloc (current_readline_line, 2 + line_len);
        current_readline_line[line_len++] = '\n';
        current_readline_line[line_len] = '\0';
--- 1062,1066 ----
        line_len = strlen (current_readline_line);
  
!       current_readline_line = (char *)xrealloc (current_readline_line, 2 + line_len);
        current_readline_line[line_len++] = '\n';
        current_readline_line[line_len] = '\0';
***************
*** 1022,1026 ****
    else
      {
!       c = (unsigned char)current_readline_line[current_readline_line_index++];
        return (c);
      }
--- 1075,1079 ----
    else
      {
!       c = current_readline_line[current_readline_line_index++];
        return (c);
      }
***************
*** 1068,1083 ****
  {
    register char *string;
!   register int c;
  
    string = bash_input.location.string;
-   c = EOF;
  
    /* If the string doesn't exist, or is empty, EOF found. */
    if (string && *string)
      {
!       c = *(unsigned char *)string++;
        bash_input.location.string = string;
      }
!   return (c);
  }
  
--- 1121,1137 ----
  {
    register char *string;
!   register unsigned char c;
  
    string = bash_input.location.string;
  
    /* If the string doesn't exist, or is empty, EOF found. */
    if (string && *string)
      {
!       c = *string++;
        bash_input.location.string = string;
+       return (c);
      }
!   else
!     return (EOF);
  }
  
***************
*** 1092,1096 ****
  void
  with_input_from_string (string, name)
!      char *string, *name;
  {
    INPUT_STREAM location;
--- 1146,1151 ----
  void
  with_input_from_string (string, name)
!      char *string;
!      const char *name;
  {
    INPUT_STREAM location;
***************
*** 1134,1138 ****
  with_input_from_stream (stream, name)
       FILE *stream;
!      char *name;
  {
    INPUT_STREAM location;
--- 1189,1193 ----
  with_input_from_stream (stream, name)
       FILE *stream;
!      const char *name;
  {
    INPUT_STREAM location;
***************
*** 1322,1326 ****
       alias_t *ap;
  {
!   STRING_SAVER *temp = (STRING_SAVER *) xmalloc (sizeof (STRING_SAVER));
  
    temp->expand_alias = expand;
--- 1377,1381 ----
       alias_t *ap;
  {
!   STRING_SAVER *temp = (STRING_SAVER *)xmalloc (sizeof (STRING_SAVER));
  
    temp->expand_alias = expand;
***************
*** 1561,1565 ****
      { \
        if (ds.delimiter_depth + 2 > ds.delimiter_space) \
! 	ds.delimiters = xrealloc \
  	  (ds.delimiters, (ds.delimiter_space += 10) * sizeof (char)); \
        ds.delimiters[ds.delimiter_depth] = character; \
--- 1616,1620 ----
      { \
        if (ds.delimiter_depth + 2 > ds.delimiter_space) \
! 	ds.delimiters = (char *)xrealloc \
  	  (ds.delimiters, (ds.delimiter_space += 10) * sizeof (char)); \
        ds.delimiters[ds.delimiter_depth] = character; \
***************
*** 1586,1589 ****
--- 1641,1645 ----
    register int i;
    int c;
+   unsigned char uc;
    static int mustpop = 0;
  
***************
*** 1756,1760 ****
  	{
  	  if (shell_input_line_len + 3 > shell_input_line_size)
! 	    shell_input_line = xrealloc (shell_input_line,
  					1 + (shell_input_line_size += 2));
  
--- 1812,1816 ----
  	{
  	  if (shell_input_line_len + 3 > shell_input_line_size)
! 	    shell_input_line = (char *)xrealloc (shell_input_line,
  					1 + (shell_input_line_size += 2));
  
***************
*** 1764,1773 ****
      }
  
!   c = shell_input_line[shell_input_line_index];
  
!   if (c)
      shell_input_line_index++;
  
!   if (c == '\\' && remove_quoted_newline &&
        shell_input_line[shell_input_line_index] == '\n')
      {
--- 1820,1829 ----
      }
  
!   uc = shell_input_line[shell_input_line_index];
  
!   if (uc)
      shell_input_line_index++;
  
!   if (uc == '\\' && remove_quoted_newline &&
        shell_input_line[shell_input_line_index] == '\n')
      {
***************
*** 1778,1793 ****
  
  #if defined (ALIAS) || defined (DPAREN_ARITHMETIC)
!   /* If C is NULL, we have reached the end of the current input string.  If
       pushed_string_list is non-empty, it's time to pop to the previous string
       because we have fully consumed the result of the last alias expansion.
       Do it transparently; just return the next character of the string popped
       to. */
!   if (!c && (pushed_string_list != (STRING_SAVER *)NULL))
      {
        if (mustpop)
  	{
  	  pop_string ();
! 	  c = shell_input_line[shell_input_line_index];
! 	  if (c)
  	    shell_input_line_index++;
  	  mustpop--;
--- 1834,1849 ----
  
  #if defined (ALIAS) || defined (DPAREN_ARITHMETIC)
!   /* If UC is NULL, we have reached the end of the current input string.  If
       pushed_string_list is non-empty, it's time to pop to the previous string
       because we have fully consumed the result of the last alias expansion.
       Do it transparently; just return the next character of the string popped
       to. */
!   if (!uc && (pushed_string_list != (STRING_SAVER *)NULL))
      {
        if (mustpop)
  	{
  	  pop_string ();
! 	  uc = shell_input_line[shell_input_line_index];
! 	  if (uc)
  	    shell_input_line_index++;
  	  mustpop--;
***************
*** 1796,1808 ****
  	{
  	  mustpop++;
! 	  c = ' ';
  	}
      }
  #endif /* ALIAS || DPAREN_ARITHMETIC */
  
!   if (!c && shell_input_line_terminator == EOF)
      return ((shell_input_line_index != 0) ? '\n' : EOF);
  
!   return ((unsigned char)c);
  }
  
--- 1852,1864 ----
  	{
  	  mustpop++;
! 	  uc = ' ';
  	}
      }
  #endif /* ALIAS || DPAREN_ARITHMETIC */
  
!   if (!uc && shell_input_line_terminator == EOF)
      return ((shell_input_line_index != 0) ? '\n' : EOF);
  
!   return (uc);
  }
  
***************
*** 1818,1821 ****
--- 1874,1879 ----
  }
  
+ #ifdef INCLUDE_UNUSED
+ /* Back the input pointer up by one, effectively `ungetting' a character. */
  static void
  shell_ungetchar ()
***************
*** 1824,1827 ****
--- 1882,1886 ----
      shell_input_line_index--;
  }
+ #endif
  
  /* Discard input until CHARACTER is seen, then push that character back
***************
*** 1844,1848 ****
       char *command;
  {
!   Function *temp_last, *temp_this;
    char *last_lastarg;
    int temp_exit_value, temp_eof_encountered;
--- 1903,1907 ----
       char *command;
  {
!   sh_builtin_func_t *temp_last, *temp_this;
    char *last_lastarg;
    int temp_exit_value, temp_eof_encountered;
***************
*** 1986,1991 ****
  	 In a pattern list in a case statement (parser_state & PST_CASEPAT). */
  static int
! alias_expand_token (token)
!      char *token;
  {
    char *expanded;
--- 2045,2050 ----
  	 In a pattern list in a case statement (parser_state & PST_CASEPAT). */
  static int
! alias_expand_token (tokstr)
!      char *tokstr;
  {
    char *expanded;
***************
*** 1995,1999 ****
  	(parser_state & PST_CASEPAT) == 0)
      {
!       ap = find_alias (token);
  
        /* Currently expanding this token. */
--- 2054,2058 ----
  	(parser_state & PST_CASEPAT) == 0)
      {
!       ap = find_alias (tokstr);
  
        /* Currently expanding this token. */
***************
*** 2067,2072 ****
  
  static int
! special_case_tokens (token)
!      char *token;
  {
    if ((last_read_token == WORD) &&
--- 2126,2131 ----
  
  static int
! special_case_tokens (tokstr)
!      char *tokstr;
  {
    if ((last_read_token == WORD) &&
***************
*** 2076,2080 ****
        ((token_before_that == FOR) || (token_before_that == CASE)) &&
  #endif
!       (token[0] == 'i' && token[1] == 'n' && token[2] == 0))
      {
        if (token_before_that == CASE)
--- 2135,2139 ----
        ((token_before_that == FOR) || (token_before_that == CASE)) &&
  #endif
!       (tokstr[0] == 'i' && tokstr[1] == 'n' && tokstr[2] == 0))
      {
        if (token_before_that == CASE)
***************
*** 2092,2096 ****
        (token_before_that == FOR) &&
  #endif
!       (token[0] == 'd' && token[1] == 'o' && token[2] == '\0'))
      return (DO);
  
--- 2151,2155 ----
        (token_before_that == FOR) &&
  #endif
!       (tokstr[0] == 'd' && tokstr[1] == 'o' && tokstr[2] == '\0'))
      return (DO);
  
***************
*** 2104,2108 ****
      {
        esacs_needed_count--;
!       if (STREQ (token, "esac"))
  	{
  	  parser_state &= ~PST_CASEPAT;
--- 2163,2167 ----
      {
        esacs_needed_count--;
!       if (STREQ (tokstr, "esac"))
  	{
  	  parser_state &= ~PST_CASEPAT;
***************
*** 2115,2119 ****
      {
        parser_state &= ~PST_ALLOWOPNBRC;
!       if (token[0] == '{' && token[1] == '\0')		/* } */
  	{
  	  open_brace_count++;
--- 2174,2178 ----
      {
        parser_state &= ~PST_ALLOWOPNBRC;
!       if (tokstr[0] == '{' && tokstr[1] == '\0')		/* } */
  	{
  	  open_brace_count++;
***************
*** 2125,2131 ****
    /* We allow a `do' after a for ((...)) without an intervening
       list_terminator */
!   if (last_read_token == ARITH_FOR_EXPRS && token[0] == 'd' && token[1] == 'o' && !token[2])
      return (DO);
!   if (last_read_token == ARITH_FOR_EXPRS && token[0] == '{' && token[1] == '\0')	/* } */
      {
        open_brace_count++;
--- 2184,2190 ----
    /* We allow a `do' after a for ((...)) without an intervening
       list_terminator */
!   if (last_read_token == ARITH_FOR_EXPRS && tokstr[0] == 'd' && tokstr[1] == 'o' && !tokstr[2])
      return (DO);
!   if (last_read_token == ARITH_FOR_EXPRS && tokstr[0] == '{' && tokstr[1] == '\0')	/* } */
      {
        open_brace_count++;
***************
*** 2133,2137 ****
      }
  
!   if (open_brace_count && reserved_word_acceptable (last_read_token) && token[0] == '}' && !token[1])
      {
        open_brace_count--;		/* { */
--- 2192,2196 ----
      }
  
!   if (open_brace_count && reserved_word_acceptable (last_read_token) && tokstr[0] == '}' && !tokstr[1])
      {
        open_brace_count--;		/* { */
***************
*** 2141,2145 ****
  #if defined (COMMAND_TIMING)
    /* Handle -p after `time'. */
!   if (last_read_token == TIME && token[0] == '-' && token[1] == 'p' && !token[2])
      return (TIMEOPT);
  #endif
--- 2200,2204 ----
  #if defined (COMMAND_TIMING)
    /* Handle -p after `time'. */
!   if (last_read_token == TIME && tokstr[0] == '-' && tokstr[1] == 'p' && !tokstr[2])
      return (TIMEOPT);
  #endif
***************
*** 2151,2155 ****
  
  #if defined (COND_COMMAND) /* [[ */
!   if ((parser_state & PST_CONDEXPR) && token[0] == ']' && token[1] == ']' && token[2] == '\0')
      return (COND_END);
  #endif
--- 2210,2214 ----
  
  #if defined (COND_COMMAND) /* [[ */
!   if ((parser_state & PST_CONDEXPR) && tokstr[0] == ']' && tokstr[1] == ']' && tokstr[2] == '\0')
      return (COND_END);
  #endif
***************
*** 2332,2336 ****
  			 of the string it returns; we need to take those out. */
  		      len = strlen (wval);
! 		      wv2 = xmalloc (len);
  		      strncpy (wv2, wval + 1, len - 2);
  		      wv2[len - 2] = '\0';
--- 2391,2395 ----
  			 of the string it returns; we need to take those out. */
  		      len = strlen (wval);
! 		      wv2 = (char *)xmalloc (len);
  		      strncpy (wv2, wval + 1, len - 2);
  		      wv2[len - 2] = '\0';
***************
*** 2460,2464 ****
    pass_next_character = was_dollar = 0;
  
!   ret = xmalloc (retsize = 64);
    retind = 0;
  
--- 2519,2523 ----
    pass_next_character = was_dollar = 0;
  
!   ret = (char *)xmalloc (retsize = 64);
    retind = 0;
  
***************
*** 2546,2550 ****
  		  /* Translate $'...' here. */
  		  ttrans = ansiexpand (nestret, 0, nestlen - 1, &ttranslen);
! 		  free (nestret);
  		  nestret = sh_single_quote (ttrans);
  		  free (ttrans);
--- 2605,2609 ----
  		  /* Translate $'...' here. */
  		  ttrans = ansiexpand (nestret, 0, nestlen - 1, &ttranslen);
! 		  xfree (nestret);
  		  nestret = sh_single_quote (ttrans);
  		  free (ttrans);
***************
*** 2556,2561 ****
  		  /* Locale expand $"..." here. */
  		  ttrans = localeexpand (nestret, 0, nestlen - 1, start_lineno, &ttranslen);
! 		  free (nestret);
! 		  nestret = xmalloc (ttranslen + 3);
  		  nestret[0] = '"';
  		  strcpy (nestret + 1, ttrans);
--- 2615,2620 ----
  		  /* Locale expand $"..." here. */
  		  ttrans = localeexpand (nestret, 0, nestlen - 1, start_lineno, &ttranslen);
! 		  xfree (nestret);
! 		  nestret = (char *)xmalloc (ttranslen + 3);
  		  nestret[0] = '"';
  		  strcpy (nestret + 1, ttrans);
***************
*** 2638,2642 ****
  {
    int exp_lineno, rval, c;
!   char *ttok, *token;
    int ttoklen;
  
--- 2697,2701 ----
  {
    int exp_lineno, rval, c;
!   char *ttok, *tokstr;
    int ttoklen;
  
***************
*** 2651,2671 ****
      rval = 0;
  
!   token = xmalloc (ttoklen + 4);
  
    /* (( ... )) -> "..." */
!   token[0] = (rval == 1) ? '"' : '(';
!   strncpy (token + 1, ttok, ttoklen - 1);	/* don't copy the final `)' */
    if (rval == 1)
      {
!       token[ttoklen] = '"';
!       token[ttoklen+1] = '\0';
      }
    else
      {
!       token[ttoklen] = ')';
!       token[ttoklen+1] = c;
!       token[ttoklen+2] = '\0';
      }
!   *ep = token;
    FREE (ttok);
    return rval;
--- 2710,2730 ----
      rval = 0;
  
!   tokstr = (char *)xmalloc (ttoklen + 4);
  
    /* (( ... )) -> "..." */
!   tokstr[0] = (rval == 1) ? '"' : '(';
!   strncpy (tokstr + 1, ttok, ttoklen - 1);	/* don't copy the final `)' */
    if (rval == 1)
      {
!       tokstr[ttoklen] = '"';
!       tokstr[ttoklen+1] = '\0';
      }
    else
      {
!       tokstr[ttoklen] = ')';
!       tokstr[ttoklen+1] = c;
!       tokstr[ttoklen+2] = '\0';
      }
!   *ep = tokstr;
    FREE (ttok);
    return rval;
***************
*** 2674,2682 ****
  
  #if defined (COND_COMMAND)
- static COND_COM *cond_term ();
- static COND_COM *cond_and ();
- static COND_COM *cond_or ();
- static COND_COM *cond_expr ();
- 
  static COND_COM *
  cond_expr ()
--- 2733,2736 ----
***************
*** 2863,2867 ****
  
    /* ALL_DIGITS becomes zero when we see a non-digit. */
!   int all_digits;
  
    /* DOLLAR_PRESENT becomes non-zero if we see a `$'. */
--- 2917,2921 ----
  
    /* ALL_DIGITS becomes zero when we see a non-digit. */
!   int all_digit_token;
  
    /* DOLLAR_PRESENT becomes non-zero if we see a `$'. */
***************
*** 2880,2889 ****
    char *ttok, *ttrans;
    int ttoklen, ttranslen;
  
    if (token_buffer_size < TOKEN_DEFAULT_INITIAL_SIZE)
!     token = xrealloc (token, token_buffer_size = TOKEN_DEFAULT_INITIAL_SIZE);
  
    token_index = 0;
!   all_digits = isdigit (character);
    dollar_present = quoted = pass_next_character = 0;
  
--- 2934,2944 ----
    char *ttok, *ttrans;
    int ttoklen, ttranslen;
+   long lvalue;
  
    if (token_buffer_size < TOKEN_DEFAULT_INITIAL_SIZE)
!     token = (char *)xrealloc (token, token_buffer_size = TOKEN_DEFAULT_INITIAL_SIZE);
  
    token_index = 0;
!   all_digit_token = DIGIT (character);
    dollar_present = quoted = pass_next_character = 0;
  
***************
*** 2920,2924 ****
  	      /* If the next character is to be quoted, note it now. */
  	      if (cd == 0 || cd == '`' ||
! 		  (cd == '"' && (sh_syntaxtab[peek_char] & CBSDQUOTE)))
  		pass_next_character++;
  
--- 2975,2979 ----
  	      /* If the next character is to be quoted, note it now. */
  	      if (cd == 0 || cd == '`' ||
! 		  (cd == '"' && peek_char >= 0 && (sh_syntaxtab[peek_char] & CBSDQUOTE)))
  		pass_next_character++;
  
***************
*** 2941,2945 ****
  	  strcpy (token + token_index, ttok);
  	  token_index += ttoklen;
! 	  all_digits = 0;
  	  quoted = 1;
  	  dollar_present |= (character == '"' && strchr (ttok, '$') != 0);
--- 2996,3000 ----
  	  strcpy (token + token_index, ttok);
  	  token_index += ttoklen;
! 	  all_digit_token = 0;
  	  quoted = 1;
  	  dollar_present |= (character == '"' && strchr (ttok, '$') != 0);
***************
*** 2968,2972 ****
  	      token_index += ttoklen;
  	      FREE (ttok);
! 	      dollar_present = all_digits = 0;
  	      goto next_character;
  	    }
--- 3023,3027 ----
  	      token_index += ttoklen;
  	      FREE (ttok);
! 	      dollar_present = all_digit_token = 0;
  	      goto next_character;
  	    }
***************
*** 3011,3015 ****
  	      FREE (ttok);
  	      dollar_present = 1;
! 	      all_digits = 0;
  	      goto next_character;
  	    }
--- 3066,3070 ----
  	      FREE (ttok);
  	      dollar_present = 1;
! 	      all_digit_token = 0;
  	      goto next_character;
  	    }
***************
*** 3046,3050 ****
  
  		  /* Add the double quotes back */
! 		  ttok = xmalloc (ttranslen + 3);
  		  ttok[0] = '"';
  		  strcpy (ttok + 1, ttrans);
--- 3101,3105 ----
  
  		  /* Add the double quotes back */
! 		  ttok = (char *)xmalloc (ttranslen + 3);
  		  ttok[0] = '"';
  		  strcpy (ttok + 1, ttrans);
***************
*** 3062,3066 ****
  	      FREE (ttrans);
  	      quoted = 1;
! 	      all_digits = 0;
  	      goto next_character;
  	    }
--- 3117,3121 ----
  	      FREE (ttrans);
  	      quoted = 1;
! 	      all_digit_token = 0;
  	      goto next_character;
  	    }
***************
*** 3069,3073 ****
  	  else if (character == '$' && peek_char == '$')
  	    {
! 	      ttok = xmalloc (3);
  	      ttok[0] = ttok[1] = '$';
  	      ttok[2] = '\0';
--- 3124,3128 ----
  	  else if (character == '$' && peek_char == '$')
  	    {
! 	      ttok = (char *)xmalloc (3);
  	      ttok[0] = ttok[1] = '$';
  	      ttok[2] = '\0';
***************
*** 3078,3082 ****
  	      token_index += 2;
  	      dollar_present = 1;
! 	      all_digits = 0;
  	      FREE (ttok);
  	      goto next_character;
--- 3133,3137 ----
  	      token_index += 2;
  	      dollar_present = 1;
! 	      all_digit_token = 0;
  	      FREE (ttok);
  	      goto next_character;
***************
*** 3109,3113 ****
  	      token_index += ttoklen;
  	      FREE (ttok);
! 	      all_digits = 0;
  	      goto next_character;
  	    }
--- 3164,3168 ----
  	      token_index += ttoklen;
  	      FREE (ttok);
! 	      all_digit_token = 0;
  	      goto next_character;
  	    }
***************
*** 3127,3131 ****
      got_character:
  
!       all_digits &= isdigit (character);
        dollar_present |= character == '$';
  
--- 3182,3186 ----
      got_character:
  
!       all_digit_token &= DIGIT (character);
        dollar_present |= character == '$';
  
***************
*** 3158,3166 ****
       a '>' or '<', then, and ONLY then, is this input token a NUMBER.
       Otherwise, it is just a word, and should be returned as such. */
!   if (all_digits && (character == '<' || character == '>' ||
  		    last_read_token == LESS_AND ||
  		    last_read_token == GREATER_AND))
        {
! 	yylval.number = atoi (token);
  	return (NUMBER);
        }
--- 3213,3224 ----
       a '>' or '<', then, and ONLY then, is this input token a NUMBER.
       Otherwise, it is just a word, and should be returned as such. */
!   if (all_digit_token && (character == '<' || character == '>' ||
  		    last_read_token == LESS_AND ||
  		    last_read_token == GREATER_AND))
        {
! 	if (legal_number (token, &lvalue) && (int)lvalue == lvalue)
! 	  yylval.number = lvalue;
! 	else
! 	  yylval.number = -1;
  	return (NUMBER);
        }
***************
*** 3196,3200 ****
  
    the_word = (WORD_DESC *)xmalloc (sizeof (WORD_DESC));
!   the_word->word = xmalloc (1 + token_index);
    the_word->flags = 0;
    strcpy (the_word->word, token);
--- 3254,3258 ----
  
    the_word = (WORD_DESC *)xmalloc (sizeof (WORD_DESC));
!   the_word->word = (char *)xmalloc (1 + token_index);
    the_word->flags = 0;
    strcpy (the_word->word, token);
***************
*** 3238,3242 ****
    int len, tlen;
  
!   temp = xmalloc (end - start + 1);
    for (tlen = 0, len = start; len < end; )
      temp[tlen++] = string[len++];
--- 3296,3300 ----
    int len, tlen;
  
!   temp = (char *)xmalloc (end - start + 1);
    for (tlen = 0, len = start; len < end; )
      temp[tlen++] = string[len++];
***************
*** 3276,3280 ****
      }
    
!   r = result = xmalloc (len + 3);
    *r++ = '"';
  
--- 3334,3338 ----
      }
    
!   r = result = (char *)xmalloc (len + 3);
    *r++ = '"';
  
***************
*** 3318,3322 ****
    char *temp, *t, *t2;
  
!   temp = xmalloc (end - start + 1);
    for (tlen = 0, len = start; len < end; )
      temp[tlen++] = string[len++];
--- 3376,3380 ----
    char *temp, *t, *t2;
  
!   temp = (char *)xmalloc (end - start + 1);
    for (tlen = 0, len = start; len < end; )
      temp[tlen++] = string[len++];
***************
*** 3364,3392 ****
  }
  
! /* Return 1 if TOKEN is a token that after being read would allow
     a reserved word to be seen, else 0. */
  static int
! reserved_word_acceptable (token)
!      int token;
  {
!   if (token == '\n' || token == ';' || token == '(' || token == ')' ||
!       token == '|' || token == '&' || token == '{' ||
!       token == '}' ||			/* XXX */
!       token == AND_AND ||
!       token == BANG ||
!       token == TIME || token == TIMEOPT ||
!       token == DO ||
!       token == ELIF ||
!       token == ELSE ||
!       token == FI ||
!       token == IF ||
!       token == OR_OR ||
!       token == SEMI_SEMI ||
!       token == THEN ||
!       token == UNTIL ||
!       token == WHILE ||
!       token == DONE ||		/* XXX these two are experimental */
!       token == ESAC ||
!       token == 0)
      return (1);
    else
--- 3422,3450 ----
  }
  
! /* Return 1 if TOKSYM is a token that after being read would allow
     a reserved word to be seen, else 0. */
  static int
! reserved_word_acceptable (toksym)
!      int toksym;
  {
!   if (toksym == '\n' || toksym == ';' || toksym == '(' || toksym == ')' ||
!       toksym == '|' || toksym == '&' || toksym == '{' ||
!       toksym == '}' ||			/* XXX */
!       toksym == AND_AND ||
!       toksym == BANG ||
!       toksym == TIME || toksym == TIMEOPT ||
!       toksym == DO ||
!       toksym == ELIF ||
!       toksym == ELSE ||
!       toksym == FI ||
!       toksym == IF ||
!       toksym == OR_OR ||
!       toksym == SEMI_SEMI ||
!       toksym == THEN ||
!       toksym == UNTIL ||
!       toksym == WHILE ||
!       toksym == DONE ||		/* XXX these two are experimental */
!       toksym == ESAC ||
!       toksym == 0)
      return (1);
    else
***************
*** 3397,3406 ****
     TOKEN is not a shell reserved word. */
  int
! find_reserved_word (token)
!      char *token;
  {
    int i;
    for (i = 0; word_token_alist[i].word; i++)
!     if (STREQ (token, word_token_alist[i].word))
        return i;
    return -1;
--- 3455,3464 ----
     TOKEN is not a shell reserved word. */
  int
! find_reserved_word (tokstr)
!      char *tokstr;
  {
    int i;
    for (i = 0; word_token_alist[i].word; i++)
!     if (STREQ (tokstr, word_token_alist[i].word))
        return i;
    return -1;
***************
*** 3425,3429 ****
        if (temp_prompt == 0)
  	{
! 	  temp_prompt = xmalloc (1);
  	  temp_prompt[0] = '\0';
  	}
--- 3483,3487 ----
        if (temp_prompt == 0)
  	{
! 	  temp_prompt = (char *)xmalloc (1);
  	  temp_prompt[0] = '\0';
  	}
***************
*** 3522,3526 ****
    if (temp_prompt == 0)
      {
!       temp_prompt = xmalloc (1);
        temp_prompt[0] = '\0';
      }
--- 3580,3584 ----
    if (temp_prompt == 0)
      {
!       temp_prompt = (char *)xmalloc (1);
        temp_prompt[0] = '\0';
      }
***************
*** 3600,3603 ****
--- 3658,3662 ----
    char *result, *t;
    struct dstack save_dstack;
+   int last_exit_value;
  #if defined (PROMPT_STRING_DECODE)
    int result_size, result_index;
***************
*** 3606,3610 ****
    time_t the_time;
  
!   result = xmalloc (result_size = PROMPT_GROWTH);
    result[result_index = 0] = 0;
    temp = (char *)NULL;
--- 3665,3669 ----
    time_t the_time;
  
!   result = (char *)xmalloc (result_size = PROMPT_GROWTH);
    result[result_index = 0] = 0;
    temp = (char *)NULL;
***************
*** 3648,3652 ****
  
  	      n = read_octal (octal_string);
! 	      temp = xmalloc (3);
  
  	      if (n == CTLESC || n == CTLNUL)
--- 3707,3711 ----
  
  	      n = read_octal (octal_string);
! 	      temp = (char *)xmalloc (3);
  
  	      if (n == CTLESC || n == CTLNUL)
***************
*** 3677,3680 ****
--- 3736,3740 ----
  	    case 'T':
  	    case '@':
+ 	    case 'A':
  	      /* Make the current time/date into a string. */
  	      the_time = time (0);
***************
*** 3683,3686 ****
--- 3743,3747 ----
  	      temp = (c != 'd') ? savestring (temp + 11) : savestring (temp);
  	      temp[(c != 'd') ? 8 : 10] = '\0';
+ 	      temp[(c != 'A') ? 10 : 5] = '\0';
  
  	      /* quick and dirty conversion to 12-hour time */
***************
*** 3709,3713 ****
  
  	    case 'r':
! 	      temp = xmalloc (2);
  	      temp[0] = '\r';
  	      temp[1] = '\0';
--- 3770,3774 ----
  
  	    case 'r':
! 	      temp = (char *)xmalloc (2);
  	      temp[0] = '\r';
  	      temp[1] = '\0';
***************
*** 3715,3719 ****
  
  	    case 'n':
! 	      temp = xmalloc (3);
  	      temp[0] = no_line_editing ? '\n' : '\r';
  	      temp[1] = no_line_editing ? '\0' : '\n';
--- 3776,3780 ----
  
  	    case 'n':
! 	      temp = (char *)xmalloc (3);
  	      temp[0] = no_line_editing ? '\n' : '\r';
  	      temp[1] = no_line_editing ? '\0' : '\n';
***************
*** 3728,3732 ****
  	    case 'v':
  	    case 'V':
! 	      temp = xmalloc (8);
  	      if (c == 'v')
  		strcpy (temp, dist_version);
--- 3789,3793 ----
  	    case 'v':
  	    case 'V':
! 	      temp = (char *)xmalloc (8);
  	      if (c == 'v')
  		strcpy (temp, dist_version);
***************
*** 3818,3822 ****
  
  	    case '$':
! 	      t = temp = xmalloc (3);
  	      if ((promptvars || posixly_correct) && (current_user.euid != 0))
  		*t++ = '\\';
--- 3879,3883 ----
  
  	    case '$':
! 	      t = temp = (char *)xmalloc (3);
  	      if ((promptvars || posixly_correct) && (current_user.euid != 0))
  		*t++ = '\\';
***************
*** 3842,3846 ****
  	    case '[':
  	    case ']':
! 	      temp = xmalloc (3);
  	      temp[0] = '\001';
  	      temp[1] = (c == '[') ? RL_PROMPT_START_IGNORE : RL_PROMPT_END_IGNORE;
--- 3903,3907 ----
  	    case '[':
  	    case ']':
! 	      temp = (char *)xmalloc (3);
  	      temp[0] = '\001';
  	      temp[1] = (c == '[') ? RL_PROMPT_START_IGNORE : RL_PROMPT_END_IGNORE;
***************
*** 3850,3854 ****
  
  	    case '\\':
! 	      temp = xmalloc (2);
  	      temp[0] = c;
  	      temp[1] = '\0';
--- 3911,3915 ----
  
  	    case '\\':
! 	      temp = (char *)xmalloc (2);
  	      temp[0] = c;
  	      temp[1] = '\0';
***************
*** 3857,3861 ****
  	    case 'a':
  	    case 'e':
! 	      temp = xmalloc (2);
  	      temp[0] = (c == 'a') ? '\07' : '\033';
  	      temp[1] = '\0';
--- 3918,3922 ----
  	    case 'a':
  	    case 'e':
! 	      temp = (char *)xmalloc (2);
  	      temp[0] = (c == 'a') ? '\07' : '\033';
  	      temp[1] = '\0';
***************
*** 3863,3867 ****
  
  	    default:
! 	      temp = xmalloc (3);
  	      temp[0] = '\\';
  	      temp[1] = c;
--- 3924,3928 ----
  
  	    default:
! 	      temp = (char *)xmalloc (3);
  	      temp[0] = '\\';
  	      temp[1] = c;
***************
*** 3900,3907 ****
--- 3961,3970 ----
    if (promptvars || posixly_correct)
      {
+       last_exit_value = last_command_exit_value;
        list = expand_prompt_string (result, Q_DOUBLE_QUOTES);
        free (result);
        result = string_list (list);
        dispose_words (list);
+       last_command_exit_value = last_exit_value;
      }
    else
***************
*** 3920,3924 ****
     errors. */
  int
! yyerror ()
  {
    report_syntax_error ((char *)NULL);
--- 3983,3988 ----
     errors. */
  int
! yyerror (msg)
!      const char *msg;
  {
    report_syntax_error ((char *)NULL);
***************
*** 4086,4090 ****
  WORD_LIST *
  parse_string_to_word_list (s, whom)
!      char *s, *whom;
  {
    WORD_LIST *wl;
--- 4150,4155 ----
  WORD_LIST *
  parse_string_to_word_list (s, whom)
!      char *s;
!      const char *whom;
  {
    WORD_LIST *wl;
***************
*** 4122,4126 ****
  	{
  	  line_number = orig_line_number + line_number - 1;
! 	  yyerror ();	/* does the right thing */
  	  if (wl)
  	    dispose_words (wl);
--- 4187,4191 ----
  	{
  	  line_number = orig_line_number + line_number - 1;
! 	  yyerror ((char *)NULL);	/* does the right thing */
  	  if (wl)
  	    dispose_words (wl);
diff -Nrc2 bash-2.05/parser-built bash-2.05a/parser-built
*** bash-2.05/parser-built	Tue Oct 10 13:27:09 2000
--- bash-2.05a/parser-built	Tue Oct 30 11:48:15 2001
***************
*** 1,45 ****
- #ifndef YYERRCODE
- #define YYERRCODE 256
- #endif
- 
- #define IF 257
- #define THEN 258
- #define ELSE 259
- #define ELIF 260
- #define FI 261
- #define CASE 262
- #define ESAC 263
- #define FOR 264
- #define SELECT 265
- #define WHILE 266
- #define UNTIL 267
- #define DO 268
- #define DONE 269
- #define FUNCTION 270
- #define COND_START 271
- #define COND_END 272
- #define COND_ERROR 273
- #define IN 274
- #define BANG 275
- #define TIME 276
- #define TIMEOPT 277
- #define WORD 278
- #define ASSIGNMENT_WORD 279
- #define NUMBER 280
- #define ARITH_CMD 281
- #define ARITH_FOR_EXPRS 282
- #define COND_CMD 283
- #define AND_AND 284
- #define OR_OR 285
- #define GREATER_GREATER 286
- #define LESS_LESS 287
- #define LESS_AND 288
- #define GREATER_AND 289
- #define SEMI_SEMI 290
- #define LESS_LESS_MINUS 291
- #define AND_GREATER 292
- #define LESS_GREATER 293
- #define GREATER_BAR 294
- #define yacc_EOF 295
  typedef union {
    WORD_DESC *word;		/* the word that we read. */
--- 1,2 ----
***************
*** 51,53 ****
--- 8,51 ----
    PATTERN_LIST *pattern;
  } YYSTYPE;
+ #define	IF	257
+ #define	THEN	258
+ #define	ELSE	259
+ #define	ELIF	260
+ #define	FI	261
+ #define	CASE	262
+ #define	ESAC	263
+ #define	FOR	264
+ #define	SELECT	265
+ #define	WHILE	266
+ #define	UNTIL	267
+ #define	DO	268
+ #define	DONE	269
+ #define	FUNCTION	270
+ #define	COND_START	271
+ #define	COND_END	272
+ #define	COND_ERROR	273
+ #define	IN	274
+ #define	BANG	275
+ #define	TIME	276
+ #define	TIMEOPT	277
+ #define	WORD	278
+ #define	ASSIGNMENT_WORD	279
+ #define	NUMBER	280
+ #define	ARITH_CMD	281
+ #define	ARITH_FOR_EXPRS	282
+ #define	COND_CMD	283
+ #define	AND_AND	284
+ #define	OR_OR	285
+ #define	GREATER_GREATER	286
+ #define	LESS_LESS	287
+ #define	LESS_AND	288
+ #define	GREATER_AND	289
+ #define	SEMI_SEMI	290
+ #define	LESS_LESS_MINUS	291
+ #define	AND_GREATER	292
+ #define	LESS_GREATER	293
+ #define	GREATER_BAR	294
+ #define	yacc_EOF	295
+ 
+ 
  extern YYSTYPE yylval;
diff -Nrc2 bash-2.05/patchlevel.h bash-2.05a/patchlevel.h
*** bash-2.05/patchlevel.h	Wed Dec 31 19:00:00 1969
--- bash-2.05a/patchlevel.h	Wed Aug 22 08:05:39 2001
***************
*** 0 ****
--- 1,30 ----
+ /* patchlevel.h -- current bash patch level */
+ 
+ /* Copyright (C) 2001 Free Software Foundation, Inc.
+ 
+    This file is part of GNU Bash, the Bourne Again SHell.
+ 
+    Bash is free software; you can redistribute it and/or modify it
+    under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2, or (at your option)
+    any later version.
+ 
+    Bash is distributed in the hope that it will be useful, but WITHOUT
+    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+    or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+    License for more details.
+ 
+    You should have received a copy of the GNU General Public License
+    along with Bash; see the file COPYING.  If not, write to the Free
+    Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. */
+ 
+ #if !defined (_PATCHLEVEL_H_)
+ #define _PATCHLEVEL_H_
+ 
+ /* It's important that there be no other strings in this file that match the
+    regexp `^#define[ 	]*PATCHLEVEL', since that's what support/mkversion.sh
+    looks for to find the patch level (for the sccs version string). */
+ 
+ #define PATCHLEVEL 0
+ 
+ #endif /* _PATCHLEVEL_H_ */
diff -Nrc2 bash-2.05/pathexp.c bash-2.05a/pathexp.c
*** bash-2.05/pathexp.c	Wed Feb 14 16:54:26 2001
--- bash-2.05a/pathexp.c	Mon Sep 10 15:32:06 2001
***************
*** 34,41 ****
  #include "flags.h"
  
! #include <glob/fnmatch.h>
  
  #if defined (USE_POSIX_GLOB_LIBRARY)
  #  include <glob.h>
  #else
  #  include <glob/glob.h>
--- 34,42 ----
  #include "flags.h"
  
! #include <glob/strmatch.h>
  
  #if defined (USE_POSIX_GLOB_LIBRARY)
  #  include <glob.h>
+ typedef int posix_glob_errfunc_t __P((const char *, int));
  #else
  #  include <glob/glob.h>
***************
*** 108,112 ****
    register int i, j;
  
!   temp = xmalloc (strlen (pathname) + 1);
  
    if ((qflags & QGLOB_CVTNULL) && QUOTED_NULL (pathname))
--- 109,113 ----
    register int i, j;
  
!   temp = (char *)xmalloc (strlen (pathname) + 1);
  
    if ((qflags & QGLOB_CVTNULL) && QUOTED_NULL (pathname))
***************
*** 138,142 ****
    char *temp, *s, *t;
  
!   temp = xmalloc (strlen (string) * 2 + 1);
    for (t = temp, s = string; *s; )
      {
--- 139,143 ----
    char *temp, *s, *t;
  
!   temp = (char *)xmalloc (strlen (string) * 2 + 1);
    for (t = temp, s = string; *s; )
      {
***************
*** 186,190 ****
    glob_flags |= (GLOB_ERR | GLOB_DOOFFS);
  
!   i = glob (temp, glob_flags, (Function *)NULL, &filenames);
  
    free (temp);
--- 187,191 ----
    glob_flags |= (GLOB_ERR | GLOB_DOOFFS);
  
!   i = glob (temp, glob_flags, (posix_glob_errfunc_t *)NULL, &filenames);
  
    free (temp);
***************
*** 250,254 ****
    0,
    (char *)0,
!   (Function *)0,
  };
  
--- 251,255 ----
    0,
    (char *)0,
!   (sh_iv_item_func_t *)0,
  };
  
***************
*** 280,284 ****
  static int
  glob_name_is_acceptable (name)
!      char *name;
  {
    struct ign *p;
--- 281,285 ----
  static int
  glob_name_is_acceptable (name)
!      const char *name;
  {
    struct ign *p;
***************
*** 292,296 ****
    for (p = globignore.ignores; p->val; p++)
      {
!       if (fnmatch (p->val, name, flags) != FNM_NOMATCH)
  	return (0);
      }
--- 293,297 ----
    for (p = globignore.ignores; p->val; p++)
      {
!       if (strmatch (p->val, (char *)name, flags) != FNM_NOMATCH)
  	return (0);
      }
***************
*** 307,311 ****
  ignore_globbed_names (names, name_func)
       char **names;
!      Function *name_func;
  {
    char **newnames;
--- 308,312 ----
  ignore_globbed_names (names, name_func)
       char **names;
!      sh_ignore_func_t *name_func;
  {
    char **newnames;
diff -Nrc2 bash-2.05/pathexp.h bash-2.05a/pathexp.h
*** bash-2.05/pathexp.h	Mon Oct 30 15:33:30 2000
--- bash-2.05a/pathexp.h	Tue Aug 28 10:23:29 2001
***************
*** 35,39 ****
  
  #if defined (EXTENDED_GLOB)
! /* Flags to OR with other flag args to fnmatch() to enabled the extended
     pattern matching. */
  #  define FNMATCH_EXTFLAG	(extended_glob ? FNM_EXTMATCH : 0)
--- 35,39 ----
  
  #if defined (EXTENDED_GLOB)
! /* Flags to OR with other flag args to strmatch() to enabled the extended
     pattern matching. */
  #  define FNMATCH_EXTFLAG	(extended_glob ? FNM_EXTMATCH : 0)
***************
*** 64,68 ****
  extern char **shell_glob_filename __P((const char *));
  
! /* Filename completion ignore.  Used to the "fignore" facility of
     tcsh and GLOBIGNORE (like ksh-93 FIGNORE).
  
--- 64,68 ----
  extern char **shell_glob_filename __P((const char *));
  
! /* Filename completion ignore.  Used to implement the "fignore" facility of
     tcsh and GLOBIGNORE (like ksh-93 FIGNORE).
  
***************
*** 78,81 ****
--- 78,83 ----
  };
  
+ typedef int sh_iv_item_func_t __P((struct ign *));
+ 
  struct ignorevar {
    char *varname;	/* FIGNORE or GLOBIGNORE */
***************
*** 83,87 ****
    int num_ignores;	/* How many are there? */
    char *last_ignoreval;	/* Last value of variable - cached for speed */
!   Function *item_func;	/* Called when each item is parsed from $`varname' */
  };
  
--- 85,89 ----
    int num_ignores;	/* How many are there? */
    char *last_ignoreval;	/* Last value of variable - cached for speed */
!   sh_iv_item_func_t *item_func; /* Called when each item is parsed from $`varname' */
  };
  
diff -Nrc2 bash-2.05/pcomplete.c bash-2.05a/pcomplete.c
*** bash-2.05/pcomplete.c	Wed Feb 14 16:59:55 2001
--- bash-2.05a/pcomplete.c	Mon Nov  5 13:13:11 2001
***************
*** 48,51 ****
--- 48,52 ----
  #include "alias.h"
  #include "bashline.h"
+ #include "execute_cmd.h"
  #include "pathexp.h"
  
***************
*** 62,66 ****
  
  #include <glob/glob.h>
! #include <glob/fnmatch.h>
  
  #include <readline/rlconf.h>
--- 63,67 ----
  
  #include <glob/glob.h>
! #include <glob/strmatch.h>
  
  #include <readline/rlconf.h>
***************
*** 83,103 ****
  extern char *signal_names[];
  
! static int it_init_aliases ();
! static int it_init_arrayvars ();
! static int it_init_bindings ();
! static int it_init_builtins ();
! static int it_init_disabled ();
! static int it_init_enabled ();
! static int it_init_exported ();
! static int it_init_functions ();
! static int it_init_hostnames ();
! static int it_init_jobs ();
! static int it_init_running ();
! static int it_init_stopped ();
! static int it_init_keywords ();
! static int it_init_signals ();
! static int it_init_variables ();
! static int it_init_setopts ();
! static int it_init_shopts ();
  
  static int progcomp_debug = 0;
--- 84,135 ----
  extern char *signal_names[];
  
! #if defined(PREFER_STDARG)
! static void debug_printf (const char *, ...)  __attribute__((__format__ (printf, 1, 2)));
! #endif
! 
! static int it_init_joblist __P((ITEMLIST *, int));
! 
! static int it_init_aliases __P((ITEMLIST *));
! static int it_init_arrayvars __P((ITEMLIST *));
! static int it_init_bindings __P((ITEMLIST *));
! static int it_init_builtins __P((ITEMLIST *));
! static int it_init_disabled __P((ITEMLIST *));
! static int it_init_enabled __P((ITEMLIST *));
! static int it_init_exported __P((ITEMLIST *));
! static int it_init_functions __P((ITEMLIST *));
! static int it_init_hostnames __P((ITEMLIST *));
! static int it_init_jobs __P((ITEMLIST *));
! static int it_init_running __P((ITEMLIST *));
! static int it_init_stopped __P((ITEMLIST *));
! static int it_init_keywords __P((ITEMLIST *));
! static int it_init_signals __P((ITEMLIST *));
! static int it_init_variables __P((ITEMLIST *));
! static int it_init_setopts __P((ITEMLIST *));
! static int it_init_shopts __P((ITEMLIST *));
! 
! static int shouldexp_filterpat __P((char *));
! static char *preproc_filterpat __P((char *, char *));
! 
! static void init_itemlist_from_varlist __P((ITEMLIST *, SVFUNC *));
! 
! static STRINGLIST *gen_matches_from_itemlist __P((ITEMLIST *, const char *));
! static STRINGLIST *gen_action_completions __P((COMPSPEC *, const char *));
! static STRINGLIST *gen_globpat_matches __P((COMPSPEC *, const char *));
! static STRINGLIST *gen_wordlist_matches __P((COMPSPEC *, const char *));
! static STRINGLIST *gen_shell_function_matches __P((COMPSPEC *, const char *,
! 						   char *, int, WORD_LIST *,
! 						   int, int));
! static STRINGLIST *gen_command_matches __P((COMPSPEC *, const char *, char *,
! 					    int, WORD_LIST *, int, int));
! 
! static char *pcomp_filename_completion_function __P((const char *, int));
! 
! #if defined (ARRAY_VARS)
! static SHELL_VAR *bind_comp_words __P((WORD_LIST *));
! #endif
! static void bind_compfunc_variables __P((char *, int, WORD_LIST *, int, int));
! static void unbind_compfunc_variables __P((int));
! static WORD_LIST *build_arg_list __P((char *, const char *, WORD_LIST *, int));
! static WORD_LIST *command_line_to_word_list __P((char *, int, int, int *, int *));
  
  static int progcomp_debug = 0;
***************
*** 118,122 ****
  ITEMLIST it_functions  = { 0, it_init_functions, (STRINGLIST *)0 };
  ITEMLIST it_hostnames  = { LIST_DYNAMIC, it_init_hostnames, (STRINGLIST *)0 };
! ITEMLIST it_jobs = { LIST_DYNAMIC, it_init_jobs, (STRINGLIST *)0 };;
  ITEMLIST it_keywords = { 0, it_init_keywords, (STRINGLIST *)0 };
  ITEMLIST it_running = { LIST_DYNAMIC, it_init_running, (STRINGLIST *)0 };
--- 150,155 ----
  ITEMLIST it_functions  = { 0, it_init_functions, (STRINGLIST *)0 };
  ITEMLIST it_hostnames  = { LIST_DYNAMIC, it_init_hostnames, (STRINGLIST *)0 };
! ITEMLIST it_groups = { LIST_DYNAMIC };	/* unused */
! ITEMLIST it_jobs = { LIST_DYNAMIC, it_init_jobs, (STRINGLIST *)0 };
  ITEMLIST it_keywords = { 0, it_init_keywords, (STRINGLIST *)0 };
  ITEMLIST it_running = { LIST_DYNAMIC, it_init_running, (STRINGLIST *)0 };
***************
*** 265,269 ****
    for (i = 0; i < sl->list_len; i++)
      {
!       m = fnmatch (t, sl->list[i], FNMATCH_EXTFLAG);
        if ((not && m == FNM_NOMATCH) || (not == 0 && m != FNM_NOMATCH))
  	free (sl->list[i]);
--- 298,302 ----
    for (i = 0; i < sl->list_len; i++)
      {
!       m = strmatch (t, sl->list[i], FNMATCH_EXTFLAG);
        if ((not && m == FNM_NOMATCH) || (not == 0 && m != FNM_NOMATCH))
  	free (sl->list[i]);
***************
*** 318,336 ****
  {
  #ifdef ALIAS
!   alias_t **aliases;
    register int i, n;
    STRINGLIST *sl;
  
!   aliases = all_aliases ();
!   if (aliases == 0)
      {
        itp->slist = (STRINGLIST *)NULL;
        return 0;
      }
!   for (n = 0; aliases[n]; n++)
      ;
    sl = alloc_stringlist (n+1);
    for (i = 0; i < n; i++)
!     sl->list[i] = STRDUP (aliases[i]->name);
    sl->list[n] = (char *)NULL;
    sl->list_size = sl->list_len = n;
--- 351,369 ----
  {
  #ifdef ALIAS
!   alias_t **alias_list;
    register int i, n;
    STRINGLIST *sl;
  
!   alias_list = all_aliases ();
!   if (alias_list == 0)
      {
        itp->slist = (STRINGLIST *)NULL;
        return 0;
      }
!   for (n = 0; alias_list[n]; n++)
      ;
    sl = alloc_stringlist (n+1);
    for (i = 0; i < n; i++)
!     sl->list[i] = STRDUP (alias_list[i]->name);
    sl->list[n] = (char *)NULL;
    sl->list_size = sl->list_len = n;
***************
*** 381,385 ****
  
    /* rl_funmap_names allocates blist, but not its members */
!   blist = (char **)rl_funmap_names ();
    sl = alloc_stringlist (0);
    sl->list = blist;
--- 414,418 ----
  
    /* rl_funmap_names allocates blist, but not its members */
!   blist = (char **)rl_funmap_names ();	/* XXX fix const later */
    sl = alloc_stringlist (0);
    sl->list = blist;
***************
*** 397,401 ****
  {
    STRINGLIST *sl;
-   char **list;
    register int i, n;
  
--- 430,433 ----
***************
*** 415,419 ****
  {
    STRINGLIST *sl;
-   char **list;
    register int i, n;
  
--- 447,450 ----
***************
*** 435,439 ****
  {
    STRINGLIST *sl;
-   char **list;
    register int i, n;
  
--- 466,469 ----
***************
*** 488,492 ****
  #if defined (JOB_CONTROL)
    STRINGLIST *sl;
!   register int i, n;
    register PROCESS *p;
    char *s, *t;
--- 518,522 ----
  #if defined (JOB_CONTROL)
    STRINGLIST *sl;
!   register int i;
    register PROCESS *p;
    char *s, *t;
***************
*** 629,632 ****
--- 659,664 ----
  	initialize_itemlist (itp);
      }
+   if (itp->slist == 0)
+     return ((STRINGLIST *)NULL);
    ret = alloc_stringlist (itp->slist->list_len+1);
    sl = itp->slist;
***************
*** 672,677 ****
        { \
  	tlist = gen_matches_from_itemlist (it, text); \
! 	glist = append_stringlist (glist, tlist); \
! 	free_stringlist (tlist); \
        } \
    } while (0)
--- 704,712 ----
        { \
  	tlist = gen_matches_from_itemlist (it, text); \
! 	if (tlist) \
! 	  { \
! 	    glist = append_stringlist (glist, tlist); \
! 	    free_stringlist (tlist); \
! 	  } \
        } \
    } while (0)
***************
*** 724,727 ****
--- 759,763 ----
    GEN_XCOMPS(flags, CA_FILE, text, pcomp_filename_completion_function, cmatches, ret, tmatches);
    GEN_XCOMPS(flags, CA_USER, text, rl_username_completion_function, cmatches, ret, tmatches);
+   GEN_XCOMPS(flags, CA_GROUP, text, bash_groupname_completion_function, cmatches, ret, tmatches);
  
    /* And lastly, the special case for directories */
***************
*** 749,753 ****
  {
    STRINGLIST *sl;
-   char *t;
  
    sl = alloc_stringlist (0);
--- 785,788 ----
***************
*** 826,830 ****
       int cw, exported;
  {
!   char ibuf[32];
    char *value;
    SHELL_VAR *v;
--- 861,865 ----
       int cw, exported;
  {
!   char ibuf[INT_STRLEN_BOUND(int) + 1];
    char *value;
    SHELL_VAR *v;
***************
*** 836,840 ****
      VSETATTR(v, att_exported);
  
!   value = inttostr (ind, ibuf, 32);
    v = bind_int_variable ("COMP_POINT", value);
    if (v && exported)
--- 871,875 ----
      VSETATTR(v, att_exported);
  
!   value = inttostr (ind, ibuf, sizeof(ibuf));
    v = bind_int_variable ("COMP_POINT", value);
    if (v && exported)
***************
*** 847,851 ****
  #ifdef ARRAY_VARS
        v = bind_comp_words (lwords);
!       value = inttostr (cw, ibuf, 32);
        bind_int_variable ("COMP_CWORD", value);
  #endif
--- 882,886 ----
  #ifdef ARRAY_VARS
        v = bind_comp_words (lwords);
!       value = inttostr (cw, ibuf, sizeof(ibuf));
        bind_int_variable ("COMP_CWORD", value);
  #endif
***************
*** 883,887 ****
  build_arg_list (cmd, text, lwords, ind)
       char *cmd;
!      char *text;
       WORD_LIST *lwords;
       int ind;
--- 918,922 ----
  build_arg_list (cmd, text, lwords, ind)
       char *cmd;
!      const char *text;
       WORD_LIST *lwords;
       int ind;
***************
*** 926,930 ****
  gen_shell_function_matches (cs, text, line, ind, lwords, nw, cw)
       COMPSPEC *cs;
!      char *text, *line;
       int ind;
       WORD_LIST *lwords;
--- 961,966 ----
  gen_shell_function_matches (cs, text, line, ind, lwords, nw, cw)
       COMPSPEC *cs;
!      const char *text;
!      char *line;
       int ind;
       WORD_LIST *lwords;
***************
*** 1004,1008 ****
  gen_command_matches (cs, text, line, ind, lwords, nw, cw)
       COMPSPEC *cs;
!      char *text, *line;
       int ind;
       WORD_LIST *lwords;
--- 1040,1045 ----
  gen_command_matches (cs, text, line, ind, lwords, nw, cw)
       COMPSPEC *cs;
!      const char *text;
!      char *line;
       int ind;
       WORD_LIST *lwords;
***************
*** 1025,1029 ****
  
    /* allocate the string for the command and fill it in. */
!   cscmd = xmalloc (cmdsize + 1);
  
    strcpy (cscmd, cs->command);			/* $0 */
--- 1062,1066 ----
  
    /* allocate the string for the command and fill it in. */
!   cscmd = (char *)xmalloc (cmdsize + 1);
  
    strcpy (cscmd, cs->command);			/* $0 */
***************
*** 1104,1117 ****
  {
    STRINGLIST *ret, *tmatches;
!   char *line, *lword;
    int llen, nw, cw;
    WORD_LIST *lwords;
  
    debug_printf ("programmable_completions (%s, %s, %d, %d)", cmd, word, start, end);
!   debug_printf ("programmable_completions: %s -> 0x%x", cmd, (int)cs);
    ret = gen_action_completions (cs, word);
    if (ret && progcomp_debug)
      {
!       debug_printf ("gen_action_completions (0x%x, %s) -->", (int)cs, word);
        print_stringlist (ret, "\t");
        rl_on_new_line ();
--- 1141,1154 ----
  {
    STRINGLIST *ret, *tmatches;
!   char *line;
    int llen, nw, cw;
    WORD_LIST *lwords;
  
    debug_printf ("programmable_completions (%s, %s, %d, %d)", cmd, word, start, end);
!   debug_printf ("programmable_completions: %s -> %p", cmd, cs);
    ret = gen_action_completions (cs, word);
    if (ret && progcomp_debug)
      {
!       debug_printf ("gen_action_completions (%p, %s) -->", cs, word);
        print_stringlist (ret, "\t");
        rl_on_new_line ();
***************
*** 1126,1130 ****
  	  if (progcomp_debug)
  	    {
! 	      debug_printf ("gen_globpat_matches (0x%x, %s) -->", (int)cs, word);
  	      print_stringlist (tmatches, "\t");
  	      rl_on_new_line ();
--- 1163,1167 ----
  	  if (progcomp_debug)
  	    {
! 	      debug_printf ("gen_globpat_matches (%p, %s) -->", cs, word);
  	      print_stringlist (tmatches, "\t");
  	      rl_on_new_line ();
***************
*** 1143,1147 ****
  	  if (progcomp_debug)
  	    {
! 	      debug_printf ("gen_wordlist_matches (0x%x, %s) -->", (int)cs, word);
  	      print_stringlist (tmatches, "\t");
  	      rl_on_new_line ();
--- 1180,1184 ----
  	  if (progcomp_debug)
  	    {
! 	      debug_printf ("gen_wordlist_matches (%p, %s) -->", cs, word);
  	      print_stringlist (tmatches, "\t");
  	      rl_on_new_line ();
***************
*** 1162,1166 ****
        llen = end - start;
  
!       debug_printf ("command_line_to_word_list (%s, %d, %d, 0x%x, 0x%x)",
  		line, llen, rl_point - start, &nw, &cw);
        lwords = command_line_to_word_list (line, llen, rl_point - start, &nw, &cw);
--- 1199,1203 ----
        llen = end - start;
  
!       debug_printf ("command_line_to_word_list (%s, %d, %d, %p, %p)",
  		line, llen, rl_point - start, &nw, &cw);
        lwords = command_line_to_word_list (line, llen, rl_point - start, &nw, &cw);
***************
*** 1185,1189 ****
  	  if (progcomp_debug)
  	    {
! 	      debug_printf ("gen_shell_function_matches (0x%x, %s, 0x%x, %d, %d) -->", (int)cs, word, lwords, nw, cw);
  	      print_stringlist (tmatches, "\t");
  	      rl_on_new_line ();
--- 1222,1226 ----
  	  if (progcomp_debug)
  	    {
! 	      debug_printf ("gen_shell_function_matches (%p, %s, %p, %d, %d) -->", cs, word, lwords, nw, cw);
  	      print_stringlist (tmatches, "\t");
  	      rl_on_new_line ();
***************
*** 1201,1205 ****
  	  if (progcomp_debug)
  	    {
! 	      debug_printf ("gen_command_matches (0x%x, %s, 0x%x, %d, %d) -->", (int)cs, word, lwords, nw, cw);
  	      print_stringlist (tmatches, "\t");
  	      rl_on_new_line ();
--- 1238,1242 ----
  	  if (progcomp_debug)
  	    {
! 	      debug_printf ("gen_command_matches (%p, %s, %p, %d, %d) -->", cs, word, lwords, nw, cw);
  	      print_stringlist (tmatches, "\t");
  	      rl_on_new_line ();
***************
*** 1222,1226 ****
        if (progcomp_debug)
  	{
! 	  debug_printf ("filter_stringlist (0x%x, %s, %s) -->", ret, cs->filterpat, word);
  	  print_stringlist (tmatches, "\t");
  	  rl_on_new_line ();
--- 1259,1263 ----
        if (progcomp_debug)
  	{
! 	  debug_printf ("filter_stringlist (%p, %s, %s) -->", ret, cs->filterpat, word);
  	  print_stringlist (tmatches, "\t");
  	  rl_on_new_line ();
diff -Nrc2 bash-2.05/pcomplete.h bash-2.05a/pcomplete.h
*** bash-2.05/pcomplete.h	Mon Nov 27 12:33:05 2000
--- bash-2.05a/pcomplete.h	Tue Aug 28 12:55:19 2001
***************
*** 52,66 ****
  #define CA_FILE		(1<<9)
  #define CA_FUNCTION	(1<<10)
! #define CA_HELPTOPIC	(1<<11)
! #define CA_HOSTNAME	(1<<12)
! #define CA_JOB		(1<<13)
! #define CA_KEYWORD	(1<<14)
! #define CA_RUNNING	(1<<15)
! #define CA_SETOPT	(1<<16)
! #define CA_SHOPT	(1<<17)
! #define CA_SIGNAL	(1<<18)
! #define CA_STOPPED	(1<<19)
! #define CA_USER		(1<<20)
! #define CA_VARIABLE	(1<<21)
  
  /* Values for COMPSPEC options field. */
--- 52,67 ----
  #define CA_FILE		(1<<9)
  #define CA_FUNCTION	(1<<10)
! #define CA_GROUP	(1<<11)
! #define CA_HELPTOPIC	(1<<12)
! #define CA_HOSTNAME	(1<<13)
! #define CA_JOB		(1<<14)
! #define CA_KEYWORD	(1<<15)
! #define CA_RUNNING	(1<<16)
! #define CA_SETOPT	(1<<17)
! #define CA_SHOPT	(1<<18)
! #define CA_SIGNAL	(1<<19)
! #define CA_STOPPED	(1<<20)
! #define CA_USER		(1<<21)
! #define CA_VARIABLE	(1<<22)
  
  /* Values for COMPSPEC options field. */
***************
*** 74,78 ****
  typedef struct _list_of_items {
    int flags;
!   Function *list_getter;	/* function to call to get the list */
  
    STRINGLIST *slist;
--- 75,79 ----
  typedef struct _list_of_items {
    int flags;
!   int (*list_getter) __P((struct _list_of_items *));	/* function to call to get the list */
  
    STRINGLIST *slist;
***************
*** 107,110 ****
--- 108,112 ----
  extern ITEMLIST it_files;
  extern ITEMLIST it_functions;
+ extern ITEMLIST it_groups;
  extern ITEMLIST it_hostnames;
  extern ITEMLIST it_jobs;
***************
*** 119,122 ****
--- 121,125 ----
  
  /* Functions from pcomplib.c */
+ typedef void sh_csprint_func_t __P((char *, COMPSPEC *));
  
  extern COMPSPEC *alloc_compspec __P((void));
***************
*** 135,142 ****
  extern COMPSPEC *find_compspec __P((const char *));
  
! extern void print_all_compspecs __P((VFunction *));
  
  /* Functions from pcomplete.c */
  extern void set_itemlist_dirty __P((ITEMLIST *));
  
  extern STRINGLIST *gen_compspec_completions __P((COMPSPEC *, const char *, const char *, int, int));
--- 138,147 ----
  extern COMPSPEC *find_compspec __P((const char *));
  
! extern void print_all_compspecs __P((sh_csprint_func_t *));
  
  /* Functions from pcomplete.c */
  extern void set_itemlist_dirty __P((ITEMLIST *));
+ 
+ extern STRINGLIST *completions_to_stringlist __P((char **));
  
  extern STRINGLIST *gen_compspec_completions __P((COMPSPEC *, const char *, const char *, int, int));
diff -Nrc2 bash-2.05/pcomplib.c bash-2.05a/pcomplib.c
*** bash-2.05/pcomplib.c	Mon Nov 27 12:32:47 2000
--- bash-2.05a/pcomplib.c	Thu Sep 13 14:37:30 2001
***************
*** 42,45 ****
--- 42,47 ----
  HASH_TABLE *prog_completes = (HASH_TABLE *)NULL;
  
+ static void free_progcomp __P((PTR_T));
+ 
  static int progcomp_initialized = 0;
  
***************
*** 128,132 ****
  static void
  free_progcomp (data)
!      char *data;
  {
    COMPSPEC *cs;
--- 130,134 ----
  static void
  free_progcomp (data)
!      PTR_T data;
  {
    COMPSPEC *cs;
***************
*** 196,200 ****
      return ((COMPSPEC *)NULL);
  
!   item = find_hash_item ((char *)cmd, prog_completes);	/* XXX fix const later */
  
    if (item == NULL)
--- 198,202 ----
      return ((COMPSPEC *)NULL);
  
!   item = find_hash_item (cmd, prog_completes);
  
    if (item == NULL)
***************
*** 208,212 ****
  void
  print_all_compspecs (pfunc)
!      VFunction *pfunc;
  {
    BUCKET_CONTENTS *item_list;
--- 210,214 ----
  void
  print_all_compspecs (pfunc)
!      sh_csprint_func_t *pfunc;
  {
    BUCKET_CONTENTS *item_list;
diff -Nrc2 bash-2.05/print_cmd.c bash-2.05a/print_cmd.c
*** bash-2.05/print_cmd.c	Tue Apr  3 15:05:26 2001
--- bash-2.05a/print_cmd.c	Tue Oct 30 11:50:59 2001
***************
*** 44,48 ****
  #include "builtins/common.h"
  
! #if !defined (PRINTF_DECLARED)
  extern int printf __P((const char *, ...));	/* Yuck.  Double yuck. */
  #endif
--- 44,48 ----
  #include "builtins/common.h"
  
! #if !HAVE_DECL_PRINTF
  extern int printf __P((const char *, ...));	/* Yuck.  Double yuck. */
  #endif
***************
*** 52,91 ****
  
  #if defined (PREFER_STDARG)
! static void cprintf __P((char *, ...));
  #else
  static void cprintf ();
- #endif
- 
- static void newline (), indent (), the_printed_command_resize ();
- static void semicolon ();
  static void xprintf ();
  
! static void make_command_string_internal ();
! static void command_print_word_list ();
! static void print_case_clauses ();
! static void print_redirection_list ();
! static void print_redirection ();
  
! static void print_for_command ();
  #if defined (SELECT_COMMAND)
! static void print_select_command ();
  #endif
! static void print_group_command ();
! static void print_case_command ();
! static void print_while_command ();
! static void print_until_command ();
! static void print_until_or_while ();
! static void print_if_command ();
! static void print_function_def ();
  #if defined (DPAREN_ARITHMETIC)
! static void print_arith_command ();
  #endif
  #if defined (COND_COMMAND)
! static void print_cond_node ();
! static void print_cond_command ();
! #endif
! #if defined (ARITH_FOR_COMMAND)
! static void print_arith_for_command ();
  #endif
  
  #define PRINTED_COMMAND_INITIAL_SIZE 64
--- 52,99 ----
  
  #if defined (PREFER_STDARG)
! typedef void PFUNC __P((const char *, ...));
! 
! static void cprintf __P((const char *, ...))  __attribute__((__format__ (printf, 1, 2)));
! static void xprintf __P((const char *, ...))  __attribute__((__format__ (printf, 1, 2)));
  #else
+ #define PFUNC VFunction
  static void cprintf ();
  static void xprintf ();
+ #endif
  
! static void reset_locals __P((void));
! static void newline __P((char *));
! static void indent __P((int));
! static void semicolon __P((void));
! static void the_printed_command_resize __P((int));
! 
! static void make_command_string_internal __P((COMMAND *));
! static void _print_word_list __P((WORD_LIST *, char *, PFUNC *));
! static void command_print_word_list __P((WORD_LIST *, char *));
! static void print_case_clauses __P((PATTERN_LIST *));
! static void print_redirection_list __P((REDIRECT *));
! static void print_redirection __P((REDIRECT *));
  
! static void print_for_command __P((FOR_COM *));
! #if defined (ARITH_FOR_COMMAND)
! static void print_arith_for_command __P((ARITH_FOR_COM *));
! #endif
  #if defined (SELECT_COMMAND)
! static void print_select_command __P((SELECT_COM *));
  #endif
! static void print_group_command __P((GROUP_COM *));
! static void print_case_command __P((CASE_COM *));
! static void print_while_command __P((WHILE_COM *));
! static void print_until_command __P((WHILE_COM *));
! static void print_until_or_while __P((WHILE_COM *, char *));
! static void print_if_command __P((IF_COM *));
  #if defined (DPAREN_ARITHMETIC)
! static void print_arith_command __P((ARITH_COM *));
  #endif
  #if defined (COND_COMMAND)
! static void print_cond_node __P((COND_COM *));
! static void print_cond_command __P((COND_COM *));
  #endif
+ static void print_function_def __P((FUNCTION_DEF *));
  
  #define PRINTED_COMMAND_INITIAL_SIZE 64
***************
*** 291,295 ****
       WORD_LIST *list;
       char *separator;
!      VFunction *pfunc;
  {
    WORD_LIST *w;
--- 299,303 ----
       WORD_LIST *list;
       char *separator;
!      PFUNC *pfunc;
  {
    WORD_LIST *w;
***************
*** 808,811 ****
--- 816,820 ----
    REDIRECT *func_redirects;
  
+   func_redirects = NULL;
    cprintf ("function %s () \n", func->name->word);
    add_unwind_protect (reset_locals, 0);
***************
*** 971,979 ****
  static void
  cprintf (format, arg1, arg2)
!      char *format, *arg1, *arg2;
  {
!   register char *s;
!   char char_arg[2], *argp, *args[2], intbuf[32];
!   int arg_len, c, arg_index;
  
    args[arg_index = 0] = arg1;
--- 980,989 ----
  static void
  cprintf (format, arg1, arg2)
!      const char *format;
!      char *arg1, *arg2;
  {
!   register const char *s;
!   char char_arg[2], *argp, *args[2], intbuf[INT_STRLEN_BOUND(int) + 1];
!   int arg_len, c, arg_index, digit_arg;
  
    args[arg_index = 0] = arg1;
***************
*** 991,995 ****
        if (c != '%' || !*s)
  	{
! 	  argp = s;
  	  arg_len = 1;
  	}
--- 1001,1006 ----
        if (c != '%' || !*s)
  	{
! 	  char_arg[0] = c;
! 	  argp = char_arg;
  	  arg_len = 1;
  	}
***************
*** 1011,1015 ****
  
  	    case 'd':
! 	      argp = inttostr (pointer_to_int (args[arg_index]), intbuf, sizeof (intbuf));
  	      arg_index++;
  	      arg_len = strlen (argp);
--- 1022,1037 ----
  
  	    case 'd':
! 	      /* Represent an out-of-range file descriptor with an out-of-range
! 		 integer value.  We can do this because the only use of `%d' in
! 		 the calls to cprintf is to output a file descriptor number for
! 		 a redirection. */
! 	      digit_arg = pointer_to_int (args[arg_index]);
! 	      if (digit_arg < 0)
! 		{
! 		  sprintf (intbuf, "%u", (unsigned)-1);
! 		  argp = intbuf;
! 		}
! 	      else
! 	        argp = inttostr (digit_arg, intbuf, sizeof (intbuf));
  	      arg_index++;
  	      arg_len = strlen (argp);
***************
*** 1045,1057 ****
  static void
  #if defined (PREFER_STDARG)
! cprintf (char *control, ...)
  #else
  cprintf (control, va_alist)
!      char *control;
       va_dcl
  #endif
  {
!   register char *s;
!   char char_arg[2], *argp, intbuf[32];
    int digit_arg, arg_len, c;
    va_list args;
--- 1067,1079 ----
  static void
  #if defined (PREFER_STDARG)
! cprintf (const char *control, ...)
  #else
  cprintf (control, va_alist)
!      const char *control;
       va_dcl
  #endif
  {
!   register const char *s;
!   char char_arg[2], *argp, intbuf[INT_STRLEN_BOUND (int) + 1];
    int digit_arg, arg_len, c;
    va_list args;
***************
*** 1076,1080 ****
        if (c != '%' || !*s)
  	{
! 	  argp = s - 1;
  	  arg_len = 1;
  	}
--- 1098,1103 ----
        if (c != '%' || !*s)
  	{
! 	  char_arg[0] = c;
! 	  argp = char_arg;
  	  arg_len = 1;
  	}
***************
*** 1096,1101 ****
  
  	    case 'd':
  	      digit_arg = va_arg (args, int);
! 	      argp = inttostr (digit_arg, intbuf, sizeof (intbuf));
  	      arg_len = strlen (argp);
  	      break;
--- 1119,1134 ----
  
  	    case 'd':
+ 	      /* Represent an out-of-range file descriptor with an out-of-range
+ 		 integer value.  We can do this because the only use of `%d' in
+ 		 the calls to cprintf is to output a file descriptor number for
+ 		 a redirection. */
  	      digit_arg = va_arg (args, int);
! 	      if (digit_arg < 0)
! 		{
! 		  sprintf (intbuf, "%u", (unsigned)-1);
! 		  argp = intbuf;
! 		}
! 	      else
! 	        argp = inttostr (digit_arg, intbuf, sizeof (intbuf));
  	      arg_len = strlen (argp);
  	      break;
***************
*** 1136,1140 ****
      {
        the_printed_command_size = (length + PRINTED_COMMAND_INITIAL_SIZE - 1) & ~(PRINTED_COMMAND_INITIAL_SIZE - 1);
!       the_printed_command = xmalloc (the_printed_command_size);
        command_string_index = 0;
      }
--- 1169,1173 ----
      {
        the_printed_command_size = (length + PRINTED_COMMAND_INITIAL_SIZE - 1) & ~(PRINTED_COMMAND_INITIAL_SIZE - 1);
!       the_printed_command = (char *)xmalloc (the_printed_command_size);
        command_string_index = 0;
      }
***************
*** 1148,1156 ****
        the_printed_command_size = new;
  
!       the_printed_command = xrealloc (the_printed_command, the_printed_command_size);
      }
  }
  
! #if defined (HAVE_VFPRINTF)
  
  static void
--- 1181,1191 ----
        the_printed_command_size = new;
  
!       the_printed_command = (char *)xrealloc (the_printed_command, the_printed_command_size);
      }
  }
  
! #if defined (HAVE_VPRINTF)
! /* ``If vprintf is available, you may assume that vfprintf and vsprintf are
!      also available.'' */
  
  static void
***************
*** 1179,1186 ****
  static void
  xprintf (format, arg1, arg2, arg3, arg4, arg5)
!      char *format;
  {
    printf (format, arg1, arg2, arg3, arg4, arg5);
  }
  
! #endif /* !HAVE_VFPRINTF */
--- 1214,1221 ----
  static void
  xprintf (format, arg1, arg2, arg3, arg4, arg5)
!      const char *format;
  {
    printf (format, arg1, arg2, arg3, arg4, arg5);
  }
  
! #endif /* !HAVE_VPRINTF */
diff -Nrc2 bash-2.05/quit.h bash-2.05a/quit.h
*** bash-2.05/quit.h	Thu Aug  5 07:12:15 1999
--- bash-2.05a/quit.h	Mon Sep 10 10:08:33 2001
***************
*** 25,30 ****
  extern int interrupt_state;
  
- extern void throw_to_top_level ();
- 
  /* Macro to call a great deal.  SIGINT just sets above variable.  When
     it is safe, put QUIT in the code, and the "interrupt" will take place. */
--- 25,28 ----
diff -Nrc2 bash-2.05/redir.c bash-2.05a/redir.c
*** bash-2.05/redir.c	Tue Mar 27 09:43:50 2001
--- bash-2.05a/redir.c	Tue Oct  2 15:02:00 2001
***************
*** 55,69 ****
  
  extern int posixly_correct;
- extern int interactive, interactive_shell;
  extern REDIRECT *redirection_undo_list;
  extern REDIRECT *exec_redirection_undo_list;
  
  /* Static functions defined and used in this file. */
! static void add_undo_close_redirect ();
! static void add_exec_redirect ();
! static int add_undo_redirect ();
! static int do_redirection_internal ();
! static int expandable_redirection_filename ();
! static int stdin_redirection ();
  
  /* Spare redirector used when translating [N]>&WORD or [N]<&WORD to a new
--- 55,75 ----
  
  extern int posixly_correct;
  extern REDIRECT *redirection_undo_list;
  extern REDIRECT *exec_redirection_undo_list;
  
  /* Static functions defined and used in this file. */
! static void add_undo_close_redirect __P((int));
! static void add_exec_redirect __P((REDIRECT *));
! static int add_undo_redirect __P((int));
! static int expandable_redirection_filename __P((REDIRECT *));
! static int stdin_redirection __P((enum r_instruction, int));
! static int do_redirection_internal __P((REDIRECT *, int, int, int));
! 
! static int write_here_document __P((int, WORD_DESC *));
! static int here_document_to_fd __P((WORD_DESC *));
! 
! static int redir_special_open __P((int, char *, int, int, enum r_instruction));
! static int noclobber_open __P((char *, int, int, enum r_instruction));
! static int redir_open __P((char *, int, int, enum r_instruction));
  
  /* Spare redirector used when translating [N]>&WORD or [N]<&WORD to a new
***************
*** 80,87 ****
       int error;
  {
!   char *filename;
    int oflags;
  
!   if (expandable_redirection_filename (temp))
      {
        if (posixly_correct && interactive_shell == 0)
--- 86,102 ----
       int error;
  {
!   char *filename, *allocname;
    int oflags;
  
!   allocname = 0;
!   if (temp->redirector < 0)
!     /* This can happen when read_token_word encounters overflow, like in
!        exec 4294967297>x */
!     filename = "file descriptor out of range";
! #ifdef EBADF
!   else if (temp->redirector >= 0 && errno == EBADF)
!     filename = allocname = itos (temp->redirector);
! #endif
!   else if (expandable_redirection_filename (temp))
      {
        if (posixly_correct && interactive_shell == 0)
***************
*** 90,106 ****
  	  temp->redirectee.filename->flags |= W_NOGLOB;
  	}
!       filename = redirection_expand (temp->redirectee.filename);
        if (posixly_correct && interactive_shell == 0)
  	temp->redirectee.filename->flags = oflags;
        if (filename == 0)
! 	filename = savestring (temp->redirectee.filename->word);
!       if (filename == 0)
! 	{
! 	  filename = xmalloc (1);
! 	  filename[0] = '\0';
! 	}
      }
    else
!     filename = itos (temp->redirectee.dest);
  
    switch (error)
--- 105,118 ----
  	  temp->redirectee.filename->flags |= W_NOGLOB;
  	}
!       filename = allocname = redirection_expand (temp->redirectee.filename);
        if (posixly_correct && interactive_shell == 0)
  	temp->redirectee.filename->flags = oflags;
        if (filename == 0)
! 	filename = temp->redirectee.filename->word;
      }
+   else if (temp->redirectee.dest < 0)
+     filename = "file descriptor out of range";
    else
!     filename = allocname = itos (temp->redirectee.dest);
  
    switch (error)
***************
*** 129,133 ****
      }
  
!   FREE (filename);
  }
  
--- 141,145 ----
      }
  
!   FREE (allocname);
  }
  
***************
*** 290,295 ****
  	    }
  	}
-       fclose (fp);
        dispose_words (tlist);
      }
    return 0;
--- 302,312 ----
  	    }
  	}
        dispose_words (tlist);
+       if (fclose (fp) != 0)
+ 	{
+ 	  if (errno == 0)
+ 	    errno = ENOSPC;
+ 	  return (errno);
+ 	}
      }
    return 0;
***************
*** 305,309 ****
    char *filename;
    int r, fd, fd2;
-   static int fnum = 0;
  
    fd = sh_mktmpfd ("sh-thd", MT_USERANDOM, &filename);
--- 322,325 ----
***************
*** 400,404 ****
--- 416,422 ----
  {
    int fd;
+ #if !defined (HAVE_DEV_FD)
    long lfd;
+ #endif
  
    fd = -1;
***************
*** 407,412 ****
  #if !defined (HAVE_DEV_FD)
      case RF_DEVFD:
!       if (legal_number, filename+8, &lfd)
! 	fd = fcntl ((int)lfd, F_DUPFD, 10);
        else
  	fd = AMBIGUOUS_REDIRECT;
--- 425,433 ----
  #if !defined (HAVE_DEV_FD)
      case RF_DEVFD:
!       if (all_digits (filename+8) && legal_number (filename+8, &lfd) && lfd == (int)lfd)
! 	{
! 	  fd = lfd;
! 	  fd = fcntl (fd, F_DUPFD, 10);
! 	}
        else
  	fd = AMBIGUOUS_REDIRECT;
***************
*** 542,545 ****
--- 563,567 ----
    WORD_DESC *redirectee;
    int redir_fd, fd, redirector, r, oflags;
+   long lfd;
    char *redirectee_word;
    enum r_instruction ri;
***************
*** 561,579 ****
        else if (redirectee_word[0] == '-' && redirectee_word[1] == '\0')
  	{
! 	  rd.dest = 0L;
  	  new_redirect = make_redirection (redirector, r_close_this, rd);
  	}
        else if (all_digits (redirectee_word))
  	{
! 	  if (ri == r_duplicating_input_word)
! 	    {
! 	      rd.dest = atol (redirectee_word);
! 	      new_redirect = make_redirection (redirector, r_duplicating_input, rd);
! 	    }
  	  else
! 	    {
! 	      rd.dest = atol (redirectee_word);
! 	      new_redirect = make_redirection (redirector, r_duplicating_output, rd);
! 	    }
  	}
        else if (ri == r_duplicating_output_word && redirector == 1)
--- 583,600 ----
        else if (redirectee_word[0] == '-' && redirectee_word[1] == '\0')
  	{
! 	  rd.dest = 0;
  	  new_redirect = make_redirection (redirector, r_close_this, rd);
  	}
        else if (all_digits (redirectee_word))
  	{
! 	  if (legal_number (redirectee_word, &lfd) && (int)lfd == lfd)
! 	    rd.dest = lfd;
  	  else
! 	    rd.dest = -1;	/* XXX */
! 	  new_redirect = make_redirection (redirector,
! 					   (ri == r_duplicating_input_word
! 						? r_duplicating_input
! 						: r_duplicating_output),
! 					   rd);		
  	}
        else if (ri == r_duplicating_output_word && redirector == 1)
***************
*** 661,669 ****
  	{
  	  if (remembering)
! 	    /* Only setup to undo it if the thing to undo is active. */
! 	    if ((fd != redirector) && (fcntl (redirector, F_GETFD, 0) != -1))
! 	      add_undo_redirect (redirector);
! 	    else
! 	      add_undo_close_redirect (redirector);
  
  #if defined (BUFFERED_INPUT)
--- 682,692 ----
  	{
  	  if (remembering)
! 	    {
! 	      /* Only setup to undo it if the thing to undo is active. */
! 	      if ((fd != redirector) && (fcntl (redirector, F_GETFD, 0) != -1))
! 		add_undo_redirect (redirector);
! 	      else
! 		add_undo_close_redirect (redirector);
! 	    }
  
  #if defined (BUFFERED_INPUT)
***************
*** 737,745 ****
  	    {
  	      if (remembering)
! 		/* Only setup to undo it if the thing to undo is active. */
! 		if ((fd != redirector) && (fcntl (redirector, F_GETFD, 0) != -1))
! 		  add_undo_redirect (redirector);
! 		else
! 		  add_undo_close_redirect (redirector);
  
  #if defined (BUFFERED_INPUT)
--- 760,770 ----
  	    {
  	      if (remembering)
! 	        {
! 		  /* Only setup to undo it if the thing to undo is active. */
! 		  if ((fd != redirector) && (fcntl (redirector, F_GETFD, 0) != -1))
! 		    add_undo_redirect (redirector);
! 		  else
! 		    add_undo_close_redirect (redirector);
! 	        }
  
  #if defined (BUFFERED_INPUT)
***************
*** 775,783 ****
  	{
  	  if (remembering)
! 	    /* Only setup to undo it if the thing to undo is active. */
! 	    if (fcntl (redirector, F_GETFD, 0) != -1)
! 	      add_undo_redirect (redirector);
! 	    else
! 	      add_undo_close_redirect (redirector);
  
  #if defined (BUFFERED_INPUT)
--- 800,810 ----
  	{
  	  if (remembering)
! 	    {
! 	      /* Only setup to undo it if the thing to undo is active. */
! 	      if (fcntl (redirector, F_GETFD, 0) != -1)
! 		add_undo_redirect (redirector);
! 	      else
! 		add_undo_close_redirect (redirector);
! 	    }
  
  #if defined (BUFFERED_INPUT)
***************
*** 852,860 ****
    clexec_flag = fcntl (fd, F_GETFD, 0);
  
!   rd.dest = 0L;
    closer = make_redirection (new_fd, r_close_this, rd);
    dummy_redirect = copy_redirects (closer);
  
!   rd.dest = (long)new_fd;
    if (fd == 0)
      new_redirect = make_redirection (fd, r_duplicating_input, rd);
--- 879,887 ----
    clexec_flag = fcntl (fd, F_GETFD, 0);
  
!   rd.dest = 0;
    closer = make_redirection (new_fd, r_close_this, rd);
    dummy_redirect = copy_redirects (closer);
  
!   rd.dest = new_fd;
    if (fd == 0)
      new_redirect = make_redirection (fd, r_duplicating_input, rd);
***************
*** 892,896 ****
    REDIRECT *closer;
  
!   rd.dest = 0L;
    closer = make_redirection (fd, r_close_this, rd);
    closer->next = redirection_undo_list;
--- 919,923 ----
    REDIRECT *closer;
  
!   rd.dest = 0;
    closer = make_redirection (fd, r_close_this, rd);
    closer->next = redirection_undo_list;
diff -Nrc2 bash-2.05/redir.h bash-2.05a/redir.h
*** bash-2.05/redir.h	Thu Aug  5 07:12:57 1999
--- bash-2.05a/redir.h	Thu Sep  6 16:00:49 2001
***************
*** 27,31 ****
  extern int do_redirections __P((REDIRECT *, int, int, int));
  extern char *redirection_expand __P((WORD_DESC *));
! extern int stdin_redirs __P((REDIRECT *));
  
  #endif /* _REDIR_H_ */
--- 27,31 ----
  extern int do_redirections __P((REDIRECT *, int, int, int));
  extern char *redirection_expand __P((WORD_DESC *));
! extern int stdin_redirects __P((REDIRECT *));
  
  #endif /* _REDIR_H_ */
diff -Nrc2 bash-2.05/shell.c bash-2.05a/shell.c
*** bash-2.05/shell.c	Tue Mar 27 09:25:51 2001
--- bash-2.05a/shell.c	Thu Nov  1 09:13:16 2001
***************
*** 32,35 ****
--- 32,36 ----
  #endif
  #include "posixstat.h"
+ #include "posixtime.h"
  #include "bashansi.h"
  #include <stdio.h>
***************
*** 43,46 ****
--- 44,49 ----
  #endif
  
+ #define NEED_SH_SETLINEBUF_DECL		/* used in externs.h */
+ 
  #include "shell.h"
  #include "flags.h"
***************
*** 64,68 ****
  
  #include <tilde/tilde.h>
! #include <glob/fnmatch.h>
  
  #if defined (__OPENNT)
--- 67,71 ----
  
  #include <tilde/tilde.h>
! #include <glob/strmatch.h>
  
  #if defined (__OPENNT)
***************
*** 102,106 ****
  struct user_info current_user =
  {
!   -1, -1, -1, -1, (char *)NULL, (char *)NULL, (char *)NULL
  };
  
--- 105,110 ----
  struct user_info current_user =
  {
!   (uid_t)-1, (uid_t)-1, (gid_t)-1, (gid_t)-1,
!   (char *)NULL, (char *)NULL, (char *)NULL
  };
  
***************
*** 242,263 ****
  static FILE *default_input;
  
! static int parse_long_options ();
! static int parse_shell_options ();
! static void run_startup_files ();
! static int bind_args ();
! static int open_shell_script ();
! static void set_bash_input ();
! static int run_one_command ();
! static int run_wordexp ();
! 
! static int uidget ();
! static int isnetconn ();
! 
! static void init_interactive (), init_noninteractive ();
! static void set_shell_name ();
! static void shell_initialize ();
! static void shell_reinitialize ();
  
! static void show_shell_usage ();
  
  #ifdef __CYGWIN__
--- 246,277 ----
  static FILE *default_input;
  
! static STRING_INT_ALIST *shopt_alist;
! static int shopt_ind = 0, shopt_len = 0;
! 
! static int parse_long_options __P((char **, int, int));
! static int parse_shell_options __P((char **, int, int));
! static int bind_args __P((char **, int, int, int));
! 
! static void add_shopt_to_alist __P((char *, int));
! static void run_shopt_alist __P((void));
! 
! static void execute_env_file __P((char *));
! static void run_startup_files __P((void));
! static int open_shell_script __P((char *));
! static void set_bash_input __P((void));
! static int run_one_command __P((char *));
! static int run_wordexp __P((char *));
! 
! static int uidget __P((void));
! static int isnetconn __P((int));
! 
! static void init_interactive __P((void));
! static void init_noninteractive __P((void));
! 
! static void set_shell_name __P((char *));
! static void shell_initialize __P((void));
! static void shell_reinitialize __P((void));
  
! static void show_shell_usage __P((FILE *, int));
  
  #ifdef __CYGWIN__
***************
*** 291,295 ****
  {
    register int i;
!   int code, saverst, old_errexit_flag;
    volatile int locally_skip_execution;
    volatile int arg_index, top_level_arg_index;
--- 305,312 ----
  {
    register int i;
!   int code, old_errexit_flag;
! #if defined (RESTRICTED_SHELL)
!   int saverst;
! #endif
    volatile int locally_skip_execution;
    volatile int arg_index, top_level_arg_index;
***************
*** 300,303 ****
--- 317,329 ----
  #endif /* __OPENNT */
  
+   USE_VAR(argc);
+   USE_VAR(argv);
+   USE_VAR(env);
+   USE_VAR(code);
+   USE_VAR(old_errexit_flag);
+ #if defined (RESTRICTED_SHELL)
+   USE_VAR(saverst);
+ #endif
+ 
    /* Catch early SIGINTs. */
    code = setjmp (top_level);
***************
*** 305,308 ****
--- 331,344 ----
      exit (2);
  
+ #if defined (USING_BASH_MALLOC) && defined (DEBUG)
+ #  if 0		/* memory tracing */
+   malloc_set_trace(1);
+ #  endif
+ 
+ #  if 0
+   malloc_set_register (1);
+ #  endif
+ #endif
+ 
    check_dev_tty ();
  
***************
*** 389,392 ****
--- 425,430 ----
      }
  
+   set_login_shell (login_shell != 0);
+ 
    /* All done with full word options; do standard shell option parsing.*/
    this_command_name = shell_name;	/* for error reporting */
***************
*** 461,464 ****
--- 499,506 ----
      }
  
+   /* Now we run the shopt_alist and process the options. */
+   if (shopt_alist)
+     run_shopt_alist ();
+ 
    /* From here on in, the shell must be a normal functioning shell.
       Variables from the environment are expected to be set, etc. */
***************
*** 474,478 ****
        no_line_editing |= term && (STREQ (term, "emacs"));
        term = getenv ("EMACS");
!       running_under_emacs = term ? ((fnmatch ("*term*", term, 0) == 0) ? 2 : 1)
  				 : 0;
      }
--- 516,520 ----
        no_line_editing |= term && (STREQ (term, "emacs"));
        term = getenv ("EMACS");
!       running_under_emacs = term ? ((strmatch ("*term*", term, 0) == 0) ? 2 : 1)
  				 : 0;
      }
***************
*** 569,572 ****
--- 611,615 ----
        startup_state = 2;
  #if defined (ONESHOT)
+       executing = 1;
        run_one_command (local_pending_command);
        exit_shell (last_command_exit_value);
***************
*** 733,736 ****
--- 776,794 ----
  	      break;
  
+ 	    case 'O':
+ 	      /* Since some of these can be overridden by the normal
+ 		 interactive/non-interactive shell initialization or
+ 		 initializing posix mode, we save the options and process
+ 		 them after initialization. */
+ 	      o_option = argv[next_arg];
+ 	      if (o_option == 0)
+ 		{
+ 		  shopt_listopt (o_option, (on_or_off == '-') ? 0 : 1);
+ 		  break;
+ 		}
+ 	      add_shopt_to_alist (o_option, on_or_off);
+ 	      next_arg++;
+ 	      break;
+ 
  	    case 'D':
  	      dump_translatable_strings = 1;
***************
*** 791,794 ****
--- 849,853 ----
  }
  
+ #ifdef INCLUDE_UNUSED
  /* A wrapper for exit that (optionally) can do other things, like malloc
     statistics tracing. */
***************
*** 799,802 ****
--- 858,862 ----
    exit (s);
  }
+ #endif
  
  /* Source the bash startup files.  If POSIXLY_CORRECT is non-zero, we obey
***************
*** 832,849 ****
  {
    char *fn;
-   WORD_LIST *list;
  
    if (env_file && *env_file)
      {
!       list = expand_string_unsplit (env_file, Q_DOUBLE_QUOTES);
!       if (list)
! 	{
! 	  fn = string_list (list);
! 	  dispose_words (list);
! 
! 	  if (fn && *fn)
! 	    maybe_execute_file (fn, 1);
! 	  FREE (fn);
! 	}
      }
  }
--- 892,902 ----
  {
    char *fn;
  
    if (env_file && *env_file)
      {
!       fn = expand_string_unsplit_to_string (env_file, Q_DOUBLE_QUOTES);
!       if (fn && *fn)
! 	maybe_execute_file (fn, 1);
!       FREE (fn);
      }
  }
***************
*** 861,866 ****
        act_like_sh == 0 && local_pending_command)
      {
!       run_by_ssh = find_variable ("SSH_CLIENT") != (SHELL_VAR *)0;
!       run_by_ssh |= find_variable ("SSH2_CLIENT") != (SHELL_VAR *)0;
  
        /* If we were run by sshd or we think we were run by rshd, execute
--- 914,923 ----
        act_like_sh == 0 && local_pending_command)
      {
! #ifdef SSH_SOURCE_BASHRC
!       run_by_ssh = (find_variable ("SSH_CLIENT") != (SHELL_VAR *)0) ||
! 		   (find_variable ("SSH2_CLIENT") != (SHELL_VAR *)0);
! #else
!       run_by_ssh = 0;
! #endif
  
        /* If we were run by sshd or we think we were run by rshd, execute
***************
*** 1059,1063 ****
  {
    int code, nw, nb;
-   WORD_DESC *w;
    WORD_LIST *wl, *result;
  
--- 1116,1119 ----
***************
*** 1199,1203 ****
    int fd, e, fd_is_tty;
    char *filename, *path_filename;
!   unsigned char sample[80];
    int sample_len;
    struct stat sb;
--- 1255,1259 ----
    int fd, e, fd_is_tty;
    char *filename, *path_filename;
!   char sample[80];
    int sample_len;
    struct stat sb;
***************
*** 1305,1308 ****
--- 1361,1369 ----
  #endif
      }
+   else if (forced_interactive && fd_is_tty == 0)
+     /* But if a script is called with something like `bash -i scriptname',
+        we need to do a non-interactive setup here, since we didn't do it
+        before. */
+     init_noninteractive ();
  
    free (filename);
***************
*** 1583,1587 ****
  
    fputs ("Shell options:\n", fp);
!   fputs ("\t-irsD or -c command\t\t(invocation only)\n", fp);
  
    for (i = 0, set_opts = 0; shell_builtins[i].name; i++)
--- 1644,1648 ----
  
    fputs ("Shell options:\n", fp);
!   fputs ("\t-irsD or -c command or -O shopt_option\t\t(invocation only)\n", fp);
  
    for (i = 0, set_opts = 0; shell_builtins[i].name; i++)
***************
*** 1610,1613 ****
--- 1671,1702 ----
  }
  
+ static void
+ add_shopt_to_alist (opt, on_or_off)
+      char *opt;
+      int on_or_off;
+ {
+   if (shopt_ind >= shopt_len)
+     {
+       shopt_len += 8;
+       shopt_alist = (STRING_INT_ALIST *)xrealloc (shopt_alist, shopt_len * sizeof (shopt_alist[0]));
+     }
+   shopt_alist[shopt_ind].word = opt;
+   shopt_alist[shopt_ind].token = on_or_off;
+   shopt_ind++;
+ }
+ 
+ static void
+ run_shopt_alist ()
+ {
+   register int i;
+ 
+   for (i = 0; i < shopt_ind; i++)
+     if (shopt_setopt (shopt_alist[i].word, (shopt_alist[i].token == '-')) != EXECUTION_SUCCESS)
+       exit (EX_USAGE);
+   free (shopt_alist);
+   shopt_alist = 0;
+   shopt_ind = shopt_len = 0;
+ }
+ 
  /* The second and subsequent conditions must match those used to decide
     whether or not to call getpeername() in isnetconn(). */
***************
*** 1622,1626 ****
  {
  #if defined (HAVE_GETPEERNAME) && !defined (SVR4_2) && !defined (__BEOS__)
!   int rv, l;
    struct sockaddr sa;
  
--- 1711,1716 ----
  {
  #if defined (HAVE_GETPEERNAME) && !defined (SVR4_2) && !defined (__BEOS__)
!   int rv;
!   socklen_t l;
    struct sockaddr sa;
  
diff -Nrc2 bash-2.05/shell.h bash-2.05a/shell.h
*** bash-2.05/shell.h	Sat Oct 14 17:33:01 2000
--- bash-2.05a/shell.h	Wed Oct 31 10:27:27 2001
***************
*** 19,23 ****
--- 19,25 ----
     Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. */
  
+ #ifdef HAVE_CONFIG_H
  #include "config.h"
+ #endif
  
  #include "bashjmp.h"
***************
*** 28,31 ****
--- 30,34 ----
  #include "error.h"
  #include "variables.h"
+ #include "arrayfunc.h"
  #include "quit.h"
  #include "maxpath.h"
***************
*** 37,40 ****
--- 40,44 ----
  #include "pathnames.h"
  #include "externs.h"
+ #include "version.h"
  
  extern int EOF_Reached;
***************
*** 42,46 ****
  #define NO_PIPE -1
  #define REDIRECT_BOTH -2
- #define IS_DESCRIPTOR -1
  
  #define NO_VARIABLE -1
--- 46,49 ----
***************
*** 83,91 ****
  /* Generalized global variables. */
  extern int executing, login_shell;
  
  /* Structure to pass around that holds a bitmap of file descriptors
     to close, and the size of that structure.  Used in execute_cmd.c. */
  struct fd_bitmap {
!   long size;
    char *bitmap;
  };
--- 86,95 ----
  /* Generalized global variables. */
  extern int executing, login_shell;
+ extern int interactive, interactive_shell;
  
  /* Structure to pass around that holds a bitmap of file descriptors
     to close, and the size of that structure.  Used in execute_cmd.c. */
  struct fd_bitmap {
!   int size;
    char *bitmap;
  };
***************
*** 106,107 ****
--- 110,119 ----
  
  extern struct user_info current_user;
+ 
+ /* Force gcc to not clobber X on a longjmp().  Old versions of gcc mangle
+    this badly. */
+ #if __GNUC__ == 2 && __GNUC_MINOR__ > 8
+ #  define USE_VAR(x)	((void) &(x))
+ #else
+ #  define USE_VAR(x)
+ #endif
diff -Nrc2 bash-2.05/sig.c bash-2.05a/sig.c
*** bash-2.05/sig.c	Mon Mar 26 11:01:55 2001
--- bash-2.05a/sig.c	Mon Sep 10 15:11:18 2001
***************
*** 55,59 ****
  extern int loop_level, continuing, breaking;
  extern int parse_and_execute_level, shell_initialized;
! extern int interactive, interactive_shell, login_shell, startup_state;
  
  /* Non-zero after SIGINT. */
--- 55,59 ----
  extern int loop_level, continuing, breaking;
  extern int parse_and_execute_level, shell_initialized;
! extern int startup_state;
  
  /* Non-zero after SIGINT. */
***************
*** 72,76 ****
  int interrupt_immediately = 0;
  
! static void initialize_shell_signals ();
  
  void
--- 72,76 ----
  int interrupt_immediately = 0;
  
! static void initialize_shell_signals __P((void));
  
  void
***************
*** 87,91 ****
  reinitialize_signals ()
  {
!   initialize_shell_signals (1);
    initialize_job_signals ();
  }
--- 87,91 ----
  reinitialize_signals ()
  {
!   initialize_shell_signals ();
    initialize_job_signals ();
  }
***************
*** 106,192 ****
  static struct termsig terminating_signals[] = {
  #ifdef SIGHUP
!   SIGHUP, NULL_HANDLER,
  #endif
  
  #ifdef SIGINT
!   SIGINT, NULL_HANDLER,
  #endif
  
  #ifdef SIGILL
!   SIGILL, NULL_HANDLER,
  #endif
  
  #ifdef SIGTRAP
!   SIGTRAP, NULL_HANDLER,
  #endif
  
  #ifdef SIGIOT
!   SIGIOT, NULL_HANDLER,
  #endif
  
  #ifdef SIGDANGER
!   SIGDANGER, NULL_HANDLER,
  #endif
  
  #ifdef SIGEMT
!   SIGEMT, NULL_HANDLER,
  #endif
  
  #ifdef SIGFPE
!   SIGFPE, NULL_HANDLER,
  #endif
  
  #ifdef SIGBUS
!   SIGBUS, NULL_HANDLER,
  #endif
  
  #ifdef SIGSEGV
!   SIGSEGV, NULL_HANDLER,
  #endif
  
  #ifdef SIGSYS
!   SIGSYS, NULL_HANDLER,
  #endif
  
  #ifdef SIGPIPE
!   SIGPIPE, NULL_HANDLER,
  #endif
  
  #ifdef SIGALRM
!   SIGALRM, NULL_HANDLER,
  #endif
  
  #ifdef SIGTERM
!   SIGTERM, NULL_HANDLER,
  #endif
  
  #ifdef SIGXCPU
!   SIGXCPU, NULL_HANDLER,
  #endif
  
  #ifdef SIGXFSZ
!   SIGXFSZ, NULL_HANDLER,
  #endif
  
  #ifdef SIGVTALRM
!   SIGVTALRM, NULL_HANDLER,
  #endif
  
  #if 0
  #ifdef SIGPROF
!   SIGPROF, NULL_HANDLER,
  #endif
  #endif
  
  #ifdef SIGLOST
!   SIGLOST, NULL_HANDLER,
  #endif
  
  #ifdef SIGUSR1
!   SIGUSR1, NULL_HANDLER,
  #endif
  
  #ifdef SIGUSR2
!   SIGUSR2, NULL_HANDLER,
  #endif
  };
--- 106,192 ----
  static struct termsig terminating_signals[] = {
  #ifdef SIGHUP
! {  SIGHUP, NULL_HANDLER },
  #endif
  
  #ifdef SIGINT
! {  SIGINT, NULL_HANDLER },
  #endif
  
  #ifdef SIGILL
! {  SIGILL, NULL_HANDLER },
  #endif
  
  #ifdef SIGTRAP
! {  SIGTRAP, NULL_HANDLER },
  #endif
  
  #ifdef SIGIOT
! {  SIGIOT, NULL_HANDLER },
  #endif
  
  #ifdef SIGDANGER
! {  SIGDANGER, NULL_HANDLER },
  #endif
  
  #ifdef SIGEMT
! {  SIGEMT, NULL_HANDLER },
  #endif
  
  #ifdef SIGFPE
! {  SIGFPE, NULL_HANDLER },
  #endif
  
  #ifdef SIGBUS
! {  SIGBUS, NULL_HANDLER },
  #endif
  
  #ifdef SIGSEGV
! {  SIGSEGV, NULL_HANDLER },
  #endif
  
  #ifdef SIGSYS
! {  SIGSYS, NULL_HANDLER },
  #endif
  
  #ifdef SIGPIPE
! {  SIGPIPE, NULL_HANDLER },
  #endif
  
  #ifdef SIGALRM
! {  SIGALRM, NULL_HANDLER },
  #endif
  
  #ifdef SIGTERM
! {  SIGTERM, NULL_HANDLER },
  #endif
  
  #ifdef SIGXCPU
! {  SIGXCPU, NULL_HANDLER },
  #endif
  
  #ifdef SIGXFSZ
! {  SIGXFSZ, NULL_HANDLER },
  #endif
  
  #ifdef SIGVTALRM
! {  SIGVTALRM, NULL_HANDLER },
  #endif
  
  #if 0
  #ifdef SIGPROF
! {  SIGPROF, NULL_HANDLER },
  #endif
  #endif
  
  #ifdef SIGLOST
! {  SIGLOST, NULL_HANDLER },
  #endif
  
  #ifdef SIGUSR1
! {  SIGUSR1, NULL_HANDLER },
  #endif
  
  #ifdef SIGUSR2
! {  SIGUSR2, NULL_HANDLER },
  #endif
  };
diff -Nrc2 bash-2.05/sig.h bash-2.05a/sig.h
*** bash-2.05/sig.h	Thu Aug  5 07:14:07 1999
--- bash-2.05a/sig.h	Mon Oct 15 09:38:48 2001
***************
*** 115,119 ****
  extern void reset_terminating_signals __P((void));
  extern void throw_to_top_level __P((void));
! extern void jump_to_top_level __P((int));
  
  /* Functions defined in trap.c. */
--- 115,119 ----
  extern void reset_terminating_signals __P((void));
  extern void throw_to_top_level __P((void));
! extern void jump_to_top_level __P((int)) __attribute__((__noreturn__));
  
  /* Functions defined in trap.c. */
diff -Nrc2 bash-2.05/siglist.c bash-2.05a/siglist.c
*** bash-2.05/siglist.c	Thu Aug  5 07:23:09 1999
--- bash-2.05a/siglist.c	Thu Aug  2 12:11:36 2001
***************
*** 33,39 ****
  #endif
  
! char *sys_siglist[NSIG];
  
! extern char *xmalloc (), *malloc ();
  
  void
--- 33,39 ----
  #endif
  
! #include "xmalloc.h"
  
! char *sys_siglist[NSIG];
  
  void
diff -Nrc2 bash-2.05/siglist.h bash-2.05a/siglist.h
*** bash-2.05/siglist.h	Thu Aug  5 07:14:25 1999
--- bash-2.05a/siglist.h	Thu Oct  4 15:14:40 2001
***************
*** 38,40 ****
--- 38,44 ----
  #endif /* !strsignal && !HAVE_STRSIGNAL */
  
+ #if !defined (strsignal) && !HAVE_DECL_STRSIGNAL
+ extern char *strsignal __P((int));
+ #endif
+ 
  #endif /* _SIGLIST_H */
diff -Nrc2 bash-2.05/stringlib.c bash-2.05a/stringlib.c
*** bash-2.05/stringlib.c	Wed Feb 14 17:00:42 2001
--- bash-2.05a/stringlib.c	Wed Sep 12 10:19:47 2001
***************
*** 30,40 ****
  #include "bashansi.h"
  #include <stdio.h>
! #include <ctype.h>
  
  #include "shell.h"
  #include "pathexp.h"
  
  #if defined (EXTENDED_GLOB)
! #  include <glob/fnmatch.h>
  #endif
  
--- 30,42 ----
  #include "bashansi.h"
  #include <stdio.h>
! #include "chartypes.h"
  
  #include "shell.h"
  #include "pathexp.h"
  
+ #include <glob/glob.h>
+ 
  #if defined (EXTENDED_GLOB)
! #  include <glob/strmatch.h>
  #endif
  
***************
*** 106,110 ****
  
  /* Find STRING in ALIST, a list of string key/int value pairs.  If FLAGS
!    is 1, STRING is treated as a pattern and matched using fnmatch. */
  int
  find_string_in_alist (string, alist, flags)
--- 108,112 ----
  
  /* Find STRING in ALIST, a list of string key/int value pairs.  If FLAGS
!    is 1, STRING is treated as a pattern and matched using strmatch. */
  int
  find_string_in_alist (string, alist, flags)
***************
*** 120,124 ****
  #if defined (EXTENDED_GLOB)
        if (flags)
! 	r = fnmatch (alist[i].word, string, FNM_EXTMATCH) != FNM_NOMATCH;
        else
  #endif
--- 122,126 ----
  #if defined (EXTENDED_GLOB)
        if (flags)
! 	r = strmatch (alist[i].word, string, FNM_EXTMATCH) != FNM_NOMATCH;
        else
  #endif
***************
*** 154,163 ****
        if (repl && STREQN (string + i, pat, patlen))
  	{
! 	  RESIZE_MALLOCED_BUFFER (temp, templen, replen, tempsize, (replen * 2));
  
  	  for (r = rep; *r; )
  	    temp[templen++] = *r++;
  
! 	  i += patlen;
  	  repl = global != 0;
  	}
--- 156,166 ----
        if (repl && STREQN (string + i, pat, patlen))
  	{
! 	  if (replen)
! 	    RESIZE_MALLOCED_BUFFER (temp, templen, replen, tempsize, (replen * 2));
  
  	  for (r = rep; *r; )
  	    temp[templen++] = *r++;
  
! 	  i += patlen ? patlen : 1;	/* avoid infinite recursion */
  	  repl = global != 0;
  	}
***************
*** 187,191 ****
    len = STRLEN (text);
    rlen = len + strlen (string) + 2;
!   ret = xmalloc (rlen);
  
    for (p = string, r = ret; p && *p; )
--- 190,194 ----
    len = STRLEN (text);
    rlen = len + strlen (string) + 2;
!   ret = (char *)xmalloc (rlen);
  
    for (p = string, r = ret; p && *p; )
***************
*** 221,224 ****
--- 224,228 ----
  	p++;
  
+       ind = r - ret;
        RESIZE_MALLOCED_BUFFER (ret, ind, 2, rlen, rlen);
        r = ret + ind;			/* in case reallocated */
diff -Nrc2 bash-2.05/subst.c bash-2.05a/subst.c
*** bash-2.05/subst.c	Mon Mar 26 13:06:16 2001
--- bash-2.05a/subst.c	Mon Nov  5 14:19:49 2001
***************
*** 27,30 ****
--- 27,31 ----
  #include "bashtypes.h"
  #include <stdio.h>
+ #include "chartypes.h"
  #include <pwd.h>
  #include <signal.h>
***************
*** 47,59 ****
  #include "mailcheck.h"
  
- #if !defined (HAVE_RESTARTABLE_SYSCALLS)	/* for getc_with_restart */
- #include "input.h"
- #endif
- 
  #include "builtins/getopt.h"
  #include "builtins/common.h"
  
  #include <tilde/tilde.h>
! #include <glob/fnmatch.h>
  
  #if !defined (errno)
--- 48,56 ----
  #include "mailcheck.h"
  
  #include "builtins/getopt.h"
  #include "builtins/common.h"
  
  #include <tilde/tilde.h>
! #include <glob/strmatch.h>
  
  #if !defined (errno)
***************
*** 98,105 ****
  /* Evaluates to 1 if this is one of the shell's special variables. */
  #define SPECIAL_VAR(name, wi) \
!  ((isdigit (*name) && all_digits (name)) || \
!       (name[1] == '\0' && (sh_syntaxtab[*name] & CSPECVAR)) || \
        (wi && name[2] == '\0' && VALID_INDIR_PARAM (name[1])))
  
  /* Process ID of the last command executed within command substitution. */
  pid_t last_command_subst_pid = NO_PID;
--- 95,107 ----
  /* Evaluates to 1 if this is one of the shell's special variables. */
  #define SPECIAL_VAR(name, wi) \
!  ((DIGIT (*name) && all_digits (name)) || \
!       (name[1] == '\0' && (sh_syntaxtab[(unsigned char)*name] & CSPECVAR)) || \
        (wi && name[2] == '\0' && VALID_INDIR_PARAM (name[1])))
  
+ /* An expansion function that takes a string and a quoted flag and returns
+    a WORD_LIST *.  Used as the type of the third argument to
+    expand_string_if_necessary(). */
+ typedef WORD_LIST *EXPFUNC __P((char *, int));
+ 
  /* Process ID of the last command executed within command substitution. */
  pid_t last_command_subst_pid = NO_PID;
***************
*** 107,114 ****
  
  /* Extern functions and variables from different files. */
! extern int last_command_exit_value, interactive, interactive_shell;
  extern int subshell_environment, startup_state;
  extern int return_catch_flag, return_catch_value;
! extern int dollar_dollar_pid;
  extern int posixly_correct;
  extern char *this_command_name;
--- 109,116 ----
  
  /* Extern functions and variables from different files. */
! extern int last_command_exit_value;
  extern int subshell_environment, startup_state;
  extern int return_catch_flag, return_catch_value;
! extern pid_t dollar_dollar_pid;
  extern int posixly_correct;
  extern char *this_command_name;
***************
*** 116,130 ****
  extern int wordexp_only;
  
- extern void getopts_reset ();
- 
  /* Non-zero means to allow unmatched globbed filenames to expand to
     a null file. */
  int allow_null_glob_expansion;
  
  /* Variables to keep track of which words in an expanded word list (the
     output of expand_word_list_internal) are the result of globbing
!    expansions.  GLOB_ARGV_FLAGS is used by execute_cmd.c. */
  char *glob_argv_flags;
  static int glob_argv_flags_size;
  
  static WORD_LIST expand_word_error, expand_word_fatal;
--- 118,133 ----
  extern int wordexp_only;
  
  /* Non-zero means to allow unmatched globbed filenames to expand to
     a null file. */
  int allow_null_glob_expansion;
  
+ #if 0
  /* Variables to keep track of which words in an expanded word list (the
     output of expand_word_list_internal) are the result of globbing
!    expansions.  GLOB_ARGV_FLAGS is used by execute_cmd.c.
!    (CURRENTLY UNUSED). */
  char *glob_argv_flags;
  static int glob_argv_flags_size;
+ #endif
  
  static WORD_LIST expand_word_error, expand_word_fatal;
***************
*** 148,173 ****
  static WORD_LIST *garglist = (WORD_LIST *)NULL;
  
! static char *make_quoted_char ();
! static void remove_quoted_nulls ();
! static char *param_expand ();
! static char *maybe_expand_string ();
! static WORD_LIST *call_expand_word_internal ();
! static WORD_LIST *expand_string_internal ();
! static WORD_LIST *expand_word_internal (), *expand_word_list_internal ();
! static WORD_LIST *expand_string_leave_quoted ();
! static WORD_LIST *expand_string_for_rhs ();
! static char *getifs ();
! static WORD_LIST *word_list_split ();
! static WORD_LIST *quote_list (), *dequote_list ();
! static char *quote_escapes ();
! static WORD_LIST *list_quote_escapes ();
! static int unquoted_substring (), unquoted_member ();
! static int do_assignment_internal ();
! static char *string_extract_verbatim (), *string_extract ();
! static char *string_extract_double_quoted (), *string_extract_single_quoted ();
! static char *string_list_dollar_at (), *string_list_dollar_star ();
! static inline int skip_single_quoted (), skip_double_quoted ();
! static char *extract_delimited_string ();
! static char *extract_dollar_brace_string ();
  
  /* **************************************************************** */
--- 151,241 ----
  static WORD_LIST *garglist = (WORD_LIST *)NULL;
  
! static char *quoted_substring __P((char *, int, int));
! static inline char *quoted_strchr __P((char *, int, int));
! 
! static char *expand_string_if_necessary __P((char *, int, EXPFUNC *));
! static inline char *expand_string_to_string_internal __P((char *, int, EXPFUNC *));
! static WORD_LIST *call_expand_word_internal __P((WORD_DESC *, int, int, int *, int *));
! static WORD_LIST *expand_string_internal __P((char *, int));
! static WORD_LIST *expand_string_leave_quoted __P((char *, int));
! static WORD_LIST *expand_string_for_rhs __P((char *, int, int *, int *));
! 
! static char *remove_quoted_escapes __P((char *));
! static WORD_LIST *list_quote_escapes __P((WORD_LIST *));
! static char *make_quoted_char __P((int));
! static WORD_LIST *quote_list __P((WORD_LIST *));
! static WORD_LIST *dequote_list __P((WORD_LIST *));
! static void remove_quoted_nulls __P((char *));
! 
! static int unquoted_substring __P((char *, char *));
! static int unquoted_member __P((int, char *));
! 
! static int do_assignment_internal __P((const char *, int));
! 
! static char *string_extract_verbatim __P((char *, int *, char *));
! static char *string_extract __P((char *, int *, char *, int));
! static char *string_extract_double_quoted __P((char *, int *, int));
! static char *string_extract_single_quoted __P((char *, int *));
! static inline int skip_single_quoted __P((char *, int));
! static int skip_double_quoted __P((char *, int));
! static char *extract_delimited_string __P((char *, int *, char *, char *, char *));
! static char *extract_dollar_brace_string __P((char *, int *, int));
! 
! static char *string_list_internal __P((WORD_LIST *, char *));
! static char *pos_params __P((char *, int, int, int));
! 
! static char *remove_pattern __P((char *, char *, int));
! static int match_pattern_char __P((char *, char *));
! static int match_pattern __P((char *, char *, int, char **, char **));
! static int getpatspec __P((int, char *));
! static char *getpattern __P((char *, int, int));
! static char *parameter_brace_remove_pattern __P((char *, char *, int, int));
! static char *list_remove_pattern __P((WORD_LIST *, char *, int, int, int));
! static char *parameter_list_remove_pattern __P((char *, int, int, int));
! #ifdef ARRAY_VARS
! static char *array_remove_pattern __P((char *, char *, char *, int, int));
! #endif
! 
! static char *process_substitute __P((char *, int));
! 
! static char *read_comsub __P((int, int));
! 
! #ifdef ARRAY_VARS
! static arrayind_t array_length_reference __P((char *));
! #endif
! 
! static int valid_brace_expansion_word __P((char *, int));
! static char *parameter_brace_expand_word __P((char *, int, int));
! static char *parameter_brace_expand_indir __P((char *, int, int));
! static char *parameter_brace_expand_rhs __P((char *, char *, int, int, int *, int *));
! static void parameter_brace_expand_error __P((char *, char *));
! 
! static int valid_length_expression __P((char *));
! static long parameter_brace_expand_length __P((char *));
! 
! static char *skiparith __P((char *, int));
! static int verify_substring_values __P((char *, char *, int, long *, long *));
! static int get_var_and_type __P((char *, char *, SHELL_VAR **, char **));
! static char *parameter_brace_substring __P((char *, char *, char *, int));
! 
! static char *pos_params_pat_subst __P((char *, char *, char *, int));
! 
! static char *parameter_brace_patsub __P((char *, char *, char *, int));
! 
! static char *parameter_brace_expand __P((char *, int *, int, int *, int *));
! static char *param_expand __P((char *, int *, int, int *, int *, int *, int *, int));
! 
! static WORD_LIST *expand_word_internal __P((WORD_DESC *, int, int, int *, int *));
! 
! static char *getifs __P((void));
! static WORD_LIST *word_list_split __P((WORD_LIST *));
! 
! static WORD_LIST *separate_out_assignments __P((WORD_LIST *));
! static WORD_LIST *glob_expand_word_list __P((WORD_LIST *, int));
! #ifdef BRACE_EXPANSION
! static WORD_LIST *brace_expand_word_list __P((WORD_LIST *, int));
! #endif
! static WORD_LIST *shell_expand_word_list __P((WORD_LIST *, int));
! static WORD_LIST *expand_word_list_internal __P((WORD_LIST *, int));
  
  /* **************************************************************** */
***************
*** 188,192 ****
  
    len = end - start;
!   result = xmalloc (len + 1);
    strncpy (result, string + start, len);
    result[len] = '\0';
--- 256,260 ----
  
    len = end - start;
!   result = (char *)xmalloc (len + 1);
    strncpy (result, string + start, len);
    result[len] = '\0';
***************
*** 217,221 ****
      }
  
!   r = result = xmalloc (2*len + 1);      /* save room for quotes */
  
    /* Copy LEN characters, including quote characters. */
--- 285,289 ----
      }
  
!   r = result = (char *)xmalloc (2*len + 1);      /* save room for quotes */
  
    /* Copy LEN characters, including quote characters. */
***************
*** 366,370 ****
  	  n = srclen + *indx;
  	  n = (n + DEFAULT_ARRAY_SIZE) - (n % DEFAULT_ARRAY_SIZE);
! 	  target = xrealloc (target, (*size = n));
  	}
  
--- 434,438 ----
  	  n = srclen + *indx;
  	  n = (n + DEFAULT_ARRAY_SIZE) - (n % DEFAULT_ARRAY_SIZE);
! 	  target = (char *)xrealloc (target, (*size = n));
  	}
  
***************
*** 384,388 ****
  char *
  sub_append_number (number, target, indx, size)
!      int number, *indx, *size;
       char *target;
  {
--- 452,457 ----
  char *
  sub_append_number (number, target, indx, size)
!      long number;
!      int *indx, *size;
       char *target;
  {
***************
*** 402,407 ****
  static char *
  string_extract (string, sindex, charlist, varname)
!      char *string, *charlist;
!      int *sindex, varname;
  {
    register int c, i;
--- 471,478 ----
  static char *
  string_extract (string, sindex, charlist, varname)
!      char *string;
!      int *sindex;
!      char *charlist;
!      int varname;
  {
    register int c, i;
***************
*** 446,450 ****
       int *sindex, stripdq;
  {
!   int c, j, i, t;
    char *temp, *ret;		/* The new string we return. */
    int pass_next, backquote, si;	/* State variables for the machine. */
--- 517,522 ----
       int *sindex, stripdq;
  {
!   int j, i, t;
!   unsigned char c;
    char *temp, *ret;		/* The new string we return. */
    int pass_next, backquote, si;	/* State variables for the machine. */
***************
*** 452,456 ****
  
    pass_next = backquote = dquote = 0;
!   temp = xmalloc (1 + strlen (string) - *sindex);
  
    for (j = 0, i = *sindex; c = string[i]; i++)
--- 524,528 ----
  
    pass_next = backquote = dquote = 0;
!   temp = (char *)xmalloc (1 + strlen (string) - *sindex);
  
    for (j = 0, i = *sindex; c = string[i]; i++)
***************
*** 567,576 ****
  
  /* This should really be another option to string_extract_double_quoted. */
! static inline int
  skip_double_quoted (string, sind)
       char *string;
       int sind;
  {
!   int c, j, i;
    char *ret;
    int pass_next, backquote, si;
--- 639,648 ----
  
  /* This should really be another option to string_extract_double_quoted. */
! static int
  skip_double_quoted (string, sind)
       char *string;
       int sind;
  {
!   int c, i;
    char *ret;
    int pass_next, backquote, si;
***************
*** 578,582 ****
    pass_next = backquote = 0;
  
!   for (j = 0, i = sind; c = string[i]; i++)
      {
        if (pass_next)
--- 650,654 ----
    pass_next = backquote = 0;
  
!   for (i = sind; c = string[i]; i++)
      {
        if (pass_next)
***************
*** 634,638 ****
       int *sindex;
  {
!   register int i, j;
    char *t;
  
--- 706,710 ----
       int *sindex;
  {
!   register int i;
    char *t;
  
***************
*** 667,672 ****
  static char *
  string_extract_verbatim (string, sindex, charlist)
!      char *string, *charlist;
       int *sindex;
  {
    register int i = *sindex;
--- 739,745 ----
  static char *
  string_extract_verbatim (string, sindex, charlist)
!      char *string;
       int *sindex;
+      char *charlist;
  {
    register int i = *sindex;
***************
*** 872,876 ****
  
    si = i - *sindex - len_closer + 1;
!   result = xmalloc (1 + si);
    strncpy (result, string + *sindex, si);
    result[si] = '\0';
--- 945,949 ----
  
    si = i - *sindex - len_closer + 1;
!   result = (char *)xmalloc (1 + si);
    strncpy (result, string + *sindex, si);
    result[si] = '\0';
***************
*** 893,897 ****
       int *sindex, quoted;
  {
!   register int i, c, l;
    int pass_character, nesting_level, si;
    char *result, *t;
--- 966,970 ----
       int *sindex, quoted;
  {
!   register int i, c;
    int pass_character, nesting_level, si;
    char *result, *t;
***************
*** 1004,1008 ****
    register char *temp;
  
!   temp = xmalloc (1 + strlen (string));
  
    for (i = 0, j = 0; (temp[j] = string[i]); i++, j++)
--- 1077,1081 ----
    register char *temp;
  
!   temp = (char *)xmalloc (1 + strlen (string));
  
    for (i = 0, j = 0; (temp[j] = string[i]); i++, j++)
***************
*** 1033,1040 ****
       int eindex;
  {
!   int i, pass_next, quoted;
  
    no_longjmp_on_fatal_error = 1;
!   for (i = pass_next = quoted = 0; i <= eindex; i++)
      {
        if (pass_next)
--- 1106,1113 ----
       int eindex;
  {
!   int i, pass_next;
  
    no_longjmp_on_fatal_error = 1;
!   for (i = pass_next = 0; i <= eindex; i++)
      {
        if (pass_next)
***************
*** 1152,1156 ****
  	  si = i + 2;
  	  if (string[si] == '\0')
! 	    break;
  	  if (string[i+1] == LPAREN)
  	    temp = extract_delimited_string (string, &si, "$(", "(", ")"); /* ) */
--- 1225,1230 ----
  	  si = i + 2;
  	  if (string[si] == '\0')
! 	    CQ_RETURN(si);
! 
  	  if (string[i+1] == LPAREN)
  	    temp = extract_delimited_string (string, &si, "$(", "(", ")"); /* ) */
***************
*** 1159,1162 ****
--- 1233,1238 ----
  	  i = si;
  	  free (temp);
+ 	  if (string[i] == '\0')	/* don't increment i past EOS in loop */
+ 	    break;
  	  continue;
  	}
***************
*** 1181,1186 ****
       int *nwp, *cwp;
  {
!   int ts, te, i, nw, cw, peekc;
!   char *token, *s, *d, *d2;
    WORD_LIST *ret, *tl;
  
--- 1257,1262 ----
       int *nwp, *cwp;
  {
!   int ts, te, i, nw, cw;
!   char *token, *d, *d2;
    WORD_LIST *ret, *tl;
  
***************
*** 1200,1204 ****
    if (delims)
      {
!       d2 = xmalloc (strlen (delims) + 1);
        for (i = ts = 0; delims[i]; i++)
  	{
--- 1276,1280 ----
    if (delims)
      {
!       d2 = (char *)xmalloc (strlen (delims) + 1);
        for (i = ts = 0; delims[i]; i++)
  	{
***************
*** 1263,1267 ****
  	break;
  
!       i = te + member (string[te], d);
        while (member (string[i], d) && whitespace(string[i]))
  	i++;
--- 1339,1343 ----
  	break;
  
!       i = te /* + member (string[te], d) */;
        while (member (string[i], d) && whitespace(string[i]))
  	i++;
***************
*** 1346,1350 ****
      }
  
!   r = result = xmalloc (result_size + 1);
  
    for (t = list; t; t = t->next)
--- 1422,1426 ----
      }
  
!   r = result = (char *)xmalloc (result_size + 1);
  
    for (t = list; t; t = t->next)
***************
*** 1384,1388 ****
     to a single field with the value of each parameter separated by the
     first character of the IFS variable, or by a <space> if IFS is unset." */
! static char *
  string_list_dollar_star (list)
       WORD_LIST *list;
--- 1460,1464 ----
     to a single field with the value of each parameter separated by the
     first character of the IFS variable, or by a <space> if IFS is unset." */
! char *
  string_list_dollar_star (list)
       WORD_LIST *list;
***************
*** 1407,1411 ****
     to quote the words in the list to preserve the positional parameters
     exactly. */
! static char *
  string_list_dollar_at (list, quoted)
       WORD_LIST *list;
--- 1483,1487 ----
     to quote the words in the list to preserve the positional parameters
     exactly. */
! char *
  string_list_dollar_at (list, quoted)
       WORD_LIST *list;
***************
*** 1705,1741 ****
  /********************************************************/
  
- #if defined (ARRAY_VARS)
- SHELL_VAR *
- do_array_element_assignment (name, value)
-      char *name, *value;
- {
-   char *t;
-   int ind, ni;
-   SHELL_VAR *entry;
- 
-   t = strchr (name, '[');
-   if (t == 0)
-     return ((SHELL_VAR *)NULL);
-   ind = t - name;
-   ni = skipsubscript (name, ind);
-   if ((ALL_ELEMENT_SUB (t[1]) && t[2] == ']') || (ni <= ind + 1))
-     {
-       report_error ("%s: bad array subscript", name);
-       return ((SHELL_VAR *)NULL);
-     }
-   *t++ = '\0';
-   ind = array_expand_index (t, ni - ind);
-   if (ind < 0)
-     {
-       t[-1] = '[';		/* restore original name ] */
-       report_error ("%s: bad array subscript", name);
-       return ((SHELL_VAR *)NULL);
-     }
-   entry = bind_array_variable (name, ind, value);
-   t[-1] = '[';		/* restore original name ] */
-   return (entry);
- }
- #endif /* ARRAY_VARS */
- 
  /* Given STRING, an assignment string, get the value of the right side
     of the `=', and bind it to the left side.  If EXPAND is true, then
--- 1781,1784 ----
***************
*** 1745,1749 ****
  static int
  do_assignment_internal (string, expand)
!      char *string;
       int expand;
  {
--- 1788,1792 ----
  static int
  do_assignment_internal (string, expand)
!      const char *string;
       int expand;
  {
***************
*** 1783,1787 ****
  			: savestring (temp);
  
! 	  value = maybe_expand_string (temp, 0, expand_string_unsplit);
  	  free (temp);
  	}
--- 1826,1830 ----
  			: savestring (temp);
  
! 	  value = expand_string_if_necessary (temp, 0, expand_string_unsplit);
  	  free (temp);
  	}
***************
*** 1792,1806 ****
    if (value == 0)
      {
!       value = xmalloc (1);
        value[0] = '\0';
      }
  
    if (echo_command_at_execute)
  #if defined (ARRAY_VARS)
!     if (assign_list)
!       fprintf (stderr, "%s%s=(%s)\n", indirection_level_string (), name, value);
!     else
  #endif
!     fprintf (stderr, "%s%s=%s\n", indirection_level_string (), name, value);
  
  #define ASSIGN_RETURN(r)	do { FREE (value); free (name); return (r); } while (0)
--- 1835,1851 ----
    if (value == 0)
      {
!       value = (char *)xmalloc (1);
        value[0] = '\0';
      }
  
    if (echo_command_at_execute)
+     {
  #if defined (ARRAY_VARS)
!       if (assign_list)
! 	fprintf (stderr, "%s%s=(%s)\n", indirection_level_string (), name, value);
!       else
  #endif
!       fprintf (stderr, "%s%s=%s\n", indirection_level_string (), name, value);
!     }
  
  #define ASSIGN_RETURN(r)	do { FREE (value); free (name); return (r); } while (0)
***************
*** 1814,1818 ****
  	  ASSIGN_RETURN (0);
  	}
!       entry = do_array_element_assignment (name, value);
        if (entry == 0)
  	ASSIGN_RETURN (0);
--- 1859,1863 ----
  	  ASSIGN_RETURN (0);
  	}
!       entry = assign_array_element (name, value);
        if (entry == 0)
  	ASSIGN_RETURN (0);
***************
*** 1837,1841 ****
  int
  do_assignment (string)
!      char *string;
  {
    return do_assignment_internal (string, 1);
--- 1882,1886 ----
  int
  do_assignment (string)
!      const char *string;
  {
    return do_assignment_internal (string, 1);
***************
*** 1847,1851 ****
  int
  do_assignment_no_expand (string)
!      char *string;
  {
    return do_assignment_internal (string, 0);
--- 1892,1896 ----
  int
  do_assignment_no_expand (string)
!      const char *string;
  {
    return do_assignment_internal (string, 0);
***************
*** 1891,1895 ****
  char *
  get_dollar_var_value (ind)
!      int ind;
  {
    char *temp;
--- 1936,1940 ----
  char *
  get_dollar_var_value (ind)
!      long ind;
  {
    char *temp;
***************
*** 1982,1989 ****
     removal if necessary.  This returns a new string. */
  static char *
! maybe_expand_string (string, quoted, func)
       char *string;
       int quoted;
!      WORD_LIST *(*func)();
  {
    WORD_LIST *list;
--- 2027,2034 ----
     removal if necessary.  This returns a new string. */
  static char *
! expand_string_if_necessary (string, quoted, func)
       char *string;
       int quoted;
!      EXPFUNC *func;
  {
    WORD_LIST *list;
***************
*** 2018,2025 ****
  
  static inline char *
! expand_string_to_string (string, quoted, func)
       char *string;
       int quoted;
!      WORD_LIST *(*func)();
  {
    WORD_LIST *list;
--- 2063,2070 ----
  
  static inline char *
! expand_string_to_string_internal (string, quoted, func)
       char *string;
       int quoted;
!      EXPFUNC *func;
  {
    WORD_LIST *list;
***************
*** 2041,2044 ****
--- 2086,2105 ----
  }
  
+ char *
+ expand_string_to_string (string, quoted)
+      char *string;
+      int quoted;
+ {
+   return (expand_string_to_string_internal (string, quoted, expand_string));
+ }
+ 
+ char *
+ expand_string_unsplit_to_string (string, quoted)
+      char *string;
+      int quoted;
+ {
+   return (expand_string_to_string_internal (string, quoted, expand_string_unsplit));
+ }
+ 
  #if defined (COND_COMMAND)
  /* Just remove backslashes in STRING.  Returns a new string. */
***************
*** 2049,2053 ****
    char *r, *ret, *s;
  
!   r = ret = xmalloc (strlen (string) + 1);
    for (s = string; s && *s; )
      {
--- 2110,2114 ----
    char *r, *ret, *s;
  
!   r = ret = (char *)xmalloc (strlen (string) + 1);
    for (s = string; s && *s; )
      {
***************
*** 2318,2322 ****
      return (string);
  
!   t1 = t = xmalloc (strlen (string) + 1);
    for (docopy = 0, s = string; *s; s++, t1++)
      {
--- 2379,2383 ----
      return (string);
  
!   t1 = t = (char *)xmalloc (strlen (string) + 1);
    for (docopy = 0, s = string; *s; s++, t1++)
      {
***************
*** 2338,2342 ****
     used to protect CTLESC and CTLNUL in variable values from the rest of
     the word expansion process after the variable is expanded. */
! static char *
  quote_escapes (string)
       char *string;
--- 2399,2403 ----
     used to protect CTLESC and CTLNUL in variable values from the rest of
     the word expansion process after the variable is expanded. */
! char *
  quote_escapes (string)
       char *string;
***************
*** 2345,2349 ****
    char *result;
  
!   result = xmalloc ((strlen (string) * 2) + 1);
    for (s = string, t = result; *s; )
      {
--- 2406,2410 ----
    char *result;
  
!   result = (char *)xmalloc ((strlen (string) * 2) + 1);
    for (s = string, t = result; *s; )
      {
***************
*** 2381,2385 ****
    char *result;
  
!   result = xmalloc (strlen (string) + 1);
    for (s = string, t = result; *s; )
      {
--- 2442,2446 ----
    char *result;
  
!   result = (char *)xmalloc (strlen (string) + 1);
    for (s = string, t = result; *s; )
      {
***************
*** 2420,2424 ****
    char *temp;
  
!   temp = xmalloc (3);
    if (c == 0)
      {
--- 2481,2485 ----
    char *temp;
  
!   temp = (char *)xmalloc (3);
    if (c == 0)
      {
***************
*** 2445,2449 ****
    if (*string == 0)
      {
!       result = xmalloc (2);
        result[0] = CTLNUL;
        result[1] = '\0';
--- 2506,2510 ----
    if (*string == 0)
      {
!       result = (char *)xmalloc (2);
        result[0] = CTLNUL;
        result[1] = '\0';
***************
*** 2451,2455 ****
    else
      {
!       result = xmalloc ((strlen (string) * 2) + 1);
  
        for (t = result; *string; )
--- 2512,2516 ----
    else
      {
!       result = (char *)xmalloc ((strlen (string) * 2) + 1);
  
        for (t = result; *string; )
***************
*** 2471,2475 ****
    char *result;
  
!   result = xmalloc (strlen (string) + 1);
  
    if (QUOTED_NULL (string))
--- 2532,2536 ----
    char *result;
  
!   result = (char *)xmalloc (strlen (string) + 1);
  
    if (QUOTED_NULL (string))
***************
*** 2612,2616 ****
  	  {
  	    c = *p; *p = '\0';
! 	    if (fnmatch (pattern, param, FNMATCH_EXTFLAG) != FNM_NOMATCH)
  	      {
  		*p = c;
--- 2673,2677 ----
  	  {
  	    c = *p; *p = '\0';
! 	    if (strmatch (pattern, param, FNMATCH_EXTFLAG) != FNM_NOMATCH)
  	      {
  		*p = c;
***************
*** 2625,2629 ****
  	  {
  	    c = *p; *p = '\0';
! 	    if (fnmatch (pattern, param, FNMATCH_EXTFLAG) != FNM_NOMATCH)
  	      {
  		*p = c;
--- 2686,2690 ----
  	  {
  	    c = *p; *p = '\0';
! 	    if (strmatch (pattern, param, FNMATCH_EXTFLAG) != FNM_NOMATCH)
  	      {
  		*p = c;
***************
*** 2637,2641 ****
  	for (p = param; p <= end; p++)
  	  {
! 	    if (fnmatch (pattern, p, FNMATCH_EXTFLAG) != FNM_NOMATCH)
  	      {
  		c = *p; *p = '\0';
--- 2698,2702 ----
  	for (p = param; p <= end; p++)
  	  {
! 	    if (strmatch (pattern, p, FNMATCH_EXTFLAG) != FNM_NOMATCH)
  	      {
  		c = *p; *p = '\0';
***************
*** 2650,2654 ****
  	for (p = end; p >= param; p--)
  	  {
! 	    if (fnmatch (pattern, p, FNMATCH_EXTFLAG) != FNM_NOMATCH)
  	      {
  		c = *p; *p = '\0';
--- 2711,2715 ----
  	for (p = end; p >= param; p--)
  	  {
! 	    if (strmatch (pattern, p, FNMATCH_EXTFLAG) != FNM_NOMATCH)
  	      {
  		c = *p; *p = '\0';
***************
*** 2664,2668 ****
  
  /* Return 1 of the first character of STRING could match the first
!    character of pattern PAT.  Used to avoid n2 calls to fnmatch(). */
  static int
  match_pattern_char (pat, string)
--- 2725,2729 ----
  
  /* Return 1 of the first character of STRING could match the first
!    character of pattern PAT.  Used to avoid n2 calls to strmatch(). */
  static int
  match_pattern_char (pat, string)
***************
*** 2724,2728 ****
  		{
  		  c = *p1; *p1 = '\0';
! 		  if (fnmatch (pat, p, FNMATCH_EXTFLAG) == 0)
  		    {
  		      *p1 = c;
--- 2785,2789 ----
  		{
  		  c = *p1; *p1 = '\0';
! 		  if (strmatch (pat, p, FNMATCH_EXTFLAG) == 0)
  		    {
  		      *p1 = c;
***************
*** 2743,2747 ****
  	{
  	  c = *p; *p = '\0';
! 	  if (fnmatch (pat, string, FNMATCH_EXTFLAG) == 0)
  	    {
  	      *p = c;
--- 2804,2808 ----
  	{
  	  c = *p; *p = '\0';
! 	  if (strmatch (pat, string, FNMATCH_EXTFLAG) == 0)
  	    {
  	      *p = c;
***************
*** 2756,2760 ****
      case MATCH_END:
        for (p = string; p <= end; p++)
! 	if (fnmatch (pat, p, FNMATCH_EXTFLAG) == 0)
  	  {
  	    *sp = p;
--- 2817,2821 ----
      case MATCH_END:
        for (p = string; p <= end; p++)
! 	if (strmatch (pat, p, FNMATCH_EXTFLAG) == 0)
  	  {
  	    *sp = p;
***************
*** 2782,2786 ****
     parameter expansion, command substitution and arithmetic expansion.
     This leaves the result quoted, so quote_string_for_globbing () has
!    to be called to fix it up for fnmatch ().  If QUOTED is non-zero,
     it means that the entire expression was enclosed in double quotes.
     This means that quoting characters in the pattern do not make any
--- 2843,2847 ----
     parameter expansion, command substitution and arithmetic expansion.
     This leaves the result quoted, so quote_string_for_globbing () has
!    to be called to fix it up for strmatch ().  If QUOTED is non-zero,
     it means that the entire expression was enclosed in double quotes.
     This means that quoting characters in the pattern do not make any
***************
*** 3018,3022 ****
  #define FIFO_INCR 20
  
! static char **fifo_list = (char **)NULL;
  static int nfifo;
  static int fifo_list_size;
--- 3079,3088 ----
  #define FIFO_INCR 20
  
! struct temp_fifo {
!   char *file;
!   pid_t proc;
! };
! 
! static struct temp_fifo *fifo_list = (struct temp_fifo *)NULL;
  static int nfifo;
  static int fifo_list_size;
***************
*** 3029,3037 ****
      {
        fifo_list_size += FIFO_INCR;
!       fifo_list = (char **)xrealloc (fifo_list,
! 				     fifo_list_size * sizeof (char *));
      }
  
!   fifo_list[nfifo++] = savestring (pathname);
  }
  
--- 3095,3104 ----
      {
        fifo_list_size += FIFO_INCR;
!       fifo_list = (struct temp_fifo *)xrealloc (fifo_list,
! 				fifo_list_size * sizeof (struct temp_fifo));
      }
  
!   fifo_list[nfifo].file = savestring (pathname);
!   nfifo++;
  }
  
***************
*** 3039,3052 ****
  unlink_fifo_list ()
  {
    if (nfifo == 0)
      return;
  
!   while (nfifo--)
      {
!       unlink (fifo_list[nfifo]);
!       free (fifo_list[nfifo]);
!       fifo_list[nfifo] = (char *)NULL;
      }
!   nfifo = 0;
  }
  
--- 3106,3141 ----
  unlink_fifo_list ()
  {
+   int saved, i, j;
+ 
    if (nfifo == 0)
      return;
  
!   for (i = saved = 0; i < nfifo; i++)
      {
!       if ((fifo_list[i].proc == -1) || (kill(fifo_list[i].proc, 0) == -1))
! 	{
!           unlink (fifo_list[i].file);
!           free (fifo_list[i].file);
!           fifo_list[i].file = (char *)NULL;
!           fifo_list[i].proc = -1;
! 	}
!       else
!         saved++;
      }
! 
!   /* If we didn't remove some of the FIFOs, compact the list. */
!   if (saved)
!     {
!       for (i = j = 0; i < nfifo; i++)
! 	if (fifo_list[i].file)
! 	  {
! 	    fifo_list[j].file = fifo_list[i].file;
! 	    fifo_list[j].proc = fifo_list[i].proc;
! 	    j++;
! 	  }
!       nfifo = j;
!     }
!   else
!     nfifo = 0;
  }
  
***************
*** 3092,3096 ****
  	totfds = fd + 2;
  
!       dev_fd_list = xrealloc (dev_fd_list, totfds);
        bzero (dev_fd_list + ofds, totfds - ofds);
      }
--- 3181,3185 ----
  	totfds = fd + 2;
  
!       dev_fd_list = (char *)xrealloc (dev_fd_list, totfds);
        bzero (dev_fd_list + ofds, totfds - ofds);
      }
***************
*** 3124,3128 ****
    register int i;
  
!   fprintf (stderr, "pid %d: dev_fd_list:", getpid ());
    fflush (stderr);
  
--- 3213,3217 ----
    register int i;
  
!   fprintf (stderr, "pid %ld: dev_fd_list:", (long)getpid ());
    fflush (stderr);
  
***************
*** 3140,3146 ****
       int fd;
  {
!   char *ret, intbuf[16], *p;
  
!   ret = xmalloc (sizeof (DEV_FD_PREFIX) + 4);
  
    strcpy (ret, DEV_FD_PREFIX);
--- 3229,3235 ----
       int fd;
  {
!   char *ret, intbuf[INT_STRLEN_BOUND (int) + 1], *p;
  
!   ret = (char *)xmalloc (sizeof (DEV_FD_PREFIX) + 4);
  
    strcpy (ret, DEV_FD_PREFIX);
***************
*** 3215,3223 ****
    old_pipeline_pgrp = pipeline_pgrp;
    pipeline_pgrp = shell_pgrp;
- #if 0
-   cleanup_the_pipeline ();
- #else
    save_pipeline (1);
- #endif
  #endif /* JOB_CONTROL */
  
--- 3304,3308 ----
***************
*** 3255,3258 ****
--- 3340,3347 ----
  #endif
  
+ #if !defined (HAVE_DEV_FD)
+       fifo_list[nfifo-1].proc = pid;
+ #endif
+ 
        last_made_pid = old_pid;
  
***************
*** 3302,3306 ****
      }
  
!   close (fd);
  
    /* Need to close any files that this process has open to pipes inherited
--- 3391,3396 ----
      }
  
!   if (fd != (open_for_read_in_child ? 0 : 1))
!     close (fd);
  
    /* Need to close any files that this process has open to pipes inherited
***************
*** 3343,3347 ****
  {
    char *istring, buf[128], *bufp;
!   int bufn, istring_index, istring_size, c;
  
    istring = (char *)NULL;
--- 3433,3438 ----
  {
    char *istring, buf[128], *bufp;
!   int istring_index, istring_size, c;
!   ssize_t bufn;
  
    istring = (char *)NULL;
***************
*** 3490,3493 ****
--- 3581,3586 ----
    stop_making_children ();
    pipeline_pgrp = old_pipeline_pgrp;
+ #else
+   stop_making_children ();
  #endif /* JOB_CONTROL */
  
***************
*** 3612,3792 ****
   ********************************************************/
  
- /* Utility functions to manage arrays and their contents for expansion */
- 
  #if defined (ARRAY_VARS)
- int
- valid_array_reference (name)
-      char *name;
- {
-   char *t;
-   int r, len;
  
!   t = strchr (name, '[');	/* ] */
!   if (t)
!     {
!       *t = '\0';
!       r = legal_identifier (name);
!       *t = '[';
!       if (r == 0)
! 	return 0;
!       /* Check for a properly-terminated non-blank subscript. */
!       len = skipsubscript (t, 0);
!       if (t[len] != ']' || len == 1)
! 	return 0;
!       for (r = 1; r < len; r++)
! 	if (whitespace (t[r]) == 0)
! 	  return 1;
!       return 0;
!     }
!   return 0;
! }
! 
! /* Expand the array index beginning at S and extending LEN characters. */
! int
! array_expand_index (s, len)
!      char *s;
!      int len;
! {
!   char *exp, *t;
!   int val, expok;
! 
!   exp = xmalloc (len);
!   strncpy (exp, s, len - 1);
!   exp[len - 1] = '\0';
!   t = maybe_expand_string (exp, 0, expand_string);
!   this_command_name = (char *)NULL;
!   val = evalexp (t, &expok);
!   free (t);
!   free (exp);
!   if (expok == 0)
!     {
!       last_command_exit_value = EXECUTION_FAILURE;
!       jump_to_top_level (DISCARD);
!     }
!   return val;
! }
! 
! /* Return the variable specified by S without any subscript.  If non-null,
!    return the index of the start of the subscript in *SUBP.  If non-null,
!    the length of the subscript is returned in *LENP. */
! SHELL_VAR *
! array_variable_part (s, subp, lenp)
!      char *s, **subp;
!      int *lenp;
! {
!   char *t;
!   int ind, ni;
!   SHELL_VAR *var;
! 
!   t = strchr (s, '[');
!   ind = t - s;
!   ni = skipsubscript (s, ind);
!   if (ni <= ind + 1 || s[ni] != ']')
!     {
!       report_error ("%s: bad array subscript", s);
!       return ((SHELL_VAR *)NULL);
!     }
! 
!   *t = '\0';
!   var = find_variable (s);
!   *t++ = '[';		/* ] */
! 
!   if (subp)
!     *subp = t;
!   if (lenp)
!     *lenp = ni - ind;
!   return var;
! }
! 
! static char *
! array_value_internal (s, quoted, allow_all)
!      char *s;
!      int quoted, allow_all;
! {
!   int len, ind;
!   char *retval, *t, *temp;
!   WORD_LIST *l, *list;
!   SHELL_VAR *var;
! 
!   var = array_variable_part (s, &t, &len);
! 
!   if (var == 0)
!     return (char *)NULL;
! 
!   /* [ */
!   if (ALL_ELEMENT_SUB (t[0]) && t[1] == ']')
!     {
!       if (allow_all == 0)
! 	{
! 	  report_error ("%s: bad array subscript", s);
! 	  return ((char *)NULL);
! 	}
!       else if (array_p (var) == 0)
! 	{
! 	  l = (WORD_LIST *)NULL;
! 	  l = add_string_to_list (value_cell (var), l);
! 	}
!       else
! 	{
! 	  l = array_to_word_list (array_cell (var));
! 	  if (l == (WORD_LIST *)NULL)
! 	    return ((char *) NULL);
! 	}
! 
!       if (t[0] == '*' && (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)))
! 	{
! 	  temp = string_list_dollar_star (l);
! 	  retval = quote_string (temp);
! 	  free (temp);
! 	}
!       else	/* ${name[@]} or unquoted ${name[*]} */
! 	retval = string_list_dollar_at (l, quoted);
! 
!       dispose_words (l);
!     }
!   else
!     {
!       ind = array_expand_index (t, len);
!       if (ind < 0)
! 	{
! 	  report_error ("%s: bad array subscript", var->name);
! 	  return ((char *)NULL);
! 	}
!       if (array_p (var) == 0)
! 	return (ind == 0 ? savestring (value_cell (var)) : (char *)NULL);
!       retval = array_reference (array_cell (var), ind);
!       if (retval)
! 	retval = quote_escapes (retval);
!     }
! 
!   return retval;
! }
! 
! static char *
! array_value (s, quoted)
!      char *s;
!      int quoted;
! {
!   return (array_value_internal (s, quoted, 1));
! }
! 
! /* Return the value of the array indexing expression S as a single string.
!    If ALLOW_ALL is 0, do not allow `@' and `*' subscripts.  This is used
!    by other parts of the shell such as the arithmetic expression evaluator
!    in expr.c. */
! char *
! get_array_value (s, allow_all)
!      char *s;
!      int allow_all;
! {
!   return (array_value_internal (s, 0, allow_all));
! }
! 
! static int
  array_length_reference (s)
       char *s;
  {
!   int ind, len;
!   char *t;
    ARRAY *array;
    SHELL_VAR *var;
--- 3705,3717 ----
   ********************************************************/
  
  #if defined (ARRAY_VARS)
  
! static arrayind_t
  array_length_reference (s)
       char *s;
  {
!   int len;
!   arrayind_t ind;
!   char *t, c;
    ARRAY *array;
    SHELL_VAR *var;
***************
*** 3798,3805 ****
    if ((var == 0 || array_p (var) == 0) && unbound_vars_is_error)
      {
!       ind = *--t;
        *t = '\0';
        report_error ("%s: unbound variable", s);
!       *t++ = (char)ind;
        return (-1);
      }
--- 3723,3730 ----
    if ((var == 0 || array_p (var) == 0) && unbound_vars_is_error)
      {
!       c = *--t;
        *t = '\0';
        report_error ("%s: unbound variable", s);
!       *t = c;
        return (-1);
      }
***************
*** 3838,3842 ****
       int var_is_special;
  {
!   if (isdigit (*name) && all_digits (name))
      return 1;
    else if (var_is_special)
--- 3763,3767 ----
       int var_is_special;
  {
!   if (DIGIT (*name) && all_digits (name))
      return 1;
    else if (var_is_special)
***************
*** 3863,3880 ****
  {
    char *temp, *tt;
!   int arg_index;
    SHELL_VAR *var;
    WORD_LIST *l;
  
    /* Handle multiple digit arguments, as in ${11}. */
!   if (isdigit (*name))
!     {
!       arg_index = atoi (name);
!       temp = get_dollar_var_value (arg_index);
!     }
    else if (var_is_special)      /* ${@} */
      {
        int sindex;
!       tt = xmalloc (2 + strlen (name));
        tt[sindex = 0] = '$';
        strcpy (tt + 1, name);
--- 3788,3805 ----
  {
    char *temp, *tt;
!   long arg_index;
    SHELL_VAR *var;
+ #if 0
    WORD_LIST *l;
+ #endif
  
    /* Handle multiple digit arguments, as in ${11}. */
!   
!   if (legal_number (name, &arg_index))
!     temp = get_dollar_var_value (arg_index);
    else if (var_is_special)      /* ${@} */
      {
        int sindex;
!       tt = (char *)xmalloc (2 + strlen (name));
        tt[sindex = 0] = '$';
        strcpy (tt + 1, name);
***************
*** 3994,3998 ****
   	 it does not expand to anything.  In this case, we want to return
   	 a quoted empty string. */
!       temp = xmalloc (2);
        temp[0] = CTLNUL;
        temp[1] = '\0';
--- 3919,3923 ----
   	 it does not expand to anything.  In this case, we want to return
   	 a quoted empty string. */
!       temp = (char *)xmalloc (2);
        temp[0] = CTLNUL;
        temp[1] = '\0';
***************
*** 4053,4058 ****
  {
    return (name[1] == '\0' ||					/* ${#} */
! 	  ((sh_syntaxtab[name[1]] & CSPECVAR) && name[2] == '\0') ||  /* special param */
! 	  (isdigit (name[1]) && all_digits (name + 1)) ||	/* ${#11} */
  #if defined (ARRAY_VARS)
  	  valid_array_reference (name + 1) ||			/* ${#a[7]} */
--- 3978,3983 ----
  {
    return (name[1] == '\0' ||					/* ${#} */
! 	  ((sh_syntaxtab[(unsigned char) name[1]] & CSPECVAR) && name[2] == '\0') ||  /* special param */
! 	  (DIGIT (name[1]) && all_digits (name + 1)) ||	/* ${#11} */
  #if defined (ARRAY_VARS)
  	  valid_array_reference (name + 1) ||			/* ${#a[7]} */
***************
*** 4063,4072 ****
  /* Handle the parameter brace expansion that requires us to return the
     length of a parameter. */
! static int
  parameter_brace_expand_length (name)
       char *name;
  {
    char *t, *newname;
!   int number;
    WORD_LIST *list;
  #if defined (ARRAY_VARS)
--- 3988,3997 ----
  /* Handle the parameter brace expansion that requires us to return the
     length of a parameter. */
! static long
  parameter_brace_expand_length (name)
       char *name;
  {
    char *t, *newname;
!   long number, arg_index;
    WORD_LIST *list;
  #if defined (ARRAY_VARS)
***************
*** 4078,4082 ****
    else if ((name[1] == '@' || name[1] == '*') && name[2] == '\0')	/* ${#@}, ${#*} */
      number = number_of_args ();
!   else if ((sh_syntaxtab[name[1]] & CSPECVAR) && name[2] == '\0')
      {
        /* Take the lengths of some of the shell's special parameters. */
--- 4003,4007 ----
    else if ((name[1] == '@' || name[1] == '*') && name[2] == '\0')	/* ${#@}, ${#*} */
      number = number_of_args ();
!   else if ((sh_syntaxtab[(unsigned char) name[1]] & CSPECVAR) && name[2] == '\0')
      {
        /* Take the lengths of some of the shell's special parameters. */
***************
*** 4096,4100 ****
  	    t = (char *)NULL;
  	  else
! 	    t = itos ((int)last_asynchronous_pid);
  	  break;
  	case '#':
--- 4021,4025 ----
  	    t = (char *)NULL;
  	  else
! 	    t = itos (last_asynchronous_pid);
  	  break;
  	case '#':
***************
*** 4113,4119 ****
        number = 0;
  
!       if (isdigit (name[1]))		/* ${#1} */
  	{
! 	  t = get_dollar_var_value (atoi (name + 1));
  	  number = STRLEN (t);
  	  FREE (t);
--- 4038,4044 ----
        number = 0;
  
!       if (legal_number (name + 1, &arg_index))		/* ${#1} */
  	{
! 	  t = get_dollar_var_value (arg_index);
  	  number = STRLEN (t);
  	  FREE (t);
***************
*** 4201,4213 ****
  verify_substring_values (value, substr, vtype, e1p, e2p)
       char *value, *substr;
!      int vtype, *e1p, *e2p;
  {
    char *t, *temp1, *temp2;
!   int len, expok;
  #if defined (ARRAY_VARS)
   ARRAY *a;
  #endif
  
- #if 1
    /* duplicate behavior of strchr(3) */
    t = skiparith (substr, ':');
--- 4126,4139 ----
  verify_substring_values (value, substr, vtype, e1p, e2p)
       char *value, *substr;
!      int vtype;
!      long *e1p, *e2p;
  {
    char *t, *temp1, *temp2;
!   arrayind_t len;
!   int expok;
  #if defined (ARRAY_VARS)
   ARRAY *a;
  #endif
  
    /* duplicate behavior of strchr(3) */
    t = skiparith (substr, ':');
***************
*** 4216,4225 ****
    else
      t = (char *)0;
! #else
!   t = strchr (substr, ':');
!   if (t)
!     *t = '\0';
! #endif
!   temp1 = maybe_expand_string (substr, Q_DOUBLE_QUOTES, expand_string);
    *e1p = evalexp (temp1, &expok);
    free (temp1);
--- 4142,4147 ----
    else
      t = (char *)0;
! 
!   temp1 = expand_string_if_necessary (substr, Q_DOUBLE_QUOTES, expand_string);
    *e1p = evalexp (temp1, &expok);
    free (temp1);
***************
*** 4227,4230 ****
--- 4149,4153 ----
      return (0);
  
+   len = -1;	/* paranoia */
    switch (vtype)
      {
***************
*** 4244,4247 ****
--- 4167,4173 ----
      }
  
+   if (len == -1)	/* paranoia */
+     return -1;
+ 
    if (*e1p < 0)		/* negative offsets count from end */
      *e1p += len;
***************
*** 4254,4258 ****
        t++;
        temp2 = savestring (t);
!       temp1 = maybe_expand_string (temp2, Q_DOUBLE_QUOTES, expand_string);
        free (temp2);
        t[-1] = ':';
--- 4180,4184 ----
        t++;
        temp2 = savestring (t);
!       temp1 = expand_string_if_necessary (temp2, Q_DOUBLE_QUOTES, expand_string);
        free (temp2);
        t[-1] = ':';
***************
*** 4299,4304 ****
        v = array_variable_part (varname, &temp, (int *)0);
        if (v && array_p (v))
! 	{
! 	  if ((temp[0] == '@' || temp[0] == '*') && temp[1] == ']')
  	    {
  	      vtype = VT_ARRAYVAR;
--- 4225,4230 ----
        v = array_variable_part (varname, &temp, (int *)0);
        if (v && array_p (v))
! 	{ /* [ */
! 	  if (ALL_ELEMENT_SUB (temp[0]) && temp[1] == ']')
  	    {
  	      vtype = VT_ARRAYVAR;
***************
*** 4343,4347 ****
       int quoted;
  {
!   int e1, e2, vtype, r;
    char *temp, *val;
    SHELL_VAR *v;
--- 4269,4274 ----
       int quoted;
  {
!   long e1, e2;
!   int vtype, r;
    char *temp, *val;
    SHELL_VAR *v;
***************
*** 4380,4383 ****
--- 4307,4312 ----
        break;
  #endif
+     default:
+       temp = (char *)NULL;
      }
  
***************
*** 4411,4415 ****
        replen = STRLEN (rep);
        l = strlen (string);
!       ret = xmalloc (replen + l + 2);
        if (replen == 0)
  	strcpy (ret, string);
--- 4340,4344 ----
        replen = STRLEN (rep);
        l = strlen (string);
!       ret = (char *)xmalloc (replen + l + 2);
        if (replen == 0)
  	strcpy (ret, string);
***************
*** 4427,4431 ****
      }
  
!   ret = xmalloc (rsize = 64);
    ret[0] = '\0';
  
--- 4356,4360 ----
      }
  
!   ret = (char *)xmalloc (rsize = 64);
    ret[0] = '\0';
  
***************
*** 4527,4531 ****
        patsub++;
      }
!   /* Malloc this because maybe_expand_string or one of the expansion functions
       in its call chain may free it on a substitution error. */
    lpatsub = savestring (patsub);
--- 4456,4460 ----
        patsub++;
      }
!   /* Malloc this because expand_string_if_necessary or one of the expansion functions
       in its call chain may free it on a substitution error. */
    lpatsub = savestring (patsub);
***************
*** 4546,4552 ****
       perform word splitting or filename generation. */
  #if 0
!   pat = maybe_expand_string (lpatsub, quoted, expand_string_unsplit);
  #else
!   pat = maybe_expand_string (lpatsub, (quoted & ~Q_DOUBLE_QUOTES), expand_string_unsplit);
  #endif
  
--- 4475,4481 ----
       perform word splitting or filename generation. */
  #if 0
!   pat = expand_string_if_necessary (lpatsub, quoted, expand_string_unsplit);
  #else
!   pat = expand_string_if_necessary (lpatsub, (quoted & ~Q_DOUBLE_QUOTES), expand_string_unsplit);
  #endif
  
***************
*** 4554,4560 ****
      {
        if ((mflags & MATCH_QUOTED) == 0)
! 	rep = maybe_expand_string (rep, quoted, expand_string_unsplit);
        else
! 	rep = expand_string_to_string (rep, quoted, expand_string_unsplit);
      }
  
--- 4483,4489 ----
      {
        if ((mflags & MATCH_QUOTED) == 0)
! 	rep = expand_string_if_necessary (rep, quoted, expand_string_unsplit);
        else
! 	rep = expand_string_to_string_internal (rep, quoted, expand_string_unsplit);
      }
  
***************
*** 4618,4622 ****
    int want_substring, want_indir, want_patsub;
    char *name, *value, *temp, *temp1;
!   int t_index, sindex, c, number;
  
    value = (char *)NULL;
--- 4547,4552 ----
    int want_substring, want_indir, want_patsub;
    char *name, *value, *temp, *temp1;
!   int t_index, sindex, c;
!   long number;
  
    value = (char *)NULL;
***************
*** 4644,4648 ****
        free (name);
        temp1 = string_extract (string, &t_index, "#%:-=?+/}", 0);
!       name = xmalloc (3 + (strlen (temp1)));
        *name = string[sindex];
        if (string[sindex] == '!')
--- 4574,4578 ----
        free (name);
        temp1 = string_extract (string, &t_index, "#%:-=?+/}", 0);
!       name = (char *)xmalloc (3 + (strlen (temp1)));
        *name = string[sindex];
        if (string[sindex] == '!')
***************
*** 4685,4689 ****
  	VALID_SPECIAL_LENGTH_PARAM (c) && string[sindex] == RBRACE)
      {
!       name = xrealloc (name, 3);
        name[1] = c;
        name[2] = '\0';
--- 4615,4619 ----
  	VALID_SPECIAL_LENGTH_PARAM (c) && string[sindex] == RBRACE)
      {
!       name = (char *)xrealloc (name, 3);
        name[1] = c;
        name[2] = '\0';
***************
*** 4703,4707 ****
       variable that expands to one of the positional parameters. */
    want_indir = *name == '!' &&
!     (legal_variable_starter (name[1]) || isdigit (name[1])
  				      || VALID_INDIR_PARAM (name[1]));
  
--- 4633,4637 ----
       variable that expands to one of the positional parameters. */
    want_indir = *name == '!' &&
!     (legal_variable_starter ((unsigned char)name[1]) || DIGIT (name[1])
  				      || VALID_INDIR_PARAM (name[1]));
  
***************
*** 4746,4750 ****
    if (want_indir && string[sindex - 1] == RBRACE &&
        (string[sindex - 2] == '*' || string[sindex - 2] == '@') &&
!       legal_variable_starter (name[1]))
      {
        char **x;
--- 4676,4680 ----
    if (want_indir && string[sindex - 1] == RBRACE &&
        (string[sindex - 2] == '*' || string[sindex - 2] == '@') &&
!       legal_variable_starter ((unsigned char) name[1]))
      {
        char **x;
***************
*** 4976,4982 ****
  {
    char *temp, *temp1;
!   int zindex, number, c, t_index, expok;
    SHELL_VAR *var;
!   WORD_LIST *list, *tlist;
  
    zindex = *sindex;
--- 4906,4914 ----
  {
    char *temp, *temp1;
!   int zindex, t_index, expok;
!   unsigned char c;
!   long number;
    SHELL_VAR *var;
!   WORD_LIST *list;
  
    zindex = *sindex;
***************
*** 4999,5003 ****
      case '8':
      case '9':
!       temp1 = dollar_vars[digit_value (c)];
        if (unbound_vars_is_error && temp1 == (char *)NULL)
  	{
--- 4931,4935 ----
      case '8':
      case '9':
!       temp1 = dollar_vars[TODIGIT (c)];
        if (unbound_vars_is_error && temp1 == (char *)NULL)
  	{
***************
*** 5047,5051 ****
  	}
        else
! 	temp = itos ((int)last_asynchronous_pid);
        break;
  
--- 4979,4983 ----
  	}
        else
! 	temp = itos (last_asynchronous_pid);
        break;
  
***************
*** 5164,5168 ****
  
  	  /* Expand variables found inside the expression. */
! 	  temp1 = maybe_expand_string (temp2, Q_DOUBLE_QUOTES, expand_string);
  	  free (temp2);
  
--- 5096,5100 ----
  
  	  /* Expand variables found inside the expression. */
! 	  temp1 = expand_string_if_necessary (temp2, Q_DOUBLE_QUOTES, expand_string);
  	  free (temp2);
  
***************
*** 5202,5206 ****
  
         /* Do initial variable expansion. */
!       temp1 = maybe_expand_string (temp, Q_DOUBLE_QUOTES, expand_string);
  
        goto arithsub;
--- 5134,5138 ----
  
         /* Do initial variable expansion. */
!       temp1 = expand_string_if_necessary (temp, Q_DOUBLE_QUOTES, expand_string);
  
        goto arithsub;
***************
*** 5218,5222 ****
  	{
  	  FREE (temp1);
! 	  temp = xmalloc (2);
  	  temp[0] = '$';
  	  temp[1] = '\0';
--- 5150,5154 ----
  	{
  	  FREE (temp1);
! 	  temp = (char *)xmalloc (2);
  	  temp[0] = '$';
  	  temp[1] = '\0';
***************
*** 5310,5314 ****
    WORD_LIST *list;
    WORD_DESC *tword;
-   SHELL_VAR *var;
  
    /* The intermediate string that we build while expanding. */
--- 5242,5245 ----
***************
*** 5342,5347 ****
    int tflag;
  
!   register int c;		/* Current character. */
!   int number;			/* Temporary number value. */
    int t_index;			/* For calls to string_extract_xxx. */
  
--- 5273,5278 ----
    int tflag;
  
!   register unsigned char c;	/* Current character. */
!   unsigned char uc;
    int t_index;			/* For calls to string_extract_xxx. */
  
***************
*** 5349,5353 ****
    char twochars[2];
  
!   istring = xmalloc (istring_size = DEFAULT_INITIAL_ARRAY_SIZE);
    istring[istring_index = 0] = '\0';
    quoted_dollar_at = had_quoted_null = has_dollar_at = 0;
--- 5280,5284 ----
    char twochars[2];
  
!   istring = (char *)xmalloc (istring_size = DEFAULT_INITIAL_ARRAY_SIZE);
    istring[istring_index = 0] = '\0';
    quoted_dollar_at = had_quoted_null = has_dollar_at = 0;
***************
*** 5373,5377 ****
      if (*temp1 != ' ' && *temp1 != '\t' && *temp1 != '\n')
  #endif
!       ifscmap[(unsigned char)*temp1] = 1;
  
    /* Begin the expansion. */
--- 5304,5311 ----
      if (*temp1 != ' ' && *temp1 != '\t' && *temp1 != '\n')
  #endif
!       {
!       	uc = *temp1;
!         ifscmap[uc] = 1;
!       }
  
    /* Begin the expansion. */
***************
*** 5388,5392 ****
  
  	case CTLESC:
! 	  temp = xmalloc (3);
  	  temp[0] = CTLESC;
  	  temp[1] = c = string[++sindex];
--- 5322,5326 ----
  
  	case CTLESC:
! 	  temp = (char *)xmalloc (3);
  	  temp[0] = CTLESC;
  	  temp[1] = c = string[++sindex];
***************
*** 5582,5586 ****
  	    {
  	      /* What we have is "".  This is a minor optimization. */
! 	      free (temp);
  	      list = (WORD_LIST *)NULL;
  	    }
--- 5516,5520 ----
  	    {
  	      /* What we have is "".  This is a minor optimization. */
! 	      FREE (temp);
  	      list = (WORD_LIST *)NULL;
  	    }
***************
*** 5771,5774 ****
--- 5705,5711 ----
  	    tword->flags |= W_QUOTED;
  	}
+ #else
+       else
+ 	list = (WORD_LIST *)NULL;
  #endif
      }
***************
*** 5829,5836 ****
  {
    char *r, *result_string, *temp;
!   int sindex, tindex, c, dquote;
  
    /* The result can be no longer than the original string. */
!   r = result_string = xmalloc (strlen (string) + 1);
  
    for (dquote = sindex = 0; c = string[sindex];)
--- 5766,5774 ----
  {
    char *r, *result_string, *temp;
!   int sindex, tindex, dquote;
!   unsigned char c;
  
    /* The result can be no longer than the original string. */
!   r = result_string = (char *)xmalloc (strlen (string) + 1);
  
    for (dquote = sindex = 0; c = string[sindex];)
***************
*** 6455,6459 ****
    if ((eflags & WEXP_VARASSIGN) && subst_assign_varlist)
      {
!       Function *assign_func;
  
        /* If the remainder of the words expand to nothing, Posix.2 requires
--- 6393,6397 ----
    if ((eflags & WEXP_VARASSIGN) && subst_assign_varlist)
      {
!       sh_assign_func_t *assign_func;
  
        /* If the remainder of the words expand to nothing, Posix.2 requires
diff -Nrc2 bash-2.05/subst.h bash-2.05a/subst.h
*** bash-2.05/subst.h	Sat Oct 14 17:46:02 2000
--- bash-2.05a/subst.h	Wed Sep 19 09:46:26 2001
***************
*** 73,76 ****
--- 73,82 ----
  extern char *string_list __P((WORD_LIST *));
  
+ /* Turn $* into a single string, obeying POSIX rules. */
+ extern char *string_list_dollar_star __P((WORD_LIST *));
+ 
+ /* Expand $@ into a single string, obeying POSIX rules. */
+ extern char *string_list_dollar_at __P((WORD_LIST *, int));
+ 
  /* Perform quoted null character removal on each element of LIST.
     This modifies LIST. */
***************
*** 89,98 ****
     expansion on the right-hand side.  Perform tilde expansion in any
     case.  Do not perform word splitting on the result of expansion. */
! extern int do_assignment __P((char *));
! extern int do_assignment_no_expand __P((char *));
! 
! #if defined (ARRAY_VARS)
! extern SHELL_VAR *do_array_element_assignment __P((char *, char *));
! #endif
  
  /* Append SOURCE to TARGET at INDEX.  SIZE is the current amount
--- 95,100 ----
     expansion on the right-hand side.  Perform tilde expansion in any
     case.  Do not perform word splitting on the result of expansion. */
! extern int do_assignment __P((const char *));
! extern int do_assignment_no_expand __P((const char *));
  
  /* Append SOURCE to TARGET at INDEX.  SIZE is the current amount
***************
*** 104,108 ****
  /* Append the textual representation of NUMBER to TARGET.
     INDEX and SIZE are as in SUB_APPEND_STRING. */
! extern char *sub_append_number __P((int, char *, int *, int *));
  
  /* Return the word list that corresponds to `$*'. */
--- 106,110 ----
  /* Append the textual representation of NUMBER to TARGET.
     INDEX and SIZE are as in SUB_APPEND_STRING. */
! extern char *sub_append_number __P((long, char *, int *, int *));
  
  /* Return the word list that corresponds to `$*'. */
***************
*** 119,123 ****
     and arithmetic expansion.  Dequote the resulting WORD_LIST before
     returning it, but do not perform word splitting.  The call to
!    remove_quoted_nulls () is in here because word splitting normally
     takes care of quote removal. */
  extern WORD_LIST *expand_string_unsplit __P((char *, int));
--- 121,125 ----
     and arithmetic expansion.  Dequote the resulting WORD_LIST before
     returning it, but do not perform word splitting.  The call to
!    remove_quoted_nulls () is made here because word splitting normally
     takes care of quote removal. */
  extern WORD_LIST *expand_string_unsplit __P((char *, int));
***************
*** 133,136 ****
--- 135,144 ----
  extern WORD_LIST *expand_string __P((char *, int));
  
+ /* Convenience functions that expand strings to strings, taking care of
+    converting the WORD_LIST * returned by the expand_string* functions
+    to a string and deallocating the WORD_LIST *. */
+ extern char *expand_string_to_string __P((char *, int));
+ extern char *expand_string_unsplit_to_string __P((char *, int));
+ 
  /* De-quoted quoted characters in STRING. */
  extern char *dequote_string __P((char *));
***************
*** 148,156 ****
  
  /* Return the value of a positional parameter.  This handles values > 10. */
! extern char *get_dollar_var_value __P((int));
  
  /* Quote a string to protect it from word splitting. */
  extern char *quote_string __P((char *));
  
  /* Perform quote removal on STRING.  If QUOTED > 0, assume we are obeying the
     backslash quoting rules for within double quotes. */
--- 156,168 ----
  
  /* Return the value of a positional parameter.  This handles values > 10. */
! extern char *get_dollar_var_value __P((long));
  
  /* Quote a string to protect it from word splitting. */
  extern char *quote_string __P((char *));
  
+ /* Quote escape characters (characters special to interals of expansion)
+    in a string. */
+ extern char *quote_escapes __P((char *));
+ 
  /* Perform quote removal on STRING.  If QUOTED > 0, assume we are obeying the
     backslash quoting rules for within double quotes. */
***************
*** 193,200 ****
  
  #if defined (ARRAY_VARS)
- extern int array_expand_index __P((char *, int));
- extern int valid_array_reference __P((char *));
- extern char *get_array_value __P((char *, int));
- extern SHELL_VAR *array_variable_part __P((char *, char **, int *));
  extern char *extract_array_assignment_list __P((char *, int *));
  #endif
--- 205,208 ----
diff -Nrc2 bash-2.05/support/bashbug.sh bash-2.05a/support/bashbug.sh
*** bash-2.05/support/bashbug.sh	Wed Mar 28 08:19:45 2001
--- bash-2.05a/support/bashbug.sh	Tue Oct 30 14:51:18 2001
***************
*** 4,12 ****
  #
  # The bug address depends on the release status of the shell.  Versions
! # with status `alpha' or `beta' mail bug reports to chet@po.cwru.edu.
  # Other versions send mail to bug-bash@gnu.org.
  #
  # configuration section:
! #	these variables are filled in by the make target in cpp-Makefile
  #
  MACHINE="!MACHINE!"
--- 4,13 ----
  #
  # The bug address depends on the release status of the shell.  Versions
! # with status `devel', `alpha', `beta', or `rc' mail bug reports to
! # chet@po.cwru.edu and, optionally, to bash-testers@po.cwru.edu.
  # Other versions send mail to bug-bash@gnu.org.
  #
  # configuration section:
! #	these variables are filled in by the make target in Makefile
  #
  MACHINE="!MACHINE!"
***************
*** 24,35 ****
  # If the OS supplies a program to make temp files with semi-random names,
  # use it.
! TEMP=/tmp/bbug.$$
! for d in /bin /usr/bin /usr/local/bin ; do
! 	if [ -x $d/mktemp ]; then
! 		TEMP=`$d/mktemp -t bbug ` ; break;
! 	elif [ -x $d/tempfile ]; then
! 		TEMP=` $d/tempfile --prefix bbug --mode 600 `; break
! 	fi
! done
  
  USAGE="Usage: $0 [--help] [--version] [bug-report-email-address]"
--- 25,54 ----
  # If the OS supplies a program to make temp files with semi-random names,
  # use it.
! : ${TMPDIR:=/tmp}
! rm_tmp1=false
! rm_tmp2=false
! 
! # if we don't have mktemp or tempfile, we don't want to see error messages
! # like `mktemp: not found', so temporarily redirect stderr using {...} while
! # trying to run them.  this may fail using old versions of the bourne shell
! # that run {...} blocks with redirections in subshells; in that case we're
! # no worse off than previous versions
! 
! { TEMPFILE1=`mktemp "$TMPDIR/bbug.XXXXXX" 2>/dev/null` ; } 2>/dev/null
! if [ -z "$TEMPFILE1" ]; then
! 	{ TEMPFILE1=`tempfile --prefix bbug --mode 600 2>/dev/null`; } 2>/dev/null
! fi
! if [ -z "$TEMPFILE1" ]; then
! 	TEMPFILE1=$TMPDIR/bbug.$$
! 	rm_tmp1=true
! fi
! { TEMPFILE2=`mktemp "$TMPDIR/bbug.XXXXXX" 2>/dev/null`; } 2>/dev/null
! if [ -z "$TEMPFILE2" ]; then
! 	{ TEMPFILE2=`tempfile --prefix bbug --mode 600 2>/dev/null`; } 2>/dev/null
! fi
! if [ -z "$TEMPFILE2" ]; then
! 	TEMPFILE2="$TMPDIR/bbug.$$.x"
! 	rm_tmp2=true
! fi
  
  USAGE="Usage: $0 [--help] [--version] [bug-report-email-address]"
***************
*** 84,93 ****
  
  case "$RELSTATUS" in
! alpha*|beta*|devel*)	BUGBASH=chet@po.cwru.edu ;;
! *)			BUGBASH=bug-bash@gnu.org ;;
  esac
  
  case "$RELSTATUS" in
! alpha*|beta*|devel*)
  		echo "$0: This is a testing release.  Would you like your bug report"
  		echo "$0: to be sent to the bash-testers mailing list?"
--- 103,112 ----
  
  case "$RELSTATUS" in
! alpha*|beta*|devel*|rc*)	BUGBASH=chet@po.cwru.edu ;;
! *)				BUGBASH=bug-bash@gnu.org ;;
  esac
  
  case "$RELSTATUS" in
! alpha*|beta*|devel*|rc*)
  		echo "$0: This is a testing release.  Would you like your bug report"
  		echo "$0: to be sent to the bash-testers mailing list?"
***************
*** 131,136 ****
  : ${USER=${LOGNAME-`whoami`}}
  
! trap 'rm -f $TEMP $TEMP.x; exit 1' 1 2 3 13 15
! trap 'rm -f $TEMP $TEMP.x' 0
  
  UN=
--- 150,155 ----
  : ${USER=${LOGNAME-`whoami`}}
  
! trap 'rm -f "$TEMPFILE1" "$TEMPFILE2"; exit 1' 1 2 3 13 15
! trap 'rm -f "$TEMPFILE1" "$TEMPFILE2"' 0
  
  UN=
***************
*** 150,160 ****
  fi
  
! # this is raceable
! rm -f $TEMP
  
! cat > $TEMP <<EOF
  From: ${USER}
  To: ${BUGADDR}
! Subject: [50 character or so descriptive subject here (for reference)]
  
  Configuration Information [Automatically generated, do not change]:
--- 169,181 ----
  fi
  
! INITIAL_SUBJECT='[50 character or so descriptive subject here (for reference)]'
! 
! # this is raceable unless (hopefully) we used mktemp(1) or tempfile(1)
! $rm_tmp1 && rm -f "$TEMPFILE1"
  
! cat > "$TEMPFILE1" <<EOF
  From: ${USER}
  To: ${BUGADDR}
! Subject: ${INITIAL_SUBJECT}
  
  Configuration Information [Automatically generated, do not change]:
***************
*** 182,208 ****
  EOF
  
! # this is still raceable
! rm -f $TEMP.x
! cp $TEMP $TEMP.x
! chmod u+w $TEMP
  
  trap '' 2		# ignore interrupts while in editor
  
! until $EDITOR $TEMP; do
! 	echo "$0: editor \`$EDITOR' exited with nonzero status."
! 	echo "$0: Perhaps it was interrupted."
! 	echo "$0: Type \`y' to give up, and lose your bug report;"
! 	echo "$0: type \`n' to re-enter the editor."
! 	echo $n "$0: Do you want to give up? $c"
! 
! 	read ans
! 	case "$ans" in
! 	[Yy]*) exit 1 ;;
  	esac
  done
  
! trap 'rm -f $TEMP $TEMP.x; exit 1' 2	# restore trap on SIGINT
  
! if cmp -s $TEMP $TEMP.x
  then
  	echo "File not changed, no bug report submitted."
--- 203,262 ----
  EOF
  
! # this is still raceable unless (hopefully) we used mktemp(1) or tempfile(1)
! $rm_tmp2 && rm -f "$TEMPFILE2"
! 
! cp "$TEMPFILE1" "$TEMPFILE2"
! chmod u+w "$TEMPFILE1"
  
  trap '' 2		# ignore interrupts while in editor
  
! edstat=1
! while [ $edstat -ne 0 ]; do
! 	$EDITOR "$TEMPFILE1"
! 	edstat=$?
! 
! 	if [ $edstat -ne 0 ]; then
! 		echo "$0: editor \`$EDITOR' exited with nonzero status."
! 		echo "$0: Perhaps it was interrupted."
! 		echo "$0: Type \`y' to give up, and lose your bug report;"
! 		echo "$0: type \`n' to re-enter the editor."
! 		echo $n "$0: Do you want to give up? $c"
! 
! 		read ans
! 		case "$ans" in
! 		[Yy]*) exit 1 ;;
! 		esac
! 
! 		continue
! 	fi
! 
! 	# find the subject from the temp file and see if it's been changed
! 	CURR_SUB=`grep '^Subject: ' "$TEMPFILE1" | sed 's|^Subject:[ 	]*||' | sed 1q`
! 
! 	case "$CURR_SUB" in
! 	"${INITIAL_SUBJECT}")
! 		echo
! 		echo "$0: You have not changed the subject from the default."
! 		echo "$0: Please use a more descriptive subject header."
! 		echo "$0: Type \`y' to give up, and lose your bug report;"
! 		echo "$0: type \`n' to re-enter the editor."
! 		echo $n "$0: Do you want to give up? $c"
! 
! 		read ans
! 		case "$ans" in
! 		[Yy]*) exit 1 ;;
! 		esac
! 
! 		echo "$0:  The editor will be restarted in five seconds."
! 		sleep 5
! 		edstat=1
! 		;;
  	esac
+ 
  done
  
! trap 'rm -f "$TEMPFILE1" "$TEMPFILE2"; exit 1' 2	# restore trap on SIGINT
  
! if cmp -s "$TEMPFILE1" "$TEMPFILE2"
  then
  	echo "File not changed, no bug report submitted."
***************
*** 216,221 ****
  esac
  
! ${RMAIL} $SMARGS < $TEMP || {
! 	cat $TEMP >> $HOME/dead.bashbug
  	echo "$0: mail failed: report saved in $HOME/dead.bashbug" >&2
  }
--- 270,275 ----
  esac
  
! ${RMAIL} $SMARGS < "$TEMPFILE1" || {
! 	cat "$TEMPFILE1" >> $HOME/dead.bashbug
  	echo "$0: mail failed: report saved in $HOME/dead.bashbug" >&2
  }
diff -Nrc2 bash-2.05/support/bashversion.c bash-2.05a/support/bashversion.c
*** bash-2.05/support/bashversion.c	Wed Dec 31 19:00:00 1969
--- bash-2.05a/support/bashversion.c	Mon Oct 15 09:46:42 2001
***************
*** 0 ****
--- 1,140 ----
+ /* bashversion.c -- Display bash version information. */
+ 
+ /* Copyright (C) 2001 Free Software Foundation, Inc.
+ 
+    This file is part of GNU Bash, the Bourne Again SHell.
+ 
+    Bash is free software; you can redistribute it and/or modify it under
+    the terms of the GNU General Public License as published by the Free
+    Software Foundation; either version 2, or (at your option) any later
+    version.
+ 
+    Bash is distributed in the hope that it will be useful, but WITHOUT ANY
+    WARRANTY; without even the implied warranty of MERCHANTABILITY or
+    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+    for more details.
+ 
+    You should have received a copy of the GNU General Public License along
+    with Bash; see the file COPYING.  If not, write to the Free Software
+    Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. */
+ 
+ #include "config.h"
+ 
+ #include "stdc.h"
+ 
+ #include <stdio.h>
+ #include "bashansi.h"
+ 
+ #include "version.h"
+ #include "conftypes.h"
+ 
+ #define RFLAG	0x0001
+ #define VFLAG	0x0002
+ #define MFLAG	0x0004
+ #define PFLAG	0x0008
+ #define SFLAG	0x0010
+ #define LFLAG	0x0020
+ #define XFLAG	0x0040
+ 
+ extern int optind;
+ extern char *optarg;
+ 
+ extern char *dist_version;
+ extern int patch_level;
+ 
+ char *shell_name = "bash";
+ char *progname;
+ 
+ static void
+ usage()
+ {
+   fprintf(stderr, "%s: usage: %s [-hrvpmlsx]\n", progname, progname);
+ }
+ 
+ int
+ main (argc, argv)
+      int argc;
+      char **argv;
+ {
+   int opt, oflags;
+   char dv[128], *rv;
+ 
+   if (progname = strrchr (argv[0], '/'))
+     progname++;
+   else
+     progname = argv[0];
+ 
+   oflags = 0;
+   while ((opt = getopt(argc, argv, "hrvmpslx")) != EOF)
+     {
+       switch (opt)
+ 	{
+ 	case 'h':
+ 	  usage ();
+ 	  exit (0);
+ 	case 'r':
+ 	  oflags |= RFLAG;	/* release */
+ 	  break;
+ 	case 'v':
+ 	  oflags |= VFLAG;	/* version */
+ 	  break;
+ 	case 'm':
+ 	  oflags |= MFLAG;	/* machtype */
+ 	  break;
+ 	case 'p':
+ 	  oflags |= PFLAG;	/* patchlevel */
+ 	  break;
+ 	case 's':		/* short version string */
+ 	  oflags |= SFLAG;
+ 	  break;
+ 	case 'l':		/* long version string */
+ 	  oflags |= LFLAG;
+ 	  break;
+ 	case 'x':		/* extended version information */
+ 	  oflags |= XFLAG;
+ 	  break;
+ 	default:
+ 	  usage ();
+ 	  exit (2);
+ 	}
+     }
+ 
+   argc -= optind;
+   argv += optind;
+ 
+   if (argc > 0)
+     {
+       usage ();
+       exit (2);
+     }
+ 
+   /* default behavior */  
+   if (oflags == 0)
+     oflags = SFLAG;
+ 
+   if (oflags & (RFLAG|VFLAG))
+     {
+       strcpy (dv, dist_version);
+       rv = strchr (dv, '.');
+       if (rv)
+         *rv++ = '\0';
+       else
+         rv = "00";
+     }
+   if (oflags & RFLAG)
+     printf ("%s\n", dv);
+   else if (oflags & VFLAG)
+     printf ("%s\n", rv);
+   else if (oflags & MFLAG)
+     printf ("%s\n", MACHTYPE);
+   else if (oflags & PFLAG)
+     printf ("%d\n", patch_level);
+   else if (oflags & SFLAG)
+     printf ("%s\n", shell_version_string ());
+   else if (oflags & LFLAG)
+     show_shell_version (0);
+   else if (oflags & XFLAG)
+     show_shell_version (1);
+ 
+   exit (0);
+ }
diff -Nrc2 bash-2.05/support/config.guess bash-2.05a/support/config.guess
*** bash-2.05/support/config.guess	Mon Dec 18 10:43:18 2000
--- bash-2.05a/support/config.guess	Mon Aug 20 15:23:13 2001
***************
*** 696,705 ****
          exit 0 ;;
      *:FreeBSD:*:*)
! 	if test -x /usr/bin/objformat; then
! 	    if test "elf" = "`/usr/bin/objformat`"; then
! 		echo ${UNAME_MACHINE}-unknown-freebsdelf`echo ${UNAME_RELEASE}|sed -e 's/[-_].*//'`
! 		exit 0
! 	    fi
! 	fi
  	echo ${UNAME_MACHINE}-unknown-freebsd`echo ${UNAME_RELEASE}|sed -e 's/[-=(].*//'`
  	exit 0 ;;
--- 696,705 ----
          exit 0 ;;
      *:FreeBSD:*:*)
! #	if test -x /usr/bin/objformat; then
! #	    if test "elf" = "`/usr/bin/objformat`"; then
! #		echo ${UNAME_MACHINE}-unknown-freebsdelf`echo ${UNAME_RELEASE}|sed -e 's/[-_].*//'`
! #		exit 0
! #	    fi
! #	fi
  	echo ${UNAME_MACHINE}-unknown-freebsd`echo ${UNAME_RELEASE}|sed -e 's/[-=(].*//'`
  	exit 0 ;;
diff -Nrc2 bash-2.05/support/fixlinks bash-2.05a/support/fixlinks
*** bash-2.05/support/fixlinks	Thu Feb 15 15:39:20 1996
--- bash-2.05a/support/fixlinks	Tue Oct 30 14:26:37 2001
***************
*** 36,50 ****
  fi
  
! rm -f /tmp/z
  # if the user specified hard links, then do that.  otherwise, try to use
  # symlinks if they're present
  if [ -n "$hardlinks" ]; then
  	LN=ln
! elif (ln -s /dev/null /tmp/z) >/dev/null 2>&1; then
  	LN="ln -s"
  else
  	LN=ln
  fi
! rm -f /tmp/z
  
  while read name target
--- 36,58 ----
  fi
  
! rm_ltmp=false
! LINKTEMP=`mktemp -t linktmp.XXXXXXXX 2>/dev/null`
! if [ -z "$LINKTEMP" ]; then
! 	: ${TMPDIR:=/tmp}
! 	LINKTEMP=${TMPDIR}/linktmp.$$
! 	rm_ltmp=true
! fi
! 
! $rm_ltmp && rm -f ${LINKTEMP}
  # if the user specified hard links, then do that.  otherwise, try to use
  # symlinks if they're present
  if [ -n "$hardlinks" ]; then
  	LN=ln
! elif (ln -s /dev/null ${LINKTEMP}) >/dev/null 2>&1; then
  	LN="ln -s"
  else
  	LN=ln
  fi
! rm -f ${LINKTEMP}
  
  while read name target
diff -Nrc2 bash-2.05/support/mkclone bash-2.05a/support/mkclone
*** bash-2.05/support/mkclone	Thu Apr 11 16:08:59 1996
--- bash-2.05a/support/mkclone	Tue Oct 30 14:26:35 2001
***************
*** 40,54 ****
  fi
  
! rm -f /tmp/z
  # if the user specified hard links, then do that.  otherwise, try to use
  # symlinks if they're present
  if [ -n "$hardlinks" ]; then
!         LN=ln
! elif (ln -s /dev/null /tmp/z) >/dev/null 2>&1; then
!         LN="ln -s"
  else
!         LN=ln
  fi
! rm -f /tmp/z
  
  TARGET=$1
--- 40,62 ----
  fi
  
! rm_ltmp=false
! LINKTEMP=`mktemp -t linktmp.XXXXXXXX 2>/dev/null`
! if [ -z "$LINKTEMP" ]; then
! 	: ${TMPDIR:=/tmp}
! 	LINKTEMP=${TMPDIR}/linktmp.$$
! 	rm_ltmp=true
! fi
! 
! $rm_ltmp && rm -f ${LINKTEMP}
  # if the user specified hard links, then do that.  otherwise, try to use
  # symlinks if they're present
  if [ -n "$hardlinks" ]; then
! 	LN=ln
! elif (ln -s /dev/null ${LINKTEMP}) >/dev/null 2>&1; then
! 	LN="ln -s"
  else
! 	LN=ln
  fi
! rm -f ${LINKTEMP}
  
  TARGET=$1
***************
*** 96,102 ****
  	$ECHO cp -p $SRCDIR/$sf $TARGET
  done
- 
- $ECHO $LN $SRCDIR/.distribution .
- $ECHO $LN $SRCDIR/.patchlevel .
  
  exit 0
--- 104,107 ----
diff -Nrc2 bash-2.05/support/mksignames.c bash-2.05a/support/mksignames.c
*** bash-2.05/support/mksignames.c	Tue Mar 28 10:12:40 2000
--- bash-2.05a/support/mksignames.c	Thu Aug  2 16:36:21 2001
***************
*** 20,23 ****
--- 20,25 ----
     Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. */
  
+ #include "config.h"
+ 
  #include <stdio.h>
  #include <sys/types.h>
***************
*** 33,37 ****
  #endif
  
! char *signal_names[2 * NSIG];
  
  #define signal_names_size (sizeof(signal_names)/sizeof(signal_names[0]))
--- 35,47 ----
  #endif
  
! /*
!  * Special traps:
!  *	EXIT == 0
!  *	DEBUG == NSIG
!  *	ERR == NSIG+1
!  */
! #define LASTSIG NSIG+1
! 
! char *signal_names[2 * NSIG + 3];
  
  #define signal_names_size (sizeof(signal_names)/sizeof(signal_names[0]))
***************
*** 106,112 ****
  	{
  	  signal_names[rtmin+i] = (char *)malloc(RTLEN);
! 	  sprintf (signal_names[rtmin+i], "SIGRTMIN+%d", i);
  	  signal_names[rtmax-i] = (char *)malloc(RTLEN);
! 	  sprintf (signal_names[rtmax-i], "SIGRTMAX-%d", i);
  	}
  
--- 116,124 ----
  	{
  	  signal_names[rtmin+i] = (char *)malloc(RTLEN);
! 	  if (signal_names[rtmin+i])
! 	    sprintf (signal_names[rtmin+i], "SIGRTMIN+%d", i);
  	  signal_names[rtmax-i] = (char *)malloc(RTLEN);
! 	  if (signal_names[rtmax-i])
! 	    sprintf (signal_names[rtmax-i], "SIGRTMAX-%d", i);
  	}
  
***************
*** 115,119 ****
  	  /* Need an extra RTMIN signal */
  	  signal_names[rtmin+rtcnt+1] = (char *)malloc(RTLEN);
! 	  sprintf (signal_names[rtmin+rtcnt+1], "SIGRTMIN+%d", rtcnt+1);
  	}
      }
--- 127,132 ----
  	  /* Need an extra RTMIN signal */
  	  signal_names[rtmin+rtcnt+1] = (char *)malloc(RTLEN);
! 	  if (signal_names[rtmin+rtcnt+1])
! 	    sprintf (signal_names[rtmin+rtcnt+1], "SIGRTMIN+%d", rtcnt+1);
  	}
      }
***************
*** 351,358 ****
        {
  	signal_names[i] = (char *)malloc (18);
! 	sprintf (signal_names[i], "SIGJUNK(%d)", i);
        }
  
    signal_names[NSIG] = "DEBUG";
  }
  
--- 364,373 ----
        {
  	signal_names[i] = (char *)malloc (18);
! 	if (signal_names[i])
! 	  sprintf (signal_names[i], "SIGJUNK(%d)", i);
        }
  
    signal_names[NSIG] = "DEBUG";
+   signal_names[NSIG+1] = "ERR";
  }
  
***************
*** 368,377 ****
    fprintf (stream,
  	   "/* A translation list so we can be polite to our users. */\n");
!   fprintf (stream, "char *signal_names[NSIG + 2] = {\n");
  
!   for (i = 0; i <= NSIG; i++)
      fprintf (stream, "    \"%s\",\n", signal_names[i]);
  
!   fprintf (stream, "    (char *)0x0,\n");
    fprintf (stream, "};\n");
  }
--- 383,392 ----
    fprintf (stream,
  	   "/* A translation list so we can be polite to our users. */\n");
!   fprintf (stream, "char *signal_names[NSIG + 3] = {\n");
  
!   for (i = 0; i <= LASTSIG; i++)
      fprintf (stream, "    \"%s\",\n", signal_names[i]);
  
!   fprintf (stream, "    (char *)0x0\n");
    fprintf (stream, "};\n");
  }
diff -Nrc2 bash-2.05/support/mkversion.sh bash-2.05a/support/mkversion.sh
*** bash-2.05/support/mkversion.sh	Fri Dec 10 10:59:39 1999
--- bash-2.05a/support/mkversion.sh	Mon Sep 10 11:50:10 2001
***************
*** 7,11 ****
  
  PROGNAME=`basename $0`
! USAGE="$PROGNAME [-b] -d version -p patchlevel [-s status] [-o outfile]"
  
  while [ $# -gt 0 ]; do
--- 7,13 ----
  
  PROGNAME=`basename $0`
! USAGE="$PROGNAME [-b] [-S srcdir] -d version -p patchlevel [-s status] [-o outfile]"
! 
! source_dir="."
  
  while [ $# -gt 0 ]; do
***************
*** 16,19 ****
--- 18,22 ----
  	-p)	shift; patch_level=$1; shift ;;
  	-d)	shift; dist_version=$1; shift ;;
+ 	-S)	shift; source_dir="$1"; shift ;;
  	*)	echo "$PROGNAME: usage: $USAGE" >&2 ; exit 2 ;;
  	esac
***************
*** 27,35 ****
  fi
  
! if [ -z "$patch_level" ]; then
! 	echo "${PROGNAME}: required argument -p missing" >&2
! 	echo "$PROGNAME: usage: $USAGE" >&2
! 	exit 1
! fi
  
  # Defaults
--- 30,38 ----
  fi
  
! #if [ -z "$patch_level" ]; then
! #	echo "${PROGNAME}: required argument -p missing" >&2
! #	echo "$PROGNAME: usage: $USAGE" >&2
! #	exit 1
! #fi
  
  # Defaults
***************
*** 52,55 ****
--- 55,69 ----
  fi
  
+ # what's the patch level?
+ if [ -z "$patch_level" ]; then
+ 	patchlevel_h=$source_dir/patchlevel.h
+ 	if [ -s $patchlevel_h ]; then
+ 		patch_level=`cat $patchlevel_h | grep '^#define[ 	]*PATCHLEVEL' | awk '{print $NF}'`
+ 	fi
+ fi
+ if [ -z "$patch_level" ]; then
+ 	patch_level=0
+ fi
+ 
  # If we have an output file specified, make it the standard output
  if [ -n "$OUTFILE" ]; then
***************
*** 67,72 ****
--- 81,89 ----
  
  # Output the distribution version.  Single numbers are converted to x.00.
+ # Allow, as a special case, `[:digit:].[:digit:][:digit:][:alpha:]' for
+ # intermediate versions (e.g., `2.05a').
  # Any characters other than digits and `.' are invalid.
  case "$dist_version" in
+ [0-9].[0-9][0-9][a-z])	;;	# special case
  *[!0-9.]*)	echo "mkversion.sh: ${dist_version}: bad distribution version" >&2
  		exit 1 ;;
***************
*** 81,84 ****
--- 98,102 ----
  case "$dist_minor" in
  "")	dist_minor=00 ;;
+ [a-z])	dist_minor=00${dist_minor} ;;
  ?)	dist_minor=0${dist_minor} ;;
  *)	;;
***************
*** 93,99 ****
  
  # Output the patch level
! echo
! echo "/* The patch level of this version of the shell. */"
! echo "#define PATCHLEVEL ${patch_level}"
  
  # Output the build version
--- 111,117 ----
  
  # Output the patch level
! #echo
! #echo "/* The patch level of this version of the shell. */"
! #echo "#define PATCHLEVEL ${patch_level}"
  
  # Output the build version
***************
*** 112,115 ****
--- 130,139 ----
  echo "/* A version string for use by sccs and the what command. */"
  echo "#define SCCSVERSION \"@(#)Bash version ${sccs_string}\""
+ 
+ # extern function declarations
+ echo
+ echo '/* Functions from version.c. */'
+ echo 'extern char *shell_version_string __P((void));'
+ echo 'extern void show_shell_version __P((int));'
  
  if [ -n "$inc_build" ]; then
diff -Nrc2 bash-2.05/support/shobj-conf bash-2.05a/support/shobj-conf
*** bash-2.05/support/shobj-conf	Tue Jan  2 11:15:44 2001
--- bash-2.05a/support/shobj-conf	Thu Aug 23 13:05:02 2001
***************
*** 78,82 ****
  	;;
  
! freebsd2* | netbsd* | openbsd*)
  	SHOBJ_CFLAGS=-fpic
  	SHOBJ_LD=ld
--- 78,92 ----
  	;;
  
! # All versions of Linux or the semi-mythical GNU Hurd.
! linux*|gnu*)
! 	SHOBJ_CFLAGS=-fPIC
! 	SHOBJ_LD='${CC}'
! 	SHOBJ_LDFLAGS='-shared -Wl,-soname,$@'
! 
! 	SHLIB_XLDFLAGS='-Wl,-rpath,$(libdir) -Wl,-soname,`basename $@ $(SHLIB_MINOR)`'
! 	SHLIB_LIBVERSION='$(SHLIB_LIBSUFF).$(SHLIB_MAJOR)$(SHLIB_MINOR)'
! 	;;
! 
! freebsd2* | netbsd*)
  	SHOBJ_CFLAGS=-fpic
  	SHOBJ_LD=ld
***************
*** 87,100 ****
  	;;
  
- # FreeBSD-3.x can have either a.out or ELF object files
- #freebsd3*)
- #	SHOBJ_CFLAGS=-fpic
- #	SHOBJ_LD='${CC}'
- #	SHOBJ_LDFLAGS='-shared'
- #
- #	SHLIB_XLDFLAGS='-R$(libdir)'
- #	SHLIB_LIBVERSION='$(SHLIB_LIBSUFF).$(SHLIB_MAJOR)$(SHLIB_MINOR)'
- #	;;
- 
  # FreeBSD-3.x ELF
  freebsd[3-9]*|freebsdelf[3-9]*|freebsdaout[3-9]*)
--- 97,100 ----
***************
*** 114,124 ****
  	fi
  	;;
! # All versions of Linux or the semi-mythical GNU Hurd.
! linux*|gnu*)
  	SHOBJ_CFLAGS=-fPIC
  	SHOBJ_LD='${CC}'
! 	SHOBJ_LDFLAGS='-shared -Wl,-soname,$@'
  
! 	SHLIB_XLDFLAGS='-Wl,-rpath,$(libdir) -Wl,-soname,`basename $@ $(SHLIB_MINOR)`'
  	SHLIB_LIBVERSION='$(SHLIB_LIBSUFF).$(SHLIB_MAJOR)$(SHLIB_MINOR)'
  	;;
--- 114,142 ----
  	fi
  	;;
! 
! # Darwin/MacOS X
! darwin*|macosx*)
! 	SHOBJ_STATUS=unsupported
! 	SHLIB_STATUS=supported
! 
! 	SHOBJ_CFLAGS='-dynamic -fno-common'
! 
! 	SHOBJ_LD=/usr/bin/libtool
! 
! 	SHLIB_LIBVERSION='$(SHLIB_MAJOR)$(SHLIB_MINOR).$(SHLIB_LIBSUFF)'
! 	SHLIB_LIBSUFF='dylib'
! 
! 	SHOBJ_LDFLAGS='-dynamic'
! 	SHLIB_XLDFLAGS='-arch_only `/usr/bin/arch` -install_name $(libdir)/$@ -current_version $(SHLIB_MAJOR)$(SHLIB_MINOR) -compatibility_version $(SHLIB_MAJOR) -v'
! 
! 	SHLIB_LIBS='-lSystem'
! 	;;
! 
! openbsd*)
  	SHOBJ_CFLAGS=-fPIC
  	SHOBJ_LD='${CC}'
! 	SHOBJ_LDFLAGS='-shared'
  
! 	SHLIB_XLDFLAGS='-R$(libdir)'
  	SHLIB_LIBVERSION='$(SHLIB_LIBSUFF).$(SHLIB_MAJOR)$(SHLIB_MINOR)'
  	;;
***************
*** 240,243 ****
--- 258,275 ----
  	SHOBJ_STATUS=unsupported
  	SHLIB_STATUS=unsupported
+ 
+ 	# If you are using the HP ANSI C compiler, you can uncomment and use
+ 	# this code (I have not tested it)
+ #	SHOBJ_STATUS=supported
+ #	SHLIB_STATUS=supported
+ #
+ #	SHOBJ_CFLAGS='+z'
+ #	SHOBJ_LD='ld'
+ #	SHOBJ_LDFLAGS='-b +s'
+ #
+ #	SHLIB_XLDFLAGS='+b $(libdir)'
+ #	SHLIB_LIBSUFF='sl'
+ #	SHLIB_LIBVERSION='$(SHLIB_LIBSUFF).$(SHLIB_MAJOR)'	
+ 
  	;;
  
***************
*** 258,272 ****
  
  	# If you are using the HP ANSI C compiler, you can uncomment and use
! 	# this code
! #	SHOBJ_STATUS=unsupported
! #	SHLIB_STATUS=unsupported
  #
  #	SHOBJ_CFLAGS='+z'
  #	SHOBJ_LD='ld'
! #	SHOBJ_LDFLAGS='-b'
  #
! #	SHLIB_XLDFLAGS=''
  #	SHLIB_LIBSUFF='sl'
  #	SHLIB_LIBVERSION='$(SHLIB_LIBSUFF).$(SHLIB_MAJOR)'	
  	;;
  
--- 290,305 ----
  
  	# If you are using the HP ANSI C compiler, you can uncomment and use
! 	# this code (I have not tested it)
! #	SHOBJ_STATUS=supported
! #	SHLIB_STATUS=supported
  #
  #	SHOBJ_CFLAGS='+z'
  #	SHOBJ_LD='ld'
! #	SHOBJ_LDFLAGS='-b +s +h $@'
  #
! #	SHLIB_XLDFLAGS='+b $(libdir)'
  #	SHLIB_LIBSUFF='sl'
  #	SHLIB_LIBVERSION='$(SHLIB_LIBSUFF).$(SHLIB_MAJOR)'	
+ 
  	;;
  
***************
*** 288,300 ****
  
  	# If you are using the HP ANSI C compiler, you can uncomment and use
! 	# this code
! #	SHOBJ_STATUS=unsupported
! #	SHLIB_STATUS=unsupported
  #
  #	SHOBJ_CFLAGS='+z'
  #	SHOBJ_LD='ld'
! #	SHOBJ_LDFLAGS='-b'
  #
! #	SHLIB_XLDFLAGS=''
  #	SHLIB_LIBSUFF='sl'
  #	SHLIB_LIBVERSION='$(SHLIB_LIBSUFF).$(SHLIB_MAJOR)'	
--- 321,333 ----
  
  	# If you are using the HP ANSI C compiler, you can uncomment and use
! 	# this code (I have not tested it)
! #	SHOBJ_STATUS=supported
! #	SHLIB_STATUS=supported
  #
  #	SHOBJ_CFLAGS='+z'
  #	SHOBJ_LD='ld'
! #	SHOBJ_LDFLAGS='-b +s +h $@'
  #
! #	SHLIB_XLDFLAGS='+b $(libdir)'
  #	SHLIB_LIBSUFF='sl'
  #	SHLIB_LIBVERSION='$(SHLIB_LIBSUFF).$(SHLIB_MAJOR)'	
diff -Nrc2 bash-2.05/support/texi2dvi bash-2.05a/support/texi2dvi
*** bash-2.05/support/texi2dvi	Mon Apr 27 12:00:44 1998
--- bash-2.05a/support/texi2dvi	Tue Sep 28 15:36:53 1999
***************
*** 1,7 ****
  #! /bin/sh
! # texi2dvi --- smartly produce DVI files from texinfo sources
! # $Id: texi2dvi,v 0.8 1998/02/26 21:13:13 karl Exp $
  #
! # Copyright (C) 1992, 93, 94, 95, 96, 97, 98 Free Software Foundation, Inc.
  #
  # This program is free software; you can redistribute it and/or modify
--- 1,7 ----
  #! /bin/sh
! # texi2dvi --- produce DVI (or PDF) files from Texinfo (or LaTeX) sources.
! # $Id: texi2dvi,v 0.43 1999/09/28 19:36:53 karl Exp $
  #
! # Copyright (C) 1992, 93, 94, 95, 96, 97, 98, 99 Free Software Foundation, Inc.
  #
  # This program is free software; you can redistribute it and/or modify
***************
*** 20,324 ****
  # Inc.; 59 Temple Place, Suite 330; Boston, MA 02111-1307, USA.
  #
! # Commentary:
! #
! # Author: Noah Friedman <friedman@gnu.org>
  #
  # Please send bug reports, etc. to bug-texinfo@gnu.org.
  # If possible, please send a copy of the output of the script called with
  # the `--debug' option when making a bug report.
- #
- # In the interest of general portability, some common bourne shell
- # constructs were avoided because they weren't guaranteed to be available
- # in some earlier implementations.  I've tried to make this program as
- # portable as possible.  Welcome to unix, where the lowest common
- # denominator is rapidly diminishing.
- #
- # Among the more interesting lossages I noticed among Bourne shells:
- #     * No shell functions.
- #     * No `unset' builtin.
- #     * `shift' cannot take a numeric argument, and signals an error if
- #       there are no arguments to shift.
- #
- # Code:
- 
- # Name by which this script was invoked.
- progname=`echo "$0" | sed -e 's/[^\/]*\///g'`
  
  # This string is expanded by rcs automatically when this file is checked out.
! rcs_revision='$Revision: 0.8 $'
! version=`set - $rcs_revision; echo $2`
  
! # To prevent hairy quoting and escaping later.
! bq='`'
! eq="'"
  
! usage="Usage: $0 [OPTION]... FILE...
! Run a Texinfo document through TeX.
  
! Options:
! -b, --batch          No interaction (\nonstopmode in TeX).
! -c, --clean          Remove all auxiliary files.
! -D, --debug          Turn on shell debugging ($bq${bq}set -x$eq$eq).
! -t, --texinfo CMD    Insert CMD after @setfilename before running TeX.
! --verbose            Report on what is done.
! -h, --help           Display this help and exit.
! -v, --version        Display version information and exit.
  
! The values of the TEX, TEXINDEX, and MAKEINFO environment variables are
! used to run those commands, if they are set.
  
! Email bug reports to bug-texinfo@gnu.org."
  
! # Initialize variables.
  # Don't use `unset' since old bourne shells don't have this command.
  # Instead, assign them an empty value.
! # Some of these, like TEX and TEXINDEX, may be inherited from the environment.
! backup_extension=.bak # these files get deleted if all goes well.
! batch=
  clean=
  debug=
! orig_pwd="`pwd`"
  textra=
! verbose=false
! makeinfo="${MAKEINFO-makeinfo}"
! texindex="${TEXINDEX-texindex}"
! tex="${TEX-tex}"
  
  # Save this so we can construct a new TEXINPUTS path for each file.
  TEXINPUTS_orig="$TEXINPUTS"
! export TEXINPUTS
  
  # Parse command line arguments.
! # Make sure that all wildcarded options are long enough to be unambiguous.
! # It's a good idea to document the full long option name in each case.
! # Long options which take arguments will need a `*' appended to the
! # canonical name to match the value appended after the `=' character.
! while :; do
!   test $# -eq 0 && break
!   
    case "$1" in
!     -b | --batch | --b* ) batch=t; shift ;;
!     -c | --clean | --c* ) clean=t; shift ;;
!     -D | --debug | --d* ) debug=t; shift ;;
!     -h | --help | --h* )   echo "$usage"; exit 0 ;;
!     # OK, we should do real option parsing here, but be lazy for now.
!     -t | --texinfo | --t*) shift; textra="$textra $1"; shift ;; 
!     -v | --vers* )
!       echo "$progname (GNU Texinfo 3.12) $version"
!       echo "Copyright (C) 1998 Free Software Foundation, Inc.
! There is NO warranty.  You may redistribute this software
! under the terms of the GNU General Public License.
! For more information about these matters, see the files named COPYING."
!       exit 0 ;;
!     --verb* )            verbose=echo; shift ;;
!     -- )     # Stop option processing
        shift
!       break ;;
!     -* )
!       case "$1" in
!         --*=* ) arg=`echo "$1" | sed -e 's/=.*//'` ;;
!         * )     arg="$1" ;;
!       esac
!       exec 1>&2
!       echo "$progname: Unknown or ambiguous option $bq$arg$eq."
!       echo "$progname: Try $bq--help$eq for more information."
!       exit 1 ;;
!     * ) break ;;
     esac
  done
  
! # See if there are any command line args left (which will be interpreted as
! # filename arguments).
! if test $# -eq 0; then
!   exec 1>&2
!   echo "$progname: At least one file name is required as an argument."
!   echo "$progname: Try $bq--help$eq for more information."
    exit 2
  fi
  
  test "$debug" = t && set -x
  
! # Texify files
  for command_line_filename in ${1+"$@"}; do
    $verbose "Processing $command_line_filename ..."
  
!   # See if file exists.  If it doesn't we're in trouble since, even
    # though the user may be able to reenter a valid filename at the tex
    # prompt (assuming they're attending the terminal), this script won't
!   # be able to find the right index files and so forth.
!   if test ! -r "${command_line_filename}"; then
!     echo "$0: Could not read ${command_line_filename}." >&2
      continue
    fi
  
!   # Roughly equivalent to `dirname ...`, but more portable
!   directory="`echo ${command_line_filename} | sed 's/\/[^\/]*$//'`"
!   filename_texi="`basename ${command_line_filename}`"
!   # Strip off the last extension part (probably .texinfo or .texi)
!   filename_noext="`echo ${filename_texi} | sed 's/\.[^.]*$//'`"
! 
!   # Use same basename since we want to generate aux files with the same
!   # basename as the manual.  Use extension .texi for the temp file so
!   # that TeX will ignore it.  Thus, we must use a subdirectory.
!   #
!   # Output the macro-expanded file to here.  The vastly abbreviated
!   # temporary directory name is so we don't have collisions on 8.3 or
!   # 14-character filesystems.
!   tmp_dir=${TMPDIR-/tmp}/txi2d.$$
!   filename_tmp=$tmp_dir/$filename_noext.texi
!   # Output the file with the user's extra commands to here.
!   tmp_dir2=${tmp_dir}.2
!   filename_tmp2=$tmp_dir2/$filename_noext.texi
!   mkdir $tmp_dir $tmp_dir2
!   # Always remove the temporary directories.
!   trap "rm -rf $tmp_dir $tmp_dir2" 1 2 15
! 
!   # If directory and file are the same, then it's probably because there's
!   # no pathname component.  Set dirname to `.', the current directory.
!   if test "z${directory}" = "z${command_line_filename}"; then
!     directory=.
!   fi
  
!   # Source file might @include additional texinfo sources.  Put `.' and
    # directory where source file(s) reside in TEXINPUTS before anything
!   # else.  `.' goes first to ensure that any old .aux, .cps, etc. files in
!   # ${directory} don't get used in preference to fresher files in `.'.
!   TEXINPUTS=".:${directory}:${TEXINPUTS_orig}"
  
!   # Expand macro commands in the original source file using Makeinfo;
!   #   the macro syntax bfox implemented is impossible to implement in TeX.
    # Always use `end' footnote style, since the `separate' style
    #   generates different output (arguably this is a bug in -E).
    # Discard main info output, the user asked to run TeX, not makeinfo.
!   # Redirect output to /dev/null to throw away `Making info file...' msg.
!   $verbose "Macro-expanding $command_line_filename to $filename_tmp ..."
!   $makeinfo --footnote-style=end -E $filename_tmp -o /dev/null \
!     $command_line_filename >/dev/null
! 
!   # But if there were no macros, or makeinfo failed for some reason,
!   # just use the original file.  (It shouldn't make any difference, but
!   # let's be safe.)
!   if test $? -ne 0 || cmp -s $filename_tmp $command_line_filename; then
      $verbose "Reverting to $command_line_filename ..."
!     cp -p $command_line_filename $filename_tmp
    fi
-   filename_input=$filename_tmp
-   dirname_input=$tmp_dir
  
    # Used most commonly for @finalout, @smallbook, etc.
    if test -n "$textra"; then
!     $verbose "Inserting extra commands: $textra."
      sed '/^@setfilename/a\
! '"$textra" $filename_input >$filename_tmp2
!    filename_input=$filename_tmp2
!    dirname_input=$tmp_dir2
    fi
  
    # If clean mode was specified, then move to the temporary directory.
    if test "$clean" = t; then
!     $verbose "cd $dirname_input"
!     cd $dirname_input || exit 1
!     filename_input=`basename $filename_input`
    fi
  
!   while true; do # will break out of loop below
!     # "Unset" variables that might have values from previous iterations and
!     # which won't be completely reset later.
!     definite_index_files=
! 
!     # Find all files having root filename with a two-letter extension,
!     # determine whether they're really index files, and save them.  Foo.aux
!     # is actually the cross-references file, but we need to keep track of
!     # that too.
!     possible_index_files="`eval echo ${filename_noext}.?? ${filename_noext}.aux`"
!     for this_file in ${possible_index_files}; do
!       # If file is empty, forget it.
!       test -s "${this_file}" || continue
! 
!       # Examine first character of file.  If it's not suitable to be an
!       # index or xref file, don't process it.
!       first_character="`sed -n '1s/^\(.\).*$/\1/p;q' ${this_file}`"
!       if test "x${first_character}" = "x\\" \
!          || test "x${first_character}" = "x'"; then
!         definite_index_files="${definite_index_files} ${this_file}"
        fi
-     done
-     orig_index_files="${definite_index_files}"
-     orig_index_files_sans_aux="`echo ${definite_index_files} \
-                                  | sed 's/'${filename_noext}'\.aux//;
-                                         s/^[ ]*//;s/[ ]*$//;'`"
- 
-     # Now save copies of original index files so we have some means of
-     # comparison later.
-     $verbose "Backing up current index files: $orig_index_files ..."  
-     for index_file_to_save in ${orig_index_files}; do
-       cp "${index_file_to_save}" "${index_file_to_save}${backup_extension}"
-     done
- 
-     # Run texindex on current index files.  If they already exist, and
-     # after running TeX a first time the index files don't change, then
-     # there's no reason to run TeX again.  But we won't know that if the
-     # index files are out of date or nonexistent.
-     if test -n "${orig_index_files_sans_aux}"; then
-       $verbose "Running $texindex $orig_index_files_sans_aux ..."
-       ${texindex} ${orig_index_files_sans_aux}
      fi
  
      # Finally, run TeX.
!     if test "$batch" = t; then
!       tex_mode='\nonstopmode'
!     else
!       tex_mode=
      fi
!     $verbose "Running $tex $filename_input ..."
!     cmd="$tex $tex_mode \\input $filename_input"
!     $cmd
! 
!     # Check if index files changed.
!     # 
!     definite_index_files=
!     # Get list of new index files.
!     possible_index_files="`eval echo ${filename_noext}.?? ${filename_noext}.aux`"
!     for this_file in ${possible_index_files}; do
!        # If file is empty, forget it.
!        test -s "${this_file}" || continue
! 
!        # Examine first character of file.  If it's not a backslash or
!        # single quote, then it's definitely not an index or xref file.
!        # (Will have to check for @ when we switch to Texinfo syntax in
!        # all these files...)
!        first_character="`sed -n '1s/^\(.\).*$/\1/p;q' ${this_file}`"
!        if test "x${first_character}" = "x\\" \
!           || test "x${first_character}" = "x'"; then
!          definite_index_files="${definite_index_files} ${this_file}"
!        fi
!     done
!     new_index_files="${definite_index_files}"
!     new_index_files_sans_aux="`echo ${definite_index_files} \
!                                | sed 's/'${filename_noext}'\.aux//;
!                                       s/^[ ]*//;s/[ ]*$//;'`"
! 
!     # If old and new list don't at least have the same file list, then one
!     # file or another has definitely changed.
!     $verbose "Original index files =$orig_index_files"
!     $verbose "New index files =$new_index_files"
!     if test "z${orig_index_files}" != "z${new_index_files}"; then
!       index_files_changed_p=t
!     else
!       # File list is the same.  We must compare each file until we find a
!       # difference.
!       index_files_changed_p=
!       for this_file in ${new_index_files}; do
!         $verbose "Comparing index file $this_file ..."
!         # cmp -s will return nonzero exit status if files differ.
!         cmp -s "${this_file}" "${this_file}${backup_extension}"
!         if test $? -ne 0; then
!           # We only need to keep comparing until we find *one* that
!           # differs, because we'll have to run texindex & tex no
!           # matter what.
!           index_files_changed_p=t
!           $verbose "Index file $this_file differed:"
!           test $verbose = echo \
!           && diff -c "${this_file}${backup_extension}" "${this_file}"
            break
          fi
--- 20,538 ----
  # Inc.; 59 Temple Place, Suite 330; Boston, MA 02111-1307, USA.
  #
! # Original author: Noah Friedman <friedman@gnu.org>.
  #
  # Please send bug reports, etc. to bug-texinfo@gnu.org.
  # If possible, please send a copy of the output of the script called with
  # the `--debug' option when making a bug report.
  
  # This string is expanded by rcs automatically when this file is checked out.
! rcs_revision='$Revision: 0.43 $'
! rcs_version=`set - $rcs_revision; echo $2`
! program=`echo $0 | sed -e 's!.*/!!'`
! version="texi2dvi (GNU Texinfo 4.0) $rcs_version
! 
! Copyright (C) 1999 Free Software Foundation, Inc.
! There is NO warranty.  You may redistribute this software
! under the terms of the GNU General Public License.
! For more information about these matters, see the files named COPYING."
  
! usage="Usage: $program [OPTION]... FILE...
  
! Run each Texinfo or LaTeX FILE through TeX in turn until all
! cross-references are resolved, building all indices.  The directory
! containing each FILE is searched for included files.  The suffix of FILE
! is used to determine its language (LaTeX or Texinfo).
  
! Makeinfo is used to perform Texinfo macro expansion before running TeX
! when needed.
  
! Options:
!   -@                   Use @input instead of \input; for preloaded Texinfo.
!   -b, --batch          No interaction.
!   -c, --clean          Remove all auxiliary files.
!   -D, --debug          Turn on shell debugging (set -x).
!   -e, --expand         Force macro expansion using makeinfo.
!   -I DIR               Search DIR for Texinfo files.
!   -h, --help           Display this help and exit successfully.
!   -l, --language=LANG  Specify the LANG of FILE: LaTeX or Texinfo.
!   -p, --pdf            Use pdftex or pdflatex for processing.
!   -q, --quiet          No output unless errors (implies --batch).
!   -s, --silent         Same as --quiet.
!   -t, --texinfo=CMD    Insert CMD after @setfilename in copy of input file.
!                        Multiple values accumulate.
!   -v, --version        Display version information and exit successfully.
!   -V, --verbose        Report on what is done.
! 
! The values of the BIBTEX, LATEX (or PDFLATEX), MAKEINDEX, MAKEINFO,
! TEX (or PDFTEX), and TEXINDEX environment variables are used to run
! those commands, if they are set.
  
! Email bug reports to <bug-texinfo@gnu.org>,
! general questions and discussion to <help-texinfo@gnu.org>."
  
! # Initialize variables for option overriding and otherwise.
  # Don't use `unset' since old bourne shells don't have this command.
  # Instead, assign them an empty value.
! escape='\'
! batch=false     # eval for batch mode
  clean=
  debug=
! expand=         # t for expansion via makeinfo
! oformat=dvi
! set_language=
! miincludes=     # makeinfo include path
  textra=
! tmpdir=${TMPDIR:-/tmp}/t2d$$  # avoid collisions on 8.3 filesystems.
! txincludes=     # TEXINPUTS extensions
! txiprereq=19990129 # minimum texinfo.tex version to have macro expansion
! quiet=          # by default let the tools' message be displayed
! verbose=false   # echo for verbose mode
! 
! orig_pwd=`pwd`
! 
! # Systems which define $COMSPEC or $ComSpec use semicolons to separate
! # directories in TEXINPUTS.
! if test -n "$COMSPEC$ComSpec"; then
!   path_sep=";"
! else
!   path_sep=":"
! fi
  
  # Save this so we can construct a new TEXINPUTS path for each file.
  TEXINPUTS_orig="$TEXINPUTS"
! # Unfortunately makeindex does not read TEXINPUTS.
! INDEXSTYLE_orig="$INDEXSTYLE"
! export TEXINPUTS INDEXSTYLE
! 
! # Push a token among the arguments that will be used to notice when we
! # ended options/arguments parsing.
! # Use "set dummy ...; shift" rather than 'set - ..." because on
! # Solaris set - turns off set -x (but keeps set -e).
! # Use ${1+"$@"} rather than "$@" because Digital Unix and Ultrix 4.3
! # still expand "$@" to a single argument (the empty string) rather
! # than nothing at all.
! arg_sep="$$--$$"
! set dummy ${1+"$@"} "$arg_sep"; shift
  
+ # 
  # Parse command line arguments.
! while test x"$1" != x"$arg_sep"; do
! 
!   # Handle --option=value by splitting apart and putting back on argv.
    case "$1" in
!     --*=*)
!       opt=`echo "$1" | sed -e 's/=.*//'`
!       val=`echo "$1" | sed -e 's/[^=]*=//'`
        shift
!       set dummy "$opt" "$val" ${1+"$@"}; shift
!       ;;
!   esac
! 
!   # This recognizes --quark as --quiet.  So what.
!   case "$1" in
!     -@ ) escape=@;;
!     # Silently and without documentation accept -b and --b[atch] as synonyms.
!     -b | --b*) batch=eval;;
!     -q | -s | --q* | --s*) quiet=t; batch=eval;;
!     -c | --c*) clean=t;;
!     -D | --d*) debug=t;;
!     -e | --e*) expand=t;;
!     -h | --h*) echo "$usage"; exit 0;;
!     -I | --I*)
!       shift
!       miincludes="$miincludes -I $1"
!       txincludes="$txincludes$path_sep$1"
!       ;;
!     -l | --l*) shift; set_language=$1;;
!     -p | --p*) oformat=pdf;;
!     -t | --t*) shift; textra="$textra\\
! $1";;
!     -v | --vers*) echo "$version"; exit 0;;
!     -V | --verb*) verbose=echo;;
!     --) # What remains are not options.
!       shift
!       while test x"$1" != x"$arg_sep"; do
!         set dummy ${1+"$@"} "$1"; shift
!         shift
!       done
!       break;;
!     -*)
!       echo "$0: Unknown or ambiguous option \`$1'." >&2
!       echo "$0: Try \`--help' for more information." >&2
!       exit 1;;
!     *) set dummy ${1+"$@"} "$1"; shift;;
     esac
+    shift
  done
+ # Pop the token
+ shift
  
! # Interpret remaining command line args as filenames.
! if test $# = 0; then
!   echo "$0: Missing file arguments." >&2
!   echo "$0: Try \`--help' for more information." >&2
    exit 2
  fi
  
+ # Prepare the temporary directory.  Remove it at exit, unless debugging.
+ if test -z "$debug"; then
+   trap "cd / && rm -rf $tmpdir" 0 1 2 15
+ fi
+ 
+ # Create the temporary directory with strict rights
+ (umask 077 && mkdir $tmpdir) || exit 1
+ 
+ # Prepare the tools we might need.  This may be extra work in some
+ # cases, but improves the readibility of the script.
+ utildir=$tmpdir/utils
+ mkdir $utildir || exit 1
+ 
+ # A sed script that preprocesses Texinfo sources in order to keep the
+ # iftex sections only.  We want to remove non TeX sections, and
+ # comment (with `@c texi2dvi') TeX sections so that makeinfo does not
+ # try to parse them.  Nevertheless, while commenting TeX sections,
+ # don't comment @macro/@end macro so that makeinfo does propagate
+ # them.  Unfortunately makeinfo --iftex --no-ifhtml --no-ifinfo
+ # doesn't work well enough (yet) to use that, so work around with sed.
+ comment_iftex_sed=$utildir/comment.sed
+ cat <<EOF >$comment_iftex_sed
+ /^@tex/,/^@end tex/{
+   s/^/@c texi2dvi/
+ }
+ /^@iftex/,/^@end iftex/{
+   s/^/@c texi2dvi/
+   /^@c texi2dvi@macro/,/^@c texi2dvi@end macro/{
+     s/^@c texi2dvi//
+   }
+ }
+ /^@html/,/^@end html/d
+ /^@ifhtml/,/^@end ifhtml/d
+ /^@ifnottex/,/^@end ifnottex/d
+ /^@ifinfo/,/^@end ifinfo/{
+   /^@node/p
+   /^@menu/,/^@end menu/p
+   d
+ }
+ EOF
+ # Uncommenting is simple: Remove any leading `@c texi2dvi'.
+ uncomment_iftex_sed=$utildir/uncomment.sed
+ cat <<EOF >$uncomment_iftex_sed
+ s/^@c texi2dvi//
+ EOF
+ 
+ # A shell script that computes the list of xref files.
+ # Takes the filename (without extension) of which we look for xref
+ # files as argument.  The index files must be reported last.
+ get_xref_files=$utildir/get_xref.sh
+ cat <<\EOF >$get_xref_files
+ #! /bin/sh
+ 
+ # Get list of xref files (indexes, tables and lists).
+ # Find all files having root filename with a two-letter extension,
+ # saves the ones that are really Texinfo-related files.  .?o? catches
+ # LaTeX tables and lists.
+ for this_file in "$1".?o? "$1".aux "$1".?? "$1".idx; do
+   # If file is empty, skip it.
+   test -s "$this_file" || continue
+   # If the file is not suitable to be an index or xref file, don't
+   # process it.  The file can't be if its first character is not a
+   # backslash or single quote.
+   first_character=`sed -n '1s/^\(.\).*$/\1/p;q' $this_file`
+   if test "x$first_character" = "x\\" \
+      || test "x$first_character" = "x'"; then
+     xref_files="$xref_files ./$this_file"
+   fi
+ done
+ echo "$xref_files"
+ EOF
+ chmod 500 $get_xref_files
+ 
+ # File descriptor usage:
+ # 0 standard input
+ # 1 standard output (--verbose messages)
+ # 2 standard error
+ # 3 some systems may open it to /dev/tty
+ # 4 used on the Kubota Titan
+ # 5 tools output (turned off by --quiet)
+ 
+ # Tools' output.  If quiet, discard, else redirect to the message flow.
+ if test "$quiet" = t; then
+   exec 5>/dev/null
+ else
+   exec 5>&1
+ fi
+ 
+ # Enable tracing
  test "$debug" = t && set -x
  
! # 
! # TeXify files.
! 
  for command_line_filename in ${1+"$@"}; do
    $verbose "Processing $command_line_filename ..."
  
!   # If the COMMAND_LINE_FILENAME is not absolute (e.g., --debug.tex),
!   # prepend `./' in order to avoid that the tools take it as an option.
!   echo "$command_line_filename" | egrep '^(/|[A-z]:/)' >/dev/null \
!   || command_line_filename="./$command_line_filename"
! 
!   # See if the file exists.  If it doesn't we're in trouble since, even
    # though the user may be able to reenter a valid filename at the tex
    # prompt (assuming they're attending the terminal), this script won't
!   # be able to find the right xref files and so forth.
!   if test ! -r "$command_line_filename"; then
!     echo "$0: Could not read $command_line_filename, skipping." >&2
      continue
    fi
  
!   # Get the name of the current directory.  We want the full path
!   # because in clean mode we are in tmp, in which case a relative
!   # path has no meaning.
!   filename_dir=`echo $command_line_filename | sed 's!/[^/]*$!!;s!^$!.!'`
!   filename_dir=`cd "$filename_dir" >/dev/null && pwd`
! 
!   # Strip directory part but leave extension.
!   filename_ext=`basename "$command_line_filename"`
!   # Strip extension.
!   filename_noext=`echo "$filename_ext" | sed 's/\.[^.]*$//'`
!   ext=`echo "$filename_ext" | sed 's/^.*\.//'`
! 
!   # _src.  Use same basename since we want to generate aux files with
!   # the same basename as the manual.  If --expand, then output the
!   # macro-expanded file to here, else copy the original file.
!   tmpdir_src=$tmpdir/src
!   filename_src=$tmpdir_src/$filename_noext.$ext
! 
!   # _xtr.  The file with the user's extra commands.
!   tmpdir_xtr=$tmpdir/xtr
!   filename_xtr=$tmpdir_xtr/$filename_noext.$ext
! 
!   # _bak.  Copies of the previous xref files (another round is run if
!   # they differ from the new one).
!   tmpdir_bak=$tmpdir/bak
! 
!   # Make all those directories and give up if we can't succeed.
!   mkdir $tmpdir_src $tmpdir_xtr $tmpdir_bak || exit 1
  
!   # Source file might include additional sources.  Put `.' and
    # directory where source file(s) reside in TEXINPUTS before anything
!   # else.  `.' goes first to ensure that any old .aux, .cps,
!   # etc. files in ${directory} don't get used in preference to fresher
!   # files in `.'.  Include orig_pwd in case we are in clean mode, where
!   # we've cd'd to a temp directory.
!   common=".$path_sep$orig_pwd$path_sep$filename_dir$path_sep$txincludes$path_sep"
!    TEXINPUTS="$common$TEXINPUTS_orig"
!   INDEXSTYLE="$common$INDEXSTYLE_orig"
! 
!   # If the user explicitly specified the language, use that.
!   # Otherwise, if the first line is \input texinfo, assume it's texinfo.
!   # Otherwise, guess from the file extension.
!   if test -n "$set_language"; then
!     language=$set_language
!   elif sed 1q "$command_line_filename" | fgrep 'input texinfo' >/dev/null; then
!     language=texinfo
!   else
!     language=
!   fi
! 
!   # Get the type of the file (latex or texinfo) from the given language
!   # we just guessed, or from the file extension if not set yet.
!   case ${language:-$filename_ext} in
!     [lL]a[tT]e[xX] | *.ltx | *.tex)
!       # Assume a LaTeX file.  LaTeX needs bibtex and uses latex for
!       # compilation.  No makeinfo.
!       bibtex=${BIBTEX:-bibtex}
!       makeinfo= # no point in running makeinfo on latex source.
!       texindex=${MAKEINDEX:-makeindex}
!       if test $oformat = dvi; then
!         tex=${LATEX:-latex}
!       else
!         tex=${PDFLATEX:-pdflatex}
!       fi
!       ;;
  
!     *)
!       # Assume a Texinfo file.  Texinfo files need makeinfo, texindex and tex.
!       bibtex=
!       texindex=${TEXINDEX:-texindex}
!       if test $oformat = dvi; then
!         tex=${TEX:-tex}
!       else
!         tex=${PDFTEX:-pdftex}
!       fi
!       # Unless required by the user, makeinfo expansion is wanted only
!       # if texinfo.tex is too old.
!       if test "$expand" = t; then
!         makeinfo=${MAKEINFO:-makeinfo}
!       else
!         # Check if texinfo.tex performs macro expansion by looking for
!         # its version.  The version is a date of the form YEAR-MO-DA.
!         # We don't need to use [0-9] to match the digits since anyway
!         # the comparison with $txiprereq, a number, will fail with non
!         # digits.
!         txiversion_tex=txiversion.tex
!         echo '\input texinfo.tex @bye' >$tmpdir/$txiversion_tex
!         # Run in the tmpdir to avoid leaving files.
!         eval `cd $tmpdir >/dev/null \
!                     && $tex $txiversion_tex 2>/dev/null \
! | sed -n 's/^.*\[\(.*\)version \(....\)-\(..\)-\(..\).*$/txiformat=\1 txiversion="\2\3\4"/p'`
!         $verbose "texinfo.tex preloaded as \`$txiformat', version is \`$txiversion' ..."
!         if test "$txiprereq" -le "$txiversion" >/dev/null 2>&1; then
!           makeinfo=
!         else
!           makeinfo=${MAKEINFO:-makeinfo}
!         fi
!         # As long as we had to run TeX, offer the user this convenience
!         if test "$txiformat" = Texinfo; then
!           escape=@
!         fi
!       fi
!       ;;
!   esac
! 
!   # Expand macro commands in the original source file using Makeinfo.
    # Always use `end' footnote style, since the `separate' style
    #   generates different output (arguably this is a bug in -E).
    # Discard main info output, the user asked to run TeX, not makeinfo.
!   if test -n "$makeinfo"; then
!     $verbose "Macro-expanding $command_line_filename to $filename_src ..."
!     sed -f $comment_iftex_sed "$command_line_filename" \
!       | $makeinfo --footnote-style=end -I "$filename_dir" $miincludes \
!         -o /dev/null --macro-expand=- \
!       | sed -f $uncomment_iftex_sed >"$filename_src"
!     filename_input=$filename_src
!   fi
! 
!   # If makeinfo failed (or was not even run), use the original file as input.
!   if test $? -ne 0 \
!      || test ! -r "$filename_src"; then
      $verbose "Reverting to $command_line_filename ..."
!     filename_input=$filename_dir/$filename_ext
    fi
  
    # Used most commonly for @finalout, @smallbook, etc.
    if test -n "$textra"; then
!     $verbose "Inserting extra commands: $textra"
      sed '/^@setfilename/a\
! '"$textra" "$filename_input" >$filename_xtr
!     filename_input=$filename_xtr
    fi
  
    # If clean mode was specified, then move to the temporary directory.
    if test "$clean" = t; then
!     $verbose "cd $tmpdir_src"
!     cd "$tmpdir_src" || exit 1
    fi
  
!   while :; do # will break out of loop below
!     orig_xref_files=`$get_xref_files "$filename_noext"`
! 
!     # Save copies of originals for later comparison.
!     if test -n "$orig_xref_files"; then
!       $verbose "Backing up xref files: `echo $orig_xref_files | sed 's|\./||g'`"
!       cp $orig_xref_files $tmpdir_bak
!     fi
! 
!     # Run bibtex on current file.
!     # - If its input (AUX) exists.
!     # - If AUX contains both `\bibdata' and `\bibstyle'.
!     # - If some citations are missing (LOG contains `Citation').
!     #   or the LOG complains of a missing .bbl
!     #
!     # We run bibtex first, because I can see reasons for the indexes
!     # to change after bibtex is run, but I see no reason for the
!     # converse.
!     #
!     # Don't try to be too smart.  Running bibtex only if the bbl file
!     # exists and is older than the LaTeX file is wrong, since the
!     # document might include files that have changed.  Because there
!     # can be several AUX (if there are \include's), but a single LOG,
!     # looking for missing citations in LOG is easier, though we take
!     # the risk to match false messages.
!     if test -n "$bibtex" \
!        && test -r "$filename_noext.aux" \
!        && test -r "$filename_noext.log" \
!        && (grep '^\\bibdata[{]'  "$filename_noext.aux" \
!            && grep '^\\bibstyle[{]' "$filename_noext.aux" \
!            && (grep 'Warning:.*Citation.*undefined' "$filename_noext.log" \
!                || grep 'No file .*\.bbl\.' "$filename_noext.log")) \
!           >/dev/null 2>&1; \
!     then
!       $verbose "Running $bibtex $filename_noext ..."
!       if $bibtex "$filename_noext" >&5; then :; else
!         echo "$0: $bibtex exited with bad status, quitting." >&2
!         exit 1
!       fi
!     fi
! 
!     # What we'll run texindex on -- exclude non-index files.
!     # Since we know index files are last, it is correct to remove everything
!     # before .aux and .?o?.
!     index_files=`echo "$orig_xref_files" \
!                  | sed "s!.*\.aux!!g;
!                         s!./$filename_noext\..o.!!g;
!                         s/^[ ]*//;s/[ ]*$//"`
!     # Run texindex (or makeindex) on current index files.  If they
!     # already exist, and after running TeX a first time the index
!     # files don't change, then there's no reason to run TeX again.
!     # But we won't know that if the index files are out of date or
!     # nonexistent.
!     if test -n "$texindex" && test -n "$index_files"; then
!       $verbose "Running $texindex $index_files ..."
!       if $texindex $index_files 2>&5 1>&2; then :; else
!          echo "$0: $texindex exited with bad status, quitting." >&2
!          exit 1
        fi
      fi
  
      # Finally, run TeX.
!     # Prevent $ESCAPE from being interpreted by the shell if it happens
!     # to be `/'.
!     $batch tex_args="\\${escape}nonstopmode\ \\${escape}input"
!     $verbose "Running $cmd ..."
!     cmd="$tex $tex_args $filename_input"
!     if $cmd >&5; then :; else
!       echo "$0: $tex exited with bad status, quitting." >&2
!       echo "$0: see $filename_noext.log for errors." >&2
!       test "$clean" = t \
!         && cp "$filename_noext.log" "$orig_pwd"
!       exit 1
      fi
! 
! 
!     # Decide if looping again is needed.
!     finished=t
! 
!     # LaTeX (and the package changebar) report in the LOG file if it
!     # should be rerun.  This is needed for files included from
!     # subdirs, since texi2dvi does not try to compare xref files in
!     # subdirs.  Performing xref files test is still good since LaTeX
!     # does not report changes in xref files.
!     if fgrep "Rerun to get" "$filename_noext.log" >/dev/null 2>&1; then
!       finished=
!     fi
! 
!     # Check if xref files changed.
!     new_xref_files=`$get_xref_files "$filename_noext"`
!     $verbose "Original xref files = `echo $orig_xref_files | sed 's|\./||g'`"
!     $verbose "New xref files      = `echo $new_xref_files | sed 's|\./||g'`"
! 
!     # If old and new lists don't at least have the same file list,
!     # then one file or another has definitely changed.
!     test "x$orig_xref_files" != "x$new_xref_files" && finished=
! 
!     # File list is the same.  We must compare each file until we find
!     # a difference.
!     if test -n "$finished"; then
!       for this_file in $new_xref_files; do
!         $verbose "Comparing xref file `echo $this_file | sed 's|\./||g'` ..."
!         # cmp -s returns nonzero exit status if files differ.
!         if cmp -s "$this_file" "$tmpdir_bak/$this_file"; then :; else
!           # We only need to keep comparing until we find one that
!           # differs, because we'll have to run texindex & tex again no
!           # matter how many more there might be.
!           finished=
!           $verbose "xref file `echo $this_file | sed 's|\./||g'` differed ..."
!           test "$debug" = t && diff -c "$tmpdir_bak/$this_file" "$this_file"
            break
          fi
***************
*** 326,339 ****
      fi
  
!     # If index files have changed since TeX has been run, or if the aux
!     # file wasn't present originally, run texindex and TeX again.
!     if test "${index_files_changed_p}"; then :; else
!       # Nothing changed.  We're done with TeX.
!       break
!     fi
    done
  
    # If we were in clean mode, compilation was in a tmp directory.
!   # Copy the DVI file into the directory where the compilation
    # has been done.  (The temp dir is about to get removed anyway.)
    # We also return to the original directory so that
--- 540,549 ----
      fi
  
!     # If finished, exit the loop, else rerun the loop.
!     test -n "$finished" && break
    done
  
    # If we were in clean mode, compilation was in a tmp directory.
!   # Copy the DVI (or PDF) file into the directory where the compilation
    # has been done.  (The temp dir is about to get removed anyway.)
    # We also return to the original directory so that
***************
*** 341,362 ****
    # - the temporary file can be removed
    if test -n "$clean"; then
!     $verbose "Copying DVI file from `pwd` to $orig_pwd"
!     cp -p $filename_noext.dvi $orig_pwd
      cd $orig_pwd || exit 1
    fi
  
!   # Generate list of files to delete, then call rm once with the entire
!   # list.  This is significantly faster than multiple executions of rm.
!   file_list=
!   for file in ${orig_index_files}; do
!     file_list="${file_list} ${file}${backup_extension}"
!   done
!   if test -n "${file_list}"; then
!     $verbose "Removing $file_list $tmp_dir $tmp_dir2 ..."
!     rm -f ${file_list}
!     rm -rf $tmp_dir $tmp_dir2
    fi
  done
  
  $verbose "$0 done."
! true # exit successfully.
--- 551,568 ----
    # - the temporary file can be removed
    if test -n "$clean"; then
!     $verbose "Copying $oformat file from `pwd` to $orig_pwd"
!     cp -p "./$filename_noext.$oformat" "$orig_pwd"
!     cd / # in case $orig_pwd is on a different drive (for DOS)
      cd $orig_pwd || exit 1
    fi
  
!   # Remove temporary files.
!   if test "x$debug" = "x"; then
!     $verbose "Removing $tmpdir_src $tmpdir_xtr $tmpdir_bak ..."
!     cd /
!     rm -rf $tmpdir_src $tmpdir_xtr $tmpdir_bak
    fi
  done
  
  $verbose "$0 done."
! exit 0 # exit successfully, not however we ended the loop.
diff -Nrc2 bash-2.05/support/texi2html bash-2.05a/support/texi2html
*** bash-2.05/support/texi2html	Mon Apr 27 12:05:31 1998
--- bash-2.05a/support/texi2html	Fri Oct  5 14:30:15 2001
***************
*** 1,18 ****
! #!/usr/local/bin/perl
  'di ';
  'ig 00 ';
  #+##############################################################################
! #                                                                              #
! # File: texi2html                                                              #
! #                                                                              #
! # Description: Program to transform most Texinfo documents to HTML             #
! #                                                                              #
  #-##############################################################################
  
! # @(#)texi2html	1.52 01/05/98	Written (mainly) by Lionel Cons, Lionel.Cons@cern.ch
  
  # The man page for this program is included at the end of this file and can be
  # viewed using the command 'nroff -man texi2html'.
! # Please read the copyright at the end of the man page.
  
  #+++############################################################################
--- 1,1732 ----
! #! /usr/bin/perl
  'di ';
  'ig 00 ';
  #+##############################################################################
! #
! # texi2html: Program to transform Texinfo documents to HTML
! #
! #    Copyright (C) 1999, 2000  Free Software Foundation, Inc.
! #
! #    This program is free software; you can redistribute it and/or modify
! #    it under the terms of the GNU General Public License as published by
! #    the Free Software Foundation; either version 2 of the License, or
! #    (at your option) any later version.
! #
! #    This program is distributed in the hope that it will be useful,
! #    but WITHOUT ANY WARRANTY; without even the implied warranty of
! #    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! #    GNU General Public License for more details.
! #
! #    You should have received a copy of the GNU General Public License
! #    along with this program; if not, write to the Free Software
! #    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
! # 
  #-##############################################################################
  
! # This requires perl version 5 or higher
! require 5.0;
! 
! #++##############################################################################
! #
! # NOTE FOR DEBUGGING THIS SCRIPT:
! # You can run 'perl texi2html.pl' directly, provided you have
! # the environment variable T2H_HOME set to the directory containing
! # the texi2html.init file
! #
! #--##############################################################################
! 
! # CVS version:
! # $Id: texi2html.pl,v 1.55 2000/07/27 14:39:41 obachman Exp $
! 
! # Homepage:
! $T2H_HOMEPAGE = <<EOT;
! http://www.mathematik.uni-kl.de/~obachman/Texi2html
! EOT
! 
! # Authors:  
! $T2H_AUTHORS = <<EOT;
! Written by: Lionel Cons <Lionel.Cons\@cern.ch> (original author)
!             Karl Berry  <karl\@freefriends.org>
!             Olaf Bachmann <obachman\@mathematik.uni-kl.de>
!             and many others.
! Maintained by: Olaf Bachmann <obachman\@mathematik.uni-kl.de>
! Send bugs and suggestions to <texi2html\@mathematik.uni-kl.de>
! EOT
  
+ # Version: set in configure.in
+ $THISVERSION = '1.64';
+ $THISPROG = "texi2html $THISVERSION";	# program name and version
+   
  # The man page for this program is included at the end of this file and can be
  # viewed using the command 'nroff -man texi2html'.
! 
! # Identity:
! 
! $T2H_TODAY = &pretty_date;		# like "20 September 1993"
! # the eval prevents this from breaking on system which do not have
! # a proper getpwuid implemented
! eval { ($T2H_USER = (getpwuid ($<))[6]) =~ s/,.*//;}; # Who am i
! 
! #+++############################################################################
! #                                                                              #
! # Initialization                                                               #
! # Pasted content of File $(srcdir)/texi2html.init: Default initializations     # 
! #                                                                              #
! #---############################################################################
! 
! # leave this within comments, and keep the require statement
! # This way, you can directly run texi2html.pl, if $ENV{T2H_HOME}/texi2html.init
! # exists.
! 
! # 
! # -*-perl-*-
! ######################################################################
! # File: texi2html.init
! #
! # Sets default values for command-line arguments and for various customizable
! # procedures
! #
! # A copy of this file is pasted into the beginning of texi2html by
! # 'make texi2html'
! #
! # Copy this file and make changes to it, if you like.
! # Afterwards, either, load it with command-line option -init_file <your_init_file>
! #
! # $Id: texi2html.init,v 1.34 2000/07/27 14:09:02 obachman Exp $
! 
! ######################################################################
! # stuff which can also be set by command-line options
! #
! #
! # Note: values set here, overwrite values set by the command-line
! # options before -init_file and might still be overwritten by
! # command-line arguments following the -init_file option
! #
! 
! # T2H_OPTIONS is a hash whose keys are the (long) names of valid
! # command-line options and whose values are a hash with the following keys:
! # type    ==> one of !|=i|:i|=s|:s (see GetOpt::Long for more info)
! # linkage ==> ref to scalar, array, or subroutine (see GetOpt::Long for more info)
! # verbose ==> short description of option (displayed by -h)
! # noHelp  ==> if 1 -> for "not so important options": only print description on -h 1
! #                2 -> for obsolete options: only print description on -h 2
! 
! $T2H_DEBUG = 0;
! $T2H_OPTIONS -> {debug} =
! {
!  type => '=i',
!  linkage => \$main::T2H_DEBUG,
!  verbose => 'output HTML with debuging information',
! };
! 
! $T2H_DOCTYPE = '<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">'; 
! $T2H_OPTIONS -> {doctype} = 
! {
!  type => '=s',
!  linkage => \$main::T2H_DOCTYPE,
!  verbose => 'document type which is output in header of HTML files',
!  noHelp => 1
! };
! 
! $T2H_CHECK = 0;
! $T2H_OPTIONS -> {check} =
! {
!  type => '!',
!  linkage => \$main::T2H_CHECK,
!  verbose => 'if set, only check files and output all things that may be Texinfo commands',
!  noHelp => 1
! };
! 
! # -expand
! # if set to "tex" (or, "info") expand @iftex and @tex (or, @ifinfo) sections
! # else, neither expand @iftex, @tex, nor @ifinfo sections
! $T2H_EXPAND = "info";
! $T2H_OPTIONS -> {expand} = 
! {
!  type => '=s',
!  linkage => \$T2H_EXPAND,
!  verbose => 'Expand info|tex|none section of texinfo source',
! };
! 
! # - glossary
! #if set, uses section named `Footnotes' for glossary
! $T2H_USE_GLOSSARY = 0;
! T2H_OPTIONS -> {glossary} =
! {
!  type => '!',
!  linkage => \$T2H_USE_GLOSSARY,
!  verbose => "if set, uses section named `Footnotes' for glossary",
!  noHelp  => 1,
! };
! 
! 
! # -invisible
! # $T2H_INVISIBLE_MARK is the text used to create invisible destination
! # anchors for index links (you can for instance use the invisible.xbm
! # file shipped with this program). This is a workaround for a known
! # bug of many WWW browsers, including netscape.
! # For me, it works fine without it -- on the contrary: if there, it
! # inserts space between headers and start of text (obachman 3/99)
! $T2H_INVISIBLE_MARK = '';
! # $T2H_INVISIBLE_MARK = '&#160;';
! $T2H_OPTIONS -> {invisible} =
! {
!  type => '=s',
!  linkage => \$T2H_INVISIBLE_MARK,
!  verbose => 'use text in invisble anchot',
!  noHelp  => 1,
! };
! 
! # -iso
! # if set, ISO8879 characters are used for special symbols (like copyright, etc)
! $T2H_USE_ISO = 0;
! $T2H_OPTIONS -> {iso} =
! {
!  type => 'iso',
!  linkage => \$T2H_USE_ISO,
!  verbose => 'if set, ISO8879 characters are used for special symbols (like copyright, etc)',
!  noHelp => 1,
! };
! 
! # -I
! # list directories where @include files are searched for (besides the
! # directory of the doc file) additional '-I' args add to this list
! @T2H_INCLUDE_DIRS = (".");
! $T2H_OPTIONS -> {I} =
! {
!  type => '=s',
!  linkage => \@T2H_INCLUDE_DIRS,
!  verbose => 'append $s to the @include search path',
! };
! 
! # -top_file
! # uses file of this name for top-level file
! # extension is manipulated appropriately, if necessary.
! # If empty, <basename of document>.html is used
! # Typically, you would set this to "index.html".
! $T2H_TOP_FILE = '';
! $T2H_OPTIONS -> {top_file} =
! {
!  type => '=s',
!  linkage => \$T2H_TOP_FILE,
!  verbose => 'use $s as top file, instead of <docname>.html',
! };
! 
! 
! # -toc_file
! # uses file of this name for table of contents file
! # extension is manipulated appropriately, if necessary.
! # If empty, <basename of document>_toc.html is used
! $T2H_TOC_FILE = '';
! $T2H_OPTIONS -> {toc_file} =
! {
!  type => '=s',
!  linkage => \$T2H_TOC_FILE,
!  verbose => 'use $s as ToC file, instead of <docname>_toc.html',
! };
! 
! # -frames
! # if set, output two additional files which use HTML 4.0 "frames".
! $T2H_FRAMES = 0;
! $T2H_OPTIONS -> {frames} =
! {
!  type => '!',
!  linkage => \$T2H_FRAMES,
!  verbose => 'output files which use HTML 4.0 frames (experimental)',
!  noHelp => 1,
! };
! 
! 
! # -menu | -nomenu
! # if set, show the Texinfo menus
! $T2H_SHOW_MENU = 1;
! $T2H_OPTIONS -> {menu} =
! {
!  type => '!',
!  linkage => \$T2H_SHOW_MENU,
!  verbose => 'ouput Texinfo menus',
! };
! 
! # -number | -nonumber
! # if set, number sections and show section names and numbers in references 
! # and menus
! $T2H_NUMBER_SECTIONS = 1;
! $T2H_OPTIONS -> {number} =
! {
!  type => '!',
!  linkage => \$T2H_NUMBER_SECTIONS,
!  verbose => 'use numbered sections'
! };
! 
! # if set, and T2H_NUMBER_SECTIONS is set, then use node names in menu
! # entries, instead of section names
! $T2H_NODE_NAME_IN_MENU = 0;
! 
! # if set and menu entry equals menu descr, then do not print menu descr.
! # Likewise, if node name equals entry name, do not print entry name.
! $T2H_AVOID_MENU_REDUNDANCY = 1;
! 
! # -split section|chapter|none 
! # if set to 'section' (resp. 'chapter') create one html file per (sub)section
! # (resp. chapter) and separate pages for Top, ToC, Overview, Index,
! # Glossary, About.
! # otherwise, create monolithic html file which contains whole document
! #$T2H_SPLIT = 'section';
! $T2H_SPLIT = '';
! $T2H_OPTIONS -> {split} =
! {
!  type => '=s',
!  linkage => \$T2H_SPLIT,
!  verbose => 'split document on section|chapter else no splitting',
! };
! 
! # -section_navigation|-no-section_navigation
! # if set, then navigation panels are printed at the beginning of each section
! # and, possibly at the end (depending on whether or not there were more than 
! # $T2H_WORDS_IN_PAGE  words on page
! # This is most useful if you do not want to have section navigation 
! # on -split chapter
! $T2H_SECTION_NAVIGATION = 1;
! $T2H_OPTIONS -> {sec_nav} =
! {
!  type => '!',
!  linkage => \$T2H_SECTION_NAVIGATION,
!  verbose => 'output navigation panels for each section',
! };
! 
! # -subdir
! # if set put result files in this directory
! # if not set result files are put into current directory
! #$T2H_SUBDIR = 'html';
! $T2H_SUBDIR = '';
! $T2H_OPTIONS -> {subdir} =
! {
!  type => '=s',
!  linkage => \$T2H_SUBDIR,
!  verbose => 'put HTML files in directory $s, instead of $cwd',
! };
! 
! # -short_extn
! # If this is set all HTML file will have extension ".htm" instead of
! # ".html". This is helpful when shipping the document to PC systems.
! $T2H_SHORTEXTN = 0;
! $T2H_OPTIONS -> {short_ext} =
! {
!  type => '!',
!  linkage => \$T2H_SHORTEXTN,
!  verbose => 'use "htm" extension for output HTML files',
! };
! 
! 
! # -prefix
! # Set the output file prefix, prepended to all .html, .gif and .pl files.
! # By default, this is the basename of the document
! $T2H_PREFIX = '';
! $T2H_OPTIONS -> {prefix} =
! {
!  type => '=s',
!  linkage => \$T2H_PREFIX,
!  verbose => 'use as prefix for output files, instead of <docname>',
! };
! 
! # -o filename
! # If set, generate monolithic document output html into $filename
! $T2H_OUT = '';
! $T2H_OPTIONS -> {out_file} =
! {
!  type => '=s',
!  linkage => sub {$main::T2H_OUT = @_[1]; $T2H_SPLIT = '';},
!  verbose => 'if set, all HTML output goes into file $s',
! };
! 
! # -short_ref
! #if set cross-references are given without section numbers
! $T2H_SHORT_REF = '';
! $T2H_OPTIONS -> {short_ref} =
! {
!  type => '!',
!  linkage => \$T2H_SHORT_REF,
!  verbose => 'if set, references are without section numbers',
! };
! 
! # -idx_sum
! # if value is set, then for each @prinindex $what
! # $docu_name_$what.idx is created which contains lines of the form
! # $key\t$ref sorted alphabetically (case matters)
! $T2H_IDX_SUMMARY = 0;
! $T2H_OPTIONS -> {idx_sum} =
! {
!  type => '!',
!  linkage => \$T2H_IDX_SUMMARY,
!  verbose => 'if set, also output index summary',
!  noHelp  => 1,
! };
! 
! # -verbose
! # if set, chatter about what we are doing
! $T2H_VERBOSE = '';
! $T2H_OPTIONS -> {Verbose} =
! {
!  type => '!',
!  linkage => \$T2H_VERBOSE,
!  verbose => 'print progress info to stdout',
! };
! 
! # -lang
! # For page titles use $T2H_WORDS->{$T2H_LANG}->{...} as title.
! # To add a new language, supply list of titles (see $T2H_WORDS below).
! # and use ISO 639 language codes (see e.g. perl module Locale-Codes-1.02 
! # for  definitions)
! # Default's to 'en' if not set or no @documentlanguage is specified
! $T2H_LANG = '';
! $T2H_OPTIONS -> {lang} =
! {
!  type => '=s',
!  linkage => sub {SetDocumentLanguage($_[1])},
!  verbose => 'use $s as document language (ISO 639 encoding)',
! };
! 
! # -l2h
! # if set, uses latex2html for generation of math content 
! $T2H_L2H = '';
! $T2H_OPTIONS -> {l2h} =
! {
!  type => '!',
!  linkage => \$T2H_L2H,
!  verbose => 'if set, uses latex2html for @math and @tex',
! };
! 
! ######################
! # The following options are only relevant if $T2H_L2H is set
! #
! # -l2h_l2h
! # name/location of latex2html progam
! $T2H_L2H_L2H = "latex2html";
! $T2H_OPTIONS -> {l2h_l2h} =
! {
!  type => '=s',
!  linkage => \$T2H_L2H_L2H,
!  verbose => 'program to use for latex2html translation',
!  noHelp => 1,
! };
! 
! # -l2h_skip
! # if set, skips actual call to latex2html tries to reuse previously generated 
! # content, instead
! $T2H_L2H_SKIP = '';
! $T2H_OPTIONS -> {l2h_skip} =
! {
!  type => '!',
!  linkage => \$T2H_L2H_SKIP,
!  verbose => 'if set, tries to reuse previously latex2html output',
!  noHelp => 1,
! };
! 
! # -l2h_tmp
! # if set, l2h uses this directory for temporarary files. The path
! # leading to this directory may not contain a dot (i.e., a "."),
! # otherwise, l2h will fail
! $T2H_L2H_TMP = '';
! $T2H_OPTIONS -> {l2h_tmp} =
! {
!  type => '=s',
!  linkage => \$T2H_L2H_TMP,
!  verbose => 'if set, uses $s as temporary latex2html directory',
!  noHelp => 1,
! };
! 
! # if set, cleans intermediate files (they all have the prefix $doc_l2h_) 
! # of l2h 
! $T2H_L2H_CLEAN = 1;
! $T2H_OPTIONS -> {l2h_clean} =
! {
!  type => '!',
!  linkage => \$T2H_L2H_CLEAN,
!  verbose => 'if set, do not keep intermediate latex2html files for later reuse',
!  noHelp => 1,
! };
! 
! $T2H_OPTIONS -> {D} =
! {
!  type => '=s',
!  linkage => sub {$main::value{@_[1]} = 1;},
!  verbose => 'equivalent to Texinfo "@set $s 1"',
!  noHelp => 1,
! };
! 
! $T2H_OPTIONS -> {init_file} =
! {
!  type => '=s',
!  linkage => \&LoadInitFile,
!  verbose => 'load init file $s'
! };
! 
! 
! ##############################################################################
! #
! # The following can only be set in the init file
! #
! ##############################################################################
! 
! # if set, center @image by default
! # otherwise, do not center by default
! $T2H_CENTER_IMAGE = 1;
! 
! # used as identation for block enclosing command @example, etc
! # If not empty, must be enclosed in <td></td>
! $T2H_EXAMPLE_INDENT_CELL = '<td>&nbsp;</td>';
! # same as above, only for @small
! $T2H_SMALL_EXAMPLE_INDENT_CELL = '<td>&nbsp;</td>';
! # font size for @small
! $T2H_SMALL_FONT_SIZE = '-1';
! 
! # if non-empty, and no @..heading appeared in Top node, then
! # use this as header for top node/section, otherwise use value of 
! # @settitle or @shorttitle (in that order)
! $T2H_TOP_HEADING = '';
! 
! # if set, use this chapter for 'Index' button, else
! # use first chapter whose name matches 'index' (case insensitive)
! $T2H_INDEX_CHAPTER = '';
! 
! # if set and $T2H_SPLIT is set, then split index pages at the next letter
! # after they have more than that many entries
! $T2H_SPLIT_INDEX = 100;
! 
! # if set (e.g., to index.html) replace hrefs to this file 
! # (i.e., to index.html) by ./
! $T2H_HREF_DIR_INSTEAD_FILE = '';
! 
! ########################################################################
! # Language dependencies: 
! # To add a new language extend T2H_WORDS hash and create $T2H_<...>_WORDS hash
! # To redefine one word, simply do:
! # $T2H_WORDS->{<language>}->{<word>} = 'whatever' in your personal init file.
! #
! $T2H_WORDS_EN =
! {
!  # titles  of pages
!  'ToC_Title' => 'Table of Contents',
!  'Overview_Title' => 'Short Table of Contents',
!  'Index_Title' => 'Index',
!  'About_Title' => 'About this document',
!  'Footnotes_Title' => 'Footnotes',
!  'See' => 'See',
!  'see' => 'see',
!  'section' => 'section',
! # If necessary, we could extend this as follows: 
! #  # text for buttons
! #  'Top_Button' => 'Top',
! #  'ToC_Button' => 'Contents',
! #  'Overview_Button' => 'Overview',
! #  'Index_button' => 'Index',
! #  'Back_Button' => 'Back',
! #  'FastBack_Button' => 'FastBack',
! #  'Prev_Button' => 'Prev',
! #  'Up_Button' => 'Up',
! #  'Next_Button' => 'Next',
! #  'Forward_Button' =>'Forward',
! #  'FastWorward_Button' => 'FastForward',
! #  'First_Button' => 'First',
! #  'Last_Button' => 'Last',
! #  'About_Button' => 'About'
! };
! 
! $T2H_WORD_DE =
! {
!  'ToC_Title' => 'Inhaltsverzeichniss',
!  'Overview_Title' => 'Kurzes Inhaltsverzeichniss',
!  'Index_Title' => 'Index',
!  'About_Title' => '&Uuml;ber dieses Dokument',
!  'Footnotes_Title' => 'Fu&szlig;noten',
!  'See' => 'Siehe',
!  'see' => 'siehe',
!  'section' => 'Abschnitt',
! };
! 
! $T2H_WORD_NL =
! {
!  'ToC_Title' => 'Inhoudsopgave',
!  'Overview_Title' => 'Korte inhoudsopgave',
!  'Index_Title' => 'Index', #Not sure ;-)
!  'About_Title' => 'No translation available!', #No translation available!
!  'Footnotes_Title' => 'No translation available!', #No translation available!
!  'See' => 'Zie',
!  'see' => 'zie',
!  'section' => 'sectie',
! };
! 
! $T2H_WORD_ES =
! {
!  'ToC_Title' => '&iacute;ndice General',
!  'Overview_Title' => 'Resumen del Contenido',
!  'Index_Title' => 'Index', #Not sure ;-)
!  'About_Title' => 'No translation available!', #No translation available!
!  'Footnotes_Title' => 'Fu&szlig;noten',
!  'See' => 'V&eacute;ase',
!  'see' => 'v&eacute;ase',
!  'section' => 'secci&oacute;n',
! };
! 
! $T2H_WORD_NO =
! {
!  'ToC_Title' => 'Innholdsfortegnelse',
!  'Overview_Title' => 'Kort innholdsfortegnelse',
!  'Index_Title' => 'Indeks', #Not sure ;-)
!  'About_Title' => 'No translation available!', #No translation available!
!  'Footnotes_Title' => 'No translation available!',
!  'See' => 'Se',
!  'see' => 'se',
!  'section' => 'avsnitt',
! };
! 
! $T2H_WORD_PT =
! {
!  'ToC_Title' => 'Sum&aacute;rio',
!  'Overview_Title' => 'Breve Sum&aacute;rio',
!  'Index_Title' => '&Iacute;ndice', #Not sure ;-)
!  'About_Title' => 'No translation available!', #No translation available!
!  'Footnotes_Title' => 'No translation available!',
!  'See' => 'Veja',
!  'see' => 'veja',
!  'section' => 'Se&ccedil;&atilde;o',
! };
! 
! $T2H_WORDS =
! {
!  'en' => $T2H_WORDS_EN,
!  'de' => $T2H_WORDS_DE,
!  'nl' => $T2H_WORDS_NL,
!  'es' => $T2H_WORDS_ES,
!  'no' => $T2H_WORDS_NO,
!  'pt' => $T2H_WORDS_PT
! };
! 
! @MONTH_NAMES_EN =
! (
!  'January', 'February', 'March', 'April', 'May',
!  'June', 'July', 'August', 'September', 'October',
!  'November', 'December'
! );
! 
! @MONTH_NAMES_DE =
! (
!  'Januar', 'Februar', 'M&auml;rz', 'April', 'Mai',
!  'Juni', 'Juli', 'August', 'September', 'Oktober',
!  'November', 'Dezember'
! );
! 
! @MONTH_NAMES_NL =
! (
!  'Januari', 'Februari', 'Maart', 'April', 'Mei',
!  'Juni', 'Juli', 'Augustus', 'September', 'Oktober',
!  'November', 'December'
! );
! 
! @MONTH_NAMES_ES =
! (
!  'enero', 'febrero', 'marzo', 'abril', 'mayo',
!  'junio', 'julio', 'agosto', 'septiembre', 'octubre',
!  'noviembre', 'diciembre'
! );
! 
! @MONTH_NAMES_NO =
! (
! 
!  'januar', 'februar', 'mars', 'april', 'mai',
!  'juni', 'juli', 'august', 'september', 'oktober',
!  'november', 'desember'
! );
! 
! @MONTH_NAMES_PT =
! (
!  'Janeiro', 'Fevereiro', 'Mar&ccedil;o', 'Abril', 'Maio',
!  'Junho', 'Julho', 'Agosto', 'Setembro', 'Outubro',
!  'Novembro', 'Dezembro'
! );
! 
! 
! $MONTH_NAMES =
! {
!     'en' => \@MONTH_NAMES_EN,
!     'de' => \@MONTH_NAMES_DE,
!     'es' => \@MONTH_NAMES_ES,
!     'nl' => \@MONTH_NAMES_NL,
!     'no' => \@MONTH_NAMES_NO,
!     'pt' => \@MONTH_NAMES_PT
! };
! ########################################################################
! # Control of Page layout:
! # You can make changes of the Page layout at two levels:
! # 1.) For small changes, it is often enough to change the value of
! #     some global string/hash/array variables
! # 2.) For larger changes, reimplement one of the T2H_DEFAULT_<fnc>* routines,
! #     give them another name, and assign them to the respective
! #     $T2H_<fnc> variable.
! 
! # As a general interface, the hashes T2H_HREF, T2H_NAME, T2H_NODE hold 
! # href, html-name, node-name of
! # This     -- current section (resp. html page)
! # Top      -- top page ($T2H_TOP_FILE)
! # Contents -- Table of contents
! # Overview -- Short table of contents
! # Index    -- Index page
! # About    -- page which explain "navigation buttons"
! # First    -- first node 
! # Last     -- last node
! #
! # Whether or not the following hash values are set, depends on the context 
! # (all values are w.r.t. 'This' section)
! # Next        -- next node of texinfo
! # Prev        -- previous node of texinfo
! # Up          -- up node of texinfo
! # Forward     -- next node in reading order
! # Back        -- previous node in reading order
! # FastForward -- if leave node, up and next, else next node
! # FastBackward-- if leave node, up and prev, else prev node
! #
! # Furthermore, the following global variabels are set:
! # $T2H_THISDOC{title}     -- title as set by @setttile
! # $T2H_THISDOC{fulltitle} -- full title as set by @title...
! # $T2H_THISDOC{subtitle}  -- subtitle as set by @subtitle
! # $T2H_THISDOC{author}    -- author as set by @author
! # 
! # and pointer to arrays of lines which need to be printed by t2h_print_lines 
! # $T2H_OVERVIEW      -- lines of short table of contents
! # $T2H_TOC           -- lines of table of contents
! # $T2H_TOP           -- lines of Top texinfo node 
! # $T2H_THIS_SECTION  -- lines of 'This' section
! 
! #
! # There are the following subs which control the layout:
! #
! $T2H_print_section            = \&T2H_DEFAULT_print_section;
! $T2H_print_Top_header         = \&T2H_DEFAULT_print_Top_header;       
! $T2H_print_Top_footer	      = \&T2H_DEFAULT_print_Top_footer;       
! $T2H_print_Top		      = \&T2H_DEFAULT_print_Top;              
! $T2H_print_Toc		      = \&T2H_DEFAULT_print_Toc;              
! $T2H_print_Overview	      = \&T2H_DEFAULT_print_Overview;         
! $T2H_print_Footnotes	      = \&T2H_DEFAULT_print_Footnotes;        
! $T2H_print_About	      = \&T2H_DEFAULT_print_About;            
! $T2H_print_misc_header	      = \&T2H_DEFAULT_print_misc_header;      
! $T2H_print_misc_footer	      = \&T2H_DEFAULT_print_misc_footer;      
! $T2H_print_misc		      = \&T2H_DEFAULT_print_misc;
! $T2H_print_chapter_header     = \&T2H_DEFAULT_print_chapter_header;      
! $T2H_print_chapter_footer     = \&T2H_DEFAULT_print_chapter_footer;      
! $T2H_print_page_head	      = \&T2H_DEFAULT_print_page_head;        
! $T2H_print_page_foot	      = \&T2H_DEFAULT_print_page_foot;        
! $T2H_print_head_navigation    = \&T2H_DEFAULT_print_head_navigation;  
! $T2H_print_foot_navigation    = \&T2H_DEFAULT_print_foot_navigation;  
! $T2H_button_icon_img	      = \&T2H_DEFAULT_button_icon_img;        
! $T2H_print_navigation	      = \&T2H_DEFAULT_print_navigation;       
! $T2H_about_body		      = \&T2H_DEFAULT_about_body;            
! $T2H_print_frame              = \&T2H_DEFAULT_print_frame;
! $T2H_print_toc_frame          = \&T2H_DEFAULT_print_toc_frame;
! 
! ########################################################################
! # Layout for html for every sections
! #
! sub T2H_DEFAULT_print_section
! {
!   my $fh = shift;
!   local $T2H_BUTTONS = \@T2H_SECTION_BUTTONS;
!   &$T2H_print_head_navigation($fh) if $T2H_SECTION_NAVIGATION;
!   my $nw = t2h_print_lines($fh);
!   if ($T2H_SPLIT eq 'section' && $T2H_SECTION_NAVIGATION)
!   {
!     &$T2H_print_foot_navigation($fh, $nw);
!   }
!   else
!   {
!     print $fh '<HR SIZE="6">' . "\n";
!   }
! }
! 
! ###################################################################
! # Layout of top-page I recommend that you use @ifnothtml, @ifhtml,
! # @html within the Top texinfo node to specify content of top-level
! # page. 
! #
! # If you enclose everything in @ifnothtml, then title, subtitle,
! # author and overview is printed
! # T2H_HREF of Next, Prev, Up, Forward, Back are not defined
! # if $T2H_SPLIT then Top page is in its own html file
! sub T2H_DEFAULT_print_Top_header
! {
!   &$T2H_print_page_head(@_) if $T2H_SPLIT;
!   t2h_print_label(@_); # this needs to be called, otherwise no label set
!   &$T2H_print_head_navigation(@_);
! }
! sub T2H_DEFAULT_print_Top_footer
! {
!   &$T2H_print_foot_navigation(@_);
!   &$T2H_print_page_foot(@_) if $T2H_SPLIT; 
! }
! sub T2H_DEFAULT_print_Top
! {
!   my $fh = shift;
! 
!   # for redefining navigation buttons use:
!   # local $T2H_BUTTONS = [...];
!   # as it is, 'Top', 'Contents', 'Index', 'About' are printed
!   local $T2H_BUTTONS = \@T2H_MISC_BUTTONS;
!   &$T2H_print_Top_header($fh);
!   if ($T2H_THIS_SECTION)
!   {
!     # if top-level node has content, then print it with extra header
!     print $fh "<H1>$T2H_NAME{Top}</H1>"
!       unless ($T2H_HAS_TOP_HEADING);
!     t2h_print_lines($fh, $T2H_THIS_SECTION)
!   }
!   else
!   {
!     # top-level node is fully enclosed in @ifnothtml
!     # print fulltitle, subtitle, author, Overview
!     print $fh 
!       "<CENTER>\n<H1>" .
!       join("</H1>\n<H1>", split(/\n/,  $T2H_THISDOC{fulltitle})) .
!       "</H1>\n";
!     print $fh "<H2>$T2H_THISDOC{subtitle}</H2>\n" if $T2H_THISDOC{subtitle};
!     print $fh "$T2H_THISDOC{author}\n" if $T2H_THISDOC{author};
!     print $fh <<EOT;
! </CENTER>
! <HR>
! <P></P>  
! <H2> Overview: </H2>
! <BLOCKQUOTE>  
! EOT
!     t2h_print_lines($fh, $T2H_OVERVIEW);
!     print $fh "</BLOCKQUOTE>\n";
!   }
!   &$T2H_print_Top_footer($fh);
! }
! 
! ###################################################################
! # Layout of Toc, Overview, and Footnotes pages
! # By default, we use "normal" layout 
! # T2H_HREF of Next, Prev, Up, Forward, Back, etc are not defined
! # use: local $T2H_BUTTONS = [...] to redefine navigation buttons
! sub T2H_DEFAULT_print_Toc
! {
!   return &$T2H_print_misc(@_);
! }
! sub T2H_DEFAULT_print_Overview
! {
!   return &$T2H_print_misc(@_);
! }
! sub T2H_DEFAULT_print_Footnotes
! {
!   return &$T2H_print_misc(@_);
! }
! sub T2H_DEFAULT_print_About
! {
!   return &$T2H_print_misc(@_);
! }
! 
! sub T2H_DEFAULT_print_misc_header
! {
!   &$T2H_print_page_head(@_) if $T2H_SPLIT;
!   # this needs to be called, otherwise, no labels are set
!   t2h_print_label(@_); 
!   &$T2H_print_head_navigation(@_);
! }
! sub T2H_DEFAULT_print_misc_footer
! {
!   &$T2H_print_foot_navigation(@_);
!   &$T2H_print_page_foot(@_) if $T2H_SPLIT; 
! }
! sub T2H_DEFAULT_print_misc
! {
!   my $fh = shift;
!   local $T2H_BUTTONS = \@T2H_MISC_BUTTONS;
!   &$T2H_print_misc_header($fh);
!   print $fh "<H1>$T2H_NAME{This}</H1>\n";
!   t2h_print_lines($fh);
!   &$T2H_print_misc_footer($fh);
! }
! 
! ###################################################################
! # chapter_header and chapter_footer are only called if
! # T2H_SPLIT eq 'chapter'
! # chapter_header: after print_page_header, before print_section
! # chapter_footer: after print_section of last section, before print_page_footer
! # 
! # If you want to get rid of navigation stuff after each section,
! # redefine print_section such that it does not call print_navigation,
! # and put print_navigation into print_chapter_header
! @T2H_CHAPTER_BUTTONS =
!   (
!    'FastBack', 'FastForward', ' ', 
!    ' ', ' ', ' ', ' ',
!    'Top', 'Contents', 'Index', 'About', 
!   );
! 
! sub T2H_DEFAULT_print_chapter_header
! {
!   # nothing to do there, by default
!   if (! $T2H_SECTION_NAVIGATION)
!   {
!     my $fh = shift;
!     local $T2H_BUTTONS = \@T2H_CHAPTER_BUTTONS;
!     &$T2H_print_navigation($fh);
!     print $fh "\n<HR SIZE=2>\n";
!   }
! }
! 
! sub T2H_DEFAULT_print_chapter_footer
! {
!   local $T2H_BUTTONS = \@T2H_CHAPTER_BUTTONS;
!   &$T2H_print_navigation(@_);
! }
! ###################################################################
! $T2H_TODAY = &pretty_date;		# like "20 September 1993"
! 
! sub pretty_date {
!     local($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst);
! 
!     ($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst) = localtime(time);
!     $year += ($year < 70) ? 2000 : 1900;
!     # obachman: Let's do it as the Americans do
!     return($MONTH_NAMES->{$T2H_LANG}[$mon] . ", " . $mday . " " . $year);
! }
! 
! 
! ###################################################################
! # Layout of standard header and footer
! #
! 
! # Set the default body text, inserted between <BODY ... > 
! ###$T2H_BODYTEXT = 'LANG="EN" BGCOLOR="#FFFFFF" TEXT="#000000" LINK="#0000FF" VLINK="#800080" ALINK="#FF0000"';
! $T2H_BODYTEXT = 'LANG="' . $T2H_LANG . '" BGCOLOR="#FFFFFF" TEXT="#000000" LINK="#0000FF" VLINK="#800080" ALINK="#FF0000"';
! # text inserted after <BODY ...>
! $T2H_AFTER_BODY_OPEN = '';
! #text inserted before </BODY>
! $T2H_PRE_BODY_CLOSE = '';
! # this is used in footer
! $T2H_ADDRESS = "by <I>$T2H_USER</I> " if $T2H_USER;
! $T2H_ADDRESS .= "on <I>$T2H_TODAY</I>";
! # this is added inside <HEAD></HEAD> after <TITLE> and some META NAME stuff
! # can be used for <style> <script>, <meta> tags
! $T2H_EXTRA_HEAD = '';
! 
! sub T2H_DEFAULT_print_page_head
! {
!   my $fh = shift; 
!   my $longtitle = "$T2H_THISDOC{title}: $T2H_NAME{This}";
!   print $fh <<EOT;
! <HTML>
! $T2H_DOCTYPE
! <!-- Created on $T2H_TODAY by $THISPROG -->
! <!-- 
! $T2H_AUTHORS 
! -->
! <HEAD>
! <TITLE>$longtitle</TITLE>
! 
! <META NAME="description" CONTENT="$longtitle">
! <META NAME="keywords" CONTENT="$longtitle">
! <META NAME="resource-type" CONTENT="document">
! <META NAME="distribution" CONTENT="global">
! <META NAME="Generator" CONTENT="$THISPROG">
! $T2H_EXTRA_HEAD
! </HEAD>
! 
! <BODY $T2H_BODYTEXT>
! $T2H_AFTER_BODY_OPEN
! EOT
! }
! 
! sub T2H_DEFAULT_print_page_foot
! {
!   my $fh = shift;
!   print $fh <<EOT;
! <BR>  
! <FONT SIZE="-1">
! This document was generated
! $T2H_ADDRESS
! using <A HREF="$T2H_HOMEPAGE"><I>texi2html</I></A>
! $T2H_PRE_BODY_CLOSE
! </BODY>
! </HTML>
! EOT
! }
! 
! ###################################################################
! # Layout of navigation panel
! 
! # if this is set, then a vertical navigation panel is used
! $T2H_VERTICAL_HEAD_NAVIGATION = 0;
! sub T2H_DEFAULT_print_head_navigation
! {
!   my $fh = shift;
!   if ($T2H_VERTICAL_HEAD_NAVIGATION)
!   {
!     print $fh <<EOT;
! <TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0">
! <TR VALIGN="TOP">
! <TD ALIGN="LEFT">
! EOT
!   }
!   &$T2H_print_navigation($fh, $T2H_VERTICAL_HEAD_NAVIGATION);
!   if ($T2H_VERTICAL_HEAD_NAVIGATION)
!   {
!     print $fh <<EOT;
! </TD>
! <TD ALIGN="LEFT">
! EOT
!   }
!   elsif ($T2H_SPLIT eq 'section')
!   {
!     print $fh "<HR SIZE=1>\n";
!   }
! }
! 
! # Specifies the minimum page length required before a navigation panel
! # is placed at the bottom of a page (the default is that of latex2html)
! # T2H_THIS_WORDS_IN_PAGE holds number of words of current page
! $T2H_WORDS_IN_PAGE = 300;
! sub T2H_DEFAULT_print_foot_navigation
! {
!   my $fh = shift;
!   my $nwords = shift;
!   if ($T2H_VERTICAL_HEAD_NAVIGATION)
!   {
!     print $fh <<EOT;
! </TD>
! </TR>
! </TABLE>
! EOT
!   }
!   print $fh "<HR SIZE=1>\n";
!   &$T2H_print_navigation($fh) if ($nwords >= $T2H_WORDS_IN_PAGE)
! }
! 
! ######################################################################
! # navigation panel
! #
! # specify in this array which "buttons" should appear in which order
! # in the navigation panel for sections; use ' ' for empty buttons (space)
! @T2H_SECTION_BUTTONS =
!   (
!    'Back', 'Forward', ' ', 'FastBack', 'Up', 'FastForward',  
!    ' ', ' ', ' ', ' ',
!    'Top', 'Contents', 'Index', 'About', 
!   );
! 
! # buttons for misc stuff
! @T2H_MISC_BUTTONS = ('Top', 'Contents', 'Index', 'About');
! 
! # insert here name of icon images for buttons 
! # Icons are used, if $T2H_ICONS and resp. value are set
! %T2H_ACTIVE_ICONS =
!   (
!    'Top',      '',
!    'Contents', '',
!    'Overview', '',
!    'Index',    '',
!    'Back',     '',
!    'FastBack', '',
!    'Prev',     '',
!    'Up',       '',
!    'Next',     '',
!    'Forward',  '',
!    'FastForward', '',
!    'About' ,    '',
!    'First',    '',
!    'Last',     '',
!    ' ',        ''
!   );
! 
! # insert here name of icon images for these, if button is inactive
! %T2H_PASSIVE_ICONS =
!   (
!    'Top',      '',
!    'Contents', '',
!    'Overview', '',
!    'Index',    '',
!    'Back',     '',
!    'FastBack', '',
!    'Prev',     '',
!    'Up',       '',
!    'Next',     '',
!    'Forward',  '',
!    'FastForward', '',
!    'About',     '',
!    'First',    '',
!    'Last',     '',
!   );
! 
! # how to create IMG tag
! sub T2H_DEFAULT_button_icon_img
! {
!   my $button = shift;
!   my $icon = shift;
!   my $name = shift;
!   return qq{<IMG SRC="$icon" BORDER="0" ALT="$button: $name" ALIGN="MIDDLE">};
! }
! 
! # Names of text as alternative for icons
! %T2H_NAVIGATION_TEXT =
!   (
!    'Top',      'Top',
!    'Contents', 'Contents',
!    'Overview', 'Overview',
!    'Index',    'Index',
!    ' ',        ' &nbsp; ',
!    'Back',     ' &lt; ',
!    'FastBack', ' &lt;&lt; ',
!    'Prev',     'Prev',
!    'Up',       ' Up ',
!    'Next',     'Next',
!    'Forward',  ' &gt; ',
!    'FastForward',  ' &gt;&gt; ',
!    'About',     ' ? ',
!    'First',    ' |&lt; ',
!    'Last',     ' &gt;| '
!   );
! 
! sub T2H_DEFAULT_print_navigation
! {
!   my $fh = shift;
!   my $vertical = shift;
!   my $spacing = 1;
!   print $fh "<TABLE CELLPADDING=$spacing CELLSPACING=$spacing BORDER=0>\n";
! 
!   print $fh "<TR>" unless $vertical;
!   for $button (@$T2H_BUTTONS)
!   {
!     print $fh qq{<TR VALIGN="TOP" ALIGN="LEFT">\n} if $vertical;
!     print $fh qq{<TD VALIGN="MIDDLE" ALIGN="LEFT">};
! 
!     if (ref($button) eq 'CODE')
!     {
!       &$button($fh, $vertical);
!     }
!     elsif ($button eq ' ')
!     { # handle space button
!       print $fh 
! 	$T2H_ICONS && $T2H_ACTIVE_ICONS{' '} ? 
! 	 &$T2H_button_icon_img($button, $T2H_ACTIVE_ICONS{' '}) :
! 	 $T2H_NAVIGATION_TEXT{' '};
!       next;
!     }
!     elsif ($T2H_HREF{$button})
!     { # button is active
!       print $fh   
! 	 $T2H_ICONS && $T2H_ACTIVE_ICONS{$button} ? # use icon ? 
! 	   t2h_anchor('', $T2H_HREF{$button},  # yes
! 		    &$T2H_button_icon_img($button,
! 					$T2H_ACTIVE_ICONS{$button},
! 					$T2H_NAME{$button})) 
! 	 : # use text
! 	 "[" . 
! 	 t2h_anchor('', $T2H_HREF{$button}, $T2H_NAVIGATION_TEXT{$button}) .
! 	 "]";  
!     }
!     else
!     { # button is passive 
!       print $fh 
! 	$T2H_ICONS && $T2H_PASSIVE_ICONS{$button} ?
! 	 &$T2H_button_icon_img($button,
! 			       $T2H_PASSIVE_ICONS{$button},
! 			       $T2H_NAME{$button}) :
! 	 
! 	 "[" . $T2H_NAVIGATION_TEXT{$button} . "]";
!     }
!     print $fh "</TD>\n";
!     print $fh "</TR>\n" if $vertical;
!   }
!   print $fh "</TR>" unless $vertical;
!   print $fh "</TABLE>\n";
! }
! 
! ######################################################################
! # Frames: this is from "Richard Y. Kim" <ryk@coho.net>
! # Should be improved to be more conforming to other _print* functions
! 
! sub T2H_DEFAULT_print_frame
! {
!   my $fh = shift;
!   print $fh <<EOT;
! <HTML>
! <HEAD><TITLE>$T2H_THISDOC{title}</TITLE></HEAD>
! <FRAMESET cols="140,*"> 
!   <FRAME name=toc  src="$docu_toc_frame_file">
!   <FRAME name=main src="$docu_doc">
! </FRAMESET> 
! </HTML>
! EOT
! }
! 
! sub T2H_DEFAULT_print_toc_frame
! {
!   my $fh = shift;
!   &$T2H_print_page_head($fh);
!   print $fh <<EOT;
! <H2>Content</H2>
! EOT
!   print $fh map {s/HREF=/target=\"main\" HREF=/; $_;} @stoc_lines;
!   print $fh "</BODY></HTML>\n";
! }
! 
! ######################################################################
! # About page
! #
! 
! # T2H_PRE_ABOUT might be a function
! $T2H_PRE_ABOUT = <<EOT;
! This document was generated $T2H_ADDRESS
! using <A HREF="$T2H_HOMEPAGE"><I>texi2html</I></A>
! <P></P>  
! EOT
! $T2H_AFTER_ABOUT = '';
! 
! sub T2H_DEFAULT_about_body
! {
!   my $about;
!   if (ref($T2H_PRE_ABOUT) eq 'CODE')
!   {
!     $about = &$T2H_PRE_ABOUT();
!   }
!   else
!   {
!     $about = $T2H_PRE_ABOUT;
!   }
!   $about .= <<EOT;
! The buttons in the navigation panels have the following meaning:
! <P></P>
! <table border = "1">
! <TR>
! <TH> Button </TH>
! <TH> Name </TH>
! <TH> Go to </TH>
! <TH> From 1.2.3 go to</TH>
! </TR>
! EOT
!   
!   for $button (@T2H_SECTION_BUTTONS)
!   {
!     next if $button eq ' ' || ref($button) eq 'CODE';
!     $about .= <<EOT;
! <TR>
! <TD ALIGN="CENTER">
! EOT
!     $about .= 	
!       ($T2H_ICONS && $T2H_ACTIVE_ICONS{$button} ?
!        &$T2H_button_icon_img($button, $T2H_ACTIVE_ICONS{$button}) :
!        " [" . $T2H_NAVIGATION_TEXT{$button} . "] ");
!     $about .= <<EOT;
! </TD>
! <TD ALIGN="CENTER">
! $button
! </TD>
! <TD>
! $T2H_BUTTONS_GOTO{$button}
! </TD>
! <TD>
! $T2H_BUTTONS_EXAMPLE{$button}
! </TD>
! </TR>
! EOT
!   }
! 
!   $about .= <<EOT;
! </TABLE>
! <P></P>
! where the <STRONG> Example </STRONG> assumes that the current position 
! is at <STRONG> Subsubsection One-Two-Three </STRONG> of a document of 
! the following structure:
! <UL>
! <LI> 1. Section One  </LI>
! <UL>
! <LI>1.1 Subsection One-One</LI>
! <UL>
! <LI> ... </LI>
! </UL>
! <LI>1.2 Subsection One-Two</LI>
! <UL>
! <LI>1.2.1 Subsubsection One-Two-One
! </LI><LI>1.2.2 Subsubsection One-Two-Two
! </LI><LI>1.2.3 Subsubsection One-Two-Three &nbsp; &nbsp; <STRONG>
! &lt;== Current Position </STRONG>
! </LI><LI>1.2.4 Subsubsection One-Two-Four
! </LI></UL>
! <LI>1.3 Subsection One-Three</LI>
! <UL>
! <LI> ... </LI>
! </UL>
! <LI>1.4 Subsection One-Four</LI>
! </UL>
! </UL>
! $T2H_AFTER_ABOUT
! EOT
!   return $about;  
! }
! 
!   
! %T2H_BUTTONS_GOTO =
!   (
!    'Top',      'cover (top) of document',
!    'Contents', 'table of contents',
!    'Overview', 'short table of contents',
!    'Index',    'concept index',
!    'Back',     'previous section in reading order',
!    'FastBack', 'previous or up-and-previous section ',
!    'Prev',     'previous section same level',
!    'Up',       'up section',
!    'Next',     'next section same level',
!    'Forward',  'next section in reading order',
!    'FastForward', 'next or up-and-next section',
!    'About' ,    'this page',
!    'First',    'first section in reading order',
!    'Last',     'last section in reading order',
!   );
! 
! %T2H_BUTTONS_EXAMPLE = 
! (
!    'Top',      ' &nbsp; ',
!    'Contents', ' &nbsp; ',
!    'Overview', ' &nbsp; ',
!    'Index',    ' &nbsp; ',
!    'Back',     '1.2.2',
!    'FastBack', '1.1',
!    'Prev',     '1.2.2',
!    'Up',       '1.2',
!    'Next',     '1.2.4',
!    'Forward',  '1.2.4',
!    'FastForward', '1.3',
!    'About',     ' &nbsp; ',
!    'First',    '1.',
!    'Last',     '1.2.4',
! );
! 
! 
! ######################################################################
! # from here on, its l2h init stuff 
! #
! 
! ## initialization for latex2html as for Singular manual generation
! ## obachman 3/99
! 
! #
! # Options controlling Titles, File-Names, Tracing and Sectioning
! #
! $TITLE = '';
! 
! $SHORTEXTN = 0;
! 
! $LONG_TITLES = 0;
! 
! $DESTDIR = ''; # should be overwritten by cmd-line argument
! 
! $NO_SUBDIR = 0;# should be overwritten by cmd-line argument
! 
! $PREFIX = '';  # should be overwritten by cmd-line argument
! 
! $AUTO_PREFIX = 0; # this is needed, so that prefix settings are used
! 
! $AUTO_LINK = 0; 
! 
! $SPLIT = 0;
! 
! $MAX_LINK_DEPTH = 0;
! 
! $TMP = ''; # should be overwritten by cmd-line argument
! 
! $DEBUG = 0;
! 
! $VERBOSE = 1;
! 
! #
! # Options controlling Extensions and Special Features 
! #
! $HTML_VERSION = "3.2";
! 
! $TEXDEFS = 1; # we absolutely need that
! 
! $EXTERNAL_FILE = '';
! 
! $SCALABLE_FONTS = 1;
! 
! $NO_SIMPLE_MATH = 1;
! 
! $LOCAL_ICONS = 1;
! 
! $SHORT_INDEX = 0;
! 
! $NO_FOOTNODE = 1;
! 
! $ADDRESS = '';
! 
! $INFO = '';
! 
! #
! # Switches controlling Image Generation 
! #
! $ASCII_MODE = 0;
! 
! $NOLATEX = 0;
! 
! $EXTERNAL_IMAGES = 0;
! 
! $PS_IMAGES = 0;
! 
! $NO_IMAGES = 0;
! 
! $IMAGES_ONLY = 0;
! 
! $REUSE = 2;
! 
! $ANTI_ALIAS = 1;
! 
! $ANTI_ALIAS_TEXT = 1;
! 
! #
! #Switches controlling Navigation Panels
! #
! $NO_NAVIGATION = 1;
! $ADDRESS = '';
! $INFO = 0;              # 0 = do not make a "About this document..." section 
! 
! #
! #Switches for Linking to other documents 
! #
! # actuall -- we don't care
! 
! $MAX_SPLIT_DEPTH = 0;	# Stop making separate files at this depth
! 
! $MAX_LINK_DEPTH = 0;    # Stop showing child nodes at this depth   
! 
! $NOLATEX = 0;           # 1 = do not pass unknown environments to Latex
! 
! $EXTERNAL_IMAGES = 0;   # 1 = leave the images outside the document 
! 
! $ASCII_MODE = 0;        # 1 = do not use any icons or internal images
! 
! # 1 =  use links to external postscript images rather than inlined bitmap
! # images.
! $PS_IMAGES = 0;
! $SHOW_SECTION_NUMBERS = 0;
! 
! ### Other global variables ###############################################
! $CHILDLINE = "";
! 
! # This is the line width measured in pixels and it is used to right justify
! # equations and equation arrays; 
! $LINE_WIDTH = 500;		
! 
! # Used in conjunction with AUTO_NAVIGATION
! $WORDS_IN_PAGE = 300;	
! 
! # Affects ONLY the way accents are processed 
! $default_language = 'english';	
! 
! # The value of this variable determines how many words to use in each 
! # title that is added to the navigation panel (see below)
! # 
! $WORDS_IN_NAVIGATION_PANEL_TITLES = 0;
! 
! # This number will determine the size of the equations, special characters,
! # and anything which will be converted into an inlined image
! # *except* "image generating environments" such as "figure", "table" 
! # or "minipage".
! # Effective values are those greater than 0.
! # Sensible values are between 0.1 - 4.
! $MATH_SCALE_FACTOR = 1.5;
! 
! # This number will determine the size of 
! # image generating environments such as "figure", "table" or "minipage".
! # Effective values are those greater than 0.
! # Sensible values are between 0.1 - 4.
! $FIGURE_SCALE_FACTOR = 1.6;
! 
! 
! #  If both of the following two variables are set then the "Up" button
! #  of the navigation panel in the first node/page of a converted document
! #  will point to $EXTERNAL_UP_LINK. $EXTERNAL_UP_TITLE should be set
! #  to some text which describes this external link.
! $EXTERNAL_UP_LINK = "";
! $EXTERNAL_UP_TITLE = "";
! 
! # If this is set then the resulting HTML will look marginally better if viewed 
! # with Netscape.
! $NETSCAPE_HTML = 1;
! 
! # Valid paper sizes are "letter", "legal", "a4","a3","a2" and "a0"
! # Paper sizes has no effect other than in the time it takes to create inlined
! # images and in whether large images can be created at all ie
! #  - larger paper sizes *MAY* help with large image problems 
! #  - smaller paper sizes are quicker to handle
! $PAPERSIZE = "a4";
! 
! # Replace "english" with another language in order to tell LaTeX2HTML that you 
! # want some generated section titles (eg "Table of Contents" or "References")
! # to appear in a different language. Currently only "english" and "french"
! # is supported but it is very easy to add your own. See the example in the
! # file "latex2html.config" 
! $TITLES_LANGUAGE = "english";
! 
! 1;	# This must be the last non-comment line
! 
! # End File texi2html.init
! ######################################################################
! 
! 
! require "$ENV{T2H_HOME}/texi2html.init" 
!   if ($0 =~ /\.pl$/ &&
!       -e "$ENV{T2H_HOME}/texi2html.init" && -r "$ENV{T2H_HOME}/texi2html.init");
! 
! #+++############################################################################
! #                                                                              #
! # Initialization                                                               #
! # Pasted content of File $(srcdir)/MySimple.pm: Command-line processing        #
! #                                                                              #
! #---############################################################################
! 
! # leave this within comments, and keep the require statement
! # This way, you can directly run texi2html.pl, if $ENV{T2H_HOME}/texi2html.init
! # exists.
! 
! # 
! package Getopt::MySimple;
! 
! # Name:
! #	Getopt::MySimple.
! #
! # Documentation:
! #	POD-style (incomplete) documentation is in file MySimple.pod
! #
! # Tabs:
! #	4 spaces || die.
! #
! # Author:
! #	Ron Savage	rpsavage@ozemail.com.au.
! #	1.00	19-Aug-97	Initial version.
! #	1.10	13-Oct-97	Add arrays of switches (eg '=s@').
! #	1.20	 3-Dec-97	Add 'Help' on a per-switch basis.
! #	1.30	11-Dec-97	Change 'Help' to 'verbose'. Make all hash keys lowercase.
! #	1.40	10-Nov-98	Change width of help report. Restructure tests.
! #               1-Jul-00        Modifications for Texi2html
! 
! # --------------------------------------------------------------------------
! # Locally modified by obachman (Display type instead of env, order by cmp)
! # $Id: MySimple.pm,v 1.1 2000/07/03 08:44:13 obachman Exp $
! 
! # use strict;
! # no strict 'refs';
! 
! use vars qw(@EXPORT @EXPORT_OK @ISA);
! use vars qw($fieldWidth $opt $VERSION);
! 
! use Exporter();
! use Getopt::Long;
! 
! @ISA		= qw(Exporter);
! @EXPORT		= qw();
! @EXPORT_OK	= qw($opt);	# An alias for $self -> {'opt'}.
! 
! # --------------------------------------------------------------------------
! 
! $fieldWidth	= 20;
! $VERSION	= '1.41';
! 
! # --------------------------------------------------------------------------
! 
! sub byOrder
! {
! 	my($self) = @_;
! 	
! 	return uc($a) cmp (uc($b));
! }
! 
! # --------------------------------------------------------------------------
! 
! sub dumpOptions
! {
! 	my($self) = @_;
! 
! 	print 'Option', ' ' x ($fieldWidth - length('Option') ), "Value\n";
! 
! 	for (sort byOrder keys(%{$self -> {'opt'} }) )
! 	{
! 	  print "-$_", ' ' x ($fieldWidth - (1 + length) ), "${$self->{'opt'} }{$_}\n";
! 	}
! 
! 	print "\n";
! 
! }	# End of dumpOptions.
! 
! # --------------------------------------------------------------------------
! # Return:
! #	0 -> Error.
! #	1 -> Ok.
! 
! sub getOptions
! {
! 	push(@_, 0) if ($#_ == 2);	# Default for $ignoreCase is 0.
! 	push(@_, 1) if ($#_ == 3);	# Default for $helpThenExit is 1.
! 
! 	my($self, $default, $helpText, $versionText, 
! 	   $helpThenExit, $versionThenExit, $ignoreCase) = @_;
! 	
! 	$helpThenExit = 1 unless (defined($helpThenExit));
! 	$versionThenExit = 1 unless (defined($versionThenExit));
! 	$ignoreCase = 0 unless (defined($ignoreCase));
! 
! 	$self -> {'default'}		= $default;
! 	$self -> {'helpText'}		= $helpText;
! 	$self -> {'versionText'}        = $versionText;
! 	$Getopt::Long::ignorecase	= $ignoreCase;
! 
! 	unless (defined($self -> {'default'}{'help'}))
! 	{
! 	  $self -> {'default'}{'help'} = 
! 	  { 
! 	   type => ':i', 
! 	   default => '',
! 	   linkage => sub {$self->helpOptions($_[1]); exit (0) if $helpThenExit;},
! 	   verbose => "print help and exit"
! 	  };
! 	}
! 
! 	unless (defined($self -> {'default'}{'version'}))
! 	{
! 	  $self -> {'default'}{'version'} = 
! 	  { 
! 	   type => '', 
! 	   default => '',
! 	   linkage => sub {print $self->{'versionText'};  exit (0) if versionTheExit;},
! 	   verbose => "print version and exit"
! 	  };
! 	}
! 
! 	for (keys(%{$self -> {'default'} }) )
! 	{
! 	  my $type = ${$self -> {'default'} }{$_}{'type'};
! 	  push(@{$self -> {'type'} }, "$_$type");
! 	  $self->{'opt'}->{$_} =  ${$self -> {'default'} }{$_}{'linkage'}
!             if ${$self -> {'default'} }{$_}{'linkage'};
! 	}
! 
! 	my($result) = &GetOptions($self -> {'opt'}, @{$self -> {'type'} });
! 
!         return $result unless $result;
! 
! 	for (keys(%{$self -> {'default'} }) )
! 	{
!  	   if (! defined(${$self -> {'opt'} }{$_})) #{
!             {
!  	     ${$self -> {'opt'} }{$_} = ${$self -> {'default'} }{$_}{'default'};
!             }
! 	}
! 
! 	$result;
! }	# End of getOptions.
! 
! # --------------------------------------------------------------------------
! 
! sub helpOptions
! {
! 	my($self) = shift;
! 	my($noHelp) = shift;
! 	$noHelp = 0 unless $noHelp;
! 	my($optwidth, $typewidth, $defaultwidth, $maxlinewidth, $valind, $valwidth) 
! 	  = (10, 5, 9, 78, 4, 11);
! 
! 	print "$self->{'helpText'}" if ($self -> {'helpText'});
! 
! 	print ' Option', ' ' x ($optwidth - length('Option') -1 ),
! 		'Type', ' ' x ($typewidth - length('Type') + 1),
! 		'Default', ' ' x ($defaultwidth - length('Default') ),
! 	        "Description\n";
! 
! 	for (sort byOrder keys(%{$self -> {'default'} }) )
! 	{
! 	  my($line, $help, $option, $val);
! 	  $option = $_;
! 	  next if ${$self->{'default'} }{$_}{'noHelp'} && ${$self->{'default'} }{$_}{'noHelp'} > $noHelp;
! 		$line = " -$_ " . ' ' x ($optwidth - (2 + length) ) .
! 			"${$self->{'default'} }{$_}{'type'} ".
! 			' ' x ($typewidth - (1+length(${$self -> {'default'} }{$_}{'type'}) ));
! 
!                  $val = ${$self->{'default'} }{$_}{'linkage'};
!                 if ($val)
!                 {
!                   if (ref($val) eq 'SCALAR')
! 		  {
! 		    $val = $$val; 
! 		  }
! 		  else
! 		  {
! 		    $val = '';
! 		  }
!                 }
! 		else
! 		{
! 		  $val = ${$self->{'default'} }{$_}{'default'};
! 		}
! 	        $line .= "$val  ";
! 		$line .= ' ' x ($optwidth + $typewidth + $defaultwidth + 1 - length($line));
! 		
! 		if (defined(${$self -> {'default'} }{$_}{'verbose'}) &&
! 		  ${$self -> {'default'} }{$_}{'verbose'} ne '')
! 	      {
! 		$help = "${$self->{'default'} }{$_}{'verbose'}";
! 	      }
! 	      else
! 	      {
! 		$help = ' ';
! 	      }
! 	      if ((length("$line") + length($help)) < $maxlinewidth)
! 	      {
! 		print $line , $help, "\n";
! 	      }
! 	      else
! 	      {
! 		print $line, "\n", ' ' x $valind, $help, "\n";
! 	      }
! 	      for $val (sort byOrder keys(%{${$self->{'default'}}{$option}{'values'}}))
! 	      {
! 	        print ' ' x ($valind + 2);
! 	        print $val, '  ', ' ' x ($valwidth - length($val) - 2);
! 	        print ${$self->{'default'}}{$option}{'values'}{$val}, "\n";
! 	      }
! 	}
! 
! 	print <<EOT;
! Note: 'Options' may be abbreviated. 'Type' specifications mean:
!  <none>| !    no argument: variable is set to 1 on -foo (or, to 0 on -nofoo)
!     =s | :s   mandatory (or, optional)  string argument
!     =i | :i   mandatory (or, optional)  integer argument
! EOT
! }	# End of helpOptions.
! 
! #-------------------------------------------------------------------
! 
! sub new
! {
! 	my($class)				= @_;
! 	my($self)				= {};
! 	$self -> {'default'}	= {};
! 	$self -> {'helpText'}	= '';
! 	$self -> {'opt'}		= {};
! 	$opt					= $self -> {'opt'};	 # An alias for $self -> {'opt'}.
! 	$self -> {'type'}		= ();
! 
! 	return bless $self, $class;
! 
! }	# End of new.
! 
! # --------------------------------------------------------------------------
! 
! 1;
! 
! # End MySimple.pm
! 
! require "$ENV{T2H_HOME}/MySimple.pm" 
!   if ($0 =~ /\.pl$/ &&
!       -e "$ENV{T2H_HOME}/texi2html.init" && -r "$ENV{T2H_HOME}/texi2html.init");
! 
! package main;
  
  #+++############################################################################
***************
*** 29,62 ****
  $DEBUG_HTML  = 32;
  $DEBUG_USER  = 64;
  
  $BIBRE = '\[[\w\/-]+\]';		# RE for a bibliography reference
  $FILERE = '[\/\w.+-]+';			# RE for a file name
  $VARRE = '[^\s\{\}]+';			# RE for a variable name
! $NODERE = '[^@{}:\'`",]+';		# RE for a node name
! $NODESRE = '[^@{}:\'`"]+';		# RE for a list of node names
! $XREFRE = '[^@{}]+';			# RE for a xref (should use NODERE)
! 
! $ERROR = "***";			        # prefix for errors and warnings
! $THISPROG = "texi2html 1.52";			# program name and version
! $HOMEPAGE = "http://wwwinfo.cern.ch/dis/texi2html/"; # program home page
! $TODAY = &pretty_date;			# like "20 September 1993"
! $SPLITTAG = "<!-- SPLIT HERE -->\n";	# tag to know where to split
  $PROTECTTAG = "_ThisIsProtected_";	# tag to recognize protected sections
- $html2_doctype = '<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0 Strict Level 2//EN">';
  
! #
! # language dependent constants
! #
! #$LDC_SEE = 'see';
! #$LDC_SECTION = 'section';
! #$LDC_IN = 'in';
! #$LDC_TOC = 'Table of Contents';
! #$LDC_GOTO = 'Go to the';
! #$LDC_FOOT = 'Footnotes';
! # TODO: @def* shortcuts
  
  #
  # pre-defined indices
  #
  %predefined_index = (
  		    'cp', 'c',
--- 1743,1781 ----
  $DEBUG_HTML  = 32;
  $DEBUG_USER  = 64;
+ $DEBUG_L2H   = 128;
+ 
  
  $BIBRE = '\[[\w\/-]+\]';		# RE for a bibliography reference
  $FILERE = '[\/\w.+-]+';			# RE for a file name
  $VARRE = '[^\s\{\}]+';			# RE for a variable name
! $NODERE = '[^,:]+';		        # RE for a node name
! $NODESRE = '[^:]+';		        # RE for a list of node names
! 
! $ERROR = "***";			        # prefix for errors 
! $WARN  = "**";                          # prefix for warnings
!   
!                                         # program home page
  $PROTECTTAG = "_ThisIsProtected_";	# tag to recognize protected sections
  
! $CHAPTEREND = "<!-- End chapter -->\n"; # to know where a chpater ends
! $SECTIONEND = "<!-- End section -->\n"; # to know where section ends
! $TOPEND     = "<!-- End top     -->\n"; # to know where top ends
! 
!   
  
  #
  # pre-defined indices
  #
+ $index_properties =
+ {
+  'c' => { name => 'cp'},
+  'f' => { name => 'fn', code => 1},
+  'v' => { name => 'vr', code => 1},
+  'k' => { name => 'ky', code => 1},
+  'p' => { name => 'pg', code => 1},
+  't' => { name => 'tp', code => 1}
+ };
+ 
+ 
  %predefined_index = (
  		    'cp', 'c',
***************
*** 123,128 ****
--- 1842,1850 ----
  	       "*", "<BR>",		# HTML+
  	       " ", " ",
+ 	       "\t", " ",
+   	       "-", "&#173;",	# soft hyphen
  	       "\n", "\n",
  	       "|", "",
+ 	       'tab', '<\/TD><TD>',
  	       # spacing commands
  	       ":", "",
***************
*** 141,145 ****
  	       'bullet', '*',
  	       'copyright', '(C)',
! 	       'dots', '...',
  	       'equiv', '==',
  	       'error', 'error-->',
--- 1863,1868 ----
  	       'bullet', '*',
  	       'copyright', '(C)',
! 	       'dots', '<small>...<\/small>',
! 	       'enddots', '<small>....<\/small>',
  	       'equiv', '==',
  	       'error', 'error-->',
***************
*** 149,153 ****
  	       'print', '-|',
  	       'result', '=>',
! 	       'today', $TODAY,
  	       );
  
--- 1872,1890 ----
  	       'print', '-|',
  	       'result', '=>',
! 	       'today', $T2H_TODAY,
! 	       'aa', '&aring;',
! 	       'AA', '&Aring;',
! 	       'ae', '&aelig;',
! 	       'oe', '&#156;',
! 	       'AE', '&AElig;',
! 	       'OE', '&#140;',
! 	       'o',  '&oslash;',
! 	       'O',  '&Oslash;',
! 	       'ss', '&szlig;',
! 	       'l', '\/l',
! 	       'L', '\/L',
! 	       'exclamdown', '&iexcl;',
! 	       'questiondown', '&iquest;',
! 	       'pounds', '&pound;'
  	       );
  
***************
*** 156,163 ****
--- 1893,1902 ----
  #
  %style_map = (
+ 	      'acronym', '&do_acronym',
  	      'asis', '',
  	      'b', 'B',
  	      'cite', 'CITE',
  	      'code', 'CODE',
+ 	      'command', 'CODE',
  	      'ctrl', '&do_ctrl',	# special case
  	      'dfn', 'EM',		# DFN tag is illegal in the standard
***************
*** 165,173 ****
  	      'email', '&do_email',     # insert a clickable email address
  	      'emph', 'EM',
  	      'file', '"TT',		# will put quotes, cf. &apply_style
  	      'i', 'I',
  	      'kbd', 'KBD',
  	      'key', 'KBD',
! 	      'math', 'EM',
  	      'r', '',			# unsupported
  	      'samp', '"SAMP',		# will put quotes, cf. &apply_style
--- 1904,1914 ----
  	      'email', '&do_email',     # insert a clickable email address
  	      'emph', 'EM',
+ 	      'env', 'CODE',
  	      'file', '"TT',		# will put quotes, cf. &apply_style
  	      'i', 'I',
  	      'kbd', 'KBD',
  	      'key', 'KBD',
! 	      'math', '&do_math',
! 	      'option', '"SAMP',        # will put quotes, cf. &apply_style
  	      'r', '',			# unsupported
  	      'samp', '"SAMP',		# will put quotes, cf. &apply_style
***************
*** 180,183 ****
--- 1921,1934 ----
  	      'var', 'VAR',
  	      'w', '',			# unsupported
+ 	      'H', '&do_accent',
+ 	      'dotaccent', '&do_accent',
+ 	      'ringaccent','&do_accent',
+ 	      'tieaccent', '&do_accent',
+ 	      'u','&do_accent',
+ 	      'ubaraccent','&do_accent',
+ 	      'udotaccent','&do_accent',
+ 	      'v', '&do_accent',
+ 	      ',', '&do_accent',
+ 	      'dotless', '&do_accent'
  	      );
  
***************
*** 186,196 ****
  #
  %format_map = (
- 	       'display', 'PRE',
- 	       'example', 'PRE',
- 	       'format', 'PRE',
- 	       'lisp', 'PRE',
  	       'quotation', 'BLOCKQUOTE',
- 	       'smallexample', 'PRE',
- 	       'smalllisp', 'PRE',
  	       # lists
  	       'itemize', 'UL',
--- 1937,1941 ----
***************
*** 202,205 ****
--- 1947,1982 ----
  
  #
+ # an eval of these $complex_format_map->{what}->[0] yields beginning
+ # an eval of these $complex_format_map->{what}->[1] yieleds end
+ $complex_format_map =
+ {
+  example => 
+  [
+   q{"<TABLE><tr>$T2H_EXAMPLE_INDENT_CELL<td class=example><pre>"},
+   q{'</pre></td></tr></table>'}
+  ],
+  smallexample => 
+  [
+   q{"<TABLE><tr>$T2H_SMALL_EXAMPLE_INDENT_CELL<td class=smallexample><FONT SIZE=$T2H_SMALL_FONT_SIZE><pre>"},
+   q{'</FONT></pre></td></tr></table>'}
+  ],
+  display =>
+  [
+   q{"<TABLE><tr>$T2H_EXAMPLE_INDENT_CELL<td class=display><pre " . 'style="font-family: serif">'},
+   q{'</pre></td></tr></table>'}
+  ],
+  smalldisplay =>
+  [
+   q{"<TABLE><tr>$T2H_SMALL_EXAMPLE_INDENT_CELL<td class=smalldisplay><FONT SIZE=$T2H_SMALL_FONT_SIZE><pre " . 'style="font-family: serif">'},
+   q{'</pre></FONT></td></tr></table>'}
+  ]
+ };
+ 
+ $complex_format_map->{lisp} = $complex_format_map->{example};
+ $complex_format_map->{smalllisp} = $complex_format_map->{smallexample};
+ $complex_format_map->{format} = $complex_format_map->{display};
+ $complex_format_map->{smallformat} = $complex_format_map->{smalldisplay};
+ 
+ #
  # texinfo definition shortcuts to real ones
  #
***************
*** 230,234 ****
--- 2007,2013 ----
  	    'deftypevar', 'deftypevr Variable',
  	    'defivar', 'defcv {Instance Variable}',
+ 	    'deftypeivar', 'defcv {Instance Variable}', # NEW: FIXME
  	    'defmethod', 'defop Method',
+ 	    'deftypemethod', 'defop Method', # NEW:FIXME
  	    # x shortcuts
  	    'defunx', 'deffnx Function',
***************
*** 250,254 ****
--- 2029,2041 ----
  	    'c', 1,
  	    'comment', 1,
+             'ifnotinfo', 1,
+             'ifnottex', 1,
+ 	    'ifhtml', 1,
+ 	    'end ifhtml', 1,
+             'end ifnotinfo', 1,
+             'end ifnottex', 1,
  	    # useless
+ 	    'detailmenu', 1,
+             'direntry', 1,
  	    'contents', 1,
  	    'shortcontents', 1,
***************
*** 264,267 ****
--- 2051,2055 ----
  	    'finalout', 1,
  	    'headings', 1,
+             'sp', 1,
  	    'need', 1,
  	    'page', 1,
***************
*** 290,375 ****
  #---############################################################################
  
! %value = ();				# hold texinfo variables, see also -D
  
  $use_bibliography = 1;
! $use_acc = 0;
! $debug = 0;
! $doctype = '';
! $check = 0;
! $expandinfo = 0;
! $use_glossary = 0;
! $invisible_mark = '';
! $use_iso = 0;
! @include_dirs = ();
! $show_menu = 0;
! $number_sections = 0;
! $split_node = 0;
! $split_chapter = 0;
! $monolithic = 0;
! $verbose = 0;
! $usage = <<EOT;
! This is $THISPROG
! To convert a Texinfo file to HMTL: $0 [options] file
!   where options can be:
!     -expandinfo    : use \@ifinfo sections, not \@iftex
!     -glossary      : handle a glossary
!     -invisible name: use 'name' as an invisible anchor
!     -Dname         : define name like with \@set
!     -I dir         : search also for files in 'dir'
!     -menu          : handle menus
!     -monolithic    : output only one file including ToC
!     -number        : number sections
!     -split_chapter : split on main sections
!     -split_node    : split on nodes
!     -usage         : print usage instructions
!     -verbose       : verbose output
! To check converted files: $0 -check [-verbose] files
! EOT
! 
! while (@ARGV && $ARGV[0] =~ /^-/) {
!     $_ = shift(@ARGV);
!     if (/^-acc$/)            { $use_acc = 1; next; }
!     if (/^-d(ebug)?(\d+)?$/) { $debug = $2 || shift(@ARGV); next; }
!     if (/^-doctype$/)        { $doctype = shift(@ARGV); next; }
!     if (/^-c(heck)?$/)       { $check = 1; next; }
!     if (/^-e(xpandinfo)?$/)  { $expandinfo = 1; next; }
!     if (/^-g(lossary)?$/)    { $use_glossary = 1; next; }
!     if (/^-i(nvisible)?$/)   { $invisible_mark = shift(@ARGV); next; }
!     if (/^-iso$/)            { $use_iso = 1; next; }
!     if (/^-D(.+)?$/)         { $value{$1 || shift(@ARGV)} = 1; next; }
!     if (/^-I(.+)?$/)         { push(@include_dirs, $1 || shift(@ARGV)); next; }
!     if (/^-m(enu)?$/)        { $show_menu = 1; next; }
!     if (/^-mono(lithic)?$/)  { $monolithic = 1; next; }
!     if (/^-n(umber)?$/)      { $number_sections = 1; next; }
!     if (/^-s(plit)?_?(n(ode)?|c(hapter)?)?$/) {
! 	if ($2 =~ /^n/) {
! 	    $split_node = 1;
! 	} else {
! 	    $split_chapter = 1;
! 	}
! 	next;
      }
-     if (/^-v(erbose)?$/)     { $verbose = 1; next; }
-     die $usage;
  }
! if ($check) {
!     die $usage unless @ARGV > 0;
      &check;
      exit;
  }
  
! if (($split_node || $split_chapter) && $monolithic) {
!     warn "Can't use -monolithic with -split, -monolithic ignored.\n";
!     $monolithic = 0;
! }
! if ($expandinfo) {
!     $to_skip{'ifinfo'}++;
!     $to_skip{'end ifinfo'}++;
! } else {
!     $to_skip{'iftex'}++;
!     $to_skip{'end iftex'}++;
  }
! $invisible_mark = '<IMG SRC="invisible.xbm">' if $invisible_mark eq 'xbm';
! die $usage unless @ARGV == 1;
  $docu = shift(@ARGV);
  if ($docu =~ /.*\//) {
--- 2078,2296 ----
  #---############################################################################
  
! #
! # flush stdout and stderr after every write
! #
! select(STDERR);
! $| = 1;
! select(STDOUT);
! $| = 1;
  
+ 
+ %value = ();				# hold texinfo variables, see also -D
  $use_bibliography = 1;
! $use_acc = 1;
! 
! #
! # called on -init-file
! sub LoadInitFile
! {
!   my $init_file = shift;
!   # second argument is value of options
!   $init_file = shift;
!   if (-f $init_file)
!   {
!     print "# reading initialization file from $init_file\n" 
!       if ($T2H_VERBOSE);
!     require($init_file);
!   }
!   else
!   {
!     print "$ERROR Error: can't read init file $int_file\n";
!     $init_file = '';
!   }
! }
! 
! #
! # called on -lang
! sub SetDocumentLanguage
! {
!   my $lang = shift;
!   if (! exists($T2H_WORDS->{$lang}))
!   {
!     warn "$ERROR: Language specs for '$lang' do not exists. Reverting to '" . 
!       ($T2H_LANG ? T2H_LANG : "en") . "'\n";
!   }
!   else
!   {
!     print "# using '$lang' as document language\n" if ($T2H_VERBOSE);
!     $T2H_LANG = $lang;
!   }
! }
! 
! ##
! ## obsolete cmd line options
! ##
! $T2H_OBSOLETE_OPTIONS -> {'no-section_navigation'} =
! {
!  type => '!',
!  linkage => sub {$main::T2H_SECTION_NAVIGATION = 0;},
!  verbose => 'obsolete, use -nosec_nav',
!  noHelp => 2,
! };
! $T2H_OBSOLETE_OPTIONS -> {use_acc} =
! {
!  type => '!',
!  linkage => \$use_acc,
!  verbose => 'obsolete',
!  noHelp => 2
! };
! $T2H_OBSOLETE_OPTIONS -> {expandinfo} =
! {
!  type => '!',
!  linkage => sub {$main::T2H_EXPAND = 'info';},
!  verbose => 'obsolete, use "-expand info" instead',
!  noHelp => 2,
! };
! $T2H_OBSOLETE_OPTIONS -> {expandtex} =
! {
!  type => '!',
!  linkage => sub {$main::T2H_EXPAND = 'tex';},
!  verbose => 'obsolete, use "-expand tex" instead',
!  noHelp => 2,
! };
! $T2H_OBSOLETE_OPTIONS -> {monolithic} =
! {
!  type => '!',
!  linkage => sub {$main::T2H_SPLIT = '';},
!  verbose => 'obsolete, use "-split no" instead',
!  noHelp => 2
! };
! $T2H_OBSOLETE_OPTIONS -> {split_node} =
! {
!  type => '!',
!  linkage => sub{$main::T2H_SPLIT = 'section';},
!  verbose => 'obsolete, use "-split section" instead',
!  noHelp => 2,
! };
! $T2H_OBSOLETE_OPTIONS -> {split_chapter} =
! {
!  type => '!',
!  linkage => sub{$main::T2H_SPLIT = 'chapter';},
!  verbose => 'obsolete, use "-split chapter" instead',
!  noHelp => 2,
! };
! $T2H_OBSOLETE_OPTIONS -> {no_verbose} =
! {
!  type => '!',
!  linkage => sub {$main::T2H_VERBOSE = 0;},
!  verbose => 'obsolete, use -noverbose instead',
!  noHelp => 2,
! };
! $T2H_OBSOLETE_OPTIONS -> {output_file} =
! {
!  type => '=s',
!  linkage => sub {$main::T2H_OUT = @_[1]; $T2H_SPLIT = '';},
!  verbose => 'obsolete, use -out_file instead',
!  noHelp => 2
! };
! 
! $T2H_OBSOLETE_OPTIONS -> {section_navigation} =
! {
!  type => '!',
!  linkage => \$T2H_SECTION_NAVIGATION,
!  verbose => 'obsolete, use -sec_nav instead',
!  noHelp => 2,
! };
! 
! $T2H_OBSOLETE_OPTIONS -> {verbose} =
! {
!  type => '!',
!  linkage => \$T2H_VERBOSE,
!  verbose => 'obsolete, use -Verbose instead',
!  noHelp => 2
! };
! 
! # read initialzation from $sysconfdir/texi2htmlrc or $HOME/.texi2htmlrc
! my $home = $ENV{HOME};
! defined($home) or $home = '';
! foreach $i ('/usr/local/etc/texi2htmlrc', "$home/.texi2htmlrc") {
!     if (-f $i) {
! 	print "# reading initialization file from $i\n" 
! 	    if ($T2H_VERBOSE);
! 	require($i);
      }
  }
! 
! 
! #+++############################################################################
! #                                                                              #
! # parse command-line options
! #                                                                              #
! #---############################################################################
! $T2H_USAGE_TEXT = <<EOT;
! Usage: texi2html  [OPTIONS] TEXINFO-FILE
! Translates Texinfo source documentation to HTML.
! EOT
! $T2H_FAILURE_TEXT = <<EOT;
! Try 'texi2html -help' for usage instructions.
! EOT
! $options = new Getopt::MySimple;
! 
! # some older version of GetOpt::Long don't have 
! # Getopt::Long::Configure("pass_through")
! eval {Getopt::Long::Configure("pass_through");};
! $Configure_failed = $@ && <<EOT;
! **WARNING: Parsing of obsolete command-line options could have failed. 
!            Consider to use only documented command-line options (run
!            'texi2html -help 2' for a complete list) or upgrade to perl 
!            version 5.005 or higher.
! EOT
! 
! if (! $options->getOptions($T2H_OPTIONS, $T2H_USAGE_TEXT, "$THISVERSION\n"))
! {
!   print $Configure_failed if $Configure_failed;
!   die $T2H_FAILURE_TEXT;
! }
! 
! if (@ARGV > 1)
! {
!   eval {Getopt::Long::Configure("no_pass_through");};
!   if (! $options->getOptions($T2H_OBSOLETE_OPTIONS, $T2H_USAGE_TEXT, "$THISVERSION\n"))
!   {
!     print $Configure_failed if $Configure_failed;
!     die $T2H_FAILURE_TEXT;
!   }
! }
! 
! if ($T2H_CHECK) {
!     die "Need file to check\n$T2H_FAILURE_TEXT" unless @ARGV > 0;
      &check;
      exit;
  }
  
! #+++############################################################################
! #                                                                              #
! # evaluation of cmd line options
! #                                                                              #
! #---############################################################################
! 
! if ($T2H_EXPAND eq 'info') 
! {
!   $to_skip{'ifinfo'} = 1;
!   $to_skip{'end ifinfo'} = 1;
! } 
! elsif ($T2H_EXPAND eq 'tex')
! {
!   $to_skip{'iftex'} = 1;
!   $to_skip{'end iftex'} = 1;
!   
  }
! 
! $T2H_INVISIBLE_MARK = '<IMG SRC="invisible.xbm">' if $T2H_INVISIBLE_MARK eq 'xbm';
! 
! #
! # file name buisness
! #
! die "Need exactly one file to translate\n$T2H_FAILURE_TEXT" unless @ARGV == 1;
  $docu = shift(@ARGV);
  if ($docu =~ /.*\//) {
***************
*** 380,393 ****
      $docu_name = $docu;
  }
! unshift(@include_dirs, $docu_dir);
  $docu_name =~ s/\.te?x(i|info)?$//;	# basename of the document
  
! $docu_doc = "$docu_name.html";		# document's contents
! if ($monolithic) {
!     $docu_toc = $docu_foot = $docu_doc;
! } else {
!     $docu_toc  = "${docu_name}_toc.html";  # document's table of contents
!     $docu_foot = "${docu_name}_foot.html"; # document's footnotes
! }
  
  #
--- 2301,2401 ----
      $docu_name = $docu;
  }
! unshift(@T2H_INCLUDE_DIRS, $docu_dir);
  $docu_name =~ s/\.te?x(i|info)?$//;	# basename of the document
+ $docu_name = $T2H_PREFIX if ($T2H_PREFIX);
  
! # subdir
! if ($T2H_SUBDIR && ! $T2H_OUT)
! {
!   $T2H_SUBDIR =~ s|/*$||;
!   unless (-d "$T2H_SUBDIR" && -w "$T2H_SUBDIR")
!   {
!     if ( mkdir($T2H_SUBDIR, oct(755)))
!     {
!       print "# created directory $T2H_SUBDIR\n" if ($T2H_VERBOSE);
!     }
!     else
!     {
!       warn "$ERROR can't create directory $T2H_SUBDIR. Put results into current directory\n";
!       $T2H_SUBDIR = '';
!     }
!   }
! }
! 
! if ($T2H_SUBDIR && ! $T2H_OUT)
! {
!   $docu_rdir = "$T2H_SUBDIR/";
!   print "# putting result files into directory $docu_rdir\n" if ($T2H_VERBOSE);
! }
! else
! {
!   if ($T2H_OUT && $T2H_OUT =~ m|(.*)/|)
!   {
!     $docu_rdir = "$1/";
!     print "# putting result files into directory $docu_rdir\n" if ($T2H_VERBOSE);
!   }
!   else
!   {
!     print "# putting result files into current directory \n" if ($T2H_VERBOSE);
!     $docu_rdir = '';
!   }
! }
! 
! # extension
! if ($T2H_SHORTEXTN)
! {
!   $docu_ext = "htm";
! }
! else
! {
!   $docu_ext = "html";
! }
! if ($T2H_TOP_FILE =~ /\..*$/)
! {
!   $T2H_TOP_FILE = $`.".$docu_ext";
! }
! 
! # result files
! if (! $T2H_OUT && ($T2H_SPLIT =~ /section/i || $T2H_SPLIT =~ /node/i))
! {
!   $T2H_SPLIT = 'section';
! }
! elsif (! $T2H_OUT && $T2H_SPLIT =~ /chapter/i)
! {
!   $T2H_SPLIT = 'chapter'
! }
! else
! {
!   undef $T2H_SPLIT;
! }
! 
! $docu_doc = "$docu_name.$docu_ext";		# document's contents
! $docu_doc_file = "$docu_rdir$docu_doc";
! if ($T2H_SPLIT) 
! {
!   $docu_toc  = $T2H_TOC_FILE || "${docu_name}_toc.$docu_ext"; # document's table of contents
!   $docu_stoc = "${docu_name}_ovr.$docu_ext"; # document's short toc
!   $docu_foot = "${docu_name}_fot.$docu_ext"; # document's footnotes
!   $docu_about = "${docu_name}_abt.$docu_ext"; # about this document
!   $docu_top  = $T2H_TOP_FILE || $docu_doc;
! }
! else
! {
!   if ($T2H_OUT)
!   {
!     $docu_doc = $T2H_OUT;
!     $docu_doc =~ s|.*/||;
!   }
!   $docu_toc = $docu_foot = $docu_stoc = $docu_about = $docu_top = $docu_doc;
! }
! 
! $docu_toc_file  = "$docu_rdir$docu_toc";
! $docu_stoc_file = "$docu_rdir$docu_stoc";
! $docu_foot_file = "$docu_rdir$docu_foot";
! $docu_about_file = "$docu_rdir$docu_about";
! $docu_top_file  = "$docu_rdir$docu_top";
! 
! $docu_frame_file =     "$docu_rdir${docu_name}_frame.$docu_ext";
! $docu_toc_frame_file = "$docu_rdir${docu_name}_toc_frame.$docu_ext";
  
  #
***************
*** 395,406 ****
  #
  $value{'html'} = 1;			# predefine html (the output format)
! $value{'texi2html'} = '1.52';		# predefine texi2html (the translator)
  # _foo: internal to track @foo
  foreach ('_author', '_title', '_subtitle',
! 	 '_settitle', '_setfilename') {
      $value{$_} = '';		        # prevent -w warnings
  }
  %node2sec = ();				# node to section name
  %node2href = ();			# node to HREF
  %bib2href = ();				# bibliography reference to HREF
  %gloss2href = ();			# glossary term to HREF
--- 2403,2421 ----
  #
  $value{'html'} = 1;			# predefine html (the output format)
! $value{'texi2html'} = $THISVERSION;	# predefine texi2html (the translator)
  # _foo: internal to track @foo
  foreach ('_author', '_title', '_subtitle',
! 	 '_settitle', '_setfilename', '_shorttitle') {
      $value{$_} = '';		        # prevent -w warnings
  }
  %node2sec = ();				# node to section name
+ %sec2node = ();				# section to node name
+ %sec2number = ();                       # section to number
+ %number2sec = ();                       # number to section 
+ %idx2node = ();                         # index keys to node
  %node2href = ();			# node to HREF
+ %node2next = ();			# node to next
+ %node2prev = ();			# node to prev
+ %node2up   = ();			# node to up
  %bib2href = ();				# bibliography reference to HREF
  %gloss2href = ();			# glossary term to HREF
***************
*** 422,426 ****
  # can I use ISO8879 characters? (HTML+)
  #
! if ($use_iso) {
      $things_map{'bullet'} = "&bull;";
      $things_map{'copyright'} = "&copy;";
--- 2437,2441 ----
  # can I use ISO8879 characters? (HTML+)
  #
! if ($T2H_USE_ISO) {
      $things_map{'bullet'} = "&bull;";
      $things_map{'copyright'} = "&copy;";
***************
*** 437,441 ****
  $extensions = 'texi2html.ext'; # extensions in working directory
  if (-f $extensions) {
!     print "# reading extensions from $extensions\n" if $verbose;
      require($extensions);
  }
--- 2452,2456 ----
  $extensions = 'texi2html.ext'; # extensions in working directory
  if (-f $extensions) {
!     print "# reading extensions from $extensions\n" if $T2H_VERBOSE;
      require($extensions);
  }
***************
*** 444,453 ****
      $extensions = "${progdir}texi2html.ext"; # extensions in texi2html directory
      if (-f $extensions) {
! 	print "# reading extensions from $extensions\n" if $verbose;
  	require($extensions);
      }
  }
  
! print "# reading from $docu\n" if $verbose;
  
  #+++############################################################################
--- 2459,2936 ----
      $extensions = "${progdir}texi2html.ext"; # extensions in texi2html directory
      if (-f $extensions) {
! 	print "# reading extensions from $extensions\n" if $T2H_VERBOSE;
  	require($extensions);
      }
  }
  
! 
! print "# reading from $docu\n" if $T2H_VERBOSE;
! 
! #########################################################################
! #
! # latex2html stuff
! # 
! # latex2html conversions consist of three stages:
! # 1) ToLatex: Put "latex" code into a latex file
! # 2) ToHtml: Use latex2html to generate corresponding html code and images
! # 3) FromHtml: Extract generated code and images from latex2html run
! #
! 
! ##########################
! # default settings
! #
! 
! # defaults for files and names
! 
! sub l2h_Init 
! {
!   local($root) = @_;
!   
!   return 0 unless ($root);
!   
!   $l2h_name =  "${root}_l2h";
!   
!   $l2h_latex_file = "$docu_rdir${l2h_name}.tex";
!   $l2h_cache_file = "${docu_rdir}l2h_cache.pm";
!   $T2H_L2H_L2H = "latex2html" unless ($T2H_L2H_L2H);
!   
!   # destination dir -- generated images are put there, should be the same
!   # as dir of enclosing html document -- 
!   $l2h_html_file = "$docu_rdir${l2h_name}.html";
!   $l2h_prefix = "${l2h_name}_";
!   return 1;
! }
! 
! 
! ##########################
! # 
! # First stage: Generation of Latex file
! # Initialize with: l2h_InitToLatex
! # Add content with: l2h_ToLatex($text) --> HTML placeholder comment
! # Finish with: l2h_FinishToLatex
! # 
! 
! $l2h_latex_preample = <<EOT;
! % This document was automatically generated by the l2h extenstion of texi2html
! % DO NOT EDIT !!!
! \\documentclass{article}
! \\usepackage{html}
! \\begin{document}
! EOT
! 
! $l2h_latex_closing = <<EOT;
! \\end{document}
! EOT
! 
! # return used latex 1, if l2h could be initalized properly, 0 otherwise
! sub l2h_InitToLatex
! {
!   %l2h_to_latex = ();
!   unless ($T2H_L2H_SKIP)
!   {
!     unless (open(L2H_LATEX, ">$l2h_latex_file"))
!     {
!       warn "$ERROR Error l2h: Can't open latex file '$latex_file' for writing\n";
!       return 0;
!     }  
!     print "# l2h: use ${l2h_latex_file} as latex file\n" if ($T2H_VERBOSE);
!     print L2H_LATEX $l2h_latex_preample;
!   }
!   # open database for caching
!   l2h_InitCache();
!   $l2h_latex_count = 0;
!   $l2h_to_latex_count = 0;
!   $l2h_cached_count = 0;
!   return  1;
! }
! 
! # print text (1st arg) into latex file (if not already there), return
! # HTML commentary which can be later on replaced by the latex2html
! # generated text
! sub l2h_ToLatex
! {
!   my($text) = @_;
!   my($count);
!   
!   $l2h_to_latex_count++;
!   $text =~ s/(\s*)$//;
!   
!   # try whether we can cache it
!   my $cached_text = l2h_FromCache($text);
!   if ($cached_text)
!   {
!     $l2h_cached_count++;
!     return $cached_text;
!   }
!   
!   # try whether we have text already on things to do
!   unless ($count = $l2h_to_latex{$text})
!   {
!     $count = $l2h_latex_count;
!     $l2h_latex_count++;
!     $l2h_to_latex{$text} = $count;
!     $l2h_to_latex[$count] = $text;
!     unless ($T2H_L2H_SKIP)
!     {
!       print L2H_LATEX "\\begin{rawhtml}\n";
!       print L2H_LATEX "<!-- l2h_begin ${l2h_name} ${count} -->\n";
!       print L2H_LATEX "\\end{rawhtml}\n";
!       
!       print L2H_LATEX "$text\n";
!       
!       print L2H_LATEX "\\begin{rawhtml}\n";
!       print L2H_LATEX "<!-- l2h_end ${l2h_name} ${count} -->\n";
!       print L2H_LATEX "\\end{rawhtml}\n";
!     }
!   }
!   return "<!-- l2h_replace ${l2h_name} ${count} -->"; 
! }
! 
! # print closing into latex file and close it
! sub l2h_FinishToLatex
! {
!   local ($reused);
!   
!   $reused = $l2h_to_latex_count - $l2h_latex_count - $l2h_cached_count;
!   unless ($T2H_L2H_SKIP)
!   {
!     print L2H_LATEX $l2h_latex_closing;
!     close(L2H_LATEX);
!   }
!   print "# l2h: finished to latex ($l2h_cached_count cached, $reused reused, $l2h_latex_count contents)\n" if ($T2H_VERBOSE);
!   unless ($l2h_latex_count)
!   {
!     l2h_Finish();
!     return 0;
!   }
!   return 1;
! }
! 
! ###################################
! # Second stage: Use latex2html to generate corresponding html code and images
! #
! # l2h_ToHtml([$l2h_latex_file, [$l2h_html_dir]]):
! #   Call latex2html on $l2h_latex_file
! #   Put images (prefixed with $l2h_name."_") and html file(s) in $l2h_html_dir
! #   Return 1, on success
! #          0, otherwise
! #
! sub l2h_ToHtml
! {
!   local($call, $ext, $root, $dotbug);
!   
!   if ($T2H_L2H_SKIP)
!   {
!     print "# l2h: skipping latex2html run\n" if ($T2H_VERBOSE);
!     return 1;
!   }
!   
!   # Check for dot in directory where dvips will work
!   if ($T2H_L2H_TMP)
!   {
!     if ($T2H_L2H_TMP =~ /\./)
!     {
!       warn "$ERROR Warning l2h: l2h_tmp dir contains a dot. Use /tmp, instead\n";
!       $dotbug = 1;
!     }
!   }
!   else
!   {
!     if (&getcwd =~ /\./)
!     {
!      warn "$ERROR Warning l2h: current dir contains a dot. Use /tmp as l2h_tmp dir \n";
!      $dotbug = 1;
!    }
!   }
!   # fix it, if necessary and hope that it works 
!   $T2H_L2H_TMP = "/tmp" if ($dotbug);
!     
!   $call = $T2H_L2H_L2H;
!   # use init file, if specified
!   $call = $call . " -init_file " . $init_file if ($init_file && -f $init_file);
!   # set output dir
!   $call .=  ($docu_rdir ? " -dir $docu_rdir" : " -no_subdir");
!   # use l2h_tmp, if specified
!   $call = $call . " -tmp $T2H_L2H_TMP" if ($T2H_L2H_TMP);
!   # options we want to be sure of
!   $call = $call ." -address 0 -info 0 -split 0 -no_navigation -no_auto_link";
!   $call = $call ." -prefix ${l2h_prefix} $l2h_latex_file"; 
! 
!   print "# l2h: executing '$call'\n" if ($T2H_VERBOSE);
!   if (system($call))
!   {
!     warn "l2h ***Error: '${call}' did not succeed\n";
!     return 0;
!   }
!   else
!   {
!     print "# l2h: latex2html finished successfully\n" if ($T2H_VERBOSE);
!     return 1;
!   }
! }
! 
! # this is directly pasted over from latex2html
! sub getcwd {
!     local($_) = `pwd`;
! 
!     die "'pwd' failed (out of memory?)\n"
! 	unless length;
!     chop;
!     $_;
! }
! 
! 
! ##########################
! # Third stage: Extract generated contents from latex2html run
! # Initialize with: l2h_InitFromHtml
! #   open $l2h_html_file for reading
! #   reads in contents into array indexed by numbers
! #   return 1,  on success -- 0, otherwise
! # Extract Html code with: l2h_FromHtml($text)
! #   replaces in $text all previosuly inserted comments by generated html code
! #   returns (possibly changed) $text
! # Finish with: l2h_FinishFromHtml
! #   closes $l2h_html_dir/$l2h_name.".$docu_ext" 
! 
! sub l2h_InitFromHtml
! {
!   local($h_line, $h_content, $count, %l2h_img);
! 
!   if (! open(L2H_HTML, "<${l2h_html_file}"))
!   {
!     print "$ERROR Error l2h: Can't open ${l2h_html_file} for reading\n";
!     return 0;
!   }
!   print "# l2h: use ${l2h_html_file} as html file\n" if ($T2H_VERBOSE);
! 
!   $l2h_html_count = 0;
!   
!   while ($h_line = <L2H_HTML>)
!   {
!     if ($h_line =~ /^<!-- l2h_begin $l2h_name ([0-9]+) -->/)
!     {
!       $count = $1;
!       $h_content = "";
!       while ($h_line = <L2H_HTML>)
!       {
! 	if ($h_line =~ /^<!-- l2h_end $l2h_name $count -->/)
! 	{
! 	  chomp $h_content;
! 	  chomp $h_content;
! 	  $l2h_html_count++;
! 	  $h_content = l2h_ToCache($count, $h_content);
! 	  $l2h_from_html[$count] = $h_content;
! 	  $h_content = '';
! 	  last;
! 	}
! 	$h_content = $h_content.$h_line;
!       }
!       if ($hcontent)
!       {
! 	print "$ERROR Warning l2h: l2h_end $l2h_name $count not found\n" 
! 	  if ($T2H_VERBOSE);
! 	close(L2H_HTML);
! 	return 0;
!       }
!     }
!   }
!   print "# l2h: Got $l2h_html_count of $l2h_latex_count html contents\n"
!     if ($T2H_VERBOSE);
! 
!   close(L2H_HTML);
!   return 1;
! }
! 
! sub l2h_FromHtml
! {
!   local($text) = @_;
!   local($done, $to_do, $count);
!   
!   $to_do = $text;
!   
!   while ($to_do =~ /([^\000]*)<!-- l2h_replace $l2h_name ([0-9]+) -->([^\000]*)/)
!   {
!     $to_do = $1;
!     $count = $2;
!     $done = $3.$done;
!     
!     $done = "<!-- l2h_end $l2h_name $count -->".$done
!       if ($T2H_DEBUG & $DEBUG_L2H);
! 
!     $done = &l2h_ExtractFromHtml($count) . $done;
! 
!     $done = "<!-- l2h_begin $l2h_name $count -->".$done
!       if ($T2H_DEBUG & $DEBUG_L2H);
!   }
!   return $to_do.$done;
! }
! 
! 
! sub l2h_ExtractFromHtml
! {
!   local($count) = @_;
!   
!   return $l2h_from_html[$count] if ($l2h_from_html[$count]);
!   
!   if ($count >= 0 && $count < $l2h_latex_count)
!   {
!     # now we are in trouble
!     local($l_l2h, $_);
! 
!     $l2h_extract_error++;
!     print "$ERROR l2h: can't extract content $count from html\n" 
!       if ($T2H_VERBOSE);
!     # try simple (ordinary) substition (without l2h)
!     $l_l2h = $T2H_L2H;
!     $T2H_L2H = 0;
!     $_ = $l2h_to_latex{$count};
!     $_ = &substitute_style($_); 
!     &unprotect_texi;
!     $_ = "<!-- l2h: ". __LINE__ . " use texi2html -->" . $_
!       if ($T2H_DEBUG & $DEBUG_L2H);
!     $T2H_L2H = $l_l2h;
!     return $_;
!   }
!   else
!   {
!     # now we have been incorrectly called
!     $l2h_range_error++;
!     print "$ERROR l2h: Request of $count content which is out of valide range [0,$l2h_latex_count)\n";
!     return "<!-- l2h: ". __LINE__ . " out of range count $count -->"
!       if ($T2H_DEBUG & $DEBUG_L2H);
!     return "<!-- l2h: out of range count $count -->";
!   }
! }
!     
! sub l2h_FinishFromHtml
! {
!   if ($T2H_VERBOSE)
!   {
!     if ($l2h_extract_error + $l2h_range_error)
!     {
!       print "# l2h: finished from html ($l2h_extract_error extract and $l2h_range_error errors)\n";
!     }
!     else
!     {
!       print "# l2h: finished from html (no errors)\n";
!     }
!   }
! }
! 
! sub l2h_Finish
! {
!   l2h_StoreCache();
!   if ($T2H_L2H_CLEAN)
!   {
!     print "# l2h: removing temporary files generated by l2h extension\n"
!       if $T2H_VERBOSE;
!     while (<"$docu_rdir$l2h_name"*>)
!     {
!       unlink $_;
!     }
!   }
!   print "# l2h: Finished\n" if $T2H_VERBOSE;
!   return 1;
! }
! 
! ##############################
! # stuff for l2h caching
! #
! 
! # I tried doing this with a dbm data base, but it did not store all
! # keys/values. Hence, I did as latex2html does it
! sub l2h_InitCache
! {
!   if (-r "$l2h_cache_file")
!   {
!     my $rdo = do "$l2h_cache_file";
!     warn("$ERROR l2h Error: could not load $docu_rdir$l2h_cache_file: $@\n")
!       unless ($rdo);
!   }
! }
! 
! sub l2h_StoreCache
! {
!   return unless $l2h_latex_count;
!   
!   my ($key, $value);
!   open(FH, ">$l2h_cache_file") || return warn"$ERROR l2h Error: could not open $docu_rdir$l2h_cache_file for writing: $!\n";
! 
!   
!   while (($key, $value) = each %l2h_cache)
!   {
!     # escape stuff
!     $key =~ s|/|\\/|g;
!     $key =~ s|\\\\/|\\/|g;
!     # weird, a \ at the end of the key results in an error
!     # maybe this also broke the dbm database stuff
!     $key =~ s|\\$|\\\\|;
!     $value =~ s/\|/\\\|/g; 
!     $value =~ s/\\\\\|/\\\|/g; 
!     $value =~ s|\\\\|\\\\\\\\|g;
!     print FH "\n\$l2h_cache_key = q/$key/;\n";
!     print FH "\$l2h_cache{\$l2h_cache_key} = q|$value|;\n";
!   }
!   print FH "1;";
!   close(FH);
! }
! 
! # return cached html, if it exists for text, and if all pictures
! # are there, as well
! sub l2h_FromCache
! {
!   my $text = shift;
!   my $cached = $l2h_cache{$text};
!   if ($cached)
!   {
!     while ($cached =~ m/SRC="(.*?)"/g)
!     {
!       unless (-e "$docu_rdir$1")
!       {
! 	return undef;
!       }
!     }
!     return $cached;
!   }
!   return undef;
! }
! 
! # insert generated html into cache, move away images, 
! # return transformed html
! $maximage = 1;
! sub l2h_ToCache
! {
!   my $count = shift;
!   my $content = shift;
!   my @images = ($content =~ /SRC="(.*?)"/g);
!   my ($src, $dest);
! 
!   for $src (@images)
!   {
!     $dest = $l2h_img{$src};
!     unless ($dest)
!     {
!       my $ext;
!       if ($src =~ /.*\.(.*)$/ && $1 ne $docu_ext)
!       {
! 	$ext = $1;
!       }
!       else
!       {
! 	warn "$ERROR: L2h image $src has invalid extension\n";
! 	next;
!       }
!       while (-e "$docu_rdir${docu_name}_$maximage.$ext") { $maximage++;}
!       $dest = "${docu_name}_$maximage.$ext";
!       system("cp -f $docu_rdir$src $docu_rdir$dest");
!       $l2h_img{$src} = $dest;
!       unlink "$docu_rdir$src" unless ($DEBUG & DEBUG_L2H);
!     }
!     $content =~ s/$src/$dest/g;
!   }
!   $l2h_cache{$l2h_to_latex[$count]} = $content;
!   return $content;
! }
! 
  
  #+++############################################################################
***************
*** 459,465 ****
  @lines = ();				# whole document
  @toc_lines = ();			# table of contents
! $toplevel = 0;			        # top level seen in hierarchy
  $curlevel = 0;				# current level in TOC
  $node = '';				# current node name
  $in_table = 0;				# am I inside a table
  $table_type = '';			# type of table ('', 'f', 'v', 'multi')
--- 2942,2951 ----
  @lines = ();				# whole document
  @toc_lines = ();			# table of contents
! @stoc_lines = ();			# table of contents
  $curlevel = 0;				# current level in TOC
  $node = '';				# current node name
+ $node_next = '';                        # current node next name               
+ $node_prev = '';                        # current node prev name
+ $node_up = '';                          # current node up name
  $in_table = 0;				# am I inside a table
  $table_type = '';			# type of table ('', 'f', 'v', 'multi')
***************
*** 468,471 ****
--- 2954,2959 ----
  $in_glossary = 0;			# am I inside a glossary
  $in_top = 0;				# am I inside the top node
+ $has_top = 0;				# did I see a top node?
+ $has_top_command = 0;			# did I see @top for automatic pointers?
  $in_pre = 0;				# am I inside a preformatted section
  $in_list = 0;				# am I inside a list
***************
*** 473,481 ****
  $first_line = 1;		        # is it the first line
  $dont_html = 0;				# don't protect HTML on this line
- $split_num = 0;				# split index
  $deferred_ref = '';			# deferred reference for indexes
  @html_stack = ();			# HTML elements stack
  $html_element = '';			# current HTML element
  &html_reset;
  
  # build code for simple substitutions
--- 2961,2973 ----
  $first_line = 1;		        # is it the first line
  $dont_html = 0;				# don't protect HTML on this line
  $deferred_ref = '';			# deferred reference for indexes
  @html_stack = ();			# HTML elements stack
  $html_element = '';			# current HTML element
  &html_reset;
+ %macros = ();                           # macros
+ 
+ # init l2h
+ $T2H_L2H = &l2h_Init($docu_name) if ($T2H_L2H);
+ $T2H_L2H = &l2h_InitToLatex      if ($T2H_L2H);    
  
  # build code for simple substitutions
***************
*** 500,504 ****
  	    $subst_code .= "s/\\\@\\$_";
  	}
! 	$subst_code .= "([aeiou])/&\${1}$accent_map{$_};/gi;\n";
      }
  }
--- 2992,2996 ----
  	    $subst_code .= "s/\\\@\\$_";
  	}
! 	$subst_code .= "([a-z])/&\${1}$accent_map{$_};/gi;\n";
      }
  }
***************
*** 506,510 ****
  
  &init_input;
! while ($_ = &next_line) {
      #
      # remove \input on the first lines only
--- 2998,3002 ----
  
  &init_input;
! INPUT_LINE: while ($_ = &next_line) {
      #
      # remove \input on the first lines only
***************
*** 514,517 ****
--- 3006,3010 ----
  	$first_line = 0;
      }
+     # non-@ substitutions cf. texinfmt.el
      #
      # parse texinfo tags
***************
*** 519,532 ****
      $tag = '';
      $end_tag = '';
!     if (/^\@end\s+(\w+)\b/) {
  	$end_tag = $1;
!     } elsif (/^\@(\w+)\b/) {
  	$tag = $1;
      }
      #
!     # handle @ifhtml / @end ifhtml
      #
      if ($in_html) {
! 	if ($end_tag eq 'ifhtml') {
  	    $in_html = 0;
  	} else {
--- 3012,3025 ----
      $tag = '';
      $end_tag = '';
!     if (/^\s*\@end\s+(\w+)\b/) {
  	$end_tag = $1;
!     } elsif (/^\s*\@(\w+)\b/) {
  	$tag = $1;
      }
      #
!     # handle @html / @end html
      #
      if ($in_html) {
! 	if ($end_tag eq 'html') {
  	    $in_html = 0;
  	} else {
***************
*** 534,567 ****
  	}
  	next;
!     } elsif ($tag eq 'ifhtml') {
  	$in_html = $PROTECTTAG . ++$html_num;
  	push(@lines, $in_html);
  	next;
      }
      #
      # try to skip the line
      #
      if ($end_tag) {
  	next if $to_skip{"end $end_tag"};
      } elsif ($tag) {
! 	next if $to_skip{$tag};
! 	last if $tag eq 'bye';
      }
      if ($in_top) {
  	# parsing the top node
! 	if ($tag eq 'node' || $tag eq 'include' || $sec2level{$tag}) {
  	    # no more in top
  	    $in_top = 0;
! 	} else {
! 	    # skip it
! 	    next;
  	}
      }
-     #
-     # try to remove inlined comments
-     # syntax from tex-mode.el comment-start-skip
-     #
-     s/((^|[^\@])(\@\@)*)\@c(omment)? .*/$1/;
-     # non-@ substitutions cf. texinfmt.el
      unless ($in_pre) {
  	s/``/\"/g;
--- 3027,3126 ----
  	}
  	next;
!     } elsif ($tag eq 'html') {
  	$in_html = $PROTECTTAG . ++$html_num;
  	push(@lines, $in_html);
  	next;
      }
+ 
+     #
+     # try to remove inlined comments
+     # syntax from tex-mode.el comment-start-skip
+     #
+     s/((^|[^\@])(\@\@)*)\@c(omment | |\{|$).*/$1/;
+ 
+ # Sometimes I use @c right at the end of  a line ( to suppress the line feed )
+ #    s/((^|[^\@])(\@\@)*)\@c(omment)?$/$1/;
+ #     s/((^|[^\@])(\@\@)*)\@c(omment)? .*/$1/;
+ #     s/(.*)\@c{.*?}(.*)/$1$2/;
+ #     s/(.*)\@comment{.*?}(.*)/$1$2/;
+ #     s/^(.*)\@c /$1/;
+ #     s/^(.*)\@comment /$1/;
+ 
+     #############################################################
+     # value substitution before macro expansion, so that
+     # it works in macro arguments			    
+     s/\@value{($VARRE)}/$value{$1}/eg;
+ 			    
+     #############################################################
+     # macro substitution
+     while (/\@(\w+)/g)
+     {
+       if (exists($macros->{$1}))    
+       {
+ 	my $before = $`;
+ 	my $name = $1;
+ 	my $after = $';
+ 	my @args;
+ 	my $args;
+ 	if ($after =~ /^\s*{(.*?[^\\])}(.*)/)  
+ 	{
+ 	  $args = $1;
+ 	  $after = $2;
+ 	}
+ 	elsif (@{$macros->{$name}->{Args}} == 1)
+ 	{
+ 	  $args = $after;
+ 	  $args =~ s/^\s*//;
+ 	  $args =~ s/\s*$//;
+ 	  $after = '';
+ 	}
+ 	$args =~ s|\\\\|\\|g;
+ 	$args =~ s|\\{|{|g;
+         $args =~ s|\\}|}|g;
+ 	if (@{$macros->{$name}->{Args}} > 1)
+ 	{
+ 	  $args =~ s/(^|[^\\]),/$1$;/g ;
+ 	  $args =~ s|\\,|,|g;
+ 	  @args = split(/$;\s*/, $args) if (@{$macros->{$name}->{Args}} > 1);
+ 	}
+ 	else
+ 	{
+ 	  $args =~ s|\\,|,|g;
+ 	  @args = ($args);
+ 	}
+ 	my $macrobody = $macros->{$name}->{Body};
+ 	for ($i=0; $i<=$#args; $i++)
+ 	{
+ 	  $macrobody =~ s|\\$macros->{$name}->{Args}->[$i]\\|$args[$i]|g;
+ 	}
+ 	$macrobody =~ s|\\\\|\\|g;
+ 	$_ = $before . $macrobody . $after;
+ 	unshift @input_spool, map {$_ = $_."\n"} split(/\n/, $_);
+ 	next INPUT_LINE;
+       }
+     }				#
+ 			    
+     
      #
      # try to skip the line
      #
      if ($end_tag) {
+         $in_titlepage = 0 if $end_tag eq 'titlepage';
  	next if $to_skip{"end $end_tag"};
      } elsif ($tag) {
!       $in_titlepage = 1 if $tag eq 'titlepage';
!       next if $to_skip{$tag};
!       last if $tag eq 'bye';
      }
      if ($in_top) {
  	# parsing the top node
! 	if ($tag eq 'node' || 
! 	    ($sec2level{$tag} && $tag !~ /unnumbered/ && $tag !~ /heading/))
! 	{
  	    # no more in top
  	    $in_top = 0;
! 	    push(@lines, $TOPEND);
  	}
      }
      unless ($in_pre) {
  	s/``/\"/g;
***************
*** 575,584 ****
  	# skip lines
  	&skip_until($tag), next if $tag eq 'ignore';
! 	if ($expandinfo) {
! 	    &skip_until($tag), next if $tag eq 'iftex';
! 	} else {
! 	    &skip_until($tag), next if $tag eq 'ifinfo';
  	}
- 	&skip_until($tag), next if $tag eq 'tex';
  	# handle special tables
  	if ($tag =~ /^(|f|v|multi)table$/) {
--- 3134,3164 ----
  	# skip lines
  	&skip_until($tag), next if $tag eq 'ignore';
! 	&skip_until($tag), next if $tag eq 'ifnothtml';
! 	if ($tag eq 'ifinfo')
! 	{
! 	  &skip_until($tag), next unless $T2H_EXPAND eq 'info';
! 	}
! 	if ($tag eq 'iftex')
! 	{
! 	  &skip_until($tag), next unless $T2H_EXPAND eq 'tex';
! 	} 
! 	if ($tag eq 'tex')
! 	{
! 	  # add to latex2html file
! 	  if ($T2H_EXPAND eq 'tex' && $T2H_L2H && ! $in_pre)
! 	  {
! 	    # add space to the end -- tex(i2dvi) does this, as well 
! 	    push(@lines, &l2h_ToLatex(&string_until($tag) . " "));
! 	  }
! 	  else
! 	  {
! 	    &skip_until($tag);
! 	  }
! 	  next;
! 	}
! 	if ($tag eq 'titlepage')
! 	{
! 	  next;
  	}
  	# handle special tables
  	if ($tag =~ /^(|f|v|multi)table$/) {
***************
*** 589,621 ****
  	if ($tag eq 'top' || ($tag eq 'node' && /^\@node\s+top\s*,/i)) {
  	    $in_top = 1;
  	    @lines = (); # ignore all lines before top (title page garbage)
  	    next;
  	} elsif ($tag eq 'node') {
  	    $in_top = 0;
! 	    warn "$ERROR Bad node line: $_" unless $_ =~ /^\@node\s$NODESRE$/o;
! 	    $_ = &protect_html($_); # if node contains '&' for instance
! 	    s/^\@node\s+//;
! 	    ($node) = split(/,/);
! 	    &normalise_node($node);
! 	    if ($split_node) {
! 		&next_doc;
! 		push(@lines, $SPLITTAG) if $split_num++;
! 		push(@sections, $node);
! 	    }
! 	    next;
  	} elsif ($tag eq 'include') {
  	    if (/^\@include\s+($FILERE)\s*$/o) {
! 		$file = $1;
! 		unless (-e $file) {
! 		    foreach $dir (@include_dirs) {
! 			$file = "$dir/$1";
! 			last if -e $file;
! 		    }
! 		}
! 		if (-e $file) {
  		    &open($file);
! 		    print "# including $file\n" if $verbose;
  		} else {
! 		    warn "$ERROR Can't find $file, skipping";
  		}
  	    } else {
--- 3169,3203 ----
  	if ($tag eq 'top' || ($tag eq 'node' && /^\@node\s+top\s*,/i)) {
  	    $in_top = 1;
+ 	    $has_top = 1;
+ 	    $has_top_command = 1 if $tag eq 'top';
  	    @lines = (); # ignore all lines before top (title page garbage)
  	    next;
  	} elsif ($tag eq 'node') {
+ 	  if ($in_top)
+ 	  {
  	    $in_top = 0;
! 	    push(@lines, $TOPEND);
! 	  }
! 	  warn "$ERROR Bad node line: $_" unless $_ =~ /^\@node\s$NODESRE$/o;
! 	  # request of "Richard Y. Kim" <ryk@ap.com>
! 	  s/^\@node\s+//;
! 	  $_ = &protect_html($_); # if node contains '&' for instance
! 	  ($node, $node_next, $node_prev, $node_up) = split(/,/);
! 	  &normalise_node($node);
! 	  &normalise_node($node_next);
! 	  &normalise_node($node_prev);
! 	  &normalise_node($node_up);
! 	  $node =~ /\"/ ?
! 	    push @lines, &html_debug("<A NAME='$node'></A>\n", __LINE__) :
! 	    push @lines, &html_debug("<A NAME=\"$node\"></A>\n", __LINE__);
! 	  next;
  	} elsif ($tag eq 'include') {
  	    if (/^\@include\s+($FILERE)\s*$/o) {
! 		$file = LocateIncludeFile($1);
! 		if ($file && -e $file) {
  		    &open($file);
! 		    print "# including $file\n" if $T2H_VERBOSE;
  		} else {
! 		    warn "$ERROR Can't find $1, skipping";
  		}
  	    } else {
***************
*** 640,662 ****
  	    next;
  	} elsif ($tag eq 'menu') {
! 	    unless ($show_menu) {
  		&skip_until($tag);
  		next;
  	    }
  	    &html_push_if($tag);
! 	    push(@lines, &html_debug("\n", __LINE__));
  	} elsif ($format_map{$tag}) {
  	    $in_pre = 1 if $format_map{$tag} eq 'PRE';
  	    &html_push_if($format_map{$tag});
! 	    push(@lines, &html_debug("\n", __LINE__));
  	    $in_list++ if $format_map{$tag} eq 'UL' || $format_map{$tag} eq 'OL' ;
! 	    push(@lines, &debug("<$format_map{$tag}>\n", __LINE__));
  	    next;
  	} elsif ($tag eq 'table') {
! 	    if (/^\@(|f|v|multi)table\s+\@(\w+)/) {
  		$in_table = $2;
  		unshift(@tables, join($;, $table_type, $in_table));
  		if ($table_type eq "multi") {
! 		    push(@lines, &debug("<TABLE BORDER>\n", __LINE__));
  		    &html_push_if('TABLE');
  		} else {
--- 3222,3264 ----
  	    next;
  	} elsif ($tag eq 'menu') {
! 	    unless ($T2H_SHOW_MENU) {
  		&skip_until($tag);
  		next;
  	    }
  	    &html_push_if($tag);
! 	    push(@lines, &html_debug('', __LINE__));
  	} elsif ($format_map{$tag}) {
  	    $in_pre = 1 if $format_map{$tag} eq 'PRE';
  	    &html_push_if($format_map{$tag});
! 	    push(@lines, &html_debug('', __LINE__));
  	    $in_list++ if $format_map{$tag} eq 'UL' || $format_map{$tag} eq 'OL' ;
! #	    push(@lines, &debug("<BLOCKQUOTE>\n", __LINE__))
! #	      if $tag =~ /example/i;
! 	    # sunshine@sunshineco.com: <PRE>bla</PRE> looks better than
! 	    # <PRE>\nbla</PRE> (at least on NeXTstep browser
! 	    push(@lines, &debug("<$format_map{$tag}>" . 
! 				($in_pre ? '' : "\n"), __LINE__));
  	    next;
+ 	}
+ 	elsif (exists $complex_format_map->{$tag})
+ 	{
+ 	  my $start = eval $complex_format_map->{$tag}->[0];
+ 	  if ($@)
+ 	  {
+ 	    print "$ERROR: eval of complex_format_map->{$tag}->[0] $complex_format_map->{$tag}->[0]: $@";
+ 	    $start = '<pre>'
+ 	  }
+ 	  $in_pre = 1 if $start =~ /<pre/;
+ 	  push(@lines, html_debug($start. ($in_pre ? '' : "\n"), __LINE__));
+ 	  next;
  	} elsif ($tag eq 'table') {
! 	  # anorland@hem2.passagen.se
! 	  # if (/^\s*\@(|f|v|multi)table\s+\@(\w+)/) {
! 	     if (/^\s*\@(|f|v|multi)table\s+\@(\w+)|(\{[^\}]*\})/) {
  		$in_table = $2;
  		unshift(@tables, join($;, $table_type, $in_table));
  		if ($table_type eq "multi") {
! 		    # don't use borders -- gets confused by empty cells
! 		    push(@lines, &debug("<TABLE>\n", __LINE__));
  		    &html_push_if('TABLE');
  		} else {
***************
*** 664,682 ****
  		    &html_push_if('DL');
  		}
! 		push(@lines, &html_debug("\n", __LINE__));
  	    } else {
  		warn "$ERROR Bad table line: $_";
  	    }
  	    next;
! 	} elsif ($tag eq 'synindex' || $tag eq 'syncodeindex') {
! 	    if (/^\@$tag\s+(\w)\w\s+(\w)\w\s*$/) {
! 		eval("*${1}index = *${2}index");
! 	    } else {
! 		warn "$ERROR Bad syn*index line: $_";
  	    }
! 	    next;
! 	} elsif ($tag eq 'sp') {
  	    push(@lines, &debug("<P>\n", __LINE__));
  	    next;
  	} elsif ($tag eq 'setref') {
  	    &protect_html; # if setref contains '&' for instance
--- 3266,3329 ----
  		    &html_push_if('DL');
  		}
! 		push(@lines, &html_debug('', __LINE__));
  	    } else {
  		warn "$ERROR Bad table line: $_";
  	    }
  	    next;
! 	} 
! 	elsif ($tag eq 'synindex' || $tag eq 'syncodeindex') 
! 	{
! 	  if (/^\@$tag\s+(\w+)\s+(\w+)\s*$/) 
! 	  {
! 	    my $from = $1;
! 	    my $to = $2;
! 	    my $prefix_from = IndexName2Prefix($from);
! 	    my $prefix_to = IndexName2Prefix($to);
! 
! 	    warn("$ERROR unknown from index name $from ind syn*index line: $_"), next
! 	      unless $prefix_from;
! 	    warn("$ERROR unknown to index name $to ind syn*index line: $_"), next
! 	      unless $prefix_to;
! 
! 	    if ($tag eq 'syncodeindex')
! 	    {
! 	      $index_properties->{$prefix_to}->{'from_code'}->{$prefix_from} = 1;
  	    }
! 	    else
! 	    {
! 	       $index_properties->{$prefix_to}->{'from'}->{$prefix_from} = 1;
! 	    }
! 	  } 
! 	  else 
! 	  {
! 	    warn "$ERROR Bad syn*index line: $_";
! 	  }
! 	  next;
! 	} 
! 	elsif ($tag eq 'defindex' || $tag eq 'defcodeindex') 
! 	{
! 	  if (/^\@$tag\s+(\w+)\s*$/) 
! 	  {
! 	    my $name = $1;
! 	    $index_properties->{$name}->{name} = $name;
! 	    $index_properties->{$name}->{code} = 1 if $tag eq 'defcodeindex';
! 	  } 
! 	  else 
! 	  {
! 	    warn "$ERROR Bad defindex line: $_";
! 	  }
! 	  next;
! 	}
! 	elsif (/^\@printindex/)
! 	{
! 	  push (@lines, "<!--::${section}::-->$_");
! 	  next;
! 	}
! 	elsif ($tag eq 'sp') {
  	    push(@lines, &debug("<P>\n", __LINE__));
  	    next;
+ 	} elsif ($tag eq 'center') {
+ 	    push(@lines, &debug("<center>\n", __LINE__));
+ 	    s/\@center//;
  	} elsif ($tag eq 'setref') {
  	    &protect_html; # if setref contains '&' for instance
***************
*** 686,689 ****
--- 3333,3337 ----
  		$setref =~ s/ $//;
  		$node2sec{$setref} = $name;
+ 		$sec2node{$name} = $setref;
  		$node2href{$setref} = "$docu_doc#$docid";
  	    } else {
***************
*** 691,702 ****
  	    }
  	    next;
! 	} elsif ($tag eq 'defindex' || $tag eq 'defcodeindex') {
! 	    if (/^\@$tag\s+(\w\w)\s*$/) {
! 		$valid_index{$1} = 1;
! 	    } else {
! 		warn "$ERROR Bad defindex line: $_";
  	    }
  	    next;
! 	} elsif (defined($def_map{$tag})) {
  	    if ($def_map{$tag}) {
  		s/^\@$tag\s+//;
--- 3339,3390 ----
  	    }
  	    next;
! 	} elsif ($tag eq 'lowersections') {
! 	    local ($sec, $level);
! 	    while (($sec, $level) = each %sec2level) {
! 		$sec2level{$sec} = $level + 1;
  	    }
  	    next;
! 	} elsif ($tag eq 'raisesections') {
! 	    local ($sec, $level);
! 	    while (($sec, $level) = each %sec2level) {
! 		$sec2level{$sec} = $level - 1;
! 	    }
! 	    next;
! 	}
! 	elsif ($tag eq 'macro' || $tag eq 'rmacro')
! 	{
! 	  if (/^\@$tag\s*(\w+)\s*(.*)/)
! 	  {
! 	    my $name = $1;
! 	    my @args;
! 	    @args = split(/\s*,\s*/ , $1)
! 	      if ($2 =~ /^\s*{(.*)}\s*/);
! 	    
! 	    $macros->{$name}->{Args} = \@args;
! 	    $macros->{$name}->{Body} = '';
! 	    while (($_ = &next_line) && $_ !~ /\@end $tag/)
! 	    {
! 	      $macros->{$name}->{Body} .= $_;
! 	    }
! 	    die "ERROR: No closing '\@end $tag' found for macro definition of '$name'\n"
! 	      unless (/\@end $tag/);
! 	    chomp $macros->{$name}->{Body};
! 	  }
! 	  else
! 	  {
! 	    warn "$ERROR: Bad macro defintion $_"
! 	  }
! 	  next;
! 	}
! 	elsif ($tag eq 'unmacro')
! 	{
! 	  delete $macros->{$1} if (/^\@unmacro\s*(\w+)/);
! 	  next;
! 	}
! 	elsif ($tag eq 'documentlanguage')
! 	{
! 	  SetDocumentLanguage($1) if (!$T2H_LANG && /documentlanguage\s*(\w+)/);
! 	}
! 	elsif (defined($def_map{$tag})) {
  	    if ($def_map{$tag}) {
  		s/^\@$tag\s+//;
***************
*** 708,712 ****
  	    s/^\@$tag\s+//;
  	    $sub = $user_sub{$tag};
! 	    print "# user $tag = $sub, arg: $_" if $debug & $DEBUG_USER;
  	    if (defined(&$sub)) {
  		chop($_);
--- 3396,3400 ----
  	    s/^\@$tag\s+//;
  	    $sub = $user_sub{$tag};
! 	    print "# user $tag = $sub, arg: $_" if $T2H_DEBUG & $DEBUG_USER;
  	    if (defined(&$sub)) {
  		chop($_);
***************
*** 716,720 ****
  	    }
  	    next;
! 	}
  	if (defined($def_map{$tag})) {
  	    s/^\@$tag\s+//;
--- 3404,3408 ----
  	    }
  	    next;
! 	  } 
  	if (defined($def_map{$tag})) {
  	    s/^\@$tag\s+//;
***************
*** 743,749 ****
  	    $type =~ s/^\{(.*)\}$/$1/;
  	    print "# def ($tag): {$type} ", join(', ', @args), "\n"
! 		if $debug & $DEBUG_DEF;
  	    $type .= ':'; # it's nicer like this
! 	    $name = shift(@args);
  	    $name =~ s/^\{(.*)\}$/$1/;
  	    if ($is_extra) {
--- 3431,3437 ----
  	    $type =~ s/^\{(.*)\}$/$1/;
  	    print "# def ($tag): {$type} ", join(', ', @args), "\n"
! 		if $T2H_DEBUG & $DEBUG_DEF;
  	    $type .= ':'; # it's nicer like this
! 	    my $name = shift(@args);
  	    $name =~ s/^\{(.*)\}$/$1/;
  	    if ($is_extra) {
***************
*** 770,780 ****
  	    $name = &unprotect_html($name);
  	    if ($tag eq 'deffn' || $tag eq 'deftypefn') {
! 		unshift(@input_spool, "\@findex $name\n");
  	    } elsif ($tag eq 'defop') {
! 		unshift(@input_spool, "\@findex $name on $ftype\n");
  	    } elsif ($tag eq 'defvr' || $tag eq 'deftypevr' || $tag eq 'defcv') {
! 		unshift(@input_spool, "\@vindex $name\n");
  	    } else {
! 		unshift(@input_spool, "\@tindex $name\n");
  	    }
  	    $dont_html = 1;
--- 3458,3472 ----
  	    $name = &unprotect_html($name);
  	    if ($tag eq 'deffn' || $tag eq 'deftypefn') {
! 	      EnterIndexEntry('f', $name, $docu_doc, $section, \@lines);
! #		unshift(@input_spool, "\@findex $name\n");
  	    } elsif ($tag eq 'defop') {
! 	      EnterIndexEntry('f', "$name on $ftype", $docu_doc, $section, \@lines);
! #		unshift(@input_spool, "\@findex $name on $ftype\n");
  	    } elsif ($tag eq 'defvr' || $tag eq 'deftypevr' || $tag eq 'defcv') {
! 	      EnterIndexEntry('v', $name, $docu_doc, $section, \@lines);
! #		unshift(@input_spool, "\@vindex $name\n");
  	    } else {
! 	      EnterIndexEntry('t', $name, $docu_doc, $section, \@lines);
! #		unshift(@input_spool, "\@tindex $name\n");
  	    }
  	    $dont_html = 1;
***************
*** 784,791 ****
  	    $in_pre = 0 if $format_map{$end_tag} eq 'PRE';
  	    $in_list-- if $format_map{$end_tag} eq 'UL' || $format_map{$end_tag} eq 'OL' ;
! 	    &html_pop_if('LI', 'P');
  	    &html_pop_if();
  	    push(@lines, &debug("</$format_map{$end_tag}>\n", __LINE__));
! 	    push(@lines, &html_debug("\n", __LINE__));
  	} elsif ($end_tag =~ /^(|f|v|multi)table$/) {
  	    unless (@tables) {
--- 3476,3495 ----
  	    $in_pre = 0 if $format_map{$end_tag} eq 'PRE';
  	    $in_list-- if $format_map{$end_tag} eq 'UL' || $format_map{$end_tag} eq 'OL' ;
! 	    &html_pop_if('P');
! 	    &html_pop_if('LI');
  	    &html_pop_if();
  	    push(@lines, &debug("</$format_map{$end_tag}>\n", __LINE__));
! 	    push(@lines, &html_debug('', __LINE__));
! 	}
! 	elsif (exists $complex_format_map->{$end_tag})
! 	{
! 	  my $end = eval $complex_format_map->{$end_tag}->[1];
! 	  if ($@)
! 	  {
! 	    print "$ERROR: eval of complex_format_map->{$end_tag}->[1] $complex_format_map->{$end_tag}->[0]: $@";
! 	    $end = '</pre>'
! 	  }
! 	  $in_pre = 0 if $end =~ m|</pre>|;
! 	  push(@lines, html_debug($end, __LINE__));
  	} elsif ($end_tag =~ /^(|f|v|multi)table$/) {
  	    unless (@tables) {
***************
*** 793,796 ****
--- 3497,3501 ----
  		next;
  	    }
+ 	    &html_pop_if('P');
  	    ($table_type, $in_table) = split($;, shift(@tables));
  	    unless ($1 eq $table_type) {
***************
*** 816,824 ****
  	    &html_pop_if();
  	    push(@lines, $_); # must keep it for pass 2
! 	}
  	next;
      }
!     #
!     # misc things
      #
      # protect texi and HTML things
--- 3521,3546 ----
  	    &html_pop_if();
  	    push(@lines, $_); # must keep it for pass 2
! 	} 
  	next;
      }
!     #############################################################
!     # anchor insertion
!     while (/\@anchor\s*\{(.*?)\}/)
!     {
!       $_ = $`.$';
!       my $anchor = $1;
!       $anchor = &normalise_node($anchor);
!       push @lines, &html_debug("<A NAME=\"$anchor\"></A>\n");
!       $node2href{$anchor} = "$docu_doc#$anchor";
!       next INPUT_LINE if $_ =~ /^\s*$/;
!     }
! 
!     #############################################################
!     # index entry generation, after value substitutions
!     if (/^\@(\w+?)index\s+/)
!     {
!       EnterIndexEntry($1, $', $docu_doc, $section, \@lines);
!       next;
!     }
      #
      # protect texi and HTML things
***************
*** 827,831 ****
      $dont_html = 0;
      # substitution (unsupported things)
-     s/^\@center\s+//g;
      s/^\@exdent\s+//g;
      s/\@noindent\s+//g;
--- 3549,3552 ----
***************
*** 833,837 ****
      # other substitutions
      &simple_substitutions;
-     s/\@value{($VARRE)}/$value{$1}/eg;
      s/\@footnote\{/\@footnote$docu_doc\{/g; # mark footnotes, cf. pass 4
      #
--- 3554,3557 ----
***************
*** 839,916 ****
      #
      if ($tag) {
! 	if (defined($sec2level{$tag}) && $sec2level{$tag} > 0) {
  	    if (/^\@$tag\s+(.+)$/) {
  		$name = $1;
! 		$name =~ s/\s+$//;
  		$level = $sec2level{$tag};
! 		$name = &update_sec_num($tag, $level) . "  $name"
! 		    if $number_sections && $tag !~ /^unnumbered/;
! 		if ($tag =~ /heading$/) {
! 		    push(@lines, &html_debug("\n", __LINE__));
! 		    if ($html_element ne 'body') {
! 			# We are in a nice pickle here. We are trying to get a H? heading
! 			# even though we are not in the body level. So, we convert it to a
! 			# nice, bold, line by itself.
! 			$_ = &debug("\n\n<P><STRONG>$name</STRONG></P>\n\n", __LINE__);
! 		    } else {
! 			$_ = &debug("<H$level>$name</H$level>\n", __LINE__);
! 			&html_push_if('body');
  		    }
! 		    print "# heading, section $name, level $level\n"
! 			if $debug & $DEBUG_TOC;
! 		} else {
! 		    if ($split_chapter) {
! 			unless ($toplevel) {
! 			    # first time we see a "section"
! 			    unless ($level == 1) {
! 				warn "$ERROR The first section found is not of level 1: $_";
! 				warn "$ERROR I'll split on sections of level $level...\n";
! 			    }
! 			    $toplevel = $level;
! 			}
! 			if ($level == $toplevel) {
! 			    &next_doc;
! 			    push(@lines, $SPLITTAG) if $split_num++;
! 			    push(@sections, $name);
! 			}
  		    }
! 		    $sec_num++;
! 		    $docid = "SEC$sec_num";
! 		    $tocid = "TOC$sec_num";
! 		    # check biblio and glossary
! 		    $in_bibliography = ($name =~ /^([A-Z]|\d+)?(\.\d+)*\s*bibliography$/i);
! 		    $in_glossary = ($name =~ /^([A-Z]|\d+)?(\.\d+)*\s*glossary$/i);
! 		    # check node
! 		    if ($node) {
! 			if ($node2sec{$node}) {
! 			    warn "$ERROR Duplicate node found: $node\n";
! 			} else {
! 			    $node2sec{$node} = $name;
! 			    $node2href{$node} = "$docu_doc#$docid";
! 			    print "# node $node, section $name, level $level\n"
! 				if $debug & $DEBUG_TOC;
! 			}
! 			$node = '';
! 		    } else {
! 			print "# no node, section $name, level $level\n"
! 			    if $debug & $DEBUG_TOC;
  		    }
  		    # update TOC
  		    while ($level > $curlevel) {
! 			$curlevel++;
! 			push(@toc_lines, "<UL>\n");
  		    }
  		    while ($level < $curlevel) {
! 			$curlevel--;
! 			push(@toc_lines, "</UL>\n");
  		    }
! 		    $_ = "<LI>" . &anchor($tocid, "$docu_doc#$docid", $name, 1);
! 		    push(@toc_lines, &substitute_style($_));
! 		    # update DOC
! 		    push(@lines, &html_debug("\n", __LINE__));
! 		    &html_reset;
! 		    $_ =  "<H$level>".&anchor($docid, "$docu_toc#$tocid", $name)."</H$level>\n";
! 		    $_ = &debug($_, __LINE__);
! 		    push(@lines, &html_debug("\n", __LINE__));
  		}
  		# update DOC
--- 3559,3672 ----
      #
      if ($tag) {
!       if (defined($sec2level{$tag}) && $sec2level{$tag} > 0) {
  	    if (/^\@$tag\s+(.+)$/) {
  		$name = $1;
! 		$name = &normalise_node($name);
  		$level = $sec2level{$tag};
! 		# check for index
! 		$first_index_chapter = $name
! 		  if ($level == 1 && !$first_index_chapter && 
! 		      $name =~ /index/i);
! 		if ($in_top && /heading/){
! 		    $T2H_HAS_TOP_HEADING = 1;
!                     $_ = &debug("<H$level>$name</H$level>\n", __LINE__);
! 		    &html_push_if('body');
! 		    print "# top heading, section $name, level $level\n"
! 			if $T2H_DEBUG & $DEBUG_TOC;
! 		}
! 		else
! 		{
! 		  unless (/^\@\w*heading/)
! 		  {
! 		    unless (/^\@unnumbered/)
! 		    {
! 		      my $number = &update_sec_num($tag, $level);
! 		      $name = $number. ' ' . $name if $T2H_NUMBER_SECTIONS;
! 		      $sec2number{$name} = $number;
! 		      $number2sec{$number} = $name;
  		    }
! 		    if (defined($toplevel))
! 		    {
! 		      push @lines, ($level==$toplevel ? $CHAPTEREND : $SECTIONEND);
  		    }
! 		    else
! 		    {
! 		      # first time we see a "section"
! 		      unless ($level == 1) 
! 		      {
! 			warn "$WARN The first section found is not of level 1: $_";
! 		      }
! 		      $toplevel = $level;
  		    }
+ 		    push(@sections, $name);
+ 		    next_doc() if ($T2H_SPLIT eq 'section' ||
+ 				   $T2H_SPLIT && $level == $toplevel);
+ 		  }
+ 		  $sec_num++;
+ 		  $docid = "SEC$sec_num";
+ 		  $tocid = (/^\@\w*heading/ ? undef : "TOC$sec_num");
+ 		  # check biblio and glossary
+ 		  $in_bibliography = ($name =~ /^([A-Z]|\d+)?(\.\d+)*\s*bibliography$/i);
+ 		  $in_glossary = ($name =~ /^([A-Z]|\d+)?(\.\d+)*\s*glossary$/i);
+ 		  # check node
+ 		  if ($node)
+ 		  {
+ 		    warn "$ERROR Duplicate node found: $node\n"
+ 		      if ($node2sec{$node});
+ 		  }
+ 		  else
+ 		  {
+ 		    $name .= ' ' while ($node2sec{$name});
+ 		    $node = $name;
+ 		  }
+ 		  $name .= ' ' while ($sec2node{$name});
+ 		  $section = $name; 
+ 		  $node2sec{$node} = $name;
+ 		  $sec2node{$name} = $node;
+ 		  $node2href{$node} = "$docu_doc#$docid";
+ 		  $node2next{$node} = $node_next;
+ 		  $node2prev{$node} = $node_prev;
+ 		  $node2up{$node} = $node_up;
+ 		  print "# node $node, section $name, level $level\n"
+ 		    if $T2H_DEBUG & $DEBUG_TOC;
+ 
+ 		  $node = '';
+ 		  $node_next = '';
+ 		  $node_prev = '';
+ 		  $node_next = '';
+ 		  if ($tocid)
+ 		  {
  		    # update TOC
  		    while ($level > $curlevel) {
! 		      $curlevel++;
! 		      push(@toc_lines, "<UL>\n");
  		    }
  		    while ($level < $curlevel) {
! 		      $curlevel--;
! 		      push(@toc_lines, "</UL>\n");
! 		    }
! 		    $_ = &t2h_anchor($tocid, "$docu_doc#$docid", $name, 1);
! 		    $_ = &substitute_style($_);
! 		    push(@stoc_lines, "$_<BR>\n") if ($level == 1);
! 		    if ($T2H_NUMBER_SECTIONS)
! 		    {
! 		      push(@toc_lines, $_ . "<BR>\n")
  		    }
! 		    else
! 		    {
! 		      push(@toc_lines, "<LI>" . $_ ."</LI>");
! 		    }
! 		  }
! 		  else
! 		  {
! 		    push(@lines, &html_debug("<A NAME=\"$docid\"></A>\n", 
! 					   __LINE__));
! 		  }
! 		  # update DOC
! 		  push(@lines, &html_debug('', __LINE__));
! 		  &html_reset;
! 		  $_ =  "<H$level> $name </H$level>\n<!--docid::${docid}::-->\n";
! 		  $_ = &debug($_, __LINE__);
! 		  push(@lines, &html_debug('', __LINE__));
  		}
  		# update DOC
***************
*** 924,980 ****
  	} else {
  	    # track variables
! 	    $value{$1} = $2, next if /^\@set\s+($VARRE)\s+(.*)$/o;
  	    delete $value{$1}, next if /^\@clear\s+($VARRE)\s*$/o;
  	    # store things
! 	    $value{'_setfilename'}   = $1, next if /^\@setfilename\s+(.*)$/;
! 	    $value{'_settitle'}      = $1, next if /^\@settitle\s+(.*)$/;
! 	    $value{'_author'}   .= "$1\n", next if /^\@author\s+(.*)$/;
! 	    $value{'_subtitle'} .= "$1\n", next if /^\@subtitle\s+(.*)$/;
! 	    $value{'_title'}    .= "$1\n", next if /^\@title\s+(.*)$/;
! 	    # index
! 	    if (/^\@(..?)index\s+/) {
! 		unless ($valid_index{$1}) {
! 		    warn "$ERROR Undefined index command: $_";
! 		    next;
! 		}
! 		$id = 'IDX' . ++$idx_num;
! 		$index = $1 . 'index';
! 		$what = &substitute_style($');
! 		$what =~ s/\s+$//;
! 		print "# found $index for '$what' id $id\n"
! 		    if $debug & $DEBUG_INDEX;
! 		eval(<<EOC);
! 		if (defined(\$$index\{\$what\})) {
! 		    \$$index\{\$what\} .= "$;$docu_doc#$id";
! 		} else {
! 		    \$$index\{\$what\} = "$docu_doc#$id";
! 		}
! EOC
! 		#
! 		# dirty hack to see if I can put an invisible anchor...
! 		#
! 		if ($html_element eq 'P' ||
! 		    $html_element eq 'LI' ||
! 		    $html_element eq 'DT' ||
! 		    $html_element eq 'DD' ||
! 		    $html_element eq 'ADDRESS' ||
! 		    $html_element eq 'B' ||
! 		    $html_element eq 'BLOCKQUOTE' ||
! 		    $html_element eq 'PRE' ||
! 		    $html_element eq 'SAMP') {
!                     push(@lines, &anchor($id, '', $invisible_mark, !$in_pre));
!                 } elsif ($html_element eq 'body') {
! 		    push(@lines, &debug("<P>\n", __LINE__));
!                     push(@lines, &anchor($id, '', $invisible_mark, !$in_pre));
! 		    &html_push('P');
! 		} elsif ($html_element eq 'DL' ||
! 			 $html_element eq 'UL' ||
! 			 $html_element eq 'OL' ) {
! 		    $deferred_ref .= &anchor($id, '', $invisible_mark, !$in_pre) . " ";
! 		}
! 		next;
! 	    }
  	    # list item
! 	    if (/^\@itemx?\s+/) {
  		$what = $';
  		$what =~ s/\s+$//;
--- 3680,3695 ----
  	} else {
  	    # track variables
! 	    $value{$1} = Unprotect_texi($2), next if /^\@set\s+($VARRE)\s+(.*)$/o;
  	    delete $value{$1}, next if /^\@clear\s+($VARRE)\s*$/o;
  	    # store things
! 	    $value{'_shorttitle'} = Unprotect_texi($1), next if /^\@shorttitle\s+(.*)$/;
! 	    $value{'_setfilename'}   = Unprotect_texi($1), next if /^\@setfilename\s+(.*)$/;
! 	    $value{'_settitle'}      = Unprotect_texi($1), next if /^\@settitle\s+(.*)$/;
! 	    $value{'_author'}   .= Unprotect_texi($1)."\n", next if /^\@author\s+(.*)$/;
! 	    $value{'_subtitle'} .= Unprotect_texi($1)."\n", next if /^\@subtitle\s+(.*)$/;
! 	    $value{'_title'}    .= Unprotect_texi($1)."\n", next if /^\@title\s+(.*)$/;
! 
  	    # list item
! 	    if (/^\s*\@itemx?\s+/) {
  		$what = $';
  		$what =~ s/\s+$//;
***************
*** 984,991 ****
  			$bib2href{$what} = "$docu_doc#$id";
  			print "# found bibliography for '$what' id $id\n"
! 			    if $debug & $DEBUG_BIB;
! 			$what = &anchor($id, '', $what);
  		    }
! 		} elsif ($in_glossary && $use_glossary) {
  		    $id = 'GLOSS' . ++$gloss_num;
  		    $entry = $what;
--- 3699,3706 ----
  			$bib2href{$what} = "$docu_doc#$id";
  			print "# found bibliography for '$what' id $id\n"
! 			    if $T2H_DEBUG & $DEBUG_BIB;
! 			$what = &t2h_anchor($id, '', $what);
  		    }
! 		} elsif ($in_glossary && $T2H_USE_GLOSSARY) {
  		    $id = 'GLOSS' . ++$gloss_num;
  		    $entry = $what;
***************
*** 993,998 ****
  		    $gloss2href{$entry} = "$docu_doc#$id";
  		    print "# found glossary for '$entry' id $id\n"
! 			if $debug & $DEBUG_GLOSS;
! 		    $what = &anchor($id, '', $what);
  		}
  		&html_pop_if('P');
--- 3708,3717 ----
  		    $gloss2href{$entry} = "$docu_doc#$id";
  		    print "# found glossary for '$entry' id $id\n"
! 			if $T2H_DEBUG & $DEBUG_GLOSS;
! 		    $what = &t2h_anchor($id, '', $what);
! 		}
! 		elsif ($in_table && ($table_type eq 'f' || $table_type eq 'v'))
! 		{
! 		  EnterIndexEntry($table_type, $what, $docu_doc, $section, \@lines);
  		}
  		&html_pop_if('P');
***************
*** 1019,1023 ****
  		    &html_push('LI') unless $html_element eq 'LI';
  		}
! 		push(@lines, &html_debug("\n", __LINE__));
  		if ($deferred_ref) {
  		    push(@lines, &debug("$deferred_ref\n", __LINE__));
--- 3738,3742 ----
  		    &html_push('LI') unless $html_element eq 'LI';
  		}
! 		push(@lines, &html_debug('', __LINE__));
  		if ($deferred_ref) {
  		    push(@lines, &debug("$deferred_ref\n", __LINE__));
***************
*** 1032,1049 ****
      }
      # paragraph separator
!     if ($_ eq "\n") {
  	next if $#lines >= 0 && $lines[$#lines] eq "\n";
  	if ($html_element eq 'P') {
! 	    push(@lines, "\n");
! 	    $_ = &debug("</P>\n", __LINE__);
! 	    &html_pop;
! 	}
!     } elsif ($html_element eq 'body' || $html_element eq 'BLOCKQUOTE') {
! 	push(@lines, "<P>\n");
! 	&html_push('P');
! 	$_ = &debug($_, __LINE__);
!     }
      # otherwise
!     push(@lines, $_);
  }
  
--- 3751,3773 ----
      }
      # paragraph separator
!     if ($_ eq "\n" && ! $in_pre) {
  	next if $#lines >= 0 && $lines[$#lines] eq "\n";
  	if ($html_element eq 'P') {
! 	    push (@lines, &debug("</P><P>\n", __LINE__));
! 	}
! # 	else
! # 	{
! # 	  push(@lines, "<P></P>\n");
! # 	  $_ = &debug("<P></P>\n", __LINE__);
! # 	}
!         elsif ($html_element eq 'body' || $html_element eq 'BLOCKQUOTE' || $html_element eq 'DD' || $html_element eq 'LI') 
! 	{
! 	  &html_push('P');
! 	  push(@lines, &debug("<P>\n", __LINE__));
! 	}
!       }
      # otherwise
!     push(@lines, $_) unless $in_titlepage;
!     push(@lines, &debug("</center>\n", __LINE__))  if ($tag eq 'center');
  }
  
***************
*** 1055,1059 ****
  }
  
! print "# end of pass 1\n" if $verbose;
  
  #+++############################################################################
--- 3779,4103 ----
  }
  
! print "# end of pass 1\n" if $T2H_VERBOSE;
! 
! SetDocumentLanguage('en') unless ($T2H_LANG);
! #+++############################################################################
! #                                                                              #
! # Stuff related to Index generation                                            #
! #                                                                              #
! #---############################################################################
! 
! sub EnterIndexEntry
! {
!   my $prefix = shift;
!   my $key = shift;
!   my $docu_doc = shift;
!   my $section = shift;
!   my $lines = shift;
!   local $_;
! 
!   warn "$ERROR Undefined index command: $_", next
!     unless (exists ($index_properties->{$prefix}));
!   $key =~ s/\s+$//;
!   $_ = $key;
!   &protect_texi;
!   $key = $_;
!   $_ = &protect_html($_);
!   my $html_key = substitute_style($_);
!   my $id;
!   $key = remove_style($key);
!   $key = remove_things($key);
!   $_ = $key;
!   &unprotect_texi;
!   $key = $_;
!   while (exists $index->{$prefix}->{$key}) {$key .= ' '};
!   if ($lines->[$#lines] =~ /^<!--docid::(.+)::-->$/)
!   {
!     $id = $1;
!   }
!   else
!   {
!     $id = 'IDX' . ++$idx_num;
!     push(@$lines, &t2h_anchor($id, '', $T2H_INVISIBLE_MARK, !$in_pre));
!   }
!   $index->{$prefix}->{$key}->{html_key} = $html_key;
!   $index->{$prefix}->{$key}->{section} = $section;
!   $index->{$prefix}->{$key}->{href} = "$docu_doc#$id";
!   print "# found ${prefix}index  for '$key' with id $id\n"
!     if $T2H_DEBUG & $DEBUG_INDEX;
! }
! 
! sub IndexName2Prefix
! {
!   my $name = shift;
!   my $prefix;
! 
!   for $prefix (keys %$index_properties)
!   {
!     return $prefix if ($index_properties->{$prefix}->{name} eq $name);
!   }
!   return undef;
! }
! 
! sub GetIndexEntries
! {
!   my $normal = shift;
!   my $code = shift;
!   my ($entries, $prefix, $key) = ({});
!   
!   for $prefix (keys %$normal)
!   {
!     for $key (keys %{$index->{$prefix}})
!     {
!       $entries->{$key} = {%{$index->{$prefix}->{$key}}};
!     }
!   }
! 
!   if (defined($code))
!   {
!     for $prefix (keys %$code)
!     {
!       unless (exists $normal->{$keys})
!       {
! 	for $key (keys %{$index->{$prefix}})
! 	{
! 	  $entries->{$key} = {%{$index->{$prefix}->{$key}}};
! 	  $entries->{$key}->{html_key} = "<CODE>$entries->{$key}->{html_key}</CODE>";
! 	}
!       }
!     }
!   }
!   return $entries;
! }
! 
! sub byAlpha
! {
!   if ($a =~ /^[A-Za-z]/)
!   {
!     if ($b =~ /^[A-Za-z]/)
!     {
!       return lc($a) cmp lc($b);
!     }
!     else
!     {
!       return 1;
!     }
!   }
!   elsif ($b =~ /^[A-Za-z]/)
!   {
!     return -1;
!   }
!   else
!   {
!     return lc($a) cmp lc($b);
!   } 
! }
! 
! sub GetIndexPages
! {
!   my $entries = shift;
!   my (@Letters, $key);
!   my ($EntriesByLetter, $Pages, $page) = ({}, [], {});
!   my @keys = sort byAlpha keys %$entries;
! 
!   for $key (@keys)
!   {
!     push @{$EntriesByLetter->{uc(substr($key,0, 1))}} , $entries->{$key};
!   }
!   @Letters = sort byAlpha keys %$EntriesByLetter;
!   
!   $T2H_SPLIT_INDEX = 0 unless ($T2H_SPLIT);
! 
!   unless ($T2H_SPLIT_INDEX)
!   {
!     $page->{First} = $Letters[0];
!     $page->{Last} = $Letters[$#Letters];
!     $page->{Letters} = \@Letters;
!     $page->{EntriesByLetter} = $EntriesByLetter;
!     push @$Pages, $page;
!     return $Pages;
!   }
! 
!   if ($T2H_SPLIT_INDEX =~ /^\d+$/)
!   {
!     my $i = 0;
!     my ($prev_letter, $letter);
!     $page->{First} = $Letters[0];
!     for $letter (@Letters)
!     {
!       if ($i > $T2H_SPLIT_INDEX)
!       {
! 	$page->{Last} = $prev_letter;
! 	push @$Pages, {%$page};
! 	$page->{Letters} = [];
! 	$page->{EntriesByLetter} = {};
! 	$page->{First} = $letter;
! 	$i=0;
!       }
!       push @{$page->{Letters}}, $letter;
!       $page->{EntriesByLetter}->{$letter} = [@{$EntriesByLetter->{$letter}}];
!       $i += scalar(@{$EntriesByLetter->{$letter}});
!       $prev_letter = $letter;
!     }
!     $page->{Last} = $Letters[$#Letters];
!     push @$Pages, {%$page};
!   }
!   return $Pages;
! }
! 
! sub GetIndexSummary
! {
!   my $first_page = shift;
!   my $Pages = shift;
!   my $name = shift;
!   my ($page, $letter, $summary, $i, $l1, $l2, $l);
! 
!   $i = 0;
!   $summary = '<table><tr><th valign=top>Jump to: &nbsp; </th><td>';
!   
!   for $page ($first_page, @$Pages)
!   {
!     for $letter (@{$page->{Letters}})
!     {
!       $l = t2h_anchor('', "$page->{href}#${name}_$letter", "<b>$letter</b>", 
! 		      0, 'style="text-decoration:none"') . "\n &nbsp; \n";
!       
!       if ($letter =~ /^[A-Za-z]/)
!       {
! 	$l2 .= $l;
!       }
!       else
!       {
! 	$l1 .= $l;
!       }
!     }
!   }
!   $summary .= $l1 . "<BR>\n" if ($l1);
!   $summary .= $l2 . '</td></tr></table><br>';
!   return $summary;
! }
! 
! sub PrintIndexPage
! {
!   my $lines = shift;
!   my $summary = shift;
!   my $page = shift;
!   my $name = shift;
! 
!   push @$lines, $summary;
! 
!   push @$lines , <<EOT;
! <P></P>
! <TABLE border=0>
! <TR><TD></TD><TH ALIGN=LEFT>Index Entry</TH><TH ALIGN=LEFT> Section</TH></TR>
! <TR><TD COLSPAN=3> <HR></TD></TR>
! EOT
! 
!   for $letter (@{$page->{Letters}})
!   {
!     push @$lines, "<TR><TH><A NAME=\"${name}_$letter\"></A>$letter</TH><TD></TD><TD></TD></TR>\n";
!     for $entry (@{$page->{EntriesByLetter}->{$letter}})
!     {
!       push @$lines, 
!       "<TR><TD></TD><TD valign=top>" . 
! 	t2h_anchor('', $entry->{href}, $entry->{html_key}) .
! 	  "</TD><TD valign=top>" . 
! 	    t2h_anchor('', sec_href($entry->{section}), clean_name($entry->{section})) .
! 	      "</TD></TR>\n";
!     }
!     push @$lines, "<TR><TD COLSPAN=3> <HR></TD></TR>\n";
!   }
!   push @$lines, "</TABLE><P></P>";
!   push @$lines, $summary;
! }
! 
! sub PrintIndex
! {
!   my $lines = shift;
!   my $name = shift;
!   my $section = shift;
!   $section = 'Top' unless $section;
!   my $prefix = IndexName2Prefix($name);
! 
!   warn ("$ERROR printindex: bad index name: $name"), return 
!     unless $prefix;
! 
!   if ($index_properties->{$prefix}->{code})
!   {
!     $index_properties->{$prefix}->{from_code}->{$prefix} = 1;
!   }
!   else
!   {
!     $index_properties->{$prefix}->{from}->{$prefix}= 1;
!   }
! 
!   my $Entries = GetIndexEntries($index_properties->{$prefix}->{from}, 
! 				$index_properties->{$prefix}->{from_code});
!   return unless %$Entries;
! 
!   if ($T2H_IDX_SUMMARY)
!   {
!     my $key;
!     open(FHIDX, ">$docu_rdir$docu_name" . "_$name.idx")
!       || die "Can't open > $docu_rdir$docu_name" . "_$name.idx for writing: $!\n";
!     print "# writing $name index summary in $docu_rdir$docu_name" . "_$name.idx...\n" if $T2H_VERBOSE;
! 
!     for $key (sort keys %$Entries)
!     {
!       print FHIDX "$key\t$Entries->{$key}->{href}\n";
!     }
!   }
! 
!   my $Pages = GetIndexPages($Entries);
!   my $page;
!   my $first_page = shift @$Pages;
!   my $sec_name = $section;
!   # remove section number
!   $sec_name =~ s/.*? // if $sec_name =~ /^([A-Z]|\d+)\./;
! 
!   ($first_page->{href} = sec_href($section)) =~ s/\#.*$//;
!   # Update tree structure of document
!   if (@$Pages)
!   {
!     my $sec;
!     my @after;
! 
!     while (@sections && $sections[$#sections] ne $section)
!     {
!       unshift @after, pop @sections;
!     }
! 
!     for $page (@$Pages)
!     {
!       my $node = ($page->{First} ne $page->{Last} ? 
! 		  "$sec_name: $page->{First} -- $page->{Last}" :
! 		  "$sec_name: $page->{First}");
!       push @sections, $node;
!       $node2sec{$node} = $node;
!       $sec2node{$node} = $node;
!       $node2up{$node} = $section;
!       $page->{href} = next_doc();
!       $page->{name} = $node;
!       $node2href{$node} = $page->{href};
!       if ($prev_node)
!       {
! 	$node2next{$prev_node} = $node;
! 	$node2prev{$node} = $prev_node;
!       }
!       $prev_node = $node;
!     }
!     push @sections, @after;
!   }
! 
!   my $summary = GetIndexSummary($first_page, $Pages, $name);
!   PrintIndexPage($lines, $summary, $first_page, $name);
!   for $page (@$Pages)
!   {
!     push @$lines, ($T2H_SPLIT eq 'chapter' ? $CHAPTEREND : $SECTIONEND);
!     push @$lines, "<H2 ALIGN=\"Left\">$page->{name}</H2>\n";
!     PrintIndexPage($lines, $summary, $page, $name);
!   }
! }
! 
  
  #+++############################################################################
***************
*** 1079,1154 ****
      # menu
      #
!     $in_menu = 1, push(@lines2, &debug("<UL>\n", __LINE__)), next if /^\@menu\b/;
!     $in_menu = 0, push(@lines2, &debug("</UL>\n", __LINE__)), next if /^\@end\s+menu\b/;
!     if ($in_menu) {
! 	if (/^\*\s+($NODERE)::/o) {
! 	    $descr = $';
! 	    chop($descr);
! 	    &menu_entry($1, $1, $descr);
! 	} elsif (/^\*\s+(.+):\s+([^\t,\.\n]+)[\t,\.\n]/) {
! 	    $descr = $';
! 	    chop($descr);
! 	    &menu_entry($1, $2, $descr);
! 	} elsif (/^\*/) {
! 	    warn "$ERROR Bad menu line: $_";
! 	} else { # description continued?
! 	    push(@lines2, $_);
! 	}
! 	next;
      }
      #
      # printindex
      #
!     if (/^\@printindex\s+(\w\w)\b/) {
! 	local($index, *ary, @keys, $key, $letter, $last_letter, @refs);
! 	if ($predefined_index{$1}) {
! 	    $index = $predefined_index{$1} . 'index';
! 	} else {
! 	    $index = $1 . 'index';
! 	}
! 	eval("*ary = *$index");
! 	@keys = keys(%ary);
! 	foreach $key (@keys) {
! 	    $_ = $key;
! 	    1 while s/<(\w+)>\`(.*)\'<\/\1>/$2/; # remove HTML tags with quotes
! 	    1 while s/<(\w+)>(.*)<\/\1>/$2/;     # remove HTML tags
! 	    $_ = &unprotect_html($_);
! 	    &unprotect_texi;
! 	    tr/A-Z/a-z/; # lowercase
! 	    $key2alpha{$key} = $_;
! 	    print "# index $key sorted as $_\n"
! 		if $key ne $_ && $debug & $DEBUG_INDEX;
! 	}
! 	push(@lines2, "Jump to:\n");
! 	$last_letter = undef;
! 	foreach $key (sort byalpha @keys) {
! 	    $letter = substr($key2alpha{$key}, 0, 1);
! 	    $letter = substr($key2alpha{$key}, 0, 2) if $letter eq $;;
! 	    if (!defined($last_letter) || $letter ne $last_letter) {
! 		push(@lines2, "-\n") if defined($last_letter);
! 		push(@lines2, "<A HREF=\"#$index\_$letter\">" . &protect_html($letter) . "</A>\n");
! 		$last_letter = $letter;
! 	    }
! 	}
! 	push(@lines2, "<P>\n");
! 	$last_letter = undef;
! 	foreach $key (sort byalpha @keys) {
! 	    $letter = substr($key2alpha{$key}, 0, 1);
! 	    $letter = substr($key2alpha{$key}, 0, 2) if $letter eq $;;
! 	    if (!defined($last_letter) || $letter ne $last_letter) {
! 		push(@lines2, "</DIR>\n") if defined($last_letter);
! 		push(@lines2, "<H2><A NAME=\"$index\_$letter\">" . &protect_html($letter) . "</A></H2>\n");
! 		push(@lines2, "<DIR>\n");
! 		$last_letter = $letter;
! 	    }
! 	    @refs = ();
! 	    foreach (split(/$;/, $ary{$key})) {
! 		push(@refs, &anchor('', $_, $key, 0));
! 	    }
! 	    push(@lines2, "<LI>" . join(", ", @refs) . "\n");
! 	}
! 	push(@lines2, "</DIR>\n") if defined($last_letter);
! 	next;
!     }
      #
      # simple style substitutions
--- 4123,4198 ----
      # menu
      #
!     if (/^\@menu\b/)
!     {
!       $in_menu = 1;
!       $in_menu_listing = 1;
!       push(@lines2, &debug("<BLOCKQUOTE><TABLE BORDER=0 CELLSPACING=0> \n", __LINE__));
!       next;
!     }
!     if (/^\@end\s+menu\b/)
!     {
!       if ($in_menu_listing)
!       {
! 	push(@lines2, &debug("</TABLE></BLOCKQUOTE>\n", __LINE__));
!       }
!       else
!       {
! 	push(@lines2, &debug("</BLOCKQUOTE>\n", __LINE__));
!       }
!       $in_menu = 0;
!       $in_menu_listing = 0;
!       next;
!     }
!     if ($in_menu) 
!     {
!       my ($node, $name, $descr);
!       if (/^\*\s+($NODERE)::/o)
!       {
! 	$node = $1;
! 	$descr = $';
!       }
!       elsif (/^\*\s+(.+):\s+([^\t,\.\n]+)[\t,\.\n]/)
!       {
! 	$name = $1;
! 	$node = $2;
! 	$descr = $';
!       }
!       elsif (/^\*/) 
!       {
! 	warn "$ERROR Bad menu line: $_";
!       }
!       else
!       {
! 	if ($in_menu_listing)
! 	{
! 	  $in_menu_listing = 0;
! 	  push(@lines2, &debug("</TABLE>\n", __LINE__));
! 	}
! 	# should be like verbatim -- preseve spaces, etc
! 	s/ /\&nbsp;/g;
! 	$_ .= "<br>\n";
! 	push(@lines2, $_);
!       }
!       if ($node)
!       {
! 	if (! $in_menu_listing)
! 	{
! 	  $in_menu_listing = 1;
! 	  push(@lines2, &debug("<TABLE BORDER=0 CELLSPACING=0>\n", __LINE__));
! 	}
! 	# look for continuation
! 	while ($lines[0] =~ /^\s+\w+/)
! 	{
! 	  $descr .= shift(@lines);
! 	}
! 	&menu_entry($node, $name, $descr);
!       } 
!       next;
      }
      #
      # printindex
      #
!     PrintIndex(\@lines2, $2, $1), next
!       if (/^<!--::(.*)::-->\@printindex\s+(\w+)/);
      #
      # simple style substitutions
***************
*** 1158,1162 ****
      # xref
      #
!     while (/\@(x|px|info|)ref{($XREFRE)(}?)/o) {
  	# note: Texinfo may accept other characters
  	($type, $nodes, $full) = ($1, $2, $3);
--- 4202,4206 ----
      # xref
      #
!     while (/\@(x|px|info|)ref{([^{}]+)(}?)/) {
  	# note: Texinfo may accept other characters
  	($type, $nodes, $full) = ($1, $2, $3);
***************
*** 1168,1176 ****
  	}
  	if ($type eq 'x') {
! 	    $type = 'See ';
  	} elsif ($type eq 'px') {
! 	    $type = 'see ';
  	} elsif ($type eq 'info') {
! 	    $type = 'See Info';
  	} else {
  	    $type = '';
--- 4212,4220 ----
  	}
  	if ($type eq 'x') {
! 	    $type = "$T2H_WORDS->{$T2H_LANG}->{'See'} ";
  	} elsif ($type eq 'px') {
! 	    $type = "$T2H_WORDS->{$T2H_LANG}->{'see'} ";
  	} elsif ($type eq 'info') {
! 	    $type = "$T2H_WORDS->{$T2H_LANG}->{'See'} Info";
  	} else {
  	    $type = '';
***************
*** 1202,1223 ****
  	@args = split(/\s*,\s*/, $nodes);
  	$node = $args[0]; # the node is always the first arg
! 	&normalise_node($node);
! 	$sec = $node2sec{$node};
  	if (@args == 5) { # reference to another manual
  	    $sec = $args[2] || $node;
  	    $man = $args[4] || $args[3];
! 	    $_ = "${before}${type}section `$sec' in \@cite{$man}$after";
  	} elsif ($type =~ /Info/) { # inforef
  	    warn "$ERROR Wrong number of arguments: $_" unless @args == 3;
  	    ($nn, $_, $in) = @args;
  	    $_ = "${before}${type} file `$in', node `$nn'$after";
! 	} elsif ($sec) {
! 	    $href = $node2href{$node};
! 	    $_ = "${before}${type}section " . &anchor('', $href, $sec) . $after;
! 	} else {
  	    warn "$ERROR Undefined node ($node): $_";
  	    $_ = "$before$;0xref{$nodes}$after";
  	}
      }
      #
      # try to guess bibliography references or glossary terms
--- 4246,4293 ----
  	@args = split(/\s*,\s*/, $nodes);
  	$node = $args[0]; # the node is always the first arg
! 	$node = &normalise_node($node);
! 	$sec = $args[2] || $args[1] || $node2sec{$node};
! 	$href = $node2href{$node};
  	if (@args == 5) { # reference to another manual
  	    $sec = $args[2] || $node;
  	    $man = $args[4] || $args[3];
! 	    $_ = "${before}${type}$T2H_WORDS->{$T2H_LANG}->{'section'} `$sec' in \@cite{$man}$after";
  	} elsif ($type =~ /Info/) { # inforef
  	    warn "$ERROR Wrong number of arguments: $_" unless @args == 3;
  	    ($nn, $_, $in) = @args;
  	    $_ = "${before}${type} file `$in', node `$nn'$after";
! 	} elsif ($sec && $href && ! $T2H_SHORT_REF) {
! 	    $_  = "${before}${type}";
! 	    $_ .= "$T2H_WORDS->{$T2H_LANG}->{'section'} " if ${type};
! 	    $_ .= &t2h_anchor('', $href, $sec) . $after;
! 	} 
! 	elsif ($href)
! 	{
! 	  $_ = "${before}${type} " . 
! 	    &t2h_anchor('', $href, $args[2] || $args[1] || $node) . 
! 	      $after;
! 	}
! 	else {
  	    warn "$ERROR Undefined node ($node): $_";
  	    $_ = "$before$;0xref{$nodes}$after";
  	}
      }
+ 
+     # replace images
+     s[\@image\s*{(.+?)}]
+     {
+      my @args = split (/\s*,\s*/, $1);
+      my $base = $args[0];
+      my $image = 
+        LocateIncludeFile("$base.png") || 
+        LocateIncludeFile("$base.jpg") ||
+        LocateIncludeFile("$base.gif");
+      warn "$ERROR no image file for $base: $_" unless ($image && -e $image);
+      "<IMG SRC=\"$image\" ALT=\"$base\">";
+      ($T2H_CENTER_IMAGE ?
+       "<CENTER><IMG SRC=\"$image\" ALT=\"$base\"></CENTER>" :
+       "<IMG SRC=\"$image\" ALT=\"$base\">");
+     }eg;
+ 
      #
      # try to guess bibliography references or glossary terms
***************
*** 1230,1234 ****
  		$href = $bib2href{$what};
  		if (defined($href) && $post !~ /^[^<]*<\/A>/) {
! 		    $done .= $pre . &anchor('', $href, $what);
  		} else {
  		    $done .= "$pre$what";
--- 4300,4304 ----
  		$href = $bib2href{$what};
  		if (defined($href) && $post !~ /^[^<]*<\/A>/) {
! 		    $done .= $pre . &t2h_anchor('', $href, $what);
  		} else {
  		    $done .= "$pre$what";
***************
*** 1238,1242 ****
  	    $_ = $done . $_;
  	}
! 	if ($use_glossary) {
  	    $done = '';
  	    while (/\b\w+\b/) {
--- 4308,4312 ----
  	    $_ = $done . $_;
  	}
! 	if ($T2H_USE_GLOSSARY) {
  	    $done = '';
  	    while (/\b\w+\b/) {
***************
*** 1246,1250 ****
  		$href = $gloss2href{$entry};
  		if (defined($href) && $post !~ /^[^<]*<\/A>/) {
! 		    $done .= $pre . &anchor('', $href, $what);
  		} else {
  		    $done .= "$pre$what";
--- 4316,4320 ----
  		$href = $gloss2href{$entry};
  		if (defined($href) && $post !~ /^[^<]*<\/A>/) {
! 		    $done .= $pre . &t2h_anchor('', $href, $what);
  		} else {
  		    $done .= "$pre$what";
***************
*** 1258,1262 ****
      push(@lines2, $_);
  }
! print "# end of pass 2\n" if $verbose;
  
  #
--- 4328,4332 ----
      push(@lines2, $_);
  }
! print "# end of pass 2\n" if $T2H_VERBOSE;
  
  #
***************
*** 1308,1313 ****
      push(@lines3, $_);
  }
! print "# end of pass 3\n" if $verbose;
! 
  #+++############################################################################
  #                                                                              #
--- 4378,4383 ----
      push(@lines3, $_);
  }
! print "# end of pass 3\n" if $T2H_VERBOSE;
! 	
  #+++############################################################################
  #                                                                              #
***************
*** 1319,1323 ****
  @doc_lines = ();			# final document
  $end_of_para = 0;			# true if last line is <P>
! 
  while (@lines3) {
      $_ = shift(@lines3);
--- 4389,4393 ----
  @doc_lines = ();			# final document
  $end_of_para = 0;			# true if last line is <P>
! 	
  while (@lines3) {
      $_ = shift(@lines3);
***************
*** 1357,1364 ****
  	    $footid = "FOOT$foot_num";
  	    $foot = "($foot_num)";
! 	    push(@foot_lines, "<H3>" . &anchor($footid, "$d#$docid", $foot) . "</H3>\n");
  	    $text = "<P>$text" unless $text =~ /^\s*<P>/;
  	    push(@foot_lines, "$text\n");
! 	    $_ = $before . &anchor($docid, "$docu_foot#$footid", $foot) . $after;
  	}
      }
--- 4427,4434 ----
  	    $footid = "FOOT$foot_num";
  	    $foot = "($foot_num)";
! 	    push(@foot_lines, "<H3>" . &t2h_anchor($footid, "$d#$docid", $foot) . "</H3>\n");
  	    $text = "<P>$text" unless $text =~ /^\s*<P>/;
  	    push(@foot_lines, "$text\n");
! 	    $_ = $before . &t2h_anchor($docid, "$docu_foot#$footid", $foot) . $after;
  	}
      }
***************
*** 1374,1378 ****
      push(@doc_lines, $_);
  }
! print "# end of pass 4\n" if $verbose;
  
  #+++############################################################################
--- 4444,4449 ----
      push(@doc_lines, $_);
  }
! 	
! print "# end of pass 4\n" if $T2H_VERBOSE;
  
  #+++############################################################################
***************
*** 1382,1505 ****
  #---############################################################################
  
! $header = <<EOT;
! <!-- This HTML file has been created by $THISPROG
!      from $docu on $TODAY -->
! EOT
! 
! $full_title = $value{'_title'} || $value{'_settitle'} || "Untitled Document";
! $title = $value{'_settitle'} || $full_title;
! $_ = &substitute_style($full_title);
! &unprotect_texi;
! s/\n$//; # rmv last \n (if any)
! $full_title = "<H1>" . join("</H1>\n<H1>", split(/\n/, $_)) . "</H1>\n";
! 
! #
! # print ToC
! #
! if (!$monolithic && @toc_lines) {
!     if (open(FILE, "> $docu_toc")) {
! 	print "# creating $docu_toc...\n" if $verbose;
! 	&print_toplevel_header("$title - Table of Contents");
! 	&print_ruler;
! 	&print(*toc_lines, FILE);
! 	&print_toplevel_footer;
! 	close(FILE);
!     } else {
! 	warn "$ERROR Can't write to $docu_toc: $!\n";
!     }
! }
  
  #
! # print footnotes
! #
! if (!$monolithic && @foot_lines) {
!     if (open(FILE, "> $docu_foot")) {
! 	print "# creating $docu_foot...\n" if $verbose;
! 	&print_toplevel_header("$title - Footnotes");
! 	&print_ruler;
!         &print(*foot_lines, FILE);
! 	&print_toplevel_footer;
! 	close(FILE);
!     } else {
! 	warn "$ERROR Can't write to $docu_foot: $!\n";
!     }
  }
  
  #
! # print document
  #
! if ($split_chapter || $split_node) { # split
!     $doc_num = 0;
!     $last_num = scalar(@sections);
!     $first_doc = &doc_name(1);
!     $last_doc = &doc_name($last_num);
!     while (@sections) {
! 	$section = shift(@sections);
! 	&next_doc;
! 	if (open(FILE, "> $docu_doc")) {
! 	    print "# creating $docu_doc...\n" if $verbose;
! 	    &print_header("$title - $section");
! 	    $prev_doc = ($doc_num == 1 ? undef : &doc_name($doc_num - 1));
! 	    $next_doc = ($doc_num == $last_num ? undef : &doc_name($doc_num + 1));
! 	    $navigation = "Go to the ";
! 	    $navigation .= ($prev_doc ? &anchor('', $first_doc, "first") : "first");
! 	    $navigation .= ", ";
! 	    $navigation .= ($prev_doc ? &anchor('', $prev_doc, "previous") : "previous");
! 	    $navigation .= ", ";
! 	    $navigation .= ($next_doc ? &anchor('', $next_doc, "next") : "next");
! 	    $navigation .= ", ";
! 	    $navigation .= ($next_doc ? &anchor('', $last_doc, "last") : "last");
! 	    $navigation .= " section, " . &anchor('', $docu_toc, "table of contents") . ".\n";
! 	    print FILE $navigation;
! 	    &print_ruler;
! 	    # find corresponding lines
!             @tmp_lines = ();
!             while (@doc_lines) {
! 		$_ = shift(@doc_lines);
! 		last if ($_ eq $SPLITTAG);
! 		push(@tmp_lines, $_);
! 	    }
!             &print(*tmp_lines, FILE);
! 	    &print_ruler;
! 	    print FILE $navigation;
! 	    &print_footer;
! 	    close(FILE);
! 	} else {
! 	    warn "$ERROR Can't write to $docu_doc: $!\n";
! 	}
!     }
! } else { # not split
!     if (open(FILE, "> $docu_doc")) {
! 	print "# creating $docu_doc...\n" if $verbose;
! 	if ($monolithic || !@toc_lines) {
! 	    &print_toplevel_header($title);
! 	} else {
! 	    &print_header($title);
! 	    print FILE $full_title;
! 	}
! 	if ($monolithic && @toc_lines) {
! 	    &print_ruler;
!  	    print FILE "<H1>Table of Contents</H1>\n";
!  	    &print(*toc_lines, FILE);
! 	}
! 	&print_ruler;
!         &print(*doc_lines, FILE);
! 	if ($monolithic && @foot_lines) {
! 	    &print_ruler;
!  	    print FILE "<H1>Footnotes</H1>\n";
!  	    &print(*foot_lines, FILE);
! 	}
! 	if ($monolithic || !@toc_lines) {
! 	    &print_toplevel_footer;
! 	} else {
! 	    &print_footer;
! 	}
! 	close(FILE);
!     } else {
! 	warn "$ERROR Can't write to $docu_doc: $!\n";
!     }
  }
  
! print "# that's all folks\n" if $verbose;
  
  #+++############################################################################
--- 4453,4827 ----
  #---############################################################################
  
! $T2H_L2H = &l2h_FinishToLatex if ($T2H_L2H);
! $T2H_L2H = &l2h_ToHtml        if ($T2H_L2H);
! $T2H_L2H = &l2h_InitFromHtml  if ($T2H_L2H);
! 
! # fix node2up, node2prev, node2next, if desired
! if ($has_top_command)
! {
!   for $section (keys %sec2number)
!   {
!     $node = $sec2node{$section};
!     $node2up{$node} = Sec2UpNode($section) unless $node2up{$node};
!     $node2prev{$node} = Sec2PrevNode($section) unless $node2prev{$node};
!     $node2next{$node} = Sec2NextNode($section) unless $node2next{$node};
!   }
! }
! 
! # prepare %T2H_THISDOC
! $T2H_THISDOC{fulltitle} = $value{'_title'} || $value{'_settitle'} || "Untitled Document";
! $T2H_THISDOC{title} = $value{'_settitle'} || $T2H_THISDOC{fulltitle};
! $T2H_THISDOC{author} = $value{'_author'};
! $T2H_THISDOC{subtitle} = $value{'_subtitle'};
! $T2H_THISDOC{shorttitle} = $value{'_shorttitle'};
! for $key (keys %T2H_THISDOC)
! {
!   $_ = &substitute_style($T2H_THISDOC{$key});
!   &unprotect_texi;
!   s/\s*$//;
!   $T2H_THISDOC{$key} = $_;
! }
! 
! # if no sections, then simply print document as is
! unless (@sections)
! {
!   print "# Writing content into $docu_top_file \n" if $T2H_VERBOSE;
!   open(FILE, "> $docu_top_file") 
!     || die "$ERROR: Can't open $docu_top_file for writing: $!\n";
! 
!   &$T2H_print_page_head(\*FILE);
!   $T2H_THIS_SECTION = \@doc_lines;
!   t2h_print_lines(\*FILE);
!   &$T2H_print_foot_navigation(\*FILE);
!   &$T2H_print_page_foot(\*FILE);
!   close(FILE);
!   goto Finish;
! }
! 
! # initialize $T2H_HREF, $T2H_NAME
! %T2H_HREF = 
!   (
!    'First' ,   sec_href($sections[0]),
!    'Last',     sec_href($sections[$#sections]),
!    'About',     $docu_about. '#SEC_About',
!   );
! 
! # prepare TOC, OVERVIEW, TOP
! $T2H_TOC = \@toc_lines;
! $T2H_OVERVIEW = \@stoc_lines;
! if ($has_top)
! {
!   while (1)
!   {
!     $_ = shift @doc_lines;
!     last if /$TOPEND/;
!     push @$T2H_TOP, $_;
!   }
!   $T2H_HREF{'Top'} = $docu_top . '#SEC_Top';
! }
! else
! {
!   $T2H_HREF{'Top'} = $T2H_HREF{First};
! }
! 
! $node2href{Top} = $T2H_HREF{Top};
! $T2H_HREF{Contents} = $docu_toc.'#SEC_Contents' if @toc_lines;
! $T2H_HREF{Overview} = $docu_stoc.'#SEC_OVERVIEW' if @stoc_lines;
! 
! # settle on index
! if ($T2H_INDEX_CHAPTER)
! {
!   $T2H_HREF{Index} = $node2href{normalise_node($T2H_INDEX_CHAPTER)};
!   warn "$ERROR T2H_INDEX_CHAPTER '$T2H_INDEX_CHAPTER' not found\n"
!     unless $T2H_HREF{Index};
! }
! if (! $T2H_HREF{Index} && $first_index_chapter)
! {
!   $T2H_INDEX_CHAPTER = $first_index_chapter;
!   $T2H_HREF{Index} = $node2href{$T2H_INDEX_CHAPTER};
! }
! 
! print "# Using '" . clean_name($T2H_INDEX_CHAPTER) . "' as index page\n"
!   if ($T2H_VERBOSE && $T2H_HREF{Index});
! 
! %T2H_NAME =
!   (
!    'First',   clean_name($sec2node{$sections[0]}),
!    'Last',    clean_name($sec2node{$sections[$#sections]}),
!    'About',    $T2H_WORDS->{$T2H_LANG}->{'About_Title'},
!    'Contents', $T2H_WORDS->{$T2H_LANG}->{'ToC_Title'},
!    'Overview', $T2H_WORDS->{$T2H_LANG}->{'Overview_Title'},
!    'Index' ,   clean_name($T2H_INDEX_CHAPTER),
!    'Top',      clean_name($T2H_TOP_HEADING || $T2H_THISDOC{'title'} || $T2H_THISDOC{'shorttitle'}),
!   );
  
+ #############################################################################
+ # print frame and frame toc file
  #
! if ( $T2H_FRAMES )
! {
!   open(FILE, "> $docu_frame_file") 
!     || die "$ERROR: Can't open $docu_frame_file for writing: $!\n";
!   print "# Creating frame in $docu_frame_file ...\n" if $T2H_VERBOSE;
!   &$T2H_print_frame(\*FILE);
!   close(FILE);
! 
!   open(FILE, "> $docu_toc_frame_file") 
!     || die "$ERROR: Can't open $docu_toc_frame_file for writing: $!\n";
!   print "# Creating toc frame in $docu_frame_file ...\n" if $T2H_VERBOSE;
!    &$T2H_print_toc_frame(\*FILE);
!   close(FILE);
  }
  
+ 
+ #############################################################################
+ # print Top
  #
! open(FILE, "> $docu_top_file") 
!   || die "$ERROR: Can't open $docu_top_file for writing: $!\n";
! &$T2H_print_page_head(\*FILE) unless ($T2H_SPLIT);
! 
! if ($has_top)
! {
!   print "# Creating Top in $docu_top_file ...\n" if $T2H_VERBOSE;
!   $T2H_THIS_SECTION = $T2H_TOP;
!   $T2H_HREF{This} = $T2H_HREF{Top};
!   $T2H_NAME{This} = $T2H_NAME{Top};
!   &$T2H_print_Top(\*FILE);
! }
!   
! close(FILE) if $T2H_SPLIT;
! 
! #############################################################################
! # Print sections
  #
! $T2H_NODE{Forward} = $sec2node{$sections[0]};
! $T2H_NAME{Forward} = &clean_name($sec2node{$sections[0]});
! $T2H_HREF{Forward} = sec_href($sections[0]);
! $T2H_NODE{This} = 'Top';
! $T2H_NAME{This} = $T2H_NAME{Top};
! $T2H_HREF{This} = $T2H_HREF{Top};
! if ($T2H_SPLIT)
! {
!   print "# writing " . scalar(@sections) . 
!     " sections in $docu_rdir$docu_name"."_[1..$doc_num]"
! 	  if $T2H_VERBOSE;
!   $previous = ($T2H_SPLIT eq 'chapter' ? $CHAPTEREND : $SECTIONEND);
!   undef $FH;
!   $doc_num = 0;
! }
! else
! {
!   print "# writing " . scalar(@sections) . " sections in $docu_top_file ..." 
!     if $T2H_VERBOSE;
!   $FH = \*FILE;
!   $previous = '';
! }
! 
! $counter = 0;
! # loop through sections
! while ($section = shift(@sections)) 
! {
!   if ($T2H_SPLIT && ($T2H_SPLIT eq 'section' || $previous eq $CHAPTEREND))
!   { 
!     if ($FH)
!     {
!       #close previous page
!       &$T2H_print_chapter_footer($FH) if $T2H_SPLIT eq 'chapter';
!       &$T2H_print_page_foot($FH);
!       close($FH);
!       undef $FH;
!     }
!   }
!   $T2H_NAME{Back} = $T2H_NAME{This};
!   $T2H_HREF{Back} = $T2H_HREF{This};
!   $T2H_NODE{Back} = $T2H_NODE{This};
!   $T2H_NAME{This} = $T2H_NAME{Forward};
!   $T2H_HREF{This} = $T2H_HREF{Forward};
!   $T2H_NODE{This} = $T2H_NODE{Forward};
!   if ($sections[0])
!   {
!     $T2H_NODE{Forward} = $sec2node{$sections[0]};
!     $T2H_NAME{Forward} = &clean_name($T2H_NODE{Forward});
!     $T2H_HREF{Forward} = sec_href($sections[0]);
!   }
!   else
!   {
!     undef $T2H_HREF{Forward}, $T2H_NODE{Forward}, $T2H_NAME{Forward};
!   }
! 
!   $node = $node2up{$T2H_NODE{This}};
!   $T2H_HREF{Up} = $node2href{$node};
!   if ($T2H_HREF{Up} eq $T2H_HREF{This} || ! $T2H_HREF{Up})
!   {
!     $T2H_NAME{Up} = $T2H_NAME{Top};
!     $T2H_HREF{Up} = $T2H_HREF{Top};
!     $T2H_NODE{Up} = 'Up';
!   }
!   else
!   {
!     $T2H_NAME{Up} = &clean_name($node);
!     $T2H_NODE{Up} = $node;
!   }
! 
!   $node = $T2H_NODE{This};
!   $node = $node2prev{$node};
!   $T2H_NAME{Prev} = &clean_name($node);
!   $T2H_HREF{Prev} = $node2href{$node};
!   $T2H_NODE{Prev} = $node;
! 
!   $node = $T2H_NODE{This};
!   if ($node2up{$node} && $node2up{$node} ne 'Top'&&
!       ($node2prev{$node} eq $T2H_NODE{Back} || ! $node2prev{$node}))
!   {
!     $node = $node2up{$node};
!     while ($node && $node ne $node2up{$node} && ! $node2prev{$node})
!     {
!       $node = $node2up{$node};
!     }
!     $node = $node2prev{$node} 
!       unless $node2up{$node} eq 'Top' || ! $node2up{$node};
!   }
!   else
!   {
!     $node = $node2prev{$node};
!   }
!   $T2H_NAME{FastBack} = &clean_name($node);
!   $T2H_HREF{FastBack} = $node2href{$node};
!   $T2H_NODE{FastBack} = $node;
!   
!   $node = $T2H_NODE{This};
!   $node = $node2next{$node};
!   $T2H_NAME{Next} = &clean_name($node);
!   $T2H_HREF{Next} = $node2href{$node};
!   $T2H_NODE{Next} = $node;
! 
!   $node = $T2H_NODE{This};
!   if ($node2up{$node} && $node2up{$node} ne 'Top'&& 
!       ($node2next{$node} eq $T2H_NODE{Forward} || ! $node2next{$node}))
!   {
!     $node = $node2up{$node};
!     while ($node && $node ne $node2up{$node} && ! $node2next{$node})
!     {
!       $node = $node2up{$node};
!     }
!   }
!   $node = $node2next{$node};
!   $T2H_NAME{FastForward} = &clean_name($node);
!   $T2H_HREF{FastForward} = $node2href{$node};
!   $T2H_NODE{FastForward} = $node;
! 
!   if (! defined($FH))
!   {
!     my $file = $T2H_HREF{This};
!     $file =~ s/\#.*$//;
!     open(FILE, "> $docu_rdir$file") || 
!       die "$ERROR: Can't open $docu_rdir$file for writing: $!\n";
!     $FH = \*FILE;
!     &$T2H_print_page_head($FH);
!     t2h_print_label($FH);
!     &$T2H_print_chapter_header($FH) if $T2H_SPLIT eq 'chapter';
!   }
!   else
!   {
!     t2h_print_label($FH);
!   }
! 
!   $T2H_THIS_SECTION = [];
!   while (@doc_lines) {
!     $_ = shift(@doc_lines);
!     last if ($_ eq $SECTIONEND || $_ eq $CHAPTEREND);
!     push(@$T2H_THIS_SECTION, $_);
!   }
!   $previous = $_;
!   &$T2H_print_section($FH);
! 
!   if ($T2H_VERBOSE)
!   {
!     $counter++;
!     print "." if $counter =~ /00$/;
!   }
! }
! if ($T2H_SPLIT)
! {
!   &$T2H_print_chapter_footer($FH) if $T2H_SPLIT eq 'chapter';
!   &$T2H_print_page_foot($FH);
!   close($FH);
  }
+ print "\n" if $T2H_VERBOSE;
+ 
+ #############################################################################
+ # Print ToC, Overview, Footnotes
+ #
+ undef $T2H_HREF{Prev};
+ undef $T2H_HREF{Next};
+ undef $T2H_HREF{Back};
+ undef $T2H_HREF{Forward};
+ undef $T2H_HREF{Up};
+ 
+ if (@foot_lines)
+ {
+   print "# writing Footnotes in $docu_foot_file...\n" if $T2H_VERBOSE;
+   open (FILE, "> $docu_foot_file") || die "$ERROR: Can't open $docu_foot_file for writing: $!\n"
+       if $T2H_SPLIT;
+   $T2H_HREF{This} = $docu_foot;
+   $T2H_NAME{This} = $T2H_WORDS->{$T2H_LANG}->{'Footnotes_Title'};
+   $T2H_THIS_SECTION = \@foot_lines;
+   &$T2H_print_Footnotes(\*FILE);
+   close(FILE) if $T2H_SPLIT;
+ }
+ 
+ if (@toc_lines)
+ {
+   print "# writing Toc in $docu_toc_file...\n" if $T2H_VERBOSE;
+   open (FILE, "> $docu_toc_file") || die "$ERROR: Can't open $docu_toc_file for writing: $!\n"
+       if $T2H_SPLIT;
+   $T2H_HREF{This} = $T2H_HREF{Contents};
+   $T2H_NAME{This} = $T2H_NAME{Contents};
+   $T2H_THIS_SECTION = \@toc_lines;
+   &$T2H_print_Toc(\*FILE);
+   close(FILE) if $T2H_SPLIT;
+ }
+ 
+ if (@stoc_lines)
+ {
+   print "# writing Overview in $docu_stoc_file...\n" if $T2H_VERBOSE;
+   open (FILE, "> $docu_stoc_file") || die "$ERROR: Can't open $docu_stoc_file for writing: $!\n"
+       if $T2H_SPLIT;
+   
+   $T2H_HREF{This} = $T2H_HREF{Overview};
+   $T2H_NAME{This} = $T2H_NAME{Overview};
+   $T2H_THIS_SECTION = \@stoc_lines;
+   unshift @$T2H_THIS_SECTION, "<BLOCKQUOTE>\n";
+   push @$T2H_THIS_SECTION, "\n</BLOCKQUOTE>\n";
+   &$T2H_print_Overview(\*FILE);
+   close(FILE) if $T2H_SPLIT;
+ }
+ 
+ if ($about_body = &$T2H_about_body())
+ {
+   print "# writing About in $docu_about_file...\n" if $T2H_VERBOSE;
+   open (FILE, "> $docu_about_file") || die "$ERROR: Can't open $docu_about_file for writing: $!\n"
+       if $T2H_SPLIT;
+   
+   $T2H_HREF{This} = $T2H_HREF{About};
+   $T2H_NAME{This} = $T2H_NAME{About};
+   $T2H_THIS_SECTION = [$about_body];
+   &$T2H_print_About(\*FILE);
+   close(FILE) if $T2H_SPLIT;
+ }
+ 
+ unless ($T2H_SPLIT)
+ {
+   &$T2H_print_page_foot(\*FILE);
+   close (FILE);
+ }
+   
+ Finish:
+ &l2h_FinishFromHtml if ($T2H_L2H);
+ &l2h_Finish if($T2H_L2H);
+ print "# that's all folks\n" if $T2H_VERBOSE;
  
! exit(0);
  
  #+++############################################################################
***************
*** 1509,1517 ****
  #---############################################################################
  
  sub update_sec_num {
      local($name, $level) = @_;
  
      $level--; # here we start at 0
!     if ($name =~ /^appendix/) {
  	# appendix style
  	if (defined(@appendix_sec_num)) {
--- 4831,4861 ----
  #---############################################################################
  
+ sub LocateIncludeFile
+ {
+   my $file = shift;
+   my $dir;
+ 
+   return $file if (-e $file && -r $file);
+   foreach $dir (@T2H_INCLUDE_DIRS)
+   {
+     return "$dir/$file" if (-e "$dir/$file" && -r "$dir/$file");
+   }
+   return undef;
+ }
+ 
+ sub clean_name 
+ {
+   local ($_);
+   $_ = &remove_style($_[0]);
+   &unprotect_texi;
+   return $_;
+ }
+ 
  sub update_sec_num {
      local($name, $level) = @_;
+     my $ret;
  
      $level--; # here we start at 0
!     if ($name =~ /^appendix/ || defined(@appendix_sec_num)) {
  	# appendix style
  	if (defined(@appendix_sec_num)) {
***************
*** 1520,1533 ****
  	    @appendix_sec_num = ('A', 0, 0, 0);
  	}
! 	return(join('.', @appendix_sec_num[0..$level]));
      } else {
  	# normal style
! 	if (defined(@normal_sec_num)) {
! 	    &incr_sec_num($level, @normal_sec_num);
! 	} else {
! 	    @normal_sec_num = (1, 0, 0, 0);
  	}
! 	return(join('.', @normal_sec_num[0..$level]));
      }
  }
  
--- 4864,4883 ----
  	    @appendix_sec_num = ('A', 0, 0, 0);
  	}
! 	$ret = join('.', @appendix_sec_num[0..$level]);
      } else {
  	# normal style
! 	if (defined(@normal_sec_num)) 
! 	{
! 	  &incr_sec_num($level, @normal_sec_num);
! 	} 
! 	else 
! 	{
! 	  @normal_sec_num = (1, 0, 0, 0);
  	}
! 	$ret = join('.', @normal_sec_num[0..$level]);
      }
+     
+     $ret .= "." if $level == 0;
+     return $ret;
  }
  
***************
*** 1541,1544 ****
--- 4891,4959 ----
  }
  
+ sub Sec2UpNode
+ {
+   my $sec = shift;
+   my $num = $sec2number{$sec};
+ 
+   return '' unless $num;
+   return 'Top' unless $num =~ /\.\d+/;
+   $num =~ s/\.[^\.]*$//;
+   $num = $num . '.' unless $num =~ /\./;
+   return $sec2node{$number2sec{$num}};
+ }
+ 
+ sub Sec2PrevNode
+ {
+   my $sec = shift;
+   my $num = $sec2number{$sec};
+   my ($i, $post);
+   
+   if ($num =~ /(\w+)(\.$|$)/)
+   {
+     $num = $`;
+     $i = $1;
+     $post = $2;
+     if ($i eq 'A')
+     {
+       $i = $normal_sec_num[0];
+     }
+     elsif ($i ne '1')
+     {
+       # unfortunately, -- operator is not magical
+       $i = chr(ord($i) + 1);
+     }
+     else
+     {
+       return '';
+     }
+     return $sec2node{$number2sec{$num . $i . $post}}
+   }
+   return '';
+ }
+ 
+ sub Sec2NextNode
+ {
+   my $sec = shift;
+   my $num = $sec2number{$sec};
+   my $i;
+ 
+   if ($num =~ /(\w+)(\.$|$)/)
+   {
+     $num = $`;
+     $i = $1;
+     $post = $2;
+     if ($post eq '.' && $i eq $normal_sec_num[0])
+     {
+       $i = 'A';
+     }
+     else
+     {
+       $i++;
+     }
+     return $sec2node{$number2sec{$num . $i . $post}}
+   }
+   return '';
+ }
+ 
  sub check {
      local($_, %seen, %context, $before, $match, $after);
***************
*** 1547,1551 ****
  	if (/\@(\*|\.|\:|\@|\{|\})/) {
  	    $seen{$&}++;
! 	    $context{$&} .= "> $_" if $verbose;
  	    $_ = "$`XX$'";
  	    redo;
--- 4962,4966 ----
  	if (/\@(\*|\.|\:|\@|\{|\})/) {
  	    $seen{$&}++;
! 	    $context{$&} .= "> $_" if $T2H_VERBOSE;
  	    $_ = "$`XX$'";
  	    redo;
***************
*** 1555,1562 ****
  	    if ($before =~ /\b[\w-]+$/ && $after =~ /^[\w-.]*\b/) { # e-mail address
  		$seen{'e-mail address'}++;
! 		$context{'e-mail address'} .= "> $_" if $verbose;
  	    } else {
  		$seen{$match}++;
! 		$context{$match} .= "> $_" if $verbose;
  	    }
  	    $match =~ s/^\@/X/;
--- 4970,4977 ----
  	    if ($before =~ /\b[\w-]+$/ && $after =~ /^[\w-.]*\b/) { # e-mail address
  		$seen{'e-mail address'}++;
! 		$context{'e-mail address'} .= "> $_" if $T2H_VERBOSE;
  	    } else {
  		$seen{$match}++;
! 		$context{$match} .= "> $_" if $T2H_VERBOSE;
  	    }
  	    $match =~ s/^\@/X/;
***************
*** 1567,1571 ****
      
      foreach (sort(keys(%seen))) {
! 	if ($verbose) {
  	    print "$_\n";
  	    print $context{$_};
--- 4982,4986 ----
      
      foreach (sort(keys(%seen))) {
! 	if ($T2H_VERBOSE) {
  	    print "$_\n";
  	    print $context{$_};
***************
*** 1622,1625 ****
--- 5037,5053 ----
  }
  
+ # used in pass 1 for l2h use &next_line
+ sub string_until {
+     local($tag) = @_;
+     local($_, $string);
+ 
+     while ($_ = &next_line) {
+ 	return $string if /^\@end\s+$tag\s*$/;
+ #	$_ =~ s/hbox/mbox/g;
+ 	$string = $string.$_;
+     }
+     die "* Failed to find '$tag' after: " . $lines[$#lines];
+ }
+ 
  #
  # HTML stacking to have a better HTML output
***************
*** 1665,1670 ****
  sub html_debug {
      local($what, $line) = @_;
!     return("<!-- $line @html_stack, $html_element -->$what")
! 	if $debug & $DEBUG_HTML;
      return($what);
  }
--- 5093,5101 ----
  sub html_debug {
      local($what, $line) = @_;
!     if ($T2H_DEBUG & $DEBUG_HTML)
!     {
!      $what = "\n" unless $what;
!      return("<!-- $line @html_stack, $html_element -->$what")
!     }	
      return($what);
  }
***************
*** 1674,1700 ****
      local($what, $line) = @_;
      return("<!-- $line -->$what")
! 	if $debug & $DEBUG_HTML;
      return($what);
  }
  
! sub normalise_node {
!     $_[0] =~ s/\s+/ /g;
!     $_[0] =~ s/ $//;
!     $_[0] =~ s/^ //;
  }
  
! sub menu_entry {
!     local($entry, $node, $descr) = @_;
!     local($href);
! 
!     &normalise_node($node);
!     $href = $node2href{$node};
!     if ($href) {
! 	$descr =~ s/^\s+//;
! 	$descr = ": $descr" if $descr;
! 	push(@lines2, "<LI>" . &anchor('', $href, $entry) . "$descr\n");
!     } else {
! 	warn "$ERROR Undefined node ($node): $_";
!     }
  }
  
--- 5105,5182 ----
      local($what, $line) = @_;
      return("<!-- $line -->$what")
! 	if $T2H_DEBUG & $DEBUG_HTML;
      return($what);
  }
  
! sub SimpleTexi2Html
! {
!   local $_ = $_[0];
!   &protect_texi;
!   &protect_html;
!   $_ = substitute_style($_);
!   $_[0]  = $_;
  }
  
! sub normalise_node {
!   local $_ = $_[0];
!   s/\s+/ /g;
!   s/ $//;
!   s/^ //;
!   &protect_texi;
!   &protect_html;
!   $_ = substitute_style($_);
!   $_[0]  = $_;
! }
! 
! sub menu_entry 
! {
!   my ($node, $name, $descr) = @_;
!   my ($href, $entry);
!   
!   &normalise_node($node);
!   $href = $node2href{$node};
!   if ($href) 
!   {
!     $descr =~ s/^\s+//;
!     $descr =~ s/\s*$//;
!     $descr = SimpleTexi2Html($descr);
!     if ($T2H_NUMBER_SECTIONS && !$T2H_NODE_NAME_IN_MENU && $node2sec{$node})
!     {
!       $entry = $node2sec{$node};
!       $name = '';
!     }
!     else
!     {
!       &normalise_node($name);
!       $entry = ($name && ($name ne $node || ! $T2H_AVOID_MENU_REDUNDANCY) 
! 		? "$name : $node" : $node);
!     }
! 
!     if ($T2H_AVOID_MENU_REDUNDANCY && $descr)
!     {
!       my $clean_entry = $entry;
!       $clean_entry =~ s/^.*? // if ($clean_entry =~ /^([A-Z]|\d+)\.[\d\.]* /);
!       $clean_entry =~ s/[^\w]//g;
!       my $clean_descr = $descr;
!       $clean_descr =~ s/[^\w]//g;
!       $descr = '' if ($clean_entry eq $clean_descr)
!     }
!     push(@lines2,&debug('<TR><TD ALIGN="left" VALIGN="TOP">' . 
! 			&t2h_anchor('', $href, $entry) . 
! 			'</TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP">' . 
! 			$descr . 
! 			"</TD></TR>\n", __LINE__));
!   }
!   elsif ($node =~ /^\(.*\)\w+/)
!   {
!     push(@lines2,&debug('<TR><TD ALIGN="left" VALIGN="TOP">' . 
! 			$entry . 
! 			'</TD><TD ALIGN="left" VALIGN="TOP">' . $descr . 
! 			"</TD></TR>\n", __LINE__))
!   }
!   else
!   {
!     warn "$ERROR Undefined node of menu_entry ($node): $_";
!   }
  }
  
***************
*** 1705,1721 ****
  
      $text = $addr unless $text;
!     &anchor('', "mailto:$addr", $text);
  }
  
! sub do_sc { "\U$_[0]\E" }
  
  sub do_uref {
!     local($url, $text) = split(/,\s*/, $_[0]);
  
      $text = $url unless $text;
!     &anchor('', $url, $text);
  }
  
! sub do_url { &anchor('', $_[0], $_[0]) }
  
  sub apply_style {
--- 5187,5235 ----
  
      $text = $addr unless $text;
!     &t2h_anchor('', "mailto:$addr", $text);
  }
  
! sub do_sc 
! { 
!   # l2h does this much better
!   return &l2h_ToLatex("{\\sc ".&unprotect_html($_[0])."}") if ($T2H_L2H);
!   return "\U$_[0]\E";
! }
! 
! sub do_math
! {
!   return &l2h_ToLatex("\$".&unprotect_html($_[0])."\$") if ($T2H_L2H);
!   return "<EM>".$text."</EM>";
! }
  
  sub do_uref {
!     local($url, $text, $only_text) = split(/,\s*/, $_[0]);
  
+     $text = $only_text if $only_text;
      $text = $url unless $text;
!     &t2h_anchor('', $url, $text);
  }
  
! sub do_url { &t2h_anchor('', $_[0], $_[0]) }
! 
! sub do_acronym
! {
!   return '<FONT SIZE="-1">' . $_[0] . '</FONT>';
! }
! 
! sub do_accent
! {
!   return "&$_[0]acute;" if $_[1] eq 'H';
!   return "$_[0]." if $_[1] eq 'dotaccent';
!   return "$_[0]*" if $_[1] eq 'ringaccent';
!   return "$_[0]".'[' if $_[1] eq 'tieaccent';
!   return "$_[0]".'(' if $_[1] eq 'u';
!   return "$_[0]_" if $_[1] eq 'ubaraccent';
!   return ".$_[0]" if $_[1] eq 'udotaccent';
!   return "$_[0]&lt;" if $_[1] eq 'v';
!   return "&$_[0]cedil;" if $_[1] eq ',';
!   return "$_[0]" if $_[1] eq 'dotless';
!   return undef;
! }
  
  sub apply_style {
***************
*** 1731,1735 ****
  	if ($style =~ /^\&/) { # custom
  	    $style = $';
! 	    $text = &$style($text);
  	} elsif ($style) { # good style
  	    $text = "<$style>$text</$style>";
--- 5245,5249 ----
  	if ($style =~ /^\&/) { # custom
  	    $style = $';
! 	    $text = &$style($text, $texi_style);
  	} elsif ($style) { # good style
  	    $text = "<$style>$text</$style>";
***************
*** 1745,1761 ****
  sub remove_style {
      local($_) = @_;
!     s/\@\w+{([^\{\}]+)}/$1/g;
      return($_);
  }
  
  sub substitute_style {
      local($_) = @_;
      local($changed, $done, $style, $text);
  
      $changed = 1;
      while ($changed) {
  	$changed = 0;
  	$done = '';
! 	while (/\@(\w+){([^\{\}]+)}/) {
  	    $text = &apply_style($1, $2);
  	    if ($text) {
--- 5259,5283 ----
  sub remove_style {
      local($_) = @_;
!     1 while(s/\@\w+{([^\{\}]+)}/$1/g);
      return($_);
  }
  
+ sub remove_things
+ {
+   local ($_) = @_;
+   s|\@(\w+)\{\}|$1|g;
+   return $_;
+ }
+ 
  sub substitute_style {
      local($_) = @_;
      local($changed, $done, $style, $text);
  
+     &simple_substitutions;
      $changed = 1;
      while ($changed) {
  	$changed = 0;
  	$done = '';
! 	while (/\@(\w+){([^\{\}]+)}/ || /\@(,){([^\{\}]+)}/) {
  	    $text = &apply_style($1, $2);
  	    if ($text) {
***************
*** 1772,1782 ****
  }
  
! sub anchor {
!     local($name, $href, $text, $newline) = @_;
      local($result);
  
      $result = "<A";
      $result .= " NAME=\"$name\"" if $name;
!     $result .= " HREF=\"$href\"" if $href;
      $result .= ">$text</A>";
      $result .= "\n" if $newline;
--- 5294,5310 ----
  }
  
! sub t2h_anchor {
!     local($name, $href, $text, $newline, $extra_attribs) = @_;
      local($result);
  
      $result = "<A";
      $result .= " NAME=\"$name\"" if $name;
!     if ($href)
!     {
!       $href =~ s|^$T2H_HREF_DIR_INSTEAD_FILE|./| 
! 	if ($T2H_HREF_DIR_INSTEAD_FILE);
!       $result .= ($href =~ /\"/ ? " HREF='$href'"  : " HREF=\"$href\"");
!     }
!     $result .= " $extra_attribs" if $extra_attribs;
      $result .= ">$text</A>";
      $result .= "\n" if $newline;
***************
*** 1787,1813 ****
      local(@MoY, $sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst);
  
!     @MoY = ('January', 'Febuary', 'March', 'April', 'May', 'June',
  	    'July', 'August', 'September', 'October', 'November', 'December');
      ($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst) = localtime(time);
      $year += ($year < 70) ? 2000 : 1900;
!     return("$mday $MoY[$mon] $year");
  }
  
! sub doc_name {
      local($num) = @_;
  
!     return("${docu_name}_$num.html");
  }
  
  sub next_doc {
!     $docu_doc = &doc_name(++$doc_num);
  }
  
! sub print {
!     local(*lines, $fh) = @_;
      local($_);
! 
!     while (@lines) {
! 	$_ = shift(@lines);
  	if (/^$PROTECTTAG/o) {
  	    $_ = $tag2pro{$_};
--- 5315,5349 ----
      local(@MoY, $sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst);
  
!     @MoY = ('January', 'February', 'March', 'April', 'May', 'June',
  	    'July', 'August', 'September', 'October', 'November', 'December');
      ($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst) = localtime(time);
      $year += ($year < 70) ? 2000 : 1900;
!     # obachman: Let's do it as the Americans do
!     return("$MoY[$mon], $mday  $year");
  }
  
! sub doc_href {
      local($num) = @_;
  
!     return("${docu_name}_$num.$docu_ext");
! }
! 
! sub sec_href
! {
!   return $node2href{$sec2node{$_[0]}};
  }
  
  sub next_doc {
!     $docu_doc = &doc_href(++$doc_num);
  }
  
! sub t2h_print_lines {
!     my ($fh, $lines) = @_;
      local($_);
!     $lines = $T2H_THIS_SECTION unless $lines;
!     my $cnt = 0;
!     for (@$lines) 
!     {
! 	$_ = l2h_FromHtml($_) if ($T2H_L2H);
  	if (/^$PROTECTTAG/o) {
  	    $_ = $tag2pro{$_};
***************
*** 1816,1888 ****
  	}
  	print $fh $_;
      }
! }
! 
! sub print_ruler {
!     print FILE "<P><HR><P>\n";
! }
! 
! sub print_header {
!     local($_);
! 
!     # clean the title
!     $_ = &remove_style($_[0]);
!     &unprotect_texi;
!     # print the header
!     if ($doctype eq 'html2') {
! 	print FILE $html2_doctype;
!     } elsif ($doctype) {
! 	print FILE $doctype;
!     }
!     print FILE <<EOT;
! <HTML>
! <HEAD>
! $header
! <TITLE>$_</TITLE>
! </HEAD>
! <BODY>
! EOT
! }
! 
! sub print_toplevel_header {
!     local($_);
! 
!     &print_header; # pass given arg...
!     print FILE $full_title;
!     if ($value{'_subtitle'}) {
! 	$value{'_subtitle'} =~ s/\n+$//;
! 	foreach (split(/\n/, $value{'_subtitle'})) {
! 	    $_ = &substitute_style($_);
! 	    &unprotect_texi;
! 	    print FILE "<H2>$_</H2>\n";
! 	}
!     }
!     if ($value{'_author'}) {
! 	$value{'_author'} =~ s/\n+$//;
! 	foreach (split(/\n/, $value{'_author'})) {
! 	    $_ = &substitute_style($_);
! 	    &unprotect_texi;
! 	    s/[\w.-]+\@[\w.-]+/<A HREF="mailto:$&">$&<\/A>/g;
! 	    print FILE "<ADDRESS>$_</ADDRESS>\n";
! 	}
!     }
!     print FILE "<P>\n";
! }
! 
! sub print_footer {
!     print FILE <<EOT;
! </BODY>
! </HTML>
! EOT
! }
! 
! sub print_toplevel_footer {
!     &print_ruler;
!     print FILE <<EOT;
! This document was generated on $TODAY using the
! <A HREF=\"$HOMEPAGE\">texi2html</A>
! translator version 1.52.</P>
! EOT
!     &print_footer;
  }
  
--- 5352,5358 ----
  	}
  	print $fh $_;
+ 	$cnt += split(/\W*\s+\W*/);
      }
!     return $cnt;
  }
  
***************
*** 1902,1905 ****
--- 5372,5382 ----
      $what =~ s/\</\&\#60;/g;
      $what =~ s/\>/\&\#62;/g;
+     # restore anything in quotes
+     # this fixes my problem where I had:
+     # < IMG SRC="leftarrow.gif" ALT="<--" >  but what if I wanted &#60; in my ALT text ??
+     # maybe byte stuffing or some other technique should be used.
+     $what =~ s/\"([^\&]+)\&\#60;(.*)\"/"$1<$2"/g;
+     $what =~ s/\"([^\&]+)\&\#62;(.*)\"/"$1>$2"/g;
+     $what =~ s/\"([^\&]+)\&\#38;(.*)\"/"$1&$2"/g;
      # but recognize some HTML things
      $what =~ s/\&\#60;\/A\&\#62;/<\/A>/g;	      # </A>
***************
*** 1917,1920 ****
--- 5394,5404 ----
  }
  
+ sub Unprotect_texi 
+ {
+   local $_ = shift;
+   &unprotect_texi;
+   return($_);
+ }
+ 
  sub unprotect_html {
      local($what) = @_;
***************
*** 1925,1930 ****
  }
  
! sub byalpha {
!     $key2alpha{$a} cmp $key2alpha{$b};
  }
  
--- 5409,5418 ----
  }
  
! sub t2h_print_label
! {
!     my $fh = shift;
!     my $href = shift || $T2H_HREF{This};
!     $href =~ s/.*#(.*)$/$1/;
!     print $fh qq{<A NAME="$href"></A>\n};
  }
  
***************
*** 1939,2081 ****
  .nr % 0			\" start at page 1
  '; __END__ ############# From here on it's a standard manual page ############
! .TH TEXI2HTML 1 "01/05/98"
! .AT 3
! .SH NAME
! texi2html \- a Texinfo to HTML converter
! .SH SYNOPSIS
! .B texi2html [options] file
! .PP
! .B texi2html -check [-verbose] files
! .SH DESCRIPTION
! .I Texi2html
! converts the given Texinfo file to a set of HTML files. It tries to handle
! most of the Texinfo commands. It creates hypertext links for cross-references,
! footnotes...
! .PP
! It also tries to add links from a reference to its corresponding entry in the
! bibliography (if any). It may also handle a glossary (see the
! .B \-glossary
! option).
! .PP
! .I Texi2html
! creates several files depending on the contents of the Texinfo file and on
! the chosen options (see FILES).
! .PP
! The HTML files created by
! .I texi2html
! are closer to TeX than to Info, that's why
! .I texi2html
! converts @iftex sections and not @ifinfo ones by default. You can reverse
! this with the \-expandinfo option.
! .SH OPTIONS
! .TP 12
! .B \-check
! Check the given file and give the list of all things that may be Texinfo commands.
! This may be used to check the output of
! .I texi2html
! to find the Texinfo commands that have been left in the HTML file.
! .TP
! .B \-expandinfo
! Expand @ifinfo sections, not @iftex ones.
! .TP
! .B \-glossary
! Use the section named 'Glossary' to build a list of terms and put links in the HTML
! document from each term toward its definition.
! .TP
! .B \-invisible \fIname\fP
! Use \fIname\fP to create invisible destination anchors for index links
! (you can for instance use the invisible.xbm file shipped with this program).
! This is a workaround for a known bug of many WWW browsers, including netscape.
! .TP
! .B \-I \fIdir\fP
! Look also in \fIdir\fP to find included files.
! .TP
! .B \-menu
! Show the Texinfo menus; by default they are ignored.
! .TP
! .B \-monolithic
! Output only one file, including the table of contents and footnotes.
! .TP
! .B \-number
! Number the sections.
! .TP
! .B \-split_chapter
! Split the output into several HTML files (one per main section:
! chapter, appendix...).
! .TP
! .B \-split_node
! Split the output into several HTML files (one per node).
! .TP
! .B \-usage
! Print usage instructions, listing the current available command-line options.
! .TP
! .B \-verbose
! Give a verbose output. Can be used with the
! .B \-check
! option.
! .PP
! .SH FILES
! By default
! .I texi2html
! creates the following files (foo being the name of the Texinfo file):
! .TP 16
! .B foo_toc.html
! The table of contents.
! .TP
! .B foo.html
! The document's contents.
! .TP
! .B foo_foot.html
! The footnotes (if any).
! .PP
! When used with the
! .B \-split
! option, it creates several files (one per chapter or node), named
! .B foo_n.html
! (n being the indice of the chapter or node), instead of the single
! .B foo.html
! file.
! .PP
! When used with the
! .B \-monolithic
! option, it creates only one file:
! .B foo.html
! .SH VARIABLES
! .I texi2html
! predefines the following variables: \fBhtml\fP, \fBtexi2html\fP.
! .SH ADDITIONAL COMMANDS
! .I texi2html
! implements the following non-Texinfo commands (maybe they are in Texinfo now...):
! .TP 16
! .B @ifhtml
! This indicates the start of an HTML section, this section will passed through
! without any modification.
! .TP
! .B @end ifhtml
! This indicates the end of an HTML section.
! .SH VERSION
! This is \fItexi2html\fP version 1.52, 01/05/98.
! .PP
! The latest version of \fItexi2html\fP can be found in WWW, cf. URL
! http://wwwinfo.cern.ch/dis/texi2html/
! .SH AUTHOR
! The main author is Lionel Cons, CERN IT/DIS/OSE, Lionel.Cons@cern.ch.
! Many other people around the net contributed to this program.
! .SH COPYRIGHT
! This program is the intellectual property of the European
! Laboratory for Particle Physics (known as CERN). No guarantee whatsoever is
! provided by CERN. No liability whatsoever is accepted for any loss or damage
! of any kind resulting from any defect or inaccuracy in this information or
! code.
! .PP
! CERN, 1211 Geneva 23, Switzerland
! .SH "SEE ALSO"
! GNU Texinfo Documentation Format,
! HyperText Markup Language (HTML),
! World Wide Web (WWW).
! .SH BUGS
! This program does not understand all Texinfo commands (yet).
! .PP
! TeX specific commands (normally enclosed in @iftex) will be
! passed unmodified.
! .ex
--- 5427,5429 ----
  .nr % 0			\" start at page 1
  '; __END__ ############# From here on it's a standard manual page ############
! .so /usr/local/man/man1/texi2html.1
diff -Nrc2 bash-2.05/test.c bash-2.05a/test.c
*** bash-2.05/test.c	Thu Mar  8 08:52:45 2001
--- bash-2.05a/test.c	Tue Oct 30 12:37:48 2001
***************
*** 33,39 ****
  #include "bashtypes.h"
  
! #if defined (HAVE_LIMITS_H)
! #  include <limits.h>
! #else
  #  include <sys/param.h>
  #endif
--- 33,37 ----
  #include "bashtypes.h"
  
! #if !defined (HAVE_LIMITS_H)
  #  include <sys/param.h>
  #endif
***************
*** 59,63 ****
  #include "builtins/common.h"
  
! #include <glob/fnmatch.h>
  
  #if !defined (STRLEN)
--- 57,61 ----
  #include "builtins/common.h"
  
! #include <glob/strmatch.h>
  
  #if !defined (STRLEN)
***************
*** 116,131 ****
  static int noeval;
  
! static int unary_operator ();
! static int binary_operator ();
! static int two_arguments ();
! static int three_arguments ();
! static int posixtest ();
! 
! static int expr ();
! static int term ();
! static int and ();
! static int or ();
! 
! static void beyond ();
  
  static void
--- 114,137 ----
  static int noeval;
  
! static void test_syntax_error __P((char *, char *)) __attribute__((__noreturn__));
! static void beyond __P((void)) __attribute__((__noreturn__));
! static void integer_expected_error __P((char *)) __attribute__((__noreturn__));
! 
! static int test_stat __P((char *, struct stat *));
! 
! static int unary_operator __P((void));
! static int binary_operator __P((void));
! static int two_arguments __P((void));
! static int three_arguments __P((void));
! static int posixtest __P((void));
! 
! static int expr __P((void));
! static int term __P((void));
! static int and __P((void));
! static int or __P((void));
! 
! static int filecomp __P((char *, char *, int));
! static int arithcomp __P((char *, char *, int, int));
! static int patcomp __P((char *, char *, int));
  
  static void
***************
*** 133,138 ****
       char *format, *arg;
  {
-   extern int interactive_shell;
-   extern char *get_name_for_error ();
    if (interactive_shell == 0)
      fprintf (stderr, "%s: ", get_name_for_error ());
--- 139,142 ----
***************
*** 179,189 ****
  #if !defined (HAVE_DEV_FD)
        long fd;
!       if (legal_number (path + 8, &fd))
! 	return (fstat ((int)fd, finfo));
!       else
! 	{
! 	  errno = EBADF;
! 	  return (-1);
! 	}
  #else
    /* If HAVE_DEV_FD is defined, DEV_FD_PREFIX is defined also, and has a
--- 183,196 ----
  #if !defined (HAVE_DEV_FD)
        long fd;
!       int r;
! 
!       if (legal_number (path + 8, &fd) && fd == (int)fd)
!         {
!           r = fstat ((int)fd, finfo);
!           if (r == 0 || errno != EBADF)
!             return (r);
!         }
!       errno = ENOENT;
!       return (-1);
  #else
    /* If HAVE_DEV_FD is defined, DEV_FD_PREFIX is defined also, and has a
***************
*** 280,284 ****
  
    value = and ();
!   while (pos < argc && argv[pos][0] == '-' && argv[pos][1] == 'o' && !argv[pos][2])
      {
        advance (0);
--- 287,291 ----
  
    value = and ();
!   if (pos < argc && argv[pos][0] == '-' && argv[pos][1] == 'o' && !argv[pos][2])
      {
        advance (0);
***************
*** 301,305 ****
  
    value = term ();
!   while (pos < argc && argv[pos][0] == '-' && argv[pos][1] == 'a' && !argv[pos][2])
      {
        advance (0);
--- 308,312 ----
  
    value = term ();
!   if (pos < argc && argv[pos][0] == '-' && argv[pos][1] == 'a' && !argv[pos][2])
      {
        advance (0);
***************
*** 457,461 ****
    int m;
  
!   m = fnmatch (pat, string, FNMATCH_EXTFLAG);
    return ((op == EQ) ? (m == 0) : (m != 0));
  }
--- 464,468 ----
    int m;
  
!   m = strmatch (pat, string, FNMATCH_EXTFLAG);
    return ((op == EQ) ? (m == 0) : (m != 0));
  }
***************
*** 551,555 ****
  unary_operator ()
  {
!   char *op, *arg;
    long r;
  
--- 558,562 ----
  unary_operator ()
  {
!   char *op;
    long r;
  
***************
*** 681,685 ****
        if (legal_number (arg, &r) == 0)
  	return (FALSE);
!       return (isatty ((int)r));
  
      case 'n':			/* True if arg has some length. */
--- 688,692 ----
        if (legal_number (arg, &r) == 0)
  	return (FALSE);
!       return ((r == (int)r) && isatty ((int)r));
  
      case 'n':			/* True if arg has some length. */
***************
*** 692,695 ****
--- 699,705 ----
        return (minus_o_option_value (arg) == 1);
      }
+ 
+   /* We can't actually get here, but this shuts up gcc. */
+   return (FALSE);
  }
  
***************
*** 789,792 ****
--- 799,804 ----
  #define ANDOR(s)  (s[0] == '-' && !s[2] && (s[1] == 'a' || s[1] == 'o'))
  
+ /* This could be augmented to handle `-t' as equivalent to `-t 1', but
+    POSIX requires that `-t' be given an argument. */
  #define ONE_ARG_TEST(s)		((s)[0] != '\0')
  
***************
*** 879,884 ****
  {
    int value;
- 
    int code;
  
    code = setjmp (test_exit_buf);
--- 891,897 ----
  {
    int value;
    int code;
+ 
+   USE_VAR(margc);
  
    code = setjmp (test_exit_buf);
diff -Nrc2 bash-2.05/tests/arith.tests bash-2.05a/tests/arith.tests
*** bash-2.05/tests/arith.tests	Mon Sep 25 13:40:45 2000
--- bash-2.05a/tests/arith.tests	Thu Oct 11 14:35:20 2001
***************
*** 137,142 ****
  echo $(( 64#A ))
  
- echo $(( 64#_ ))
  echo $(( 64#@ ))
  
  # weird bases
--- 137,142 ----
  echo $(( 64#A ))
  
  echo $(( 64#@ ))
+ echo $(( 64#_ ))
  
  # weird bases
***************
*** 266,269 ****
--- 266,270 ----
  
  # These are errors
+ unset b
  echo $((a b))
  ((a b))
diff -Nrc2 bash-2.05/tests/array.right bash-2.05a/tests/array.right
*** bash-2.05/tests/array.right	Tue Sep 26 15:31:51 2000
--- bash-2.05a/tests/array.right	Thu Aug  9 18:29:08 2001
***************
*** 28,32 ****
  readonly -a a='([1]="" [2]="bdef" [5]="hello world" [6]="test expression")'
  readonly -a c='()'
- ./array.tests: declare: e: cannot assign to array variables in this way
  a test
  declare -a DIRSTACK='()'
--- 28,31 ----
***************
*** 112,123 ****
  4414758999202
  aaa bbb
! ./array.tests: array assign: line 262: syntax error near unexpected token `for'
! ./array.tests: array assign: line 262: `a b c for case if then else'
! ./array.tests: array assign: line 264: syntax error near unexpected token `for'
! ./array.tests: array assign: line 264: `for case if then else'
! ./array.tests: array assign: line 266: syntax error near unexpected token `<>'
! ./array.tests: array assign: line 266: ` <> < > ! '
! ./array.tests: array assign: line 267: syntax error near unexpected token `[1]=<>'
! ./array.tests: array assign: line 267: ` [1]=<> [2]=< [3]=> [4]=! '
  abc 3
  0
--- 111,122 ----
  4414758999202
  aaa bbb
! ./array.tests: array assign: line 263: syntax error near unexpected token `for'
! ./array.tests: array assign: line 263: `a b c for case if then else'
! ./array.tests: array assign: line 265: syntax error near unexpected token `for'
! ./array.tests: array assign: line 265: `for case if then else'
! ./array.tests: array assign: line 267: syntax error near unexpected token `<>'
! ./array.tests: array assign: line 267: ` <> < > ! '
! ./array.tests: array assign: line 268: syntax error near unexpected token `[1]=<>'
! ./array.tests: array assign: line 268: ` [1]=<> [2]=< [3]=> [4]=! '
  abc 3
  0
diff -Nrc2 bash-2.05/tests/array.tests bash-2.05a/tests/array.tests
*** bash-2.05/tests/array.tests	Tue Sep 26 15:30:59 2000
--- bash-2.05a/tests/array.tests	Thu Aug  9 18:28:11 2001
***************
*** 22,25 ****
--- 22,26 ----
  a[2]=bdef
  
+ unset b
  declare -a b[256]
  
***************
*** 79,83 ****
  d[9]="ninth element"
  
! declare -a e[10]=test
  declare -a e[10]='(test)'
  
--- 80,84 ----
  d[9]="ninth element"
  
! declare -a e[10]=test	# this works in post-bash-2.05 versions
  declare -a e[10]='(test)'
  
diff -Nrc2 bash-2.05/tests/builtins.right bash-2.05a/tests/builtins.right
*** bash-2.05/tests/builtins.right	Tue Sep 21 11:48:29 1999
--- bash-2.05a/tests/builtins.right	Tue Sep 11 12:35:10 2001
***************
*** 46,54 ****
  bar
  xxx
! 022
  u=rwx,g=rx,o=rx
! 002
  u=rwx,g=rwx,o=rx
! umask 002
  umask -S u=rwx,g=rwx,o=rx
  u=rwx,g=rwx,o=rwx
--- 46,54 ----
  bar
  xxx
! 0022
  u=rwx,g=rx,o=rx
! 0002
  u=rwx,g=rwx,o=rx
! umask 0002
  umask -S u=rwx,g=rwx,o=rx
  u=rwx,g=rwx,o=rwx
diff -Nrc2 bash-2.05/tests/errors.right bash-2.05a/tests/errors.right
*** bash-2.05/tests/errors.right	Tue Feb 22 12:30:58 2000
--- bash-2.05a/tests/errors.right	Thu Aug  9 18:26:07 2001
***************
*** 32,36 ****
  ./errors.tests: hash: notthere: not found
  ./errors.tests: hash: illegal option: -v
! hash: usage: hash [-r] [-p pathname] [name ...]
  ./errors.tests: hash: hashing disabled
  ./errors.tests: export: `AA[4]': not a valid identifier
--- 32,36 ----
  ./errors.tests: hash: notthere: not found
  ./errors.tests: hash: illegal option: -v
! hash: usage: hash [-r] [-p pathname] [-t] [name ...]
  ./errors.tests: hash: hashing disabled
  ./errors.tests: export: `AA[4]': not a valid identifier
***************
*** 39,43 ****
  ./errors.tests: AA: readonly variable
  ./errors.tests: AA: readonly variable
- ./errors.tests: readonly: ZZZ: cannot assign to array variables in this way
  ./errors.tests: shift: shift count must be <= $#
  ./errors.tests: shift: shift count must be >= 0
--- 39,42 ----
***************
*** 87,91 ****
  ./errors.tests: trap: illegal option: -s
  trap: usage: trap [arg] [signal_spec ...] or trap -l
- ./errors.tests: trap: ERR: not a signal specification
  ./errors.tests: return: can only `return' from a function or sourced script
  ./errors.tests: break: loop count must be > 0
--- 86,89 ----
diff -Nrc2 bash-2.05/tests/errors.tests bash-2.05a/tests/errors.tests
*** bash-2.05/tests/errors.tests	Tue Feb 22 12:30:32 2000
--- bash-2.05a/tests/errors.tests	Thu Aug  9 18:26:49 2001
***************
*** 122,126 ****
  
  # try to assign a readonly array with bad assignment syntax
! readonly -a ZZZ=bbb
  
  # bad counts to `shift'
--- 122,127 ----
  
  # try to assign a readonly array with bad assignment syntax
! # NOTE: this works in post-bash-2.05 (at least when I write this)
! # readonly -a ZZZ=bbb
  
  # bad counts to `shift'
***************
*** 218,223 ****
  trap -p -s NOSIG
  
! # maybe someday we will have a ksh-like ERR trap, but not yet
! trap 'echo [$LINENO] -- error' ERR
  
  # can only return from a function or sourced script
--- 219,224 ----
  trap -p -s NOSIG
  
! # we have a ksh-like ERR trap, post-bash-2.05
! #trap 'echo [$LINENO] -- error' ERR
  
  # can only return from a function or sourced script
diff -Nrc2 bash-2.05/tests/exec.right bash-2.05a/tests/exec.right
*** bash-2.05/tests/exec.right	Mon Sep 25 11:37:03 2000
--- bash-2.05a/tests/exec.right	Wed May  2 14:49:25 2001
***************
*** 18,23 ****
  1
  127
! ./execscript: .: /dev/null: not a regular file
! 1
  this is bashenv
  ./exec3.sub: /tmp/bash-notthere: No such file or directory
--- 18,22 ----
  1
  127
! 0
  this is bashenv
  ./exec3.sub: /tmp/bash-notthere: No such file or directory
diff -Nrc2 bash-2.05/tests/execscript bash-2.05a/tests/execscript
*** bash-2.05/tests/execscript	Thu Jul 27 10:15:32 2000
--- bash-2.05a/tests/execscript	Wed May  2 14:50:01 2001
***************
*** 2,5 ****
--- 2,9 ----
  export LANG=C
  
+ if (( $UID == 0 )); then
+         echo "execscript: the test suite should not be run as root" >&2
+ fi
+ 
  set -- one two three
  echo before exec1.sub: "$@"
***************
*** 41,44 ****
--- 45,49 ----
  echo $?
  
+ # post-bash-2.05 versions allow sourcing non-regular files
  . /dev/null
  echo $?
diff -Nrc2 bash-2.05/tests/posix2.tests bash-2.05a/tests/posix2.tests
*** bash-2.05/tests/posix2.tests	Fri Oct 13 15:50:34 2000
--- bash-2.05a/tests/posix2.tests	Thu Oct 25 09:15:23 2001
***************
*** 147,151 ****
  SQUOTE="'"
  val1=$(set | sed -n 's:^SQUOTE=::p')
! if [ "$val1" != "\$'\\''" ]; then
          testfail "variable quoting 1"
  fi
--- 147,151 ----
  SQUOTE="'"
  val1=$(set | sed -n 's:^SQUOTE=::p')
! if [ "$val1" != "''\\'''" ]; then
          testfail "variable quoting 1"
  fi
***************
*** 154,158 ****
  VTILDE='~'
  val1=$(set | sed -n 's:^VTILDE=::p')
! if [ "$val1" != "\$'~'" ]; then
  	testfail "variable quoting 2"
  fi
--- 154,158 ----
  VTILDE='~'
  val1=$(set | sed -n 's:^VTILDE=::p')
! if [ "$val1" != "'~'" ]; then
  	testfail "variable quoting 2"
  fi
***************
*** 168,172 ****
  VHASH2=#abcd
  val1=$(set | sed -n 's:^VHASH2=::p')
! if [ "$val1" != "\$'#abcd'" ]; then
  	testfail "variable quoting 4"
  fi
--- 168,172 ----
  VHASH2=#abcd
  val1=$(set | sed -n 's:^VHASH2=::p')
! if [ "$val1" != "'#abcd'" ]; then
  	testfail "variable quoting 4"
  fi
Binary files bash-2.05/tests/printf.right and bash-2.05a/tests/printf.right differ
diff -Nrc2 bash-2.05/tests/printf.tests bash-2.05a/tests/printf.tests
*** bash-2.05/tests/printf.tests	Wed Mar 15 11:34:22 2000
--- bash-2.05a/tests/printf.tests	Thu Oct  4 15:35:26 2001
***************
*** 62,70 ****
  # these should all display `A7'
  echo -e "\1017"
! echo -e "\x0417"
  
  printf "%b\n" '\01017'
  printf "%b\n" '\1017'
! printf "%b\n" '\x0417'
  
  printf -- "--%b--\n" '\"abcd\"'
--- 62,70 ----
  # these should all display `A7'
  echo -e "\1017"
! echo -e "\x417"
  
  printf "%b\n" '\01017'
  printf "%b\n" '\1017'
! printf "%b\n" '\x417'
  
  printf -- "--%b--\n" '\"abcd\"'
***************
*** 207,210 ****
--- 207,224 ----
  printf "%y" 0
  
+ # these should print a warning and `0', according to POSIX.2
  printf "%d\n" GNU
  printf "%o\n" GNU
+ 
+ # failures in all bash versions through bash-2.05
+ printf "%.0s" foo
+ printf "%.*s" 0 foo
+ 
+ printf '%.0b-%.0s\n' foo bar
+ printf '(%*b)(%*s)\n' -4 foo -4 bar
+ 
+ format='%'`printf '%0100384d' 0`'d\n' 
+ printf $format 0
+ 
+ # this doesn't work with printf(3) on all systems
+ #printf "%'s\n" foo
diff -Nrc2 bash-2.05/tests/shopt.right bash-2.05a/tests/shopt.right
*** bash-2.05/tests/shopt.right	Tue Sep 26 15:26:09 2000
--- bash-2.05a/tests/shopt.right	Wed May  9 13:40:39 2001
***************
*** 18,21 ****
--- 18,22 ----
  shopt -s interactive_comments
  shopt -u lithist
+ shopt -u login_shell
  shopt -u mailwarn
  shopt -u no_empty_cmd_completion
***************
*** 53,56 ****
--- 54,58 ----
  shopt -u huponexit
  shopt -u lithist
+ shopt -u login_shell
  shopt -u mailwarn
  shopt -u no_empty_cmd_completion
***************
*** 72,75 ****
--- 74,78 ----
  huponexit      	off
  lithist        	off
+ login_shell    	off
  mailwarn       	off
  no_empty_cmd_completion	off
***************
*** 100,103 ****
--- 103,107 ----
  set +o ignoreeof
  set -o interactive-comments
+ set +o nolog
  set +o posix
  set -o emacs
***************
*** 124,127 ****
--- 128,132 ----
  ignoreeof      	off
  interactive-comments	on
+ nolog          	off
  posix          	off
  emacs          	on
***************
*** 148,151 ****
--- 153,157 ----
  set +o ignoreeof
  set -o interactive-comments
+ set +o nolog
  set +o posix
  set -o emacs
***************
*** 177,180 ****
--- 183,187 ----
  set +o xtrace
  set +o ignoreeof
+ set +o nolog
  set +o posix
  set +o vi
***************
*** 193,196 ****
--- 200,204 ----
  xtrace         	off
  ignoreeof      	off
+ nolog          	off
  posix          	off
  vi             	off
diff -Nrc2 bash-2.05/tests/trap.right bash-2.05a/tests/trap.right
*** bash-2.05/tests/trap.right	Mon Sep 25 11:59:04 2000
--- bash-2.05a/tests/trap.right	Wed May 23 12:50:26 2001
***************
*** 46,49 ****
--- 46,59 ----
  trap -- 'echo aborting' SIGTERM
  0
+ ERRTRAP
+ ERRTRAP
+ ERRTRAP
+ after falses
+ if negation ok
+ after negation
+ after while
+ before false in trap2a.sub
+ after false in trap2a.sub
+ command substitution
  caught a child death
  caught a child death
diff -Nrc2 bash-2.05/tests/trap.tests bash-2.05a/tests/trap.tests
*** bash-2.05/tests/trap.tests	Mon Sep 25 11:58:34 2000
--- bash-2.05a/tests/trap.tests	Wed May 23 12:48:46 2001
***************
*** 54,57 ****
--- 54,60 ----
  ./trap1.sub
  
+ # test ERR trap
+ ./trap2.sub
+ 
  #
  # show that setting a trap on SIGCHLD is not disastrous.
***************
*** 72,73 ****
--- 75,77 ----
  
  trap
+ 
diff -Nrc2 bash-2.05/tests/trap2.sub bash-2.05a/tests/trap2.sub
*** bash-2.05/tests/trap2.sub	Wed Dec 31 19:00:00 1969
--- bash-2.05a/tests/trap2.sub	Wed May 23 12:49:59 2001
***************
*** 0 ****
--- 1,25 ----
+ set +e
+ trap 'echo ERRTRAP' ERR
+ 
+ false
+ false
+ false
+ 
+ echo after falses
+ 
+ if ! false; then
+ 	echo if negation ok
+ fi
+ 
+ ! false
+ echo after negation 
+ 
+ while false; do
+ 	echo while negation ok
+ done
+ 
+ echo after while
+ 
+ ./trap2a.sub
+ 
+ echo $(false ; echo command substitution)
diff -Nrc2 bash-2.05/tests/trap2a.sub bash-2.05a/tests/trap2a.sub
*** bash-2.05/tests/trap2a.sub	Wed Dec 31 19:00:00 1969
--- bash-2.05a/tests/trap2a.sub	Wed May 23 12:49:24 2001
***************
*** 0 ****
--- 1,3 ----
+ echo before false in trap2a.sub
+ false
+ echo after false in trap2a.sub
diff -Nrc2 bash-2.05/trap.c bash-2.05a/trap.c
*** bash-2.05/trap.c	Wed Feb 14 17:00:48 2001
--- bash-2.05a/trap.c	Mon Sep 10 15:10:22 2001
***************
*** 53,65 ****
  #define SIG_IGNORED	0x40	/* The signal is currently being ignored. */
  
  /* An array of such flags, one for each signal, describing what the
     shell will do with a signal.  DEBUG_TRAP == NSIG; some code below
     assumes this. */
! static int sigmodes[NSIG+1];
  
! static void change_signal (), restore_signal ();
  
  /* Variables used here but defined in other files. */
- extern int interactive_shell, interactive;
  extern int interrupt_immediately;
  extern int last_command_exit_value;
--- 53,75 ----
  #define SIG_IGNORED	0x40	/* The signal is currently being ignored. */
  
+ #define SPECIAL_TRAP(s)	((s) == EXIT_TRAP || (s) == DEBUG_TRAP || (s) == ERROR_TRAP)
+ 
  /* An array of such flags, one for each signal, describing what the
     shell will do with a signal.  DEBUG_TRAP == NSIG; some code below
     assumes this. */
! static int sigmodes[BASH_NSIG];
! 
! static void free_trap_command __P((int));
! static void change_signal __P((int, char *));
! 
! static void get_original_signal __P((int));
! 
! static void _run_trap_internal __P((int, char *));
  
! static void reset_signal __P((int));
! static void restore_signal __P((int));
! static void reset_or_restore_signal_handlers __P((sh_resetsig_func_t *));
  
  /* Variables used here but defined in other files. */
  extern int interrupt_immediately;
  extern int last_command_exit_value;
***************
*** 74,78 ****
     you were so rudely interrupted, or IGNORE_SIG, which says ignore
     this signal. */
! char *trap_list[NSIG+1];
  
  /* A bitmap of signals received for which we have trap handlers. */
--- 84,88 ----
     you were so rudely interrupted, or IGNORE_SIG, which says ignore
     this signal. */
! char *trap_list[BASH_NSIG];
  
  /* A bitmap of signals received for which we have trap handlers. */
***************
*** 98,103 ****
    register int i;
  
!   trap_list[EXIT_TRAP] = trap_list[DEBUG_TRAP] = (char *)NULL;
!   sigmodes[EXIT_TRAP] = sigmodes[DEBUG_TRAP] = SIG_INHERITED;
    original_signals[EXIT_TRAP] = IMPOSSIBLE_TRAP_HANDLER;
  
--- 108,113 ----
    register int i;
  
!   trap_list[EXIT_TRAP] = trap_list[DEBUG_TRAP] = trap_list[ERROR_TRAP] = (char *)NULL;
!   sigmodes[EXIT_TRAP] = sigmodes[DEBUG_TRAP] = sigmodes[ERROR_TRAP] = SIG_INHERITED;
    original_signals[EXIT_TRAP] = IMPOSSIBLE_TRAP_HANDLER;
  
***************
*** 186,193 ****
  
    if (legal_number (string, &sig))
!     return ((sig >= 0 && sig <= NSIG) ? (int)sig : NO_SIG);
  
    /* A leading `SIG' may be omitted. */
!   for (sig = 0; sig <= NSIG; sig++)
      {
        if (signal_names[sig] == 0 || signal_names[sig][0] == '\0')
--- 196,203 ----
  
    if (legal_number (string, &sig))
!     return ((sig >= 0 && sig < NSIG) ? (int)sig : NO_SIG);
  
    /* A leading `SIG' may be omitted. */
!   for (sig = 0; sig < BASH_NSIG; sig++)
      {
        if (signal_names[sig] == 0 || signal_names[sig][0] == '\0')
***************
*** 261,266 ****
  		 trap_list[SIGTERM] == DEFAULT_SIG, because DEFAULT_SIG is
  		 usually 0x0. */
! 	      internal_warning ("run_pending_traps: bad value in trap_list[%d]: 0x%x",
! 				sig, (int)trap_list[sig]);
  	      if (trap_list[sig] == (char *)DEFAULT_SIG)
  		{
--- 271,276 ----
  		 trap_list[SIGTERM] == DEFAULT_SIG, because DEFAULT_SIG is
  		 usually 0x0. */
! 	      internal_warning ("run_pending_traps: bad value in trap_list[%d]: %p",
! 				sig, trap_list[sig]);
  	      if (trap_list[sig] == (char *)DEFAULT_SIG)
  		{
***************
*** 351,354 ****
--- 361,371 ----
  }
  
+ void
+ set_error_trap (command)
+      char *command;
+ {
+   set_signal (ERROR_TRAP, command);
+ }
+ 
  #ifdef INCLUDE_UNUSED
  void
***************
*** 403,407 ****
       char *string;
  {
!   if (sig == DEBUG_TRAP || sig == EXIT_TRAP)
      {
        change_signal (sig, savestring (string));
--- 420,424 ----
       char *string;
  {
!   if (SPECIAL_TRAP (sig))
      {
        change_signal (sig, savestring (string));
***************
*** 509,515 ****
       int sig;
  {
!   if (sig == DEBUG_TRAP || sig == EXIT_TRAP)
      {
!       if ((sig != DEBUG_TRAP) || (sigmodes[sig] & SIG_INPROGRESS) == 0)
  	free_trap_command (sig);
        trap_list[sig] = (char *)NULL;
--- 526,532 ----
       int sig;
  {
!   if (SPECIAL_TRAP (sig))
      {
!       if ((sig != DEBUG_TRAP && sig != ERROR_TRAP) || (sigmodes[sig] & SIG_INPROGRESS) == 0)
  	free_trap_command (sig);
        trap_list[sig] = (char *)NULL;
***************
*** 547,551 ****
       int sig;
  {
!   if ((sig == EXIT_TRAP || sig == DEBUG_TRAP) && ((sigmodes[sig] & SIG_IGNORED) == 0))
      {
        change_signal (sig, (char *)IGNORE_SIG);
--- 564,568 ----
       int sig;
  {
!   if (SPECIAL_TRAP (sig) && ((sigmodes[sig] & SIG_IGNORED) == 0))
      {
        change_signal (sig, (char *)IGNORE_SIG);
***************
*** 624,628 ****
  {
    char *trap_command, *old_trap;
!   int old_exit_value, old_line_number, *token_state;
  
    /* Run the trap only if SIG is trapped and not ignored, and we are not
--- 641,645 ----
  {
    char *trap_command, *old_trap;
!   int old_exit_value, *token_state;
  
    /* Run the trap only if SIG is trapped and not ignored, and we are not
***************
*** 668,671 ****
--- 685,695 ----
  }
  
+ void
+ run_error_trap ()
+ {
+   if ((sigmodes[ERROR_TRAP] & SIG_TRAPPED) && (sigmodes[ERROR_TRAP] & SIG_INPROGRESS) == 0)
+     _run_trap_internal (ERROR_TRAP, "error trap");
+ }
+ 
  /* Run a trap set on SIGINT.  This is called from throw_to_top_level (), and
     declared here to localize the trap functions. */
***************
*** 684,688 ****
    register int i;
  
!   for (i = 0; i < NSIG+1; i++)
      {
        free_trap_command (i);
--- 708,712 ----
    register int i;
  
!   for (i = 0; i < BASH_NSIG; i++)
      {
        free_trap_command (i);
***************
*** 690,694 ****
        sigmodes[i] &= ~SIG_TRAPPED;
      }
!   trap_list[DEBUG_TRAP] = trap_list[EXIT_TRAP] = (char *)NULL;
  }
  #endif
--- 714,718 ----
        sigmodes[i] &= ~SIG_TRAPPED;
      }
!   trap_list[DEBUG_TRAP] = trap_list[EXIT_TRAP] = trap_list[ERROR_TRAP] = (char *)NULL;
  }
  #endif
***************
*** 715,719 ****
  static void
  reset_or_restore_signal_handlers (reset)
!      VFunction *reset;
  {
    register int i;
--- 739,743 ----
  static void
  reset_or_restore_signal_handlers (reset)
!      sh_resetsig_func_t *reset;
  {
    register int i;
***************
*** 738,743 ****
--- 762,774 ----
  	(*reset) (i);
      }
+ 
+   /* Command substitution and other child processes don't inherit the
+      debug or error traps. */
+   sigmodes[DEBUG_TRAP] &= ~SIG_TRAPPED;  
+   sigmodes[ERROR_TRAP] &= ~SIG_TRAPPED;
  }
  
+ /* Reset trapped signals to their original values, but don't free the
+    trap strings.  Called by the command substitution code. */
  void
  reset_signal_handlers ()
***************
*** 774,777 ****
--- 805,811 ----
  	case DEBUG_TRAP:
  	  run_debug_trap ();
+ 	  break;
+ 	case ERROR_TRAP:
+ 	  run_error_trap ();
  	  break;
  	default:
diff -Nrc2 bash-2.05/trap.h bash-2.05a/trap.h
*** bash-2.05/trap.h	Thu Aug  5 07:15:32 1999
--- bash-2.05a/trap.h	Wed May 23 12:35:06 2001
***************
*** 39,46 ****
--- 39,54 ----
  /* Special shell trap names. */
  #define DEBUG_TRAP NSIG
+ #define ERROR_TRAP NSIG+1
  #define EXIT_TRAP 0
  
+ /* system signals plus special bash traps */
+ #define BASH_NSIG	NSIG+2
+ 
  #define signal_object_p(x) (decode_signal (x) != NO_SIG)
  
+ #define TRAP_STRING(s) \
+   (signal_is_trapped (s) && signal_is_ignored (s) == 0) ? trap_list[s] \
+ 							: (char *)NULL
+ 
  extern char *trap_list[];
  
***************
*** 51,54 ****
--- 59,63 ----
  extern void set_sigchld_trap __P((char *));
  extern void set_debug_trap __P((char *));
+ extern void set_error_trap __P((char *));
  extern void set_sigint_trap __P((char *));
  extern void set_signal __P((int, char *));
***************
*** 58,61 ****
--- 67,71 ----
  extern void run_trap_cleanup __P((int));
  extern void run_debug_trap __P((void));
+ extern void run_error_trap __P((void));
  extern void free_trap_strings __P((void));
  extern void reset_signal_handlers __P((void));
diff -Nrc2 bash-2.05/unwind_prot.c bash-2.05a/unwind_prot.c
*** bash-2.05/unwind_prot.c	Wed Feb 14 17:00:55 2001
--- bash-2.05a/unwind_prot.c	Thu Nov  8 08:15:54 2001
***************
*** 34,37 ****
--- 34,45 ----
  #endif
  
+ #if STDC_HEADERS
+ #  include <stddef.h>
+ #endif
+ 
+ #ifndef offsetof
+ #  define offsetof(TYPE, MEMBER) ((size_t) &((TYPE *)0)->MEMBER)
+ #endif
+ 
  #include "command.h"
  #include "general.h"
***************
*** 40,68 ****
  #include "sig.h"
  
! /* If CLEANUP is null, then ARG contains a tag to throw back to. */
! typedef struct _uwp {
!   struct _uwp *next;
!   Function *cleanup;
!   char *arg;
! } UNWIND_ELT;
! 
! /* Structure describing a saved variable and the value to restore it to.
!    If a cleanup function is set to restore_variable, the `arg' pointer
!    points to this. */
  typedef struct {
!   int *variable;
!   char *desired_setting;
    int size;
  } SAVED_VAR;
  
! static void without_interrupts ();
! static void unwind_frame_discard_internal ();
! static void unwind_frame_run_internal ();
! static void add_unwind_protect_internal ();
! static void remove_unwind_protect_internal ();
! static void run_unwind_protects_internal ();
! static void clear_unwind_protects_internal ();
! static void restore_variable ();
! static void discard_saved_var ();
  
  static UNWIND_ELT *unwind_protect_list = (UNWIND_ELT *)NULL;
--- 48,85 ----
  #include "sig.h"
  
! /* Structure describing a saved variable and the value to restore it to.  */
  typedef struct {
!   char *variable;
    int size;
+   char desired_setting[1]; /* actual size is `size' */
  } SAVED_VAR;
  
! /* If HEAD.CLEANUP is null, then ARG.V contains a tag to throw back to.
!    If HEAD.CLEANUP is restore_variable, then SV.V contains the saved
!    variable.  Otherwise, call HEAD.CLEANUP (ARG.V) to clean up.  */
! typedef union uwp {
!   struct uwp_head {
!     union uwp *next;
!     Function *cleanup;
!   } head;
!   struct {
!     struct uwp_head uwp_head;
!     char *v;
!   } arg;
!   struct {
!     struct uwp_head uwp_head;
!     SAVED_VAR v;
!   } sv;
! } UNWIND_ELT;
! 
! static void without_interrupts __P((VFunction *, char *, char *));
! static void unwind_frame_discard_internal __P((char *, char *));
! static void unwind_frame_run_internal __P((char *, char *));
! static void add_unwind_protect_internal __P((Function *, char *));
! static void remove_unwind_protect_internal __P((char *, char *));
! static void run_unwind_protects_internal __P((char *, char *));
! static void clear_unwind_protects_internal __P((char *, char *));
! static inline void restore_variable __P((SAVED_VAR *));
! static void unwind_protect_mem_internal __P((char *, char *));
  
  static UNWIND_ELT *unwind_protect_list = (UNWIND_ELT *)NULL;
***************
*** 146,152 ****
       int flags;
  {
    if (unwind_protect_list)
!     without_interrupts
!       (clear_unwind_protects_internal, (char *)flags, (char *)NULL);
  }
  
--- 163,174 ----
       int flags;
  {
+   char *flag;
+ 
    if (unwind_protect_list)
!     {
!       flag = flags ? "" : (char *)NULL;
!       without_interrupts
!         (clear_unwind_protects_internal, flag, (char *)NULL);
!     }
  }
  
***************
*** 165,171 ****
  
    elt = (UNWIND_ELT *)xmalloc (sizeof (UNWIND_ELT));
!   elt->cleanup = cleanup;
!   elt->arg = arg;
!   elt->next = unwind_protect_list;
    unwind_protect_list = elt;
  }
--- 187,193 ----
  
    elt = (UNWIND_ELT *)xmalloc (sizeof (UNWIND_ELT));
!   elt->head.next = unwind_protect_list;
!   elt->head.cleanup = cleanup;
!   elt->arg.v = arg;
    unwind_protect_list = elt;
  }
***************
*** 180,186 ****
    if (elt)
      {
!       unwind_protect_list = unwind_protect_list->next;
!       if (elt->cleanup && elt->cleanup == (Function *)restore_variable)
! 	discard_saved_var ((SAVED_VAR *)elt->arg);
        free (elt);
      }
--- 202,206 ----
    if (elt)
      {
!       unwind_protect_list = unwind_protect_list->head.next;
        free (elt);
      }
***************
*** 191,210 ****
       char *ignore1, *ignore2;
  {
!   UNWIND_ELT *t, *elt = unwind_protect_list;
! 
!   while (elt)
!    {
!       /* This function can be run at strange times, like when unwinding
! 	 the entire world of unwind protects.  Thus, we may come across
! 	 an element which is simply a label for a catch frame.  Don't call
! 	 the non-existant function. */
!       if (elt->cleanup)
! 	(*(elt->cleanup)) (elt->arg);
! 
!       t = elt;
!       elt = elt->next;
!       free (t);
!     }
!   unwind_protect_list = elt;
  }
  
--- 211,215 ----
       char *ignore1, *ignore2;
  {
!   unwind_frame_run_internal ((char *) NULL, (char *) NULL);
  }
  
***************
*** 213,220 ****
       char *flag, *ignore;
  {
!   int free_elts = (int)flag;
!   UNWIND_ELT *elt;
! 
!   if (free_elts != 0 && unwind_protect_list)
      {
        while (unwind_protect_list)
--- 218,222 ----
       char *flag, *ignore;
  {
!   if (flag)
      {
        while (unwind_protect_list)
***************
*** 232,246 ****
    while (elt = unwind_protect_list)
      {
!       unwind_protect_list = unwind_protect_list->next;
!       if (elt->cleanup == 0 && (STREQ (elt->arg, tag)))
  	{
  	  free (elt);
  	  break;
  	}
-       else if (elt->cleanup && elt->cleanup == (Function *)restore_variable)
- 	{
- 	  discard_saved_var ((SAVED_VAR *)elt->arg);
- 	  free (elt);
- 	}
        else
  	free (elt);
--- 234,243 ----
    while (elt = unwind_protect_list)
      {
!       unwind_protect_list = unwind_protect_list->head.next;
!       if (elt->head.cleanup == 0 && (STREQ (elt->arg.v, tag)))
  	{
  	  free (elt);
  	  break;
  	}
        else
  	free (elt);
***************
*** 248,251 ****
--- 245,258 ----
  }
  
+ /* Restore the value of a variable, based on the contents of SV.
+    sv->desired_setting is a block of memory SIZE bytes long holding the
+    value itself.  This block of memory is copied back into the variable. */
+ static inline void
+ restore_variable (sv)
+      SAVED_VAR *sv;
+ {
+   FASTCOPY (sv->desired_setting, sv->variable, sv->size);
+ }
+ 
  static void
  unwind_frame_run_internal (tag, ignore)
***************
*** 256,330 ****
    while (elt = unwind_protect_list)
      {
!       unwind_protect_list = elt->next;
  
        /* If tag, then compare. */
!       if (!elt->cleanup)
  	{
! 	  if (STREQ (elt->arg, tag))
  	    {
  	      free (elt);
  	      break;
  	    }
- 	  free (elt);
- 	  continue;
  	}
        else
  	{
! 	  (*(elt->cleanup)) (elt->arg);
! 	  free (elt);
  	}
      }
  }
  
  static void
! discard_saved_var (sv)
!      SAVED_VAR *sv;
  {
!   if (sv->size != sizeof (int))
!     free (sv->desired_setting);
!   free (sv);
! }
! 
! /* Restore the value of a variable, based on the contents of SV.  If
!    sv->size is greater than sizeof (int), sv->desired_setting points to
!    a block of memory SIZE bytes long holding the value, rather than the
!    value itself.  This block of memory is copied back into the variable. */
! static void
! restore_variable (sv)
!      SAVED_VAR *sv;
! {
!   if (sv->size != sizeof (int))
!     {
!       FASTCOPY ((char *)sv->desired_setting, (char *)sv->variable, sv->size);
!       free (sv->desired_setting);
!     }
!   else
!     *(sv->variable) = (int)sv->desired_setting;
  
!   free (sv);
  }
  
  /* Save the value of a variable so it will be restored when unwind-protects
!    are run.  VAR is a pointer to the variable.  VALUE is the value to be
!    saved.  SIZE is the size in bytes of VALUE.  If SIZE is bigger than what
!    can be saved in an int, memory will be allocated and the value saved
!    into that using bcopy (). */
  void
! unwind_protect_var (var, value, size)
!      int *var;
!      char *value;
       int size;
  {
!   SAVED_VAR *s = (SAVED_VAR *)xmalloc (sizeof (SAVED_VAR));
! 
!   s->variable = var;
!   if (size != sizeof (int))
!     {
!       s->desired_setting = (char *)xmalloc (size);
!       FASTCOPY (value, (char *)s->desired_setting, size);
!     }
!   else
!     s->desired_setting = value;
!   s->size = size;
!   add_unwind_protect ((Function *)restore_variable, (char *)s);
  }
--- 263,316 ----
    while (elt = unwind_protect_list)
      {
!       unwind_protect_list = elt->head.next;
  
        /* If tag, then compare. */
!       if (!elt->head.cleanup)
  	{
! 	  if (tag && STREQ (elt->arg.v, tag))
  	    {
  	      free (elt);
  	      break;
  	    }
  	}
        else
  	{
! 	  if (elt->head.cleanup == (Function *) restore_variable)
! 	    restore_variable (&elt->sv.v);
! 	  else
! 	    (*(elt->head.cleanup)) (elt->arg.v);
  	}
+ 
+       free (elt);
      }
  }
  
  static void
! unwind_protect_mem_internal (var, psize)
!      char *var;
!      char *psize;
  {
!   int size, allocated;
!   UNWIND_ELT *elt;
  
!   size = *(int *) psize;
!   allocated = size + offsetof (UNWIND_ELT, sv.v.desired_setting[0]);
!   elt = (UNWIND_ELT *)xmalloc (allocated);
!   elt->head.next = unwind_protect_list;
!   elt->head.cleanup = (Function *) restore_variable;
!   elt->sv.v.variable = var;
!   elt->sv.v.size = size;
!   FASTCOPY (var, elt->sv.v.desired_setting, size);
!   unwind_protect_list = elt;
  }
  
  /* Save the value of a variable so it will be restored when unwind-protects
!    are run.  VAR is a pointer to the variable.  SIZE is the size in
!    bytes of VAR.  */
  void
! unwind_protect_mem (var, size)
!      char *var;
       int size;
  {
!   without_interrupts (unwind_protect_mem_internal, var, (char *) &size);
  }
diff -Nrc2 bash-2.05/unwind_prot.h bash-2.05a/unwind_prot.h
*** bash-2.05/unwind_prot.h	Thu Feb  1 13:51:00 2001
--- bash-2.05a/unwind_prot.h	Tue May  8 08:30:00 2001
***************
*** 23,70 ****
  
  /* Run a function without interrupts. */
! extern void begin_unwind_frame ();
! extern void discard_unwind_frame ();
! extern void run_unwind_frame ();
! extern void add_unwind_protect ();
! extern void remove_unwind_protect ();
! extern void run_unwind_protects ();
! extern void unwind_protect_var ();
! extern void clear_unwind_protect_list ();
! 
! /* Try to force correct alignment on machines where pointers and ints
!    differ in size. */
! typedef union {
!   char *s;
!   int i;
! } UWP;
  
  /* Define for people who like their code to look a certain way. */
  #define end_unwind_frame()
  
! /* How to protect an integer. */
! #define unwind_protect_int(X) \
! 	do \
! 	  { \
! 	    UWP u; \
! 	    u.i = (X); \
! 	    unwind_protect_var (&(X), u.s, sizeof (int)); \
! 	  } \
! 	while (0)
! 
! #define unwind_protect_short(X) \
!   unwind_protect_var ((int *)&(X), (char *)&(X), sizeof (short))
! 
! /* How to protect a pointer to a string. */
! #define unwind_protect_string(X) \
!   unwind_protect_var ((int *)&(X), \
! 		      ((sizeof (char *) == sizeof (int)) ? (char *) (X) : (char *) &(X)), \
! 		       sizeof (char *))
! 
! /* How to protect any old pointer. */
! #define unwind_protect_pointer(X) unwind_protect_string (X)
! 
! /* How to protect the contents of a jmp_buf. */
! #define unwind_protect_jmp_buf(X) \
!   unwind_protect_var ((int *)(X), (char *)(X), sizeof (procenv_t))
  
  #endif /* _UNWIND_PROT_H */
--- 23,47 ----
  
  /* Run a function without interrupts. */
! extern void begin_unwind_frame __P((char *));
! extern void discard_unwind_frame __P((char *));
! extern void run_unwind_frame __P((char *));
! extern void add_unwind_protect (); /* Not portable to arbitrary C99 hosts.  */
! extern void remove_unwind_protect __P((void));
! extern void run_unwind_protects __P((void));
! extern void clear_unwind_protect_list __P((int));
  
  /* Define for people who like their code to look a certain way. */
  #define end_unwind_frame()
  
! /* How to protect a variable.  */
! #define unwind_protect_var(X) unwind_protect_mem ((char *)&(X), sizeof (X))
! extern void unwind_protect_mem __P((char *, int));
! 
! /* Backwards compatibility */
! #define unwind_protect_int	unwind_protect_var
! #define unwind_protect_short	unwind_protect_var
! #define unwind_protect_string	unwind_protect_var
! #define unwind_protect_pointer	unwind_protect_var
! #define unwind_protect_jmp_buf	unwind_protect_var
  
  #endif /* _UNWIND_PROT_H */
diff -Nrc2 bash-2.05/variables.c bash-2.05a/variables.c
*** bash-2.05/variables.c	Wed Feb 21 13:47:11 2001
--- bash-2.05a/variables.c	Mon Nov  5 09:55:34 2001
***************
*** 23,26 ****
--- 23,27 ----
  #include "bashtypes.h"
  #include "posixstat.h"
+ #include "posixtime.h"
  
  #if defined (qnx)
***************
*** 33,37 ****
  
  #include <stdio.h>
! #include <ctype.h>
  #include <pwd.h>
  #include "bashansi.h"
--- 34,38 ----
  
  #include <stdio.h>
! #include "chartypes.h"
  #include <pwd.h>
  #include "bashansi.h"
***************
*** 43,46 ****
--- 44,49 ----
  #include "mailcheck.h"
  #include "input.h"
+ #include "hashcmd.h"
+ #include "pathexp.h"
  
  #include "builtins/getopt.h"
***************
*** 65,70 ****
  /* Variables used here and defined in other files. */
  extern int posixly_correct;
! extern int variable_context, line_number;
! extern int interactive, interactive_shell, login_shell;
  extern int subshell_environment, indirection_level;
  extern int build_version, patch_level;
--- 68,72 ----
  /* Variables used here and defined in other files. */
  extern int posixly_correct;
! extern int line_number;
  extern int subshell_environment, indirection_level;
  extern int build_version, patch_level;
***************
*** 73,77 ****
  extern char *primary_prompt, *secondary_prompt;
  extern char *current_host_name;
! extern Function *this_shell_builtin;
  extern SHELL_VAR *this_shell_function;
  extern char *this_command_name;
--- 75,79 ----
  extern char *primary_prompt, *secondary_prompt;
  extern char *current_host_name;
! extern sh_builtin_func_t *this_shell_builtin;
  extern SHELL_VAR *this_shell_function;
  extern char *this_command_name;
***************
*** 109,113 ****
  
  /* The value of $$. */
! int dollar_dollar_pid;
  
  /* An array which is passed to commands as their environment.  It is
--- 111,115 ----
  
  /* The value of $$. */
! pid_t dollar_dollar_pid;
  
  /* An array which is passed to commands as their environment.  It is
***************
*** 129,142 ****
  
  /* Some forward declarations. */
! static void set_home_var ();
! static void set_shell_var ();
! static char *get_bash_name ();
! static void initialize_shell_level ();
! static void uidset ();
! static void initialize_dynamic_variables ();
! static void make_vers_array ();
! static void sbrand ();		/* set bash random number generator. */
! static int qsort_var_comp ();
! static SHELL_VAR *bind_tempenv_variable ();
  
  /* Make VAR be auto-exported.  VAR is a pointer to a SHELL_VAR. */
--- 131,170 ----
  
  /* Some forward declarations. */
! static void set_machine_vars __P((void));
! static void set_home_var __P((void));
! static void set_shell_var __P((void));
! static char *get_bash_name __P((void));
! static void initialize_shell_level __P((void));
! static void uidset __P((void));
! #if defined (ARRAY_VARS)
! static void make_vers_array __P((void));
! #endif
! static void initialize_dynamic_variables __P((void));
! 
! static void sbrand __P((unsigned long));		/* set bash random number generator. */
! 
! static int qsort_var_comp __P((SHELL_VAR **, SHELL_VAR **));
! static SHELL_VAR **all_vars __P((HASH_TABLE *));
! 
! static void free_variable_hash_data __P((PTR_T));
! static SHELL_VAR *new_shell_variable __P((const char *));
! 
! static SHELL_VAR *make_new_variable __P((const char *));
! 
! static int visible_var __P((SHELL_VAR *));
! static SHELL_VAR **_visible_names __P((HASH_TABLE *));
! static int visible_and_exported __P((SHELL_VAR *));
! #if defined (ARRAY_VARS)
! static int visible_array_vars __P((SHELL_VAR *));
! #endif
! 
! static inline char *mk_env_string __P((const char *, const char *));
! static SHELL_VAR *shell_var_from_env_string __P((const char *, char *, int));
! static SHELL_VAR *bind_name_in_env_array __P((const char *, char *, char **));
! static SHELL_VAR *find_name_in_env_array __P((const char *, char **));
! 
! static SHELL_VAR *bind_tempenv_variable __P((const char *, char *));
! static void dispose_temporary_vars __P((char ***));
! static void merge_env_array __P((char **));
  
  /* Make VAR be auto-exported.  VAR is a pointer to a SHELL_VAR. */
***************
*** 181,189 ****
  	 char_index == strlen (name) */
  
!       /* If exported function, define it now. */
        if (privmode == 0 && read_but_dont_execute == 0 && STREQN ("() {", string, 4))
  	{
  	  string_length = strlen (string);
! 	  temp_string = xmalloc (3 + string_length + char_index);
  
  	  strcpy (temp_string, name);
--- 209,218 ----
  	 char_index == strlen (name) */
  
!       /* If exported function, define it now.  Don't import functions from
!          the environment in privileged mode. */
        if (privmode == 0 && read_but_dont_execute == 0 && STREQN ("() {", string, 4))
  	{
  	  string_length = strlen (string);
! 	  temp_string = (char *)xmalloc (3 + string_length + char_index);
  
  	  strcpy (temp_string, name);
***************
*** 246,258 ****
  
    /* Remember this pid. */
!   dollar_dollar_pid = (int)getpid ();
  
    /* Now make our own defaults in case the vars that we think are
       important are missing. */
    temp_var = set_if_not ("PATH", DEFAULT_PATH_VALUE);
!   set_auto_export (temp_var);
  
    temp_var = set_if_not ("TERM", "dumb");
!   set_auto_export (temp_var);
  
  #if defined (qnx)
--- 275,291 ----
  
    /* Remember this pid. */
!   dollar_dollar_pid = getpid ();
  
    /* Now make our own defaults in case the vars that we think are
       important are missing. */
    temp_var = set_if_not ("PATH", DEFAULT_PATH_VALUE);
! #if 0
!   set_auto_export (temp_var);	/* XXX */
! #endif
  
    temp_var = set_if_not ("TERM", "dumb");
! #if 0
!   set_auto_export (temp_var);	/* XXX */
! #endif
  
  #if defined (qnx)
***************
*** 284,303 ****
  
    /* Magic machine types.  Pretty convenient. */
!   temp_var = set_if_not ("HOSTTYPE", HOSTTYPE);
!   set_auto_export (temp_var);
!   temp_var = set_if_not ("OSTYPE", OSTYPE);
!   set_auto_export (temp_var);
!   temp_var = set_if_not ("MACHTYPE", MACHTYPE);
!   set_auto_export (temp_var);
! 
!   temp_var = set_if_not ("HOSTNAME", current_host_name);
!   set_auto_export (temp_var);
  
    /* Default MAILCHECK for interactive shells.  Defer the creation of a
       default MAILPATH until the startup files are read, because MAIL
!      names a mail file if MAILCHECK is not set, and we should provide a
       default only if neither is set. */
    if (interactive_shell)
!     set_if_not ("MAILCHECK", "60");
  
    /* Do some things with shell level. */
--- 317,328 ----
  
    /* Magic machine types.  Pretty convenient. */
!   set_machine_vars ();
  
    /* Default MAILCHECK for interactive shells.  Defer the creation of a
       default MAILPATH until the startup files are read, because MAIL
!      names a mail file if MAILPATH is not set, and we should provide a
       default only if neither is set. */
    if (interactive_shell)
!     set_if_not ("MAILCHECK", posixly_correct ? "600" : "60");
  
    /* Do some things with shell level. */
***************
*** 358,362 ****
  
    /* Seed the random number generator. */
!   sbrand (dollar_dollar_pid + (long)shell_start_time);
  
    /* Handle some "special" variables that we may have inherited from a
--- 383,387 ----
  
    /* Seed the random number generator. */
!   sbrand (dollar_dollar_pid + shell_start_time);
  
    /* Handle some "special" variables that we may have inherited from a
***************
*** 379,382 ****
--- 404,418 ----
  #endif /* HISTORY */
  
+      /*
+       * 24 October 2001
+       *
+       * I'm tired of the arguing and bug reports.  Bash now leaves SSH_CLIENT
+       * and SSH2_CLIENT alone.  I'm going to rely on the shell_level check in
+       * isnetconn() to avoid running the startup files more often than wanted.
+       * That will, of course, only work if the user's login shell is bash, so
+       * I've made that behavior conditional on SSH_SOURCE_BASHRC being defined
+       * in config-top.h.
+       */
+ #if 0
    temp_var = find_variable ("SSH_CLIENT");
    if (temp_var && imported_p (temp_var))
***************
*** 391,394 ****
--- 427,431 ----
        array_needs_making = 1;
      }
+ #endif
  
    /* Get the user's real and effective user ids. */
***************
*** 399,402 ****
--- 436,451 ----
  }
  
+ static void
+ set_machine_vars ()
+ {
+   SHELL_VAR *temp_var;
+ 
+   temp_var = set_if_not ("HOSTTYPE", HOSTTYPE);
+   temp_var = set_if_not ("OSTYPE", OSTYPE);
+   temp_var = set_if_not ("MACHTYPE", MACHTYPE);
+ 
+   temp_var = set_if_not ("HOSTNAME", current_host_name);
+ }
+ 
  /* Set $HOME to the information in the password file if we didn't get
     it from the environment. */
***************
*** 420,424 ****
--- 469,475 ----
    if (temp_var == 0)
      temp_var = bind_variable ("HOME", sh_get_home_dir ());
+ #if 0
    VSETATTR (temp_var, att_exported);
+ #endif
  }
  
***************
*** 437,441 ****
--- 488,494 ----
        temp_var = bind_variable ("SHELL", current_user.shell);
      }
+ #if 0
    VSETATTR (temp_var, att_exported);
+ #endif
  }
  
***************
*** 463,467 ****
  	{
  	  len = strlen (cdir);
! 	  name = xmalloc (len + strlen (shell_name) + 1);
  	  strcpy (name, cdir);
  	  strcpy (name + len, shell_name + 1);
--- 516,520 ----
  	{
  	  len = strlen (cdir);
! 	  name = (char *)xmalloc (len + strlen (shell_name) + 1);
  	  strcpy (name, cdir);
  	  strcpy (name + len, shell_name + 1);
***************
*** 518,526 ****
  {
    char new_level[5], *old_SHLVL;
!   int old_level;
    SHELL_VAR *temp_var;
  
    old_SHLVL = get_string_value ("SHLVL");
!   old_level = old_SHLVL ? atoi (old_SHLVL) : 0;
  
    shell_level = old_level + change;
--- 571,580 ----
  {
    char new_level[5], *old_SHLVL;
!   long old_level;
    SHELL_VAR *temp_var;
  
    old_SHLVL = get_string_value ("SHLVL");
!   if (old_SHLVL == 0 || *old_SHLVL == '\0' || legal_number (old_SHLVL, &old_level) == 0)
!     old_level = 0;
  
    shell_level = old_level + change;
***************
*** 614,621 ****
  set_ppid ()
  {
!   char namebuf[32], *name;
    SHELL_VAR *temp_var;
  
!   name = inttostr ((int) getppid (), namebuf, sizeof(namebuf));
    temp_var = find_variable ("PPID");
    if (temp_var)
--- 668,675 ----
  set_ppid ()
  {
!   char namebuf[INT_STRLEN_BOUND(pid_t) + 1], *name;
    SHELL_VAR *temp_var;
  
!   name = inttostr (getppid (), namebuf, sizeof(namebuf));
    temp_var = find_variable ("PPID");
    if (temp_var)
***************
*** 628,632 ****
  uidset ()
  {
!   char buff[32], *b;
    register SHELL_VAR *v;
  
--- 682,686 ----
  uidset ()
  {
!   char buff[INT_STRLEN_BOUND(uid_t) + 1], *b;
    register SHELL_VAR *v;
  
***************
*** 656,660 ****
    SHELL_VAR *vv;
    ARRAY *av;
!   char *s, d[32];
  
    makunbound ("BASH_VERSINFO", shell_variables);
--- 710,714 ----
    SHELL_VAR *vv;
    ARRAY *av;
!   char *s, d[32], b[INT_STRLEN_BOUND(int) + 1];
  
    makunbound ("BASH_VERSINFO", shell_variables);
***************
*** 668,674 ****
    array_add_element (av, 0, d);
    array_add_element (av, 1, s);
!   s = inttostr (patch_level, d, sizeof (d));
    array_add_element (av, 2, s);
!   s = inttostr (build_version, d, sizeof (d));
    array_add_element (av, 3, s);
    array_add_element (av, 4, release_status);
--- 722,728 ----
    array_add_element (av, 0, d);
    array_add_element (av, 1, s);
!   s = inttostr (patch_level, b, sizeof (b));
    array_add_element (av, 2, s);
!   s = inttostr (build_version, b, sizeof (b));
    array_add_element (av, 3, s);
    array_add_element (av, 4, release_status);
***************
*** 685,689 ****
       int lines, cols;
  {
!   char val[32], *v;
  
    v = inttostr (lines, val, sizeof (val));
--- 739,743 ----
       int lines, cols;
  {
!   char val[INT_STRLEN_BOUND(int) + 1], *v;
  
    v = inttostr (lines, val, sizeof (val));
***************
*** 712,717 ****
  SHELL_VAR **
  map_over (function, var_hash_table)
!      Function *function;
!      HASH_TABLE* var_hash_table;
  {
    register int i;
--- 766,771 ----
  SHELL_VAR **
  map_over (function, var_hash_table)
!      sh_var_map_func_t *function;
!      HASH_TABLE *var_hash_table;
  {
    register int i;
***************
*** 748,752 ****
       SHELL_VAR **array;
  {
!   qsort (array, array_len ((char **)array), sizeof (SHELL_VAR *), qsort_var_comp);
  }
  
--- 802,806 ----
       SHELL_VAR **array;
  {
!   qsort (array, array_len ((char **)array), sizeof (SHELL_VAR *), (QSFUNC *)qsort_var_comp);
  }
  
***************
*** 770,774 ****
    SHELL_VAR **list;
  
!   list = map_over ((Function *)NULL, table);
    if (list /* && posixly_correct */)
      sort_variables (list);
--- 824,828 ----
    SHELL_VAR **list;
  
!   list = map_over ((sh_var_map_func_t *)NULL, table);
    if (list /* && posixly_correct */)
      sort_variables (list);
***************
*** 876,886 ****
    if (var->value)
      {
!       if (quote && sh_contains_shell_metas (var->value))
  	{
- #if 0
- 	  t = sh_single_quote (var->value);
- #else
  	  t = ansic_quote (var->value, 0, (int *)0);
! #endif
  	  printf ("%s", t);
  	  free (t);
--- 930,942 ----
    if (var->value)
      {
!       if (quote && posixly_correct == 0 && ansic_shouldquote (var->value))
  	{
  	  t = ansic_quote (var->value, 0, (int *)0);
! 	  printf ("%s", t);
! 	  free (t);
! 	}
!       else if (quote && sh_contains_shell_metas (var->value))
! 	{
! 	  t = sh_single_quote (var->value);
  	  printf ("%s", t);
  	  free (t);
***************
*** 901,927 ****
  }
  
- #if defined (ARRAY_VARS)
- void
- print_array_assignment (var, quoted)
-      SHELL_VAR *var;
-      int quoted;
- {
-   char *vstr;
- 
-   if (quoted)
-     vstr = quoted_array_assignment_string (array_cell (var));
-   else
-     vstr = array_to_assignment_string (array_cell (var));
- 
-   if (vstr == 0)
-     printf ("%s=%s\n", var->name, quoted ? "'()'" : "()");
-   else
-     {
-       printf ("%s=%s\n", var->name, vstr);
-       free (vstr);
-     }
- }
- #endif /* ARRAY_VARS */
- 
  /* **************************************************************** */
  /*								    */
--- 957,960 ----
***************
*** 961,964 ****
--- 994,1015 ----
     localized as possible.  */
  
+ #define INIT_DYNAMIC_VAR(var, val, gfunc, afunc) \
+   do \
+     { \
+       v = bind_variable (var, (val)); \
+       v->dynamic_value = gfunc; \
+       v->assign_func = afunc; \
+     } \
+   while (0)
+ 
+ #define INIT_DYNAMIC_ARRAY_VAR(var, gfunc, afunc) \
+   do \
+     { \
+       v = make_new_array_variable (var); \
+       v->dynamic_value = gfunc; \
+       v->assign_func = afunc; \
+     } \
+   while (0)
+ 
  static SHELL_VAR *
  null_assign (self, value)
***************
*** 973,977 ****
  null_array_assign (self, ind, value)
       SHELL_VAR *self;
!      int ind;
       char *value;
  {
--- 1024,1028 ----
  null_array_assign (self, ind, value)
       SHELL_VAR *self;
!      arrayind_t ind;
       char *value;
  {
***************
*** 990,994 ****
       char *value;
  {
!   seconds_value_assigned = strtol (value, (char **)NULL, 10);
    shell_start_time = NOW;
    return (self);
--- 1041,1046 ----
       char *value;
  {
!   if (legal_number (value, &seconds_value_assigned) == 0)
!     seconds_value_assigned = 0;
    shell_start_time = NOW;
    return (self);
***************
*** 1003,1007 ****
  
    time_since_start = NOW - shell_start_time;
!   p = itos((int) seconds_value_assigned + time_since_start);
  
    FREE (var->value);
--- 1055,1059 ----
  
    time_since_start = NOW - shell_start_time;
!   p = itos(seconds_value_assigned + time_since_start);
  
    FREE (var->value);
***************
*** 1012,1022 ****
  }
  
  /* The random number seed.  You can change this by setting RANDOM. */
  static unsigned long rseed = 1;
! static unsigned long last_random_value;
  
! /* A linear congruential random number generator based on the ANSI
!    C standard.  This one isn't very good (the values are alternately
!    odd and even, for example), but a more complicated one is overkill.  */
  
  /* Returns a pseudo-random number between 0 and 32767. */
--- 1064,1089 ----
  }
  
+ static SHELL_VAR *
+ init_seconds_var ()
+ {
+   SHELL_VAR *v;
+ 
+   v = find_variable ("SECONDS");
+   if (v)
+     {
+       if (legal_number (value_cell(v), &seconds_value_assigned) == 0)
+ 	seconds_value_assigned = 0;
+     }
+   INIT_DYNAMIC_VAR ("SECONDS", (v ? v->value : (char *)NULL), get_seconds, assign_seconds);
+   return v;      
+ }
+      
  /* The random number seed.  You can change this by setting RANDOM. */
  static unsigned long rseed = 1;
! static int last_random_value;
  
! /* A linear congruential random number generator based on the example
!    on in the ANSI C standard.  This one isn't very good, but a more
!    complicated one is overkill. */
  
  /* Returns a pseudo-random number between 0 and 32767. */
***************
*** 1025,1029 ****
  {
    rseed = rseed * 1103515245 + 12345;
!   return ((unsigned int)(rseed & 32767));	/* was % 32768 */
  }
  
--- 1092,1096 ----
  {
    rseed = rseed * 1103515245 + 12345;
!   return ((unsigned int)((rseed >> 16) & 32767));	/* was % 32768 */
  }
  
***************
*** 1031,1035 ****
  static void
  sbrand (seed)
!      int seed;
  {
    rseed = seed;
--- 1098,1102 ----
  static void
  sbrand (seed)
!      unsigned long seed;
  {
    rseed = seed;
***************
*** 1042,1046 ****
       char *value;
  {
!   sbrand (atoi (value));
    return (self);
  }
--- 1109,1113 ----
       char *value;
  {
!   sbrand (strtoul (value, (char **)NULL, 10));
    return (self);
  }
***************
*** 1053,1061 ****
    /* Reset for command and process substitution. */
    if (subshell_environment)
!     sbrand (rseed + (int)(getpid() + NOW));
  
    do
      rv = brand ();
!   while (rv == (int)last_random_value);
    return rv;
  }
--- 1120,1128 ----
    /* Reset for command and process substitution. */
    if (subshell_environment)
!     sbrand (rseed + getpid() + NOW);
  
    do
      rv = brand ();
!   while (rv == last_random_value);
    return rv;
  }
***************
*** 1070,1074 ****
    rv = get_random_number ();
    last_random_value = rv;
!   p = itos ((int)rv);
  
    FREE (var->value);
--- 1137,1141 ----
    rv = get_random_number ();
    last_random_value = rv;
!   p = itos (rv);
  
    FREE (var->value);
***************
*** 1099,1103 ****
       char *value;
  {
!   line_number = atoi (value);
    return var;
  }
--- 1166,1174 ----
       char *value;
  {
!   long new_value;
! 
!   if (value == 0 || *value == '\0' || legal_number (value, &new_value) == 0)
!     new_value = 0;
!   line_number = new_value;
    return var;
  }
***************
*** 1136,1140 ****
  assign_dirstack (self, ind, value)
       SHELL_VAR *self;
!      int ind;
       char *value;
  {
--- 1207,1211 ----
  assign_dirstack (self, ind, value)
       SHELL_VAR *self;
!      arrayind_t ind;
       char *value;
  {
***************
*** 1142,1145 ****
--- 1213,1228 ----
    return self;
  }
+ 
+ static SHELL_VAR *
+ init_dirstack_var ()
+ {
+   SHELL_VAR *v;
+ 
+   v = find_variable ("DIRSTACK");
+   if (v)
+     return v;
+   INIT_DYNAMIC_ARRAY_VAR ("DIRSTACK", get_dirstack, assign_dirstack);
+   return v;
+ }
  #endif /* PUSHD AND POPD && ARRAY_VARS */
  
***************
*** 1165,1168 ****
--- 1248,1264 ----
    return (self);
  }
+ 
+ static SHELL_VAR *
+ init_groups_var ()
+ {
+   SHELL_VAR *v;
+ 
+   v = find_variable ("GROUPS");
+   if (v)
+     return (v);
+   INIT_DYNAMIC_ARRAY_VAR ("GROUPS", get_groupset, null_array_assign);
+   VSETATTR (v, att_noassign);
+   return v;
+ }
  #endif /* ARRAY_VARS */
  
***************
*** 1195,1213 ****
  }
  
! #define INIT_DYNAMIC_VAR(var, val, gfunc, afunc) \
!   do \
!     { \
!       v = bind_variable (var, val); \
!       v->dynamic_value = gfunc; \
!       v->assign_func = afunc; \
!     } while (0)
  
! #define INIT_DYNAMIC_ARRAY_VAR(var, gfunc, afunc) \
!   do \
!     { \
!       v = make_new_array_variable (var); \
!       v->dynamic_value = gfunc; \
!       v->assign_func = afunc; \
!     } while (0)
  
  static void
--- 1291,1306 ----
  }
  
! static SHELL_VAR *
! init_funcname_var ()
! {
!   SHELL_VAR *v;
  
!   v = find_variable ("FUNCNAME");
!   if (v)
!     return v;
!   INIT_DYNAMIC_VAR ("FUNCNAME", (char *)NULL, get_funcname, null_assign);
!   VSETATTR (v, att_invisible|att_noassign);
!   return v;
! }
  
  static void
***************
*** 1216,1220 ****
    SHELL_VAR *v;
  
!   INIT_DYNAMIC_VAR ("SECONDS", (char *)NULL, get_seconds, assign_seconds);
    INIT_DYNAMIC_VAR ("RANDOM", (char *)NULL, get_random, assign_random);
    INIT_DYNAMIC_VAR ("LINENO", (char *)NULL, get_lineno, assign_lineno);
--- 1309,1314 ----
    SHELL_VAR *v;
  
!   v = init_seconds_var ();
! 
    INIT_DYNAMIC_VAR ("RANDOM", (char *)NULL, get_random, assign_random);
    INIT_DYNAMIC_VAR ("LINENO", (char *)NULL, get_lineno, assign_lineno);
***************
*** 1225,1238 ****
  
  #if defined (PUSHD_AND_POPD) && defined (ARRAY_VARS)
!   INIT_DYNAMIC_ARRAY_VAR ("DIRSTACK", get_dirstack, assign_dirstack);
  #endif /* PUSHD_AND_POPD && ARRAY_VARS */
  
  #if defined (ARRAY_VARS)
!   INIT_DYNAMIC_ARRAY_VAR ("GROUPS", get_groupset, null_array_assign);
!   VSETATTR (v, att_noassign);
  #endif
  
!   INIT_DYNAMIC_VAR ("FUNCNAME", (char *)NULL, get_funcname, null_assign);
!   VSETATTR (v, att_invisible|att_noassign);
  }
  
--- 1319,1330 ----
  
  #if defined (PUSHD_AND_POPD) && defined (ARRAY_VARS)
!   v = init_dirstack_var ();
  #endif /* PUSHD_AND_POPD && ARRAY_VARS */
  
  #if defined (ARRAY_VARS)
!   v = init_groups_var ();
  #endif
  
!   v = init_funcname_var ();
  }
  
***************
*** 1242,1246 ****
  SHELL_VAR *
  var_lookup (name, hashed_vars)
!      char *name;
       HASH_TABLE *hashed_vars;
  {
--- 1334,1338 ----
  SHELL_VAR *
  var_lookup (name, hashed_vars)
!      const char *name;
       HASH_TABLE *hashed_vars;
  {
***************
*** 1255,1259 ****
  SHELL_VAR *
  find_variable_internal (name, search_tempenv)
!      char *name;
       int search_tempenv;
  {
--- 1347,1351 ----
  SHELL_VAR *
  find_variable_internal (name, search_tempenv)
!      const char *name;
       int search_tempenv;
  {
***************
*** 1283,1287 ****
  SHELL_VAR *
  find_variable (name)
!      char *name;
  {
    return (find_variable_internal
--- 1375,1379 ----
  SHELL_VAR *
  find_variable (name)
!      const char *name;
  {
    return (find_variable_internal
***************
*** 1293,1297 ****
  SHELL_VAR *
  find_function (name)
!      char *name;
  {
    return (var_lookup (name, shell_functions));
--- 1385,1389 ----
  SHELL_VAR *
  find_function (name)
!      const char *name;
  {
    return (var_lookup (name, shell_functions));
***************
*** 1308,1312 ****
    SHELL_VAR *var;
  
!   var = find_variable ((char *)var_name);	/* XXX fix later */
  
    if (!var)
--- 1400,1404 ----
    SHELL_VAR *var;
  
!   var = find_variable (var_name);
  
    if (!var)
***************
*** 1331,1339 ****
  SHELL_VAR *
  make_local_variable (name)
!      char *name;
  {
    SHELL_VAR *new_var, *old_var;
    BUCKET_CONTENTS *elt;
-   int old_var_context;
  
    /* local foo; local foo;  is a no-op. */
--- 1423,1430 ----
  SHELL_VAR *
  make_local_variable (name)
!      const char *name;
  {
    SHELL_VAR *new_var, *old_var;
    BUCKET_CONTENTS *elt;
  
    /* local foo; local foo;  is a no-op. */
***************
*** 1353,1357 ****
      {
        if (readonly_p (old_var))
! 	builtin_error ("%s: readonly variable");
        return ((SHELL_VAR *)NULL);
      }
--- 1444,1448 ----
      {
        if (readonly_p (old_var))
! 	builtin_error ("%s: readonly variable", name);
        return ((SHELL_VAR *)NULL);
      }
***************
*** 1376,1380 ****
  
        new_var->name = savestring (name);
!       new_var->value = xmalloc (1);
        new_var->value[0] = '\0';
  
--- 1467,1471 ----
  
        new_var->name = savestring (name);
!       new_var->value = (char *)xmalloc (1);
        new_var->value[0] = '\0';
  
***************
*** 1430,1437 ****
  /* Create a new shell variable with name NAME and add it to the hash table
     of shell variables. */
! static
! SHELL_VAR *
  make_new_variable (name)
!      char *name;
  {
    SHELL_VAR *entry;
--- 1521,1527 ----
  /* Create a new shell variable with name NAME and add it to the hash table
     of shell variables. */
! static SHELL_VAR *
  make_new_variable (name)
!      const char *name;
  {
    SHELL_VAR *entry;
***************
*** 1507,1511 ****
        else
  	{
! 	  retval = xmalloc (1);
  	  retval[0] = '\0';
  	}
--- 1597,1601 ----
        else
  	{
! 	  retval = (char *)xmalloc (1);
  	  retval[0] = '\0';
  	}
***************
*** 1521,1532 ****
  SHELL_VAR *
  bind_variable (name, value)
!      char *name, *value;
  {
    char *newval;
    SHELL_VAR *entry, *tempenv_entry;
-   int found_in_tempenv;
  
    entry = (SHELL_VAR *)0;
-   found_in_tempenv = 0;
  
    /* If we have a temporary environment, look there first for the variable,
--- 1611,1621 ----
  SHELL_VAR *
  bind_variable (name, value)
!      const char *name;
!      char *value;
  {
    char *newval;
    SHELL_VAR *entry, *tempenv_entry;
  
    entry = (SHELL_VAR *)0;
  
    /* If we have a temporary environment, look there first for the variable,
***************
*** 1586,1597 ****
  	}
        else
  	{
  	  FREE (entry->value);
  	  entry->value = newval;
  	}
- #else
-       FREE (entry->value);
-       entry->value = newval;
- #endif
      }
  
--- 1675,1683 ----
  	}
        else
+ #endif
  	{
  	  FREE (entry->value);
  	  entry->value = newval;
  	}
      }
  
***************
*** 1666,1926 ****
  }
  
- #if defined (ARRAY_VARS)
- /* Convert a shell variable to an array variable.  The original value is
-    saved as array[0]. */
- SHELL_VAR *
- convert_var_to_array (var)
-      SHELL_VAR *var;
- {
-   char *oldval;
-   ARRAY *array;
- 
-   oldval = value_cell (var);
-   array = new_array ();
-   array_add_element (array, 0, oldval);
- 
-   FREE (value_cell (var));
-   var->value = (char *)array;
- 
-   INVALIDATE_EXPORTSTR (var);
- 
-   VSETATTR (var, att_array);
-   VUNSETATTR (var, att_invisible);
- 
-   return var;
- }
- 
- /* Perform an array assignment name[ind]=value.  If NAME already exists and
-    is not an array, and IND is 0, perform name=value instead.  If NAME exists
-    and is not an array, and IND is not 0, convert it into an array with the
-    existing value as name[0].
- 
-    If NAME does not exist, just create an array variable, no matter what
-    IND's value may be. */
- SHELL_VAR *
- bind_array_variable (name, ind, value)
-      char *name;
-      int ind;
-      char *value;
- {
-   SHELL_VAR *entry;
-   char *newval;
- 
-   entry = var_lookup (name, shell_variables);
- 
-   if (entry == (SHELL_VAR *) 0)
-     entry = make_new_array_variable (name);
-   else if (readonly_p (entry) || noassign_p (entry))
-     {
-       if (readonly_p (entry))
- 	report_error ("%s: readonly variable", name);
-       return (entry);
-     }
-   else if (array_p (entry) == 0)
-     entry = convert_var_to_array (entry);
- 
-   /* ENTRY is an array variable, and ARRAY points to the value. */
-   newval = make_variable_value (entry, value);
-   if (entry->assign_func)
-     (*entry->assign_func) (entry, ind, newval);
-   else
-     array_add_element (array_cell (entry), ind, newval);
-   FREE (newval);
- 
-   return (entry);
- }
- 
- /* Perform a compound assignment statement for array NAME, where VALUE is
-    the text between the parens:  NAME=( VALUE ) */
  SHELL_VAR *
! assign_array_from_string (name, value)
!      char *name, *value;
  {
!   SHELL_VAR *var;
! 
!   var = find_variable (name);
!   if (var == 0)
!     var = make_new_array_variable (name);
!   else if (readonly_p (var) || noassign_p (var))
!     {
!       if (readonly_p (var))
! 	report_error ("%s: readonly variable", name);
!       return ((SHELL_VAR *)NULL);
!     }
!   else if (array_p (var) == 0)
!     var = convert_var_to_array (var);
! 
!   return (assign_array_var_from_string (var, value));
! }
! 
! SHELL_VAR *
! assign_array_var_from_word_list (var, list)
!      SHELL_VAR *var;
!      WORD_LIST *list;
! {
!   register int i;
!   register WORD_LIST *l;
!   ARRAY *a;
! 
!   for (a = array_cell (var), l = list, i = 0; l; l = l->next, i++)
!     if (var->assign_func)
!       (*var->assign_func) (var, i, l->word->word);
!     else
!       array_add_element (a, i, l->word->word);
!   return var;
! }
! 
! /* For each word in a compound array assignment, if the word looks like
!    [ind]=value, quote the `[' and `]' before the `=' to protect them from
!    unwanted filename expansion. */
! static void
! quote_array_assignment_chars (list)
!      WORD_LIST *list;
! {
!   char *s, *t, *nword;
!   int saw_eq;
!   WORD_LIST *l;
! 
!   for (l = list; l; l = l->next)
!     {
!       if (l->word == 0 || l->word->word == 0 || l->word->word[0] == '\0')
! 	continue;	/* should not happen, but just in case... */
!       /* Don't bother if it doesn't look like [ind]=value */
!       if (l->word->word[0] != '[' || strchr (l->word->word, '=') == 0) /* ] */
! 	continue;
!       s = nword = xmalloc (strlen (l->word->word) * 2 + 1);
!       saw_eq = 0;
!       for (t = l->word->word; *t; )
! 	{
! 	  if (*t == '=')
! 	    saw_eq = 1;
! 	  if (saw_eq == 0 && (*t == '[' || *t == ']'))
! 	    *s++ = '\\';
! 	  *s++ = *t++;
! 	}
!       *s = '\0';
!       free (l->word->word);
!       l->word->word = nword;
!     }
! }
! 
! /* Perform a compound array assignment:  VAR->name=( VALUE ).  The
!    VALUE has already had the parentheses stripped. */
! SHELL_VAR *
! assign_array_var_from_string (var, value)
!      SHELL_VAR *var;
!      char *value;
! {
!   ARRAY *a;
!   WORD_LIST *list, *nlist;
!   char *w, *val, *nval;
!   int ni, len, ind, last_ind;
! 
!   if (value == 0)
!     return var;
! 
!   /* If this is called from declare_builtin, value[0] == '(' and
!      strchr(value, ')') != 0.  In this case, we need to extract
!      the value from between the parens before going on. */
!   if (*value == '(')	/*)*/
!     {
!       ni = 1;
!       val = extract_array_assignment_list (value, &ni);
!       if (val == 0)
! 	return var;
!     }
!   else
!     val = value;
! 
!   /* Expand the value string into a list of words, performing all the
!      shell expansions including pathname generation and word splitting. */
!   /* First we split the string on whitespace, using the shell parser
!      (ksh93 seems to do this). */
!   list = parse_string_to_word_list (val, "array assign");
! 
!   /* If we're using [subscript]=value, we need to quote each [ and ] to
!      prevent unwanted filename expansion. */
!   if (list)
!     quote_array_assignment_chars (list);
! 
!   /* Now that we've split it, perform the shell expansions on each
!      word in the list. */
!   nlist = list ? expand_words_no_vars (list) : (WORD_LIST *)NULL;
! 
!   dispose_words (list);
  
!   if (val != value)
!     free (val);
! 
!   a = array_cell (var);
! 
!   /* Now that we are ready to assign values to the array, kill the existing
!      value. */
!   if (a)
!     empty_array (a);
! 
!   for (last_ind = 0, list = nlist; list; list = list->next)
!     {
!       w = list->word->word;
! 
!       /* We have a word of the form [ind]=value */
!       if (w[0] == '[')
! 	{
! 	  len = skipsubscript (w, 0);
! 
! 	  if (w[len] != ']' || w[len+1] != '=')
! 	    {
! 	      nval = make_variable_value (var, w);
! 	      if (var->assign_func)
! 		(*var->assign_func) (var, last_ind, nval);
! 	      else
! 		array_add_element (a, last_ind, nval);
! 	      FREE (nval);
! 	      last_ind++;
! 	      continue;
! 	    }
! 
! 	  if (len == 1)
! 	    {
! 	      report_error ("%s: bad array subscript", w);
! 	      continue;
! 	    }
! 
! 	  if (ALL_ELEMENT_SUB (w[1]) && len == 2)
! 	    {
! 	      report_error ("%s: cannot assign to non-numeric index", w);
! 	      continue;
! 	    }
! 
! 	  ind = array_expand_index (w + 1, len);
! 	  if (ind < 0)
! 	    {
! 	      report_error ("%s: bad array subscript", w);
! 	      continue;
! 	    }
! 	  last_ind = ind;
! 	  val = w + len + 2;
! 	}
!       else		/* No [ind]=value, just a stray `=' */
! 	{
! 	  ind = last_ind;
! 	  val = w;
! 	}
! 
!       if (integer_p (var))
! 	this_command_name = (char *)NULL;	/* no command name for errors */
!       nval = make_variable_value (var, val);
!       if (var->assign_func)
! 	(*var->assign_func) (var, ind, nval);
!       else
! 	array_add_element (a, ind, nval);
!       FREE (nval);
!       last_ind++;
!     }
! 
!   dispose_words (nlist);
!   return (var);
  }
- #endif /* ARRAY_VARS */
  
  /* Dispose of the information attached to VAR. */
--- 1752,1765 ----
  }
  
  SHELL_VAR *
! bind_var_to_int (var, val)
!      char *var;
!      long val;
  {
!   char ibuf[INT_STRLEN_BOUND (long) + 1], *p;
  
!   p = fmtulong (val, 10, ibuf, sizeof (ibuf), 0);
!   return (bind_int_variable (var, p));
  }
  
  /* Dispose of the information attached to VAR. */
***************
*** 1951,1995 ****
  }
  
- #if defined (ARRAY_VARS)
- /* This function is called with SUB pointing to just after the beginning
-    `[' of an array subscript. */
- int
- unbind_array_element (var, sub)
-      SHELL_VAR *var;
-      char *sub;
- {
-   int len, ind;
-   ARRAY_ELEMENT *ae;
- 
-   len = skipsubscript (sub, 0);
-   if (sub[len] != ']' || len == 0)
-     {
-       builtin_error ("%s[%s: bad array subscript", var->name, sub);
-       return -1;
-     }
-   sub[len] = '\0';
- 
-   if (ALL_ELEMENT_SUB (sub[0]) && sub[1] == 0)
-     {
-       makunbound (var->name, shell_variables);
-       return (0);
-     }
-   ind = array_expand_index (sub, len+1);
-   if (ind < 0)
-     {
-       builtin_error ("[%s]: bad array subscript", sub);
-       return -1;
-     }
-   ae = array_delete_element (array_cell (var), ind);
-   if (ae)
-     destroy_array_element (ae);
-   return 0;
- }
- #endif
- 
  /* Unset the variable referenced by NAME. */
  int
  unbind_variable (name)
!      char *name;
  {
    SHELL_VAR *var;
--- 1790,1797 ----
  }
  
  /* Unset the variable referenced by NAME. */
  int
  unbind_variable (name)
!      const char *name;
  {
    SHELL_VAR *var;
***************
*** 2021,2025 ****
  int
  makunbound (name, hash_list)
!      char *name;
       HASH_TABLE *hash_list;
  {
--- 1823,1827 ----
  int
  makunbound (name, hash_list)
!      const char *name;
       HASH_TABLE *hash_list;
  {
***************
*** 2091,2095 ****
  int
  kill_local_variable (name)
!      char *name;
  {
    SHELL_VAR *temp;
--- 1893,1897 ----
  int
  kill_local_variable (name)
!      const char *name;
  {
    SHELL_VAR *temp;
***************
*** 2153,2157 ****
  static void
  free_variable_hash_data (data)
!      char *data;
  {
    SHELL_VAR *var, *prev;
--- 1955,1959 ----
  static void
  free_variable_hash_data (data)
!      PTR_T data;
  {
    SHELL_VAR *var, *prev;
***************
*** 2176,2180 ****
  static SHELL_VAR *
  new_shell_variable (name)
!      char *name;
  {
    SHELL_VAR *var;
--- 1978,1982 ----
  static SHELL_VAR *
  new_shell_variable (name)
!      const char *name;
  {
    SHELL_VAR *var;
***************
*** 2191,2195 ****
  SHELL_VAR *
  bind_function (name, value)
!      char *name;
       COMMAND *value;
  {
--- 1993,1997 ----
  SHELL_VAR *
  bind_function (name, value)
!      const char *name;
       COMMAND *value;
  {
***************
*** 2306,2310 ****
  void
  set_func_read_only (name)
!      char *name;
  {
    SHELL_VAR *entry;
--- 2108,2112 ----
  void
  set_func_read_only (name)
!      const char *name;
  {
    SHELL_VAR *entry;
***************
*** 2330,2334 ****
  void
  set_func_auto_export (name)
!      char *name;
  {
    SHELL_VAR *entry;
--- 2132,2136 ----
  void
  set_func_auto_export (name)
!      const char *name;
  {
    SHELL_VAR *entry;
***************
*** 2340,2371 ****
  #endif
  
- #if defined (ARRAY_VARS)
- /* This function assumes s[i] == '['; returns with s[ret] == ']' if
-    an array subscript is correctly parsed. */
- int
- skipsubscript (s, i)
-      char *s;
-      int i;
- {
-   int count, c;
- 
-   for (count = 1; count && (c = s[++i]); )
-     {
-       if (c == '[')
- 	count++;
-       else if (c == ']')
- 	count--;
-     }
-   return i;
- }
- #endif /* ARRAY_VARS */
- 
  /* Returns non-zero if STRING is an assignment statement.  The returned value
     is the index of the `=' sign. */
  int
  assignment (string)
!      char *string;
  {
!   register int c, newi, indx;
  
    c = string[indx = 0];
--- 2142,2153 ----
  #endif
  
  /* Returns non-zero if STRING is an assignment statement.  The returned value
     is the index of the `=' sign. */
  int
  assignment (string)
!      const char *string;
  {
!   register unsigned char c;
!   register int newi, indx;
  
    c = string[indx = 0];
***************
*** 2477,2481 ****
  char **
  all_variables_matching_prefix (prefix)
!      char *prefix;
  {
    SHELL_VAR **varlist;
--- 2259,2263 ----
  char **
  all_variables_matching_prefix (prefix)
!      const char *prefix;
  {
    SHELL_VAR **varlist;
***************
*** 2503,2507 ****
  static inline char *
  mk_env_string (name, value)
!      char *name, *value;
  {
    int name_len, value_len;
--- 2285,2289 ----
  static inline char *
  mk_env_string (name, value)
!      const char *name, *value;
  {
    int name_len, value_len;
***************
*** 2510,2514 ****
    name_len = strlen (name);
    value_len = STRLEN (value);
!   p = xmalloc (2 + name_len + value_len);
    strcpy (p, name);
    p[name_len] = '=';
--- 2292,2296 ----
    name_len = strlen (name);
    value_len = STRLEN (value);
!   p = (char *)xmalloc (2 + name_len + value_len);
    strcpy (p, name);
    p[name_len] = '=';
***************
*** 2520,2523 ****
--- 2302,2306 ----
  }
  
+ #ifdef DEBUG
  /* Debugging */
  static int
***************
*** 2528,2532 ****
  
    s = v->exportstr;
!   if (legal_variable_starter (*s) == 0)
      {
        internal_error ("invalid character %d in exportstr for %s", *s, v->name);
--- 2311,2315 ----
  
    s = v->exportstr;
!   if (legal_variable_starter ((unsigned char)*s) == 0)
      {
        internal_error ("invalid character %d in exportstr for %s", *s, v->name);
***************
*** 2537,2541 ****
        if (*s == '=')
  	break;
!       if (legal_variable_char (*s) == 0)
  	{
  	  internal_error ("invalid character %d in exportstr for %s", *s, v->name);
--- 2320,2324 ----
        if (*s == '=')
  	break;
!       if (legal_variable_char ((unsigned char)*s) == 0)
  	{
  	  internal_error ("invalid character %d in exportstr for %s", *s, v->name);
***************
*** 2550,2553 ****
--- 2333,2337 ----
    return (1);
  }
+ #endif
  
  /* Make an array of assignment statements from the hash table
***************
*** 2625,2634 ****
  int
  assign_in_env (string)
!      char *string;
  {
    int size, offset;
    char *name, *temp, *value;
-   int nlen, vlen;
-   WORD_LIST *list;
    SHELL_VAR *var;
  
--- 2409,2416 ----
  int
  assign_in_env (string)
!      const char *string;
  {
    int size, offset;
    char *name, *temp, *value;
    SHELL_VAR *var;
  
***************
*** 2653,2662 ****
        temp = (strchr (temp, '~') != 0) ? bash_tilde_expand (temp) : savestring (temp);
  
!       list = expand_string_unsplit (temp, 0);
!       value = string_list (list);
! 
!       if (list)
! 	dispose_words (list);
! 
        free (temp);
      }
--- 2435,2439 ----
        temp = (strchr (temp, '~') != 0) ? bash_tilde_expand (temp) : savestring (temp);
  
!       value = expand_string_unsplit_to_string (temp, 0);
        free (temp);
      }
***************
*** 2696,2700 ****
  static SHELL_VAR *
  shell_var_from_env_string (name, env_string, l)
!      char *name, *env_string;
       int l;
  {
--- 2473,2478 ----
  static SHELL_VAR *
  shell_var_from_env_string (name, env_string, l)
!      const char *name;
!      char *env_string;
       int l;
  {
***************
*** 2726,2734 ****
  static SHELL_VAR *
  bind_name_in_env_array (name, value, array)
!      char *name, *value;
       char **array;
  {
    register int i, l;
!   char *new_env_string, *w;
    SHELL_VAR *temp;
  
--- 2504,2513 ----
  static SHELL_VAR *
  bind_name_in_env_array (name, value, array)
!      const char *name;
!      char *value;
       char **array;
  {
    register int i, l;
!   char *new_env_string;
    SHELL_VAR *temp;
  
***************
*** 2758,2762 ****
  static SHELL_VAR *
  find_name_in_env_array (name, array)
!      char *name;
       char **array;
  {
--- 2537,2541 ----
  static SHELL_VAR *
  find_name_in_env_array (name, array)
!      const char *name;
       char **array;
  {
***************
*** 2794,2798 ****
  static SHELL_VAR *
  bind_tempenv_variable (name, value)
!      char *name, *value;
  {
    SHELL_VAR *var;
--- 2573,2578 ----
  static SHELL_VAR *
  bind_tempenv_variable (name, value)
!      const char *name;
!      char *value;
  {
    SHELL_VAR *var;
***************
*** 2823,2827 ****
  SHELL_VAR *
  find_tempenv_variable (name)
!      char *name;
  {
    SHELL_VAR *var;
--- 2603,2607 ----
  SHELL_VAR *
  find_tempenv_variable (name)
!      const char *name;
  {
    SHELL_VAR *var;
***************
*** 2924,2927 ****
--- 2704,2708 ----
  }
  
+ #ifdef INCLUDE_UNUSED
  int
  any_temporary_variables ()
***************
*** 2929,2932 ****
--- 2710,2714 ----
    return (temporary_env || function_env);
  }
+ #endif
  
  /* Add ENVSTR to the end of the exported environment, EXPORT_ENV. */
***************
*** 3014,3018 ****
--- 2796,2805 ----
  	}
  
+ #if defined (RESTRICTED_SHELL)
+       /* Restricted shells may not export shell functions. */
+       temp_array = restricted ? (char **)0 : make_var_array (shell_functions);
+ #else
        temp_array = make_var_array (shell_functions);
+ #endif
        if (temp_array)
  	{
***************
*** 3061,3065 ****
    char *evar;
  
!   evar = xmalloc (STRLEN (value) + preflen + 1);
    strcpy (evar, env_prefix);
    if (value)
--- 2848,2852 ----
    char *evar;
  
!   evar = (char *)xmalloc (STRLEN (value) + preflen + 1);
    strcpy (evar, env_prefix);
    if (value)
***************
*** 3079,3083 ****
  void
  put_gnu_argv_flags_into_env (pid, flags_string)
!      int pid;
       char *flags_string;
  {
--- 2866,2870 ----
  void
  put_gnu_argv_flags_into_env (pid, flags_string)
!      long pid;
       char *flags_string;
  {
***************
*** 3090,3094 ****
    fl = strlen (flags_string);
  
!   dummy = xmalloc (l + fl + 30);
    dummy[0] = '_';
    strcpy (dummy + 1, pbuf);
--- 2877,2881 ----
    fl = strlen (flags_string);
  
!   dummy = (char *)xmalloc (l + fl + 30);
    dummy[0] = '_';
    strcpy (dummy + 1, pbuf);
***************
*** 3154,3158 ****
  struct name_and_function {
    char *name;
!   VFunction *function;
  } special_vars[] = {
    { "PATH", sv_path },
--- 2941,2945 ----
  struct name_and_function {
    char *name;
!   sh_sv_func_t *function;
  } special_vars[] = {
    { "PATH", sv_path },
***************
*** 3202,3206 ****
  #endif
  
!   { (char *)0, (VFunction *)0 }
  };
  
--- 2989,2993 ----
  #endif
  
!   { (char *)0, (sh_sv_func_t *)0 }
  };
  
***************
*** 3478,3482 ****
    ARRAY *a;
    register int i;
!   char *t, tbuf[16];
  
    v = find_variable ("PIPESTATUS");
--- 3265,3269 ----
    ARRAY *a;
    register int i;
!   char *t, tbuf[INT_STRLEN_BOUND(int) + 1];
  
    v = find_variable ("PIPESTATUS");
diff -Nrc2 bash-2.05/variables.h bash-2.05a/variables.h
*** bash-2.05/variables.h	Wed Feb 21 11:38:19 2001
--- bash-2.05a/variables.h	Tue Oct 23 08:47:46 2001
***************
*** 28,52 ****
  #include "hashlib.h"
  
! /* Placeholder for future modifications if cross-compiling or building a
!    `fat' binary, e.g. on Apple Rhapsody.  These values are used in multiple
!    files, so they appear here. */
! #if !defined (RHAPSODY)
! #  define HOSTTYPE	CONF_HOSTTYPE
! #  define OSTYPE	CONF_OSTYPE
! #  define MACHTYPE	CONF_MACHTYPE
! #else /* RHAPSODY */
! #  if   defined(__powerpc__) || defined(__ppc__)
! #    define HOSTTYPE "powerpc"
! #  elif defined(__i386__)
! #    define HOSTTYPE "i386"
! #  else
! #    define HOSTTYPE CONF_HOSTTYPE
! #  endif
! 
! #  define OSTYPE CONF_OSTYPE
! #  define VENDOR CONF_VENDOR
! 
! #  define MACHTYPE HOSTTYPE "-" VENDOR "-" OSTYPE
! #endif /* RHAPSODY */
  
  /* What a shell variable looks like. */
--- 28,32 ----
  #include "hashlib.h"
  
! #include "conftypes.h"
  
  /* What a shell variable looks like. */
***************
*** 106,109 ****
--- 86,94 ----
  #define VUNSETATTR(var, attr)	((var)->attributes &= ~(attr))
  
+ #define VGETFLAGS(var)		((var)->attributes)
+ 
+ #define VSETFLAGS(var, flags)	((var)->attributes = (flags))
+ #define VCLRFLAGS(var)		((var)->attributes = 0)
+ 
  /* Macros to perform various operations on `exportstr' member of a SHELL_VAR. */
  #define CLEAR_EXPORTSTR(var)	(var)->exportstr = (char *)NULL
***************
*** 146,149 ****
--- 131,136 ----
  	
  /* Stuff for hacking variables. */
+ typedef int sh_var_map_func_t __P((SHELL_VAR *));
+ 
  extern int variable_context;
  extern HASH_TABLE *shell_variables, *shell_functions;
***************
*** 162,175 ****
  extern void make_funcname_visible __P((int));
  
! extern SHELL_VAR *find_function __P((char *));
! extern SHELL_VAR *find_variable __P((char *));
! extern SHELL_VAR *find_variable_internal __P((char *, int));
! extern SHELL_VAR *find_tempenv_variable __P((char *));
  extern SHELL_VAR *copy_variable __P((SHELL_VAR *));
! extern SHELL_VAR *make_local_variable __P((char *));
! extern SHELL_VAR *bind_variable __P((char *, char *));
! extern SHELL_VAR *bind_function __P((char *, COMMAND *));
  
! extern SHELL_VAR **map_over __P((Function *, HASH_TABLE *));
  extern SHELL_VAR **all_shell_variables __P((void));
  extern SHELL_VAR **all_shell_functions __P((void));
--- 149,164 ----
  extern void make_funcname_visible __P((int));
  
! extern SHELL_VAR *var_lookup __P((const char *, HASH_TABLE *));
! 
! extern SHELL_VAR *find_function __P((const char *));
! extern SHELL_VAR *find_variable __P((const char *));
! extern SHELL_VAR *find_variable_internal __P((const char *, int));
! extern SHELL_VAR *find_tempenv_variable __P((const char *));
  extern SHELL_VAR *copy_variable __P((SHELL_VAR *));
! extern SHELL_VAR *make_local_variable __P((const char *));
! extern SHELL_VAR *bind_variable __P((const char *, char *));
! extern SHELL_VAR *bind_function __P((const char *, COMMAND *));
  
! extern SHELL_VAR **map_over __P((sh_var_map_func_t *, HASH_TABLE *));
  extern SHELL_VAR **all_shell_variables __P((void));
  extern SHELL_VAR **all_shell_functions __P((void));
***************
*** 181,185 ****
  #endif
  
! extern char **all_variables_matching_prefix __P((char *));
  
  extern char **make_var_array __P((HASH_TABLE *));
--- 170,174 ----
  #endif
  
! extern char **all_variables_matching_prefix __P((const char *));
  
  extern char **make_var_array __P((HASH_TABLE *));
***************
*** 191,201 ****
  extern SHELL_VAR *bind_variable_value __P((SHELL_VAR *, char *));
  extern SHELL_VAR *bind_int_variable __P((char *, char *));
  
! extern int assignment __P((char *));
  extern int variable_in_context __P((SHELL_VAR *));
! extern int assign_in_env __P((char *));
! extern int unbind_variable __P((char *));
! extern int makunbound __P((char *, HASH_TABLE *));
! extern int kill_local_variable __P((char *));
  extern void delete_all_variables __P((HASH_TABLE *));
  
--- 180,191 ----
  extern SHELL_VAR *bind_variable_value __P((SHELL_VAR *, char *));
  extern SHELL_VAR *bind_int_variable __P((char *, char *));
+ extern SHELL_VAR *bind_var_to_int __P((char *, long));
  
! extern int assignment __P((const char *));
  extern int variable_in_context __P((SHELL_VAR *));
! extern int assign_in_env __P((const char *));
! extern int unbind_variable __P((const char *));
! extern int makunbound __P((const char *, HASH_TABLE *));
! extern int kill_local_variable __P((const char *));
  extern void delete_all_variables __P((HASH_TABLE *));
  
***************
*** 211,222 ****
  extern void kill_all_local_variables __P((void));
  extern void set_var_read_only __P((char *));
! extern void set_func_read_only __P((char *));
  extern void set_var_auto_export __P((char *));
! extern void set_func_auto_export __P((char *));
  extern void sort_variables __P((SHELL_VAR **));
  extern void maybe_make_export_env __P((void));
  extern void update_export_env_inplace __P((char *, int, char *));
  extern void put_command_name_into_env __P((char *));
! extern void put_gnu_argv_flags_into_env __P((int, char *));
  extern void print_var_list __P((SHELL_VAR **));
  extern void print_func_list __P((SHELL_VAR **));
--- 201,212 ----
  extern void kill_all_local_variables __P((void));
  extern void set_var_read_only __P((char *));
! extern void set_func_read_only __P((const char *));
  extern void set_var_auto_export __P((char *));
! extern void set_func_auto_export __P((const char *));
  extern void sort_variables __P((SHELL_VAR **));
  extern void maybe_make_export_env __P((void));
  extern void update_export_env_inplace __P((char *, int, char *));
  extern void put_command_name_into_env __P((char *));
! extern void put_gnu_argv_flags_into_env __P((long, char *));
  extern void print_var_list __P((SHELL_VAR **));
  extern void print_func_list __P((SHELL_VAR **));
***************
*** 230,241 ****
  extern SHELL_VAR *make_new_array_variable __P((char *));
  extern SHELL_VAR *make_local_array_variable __P((char *));
- extern SHELL_VAR *convert_var_to_array __P((SHELL_VAR *));
- extern SHELL_VAR *bind_array_variable __P((char *, int, char *));
- extern SHELL_VAR *assign_array_from_string  __P((char *, char *));
- extern SHELL_VAR *assign_array_var_from_word_list __P((SHELL_VAR *, WORD_LIST *));
- extern SHELL_VAR *assign_array_var_from_string __P((SHELL_VAR *, char *));
- extern int unbind_array_element __P((SHELL_VAR *, char *));
- extern int skipsubscript __P((char *, int));
- extern void print_array_assignment __P((SHELL_VAR *, int));
  
  extern void set_pipestatus_array __P((int *));
--- 220,223 ----
***************
*** 252,270 ****
  /* The `special variable' functions that get called when a particular
     variable is set. */
! void sv_path (), sv_mail (), sv_ignoreeof (), sv_strict_posix ();
! void sv_optind (), sv_opterr (), sv_globignore (), sv_locale ();
  
  #if defined (READLINE)
! void sv_terminal (), sv_hostfile ();
  #endif
  
  #if defined (HAVE_TZSET) && defined (PROMPT_STRING_DECODE)
! void sv_tz ();
  #endif
  
  #if defined (HISTORY)
! void sv_histsize (), sv_histignore (), sv_history_control ();
  #  if defined (BANG_HISTORY)
! void sv_histchars ();
  #  endif
  #endif /* HISTORY */
--- 234,261 ----
  /* The `special variable' functions that get called when a particular
     variable is set. */
! extern void sv_path __P((char *));
! extern void sv_mail __P((char *));
! extern void sv_globignore __P((char *));
! extern void sv_ignoreeof __P((char *));
! extern void sv_strict_posix __P((char *));
! extern void sv_optind __P((char *));
! extern void sv_opterr __P((char *));
! extern void sv_locale __P((char *));
  
  #if defined (READLINE)
! extern void sv_terminal __P((char *));
! extern void sv_hostfile __P((char *));
  #endif
  
  #if defined (HAVE_TZSET) && defined (PROMPT_STRING_DECODE)
! extern void sv_tz __P((char *));
  #endif
  
  #if defined (HISTORY)
! extern void sv_histsize __P((char *));
! extern void sv_histignore __P((char *));
! extern void sv_history_control __P((char *));
  #  if defined (BANG_HISTORY)
! extern void sv_histchars __P((char *));
  #  endif
  #endif /* HISTORY */
diff -Nrc2 bash-2.05/version.c bash-2.05a/version.c
*** bash-2.05/version.c	Mon Mar 20 11:27:27 2000
--- bash-2.05a/version.c	Mon Sep 10 11:48:33 2001
***************
*** 19,38 ****
     Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. */
  
  #include <stdio.h>
  
  #include "version.h"
  
  extern char *shell_name;
  
  /* Defines from version.h */
! char *dist_version = DISTVERSION;
  int patch_level = PATCHLEVEL;
  int build_version = BUILDVERSION;
  #ifdef RELSTATUS
! char *release_status = RELSTATUS;
  #else
! char *release_status = (char *)0;
  #endif
! char *sccs_version = SCCSVERSION;
  
  /* Functions for getting, setting, and displaying the shell version. */
--- 19,44 ----
     Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. */
  
+ #include <config.h>
+ 
  #include <stdio.h>
  
+ #include "stdc.h"
+ 
  #include "version.h"
+ #include "patchlevel.h"
+ #include "conftypes.h"
  
  extern char *shell_name;
  
  /* Defines from version.h */
! const char *dist_version = DISTVERSION;
  int patch_level = PATCHLEVEL;
  int build_version = BUILDVERSION;
  #ifdef RELSTATUS
! const char *release_status = RELSTATUS;
  #else
! const char *release_status = (char *)0;
  #endif
! const char *sccs_version = SCCSVERSION;
  
  /* Functions for getting, setting, and displaying the shell version. */
***************
*** 54,65 ****
  }
  
- #if !defined (MACHTYPE)
- #  if defined (CONF_MACHTYPE)
- #    define MACHTYPE CONF_MACHTYPE
- #  else
- #    define MACHTYPE "unknown"
- #  endif
- #endif
- 
  void
  show_shell_version (extended)
--- 60,63 ----
***************
*** 68,71 ****
    printf ("GNU bash, version %s (%s)\n", shell_version_string (), MACHTYPE);
    if (extended)
!     printf ("Copyright 2000 Free Software Foundation, Inc.\n");
  }
--- 66,69 ----
    printf ("GNU bash, version %s (%s)\n", shell_version_string (), MACHTYPE);
    if (extended)
!     printf ("Copyright 2001 Free Software Foundation, Inc.\n");
  }
diff -Nrc2 bash-2.05/xmalloc.c bash-2.05a/xmalloc.c
*** bash-2.05/xmalloc.c	Thu Aug  5 07:24:07 1999
--- bash-2.05a/xmalloc.c	Wed Sep 19 09:52:59 2001
***************
*** 47,51 ****
  #endif /* !PTR_T */
  
! #if defined (HAVE_SBRK) && !defined (SBRK_DECLARED)
  extern char *sbrk();
  #endif
--- 47,51 ----
  #endif /* !PTR_T */
  
! #if defined (HAVE_SBRK) && !HAVE_DECL_SBRK
  extern char *sbrk();
  #endif
***************
*** 77,87 ****
     to hold BYTES number of bytes.  If the memory cannot be allocated,
     print an error message and abort. */
! char *
  xmalloc (bytes)
       size_t bytes;
  {
!   char *temp;
  
!   temp = (char *)malloc (bytes);
  
    if (temp == 0)
--- 77,87 ----
     to hold BYTES number of bytes.  If the memory cannot be allocated,
     print an error message and abort. */
! PTR_T
  xmalloc (bytes)
       size_t bytes;
  {
!   PTR_T temp;
  
!   temp = malloc (bytes);
  
    if (temp == 0)
***************
*** 98,109 ****
  }
  
! char *
  xrealloc (pointer, bytes)
       PTR_T pointer;
       size_t bytes;
  {
!   char *temp;
  
!   temp = pointer ? (char *)realloc (pointer, bytes) : (char *)malloc (bytes);
  
    if (temp == 0)
--- 98,109 ----
  }
  
! PTR_T
  xrealloc (pointer, bytes)
       PTR_T pointer;
       size_t bytes;
  {
!   PTR_T temp;
  
!   temp = pointer ? realloc (pointer, bytes) : malloc (bytes);
  
    if (temp == 0)
***************
*** 129,130 ****
--- 129,191 ----
      free (string);
  }
+ 
+ #ifdef USING_BASH_MALLOC
+ #include <malloc/shmalloc.h>
+ 
+ PTR_T
+ sh_xmalloc (bytes, file, line)
+      size_t bytes;
+      char *file;
+      int line;
+ {
+   PTR_T temp;
+ 
+   temp = sh_malloc (bytes, file, line);
+ 
+   if (temp == 0)
+     {
+ #if defined (HAVE_SBRK)
+       allocated = findbrk ();
+       fatal_error ("xmalloc: %s:%d: cannot allocate %lu bytes (%lu bytes allocated)", file, line, (unsigned long)bytes, (unsigned long)allocated);
+ #else
+       fatal_error ("xmalloc: %s:%d: cannot allocate %lu bytes", file, line, (unsigned long)bytes);
+ #endif /* !HAVE_SBRK */
+     }
+ 
+   return (temp);
+ }
+ 
+ PTR_T
+ sh_xrealloc (pointer, bytes, file, line)
+      PTR_T pointer;
+      size_t bytes;
+      char *file;
+      int line;
+ {
+   PTR_T temp;
+ 
+   temp = pointer ? sh_realloc (pointer, bytes, file, line) : sh_malloc (bytes, file, line);
+ 
+   if (temp == 0)
+     {
+ #if defined (HAVE_SBRK)
+       allocated = findbrk ();
+       fatal_error ("xrealloc: %s:%d: cannot reallocate %lu bytes (%lu bytes allocated)", file, line, (unsigned long)bytes, (unsigned long)allocated);
+ #else
+       fatal_error ("xrealloc: %s:%d: cannot allocate %lu bytes", file, line, (unsigned long)bytes);
+ #endif /* !HAVE_SBRK */
+     }
+ 
+   return (temp);
+ }
+ 
+ void
+ sh_xfree (string, file, line)
+      PTR_T string;
+      char *file;
+      int line;
+ {
+   if (string)
+     sh_free (string, file, line);
+ }
+ #endif
diff -Nrc2 bash-2.05/xmalloc.h bash-2.05a/xmalloc.h
*** bash-2.05/xmalloc.h	Wed Dec 31 19:00:00 1969
--- bash-2.05a/xmalloc.h	Mon Sep 10 11:57:39 2001
***************
*** 0 ****
--- 1,58 ----
+ /* xmalloc.h -- defines for the `x' memory allocation functions */
+ 
+ /* Copyright (C) 2001 Free Software Foundation, Inc.
+ 
+    This file is part of GNU Bash, the Bourne Again SHell.
+ 
+    Bash is free software; you can redistribute it and/or modify it under
+    the terms of the GNU General Public License as published by the Free
+    Software Foundation; either version 2, or (at your option) any later
+    version.
+ 
+    Bash is distributed in the hope that it will be useful, but WITHOUT ANY
+    WARRANTY; without even the implied warranty of MERCHANTABILITY or
+    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+    for more details.
+ 
+    You should have received a copy of the GNU General Public License along
+    with Bash; see the file COPYING.  If not, write to the Free Software
+    Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. */
+ 
+ #if !defined (_XMALLOC_H_)
+ #define _XMALLOC_H_
+ 
+ #include "stdc.h"
+ #include "bashansi.h"
+ 
+ /* Generic pointer type. */
+ #ifndef PTR_T
+ 
+ #if defined (__STDC__)
+ #  define PTR_T	void *
+ #else
+ #  define PTR_T char *
+ #endif
+ 
+ #endif /* PTR_T */
+ 
+ /* Allocation functions in xmalloc.c */
+ extern PTR_T xmalloc __P((size_t));
+ extern PTR_T xrealloc __P((void *, size_t));
+ extern void xfree __P((void *));
+ 
+ #ifdef USING_BASH_MALLOC
+ extern PTR_T sh_xmalloc __P((size_t, const char *, int));
+ extern PTR_T sh_xrealloc __P((void *, size_t, const char *, int));
+ extern void sh_xfree __P((void *, const char *, int));
+ 
+ #define xmalloc(x)	sh_xmalloc((x), __FILE__, __LINE__)
+ #define xrealloc(x, n)	sh_xrealloc((x), (n), __FILE__, __LINE__)
+ #define xfree(x)	sh_xfree((x), __FILE__, __LINE__)
+ 
+ #ifdef free
+ #undef free
+ #endif
+ #define free(x)		sh_xfree((x), __FILE__, __LINE__)
+ #endif	/* USING_BASH_MALLOC */
+ 
+ #endif	/* _XMALLOC_H_ */
diff -Nrc2 bash-2.05/y.tab.c bash-2.05a/y.tab.c
*** bash-2.05/y.tab.c	Tue Mar 27 10:06:14 2001
--- bash-2.05a/y.tab.c	Tue Oct 30 11:48:15 2001
***************
*** 1,18 ****
! #ifndef lint
! static char const 
! yyrcsid[] = "$FreeBSD: src/usr.bin/yacc/skeleton.c,v 1.28 2000/01/17 02:04:06 bde Exp $";
! #endif
! #include <stdlib.h>
! #define YYBYACC 1
! #define YYMAJOR 1
! #define YYMINOR 9
! #define YYLEX yylex()
! #define YYEMPTY -1
! #define yyclearin (yychar=(YYEMPTY))
! #define yyerrok (yyerrflag=0)
! #define YYRECOVERING() (yyerrflag!=0)
! static int yygrowstack();
! #define YYPREFIX "yy"
! #line 22 "/usr/homes/chet/src/bash/src/parse.y"
  #include "config.h"
  
--- 1,50 ----
! 
! /*  A Bison parser, made from /usr/homes/chet/src/bash/src/parse.y
!     by GNU Bison version 1.28  */
! 
! #define YYBISON 1  /* Identify Bison output.  */
! 
! #define	IF	257
! #define	THEN	258
! #define	ELSE	259
! #define	ELIF	260
! #define	FI	261
! #define	CASE	262
! #define	ESAC	263
! #define	FOR	264
! #define	SELECT	265
! #define	WHILE	266
! #define	UNTIL	267
! #define	DO	268
! #define	DONE	269
! #define	FUNCTION	270
! #define	COND_START	271
! #define	COND_END	272
! #define	COND_ERROR	273
! #define	IN	274
! #define	BANG	275
! #define	TIME	276
! #define	TIMEOPT	277
! #define	WORD	278
! #define	ASSIGNMENT_WORD	279
! #define	NUMBER	280
! #define	ARITH_CMD	281
! #define	ARITH_FOR_EXPRS	282
! #define	COND_CMD	283
! #define	AND_AND	284
! #define	OR_OR	285
! #define	GREATER_GREATER	286
! #define	LESS_LESS	287
! #define	LESS_AND	288
! #define	GREATER_AND	289
! #define	SEMI_SEMI	290
! #define	LESS_LESS_MINUS	291
! #define	AND_GREATER	292
! #define	LESS_GREATER	293
! #define	GREATER_BAR	294
! #define	yacc_EOF	295
! 
! #line 21 "/usr/homes/chet/src/bash/src/parse.y"
! 
  #include "config.h"
  
***************
*** 31,34 ****
--- 63,67 ----
  
  #include <stdio.h>
+ #include "chartypes.h"
  #include <signal.h>
  
***************
*** 40,43 ****
--- 73,77 ----
  #include "parser.h"
  #include "mailcheck.h"
+ #include "test.h"
  #include "builtins/common.h"
  #include "builtins/builtext.h"
***************
*** 81,85 ****
  extern int no_line_editing, running_under_emacs;
  extern int current_command_number;
- extern int interactive, interactive_shell, login_shell;
  extern int sourcelevel;
  extern int posixly_correct;
--- 115,118 ----
***************
*** 90,94 ****
  extern int patch_level;
  extern int dump_translatable_strings, dump_po_strings;
! extern Function *last_shell_builtin, *this_shell_builtin;
  #if defined (BUFFERED_INPUT)
  extern int bash_input_fd_changed;
--- 123,127 ----
  extern int patch_level;
  extern int dump_translatable_strings, dump_po_strings;
! extern sh_builtin_func_t *last_shell_builtin, *this_shell_builtin;
  #if defined (BUFFERED_INPUT)
  extern int bash_input_fd_changed;
***************
*** 102,130 ****
  /* **************************************************************** */
  
! static char *ansiexpand ();
! static char *localeexpand ();
! static int reserved_word_acceptable ();
! static int read_token ();
! static int yylex ();
! static int parse_arith_cmd ();
! #if defined (COND_COMMAND)
! static COMMAND *parse_cond_command ();
  #endif
- static int read_token_word ();
- static void discard_parser_constructs ();
  
! static void report_syntax_error ();
! static void handle_eof_input_unit ();
! static void prompt_again ();
  #if 0
! static void reset_readline_prompt ();
  #endif
! static void print_prompt ();
  
  #if defined (HISTORY)
! char *history_delimiting_chars ();
  #endif
  
! extern int yyerror ();
  
  /* Default prompt strings */
--- 135,204 ----
  /* **************************************************************** */
  
! #ifdef DEBUG
! static void debug_parser __P((int));
! #endif
! 
! static int yy_getc __P((void));
! static int yy_ungetc __P((int));
! 
! #if defined (READLINE)
! static int yy_readline_get __P((void));
! static int yy_readline_unget __P((int));
  #endif
  
! static int yy_string_get __P((void));
! static int yy_string_unget __P((int));
! static int yy_stream_get __P((void));
! static int yy_stream_unget __P((int));
! 
! static int shell_getc __P((int));
! static void shell_ungetc __P((int));
! static void discard_until __P((int));
! 
! #if defined (ALIAS) || defined (DPAREN_ARITHMETIC)
! static void push_string __P((char *, int, alias_t *));
! static void pop_string __P((void));
! static void free_string_list __P((void));
! #endif
! 
! static char *read_a_line __P((int));
! 
! static char *ansiexpand __P((char *, int, int, int *));
! static char *mk_msgstr __P((char *, int *));
! static char *localeexpand __P((char *, int, int, int, int *));
! static int reserved_word_acceptable __P((int));
! static int yylex __P((void));
! static int alias_expand_token __P((char *));
! static int time_command_acceptable __P((void));
! static int special_case_tokens __P((char *));
! static int read_token __P((int));
! static char *parse_matched_pair __P((int, int, int, int *, int));
! #if defined (DPAREN_ARITHMETIC) || defined (ARITH_FOR_COMMAND)
! static int parse_arith_cmd __P((char **));
! #endif
! #if defined (COND_COMMAND)
! static COND_COM *cond_expr __P((void));
! static COND_COM *cond_or __P((void));
! static COND_COM *cond_and __P((void));
! static COND_COM *cond_term __P((void));
! static int cond_skip_newlines __P((void));
! static COMMAND *parse_cond_command __P((void));
! #endif
! static int read_token_word __P((int));
! static void discard_parser_constructs __P((int));
! 
! static void report_syntax_error __P((char *));
! static void handle_eof_input_unit __P((void));
! static void prompt_again __P((void));
  #if 0
! static void reset_readline_prompt __P((void));
  #endif
! static void print_prompt __P((void));
  
  #if defined (HISTORY)
! char *history_delimiting_chars __P((void));
  #endif
  
! extern int yyerror __P((const char *));
  
  /* Default prompt strings */
***************
*** 181,185 ****
  
  static REDIRECTEE redir;
! #line 190 "/usr/homes/chet/src/bash/src/parse.y"
  typedef union {
    WORD_DESC *word;		/* the word that we read. */
--- 255,260 ----
  
  static REDIRECTEE redir;
! 
! #line 232 "/usr/homes/chet/src/bash/src/parse.y"
  typedef union {
    WORD_DESC *word;		/* the word that we read. */
***************
*** 191,1559 ****
    PATTERN_LIST *pattern;
  } YYSTYPE;
! #line 194 "y.tab.c"
! #define YYERRCODE 256
! #define IF 257
! #define THEN 258
! #define ELSE 259
! #define ELIF 260
! #define FI 261
! #define CASE 262
! #define ESAC 263
! #define FOR 264
! #define SELECT 265
! #define WHILE 266
! #define UNTIL 267
! #define DO 268
! #define DONE 269
! #define FUNCTION 270
! #define COND_START 271
! #define COND_END 272
! #define COND_ERROR 273
! #define IN 274
! #define BANG 275
! #define TIME 276
! #define TIMEOPT 277
! #define WORD 278
! #define ASSIGNMENT_WORD 279
! #define NUMBER 280
! #define ARITH_CMD 281
! #define ARITH_FOR_EXPRS 282
! #define COND_CMD 283
! #define AND_AND 284
! #define OR_OR 285
! #define GREATER_GREATER 286
! #define LESS_LESS 287
! #define LESS_AND 288
! #define GREATER_AND 289
! #define SEMI_SEMI 290
! #define LESS_LESS_MINUS 291
! #define AND_GREATER 292
! #define LESS_GREATER 293
! #define GREATER_BAR 294
! #define yacc_EOF 295
! const short yylhs[] = {                                        -1,
!     0,    0,    0,    0,   27,   27,   24,   24,   24,   24,
!    24,   24,   24,   24,   24,   24,   24,   24,   24,   24,
!    24,   24,   24,   24,   24,   24,   24,   24,   24,   24,
!    24,   24,   24,   26,   26,   26,   25,   25,   10,   10,
!     1,    1,    1,    1,   11,   11,   11,   11,   11,   11,
!    11,   11,   11,   11,   11,   12,   12,   12,   12,   12,
!    12,   18,   18,   18,   18,   13,   13,   13,   13,   13,
!    13,   14,   14,   14,   19,   19,   19,   20,   20,   23,
!    21,   21,   21,   15,   16,   17,   22,   22,   22,   31,
!    31,   29,   29,   29,   29,   30,   30,   28,   28,    4,
!     7,    7,    5,    5,    5,    6,    6,    6,    6,    6,
!     6,   34,   34,   34,   33,   33,    8,    8,    8,    9,
!     9,    9,    9,    9,    3,    3,    3,    3,    3,    2,
!     2,   32,   32,
  };
! const short yylen[] = {                                         2,
!     2,    1,    2,    1,    1,    2,    2,    2,    3,    3,
!     2,    3,    2,    3,    2,    3,    2,    3,    2,    3,
!     2,    3,    2,    3,    2,    3,    2,    3,    2,    3,
!     2,    2,    3,    1,    1,    1,    1,    2,    1,    2,
!     1,    1,    2,    1,    1,    1,    5,    5,    1,    1,
!     1,    1,    1,    1,    1,    6,    6,    7,    7,   10,
!    10,    7,    7,    5,    5,    6,    6,    7,    7,   10,
!    10,    6,    7,    6,    5,    6,    4,    1,    2,    3,
!     5,    7,    6,    3,    1,    3,    4,    6,    5,    1,
!     2,    4,    4,    5,    5,    2,    3,    1,    3,    2,
!     1,    2,    3,    3,    3,    4,    4,    4,    4,    4,
!     1,    1,    1,    1,    0,    2,    1,    2,    2,    4,
!     4,    3,    3,    1,    1,    2,    2,    3,    3,    4,
!     1,    1,    2,
  };
! const short yydefred[] = {                                      0,
!     0,  115,    0,    0,    0,  115,  115,    0,    0,    0,
!     0,    0,   35,    0,   85,    0,    0,    0,    0,    0,
!     0,    0,    0,    2,    4,    0,    0,  115,  115,    0,
!   131,    0,  124,    0,    0,    0,    0,   45,   49,   46,
!    52,   53,   54,   55,   44,   50,   51,   36,   39,    0,
!     3,  101,    0,    0,  115,    0,    0,    0,    0,    0,
!     0,    0,    0,    0,  133,    0,    0,    0,    0,    0,
!     0,    0,    0,    0,    0,   11,   13,   19,   15,   27,
!    21,   17,   25,   23,   29,   31,   32,    7,    8,    0,
!     0,  115,    1,  115,  115,    0,    0,   34,   40,   37,
!     0,    0,    0,  115,  116,  111,  100,    0,    0,  115,
!     0,  115,  113,  112,  114,  115,  115,  115,    0,  115,
!   115,    0,    0,   86,    0,  115,   12,   14,   20,   16,
!    28,   22,   18,   26,   24,   30,   33,    9,   10,   84,
!    80,    0,    0,    0,    0,    0,   38,    0,    0,  115,
!   115,  115,  115,  115,  115,    0,  115,    0,  115,    0,
!     0,    0,    0,  115,    0,  115,    0,    0,  115,    0,
!    77,    0,    0,  120,  121,    0,    0,  115,  115,   81,
!     0,    0,    0,    0,    0,    0,    0,  115,    0,    0,
!   115,  115,    0,    5,    0,    0,   64,   65,  115,  115,
!   115,  115,    0,    0,    0,    0,   47,   48,    0,    0,
!    75,    0,    0,   83,  106,  107,    0,    0,    0,   96,
!     0,    0,   74,   72,   98,    0,    0,    0,    0,   56,
!     6,  115,   57,    0,    0,    0,    0,   66,    0,  115,
!    67,   76,   82,  115,  115,  115,  115,   97,   73,    0,
!     0,  115,   58,   59,    0,   62,   63,   68,   69,    0,
!     0,    0,    0,    0,  115,   99,   92,    0,  115,  115,
!   115,  115,  115,   89,   94,    0,    0,    0,    0,    0,
!    88,   60,   61,   70,   71,
  };
! const short yydgoto[] = {                                      30,
!    31,   32,  106,   52,  107,  108,   53,   34,  145,   36,
!    37,   38,   39,   40,   41,   42,   43,   44,   45,  171,
!    46,  181,   47,   48,  101,   49,  195,  227,  187,  188,
!   189,   50,   54,  117,
  };
! const short yysindex[] = {                                    -10,
!     2,    0, -258, -255, -246,    0,    0, -237, -249,  846,
!  -226,   15,    0,  123,    0, -211, -203,  -44,  -43, -199,
!  -198, -194, -193,    0,    0, -192, -191,    0,    0,    0,
!     0,  -41,    0,   78,   23,  956,  975,    0,    0,    0,
!     0,    0,    0,    0,    0,    0,    0,    0,    0,  721,
!     0,    0, -169,   71,    0,   35,   -6,   39, -177, -172,
!    61, -168,  -41,  933,    0,   62, -176, -173,  -30,  -27,
!  -166, -163, -162, -160, -159,    0,    0,    0,    0,    0,
!     0,    0,    0,    0,    0,    0,    0,    0,    0,  -17,
!    69,    0,    0,    0,    0,  813,  813,    0,    0,    0,
!   975,  933,  -41,    0,    0,    0,    0,   19,   -7,    0,
!    66,    0,    0,    0,    0,    0,    0,    0,   99,    0,
!     0,   79,  305,    0,  -41,    0,    0,    0,    0,    0,
!     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
!     0,  104,   71,   71, -247, -247,    0,  -41, -195,    0,
!     0,    0,    0,    0,    0,    4,    0, -156,    0, -145,
!     1,    7,   12,    0, -156,    0, -144, -140,    0,  975,
!     0,  305,  -41,    0,    0,  813,  813,    0,    0,    0,
!  -138,   71,   71,   71,   71,   71, -158,    0, -129,   -4,
!     0,    0, -132,    0,   -5,   16,    0,    0,    0,    0,
!     0,    0, -126,   71,   -5,   20,    0,    0,  305,  975,
!     0, -115, -111,    0,    0,    0, -240, -240, -240,    0,
!  -142,   32,    0,    0,    0, -128,  -34, -120,   26,    0,
!     0,    0,    0, -114,   36, -107,   38,    0,   19,    0,
!     0,    0,    0,    0,    0,    0,    0,    0,    0,  -25,
!  -113,    0,    0,    0,   29,    0,    0,    0,    0,   37,
!  -201,   71,   71,   71,    0,    0,    0,   71,    0,    0,
!     0,    0,    0,    0,    0,   71, -100,   45,  -98,   48,
!     0,    0,    0,    0,    0,
  };
! const short yyrindex[] = {                                      0,
!     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
!   888,   33,    0,    0,    0,    0,    0,    0,    0,    0,
!     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
!     0,  450,    0,    0,  164,  118,  162,    0,    0,    0,
!     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
!     0,    0,    0,    0,    0,  126,    0,  126,    0,    0,
!   216,    0,  462,    0,    0,    0,    0,    0,    0,    0,
!     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
!     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
!     0,    0,    0,    0,    0,  165,  166,    0,    0,    0,
!   174,    0,  495,    0,    0,    0,    0,  436,    0,    0,
!     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
!     0,    0,    0,    0,  507,    0,    0,    0,    0,    0,
!     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
!     0,    0,    0,    0,   11,   18,    0,  540,    0,    0,
!     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
!     0,    0,    0,    0,    0,    0,    0,    0,    0,  403,
!     0,    0,  553,    0,    0,    0,    0,    0,    0,    0,
!     0,    0,    0,  573,  662,  765,  -85,    0,    0,    0,
!     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
!     0,    0,    0,    0,    0,    0,    0,    0,    0,  416,
!     0,    0,    0,    0,    0,    0,  587,  599,  611,    0,
!   -84,    0,    0,    0,    0,    0,    0,    0,    0,    0,
!     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
!     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
!     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
!   -81,    0,    0,    0,    0,    0,    0, -250,    0,    0,
!     0,    0,    0,    0,    0, -244,    0,    0,    0,    0,
!     0,    0,    0,    0,    0,
  };
! const short yygindex[] = {                                      0,
!     0,   -2,   10, -133,    0,  340,  798,    0,   24,    0,
!  -112,    0,    0,    0,    0,    0,    0,    0,    0, -146,
!     0,  -80,    0,  -28,   21,  152,   25,  -33,    8,    0,
!     0,  182, 1196, -170,
  };
! #define YYTABLESIZE 1468
! const short yytable[] = {                                      24,
!    80,   83,  105,  114,  114,  105,  252,   63,  100,   33,
!   170,   51,   93,  105,  131,  265,  105,  134,   95,   55,
!   122,  105,   56,   35,  232,  211,   57,  123,  154,   29,
!   203,   58,  206,   62,  240,  226,   94,   95,  105,   93,
!    61,  105,   34,  150,  151,   95,  105,  103,  122,   27,
!    65,   26,  113,  113,   66,  123,  152,  273,  179,  170,
!    96,  125,  242,  178,  179,  180,   76,  236,  237,  122,
!    34,  226,  147,   34,   77,  105,  123,  153,   84,   85,
!   105,   97,   92,   86,   87,   88,   89,   93,  104,  251,
!   120,   34,   34,  110,   34,  121,  170,  118,  251,  148,
!   122,  127,  126,  124,  128,   33,   33,  140,  105,  141,
!    29,  135,   28,  105,  136,  137,  116,  138,  139,  169,
!   146,  194,  214,  197,  207,  198,  192,   41,  208,  200,
!    27,  220,   26,  223,  202,  115,  230,  279,  280,  173,
!   233,  100,  238,   29,  241,  243,  244,  248,  253,  225,
!   254,  270,   33,   33,  256,   41,   34,   34,   41,  272,
!   257,  258,  259,   27,  266,   26,  174,  175,  282,  283,
!   284,   42,  285,  117,  118,  119,   41,   90,   91,   87,
!   274,  147,   75,   43,   74,   33,   33,   99,  159,  205,
!   210,   64,  250,   28,    0,  221,    0,    0,    0,   42,
!   146,    0,   42,    0,    0,    0,    0,    0,    0,    0,
!     0,   43,    0,    0,   43,    0,    0,    0,    0,    0,
!    42,  166,    0,    0,    0,  115,   28,    0,    0,    0,
!     0,    0,   43,   78,   81,   79,   82,    0,    0,    0,
!     0,   41,   41,    0,    0,    1,    2,  129,  115,  130,
!   132,    3,  133,    4,    5,    6,    7,    0,  224,    8,
!     9,  112,    0,    0,   10,   11,  155,   12,   13,   14,
!    15,  191,  231,  225,  199,   16,   17,   18,   19,  201,
!    20,   21,   22,   23,   25,   42,   42,    0,  115,  115,
!    34,   34,   34,   34,  249,   34,  269,   43,   43,    0,
!    34,   34,  150,  151,  271,    0,   94,   95,    0,  225,
!    34,   34,   34,    0,  105,    0,   34,   34,   34,   34,
!    34,   34,   34,   34,   34,   34,   34,    2,    0,    0,
!     0,    0,    3,  157,    4,    5,    6,    7,  115,  158,
!     8,    9,    0,    0,   29,   10,   11,    0,   12,   13,
!    14,   15,    0,    0,    0,    0,   16,   17,   18,   19,
!     2,   20,   21,   22,   23,    3,  164,    4,    5,    6,
!     7,    0,  165,    8,    9,   41,   41,   41,   41,    0,
!    41,   12,   13,   14,   15,   41,   41,    0,    0,   16,
!    17,   18,   19,  115,   20,   21,   22,   23,    0,  115,
!     0,   41,   41,    0,    0,    0,    0,   41,   67,   68,
!    69,   70,   78,   71,    0,   72,   73,    0,    0,   42,
!    42,   42,   42,    0,   42,   79,    0,   28,    0,   42,
!    42,   43,   43,   43,   43,    0,   43,    0,    0,    0,
!    78,   43,   43,   78,    0,   42,   42,    0,    0,    0,
!     0,   42,    0,   79,    0,    0,   79,   43,   43,  125,
!     0,   78,    0,   43,    0,    0,    0,    0,    0,    0,
!     0,  126,  115,    0,   79,    0,  102,  115,    0,  115,
!   115,  115,  115,    0,    0,    0,  115,  125,    0,    0,
!   125,    0,    0,    0,    0,    0,  115,    0,    0,  126,
!     0,    0,  126,    0,  127,    0,    0,    0,  125,    0,
!     0,    0,    0,    0,    0,    0,  129,    0,    0,    0,
!   126,  215,  216,  217,  218,  219,   78,   78,    0,    0,
!     0,    0,  127,    0,    0,  127,    0,    0,    0,   79,
!    79,    0,    0,  239,  129,    0,    0,  129,    0,  128,
!     0,    0,    0,  127,    0,    0,    0,    0,    0,    0,
!   102,    2,  130,    0,    0,  129,    3,    0,    4,    5,
!     6,    7,    0,    0,  125,    9,    0,  128,    0,    0,
!   128,    0,    0,    0,    0,   15,  126,    0,    0,    0,
!   130,    0,    0,  130,    0,    0,  108,    0,  128,    0,
!     0,  217,  218,  219,    0,    0,    0,    0,  109,    0,
!     0,  130,    0,  104,    0,    0,    0,    0,    0,  127,
!   110,    0,    0,    0,  108,    0,    0,  108,    0,    0,
!     0,  129,    0,    0,    0,    0,  109,    0,    0,  109,
!     0,    0,    0,    0,    0,  108,    0,    0,  110,    0,
!     0,  110,    0,    0,    0,    0,    0,  109,    0,    0,
!    78,   78,   78,   78,  128,   78,    0,    0,    0,  110,
!    78,   78,    0,   79,   79,   79,   79,  130,   79,    0,
!     0,    0,    0,   79,   79,    0,   78,   78,    0,    0,
!     0,    0,   78,  102,  102,  102,  102,  104,  102,   79,
!    79,    0,  105,  102,  102,   79,    0,  125,  125,  125,
!   125,  108,  125,    0,    0,    0,    0,  125,  125,  126,
!   126,  126,  126,  109,  126,  102,    0,    0,    0,  126,
!   126,    0,    0,  125,  125,  110,    0,    0,    0,  125,
!     0,    0,    0,    0,    0,  126,  126,    0,    0,    0,
!     0,  126,  127,  127,  127,  127,    0,  127,    0,    0,
!    29,    0,  127,  127,  129,  129,  129,  129,    0,  129,
!     0,    0,    0,    0,  129,  129,    0,    0,  127,  127,
!    27,    0,   26,    0,  127,    0,  105,    0,    0,    0,
!   129,  129,    0,    0,    0,    0,  129,  128,  128,  128,
!   128,    0,  128,   59,   60,  103,    0,  128,  128,    0,
!   130,  130,  130,  130,    0,  130,    0,    0,    0,    0,
!   130,  130,    0,  128,  128,   90,   91,    0,    0,  128,
!   104,  104,  104,  104,    0,  104,  130,  130,    0,    0,
!   104,  104,  130,   28,  108,  108,  108,  108,    0,  108,
!     0,    0,   29,    0,  108,  108,  109,  109,  109,  109,
!     0,  109,  104,    0,    0,    0,  109,  109,  110,  110,
!   110,  110,   27,  110,   26,    0,  108,    0,  110,  110,
!     0,    0,    0,    0,    0,   29,    0,    0,  109,  103,
!     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
!   110,  149,    0,    0,    0,   27,    0,   26,    0,  160,
!     0,    0,    0,  161,    0,    0,    0,  167,  168,  105,
!   105,  105,  105,    0,  105,    0,    0,  132,    0,  105,
!   105,    0,    0,    0,    0,   28,    0,    0,    0,    0,
!     0,    0,    0,    0,    0,    0,    0,  132,    0,  132,
!     0,  105,    0,    0,  193,    0,  196,    0,    0,    0,
!     0,    0,    0,    0,    0,    0,    0,    0,   28,    0,
!     0,    0,   29,    0,    0,  212,  213,    2,    0,    0,
!     0,    0,    3,    0,    4,    5,    6,    7,  228,  229,
!     8,    9,   27,    0,   26,  102,  234,  235,   12,   13,
!    14,   15,    0,    0,    0,    0,   16,   17,   18,   19,
!   132,   20,   21,   22,   23,   27,    0,   26,    0,    0,
!     0,    0,  103,  103,  103,  103,    0,  103,    0,    0,
!     0,    0,  103,  103,   27,    0,   26,    0,    0,    0,
!     0,  261,    0,    0,    0,    0,    0,    0,    0,  267,
!     0,    0,    0,    0,  103,   28,    0,    0,    0,    0,
!     0,    0,  275,    0,    0,    0,  277,  278,    0,    2,
!   281,    0,    0,    0,    3,    0,    4,    5,    6,    7,
!     0,    0,    8,    9,    0,    0,    0,   10,   11,    0,
!    12,   13,   14,   15,    0,    0,    0,    0,   16,   17,
!    18,   19,    2,   20,   21,   22,   23,    3,    0,    4,
!     5,    6,    7,    0,    0,    8,    9,    0,    0,    0,
!     0,   11,    0,   12,   13,   14,   15,    0,    0,    0,
!     0,   16,   17,   18,   19,    0,   20,   21,   22,   23,
!     0,    0,    0,    0,  132,    0,    0,    0,    0,  132,
!     0,  132,  132,  132,  132,    0,    0,  132,  132,    0,
!     0,    0,  132,    0,    0,  132,  132,  132,  132,    0,
!     0,    0,    0,  132,  132,  132,  132,    0,  132,  132,
!   132,  132,    0,    0,    0,    0,    0,    0,    0,    2,
!     0,    0,    0,    0,    3,    0,    4,    5,    6,    7,
!     0,    0,    8,    9,    0,    0,    0,    0,    0,    0,
!    12,   13,   14,   15,    0,    0,    0,    0,   16,   17,
!    18,   19,    0,   20,   21,   22,   23,    0,    0,    0,
!     0,    0,    0,   98,   13,   14,    0,    0,    0,    0,
!     0,   16,   17,   18,   19,    0,   20,   21,   22,   23,
!   109,  111,    0,  119,   14,    0,  123,    0,    0,    0,
!    16,   17,   18,   19,    0,   20,   21,   22,   23,    0,
!     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
!     0,    0,    0,    0,    0,    0,    0,  142,    0,  143,
!   144,    0,    0,    0,    0,    0,    0,    0,    0,    0,
!     0,    0,    0,    0,    0,  156,    0,    0,    0,    0,
!     0,    0,  162,  163,    0,    0,    0,    0,    0,    0,
!     0,  172,    0,    0,    0,    0,    0,    0,    0,    0,
!     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
!     0,    0,    0,    0,    0,  182,  183,  184,  185,  186,
!   190,    0,    0,    0,    0,    0,    0,    0,    0,  204,
!     0,  204,    0,    0,  209,    0,    0,    0,    0,    0,
!     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
!     0,    0,    0,  222,    0,    0,    0,    0,    0,    0,
!     0,    0,    0,    0,    0,    0,  204,  204,    0,    0,
!     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
!     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
!     0,    0,    0,    0,    0,    0,    0,  255,    0,    0,
!     0,    0,    0,    0,    0,  260,    0,    0,    0,    0,
!   262,  263,  264,    0,    0,    0,    0,  268,    0,    0,
!     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
!   276,    0,    0,    0,    0,    0,  204,  204,
  };
! const short yycheck[] = {                                      10,
!    45,   45,   10,   10,   10,   10,   41,   10,   37,    0,
!   123,   10,  263,   10,   45,   41,   10,   45,  263,  278,
!    10,   10,  278,    0,  195,  172,  282,   10,   10,   40,
!   164,  278,  166,  283,  205,   40,  284,  285,   10,  290,
!   278,   10,   10,  284,  285,  290,   10,   50,   38,   60,
!   277,   62,   59,   59,   40,   38,   38,  259,  260,  172,
!    38,   64,  209,  259,  260,  261,  278,  201,  202,   59,
!    38,   40,  101,   41,  278,   10,   59,   59,  278,  278,
!    10,   59,  124,  278,  278,  278,  278,   10,  258,  124,
!   268,   59,   60,   59,   62,  268,  209,   59,  124,  102,
!    40,  278,   41,  272,  278,   96,   97,  125,   10,   41,
!    40,  278,  123,   10,  278,  278,  123,  278,  278,   41,
!    97,  278,  261,  269,  269,  125,  123,   10,  269,  123,
!    60,  290,   62,  263,  123,   10,  269,  271,  272,  142,
!   125,  170,  269,   40,  125,  261,  258,  290,  269,  278,
!   125,  123,  143,  144,  269,   38,  124,  125,   41,  123,
!   125,  269,  125,   60,  278,   62,  143,  144,  269,  125,
!   269,   10,  125,   10,   10,   10,   59,  263,  263,  261,
!   261,  210,   60,   10,   62,  176,  177,   36,  123,  165,
!   170,   10,  226,  123,   -1,  188,   -1,   -1,   -1,   38,
!   177,   -1,   41,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
!    -1,   38,   -1,   -1,   41,   -1,   -1,   -1,   -1,   -1,
!    59,  123,   -1,   -1,   -1,   10,  123,   -1,   -1,   -1,
!    -1,   -1,   59,  278,  278,  280,  280,   -1,   -1,   -1,
!    -1,  124,  125,   -1,   -1,  256,  257,  278,  123,  280,
!   278,  262,  280,  264,  265,  266,  267,   -1,  263,  270,
!   271,  268,   -1,   -1,  275,  276,  274,  278,  279,  280,
!   281,  268,  278,  278,  268,  286,  287,  288,  289,  268,
!   291,  292,  293,  294,  295,  124,  125,   -1,  295,  295,
!   258,  259,  260,  261,  263,  263,  268,  124,  125,   -1,
!   268,  269,  284,  285,  268,   -1,  284,  285,   -1,  278,
!   278,  279,  280,   -1,   10,   -1,  284,  285,  286,  287,
!   288,  289,  290,  291,  292,  293,  294,  257,   -1,   -1,
!    -1,   -1,  262,  268,  264,  265,  266,  267,  123,  274,
!   270,  271,   -1,   -1,   40,  275,  276,   -1,  278,  279,
!   280,  281,   -1,   -1,   -1,   -1,  286,  287,  288,  289,
!   257,  291,  292,  293,  294,  262,  268,  264,  265,  266,
!   267,   -1,  274,  270,  271,  258,  259,  260,  261,   -1,
!   263,  278,  279,  280,  281,  268,  269,   -1,   -1,  286,
!   287,  288,  289,  268,  291,  292,  293,  294,   -1,  274,
!    -1,  284,  285,   -1,   -1,   -1,   -1,  290,  286,  287,
!   288,  289,   10,  291,   -1,  293,  294,   -1,   -1,  258,
!   259,  260,  261,   -1,  263,   10,   -1,  123,   -1,  268,
!   269,  258,  259,  260,  261,   -1,  263,   -1,   -1,   -1,
!    38,  268,  269,   41,   -1,  284,  285,   -1,   -1,   -1,
!    -1,  290,   -1,   38,   -1,   -1,   41,  284,  285,   10,
!    -1,   59,   -1,  290,   -1,   -1,   -1,   -1,   -1,   -1,
!    -1,   10,  257,   -1,   59,   -1,   41,  262,   -1,  264,
!   265,  266,  267,   -1,   -1,   -1,  271,   38,   -1,   -1,
!    41,   -1,   -1,   -1,   -1,   -1,  281,   -1,   -1,   38,
!    -1,   -1,   41,   -1,   10,   -1,   -1,   -1,   59,   -1,
!    -1,   -1,   -1,   -1,   -1,   -1,   10,   -1,   -1,   -1,
!    59,  182,  183,  184,  185,  186,  124,  125,   -1,   -1,
!    -1,   -1,   38,   -1,   -1,   41,   -1,   -1,   -1,  124,
!   125,   -1,   -1,  204,   38,   -1,   -1,   41,   -1,   10,
!    -1,   -1,   -1,   59,   -1,   -1,   -1,   -1,   -1,   -1,
!   125,  257,   10,   -1,   -1,   59,  262,   -1,  264,  265,
!   266,  267,   -1,   -1,  125,  271,   -1,   38,   -1,   -1,
!    41,   -1,   -1,   -1,   -1,  281,  125,   -1,   -1,   -1,
!    38,   -1,   -1,   41,   -1,   -1,   10,   -1,   59,   -1,
!    -1,  262,  263,  264,   -1,   -1,   -1,   -1,   10,   -1,
!    -1,   59,   -1,   41,   -1,   -1,   -1,   -1,   -1,  125,
!    10,   -1,   -1,   -1,   38,   -1,   -1,   41,   -1,   -1,
!    -1,  125,   -1,   -1,   -1,   -1,   38,   -1,   -1,   41,
!    -1,   -1,   -1,   -1,   -1,   59,   -1,   -1,   38,   -1,
!    -1,   41,   -1,   -1,   -1,   -1,   -1,   59,   -1,   -1,
!   258,  259,  260,  261,  125,  263,   -1,   -1,   -1,   59,
!   268,  269,   -1,  258,  259,  260,  261,  125,  263,   -1,
!    -1,   -1,   -1,  268,  269,   -1,  284,  285,   -1,   -1,
!    -1,   -1,  290,  258,  259,  260,  261,  125,  263,  284,
!   285,   -1,   41,  268,  269,  290,   -1,  258,  259,  260,
!   261,  125,  263,   -1,   -1,   -1,   -1,  268,  269,  258,
!   259,  260,  261,  125,  263,  290,   -1,   -1,   -1,  268,
!   269,   -1,   -1,  284,  285,  125,   -1,   -1,   -1,  290,
!    -1,   -1,   -1,   -1,   -1,  284,  285,   -1,   -1,   -1,
!    -1,  290,  258,  259,  260,  261,   -1,  263,   -1,   -1,
!    40,   -1,  268,  269,  258,  259,  260,  261,   -1,  263,
!    -1,   -1,   -1,   -1,  268,  269,   -1,   -1,  284,  285,
!    60,   -1,   62,   -1,  290,   -1,  125,   -1,   -1,   -1,
!   284,  285,   -1,   -1,   -1,   -1,  290,  258,  259,  260,
!   261,   -1,  263,    6,    7,   41,   -1,  268,  269,   -1,
!   258,  259,  260,  261,   -1,  263,   -1,   -1,   -1,   -1,
!   268,  269,   -1,  284,  285,   28,   29,   -1,   -1,  290,
!   258,  259,  260,  261,   -1,  263,  284,  285,   -1,   -1,
!   268,  269,  290,  123,  258,  259,  260,  261,   -1,  263,
!    -1,   -1,   40,   -1,  268,  269,  258,  259,  260,  261,
!    -1,  263,  290,   -1,   -1,   -1,  268,  269,  258,  259,
!   260,  261,   60,  263,   62,   -1,  290,   -1,  268,  269,
!    -1,   -1,   -1,   -1,   -1,   40,   -1,   -1,  290,  125,
!    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
!   290,  104,   -1,   -1,   -1,   60,   -1,   62,   -1,  112,
!    -1,   -1,   -1,  116,   -1,   -1,   -1,  120,  121,  258,
!   259,  260,  261,   -1,  263,   -1,   -1,   40,   -1,  268,
!   269,   -1,   -1,   -1,   -1,  123,   -1,   -1,   -1,   -1,
!    -1,   -1,   -1,   -1,   -1,   -1,   -1,   60,   -1,   62,
!    -1,  290,   -1,   -1,  157,   -1,  159,   -1,   -1,   -1,
!    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  123,   -1,
!    -1,   -1,   40,   -1,   -1,  178,  179,  257,   -1,   -1,
!    -1,   -1,  262,   -1,  264,  265,  266,  267,  191,  192,
!   270,  271,   60,   -1,   62,  275,  199,  200,  278,  279,
!   280,  281,   -1,   -1,   -1,   -1,  286,  287,  288,  289,
!   123,  291,  292,  293,  294,   60,   -1,   62,   -1,   -1,
!    -1,   -1,  258,  259,  260,  261,   -1,  263,   -1,   -1,
!    -1,   -1,  268,  269,   60,   -1,   62,   -1,   -1,   -1,
!    -1,  244,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  252,
!    -1,   -1,   -1,   -1,  290,  123,   -1,   -1,   -1,   -1,
!    -1,   -1,  265,   -1,   -1,   -1,  269,  270,   -1,  257,
!   273,   -1,   -1,   -1,  262,   -1,  264,  265,  266,  267,
!    -1,   -1,  270,  271,   -1,   -1,   -1,  275,  276,   -1,
!   278,  279,  280,  281,   -1,   -1,   -1,   -1,  286,  287,
!   288,  289,  257,  291,  292,  293,  294,  262,   -1,  264,
!   265,  266,  267,   -1,   -1,  270,  271,   -1,   -1,   -1,
!    -1,  276,   -1,  278,  279,  280,  281,   -1,   -1,   -1,
!    -1,  286,  287,  288,  289,   -1,  291,  292,  293,  294,
!    -1,   -1,   -1,   -1,  257,   -1,   -1,   -1,   -1,  262,
!    -1,  264,  265,  266,  267,   -1,   -1,  270,  271,   -1,
!    -1,   -1,  275,   -1,   -1,  278,  279,  280,  281,   -1,
!    -1,   -1,   -1,  286,  287,  288,  289,   -1,  291,  292,
!   293,  294,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  257,
!    -1,   -1,   -1,   -1,  262,   -1,  264,  265,  266,  267,
!    -1,   -1,  270,  271,   -1,   -1,   -1,   -1,   -1,   -1,
!   278,  279,  280,  281,   -1,   -1,   -1,   -1,  286,  287,
!   288,  289,   -1,  291,  292,  293,  294,   -1,   -1,   -1,
!    -1,   -1,   -1,  278,  279,  280,   -1,   -1,   -1,   -1,
!    -1,  286,  287,  288,  289,   -1,  291,  292,  293,  294,
!    55,   56,   -1,   58,  280,   -1,   61,   -1,   -1,   -1,
!   286,  287,  288,  289,   -1,  291,  292,  293,  294,   -1,
!    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
!    -1,   -1,   -1,   -1,   -1,   -1,   -1,   92,   -1,   94,
!    95,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
!    -1,   -1,   -1,   -1,   -1,  110,   -1,   -1,   -1,   -1,
!    -1,   -1,  117,  118,   -1,   -1,   -1,   -1,   -1,   -1,
!    -1,  126,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
!    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
!    -1,   -1,   -1,   -1,   -1,  150,  151,  152,  153,  154,
!   155,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  164,
!    -1,  166,   -1,   -1,  169,   -1,   -1,   -1,   -1,   -1,
!    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
!    -1,   -1,   -1,  188,   -1,   -1,   -1,   -1,   -1,   -1,
!    -1,   -1,   -1,   -1,   -1,   -1,  201,  202,   -1,   -1,
!    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
!    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
!    -1,   -1,   -1,   -1,   -1,   -1,   -1,  232,   -1,   -1,
!    -1,   -1,   -1,   -1,   -1,  240,   -1,   -1,   -1,   -1,
!   245,  246,  247,   -1,   -1,   -1,   -1,  252,   -1,   -1,
!    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
!   265,   -1,   -1,   -1,   -1,   -1,  271,  272,
  };
! #define YYFINAL 30
! #ifndef YYDEBUG
! #define YYDEBUG 0
! #endif
! #define YYMAXTOKEN 295
! #if YYDEBUG
! const char * const yyname[] = {
! "end-of-file",0,0,0,0,0,0,0,0,0,"'\\n'",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
! 0,0,0,0,0,0,0,"'&'",0,"'('","')'",0,0,0,"'-'",0,0,0,0,0,0,0,0,0,0,0,0,0,"';'",
! "'<'",0,"'>'",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
! 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"'{'","'|'","'}'",0,0,0,0,
! 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
! 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
! 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
! 0,0,0,0,0,0,0,"IF","THEN","ELSE","ELIF","FI","CASE","ESAC","FOR","SELECT",
! "WHILE","UNTIL","DO","DONE","FUNCTION","COND_START","COND_END","COND_ERROR",
! "IN","BANG","TIME","TIMEOPT","WORD","ASSIGNMENT_WORD","NUMBER","ARITH_CMD",
! "ARITH_FOR_EXPRS","COND_CMD","AND_AND","OR_OR","GREATER_GREATER","LESS_LESS",
! "LESS_AND","GREATER_AND","SEMI_SEMI","LESS_LESS_MINUS","AND_GREATER",
! "LESS_GREATER","GREATER_BAR","yacc_EOF",
  };
! const char * const yyrule[] = {
! "$accept : inputunit",
! "inputunit : simple_list '\\n'",
! "inputunit : '\\n'",
! "inputunit : error '\\n'",
! "inputunit : yacc_EOF",
! "word_list : WORD",
! "word_list : word_list WORD",
! "redirection : '>' WORD",
! "redirection : '<' WORD",
! "redirection : NUMBER '>' WORD",
! "redirection : NUMBER '<' WORD",
! "redirection : GREATER_GREATER WORD",
! "redirection : NUMBER GREATER_GREATER WORD",
! "redirection : LESS_LESS WORD",
! "redirection : NUMBER LESS_LESS WORD",
! "redirection : LESS_AND NUMBER",
! "redirection : NUMBER LESS_AND NUMBER",
! "redirection : GREATER_AND NUMBER",
! "redirection : NUMBER GREATER_AND NUMBER",
! "redirection : LESS_AND WORD",
! "redirection : NUMBER LESS_AND WORD",
! "redirection : GREATER_AND WORD",
! "redirection : NUMBER GREATER_AND WORD",
! "redirection : LESS_LESS_MINUS WORD",
! "redirection : NUMBER LESS_LESS_MINUS WORD",
! "redirection : GREATER_AND '-'",
! "redirection : NUMBER GREATER_AND '-'",
! "redirection : LESS_AND '-'",
! "redirection : NUMBER LESS_AND '-'",
! "redirection : AND_GREATER WORD",
! "redirection : NUMBER LESS_GREATER WORD",
! "redirection : LESS_GREATER WORD",
! "redirection : GREATER_BAR WORD",
! "redirection : NUMBER GREATER_BAR WORD",
! "simple_command_element : WORD",
! "simple_command_element : ASSIGNMENT_WORD",
! "simple_command_element : redirection",
! "redirection_list : redirection",
! "redirection_list : redirection_list redirection",
! "simple_command : simple_command_element",
! "simple_command : simple_command simple_command_element",
! "command : simple_command",
! "command : shell_command",
! "command : shell_command redirection_list",
! "command : function_def",
! "shell_command : for_command",
! "shell_command : case_command",
! "shell_command : WHILE compound_list DO compound_list DONE",
! "shell_command : UNTIL compound_list DO compound_list DONE",
! "shell_command : select_command",
! "shell_command : if_command",
! "shell_command : subshell",
! "shell_command : group_command",
! "shell_command : arith_command",
! "shell_command : cond_command",
! "shell_command : arith_for_command",
! "for_command : FOR WORD newline_list DO compound_list DONE",
! "for_command : FOR WORD newline_list '{' compound_list '}'",
! "for_command : FOR WORD ';' newline_list DO compound_list DONE",
! "for_command : FOR WORD ';' newline_list '{' compound_list '}'",
! "for_command : FOR WORD newline_list IN word_list list_terminator newline_list DO compound_list DONE",
! "for_command : FOR WORD newline_list IN word_list list_terminator newline_list '{' compound_list '}'",
! "arith_for_command : FOR ARITH_FOR_EXPRS list_terminator newline_list DO compound_list DONE",
! "arith_for_command : FOR ARITH_FOR_EXPRS list_terminator newline_list '{' compound_list '}'",
! "arith_for_command : FOR ARITH_FOR_EXPRS DO compound_list DONE",
! "arith_for_command : FOR ARITH_FOR_EXPRS '{' compound_list '}'",
! "select_command : SELECT WORD newline_list DO list DONE",
! "select_command : SELECT WORD newline_list '{' list '}'",
! "select_command : SELECT WORD ';' newline_list DO list DONE",
! "select_command : SELECT WORD ';' newline_list '{' list '}'",
! "select_command : SELECT WORD newline_list IN word_list list_terminator newline_list DO list DONE",
! "select_command : SELECT WORD newline_list IN word_list list_terminator newline_list '{' list '}'",
! "case_command : CASE WORD newline_list IN newline_list ESAC",
! "case_command : CASE WORD newline_list IN case_clause_sequence newline_list ESAC",
! "case_command : CASE WORD newline_list IN case_clause ESAC",
! "function_def : WORD '(' ')' newline_list function_body",
! "function_def : FUNCTION WORD '(' ')' newline_list function_body",
! "function_def : FUNCTION WORD newline_list function_body",
! "function_body : shell_command",
! "function_body : shell_command redirection_list",
! "subshell : '(' compound_list ')'",
! "if_command : IF compound_list THEN compound_list FI",
! "if_command : IF compound_list THEN compound_list ELSE compound_list FI",
! "if_command : IF compound_list THEN compound_list elif_clause FI",
! "group_command : '{' compound_list '}'",
! "arith_command : ARITH_CMD",
! "cond_command : COND_START COND_CMD COND_END",
! "elif_clause : ELIF compound_list THEN compound_list",
! "elif_clause : ELIF compound_list THEN compound_list ELSE compound_list",
! "elif_clause : ELIF compound_list THEN compound_list elif_clause",
! "case_clause : pattern_list",
! "case_clause : case_clause_sequence pattern_list",
! "pattern_list : newline_list pattern ')' compound_list",
! "pattern_list : newline_list pattern ')' newline_list",
! "pattern_list : newline_list '(' pattern ')' compound_list",
! "pattern_list : newline_list '(' pattern ')' newline_list",
! "case_clause_sequence : pattern_list SEMI_SEMI",
! "case_clause_sequence : case_clause_sequence pattern_list SEMI_SEMI",
! "pattern : WORD",
! "pattern : pattern '|' WORD",
! "list : newline_list list0",
! "compound_list : list",
! "compound_list : newline_list list1",
! "list0 : list1 '\\n' newline_list",
! "list0 : list1 '&' newline_list",
! "list0 : list1 ';' newline_list",
! "list1 : list1 AND_AND newline_list list1",
! "list1 : list1 OR_OR newline_list list1",
! "list1 : list1 '&' newline_list list1",
! "list1 : list1 ';' newline_list list1",
! "list1 : list1 '\\n' newline_list list1",
! "list1 : pipeline_command",
! "list_terminator : '\\n'",
! "list_terminator : ';'",
! "list_terminator : yacc_EOF",
! "newline_list :",
! "newline_list : newline_list '\\n'",
! "simple_list : simple_list1",
! "simple_list : simple_list1 '&'",
! "simple_list : simple_list1 ';'",
! "simple_list1 : simple_list1 AND_AND newline_list simple_list1",
! "simple_list1 : simple_list1 OR_OR newline_list simple_list1",
! "simple_list1 : simple_list1 '&' simple_list1",
! "simple_list1 : simple_list1 ';' simple_list1",
! "simple_list1 : pipeline_command",
! "pipeline_command : pipeline",
! "pipeline_command : BANG pipeline",
! "pipeline_command : timespec pipeline",
! "pipeline_command : timespec BANG pipeline",
! "pipeline_command : BANG timespec pipeline",
! "pipeline : pipeline '|' newline_list pipeline",
! "pipeline : command",
! "timespec : TIME",
! "timespec : TIME TIMEOPT",
  };
  #endif
! #if YYDEBUG
! #include <stdio.h>
! #endif
! #ifdef YYSTACKSIZE
! #undef YYMAXDEPTH
! #define YYMAXDEPTH YYSTACKSIZE
  #else
! #ifdef YYMAXDEPTH
! #define YYSTACKSIZE YYMAXDEPTH
  #else
! #define YYSTACKSIZE 10000
! #define YYMAXDEPTH 10000
  #endif
  #endif
- #define YYINITSTACKSIZE 200
- int yydebug;
- int yynerrs;
- int yyerrflag;
- int yychar;
- short *yyssp;
- YYSTYPE *yyvsp;
- YYSTYPE yyval;
- YYSTYPE yylval;
- short *yyss;
- short *yysslim;
- YYSTYPE *yyvs;
- int yystacksize;
- #line 815 "/usr/homes/chet/src/bash/src/parse.y"
  
! /* Possible states for the parser that require it to do special things. */
! #define PST_CASEPAT	0x001		/* in a case pattern list */
! #define PST_ALEXPNEXT	0x002		/* expand next word for aliases */
! #define PST_ALLOWOPNBRC	0x004		/* allow open brace for function def */
! #define PST_NEEDCLOSBRC	0x008		/* need close brace */
! #define PST_DBLPAREN	0x010		/* double-paren parsing */
! #define PST_SUBSHELL	0x020		/* ( ... ) subshell */
! #define PST_CMDSUBST	0x040		/* $( ... ) command substitution */
! #define PST_CASESTMT	0x080		/* parsing a case statement */
! #define PST_CONDCMD	0x100		/* parsing a [[...]] command */
! #define PST_CONDEXPR	0x200		/* parsing the guts of [[...]] */
! #define PST_ARITHFOR	0x400		/* parsing an arithmetic for command */
  
! /* Initial size to allocate for tokens, and the
!    amount to grow them by. */
! #define TOKEN_DEFAULT_INITIAL_SIZE 496
! #define TOKEN_DEFAULT_GROW_SIZE 512
  
! /* The token currently being read. */
! static int current_token;
  
! /* The last read token, or NULL.  read_token () uses this for context
!    checking. */
! static int last_read_token;
  
! /* The token read prior to last_read_token. */
! static int token_before_that;
  
! /* The token read prior to token_before_that. */
! static int two_tokens_ago;
  
! /* If non-zero, it is the token that we want read_token to return
!    regardless of what text is (or isn't) present to be read.  This
!    is reset by read_token.  If token_to_read == WORD or
!    ASSIGNMENT_WORD, yylval.word should be set to word_desc_to_read. */
! static int token_to_read;
! static WORD_DESC *word_desc_to_read;
  
! /* The current parser state. */
! static int parser_state;
  
! /* Global var is non-zero when end of file has been reached. */
! int EOF_Reached = 0;
  
! void
! debug_parser (i)
!      int i;
! {
! #if YYDEBUG != 0
!   yydebug = i;
  #endif
- }
  
! /* yy_getc () returns the next available character from input or EOF.
!    yy_ungetc (c) makes `c' the next character to read.
!    init_yy_io (get, unget, type, location) makes the function GET the
!    installed function for getting the next character, makes UNGET the
!    installed function for un-getting a character, sets the type of stream
!    (either string or file) from TYPE, and makes LOCATION point to where
!    the input is coming from. */
  
! /* Unconditionally returns end-of-file. */
! int
! return_EOF ()
  {
!   return (EOF);
  }
  
! /* Variable containing the current get and unget functions.
!    See ./input.h for a clearer description. */
! BASH_INPUT bash_input;
  
! /* Set all of the fields in BASH_INPUT to NULL.  Free bash_input.name if it
!    is non-null, avoiding a memory leak. */
! void
! initialize_bash_input ()
  {
!   bash_input.type = st_none;
!   FREE (bash_input.name);
!   bash_input.name = (char *)NULL;
!   bash_input.location.file = (FILE *)NULL;
!   bash_input.location.string = (char *)NULL;
!   bash_input.getter = (Function *)NULL;
!   bash_input.ungetter = (Function *)NULL;
  }
  
! /* Set the contents of the current bash input stream from
!    GET, UNGET, TYPE, NAME, and LOCATION. */
! void
! init_yy_io (get, unget, type, name, location)
!      Function *get, *unget;
!      enum stream_type type;
!      char *name;
!      INPUT_STREAM location;
! {
!   bash_input.type = type;
!   FREE (bash_input.name);
!   bash_input.name = name ? savestring (name) : (char *)NULL;
  
!   /* XXX */
! #if defined (CRAY)
!   memcpy((char *)&bash_input.location.string, (char *)&location.string, sizeof(location));
  #else
!   bash_input.location = location;
  #endif
-   bash_input.getter = get;
-   bash_input.ungetter = unget;
- }
- 
- /* Call this to get the next character of input. */
- int
- yy_getc ()
- {
-   return (*(bash_input.getter)) ();
- }
  
- /* Call this to unget C.  That is, to make C the next character
-    to be read. */
  int
! yy_ungetc (c)
!      int c;
  {
!   return (*(bash_input.ungetter)) (c);
! }
  
! #if defined (BUFFERED_INPUT)
! int
! input_file_descriptor ()
! {
!   switch (bash_input.type)
!     {
!     case st_stream:
!       return (fileno (bash_input.location.file));
!     case st_bstream:
!       return (bash_input.location.buffered_fd);
!     case st_stdin:
!     default:
!       return (fileno (stdin));
!     }
! }
! #endif /* BUFFERED_INPUT */
  
! /* **************************************************************** */
! /*								    */
! /*		  Let input be read from readline ().		    */
! /*								    */
! /* **************************************************************** */
  
! #if defined (READLINE)
! char *current_readline_prompt = (char *)NULL;
! char *current_readline_line = (char *)NULL;
! int current_readline_line_index = 0;
  
! static int
! yy_readline_get ()
! {
!   SigHandler *old_sigint;
!   int line_len, c;
  
!   if (!current_readline_line)
!     {
!       if (!bash_readline_initialized)
! 	initialize_readline ();
  
! #if defined (JOB_CONTROL)
!       if (job_control)
! 	give_terminal_to (shell_pgrp, 0);
! #endif /* JOB_CONTROL */
  
!       if (signal_is_ignored (SIGINT) == 0)
  	{
! 	  old_sigint = (SigHandler *)set_signal_handler (SIGINT, sigint_sighandler);
! 	  interrupt_immediately++;
  	}
  
!       current_readline_line = readline (current_readline_prompt ?
!       					  current_readline_prompt : "");
  
!       if (signal_is_ignored (SIGINT) == 0)
! 	{
! 	  interrupt_immediately--;
! 	  set_signal_handler (SIGINT, old_sigint);
! 	}
  
! #if 0
!       /* Reset the prompt to the decoded value of prompt_string_pointer. */
!       reset_readline_prompt ();
  #endif
  
!       if (current_readline_line == 0)
! 	return (EOF);
  
!       current_readline_line_index = 0;
!       line_len = strlen (current_readline_line);
  
!       current_readline_line = xrealloc (current_readline_line, 2 + line_len);
!       current_readline_line[line_len++] = '\n';
!       current_readline_line[line_len] = '\0';
!     }
  
!   if (current_readline_line[current_readline_line_index] == 0)
      {
!       free (current_readline_line);
!       current_readline_line = (char *)NULL;
!       return (yy_readline_get ());
      }
-   else
-     {
-       c = (unsigned char)current_readline_line[current_readline_line_index++];
-       return (c);
-     }
- }
- 
- static int
- yy_readline_unget (c)
-      int c;
- {
-   if (current_readline_line_index && current_readline_line)
-     current_readline_line[--current_readline_line_index] = c;
-   return (c);
- }
  
! void
! with_input_from_stdin ()
! {
!   INPUT_STREAM location;
  
!   if (bash_input.type != st_stdin && stream_on_stack (st_stdin) == 0)
      {
!       location.string = current_readline_line;
!       init_yy_io (yy_readline_get, yy_readline_unget,
! 		  st_stdin, "readline stdin", location);
!     }
! }
  
! #else  /* !READLINE */
  
! void
! with_input_from_stdin ()
! {
!   with_input_from_stream (stdin, "stdin");
! }
! #endif	/* !READLINE */
  
! /* **************************************************************** */
! /*								    */
! /*   Let input come from STRING.  STRING is zero terminated.	    */
! /*								    */
! /* **************************************************************** */
  
! static int
! yy_string_get ()
! {
!   register char *string;
!   register int c;
  
!   string = bash_input.location.string;
!   c = EOF;
  
!   /* If the string doesn't exist, or is empty, EOF found. */
!   if (string && *string)
      {
!       c = *(unsigned char *)string++;
!       bash_input.location.string = string;
      }
!   return (c);
! }
! 
! static int
! yy_string_unget (c)
!      int c;
! {
!   *(--bash_input.location.string) = c;
!   return (c);
! }
! 
! void
! with_input_from_string (string, name)
!      char *string, *name;
! {
!   INPUT_STREAM location;
! 
!   location.string = string;
!   init_yy_io (yy_string_get, yy_string_unget, st_string, name, location);
! }
! 
! /* **************************************************************** */
! /*								    */
! /*		     Let input come from STREAM.		    */
! /*								    */
! /* **************************************************************** */
! 
! /* These two functions used to test the value of the HAVE_RESTARTABLE_SYSCALLS
!    define, and just use getc/ungetc if it was defined, but since bash
!    installs its signal handlers without the SA_RESTART flag, some signals
!    (like SIGCHLD, SIGWINCH, etc.) received during a read(2) will not cause
!    the read to be restarted.  We need to restart it ourselves. */
! 
! static int
! yy_stream_get ()
! {
!   int result;
! 
!   result = EOF;
!   if (bash_input.location.file)
!     result = getc_with_restart (bash_input.location.file);
! 
!   return (result);
! }
! 
! static int
! yy_stream_unget (c)
!      int c;
! {
!   return (ungetc_with_restart (c, bash_input.location.file));
! }
  
! void
! with_input_from_stream (stream, name)
!      FILE *stream;
!      char *name;
! {
!   INPUT_STREAM location;
  
!   location.file = stream;
!   init_yy_io (yy_stream_get, yy_stream_unget, st_stream, name, location);
! }
  
! typedef struct stream_saver {
!   struct stream_saver *next;
!   BASH_INPUT bash_input;
!   int line;
! #if defined (BUFFERED_INPUT)
!   BUFFERED_STREAM *bstream;
! #endif /* BUFFERED_INPUT */
! } STREAM_SAVER;
  
! /* The globally known line number. */
! int line_number = 0;
  
! #if defined (COND_COMMAND)
! static int cond_lineno;
! static int cond_token;
  #endif
  
! STREAM_SAVER *stream_list = (STREAM_SAVER *)NULL;
  
! void
! push_stream (reset_lineno)
!      int reset_lineno;
! {
!   STREAM_SAVER *saver = (STREAM_SAVER *)xmalloc (sizeof (STREAM_SAVER));
  
!   xbcopy ((char *)&bash_input, (char *)&(saver->bash_input), sizeof (BASH_INPUT));
  
! #if defined (BUFFERED_INPUT)
!   saver->bstream = (BUFFERED_STREAM *)NULL;
!   /* If we have a buffered stream, clear out buffers[fd]. */
!   if (bash_input.type == st_bstream && bash_input.location.buffered_fd >= 0)
!     saver->bstream = set_buffered_stream (bash_input.location.buffered_fd,
!     					  (BUFFERED_STREAM *)NULL);
! #endif /* BUFFERED_INPUT */
  
!   saver->line = line_number;
!   bash_input.name = (char *)NULL;
!   saver->next = stream_list;
!   stream_list = saver;
!   EOF_Reached = 0;
!   if (reset_lineno)
!     line_number = 0;
! }
  
! void
! pop_stream ()
! {
!   if (!stream_list)
!     EOF_Reached = 1;
!   else
      {
!       STREAM_SAVER *saver = stream_list;
  
!       EOF_Reached = 0;
!       stream_list = stream_list->next;
! 
!       init_yy_io (saver->bash_input.getter,
! 		  saver->bash_input.ungetter,
! 		  saver->bash_input.type,
! 		  saver->bash_input.name,
! 		  saver->bash_input.location);
! 
! #if defined (BUFFERED_INPUT)
!       /* If we have a buffered stream, restore buffers[fd]. */
!       /* If the input file descriptor was changed while this was on the
! 	 save stack, update the buffered fd to the new file descriptor and
! 	 re-establish the buffer <-> bash_input fd correspondence. */
!       if (bash_input.type == st_bstream && bash_input.location.buffered_fd >= 0)
! 	{
! 	  if (bash_input_fd_changed)
! 	    {
! 	      bash_input_fd_changed = 0;
! 	      if (default_buffered_input >= 0)
! 		{
! 		  bash_input.location.buffered_fd = default_buffered_input;
! 		  saver->bstream->b_fd = default_buffered_input;
! 		  SET_CLOSE_ON_EXEC (default_buffered_input);
! 		}
! 	    }
! 	  /* XXX could free buffered stream returned as result here. */
! 	  set_buffered_stream (bash_input.location.buffered_fd, saver->bstream);
! 	}
! #endif /* BUFFERED_INPUT */
! 
!       line_number = saver->line;
  
!       FREE (saver->bash_input.name);
!       free (saver);
      }
! }
  
- /* Return 1 if a stream of type TYPE is saved on the stack. */
- int
- stream_on_stack (type)
-      enum stream_type type;
- {
-   register STREAM_SAVER *s;
  
!   for (s = stream_list; s; s = s->next)
!     if (s->bash_input.type == type)
!       return 1;
!   return 0;
! }
  
! /* Save the current token state and return it in a malloced array. */
! int *
! save_token_state ()
  {
!   int *ret;
! 
!   ret = (int *)xmalloc (3 * sizeof (int));
!   ret[0] = last_read_token;
!   ret[1] = token_before_that;
!   ret[2] = two_tokens_ago;
!   return ret;
! }
! 
! void
! restore_token_state (ts)
!      int *ts;
  {
!   if (ts == 0)
!     return;
!   last_read_token = ts[0];
!   token_before_that = ts[1];
!   two_tokens_ago = ts[2];
! }
! 
! /*
!  * This is used to inhibit alias expansion and reserved word recognition
!  * inside case statement pattern lists.  A `case statement pattern list' is:
!  *
!  *	everything between the `in' in a `case word in' and the next ')'
!  *	or `esac'
!  *	everything between a `;;' and the next `)' or `esac'
!  */
! 
! #if defined (ALIAS) || defined (DPAREN_ARITHMETIC)
! 
! #if !defined (ALIAS)
! typedef void *alias_t;
! #endif
! 
! #define END_OF_ALIAS 0
! 
! /*
!  * Pseudo-global variables used in implementing token-wise alias expansion.
!  */
! 
! /*
!  * Pushing and popping strings.  This works together with shell_getc to
!  * implement alias expansion on a per-token basis.
!  */
! 
! typedef struct string_saver {
!   struct string_saver *next;
!   int expand_alias;  /* Value to set expand_alias to when string is popped. */
!   char *saved_line;
! #if defined (ALIAS)
!   alias_t *expander;   /* alias that caused this line to be pushed. */
! #endif
!   int saved_line_size, saved_line_index, saved_line_terminator;
! } STRING_SAVER;
! 
! STRING_SAVER *pushed_string_list = (STRING_SAVER *)NULL;
! 
! /*
!  * Push the current shell_input_line onto a stack of such lines and make S
!  * the current input.  Used when expanding aliases.  EXPAND is used to set
!  * the value of expand_next_token when the string is popped, so that the
!  * word after the alias in the original line is handled correctly when the
!  * alias expands to multiple words.  TOKEN is the token that was expanded
!  * into S; it is saved and used to prevent infinite recursive expansion.
!  */
! static void
! push_string (s, expand, ap)
!      char *s;
!      int expand;
!      alias_t *ap;
  {
!   STRING_SAVER *temp = (STRING_SAVER *) xmalloc (sizeof (STRING_SAVER));
! 
!   temp->expand_alias = expand;
!   temp->saved_line = shell_input_line;
!   temp->saved_line_size = shell_input_line_size;
!   temp->saved_line_index = shell_input_line_index;
!   temp->saved_line_terminator = shell_input_line_terminator;
! #if defined (ALIAS)
!   temp->expander = ap;
! #endif
!   temp->next = pushed_string_list;
!   pushed_string_list = temp;
! 
! #if defined (ALIAS)
!   if (ap)
!     ap->flags |= AL_BEINGEXPANDED;
! #endif
! 
!   shell_input_line = s;
!   shell_input_line_size = strlen (s);
!   shell_input_line_index = 0;
!   shell_input_line_terminator = '\0';
!   parser_state &= ~PST_ALEXPNEXT;
! }
! 
! /*
!  * Make the top of the pushed_string stack be the current shell input.
!  * Only called when there is something on the stack.  Called from shell_getc
!  * when it thinks it has consumed the string generated by an alias expansion
!  * and needs to return to the original input line.
!  */
! static void
! pop_string ()
  {
!   STRING_SAVER *t;
! 
!   FREE (shell_input_line);
!   shell_input_line = pushed_string_list->saved_line;
!   shell_input_line_index = pushed_string_list->saved_line_index;
!   shell_input_line_size = pushed_string_list->saved_line_size;
!   shell_input_line_terminator = pushed_string_list->saved_line_terminator;
! 
!   if (pushed_string_list->expand_alias)
!     parser_state |= PST_ALEXPNEXT;
!   else
!     parser_state &= ~PST_ALEXPNEXT;
! 
!   t = pushed_string_list;
!   pushed_string_list = pushed_string_list->next;
! 
! #if defined (ALIAS)
!   if (t->expander)
!     t->expander->flags &= ~AL_BEINGEXPANDED;
! #endif
! 
!   free ((char *)t);
! }
! 
! static void
! free_string_list ()
  {
!   register STRING_SAVER *t, *t1;
! 
!   for (t = pushed_string_list; t; )
!     {
!       t1 = t->next;
!       FREE (t->saved_line);
! #if defined (ALIAS)
!       if (t->expander)
! 	t->expander->flags &= ~AL_BEINGEXPANDED;
! #endif
!       free ((char *)t);
!       t = t1;
!     }
!   pushed_string_list = (STRING_SAVER *)NULL;
! }
! 
! #endif /* ALIAS || DPAREN_ARITHMETIC */
! 
! /* Return a line of text, taken from wherever yylex () reads input.
!    If there is no more input, then we return NULL.  If REMOVE_QUOTED_NEWLINE
!    is non-zero, we remove unquoted \<newline> pairs.  This is used by
!    read_secondary_line to read here documents. */
! static char *
! read_a_line (remove_quoted_newline)
!      int remove_quoted_newline;
  {
!   static char *line_buffer = (char *)NULL;
!   static int buffer_size = 0;
!   int indx = 0, c, peekc, pass_next;
! 
! #if defined (READLINE)
!   if (interactive && bash_input.type != st_string && no_line_editing)
! #else
!   if (interactive && bash_input.type != st_string)
! #endif
!     print_prompt ();
! 
!   pass_next = 0;
!   while (1)
!     {
!       c = yy_getc ();
! 
!       /* Allow immediate exit if interrupted during input. */
!       QUIT;
! 
!       /* Ignore null bytes in input. */
!       if (c == 0)
! 	{
! #if 0
! 	  internal_warning ("read_a_line: ignored null byte in input");
! #endif
! 	  continue;
! 	}
! 
!       /* If there is no more input, then we return NULL. */
!       if (c == EOF)
! 	{
! 	  if (interactive && bash_input.type == st_stream)
! 	    clearerr (stdin);
! 	  if (indx == 0)
! 	    return ((char *)NULL);
! 	  c = '\n';
! 	}
! 
!       /* `+2' in case the final character in the buffer is a newline. */
!       RESIZE_MALLOCED_BUFFER (line_buffer, indx, 2, buffer_size, 128);
! 
!       /* IF REMOVE_QUOTED_NEWLINES is non-zero, we are reading a
! 	 here document with an unquoted delimiter.  In this case,
! 	 the line will be expanded as if it were in double quotes.
! 	 We allow a backslash to escape the next character, but we
! 	 need to treat the backslash specially only if a backslash
! 	 quoting a backslash-newline pair appears in the line. */
!       if (pass_next)
! 	{
! 	  line_buffer[indx++] = c;
! 	  pass_next = 0;
! 	}
!       else if (c == '\\' && remove_quoted_newline)
! 	{
! 	  peekc = yy_getc ();
! 	  if (peekc == '\n')
! 	    continue;	/* Make the unquoted \<newline> pair disappear. */
! 	  else
! 	    {
! 	      yy_ungetc (peekc);
! 	      pass_next = 1;
! 	      line_buffer[indx++] = c;		/* Preserve the backslash. */
! 	    }
! 	}
!       else
! 	line_buffer[indx++] = c;
! 
!       if (c == '\n')
! 	{
! 	  line_buffer[indx] = '\0';
! 	  return (line_buffer);
! 	}
!     }
! }
! 
! /* Return a line as in read_a_line (), but insure that the prompt is
!    the secondary prompt.  This is used to read the lines of a here
!    document.  REMOVE_QUOTED_NEWLINE is non-zero if we should remove
!    newlines quoted with backslashes while reading the line.  It is
!    non-zero unless the delimiter of the here document was quoted. */
! char *
! read_secondary_line (remove_quoted_newline)
!      int remove_quoted_newline;
  {
!   prompt_string_pointer = &ps2_prompt;
!   prompt_again ();
!   return (read_a_line (remove_quoted_newline));
! }
! 
! /* **************************************************************** */
! /*								    */
! /*				YYLEX ()			    */
! /*								    */
! /* **************************************************************** */
! 
! /* Reserved words.  These are only recognized as the first word of a
!    command. */
! STRING_INT_ALIST word_token_alist[] = {
!   { "if", IF },
!   { "then", THEN },
!   { "else", ELSE },
!   { "elif", ELIF },
!   { "fi", FI },
!   { "case", CASE },
!   { "esac", ESAC },
!   { "for", FOR },
  #if defined (SELECT_COMMAND)
    { "select", SELECT },
--- 266,2890 ----
    PATTERN_LIST *pattern;
  } YYSTYPE;
! #include <stdio.h>
! 
! #ifndef __cplusplus
! #ifndef __STDC__
! #define const
! #endif
! #endif
! 
! 
! 
! #define	YYFINAL		295
! #define	YYFLAG		-32768
! #define	YYNTBASE	53
! 
! #define YYTRANSLATE(x) ((unsigned)(x) <= 295 ? yytranslate[x] : 88)
! 
! static const char yytranslate[] = {     0,
!      2,     2,     2,     2,     2,     2,     2,     2,     2,    43,
!      2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
!      2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
!      2,     2,     2,     2,     2,     2,     2,    41,     2,    51,
!     52,     2,     2,     2,    48,     2,     2,     2,     2,     2,
!      2,     2,     2,     2,     2,     2,     2,     2,    42,    47,
!      2,    46,     2,     2,     2,     2,     2,     2,     2,     2,
!      2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
!      2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
!      2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
!      2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
!      2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
!      2,     2,    49,    45,    50,     2,     2,     2,     2,     2,
!      2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
!      2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
!      2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
!      2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
!      2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
!      2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
!      2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
!      2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
!      2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
!      2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
!      2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
!      2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
!      2,     2,     2,     2,     2,     1,     3,     4,     5,     6,
!      7,     8,     9,    10,    11,    12,    13,    14,    15,    16,
!     17,    18,    19,    20,    21,    22,    23,    24,    25,    26,
!     27,    28,    29,    30,    31,    32,    33,    34,    35,    36,
!     37,    38,    39,    40,    44
! };
! 
! #if YYDEBUG != 0
! static const short yyprhs[] = {     0,
!      0,     3,     5,     8,    10,    12,    15,    18,    21,    25,
!     29,    32,    36,    39,    43,    46,    50,    53,    57,    60,
!     64,    67,    71,    74,    78,    81,    85,    88,    92,    95,
!     99,   102,   105,   109,   111,   113,   115,   117,   120,   122,
!    125,   127,   129,   132,   134,   136,   138,   144,   150,   152,
!    154,   156,   158,   160,   162,   164,   171,   178,   186,   194,
!    205,   216,   226,   236,   244,   252,   258,   264,   271,   278,
!    286,   294,   305,   316,   323,   331,   338,   344,   351,   356,
!    358,   361,   365,   371,   379,   386,   390,   392,   396,   401,
!    408,   414,   416,   419,   424,   429,   435,   441,   444,   448,
!    450,   454,   457,   459,   462,   466,   470,   474,   479,   484,
!    489,   494,   499,   501,   503,   505,   507,   508,   511,   513,
!    516,   519,   524,   529,   533,   537,   539,   541,   544,   547,
!    551,   555,   560,   562,   564
! };
! 
! static const short yyrhs[] = {    83,
!     43,     0,    43,     0,     1,    43,     0,    44,     0,    24,
!      0,    54,    24,     0,    46,    24,     0,    47,    24,     0,
!     26,    46,    24,     0,    26,    47,    24,     0,    32,    24,
!      0,    26,    32,    24,     0,    33,    24,     0,    26,    33,
!     24,     0,    34,    26,     0,    26,    34,    26,     0,    35,
!     26,     0,    26,    35,    26,     0,    34,    24,     0,    26,
!     34,    24,     0,    35,    24,     0,    26,    35,    24,     0,
!     37,    24,     0,    26,    37,    24,     0,    35,    48,     0,
!     26,    35,    48,     0,    34,    48,     0,    26,    34,    48,
!      0,    38,    24,     0,    26,    39,    24,     0,    39,    24,
!      0,    40,    24,     0,    26,    40,    24,     0,    24,     0,
!     25,     0,    55,     0,    55,     0,    57,    55,     0,    56,
!      0,    58,    56,     0,    58,     0,    60,     0,    60,    57,
!      0,    65,     0,    61,     0,    64,     0,    12,    78,    14,
!     78,    15,     0,    13,    78,    14,    78,    15,     0,    63,
!      0,    68,     0,    67,     0,    69,     0,    70,     0,    71,
!      0,    62,     0,    10,    24,    82,    14,    78,    15,     0,
!     10,    24,    82,    49,    78,    50,     0,    10,    24,    42,
!     82,    14,    78,    15,     0,    10,    24,    42,    82,    49,
!     78,    50,     0,    10,    24,    82,    20,    54,    81,    82,
!     14,    78,    15,     0,    10,    24,    82,    20,    54,    81,
!     82,    49,    78,    50,     0,    10,    24,    82,    20,    81,
!     82,    14,    78,    15,     0,    10,    24,    82,    20,    81,
!     82,    49,    78,    50,     0,    10,    28,    81,    82,    14,
!     78,    15,     0,    10,    28,    81,    82,    49,    78,    50,
!      0,    10,    28,    14,    78,    15,     0,    10,    28,    49,
!     78,    50,     0,    11,    24,    82,    14,    77,    15,     0,
!     11,    24,    82,    49,    77,    50,     0,    11,    24,    42,
!     82,    14,    77,    15,     0,    11,    24,    42,    82,    49,
!     77,    50,     0,    11,    24,    82,    20,    54,    81,    82,
!     14,    77,    15,     0,    11,    24,    82,    20,    54,    81,
!     82,    49,    77,    50,     0,     8,    24,    82,    20,    82,
!      9,     0,     8,    24,    82,    20,    75,    82,     9,     0,
!      8,    24,    82,    20,    73,     9,     0,    24,    51,    52,
!     82,    66,     0,    16,    24,    51,    52,    82,    66,     0,
!     16,    24,    82,    66,     0,    60,     0,    60,    57,     0,
!     51,    78,    52,     0,     3,    78,     4,    78,     7,     0,
!      3,    78,     4,    78,     5,    78,     7,     0,     3,    78,
!      4,    78,    72,     7,     0,    49,    78,    50,     0,    27,
!      0,    17,    29,    18,     0,     6,    78,     4,    78,     0,
!      6,    78,     4,    78,     5,    78,     0,     6,    78,     4,
!     78,    72,     0,    74,     0,    75,    74,     0,    82,    76,
!     52,    78,     0,    82,    76,    52,    82,     0,    82,    51,
!     76,    52,    78,     0,    82,    51,    76,    52,    82,     0,
!     74,    36,     0,    75,    74,    36,     0,    24,     0,    76,
!     45,    24,     0,    82,    79,     0,    77,     0,    82,    80,
!      0,    80,    43,    82,     0,    80,    41,    82,     0,    80,
!     42,    82,     0,    80,    30,    82,    80,     0,    80,    31,
!     82,    80,     0,    80,    41,    82,    80,     0,    80,    42,
!     82,    80,     0,    80,    43,    82,    80,     0,    85,     0,
!     43,     0,    42,     0,    44,     0,     0,    82,    43,     0,
!     84,     0,    84,    41,     0,    84,    42,     0,    84,    30,
!     82,    84,     0,    84,    31,    82,    84,     0,    84,    41,
!     84,     0,    84,    42,    84,     0,    85,     0,    86,     0,
!     21,    86,     0,    87,    86,     0,    87,    21,    86,     0,
!     21,    87,    86,     0,    86,    45,    82,    86,     0,    59,
!      0,    22,     0,    22,    23,     0
  };
! 
! #endif
! 
! #if YYDEBUG != 0
! static const short yyrline[] = { 0,
!    282,   291,   298,   313,   323,   325,   329,   334,   339,   344,
!    349,   354,   359,   365,   371,   376,   381,   386,   391,   396,
!    401,   406,   411,   418,   425,   430,   435,   440,   445,   450,
!    455,   460,   465,   472,   474,   476,   480,   484,   495,   497,
!    501,   503,   505,   521,   525,   527,   529,   531,   533,   535,
!    537,   539,   541,   543,   545,   549,   551,   553,   555,   557,
!    559,   561,   563,   567,   569,   571,   573,   577,   581,   585,
!    589,   593,   597,   603,   605,   607,   611,   614,   617,   622,
!    624,   655,   662,   664,   666,   671,   675,   679,   683,   685,
!    687,   691,   692,   696,   698,   700,   702,   706,   707,   711,
!    713,   722,   730,   731,   737,   738,   745,   749,   751,   753,
!    760,   762,   764,   768,   769,   770,   773,   774,   783,   789,
!    798,   806,   808,   810,   817,   820,   824,   826,   831,   836,
!    841,   848,   851,   855,   857
  };
! #endif
! 
! 
! #if YYDEBUG != 0 || defined (YYERROR_VERBOSE)
! 
! static const char * const yytname[] = {   "$","error","$undefined.","IF","THEN",
! "ELSE","ELIF","FI","CASE","ESAC","FOR","SELECT","WHILE","UNTIL","DO","DONE",
! "FUNCTION","COND_START","COND_END","COND_ERROR","IN","BANG","TIME","TIMEOPT",
! "WORD","ASSIGNMENT_WORD","NUMBER","ARITH_CMD","ARITH_FOR_EXPRS","COND_CMD","AND_AND",
! "OR_OR","GREATER_GREATER","LESS_LESS","LESS_AND","GREATER_AND","SEMI_SEMI","LESS_LESS_MINUS",
! "AND_GREATER","LESS_GREATER","GREATER_BAR","'&'","';'","'\\n'","yacc_EOF","'|'",
! "'>'","'<'","'-'","'{'","'}'","'('","')'","inputunit","word_list","redirection",
! "simple_command_element","redirection_list","simple_command","command","shell_command",
! "for_command","arith_for_command","select_command","case_command","function_def",
! "function_body","subshell","if_command","group_command","arith_command","cond_command",
! "elif_clause","case_clause","pattern_list","case_clause_sequence","pattern",
! "list","compound_list","list0","list1","list_terminator","newline_list","simple_list",
! "simple_list1","pipeline_command","pipeline","timespec", NULL
  };
! #endif
! 
! static const short yyr1[] = {     0,
!     53,    53,    53,    53,    54,    54,    55,    55,    55,    55,
!     55,    55,    55,    55,    55,    55,    55,    55,    55,    55,
!     55,    55,    55,    55,    55,    55,    55,    55,    55,    55,
!     55,    55,    55,    56,    56,    56,    57,    57,    58,    58,
!     59,    59,    59,    59,    60,    60,    60,    60,    60,    60,
!     60,    60,    60,    60,    60,    61,    61,    61,    61,    61,
!     61,    61,    61,    62,    62,    62,    62,    63,    63,    63,
!     63,    63,    63,    64,    64,    64,    65,    65,    65,    66,
!     66,    67,    68,    68,    68,    69,    70,    71,    72,    72,
!     72,    73,    73,    74,    74,    74,    74,    75,    75,    76,
!     76,    77,    78,    78,    79,    79,    79,    80,    80,    80,
!     80,    80,    80,    81,    81,    81,    82,    82,    83,    83,
!     83,    84,    84,    84,    84,    84,    85,    85,    85,    85,
!     85,    86,    86,    87,    87
  };
! 
! static const short yyr2[] = {     0,
!      2,     1,     2,     1,     1,     2,     2,     2,     3,     3,
!      2,     3,     2,     3,     2,     3,     2,     3,     2,     3,
!      2,     3,     2,     3,     2,     3,     2,     3,     2,     3,
!      2,     2,     3,     1,     1,     1,     1,     2,     1,     2,
!      1,     1,     2,     1,     1,     1,     5,     5,     1,     1,
!      1,     1,     1,     1,     1,     6,     6,     7,     7,    10,
!     10,     9,     9,     7,     7,     5,     5,     6,     6,     7,
!      7,    10,    10,     6,     7,     6,     5,     6,     4,     1,
!      2,     3,     5,     7,     6,     3,     1,     3,     4,     6,
!      5,     1,     2,     4,     4,     5,     5,     2,     3,     1,
!      3,     2,     1,     2,     3,     3,     3,     4,     4,     4,
!      4,     4,     1,     1,     1,     1,     0,     2,     1,     2,
!      2,     4,     4,     3,     3,     1,     1,     2,     2,     3,
!      3,     4,     1,     1,     2
  };
! 
! static const short yydefact[] = {     0,
!      0,   117,     0,     0,     0,   117,   117,     0,     0,     0,
!    134,    34,    35,     0,    87,     0,     0,     0,     0,     0,
!      0,     0,     0,     2,     4,     0,     0,   117,   117,    36,
!     39,    41,   133,    42,    45,    55,    49,    46,    44,    51,
!     50,    52,    53,    54,     0,   119,   126,   127,     0,     3,
!    103,     0,     0,   117,   117,     0,   117,     0,     0,   117,
!      0,   128,     0,   135,     0,     0,     0,     0,     0,     0,
!      0,     0,     0,     0,    11,    13,    19,    15,    27,    21,
!     17,    25,    23,    29,    31,    32,     7,     8,     0,     0,
!     34,    40,    37,    43,     1,   117,   117,   120,   121,   117,
!      0,   129,   117,   118,   102,   104,   113,     0,   117,     0,
!    117,   115,   114,   116,   117,   117,   117,     0,   117,   117,
!      0,     0,    88,   131,   117,    12,    14,    20,    16,    28,
!     22,    18,    26,    24,    30,    33,     9,    10,    86,    82,
!     38,     0,     0,   124,   125,     0,   130,     0,   117,   117,
!    117,   117,   117,   117,     0,   117,     0,   117,     0,     0,
!      0,     0,   117,     0,   117,     0,     0,   117,    80,    79,
!      0,   122,   123,     0,     0,   132,   117,   117,    83,     0,
!      0,     0,   106,   107,   105,     0,    92,   117,     0,   117,
!    117,     0,     5,     0,   117,     0,    66,    67,   117,   117,
!    117,   117,     0,     0,     0,     0,    47,    48,     0,    81,
!     77,     0,     0,    85,   108,   109,   110,   111,   112,    76,
!     98,    93,     0,    74,   100,     0,     0,     0,     0,    56,
!      6,   117,     0,    57,     0,     0,     0,     0,    68,     0,
!    117,    69,    78,    84,   117,   117,   117,   117,    99,    75,
!      0,     0,   117,    58,    59,     0,   117,   117,    64,    65,
!     70,    71,     0,    89,     0,     0,     0,   117,   101,    94,
!     95,   117,   117,     0,     0,   117,   117,   117,    91,    96,
!     97,     0,     0,    62,    63,     0,     0,    90,    60,    61,
!     72,    73,     0,     0,     0
  };
! 
! static const short yydefgoto[] = {   293,
!    194,    30,    31,    94,    32,    33,    34,    35,    36,    37,
!     38,    39,   170,    40,    41,    42,    43,    44,   180,   186,
!    187,   188,   227,    51,    52,   105,   106,   116,    53,    45,
!    144,   107,    48,    49
  };
! 
! static const short yypact[] = {   267,
!    -30,-32768,     2,     1,     7,-32768,-32768,    13,    25,   393,
!     17,    29,-32768,   557,-32768,    44,    47,    48,    82,    61,
!     78,    83,   105,-32768,-32768,   111,   125,-32768,-32768,-32768,
! -32768,   178,-32768,   541,-32768,-32768,-32768,-32768,-32768,-32768,
! -32768,-32768,-32768,-32768,    50,    34,-32768,   113,   435,-32768,
! -32768,   155,   309,-32768,   118,    35,   120,   150,   151,   115,
!    149,   113,   519,-32768,   117,   146,   152,   107,   108,   153,
!    159,   164,   171,   173,-32768,-32768,-32768,-32768,-32768,-32768,
! -32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,   123,   156,
! -32768,-32768,-32768,   541,-32768,-32768,-32768,   351,   351,-32768,
!    519,   113,-32768,-32768,-32768,   201,-32768,     0,-32768,    72,
! -32768,-32768,-32768,-32768,-32768,-32768,-32768,    97,-32768,-32768,
!    175,   179,-32768,   113,-32768,-32768,-32768,-32768,-32768,-32768,
! -32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,
! -32768,   309,   309,     4,     4,   477,   113,   137,-32768,-32768,
! -32768,-32768,-32768,-32768,    -2,-32768,   157,-32768,   183,   184,
!     18,    38,-32768,   185,-32768,   192,   208,-32768,   541,-32768,
!    179,-32768,-32768,   351,   351,   113,-32768,-32768,-32768,   222,
!    309,   309,   309,   309,   309,   224,   200,-32768,    12,-32768,
! -32768,   223,-32768,   211,-32768,   187,-32768,-32768,-32768,-32768,
! -32768,-32768,   225,   309,   211,   195,-32768,-32768,   179,   541,
! -32768,   239,   244,-32768,-32768,-32768,    20,    20,    20,-32768,
! -32768,   220,    15,-32768,-32768,   233,   -38,   243,   209,-32768,
! -32768,-32768,    69,-32768,   245,   213,   246,   214,-32768,   201,
! -32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,
!     43,   241,-32768,-32768,-32768,   102,-32768,-32768,-32768,-32768,
! -32768,-32768,   114,    54,   309,   309,   309,-32768,-32768,-32768,
!    309,-32768,-32768,   254,   221,-32768,-32768,-32768,-32768,-32768,
!    309,   258,   226,-32768,-32768,   259,   231,-32768,-32768,-32768,
! -32768,-32768,   282,   285,-32768
  };
! 
! static const short yypgoto[] = {-32768,
!    122,   -32,   255,   121,-32768,-32768,  -118,-32768,-32768,-32768,
! -32768,-32768,  -161,-32768,-32768,-32768,-32768,-32768,    31,-32768,
!    109,-32768,    70,  -157,    -6,-32768,  -166,  -148,   -27,-32768,
!     11,     5,    -7,   288
  };
! 
! 
! #define	YYLAST		604
! 
! 
! static const short yytable[] = {    58,
!     59,    93,    62,   169,    47,   203,   252,   206,   195,   211,
!     46,   190,    50,   253,   215,   216,   217,   218,   219,   154,
!    224,    89,    90,   250,    55,    54,   108,   110,    56,   118,
!     57,   199,   122,    96,    97,   225,    60,   240,   225,    64,
!    104,   102,   104,   237,   238,   232,   191,   243,   111,   149,
!    150,   201,   169,    61,   104,   124,   241,   104,   278,   178,
!    104,   141,   226,    96,    97,   226,   200,    75,   142,   143,
!     76,    77,   146,    78,    98,    99,   112,   113,   114,    65,
!    104,   155,   257,   115,    83,   156,   202,   252,   161,   162,
!    169,   157,    95,   147,   268,    79,   148,   171,   217,   218,
!    219,    84,    47,    47,   159,    80,    85,    81,   160,   145,
!    163,   104,   166,   167,   104,   272,   164,   258,   286,   287,
!    158,   181,   182,   183,   184,   185,   189,   276,    86,    82,
!    128,   131,   129,   132,    87,   204,    93,   204,   176,   104,
!    209,   177,   178,   179,   104,   165,    47,    47,    88,   192,
!    273,   196,   172,   173,   130,   133,   104,   100,   103,   109,
!    223,   117,   277,   119,   120,   121,   123,   233,   125,   126,
!    212,   213,   139,   204,   204,   127,   134,   141,    47,    47,
!    193,     2,   135,   228,   229,   145,     3,   136,     4,     5,
!      6,     7,   235,   236,   137,     9,   138,   197,   112,   113,
!    114,    91,    13,    14,   256,    15,   207,   140,   193,    16,
!     17,    18,    19,   263,    20,    21,    22,    23,   265,   266,
!    267,   104,   208,    26,    27,   271,   168,    28,   214,    29,
!    149,   150,   220,   198,   231,   221,   234,   230,   264,   239,
!    281,   151,   152,   153,   242,   244,   270,   245,   204,   204,
!    274,   275,   112,   113,   114,   249,   225,   254,   255,   259,
!    261,   280,   260,   262,   269,   282,   283,     1,   284,     2,
!    285,   288,   289,   291,     3,   290,     4,     5,     6,     7,
!    292,   294,     8,     9,   295,   205,    92,    10,    11,   210,
!     12,    13,    14,    15,   279,   251,   222,    63,    16,    17,
!     18,    19,     0,    20,    21,    22,    23,     0,     0,    24,
!     25,     2,    26,    27,     0,    28,     3,    29,     4,     5,
!      6,     7,     0,     0,     8,     9,     0,     0,     0,    10,
!     11,     0,    12,    13,    14,    15,     0,     0,     0,     0,
!     16,    17,    18,    19,     0,    20,    21,    22,    23,     0,
!      0,   104,     0,     2,    26,    27,     0,    28,     3,    29,
!      4,     5,     6,     7,     0,     0,     8,     9,     0,     0,
!      0,    10,    11,     0,    12,    13,    14,    15,     0,     0,
!      0,     0,    16,    17,    18,    19,     0,    20,    21,    22,
!     23,     0,     0,     0,     0,     2,    26,    27,     0,    28,
!      3,    29,     4,     5,     6,     7,     0,     0,     8,     9,
!      0,     0,     0,     0,    11,     0,    12,    13,    14,    15,
!      0,     0,     0,     0,    16,    17,    18,    19,     0,    20,
!     21,    22,    23,     0,     0,     0,     0,     2,    26,    27,
!      0,    28,     3,    29,     4,     5,     6,     7,     0,     0,
!      8,     9,     0,     0,     0,   101,     0,     0,    12,    13,
!     14,    15,     0,     0,     0,     0,    16,    17,    18,    19,
!      0,    20,    21,    22,    23,     0,     0,     0,     0,     2,
!     26,    27,     0,    28,     3,    29,     4,     5,     6,     7,
!      0,     0,     8,     9,     0,     0,     0,     0,     0,     0,
!     12,    13,    14,    15,     0,     0,     0,     0,    16,    17,
!     18,    19,     0,    20,    21,    22,    23,     0,     0,   104,
!      0,     2,    26,    27,     0,    28,     3,    29,     4,     5,
!      6,     7,     0,     0,     8,     9,     0,     0,     0,     0,
!      0,     0,    12,    13,    14,    15,     0,     0,     0,     0,
!     16,    17,    18,    19,     0,    20,    21,    22,    23,     0,
!      0,     0,     0,     0,    26,    27,    14,    28,     0,    29,
!      0,     0,    16,    17,    18,    19,     0,    20,    21,    22,
!     23,     0,     0,     0,     0,     0,    26,    27,    66,    67,
!     68,    69,     0,    70,     0,    71,    72,     0,     0,     0,
!      0,     0,    73,    74
  };
! 
! static const short yycheck[] = {     6,
!      7,    34,    10,   122,     0,   163,    45,   165,   157,   171,
!      0,    14,    43,    52,   181,   182,   183,   184,   185,    20,
!      9,    28,    29,     9,    24,    24,    54,    55,    28,    57,
!     24,    14,    60,    30,    31,    24,    24,   204,    24,    23,
!     43,    49,    43,   201,   202,   194,    49,   209,    14,    30,
!     31,    14,   171,    29,    43,    63,   205,    43,     5,     6,
!     43,    94,    51,    30,    31,    51,    49,    24,    96,    97,
!     24,    24,   100,    26,    41,    42,    42,    43,    44,    51,
!     43,   109,    14,    49,    24,    14,    49,    45,   116,   117,
!    209,    20,    43,   101,    52,    48,   103,   125,   265,   266,
!    267,    24,    98,    99,   111,    24,    24,    26,   115,    99,
!     14,    43,   119,   120,    43,    14,    20,    49,   276,   277,
!     49,   149,   150,   151,   152,   153,   154,    14,    24,    48,
!     24,    24,    26,    26,    24,   163,   169,   165,   146,    43,
!    168,     5,     6,     7,    43,    49,   142,   143,    24,   156,
!     49,   158,   142,   143,    48,    48,    43,    45,     4,    42,
!    188,    42,    49,    14,    14,    51,    18,   195,    52,    24,
!    177,   178,    50,   201,   202,    24,    24,   210,   174,   175,
!     24,     3,    24,   190,   191,   175,     8,    24,    10,    11,
!     12,    13,   199,   200,    24,    17,    24,    15,    42,    43,
!     44,    24,    25,    26,   232,    27,    15,    52,    24,    32,
!     33,    34,    35,   241,    37,    38,    39,    40,   246,   247,
!    248,    43,    15,    46,    47,   253,    52,    49,     7,    51,
!     30,    31,     9,    50,    24,    36,    50,    15,   245,    15,
!    268,    41,    42,    43,    50,     7,   253,     4,   276,   277,
!    257,   258,    42,    43,    44,    36,    24,    15,    50,    15,
!     15,   268,    50,    50,    24,   272,   273,     1,    15,     3,
!     50,   278,    15,    15,     8,    50,    10,    11,    12,    13,
!     50,     0,    16,    17,     0,   164,    32,    21,    22,   169,
!     24,    25,    26,    27,   264,   226,   188,    10,    32,    33,
!     34,    35,    -1,    37,    38,    39,    40,    -1,    -1,    43,
!     44,     3,    46,    47,    -1,    49,     8,    51,    10,    11,
!     12,    13,    -1,    -1,    16,    17,    -1,    -1,    -1,    21,
!     22,    -1,    24,    25,    26,    27,    -1,    -1,    -1,    -1,
!     32,    33,    34,    35,    -1,    37,    38,    39,    40,    -1,
!     -1,    43,    -1,     3,    46,    47,    -1,    49,     8,    51,
!     10,    11,    12,    13,    -1,    -1,    16,    17,    -1,    -1,
!     -1,    21,    22,    -1,    24,    25,    26,    27,    -1,    -1,
!     -1,    -1,    32,    33,    34,    35,    -1,    37,    38,    39,
!     40,    -1,    -1,    -1,    -1,     3,    46,    47,    -1,    49,
!      8,    51,    10,    11,    12,    13,    -1,    -1,    16,    17,
!     -1,    -1,    -1,    -1,    22,    -1,    24,    25,    26,    27,
!     -1,    -1,    -1,    -1,    32,    33,    34,    35,    -1,    37,
!     38,    39,    40,    -1,    -1,    -1,    -1,     3,    46,    47,
!     -1,    49,     8,    51,    10,    11,    12,    13,    -1,    -1,
!     16,    17,    -1,    -1,    -1,    21,    -1,    -1,    24,    25,
!     26,    27,    -1,    -1,    -1,    -1,    32,    33,    34,    35,
!     -1,    37,    38,    39,    40,    -1,    -1,    -1,    -1,     3,
!     46,    47,    -1,    49,     8,    51,    10,    11,    12,    13,
!     -1,    -1,    16,    17,    -1,    -1,    -1,    -1,    -1,    -1,
!     24,    25,    26,    27,    -1,    -1,    -1,    -1,    32,    33,
!     34,    35,    -1,    37,    38,    39,    40,    -1,    -1,    43,
!     -1,     3,    46,    47,    -1,    49,     8,    51,    10,    11,
!     12,    13,    -1,    -1,    16,    17,    -1,    -1,    -1,    -1,
!     -1,    -1,    24,    25,    26,    27,    -1,    -1,    -1,    -1,
!     32,    33,    34,    35,    -1,    37,    38,    39,    40,    -1,
!     -1,    -1,    -1,    -1,    46,    47,    26,    49,    -1,    51,
!     -1,    -1,    32,    33,    34,    35,    -1,    37,    38,    39,
!     40,    -1,    -1,    -1,    -1,    -1,    46,    47,    32,    33,
!     34,    35,    -1,    37,    -1,    39,    40,    -1,    -1,    -1,
!     -1,    -1,    46,    47
  };
+ /* -*-C-*-  Note some compilers choke on comments on `#line' lines.  */
+ #line 3 "/usr/local/share/bison.simple"
+ /* This file comes from bison-1.28.  */
+ 
+ /* Skeleton output parser for bison,
+    Copyright (C) 1984, 1989, 1990 Free Software Foundation, Inc.
+ 
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2, or (at your option)
+    any later version.
+ 
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+ 
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place - Suite 330,
+    Boston, MA 02111-1307, USA.  */
+ 
+ /* As a special exception, when this file is copied by Bison into a
+    Bison output file, you may use that output file without restriction.
+    This special exception was added by the Free Software Foundation
+    in version 1.24 of Bison.  */
+ 
+ /* This is the parser code that is written into each bison parser
+   when the %semantic_parser declaration is not specified in the grammar.
+   It was written by Richard Stallman by simplifying the hairy parser
+   used when %semantic_parser is specified.  */
+ 
+ #ifndef YYSTACK_USE_ALLOCA
+ #ifdef alloca
+ #define YYSTACK_USE_ALLOCA
+ #else /* alloca not defined */
+ #ifdef __GNUC__
+ #define YYSTACK_USE_ALLOCA
+ #define alloca __builtin_alloca
+ #else /* not GNU C.  */
+ #if (!defined (__STDC__) && defined (sparc)) || defined (__sparc__) || defined (__sparc) || defined (__sgi) || (defined (__sun) && defined (__i386))
+ #define YYSTACK_USE_ALLOCA
+ #include <alloca.h>
+ #else /* not sparc */
+ /* We think this test detects Watcom and Microsoft C.  */
+ /* This used to test MSDOS, but that is a bad idea
+    since that symbol is in the user namespace.  */
+ #if (defined (_MSDOS) || defined (_MSDOS_)) && !defined (__TURBOC__)
+ #if 0 /* No need for malloc.h, which pollutes the namespace;
+ 	 instead, just don't use alloca.  */
+ #include <malloc.h>
+ #endif
+ #else /* not MSDOS, or __TURBOC__ */
+ #if defined(_AIX)
+ /* I don't know what this was needed for, but it pollutes the namespace.
+    So I turned it off.   rms, 2 May 1997.  */
+ /* #include <malloc.h>  */
+  #pragma alloca
+ #define YYSTACK_USE_ALLOCA
+ #else /* not MSDOS, or __TURBOC__, or _AIX */
+ #if 0
+ #ifdef __hpux /* haible@ilog.fr says this works for HPUX 9.05 and up,
+ 		 and on HPUX 10.  Eventually we can turn this on.  */
+ #define YYSTACK_USE_ALLOCA
+ #define alloca __builtin_alloca
+ #endif /* __hpux */
+ #endif
+ #endif /* not _AIX */
+ #endif /* not MSDOS, or __TURBOC__ */
+ #endif /* not sparc */
+ #endif /* not GNU C */
+ #endif /* alloca not defined */
+ #endif /* YYSTACK_USE_ALLOCA not defined */
+ 
+ #ifdef YYSTACK_USE_ALLOCA
+ #define YYSTACK_ALLOC alloca
+ #else
+ #define YYSTACK_ALLOC malloc
  #endif
! 
! /* Note: there must be only one dollar sign in this file.
!    It is replaced by the list of actions, each action
!    as one case of the switch.  */
! 
! #define yyerrok		(yyerrstatus = 0)
! #define yyclearin	(yychar = YYEMPTY)
! #define YYEMPTY		-2
! #define YYEOF		0
! #define YYACCEPT	goto yyacceptlab
! #define YYABORT 	goto yyabortlab
! #define YYERROR		goto yyerrlab1
! /* Like YYERROR except do call yyerror.
!    This remains here temporarily to ease the
!    transition to the new meaning of YYERROR, for GCC.
!    Once GCC version 2 has supplanted version 1, this can go.  */
! #define YYFAIL		goto yyerrlab
! #define YYRECOVERING()  (!!yyerrstatus)
! #define YYBACKUP(token, value) \
! do								\
!   if (yychar == YYEMPTY && yylen == 1)				\
!     { yychar = (token), yylval = (value);			\
!       yychar1 = YYTRANSLATE (yychar);				\
!       YYPOPSTACK;						\
!       goto yybackup;						\
!     }								\
!   else								\
!     { yyerror ("syntax error: cannot back up"); YYERROR; }	\
! while (0)
! 
! #define YYTERROR	1
! #define YYERRCODE	256
! 
! #ifndef YYPURE
! #define YYLEX		yylex()
! #endif
! 
! #ifdef YYPURE
! #ifdef YYLSP_NEEDED
! #ifdef YYLEX_PARAM
! #define YYLEX		yylex(&yylval, &yylloc, YYLEX_PARAM)
  #else
! #define YYLEX		yylex(&yylval, &yylloc)
! #endif
! #else /* not YYLSP_NEEDED */
! #ifdef YYLEX_PARAM
! #define YYLEX		yylex(&yylval, YYLEX_PARAM)
  #else
! #define YYLEX		yylex(&yylval)
  #endif
+ #endif /* not YYLSP_NEEDED */
  #endif
  
! /* If nonreentrant, generate the variables here */
  
! #ifndef YYPURE
  
! int	yychar;			/*  the lookahead symbol		*/
! YYSTYPE	yylval;			/*  the semantic value of the		*/
! 				/*  lookahead symbol			*/
  
! #ifdef YYLSP_NEEDED
! YYLTYPE yylloc;			/*  location data for the lookahead	*/
! 				/*  symbol				*/
! #endif
  
! int yynerrs;			/*  number of parse errors so far       */
! #endif  /* not YYPURE */
  
! #if YYDEBUG != 0
! int yydebug;			/*  nonzero means print parse trace	*/
! /* Since this is uninitialized, it does not stop multiple parsers
!    from coexisting.  */
! #endif
  
! /*  YYINITDEPTH indicates the initial size of the parser's stacks	*/
  
! #ifndef	YYINITDEPTH
! #define YYINITDEPTH 200
! #endif
  
! /*  YYMAXDEPTH is the maximum size the stacks can grow to
!     (effective only if the built-in stack extension method is used).  */
  
! #if YYMAXDEPTH == 0
! #undef YYMAXDEPTH
  #endif
  
! #ifndef YYMAXDEPTH
! #define YYMAXDEPTH 10000
! #endif
! 
! /* Define __yy_memcpy.  Note that the size argument
!    should be passed with type unsigned int, because that is what the non-GCC
!    definitions require.  With GCC, __builtin_memcpy takes an arg
!    of type size_t, but it can handle unsigned int.  */
! 
! #if __GNUC__ > 1		/* GNU C and GNU C++ define this.  */
! #define __yy_memcpy(TO,FROM,COUNT)	__builtin_memcpy(TO,FROM,COUNT)
! #else				/* not GNU C or C++ */
! #ifndef __cplusplus
  
! /* This is the most reliable way to avoid incompatibilities
!    in available built-in functions on various systems.  */
! static void
! __yy_memcpy (to, from, count)
!      char *to;
!      char *from;
!      unsigned int count;
  {
!   register char *f = from;
!   register char *t = to;
!   register int i = count;
! 
!   while (i-- > 0)
!     *t++ = *f++;
  }
  
! #else /* __cplusplus */
  
! /* This is the most reliable way to avoid incompatibilities
!    in available built-in functions on various systems.  */
! static void
! __yy_memcpy (char *to, char *from, unsigned int count)
  {
!   register char *t = to;
!   register char *f = from;
!   register int i = count;
! 
!   while (i-- > 0)
!     *t++ = *f++;
  }
  
! #endif
! #endif
! 
! #line 217 "/usr/local/share/bison.simple"
  
! /* The user can define YYPARSE_PARAM as the name of an argument to be passed
!    into yyparse.  The argument should have type void *.
!    It should actually point to an object.
!    Grammar actions can access the variable by casting it
!    to the proper pointer type.  */
! 
! #ifdef YYPARSE_PARAM
! #ifdef __cplusplus
! #define YYPARSE_PARAM_ARG void *YYPARSE_PARAM
! #define YYPARSE_PARAM_DECL
! #else /* not __cplusplus */
! #define YYPARSE_PARAM_ARG YYPARSE_PARAM
! #define YYPARSE_PARAM_DECL void *YYPARSE_PARAM;
! #endif /* not __cplusplus */
! #else /* not YYPARSE_PARAM */
! #define YYPARSE_PARAM_ARG
! #define YYPARSE_PARAM_DECL
! #endif /* not YYPARSE_PARAM */
! 
! /* Prevent warning if -Wstrict-prototypes.  */
! #ifdef __GNUC__
! #ifdef YYPARSE_PARAM
! int yyparse (void *);
  #else
! int yyparse (void);
! #endif
  #endif
  
  int
! yyparse(YYPARSE_PARAM_ARG)
!      YYPARSE_PARAM_DECL
  {
!   register int yystate;
!   register int yyn;
!   register short *yyssp;
!   register YYSTYPE *yyvsp;
!   int yyerrstatus;	/*  number of tokens to shift before error messages enabled */
!   int yychar1 = 0;		/*  lookahead token as an internal (translated) token number */
! 
!   short	yyssa[YYINITDEPTH];	/*  the state stack			*/
!   YYSTYPE yyvsa[YYINITDEPTH];	/*  the semantic value stack		*/
! 
!   short *yyss = yyssa;		/*  refer to the stacks thru separate pointers */
!   YYSTYPE *yyvs = yyvsa;	/*  to allow yyoverflow to reallocate them elsewhere */
! 
! #ifdef YYLSP_NEEDED
!   YYLTYPE yylsa[YYINITDEPTH];	/*  the location stack			*/
!   YYLTYPE *yyls = yylsa;
!   YYLTYPE *yylsp;
  
! #define YYPOPSTACK   (yyvsp--, yyssp--, yylsp--)
! #else
! #define YYPOPSTACK   (yyvsp--, yyssp--)
! #endif
  
!   int yystacksize = YYINITDEPTH;
!   int yyfree_stacks = 0;
  
! #ifdef YYPURE
!   int yychar;
!   YYSTYPE yylval;
!   int yynerrs;
! #ifdef YYLSP_NEEDED
!   YYLTYPE yylloc;
! #endif
! #endif
  
!   YYSTYPE yyval;		/*  the variable used to return		*/
! 				/*  semantic values from the action	*/
! 				/*  routines				*/
  
!   int yylen;
  
! #if YYDEBUG != 0
!   if (yydebug)
!     fprintf(stderr, "Starting parse\n");
! #endif
  
!   yystate = 0;
!   yyerrstatus = 0;
!   yynerrs = 0;
!   yychar = YYEMPTY;		/* Cause a token to be read.  */
! 
!   /* Initialize stack pointers.
!      Waste one element of value and location stack
!      so that they stay on the same level as the state stack.
!      The wasted elements are never initialized.  */
! 
!   yyssp = yyss - 1;
!   yyvsp = yyvs;
! #ifdef YYLSP_NEEDED
!   yylsp = yyls;
! #endif
! 
! /* Push a new state, which is found in  yystate  .  */
! /* In all cases, when you get here, the value and location stacks
!    have just been pushed. so pushing a state here evens the stacks.  */
! yynewstate:
! 
!   *++yyssp = yystate;
! 
!   if (yyssp >= yyss + yystacksize - 1)
!     {
!       /* Give user a chance to reallocate the stack */
!       /* Use copies of these so that the &'s don't force the real ones into memory. */
!       YYSTYPE *yyvs1 = yyvs;
!       short *yyss1 = yyss;
! #ifdef YYLSP_NEEDED
!       YYLTYPE *yyls1 = yyls;
! #endif
! 
!       /* Get the current used size of the three stacks, in elements.  */
!       int size = yyssp - yyss + 1;
! 
! #ifdef yyoverflow
!       /* Each stack pointer address is followed by the size of
! 	 the data in use in that stack, in bytes.  */
! #ifdef YYLSP_NEEDED
!       /* This used to be a conditional around just the two extra args,
! 	 but that might be undefined if yyoverflow is a macro.  */
!       yyoverflow("parser stack overflow",
! 		 &yyss1, size * sizeof (*yyssp),
! 		 &yyvs1, size * sizeof (*yyvsp),
! 		 &yyls1, size * sizeof (*yylsp),
! 		 &yystacksize);
! #else
!       yyoverflow("parser stack overflow",
! 		 &yyss1, size * sizeof (*yyssp),
! 		 &yyvs1, size * sizeof (*yyvsp),
! 		 &yystacksize);
! #endif
! 
!       yyss = yyss1; yyvs = yyvs1;
! #ifdef YYLSP_NEEDED
!       yyls = yyls1;
! #endif
! #else /* no yyoverflow */
!       /* Extend the stack our own way.  */
!       if (yystacksize >= YYMAXDEPTH)
  	{
! 	  yyerror("parser stack overflow");
! 	  if (yyfree_stacks)
! 	    {
! 	      free (yyss);
! 	      free (yyvs);
! #ifdef YYLSP_NEEDED
! 	      free (yyls);
! #endif
! 	    }
! 	  return 2;
  	}
+       yystacksize *= 2;
+       if (yystacksize > YYMAXDEPTH)
+ 	yystacksize = YYMAXDEPTH;
+ #ifndef YYSTACK_USE_ALLOCA
+       yyfree_stacks = 1;
+ #endif
+       yyss = (short *) YYSTACK_ALLOC (yystacksize * sizeof (*yyssp));
+       __yy_memcpy ((char *)yyss, (char *)yyss1,
+ 		   size * (unsigned int) sizeof (*yyssp));
+       yyvs = (YYSTYPE *) YYSTACK_ALLOC (yystacksize * sizeof (*yyvsp));
+       __yy_memcpy ((char *)yyvs, (char *)yyvs1,
+ 		   size * (unsigned int) sizeof (*yyvsp));
+ #ifdef YYLSP_NEEDED
+       yyls = (YYLTYPE *) YYSTACK_ALLOC (yystacksize * sizeof (*yylsp));
+       __yy_memcpy ((char *)yyls, (char *)yyls1,
+ 		   size * (unsigned int) sizeof (*yylsp));
+ #endif
+ #endif /* no yyoverflow */
+ 
+       yyssp = yyss + size - 1;
+       yyvsp = yyvs + size - 1;
+ #ifdef YYLSP_NEEDED
+       yylsp = yyls + size - 1;
+ #endif
  
! #if YYDEBUG != 0
!       if (yydebug)
! 	fprintf(stderr, "Stack size increased to %d\n", yystacksize);
! #endif
  
!       if (yyssp >= yyss + yystacksize - 1)
! 	YYABORT;
!     }
  
! #if YYDEBUG != 0
!   if (yydebug)
!     fprintf(stderr, "Entering state %d\n", yystate);
  #endif
  
!   goto yybackup;
!  yybackup:
  
! /* Do appropriate processing given the current state.  */
! /* Read a lookahead token if we need one and don't already have one.  */
! /* yyresume: */
  
!   /* First try to decide what to do without reference to lookahead token.  */
  
!   yyn = yypact[yystate];
!   if (yyn == YYFLAG)
!     goto yydefault;
! 
!   /* Not known => get a lookahead token if don't already have one.  */
! 
!   /* yychar is either YYEMPTY or YYEOF
!      or a valid token in external form.  */
! 
!   if (yychar == YYEMPTY)
      {
! #if YYDEBUG != 0
!       if (yydebug)
! 	fprintf(stderr, "Reading a token: ");
! #endif
!       yychar = YYLEX;
      }
  
!   /* Convert token to internal form (in yychar1) for indexing tables with */
  
!   if (yychar <= 0)		/* This means end of input. */
      {
!       yychar1 = 0;
!       yychar = YYEOF;		/* Don't call YYLEX any more */
  
! #if YYDEBUG != 0
!       if (yydebug)
! 	fprintf(stderr, "Now at end of input.\n");
! #endif
!     }
!   else
!     {
!       yychar1 = YYTRANSLATE(yychar);
  
! #if YYDEBUG != 0
!       if (yydebug)
! 	{
! 	  fprintf (stderr, "Next token is %d (%s", yychar, yytname[yychar1]);
! 	  /* Give the individual parser a way to print the precise meaning
! 	     of a token, for further debugging info.  */
! #ifdef YYPRINT
! 	  YYPRINT (stderr, yychar, yylval);
! #endif
! 	  fprintf (stderr, ")\n");
! 	}
! #endif
!     }
  
!   yyn += yychar1;
!   if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != yychar1)
!     goto yydefault;
  
!   yyn = yytable[yyn];
  
!   /* yyn is what to do for this token type in this state.
!      Negative => reduce, -yyn is rule number.
!      Positive => shift, yyn is new state.
!        New state is final state => don't bother to shift,
!        just return success.
!      0, or most negative number => error.  */
  
!   if (yyn < 0)
      {
!       if (yyn == YYFLAG)
! 	goto yyerrlab;
!       yyn = -yyn;
!       goto yyreduce;
      }
!   else if (yyn == 0)
!     goto yyerrlab;
  
!   if (yyn == YYFINAL)
!     YYACCEPT;
  
!   /* Shift the lookahead token.  */
  
! #if YYDEBUG != 0
!   if (yydebug)
!     fprintf(stderr, "Shifting token %d (%s), ", yychar, yytname[yychar1]);
! #endif
  
!   /* Discard the token being shifted unless it is eof.  */
!   if (yychar != YYEOF)
!     yychar = YYEMPTY;
  
!   *++yyvsp = yylval;
! #ifdef YYLSP_NEEDED
!   *++yylsp = yylloc;
  #endif
  
!   /* count tokens shifted since error; after three, turn off error status.  */
!   if (yyerrstatus) yyerrstatus--;
  
!   yystate = yyn;
!   goto yynewstate;
  
! /* Do the default action for the current state.  */
! yydefault:
  
!   yyn = yydefact[yystate];
!   if (yyn == 0)
!     goto yyerrlab;
  
! /* Do a reduction.  yyn is the number of a rule to reduce with.  */
! yyreduce:
!   yylen = yyr2[yyn];
!   if (yylen > 0)
!     yyval = yyvsp[1-yylen]; /* implement default value of the action */
  
! #if YYDEBUG != 0
!   if (yydebug)
      {
!       int i;
  
!       fprintf (stderr, "Reducing via rule %d (line %d), ",
! 	       yyn, yyrline[yyn]);
  
!       /* Print the symbols being reduced, and their result.  */
!       for (i = yyprhs[yyn]; yyrhs[i] > 0; i++)
! 	fprintf (stderr, "%s ", yytname[yyrhs[i]]);
!       fprintf (stderr, " -> %s\n", yytname[yyr1[yyn]]);
      }
! #endif
  
  
!   switch (yyn) {
  
! case 1:
! #line 283 "/usr/homes/chet/src/bash/src/parse.y"
  {
! 			  /* Case of regular command.  Discard the error
! 			     safety net,and return the command just parsed. */
! 			  global_command = yyvsp[-1].command;
! 			  eof_encountered = 0;
! 			  discard_parser_constructs (0);
! 			  YYACCEPT;
! 			;
!     break;}
! case 2:
! #line 292 "/usr/homes/chet/src/bash/src/parse.y"
  {
! 			  /* Case of regular command, but not a very
! 			     interesting one.  Return a NULL command. */
! 			  global_command = (COMMAND *)NULL;
! 			  YYACCEPT;
! 			;
!     break;}
! case 3:
! #line 299 "/usr/homes/chet/src/bash/src/parse.y"
  {
! 			  /* Error during parsing.  Return NULL command. */
! 			  global_command = (COMMAND *)NULL;
! 			  eof_encountered = 0;
! 			  discard_parser_constructs (1);
! 			  if (interactive)
! 			    {
! 			      YYACCEPT;
! 			    }
! 			  else
! 			    {
! 			      YYABORT;
! 			    }
! 			;
!     break;}
! case 4:
! #line 314 "/usr/homes/chet/src/bash/src/parse.y"
  {
! 			  /* Case of EOF seen by itself.  Do ignoreeof or
! 			     not. */
! 			  global_command = (COMMAND *)NULL;
! 			  handle_eof_input_unit ();
! 			  YYACCEPT;
! 			;
!     break;}
! case 5:
! #line 324 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.word_list = make_word_list (yyvsp[0].word, (WORD_LIST *)NULL); ;
!     break;}
! case 6:
! #line 326 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.word_list = make_word_list (yyvsp[0].word, yyvsp[-1].word_list); ;
!     break;}
! case 7:
! #line 330 "/usr/homes/chet/src/bash/src/parse.y"
  {
! 			  redir.filename = yyvsp[0].word;
! 			  yyval.redirect = make_redirection (1, r_output_direction, redir);
! 			;
!     break;}
! case 8:
! #line 335 "/usr/homes/chet/src/bash/src/parse.y"
  {
! 			  redir.filename = yyvsp[0].word;
! 			  yyval.redirect = make_redirection (0, r_input_direction, redir);
! 			;
!     break;}
! case 9:
! #line 340 "/usr/homes/chet/src/bash/src/parse.y"
  {
! 			  redir.filename = yyvsp[0].word;
! 			  yyval.redirect = make_redirection (yyvsp[-2].number, r_output_direction, redir);
! 			;
!     break;}
! case 10:
! #line 345 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  redir.filename = yyvsp[0].word;
! 			  yyval.redirect = make_redirection (yyvsp[-2].number, r_input_direction, redir);
! 			;
!     break;}
! case 11:
! #line 350 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  redir.filename = yyvsp[0].word;
! 			  yyval.redirect = make_redirection (1, r_appending_to, redir);
! 			;
!     break;}
! case 12:
! #line 355 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  redir.filename = yyvsp[0].word;
! 			  yyval.redirect = make_redirection (yyvsp[-2].number, r_appending_to, redir);
! 			;
!     break;}
! case 13:
! #line 360 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  redir.filename = yyvsp[0].word;
! 			  yyval.redirect = make_redirection (0, r_reading_until, redir);
! 			  redir_stack[need_here_doc++] = yyval.redirect;
! 			;
!     break;}
! case 14:
! #line 366 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  redir.filename = yyvsp[0].word;
! 			  yyval.redirect = make_redirection (yyvsp[-2].number, r_reading_until, redir);
! 			  redir_stack[need_here_doc++] = yyval.redirect;
! 			;
!     break;}
! case 15:
! #line 372 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  redir.dest = yyvsp[0].number;
! 			  yyval.redirect = make_redirection (0, r_duplicating_input, redir);
! 			;
!     break;}
! case 16:
! #line 377 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  redir.dest = yyvsp[0].number;
! 			  yyval.redirect = make_redirection (yyvsp[-2].number, r_duplicating_input, redir);
! 			;
!     break;}
! case 17:
! #line 382 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  redir.dest = yyvsp[0].number;
! 			  yyval.redirect = make_redirection (1, r_duplicating_output, redir);
! 			;
!     break;}
! case 18:
! #line 387 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  redir.dest = yyvsp[0].number;
! 			  yyval.redirect = make_redirection (yyvsp[-2].number, r_duplicating_output, redir);
! 			;
!     break;}
! case 19:
! #line 392 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  redir.filename = yyvsp[0].word;
! 			  yyval.redirect = make_redirection (0, r_duplicating_input_word, redir);
! 			;
!     break;}
! case 20:
! #line 397 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  redir.filename = yyvsp[0].word;
! 			  yyval.redirect = make_redirection (yyvsp[-2].number, r_duplicating_input_word, redir);
! 			;
!     break;}
! case 21:
! #line 402 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  redir.filename = yyvsp[0].word;
! 			  yyval.redirect = make_redirection (1, r_duplicating_output_word, redir);
! 			;
!     break;}
! case 22:
! #line 407 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  redir.filename = yyvsp[0].word;
! 			  yyval.redirect = make_redirection (yyvsp[-2].number, r_duplicating_output_word, redir);
! 			;
!     break;}
! case 23:
! #line 412 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  redir.filename = yyvsp[0].word;
! 			  yyval.redirect = make_redirection
! 			    (0, r_deblank_reading_until, redir);
! 			  redir_stack[need_here_doc++] = yyval.redirect;
! 			;
!     break;}
! case 24:
! #line 419 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  redir.filename = yyvsp[0].word;
! 			  yyval.redirect = make_redirection
! 			    (yyvsp[-2].number, r_deblank_reading_until, redir);
! 			  redir_stack[need_here_doc++] = yyval.redirect;
! 			;
!     break;}
! case 25:
! #line 426 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  redir.dest = 0;
! 			  yyval.redirect = make_redirection (1, r_close_this, redir);
! 			;
!     break;}
! case 26:
! #line 431 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  redir.dest = 0;
! 			  yyval.redirect = make_redirection (yyvsp[-2].number, r_close_this, redir);
! 			;
!     break;}
! case 27:
! #line 436 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  redir.dest = 0;
! 			  yyval.redirect = make_redirection (0, r_close_this, redir);
! 			;
!     break;}
! case 28:
! #line 441 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  redir.dest = 0;
! 			  yyval.redirect = make_redirection (yyvsp[-2].number, r_close_this, redir);
! 			;
!     break;}
! case 29:
! #line 446 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  redir.filename = yyvsp[0].word;
! 			  yyval.redirect = make_redirection (1, r_err_and_out, redir);
! 			;
!     break;}
! case 30:
! #line 451 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  redir.filename = yyvsp[0].word;
! 			  yyval.redirect = make_redirection (yyvsp[-2].number, r_input_output, redir);
! 			;
!     break;}
! case 31:
! #line 456 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  redir.filename = yyvsp[0].word;
! 			  yyval.redirect = make_redirection (0, r_input_output, redir);
! 			;
!     break;}
! case 32:
! #line 461 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  redir.filename = yyvsp[0].word;
! 			  yyval.redirect = make_redirection (1, r_output_force, redir);
! 			;
!     break;}
! case 33:
! #line 466 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  redir.filename = yyvsp[0].word;
! 			  yyval.redirect = make_redirection (yyvsp[-2].number, r_output_force, redir);
! 			;
!     break;}
! case 34:
! #line 473 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.element.word = yyvsp[0].word; yyval.element.redirect = 0; ;
!     break;}
! case 35:
! #line 475 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.element.word = yyvsp[0].word; yyval.element.redirect = 0; ;
!     break;}
! case 36:
! #line 477 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.element.redirect = yyvsp[0].redirect; yyval.element.word = 0; ;
!     break;}
! case 37:
! #line 481 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  yyval.redirect = yyvsp[0].redirect;
! 			;
!     break;}
! case 38:
! #line 485 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  register REDIRECT *t;
! 
! 			  for (t = yyvsp[-1].redirect; t->next; t = t->next)
! 			    ;
! 			  t->next = yyvsp[0].redirect;
! 			  yyval.redirect = yyvsp[-1].redirect;
! 			;
!     break;}
! case 39:
! #line 496 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = make_simple_command (yyvsp[0].element, (COMMAND *)NULL); ;
!     break;}
! case 40:
! #line 498 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = make_simple_command (yyvsp[0].element, yyvsp[-1].command); ;
!     break;}
! case 41:
! #line 502 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = clean_simple_command (yyvsp[0].command); ;
!     break;}
! case 42:
! #line 504 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = yyvsp[0].command; ;
!     break;}
! case 43:
! #line 506 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  COMMAND *tc;
! 
! 			  tc = yyvsp[-1].command;
! 			  if (tc->redirects)
! 			    {
! 			      register REDIRECT *t;
! 			      for (t = tc->redirects; t->next; t = t->next)
! 				;
! 			      t->next = yyvsp[0].redirect;
! 			    }
! 			  else
! 			    tc->redirects = yyvsp[0].redirect;
! 			  yyval.command = yyvsp[-1].command;
! 			;
!     break;}
! case 44:
! #line 522 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = yyvsp[0].command; ;
!     break;}
! case 45:
! #line 526 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = yyvsp[0].command; ;
!     break;}
! case 46:
! #line 528 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = yyvsp[0].command; ;
!     break;}
! case 47:
! #line 530 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = make_while_command (yyvsp[-3].command, yyvsp[-1].command); ;
!     break;}
! case 48:
! #line 532 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = make_until_command (yyvsp[-3].command, yyvsp[-1].command); ;
!     break;}
! case 49:
! #line 534 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = yyvsp[0].command; ;
!     break;}
! case 50:
! #line 536 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = yyvsp[0].command; ;
!     break;}
! case 51:
! #line 538 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = yyvsp[0].command; ;
!     break;}
! case 52:
! #line 540 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = yyvsp[0].command; ;
!     break;}
! case 53:
! #line 542 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = yyvsp[0].command; ;
!     break;}
! case 54:
! #line 544 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = yyvsp[0].command; ;
!     break;}
! case 55:
! #line 546 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = yyvsp[0].command; ;
!     break;}
! case 56:
! #line 550 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = make_for_command (yyvsp[-4].word, add_string_to_list ("\"$@\"", (WORD_LIST *)NULL), yyvsp[-1].command); ;
!     break;}
! case 57:
! #line 552 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = make_for_command (yyvsp[-4].word, add_string_to_list ("$@", (WORD_LIST *)NULL), yyvsp[-1].command); ;
!     break;}
! case 58:
! #line 554 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = make_for_command (yyvsp[-5].word, add_string_to_list ("\"$@\"", (WORD_LIST *)NULL), yyvsp[-1].command); ;
!     break;}
! case 59:
! #line 556 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = make_for_command (yyvsp[-5].word, add_string_to_list ("\"$@\"", (WORD_LIST *)NULL), yyvsp[-1].command); ;
!     break;}
! case 60:
! #line 558 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = make_for_command (yyvsp[-8].word, REVERSE_LIST (yyvsp[-5].word_list, WORD_LIST *), yyvsp[-1].command); ;
!     break;}
! case 61:
! #line 560 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = make_for_command (yyvsp[-8].word, REVERSE_LIST (yyvsp[-5].word_list, WORD_LIST *), yyvsp[-1].command); ;
!     break;}
! case 62:
! #line 562 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = make_for_command (yyvsp[-7].word, (WORD_LIST *)NULL, yyvsp[-1].command); ;
!     break;}
! case 63:
! #line 564 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = make_for_command (yyvsp[-7].word, (WORD_LIST *)NULL, yyvsp[-1].command); ;
!     break;}
! case 64:
! #line 568 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = make_arith_for_command (yyvsp[-5].word_list, yyvsp[-1].command, arith_for_lineno); ;
!     break;}
! case 65:
! #line 570 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = make_arith_for_command (yyvsp[-5].word_list, yyvsp[-1].command, arith_for_lineno); ;
!     break;}
! case 66:
! #line 572 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = make_arith_for_command (yyvsp[-3].word_list, yyvsp[-1].command, arith_for_lineno); ;
!     break;}
! case 67:
! #line 574 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = make_arith_for_command (yyvsp[-3].word_list, yyvsp[-1].command, arith_for_lineno); ;
!     break;}
! case 68:
! #line 578 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  yyval.command = make_select_command (yyvsp[-4].word, add_string_to_list ("\"$@\"", (WORD_LIST *)NULL), yyvsp[-1].command);
! 			;
!     break;}
! case 69:
! #line 582 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  yyval.command = make_select_command (yyvsp[-4].word, add_string_to_list ("$@", (WORD_LIST *)NULL), yyvsp[-1].command);
! 			;
!     break;}
! case 70:
! #line 586 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  yyval.command = make_select_command (yyvsp[-5].word, add_string_to_list ("\"$@\"", (WORD_LIST *)NULL), yyvsp[-1].command);
! 			;
!     break;}
! case 71:
! #line 590 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  yyval.command = make_select_command (yyvsp[-5].word, add_string_to_list ("\"$@\"", (WORD_LIST *)NULL), yyvsp[-1].command);
! 			;
!     break;}
! case 72:
! #line 594 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  yyval.command = make_select_command (yyvsp[-8].word, (WORD_LIST *)reverse_list (yyvsp[-5].word_list), yyvsp[-1].command);
! 			;
!     break;}
! case 73:
! #line 598 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  yyval.command = make_select_command (yyvsp[-8].word, (WORD_LIST *)reverse_list (yyvsp[-5].word_list), yyvsp[-1].command);
! 			;
!     break;}
! case 74:
! #line 604 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = make_case_command (yyvsp[-4].word, (PATTERN_LIST *)NULL); ;
!     break;}
! case 75:
! #line 606 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = make_case_command (yyvsp[-5].word, yyvsp[-2].pattern); ;
!     break;}
! case 76:
! #line 608 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = make_case_command (yyvsp[-4].word, yyvsp[-1].pattern); ;
!     break;}
! case 77:
! #line 612 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = make_function_def (yyvsp[-4].word, yyvsp[0].command, function_dstart, function_bstart); ;
!     break;}
! case 78:
! #line 615 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = make_function_def (yyvsp[-4].word, yyvsp[0].command, function_dstart, function_bstart); ;
!     break;}
! case 79:
! #line 618 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = make_function_def (yyvsp[-2].word, yyvsp[0].command, function_dstart, function_bstart); ;
!     break;}
! case 80:
! #line 623 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = yyvsp[0].command; ;
!     break;}
! case 81:
! #line 625 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  COMMAND *tc;
! 
! 			  tc = yyvsp[-1].command;
! 			  /* According to Posix.2 3.9.5, redirections
! 			     specified after the body of a function should
! 			     be attached to the function and performed when
! 			     the function is executed, not as part of the
! 			     function definition command. */
! 			  /* XXX - I don't think it matters, but we might
! 			     want to change this in the future to avoid
! 			     problems differentiating between a function
! 			     definition with a redirection and a function
! 			     definition containing a single command with a
! 			     redirection.  The two are semantically equivalent,
! 			     though -- the only difference is in how the
! 			     command printing code displays the redirections. */
! 			  if (tc->redirects)
! 			    {
! 			      register REDIRECT *t;
! 			      for (t = tc->redirects; t->next; t = t->next)
! 				;
! 			      t->next = yyvsp[0].redirect;
! 			    }
! 			  else
! 			    tc->redirects = yyvsp[0].redirect;
! 			  yyval.command = yyvsp[-1].command;
! 			;
!     break;}
! case 82:
! #line 656 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  yyval.command = make_subshell_command (yyvsp[-1].command);
! 			  yyval.command->flags |= CMD_WANT_SUBSHELL;
! 			;
!     break;}
! case 83:
! #line 663 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = make_if_command (yyvsp[-3].command, yyvsp[-1].command, (COMMAND *)NULL); ;
!     break;}
! case 84:
! #line 665 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = make_if_command (yyvsp[-5].command, yyvsp[-3].command, yyvsp[-1].command); ;
!     break;}
! case 85:
! #line 667 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = make_if_command (yyvsp[-4].command, yyvsp[-2].command, yyvsp[-1].command); ;
!     break;}
! case 86:
! #line 672 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = make_group_command (yyvsp[-1].command); ;
!     break;}
! case 87:
! #line 676 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = make_arith_command (yyvsp[0].word_list); ;
!     break;}
! case 88:
! #line 680 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = yyvsp[-1].command; ;
!     break;}
! case 89:
! #line 684 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = make_if_command (yyvsp[-2].command, yyvsp[0].command, (COMMAND *)NULL); ;
!     break;}
! case 90:
! #line 686 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = make_if_command (yyvsp[-4].command, yyvsp[-2].command, yyvsp[0].command); ;
!     break;}
! case 91:
! #line 688 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = make_if_command (yyvsp[-3].command, yyvsp[-1].command, yyvsp[0].command); ;
!     break;}
! case 93:
! #line 693 "/usr/homes/chet/src/bash/src/parse.y"
! { yyvsp[0].pattern->next = yyvsp[-1].pattern; yyval.pattern = yyvsp[0].pattern; ;
!     break;}
! case 94:
! #line 697 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.pattern = make_pattern_list (yyvsp[-2].word_list, yyvsp[0].command); ;
!     break;}
! case 95:
! #line 699 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.pattern = make_pattern_list (yyvsp[-2].word_list, (COMMAND *)NULL); ;
!     break;}
! case 96:
! #line 701 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.pattern = make_pattern_list (yyvsp[-2].word_list, yyvsp[0].command); ;
!     break;}
! case 97:
! #line 703 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.pattern = make_pattern_list (yyvsp[-2].word_list, (COMMAND *)NULL); ;
!     break;}
! case 99:
! #line 708 "/usr/homes/chet/src/bash/src/parse.y"
! { yyvsp[-1].pattern->next = yyvsp[-2].pattern; yyval.pattern = yyvsp[-1].pattern; ;
!     break;}
! case 100:
! #line 712 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.word_list = make_word_list (yyvsp[0].word, (WORD_LIST *)NULL); ;
!     break;}
! case 101:
! #line 714 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.word_list = make_word_list (yyvsp[0].word, yyvsp[-2].word_list); ;
!     break;}
! case 102:
! #line 723 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  yyval.command = yyvsp[0].command;
! 			  if (need_here_doc)
! 			    gather_here_documents ();
! 			 ;
!     break;}
! case 104:
! #line 732 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  yyval.command = yyvsp[0].command;
! 			;
!     break;}
! case 106:
! #line 739 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  if (yyvsp[-2].command->type == cm_connection)
! 			    yyval.command = connect_async_list (yyvsp[-2].command, (COMMAND *)NULL, '&');
! 			  else
! 			    yyval.command = command_connect (yyvsp[-2].command, (COMMAND *)NULL, '&');
! 			;
!     break;}
! case 108:
! #line 750 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = command_connect (yyvsp[-3].command, yyvsp[0].command, AND_AND); ;
!     break;}
! case 109:
! #line 752 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = command_connect (yyvsp[-3].command, yyvsp[0].command, OR_OR); ;
!     break;}
! case 110:
! #line 754 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  if (yyvsp[-3].command->type == cm_connection)
! 			    yyval.command = connect_async_list (yyvsp[-3].command, yyvsp[0].command, '&');
! 			  else
! 			    yyval.command = command_connect (yyvsp[-3].command, yyvsp[0].command, '&');
! 			;
!     break;}
! case 111:
! #line 761 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = command_connect (yyvsp[-3].command, yyvsp[0].command, ';'); ;
!     break;}
! case 112:
! #line 763 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = command_connect (yyvsp[-3].command, yyvsp[0].command, ';'); ;
!     break;}
! case 113:
! #line 765 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = yyvsp[0].command; ;
!     break;}
! case 119:
! #line 784 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  yyval.command = yyvsp[0].command;
! 			  if (need_here_doc)
! 			    gather_here_documents ();
! 			;
!     break;}
! case 120:
! #line 790 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  if (yyvsp[-1].command->type == cm_connection)
! 			    yyval.command = connect_async_list (yyvsp[-1].command, (COMMAND *)NULL, '&');
! 			  else
! 			    yyval.command = command_connect (yyvsp[-1].command, (COMMAND *)NULL, '&');
! 			  if (need_here_doc)
! 			    gather_here_documents ();
! 			;
!     break;}
! case 121:
! #line 799 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  yyval.command = yyvsp[-1].command;
! 			  if (need_here_doc)
! 			    gather_here_documents ();
! 			;
!     break;}
! case 122:
! #line 807 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = command_connect (yyvsp[-3].command, yyvsp[0].command, AND_AND); ;
!     break;}
! case 123:
! #line 809 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = command_connect (yyvsp[-3].command, yyvsp[0].command, OR_OR); ;
!     break;}
! case 124:
! #line 811 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  if (yyvsp[-2].command->type == cm_connection)
! 			    yyval.command = connect_async_list (yyvsp[-2].command, yyvsp[0].command, '&');
! 			  else
! 			    yyval.command = command_connect (yyvsp[-2].command, yyvsp[0].command, '&');
! 			;
!     break;}
! case 125:
! #line 818 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = command_connect (yyvsp[-2].command, yyvsp[0].command, ';'); ;
!     break;}
! case 126:
! #line 821 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = yyvsp[0].command; ;
!     break;}
! case 127:
! #line 825 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = yyvsp[0].command; ;
!     break;}
! case 128:
! #line 827 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  yyvsp[0].command->flags |= CMD_INVERT_RETURN;
! 			  yyval.command = yyvsp[0].command;
! 			;
!     break;}
! case 129:
! #line 832 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  yyvsp[0].command->flags |= yyvsp[-1].number;
! 			  yyval.command = yyvsp[0].command;
! 			;
!     break;}
! case 130:
! #line 837 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  yyvsp[0].command->flags |= yyvsp[-2].number|CMD_INVERT_RETURN;
! 			  yyval.command = yyvsp[0].command;
! 			;
!     break;}
! case 131:
! #line 842 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  yyvsp[0].command->flags |= yyvsp[-1].number|CMD_INVERT_RETURN;
! 			  yyval.command = yyvsp[0].command;
! 			;
!     break;}
! case 132:
! #line 850 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = command_connect (yyvsp[-3].command, yyvsp[0].command, '|'); ;
!     break;}
! case 133:
! #line 852 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = yyvsp[0].command; ;
!     break;}
! case 134:
! #line 856 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.number = CMD_TIME_PIPELINE; ;
!     break;}
! case 135:
! #line 858 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.number = CMD_TIME_PIPELINE|CMD_TIME_POSIX; ;
!     break;}
! }
!    /* the action file gets copied in in place of this dollarsign */
! #line 543 "/usr/local/share/bison.simple"
! 
!   yyvsp -= yylen;
!   yyssp -= yylen;
! #ifdef YYLSP_NEEDED
!   yylsp -= yylen;
! #endif
! 
! #if YYDEBUG != 0
!   if (yydebug)
!     {
!       short *ssp1 = yyss - 1;
!       fprintf (stderr, "state stack now");
!       while (ssp1 != yyssp)
! 	fprintf (stderr, " %d", *++ssp1);
!       fprintf (stderr, "\n");
!     }
! #endif
! 
!   *++yyvsp = yyval;
! 
! #ifdef YYLSP_NEEDED
!   yylsp++;
!   if (yylen == 0)
!     {
!       yylsp->first_line = yylloc.first_line;
!       yylsp->first_column = yylloc.first_column;
!       yylsp->last_line = (yylsp-1)->last_line;
!       yylsp->last_column = (yylsp-1)->last_column;
!       yylsp->text = 0;
!     }
!   else
!     {
!       yylsp->last_line = (yylsp+yylen-1)->last_line;
!       yylsp->last_column = (yylsp+yylen-1)->last_column;
!     }
! #endif
! 
!   /* Now "shift" the result of the reduction.
!      Determine what state that goes to,
!      based on the state we popped back to
!      and the rule number reduced by.  */
! 
!   yyn = yyr1[yyn];
! 
!   yystate = yypgoto[yyn - YYNTBASE] + *yyssp;
!   if (yystate >= 0 && yystate <= YYLAST && yycheck[yystate] == *yyssp)
!     yystate = yytable[yystate];
!   else
!     yystate = yydefgoto[yyn - YYNTBASE];
! 
!   goto yynewstate;
! 
! yyerrlab:   /* here on detecting error */
! 
!   if (! yyerrstatus)
!     /* If not already recovering from an error, report this error.  */
!     {
!       ++yynerrs;
! 
! #ifdef YYERROR_VERBOSE
!       yyn = yypact[yystate];
! 
!       if (yyn > YYFLAG && yyn < YYLAST)
! 	{
! 	  int size = 0;
! 	  char *msg;
! 	  int x, count;
! 
! 	  count = 0;
! 	  /* Start X at -yyn if nec to avoid negative indexes in yycheck.  */
! 	  for (x = (yyn < 0 ? -yyn : 0);
! 	       x < (sizeof(yytname) / sizeof(char *)); x++)
! 	    if (yycheck[x + yyn] == x)
! 	      size += strlen(yytname[x]) + 15, count++;
! 	  msg = (char *) malloc(size + 15);
! 	  if (msg != 0)
! 	    {
! 	      strcpy(msg, "parse error");
! 
! 	      if (count < 5)
! 		{
! 		  count = 0;
! 		  for (x = (yyn < 0 ? -yyn : 0);
! 		       x < (sizeof(yytname) / sizeof(char *)); x++)
! 		    if (yycheck[x + yyn] == x)
! 		      {
! 			strcat(msg, count == 0 ? ", expecting `" : " or `");
! 			strcat(msg, yytname[x]);
! 			strcat(msg, "'");
! 			count++;
! 		      }
! 		}
! 	      yyerror(msg);
! 	      free(msg);
! 	    }
! 	  else
! 	    yyerror ("parse error; also virtual memory exceeded");
! 	}
!       else
! #endif /* YYERROR_VERBOSE */
! 	yyerror("parse error");
!     }
! 
!   goto yyerrlab1;
! yyerrlab1:   /* here on error raised explicitly by an action */
! 
!   if (yyerrstatus == 3)
!     {
!       /* if just tried and failed to reuse lookahead token after an error, discard it.  */
! 
!       /* return failure if at end of input */
!       if (yychar == YYEOF)
! 	YYABORT;
! 
! #if YYDEBUG != 0
!       if (yydebug)
! 	fprintf(stderr, "Discarding token %d (%s).\n", yychar, yytname[yychar1]);
! #endif
! 
!       yychar = YYEMPTY;
!     }
! 
!   /* Else will try to reuse lookahead token
!      after shifting the error token.  */
! 
!   yyerrstatus = 3;		/* Each real token shifted decrements this */
! 
!   goto yyerrhandle;
! 
! yyerrdefault:  /* current state does not do anything special for the error token. */
! 
! #if 0
!   /* This is wrong; only states that explicitly want error tokens
!      should shift them.  */
!   yyn = yydefact[yystate];  /* If its default is to accept any token, ok.  Otherwise pop it.*/
!   if (yyn) goto yydefault;
! #endif
! 
! yyerrpop:   /* pop the current state because it cannot handle the error token */
! 
!   if (yyssp == yyss) YYABORT;
!   yyvsp--;
!   yystate = *--yyssp;
! #ifdef YYLSP_NEEDED
!   yylsp--;
! #endif
! 
! #if YYDEBUG != 0
!   if (yydebug)
!     {
!       short *ssp1 = yyss - 1;
!       fprintf (stderr, "Error: state stack now");
!       while (ssp1 != yyssp)
! 	fprintf (stderr, " %d", *++ssp1);
!       fprintf (stderr, "\n");
!     }
! #endif
! 
! yyerrhandle:
! 
!   yyn = yypact[yystate];
!   if (yyn == YYFLAG)
!     goto yyerrdefault;
! 
!   yyn += YYTERROR;
!   if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != YYTERROR)
!     goto yyerrdefault;
! 
!   yyn = yytable[yyn];
!   if (yyn < 0)
!     {
!       if (yyn == YYFLAG)
! 	goto yyerrpop;
!       yyn = -yyn;
!       goto yyreduce;
!     }
!   else if (yyn == 0)
!     goto yyerrpop;
! 
!   if (yyn == YYFINAL)
!     YYACCEPT;
! 
! #if YYDEBUG != 0
!   if (yydebug)
!     fprintf(stderr, "Shifting error token, ");
! #endif
! 
!   *++yyvsp = yylval;
! #ifdef YYLSP_NEEDED
!   *++yylsp = yylloc;
! #endif
! 
!   yystate = yyn;
!   goto yynewstate;
! 
!  yyacceptlab:
!   /* YYACCEPT comes here.  */
!   if (yyfree_stacks)
!     {
!       free (yyss);
!       free (yyvs);
! #ifdef YYLSP_NEEDED
!       free (yyls);
! #endif
!     }
!   return 0;
! 
!  yyabortlab:
!   /* YYABORT comes here.  */
!   if (yyfree_stacks)
!     {
!       free (yyss);
!       free (yyvs);
! #ifdef YYLSP_NEEDED
!       free (yyls);
! #endif
!     }
!   return 1;
! }
! #line 860 "/usr/homes/chet/src/bash/src/parse.y"
! 
! 
! /* Possible states for the parser that require it to do special things. */
! #define PST_CASEPAT	0x001		/* in a case pattern list */
! #define PST_ALEXPNEXT	0x002		/* expand next word for aliases */
! #define PST_ALLOWOPNBRC	0x004		/* allow open brace for function def */
! #define PST_NEEDCLOSBRC	0x008		/* need close brace */
! #define PST_DBLPAREN	0x010		/* double-paren parsing */
! #define PST_SUBSHELL	0x020		/* ( ... ) subshell */
! #define PST_CMDSUBST	0x040		/* $( ... ) command substitution */
! #define PST_CASESTMT	0x080		/* parsing a case statement */
! #define PST_CONDCMD	0x100		/* parsing a [[...]] command */
! #define PST_CONDEXPR	0x200		/* parsing the guts of [[...]] */
! #define PST_ARITHFOR	0x400		/* parsing an arithmetic for command */
! 
! /* Initial size to allocate for tokens, and the
!    amount to grow them by. */
! #define TOKEN_DEFAULT_INITIAL_SIZE 496
! #define TOKEN_DEFAULT_GROW_SIZE 512
! 
! /* The token currently being read. */
! static int current_token;
! 
! /* The last read token, or NULL.  read_token () uses this for context
!    checking. */
! static int last_read_token;
! 
! /* The token read prior to last_read_token. */
! static int token_before_that;
! 
! /* The token read prior to token_before_that. */
! static int two_tokens_ago;
! 
! /* If non-zero, it is the token that we want read_token to return
!    regardless of what text is (or isn't) present to be read.  This
!    is reset by read_token.  If token_to_read == WORD or
!    ASSIGNMENT_WORD, yylval.word should be set to word_desc_to_read. */
! static int token_to_read;
! static WORD_DESC *word_desc_to_read;
! 
! /* The current parser state. */
! static int parser_state;
! 
! /* Global var is non-zero when end of file has been reached. */
! int EOF_Reached = 0;
! 
! #ifdef DEBUG
! static void
! debug_parser (i)
!      int i;
! {
! #if YYDEBUG != 0
!   yydebug = i;
! #endif
! }
! #endif
! 
! /* yy_getc () returns the next available character from input or EOF.
!    yy_ungetc (c) makes `c' the next character to read.
!    init_yy_io (get, unget, type, location) makes the function GET the
!    installed function for getting the next character, makes UNGET the
!    installed function for un-getting a character, sets the type of stream
!    (either string or file) from TYPE, and makes LOCATION point to where
!    the input is coming from. */
! 
! /* Unconditionally returns end-of-file. */
! int
! return_EOF ()
! {
!   return (EOF);
! }
! 
! /* Variable containing the current get and unget functions.
!    See ./input.h for a clearer description. */
! BASH_INPUT bash_input;
! 
! /* Set all of the fields in BASH_INPUT to NULL.  Free bash_input.name if it
!    is non-null, avoiding a memory leak. */
! void
! initialize_bash_input ()
! {
!   bash_input.type = st_none;
!   FREE (bash_input.name);
!   bash_input.name = (char *)NULL;
!   bash_input.location.file = (FILE *)NULL;
!   bash_input.location.string = (char *)NULL;
!   bash_input.getter = (sh_cget_func_t *)NULL;
!   bash_input.ungetter = (sh_cunget_func_t *)NULL;
! }
! 
! /* Set the contents of the current bash input stream from
!    GET, UNGET, TYPE, NAME, and LOCATION. */
! void
! init_yy_io (get, unget, type, name, location)
!      sh_cget_func_t *get;
!      sh_cunget_func_t *unget;
!      enum stream_type type;
!      const char *name;
!      INPUT_STREAM location;
! {
!   bash_input.type = type;
!   FREE (bash_input.name);
!   bash_input.name = name ? savestring (name) : (char *)NULL;
! 
!   /* XXX */
! #if defined (CRAY)
!   memcpy((char *)&bash_input.location.string, (char *)&location.string, sizeof(location));
! #else
!   bash_input.location = location;
! #endif
!   bash_input.getter = get;
!   bash_input.ungetter = unget;
! }
! 
! /* Call this to get the next character of input. */
! static int
! yy_getc ()
! {
!   return (*(bash_input.getter)) ();
! }
! 
! /* Call this to unget C.  That is, to make C the next character
!    to be read. */
! static int
! yy_ungetc (c)
!      int c;
! {
!   return (*(bash_input.ungetter)) (c);
! }
! 
! #if defined (BUFFERED_INPUT)
! #ifdef INCLUDE_UNUSED
! int
! input_file_descriptor ()
! {
!   switch (bash_input.type)
!     {
!     case st_stream:
!       return (fileno (bash_input.location.file));
!     case st_bstream:
!       return (bash_input.location.buffered_fd);
!     case st_stdin:
!     default:
!       return (fileno (stdin));
!     }
! }
! #endif
! #endif /* BUFFERED_INPUT */
! 
! /* **************************************************************** */
! /*								    */
! /*		  Let input be read from readline ().		    */
! /*								    */
! /* **************************************************************** */
! 
! #if defined (READLINE)
! char *current_readline_prompt = (char *)NULL;
! char *current_readline_line = (char *)NULL;
! int current_readline_line_index = 0;
! 
! static int
! yy_readline_get ()
! {
!   SigHandler *old_sigint;
!   int line_len;
!   unsigned char c;
! 
!   if (!current_readline_line)
!     {
!       if (!bash_readline_initialized)
! 	initialize_readline ();
! 
! #if defined (JOB_CONTROL)
!       if (job_control)
! 	give_terminal_to (shell_pgrp, 0);
! #endif /* JOB_CONTROL */
! 
!       old_sigint = (SigHandler *)NULL;
!       if (signal_is_ignored (SIGINT) == 0)
! 	{
! 	  old_sigint = (SigHandler *)set_signal_handler (SIGINT, sigint_sighandler);
! 	  interrupt_immediately++;
! 	}
! 
!       current_readline_line = readline (current_readline_prompt ?
!       					  current_readline_prompt : "");
! 
!       if (signal_is_ignored (SIGINT) == 0 && old_sigint)
! 	{
! 	  interrupt_immediately--;
! 	  set_signal_handler (SIGINT, old_sigint);
! 	}
! 
! #if 0
!       /* Reset the prompt to the decoded value of prompt_string_pointer. */
!       reset_readline_prompt ();
! #endif
! 
!       if (current_readline_line == 0)
! 	return (EOF);
! 
!       current_readline_line_index = 0;
!       line_len = strlen (current_readline_line);
! 
!       current_readline_line = (char *)xrealloc (current_readline_line, 2 + line_len);
!       current_readline_line[line_len++] = '\n';
!       current_readline_line[line_len] = '\0';
!     }
! 
!   if (current_readline_line[current_readline_line_index] == 0)
!     {
!       free (current_readline_line);
!       current_readline_line = (char *)NULL;
!       return (yy_readline_get ());
!     }
!   else
!     {
!       c = current_readline_line[current_readline_line_index++];
!       return (c);
!     }
! }
! 
! static int
! yy_readline_unget (c)
!      int c;
! {
!   if (current_readline_line_index && current_readline_line)
!     current_readline_line[--current_readline_line_index] = c;
!   return (c);
! }
! 
! void
! with_input_from_stdin ()
! {
!   INPUT_STREAM location;
! 
!   if (bash_input.type != st_stdin && stream_on_stack (st_stdin) == 0)
!     {
!       location.string = current_readline_line;
!       init_yy_io (yy_readline_get, yy_readline_unget,
! 		  st_stdin, "readline stdin", location);
!     }
! }
! 
! #else  /* !READLINE */
! 
! void
! with_input_from_stdin ()
! {
!   with_input_from_stream (stdin, "stdin");
! }
! #endif	/* !READLINE */
! 
! /* **************************************************************** */
! /*								    */
! /*   Let input come from STRING.  STRING is zero terminated.	    */
! /*								    */
! /* **************************************************************** */
! 
! static int
! yy_string_get ()
! {
!   register char *string;
!   register unsigned char c;
! 
!   string = bash_input.location.string;
! 
!   /* If the string doesn't exist, or is empty, EOF found. */
!   if (string && *string)
!     {
!       c = *string++;
!       bash_input.location.string = string;
!       return (c);
!     }
!   else
!     return (EOF);
! }
! 
! static int
! yy_string_unget (c)
!      int c;
! {
!   *(--bash_input.location.string) = c;
!   return (c);
! }
! 
! void
! with_input_from_string (string, name)
!      char *string;
!      const char *name;
! {
!   INPUT_STREAM location;
! 
!   location.string = string;
!   init_yy_io (yy_string_get, yy_string_unget, st_string, name, location);
! }
! 
! /* **************************************************************** */
! /*								    */
! /*		     Let input come from STREAM.		    */
! /*								    */
! /* **************************************************************** */
! 
! /* These two functions used to test the value of the HAVE_RESTARTABLE_SYSCALLS
!    define, and just use getc/ungetc if it was defined, but since bash
!    installs its signal handlers without the SA_RESTART flag, some signals
!    (like SIGCHLD, SIGWINCH, etc.) received during a read(2) will not cause
!    the read to be restarted.  We need to restart it ourselves. */
! 
! static int
! yy_stream_get ()
! {
!   int result;
! 
!   result = EOF;
!   if (bash_input.location.file)
!     result = getc_with_restart (bash_input.location.file);
! 
!   return (result);
! }
! 
! static int
! yy_stream_unget (c)
!      int c;
! {
!   return (ungetc_with_restart (c, bash_input.location.file));
! }
! 
! void
! with_input_from_stream (stream, name)
!      FILE *stream;
!      const char *name;
! {
!   INPUT_STREAM location;
! 
!   location.file = stream;
!   init_yy_io (yy_stream_get, yy_stream_unget, st_stream, name, location);
! }
! 
! typedef struct stream_saver {
!   struct stream_saver *next;
!   BASH_INPUT bash_input;
!   int line;
! #if defined (BUFFERED_INPUT)
!   BUFFERED_STREAM *bstream;
! #endif /* BUFFERED_INPUT */
! } STREAM_SAVER;
! 
! /* The globally known line number. */
! int line_number = 0;
! 
! #if defined (COND_COMMAND)
! static int cond_lineno;
! static int cond_token;
! #endif
! 
! STREAM_SAVER *stream_list = (STREAM_SAVER *)NULL;
! 
! void
! push_stream (reset_lineno)
!      int reset_lineno;
! {
!   STREAM_SAVER *saver = (STREAM_SAVER *)xmalloc (sizeof (STREAM_SAVER));
! 
!   xbcopy ((char *)&bash_input, (char *)&(saver->bash_input), sizeof (BASH_INPUT));
! 
! #if defined (BUFFERED_INPUT)
!   saver->bstream = (BUFFERED_STREAM *)NULL;
!   /* If we have a buffered stream, clear out buffers[fd]. */
!   if (bash_input.type == st_bstream && bash_input.location.buffered_fd >= 0)
!     saver->bstream = set_buffered_stream (bash_input.location.buffered_fd,
!     					  (BUFFERED_STREAM *)NULL);
! #endif /* BUFFERED_INPUT */
! 
!   saver->line = line_number;
!   bash_input.name = (char *)NULL;
!   saver->next = stream_list;
!   stream_list = saver;
!   EOF_Reached = 0;
!   if (reset_lineno)
!     line_number = 0;
! }
! 
! void
! pop_stream ()
! {
!   if (!stream_list)
!     EOF_Reached = 1;
!   else
!     {
!       STREAM_SAVER *saver = stream_list;
! 
!       EOF_Reached = 0;
!       stream_list = stream_list->next;
! 
!       init_yy_io (saver->bash_input.getter,
! 		  saver->bash_input.ungetter,
! 		  saver->bash_input.type,
! 		  saver->bash_input.name,
! 		  saver->bash_input.location);
! 
! #if defined (BUFFERED_INPUT)
!       /* If we have a buffered stream, restore buffers[fd]. */
!       /* If the input file descriptor was changed while this was on the
! 	 save stack, update the buffered fd to the new file descriptor and
! 	 re-establish the buffer <-> bash_input fd correspondence. */
!       if (bash_input.type == st_bstream && bash_input.location.buffered_fd >= 0)
! 	{
! 	  if (bash_input_fd_changed)
! 	    {
! 	      bash_input_fd_changed = 0;
! 	      if (default_buffered_input >= 0)
! 		{
! 		  bash_input.location.buffered_fd = default_buffered_input;
! 		  saver->bstream->b_fd = default_buffered_input;
! 		  SET_CLOSE_ON_EXEC (default_buffered_input);
! 		}
! 	    }
! 	  /* XXX could free buffered stream returned as result here. */
! 	  set_buffered_stream (bash_input.location.buffered_fd, saver->bstream);
! 	}
! #endif /* BUFFERED_INPUT */
! 
!       line_number = saver->line;
! 
!       FREE (saver->bash_input.name);
!       free (saver);
!     }
! }
! 
! /* Return 1 if a stream of type TYPE is saved on the stack. */
! int
! stream_on_stack (type)
!      enum stream_type type;
! {
!   register STREAM_SAVER *s;
! 
!   for (s = stream_list; s; s = s->next)
!     if (s->bash_input.type == type)
!       return 1;
!   return 0;
! }
! 
! /* Save the current token state and return it in a malloced array. */
! int *
! save_token_state ()
! {
!   int *ret;
! 
!   ret = (int *)xmalloc (3 * sizeof (int));
!   ret[0] = last_read_token;
!   ret[1] = token_before_that;
!   ret[2] = two_tokens_ago;
!   return ret;
! }
! 
! void
! restore_token_state (ts)
!      int *ts;
! {
!   if (ts == 0)
!     return;
!   last_read_token = ts[0];
!   token_before_that = ts[1];
!   two_tokens_ago = ts[2];
! }
! 
! /*
!  * This is used to inhibit alias expansion and reserved word recognition
!  * inside case statement pattern lists.  A `case statement pattern list' is:
!  *
!  *	everything between the `in' in a `case word in' and the next ')'
!  *	or `esac'
!  *	everything between a `;;' and the next `)' or `esac'
!  */
! 
! #if defined (ALIAS) || defined (DPAREN_ARITHMETIC)
! 
! #if !defined (ALIAS)
! typedef void *alias_t;
! #endif
! 
! #define END_OF_ALIAS 0
! 
! /*
!  * Pseudo-global variables used in implementing token-wise alias expansion.
!  */
! 
! /*
!  * Pushing and popping strings.  This works together with shell_getc to
!  * implement alias expansion on a per-token basis.
!  */
! 
! typedef struct string_saver {
!   struct string_saver *next;
!   int expand_alias;  /* Value to set expand_alias to when string is popped. */
!   char *saved_line;
! #if defined (ALIAS)
!   alias_t *expander;   /* alias that caused this line to be pushed. */
! #endif
!   int saved_line_size, saved_line_index, saved_line_terminator;
! } STRING_SAVER;
! 
! STRING_SAVER *pushed_string_list = (STRING_SAVER *)NULL;
! 
! /*
!  * Push the current shell_input_line onto a stack of such lines and make S
!  * the current input.  Used when expanding aliases.  EXPAND is used to set
!  * the value of expand_next_token when the string is popped, so that the
!  * word after the alias in the original line is handled correctly when the
!  * alias expands to multiple words.  TOKEN is the token that was expanded
!  * into S; it is saved and used to prevent infinite recursive expansion.
!  */
! static void
! push_string (s, expand, ap)
!      char *s;
!      int expand;
!      alias_t *ap;
! {
!   STRING_SAVER *temp = (STRING_SAVER *)xmalloc (sizeof (STRING_SAVER));
! 
!   temp->expand_alias = expand;
!   temp->saved_line = shell_input_line;
!   temp->saved_line_size = shell_input_line_size;
!   temp->saved_line_index = shell_input_line_index;
!   temp->saved_line_terminator = shell_input_line_terminator;
! #if defined (ALIAS)
!   temp->expander = ap;
! #endif
!   temp->next = pushed_string_list;
!   pushed_string_list = temp;
! 
! #if defined (ALIAS)
!   if (ap)
!     ap->flags |= AL_BEINGEXPANDED;
! #endif
! 
!   shell_input_line = s;
!   shell_input_line_size = strlen (s);
!   shell_input_line_index = 0;
!   shell_input_line_terminator = '\0';
!   parser_state &= ~PST_ALEXPNEXT;
! }
! 
! /*
!  * Make the top of the pushed_string stack be the current shell input.
!  * Only called when there is something on the stack.  Called from shell_getc
!  * when it thinks it has consumed the string generated by an alias expansion
!  * and needs to return to the original input line.
!  */
! static void
! pop_string ()
! {
!   STRING_SAVER *t;
! 
!   FREE (shell_input_line);
!   shell_input_line = pushed_string_list->saved_line;
!   shell_input_line_index = pushed_string_list->saved_line_index;
!   shell_input_line_size = pushed_string_list->saved_line_size;
!   shell_input_line_terminator = pushed_string_list->saved_line_terminator;
! 
!   if (pushed_string_list->expand_alias)
!     parser_state |= PST_ALEXPNEXT;
!   else
!     parser_state &= ~PST_ALEXPNEXT;
! 
!   t = pushed_string_list;
!   pushed_string_list = pushed_string_list->next;
! 
! #if defined (ALIAS)
!   if (t->expander)
!     t->expander->flags &= ~AL_BEINGEXPANDED;
! #endif
! 
!   free ((char *)t);
! }
! 
! static void
! free_string_list ()
! {
!   register STRING_SAVER *t, *t1;
! 
!   for (t = pushed_string_list; t; )
!     {
!       t1 = t->next;
!       FREE (t->saved_line);
! #if defined (ALIAS)
!       if (t->expander)
! 	t->expander->flags &= ~AL_BEINGEXPANDED;
! #endif
!       free ((char *)t);
!       t = t1;
!     }
!   pushed_string_list = (STRING_SAVER *)NULL;
! }
! 
! #endif /* ALIAS || DPAREN_ARITHMETIC */
! 
! /* Return a line of text, taken from wherever yylex () reads input.
!    If there is no more input, then we return NULL.  If REMOVE_QUOTED_NEWLINE
!    is non-zero, we remove unquoted \<newline> pairs.  This is used by
!    read_secondary_line to read here documents. */
! static char *
! read_a_line (remove_quoted_newline)
!      int remove_quoted_newline;
! {
!   static char *line_buffer = (char *)NULL;
!   static int buffer_size = 0;
!   int indx = 0, c, peekc, pass_next;
! 
! #if defined (READLINE)
!   if (interactive && bash_input.type != st_string && no_line_editing)
! #else
!   if (interactive && bash_input.type != st_string)
! #endif
!     print_prompt ();
! 
!   pass_next = 0;
!   while (1)
!     {
!       c = yy_getc ();
! 
!       /* Allow immediate exit if interrupted during input. */
!       QUIT;
! 
!       /* Ignore null bytes in input. */
!       if (c == 0)
! 	{
! #if 0
! 	  internal_warning ("read_a_line: ignored null byte in input");
! #endif
! 	  continue;
! 	}
! 
!       /* If there is no more input, then we return NULL. */
!       if (c == EOF)
! 	{
! 	  if (interactive && bash_input.type == st_stream)
! 	    clearerr (stdin);
! 	  if (indx == 0)
! 	    return ((char *)NULL);
! 	  c = '\n';
! 	}
! 
!       /* `+2' in case the final character in the buffer is a newline. */
!       RESIZE_MALLOCED_BUFFER (line_buffer, indx, 2, buffer_size, 128);
! 
!       /* IF REMOVE_QUOTED_NEWLINES is non-zero, we are reading a
! 	 here document with an unquoted delimiter.  In this case,
! 	 the line will be expanded as if it were in double quotes.
! 	 We allow a backslash to escape the next character, but we
! 	 need to treat the backslash specially only if a backslash
! 	 quoting a backslash-newline pair appears in the line. */
!       if (pass_next)
! 	{
! 	  line_buffer[indx++] = c;
! 	  pass_next = 0;
! 	}
!       else if (c == '\\' && remove_quoted_newline)
! 	{
! 	  peekc = yy_getc ();
! 	  if (peekc == '\n')
! 	    continue;	/* Make the unquoted \<newline> pair disappear. */
! 	  else
! 	    {
! 	      yy_ungetc (peekc);
! 	      pass_next = 1;
! 	      line_buffer[indx++] = c;		/* Preserve the backslash. */
! 	    }
! 	}
!       else
! 	line_buffer[indx++] = c;
! 
!       if (c == '\n')
! 	{
! 	  line_buffer[indx] = '\0';
! 	  return (line_buffer);
! 	}
!     }
! }
! 
! /* Return a line as in read_a_line (), but insure that the prompt is
!    the secondary prompt.  This is used to read the lines of a here
!    document.  REMOVE_QUOTED_NEWLINE is non-zero if we should remove
!    newlines quoted with backslashes while reading the line.  It is
!    non-zero unless the delimiter of the here document was quoted. */
! char *
! read_secondary_line (remove_quoted_newline)
!      int remove_quoted_newline;
! {
!   prompt_string_pointer = &ps2_prompt;
!   prompt_again ();
!   return (read_a_line (remove_quoted_newline));
! }
! 
! /* **************************************************************** */
! /*								    */
! /*				YYLEX ()			    */
! /*								    */
! /* **************************************************************** */
! 
! /* Reserved words.  These are only recognized as the first word of a
!    command. */
! STRING_INT_ALIST word_token_alist[] = {
!   { "if", IF },
!   { "then", THEN },
!   { "else", ELSE },
!   { "elif", ELIF },
!   { "fi", FI },
!   { "case", CASE },
!   { "esac", ESAC },
!   { "for", FOR },
  #if defined (SELECT_COMMAND)
    { "select", SELECT },
***************
*** 1602,1606 ****
      { \
        if (ds.delimiter_depth + 2 > ds.delimiter_space) \
! 	ds.delimiters = xrealloc \
  	  (ds.delimiters, (ds.delimiter_space += 10) * sizeof (char)); \
        ds.delimiters[ds.delimiter_depth] = character; \
--- 2933,2937 ----
      { \
        if (ds.delimiter_depth + 2 > ds.delimiter_space) \
! 	ds.delimiters = (char *)xrealloc \
  	  (ds.delimiters, (ds.delimiter_space += 10) * sizeof (char)); \
        ds.delimiters[ds.delimiter_depth] = character; \
***************
*** 1627,1630 ****
--- 2958,2962 ----
    register int i;
    int c;
+   unsigned char uc;
    static int mustpop = 0;
  
***************
*** 1797,1801 ****
  	{
  	  if (shell_input_line_len + 3 > shell_input_line_size)
! 	    shell_input_line = xrealloc (shell_input_line,
  					1 + (shell_input_line_size += 2));
  
--- 3129,3133 ----
  	{
  	  if (shell_input_line_len + 3 > shell_input_line_size)
! 	    shell_input_line = (char *)xrealloc (shell_input_line,
  					1 + (shell_input_line_size += 2));
  
***************
*** 1805,1814 ****
      }
  
!   c = shell_input_line[shell_input_line_index];
  
!   if (c)
      shell_input_line_index++;
  
!   if (c == '\\' && remove_quoted_newline &&
        shell_input_line[shell_input_line_index] == '\n')
      {
--- 3137,3146 ----
      }
  
!   uc = shell_input_line[shell_input_line_index];
  
!   if (uc)
      shell_input_line_index++;
  
!   if (uc == '\\' && remove_quoted_newline &&
        shell_input_line[shell_input_line_index] == '\n')
      {
***************
*** 1819,1834 ****
  
  #if defined (ALIAS) || defined (DPAREN_ARITHMETIC)
!   /* If C is NULL, we have reached the end of the current input string.  If
       pushed_string_list is non-empty, it's time to pop to the previous string
       because we have fully consumed the result of the last alias expansion.
       Do it transparently; just return the next character of the string popped
       to. */
!   if (!c && (pushed_string_list != (STRING_SAVER *)NULL))
      {
        if (mustpop)
  	{
  	  pop_string ();
! 	  c = shell_input_line[shell_input_line_index];
! 	  if (c)
  	    shell_input_line_index++;
  	  mustpop--;
--- 3151,3166 ----
  
  #if defined (ALIAS) || defined (DPAREN_ARITHMETIC)
!   /* If UC is NULL, we have reached the end of the current input string.  If
       pushed_string_list is non-empty, it's time to pop to the previous string
       because we have fully consumed the result of the last alias expansion.
       Do it transparently; just return the next character of the string popped
       to. */
!   if (!uc && (pushed_string_list != (STRING_SAVER *)NULL))
      {
        if (mustpop)
  	{
  	  pop_string ();
! 	  uc = shell_input_line[shell_input_line_index];
! 	  if (uc)
  	    shell_input_line_index++;
  	  mustpop--;
***************
*** 1837,1849 ****
  	{
  	  mustpop++;
! 	  c = ' ';
  	}
      }
  #endif /* ALIAS || DPAREN_ARITHMETIC */
  
!   if (!c && shell_input_line_terminator == EOF)
      return ((shell_input_line_index != 0) ? '\n' : EOF);
  
!   return ((unsigned char)c);
  }
  
--- 3169,3181 ----
  	{
  	  mustpop++;
! 	  uc = ' ';
  	}
      }
  #endif /* ALIAS || DPAREN_ARITHMETIC */
  
!   if (!uc && shell_input_line_terminator == EOF)
      return ((shell_input_line_index != 0) ? '\n' : EOF);
  
!   return (uc);
  }
  
***************
*** 1859,1862 ****
--- 3191,3196 ----
  }
  
+ #ifdef INCLUDE_UNUSED
+ /* Back the input pointer up by one, effectively `ungetting' a character. */
  static void
  shell_ungetchar ()
***************
*** 1865,1868 ****
--- 3199,3203 ----
      shell_input_line_index--;
  }
+ #endif
  
  /* Discard input until CHARACTER is seen, then push that character back
***************
*** 1885,1889 ****
       char *command;
  {
!   Function *temp_last, *temp_this;
    char *last_lastarg;
    int temp_exit_value, temp_eof_encountered;
--- 3220,3224 ----
       char *command;
  {
!   sh_builtin_func_t *temp_last, *temp_this;
    char *last_lastarg;
    int temp_exit_value, temp_eof_encountered;
***************
*** 2027,2032 ****
  	 In a pattern list in a case statement (parser_state & PST_CASEPAT). */
  static int
! alias_expand_token (token)
!      char *token;
  {
    char *expanded;
--- 3362,3367 ----
  	 In a pattern list in a case statement (parser_state & PST_CASEPAT). */
  static int
! alias_expand_token (tokstr)
!      char *tokstr;
  {
    char *expanded;
***************
*** 2036,2040 ****
  	(parser_state & PST_CASEPAT) == 0)
      {
!       ap = find_alias (token);
  
        /* Currently expanding this token. */
--- 3371,3375 ----
  	(parser_state & PST_CASEPAT) == 0)
      {
!       ap = find_alias (tokstr);
  
        /* Currently expanding this token. */
***************
*** 2108,2113 ****
  
  static int
! special_case_tokens (token)
!      char *token;
  {
    if ((last_read_token == WORD) &&
--- 3443,3448 ----
  
  static int
! special_case_tokens (tokstr)
!      char *tokstr;
  {
    if ((last_read_token == WORD) &&
***************
*** 2117,2121 ****
        ((token_before_that == FOR) || (token_before_that == CASE)) &&
  #endif
!       (token[0] == 'i' && token[1] == 'n' && token[2] == 0))
      {
        if (token_before_that == CASE)
--- 3452,3456 ----
        ((token_before_that == FOR) || (token_before_that == CASE)) &&
  #endif
!       (tokstr[0] == 'i' && tokstr[1] == 'n' && tokstr[2] == 0))
      {
        if (token_before_that == CASE)
***************
*** 2133,2137 ****
        (token_before_that == FOR) &&
  #endif
!       (token[0] == 'd' && token[1] == 'o' && token[2] == '\0'))
      return (DO);
  
--- 3468,3472 ----
        (token_before_that == FOR) &&
  #endif
!       (tokstr[0] == 'd' && tokstr[1] == 'o' && tokstr[2] == '\0'))
      return (DO);
  
***************
*** 2145,2149 ****
      {
        esacs_needed_count--;
!       if (STREQ (token, "esac"))
  	{
  	  parser_state &= ~PST_CASEPAT;
--- 3480,3484 ----
      {
        esacs_needed_count--;
!       if (STREQ (tokstr, "esac"))
  	{
  	  parser_state &= ~PST_CASEPAT;
***************
*** 2156,2160 ****
      {
        parser_state &= ~PST_ALLOWOPNBRC;
!       if (token[0] == '{' && token[1] == '\0')		/* } */
  	{
  	  open_brace_count++;
--- 3491,3495 ----
      {
        parser_state &= ~PST_ALLOWOPNBRC;
!       if (tokstr[0] == '{' && tokstr[1] == '\0')		/* } */
  	{
  	  open_brace_count++;
***************
*** 2166,2172 ****
    /* We allow a `do' after a for ((...)) without an intervening
       list_terminator */
!   if (last_read_token == ARITH_FOR_EXPRS && token[0] == 'd' && token[1] == 'o' && !token[2])
      return (DO);
!   if (last_read_token == ARITH_FOR_EXPRS && token[0] == '{' && token[1] == '\0')	/* } */
      {
        open_brace_count++;
--- 3501,3507 ----
    /* We allow a `do' after a for ((...)) without an intervening
       list_terminator */
!   if (last_read_token == ARITH_FOR_EXPRS && tokstr[0] == 'd' && tokstr[1] == 'o' && !tokstr[2])
      return (DO);
!   if (last_read_token == ARITH_FOR_EXPRS && tokstr[0] == '{' && tokstr[1] == '\0')	/* } */
      {
        open_brace_count++;
***************
*** 2174,2178 ****
      }
  
!   if (open_brace_count && reserved_word_acceptable (last_read_token) && token[0] == '}' && !token[1])
      {
        open_brace_count--;		/* { */
--- 3509,3513 ----
      }
  
!   if (open_brace_count && reserved_word_acceptable (last_read_token) && tokstr[0] == '}' && !tokstr[1])
      {
        open_brace_count--;		/* { */
***************
*** 2182,2186 ****
  #if defined (COMMAND_TIMING)
    /* Handle -p after `time'. */
!   if (last_read_token == TIME && token[0] == '-' && token[1] == 'p' && !token[2])
      return (TIMEOPT);
  #endif
--- 3517,3521 ----
  #if defined (COMMAND_TIMING)
    /* Handle -p after `time'. */
!   if (last_read_token == TIME && tokstr[0] == '-' && tokstr[1] == 'p' && !tokstr[2])
      return (TIMEOPT);
  #endif
***************
*** 2192,2196 ****
  
  #if defined (COND_COMMAND) /* [[ */
!   if ((parser_state & PST_CONDEXPR) && token[0] == ']' && token[1] == ']' && token[2] == '\0')
      return (COND_END);
  #endif
--- 3527,3531 ----
  
  #if defined (COND_COMMAND) /* [[ */
!   if ((parser_state & PST_CONDEXPR) && tokstr[0] == ']' && tokstr[1] == ']' && tokstr[2] == '\0')
      return (COND_END);
  #endif
***************
*** 2373,2377 ****
  			 of the string it returns; we need to take those out. */
  		      len = strlen (wval);
! 		      wv2 = xmalloc (len);
  		      strncpy (wv2, wval + 1, len - 2);
  		      wv2[len - 2] = '\0';
--- 3708,3712 ----
  			 of the string it returns; we need to take those out. */
  		      len = strlen (wval);
! 		      wv2 = (char *)xmalloc (len);
  		      strncpy (wv2, wval + 1, len - 2);
  		      wv2[len - 2] = '\0';
***************
*** 2501,2505 ****
    pass_next_character = was_dollar = 0;
  
!   ret = xmalloc (retsize = 64);
    retind = 0;
  
--- 3836,3840 ----
    pass_next_character = was_dollar = 0;
  
!   ret = (char *)xmalloc (retsize = 64);
    retind = 0;
  
***************
*** 2587,2591 ****
  		  /* Translate $'...' here. */
  		  ttrans = ansiexpand (nestret, 0, nestlen - 1, &ttranslen);
! 		  free (nestret);
  		  nestret = sh_single_quote (ttrans);
  		  free (ttrans);
--- 3922,3926 ----
  		  /* Translate $'...' here. */
  		  ttrans = ansiexpand (nestret, 0, nestlen - 1, &ttranslen);
! 		  xfree (nestret);
  		  nestret = sh_single_quote (ttrans);
  		  free (ttrans);
***************
*** 2597,2602 ****
  		  /* Locale expand $"..." here. */
  		  ttrans = localeexpand (nestret, 0, nestlen - 1, start_lineno, &ttranslen);
! 		  free (nestret);
! 		  nestret = xmalloc (ttranslen + 3);
  		  nestret[0] = '"';
  		  strcpy (nestret + 1, ttrans);
--- 3932,3937 ----
  		  /* Locale expand $"..." here. */
  		  ttrans = localeexpand (nestret, 0, nestlen - 1, start_lineno, &ttranslen);
! 		  xfree (nestret);
! 		  nestret = (char *)xmalloc (ttranslen + 3);
  		  nestret[0] = '"';
  		  strcpy (nestret + 1, ttrans);
***************
*** 2679,2683 ****
  {
    int exp_lineno, rval, c;
!   char *ttok, *token;
    int ttoklen;
  
--- 4014,4018 ----
  {
    int exp_lineno, rval, c;
!   char *ttok, *tokstr;
    int ttoklen;
  
***************
*** 2692,2712 ****
      rval = 0;
  
!   token = xmalloc (ttoklen + 4);
  
    /* (( ... )) -> "..." */
!   token[0] = (rval == 1) ? '"' : '(';
!   strncpy (token + 1, ttok, ttoklen - 1);	/* don't copy the final `)' */
    if (rval == 1)
      {
!       token[ttoklen] = '"';
!       token[ttoklen+1] = '\0';
      }
    else
      {
!       token[ttoklen] = ')';
!       token[ttoklen+1] = c;
!       token[ttoklen+2] = '\0';
      }
!   *ep = token;
    FREE (ttok);
    return rval;
--- 4027,4047 ----
      rval = 0;
  
!   tokstr = (char *)xmalloc (ttoklen + 4);
  
    /* (( ... )) -> "..." */
!   tokstr[0] = (rval == 1) ? '"' : '(';
!   strncpy (tokstr + 1, ttok, ttoklen - 1);	/* don't copy the final `)' */
    if (rval == 1)
      {
!       tokstr[ttoklen] = '"';
!       tokstr[ttoklen+1] = '\0';
      }
    else
      {
!       tokstr[ttoklen] = ')';
!       tokstr[ttoklen+1] = c;
!       tokstr[ttoklen+2] = '\0';
      }
!   *ep = tokstr;
    FREE (ttok);
    return rval;
***************
*** 2715,2723 ****
  
  #if defined (COND_COMMAND)
- static COND_COM *cond_term ();
- static COND_COM *cond_and ();
- static COND_COM *cond_or ();
- static COND_COM *cond_expr ();
- 
  static COND_COM *
  cond_expr ()
--- 4050,4053 ----
***************
*** 2904,2908 ****
  
    /* ALL_DIGITS becomes zero when we see a non-digit. */
!   int all_digits;
  
    /* DOLLAR_PRESENT becomes non-zero if we see a `$'. */
--- 4234,4238 ----
  
    /* ALL_DIGITS becomes zero when we see a non-digit. */
!   int all_digit_token;
  
    /* DOLLAR_PRESENT becomes non-zero if we see a `$'. */
***************
*** 2921,2930 ****
    char *ttok, *ttrans;
    int ttoklen, ttranslen;
  
    if (token_buffer_size < TOKEN_DEFAULT_INITIAL_SIZE)
!     token = xrealloc (token, token_buffer_size = TOKEN_DEFAULT_INITIAL_SIZE);
  
    token_index = 0;
!   all_digits = isdigit (character);
    dollar_present = quoted = pass_next_character = 0;
  
--- 4251,4261 ----
    char *ttok, *ttrans;
    int ttoklen, ttranslen;
+   long lvalue;
  
    if (token_buffer_size < TOKEN_DEFAULT_INITIAL_SIZE)
!     token = (char *)xrealloc (token, token_buffer_size = TOKEN_DEFAULT_INITIAL_SIZE);
  
    token_index = 0;
!   all_digit_token = DIGIT (character);
    dollar_present = quoted = pass_next_character = 0;
  
***************
*** 2961,2965 ****
  	      /* If the next character is to be quoted, note it now. */
  	      if (cd == 0 || cd == '`' ||
! 		  (cd == '"' && (sh_syntaxtab[peek_char] & CBSDQUOTE)))
  		pass_next_character++;
  
--- 4292,4296 ----
  	      /* If the next character is to be quoted, note it now. */
  	      if (cd == 0 || cd == '`' ||
! 		  (cd == '"' && peek_char >= 0 && (sh_syntaxtab[peek_char] & CBSDQUOTE)))
  		pass_next_character++;
  
***************
*** 2982,2986 ****
  	  strcpy (token + token_index, ttok);
  	  token_index += ttoklen;
! 	  all_digits = 0;
  	  quoted = 1;
  	  dollar_present |= (character == '"' && strchr (ttok, '$') != 0);
--- 4313,4317 ----
  	  strcpy (token + token_index, ttok);
  	  token_index += ttoklen;
! 	  all_digit_token = 0;
  	  quoted = 1;
  	  dollar_present |= (character == '"' && strchr (ttok, '$') != 0);
***************
*** 3009,3013 ****
  	      token_index += ttoklen;
  	      FREE (ttok);
! 	      dollar_present = all_digits = 0;
  	      goto next_character;
  	    }
--- 4340,4344 ----
  	      token_index += ttoklen;
  	      FREE (ttok);
! 	      dollar_present = all_digit_token = 0;
  	      goto next_character;
  	    }
***************
*** 3052,3056 ****
  	      FREE (ttok);
  	      dollar_present = 1;
! 	      all_digits = 0;
  	      goto next_character;
  	    }
--- 4383,4387 ----
  	      FREE (ttok);
  	      dollar_present = 1;
! 	      all_digit_token = 0;
  	      goto next_character;
  	    }
***************
*** 3087,3091 ****
  
  		  /* Add the double quotes back */
! 		  ttok = xmalloc (ttranslen + 3);
  		  ttok[0] = '"';
  		  strcpy (ttok + 1, ttrans);
--- 4418,4422 ----
  
  		  /* Add the double quotes back */
! 		  ttok = (char *)xmalloc (ttranslen + 3);
  		  ttok[0] = '"';
  		  strcpy (ttok + 1, ttrans);
***************
*** 3103,3107 ****
  	      FREE (ttrans);
  	      quoted = 1;
! 	      all_digits = 0;
  	      goto next_character;
  	    }
--- 4434,4438 ----
  	      FREE (ttrans);
  	      quoted = 1;
! 	      all_digit_token = 0;
  	      goto next_character;
  	    }
***************
*** 3110,3114 ****
  	  else if (character == '$' && peek_char == '$')
  	    {
! 	      ttok = xmalloc (3);
  	      ttok[0] = ttok[1] = '$';
  	      ttok[2] = '\0';
--- 4441,4445 ----
  	  else if (character == '$' && peek_char == '$')
  	    {
! 	      ttok = (char *)xmalloc (3);
  	      ttok[0] = ttok[1] = '$';
  	      ttok[2] = '\0';
***************
*** 3119,3123 ****
  	      token_index += 2;
  	      dollar_present = 1;
! 	      all_digits = 0;
  	      FREE (ttok);
  	      goto next_character;
--- 4450,4454 ----
  	      token_index += 2;
  	      dollar_present = 1;
! 	      all_digit_token = 0;
  	      FREE (ttok);
  	      goto next_character;
***************
*** 3150,3154 ****
  	      token_index += ttoklen;
  	      FREE (ttok);
! 	      all_digits = 0;
  	      goto next_character;
  	    }
--- 4481,4485 ----
  	      token_index += ttoklen;
  	      FREE (ttok);
! 	      all_digit_token = 0;
  	      goto next_character;
  	    }
***************
*** 3168,3172 ****
      got_character:
  
!       all_digits &= isdigit (character);
        dollar_present |= character == '$';
  
--- 4499,4503 ----
      got_character:
  
!       all_digit_token &= DIGIT (character);
        dollar_present |= character == '$';
  
***************
*** 3199,3207 ****
       a '>' or '<', then, and ONLY then, is this input token a NUMBER.
       Otherwise, it is just a word, and should be returned as such. */
!   if (all_digits && (character == '<' || character == '>' ||
  		    last_read_token == LESS_AND ||
  		    last_read_token == GREATER_AND))
        {
! 	yylval.number = atoi (token);
  	return (NUMBER);
        }
--- 4530,4541 ----
       a '>' or '<', then, and ONLY then, is this input token a NUMBER.
       Otherwise, it is just a word, and should be returned as such. */
!   if (all_digit_token && (character == '<' || character == '>' ||
  		    last_read_token == LESS_AND ||
  		    last_read_token == GREATER_AND))
        {
! 	if (legal_number (token, &lvalue) && (int)lvalue == lvalue)
! 	  yylval.number = lvalue;
! 	else
! 	  yylval.number = -1;
  	return (NUMBER);
        }
***************
*** 3221,5172 ****
    /* Aliases are expanded iff EXPAND_ALIASES is non-zero, and quoting
       inhibits alias expansion. */
!   if (expand_aliases && quoted == 0)
!     {
!       result = alias_expand_token (token);
!       if (result == RE_READ_TOKEN)
! 	return (RE_READ_TOKEN);
!       else if (result == NO_EXPANSION)
! 	parser_state &= ~PST_ALEXPNEXT;
!     }
! 
!   /* If not in Posix.2 mode, check for reserved words after alias
!      expansion. */
!   if (posixly_correct == 0)
! #endif
!     CHECK_FOR_RESERVED_WORD (token);
! 
!   the_word = (WORD_DESC *)xmalloc (sizeof (WORD_DESC));
!   the_word->word = xmalloc (1 + token_index);
!   the_word->flags = 0;
!   strcpy (the_word->word, token);
!   if (dollar_present)
!     the_word->flags |= W_HASDOLLAR;
!   if (quoted)
!     the_word->flags |= W_QUOTED;
!   /* A word is an assignment if it appears at the beginning of a
!      simple command, or after another assignment word.  This is
!      context-dependent, so it cannot be handled in the grammar. */
!   if (assignment (token))
!     {
!       the_word->flags |= W_ASSIGNMENT;
!       /* Don't perform word splitting on assignment statements. */
!       if (assignment_acceptable (last_read_token))
! 	the_word->flags |= W_NOSPLIT;
!     }
! 
!   yylval.word = the_word;
! 
!   result = ((the_word->flags & (W_ASSIGNMENT|W_NOSPLIT)) == (W_ASSIGNMENT|W_NOSPLIT))
! 		? ASSIGNMENT_WORD : WORD;
! 
!   if (last_read_token == FUNCTION)
!     {
!       parser_state |= PST_ALLOWOPNBRC;
!       function_dstart = line_number;
!     }
! 
!   return (result);
! }
! 
! /* $'...' ANSI-C expand the portion of STRING between START and END and
!    return the result.  The result cannot be longer than the input string. */
! static char *
! ansiexpand (string, start, end, lenp)
!      char *string;
!      int start, end, *lenp;
! {
!   char *temp, *t;
!   int len, tlen;
! 
!   temp = xmalloc (end - start + 1);
!   for (tlen = 0, len = start; len < end; )
!     temp[tlen++] = string[len++];
!   temp[tlen] = '\0';
! 
!   if (*temp)
!     {
!       t = ansicstr (temp, tlen, 0, (int *)NULL, lenp);
!       free (temp);
!       return (t);
!     }
!   else
!     {
!       if (lenp)
! 	*lenp = 0;
!       return (temp);
!     }
! }
! 
! /* Change a bash string into a string suitable for inclusion in a `po' file.
!    This backslash-escapes `"' and `\' and changes newlines into \\\n"\n". */
! static char *
! mk_msgstr (string, foundnlp)
!      char *string;
!      int *foundnlp;
! {
!   register int c, len;
!   char *result, *r, *s;
! 
!   for (len = 0, s = string; s && *s; s++)
!     {
!       len++;
!       if (*s == '"' || *s == '\\')
! 	len++;
!       else if (*s == '\n')
! 	len += 5;
!     }
!   
!   r = result = xmalloc (len + 3);
!   *r++ = '"';
! 
!   for (s = string; s && (c = *s); s++)
!     {
!       if (c == '\n')	/* <NL> -> \n"<NL>" */
! 	{
! 	  *r++ = '\\';
! 	  *r++ = 'n';
! 	  *r++ = '"';
! 	  *r++ = '\n';
! 	  *r++ = '"';
! 	  if (foundnlp)
! 	    *foundnlp = 1;
! 	  continue;
! 	}
!       if (c == '"' || c == '\\')
! 	*r++ = '\\';
!       *r++ = c;
!     }
! 
!   *r++ = '"';
!   *r++ = '\0';
! 
!   return result;
! }
! 
! /* $"..." -- Translate the portion of STRING between START and END
!    according to current locale using gettext (if available) and return
!    the result.  The caller will take care of leaving the quotes intact.
!    The string will be left without the leading `$' by the caller.
!    If translation is performed, the translated string will be double-quoted
!    by the caller.  The length of the translated string is returned in LENP,
!    if non-null. */
! static char *
! localeexpand (string, start, end, lineno, lenp)
!      char *string;
!      int start, end, lineno, *lenp;
! {
!   int len, tlen, foundnl;
!   char *temp, *t, *t2;
! 
!   temp = xmalloc (end - start + 1);
!   for (tlen = 0, len = start; len < end; )
!     temp[tlen++] = string[len++];
!   temp[tlen] = '\0';
! 
!   /* If we're just dumping translatable strings, don't do anything with the
!      string itself, but if we're dumping in `po' file format, convert it into a form more palatable to gettext(3)
!      and friends by quoting `"' and `\' with backslashes and converting <NL>
!      into `\n"<NL>"'.  If we find a newline in TEMP, we first output a
!      `msgid ""' line and then the translated string; otherwise we output the
!      `msgid' and translated string all on one line. */
!   if (dump_translatable_strings)
!     {
!       if (dump_po_strings)
! 	{
! 	  foundnl = 0;
! 	  t = mk_msgstr (temp, &foundnl);
! 	  t2 = foundnl ? "\"\"\n" : "";
! 
! 	  printf ("#: %s:%d\nmsgid %s%s\nmsgstr \"\"\n",
! 		  (bash_input.name ? bash_input.name : "stdin"), lineno, t2, t);
! 	  free (t);
! 	}
!       else
! 	printf ("\"%s\"\n", temp);
! 
!       if (lenp)
! 	*lenp = tlen;
!       return (temp);
!     }
!   else if (*temp)
!     {
!       t = localetrans (temp, tlen, &len);
!       free (temp);
!       if (lenp)
! 	*lenp = len;
!       return (t);
!     }
!   else
!     {
!       if (lenp)
! 	*lenp = 0;
!       return (temp);
!     }
! }
! 
! /* Return 1 if TOKEN is a token that after being read would allow
!    a reserved word to be seen, else 0. */
! static int
! reserved_word_acceptable (token)
!      int token;
! {
!   if (token == '\n' || token == ';' || token == '(' || token == ')' ||
!       token == '|' || token == '&' || token == '{' ||
!       token == '}' ||			/* XXX */
!       token == AND_AND ||
!       token == BANG ||
!       token == TIME || token == TIMEOPT ||
!       token == DO ||
!       token == ELIF ||
!       token == ELSE ||
!       token == FI ||
!       token == IF ||
!       token == OR_OR ||
!       token == SEMI_SEMI ||
!       token == THEN ||
!       token == UNTIL ||
!       token == WHILE ||
!       token == DONE ||		/* XXX these two are experimental */
!       token == ESAC ||
!       token == 0)
!     return (1);
!   else
!     return (0);
! }
! 
! /* Return the index of TOKEN in the alist of reserved words, or -1 if
!    TOKEN is not a shell reserved word. */
! int
! find_reserved_word (token)
!      char *token;
! {
!   int i;
!   for (i = 0; word_token_alist[i].word; i++)
!     if (STREQ (token, word_token_alist[i].word))
!       return i;
!   return -1;
! }
! 
! #if 0
! #if defined (READLINE)
! /* Called after each time readline is called.  This insures that whatever
!    the new prompt string is gets propagated to readline's local prompt
!    variable. */
! static void
! reset_readline_prompt ()
! {
!   char *temp_prompt;
! 
!   if (prompt_string_pointer)
!     {
!       temp_prompt = (*prompt_string_pointer)
! 			? decode_prompt_string (*prompt_string_pointer)
! 			: (char *)NULL;
! 
!       if (temp_prompt == 0)
! 	{
! 	  temp_prompt = xmalloc (1);
! 	  temp_prompt[0] = '\0';
! 	}
! 
!       FREE (current_readline_prompt);
!       current_readline_prompt = temp_prompt;
!     }
! }
! #endif /* READLINE */
! #endif /* 0 */
! 
! #if defined (HISTORY)
! /* A list of tokens which can be followed by newlines, but not by
!    semi-colons.  When concatenating multiple lines of history, the
!    newline separator for such tokens is replaced with a space. */
! static int no_semi_successors[] = {
!   '\n', '{', '(', ')', ';', '&', '|',
!   CASE, DO, ELSE, IF, SEMI_SEMI, THEN, UNTIL, WHILE, AND_AND, OR_OR, IN,
!   0
! };
! 
! /* If we are not within a delimited expression, try to be smart
!    about which separators can be semi-colons and which must be
!    newlines.  Returns the string that should be added into the
!    history entry. */
! char *
! history_delimiting_chars ()
! {
!   register int i;
! 
!   if (dstack.delimiter_depth != 0)
!     return ("\n");
!     
!   /* First, handle some special cases. */
!   /*(*/
!   /* If we just read `()', assume it's a function definition, and don't
!      add a semicolon.  If the token before the `)' was not `(', and we're
!      not in the midst of parsing a case statement, assume it's a
!      parenthesized command and add the semicolon. */
!   /*)(*/
!   if (token_before_that == ')')
      {
!       if (two_tokens_ago == '(')	/*)*/	/* function def */
! 	return " ";
!       /* This does not work for subshells inside case statement
! 	 command lists.  It's a suboptimal solution. */
!       else if (parser_state & PST_CASESTMT)	/* case statement pattern */
! 	return " ";
!       else	
! 	return "; ";				/* (...) subshell */
      }
-   else if (token_before_that == WORD && two_tokens_ago == FUNCTION)
-     return " ";		/* function def using `function name' without `()' */
  
!   else if (token_before_that == WORD && two_tokens_ago == FOR)
      {
!       /* Tricky.  `for i\nin ...' should not have a semicolon, but
! 	 `for i\ndo ...' should.  We do what we can. */
!       for (i = shell_input_line_index; whitespace(shell_input_line[i]); i++)
! 	;
!       if (shell_input_line[i] && shell_input_line[i] == 'i' && shell_input_line[i+1] == 'n')
! 	return " ";
!       return ";";
      }
  
!   for (i = 0; no_semi_successors[i]; i++)
      {
!       if (token_before_that == no_semi_successors[i])
! 	return (" ");
      }
  
!   return ("; ");
  }
- #endif /* HISTORY */
  
! /* Issue a prompt, or prepare to issue a prompt when the next character
!    is read. */
! static void
! prompt_again ()
  {
!   char *temp_prompt;
! 
!   if (!interactive)	/* XXX */
!     return;
! 
!   ps1_prompt = get_string_value ("PS1");
!   ps2_prompt = get_string_value ("PS2");
! 
!   if (!prompt_string_pointer)
!     prompt_string_pointer = &ps1_prompt;
! 
!   temp_prompt = *prompt_string_pointer
! 			? decode_prompt_string (*prompt_string_pointer)
! 			: (char *)NULL;
! 
!   if (temp_prompt == 0)
!     {
!       temp_prompt = xmalloc (1);
!       temp_prompt[0] = '\0';
!     }
  
!   current_prompt_string = *prompt_string_pointer;
!   prompt_string_pointer = &ps2_prompt;
  
! #if defined (READLINE)
!   if (!no_line_editing)
      {
!       FREE (current_readline_prompt);
!       current_readline_prompt = temp_prompt;
      }
    else
- #endif	/* READLINE */
      {
!       FREE (current_decoded_prompt);
!       current_decoded_prompt = temp_prompt;
      }
  }
  
! int
! get_current_prompt_level ()
! {
!   return ((current_prompt_string && current_prompt_string == ps2_prompt) ? 2 : 1);
! }
! 
! void
! set_current_prompt_level (x)
!      int x;
! {
!   prompt_string_pointer = (x == 2) ? &ps2_prompt : &ps1_prompt;
!   current_prompt_string = *prompt_string_pointer;
! }
!       
! static void
! print_prompt ()
! {
!   fprintf (stderr, "%s", current_decoded_prompt);
!   fflush (stderr);
! }
! 
! /* Return a string which will be printed as a prompt.  The string
!    may contain special characters which are decoded as follows:
! 
! 	\a	bell (ascii 07)
! 	\e	escape (ascii 033)
! 	\d	the date in Day Mon Date format
! 	\h	the hostname up to the first `.'
! 	\H	the hostname
! 	\j	the number of active jobs
! 	\l	the basename of the shell's tty device name
! 	\n	CRLF
! 	\s	the name of the shell
! 	\t	the time in 24-hour hh:mm:ss format
! 	\T	the time in 12-hour hh:mm:ss format
! 	\@	the time in 12-hour am/pm format
! 	\v	the version of bash (e.g., 2.00)
! 	\V	the release of bash, version + patchlevel (e.g., 2.00.0)
! 	\w	the current working directory
! 	\W	the last element of $PWD
! 	\u	your username
! 	\#	the command number of this command
! 	\!	the history number of this command
! 	\$	a $ or a # if you are root
! 	\nnn	character code nnn in octal
! 	\\	a backslash
! 	\[	begin a sequence of non-printing chars
! 	\]	end a sequence of non-printing chars
! */
! #define PROMPT_GROWTH 48
! char *
! decode_prompt_string (string)
       char *string;
  {
!   WORD_LIST *list;
!   char *result, *t;
!   struct dstack save_dstack;
! #if defined (PROMPT_STRING_DECODE)
!   int result_size, result_index;
!   int c, n;
!   char *temp, octal_string[4];
!   time_t the_time;
  
!   result = xmalloc (result_size = PROMPT_GROWTH);
!   result[result_index = 0] = 0;
!   temp = (char *)NULL;
  
!   while (c = *string++)
      {
!       if (posixly_correct && c == '!')
! 	{
! 	  if (*string == '!')
! 	    {
! 	      temp = savestring ("!");
! 	      goto add_string;
! 	    }
! 	  else
! 	    {
! #if !defined (HISTORY)
! 		temp = savestring ("1");
! #else /* HISTORY */
! 		temp = itos (history_number ());
! #endif /* HISTORY */
! 		string--;	/* add_string increments string again. */
! 		goto add_string;
! 	    }
! 	}
!       if (c == '\\')
  	{
! 	  c = *string;
! 
! 	  switch (c)
! 	    {
! 	    case '0':
! 	    case '1':
! 	    case '2':
! 	    case '3':
! 	    case '4':
! 	    case '5':
! 	    case '6':
! 	    case '7':
! 	      strncpy (octal_string, string, 3);
! 	      octal_string[3] = '\0';
! 
! 	      n = read_octal (octal_string);
! 	      temp = xmalloc (3);
! 
! 	      if (n == CTLESC || n == CTLNUL)
! 		{
! 		  temp[0] = CTLESC;
! 		  temp[1] = n;
! 		  temp[2] = '\0';
! 		}
! 	      else if (n == -1)
! 		{
! 		  temp[0] = '\\';
! 		  temp[1] = '\0';
! 		}
! 	      else
! 		{
! 		  temp[0] = n;
! 		  temp[1] = '\0';
! 		}
! 
! 	      for (c = 0; n != -1 && c < 3 && ISOCTAL (*string); c++)
! 		string++;
! 
! 	      c = 0;
! 	      goto add_string;
  
! 	    case 't':
! 	    case 'd':
! 	    case 'T':
! 	    case '@':
! 	      /* Make the current time/date into a string. */
! 	      the_time = time (0);
! 	      temp = ctime (&the_time);
  
! 	      temp = (c != 'd') ? savestring (temp + 11) : savestring (temp);
! 	      temp[(c != 'd') ? 8 : 10] = '\0';
  
! 	      /* quick and dirty conversion to 12-hour time */
! 	      if (c == 'T' || c == '@')
! 		{
! 		  if (c == '@')
! 		    {
! 		      temp[5] = 'a';	/* am/pm format */
! 		      temp[6] = 'm';
! 		      temp[7] = '\0';
! 		    }
! 		  c = temp[2];
! 		  temp[2] = '\0';
! 		  n = atoi (temp);
! 		  temp[2] = c;
! 		  n -= 12;
! 		  if (n > 0)
! 		    {
! 		      temp[0] = (n / 10) + '0';
! 		      temp[1] = (n % 10) + '0';
! 		    }
! 		  if (n >= 0 && temp[5] == 'a')
! 		    temp[5] = 'p';
! 		}
! 	      goto add_string;
  
! 	    case 'r':
! 	      temp = xmalloc (2);
! 	      temp[0] = '\r';
! 	      temp[1] = '\0';
! 	      goto add_string;
  
! 	    case 'n':
! 	      temp = xmalloc (3);
! 	      temp[0] = no_line_editing ? '\n' : '\r';
! 	      temp[1] = no_line_editing ? '\0' : '\n';
! 	      temp[2] = '\0';
! 	      goto add_string;
  
! 	    case 's':
! 	      temp = base_pathname (shell_name);
! 	      temp = savestring (temp);
! 	      goto add_string;
  
! 	    case 'v':
! 	    case 'V':
! 	      temp = xmalloc (8);
! 	      if (c == 'v')
! 		strcpy (temp, dist_version);
! 	      else
! 		sprintf (temp, "%s.%d", dist_version, patch_level);
! 	      goto add_string;
  
! 	    case 'w':
! 	    case 'W':
! 	      {
! 		/* Use the value of PWD because it is much more efficient. */
! 		char t_string[PATH_MAX];
! 		int tlen;
  
! 		temp = get_string_value ("PWD");
  
! 		if (temp == 0)
! 		  {
! 		    if (getcwd (t_string, sizeof(t_string)) == 0)
! 		      {
! 			t_string[0] = '.';
! 			tlen = 1;
! 		      }
! 		    else
! 		      tlen = strlen (t_string);
! 		  }
! 		else
! 		  {
! 		    tlen = sizeof (t_string) - 1;
! 		    strncpy (t_string, temp, tlen);
! 		  }
! 		t_string[tlen] = '\0';
  
! #define ROOT_PATH(x)	((x)[0] == '/' && (x)[1] == 0)
! #define DOUBLE_SLASH_ROOT(x)	((x)[0] == '/' && (x)[1] == '/' && (x)[2] == 0)
! 		if (c == 'W')
! 		  {
! 		    if (ROOT_PATH (t_string) == 0 && DOUBLE_SLASH_ROOT (t_string) == 0)
! 		      {
! 			t = strrchr (t_string, '/');
! 			if (t)
! 			  strcpy (t_string, t + 1);
! 		      }
! 		  }
! #undef ROOT_PATH
! #undef DOUBLE_SLASH_ROOT
! 		else
! 		  /* polite_directory_format is guaranteed to return a string
! 		     no longer than PATH_MAX - 1 characters. */
! 		  strcpy (t_string, polite_directory_format (t_string));
  
! 		/* If we're going to be expanding the prompt string later,
! 		   quote the directory name. */
! 		if (promptvars || posixly_correct)
! 		  /* Make sure that expand_prompt_string is called with a
! 		     second argument of Q_DOUBLE_QUOTE if we use this
! 		     function here. */
! 		  temp = sh_backslash_quote_for_double_quotes (t_string);
! 		else
! 		  temp = savestring (t_string);
  
! 		goto add_string;
! 	      }
  
! 	    case 'u':
! 	      if (current_user.user_name == 0)
! 		get_current_user_info ();
! 	      temp = savestring (current_user.user_name);
! 	      goto add_string;
  
! 	    case 'h':
! 	    case 'H':
! 	      temp = savestring (current_host_name);
! 	      if (c == 'h' && (t = (char *)strchr (temp, '.')))
! 		*t = '\0';
! 	      goto add_string;
  
! 	    case '#':
! 	      temp = itos (current_command_number);
! 	      goto add_string;
  
! 	    case '!':
! #if !defined (HISTORY)
! 	      temp = savestring ("1");
! #else /* HISTORY */
! 	      temp = itos (history_number ());
! #endif /* HISTORY */
! 	      goto add_string;
  
! 	    case '$':
! 	      t = temp = xmalloc (3);
! 	      if ((promptvars || posixly_correct) && (current_user.euid != 0))
! 		*t++ = '\\';
! 	      *t++ = current_user.euid == 0 ? '#' : '$';
! 	      *t = '\0';
! 	      goto add_string;
  
! 	    case 'j':
! 	      temp = itos (count_all_jobs ());
! 	      goto add_string;
  
! 	    case 'l':
! #if defined (HAVE_TTYNAME)
! 	      temp = (char *)ttyname (fileno (stdin));
! 	      t = temp ? base_pathname (temp) : "tty";
! 	      temp = savestring (t);
! #else
! 	      temp = savestring ("tty");
! #endif /* !HAVE_TTYNAME */
! 	      goto add_string;
  
! #if defined (READLINE)
! 	    case '[':
! 	    case ']':
! 	      temp = xmalloc (3);
! 	      temp[0] = '\001';
! 	      temp[1] = (c == '[') ? RL_PROMPT_START_IGNORE : RL_PROMPT_END_IGNORE;
! 	      temp[2] = '\0';
! 	      goto add_string;
! #endif /* READLINE */
  
! 	    case '\\':
! 	      temp = xmalloc (2);
! 	      temp[0] = c;
! 	      temp[1] = '\0';
! 	      goto add_string;
  
! 	    case 'a':
! 	    case 'e':
! 	      temp = xmalloc (2);
! 	      temp[0] = (c == 'a') ? '\07' : '\033';
! 	      temp[1] = '\0';
! 	      goto add_string;
  
! 	    default:
! 	      temp = xmalloc (3);
! 	      temp[0] = '\\';
! 	      temp[1] = c;
! 	      temp[2] = '\0';
  
! 	    add_string:
! 	      if (c)
! 		string++;
! 	      result =
! 		sub_append_string (temp, result, &result_index, &result_size);
! 	      temp = (char *)NULL; /* Freed in sub_append_string (). */
! 	      result[result_index] = '\0';
! 	      break;
! 	    }
! 	}
!       else
! 	{
! 	  RESIZE_MALLOCED_BUFFER (result, result_index, 3, result_size, PROMPT_GROWTH);
! 	  result[result_index++] = c;
! 	  result[result_index] = '\0';
! 	}
      }
- #else /* !PROMPT_STRING_DECODE */
-   result = savestring (string);
- #endif /* !PROMPT_STRING_DECODE */
  
!   /* Save the delimiter stack and point `dstack' to temp space so any
!      command substitutions in the prompt string won't result in screwing
!      up the parser's quoting state. */
!   save_dstack = dstack;
!   dstack = temp_dstack;
!   dstack.delimiter_depth = 0;
  
!   /* Perform variable and parameter expansion and command substitution on
!      the prompt string. */
!   if (promptvars || posixly_correct)
      {
!       list = expand_prompt_string (result, Q_DOUBLE_QUOTES);
!       free (result);
!       result = string_list (list);
!       dispose_words (list);
      }
    else
      {
!       t = dequote_string (result);
!       free (result);
!       result = t;
      }
- 
-   dstack = save_dstack;
- 
-   return (result);
  }
  
- /* Report a syntax error, and restart the parser.  Call here for fatal
-    errors. */
  int
! yyerror ()
  {
!   report_syntax_error ((char *)NULL);
!   reset_parser ();
!   return (0);
  }
  
! /* Report a syntax error with line numbers, etc.
!    Call here for recoverable errors.  If you have a message to print,
!    then place it in MESSAGE, otherwise pass NULL and this will figure
!    out an appropriate message for you. */
  static void
! report_syntax_error (message)
!      char *message;
  {
!   char *msg, *t;
!   int token_end, i;
!   char msg2[2];
! 
!   if (message)
!     {
!       parser_error (line_number, "%s", message);
!       if (interactive && EOF_Reached)
! 	EOF_Reached = 0;
!       last_command_exit_value = EX_USAGE;
!       return;
!     }
! 
!   /* If the line of input we're reading is not null, try to find the
!      objectionable token. */
!   if (shell_input_line && *shell_input_line)
!     {
!       t = shell_input_line;
!       i = shell_input_line_index;
!       token_end = 0;
! 
!       if (i && t[i] == '\0')
! 	i--;
! 
!       while (i && (whitespace (t[i]) || t[i] == '\n'))
! 	i--;
  
!       if (i)
! 	token_end = i + 1;
  
!       while (i && (member (t[i], " \n\t;|&") == 0))
! 	i--;
  
!       while (i != token_end && (whitespace (t[i]) || t[i] == '\n'))
! 	i++;
  
!       /* Print the offending token. */
!       if (token_end || (i == 0 && token_end == 0))
  	{
! 	  if (token_end)
! 	    msg = substring (t, i, token_end);
! 	  else	/* one-character token */
  	    {
! 	      msg2[0] = t[i];
! 	      msg2[1] = '\0';
! 	      msg = msg2;
! 	    }
  
! 	  parser_error (line_number, "syntax error near unexpected token `%s'", msg);
  
! 	  if (msg != msg2)
! 	    free (msg);
! 	}
  
!       /* If not interactive, print the line containing the error. */
!       if (interactive == 0)
! 	{
! 	  msg = savestring (shell_input_line);
! 	  token_end = strlen (msg);
! 	  while (token_end && msg[token_end - 1] == '\n')
! 	    msg[--token_end] = '\0';
  
! 	  parser_error (line_number, "`%s'", msg);
! 	  free (msg);
! 	}
!     }
!   else
!     {
!       msg = EOF_Reached ? "syntax error: unexpected end of file" : "syntax error";
!       parser_error (line_number, "%s", msg);
!       /* When the shell is interactive, this file uses EOF_Reached
! 	 only for error reporting.  Other mechanisms are used to
! 	 decide whether or not to exit. */
!       if (interactive && EOF_Reached)
! 	EOF_Reached = 0;
!     }
!   last_command_exit_value = EX_USAGE;
! }
  
! /* ??? Needed function. ??? We have to be able to discard the constructs
!    created during parsing.  In the case of error, we want to return
!    allocated objects to the memory pool.  In the case of no error, we want
!    to throw away the information about where the allocated objects live.
!    (dispose_command () will actually free the command. */
! static void
! discard_parser_constructs (error_p)
!      int error_p;
! {
! }
  
! /* Do that silly `type "bye" to exit' stuff.  You know, "ignoreeof". */
  
! /* A flag denoting whether or not ignoreeof is set. */
! int ignoreeof = 0;
  
! /* The number of times that we have encountered an EOF character without
!    another character intervening.  When this gets above the limit, the
!    shell terminates. */
! int eof_encountered = 0;
  
! /* The limit for eof_encountered. */
! int eof_encountered_limit = 10;
  
! /* If we have EOF as the only input unit, this user wants to leave
!    the shell.  If the shell is not interactive, then just leave.
!    Otherwise, if ignoreeof is set, and we haven't done this the
!    required number of times in a row, print a message. */
! static void
! handle_eof_input_unit ()
! {
!   if (interactive)
!     {
!       /* shell.c may use this to decide whether or not to write out the
! 	 history, among other things.  We use it only for error reporting
! 	 in this file. */
!       if (EOF_Reached)
! 	EOF_Reached = 0;
  
!       /* If the user wants to "ignore" eof, then let her do so, kind of. */
!       if (ignoreeof)
! 	{
! 	  if (eof_encountered < eof_encountered_limit)
! 	    {
! 	      fprintf (stderr, "Use \"%s\" to leave the shell.\n",
! 		       login_shell ? "logout" : "exit");
! 	      eof_encountered++;
! 	      /* Reset the prompt string to be $PS1. */
! 	      prompt_string_pointer = (char **)NULL;
! 	      prompt_again ();
! 	      last_read_token = current_token = '\n';
! 	      return;
! 	    }
! 	}
  
!       /* In this case EOF should exit the shell.  Do it now. */
!       reset_parser ();
!       exit_builtin ((WORD_LIST *)NULL);
!     }
!   else
!     {
!       /* We don't write history files, etc., for non-interactive shells. */
!       EOF_Reached = 1;
!     }
! }
  
! static WORD_LIST parse_string_error;
  
! /* Take a string and run it through the shell parser, returning the
!    resultant word list.  Used by compound array assignment. */
! WORD_LIST *
! parse_string_to_word_list (s, whom)
!      char *s, *whom;
! {
!   WORD_LIST *wl;
!   int tok, orig_line_number, orig_input_terminator;
!   int orig_line_count;
! #if defined (HISTORY)
!   int old_remember_on_history, old_history_expansion_inhibited;
! #endif
  
! #if defined (HISTORY)
!   old_remember_on_history = remember_on_history;
! #  if defined (BANG_HISTORY)
!   old_history_expansion_inhibited = history_expansion_inhibited;
! #  endif
!   bash_history_disable ();
! #endif
  
!   orig_line_number = line_number;
!   orig_line_count = current_command_line_count;
!   orig_input_terminator = shell_input_line_terminator;
  
!   push_stream (1);
!   last_read_token = '\n';
!   current_command_line_count = 0;
  
!   with_input_from_string (s, whom);
!   wl = (WORD_LIST *)NULL;
!   while ((tok = read_token (READ)) != yacc_EOF)
!     {
!       if (tok == '\n' && *bash_input.location.string == '\0')
! 	break;
!       if (tok == '\n')		/* Allow newlines in compound assignments */
! 	continue;
!       if (tok != WORD && tok != ASSIGNMENT_WORD)
! 	{
! 	  line_number = orig_line_number + line_number - 1;
! 	  yyerror ();	/* does the right thing */
! 	  if (wl)
! 	    dispose_words (wl);
! 	  wl = &parse_string_error;
! 	  break;
! 	}
!       wl = make_word_list (yylval.word, wl);
!     }
!   
!   last_read_token = '\n';
!   pop_stream ();
  
! #if defined (HISTORY)
!   remember_on_history = old_remember_on_history;
! #  if defined (BANG_HISTORY)
!   history_expansion_inhibited = old_history_expansion_inhibited;
! #  endif /* BANG_HISTORY */
  #endif /* HISTORY */
  
!   current_command_line_count = orig_line_count;
!   shell_input_line_terminator = orig_input_terminator;
! 
!   if (wl == &parse_string_error)
!     {
!       last_command_exit_value = EXECUTION_FAILURE;
!       if (interactive_shell == 0 && posixly_correct)
! 	jump_to_top_level (FORCE_EOF);
!       else
! 	jump_to_top_level (DISCARD);
!     }
  
!   return (REVERSE_LIST (wl, WORD_LIST *));
! }
! #line 4199 "y.tab.c"
! /* allocate initial stack or double stack size, up to YYMAXDEPTH */
! static int yygrowstack()
! {
!     int newsize, i;
!     short *newss;
!     YYSTYPE *newvs;
! 
!     if ((newsize = yystacksize) == 0)
!         newsize = YYINITSTACKSIZE;
!     else if (newsize >= YYMAXDEPTH)
!         return -1;
!     else if ((newsize *= 2) > YYMAXDEPTH)
!         newsize = YYMAXDEPTH;
!     i = yyssp - yyss;
!     newss = yyss ? (short *)realloc(yyss, newsize * sizeof *newss) :
!       (short *)malloc(newsize * sizeof *newss);
!     if (newss == NULL)
!         return -1;
!     yyss = newss;
!     yyssp = newss + i;
!     newvs = yyvs ? (YYSTYPE *)realloc(yyvs, newsize * sizeof *newvs) :
!       (YYSTYPE *)malloc(newsize * sizeof *newvs);
!     if (newvs == NULL)
!         return -1;
!     yyvs = newvs;
!     yyvsp = newvs + i;
!     yystacksize = newsize;
!     yysslim = yyss + newsize - 1;
!     return 0;
! }
! 
! #define YYABORT goto yyabort
! #define YYREJECT goto yyabort
! #define YYACCEPT goto yyaccept
! #define YYERROR goto yyerrlab
! 
! #ifndef YYPARSE_PARAM
! #if defined(__cplusplus) || __STDC__
! #define YYPARSE_PARAM_ARG void
! #define YYPARSE_PARAM_DECL
! #else	/* ! ANSI-C/C++ */
! #define YYPARSE_PARAM_ARG
! #define YYPARSE_PARAM_DECL
! #endif	/* ANSI-C/C++ */
! #else	/* YYPARSE_PARAM */
! #ifndef YYPARSE_PARAM_TYPE
! #define YYPARSE_PARAM_TYPE void *
! #endif
! #if defined(__cplusplus) || __STDC__
! #define YYPARSE_PARAM_ARG YYPARSE_PARAM_TYPE YYPARSE_PARAM
! #define YYPARSE_PARAM_DECL
! #else	/* ! ANSI-C/C++ */
! #define YYPARSE_PARAM_ARG YYPARSE_PARAM
! #define YYPARSE_PARAM_DECL YYPARSE_PARAM_TYPE YYPARSE_PARAM;
! #endif	/* ANSI-C/C++ */
! #endif	/* ! YYPARSE_PARAM */
  
! int
! yyparse (YYPARSE_PARAM_ARG)
!     YYPARSE_PARAM_DECL
! {
!     register int yym, yyn, yystate;
! #if YYDEBUG
!     register const char *yys;
! 
!     if ((yys = getenv("YYDEBUG")))
!     {
!         yyn = *yys;
!         if (yyn >= '0' && yyn <= '9')
!             yydebug = yyn - '0';
!     }
! #endif
! 
!     yynerrs = 0;
!     yyerrflag = 0;
!     yychar = (-1);
! 
!     if (yyss == NULL && yygrowstack()) goto yyoverflow;
!     yyssp = yyss;
!     yyvsp = yyvs;
!     *yyssp = yystate = 0;
! 
! yyloop:
!     if ((yyn = yydefred[yystate])) goto yyreduce;
!     if (yychar < 0)
!     {
!         if ((yychar = yylex()) < 0) yychar = 0;
! #if YYDEBUG
!         if (yydebug)
!         {
!             yys = 0;
!             if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
!             if (!yys) yys = "illegal-symbol";
!             printf("%sdebug: state %d, reading %d (%s)\n",
!                     YYPREFIX, yystate, yychar, yys);
!         }
! #endif
!     }
!     if ((yyn = yysindex[yystate]) && (yyn += yychar) >= 0 &&
!             yyn <= YYTABLESIZE && yycheck[yyn] == yychar)
!     {
! #if YYDEBUG
!         if (yydebug)
!             printf("%sdebug: state %d, shifting to state %d\n",
!                     YYPREFIX, yystate, yytable[yyn]);
! #endif
!         if (yyssp >= yysslim && yygrowstack())
!         {
!             goto yyoverflow;
!         }
!         *++yyssp = yystate = yytable[yyn];
!         *++yyvsp = yylval;
!         yychar = (-1);
!         if (yyerrflag > 0)  --yyerrflag;
!         goto yyloop;
!     }
!     if ((yyn = yyrindex[yystate]) && (yyn += yychar) >= 0 &&
!             yyn <= YYTABLESIZE && yycheck[yyn] == yychar)
!     {
!         yyn = yytable[yyn];
!         goto yyreduce;
!     }
!     if (yyerrflag) goto yyinrecovery;
! #if defined(lint) || defined(__GNUC__)
!     goto yynewerror;
! #endif
! yynewerror:
!     yyerror("syntax error");
! #if defined(lint) || defined(__GNUC__)
!     goto yyerrlab;
! #endif
! yyerrlab:
!     ++yynerrs;
! yyinrecovery:
!     if (yyerrflag < 3)
!     {
!         yyerrflag = 3;
!         for (;;)
!         {
!             if ((yyn = yysindex[*yyssp]) && (yyn += YYERRCODE) >= 0 &&
!                     yyn <= YYTABLESIZE && yycheck[yyn] == YYERRCODE)
!             {
! #if YYDEBUG
!                 if (yydebug)
!                     printf("%sdebug: state %d, error recovery shifting\
!  to state %d\n", YYPREFIX, *yyssp, yytable[yyn]);
! #endif
!                 if (yyssp >= yysslim && yygrowstack())
!                 {
!                     goto yyoverflow;
!                 }
!                 *++yyssp = yystate = yytable[yyn];
!                 *++yyvsp = yylval;
!                 goto yyloop;
!             }
!             else
!             {
! #if YYDEBUG
!                 if (yydebug)
!                     printf("%sdebug: error recovery discarding state %d\n",
!                             YYPREFIX, *yyssp);
! #endif
!                 if (yyssp <= yyss) goto yyabort;
!                 --yyssp;
!                 --yyvsp;
!             }
!         }
!     }
!     else
!     {
!         if (yychar == 0) goto yyabort;
! #if YYDEBUG
!         if (yydebug)
!         {
!             yys = 0;
!             if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
!             if (!yys) yys = "illegal-symbol";
!             printf("%sdebug: state %d, error recovery discards token %d (%s)\n",
!                     YYPREFIX, yystate, yychar, yys);
!         }
! #endif
!         yychar = (-1);
!         goto yyloop;
!     }
! yyreduce:
! #if YYDEBUG
!     if (yydebug)
!         printf("%sdebug: state %d, reducing by rule %d (%s)\n",
!                 YYPREFIX, yystate, yyn, yyrule[yyn]);
! #endif
!     yym = yylen[yyn];
!     yyval = yyvsp[1-yym];
!     switch (yyn)
!     {
! case 1:
! #line 241 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  /* Case of regular command.  Discard the error
! 			     safety net,and return the command just parsed. */
! 			  global_command = yyvsp[-1].command;
! 			  eof_encountered = 0;
! 			  discard_parser_constructs (0);
! 			  YYACCEPT;
! 			}
! break;
! case 2:
! #line 250 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  /* Case of regular command, but not a very
! 			     interesting one.  Return a NULL command. */
! 			  global_command = (COMMAND *)NULL;
! 			  YYACCEPT;
! 			}
! break;
! case 3:
! #line 257 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  /* Error during parsing.  Return NULL command. */
! 			  global_command = (COMMAND *)NULL;
! 			  eof_encountered = 0;
! 			  discard_parser_constructs (1);
! 			  if (interactive)
! 			    {
! 			      YYACCEPT;
! 			    }
! 			  else
! 			    {
! 			      YYABORT;
! 			    }
! 			}
! break;
! case 4:
! #line 272 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  /* Case of EOF seen by itself.  Do ignoreeof or
! 			     not. */
! 			  global_command = (COMMAND *)NULL;
! 			  handle_eof_input_unit ();
! 			  YYACCEPT;
! 			}
! break;
! case 5:
! #line 282 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.word_list = make_word_list (yyvsp[0].word, (WORD_LIST *)NULL); }
! break;
! case 6:
! #line 284 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.word_list = make_word_list (yyvsp[0].word, yyvsp[-1].word_list); }
! break;
! case 7:
! #line 288 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  redir.filename = yyvsp[0].word;
! 			  yyval.redirect = make_redirection (1, r_output_direction, redir);
! 			}
! break;
! case 8:
! #line 293 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  redir.filename = yyvsp[0].word;
! 			  yyval.redirect = make_redirection (0, r_input_direction, redir);
! 			}
! break;
! case 9:
! #line 298 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  redir.filename = yyvsp[0].word;
! 			  yyval.redirect = make_redirection (yyvsp[-2].number, r_output_direction, redir);
! 			}
! break;
! case 10:
! #line 303 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  redir.filename = yyvsp[0].word;
! 			  yyval.redirect = make_redirection (yyvsp[-2].number, r_input_direction, redir);
! 			}
! break;
! case 11:
! #line 308 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  redir.filename = yyvsp[0].word;
! 			  yyval.redirect = make_redirection (1, r_appending_to, redir);
! 			}
! break;
! case 12:
! #line 313 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  redir.filename = yyvsp[0].word;
! 			  yyval.redirect = make_redirection (yyvsp[-2].number, r_appending_to, redir);
! 			}
! break;
! case 13:
! #line 318 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  redir.filename = yyvsp[0].word;
! 			  yyval.redirect = make_redirection (0, r_reading_until, redir);
! 			  redir_stack[need_here_doc++] = yyval.redirect;
! 			}
! break;
! case 14:
! #line 324 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  redir.filename = yyvsp[0].word;
! 			  yyval.redirect = make_redirection (yyvsp[-2].number, r_reading_until, redir);
! 			  redir_stack[need_here_doc++] = yyval.redirect;
! 			}
! break;
! case 15:
! #line 330 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  redir.dest = yyvsp[0].number;
! 			  yyval.redirect = make_redirection (0, r_duplicating_input, redir);
! 			}
! break;
! case 16:
! #line 335 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  redir.dest = yyvsp[0].number;
! 			  yyval.redirect = make_redirection (yyvsp[-2].number, r_duplicating_input, redir);
! 			}
! break;
! case 17:
! #line 340 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  redir.dest = yyvsp[0].number;
! 			  yyval.redirect = make_redirection (1, r_duplicating_output, redir);
! 			}
! break;
! case 18:
! #line 345 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  redir.dest = yyvsp[0].number;
! 			  yyval.redirect = make_redirection (yyvsp[-2].number, r_duplicating_output, redir);
! 			}
! break;
! case 19:
! #line 350 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  redir.filename = yyvsp[0].word;
! 			  yyval.redirect = make_redirection (0, r_duplicating_input_word, redir);
! 			}
! break;
! case 20:
! #line 355 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  redir.filename = yyvsp[0].word;
! 			  yyval.redirect = make_redirection (yyvsp[-2].number, r_duplicating_input_word, redir);
! 			}
! break;
! case 21:
! #line 360 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  redir.filename = yyvsp[0].word;
! 			  yyval.redirect = make_redirection (1, r_duplicating_output_word, redir);
! 			}
! break;
! case 22:
! #line 365 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  redir.filename = yyvsp[0].word;
! 			  yyval.redirect = make_redirection (yyvsp[-2].number, r_duplicating_output_word, redir);
! 			}
! break;
! case 23:
! #line 370 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  redir.filename = yyvsp[0].word;
! 			  yyval.redirect = make_redirection
! 			    (0, r_deblank_reading_until, redir);
! 			  redir_stack[need_here_doc++] = yyval.redirect;
! 			}
! break;
! case 24:
! #line 377 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  redir.filename = yyvsp[0].word;
! 			  yyval.redirect = make_redirection
! 			    (yyvsp[-2].number, r_deblank_reading_until, redir);
! 			  redir_stack[need_here_doc++] = yyval.redirect;
! 			}
! break;
! case 25:
! #line 384 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  redir.dest = 0L;
! 			  yyval.redirect = make_redirection (1, r_close_this, redir);
! 			}
! break;
! case 26:
! #line 389 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  redir.dest = 0L;
! 			  yyval.redirect = make_redirection (yyvsp[-2].number, r_close_this, redir);
! 			}
! break;
! case 27:
! #line 394 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  redir.dest = 0L;
! 			  yyval.redirect = make_redirection (0, r_close_this, redir);
! 			}
! break;
! case 28:
! #line 399 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  redir.dest = 0L;
! 			  yyval.redirect = make_redirection (yyvsp[-2].number, r_close_this, redir);
! 			}
! break;
! case 29:
! #line 404 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  redir.filename = yyvsp[0].word;
! 			  yyval.redirect = make_redirection (1, r_err_and_out, redir);
! 			}
! break;
! case 30:
! #line 409 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  redir.filename = yyvsp[0].word;
! 			  yyval.redirect = make_redirection (yyvsp[-2].number, r_input_output, redir);
! 			}
! break;
! case 31:
! #line 414 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  redir.filename = yyvsp[0].word;
! 			  yyval.redirect = make_redirection (0, r_input_output, redir);
! 			}
! break;
! case 32:
! #line 419 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  redir.filename = yyvsp[0].word;
! 			  yyval.redirect = make_redirection (1, r_output_force, redir);
! 			}
! break;
! case 33:
! #line 424 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  redir.filename = yyvsp[0].word;
! 			  yyval.redirect = make_redirection (yyvsp[-2].number, r_output_force, redir);
! 			}
! break;
! case 34:
! #line 431 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.element.word = yyvsp[0].word; yyval.element.redirect = 0; }
! break;
! case 35:
! #line 433 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.element.word = yyvsp[0].word; yyval.element.redirect = 0; }
! break;
! case 36:
! #line 435 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.element.redirect = yyvsp[0].redirect; yyval.element.word = 0; }
! break;
! case 37:
! #line 439 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  yyval.redirect = yyvsp[0].redirect;
! 			}
! break;
! case 38:
! #line 443 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  register REDIRECT *t;
  
! 			  for (t = yyvsp[-1].redirect; t->next; t = t->next)
! 			    ;
! 			  t->next = yyvsp[0].redirect;
! 			  yyval.redirect = yyvsp[-1].redirect;
! 			}
! break;
! case 39:
! #line 454 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = make_simple_command (yyvsp[0].element, (COMMAND *)NULL); }
! break;
! case 40:
! #line 456 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = make_simple_command (yyvsp[0].element, yyvsp[-1].command); }
! break;
! case 41:
! #line 460 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = clean_simple_command (yyvsp[0].command); }
! break;
! case 42:
! #line 462 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = yyvsp[0].command; }
! break;
! case 43:
! #line 464 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  COMMAND *tc;
  
! 			  tc = yyvsp[-1].command;
! 			  if (tc->redirects)
! 			    {
! 			      register REDIRECT *t;
! 			      for (t = tc->redirects; t->next; t = t->next)
! 				;
! 			      t->next = yyvsp[0].redirect;
! 			    }
! 			  else
! 			    tc->redirects = yyvsp[0].redirect;
! 			  yyval.command = yyvsp[-1].command;
! 			}
! break;
! case 44:
! #line 480 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = yyvsp[0].command; }
! break;
! case 45:
! #line 484 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = yyvsp[0].command; }
! break;
! case 46:
! #line 486 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = yyvsp[0].command; }
! break;
! case 47:
! #line 488 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = make_while_command (yyvsp[-3].command, yyvsp[-1].command); }
! break;
! case 48:
! #line 490 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = make_until_command (yyvsp[-3].command, yyvsp[-1].command); }
! break;
! case 49:
! #line 492 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = yyvsp[0].command; }
! break;
! case 50:
! #line 494 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = yyvsp[0].command; }
! break;
! case 51:
! #line 496 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = yyvsp[0].command; }
! break;
! case 52:
! #line 498 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = yyvsp[0].command; }
! break;
! case 53:
! #line 500 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = yyvsp[0].command; }
! break;
! case 54:
! #line 502 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = yyvsp[0].command; }
! break;
! case 55:
! #line 504 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = yyvsp[0].command; }
! break;
! case 56:
! #line 508 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = make_for_command (yyvsp[-4].word, add_string_to_list ("\"$@\"", (WORD_LIST *)NULL), yyvsp[-1].command); }
! break;
! case 57:
! #line 510 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = make_for_command (yyvsp[-4].word, add_string_to_list ("$@", (WORD_LIST *)NULL), yyvsp[-1].command); }
! break;
! case 58:
! #line 512 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = make_for_command (yyvsp[-5].word, add_string_to_list ("\"$@\"", (WORD_LIST *)NULL), yyvsp[-1].command); }
! break;
! case 59:
! #line 514 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = make_for_command (yyvsp[-5].word, add_string_to_list ("\"$@\"", (WORD_LIST *)NULL), yyvsp[-1].command); }
! break;
! case 60:
! #line 516 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = make_for_command (yyvsp[-8].word, REVERSE_LIST (yyvsp[-5].word_list, WORD_LIST *), yyvsp[-1].command); }
! break;
! case 61:
! #line 518 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = make_for_command (yyvsp[-8].word, REVERSE_LIST (yyvsp[-5].word_list, WORD_LIST *), yyvsp[-1].command); }
! break;
! case 62:
! #line 522 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = make_arith_for_command (yyvsp[-5].word_list, yyvsp[-1].command, arith_for_lineno); }
! break;
! case 63:
! #line 524 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = make_arith_for_command (yyvsp[-5].word_list, yyvsp[-1].command, arith_for_lineno); }
! break;
! case 64:
! #line 526 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = make_arith_for_command (yyvsp[-3].word_list, yyvsp[-1].command, arith_for_lineno); }
! break;
! case 65:
! #line 528 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = make_arith_for_command (yyvsp[-3].word_list, yyvsp[-1].command, arith_for_lineno); }
! break;
! case 66:
! #line 532 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  yyval.command = make_select_command (yyvsp[-4].word, add_string_to_list ("\"$@\"", (WORD_LIST *)NULL), yyvsp[-1].command);
! 			}
! break;
! case 67:
! #line 536 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  yyval.command = make_select_command (yyvsp[-4].word, add_string_to_list ("$@", (WORD_LIST *)NULL), yyvsp[-1].command);
! 			}
! break;
! case 68:
! #line 540 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  yyval.command = make_select_command (yyvsp[-5].word, add_string_to_list ("\"$@\"", (WORD_LIST *)NULL), yyvsp[-1].command);
! 			}
! break;
! case 69:
! #line 544 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  yyval.command = make_select_command (yyvsp[-5].word, add_string_to_list ("\"$@\"", (WORD_LIST *)NULL), yyvsp[-1].command);
! 			}
! break;
! case 70:
! #line 548 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  yyval.command = make_select_command (yyvsp[-8].word, (WORD_LIST *)reverse_list (yyvsp[-5].word_list), yyvsp[-1].command);
! 			}
! break;
! case 71:
! #line 552 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  yyval.command = make_select_command (yyvsp[-8].word, (WORD_LIST *)reverse_list (yyvsp[-5].word_list), yyvsp[-1].command);
! 			}
! break;
! case 72:
! #line 558 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = make_case_command (yyvsp[-4].word, (PATTERN_LIST *)NULL); }
! break;
! case 73:
! #line 560 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = make_case_command (yyvsp[-5].word, yyvsp[-2].pattern); }
! break;
! case 74:
! #line 562 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = make_case_command (yyvsp[-4].word, yyvsp[-1].pattern); }
! break;
! case 75:
! #line 566 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = make_function_def (yyvsp[-4].word, yyvsp[0].command, function_dstart, function_bstart); }
! break;
! case 76:
! #line 569 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = make_function_def (yyvsp[-4].word, yyvsp[0].command, function_dstart, function_bstart); }
! break;
! case 77:
! #line 572 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = make_function_def (yyvsp[-2].word, yyvsp[0].command, function_dstart, function_bstart); }
! break;
! case 78:
! #line 577 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = yyvsp[0].command; }
! break;
! case 79:
! #line 579 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  COMMAND *tc;
  
! 			  tc = yyvsp[-1].command;
! 			  /* According to Posix.2 3.9.5, redirections
! 			     specified after the body of a function should
! 			     be attached to the function and performed when
! 			     the function is executed, not as part of the
! 			     function definition command. */
! 			  /* XXX - I don't think it matters, but we might
! 			     want to change this in the future to avoid
! 			     problems differentiating between a function
! 			     definition with a redirection and a function
! 			     definition containing a single command with a
! 			     redirection.  The two are semantically equivalent,
! 			     though -- the only difference is in how the
! 			     command printing code displays the redirections. */
! 			  if (tc->redirects)
! 			    {
! 			      register REDIRECT *t;
! 			      for (t = tc->redirects; t->next; t = t->next)
! 				;
! 			      t->next = yyvsp[0].redirect;
! 			    }
! 			  else
! 			    tc->redirects = yyvsp[0].redirect;
! 			  yyval.command = yyvsp[-1].command;
! 			}
! break;
! case 80:
! #line 610 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  yyval.command = make_subshell_command (yyvsp[-1].command);
! 			  yyval.command->flags |= CMD_WANT_SUBSHELL;
! 			}
! break;
! case 81:
! #line 617 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = make_if_command (yyvsp[-3].command, yyvsp[-1].command, (COMMAND *)NULL); }
! break;
! case 82:
! #line 619 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = make_if_command (yyvsp[-5].command, yyvsp[-3].command, yyvsp[-1].command); }
! break;
! case 83:
! #line 621 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = make_if_command (yyvsp[-4].command, yyvsp[-2].command, yyvsp[-1].command); }
! break;
! case 84:
! #line 626 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = make_group_command (yyvsp[-1].command); }
! break;
! case 85:
! #line 630 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = make_arith_command (yyvsp[0].word_list); }
! break;
! case 86:
! #line 634 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = yyvsp[-1].command; }
! break;
! case 87:
! #line 638 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = make_if_command (yyvsp[-2].command, yyvsp[0].command, (COMMAND *)NULL); }
! break;
! case 88:
! #line 640 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = make_if_command (yyvsp[-4].command, yyvsp[-2].command, yyvsp[0].command); }
! break;
! case 89:
! #line 642 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = make_if_command (yyvsp[-3].command, yyvsp[-1].command, yyvsp[0].command); }
! break;
! case 91:
! #line 647 "/usr/homes/chet/src/bash/src/parse.y"
! { yyvsp[0].pattern->next = yyvsp[-1].pattern; yyval.pattern = yyvsp[0].pattern; }
! break;
! case 92:
! #line 651 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.pattern = make_pattern_list (yyvsp[-2].word_list, yyvsp[0].command); }
! break;
! case 93:
! #line 653 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.pattern = make_pattern_list (yyvsp[-2].word_list, (COMMAND *)NULL); }
! break;
! case 94:
! #line 655 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.pattern = make_pattern_list (yyvsp[-2].word_list, yyvsp[0].command); }
! break;
! case 95:
! #line 657 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.pattern = make_pattern_list (yyvsp[-2].word_list, (COMMAND *)NULL); }
! break;
! case 97:
! #line 662 "/usr/homes/chet/src/bash/src/parse.y"
! { yyvsp[-1].pattern->next = yyvsp[-2].pattern; yyval.pattern = yyvsp[-1].pattern; }
! break;
! case 98:
! #line 666 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.word_list = make_word_list (yyvsp[0].word, (WORD_LIST *)NULL); }
! break;
! case 99:
! #line 668 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.word_list = make_word_list (yyvsp[0].word, yyvsp[-2].word_list); }
! break;
! case 100:
! #line 677 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  yyval.command = yyvsp[0].command;
! 			  if (need_here_doc)
! 			    gather_here_documents ();
! 			 }
! break;
! case 102:
! #line 686 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  yyval.command = yyvsp[0].command;
! 			}
! break;
! case 104:
! #line 693 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  if (yyvsp[-2].command->type == cm_connection)
! 			    yyval.command = connect_async_list (yyvsp[-2].command, (COMMAND *)NULL, '&');
! 			  else
! 			    yyval.command = command_connect (yyvsp[-2].command, (COMMAND *)NULL, '&');
! 			}
! break;
! case 106:
! #line 704 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = command_connect (yyvsp[-3].command, yyvsp[0].command, AND_AND); }
! break;
! case 107:
! #line 706 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = command_connect (yyvsp[-3].command, yyvsp[0].command, OR_OR); }
! break;
! case 108:
! #line 708 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  if (yyvsp[-3].command->type == cm_connection)
! 			    yyval.command = connect_async_list (yyvsp[-3].command, yyvsp[0].command, '&');
! 			  else
! 			    yyval.command = command_connect (yyvsp[-3].command, yyvsp[0].command, '&');
! 			}
! break;
! case 109:
! #line 715 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = command_connect (yyvsp[-3].command, yyvsp[0].command, ';'); }
! break;
! case 110:
! #line 717 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = command_connect (yyvsp[-3].command, yyvsp[0].command, ';'); }
! break;
! case 111:
! #line 719 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = yyvsp[0].command; }
! break;
! case 117:
! #line 738 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  yyval.command = yyvsp[0].command;
! 			  if (need_here_doc)
! 			    gather_here_documents ();
! 			}
! break;
! case 118:
! #line 744 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  if (yyvsp[-1].command->type == cm_connection)
! 			    yyval.command = connect_async_list (yyvsp[-1].command, (COMMAND *)NULL, '&');
! 			  else
! 			    yyval.command = command_connect (yyvsp[-1].command, (COMMAND *)NULL, '&');
! 			  if (need_here_doc)
! 			    gather_here_documents ();
! 			}
! break;
! case 119:
! #line 753 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  yyval.command = yyvsp[-1].command;
! 			  if (need_here_doc)
! 			    gather_here_documents ();
! 			}
! break;
! case 120:
! #line 761 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = command_connect (yyvsp[-3].command, yyvsp[0].command, AND_AND); }
! break;
! case 121:
! #line 763 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = command_connect (yyvsp[-3].command, yyvsp[0].command, OR_OR); }
! break;
! case 122:
! #line 765 "/usr/homes/chet/src/bash/src/parse.y"
  {
! 			  if (yyvsp[-2].command->type == cm_connection)
! 			    yyval.command = connect_async_list (yyvsp[-2].command, yyvsp[0].command, '&');
! 			  else
! 			    yyval.command = command_connect (yyvsp[-2].command, yyvsp[0].command, '&');
! 			}
! break;
! case 123:
! #line 772 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = command_connect (yyvsp[-2].command, yyvsp[0].command, ';'); }
! break;
! case 124:
! #line 775 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = yyvsp[0].command; }
! break;
! case 125:
! #line 779 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = yyvsp[0].command; }
! break;
! case 126:
! #line 781 "/usr/homes/chet/src/bash/src/parse.y"
  {
! 			  yyvsp[0].command->flags |= CMD_INVERT_RETURN;
! 			  yyval.command = yyvsp[0].command;
! 			}
! break;
! case 127:
! #line 786 "/usr/homes/chet/src/bash/src/parse.y"
  {
! 			  yyvsp[0].command->flags |= yyvsp[-1].number;
! 			  yyval.command = yyvsp[0].command;
! 			}
! break;
! case 128:
! #line 791 "/usr/homes/chet/src/bash/src/parse.y"
  {
! 			  yyvsp[0].command->flags |= yyvsp[-2].number|CMD_INVERT_RETURN;
! 			  yyval.command = yyvsp[0].command;
! 			}
! break;
! case 129:
! #line 796 "/usr/homes/chet/src/bash/src/parse.y"
  {
! 			  yyvsp[0].command->flags |= yyvsp[-1].number|CMD_INVERT_RETURN;
! 			  yyval.command = yyvsp[0].command;
! 			}
! break;
! case 130:
! #line 804 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = command_connect (yyvsp[-3].command, yyvsp[0].command, '|'); }
! break;
! case 131:
! #line 806 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = yyvsp[0].command; }
! break;
! case 132:
! #line 810 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.number = CMD_TIME_PIPELINE; }
! break;
! case 133:
! #line 812 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.number = CMD_TIME_PIPELINE|CMD_TIME_POSIX; }
! break;
! #line 5117 "y.tab.c"
!     }
!     yyssp -= yym;
!     yystate = *yyssp;
!     yyvsp -= yym;
!     yym = yylhs[yyn];
!     if (yystate == 0 && yym == 0)
!     {
! #if YYDEBUG
!         if (yydebug)
!             printf("%sdebug: after reduction, shifting from state 0 to\
!  state %d\n", YYPREFIX, YYFINAL);
! #endif
!         yystate = YYFINAL;
!         *++yyssp = YYFINAL;
!         *++yyvsp = yyval;
!         if (yychar < 0)
!         {
!             if ((yychar = yylex()) < 0) yychar = 0;
! #if YYDEBUG
!             if (yydebug)
!             {
!                 yys = 0;
!                 if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
!                 if (!yys) yys = "illegal-symbol";
!                 printf("%sdebug: state %d, reading %d (%s)\n",
!                         YYPREFIX, YYFINAL, yychar, yys);
!             }
! #endif
!         }
!         if (yychar == 0) goto yyaccept;
!         goto yyloop;
!     }
!     if ((yyn = yygindex[yym]) && (yyn += yystate) >= 0 &&
!             yyn <= YYTABLESIZE && yycheck[yyn] == yystate)
!         yystate = yytable[yyn];
!     else
!         yystate = yydgoto[yym];
! #if YYDEBUG
!     if (yydebug)
!         printf("%sdebug: after reduction, shifting from state %d \
! to state %d\n", YYPREFIX, *yyssp, yystate);
! #endif
!     if (yyssp >= yysslim && yygrowstack())
!     {
!         goto yyoverflow;
!     }
!     *++yyssp = yystate;
!     *++yyvsp = yyval;
!     goto yyloop;
! yyoverflow:
!     yyerror("yacc stack overflow");
! yyabort:
!     return (1);
! yyaccept:
!     return (0);
  }
--- 4555,5538 ----
    /* Aliases are expanded iff EXPAND_ALIASES is non-zero, and quoting
       inhibits alias expansion. */
!   if (expand_aliases && quoted == 0)
      {
!       result = alias_expand_token (token);
!       if (result == RE_READ_TOKEN)
! 	return (RE_READ_TOKEN);
!       else if (result == NO_EXPANSION)
! 	parser_state &= ~PST_ALEXPNEXT;
      }
  
!   /* If not in Posix.2 mode, check for reserved words after alias
!      expansion. */
!   if (posixly_correct == 0)
! #endif
!     CHECK_FOR_RESERVED_WORD (token);
! 
!   the_word = (WORD_DESC *)xmalloc (sizeof (WORD_DESC));
!   the_word->word = (char *)xmalloc (1 + token_index);
!   the_word->flags = 0;
!   strcpy (the_word->word, token);
!   if (dollar_present)
!     the_word->flags |= W_HASDOLLAR;
!   if (quoted)
!     the_word->flags |= W_QUOTED;
!   /* A word is an assignment if it appears at the beginning of a
!      simple command, or after another assignment word.  This is
!      context-dependent, so it cannot be handled in the grammar. */
!   if (assignment (token))
      {
!       the_word->flags |= W_ASSIGNMENT;
!       /* Don't perform word splitting on assignment statements. */
!       if (assignment_acceptable (last_read_token))
! 	the_word->flags |= W_NOSPLIT;
      }
  
!   yylval.word = the_word;
! 
!   result = ((the_word->flags & (W_ASSIGNMENT|W_NOSPLIT)) == (W_ASSIGNMENT|W_NOSPLIT))
! 		? ASSIGNMENT_WORD : WORD;
! 
!   if (last_read_token == FUNCTION)
      {
!       parser_state |= PST_ALLOWOPNBRC;
!       function_dstart = line_number;
      }
  
!   return (result);
  }
  
! /* $'...' ANSI-C expand the portion of STRING between START and END and
!    return the result.  The result cannot be longer than the input string. */
! static char *
! ansiexpand (string, start, end, lenp)
!      char *string;
!      int start, end, *lenp;
  {
!   char *temp, *t;
!   int len, tlen;
  
!   temp = (char *)xmalloc (end - start + 1);
!   for (tlen = 0, len = start; len < end; )
!     temp[tlen++] = string[len++];
!   temp[tlen] = '\0';
  
!   if (*temp)
      {
!       t = ansicstr (temp, tlen, 0, (int *)NULL, lenp);
!       free (temp);
!       return (t);
      }
    else
      {
!       if (lenp)
! 	*lenp = 0;
!       return (temp);
      }
  }
  
! /* Change a bash string into a string suitable for inclusion in a `po' file.
!    This backslash-escapes `"' and `\' and changes newlines into \\\n"\n". */
! static char *
! mk_msgstr (string, foundnlp)
       char *string;
+      int *foundnlp;
  {
!   register int c, len;
!   char *result, *r, *s;
  
!   for (len = 0, s = string; s && *s; s++)
!     {
!       len++;
!       if (*s == '"' || *s == '\\')
! 	len++;
!       else if (*s == '\n')
! 	len += 5;
!     }
!   
!   r = result = (char *)xmalloc (len + 3);
!   *r++ = '"';
  
!   for (s = string; s && (c = *s); s++)
      {
!       if (c == '\n')	/* <NL> -> \n"<NL>" */
  	{
! 	  *r++ = '\\';
! 	  *r++ = 'n';
! 	  *r++ = '"';
! 	  *r++ = '\n';
! 	  *r++ = '"';
! 	  if (foundnlp)
! 	    *foundnlp = 1;
! 	  continue;
! 	}
!       if (c == '"' || c == '\\')
! 	*r++ = '\\';
!       *r++ = c;
!     }
  
!   *r++ = '"';
!   *r++ = '\0';
  
!   return result;
! }
  
! /* $"..." -- Translate the portion of STRING between START and END
!    according to current locale using gettext (if available) and return
!    the result.  The caller will take care of leaving the quotes intact.
!    The string will be left without the leading `$' by the caller.
!    If translation is performed, the translated string will be double-quoted
!    by the caller.  The length of the translated string is returned in LENP,
!    if non-null. */
! static char *
! localeexpand (string, start, end, lineno, lenp)
!      char *string;
!      int start, end, lineno, *lenp;
! {
!   int len, tlen, foundnl;
!   char *temp, *t, *t2;
  
!   temp = (char *)xmalloc (end - start + 1);
!   for (tlen = 0, len = start; len < end; )
!     temp[tlen++] = string[len++];
!   temp[tlen] = '\0';
  
!   /* If we're just dumping translatable strings, don't do anything with the
!      string itself, but if we're dumping in `po' file format, convert it into a form more palatable to gettext(3)
!      and friends by quoting `"' and `\' with backslashes and converting <NL>
!      into `\n"<NL>"'.  If we find a newline in TEMP, we first output a
!      `msgid ""' line and then the translated string; otherwise we output the
!      `msgid' and translated string all on one line. */
!   if (dump_translatable_strings)
!     {
!       if (dump_po_strings)
! 	{
! 	  foundnl = 0;
! 	  t = mk_msgstr (temp, &foundnl);
! 	  t2 = foundnl ? "\"\"\n" : "";
  
! 	  printf ("#: %s:%d\nmsgid %s%s\nmsgstr \"\"\n",
! 		  (bash_input.name ? bash_input.name : "stdin"), lineno, t2, t);
! 	  free (t);
! 	}
!       else
! 	printf ("\"%s\"\n", temp);
  
!       if (lenp)
! 	*lenp = tlen;
!       return (temp);
!     }
!   else if (*temp)
!     {
!       t = localetrans (temp, tlen, &len);
!       free (temp);
!       if (lenp)
! 	*lenp = len;
!       return (t);
!     }
!   else
!     {
!       if (lenp)
! 	*lenp = 0;
!       return (temp);
!     }
! }
  
! /* Return 1 if TOKSYM is a token that after being read would allow
!    a reserved word to be seen, else 0. */
! static int
! reserved_word_acceptable (toksym)
!      int toksym;
! {
!   if (toksym == '\n' || toksym == ';' || toksym == '(' || toksym == ')' ||
!       toksym == '|' || toksym == '&' || toksym == '{' ||
!       toksym == '}' ||			/* XXX */
!       toksym == AND_AND ||
!       toksym == BANG ||
!       toksym == TIME || toksym == TIMEOPT ||
!       toksym == DO ||
!       toksym == ELIF ||
!       toksym == ELSE ||
!       toksym == FI ||
!       toksym == IF ||
!       toksym == OR_OR ||
!       toksym == SEMI_SEMI ||
!       toksym == THEN ||
!       toksym == UNTIL ||
!       toksym == WHILE ||
!       toksym == DONE ||		/* XXX these two are experimental */
!       toksym == ESAC ||
!       toksym == 0)
!     return (1);
!   else
!     return (0);
! }
  
! /* Return the index of TOKEN in the alist of reserved words, or -1 if
!    TOKEN is not a shell reserved word. */
! int
! find_reserved_word (tokstr)
!      char *tokstr;
! {
!   int i;
!   for (i = 0; word_token_alist[i].word; i++)
!     if (STREQ (tokstr, word_token_alist[i].word))
!       return i;
!   return -1;
! }
  
! #if 0
! #if defined (READLINE)
! /* Called after each time readline is called.  This insures that whatever
!    the new prompt string is gets propagated to readline's local prompt
!    variable. */
! static void
! reset_readline_prompt ()
! {
!   char *temp_prompt;
  
!   if (prompt_string_pointer)
!     {
!       temp_prompt = (*prompt_string_pointer)
! 			? decode_prompt_string (*prompt_string_pointer)
! 			: (char *)NULL;
  
!       if (temp_prompt == 0)
! 	{
! 	  temp_prompt = (char *)xmalloc (1);
! 	  temp_prompt[0] = '\0';
! 	}
  
!       FREE (current_readline_prompt);
!       current_readline_prompt = temp_prompt;
!     }
! }
! #endif /* READLINE */
! #endif /* 0 */
  
! #if defined (HISTORY)
! /* A list of tokens which can be followed by newlines, but not by
!    semi-colons.  When concatenating multiple lines of history, the
!    newline separator for such tokens is replaced with a space. */
! static int no_semi_successors[] = {
!   '\n', '{', '(', ')', ';', '&', '|',
!   CASE, DO, ELSE, IF, SEMI_SEMI, THEN, UNTIL, WHILE, AND_AND, OR_OR, IN,
!   0
! };
  
! /* If we are not within a delimited expression, try to be smart
!    about which separators can be semi-colons and which must be
!    newlines.  Returns the string that should be added into the
!    history entry. */
! char *
! history_delimiting_chars ()
! {
!   register int i;
  
!   if (dstack.delimiter_depth != 0)
!     return ("\n");
!     
!   /* First, handle some special cases. */
!   /*(*/
!   /* If we just read `()', assume it's a function definition, and don't
!      add a semicolon.  If the token before the `)' was not `(', and we're
!      not in the midst of parsing a case statement, assume it's a
!      parenthesized command and add the semicolon. */
!   /*)(*/
!   if (token_before_that == ')')
!     {
!       if (two_tokens_ago == '(')	/*)*/	/* function def */
! 	return " ";
!       /* This does not work for subshells inside case statement
! 	 command lists.  It's a suboptimal solution. */
!       else if (parser_state & PST_CASESTMT)	/* case statement pattern */
! 	return " ";
!       else	
! 	return "; ";				/* (...) subshell */
!     }
!   else if (token_before_that == WORD && two_tokens_ago == FUNCTION)
!     return " ";		/* function def using `function name' without `()' */
  
!   else if (token_before_that == WORD && two_tokens_ago == FOR)
!     {
!       /* Tricky.  `for i\nin ...' should not have a semicolon, but
! 	 `for i\ndo ...' should.  We do what we can. */
!       for (i = shell_input_line_index; whitespace(shell_input_line[i]); i++)
! 	;
!       if (shell_input_line[i] && shell_input_line[i] == 'i' && shell_input_line[i+1] == 'n')
! 	return " ";
!       return ";";
!     }
  
!   for (i = 0; no_semi_successors[i]; i++)
!     {
!       if (token_before_that == no_semi_successors[i])
! 	return (" ");
!     }
  
!   return ("; ");
! }
! #endif /* HISTORY */
  
! /* Issue a prompt, or prepare to issue a prompt when the next character
!    is read. */
! static void
! prompt_again ()
! {
!   char *temp_prompt;
  
!   if (!interactive)	/* XXX */
!     return;
  
!   ps1_prompt = get_string_value ("PS1");
!   ps2_prompt = get_string_value ("PS2");
  
!   if (!prompt_string_pointer)
!     prompt_string_pointer = &ps1_prompt;
  
!   temp_prompt = *prompt_string_pointer
! 			? decode_prompt_string (*prompt_string_pointer)
! 			: (char *)NULL;
  
!   if (temp_prompt == 0)
!     {
!       temp_prompt = (char *)xmalloc (1);
!       temp_prompt[0] = '\0';
      }
  
!   current_prompt_string = *prompt_string_pointer;
!   prompt_string_pointer = &ps2_prompt;
  
! #if defined (READLINE)
!   if (!no_line_editing)
      {
!       FREE (current_readline_prompt);
!       current_readline_prompt = temp_prompt;
      }
    else
+ #endif	/* READLINE */
      {
!       FREE (current_decoded_prompt);
!       current_decoded_prompt = temp_prompt;
      }
  }
  
  int
! get_current_prompt_level ()
  {
!   return ((current_prompt_string && current_prompt_string == ps2_prompt) ? 2 : 1);
  }
  
! void
! set_current_prompt_level (x)
!      int x;
! {
!   prompt_string_pointer = (x == 2) ? &ps2_prompt : &ps1_prompt;
!   current_prompt_string = *prompt_string_pointer;
! }
!       
  static void
! print_prompt ()
  {
!   fprintf (stderr, "%s", current_decoded_prompt);
!   fflush (stderr);
! }
  
! /* Return a string which will be printed as a prompt.  The string
!    may contain special characters which are decoded as follows:
  
! 	\a	bell (ascii 07)
! 	\e	escape (ascii 033)
! 	\d	the date in Day Mon Date format
! 	\h	the hostname up to the first `.'
! 	\H	the hostname
! 	\j	the number of active jobs
! 	\l	the basename of the shell's tty device name
! 	\n	CRLF
! 	\s	the name of the shell
! 	\t	the time in 24-hour hh:mm:ss format
! 	\T	the time in 12-hour hh:mm:ss format
! 	\@	the time in 12-hour am/pm format
! 	\v	the version of bash (e.g., 2.00)
! 	\V	the release of bash, version + patchlevel (e.g., 2.00.0)
! 	\w	the current working directory
! 	\W	the last element of $PWD
! 	\u	your username
! 	\#	the command number of this command
! 	\!	the history number of this command
! 	\$	a $ or a # if you are root
! 	\nnn	character code nnn in octal
! 	\\	a backslash
! 	\[	begin a sequence of non-printing chars
! 	\]	end a sequence of non-printing chars
! */
! #define PROMPT_GROWTH 48
! char *
! decode_prompt_string (string)
!      char *string;
! {
!   WORD_LIST *list;
!   char *result, *t;
!   struct dstack save_dstack;
!   int last_exit_value;
! #if defined (PROMPT_STRING_DECODE)
!   int result_size, result_index;
!   int c, n;
!   char *temp, octal_string[4];
!   time_t the_time;
  
!   result = (char *)xmalloc (result_size = PROMPT_GROWTH);
!   result[result_index = 0] = 0;
!   temp = (char *)NULL;
  
!   while (c = *string++)
!     {
!       if (posixly_correct && c == '!')
! 	{
! 	  if (*string == '!')
! 	    {
! 	      temp = savestring ("!");
! 	      goto add_string;
! 	    }
! 	  else
! 	    {
! #if !defined (HISTORY)
! 		temp = savestring ("1");
! #else /* HISTORY */
! 		temp = itos (history_number ());
! #endif /* HISTORY */
! 		string--;	/* add_string increments string again. */
! 		goto add_string;
! 	    }
! 	}
!       if (c == '\\')
  	{
! 	  c = *string;
! 
! 	  switch (c)
  	    {
! 	    case '0':
! 	    case '1':
! 	    case '2':
! 	    case '3':
! 	    case '4':
! 	    case '5':
! 	    case '6':
! 	    case '7':
! 	      strncpy (octal_string, string, 3);
! 	      octal_string[3] = '\0';
  
! 	      n = read_octal (octal_string);
! 	      temp = (char *)xmalloc (3);
  
! 	      if (n == CTLESC || n == CTLNUL)
! 		{
! 		  temp[0] = CTLESC;
! 		  temp[1] = n;
! 		  temp[2] = '\0';
! 		}
! 	      else if (n == -1)
! 		{
! 		  temp[0] = '\\';
! 		  temp[1] = '\0';
! 		}
! 	      else
! 		{
! 		  temp[0] = n;
! 		  temp[1] = '\0';
! 		}
  
! 	      for (c = 0; n != -1 && c < 3 && ISOCTAL (*string); c++)
! 		string++;
  
! 	      c = 0;
! 	      goto add_string;
  
! 	    case 't':
! 	    case 'd':
! 	    case 'T':
! 	    case '@':
! 	    case 'A':
! 	      /* Make the current time/date into a string. */
! 	      the_time = time (0);
! 	      temp = ctime (&the_time);
  
! 	      temp = (c != 'd') ? savestring (temp + 11) : savestring (temp);
! 	      temp[(c != 'd') ? 8 : 10] = '\0';
! 	      temp[(c != 'A') ? 10 : 5] = '\0';
  
! 	      /* quick and dirty conversion to 12-hour time */
! 	      if (c == 'T' || c == '@')
! 		{
! 		  if (c == '@')
! 		    {
! 		      temp[5] = 'a';	/* am/pm format */
! 		      temp[6] = 'm';
! 		      temp[7] = '\0';
! 		    }
! 		  c = temp[2];
! 		  temp[2] = '\0';
! 		  n = atoi (temp);
! 		  temp[2] = c;
! 		  n -= 12;
! 		  if (n > 0)
! 		    {
! 		      temp[0] = (n / 10) + '0';
! 		      temp[1] = (n % 10) + '0';
! 		    }
! 		  if (n >= 0 && temp[5] == 'a')
! 		    temp[5] = 'p';
! 		}
! 	      goto add_string;
  
! 	    case 'r':
! 	      temp = (char *)xmalloc (2);
! 	      temp[0] = '\r';
! 	      temp[1] = '\0';
! 	      goto add_string;
  
! 	    case 'n':
! 	      temp = (char *)xmalloc (3);
! 	      temp[0] = no_line_editing ? '\n' : '\r';
! 	      temp[1] = no_line_editing ? '\0' : '\n';
! 	      temp[2] = '\0';
! 	      goto add_string;
  
! 	    case 's':
! 	      temp = base_pathname (shell_name);
! 	      temp = savestring (temp);
! 	      goto add_string;
  
! 	    case 'v':
! 	    case 'V':
! 	      temp = (char *)xmalloc (8);
! 	      if (c == 'v')
! 		strcpy (temp, dist_version);
! 	      else
! 		sprintf (temp, "%s.%d", dist_version, patch_level);
! 	      goto add_string;
  
! 	    case 'w':
! 	    case 'W':
! 	      {
! 		/* Use the value of PWD because it is much more efficient. */
! 		char t_string[PATH_MAX];
! 		int tlen;
  
! 		temp = get_string_value ("PWD");
  
! 		if (temp == 0)
! 		  {
! 		    if (getcwd (t_string, sizeof(t_string)) == 0)
! 		      {
! 			t_string[0] = '.';
! 			tlen = 1;
! 		      }
! 		    else
! 		      tlen = strlen (t_string);
! 		  }
! 		else
! 		  {
! 		    tlen = sizeof (t_string) - 1;
! 		    strncpy (t_string, temp, tlen);
! 		  }
! 		t_string[tlen] = '\0';
  
! #define ROOT_PATH(x)	((x)[0] == '/' && (x)[1] == 0)
! #define DOUBLE_SLASH_ROOT(x)	((x)[0] == '/' && (x)[1] == '/' && (x)[2] == 0)
! 		if (c == 'W')
! 		  {
! 		    if (ROOT_PATH (t_string) == 0 && DOUBLE_SLASH_ROOT (t_string) == 0)
! 		      {
! 			t = strrchr (t_string, '/');
! 			if (t)
! 			  strcpy (t_string, t + 1);
! 		      }
! 		  }
! #undef ROOT_PATH
! #undef DOUBLE_SLASH_ROOT
! 		else
! 		  /* polite_directory_format is guaranteed to return a string
! 		     no longer than PATH_MAX - 1 characters. */
! 		  strcpy (t_string, polite_directory_format (t_string));
  
! 		/* If we're going to be expanding the prompt string later,
! 		   quote the directory name. */
! 		if (promptvars || posixly_correct)
! 		  /* Make sure that expand_prompt_string is called with a
! 		     second argument of Q_DOUBLE_QUOTE if we use this
! 		     function here. */
! 		  temp = sh_backslash_quote_for_double_quotes (t_string);
! 		else
! 		  temp = savestring (t_string);
! 
! 		goto add_string;
! 	      }
! 
! 	    case 'u':
! 	      if (current_user.user_name == 0)
! 		get_current_user_info ();
! 	      temp = savestring (current_user.user_name);
! 	      goto add_string;
  
! 	    case 'h':
! 	    case 'H':
! 	      temp = savestring (current_host_name);
! 	      if (c == 'h' && (t = (char *)strchr (temp, '.')))
! 		*t = '\0';
! 	      goto add_string;
  
! 	    case '#':
! 	      temp = itos (current_command_number);
! 	      goto add_string;
  
! 	    case '!':
! #if !defined (HISTORY)
! 	      temp = savestring ("1");
! #else /* HISTORY */
! 	      temp = itos (history_number ());
  #endif /* HISTORY */
+ 	      goto add_string;
  
! 	    case '$':
! 	      t = temp = (char *)xmalloc (3);
! 	      if ((promptvars || posixly_correct) && (current_user.euid != 0))
! 		*t++ = '\\';
! 	      *t++ = current_user.euid == 0 ? '#' : '$';
! 	      *t = '\0';
! 	      goto add_string;
  
! 	    case 'j':
! 	      temp = itos (count_all_jobs ());
! 	      goto add_string;
  
! 	    case 'l':
! #if defined (HAVE_TTYNAME)
! 	      temp = (char *)ttyname (fileno (stdin));
! 	      t = temp ? base_pathname (temp) : "tty";
! 	      temp = savestring (t);
! #else
! 	      temp = savestring ("tty");
! #endif /* !HAVE_TTYNAME */
! 	      goto add_string;
  
! #if defined (READLINE)
! 	    case '[':
! 	    case ']':
! 	      temp = (char *)xmalloc (3);
! 	      temp[0] = '\001';
! 	      temp[1] = (c == '[') ? RL_PROMPT_START_IGNORE : RL_PROMPT_END_IGNORE;
! 	      temp[2] = '\0';
! 	      goto add_string;
! #endif /* READLINE */
  
! 	    case '\\':
! 	      temp = (char *)xmalloc (2);
! 	      temp[0] = c;
! 	      temp[1] = '\0';
! 	      goto add_string;
  
! 	    case 'a':
! 	    case 'e':
! 	      temp = (char *)xmalloc (2);
! 	      temp[0] = (c == 'a') ? '\07' : '\033';
! 	      temp[1] = '\0';
! 	      goto add_string;
! 
! 	    default:
! 	      temp = (char *)xmalloc (3);
! 	      temp[0] = '\\';
! 	      temp[1] = c;
! 	      temp[2] = '\0';
! 
! 	    add_string:
! 	      if (c)
! 		string++;
! 	      result =
! 		sub_append_string (temp, result, &result_index, &result_size);
! 	      temp = (char *)NULL; /* Freed in sub_append_string (). */
! 	      result[result_index] = '\0';
! 	      break;
! 	    }
! 	}
!       else
! 	{
! 	  RESIZE_MALLOCED_BUFFER (result, result_index, 3, result_size, PROMPT_GROWTH);
! 	  result[result_index++] = c;
! 	  result[result_index] = '\0';
! 	}
!     }
! #else /* !PROMPT_STRING_DECODE */
!   result = savestring (string);
! #endif /* !PROMPT_STRING_DECODE */
! 
!   /* Save the delimiter stack and point `dstack' to temp space so any
!      command substitutions in the prompt string won't result in screwing
!      up the parser's quoting state. */
!   save_dstack = dstack;
!   dstack = temp_dstack;
!   dstack.delimiter_depth = 0;
! 
!   /* Perform variable and parameter expansion and command substitution on
!      the prompt string. */
!   if (promptvars || posixly_correct)
!     {
!       last_exit_value = last_command_exit_value;
!       list = expand_prompt_string (result, Q_DOUBLE_QUOTES);
!       free (result);
!       result = string_list (list);
!       dispose_words (list);
!       last_command_exit_value = last_exit_value;
!     }
!   else
!     {
!       t = dequote_string (result);
!       free (result);
!       result = t;
!     }
! 
!   dstack = save_dstack;
! 
!   return (result);
! }
! 
! /* Report a syntax error, and restart the parser.  Call here for fatal
!    errors. */
! int
! yyerror (msg)
!      const char *msg;
  {
!   report_syntax_error ((char *)NULL);
!   reset_parser ();
!   return (0);
! }
! 
! /* Report a syntax error with line numbers, etc.
!    Call here for recoverable errors.  If you have a message to print,
!    then place it in MESSAGE, otherwise pass NULL and this will figure
!    out an appropriate message for you. */
! static void
! report_syntax_error (message)
!      char *message;
  {
!   char *msg, *t;
!   int token_end, i;
!   char msg2[2];
! 
!   if (message)
!     {
!       parser_error (line_number, "%s", message);
!       if (interactive && EOF_Reached)
! 	EOF_Reached = 0;
!       last_command_exit_value = EX_USAGE;
!       return;
!     }
! 
!   /* If the line of input we're reading is not null, try to find the
!      objectionable token. */
!   if (shell_input_line && *shell_input_line)
!     {
!       t = shell_input_line;
!       i = shell_input_line_index;
!       token_end = 0;
! 
!       if (i && t[i] == '\0')
! 	i--;
! 
!       while (i && (whitespace (t[i]) || t[i] == '\n'))
! 	i--;
! 
!       if (i)
! 	token_end = i + 1;
! 
!       while (i && (member (t[i], " \n\t;|&") == 0))
! 	i--;
! 
!       while (i != token_end && (whitespace (t[i]) || t[i] == '\n'))
! 	i++;
! 
!       /* Print the offending token. */
!       if (token_end || (i == 0 && token_end == 0))
! 	{
! 	  if (token_end)
! 	    msg = substring (t, i, token_end);
! 	  else	/* one-character token */
! 	    {
! 	      msg2[0] = t[i];
! 	      msg2[1] = '\0';
! 	      msg = msg2;
! 	    }
! 
! 	  parser_error (line_number, "syntax error near unexpected token `%s'", msg);
! 
! 	  if (msg != msg2)
! 	    free (msg);
! 	}
! 
!       /* If not interactive, print the line containing the error. */
!       if (interactive == 0)
! 	{
! 	  msg = savestring (shell_input_line);
! 	  token_end = strlen (msg);
! 	  while (token_end && msg[token_end - 1] == '\n')
! 	    msg[--token_end] = '\0';
! 
! 	  parser_error (line_number, "`%s'", msg);
! 	  free (msg);
! 	}
!     }
!   else
!     {
!       msg = EOF_Reached ? "syntax error: unexpected end of file" : "syntax error";
!       parser_error (line_number, "%s", msg);
!       /* When the shell is interactive, this file uses EOF_Reached
! 	 only for error reporting.  Other mechanisms are used to
! 	 decide whether or not to exit. */
!       if (interactive && EOF_Reached)
! 	EOF_Reached = 0;
!     }
!   last_command_exit_value = EX_USAGE;
! }
! 
! /* ??? Needed function. ??? We have to be able to discard the constructs
!    created during parsing.  In the case of error, we want to return
!    allocated objects to the memory pool.  In the case of no error, we want
!    to throw away the information about where the allocated objects live.
!    (dispose_command () will actually free the command. */
! static void
! discard_parser_constructs (error_p)
!      int error_p;
  {
! }
! 
! /* Do that silly `type "bye" to exit' stuff.  You know, "ignoreeof". */
! 
! /* A flag denoting whether or not ignoreeof is set. */
! int ignoreeof = 0;
! 
! /* The number of times that we have encountered an EOF character without
!    another character intervening.  When this gets above the limit, the
!    shell terminates. */
! int eof_encountered = 0;
! 
! /* The limit for eof_encountered. */
! int eof_encountered_limit = 10;
! 
! /* If we have EOF as the only input unit, this user wants to leave
!    the shell.  If the shell is not interactive, then just leave.
!    Otherwise, if ignoreeof is set, and we haven't done this the
!    required number of times in a row, print a message. */
! static void
! handle_eof_input_unit ()
  {
!   if (interactive)
!     {
!       /* shell.c may use this to decide whether or not to write out the
! 	 history, among other things.  We use it only for error reporting
! 	 in this file. */
!       if (EOF_Reached)
! 	EOF_Reached = 0;
! 
!       /* If the user wants to "ignore" eof, then let her do so, kind of. */
!       if (ignoreeof)
! 	{
! 	  if (eof_encountered < eof_encountered_limit)
! 	    {
! 	      fprintf (stderr, "Use \"%s\" to leave the shell.\n",
! 		       login_shell ? "logout" : "exit");
! 	      eof_encountered++;
! 	      /* Reset the prompt string to be $PS1. */
! 	      prompt_string_pointer = (char **)NULL;
! 	      prompt_again ();
! 	      last_read_token = current_token = '\n';
! 	      return;
! 	    }
! 	}
! 
!       /* In this case EOF should exit the shell.  Do it now. */
!       reset_parser ();
!       exit_builtin ((WORD_LIST *)NULL);
!     }
!   else
!     {
!       /* We don't write history files, etc., for non-interactive shells. */
!       EOF_Reached = 1;
!     }
! }
! 
! static WORD_LIST parse_string_error;
! 
! /* Take a string and run it through the shell parser, returning the
!    resultant word list.  Used by compound array assignment. */
! WORD_LIST *
! parse_string_to_word_list (s, whom)
!      char *s;
!      const char *whom;
  {
!   WORD_LIST *wl;
!   int tok, orig_line_number, orig_input_terminator;
!   int orig_line_count;
! #if defined (HISTORY)
!   int old_remember_on_history, old_history_expansion_inhibited;
! #endif
! 
! #if defined (HISTORY)
!   old_remember_on_history = remember_on_history;
! #  if defined (BANG_HISTORY)
!   old_history_expansion_inhibited = history_expansion_inhibited;
! #  endif
!   bash_history_disable ();
! #endif
! 
!   orig_line_number = line_number;
!   orig_line_count = current_command_line_count;
!   orig_input_terminator = shell_input_line_terminator;
! 
!   push_stream (1);
!   last_read_token = '\n';
!   current_command_line_count = 0;
! 
!   with_input_from_string (s, whom);
!   wl = (WORD_LIST *)NULL;
!   while ((tok = read_token (READ)) != yacc_EOF)
!     {
!       if (tok == '\n' && *bash_input.location.string == '\0')
! 	break;
!       if (tok == '\n')		/* Allow newlines in compound assignments */
! 	continue;
!       if (tok != WORD && tok != ASSIGNMENT_WORD)
! 	{
! 	  line_number = orig_line_number + line_number - 1;
! 	  yyerror ((char *)NULL);	/* does the right thing */
! 	  if (wl)
! 	    dispose_words (wl);
! 	  wl = &parse_string_error;
! 	  break;
! 	}
!       wl = make_word_list (yylval.word, wl);
!     }
!   
!   last_read_token = '\n';
!   pop_stream ();
! 
! #if defined (HISTORY)
!   remember_on_history = old_remember_on_history;
! #  if defined (BANG_HISTORY)
!   history_expansion_inhibited = old_history_expansion_inhibited;
! #  endif /* BANG_HISTORY */
! #endif /* HISTORY */
! 
!   current_command_line_count = orig_line_count;
!   shell_input_line_terminator = orig_input_terminator;
! 
!   if (wl == &parse_string_error)
!     {
!       last_command_exit_value = EXECUTION_FAILURE;
!       if (interactive_shell == 0 && posixly_correct)
! 	jump_to_top_level (FORCE_EOF);
!       else
! 	jump_to_top_level (DISCARD);
!     }
! 
!   return (REVERSE_LIST (wl, WORD_LIST *));
  }
diff -Nrc2 bash-2.05/y.tab.h bash-2.05a/y.tab.h
*** bash-2.05/y.tab.h	Tue Mar 27 10:06:14 2001
--- bash-2.05a/y.tab.h	Tue Oct 30 11:48:15 2001
***************
*** 1,45 ****
- #ifndef YYERRCODE
- #define YYERRCODE 256
- #endif
- 
- #define IF 257
- #define THEN 258
- #define ELSE 259
- #define ELIF 260
- #define FI 261
- #define CASE 262
- #define ESAC 263
- #define FOR 264
- #define SELECT 265
- #define WHILE 266
- #define UNTIL 267
- #define DO 268
- #define DONE 269
- #define FUNCTION 270
- #define COND_START 271
- #define COND_END 272
- #define COND_ERROR 273
- #define IN 274
- #define BANG 275
- #define TIME 276
- #define TIMEOPT 277
- #define WORD 278
- #define ASSIGNMENT_WORD 279
- #define NUMBER 280
- #define ARITH_CMD 281
- #define ARITH_FOR_EXPRS 282
- #define COND_CMD 283
- #define AND_AND 284
- #define OR_OR 285
- #define GREATER_GREATER 286
- #define LESS_LESS 287
- #define LESS_AND 288
- #define GREATER_AND 289
- #define SEMI_SEMI 290
- #define LESS_LESS_MINUS 291
- #define AND_GREATER 292
- #define LESS_GREATER 293
- #define GREATER_BAR 294
- #define yacc_EOF 295
  typedef union {
    WORD_DESC *word;		/* the word that we read. */
--- 1,2 ----
***************
*** 51,53 ****
--- 8,51 ----
    PATTERN_LIST *pattern;
  } YYSTYPE;
+ #define	IF	257
+ #define	THEN	258
+ #define	ELSE	259
+ #define	ELIF	260
+ #define	FI	261
+ #define	CASE	262
+ #define	ESAC	263
+ #define	FOR	264
+ #define	SELECT	265
+ #define	WHILE	266
+ #define	UNTIL	267
+ #define	DO	268
+ #define	DONE	269
+ #define	FUNCTION	270
+ #define	COND_START	271
+ #define	COND_END	272
+ #define	COND_ERROR	273
+ #define	IN	274
+ #define	BANG	275
+ #define	TIME	276
+ #define	TIMEOPT	277
+ #define	WORD	278
+ #define	ASSIGNMENT_WORD	279
+ #define	NUMBER	280
+ #define	ARITH_CMD	281
+ #define	ARITH_FOR_EXPRS	282
+ #define	COND_CMD	283
+ #define	AND_AND	284
+ #define	OR_OR	285
+ #define	GREATER_GREATER	286
+ #define	LESS_LESS	287
+ #define	LESS_AND	288
+ #define	GREATER_AND	289
+ #define	SEMI_SEMI	290
+ #define	LESS_LESS_MINUS	291
+ #define	AND_GREATER	292
+ #define	LESS_GREATER	293
+ #define	GREATER_BAR	294
+ #define	yacc_EOF	295
+ 
+ 
  extern YYSTYPE yylval;
