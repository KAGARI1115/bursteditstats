diff -Nrc2 bash-2.04/CHANGES bash-2.05/CHANGES
*** bash-2.04/CHANGES	Tue Mar 14 11:40:08 2000
--- bash-2.05/CHANGES	Tue Apr  3 10:33:50 2001
***************
*** 1,2 ****
--- 1,558 ----
+ This document details the changes between this version, bash-2.05-release,
+ and the previous version, bash-2.05-beta2.
+ 
+ 1.  Changes to Bash
+ 
+ a.  Make sure we note that the first line of a multi-line command was not
+     saved in the history if the tests for HISTCONTROL succeed, but the
+     HISTIGNORE check fails.
+ 
+ b.  Fixed a bug in the pattern matching code that caused `[' to be treated
+     as a special character inside a `[...]' bracket expression.
+ 
+ c.  Fixed a bug in the pattern matching code that caused `]' to terminate
+     a bracket expression even if it was the first character after the `['
+     (or a leading `!' or `^').
+ 
+ d.  Made a small change to report a more user-friendly error message if
+     execve(2) fails because of an error with the interpreter in a script
+     with a leading `#! interpreter'.
+ 
+ e.  If the OS does not support an exec(2) magic number of `#!', make sure we
+     have a non-null interpreter name before attempting to execute it.
+ 
+ f.  Fixed a bug that caused the shell process to end up in a different
+     process group than the controlling terminal if a job-control shell was
+     run with `exec' in the startup files.
+ 
+ g.  When started in POSIX mode, either by `bash --posix', `bash -o posix', or
+     `sh', $SHELLOPTS includes `posix' and POSIXLY_CORRECT is set.
+ 
+ h.  Fixed a problem that caused the `\W' prompt string escape sequence to
+     expand to nothing when $PWD was `//'.
+ 
+ i.  The `bashbug' shell script no longer uses $(...) command substitution.
+ 
+ j.  When `set' is invoked without options in POSIX mode, it no longer prints
+     the names and definitions of shell functions.
+ 
+ 2.  Changes to Readline
+ 
+ a.  rl_set_paren_blink_timeout() is now documented.
+ 
+ b.  Corrected history.3 man page: `$' is not in the default value of
+     history_word_delimiters.
+ 
+ c.  If a hook function assigned to rl_event_hook sets rl_done to a non-zero
+     value, rl_read_key() now immediately returns '\n' (which is assumed to
+     be bound to accept-line).
+ 
+ 3.  New Features in Bash
+ 
+ a.  The `>&word' redirection now works in POSIX mode as it does by default,
+     since POSIX.2 leaves it unspecified.
+ 
+ ------------------------------------------------------------------------------
+ This document details the changes between this version, bash-2.05-beta2,
+ and the previous version, bash-2.05-beta1.
+ 
+ 1.  Changes to Bash
+ 
+ a.  Fixed a bug in the arithmetic evaluation code so that a^=b is supported.
+ 
+ b.  Fixed startup so posixly_correct is retained across subshells begun to
+     execute scripts without a leading `#!'.
+ 
+ c.  Fixed a bug that caused $(< file) to not work in a (...) subshell.
+ 
+ d.  Added config support for Linux running on the IBM S390.
+ 
+ e.  Fixed a bug that caused bash to get its input pointer out of sync when
+     reading commands through a pipe and running a command with standard
+     input redirected from a file.
+ 
+ f.  Made a change so that command completion now makes about half as many
+     stat(2) calls when searching the $PATH.
+ 
+ g.  Fixed a bug that caused variable assignments preceding `return' to not
+     be propagated to the shell environment in POSIX mode.
+ 
+ h.  Fixed a bug with ${parameter[:]?word} -- tilde expansion was not performed
+     on `word'.
+ 
+ i.  In POSIX mode, `break' and `continue' do not complain and return success
+     if called when the shell is not executing a loop.
+ 
+ j.  Fixed `bash -o posix' to work the same as `bash --posix'.
+ 
+ k.  Fixed a bug where variable assignments preceding `eval' or `source/.'
+     would not show up in the environment exported to subshells run by the
+     commands.
+ 
+ l.  In POSIX mode, shells started to execute command substitutions inherit
+     the value of the `-e' option from their parent shell.
+ 
+ m.  In POSIX mode, aliases are expanded even in non-interactive shells.
+ 
+ n.  Changed some of the job control messages to display the text required by
+     POSIX.2 when the shell is in POSIX mode.
+ 
+ o.  Fixed a bug in `test' that caused it to occasionally return incorrect
+     results when non-numeric arguments were supplied to `-t'.
+ 
+ 2.  Changes to Readline
+ 
+ a.  Some changes were made to avoid gcc warnings with -Wall.
+ 
+ b.  rl_get_keymap_by_name now finds keymaps case-insensitively, so
+     `set keymap EMACS' works.
+ 
+ c.  The history file writing and truncation functions now return a useful
+     status on error.
+ 
+ d.  Fixed a bug that could cause applications to dereference a NULL pointer
+     if a NULL second argument was passed to history_expand().
+ 
+ 3.  New Features in Bash
+ 
+ a.  doc/readline.3 has been moved to the readline distribution.
+ 
+ 4.  New Features in Readline
+ 
+ a.  New function, rl_get_screen_size (int *rows, int *columns), returns
+     readline's idea of the screen dimensions.
+ 
+ b.  The timeout in rl_gather_tyi (readline keyboard input polling function)
+     is now settable via a function (rl_set_keyboard_input_timeout()).
+ 
+ c.  Renamed the max_input_history variable to history_max_entries; the old
+     variable is maintained for backwards compatibility.
+ 
+ d.  The list of characters that separate words for the history tokenizer is
+     now settable with a variable:  history_word_delimiters.  The default
+     value is as before.
+ 
+ ------------------------------------------------------------------------------
+ This document details the changes between this version, bash-2.05-beta1,
+ and the previous version, bash-2.05-alpha1.
+ 
+ 1.  Changes to Bash
+ 
+ a.  Changes to allow shared library and object building on the GNU Hurd.
+ 
+ b.  Fixes to the way exported functions are placed into the environment and
+     cached.
+ 
+ c.  The globbing library once again respects locales when processing ranges
+     in bracket expressions while doing pattern matching.
+ 
+ d.  System-specific configuration changes for:  Tru 64, Interix
+ 
+ e.  Bashbug now uses /usr/bin/editor as one of the editing alternatives, and
+     will use mktemp(1) or tempfile(1), if present, for temporary file creation.
+ 
+ f.  Bash no longer performs a binary file check on a script argument that's
+     really a tty (like /dev/fd/0 or /dev/stdin).
+ 
+ g.  Fixed a bug in the execution of shell scripts that caused the effects of
+     $BASH_ENV to be undone in some cases.
+ 
+ h.  Fixed several bugs that made `bash [-i] /dev/stdin' not work correctly.
+ 
+ i.  Several changes to the job control code to avoid some signal state
+     manipulation.
+ 
+ j.  The Bash malloc no longer blocks signals as often, which should make it
+     faster.
+ 
+ k.  Fixed a parsing bug that did not allow backslash to escape a single quote
+     inside a $'...' construct.
+ 
+ l.  Fixed a bug that caused things like ${var:=$'value'} to be parsed
+     incorrectly.  This showed up in newer versions of autoconf.
+ 
+ m.  Fixed a bug in the bash-specific readline initialization that caused
+     key bindings to bash-specific function names appearing in .inputrc to
+     not be honored.
+ 
+ n.  Bash now sets the file descriptor it uses to save the file descriptor
+     opened on a shell script to close on exec.
+ 
+ o.  Fixed a bug in the prompt string decoding that caused it to misbehave
+     when presented an octal sequence of fewer than three characters.
+ 
+ p.  Fixed the `test' builtin to return an error if `[' is supplied a single
+     argument that is not `]'.
+ 
+ q.  Fixed a bug that caused subshells started to run executable shell scripts
+     without a leading `#!' to incorrectly inherit an argument list preceding
+     a shell builtin (like such a script called from a script sourced with `.',
+     where there were variable assignments preceding the `.' command)
+ 
+ r.  Fixed a bug that caused changes to variables supplied in an assignment
+     statement preceding a shell builtin to not be honored (like a script
+     run with `.').
+ 
+ s.  HOSTTYPE, OSTYPE, and MACHTYPE are set only if they do not have values
+     when the shell is started.
+ 
+ t.  Fixed a bug that caused SIGINT to kill shell scripts after the script
+     called `wait'.
+ 
+ u.  The `fc' builtin now tries to create its temporary files in the directory
+     named by $TMPDIR.
+ 
+ v.  Bash no longer calls any Readline functions or uses any Readline variables
+     not declared in readline.h.
+ 
+ w.  Fixed a bug that caused some substitutions involving $@ to not be split
+     correctly, especially expansions of the form ${paramterOPword}.
+ 
+ x.  SSH2_CLIENT is now treated like SSH_CLIENT and not auto-exported if it
+     appears in the initial environment.
+ 
+ y.  Fixed a couple of problems with shell scripts without a leading `#!'
+     being executed out of shell functions that could cause core dumps if
+     such a script attempted to execute `return'.
+ 
+ z.  Fixed a problem with the `-nt' and `-ot' binary operators for the
+     `test/[' builtin and the `[[' conditional command that caused wrong
+     return values if one of the file arguments did not exist.
+ 
+ aa. Fixed a bug that caused non-interactive shells which had previously
+     executed `shopt -s expand_aliases' to fail to expand aliases in a
+     command like `(command) &'.
+  
+ 2.  Changes to Readline
+ 
+ a.  Changes to make most (but not yet all -- there is still crlf()) of the
+     exported readline functions declared in readline.h have an rl_ prefix.
+ 
+ b.  More `const' changes in function arguments, mostly for completion
+     functions.
+ 
+ c.  Fixed a bug in rl_forward that could cause the point to be set to before
+     the beginning of the line in vi mode.
+ 
+ d.  Fixed a bug in the callback read-char interface to make it work when a
+     readline function pushes some input onto the input stream with
+     rl_execute_next (like the incremental search functions).
+ 
+ e.  Fixed a file descriptor leak in the history file manipulation code that
+     was tripped when attempting to truncate a non-regular file (like
+     /dev/null).
+ 
+ f.  Some existing variables are now documented and part of the public
+     interface (declared in readline.h):  rl_explict_arg, rl_numeric_arg,
+     rl_editing_mode, rl_last_func.
+ 
+ g.  Renamed rltty_set_default_bindings to rl_tty_set_default_bindings and
+     crlf to rl_crlf, so there are no public functions declared in readline.h
+     without an `rl_' prefix.  The old functions still exist for backwards
+     compatibility.
+ 
+ 3.  New Features in Bash
+ 
+ a.  A new loadable builtin, realpath, which canonicalizes and expands symlinks
+     in pathname arguments.
+ 
+ b.  When `set' is called without options, it prints function defintions in a
+     way that allows them to be reused as input.  This affects `declare' and
+     `declare -p' as well.
+ 
+ 4.  New Features in Readline
+ 
+ a.  New application-callable function rl_set_prompt(const char *prompt):
+     expands its prompt string argument and sets rl_prompt to the result.
+ 
+ b.  New application-callable function rl_set_screen_size(int rows, int cols):
+     public method for applications to set readline's idea of the screen
+     dimensions.
+ 
+ c.  The history example program (examples/histexamp.c) is now built as one
+     of the examples.
+ 
+ ------------------------------------------------------------------------------
+ This document details the changes between this version, bash-2.05-alpha1,
+ and the previous version, bash-2.04-release.
+ 
+ 1.  Changes to Bash
+ 
+ a.  A fix was made to allow newlines in compond array assignments.
+ 
+ b.  configure now checks for real-time signals with unusable values.
+ 
+ c.  Interactive shells no longer exit if a substitution fails because of an
+     unset variable within a sourced file.
+ 
+ d.  Fixed a problem with incorrect matching of extended glob patterns when
+     doing pattern substitution.
+ 
+ e.  `{' is now quoted by the completion code when it appears in a filename.
+ 
+ f.  Fixed an error in pattern matching that caused the matcher to not
+     correctly skip the rest of a bracket expression after a character
+     matched.
+ 
+ g.  Fixed a bug in the IFS word splitting code to make a non-whitespace IFS
+     character preceded by IFS whitespace part of the current delimiter rather
+     than generating a separate field.
+ 
+ h.  The {!prefix@} expansion now generates separate words, analogous to $@,
+     when double-quoted.
+ 
+ i.  Command substitution now ignores NUL bytes in the command output, and the
+     parser ignores them on input.
+ 
+ j.  A fix was made to the job control code to prevent hanging processes when
+     the shell thinks background processes are running but the kernel returns
+     -1/ECHILD from waitpid().
+ 
+ k.  `pwd' now prints an error message if the write fails when displaying the
+     current directory.
+ 
+ l.  When in POSIX mode, the shell prints trap dispostions without a leading
+     `SIG' in the signal specification.
+ 
+ m.  Fixed a parser bug that caused the current command's line count to be
+     messed up by a compound array assignment.
+ 
+ n.  Fixed a bug in the unwind-protect code that caused bad behavior on machines
+     where ints and pointers are not the same size.
+ 
+ o.  System-specific configure changes for:  MacOS X.
+ 
+ p.  Changes for Cygwin to translate \r\n and \r to \n and to set file
+     descriptors used for reading input to text mode in various places.
+ 
+ q.  Fixed a bug that caused `!' to occasionally not be honored when in
+     a (...) subshell.
+ 
+ r.  Bash no longer assumes that getcwd() will return any useful error message
+     in the buffer passed as an argument if the call fails.
+ 
+ s.  The `source', `.', and `fc' builtins no longer check whether a file is
+     binary before reading commands from it.
+ 
+ t.  Subshells no longer turn off job control when they exit, since that
+     sometimes resulted in the terminal being reset to the wrong process
+     group.
+ 
+ u.  The history code no longer tries to save the second and subsequent lines
+     of a multi-line command if the first line was not saved.
+ 
+ v.  The history saving code now does a better job of saving blank lines in a
+     multi-line command.
+ 
+ w.  Removed a `feature' that made `ulimit' silently translate `unlimited' to
+     the current hard limit, which obscured some kernel error returns.
+ 
+ x.  Fixed the grammar so that `}' is recognized as a reserved word after
+     another reserved word, rather than requiring a `;' or newline.  This
+     means that constructs like
+ 
+ 	{ { echo a b c ; } }
+ 
+     work as expected.
+ 
+ y.  Conditional commands ([[...]]) now perform tilde expansion on their
+     arguments.
+ 
+ z.  Noted in the documentation that `set -a' will cause functions to be
+     exported if they are defined after `set -a' is executed.
+ 
+ aa. When an interactive login shell starts, if $PWD and $HOME refer to the
+     same directory but are not the same string, $PWD is set to $HOME.
+ 
+ bb. Fixed `printf' to handle invalid floating point numbers better.
+ 
+ cc. Temporary files are now created with random filenames, to improve security.
+ 
+ dd. The readline initialization code now binds the custom bash functions and
+     key bindings after the readline defaults are set up.
+ 
+ ee. Fixed the `source' builtin to no longer overwrite a shell function's
+     argument list, even if the sourced file changes the positional parameters.
+ 
+ ff. A bug fix was made in the expansion of `$*' in contexts where it should
+     not be split, like assignment statements.
+ 
+ gg. Fixed a bug in the parameter substring expansion to handle conditional
+     arithmetic expressions ( exp ? val1 : val2 ) without cutting the expression
+     off at the wrong `:'.
+ 
+ hh. The `<>' redirection is no longer subject to the current setting of
+     `noclobber', as POSIX.2 specifies.
+ 
+ ii. Fixed a bug in the conditional command parsing code that caused expressions
+     in parentheses to occasionally be parsed incorrectly.
+ 
+ jj. Fixed a bug in the ((...)) arithmetic command to allow do...done or
+     {...} to follow the )) without an intervening list terminator.
+ 
+ kk. `printf' now treats `\E' the same as `\e' when performing backslash escape
+     expansion for the `%b' format specifier.
+ 
+ ll. When in POSIX mode, the shell no longer searches the current directory for
+     a file to be sourced with `.' or `source' if `.' is not in $PATH.
+ 
+ mm. Interactive comments are no longer turned off when POSIX mode is disabled.
+ 
+ nn. The UID, EUID, HOSTNAME variables are not set if they are in the shell's
+     environment when it starts up.
+ 
+ oo. Fixed a bug in the `command' builtin so the effect of a command like
+     `command exec 4<file' is as if the `command' had been omitted.
+ 
+ pp. ${foo[@]} and ${foo[*]} now work as in ksh93 if `foo' is not an array
+     variable.
+ 
+ qq. ${#foo[X]}, where X is 0, @, or *, now work as in ksh93 if `foo' is not
+     an array variable.
+ 
+ rr. The shell's idea of an absolute pathname now takes into account a
+     possible drive specification on Cygwin and other Windows systems.
+ 
+ ss. Fixed a bug which caused incorrect parsing of some multi-character
+     constructs if they were split across input lines with backslash-newline
+     line continuation.
+ 
+ tt. Fixed a bug that caused restricted shell mode to be set inappropriately
+     when trying to execute a shell script without a leading `#!'.
+ 
+ uu. Shell function definitions no longer require that the body be a group
+     command ( {...} ), as POSIX.2 requires.
+ 
+ vv. The `cd' and `pwd' builtins now process symlinks in pathnames internally
+     and should require many fewer calls to getcwd().
+ 
+ ww. Fixed a bug that caused a pipeline's process group to be set incorrectly
+     if one of the pipeline elements contained a command substitution.
+ 
+ xx. Fixed a bug that caused core dumps when expanding the value of HISTIGNORE.
+ 
+ yy. The output of `set' is now quoted using $'...' so invisible characters are
+     displayed as escape sequences.
+ 
+ zz. Fixed the help text for `unset', since PATH and IFS may both be unset.
+ 
+ aaa. The shell no longer puts directory names into the command hash table.
+ 
+ bbb. Fixed a bug in `read' that caused it to occasionally free memory twice if
+      it was interrupted after reading a large amount of data.
+ 
+ ccc. Assignment statements that attempt to assign values to readonly variables
+      now cause the command to return an error status.
+ 
+ ddd. Fixed a bug that could cause incorrect output if a $(<file) construct was
+      interrupted.
+ 
+ eee. GROUPS and FUNCNAME now return an error status when assignment is
+      attempted, but may be unset (in which case they lose their special
+      properties).  In all respects except unsetting, they are readonly.
+ 
+ fff. The string-to-integer conversion code now ignores trailing whitespace in
+      the string, even if strtol(3) does not.
+ 
+ ggg. The tcsh magic-space function now does a better job of inserting the
+      space close to where the point was before the history expansion, rather
+      than just appending it.
+ 
+ hhh. Fixed a bug which caused a file sourced from an interactive shell to
+      fill up the jobs table if it ran lots of jobs.
+ 
+ iii. Fixed a bug in the parameter pattern substitution code to avoid infinite
+      recursion on zero-length matches.
+ 
+ 2.  Changes to Readline
+ 
+ a.  When setting the terminal attributes on systems using `struct termio',
+     readline waits for output to drain before changing the attributes.
+ 
+ b.  A fix was made to the history word tokenization code to avoid attempts to
+     dereference a null pointer.
+ 
+ c.  Readline now defaults rl_terminal_name to $TERM if the calling application
+     has left it unset, and tries to initialize with the resultant value.
+ 
+ d.  Instead of calling (*rl_getc_function)() directly to get input in certain
+     places, readline now calls rl_read_key() consistently.
+ 
+ e.  Fixed a bug in the completion code that allowed a backslash to quote a
+     single quote inside a single-quoted string.
+ 
+ f.  rl_prompt is no longer assigned directly from the argument to readline(),
+     but uses memory allocated by readline.  This allows constant strings to
+     be passed to readline without problems arising when the prompt processing
+     code wants to modify the string.
+ 
+ g.  Fixed a bug that caused non-interactive history searches to return the
+     wrong line when performing multiple searches backward for the same string.
+ 
+ h.  Many variables, function arguments, and function return values are now
+     declared `const' where appropriate, to improve behavior when linking with
+     C++ code.
+ 
+ i.  The control character detection code now works better on systems where
+     `char' is unsigned by default.
+ 
+ j.  The vi-mode numeric argument is now capped at 999999, just like emacs mode.
+ 
+ k.  The Function, CPFunction, CPPFunction, and VFunction typedefs have been
+     replaced with a set of specific prototyped typedefs, though they are
+     still in the readline header files for backwards compatibility.
+ 
+ m.  Nearly all of the (undocumented) internal global variables in the library
+     now have an _rl_ prefix -- there were a number that did not, like
+     screenheight, screenwidth, alphabetic, etc.
+ 
+ n.  The ding() convenience function has been renamed to rl_ding(), though the
+     old function is still defined for backwards compatibility.
+ 
+ o.  The completion convenience functions filename_completion_function,
+     username_completion_function, and completion_matches now have an rl_
+     prefix, though the old names are still defined for backwards compatibility.
+ 
+ p.  The functions shared by readline and bash (linkage is satisfied from bash
+     when compiling with bash, and internally otherwise) now have an sh_ prefix.
+ 
+ q.  Changed the shared library creation procedure on Linux and BSD/OS 4.x so
+     that the `soname' contains only the major version number rather than the
+     major and minor numbers.
+ 
+ r.  Fixed a redisplay bug that occurred when the prompt spanned more than one
+     physical line and contained invisible characters.
+ 
+ 3.  New Features in Bash
+ 
+ a.  Added a new `--init-file' invocation argument as a synonym for `--rcfile',
+     per the new GNU coding standards.
+ 
+ b.  The /dev/tcp and /dev/udp redirections now accept service names as well as
+     port numbers.
+ 
+ c.  `complete' and `compgen' now take a `-o value' option, which controls some
+     of the aspects of that compspec.  Valid values are:
+ 
+ 	default - perform bash default completion if programmable
+ 		  completion produces no matches
+ 	dirnames - perform directory name completion if programmable
+ 		   completion produces no matches
+ 	filenames - tell readline that the compspec produces filenames,
+ 		    so it can do things like append slashes to
+ 		    directory names and suppress trailing spaces
+ 
+ 4.  New Features in Readline
+ 
+ a.  The blink timeout for paren matching is now settable by applications.
+ 
+ b.  _rl_executing_macro has been renamed to rl_executing_macro, which means
+     it's now part of the public interface.
+ 
+ c.  Readline has a new variable, rl_readline_state, which is a bitmap that
+     encapsulates the current state of the library; intended for use by
+     callbacks and hook functions.
+ 
+ ------------------------------------------------------------------------------
  This document details the changes between this version, bash-2.04-release,
  and the previous version, bash-2.04-beta5.
***************
*** 481,485 ****
      the wrong order was fixed.
  
! v.  A bug that occasionally caused inaapropriate expansion of assignment
      statements in compound array assignments was fixed.
  
--- 1037,1041 ----
      the wrong order was fixed.
  
! v.  A bug that occasionally caused inappropriate expansion of assignment
      statements in compound array assignments was fixed.
  
diff -Nrc2 bash-2.04/COMPAT bash-2.05/COMPAT
*** bash-2.04/COMPAT	Mon Feb 28 11:41:10 2000
--- bash-2.05/COMPAT	Wed Apr  4 11:07:34 2001
***************
*** 1,4 ****
  This document details the incompatibilites between this version of bash,
! bash-2.04, and the previous widely-available version, bash-1.14 (which
  is still the `standard' version for many Linux distributions).  These
  were discovered by users of bash-2.x, so this list is not comprehensive.
--- 1,4 ----
  This document details the incompatibilites between this version of bash,
! bash-2.05, and the previous widely-available version, bash-1.14 (which
  is still the `standard' version for many Linux distributions).  These
  were discovered by users of bash-2.x, so this list is not comprehensive.
***************
*** 132,133 ****
--- 132,200 ----
  
  	alias -x='chmod a-x' --> alias -- -x='chmod a-x'
+ 
+ 13. There was a bug in bash-1.14 and previous versions that caused it to
+     accept as valid syntax for loops of the form
+ 
+ 	for f in ; do ... ; done
+ 
+     This should be a syntax error, and bash-2.x treats it as such.
+ 
+ 14. The behavior of range specificiers within bracket matching expressions
+     in the pattern matcher (e.g., [A-Z]) depends on the current locale,
+     specifically the value of the LC_COLLATE environment variable.  Setting
+     this variable to C or POSIX will result in the traditional ASCII behavior
+     for range comparisons.  If the locale is set to something else, e.g.,
+     en_US (specified by the LANG or LC_ALL variables), collation order is
+     locale-dependent.  For example, the en_US locale sorts the upper and
+     lower case letters like this:
+ 
+ 	AaBb...Zz
+ 
+     so a range specification like [A-Z] will match every letter except `z'.
+ 
+     The portable way to specify upper case letters is [:upper:] instead of
+     A-Z; lower case may be specified as [:lower:] instead of a-z.
+ 
+     Look at the manual pages for setlocale(3), strcoll(3), and, if it is
+     present, locale(1).
+ 
+     You can find your current locale information by running locale(1):
+ 
+ 	caleb.ins.cwru.edu(2)$ locale
+ 	LANG=en_US
+ 	LC_CTYPE="en_US"
+ 	LC_NUMERIC="en_US"
+ 	LC_TIME="en_US"
+ 	LC_COLLATE="en_US"
+ 	LC_MONETARY="en_US"
+ 	LC_MESSAGES="en_US"
+ 	LC_ALL=en_US
+ 
+     My advice is to put
+ 
+ 	export LC_COLLATE=C
+ 
+     into /etc/profile and inspect any shell scripts run from cron for
+     constructs like [A-Z].  This will prevent things like
+ 
+ 	rm [A-Z]*
+ 
+     from removing every file in the current directory except those beginning
+     with `z' and still allow individual users to change the collation order.
+     Users may put the above command into their own profiles as well, of course.
+ 
+ 15.  Bash versions up to 1.14.7 included an undocumented `-l' operator to
+      the `test/[' builtin.  It was a unary operator that expanded to the
+      length of its string argument.  This let you do things like
+ 
+ 	test -l $variable -lt 20
+ 
+      for example.
+ 
+      This was included for backwards compatibility with old versions of the
+      Bourne shell, which did not provide an easy way to obtain the length of
+      the value of a shell variable.
+ 
+      This operator is not part of the POSIX standard, because one can (and
+      should) use ${#variable} to get the length of a variable's value.
+      Bash-2.x does not support it.
diff -Nrc2 bash-2.04/CWRU/POSIX.NOTES bash-2.05/CWRU/POSIX.NOTES
*** bash-2.04/CWRU/POSIX.NOTES	Mon Mar  6 11:51:34 2000
--- bash-2.05/CWRU/POSIX.NOTES	Wed Mar 28 15:13:46 2001
***************
*** 13,20 ****
       available with `shopt -s checkhash'.
  
!   2. The `>&' redirection does not redirect stdout and stderr.
  
    3. The message printed by the job control code and builtins when a job
!      exits with a non-zero status is `Done(status)'.
  
    4. Reserved words may not be aliased.
--- 13,22 ----
       available with `shopt -s checkhash'.
  
!   2. The message printed by the job control code and builtins when a job
!      exits with a non-zero status is `Done(status)'.
  
    3. The message printed by the job control code and builtins when a job
!      is stopped is `Stopped(SIGNAME)', where SIGNAME is, for example,
!      `SIGTSTP'.
  
    4. Reserved words may not be aliased.
***************
*** 70,74 ****
       contain any symbolic links, as if `cd -P' had been executed.
  
!  19. If `$CDPATH' is set, the `cd' builtin will not implicitly append
       the current directory to it.  This means that `cd' will fail if no
       valid directory name can be constructed from any of the entries in
--- 72,76 ----
       contain any symbolic links, as if `cd -P' had been executed.
  
!  19. If `CDPATH' is set, the `cd' builtin will not implicitly append
       the current directory to it.  This means that `cd' will fail if no
       valid directory name can be constructed from any of the entries in
***************
*** 90,96 ****
       persist in the shell environment after the builtin completes.
  
!  24. The `export' and `readonly' builtin commands display their output
       in the format required by POSIX 1003.2.
  
  
  There is other POSIX 1003.2 behavior that Bash does not implement.
--- 92,116 ----
       persist in the shell environment after the builtin completes.
  
!  24. Assignment statements preceding shell function calls persist in the
!      shell environment after the function returns, as if a POSIX
!      special builtin command had been executed.
! 
!  25. The `export' and `readonly' builtin commands display their output
       in the format required by POSIX 1003.2.
  
+  26. The `trap' builtin displays signal names without the leading `SIG'.
+ 
+  27. The `.' and `source' builtins do not search the current directory
+      for the filename argument if it is not found by searching `PATH'.
+ 
+  28. Subshells spawned to execute command substitutions inherit the
+      value of the `-e' option from the parent shell.  When not in POSIX
+      mode, Bash clears the `-e' option in such subshells.
+ 
+  29. Alias expansion is always enabled, even in non-interactive shells.
+ 
+  30. When the `set' builtin is invoked without options, it does not
+      display shell function names and definitions.
+ 
  
  There is other POSIX 1003.2 behavior that Bash does not implement.
***************
*** 99,101 ****
--- 119,131 ----
    1. Assignment statements affect the execution environment of all
       builtins, not just special ones.
+ 
+   2. When a subshell is created to execute a shell script with execute
+      permission, but without a leading `#!', Bash sets `$0' to the full
+      pathname of the script as found by searching `$PATH', rather than
+      the command as typed by the user.
+ 
+   3. When using `.' to source a shell script found in `$PATH', bash
+      checks execute permission bits rather than read permission bits,
+      just as if it were searching for a command.
+ 
  
diff -Nrc2 bash-2.04/CWRU/changelog bash-2.05/CWRU/changelog
*** bash-2.04/CWRU/changelog	Wed Mar 15 11:20:31 2000
--- bash-2.05/CWRU/changelog	Fri Apr  6 15:14:31 2001
***************
*** 49,54 ****
  	  an otherwise-empty line
  
! 				    1/2
! 				    ---
  support/bashbug.sh
  	- fixed a typo, thanks to eggert@twinsun.com
--- 49,54 ----
  	  an otherwise-empty line
  
! 				 1/2/1997
! 				 --------
  support/bashbug.sh
  	- fixed a typo, thanks to eggert@twinsun.com
***************
*** 3400,3405 ****
  [bash-2.02-alpha1 frozen]
  
! 				  1/6/98
! 				  ------
  lib/glob/fnmatch.c
  	- fix define for isgraph so that it does not return success for space
--- 3400,3405 ----
  [bash-2.02-alpha1 frozen]
  
! 				 1/6/1998
! 				 --------
  lib/glob/fnmatch.c
  	- fix define for isgraph so that it does not return success for space
***************
*** 5035,5040 ****
  	  declaration
  
! 				  1/4/99
! 				  ------
  print_cmd.c
  	- don't print bare words when printing conditional expressions in
--- 5035,5040 ----
  	  declaration
  
! 				 1/4/1999
! 				 --------
  print_cmd.c
  	- don't print bare words when printing conditional expressions in
***************
*** 7739,7740 ****
--- 7739,10041 ----
  pcomplete.c
  	- fix to avoid freeing memory twice
+ 
+ 				   3/17
+ 				   ----
+ [bash-2.04 released]
+ 
+ 				   3/20
+ 				   ----
+ doc/bash.1
+ 	- minor typo fix to description of `xpg_echo' option in `echo'
+ 	  description
+ 
+ 				   3/23
+ 				   ----
+ parse.y
+ 	- minor fix to parse_string_to_word_list to allow newlines in
+ 	  compound array assignments
+ 
+ 				   3/27
+ 				   ----
+ lib/readline/rltty.c
+ 	- fixed a missing-semicolon syntax error in the old 4.3 BSD tty code
+ 
+ support/mksignames.c
+ 	- if SIGRTMAX is >= 2*NSIG, just #undef SIGRTMIN and SIGRTMAX.  This
+ 	  is an issue on AIX 4.3 (only, so far) -- checked by configure, which
+ 	  #defines UNUSABLE_RT_SIGNALS if this is the case
+ 
+ aclocal.m4
+ 	- new macro, BASH_CHECK_RTSIGS, checks whether or not real-time
+ 	  signals are defined with large values and defines UNUSABLE_RT_SIGNALS
+ 	  if they are
+ 
+ config.h.in
+ 	- place marker for UNDEF_RT_SIGNALS (initially undefined)
+ 
+ configure.in
+ 	- call BASH_CHECK_RTSIGS in the `bash miscellaneous' section
+ 
+ 				   3/29
+ 				   ----
+ 
+ subst.c
+ 	- fixed a problem in match_pattern_char, where `string' was checked
+ 	  for a paren following a [?+!@], rather than `pat'
+ 	- the code that checks whether or not to exit after a failed
+ 	  ${word?msg} substitution needs to check interactive_shell rather
+ 	  than interactive to avoid exiting if such a construct appears in
+ 	  a sourced file
+ 
+ 				   3/31
+ 				   ----
+ 
+ bashline.c
+ 	- add `{' to the list of characters that need to be quoted by the
+ 	  completion code when appearing in a filename
+ 
+ 				    4/1
+ 				    ---
+ lib/glob/fnmatch.c
+ 	- fixed an error in brackmatch() while skipping the rest of a bracket
+ 	  expression after a character matched.  When `c' was a backslash and
+ 	  *p was a backslash, as in a pattern like [/\\], the old code didn't
+ 	  take both backslashes into account and ended up skipping the `]'
+ 	  after erroneously concluding that it was quoted.  Report and fix
+ 	  from akim@epita.fr
+ 
+ 				    4/3
+ 				    ---
+ lib/readline/rltty.c
+ 	- slight change to the BSD tty interface code, so that if the first
+ 	  ioctl fails, get_tty_settings returns -1 immediately
+ 	- better checking of ioctl return values in BSD tty version of
+ 	  get_tty_settings
+ 
+ 				    4/5
+ 				    ---
+ doc/{bash.1,bashref.texi}
+ 	- documented use of LINES and COLUMNS variables
+ 
+ 				   4/12
+ 				   ----
+ lib/readline/rltty.c
+ 	- change the SETATTR define for the termio tty driver to use
+ 	  TCSETAW (the analog of the termios TCSADRAIN)
+ 
+ lib/glob/fnmatch.c
+ 	- fix for posix-style bracket expressions ([:xxx:], [=x=]) broken
+ 	  by fix of 4/1 for quotes in bracket expressions
+ 
+ 				   4/26
+ 				   ----
+ subst.c
+ 	- fix to list_string and get_word_from_string to make a non-whitespace
+ 	  IFS character preceded by IFS whitespace part of the current field
+ 	  delimiter, not a separate delimiter that would result in a separate
+ 	  null field when splitting.  cf POSIX.2, 3.6.5, (3)(b).  Bug reported
+ 	  by amc@cs.berkeley.edu
+ 	- changed the behavior of the (currently undocumented) ${!prefix@}
+ 	  expansion to be analogous to the expansion of $@ in other contexts
+ 	  when double-quoted.  ksh93 seems to do this.  Bug reported by
+ 	  Ken Pizzini <ken@halcyon.com>
+ 	- changed read_comsub to ignore NUL bytes in the command substitution
+ 	  output, printing a warning message for now
+ 
+ parse.y
+ 	- changed shell_getc to ignore NUL bytes in the input, printing a
+ 	  warning message for now
+ 	- changed read_a_line to print a warning when a NUL byte is encountered,
+ 	  like shell_getc does
+ 
+ 				   5/18
+ 				   ----
+ subst.c
+ 	- make sure split_at_delims uses d2 only if it's non-null
+ 	- make split_at_delims skip leading newlines in the string to split,
+ 	  if newline is a delimiter
+ 
+ jobs.c
+ 	- prevent hanging processes by marking a child process as not running
+ 	  (even if the shell thinks it is) when waitpid() returns -1/ECHILD --
+ 	  this indicates that waitpid never returned a reasonable status
+ 	  for that child though, which may be a symptom of another problem
+ 
+ builtins/cd.def
+ 	- make `pwd' print an error message if the write fails when displaying
+ 	  the current directory
+ 
+ lib/readline/histexpand.c
+ 	- return NULL from history_find_word if history_tokenize_internal
+ 	  returns (char **)NULL rather than attempting to dereference a
+ 	  possibly-NULL pointer
+ 	- change history_tokenize_internal to set *indp to -1 before any
+ 	  processing if indp is non-null
+ 
+ 				   5/19
+ 				   ----
+ builtins/trap.def
+ 	- when in POSIX.2 mode and printing trap dispositions, print the
+ 	  signal name without the leading `SIG', as POSIX.2 requires
+ 
+ 				   5/23
+ 				   ----
+ lib/readline/readline.c
+ 	- readline_initialize_everything now assigns $TERM to rl_terminal_name
+ 	  if the application has left it unset, and calls _rl_init_terminal_io
+ 	  with the resultant value
+ 
+ lib/readline/doc/rltech.texinfo
+ 	- updated the description of rl_terminal_name to note initialization
+ 
+ parse.y
+ 	- change parse_string_to_word_list to save and restore the value of
+ 	  current_command_line_count before calling back into the parser --
+ 	  it will screw up history if the string extends over one line.  Bug
+ 	  reported by Jan.Djarv@mbox200.swipnet.se
+ 
+ 				    6/7
+ 				    ---
+ unwind_prot.h
+ 	- change unwind_protect_string to pass the address of the variable to
+ 	  unwind_protect_var on machines where ints and char *s are not the
+ 	  same size
+ 
+ unwind_prot.c
+ 	- make sure we save the value of a variable in unwind_protect_var on
+ 	  machines where sizeof(char *) != sizeof(int), not the contents the
+ 	  value points to.  Fix from Andreas Schwab <schwab@suse.de>
+ 
+ 				    6/8
+ 				    ---
+ configure.in
+ 	- auto-configure MacOS X without bash malloc (like Rhapsody)
+ 
+ 				   6/12
+ 				   ----
+ configure.in
+ 	- replace `cygwin32' with `cygwin'
+ 
+ builtins/evalfile.c
+ 	- in _evalfile, change all instances of \r to \n in the file to be
+           sourced and evaluated if __CYGWIN__ is defined
+ 
+ input.c
+ 	- change \r to \n in the buffer argument to make_buffered_stream and
+           after calling zread() from b_fill_buffer if __CYGWIN__ is defined
+ 
+ 				   6/29
+ 				   ----
+ lib/sh/Makefile.in
+ 	- add rest of dependency rules for makepath.o
+ 
+ 				    7/3
+ 				    ---
+ jobs.c
+ 	- changed `int' to `WAIT' in a couple of places for non-POSIX
+ 	  environments
+ 
+ 				    7/5
+ 				    ---
+ locale.c
+ 	- try to avoid an unnecessary memory allocation in localetrans() in
+ 	  the case that a translation for the string exists
+ 
+ lib/readline/doc/rluserman.texinfo
+ 	- change the `direntry' information to make it use rluserman instead
+ 	  of readline
+ 
+ 				    7/6
+ 				    ---
+ execute_cmd.c
+ 	- changes to execute_in_subshell so it honors a `!' prefixing a command
+ 	  inside a user subshell (...)
+ 
+ support/config.{guess,sub}
+ 	- add cases for Apple Darwin (Mac OS X)
+ 
+ configure.in
+ 	- Apple Darwin (MacOS X) uses its own malloc
+ 
+ lib/readline/readline.h
+ 	- removed bogus extern declaration of savestring
+ 
+ 				    7/7
+ 				    ---
+ builtins/common.c
+ 	- in get_working_directory, don't count on getcwd returning anything
+ 	  useful in the buffer passed as the first argument on failure; just
+ 	  use bash_getcwd_errstr in the error message
+ 
+ examples/loadables/cut.c
+ 	- loadable version of cut(1), from the FreeBSD source tree
+ 
+ 				   7/18
+ 				   ----
+ lib/readline/vi_mode.c
+ 	- changed two instances of (*rl_getc_function) (rl_instream) to calls
+ 	  to rl_read_key(), which works better when using the readline
+ 	  callback interface
+ 
+ builtins/evalfile.c
+ 	- added FEVAL_CHECKBINARY flag for _evalfile; controls whether a check
+ 	  for a binary file is performed
+ 	- FEVAL_CHECKBINARY is not set by source_file or maybe_execute_file,
+ 	  which means that the startup file execution and the `.' builtin will
+ 	  not check for binary files
+ 	- FEVAL_CHECKBINARY is not set by fc_execute_file, so that files
+ 	  composed of history commands run by the `fc' builtin will not check
+ 	  for binary files
+ 
+ 				   7/21
+ 				   ----
+ shell.c
+ 	- added `--init-file' as a synonym for `--rcfile'
+ 
+ 				   7/26
+ 				   ----
+ support/shobj-conf
+ 	- added commented-out stanzas for hpux 10 and hpux 11 when the HP
+ 	  unbundled ANSI C compiler is being used
+ 
+ 				   7/27
+ 				   ----
+ shell.c
+ 	- don't call end_job_control() from exit_shell if subshell_environment
+ 	  is non-zero, even if the shell is interactive
+ 
+ 				    8/1
+ 				    ---
+ bashhist.c
+ 	- change maybe_add_history to remember if we saved the first line of
+ 	  a command and don't save the second and subsequent lines of a
+ 	  multi-line command if we didn't save the first line
+ 
+ configure.in, config.h.in
+ 	- add autoconf check for getservbyname()
+ 
+ lib/sh/netopen.c
+ 	- add support for named services in /dev/(tcp|udp)/host/service
+ 	  translation
+ 	- make sure _netopen sets errno to something other than 0 if something
+ 	  goes wrong, so the redirection functions behave
+ 
+ 				    8/3
+ 				    ---
+ parse.y
+ 	- changes to shell_getc so that history saving of blank lines in
+ 	  multi-line commands does a better job of syntactic correctness
+ 
+ bashline.c
+ 	- bind ^O to operate-and-get-next in emacs_standard_keymap explicitly,
+ 	  rather than letting rl_add_defun do it in whatever keymap is current
+ 
+ 				    8/4
+ 				    ---
+ builtins/ulimit.def
+ 	- removed some of the special handling of RLIM_INFINITY -- the old
+ 	  code would let people use RLIM_INFINITY as a shorthand for setting
+ 	  the soft limit to the hard limit.  Now, the code just passes
+ 	  RLIM_INFINITY through if the hard limit is being set, so any kernel
+ 	  errors will get through
+ 
+ 				   8/10
+ 				   ----
+ parse.y
+ 	- change the grammar rule for group_command so that it's composed of
+ 	  a compound_list instead of a list, which requires a terminator
+ 	  This means that you can now do (legal) things like
+ 
+ 		{ { echo a b c ; } }
+ 
+ 	  since the second close brace will be recognized as such because a
+ 	  reserved word is legal in that context
+ 
+ 				   8/23
+ 				   ----
+ subst.c
+ 	- fix parameter_brace_substring to free all memory allocated by
+ 	  get_var_and_type in the VT_ARRAYMEMBER case (returned parameter
+ 	  `val')
+ 
+ 				   8/30
+ 				   ----
+ variables.c
+ 	- now that we have dynamic array variables, remove the check for
+ 	  array_p in bind_variable and let array variables with assignment
+ 	  functions call the assignment function
+ 
+ subst.c
+ 	- change cond_expand_word to perform tilde expansion (like it should
+ 	  have done all along)
+ 
+ lib/readline/complete.c
+ 	- don't allow backslash to quote anything inside a single-quoted
+ 	  string in find_completion_word
+ 
+ doc/{bash.1,bashref.texi}
+ 	- note that `set -a' will cause functions to be exported
+ 
+ lib/readline/parens.c
+ 	- changed the blink timeout so it's settable by the application.  A
+ 	  new function, int rl_set_paren_blink_timeout (int u), (still
+ 	  undocumented) will set the timeout to U usec
+ 
+ variables.c
+ 	- at startup of an interactive login shell, if the current directory
+ 	  is $HOME, and $HOME and $PWD are not the same, set the current
+ 	  directory (and $PWD) to $HOME
+ 	- break code that initializes $PWD and $OLDPWD into set_pwd function
+ 
+ variables.h
+ 	- new extern declaration for set_pwd()
+ 
+ 				    9/6
+ 				    ---
+ lib/readline/{readline,callback}.c
+ 	- allocate memory for rl_prompt instead of simply using what's passed
+ 	  as the `prompt' argument to readline() or
+ 	  rl_callback_handler_install().  This will allow constant strings to
+ 	  be passed to readline(), since the prompt processing code wants to
+ 	  write to rl_prompt
+ 
+ lib/sh/pathcanon.c
+ 	- new file, does pathname canonicalization
+ 
+ externs.h
+ 	- extern declarations for stuff in lib/sh/pathcanon.c
+ 
+ general.c
+ 	- canonicalize_pathname now simply calls sh_canonpath()
+ 
+ 				    9/7
+ 				    ---
+ pcomplete.h
+ 	- new member in a `struct compspec': options
+ 	- define some flag values for options field
+ 
+ pcomplib.c
+ 	- make sure options field is allocated and copied by compspec utility
+ 	  functions
+ 
+ builtins/complete.def
+ 	- add struct for completion options.  These control the `meta-behavior'
+ 	  of the compspec.  Initially, there are three:
+ 
+ 		default - perform bash default completion if programmable
+ 			  completion produces no matches
+ 		dirnames - perform directory name completion if programmable
+ 			   completion produces no matches
+ 		filenames - tell readline that the compspec produces filenames,
+ 			    so it can do things like append slashes to
+ 			    directory names and suppress trailing spaces
+ 
+ 	- add `-o option' to complete and compgen, setting new options field
+ 	  in a compspec
+ 	- add code to display any -o options when a compspect is printed
+ 	  with the `-p' option to complete
+ 
+ pcomplete.c
+ 	- programmable_completions now passes back to the caller in the last
+ 	  argument any options associated with the active compspec (from the
+ 	  options field)
+ 	- change gen_compspec_completions to re-call gen_action_completions
+ 	  with a CA_DIRECTORY action if the rest of the compspec actions
+ 	  generate no matches and the COPT_DIRNAMES option is present
+ 
+ bashline.c
+ 	- if a programmable completion was specified to return filenames with
+ 	  the `-o filenames' option, set rl_filename_completion_desired to 1
+ 	  so readline does its special filename-specific things
+ 	- if a compspec was defined to fall back to the readline default with
+ 	  the `-o default' option, suppress setting the
+ 	  rl_attempted_completion_over variable in attempt_shell_completion
+ 	  so readline will go on and do filename completion
+ 
+ include/ansi_stdlib.h
+ 	- add extern declarations for atof and strtod
+ 
+ builtins/printf.def
+ 	- change getdouble() to use strtod (since we provide a version in
+ 	  libsh if the C library doesn't have one), and change the calling
+ 	  convention to match the other getXXX functions (take value pointer
+ 	  as argument, return success or failure).  This makes printf handle
+ 	  invalid floating point numbers better
+ 
+ doc/bash.1, lib/readline/doc/rluser.texinfo
+ 	- documented new `-o' option to complete and compgen; described the
+ 	  arguments and their effects
+ 
+ lib/readline/{macro,util}.c
+ 	- renamed _rl_executing_macro to rl_executing_macro; made it public
+ 
+ lib/readline/readline.h
+ 	- new extern declaration for rl_executing_macro
+ 
+ lib/readline/rltech.texinfo
+ 	- documented rl_executing_macro
+ 
+ 				    8/8
+ 				    ---
+ lib/readline/readline.c
+ 	- new state variable, rl_readline_state
+ 
+ lib/readline/readline.h
+ 	- extern declaration for rl_readline_state
+ 	- define some flag bits for rl_readline_state and macros to test and
+ 	  set them
+ 
+ lib/readline/{readline,complete,isearch,macro,rltty,search,signals,undo,vi_mode}.c
+ 	- added calls to the macros that set and unset various readline states
+ 
+ lib/readline/readline.c
+ 	- new private function, _rl_free_saved_history_line, to free up the
+ 	  history entry saved in saved_line_for_history
+ 
+ lib/readline/search.c
+ 	- free any saved history entry in rl_history_search_reinit(), because
+ 	  rl_get_previous_history makes a call to maybe_save_line without
+ 	  freeing up the saved line when it returns (so rl_get_next_history
+ 	  can use it)
+ 	- fix up noninc_search_from_pos to deal with invalid history indices
+ 	  better
+ 
+ 				   9/12
+ 				   ----
+ support/shobj-conf
+ 	- HPUX 11.0 needs the `-fpic' flag passed to the linker as well as
+ 	  the compiler
+ 
+ execute_cmd.c
+ 	- on MS-DOS systems, let the #! checking stuff in execute_shell_script
+ 	  treat \r as EOL (identical to \n)
+ 
+ input.c
+ 	- on DJGPP systems, allow buffered_getchar to ignore \r.  Change
+ 	  suggested by snowball3@bigfoot.com
+ 
+ 				   9/13
+ 				   ----
+ lib/sh/tmpfile.c
+ 	- new file, with functions for creating and (hopefully safely) opening
+ 	  temporary files for the shell
+ 
+ externs.h
+ 	- extern declarations for functions in tmpfile.c
+ 
+ variables.c
+ 	- new function, get_random_number, returns random values from the
+ 	  shell's (lame) RNG to the rest of the shell
+ 
+ variables.h
+ 	- new extern declaration for get_random_number()
+ 
+ subst.c
+ 	- changed make_named_pipe to call sh_mktmpname instead of mktemp
+ 
+ redir.c
+ 	- changed here_document_to_fd to call sh_mktmpfd instead of using
+ 	  inline code
+ 
+ builtins/fc.def
+ 	- changed fc_builtin to call sh_mktmpfp instead of using inline code
+ 
+ builtins/common.h
+ 	- new extern declaration for fc_execute_file()
+ 
+ bashline.c
+ 	- if RL_ISSTATE(RL_STATE_INITIALIZED) is 0 in initialize_readline,
+ 	  call rl_initialize to bind the defaults before setting up our
+ 	  custom shell functions and key bindings
+ 
+ lib/readline/doc/{rluser,hsuser}.texinfo
+ 	- some markup changes proposed by dima@chg.ru
+ 
+ lib/readline/rlstdc.h, lib/tilde/tilde.h
+ 	- to get ready for some `const' changes to the source, define const
+ 	  as either `__const' (gcc -traditional) or nothing if __STDC__ and
+ 	  __cplusplus are not defined
+ 
+ lib/readline/readline.c
+ 	- upped the default readline version to `4.2-alpha'
+ 
+ lib/readline/readline.[ch]
+ 	- readline now takes a `const char *' as an argument
+ 
+ lib/readline/history.h
+ 	- read_history(), read_history_range(), write_history(),
+ 	  append_history(), history_truncate_file() now take `const char *'
+ 	  filename arguments
+ 
+ lib/readline/histfile.c
+ 	- history_filename(), read_history(), read_history_range(),
+ 	  write_history(), append_history(), history_truncate_file(),
+ 	  history_do_write() now take `const char *' filename arguments
+ 
+ lib/readline/readline.h
+ 	- rl_read_init_file() now takes a `const char *' filename argument
+ 
+ lib/readline/bind.c
+ 	- current_readline_init_file is now a `const char *'
+ 	- _rl_read_init_file(), rl_read_init_file() now take `const char *'
+ 	  filename arguments
+ 
+ lib/tilde/tilde.c
+ 	- tilde_expand(), tilde_expand_word() now take a `const char *'
+ 	  as their first argument
+ 
+ lib/readline/chardefs.h
+ 	- fixed CTRL_CHAR macro to be right on systems where chars are unsigned
+ 	  by default
+ 
+ 				   9/14
+ 				   ----
+ lib/readline/doc/{rl,hs}tech.texinfo
+ 	- documented new `const char *' function arguments where appropriate
+ 
+ lib/readline/vi_mode.c
+ 	- clamp the numeric argument in vi mode at 999999, just like in emacs
+ 	  mode
+ 
+ lib/readline/doc/rltech.texinfo
+ 	- documented rl_readline_state and its possible bit values
+ 
+ builtins/source.def
+ 	- in maybe_pop_dollar_vars, don't overwrite a shell function's
+ 	  argument list even if the sourced script changes the positional
+ 	  parameters
+ 
+ lib/readline/{util.c,rlprivate.h}
+ 	- made _rl_strindex() and _rl_savestring() take `const char *'
+ 	  arguments
+ 
+ 				   9/15
+ 				   ----
+ subst.c
+ 	- renamed `doing_completion' to `no_longjmp_on_fatal_error', a more
+ 	  accurate description of its current behavior
+ 
+ pcomplete.[ch], externs.h, lib/sh/stringlist.c
+ 	- moved the stringlist code from pcomplete.c to lib/sh/stringlist.c
+ 	- moved the type declaration and extern function declarations from
+ 	  pcomplete.h to externs.h
+ 
+ stringlib.c, externs.h, lib/sh/stringvec.c
+ 	- moved the char array code from stringlib.c to lib/sh/stringvec.c
+ 
+ 				   9/18
+ 				   ----
+ subst.c
+ 	- new static variable, expand_no_split_dollar_star, to ensure that
+ 	  $* isn't `split and rejoined' when expanded via a call to
+ 	  expand_string_unsplit or expand_word_no_split
+ 
+ 				   9/19
+ 				   ----
+ subst.[ch], execute_cmd.c
+ 	- renamed expand_word_no_split to expand_word_unsplit
+ 
+ copy_cmd.c
+ 	- in copy_word, just assign w->flags to new_word->flags rather than
+ 	  bcopying the entire structure
+ 
+ configure.in, config.h.in
+ 	- add autoconf check for pathconf(3)
+ 
+ lib/sh/tmpfile.c
+ 	- test for systems with short filenames using pathconf and
+ 	  _PC_NAME_MAX, so generated temp file names don't exceed that length
+ 	  (only do this if the file name length is less than 32, since the
+ 	  current code doesn't generate filenames longer than about 17 chars)
+ 
+ 				   9/20
+ 				   ----
+ command.h
+ 	- added `W_NOSPLIT2' word flag to prepare for supporting weird $@
+ 	  expansion on the rhs of assignment statements (inspecting the ksh93
+ 	  behavior, it seems like nothing except $@ is split, and $@ is split
+ 	  on $IFS and rejoined as a single string)
+ 
+ 				   9/21
+ 				   ----
+ subst.c
+ 	- since verify_substring_values looks for arithmetic expressions
+ 	  bounded by `:', do some ad-hoc parsing of the substring passed as
+ 	  the argument to avoid cutting the expression off at the wrong `:'
+ 	  (since the inclusion of conditional expressions, expressions may
+ 	  contain a `:').  Do some paren balancing, too.
+ 
+ 				   9/22
+ 				   ----
+ command.h
+ 	- new #define, CLOBBERING_REDIRECT, evaluates to true for any redirect
+ 	  that will clobber a file and should be subject to `noclobber'
+ 
+ redir.c
+ 	- changed redir_open to use CLOBBERING_REDIRECT instead of
+ 	  OUTPUT_REDIRECT.  This means that <> no longer tests the value of
+ 	  noclobber, as POSIX.2 specifies
+ 
+ parse.y
+ 	- made a change to cond_term so that expressions like [[ (x) ]] are
+ 	  parsed correctly
+ 
+ 				   9/25
+ 				   ----
+ parse.y
+ 	- small change to grammar for arith_for_command and special_case_tokens
+ 	  to allow `do...done' or {...} after ((...)) without an intervening
+ 	  list_terminator (for ksh93 compatibility)
+ 
+ builtins/printf.def
+ 	- `printf' now treats \E and \e the same when performing backslash
+ 	  escape expansion for the %b format character for compatibility with
+ 	  $'...' quoting (for ksh93 compatibility)
+ 
+ 				   9/26
+ 				   ----
+ builtins/source.def
+ 	- new variable, source_searches_cwd, initially 1.  If non-zero, `.'
+ 	  searches $PWD for the filename argument if it's not found in $PATH
+ 
+ general.c
+ 	- changed posix_initialize to turn off source_searches_cwd if posix
+ 	  mode is being enabled; turn it on if posix mode is being disabled
+ 	- changed things so interactive_comments is not turned off if posix
+ 	  mode is disabled, since that's rarely what is desired
+ 
+ variables.c
+ 	- changed uidset() to set UID and EUID only if they are not already
+ 	  set when the shell starts up
+ 	- changed things to HOSTNAME is set only if it's not set when the
+ 	  shell starts up
+ 
+ execute_cmd.c
+ 	- changed execute_builtin_or_function so that if a command like
+ 	  `command exec 4<file' is executed, the effect is as if the `command'
+ 	  had been omitted, as POSIX.2 requires
+ 
+ subst.c
+ 	- changed array_length_reference to support ${foo[X]} when foo is not
+ 	  an array variable and X is 0, @, or * (everything else returns 0)
+ 	  for ksh compatibility
+ 	- changed array_value_internal to support ${foo[@]} and ${foo[*]}
+ 	  when foo is not an array variable (as ksh does)
+ 
+ 				   9/27
+ 				   ----
+ general.h
+ 	- added defines for ABSPATH (absolute pathname), RELPATH (relative
+ 	  pathname, and ROOTEDPATH (pathname rooted at /), with different
+ 	  definitions for Unix and Cygwin
+ 	- added defines for DIRSEP (the directory separator in pathnames,
+ 	  and ISDIRSEP (whether a particular character is the directory
+ 	  separator)
+ 	- added PATHSEP define: takes a character and decides whether it
+ 	  delimits a filename component of a pathname
+ 	- changed isletter(c) #define to just call isalpha(c)
+ 
+ lib/sh/pathcanon.c
+ 	- changed to use new pathname #defines from general.h above
+ 
+ general.c
+ 	- changed make_absolute, absolute_pathname to understand
+ 	  Cygwin's idea of an absolute pathname: [[:upper:][:lower:]]:/
+ 	- rewrote absolute_pathname to use PATHSEP and ABSPATH
+ 	- changed full_pathname to use ABSPATH
+ 
+ variables.c
+ 	- changed get_bash_name to use ABSPATH and RELPATH, and to handle the
+ 	  case when $PWD is unset when it is called
+ 
+ subst.c
+ 	- if compiling on cygwin, translate \r\n to \n when reading the output
+ 	  of a command substitution in read_comsub()
+ 
+ 				   9/28
+ 				   ----
+ input.c, shell.c, builtins/read.def, lib/tilde/tilde.c
+ 	- changed __CYGWIN32__ to __CYGWIN__
+ 
+ lib/readline/{bind,funmap,kill}.c, lib/readline/readline.h
+ 	- changed __CYGWIN32__ to __CYGWIN__
+ 
+ input.c
+ 	- a couple of minor changes to clean up the code
+ 
+ parse.y
+ 	- changed shell_getc and shell_ungetc to implement one character of
+ 	  lookahead/lookbehind when pushing a character back at the start
+ 	  of an input line (the old code would have discarded it because
+ 	  shell_input_line_index was 0)
+ 
+ lib/readline{histsearch.c,history.h}
+ 	- history_search_internal, history_search, history_search_prefix,
+ 	  history_search_pos now take const char * string arguments
+ 
+ lib/readline/{histexpand.c,history.h}
+ 	- get_history_event, history_arg_extract, history_tokenize_internal,
+ 	  history_tokenize now take const char * string arguments
+ 
+ lib/readline/{history.c,history.h}
+ 	- add_history, replace_history_entry now take const char * string
+ 	  arguments
+ 
+ lib/readline/{bind.c,readline.h}
+ 	- rl_add_defun, rl_unbind_command_in_map, rl_set_key, rl_macro_bind,
+ 	  rl_generic_bind, rl_translate_keyseq, rl_named_function,
+ 	  rl_function_of_keyseq, rl_variable_bind, rl_get_keymap_by_name
+ 	  now take const char * string arguments where appropriate
+ 	- rl_function_dumper, rl_list_funmap_names needed changes to deal
+ 	  with rl_funmap_names returning const char **
+ 	- rl_readline_name is now a const char * variable
+ 
+ lib/readline/keymaps.h
+ 	- duplicate definition of rl_get_keymap_by_name needs const changes
+ 
+ lib/readline/{bind.c,rlprivate.h}
+ 	- _rl_bind_if_unbound takes a const char * string argument
+ 
+ lib/readline/{funmap.c,readline.h}
+ 	- rl_add_funmap_entry now takes a const char * string argument
+ 	- rl_funmap_names now returns a const char **
+ 	- a FUNMAP now has a const char *name member
+ 
+ lib/readline/{terminal.c,readline.h,rlprivate.h}
+ 	- _rl_init_terminal_io, rl_get_termcap, rl_reset_terminal,
+ 	  _rl_output_some_chars now take const char * string arguments
+ 
+ lib/readline/{readline.[ch],rlprivate.h}
+ 	- rl_library_version and rl_terminal_name are now const char *
+ 	  variables
+ 	- rl_insert_text, _rl_replace_text now take const char * string
+ 	  arguments
+ 
+ lib/readline/{callback.c,readline.h}
+ 	- rl_callback_handler_install takes a const char * string argument
+ 
+ lib/readline/doc/{rltech,hstech}.texinfo
+ 	- changed documentation for newly-consted functions and variables
+ 
+ lib/readline/{complete.c,readline.h}
+ 	- rl_strpbrk now takes const char * string arguments
+ 	- username_completion_function and filename_completion_function
+ 	  now take const char * string arguments
+ 	- rl_basic_word_break_characters, rl_basic_quote_characters,
+ 	  rl_completer_word_break_characters, rl_completer_quote_characters,
+ 	  rl_filename_quote_characters, rl_special_prefixes are all
+ 	  const char * variables
+ 
+ lib/readline/{display.c,rlprivate.h}
+ 	- _rl_move_cursor_relative takes a const char * string argument
+ 
+ redir.c
+ 	- change from tbisp@uswest.net to fix a problem with cygwin and
+ 	  here_document_to_fd, since cygwin doesn't allow a file to be
+ 	  unlinked if there is a descriptor open on it
+ 
+ display.c
+ 	- fixed a slight bug in the logic deciding whether or not to redraw
+ 	  a prompt containing invisible characters in update_line.  Fixes
+ 	  bug reported by bdluevel@heitec.net
+ 
+ 				   9/29
+ 				   ----
+ shell.c
+ 	- fixed a problem with a too-aggressive setting of restricted shell
+ 	  mode based on shell_name.  Old code set `restricted' even after a
+ 	  longjmp due to shell_execve trying to execute an executable script
+ 	  without a leading `#!', though that case should result in an
+ 	  unrestricted shell
+ 
+ 				   10/2
+ 				   ----
+ copy_cmd.c
+ 	- make sure copy_function_def copies the `flags' and `line' members
+ 	  of the function_def
+ 
+ parse.y
+ 	- make the function_def production take a new function_body parse
+ 	  unit, which is currently just a group_command (in prep for future
+ 	  changes)
+ 
+ builtins/printf.def
+ 	- changed getint, getlong, getulong, getdouble to print warnings on
+ 	  range errors and return the clamped values that strtol/strtod
+ 	  return, as POSIX.2 specifies
+ 
+ 				   10/3
+ 				   ----
+ parse.y
+ 	- made a function_def a `command' instead of a `shell_command'
+ 	  This makes the grammar more closely resemble that supplied in
+ 	  the POSIX.2 standard
+ 	- made a `function_body' be like the function_body production in
+ 	  the POSIX.2 standard.  This relaxes the restriction that the
+ 	  body be composed of a group_command, but introduces a YACC
+ 	  shift/reduce conflict
+ 
+ print_cmd.c
+ 	- changes to named_function_string (for normal function printing)
+ 	  and print_function_def (for printing function definitions embedded
+ 	  in other commands) to print redirections that should be attached
+ 	  to the function as a whole after the closing brace, because of
+ 	  the changes to the parser
+ 
+ tests/func2.sub
+ 	- tests for new function declarations whose bodies are not group
+ 	  commands -- the command printing code still prints them with the
+ 	  braces
+ 
+ 				   10/4
+ 				   ----
+ lib/sh/pathphys.c
+ 	- new function, sh_physpath, resolves symlinks in pathname passed
+ 	  as argument
+ 
+ builtins/cd.def
+ 	- changed pwd_builtin to use sh_physpath if -P supplied or in
+ 	  physical mode
+ 	- changed bindpwd to use sh_physpath if the no_symlinks argument is
+ 	  non-zero
+ 	- changed change_to_directory to use sh_physpath and set
+ 	  the_current_working_directory appropriately if the `nolinks'
+ 	  argument is non-zero
+ 
+ 				   10/5
+ 				   ----
+ variables.c, bashline.c, builtins/cd.def
+ 	- replaced calls to canonicalize_pathname with sh_canonpath
+ 
+ builtins/cd.def
+ 	- rewrote change_to_directory to make it much shorter and simpler
+ 
+ command.h
+ 	- added SUBSHELL_PIPE as possible flag value for subshell_environment
+ 
+ execute_cmd.c
+ 	- execute_simple_command sets SUBSHELL_PIPE in subshell_environment
+ 	  if the command has a pipe in or out
+ 
+ subst.c
+ 	- don't reset pipeline_pgrp to shell_pgrp in command_substitute if
+ 	  we're already in a pipline
+ 	  ((subshell_environment & SUBSHELL_PIPE) != 0)
+ 
+ 				   10/6
+ 				   ----
+ subst.c 
+ 	- change command_substitute to call setmode(fd, O_TEXT) on the pipe
+ 	  file descriptor if __CYGWIN__ is defined; remove the other code
+ 	  that converts CR/LF to LF on cygwin
+ 
+ 				   10/9
+ 				   ----
+ stringlib.c
+ 	- change strcreplace() to make sure that RESIZE_MALLOCED_BUFFER is
+ 	  called everywhere characters are added
+ 
+ 				   10/11
+ 				   -----
+ lib/sh/spell.c
+ 	- new file, with the spelling correction code from builtins/cd.def
+ 
+ builtins/cd.def
+ 	- a little surgery on cd_builtin, to make the structure clearer
+ 
+ 				   10/12
+ 				   -----
+ builtins/read.def
+ 	- include fcntl.h and io.h on __CYGWIN__
+ 	- set mode of fd 0 to O_TEXT if __CYGWIN__ and O_TEXT are both
+ 	  defined
+ 
+ shell.c
+ 	- in open_shell_script, set mode of fd opened to the shell script
+ 	  to O_TEXT if __CYGWIN__ and O_TEXT are both defined
+ 
+ builtins/evalfile.c
+ 	- changed the __CYGWIN__ code to call setmode(fd, O_TEXT) instead
+ 	  of translating \r to \n after the read() returns
+ 
+ 				   10/13
+ 				   -----
+ lib/sh/strtrans.c, stringlib.c
+ 	- moved ansicstr() from stringlib.c to new file lib/sh/strtrans.c
+ 	- new function ansic_quote, to quote a string with $'...'
+ 
+ lib/sh/strindex.c, stringlib.c
+ 	- moved strindex() from stringlib.c to new file lib/sh/strindex.c
+ 
+ lib/sh/Makefile.in
+ 	- compile `shquote.c' in as part of the shell library
+ 	- compile `strtrans.c' in as part of the shell library
+ 	- compile `strindex.c' in as part of the shell library
+ 
+ Makefile.in
+ 	- link with libsh before any of the readline libraries
+ 
+ builtins/common.c
+ 	- removed the functions also appearing in lib/sh/shquote.c
+ 
+ externs.h, builtins/common.h
+ 	- moved extern declarations for functions in lib/sh/shquote.c to
+ 	  externs.h from builtins/common.h
+ 
+ variables.c
+ 	- print_var_value (used in the output of `set') now calls
+ 	  ansic_quote to quote the value, so any non-printable characters
+ 	  are displayed
+ 
+ 				   10/14
+ 				   -----
+ syntax.h
+ 	- new file, with definitions from shell.h having to do with shell
+ 	  syntax, metacharacters, and quoting
+ 
+ parse.y
+ 	- moved defines for shell metachars and other char class declarations
+ 	  to syntax.h
+ 
+ shell.h
+ 	- now includes syntax.h
+ 
+ Makefile.in,builtins/Makefile.in,lib/sh/Makefile.in
+ 	- added syntax.h to appropriate dependency lists
+ 
+ 				   10/16
+ 				   -----
+ mksyntax.c
+ 	- new program, to build a syntax table for the shell at compile time
+ 
+ Makefile.in
+ 	- new generated file, syntax.c, generated by mksyntax
+ 
+ general.h
+ 	- `digit(x)' is now just defined as `isdigit(x)'
+ 
+ syntax.h
+ 	- now that we have sh_syntaxtab[], change the appropriate defines
+ 	  to use it
+ 
+ parse.y, subst.c
+ 	- change checks of member(c, slashify_in_quotes) to test
+ 	  sh_syntaxtab[c] & CBSDQUOTE
+ 
+ builtins/set.def
+ 	- corrected the help text for `unset', since PATH and IFS may be
+ 	  unset
+ 
+ subst.c
+ 	- changed explicit tests for shell special parameters using member()
+ 	  or strchr() to test (sh_syntaxtab[c] & CSPECVAR) instead
+ 	- changed some boilerplate calls to member() that test for validity
+ 	  of various characters in the expansion process to macros for
+ 	  efficiency
+ 
+ lib/sh/shquote.c
+ 	- changed some of the functions to use checks against sh_syntaxtab[]
+ 	  flag values
+ 
+ 				   10/19
+ 				   -----
+ findcmd.c
+ 	- find_user_command_in_path no longer finds directories if the caller
+ 	  specified FS_NODIRS in the flags argument.  This fixes the bug of
+ 	  hashing directory names, at the loss of some information about
+ 	  attempting to execute directories
+ 
+ builtins/hash.def
+ 	- hash -p dirname name no longer puts directories into the hash table
+ 
+ 				   10/26
+ 				   -----
+ builtins/read.def
+ 	- make sure that the last unwind-protect added is the one that calls
+ 	  xfree(input_string), so that this is the top element on the
+ 	  unwind-protect stack
+ 	- if xrealloc() is called to increase the size of input_string, make
+ 	  sure to remove the top element from the unwind-protect stack (the
+ 	  old xfree) and add a new one, in case realloc() freed the original
+ 	  input_string and allocated new space.  This fixes the bug of bash
+ 	  crashing because it's trying to free already-freed memory if the
+ 	  `read' is interrupted (reported by klausf@Pool.Informatik.RWTH-Aachen.DE)
+ 
+ 				   10/27
+ 				   -----
+ subst.c
+ 	- fixed a problem in expand_word_list_internal so that
+ 	  last_command_exit_value is set to 1 if a variable assignment fails
+ 	  and a jump_to_top_level (DISCARD) is taken.  This fixes the problem
+ 	  of assignment statements to read-only variables appearing to succeed
+ 	  (though it always worked right in non-interactive posix-mode shells)
+ 
+ 				   10/30
+ 				   -----
+ lib/readline/readline.h
+ 	- rl_completion_entry_function is now of type CPFunction *, since
+ 	  that's the actual type that's used, and casting function pointers
+ 	  of different types (which happened all the time as a result), is
+ 	  problematic on some architectures
+ 
+ lib/readline/complete.c
+ 	- changed entry function argument to gen_completion_matches to be of
+ 	  type CPFunction *, since that's how it's used
+ 	- changed variables that are completion entry function pointers to be
+ 	  of type CPFunction *, removed problematic typecasts
+ 
+ lib/readline/doc/rltech.texinfo
+ 	- documented type change for rl_completion_entry_func
+ 
+ lib/readline/rltypedefs.h
+ 	- new file, with all the readline function typedefs
+ 
+ lib/readline/rltypedefs.h
+ 	- new typedef, rl_command_func_t, which is a function returning
+ 	  an int
+ 	- a KEYMAP_ENTRY now contains a pointer to an rl_command_func_t
+ 	- new typedef, rl_compentry_func_t, which is a function returning
+ 	  a char *
+ 	- new typdef, rl_completion_func_t, which is a function returning
+ 	  a char **
+ 	- new typedef, rl_quote_func_t, which is a function returning a
+ 	  char *
+ 	- new typedef, rl_dequote_func_t, which is a function returning a
+ 	  char *
+ 	- new typedef, rl_compignore_func_t, which is a function returning a
+ 	  char *
+ 	- new typedef, rl_compdisp_func_t, which is a void function taking
+ 	  a char **, int, int argument list
+ 	- new typedef, rl_hook_func_t, which is a function taking no args
+ 	  and returning an int (used for input and other hooks)
+ 	- new typedef, rl_modterm_func_t, which is a void function tkaing
+ 	  an int, used to modify terminal (rl_prep_term_function)
+ 	- new typedef, rl_getc_func_t, which is an int-returning function
+ 	  that takes a FILE *
+ 	- new typedef, rl_linebuf_func_t, which takes a string and an int
+ 	  index and returns an int
+ 	- new generic typedefs, rl_intfunc_t and rl_voidfunc_t, which are
+ 	  functions which take and return int and void, respectively 
+ 	- new generic typedef, rl_vintfunc_t, which takes an int and returns
+ 	  void
+ 	- new generic typedefs, rl_icpfunc_t and rl_vcpfunc_t, which take a
+ 	  char * and return int and void, respectively
+ 	- new generic typedefs, rl_icppfunc_t and rl_vcppfunc_t, which take
+ 	  a char ** and return int and void, respectively
+ 
+ lib/readline/rlprivate.h
+ 	- rl_last_func is now of type rl_command_func_t *
+ 
+ lib/readline/readline.c
+ 	- declare rl_last_func as rl_command_func_t *
+ 
+ lib/readline/{bind,readline,vi_keymap,emacs_keymap,funmap,keymaps,isearch}.c
+ lib/readline/readline.h
+ 	- change appropriate cases of (Function *) to (rl_command_func_t *)
+ 
+ lib/readline/{readline.h,bind.c}
+ 	- rl_named_function and rl_function_of_keyseq now return a
+ 	  (rl_command_func_t *)
+ 
+ lib/readline/bind.c
+ 	- changed type of functions in parser function table from Function *
+ 	  to _rl_parser_func_t *
+ 
+ lib/readline/funmap.c
+ 	- removed `vi-bracktype' from vi function map -- it's not a
+ 	  bindable function
+ 
+ lib/readline/{readline.h,complete.c}
+ 	- changed appropriate uses of CPFunction * to rl_compentry_func_t *
+ 	  or rl_quote_func_t *
+ 
+ lib/readline/{rltty.c,readline.h}
+ 	- rl_prep_term_function is now of type rl_vintfunc_t *
+ 	- rl_deprep_term_function is now of type rl_voidfunc_t *
+ 
+ lib/readline/{keymaps,history.h}
+ 	- include rltypedefs.h or <readline/rltypedefs.h> as appropriate
+ 
+ lib/readline/{display.c,readline.h}
+ 	- rl_redisplay_func is now of type rl_voidfunc_t *
+ 
+ lib/readline/{callbacks.c,readline.h}
+ 	- the `linefunc' argument to rl_callback_handler_install and the
+ 	  rl_linefunc variable are now of type rl_vcpfunc_t *
+ 
+ lib/readline/{complete.c,readline.h}
+ 	- rl_completion_display_matches_hook is now of type
+ 	  rl_compdisplay_func_t *
+ 	- rl_directory_completion_hook is now of type rl_icppfunc_t *
+ 
+ lib/readline/{history.h,histexpand.c}
+ 	- history_inhibit_expansion_function is now of type
+ 	  rl_linebuf_func_t *
+ 
+ lib/readline/histexpand.c
+ 	- new private type, _hist_search_func_t, used to indirect through
+ 	  the various history search functions
+ 
+ lib/tilde/tilde.h
+ 	- new typedef, tilde_hook_func_t, which takes a char * and returns
+ 	  a char *
+ 
+ lib/tilde/tilde.[ch]
+ 	- tilde_expansion_preexpansion_hook and tilde_expansion_failure_hook
+ 	  are now of type tilde_hook_func_t *
+ 
+ [THERE ARE NO LONGER ANY REFERENCES TO Function *, CPFunction *, or
+ CPPFunction * IN THE READLINE SOURCE, WHICH INCLUDES THE TILDE LIBRARY]
+ 
+ {bashline,bracecomp}.c, bashline.h
+ 	- changes for changed type of rl_completion_entry_func and other
+ 	  changed types (rl_compentry_func_t, rl_completion_func_t,
+ 	  const changes for prototypes, etc.)
+ 
+ pathexp.[ch]
+ 	- shell_glob_filename now takes a `const char *' argument
+ 	- quote_string_for_globbing now takes a `const char *' argument
+ 
+ 				   10/31
+ 				   -----
+ lib/sh/zwrite.c
+ 	- fix zwrite() to update the buffer pointer in the case of a
+ 	  partial write, in addition to decreasing the count of bytes to
+ 	  be written
+ 
+ support/config.{guess,sub}
+ 	- added entries for MIPS-based Compaq machines running NonStopUX
+ 
+ 				   11/1
+ 				   ----
+ lib/readline/undo.c
+ 	- renamed free_undo_list to be rl_free_undo_list, made a dummy
+ 	  replacement function free_undo_list that just calls
+ 	  rl_free_undo_list
+ 
+ lib/readline/readline.h
+ 	- extern declaration for rl_free_undo_list
+ 
+ lib/readline/{readline,signals}.c
+ 	- changed calls to free_undo_list to rl_free_undo_list
+ 
+ lib/readline/doc/rltech.texinfo
+ 	- changed all function types and arguments for new typedefs
+ 
+ 				   11/2
+ 				   ----
+ lib/readline/{rlprivate.h,terminal.c,display.c}
+ 	- term_clreol, term_clrpag, term_cr, term_backspace, term_goto,
+ 	  term_pc, term_im, term_ei, term_ic, term_ip, term_IC, term_dc,
+ 	  term_DC, term_forward_char, term_up, term_mm, term_mo, term_ku,
+ 	  term_kd, term_kr, term_kl, term_ks, term_ke, term_kh, term_kH,
+ 	  terminal_can_insert variables all now have a _rl_ prefix
+ 
+ lib/readline/{rlprivate.h,terminal.c,display.c, readline.c}
+ 	- screenheight, screenwidth, screenchars now have an _rl_ prefix
+ 
+ lib/readline/{terminal,complete,isearch,kill,macro,readline,search,undo,util,vi_mode}.c
+ 	- changed calls to ding to calls to rl_ding
+ 
+ lib/readine/{isearch,readline,search}.c
+ 	- saved_line_for_history now has an _rl_ prefix
+ 
+ lib/readline/readline.[ch]
+ 	- renamed maybe_{replace,save,unsave} line to have an rl_ prefix
+ 
+ lib/readline/{readline,search,isearch}.c
+ 	- changed calls to maybe_{replace,save,unsave} line to call the
+ 	  rl_-prefixed equivalents
+ 
+ lib/readline/{rlprivate.h,readline.c,util.c}
+ 	- renamed alphabetic to rl_alphabetic; changed calls
+ 
+ lib/readline/{bind.c,funmap.c,rlprivate.h}
+ 	- possible_control_prefixes -> _rl_possible_control_prefixes
+ 	- possible_meta_prefixes -> _rl_possible_meta_prefixes
+ 
+ lib/readline/compat.c
+ 	- new file for entry points for backwards compatibility functions
+ 	- moved free_undo_list here from undo.c
+ 	- maybe_{replace,save,unsave}_line function that call their rl_
+ 	  counterparts
+ 	- moved ding() here; it just calls rl_ding()
+ 	- moved alphabetic here; it just calls _rl_alphabetic()
+ 
+ lib/readline/Makefile.in
+ 	- make sure compat.o is built and linked appropriately
+ 
+ bashline.c,pcomplete.c
+ 	- changed calls to ding() to call rl_ding()
+ 
+ support/shobj-conf
+ 	- changed linux stanza SHLIB_XLDFLAGS to make the `soname' in a
+ 	  shared library have only the major version number, rather than
+ 	  major and minor numbers
+ 	- made analogous changes for bsd/os-4
+ 	- changed freebsd 3.x stanza to match `freebsdelf[3-9]*' for
+ 	  FreeBSD elf systems and `freebsdaout[3-9]*' for FreeBSD
+ 	  a.out systems (are there any?)
+ 
+ lib/readline/doc/{rluser,hsuser}.texinfo
+ 	- changed uses of @samp to @option where appropriate
+ 
+ doc/bashref.texi
+ 	- changed uses of @samp to @option where appropriate
+ 
+ 				   11/3
+ 				   ----
+ lib/readline/{readline.h,complete.c,compat.c}
+ 	- completion_matches, username_completion_function,
+ 	  filename_completion_function all have an rl_ prefix
+ 
+ {bashline,bracecomp,pcomplete}.c
+ 	- changed calls to completion_matches, username_completion_function,
+ 	  and filename_completion_function
+ 
+ lib/sh/shquote.c
+ 	- single_quote, double_quote, un_double_quote, backslash_quote,
+ 	  backslash_quote_for_double_quotes, contains_shell_metas all now
+ 	  have an sh_ prefix
+ 
+ externs.h
+ 	- changed extern declarations for functions from shquote.c
+ 
+ {array,bashline,pcomplete,print_cmd,variables}.c, parse.y
+ builtins/{alias,complete,trap,type}.def
+ 	- changed callers of single_quote
+ 
+ {array,bashline}.c, builtins/setattr.def
+ 	- changed callers of double_quote
+ 
+ {bashline,bracecomp}.c, parse.y, builtins/printf.def
+ 	- changed callers of backslash_quote
+ 
+ parse.y
+ 	- changed callers of backslash_quote_for_double_quotes
+ 
+ {print_cmd,variables}.c
+ 	- changed callers of contains_shell_metas
+ 
+ lib/readline/{rlshell.h,shell.c,histexpand.c}
+ 	- single_quote -> sh_single_quote
+ 
+ lib/readline/{rlshell.h,shell.c,input.c}
+ general.[ch],shell.c,subst.c
+ 	 - unset_nodelay_mode -> sh_unset_nodelay_mode
+ 
+ lib/readline/{rlshell.h,shell.c}, lib/tilde/tilde.c, variables.c
+ 	- get_home_dir -> sh_get_home_dir
+ 
+ lib/readline/rlshell.h,lib/readline/bind,histfile,nls,readline,shell,terminal}.c, lib/tilde/tilde.c, variables.c
+ 	- get_env_value -> sh_get_env_value
+ 
+ lib/readline/rlshell.h,lib/readline/{shell,terminal}.c
+ variables.h,{jobs,nojobs,variables}.c
+ 	- set_lines_and_columns -> sh_set_lines_and_columns
+ 
+ 				   11/6
+ 				   ----
+ configure.in
+ 	- bash can only link with an already-installed readline library whose
+ 	  version is 4.2 or greater
+ 
+ variables.h
+ 	- new variable attribiute, noassign, with its accompanying test macro,
+ 	  noassign_p.  Completely internal, not user-settable
+ 
+ execute_cmd.c
+ 	- treat noassign variables like readonly variables, except an attempt
+ 	  to assign to them does not cause a non-interactive shell in POSIX
+ 	  mode to abort
+ 
+ {subst,variables}.c,builtins/declare.def
+ 	- attempts to assign to `noassign' variables return an error status,
+ 	  but no error messages -- almost identical to readonly variables
+ 
+ variables.c
+ 	- GROUPS and FUNCNAME are `noassign' variables, meaning assignment to
+ 	  them is disallowed, but that they may be unset (in which case they
+ 	  lose their special properties)
+ 
+ doc/{bash.1,bashref.texi}
+ 	- documented that assignments to GROUPS and FUNCNAME are disallowed
+ 	  and return an error status
+ 
+ 				   11/8
+ 				   ----
+ lib/readline/{funmap.c,bind.c,rlprivate.h}
+ 	- _rl_possible_{control,meta}_prefixes are now arrays of `const char *'
+ 	  and are defined in bind.c, since that's where they're used
+ 
+ lib/readline/rltty.c
+ 	- changed prepare_terminal_settings to take an `oldtio' argument
+ 	  instead of `otio', which shadows the global declaration
+ 
+ lib/readline/bind.c
+ 	- the `name' member of a parser_directive element is now a
+ 	  `const char *'
+ 	- the `name' member of a boolean_varlist element is now a
+ 	  `const char *'
+ 	- the `name' member of a string_varlist element is now a
+ 	  `const char *'
+ 	- the `name' member of an assoc_list element is now a
+ 	  `const char *'
+ 	- the `name' member of an keymap_names element is now a
+ 	  `const char *'
+ 
+ lib/readline/display.c
+ 	- changed scope-local char * variable `temp' to `vtemp' because
+ 	  there's already a function local variable named `temp' of a
+ 	  different type (int) in rl_redisplay
+ 
+ lib/readline/util.c
+ 	- pathname_alphabetic_chars is now `const char *'
+ 
+ lib/readline/terminal.c
+ 	- the `tc_var' member of a _tc_string element is now a
+ 	  `const char *'
+ 
+ lib/readline/histexpand.c
+ 	- changed history_expand_internal to remove the duplicate local
+ 	  declaration of `t' in the `s'/`&' case
+ 
+ lib/readline/histfile.c
+ 	- in history_filename, `home' is now a `const char *'
+ 
+ lib/tilde/tilde.c
+ 	- default_prefixes and default_suffixes are now arrays of
+ 	  `const char *'
+ 
+ lib/readline/vi_mode.c
+ 	- vi_motion and vi_texmod are now `const char *'
+ 
+ lib/readline/complete.c
+ 	- simplified the conditional declaration of getpwent()
+ 
+ variables.[ch]
+ 	- get_string_value now takes a `const char *' argument
+ 
+ 				   11/10
+ 				   -----
+ display.c
+ 	- changes to expand_prompt and rl_redisplay to keep track of the number
+ 	  of invisible characters on the first line of the prompt, in case it
+ 	  takes up more than one physical line, and not all invisible chars are
+ 	  on the first line
+ 	- the code that determines the index into the line at which to wrap the
+ 	  first line if the visible prompt length exceeds the screen width was
+ 	  changed to use the number of invisible chars in the first physical
+ 	  prompt line rather than the total number of invisible characters
+ 	- changed redraw_prompt to save and restore prompt_invis_chars_first_line
+ 
+ subst.c
+ 	- changed expand_string_internal to savestring() the string argument
+ 	  to avoid possible doubly-freed memory on substitution errors
+ 	- fixed expand_word_list_internal so that commands with assignment
+ 	  statements preceding words that expand to nothing return a failure
+ 	  status if one of the assignments fails; for example
+ 
+ 		readonly TVAR
+ 		TVAR=7 $ECHO $ABCDE
+ 	- made sure that all cases of jump_to_top_level set
+ 	  last_command_exit_value to something non-zero before jumping, since
+ 	  they are by definition errors
+ 
+ builtins/evalstring.c
+ 	- changed parse_and_execute to set last_result to EXECUTION_FAILURE
+ 	  along with last_command_exit_value in the `DISPOSE' case of a
+ 	  jump_to_top_level, since we can return this value in most
+ 	  (interactive) circumstances
+ 
+ 				   11/14
+ 				   -----
+ general.c
+ 	- fix legal_number so that it skips any trailing whitespace in its
+ 	  string argument after strtol returns, since strtol does not
+ 
+ lib/readline/{complete.c,readline.h}
+ 	- new function pointer, rl_directory_rewrite_hook, identical in effect
+ 	  to rl_directory_completion_hook except that it does not modify what
+ 	  is displayed when the possible completions are listed or inserted
+ 
+ bashline.c
+ 	- changed tcsh_magic_space to try and insert a space closer to where
+ 	  the point was originally, rather than always inserting it at the
+ 	  end of the line
+ 
+ 				   11/16
+ 				   -----
+ jobs.c
+ 	- fixed a bug that happened on cygwin systems that caused the jobs
+ 	  table to fill up if a file sourced from an interactive shell ran
+ 	  lots of jobs -- notify_and_cleanup() never called notify_of_job_status
+ 
+ subst.c
+ 	- fixed pat_match to avoid infinite recursion on zero-length matches
+ 	  from match_pattern
+ 
+ 				11/17/2000
+ 				----------
+ [bash-2.05-alpha1 released]
+ 
+ 				   11/18
+ 				   -----
+ support/shobj-conf
+ 	- added GNU Hurd support, identical to linux
+ 
+ variables.c
+ 	- cygwin systems don't use the exportstr stuff at all, so call
+ 	  INVALIDATE_EXPORTSTR before testing var->exportstr, since just
+ 	  blindly using the value_cell will break exported functions that
+ 	  already have an exportstr set
+ 	- when recomputing the exported value because valid_exportstr fails,
+ 	  make sure to call named_function_string if the variable is a shell
+ 	  function
+ 
+ 				   11/20
+ 				   -----
+ variables.c
+ 	- removed call to valid_exportstr; the exportstr code has been
+ 	  adequately debugged
+ 
+ lib/glob/fnmatch.c
+ 	- reverted to the POSIX.2 behavior of using the current locale and
+ 	  strcoll() to evaluate range expressions in bracket expressions
+ 
+ doc/{bash.1,bashref.texi}
+ 	- added note to Pattern Matching section emphasizing that the current
+ 	  locale plays a part in evaluating range expressions within [...]
+ 
+ aclocal.m4
+ 	- added an #include <unistd.h> to the test for posix sigaction
+ 	  restarting interrupted system calls
+ 
+ support/config.guess
+ 	- changes from Tim Mooney to support `letter version' releases of
+ 	  Tru 64 Unix on the Alpha (e.g., 5.1a)
+ 
+ 				   11/21
+ 				   -----
+ lib/sh/pathphys.c
+ 	- make sure MAXSYMLINKS is defined
+ 
+ aclocal.m4
+ 	- changed BASH_CHECK_PWFUNCS to just use AC_EGREP_CPP on a file
+ 	  that includes pwd.h and other header files, checking for getpwuid.
+ 	  It #defines HAVE_GETPW_DECLS if the egrep succeeds
+ 
+ lib/readline/complete.c
+ 	- provide extern declaration of getpwent if _POSIX_SOURCE is defined,
+ 	  since most systems don't declare it in <pwd.h> unless _POSIX_SOURCE
+ 	  is undefined
+ 
+ 				   11/22
+ 				   -----
+ input.c
+ 	- fixed a small typo in the cygwin-specific code
+ 
+ doc/{bashref.texi,bash.1}
+ 	- added some more explanatory text about the effect of the current
+ 	  locale's collating order on range expressions within bracket
+ 	  expressions
+ 
+ doc/bashref.texi, lib/readline/doc/{rltech,rluser,hstech}.texinfo
+ 	- changed to use @env instead of @code for the names of environment
+ 	  and shell variables in text (not in tables yet)
+ 
+ 				   11/27
+ 				   -----
+ configure.in
+ 	- configure without the bash malloc on Interix
+ 
+ lib/readline/doc/rltech.texinfo
+ 	- changed completion_matches() to rl_completion_matches()
+ 	- changed filename_completion_function() to
+ 	  rl_filename_completion_function()
+ 	- changed username_completion_function() to
+ 	  rl_username_completion_function()
+ 
+ lib/readline/rlprivate.h
+ 	- changed declaration of _rl_alphabetic to rl_alphabetic, since that's
+ 	  what's used in the C files
+ 
+ support/bashbug.sh
+ 	- Debian has /usr/bin/editor as a link to the system default editor;
+ 	  make that one of the alternatives if $EDITOR is not set
+ 	- if the OS provides mktemp(1) or tempfile(1), use those to create
+ 	  the temp file for the bug report
+ 
+ lib/readline/{readline.[ch], callback.c}
+ 	- new function, rl_set_prompt, called with prompt string as argument,
+ 	  sets and, if necessary, expands rl_prompt
+ 
+ lib/readline/{complete.c,compat.c,readline.h}
+ 	- rl_completion_matches now takes a `const char *' as its first
+ 	  argument
+ 	- compute_lcd_of_matches now takes a `const char *' as its third
+ 	  argument
+ 
+ lib/readline/rltypedefs.h
+ 	- a rl_completion_func_t now takes a `const char *' as its first
+ 	  argument
+ 
+ lib/readline/Makefile.in
+ 	- added dependencies on rltypedefs.h
+ 
+ bashline.c
+ 	- attempt_shell_completion now takes a `const char *' as its first
+ 	  argument
+ 	- removed bogus cast when assigning to rl_attempted_completion_function
+ 	  and rl_completion_entry_function
+ 	- bash_directory_completion_matches takes a `const char *' argument
+ 
+ pcomplete.c
+ 	- gen_matches_from_itemlist, pcomp_filename_completion_function,
+ 	  gen_action_completions, gen_globpat_matches, gen_wordlist_matches,
+ 	  gen_compspec_completions now take `const char *' arguments as
+ 	  appropriate
+ 	- programmable_completions now takes `const char *' first and 
+ 	  second arguments
+ 
+ pcomplib.c
+ 	- find_compspec now takes a `const char *' argument
+ 
+ 				   11/29
+ 				   -----
+ shell.c
+ 	- in open_shell_script, if we have /dev/fd, don't perform the check
+ 	  for a binary file if isatty(fd) (where fd is opened on the script
+ 	  name) returns non-zero
+ 	- in open_shell_script, don't call init_noninteractive again, since it
+ 	  can undo changes made by the startup files ($BASH_ENV)
+ 
+ input.c
+ 	- in fd_to_buffered_stream, make sure buffer size (and hence size
+ 	  arg passed to read(2)) is greater than zero.  This makes
+ 	  bash /dev/stdin work right.
+ 	- return -1 from sync_buffered_stream immediately if buffers is NULL
+ 	  (can happen when running `bash -i /dev/stdin' and executing a
+ 	  command that requires a fork)
+ 
+ 				   11/30
+ 				   -----
+ jobs.c
+ 	- renamed cont_signal_handler to sigcont_sighandler for consistency
+ 	- renamed stop_signal_handler to sigstop_sighandler for consistency
+ 	- if there is no jobs list or no outstanding jobs, return immediately
+ 	  from notify_of_job_status, before fussing with the signal state
+ 	- change map_over_jobs to not fuss with the signal state unless there
+ 	  are jobs
+ 
+ lib/malloc/malloc.c
+ 	- encapsulated the code to block and unblock signals during morecore()
+ 	  execution into two functions:  block_signals and unblock_signals
+ 	- only block signals in morecore() if interrupt_immediately is non-zero
+ 	  or SIGINT or SIGCHLD is trapped
+ 
+ 				   12/1
+ 				   ----
+ lib/readline/readline.c
+ 	- fix to rl_forward to make sure that lend doesn't get set < 0, since
+ 	  that will result in rl_point being < 0
+ 
+ 				   12/5
+ 				   ----
+ parse.y
+ 	- fix to parse_matched_pair to allow backslash to escape a ' inside a
+ 	  $'...' construct inside another grouping construct like ${...}
+ 	- translate $'...' and $"..." in parse_matched_pair, because nothing
+ 	  else will do it if such a construct appears inside a grouping
+ 	  construct
+ 
+ 				   12/6
+ 				   ----
+ configure.in
+ 	- make sure all bracket tests for pattern matching in case statements
+ 	  are appropriately quoted, so autoconf doesn't swallow the brackets
+ 	- add -rdynamic to LOCAL_LDFLAGS for freebsd-4.x
+ 
+ examples/loadables/realpath.c
+ 	- new loadable builtin, canonicalizes pathnames and expands symlinks
+ 
+ builtins/ulimit.def
+ 	- added undocumented -w option for setting RLIMIT_SWAP, if it's defined
+ 
+ 				   12/7
+ 				   ----
+ bashline.c
+ 	- reordered code in initialize_readline so all of the rl_add_defun
+ 	  calls are made before the call to rl_initialize, and all of the
+ 	  rl_{bind,unbind}_key_in_map calls are made after initializing
+ 	  readline.  This allows the bash-specific function names to be used
+ 	  in ~/.inputrc
+ 
+ 				   12/12
+ 				   -----
+ lib/readline/callback.c
+ 	- in rl_callback_read_char, loop after returning from
+ 	  readline_internal_char and test rl_pending_input in case some
+ 	  function (like the incremental search functions and digit argument
+ 	  functions) pushed input back with rl_execute_next
+ 
+ lib/readline/readline.h
+ 	- new rl_state flag:  RL_STATE_INPUTPENDING, indicating that
+ 	  rl_execute_next has pushed input back for rl_get_key to read
+ 
+ lib/readline/input.c
+ 	- new function to clear rl_pending_input: rl_clear_pending_input()
+ 
+ lib/readline/{input,readline,signals}.c
+ 	- when rl_pending_input is set, set state RL_STATE_INPUTPENDING;
+ 	  unset that state when rl_read_key returns the pending input
+ 	- call rl_clear_pending_input at appropriate points
+ 
+ 				   12/15
+ 				   -----
+ lib/readline/histfile.c
+ 	- don't leak file descriptors while attempting to truncate a non-regular
+ 	  file
+ 
+ input.c
+ 	- make sure check_bash_input sets the close-on-exec flag for the file
+ 	  descriptor used to save the bash input fd
+ 
+ parse.y
+ 	- if default_buffered_input gets changed while it's on the saved
+ 	  stream stack, make sure it gets set to close-on-exec when it's
+ 	  restored by pop_stream()
+ 
+ 				   12/18
+ 				   -----
+ builtins/ulimit.def
+ 	- change set_limit to account for Cygwin's setdtablesize() being
+ 	  declared as a void function
+ 
+ support/config.{guess,sub}
+ 	- change cygwin32 to cygwin
+ 
+ 				   12/20
+ 				   -----
+ nojobs.c
+ 	- make wait_sigint_handler handle the case of interrupt_immediately
+ 	  being non-zero when it's called, and jump out appropriately
+ 
+ jobs.c
+ 	- new function to run sigchld traps: run_sigchld_trap(); called from
+ 	  waitchld
+ 	- broke the code that computes the printable job status messages for
+ 	  pretty_print_job out into a separate function
+ 	- rearranged some code eliminating a useless `else' branch in wait_for
+ 	- shell_tty_info is now a TTYSTRUCT, using defines from shtty.h
+ 	- broke the code that sets a job's status after waitpid says its state
+ 	  has changed and cleans up after a received SIGINT out into a separate
+ 	  function: set_job_status_and_cleanup
+ 	- last_stopped_job() -> job_last_stopped() to avoid collision with a
+ 	  variable name
+ 	- last_running_job() -> job_last_running() for consistency
+ 
+ 				   12/21
+ 				   -----
+ variables.c
+ 	- new function, print_func_list (SHELL_VAR **list); prints shell
+ 	  functions from list in a form that may be re-used as input to
+ 	  redefine the functions
+ 
+ variables.h
+ 	- new extern declaration for print_func_list
+ 
+ builtins/set.def
+ 	- set without options now calls print_func_list to have functions
+ 	  printed in a way that can be reused as input (this affects
+ 	  `declare' and `declare -p' also)
+ 
+ 				   12/27
+ 				   -----
+ general.h
+ 	- add an ISOCTAL define
+ 
+ builtins/common.h
+ 	- use ISOCTAL in read_octal function
+ 
+ parse.y
+ 	- in decode_prompt_string, don't just skip STRING forward by 3 if an
+ 	  octal sequence is translated; handle sequences of fewer than three
+ 	  characters by checking each character
+ 
+ 				   12/28
+ 				   -----
+ doc/{bash.1,bashref.texi}
+ 	- make sure `vi-move' is a documented keymap argument to bind's
+ 	  `-m' option
+ 
+ 				   12/29
+ 				   -----
+ variables.c
+ 	- change print_assignment so that functions are printed in a way that
+ 	  may be reused as input (without the `=')
+ 
+ 				 1/2/2001
+ 				 --------
+ test.c
+ 	- fix test_command to print an error message if `[' is supplied a
+ 	  single argument that is not `]'
+ 
+ support/shobj-conf
+ 	- change test of $SHOBJ_CC from `gcc*' to `*gcc*' to handle full
+ 	  pathnames
+ 
+ 				   1/11
+ 				   ----
+ execute_cmd.c
+ 	- in initialize_subshell, zero out builtin_env, since those aren't
+ 	  supposed to be exported
+ 
+ variables.c
+ 	- new function: shell_var_from_env_string, creates a SHELL_VAR from
+ 	  a `name=value' style environment string and returns it
+ 	- new function: bind_name_in_env_array(name, value, array), makes
+ 	  NAME have VALUE in ARRAY, a temporary environment
+ 	- new function: bind_tempenv_variable (name, value), makes NAME have
+ 	  VALUE in one of the temporary environments -- temporary_env,
+ 	  builtin_env, or function_env
+ 	- changed bind_variable to call bind_tempenv_variable if one of the
+ 	  temporary environments is non-null before modifying the
+ 	  shell_variables table.  This fixes a problem with sourced scripts
+ 	  modifying variables in a temporary environment, but not seeing the
+ 	  updated values
+ 
+ 				   1/12
+ 				   ----
+ variables.c
+ 	- changed things so OSTYPE, HOSTTYPE, and MACHTYPE are set only if
+ 	  they don't have a value at shell startup
+ 
+ 				   1/17
+ 				   ----
+ builtins/fc.def
+ 	- create temp file with MT_USETMPDIR
+ 
+ variables.c
+ 	- allow function local readonly variables to overwrite (or shadow)
+ 	  other (calling) function readonly variables, but not global
+ 	  readonly ones
+ 
+ builtins/wait.def
+ 	- replace unwind_protect of interrupt_immediately, since that's a
+ 	  variable that you cannot unwind-protect (the unwind-protect code
+ 	  uses it)
+ 
+ 				   1/22
+ 				   ----
+ Makefile.in
+ 	- changed RELSTATUS to `beta1'
+ 
+ lib/readline/terminal.c
+ 	- added rl_set_screen_size function, wrapper around
+ 	  _rl_set_screen_size so bash doesn't call _rl_ functions
+ 
+ lib/readline/{rlprivate,readline}.h
+ 	- moved rl_explicit_arg to readline.h
+ 	- moved rl_numeric_arg to readline.h
+ 	- moved rl_editing_mode to readline.h
+ 	- moved rl_last_func to readline.h
+ 	- added rl_set_screen_size to readline.h
+ 
+ lib/readline/doc/rltech.texinfo
+ 	- documented rl_explicit_arg, rl_editing_mode, rl_numeric_arg,
+ 	  rl_last_func
+ 	- documented rl_set_screen_size
+ 
+ {jobs,nojobs}.c
+ 	- _rl_set_screen_size -> rl_set_screen_size
+ 
+ {bashline,pcomplete}.c, builtins/set.def
+ 	- removed extern declarations of variables defined in readline.h
+ 
+ 				   1/23
+ 				   ----
+ support/rlvers.sh
+ 	- use $TMPDIR if it's defined
+ 	- use $RL_INCDIR (set by -I option, /usr/local/include by default)
+ 	  as the directory containing the installed readline header files
+ 	- cd to the temp directory before attempting compilation
+ 
+ configure.in
+ 	- pass `-I ${includedir}' to rlvers.sh
+ 
+ 				   1/29
+ 				   ----
+ subst.c
+ 	- fixed parameter_brace_expand to only throw away the state of
+ 	  quoted dollar-at if we're going to be using the rhs of the
+ 	  brace expansion, since whatever parameter_brace_expand_rhs sets
+ 	  should be what goes (corrects bad fix of 2/16/2000)
+ 	- fixed param_expand to only free temp after calling
+ 	  parameter_brace_expand if it's a quoted null and we *did not*
+ 	  have a quoted $@, since in that case we want to keep it and
+ 	  do the $@ special handling (fixes real problem from 2/16/2000)
+ 
+ 				   1/30
+ 				   ----
+ variables.c
+ 	- remove export attribute from SSH2_CLIENT, like SSH_CLIENT
+ 
+ 				    2/1
+ 				    ---
+ unwind_prot.c
+ 	- added new function, clear_unwind_protect_list, to zero out the
+ 	  unwind_protect list, optionally freeing the elements
+ 
+ unwind_prot.h
+ 	- new extern declaration for clear_unwind_protect_list
+ 
+ execute_cmd.c
+ 	- call clear_unwind_protect_list in initialize_subshell.  This fixes
+ 	  the problem of core dumps when calling a shell script without a
+ 	  leading `#!' from a shell function or other context with an
+ 	  unwind-protect list
+ 	- set variable_context and return_catch_flag to 0 in
+ 	  initialize_subshell, since a new subshell is no longer in a shell
+ 	  function
+ 
+ 				    2/2
+ 				    ---
+ doc/readline.3
+ 	- updated the text; clarified several points
+ 	- changed the usage synopsis to include <readline/readline.h> and
+ 	  <readline/history.h>
+ 
+ lib/readline/doc/hstech.texinfo
+ 	- made sure all function prototypes are valid ANSI C (mostly
+ 	  changing () to (void))
+ 
+ lib/readline/doc/rluser.texinfo
+ 	- a few clarifications
+ 
+ lib/readline/doc/rltech.texinfo
+ 	- a few clarifications
+ 	- added two new subsections for character input and terminal
+ 	  management
+ 	- changed all function prototypes to be valid ANSI C (mostly
+ 	  replacing () with (void))
+ 	- documented some variables in readline.h but previously not in
+ 	  the reference manual (rl_num_chars_to_read, rl_dispatching,
+ 	  rl_gnu_readline_p, rl_completion_type)
+ 	- documented some functions in readline.h but previously not in
+ 	  the reference manual (rl_clear_pending_input, rl_prep_terminal,
+ 	  rl_deprep_terminal, rl_tty_set_default_bindings, rl_alphabetic,
+ 	  rl_crlf)
+ 
+ lib/readline/readline.h
+ 	- added extern declaration for rl_clear_pending_input()
+ 	- added extern declaration for rl_alphabetic
+ 	- changed rltty_set_default_bindings to rl_tty_set_default_bindings
+ 	- changed crlf() -> rl_crlf()
+ 
+ lib/readline/rltty.c
+ 	- new function, rl_tty_set_default_bindings, just calls
+ 	  rltty_set_default_bindings (needed `rl_' prefix)
+ 
+ lib/readline/readline.c
+ 	- readline_default_bindings now calls rl_tty_set_default_bindings
+ 
+ lib/readline/terminal.c
+ 	- renamed crlf() to rl_crlf(); crlf() is still defined for backwards
+ 	  compatibility 
+ 
+ bashline.c, lib/readline/{complete,display}.c
+ 	- changed all calls to crlf() to rl_crlf()
+ 
+ test.c
+ 	- fix filecomp() so that `test file1 -nt file2' doesn't fail if file1
+ 	  exists but file2 does not
+ 
+ 				    2/5
+ 				    ---
+ lib/readline/{terminal,compat}.c
+ 	- move crlf() backwards-compatibility definition to compat.c
+ 
+ execute_cmd.c
+ 	- if we're running a command `( command ) &' from a non-interactive
+ 	  shell, don't unconditionally disable expand_aliases.  Only do it
+ 	  when running such a command from an interactive shell, since then
+ 	  we're changing to a non-interactive shell
+ 
+ 				    2/6
+ 				    ---
+ [bash-2.05-beta1 released]
+ 
+ lib/readline/compat.c
+ 	- add extern declaration for rl_crlf()
+ 
+ lib/readline/undo.c
+ 	- initialize start and end in rl_do_undo to avoid bogus gcc compiler
+ 	  warning with -Wall
+ 
+ lib/readline/rlprivate.h
+ 	- fix typo in extern declaration of _rl_current_display_line()
+ 	- add extern declaration of _rl_free_saved_history_line()
+ 
+ lib/readline/terminal.c
+ 	- return immediately from _rl_set_screen_size if one of the args is 0
+ 	- new function, rl_get_screen_size (int *rows, int *cols) to return
+ 	  readline's idea of the screen dimensions
+ 
+ lib/readline/doc/rltech.texinfo
+ 	- documented rl_get_screen_size
+ 
+ 				    2/7
+ 				    ---
+ pathexp.c
+ 	- a couple of fixes for the POSIX_GLOB_LIBRARY version of the globbing
+ 	  code
+ 
+ expr.c
+ 	- fixed omission of ^= from the special assignment operators
+ 
+ shell.c
+ 	- change logic for setting `posixly_correct' at shell startup:  if
+ 	  $POSIXLY_CORRECT or $POSIX_PEDANTIC is found in the environment,
+ 	  set it to 1, otherwise retain the previous value (which is
+ 	  initialized to 0)
+ 
+ 				   2/10
+ 				   ----
+ builtins/evalstring.c
+ 	- since subshell_environment is now a flags word, test for the
+ 	  SUBSHELL_COMSUB bit being set when decided whether or not to
+ 	  evaluate $(<file), not just for subshell_environment ==
+ 	  SUBSHELL_COMSUB
+ 
+ 				   2/12
+ 				   ----
+ lib/readline/doc/rltech.texinfo
+ 	- fixed a couple of problems with the documentation for
+ 	  rl_prep_terminal and rl_deprep_terminal 
+ 	- added description of rl_set_prompt
+ 
+ support/config.sub
+ 	- added support for Linux running on the IBM S390
+ 
+ 				   2/13
+ 				   ----
+ input.c
+ 	- new function, fd_is_bash_input (fd), encapsulates the test for
+ 	  whether or not FD is the file descriptor from which bash is reading
+ 	  its input
+ 	- change check_bash_input to call fd_is_bash_input
+ 	- new function, save_bash_input (fd, new_fd), handles saving the
+ 	  buffered stream associated with file descriptor FD to one
+ 	  associated with NEW_FD.  If NEW_FD == -1, this function allocates a
+ 	  file descriptor itself with fcntl
+ 	- new function, set_bash_input_fd(fd), sets the fd bash is using to
+ 	  read input to FD
+ 	- changed duplicate_buffered_stream to note that the buffer it's
+ 	  duplicating to was the bash input buffer (B_WASBASHINPUT)
+ 
+ input.h
+ 	- extern declarations for fd_is_bash_input and save_bash_input
+ 	- new flag for b->flag: B_WASBASHINPUT
+ 
+ redir.c
+ 	- in add_undo_redirect, if FD is 0, make the undo redirect be of type
+ 	  r_duplicating_input instead of r_duplicating_output, since that fd
+ 	  requires special handling in the presence of buffered streams (fixes
+ 	  problem with scripts reading input through a pipe restoring bash
+ 	  input buffered stream correctly after a `read' with an input
+ 	  redirection
+ 
+ 				   2/14
+ 				   ----
+ lib/readline{complete,util}.c
+ 	- moved rl_strpbrk to util.c with rest of string utility functions,
+ 	  renamed to _rl_strpbrk
+ 
+ lib/readline/rlprivate.h
+ 	- extern declaration for _rl_strpbrk
+ 
+ lib/readline/input.c
+ 	- make the timeout in rl_gather_tyi() be a variable
+ 	  (_keyboard_input_timeout) rather than a constant
+ 	- new function, rl_set_keyboard_input_timeout (int u) to set
+ 	  _keyboard_input_timeout.  The argument is in microseconds; returns
+ 	  the old value of _keyboard_input_timeout
+ 	- _rl_input_available uses _keyboard_input_timeout also
+ 
+ lib/readline/readline.h
+ 	- extern declaration for rl_set_keyboard_input_timeout
+ 
+ lib/readline/doc/rltech.texinfo
+ 	- documented rl_variable_bind(), rl_macro_bind(), rl_macro_dumper(),
+ 	  rl_variable_dumper(), rl_push_macro_input(), rl_show_char()
+ 
+ 				   2/20
+ 				   ----
+ findcmd.c
+ 	- new function, executable_or_directory(name), returns 1 if NAME is
+ 	  an executable file or a directory
+ 
+ findcmd.h
+ 	- extern declaration for executable_or_directory()
+ 
+ bashline.c
+ 	- call executable_or_directory() from command_word_completion_function,
+ 	  which requires a single stat(2), instead of executable_file() and
+ 	  is_directory(), each of which requires a stat(2)
+ 
+ 				   2/21
+ 				   ----
+ execute_cmd.c
+ 	- changed execute_builtin to handle `return' with a preceding variable
+ 	  assignment list specially when in POSIX mode.  POSIX says that the
+ 	  variable assignments should persist after the builtin returns, since
+ 	  `return' is a special builtin.  Since `return' does a longjmp and
+ 	  doesn't go through the normal cleanup path, we need to do special
+ 	  things
+ 
+ variables.c
+ 	- new function, merge_function_env(), merges the function_env into
+ 	  the shell_variables table
+ 
+ variables.h
+ 	- extern declaration for merge_function_env()
+ 
+ execute_cmd.c
+ 	- changed execute_function to merge any variable assignments preceding
+ 	  the function call into shell_variables if the shell is running in
+ 	  POSIX mode
+ 
+ subst.c
+ 	- changed parameter_brace_expand_error to do tilde expansion on the
+ 	  rhs of the expansion, if it's not null
+ 	- changed command_substitute so that the subshell begun to execute
+ 	  the command substitution inherits the setting of the `-e' option
+ 	  when in POSIX mode
+ 
+ builtins/break.def
+ 	- changed check_loop_level to not print a complaining message when
+ 	  the shell is running in POSIX mode, even if BREAK_COMPLAINS is
+ 	  defined.  This affects `break' and `continue'
+ 	- changed `break' and `continue' to return success even if the shell
+ 	  is not executing a loop, as POSIX specifies
+ 
+ builtins/set.def
+ 	- changed reset_shell_options() to not clear posixly_correct, so
+ 	  subshells spawned to execute shell scripts without a leading `#!'
+ 	  inherit posix mode from their parent shell
+ 
+ variables.c
+ 	- changed make_new_variable to create the shell_variables hash table
+ 	  if it hasn't been done yet.  This is needed because bind_variable
+ 	  may be called before initialize_shell_variables (e.g., when
+ 	  `bash -o posix' calls bind_variable("POSIXLY_CORRECT", "y") from
+ 	  parse_shell_options -> set_minus_o_option -> set_posix_mode
+ 	  This makes `bash --posix' and `bash -o posix' equivalent, as they
+ 	  should always have been
+ 	- changed maybe_make_export_env to merge the contents of `builtin_env'
+ 	  into export_env after function_env and before temporary_env.  This
+ 	  fixes the problems with variable assignments preceding `eval' or
+ 	  `source' not making it into the environment passed to executed disk
+ 	  commands (var=20 eval printenv var)
+ 
+ doc/bashref.texi
+ 	- noted that variable assignments preceding shell function calls
+ 	  persist in the shell environment after the function returns when
+ 	  the shell is running in POSIX mode
+ 	- noted that when the shell is running in POSIX mode, subshells
+ 	  spawned to execute command substitutions inherit the value of
+ 	  the `-e' option from the parent shell
+ 
+ 				   2/26
+ 				   ----
+ doc/bashref.texi
+ 	- augmented description of bash non-posix behavior in posix mode
+ 	  with information from running the vsc-lite test suite
+ 
+ 				   2/28
+ 				   ----
+ general.c
+ 	- since POSIX.2 says that aliases should be expanded even in
+ 	  non-interactive shells, enable alias expansion in
+ 	  posix_initialize() when posix mode is enabled, and set it to the
+ 	  value of interactive_shell if posix mode is disabled
+ 
+ shell.c
+ 	- before running the startup scripts, set expand_aliases to
+ 	  posixly_correct, since we don't want alias expansion in startup
+ 	  files unless we've been given the --posix invocation option
+ 
+ doc/bashref.texi
+ 	- added item in BASH Posix Mode section noting that alias expansion
+ 	  is always enabled when in posix mode
+ 
+ Makefile.in
+ 	- changed release level to `beta2'
+ 
+ 				    3/1
+ 				    ---
+ jobs.c
+ 	- expanded retcode_name_buffer to 64
+ 	- changed printable_job_status to conform to posix.2 for text of
+ 	  stopped job status: `Stopped(SIGTSTP)' or `Stopped(SIGSTOP)'
+ 
+ doc/bashref.texi
+ 	- Noted above change in posix mode section
+ 
+ 				    3/5
+ 				    ---
+ lib/readline/bind.c
+ 	- changed rl_get_keymap_by_name to work case-insensitively
+ 
+ 				    3/6
+ 				    ---
+ doc/readline.{0,3,ps}
+ 	- removed from distribution; moved to readline distribution
+ 
+ lib/readline/doc/history.3
+ 	- man page for history library; neither built nor installed
+ 	  (part of the standalone readline distribution)
+ 
+ lib/readline/histfile.c
+ 	- changed history_truncate_file to return 0 on success, errno
+ 	  on failure
+ 	- changed history_do_write to return errno on a write error.  This
+ 	  affects write_history and append_history
+ 
+ lib/readline/history.c
+ 	- max_input_history is now history_max_entries; the old variable is
+ 	  maintained for backwards compatibility
+ 
+ lib/readline/histexpand.c
+ 	- the list of delimiters that separate words for history_tokenize
+ 	  is now a variable: history_word_delimiters; default value is as
+ 	  before
+ 	- changed history_expand to return 0 immediately if its second
+ 	  argument is NULL
+ 
+ bashline.c
+ 	- changed to use history_max_entries
+ 
+ lib/readline/history.h
+ 	- extern declaration for history_max_entries
+ 	- extern declaration for history_word_delimiters
+ 
+ 				    3/8
+ 				    ---
+ test.c
+ 	- changed unary_operator() to return FALSE for non-numeric arguments
+ 	  to `-t'
+ 
+ 				    3/9
+ 				    ---
+ [bash-2.05-beta2 released]
+ 
+ 				   3/12
+ 				   ----
+ lib/readline/doc/rltech.texinfo
+ 	- documented rl_set_paren_blink_timeout()
+ 	- moved the example function to its own info node
+ 
+ lib/readline/{hstech.texinfo,history.3}
+ 	- `$' is not in the default value of history_word_delimiters
+ 
+ 				   3/13
+ 				   ----
+ bashline.c
+ 	- in maybe_add_history, if the tests for HISTCONTROL succeed, but
+ 	  the HISTIGNORE check fails, set first_line_saved to 0
+ 
+ 				   3/15
+ 				   ----
+ 
+ lib/glob/fnmatch.c
+ 	- fixed a bug in patscan that caused `[' to be treated as special
+ 	  even inside a nested bracket expression.  It's supposed to lose
+ 	  it's special handling inside []
+ 	- fixed a bug in patscan that caused `]' to end an embedded bracket
+ 	  expression even if it was the first character after the `[' (or
+ 	  a leading `!' or `^')
+ 
+ 				   3/22
+ 				   ----
+ execute_cmd.c
+ 	- made a small change to shell_execve to report a more user-friendly
+ 	  error if execve(2) fails because of a `#! interpreter' error with
+ 	  `interpreter'
+ 	- in shell_execve, if HAVE_HASH_BANG_EXEC is not defined, make sure
+ 	  the file length is > 2 characters before attempting to execute an
+ 	  interpreter
+ 
+ 				   3/26
+ 				   ----
+ jobs.c, nojobs.c
+ 	- give_terminal_to now takes a second argument, FORCE.  If that
+ 	  second argument is non-zero, give the terminal away no matter
+ 	  what job_control is set to
+ 
+ jobs.h
+ 	- changed extern declaration of give_terminal_to
+ 
+ {jobs,sig,subst}.c,parse.y
+ 	- changed all calls to give_terminal_to to add a second argument
+ 	  of 0
+ 
+ jobs.c
+ 	- changed second argument of call to give_terminal_to in
+ 	  end_job_control to 1, to force this even if job_control is 0.
+ 	  This fixes the problem of `exec other-job-control-shell' in a
+ 	  startup file hanging, since run_startup_files sets job_control to 0
+ 
+ subst.c
+ 	- fixed test of subshell_environment in command_substitute to test the
+ 	  bit SUBSHELL_ASYNC rather than test equality, since it's now a
+ 	  bitmask
+ 
+ 				   3/27
+ 				   ----
+ shell.c
+ 	- changed posix initialization calls to set POSIXLY_CORRECT=y and
+ 	  then call sv_strict_posix, so $SHELLOPTS includes `posix' and
+ 	  POSIXLY_CORRECT is set, for both the posix command line options
+ 	  and when act_like_sh is non-zero
+ 
+ redir.c
+ 	- the `>& filename' redirection now works in posix mode, redirecting
+ 	  stdout and stderr, since POSIX.2 leaves it unspecified
+ 
+ doc/bashref.texi
+ 	- removed item about `>& filename' from Bash POSIX Mode section
+ 
+ parse.y
+ 	- fixed a problem in decode_prompt_string with `\W' not printing
+ 	  anything if PWD == "//"
+ 
+ lib/readline/input.c
+ 	- in rl_read_key, after calling (*rl_event_hook), check for rl_done
+ 	  being set, and return '\n' if it is
+ 
+ Makefile.in
+ 	- changed RELSTATUS to `release'
+ 
+ 				   3/28
+ 				   ----
+ support/bashbug.sh
+ 	- replace use of $(...) with `...` for the benefit of old versions
+ 	  of sh
+ 
+ builtins/set.def
+ 	- changed print_all_shell_variables to not print shell function names
+ 	  and definitions when in posix mode
+ 
+ doc/bashref.texi
+ 	- noted change in `set' behavior in posix mode section
+ 
+ 				    4/2
+ 				    ---
+ lib/readline/readline.c
+ 	- changed default value of RL_LIBRARY_VERSION to `4.2'
+ 
+ 				    4/5
+ 				    ---
+ [bash-2.05-release frozen]
diff -Nrc2 bash-2.04/CWRU/maildir-patch bash-2.05/CWRU/maildir-patch
*** bash-2.04/CWRU/maildir-patch	Wed Dec 31 19:00:00 1969
--- bash-2.05/CWRU/maildir-patch	Mon Nov 27 11:26:32 2000
***************
*** 0 ****
--- 1,175 ----
+ # DP: From: Miquel van Smoorenburg <miquels@cistron.nl>
+ # DP: A patch that adds support for Maildir type mailboxes.
+ 
+ --- ./mailcheck.c.orig	Wed Feb  4 21:30:33 1998
+ +++ ./mailcheck.c	Sun Nov 14 15:35:07 1999
+ @@ -21,8 +21,10 @@
+  #include "config.h"
+  
+  #include <stdio.h>
+ +#include <errno.h>
+  #include "bashtypes.h"
+  #include "posixstat.h"
+ +#include "posixdir.h"
+  #ifndef _MINIX
+  #  include <sys/param.h>
+  #endif
+ @@ -37,6 +39,8 @@
+  #include "mailcheck.h"
+  #include <tilde/tilde.h>
+  
+ +#include "mailstat.c"
+ +
+  #ifndef NOW
+  #define NOW ((time_t)time ((time_t *)0))
+  #endif
+ @@ -131,7 +135,7 @@
+    struct stat finfo;
+  
+    file = mailfiles[i]->name;
+ -  if (stat (file, &finfo) == 0)
+ +  if (mailstat (file, &finfo) == 0)
+      {
+        mailfiles[i]->access_time = finfo.st_atime;
+        mailfiles[i]->mod_time = finfo.st_mtime;
+ @@ -155,7 +159,7 @@
+    i = find_mail_file (filename);
+    if (i >= 0)
+      {
+ -      if (stat (filename, &finfo) == 0)
+ +      if (mailstat (filename, &finfo) == 0)
+  	{
+  	  mailfiles[i]->mod_time = finfo.st_mtime;
+  	  mailfiles[i]->access_time = finfo.st_atime;
+ @@ -221,7 +225,7 @@
+    file = mailfiles[i]->name;
+    mtime = mailfiles[i]->mod_time;
+  
+ -  if ((stat (file, &finfo) == 0) && (finfo.st_size > 0))
+ +  if ((mailstat (file, &finfo) == 0) && (finfo.st_size > 0))
+      return (mtime != finfo.st_mtime);
+  
+    return (0);
+ @@ -239,7 +243,7 @@
+    file = mailfiles[i]->name;
+    atime = mailfiles[i]->access_time;
+  
+ -  if ((stat (file, &finfo) == 0) && (finfo.st_size > 0))
+ +  if ((mailstat (file, &finfo) == 0) && (finfo.st_size > 0))
+      return (atime != finfo.st_atime);
+  
+    return (0);
+ @@ -257,7 +261,7 @@
+    file = mailfiles[i]->name;
+    size = mailfiles[i]->file_size;
+  
+ -  return ((stat (file, &finfo) == 0) && (finfo.st_size > size));
+ +  return ((mailstat (file, &finfo) == 0) && (finfo.st_size > size));
+  }
+  
+  /* Take an element from $MAILPATH and return the portion from
+ 
+ 
+ diff -ruN bash-2.01.1.b4/mailstat.c bash-2.01.1/mailstat.c
+ --- bash-2.01.1.b4/mailstat.c   Thu Jan  1 01:00:00 1970
+ +++ bash-2.01.1/mailstat.c      Wed Jun  2 12:05:04 1999
+ @@ -0,0 +1,98 @@
+ +/*
+ + *     Stat a file. If it's a maildir, check all messages
+ + *     in the maildir and present the grand total as a file.
+ + *     The fields in the 'struct stat' are from the mail directory.
+ + *     The following fields are emulated:
+ + *
+ + *     st_nlink        always 1
+ + *     st_size         total number of bytes in all files
+ + *     st_blocks       total number of messages
+ + *     st_atime        access time of newest file in maildir
+ + *     st_mtime        modify time of newest file in maildir
+ + *     st_mode         S_IFDIR changed to S_IFREG
+ + *
+ + *     This is good enough for most mail-checking applications.
+ + */
+ +int
+ +mailstat(char *path, struct stat *st)
+ +{
+ +       DIR                     *dd;
+ +       struct                  dirent *fn;
+ +       struct stat             st_ret, st_tmp;
+ +       static struct stat      st_new_last, st_ret_last;
+ +       char                    dir[PATH_MAX * 2];
+ +       char                    file[PATH_MAX * 2];
+ +       int                     i, l;
+ +       time_t                  atime = 0, mtime = 0;
+ +
+ +       /* First see if it's a directory. */
+ +       if ((i = stat(path, st)) != 0 || !S_ISDIR(st->st_mode))
+ +               return i;
+ +       if (strlen(path) > sizeof(dir) - 5) {
+ +               errno = ENAMETOOLONG;
+ +               return -1;
+ +       }
+ +
+ +       st_ret = *st;
+ +       st_ret.st_nlink = 1;
+ +       st_ret.st_size  = 0;
+ +       st_ret.st_blocks  = 0;
+ +       st_ret.st_mode  &= ~S_IFDIR;
+ +       st_ret.st_mode  |= S_IFREG;
+ +
+ +       /* See if cur/ is present */
+ +       sprintf(dir, "%s/cur", path);
+ +       if (stat(dir, &st_tmp) || !S_ISDIR(st_tmp.st_mode)) return 0;
+ +       st_ret.st_atime = st_tmp.st_atime;
+ +
+ +       /* See if tmp/ is present */
+ +       sprintf(dir, "%s/tmp", path);
+ +       if (stat(dir, &st_tmp) || !S_ISDIR(st_tmp.st_mode)) return 0;
+ +       st_ret.st_mtime = st_tmp.st_mtime;
+ +
+ +       /* And new/ */
+ +       sprintf(dir, "%s/new", path);
+ +       if (stat(dir, &st_tmp) || !S_ISDIR(st_tmp.st_mode)) return 0;
+ +       st_ret.st_mtime = st_tmp.st_mtime;
+ +
+ +       /* Optimization - if new/ didn't change, nothing else did. */
+ +       if (st_tmp.st_dev == st_new_last.st_dev &&
+ +           st_tmp.st_ino == st_new_last.st_ino &&
+ +           st_tmp.st_atime == st_new_last.st_atime &&
+ +           st_tmp.st_mtime == st_new_last.st_mtime) {
+ +               *st = st_ret_last;
+ +               return 0;
+ +       }
+ +       st_new_last = st_tmp;
+ +
+ +       /* Loop over new/ and cur/ */
+ +       for (i = 0; i < 2; i++) {
+ +               sprintf(dir, "%s/%s", path, i ? "cur" : "new");
+ +               sprintf(file, "%s/", dir);
+ +               l = strlen(file);
+ +               if ((dd = opendir(dir)) == NULL)
+ +                       return 0;
+ +               while ((fn = readdir(dd)) != NULL) {
+ +                       if (fn->d_name[0] == '.' ||
+ +                           strlen(fn->d_name) + l >= sizeof(file))
+ +                               continue;
+ +                       strcpy(file + l, fn->d_name);
+ +                       if (stat(file, &st_tmp) != 0)
+ +                               continue;
+ +                       st_ret.st_size += st_tmp.st_size;
+ +                       st_ret.st_blocks++;
+ +                       if (st_tmp.st_atime != st_tmp.st_mtime &&
+ +                           st_tmp.st_atime > atime)
+ +                               atime = st_tmp.st_atime;
+ +                       if (st_tmp.st_mtime > mtime)
+ +                               mtime = st_tmp.st_mtime;
+ +               }
+ +               closedir(dd);
+ +       }
+ +
+ +       if (atime) st_ret.st_atime = atime;
+ +       if (mtime) st_ret.st_mtime = mtime;
+ +
+ +       *st = st_ret_last = st_ret;
+ +       return 0;
+ +}
+ 
diff -Nrc2 bash-2.04/INSTALL bash-2.05/INSTALL
*** bash-2.04/INSTALL	Mon Mar  6 11:51:48 2000
--- bash-2.05/INSTALL	Thu Mar  8 10:44:18 2001
***************
*** 256,273 ****
  `--enable-alias'
       Allow alias expansion and include the `alias' and `unalias'
!      builtins (*note Aliases::.).
  
  `--enable-arith-for-command'
       Include support for the alternate form of the `for' command that
       behaves like the C language `for' statement (*note Looping
!      Constructs::.).
  
  `--enable-array-variables'
       Include support for one-dimensional array shell variables (*note
!      Arrays::.).
  
  `--enable-bang-history'
       Include support for `csh'-like history substitution (*note History
!      Interaction::.).
  
  `--enable-brace-expansion'
--- 256,273 ----
  `--enable-alias'
       Allow alias expansion and include the `alias' and `unalias'
!      builtins (*note Aliases::).
  
  `--enable-arith-for-command'
       Include support for the alternate form of the `for' command that
       behaves like the C language `for' statement (*note Looping
!      Constructs::).
  
  `--enable-array-variables'
       Include support for one-dimensional array shell variables (*note
!      Arrays::).
  
  `--enable-bang-history'
       Include support for `csh'-like history substitution (*note History
!      Interaction::).
  
  `--enable-brace-expansion'
***************
*** 278,291 ****
       Include support for recognizing `time' as a reserved word and for
       displaying timing statistics for the pipeline following `time'
!      (*note Pipelines::.).  This allows pipelines as well as shell
       builtins and functions to be timed.
  
  `--enable-cond-command'
       Include support for the `[[' conditional command (*note
!      Conditional Constructs::.).
  
  `--enable-directory-stack'
       Include support for a `csh'-like directory stack and the `pushd',
!      `popd', and `dirs' builtins (*note The Directory Stack::.).
  
  `--enable-disabled-builtins'
--- 278,291 ----
       Include support for recognizing `time' as a reserved word and for
       displaying timing statistics for the pipeline following `time'
!      (*note Pipelines::).  This allows pipelines as well as shell
       builtins and functions to be timed.
  
  `--enable-cond-command'
       Include support for the `[[' conditional command (*note
!      Conditional Constructs::).
  
  `--enable-directory-stack'
       Include support for a `csh'-like directory stack and the `pushd',
!      `popd', and `dirs' builtins (*note The Directory Stack::).
  
  `--enable-disabled-builtins'
***************
*** 297,301 ****
  `--enable-dparen-arithmetic'
       Include support for the `((...))' command (*note Conditional
!      Constructs::.).
  
  `--enable-extended-glob'
--- 297,301 ----
  `--enable-dparen-arithmetic'
       Include support for the `((...))' command (*note Conditional
!      Constructs::).
  
  `--enable-extended-glob'
***************
*** 305,316 ****
  `--enable-help-builtin'
       Include the `help' builtin, which displays help on shell builtins
!      and variables (*note Bash Builtins::.).
  
  `--enable-history'
       Include command history and the `fc' and `history' builtin
!      commands (*note Bash History Facilities::.).
  
  `--enable-job-control'
!      This enables the job control features (*note Job Control::.), if
       the operating system supports them.
  
--- 305,316 ----
  `--enable-help-builtin'
       Include the `help' builtin, which displays help on shell builtins
!      and variables (*note Bash Builtins::).
  
  `--enable-history'
       Include command history and the `fc' and `history' builtin
!      commands (*note Bash History Facilities::).
  
  `--enable-job-control'
!      This enables the job control features (*note Job Control::), if
       the operating system supports them.
  
***************
*** 318,326 ****
       This enables the special handling of filenames of the form
       `/dev/tcp/HOST/PORT' and `/dev/udp/HOST/PORT' when used in
!      redirections (*note Redirections::.).
  
  `--enable-process-substitution'
!      This enables process substitution (*note Process Substitution::.)
!      if the operating system provides the necessary support.
  
  `--enable-prompt-string-decoding'
--- 318,326 ----
       This enables the special handling of filenames of the form
       `/dev/tcp/HOST/PORT' and `/dev/udp/HOST/PORT' when used in
!      redirections (*note Redirections::).
  
  `--enable-process-substitution'
!      This enables process substitution (*note Process Substitution::) if
!      the operating system provides the necessary support.
  
  `--enable-prompt-string-decoding'
***************
*** 332,341 ****
  `--enable-progcomp'
       Enable the programmable completion facilities (*note Programmable
!      Completion::.).  If Readline is not enabled, this option has no
       effect.
  
  `--enable-readline'
       Include support for command-line editing and history with the Bash
!      version of the Readline library (*note Command Line Editing::.).
  
  `--enable-restricted'
--- 332,341 ----
  `--enable-progcomp'
       Enable the programmable completion facilities (*note Programmable
!      Completion::).  If Readline is not enabled, this option has no
       effect.
  
  `--enable-readline'
       Include support for command-line editing and history with the Bash
!      version of the Readline library (*note Command Line Editing::).
  
  `--enable-restricted'
***************
*** 346,350 ****
  `--enable-select'
       Include the `select' builtin, which allows the generation of simple
!      menus (*note Conditional Constructs::.).
  
  `--enable-usg-echo-default'
--- 346,350 ----
  `--enable-select'
       Include the `select' builtin, which allows the generation of simple
!      menus (*note Conditional Constructs::).
  
  `--enable-usg-echo-default'
diff -Nrc2 bash-2.04/MANIFEST bash-2.05/MANIFEST
*** bash-2.04/MANIFEST	Tue Jan 25 11:37:55 2000
--- bash-2.05/MANIFEST	Tue Mar 20 09:35:19 2001
***************
*** 96,99 ****
--- 96,100 ----
  pcomplete.c	f
  pcomplib.c	f
+ mksyntax.c	f
  alias.h		f
  builtins.h	f
***************
*** 108,111 ****
--- 109,113 ----
  flags.h		f
  shell.h		f
+ syntax.h	f
  pathexp.h	f
  parser.h	f
***************
*** 252,255 ****
--- 254,258 ----
  lib/readline/parens.c	f
  lib/readline/rltty.c	f
+ lib/readline/compat.c	f
  lib/readline/complete.c	f
  lib/readline/bind.c	f
***************
*** 270,273 ****
--- 273,277 ----
  lib/readline/rlshell.h	f
  lib/readline/rltty.h	f
+ lib/readline/rltypedefs.h	f
  lib/readline/rlwinsize.h	f
  lib/readline/readline.h	f
***************
*** 311,326 ****
--- 315,338 ----
  lib/sh/netopen.c	f
  lib/sh/oslib.c		f
+ lib/sh/pathcanon.c	f
+ lib/sh/pathphys.c	f
  lib/sh/rename.c		f
  lib/sh/setlinebuf.c	f
  lib/sh/shquote.c	f
  lib/sh/shtty.c		f
+ lib/sh/spell.c		f
  lib/sh/strcasecmp.c	f
  lib/sh/strerror.c	f
+ lib/sh/strindex.c	f
+ lib/sh/stringlist.c	f
+ lib/sh/stringvec.c	f
  lib/sh/strpbrk.c	f
  lib/sh/strtod.c		f
  lib/sh/strtol.c		f
  lib/sh/strtoul.c	f
+ lib/sh/strtrans.c	f
  lib/sh/times.c		f
  lib/sh/timeval.c	f
+ lib/sh/tmpfile.c	f
  lib/sh/vprint.c		f
  lib/sh/zread.c		f
***************
*** 368,371 ****
--- 380,384 ----
  CWRU/sh-redir-hack	f
  CWRU/empty-for-wordlist	f
+ CWRU/maildir-patch	f
  CWRU/mh-folder-comp	f
  doc/FAQ		f
***************
*** 377,381 ****
  doc/README	f
  doc/INTRO	f
- doc/readline.3	f
  doc/texinfo.tex	f
  doc/bashref.texi	f
--- 390,393 ----
***************
*** 413,416 ****
--- 425,431 ----
  examples/bashdb/bashdb.pre	f
  examples/complete/complete-examples	f
+ examples/complete/complete.ianmac	f
+ examples/complete/complete2.ianmac	f
+ examples/complete/complete.freebsd	f
  examples/loadables/README	f
  examples/loadables/template.c	f
***************
*** 419,422 ****
--- 434,438 ----
  examples/loadables/hello.c	f
  examples/loadables/print.c	f
+ examples/loadables/realpath.c	f
  examples/loadables/sprintf.c	f
  examples/loadables/sleep.c	f
***************
*** 425,428 ****
--- 441,445 ----
  examples/loadables/finfo.c	f
  examples/loadables/cat.c	f
+ examples/loadables/cut.c	f
  examples/loadables/logname.c	f
  examples/loadables/basename.c	f
***************
*** 434,437 ****
--- 451,455 ----
  examples/loadables/head.c	f
  examples/loadables/printenv.c	f
+ examples/loadables/push.c	f
  examples/loadables/id.c		f
  examples/loadables/whoami.c	f
***************
*** 446,449 ****
--- 464,468 ----
  examples/loadables/perl/iperl.c	f
  examples/functions/array-stuff	f
+ examples/functions/array-to-string	f
  examples/functions/autoload	f
  examples/functions/autoload.v2	f
***************
*** 454,457 ****
--- 473,477 ----
  examples/functions/dirfuncs	f
  examples/functions/dirname	f
+ examples/functions/emptydir	f
  examples/functions/exitstat	f
  examples/functions/external	f
***************
*** 459,462 ****
--- 479,483 ----
  examples/functions/fstty	f
  examples/functions/func		f
+ examples/functions/gethtml	f
  examples/functions/getoptx.bash	f
  examples/functions/inetaddr	f
***************
*** 467,470 ****
--- 488,492 ----
  examples/functions/jj.bash	f
  examples/functions/keep		f
+ examples/functions/ksh-cd	f
  examples/functions/ksh-compat-test	f
  examples/functions/kshenv	f
***************
*** 475,478 ****
--- 497,501 ----
  examples/functions/notify.bash	f
  examples/functions/pathfuncs	f
+ examples/functions/recurse	f
  examples/functions/repeat2	f
  examples/functions/repeat3	f
***************
*** 481,484 ****
--- 504,508 ----
  examples/functions/shcat	f
  examples/functions/shcat2	f
+ examples/functions/sort-pos-params	f
  examples/functions/substr	f
  examples/functions/substr2	f
***************
*** 491,495 ****
--- 515,521 ----
  examples/scripts/adventure.sh	f
  examples/scripts/bcsh.sh	f
+ examples/scripts/cat.sh		f
  examples/scripts/center		f
+ examples/scripts/dd-ex.sh	f
  examples/scripts/fixfiles.bash	f
  examples/scripts/hanoi.bash	f
***************
*** 568,571 ****
--- 594,598 ----
  tests/exec4.sub		f
  tests/exec5.sub		f
+ tests/exec6.sub		f
  tests/exp-tests		f
  tests/exp.right		f
***************
*** 577,580 ****
--- 604,609 ----
  tests/func.right	f
  tests/func1.sub		f
+ tests/func2.sub		f
+ tests/func3.sub		f
  tests/getopts.tests	f
  tests/getopts.right	f
***************
*** 713,716 ****
--- 742,746 ----
  tests/varenv.right	f
  tests/varenv.sh		f
+ tests/varenv1.sub	f
  tests/version		f
  tests/version.mini	f
diff -Nrc2 bash-2.04/Makefile.in bash-2.05/Makefile.in
*** bash-2.04/Makefile.in	Wed Mar  1 14:52:12 2000
--- bash-2.05/Makefile.in	Tue Apr  3 15:03:24 2001
***************
*** 1,3 ****
! # Makefile for bash-2.04, version 2.115
  #
  # Copyright (C) 1996 Free Software Foundation, Inc.
--- 1,3 ----
! # Makefile for bash-2.05, version 2.120
  #
  # Copyright (C) 1996 Free Software Foundation, Inc.
***************
*** 86,89 ****
--- 86,92 ----
  MACHTYPE = @host@
  
+ # comment out for release
+ # DEBUG = -DDEBUG
+ 
  THIS_SH = $(BUILD_DIR)/$(Program)
  
***************
*** 97,101 ****
  CFLAGS = @CFLAGS@
  CPPFLAGS = @CPPFLAGS@
! LOCAL_CFLAGS = @LOCAL_CFLAGS@
  DEFS = @DEFS@
  LOCAL_DEFS = @LOCAL_DEFS@
--- 100,104 ----
  CFLAGS = @CFLAGS@
  CPPFLAGS = @CPPFLAGS@
! LOCAL_CFLAGS = @LOCAL_CFLAGS@ ${DEBUG}
  DEFS = @DEFS@
  LOCAL_DEFS = @LOCAL_DEFS@
***************
*** 147,151 ****
  	       ${SH_LIBSRC}/netopen.c ${SH_LIBSRC}/strpbrk.c \
  	       ${SH_LIBSRC}/timeval.c ${SH_LIBSRC}/clock.c \
! 	       ${SH_LIBSRC}/makepath.c
  
  SHLIB_LIB = -lsh
--- 150,158 ----
  	       ${SH_LIBSRC}/netopen.c ${SH_LIBSRC}/strpbrk.c \
  	       ${SH_LIBSRC}/timeval.c ${SH_LIBSRC}/clock.c \
! 	       ${SH_LIBSRC}/makepath.c ${SH_LIBSRC}/pathcanon.c \
! 	       ${SH_LIBSRC}/pathphys.c ${SH_LIBSRC}/stringlist.c \
! 	       ${SH_LIBSRC}/stringvec.c ${SH_LIBSRC}/tmpfile.c \
! 	       ${SH_LIBSRC}/spell.c ${SH_LIBSRC}/strtrans.c \
! 	       ${SH_LIBSRC}/strindex.c ${SH_LIBSRC}/shquote.c
  
  SHLIB_LIB = -lsh
***************
*** 187,190 ****
--- 194,198 ----
  		  $(RL_LIBSRC)/input.c $(RL_LIBSRC)/xmalloc.c \
  		  $(RL_LIBSRC)/shell.c $(RL_LIBSRC)/savestring.c \
+ 		  $(RL_LIBSRC)/compat.c \
  		  $(RL_LIBSRC)/histexpand.c $(RL_LIBSRC)/history.c \
  		  $(RL_LIBSRC)/histsearch.c $(RL_LIBSRC)/histfile.c
***************
*** 201,204 ****
--- 209,213 ----
  		  $(RL_LIBDIR)/terminal.o $(RL_LIBDIR)/callback.o \
  		  $(RL_LIBDIR)/shell.o $(RL_LIBDIR)/savestring.o \
+ 		  $(RL_LIBDIR)/compat.o \
  		  $(RL_LIBDIR)/history.o $(RL_LIBDIR)/histexpand.o \
  		  $(RL_LIBDIR)/histsearch.o $(RL_LIBDIR)/histfile.o
***************
*** 296,304 ****
  		 $(BASHINCDIR)/shtty.h
  
! LIBRARIES = $(READLINE_LIB) $(HISTORY_LIB) $(TERMCAP_LIB) $(GLOB_LIB) \
! 	    $(TILDE_LIB) $(MALLOC_LIB) $(SHLIB_LIB) $(LOCAL_LIBS)
  
! LIBDEP = $(READLINE_DEP) $(HISTORY_DEP) $(TERMCAP_DEP) $(GLOB_DEP) \
! 	 $(TILDE_DEP) $(MALLOC_DEP) $(SHLIB_DEP)
  
  LIBRARY_LDFLAGS = $(READLINE_LDFLAGS) $(HISTORY_LDFLAGS) $(GLOB_LDFLAGS) \
--- 305,313 ----
  		 $(BASHINCDIR)/shtty.h
  
! LIBRARIES = $(SHLIB_LIB) $(READLINE_LIB) $(HISTORY_LIB) $(TERMCAP_LIB) $(GLOB_LIB) \
! 	    $(TILDE_LIB) $(MALLOC_LIB) $(LOCAL_LIBS)
  
! LIBDEP = $(SHLIB_DEP) $(READLINE_DEP) $(HISTORY_DEP) $(TERMCAP_DEP) $(GLOB_DEP) \
! 	 $(TILDE_DEP) $(MALLOC_DEP)
  
  LIBRARY_LDFLAGS = $(READLINE_LDFLAGS) $(HISTORY_LDFLAGS) $(GLOB_LDFLAGS) \
***************
*** 317,325 ****
  	   unwind_prot.c siglist.c bashline.c bracecomp.c error.c \
  	   list.c stringlib.c locale.c findcmd.c redir.c \
! 	   pcomplete.c pcomplib.c xmalloc.c
  
  HSOURCES = shell.h flags.h trap.h hashcmd.h hashlib.h jobs.h builtins.h \
  	   general.h variables.h config.h $(ALLOC_HEADERS) alias.h \
! 	   quit.h unwind_prot.h \
  	   command.h input.h error.h bashansi.h dispose_cmd.h make_cmd.h \
  	   subst.h externs.h siglist.h bashhist.h bashline.h bashtypes.h \
--- 326,334 ----
  	   unwind_prot.c siglist.c bashline.c bracecomp.c error.c \
  	   list.c stringlib.c locale.c findcmd.c redir.c \
! 	   pcomplete.c pcomplib.c syntax.c xmalloc.c
  
  HSOURCES = shell.h flags.h trap.h hashcmd.h hashlib.h jobs.h builtins.h \
  	   general.h variables.h config.h $(ALLOC_HEADERS) alias.h \
! 	   quit.h unwind_prot.h syntax.h \
  	   command.h input.h error.h bashansi.h dispose_cmd.h make_cmd.h \
  	   subst.h externs.h siglist.h bashhist.h bashline.h bashtypes.h \
***************
*** 343,347 ****
  	   alias.o array.o braces.o bracecomp.o bashhist.o bashline.o \
  	   siglist.o list.o stringlib.o locale.o findcmd.o redir.o \
! 	   pcomplete.o pcomplib.o xmalloc.o
  
  # Where the source code of the shell builtins resides.
--- 352,356 ----
  	   alias.o array.o braces.o bracecomp.o bashhist.o bashline.o \
  	   siglist.o list.o stringlib.o locale.o findcmd.o redir.o \
! 	   pcomplete.o pcomplib.o syntax.o xmalloc.o
  
  # Where the source code of the shell builtins resides.
***************
*** 405,409 ****
  CREATED_SUPPORT = signames.h recho$(EXEEXT) zecho$(EXEEXT) printenv$(EXEEXT) \
  		  tests/recho$(EXEEXT) tests/zecho$(EXEEXT) \
! 		  tests/printenv$(EXEEXT) mksignames$(EXEEXT) lsignames.h
  CREATED_CONFIGURE = config.h config.cache config.status config.log \
  		    stamp-h
--- 414,419 ----
  CREATED_SUPPORT = signames.h recho$(EXEEXT) zecho$(EXEEXT) printenv$(EXEEXT) \
  		  tests/recho$(EXEEXT) tests/zecho$(EXEEXT) \
! 		  tests/printenv$(EXEEXT) mksignames$(EXEEXT) lsignames.h \
! 		  mksyntax${EXEEXT} syntax.c
  CREATED_CONFIGURE = config.h config.cache config.status config.log \
  		    stamp-h
***************
*** 504,507 ****
--- 514,520 ----
  	$(CC_FOR_BUILD) $(CCFLAGS) $(CPPFLAGS) -o $@ $(SUPPORT_SRC)mksignames.c
  
+ mksyntax$(EXEEXT):	${srcdir}/mksyntax.c config.h syntax.h
+ 	${CC_FOR_BUILD} ${CCFLAGS} ${CPPFLAGS} -o $@ ${srcdir}/mksyntax.c
+ 
  # make a list of signals for the local system -- this is done when we're
  # *not* cross-compiling
***************
*** 514,517 ****
--- 527,534 ----
  	-if cmp -s $(SIGNAMES_H) $@ ; then :; else $(RM) $@ ; $(CP) $(SIGNAMES_H) $@ ; fi
  
+ syntax.c:	mksyntax${EXEEXT} $(srcdir)/syntax.h 
+ 	$(RM) $@
+ 	./mksyntax -o $@
+ 
  $(BUILTINS_LIBRARY): $(BUILTIN_DEFS) $(BUILTIN_C_SRC) config.h ${BASHINCDIR}/memalloc.h
  	@(cd $(DEFDIR) && $(MAKE) $(MFLAGS) libbuiltins.a ) || exit 1
***************
*** 707,716 ****
  
  # shell basics
! copy_cmd.o: shell.h config.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h ${BASHINCDIR}/stdc.h error.h
  copy_cmd.o: general.h bashtypes.h variables.h array.h hashlib.h
  copy_cmd.o: quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
  copy_cmd.o: make_cmd.h subst.h sig.h pathnames.h externs.h
  dispose_cmd.o: bashansi.h ${BASHINCDIR}/ansi_stdlib.h
! dispose_cmd.o: shell.h config.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h ${BASHINCDIR}/stdc.h
  dispose_cmd.o: error.h general.h bashtypes.h variables.h array.h hashlib.h
  dispose_cmd.o: quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
--- 724,733 ----
  
  # shell basics
! copy_cmd.o: shell.h syntax.h config.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h ${BASHINCDIR}/stdc.h error.h
  copy_cmd.o: general.h bashtypes.h variables.h array.h hashlib.h
  copy_cmd.o: quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
  copy_cmd.o: make_cmd.h subst.h sig.h pathnames.h externs.h
  dispose_cmd.o: bashansi.h ${BASHINCDIR}/ansi_stdlib.h
! dispose_cmd.o: shell.h syntax.h config.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h ${BASHINCDIR}/stdc.h
  dispose_cmd.o: error.h general.h bashtypes.h variables.h array.h hashlib.h
  dispose_cmd.o: quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
***************
*** 719,723 ****
  error.o: command.h general.h externs.h input.h bashhist.h
  eval.o: config.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h trap.h flags.h ${DEFSRC}/common.h
! eval.o: shell.h config.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h ${BASHINCDIR}/stdc.h error.h
  eval.o: general.h bashtypes.h variables.h array.h hashlib.h
  eval.o: quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
--- 736,740 ----
  error.o: command.h general.h externs.h input.h bashhist.h
  eval.o: config.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h trap.h flags.h ${DEFSRC}/common.h
! eval.o: shell.h syntax.h config.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h ${BASHINCDIR}/stdc.h error.h
  eval.o: general.h bashtypes.h variables.h array.h hashlib.h
  eval.o: quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
***************
*** 725,729 ****
  eval.o: input.h execute_cmd.h
  execute_cmd.o: config.h bashtypes.h ${BASHINCDIR}/filecntl.h ${BASHINCDIR}/posixstat.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h
! execute_cmd.o: shell.h config.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h ${BASHINCDIR}/stdc.h error.h
  execute_cmd.o: general.h bashtypes.h variables.h array.h hashlib.h
  execute_cmd.o: quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
--- 742,746 ----
  eval.o: input.h execute_cmd.h
  execute_cmd.o: config.h bashtypes.h ${BASHINCDIR}/filecntl.h ${BASHINCDIR}/posixstat.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h
! execute_cmd.o: shell.h syntax.h config.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h ${BASHINCDIR}/stdc.h error.h
  execute_cmd.o: general.h bashtypes.h variables.h array.h hashlib.h
  execute_cmd.o: quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
***************
*** 734,753 ****
  execute_cmd.o: ${BASHINCDIR}/posixtime.h
  expr.o: config.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h
! expr.o: shell.h config.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h ${BASHINCDIR}/stdc.h error.h
  expr.o: general.h bashtypes.h variables.h array.h hashlib.h
  expr.o: quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
  expr.o: make_cmd.h subst.h sig.h pathnames.h externs.h
  findcmd.o: config.h bashtypes.h ${BASHINCDIR}/filecntl.h ${BASHINCDIR}/posixstat.h bashansi.h
! findcmd.o: ${BASHINCDIR}/ansi_stdlib.h ${BASHINCDIR}/memalloc.h shell.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h
  findcmd.o: ${BASHINCDIR}/stdc.h error.h general.h variables.h quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h
  findcmd.o: dispose_cmd.h make_cmd.h subst.h sig.h pathnames.h externs.h
  findcmd.o: flags.h hashlib.h pathexp.h hashcmd.h 
  flags.o: config.h flags.h
! flags.o: shell.h config.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h ${BASHINCDIR}/stdc.h error.h
  flags.o: general.h bashtypes.h variables.h array.h hashlib.h
  flags.o: quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
  flags.o: make_cmd.h subst.h sig.h pathnames.h externs.h
  general.o: config.h bashtypes.h ${BASHINCDIR}/posixstat.h ${BASHINCDIR}/filecntl.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h
! general.o: shell.h config.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h ${BASHINCDIR}/stdc.h error.h
  general.o: general.h bashtypes.h variables.h array.h hashlib.h
  general.o: quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
--- 751,770 ----
  execute_cmd.o: ${BASHINCDIR}/posixtime.h
  expr.o: config.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h
! expr.o: shell.h syntax.h config.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h ${BASHINCDIR}/stdc.h error.h
  expr.o: general.h bashtypes.h variables.h array.h hashlib.h
  expr.o: quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
  expr.o: make_cmd.h subst.h sig.h pathnames.h externs.h
  findcmd.o: config.h bashtypes.h ${BASHINCDIR}/filecntl.h ${BASHINCDIR}/posixstat.h bashansi.h
! findcmd.o: ${BASHINCDIR}/ansi_stdlib.h ${BASHINCDIR}/memalloc.h shell.h syntax.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h
  findcmd.o: ${BASHINCDIR}/stdc.h error.h general.h variables.h quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h
  findcmd.o: dispose_cmd.h make_cmd.h subst.h sig.h pathnames.h externs.h
  findcmd.o: flags.h hashlib.h pathexp.h hashcmd.h 
  flags.o: config.h flags.h
! flags.o: shell.h syntax.h config.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h ${BASHINCDIR}/stdc.h error.h
  flags.o: general.h bashtypes.h variables.h array.h hashlib.h
  flags.o: quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
  flags.o: make_cmd.h subst.h sig.h pathnames.h externs.h
  general.o: config.h bashtypes.h ${BASHINCDIR}/posixstat.h ${BASHINCDIR}/filecntl.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h
! general.o: shell.h syntax.h config.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h ${BASHINCDIR}/stdc.h error.h
  general.o: general.h bashtypes.h variables.h array.h hashlib.h
  general.o: quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
***************
*** 755,763 ****
  general.o: ${BASHINCDIR}/maxpath.h ${BASHINCDIR}/posixtime.h
  hashcmd.o: config.h ${BASHINCDIR}/posixstat.h bashtypes.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h
! hashcmd.o: shell.h config.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h ${BASHINCDIR}/stdc.h error.h
  hashcmd.o: general.h bashtypes.h variables.h array.h hashcmd.h
  hashcmd.o: execute_cmd.h findcmd.h ${BASHINCDIR}/stdc.h
  hashlib.o: config.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h
! hashlib.o: shell.h config.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h ${BASHINCDIR}/stdc.h error.h
  hashlib.o: general.h bashtypes.h variables.h array.h hashlib.h
  hashlib.o: quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
--- 772,780 ----
  general.o: ${BASHINCDIR}/maxpath.h ${BASHINCDIR}/posixtime.h
  hashcmd.o: config.h ${BASHINCDIR}/posixstat.h bashtypes.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h
! hashcmd.o: shell.h syntax.h config.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h ${BASHINCDIR}/stdc.h error.h
  hashcmd.o: general.h bashtypes.h variables.h array.h hashcmd.h
  hashcmd.o: execute_cmd.h findcmd.h ${BASHINCDIR}/stdc.h
  hashlib.o: config.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h
! hashlib.o: shell.h syntax.h config.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h ${BASHINCDIR}/stdc.h error.h
  hashlib.o: general.h bashtypes.h variables.h array.h hashlib.h
  hashlib.o: quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
***************
*** 765,779 ****
  input.o: config.h bashtypes.h ${BASHINCDIR}/filecntl.h ${BASHINCDIR}/posixstat.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h
  input.o: command.h ${BASHINCDIR}/stdc.h general.h input.h error.h externs.h
! list.o: shell.h config.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h ${BASHINCDIR}/stdc.h error.h
  list.o: general.h bashtypes.h variables.h array.h hashlib.h
  list.o: quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
  list.o: make_cmd.h subst.h sig.h pathnames.h externs.h
  locale.o: config.h bashtypes.h bashintl.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h
! locale.o: shell.h config.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h ${BASHINCDIR}/stdc.h error.h
  locale.o: general.h bashtypes.h variables.h array.h hashlib.h
  locale.o: quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
  locale.o: make_cmd.h subst.h sig.h pathnames.h externs.h
  mailcheck.o: config.h bashtypes.h ${BASHINCDIR}/posixstat.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h
! mailcheck.o: shell.h config.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h ${BASHINCDIR}/stdc.h error.h
  mailcheck.o: general.h bashtypes.h variables.h array.h hashlib.h
  mailcheck.o: quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
--- 782,796 ----
  input.o: config.h bashtypes.h ${BASHINCDIR}/filecntl.h ${BASHINCDIR}/posixstat.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h
  input.o: command.h ${BASHINCDIR}/stdc.h general.h input.h error.h externs.h
! list.o: shell.h syntax.h config.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h ${BASHINCDIR}/stdc.h error.h
  list.o: general.h bashtypes.h variables.h array.h hashlib.h
  list.o: quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
  list.o: make_cmd.h subst.h sig.h pathnames.h externs.h
  locale.o: config.h bashtypes.h bashintl.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h
! locale.o: shell.h syntax.h config.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h ${BASHINCDIR}/stdc.h error.h
  locale.o: general.h bashtypes.h variables.h array.h hashlib.h
  locale.o: quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
  locale.o: make_cmd.h subst.h sig.h pathnames.h externs.h
  mailcheck.o: config.h bashtypes.h ${BASHINCDIR}/posixstat.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h
! mailcheck.o: shell.h syntax.h config.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h ${BASHINCDIR}/stdc.h error.h
  mailcheck.o: general.h bashtypes.h variables.h array.h hashlib.h
  mailcheck.o: quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
***************
*** 783,789 ****
  make_cmd.o: command.h ${BASHINCDIR}/stdc.h general.h error.h flags.h make_cmd.h
  make_cmd.o: variables.h array.h hashlib.h subst.h input.h externs.h
! make_cmd.o: jobs.h quit.h siglist.h
  y.tab.o: config.h bashtypes.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h ${BASHINCDIR}/memalloc.h
! y.tab.o: shell.h config.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h ${BASHINCDIR}/stdc.h error.h
  y.tab.o: general.h bashtypes.h variables.h array.h hashlib.h
  y.tab.o: quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
--- 800,806 ----
  make_cmd.o: command.h ${BASHINCDIR}/stdc.h general.h error.h flags.h make_cmd.h
  make_cmd.o: variables.h array.h hashlib.h subst.h input.h externs.h
! make_cmd.o: jobs.h quit.h siglist.h syntax.h
  y.tab.o: config.h bashtypes.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h ${BASHINCDIR}/memalloc.h
! y.tab.o: shell.h syntax.h config.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h ${BASHINCDIR}/stdc.h error.h
  y.tab.o: general.h bashtypes.h variables.h array.h hashlib.h
  y.tab.o: quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
***************
*** 792,796 ****
  y.tab.o: $(DEFDIR)/builtext.h bashline.h bashhist.h jobs.h siglist.h alias.h
  pathexp.o: config.h bashtypes.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h
! pathexp.o: shell.h config.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h ${BASHINCDIR}/stdc.h error.h
  pathexp.o: general.h bashtypes.h variables.h array.h hashlib.h
  pathexp.o: quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
--- 809,813 ----
  y.tab.o: $(DEFDIR)/builtext.h bashline.h bashhist.h jobs.h siglist.h alias.h
  pathexp.o: config.h bashtypes.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h
! pathexp.o: shell.h syntax.h config.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h ${BASHINCDIR}/stdc.h error.h
  pathexp.o: general.h bashtypes.h variables.h array.h hashlib.h
  pathexp.o: quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
***************
*** 799,803 ****
  pathexp.o: $(GLOB_LIBSRC)/glob.h $(GLOB_LIBSRC)/fnmatch.h
  print_cmd.o: config.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h
! print_cmd.o: shell.h config.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h ${BASHINCDIR}/stdc.h error.h
  print_cmd.o: general.h bashtypes.h variables.h array.h hashlib.h
  print_cmd.o: quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
--- 816,820 ----
  pathexp.o: $(GLOB_LIBSRC)/glob.h $(GLOB_LIBSRC)/fnmatch.h
  print_cmd.o: config.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h
! print_cmd.o: shell.h syntax.h config.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h ${BASHINCDIR}/stdc.h error.h
  print_cmd.o: general.h bashtypes.h variables.h array.h hashlib.h
  print_cmd.o: quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
***************
*** 805,814 ****
  print_cmd.o: ${GRAM_H} $(DEFSRC)/common.h
  redir.o: config.h bashtypes.h ${BASHINCDIR}/posixstat.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h ${BASHINCDIR}/filecntl.h
! redir.o: ${BASHINCDIR}/memalloc.h shell.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h ${BASHINCDIR}/stdc.h error.h
  redir.o: general.h variables.h array.h hashlib.h quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h
  redir.o: dispose_cmd.h make_cmd.h subst.h sig.h pathnames.h externs.h
  redir.o: flags.h execute_cmd.h redir.h input.h
  shell.o: config.h bashtypes.h ${BASHINCDIR}/posixstat.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h ${BASHINCDIR}/filecntl.h
! shell.o: shell.h config.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h ${BASHINCDIR}/stdc.h error.h
  shell.o: general.h bashtypes.h variables.h array.h hashlib.h
  shell.o: quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
--- 822,831 ----
  print_cmd.o: ${GRAM_H} $(DEFSRC)/common.h
  redir.o: config.h bashtypes.h ${BASHINCDIR}/posixstat.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h ${BASHINCDIR}/filecntl.h
! redir.o: ${BASHINCDIR}/memalloc.h shell.h syntax.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h ${BASHINCDIR}/stdc.h error.h
  redir.o: general.h variables.h array.h hashlib.h quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h
  redir.o: dispose_cmd.h make_cmd.h subst.h sig.h pathnames.h externs.h
  redir.o: flags.h execute_cmd.h redir.h input.h
  shell.o: config.h bashtypes.h ${BASHINCDIR}/posixstat.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h ${BASHINCDIR}/filecntl.h
! shell.o: shell.h syntax.h config.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h ${BASHINCDIR}/stdc.h error.h
  shell.o: general.h bashtypes.h variables.h array.h hashlib.h
  shell.o: quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
***************
*** 818,822 ****
  shell.o: ${GLOB_LIBSRC}/fnmatch.h
  sig.o: config.h bashtypes.h
! sig.o: shell.h config.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h ${BASHINCDIR}/stdc.h error.h
  sig.o: general.h bashtypes.h variables.h array.h hashlib.h
  sig.o: quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
--- 835,839 ----
  shell.o: ${GLOB_LIBSRC}/fnmatch.h
  sig.o: config.h bashtypes.h
! sig.o: shell.h syntax.h config.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h ${BASHINCDIR}/stdc.h error.h
  sig.o: general.h bashtypes.h variables.h array.h hashlib.h
  sig.o: quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
***************
*** 825,834 ****
  siglist.o: config.h bashtypes.h siglist.h trap.h
  stringlib.o: bashtypes.h
! stringlib.o: shell.h config.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h ${BASHINCDIR}/stdc.h error.h
  stringlib.o: general.h bashtypes.h variables.h array.h hashlib.h
  stringlib.o: quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
  stringlib.o: make_cmd.h subst.h sig.h pathnames.h externs.h
  subst.o: config.h bashtypes.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h ${BASHINCDIR}/posixstat.h
! subst.o: shell.h config.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h ${BASHINCDIR}/stdc.h error.h
  subst.o: general.h bashtypes.h variables.h array.h hashlib.h
  subst.o: quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
--- 842,851 ----
  siglist.o: config.h bashtypes.h siglist.h trap.h
  stringlib.o: bashtypes.h
! stringlib.o: shell.h syntax.h config.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h ${BASHINCDIR}/stdc.h error.h
  stringlib.o: general.h bashtypes.h variables.h array.h hashlib.h
  stringlib.o: quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
  stringlib.o: make_cmd.h subst.h sig.h pathnames.h externs.h
  subst.o: config.h bashtypes.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h ${BASHINCDIR}/posixstat.h
! subst.o: shell.h syntax.h config.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h ${BASHINCDIR}/stdc.h error.h
  subst.o: general.h bashtypes.h variables.h array.h hashlib.h
  subst.o: quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
***************
*** 838,842 ****
  subst.o: bashline.h bashhist.h ${GLOB_LIBSRC}/fnmatch.h
  test.o: bashtypes.h ${BASHINCDIR}/posixstat.h ${BASHINCDIR}/filecntl.h
! test.o: shell.h config.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h ${BASHINCDIR}/stdc.h error.h
  test.o: general.h bashtypes.h variables.h array.h hashlib.h
  test.o: quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
--- 855,859 ----
  subst.o: bashline.h bashhist.h ${GLOB_LIBSRC}/fnmatch.h
  test.o: bashtypes.h ${BASHINCDIR}/posixstat.h ${BASHINCDIR}/filecntl.h
! test.o: shell.h syntax.h config.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h ${BASHINCDIR}/stdc.h error.h
  test.o: general.h bashtypes.h variables.h array.h hashlib.h
  test.o: quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
***************
*** 844,848 ****
  test.o: ${DEFSRC}/common.h
  trap.o: config.h bashtypes.h trap.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h
! trap.o: shell.h config.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h ${BASHINCDIR}/stdc.h error.h
  trap.o: general.h bashtypes.h variables.h array.h hashlib.h
  trap.o: quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
--- 861,865 ----
  test.o: ${DEFSRC}/common.h
  trap.o: config.h bashtypes.h trap.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h
! trap.o: shell.h syntax.h config.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h ${BASHINCDIR}/stdc.h error.h
  trap.o: general.h bashtypes.h variables.h array.h hashlib.h
  trap.o: quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
***************
*** 852,856 ****
  unwind_prot.o: general.h unwind_prot.h quit.h sig.h
  variables.o: config.h bashtypes.h ${BASHINCDIR}/posixstat.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h
! variables.o: shell.h config.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h ${BASHINCDIR}/stdc.h error.h
  variables.o: general.h bashtypes.h variables.h array.h hashlib.h
  variables.o: quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
--- 869,873 ----
  unwind_prot.o: general.h unwind_prot.h quit.h sig.h
  variables.o: config.h bashtypes.h ${BASHINCDIR}/posixstat.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h
! variables.o: shell.h syntax.h config.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h ${BASHINCDIR}/stdc.h error.h
  variables.o: general.h bashtypes.h variables.h array.h hashlib.h
  variables.o: quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
***************
*** 866,870 ****
  jobs.o: config.h bashtypes.h trap.h ${BASHINCDIR}/filecntl.h input.h ${BASHINCDIR}/shtty.h
  jobs.o: bashansi.h ${BASHINCDIR}/ansi_stdlib.h
! jobs.o: shell.h config.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h ${BASHINCDIR}/stdc.h error.h
  jobs.o: general.h bashtypes.h variables.h array.h hashlib.h
  jobs.o: quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
--- 883,887 ----
  jobs.o: config.h bashtypes.h trap.h ${BASHINCDIR}/filecntl.h input.h ${BASHINCDIR}/shtty.h
  jobs.o: bashansi.h ${BASHINCDIR}/ansi_stdlib.h
! jobs.o: shell.h syntax.h config.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h ${BASHINCDIR}/stdc.h error.h
  jobs.o: general.h bashtypes.h variables.h array.h hashlib.h
  jobs.o: quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
***************
*** 879,883 ****
  
  array.o: config.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h
! array.o: shell.h config.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h ${BASHINCDIR}/stdc.h error.h
  array.o: general.h bashtypes.h variables.h array.h hashlib.h
  array.o: quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
--- 896,900 ----
  
  array.o: config.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h
! array.o: shell.h syntax.h config.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h ${BASHINCDIR}/stdc.h error.h
  array.o: general.h bashtypes.h variables.h array.h hashlib.h
  array.o: quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
***************
*** 885,889 ****
  array.o: $(DEFSRC)/common.h
  braces.o: config.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h
! braces.o: shell.h config.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h ${BASHINCDIR}/stdc.h error.h
  braces.o: general.h bashtypes.h variables.h array.h hashlib.h
  braces.o: quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
--- 902,906 ----
  array.o: $(DEFSRC)/common.h
  braces.o: config.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h
! braces.o: shell.h syntax.h config.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h ${BASHINCDIR}/stdc.h error.h
  braces.o: general.h bashtypes.h variables.h array.h hashlib.h
  braces.o: quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
***************
*** 894,898 ****
  
  pcomplib.o: config.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h bashtypes.h
! pcomplib.o: ${BASHINCDIR}/stdc.h hashlib.h pcomplete.h shell.h
  pcomplib.o: bashjmp.h command.h general.h error.h variables.h quit.h
  pcomplib.o: unwind_prot.h dispose_cmd.h make_cmd.h subst.h sig.h pathnames.h
--- 911,915 ----
  
  pcomplib.o: config.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h bashtypes.h
! pcomplib.o: ${BASHINCDIR}/stdc.h hashlib.h pcomplete.h shell.h syntax.h
  pcomplib.o: bashjmp.h command.h general.h error.h variables.h quit.h
  pcomplib.o: unwind_prot.h dispose_cmd.h make_cmd.h subst.h sig.h pathnames.h
***************
*** 900,904 ****
  
  pcomplete.o: config.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h bashtypes.h
! pcomplete.o: ${BASHINCDIR}/stdc.h hashlib.h pcomplete.h shell.h
  pcomplete.o: bashjmp.h command.h general.h error.h variables.h quit.h
  pcomplete.o: unwind_prot.h dispose_cmd.h make_cmd.h subst.h sig.h pathnames.h
--- 917,921 ----
  
  pcomplete.o: config.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h bashtypes.h
! pcomplete.o: ${BASHINCDIR}/stdc.h hashlib.h pcomplete.h shell.h syntax.h
  pcomplete.o: bashjmp.h command.h general.h error.h variables.h quit.h
  pcomplete.o: unwind_prot.h dispose_cmd.h make_cmd.h subst.h sig.h pathnames.h
***************
*** 909,913 ****
  bashhist.o: config.h bashtypes.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h ${BASHINCDIR}/posixstat.h
  bashhist.o: ${BASHINCDIR}/filecntl.h
! bashhist.o: shell.h config.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h ${BASHINCDIR}/stdc.h error.h
  bashhist.o: general.h bashtypes.h variables.h array.h hashlib.h
  bashhist.o: quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
--- 926,930 ----
  bashhist.o: config.h bashtypes.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h ${BASHINCDIR}/posixstat.h
  bashhist.o: ${BASHINCDIR}/filecntl.h
! bashhist.o: shell.h syntax.h config.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h ${BASHINCDIR}/stdc.h error.h
  bashhist.o: general.h bashtypes.h variables.h array.h hashlib.h
  bashhist.o: quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
***************
*** 916,920 ****
  bashhist.o: $(GLOB_LIBSRC)/fnmatch.h
  bashline.o: config.h bashtypes.h ${BASHINCDIR}/posixstat.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h
! bashline.o: shell.h config.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h ${BASHINCDIR}/stdc.h error.h
  bashline.o: general.h bashtypes.h variables.h array.h hashlib.h
  bashline.o: quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
--- 933,937 ----
  bashhist.o: $(GLOB_LIBSRC)/fnmatch.h
  bashline.o: config.h bashtypes.h ${BASHINCDIR}/posixstat.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h
! bashline.o: shell.h syntax.h config.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h ${BASHINCDIR}/stdc.h error.h
  bashline.o: general.h bashtypes.h variables.h array.h hashlib.h
  bashline.o: quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
***************
*** 924,932 ****
  bashline.o: pcomplete.h
  bracecomp.o: config.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h
! bracecomp.o: shell.h config.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h ${BASHINCDIR}/stdc.h error.h
  bracecomp.o: general.h bashtypes.h variables.h array.h hashlib.h
  bracecomp.o: quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
  bracecomp.o: make_cmd.h subst.h sig.h pathnames.h externs.h
! bracecomp.o: shell.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h command.h hashlib.h builtins.h general.h
  bracecomp.o: quit.h alias.h config.h  variables.h
  bracecomp.o: dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
--- 941,949 ----
  bashline.o: pcomplete.h
  bracecomp.o: config.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h
! bracecomp.o: shell.h syntax.h config.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h ${BASHINCDIR}/stdc.h error.h
  bracecomp.o: general.h bashtypes.h variables.h array.h hashlib.h
  bracecomp.o: quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
  bracecomp.o: make_cmd.h subst.h sig.h pathnames.h externs.h
! bracecomp.o: shell.h syntax.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h command.h hashlib.h builtins.h general.h
  bracecomp.o: quit.h alias.h config.h  variables.h
  bracecomp.o: dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
***************
*** 961,970 ****
  # builtin c sources
  builtins/bashgetopt.o: config.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h
! builtins/bashgetopt.o: shell.h config.h bashjmp.h command.h general.h error.h
  builtins/bashgetopt.o: variables.h quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
  builtins/bashgetopt.o: make_cmd.h subst.h sig.h pathnames.h externs.h
  builtins/bashgetopt.o: $(DEFSRC)/common.h
  builtins/common.o: bashtypes.h ${BASHINCDIR}/posixstat.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h
! builtins/common.o: shell.h config.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h command.h
  builtins/common.o: ${BASHINCDIR}/memalloc.h variables.h input.h siglist.h
  builtins/common.o: quit.h unwind_prot.h ${BASHINCDIR}/maxpath.h jobs.h builtins.h
--- 978,987 ----
  # builtin c sources
  builtins/bashgetopt.o: config.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h
! builtins/bashgetopt.o: shell.h syntax.h config.h bashjmp.h command.h general.h error.h
  builtins/bashgetopt.o: variables.h quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
  builtins/bashgetopt.o: make_cmd.h subst.h sig.h pathnames.h externs.h
  builtins/bashgetopt.o: $(DEFSRC)/common.h
  builtins/common.o: bashtypes.h ${BASHINCDIR}/posixstat.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h
! builtins/common.o: shell.h syntax.h config.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h command.h
  builtins/common.o: ${BASHINCDIR}/memalloc.h variables.h input.h siglist.h
  builtins/common.o: quit.h unwind_prot.h ${BASHINCDIR}/maxpath.h jobs.h builtins.h
***************
*** 973,977 ****
  builtins/common.o: ${DEFDIR}/builtext.h
  builtins/evalfile.o: bashtypes.h ${BASHINCDIR}/posixstat.h ${BASHINCDIR}/filecntl.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h
! builtins/evalfile.o: shell.h config.h bashjmp.h command.h general.h error.h
  builtins/evalfile.o: variables.h quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
  builtins/evalfile.o: make_cmd.h subst.h sig.h pathnames.h externs.h
--- 990,994 ----
  builtins/common.o: ${DEFDIR}/builtext.h
  builtins/evalfile.o: bashtypes.h ${BASHINCDIR}/posixstat.h ${BASHINCDIR}/filecntl.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h
! builtins/evalfile.o: shell.h syntax.h config.h bashjmp.h command.h general.h error.h
  builtins/evalfile.o: variables.h quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
  builtins/evalfile.o: make_cmd.h subst.h sig.h pathnames.h externs.h
***************
*** 979,983 ****
  builtins/evalfile.o: bashhist.h $(DEFSRC)/common.h
  builtins/evalstring.o: config.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h
! builtins/evalstring.o: shell.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h command.h siglist.h
  builtins/evalstring.o: ${BASHINCDIR}/memalloc.h variables.h input.h
  builtins/evalstring.o: quit.h unwind_prot.h ${BASHINCDIR}/maxpath.h jobs.h builtins.h
--- 996,1000 ----
  builtins/evalfile.o: bashhist.h $(DEFSRC)/common.h
  builtins/evalstring.o: config.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h
! builtins/evalstring.o: shell.h syntax.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h command.h siglist.h
  builtins/evalstring.o: ${BASHINCDIR}/memalloc.h variables.h input.h
  builtins/evalstring.o: quit.h unwind_prot.h ${BASHINCDIR}/maxpath.h jobs.h builtins.h
***************
*** 986,990 ****
  builtins/evalstring.o: bashhist.h $(DEFSRC)/common.h
  builtins/getopt.o: config.h ${BASHINCDIR}/memalloc.h
! builtins/getopt.o: shell.h bashjmp.h command.h general.h error.h
  builtins/getopt.o: variables.h quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
  builtins/getopt.o: make_cmd.h subst.h sig.h pathnames.h externs.h
--- 1003,1007 ----
  builtins/evalstring.o: bashhist.h $(DEFSRC)/common.h
  builtins/getopt.o: config.h ${BASHINCDIR}/memalloc.h
! builtins/getopt.o: shell.h syntax.h bashjmp.h command.h general.h error.h
  builtins/getopt.o: variables.h quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
  builtins/getopt.o: make_cmd.h subst.h sig.h pathnames.h externs.h
***************
*** 996,1143 ****
  builtins/alias.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h ${BASHINCDIR}/maxpath.h
  builtins/alias.o: quit.h $(DEFSRC)/common.h
! builtins/alias.o: shell.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h command.h ${BASHINCDIR}/stdc.h unwind_prot.h
  builtins/alias.o: dispose_cmd.h make_cmd.h subst.h externs.h variables.h 
  builtins/bind.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h ${BASHINCDIR}/maxpath.h
  builtins/bind.o: dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
! builtins/bind.o: shell.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h variables.h quit.h
  builtins/bind.o: $(DEFSRC)/bashgetopt.h
  builtins/break.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h ${BASHINCDIR}/maxpath.h
! builtins/break.o: shell.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h variables.h quit.h
  builtins/break.o: dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
  builtins/builtin.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h ${BASHINCDIR}/maxpath.h
  builtins/builtin.o: quit.h $(DEFSRC)/common.h
! builtins/builtin.o: shell.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h variables.h 
  builtins/builtin.o: dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
  builtins/cd.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h ${BASHINCDIR}/maxpath.h
! builtins/cd.o: shell.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h variables.h
  builtins/cd.o: dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
  builtins/cd.o: $(DEFSRC)/common.h quit.h 
  builtins/command.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h ${BASHINCDIR}/maxpath.h
  builtins/command.o: quit.h $(DEFSRC)/bashgetopt.h
! builtins/command.o: shell.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h variables.h 
  builtins/command.o: dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
  builtins/declare.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h ${BASHINCDIR}/maxpath.h
! builtins/declare.o: shell.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h variables.h quit.h
  builtins/declare.o: dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
  builtins/echo.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h ${BASHINCDIR}/maxpath.h
! builtins/echo.o: shell.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h variables.h quit.h
  builtins/echo.o: dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
  builtins/enable.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h ${BASHINCDIR}/maxpath.h
! builtins/enable.o: shell.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h variables.h quit.h
  builtins/enable.o: dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
  builtins/enable.o: pcomplete.h
  builtins/eval.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h ${BASHINCDIR}/maxpath.h
! builtins/eval.o: shell.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h variables.h quit.h 
  builtins/eval.o: dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
  builtins/exec.o: bashtypes.h
  builtins/exec.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h ${BASHINCDIR}/maxpath.h
! builtins/exec.o: shell.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h variables.h
  builtins/exec.o: dispose_cmd.h make_cmd.h subst.h externs.h execute_cmd.h
  builtins/exec.o: findcmd.h flags.h quit.h $(DEFSRC)/common.h ${BASHINCDIR}/stdc.h
  builtins/exit.o: bashtypes.h
  builtins/exit.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h ${BASHINCDIR}/maxpath.h
! builtins/exit.o: shell.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h variables.h quit.h
  builtins/exit.o: dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
  builtins/fc.o: bashtypes.h ${BASHINCDIR}/posixstat.h
  builtins/fc.o: bashansi.h ${BASHINCDIR}/ansi_stdlib.h builtins.h command.h ${BASHINCDIR}/stdc.h 
  builtins/fc.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h ${BASHINCDIR}/maxpath.h
! builtins/fc.o: flags.h unwind_prot.h variables.h shell.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h 
  builtins/fc.o: dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h quit.h 
  builtins/fc.o: $(DEFSRC)/bashgetopt.h bashhist.h
  builtins/fg_bg.o: bashtypes.h
  builtins/fg_bg.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h ${BASHINCDIR}/maxpath.h
! builtins/fg_bg.o: shell.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h variables.h quit.h
  builtins/fg_bg.o: dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
  builtins/getopts.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h ${BASHINCDIR}/maxpath.h
! builtins/getopts.o: shell.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h variables.h quit.h 
  builtins/getopts.o: dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
  builtins/hash.o: bashtypes.h
  builtins/hash.o: builtins.h command.h findcmd.h ${BASHINCDIR}/stdc.h $(DEFSRC)/common.h
  builtins/hash.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h ${BASHINCDIR}/maxpath.h
! builtins/hash.o: shell.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h variables.h quit.h 
  builtins/help.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h ${BASHINCDIR}/maxpath.h
  builtins/help.o: dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
! builtins/help.o: shell.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h variables.h quit.h
  builtins/help.o: $(GLOB_LIBSRC)/glob.h
  builtins/history.o: bashtypes.h
  builtins/history.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h ${BASHINCDIR}/maxpath.h
  builtins/history.o: quit.h dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
! builtins/history.o: ${BASHINCDIR}/filecntl.h shell.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h
  builtins/history.o: bashhist.h variables.h 
  builtins/inlib.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h ${BASHINCDIR}/maxpath.h
! builtins/inlib.o: shell.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h variables.h quit.h 
  builtins/inlib.o: dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
  builtins/jobs.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h ${BASHINCDIR}/maxpath.h
  builtins/jobs.o: quit.h $(DEFSRC)/bashgetopt.h
! builtins/jobs.o: shell.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h variables.h 
  builtins/jobs.o: dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
  builtins/kill.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h ${BASHINCDIR}/maxpath.h
  builtins/kill.o: quit.h dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
! builtins/kill.o: shell.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h trap.h unwind_prot.h variables.h 
  builtins/let.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h ${BASHINCDIR}/maxpath.h
  builtins/let.o: quit.h dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
! builtins/let.o: shell.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h variables.h 
  builtins/printf.o: config.h ${BASHINCDIR}/memalloc.h bashjmp.h command.h error.h
  builtins/printf.o: general.h quit.h dispose_cmd.h make_cmd.h subst.h
! builtins/printf.o: externs.h sig.h pathnames.h shell.h unwind_prot.h
  builtins/printf.o: variables.h ${BASHINCDIR}/stdc.h $(DEFSRC)/bashgetopt.h
  builtins/pushd.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h ${BASHINCDIR}/maxpath.h
  builtins/pushd.o: quit.h dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
! builtins/pushd.o: shell.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h variables.h
  builtins/pushd.o: $(DEFSRC)/common.h
  builtins/read.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h ${BASHINCDIR}/maxpath.h
  builtins/read.o: quit.h dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
! builtins/read.o: shell.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h variables.h 
  builtins/return.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h ${BASHINCDIR}/maxpath.h
  builtins/return.o: quit.h dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
! builtins/return.o: shell.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h variables.h 
  builtins/set.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h ${BASHINCDIR}/maxpath.h
  builtins/set.o: quit.h dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
! builtins/set.o: shell.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h variables.h flags.h
  builtins/setattr.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h ${BASHINCDIR}/maxpath.h
  builtins/setattr.o: quit.h $(DEFSRC)/common.h $(DEFSRC)/bashgetopt.h
! builtins/setattr.o: shell.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h variables.h 
  builtins/setattr.o: dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
  builtins/shift.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h ${BASHINCDIR}/maxpath.h
  builtins/shift.o: quit.h dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
! builtins/shift.o: shell.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h variables.h 
  builtins/shift.o: dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
  builtins/shopt.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h
  builtins/shopt.o: quit.h dispose_cmd.h make_cmd.h subst.h externs.h
! builtins/shopt.o: shell.h bashjmp.h ${BASHINCDIR}/posixjmp.h unwind_prot.h variables.h ${BASHINCDIR}/maxpath.h
  builtins/shopt.o: $(DEFSRC)/common.h $(DEFSRC)/bashgetopt.h
  builtins/source.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h ${BASHINCDIR}/maxpath.h
  builtins/source.o: quit.h dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
! builtins/source.o: shell.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h variables.h
  builtins/source.o: findcmd.h
  builtins/suspend.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h ${BASHINCDIR}/maxpath.h
  builtins/suspend.o: quit.h dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
! builtins/suspend.o: shell.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h variables.h 
  builtins/test.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h ${BASHINCDIR}/maxpath.h
  builtins/test.o: quit.h dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
! builtins/test.o: shell.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h variables.h 
  builtins/test.o: test.h
  builtins/times.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h ${BASHINCDIR}/maxpath.h
  builtins/times.o: quit.h dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
! builtins/times.o: shell.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h variables.h 
  builtins/trap.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h ${BASHINCDIR}/maxpath.h
  builtins/trap.o: quit.h $(DEFSRC)/common.h
! builtins/trap.o: shell.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h variables.h 
  builtins/trap.o: dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
  builtins/type.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h ${BASHINCDIR}/maxpath.h
  builtins/type.o: quit.h $(DEFSRC)/common.h findcmd.h
! builtins/type.o: shell.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h variables.h
  builtins/type.o: dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
  builtins/ulimit.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h ${BASHINCDIR}/maxpath.h
  builtins/ulimit.o: quit.h dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
! builtins/ulimit.o: shell.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h variables.h 
  builtins/umask.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h ${BASHINCDIR}/maxpath.h
  builtins/umask.o: quit.h dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
! builtins/umask.o: shell.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h variables.h 
  builtins/wait.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h ${BASHINCDIR}/maxpath.h
  builtins/wait.o: quit.h dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
! builtins/wait.o: shell.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h variables.h
  
! builtins/complete.o: config.h shell.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h
  builtins/complete.o: unwind_prot.h variables.h
  builtins/complete.o: bashtypes.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h
--- 1013,1160 ----
  builtins/alias.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h ${BASHINCDIR}/maxpath.h
  builtins/alias.o: quit.h $(DEFSRC)/common.h
! builtins/alias.o: shell.h syntax.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h command.h ${BASHINCDIR}/stdc.h unwind_prot.h
  builtins/alias.o: dispose_cmd.h make_cmd.h subst.h externs.h variables.h 
  builtins/bind.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h ${BASHINCDIR}/maxpath.h
  builtins/bind.o: dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
! builtins/bind.o: shell.h syntax.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h variables.h quit.h
  builtins/bind.o: $(DEFSRC)/bashgetopt.h
  builtins/break.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h ${BASHINCDIR}/maxpath.h
! builtins/break.o: shell.h syntax.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h variables.h quit.h
  builtins/break.o: dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
  builtins/builtin.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h ${BASHINCDIR}/maxpath.h
  builtins/builtin.o: quit.h $(DEFSRC)/common.h
! builtins/builtin.o: shell.h syntax.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h variables.h 
  builtins/builtin.o: dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
  builtins/cd.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h ${BASHINCDIR}/maxpath.h
! builtins/cd.o: shell.h syntax.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h variables.h
  builtins/cd.o: dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
  builtins/cd.o: $(DEFSRC)/common.h quit.h 
  builtins/command.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h ${BASHINCDIR}/maxpath.h
  builtins/command.o: quit.h $(DEFSRC)/bashgetopt.h
! builtins/command.o: shell.h syntax.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h variables.h 
  builtins/command.o: dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
  builtins/declare.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h ${BASHINCDIR}/maxpath.h
! builtins/declare.o: shell.h syntax.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h variables.h quit.h
  builtins/declare.o: dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
  builtins/echo.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h ${BASHINCDIR}/maxpath.h
! builtins/echo.o: shell.h syntax.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h variables.h quit.h
  builtins/echo.o: dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
  builtins/enable.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h ${BASHINCDIR}/maxpath.h
! builtins/enable.o: shell.h syntax.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h variables.h quit.h
  builtins/enable.o: dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
  builtins/enable.o: pcomplete.h
  builtins/eval.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h ${BASHINCDIR}/maxpath.h
! builtins/eval.o: shell.h syntax.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h variables.h quit.h 
  builtins/eval.o: dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
  builtins/exec.o: bashtypes.h
  builtins/exec.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h ${BASHINCDIR}/maxpath.h
! builtins/exec.o: shell.h syntax.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h variables.h
  builtins/exec.o: dispose_cmd.h make_cmd.h subst.h externs.h execute_cmd.h
  builtins/exec.o: findcmd.h flags.h quit.h $(DEFSRC)/common.h ${BASHINCDIR}/stdc.h
  builtins/exit.o: bashtypes.h
  builtins/exit.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h ${BASHINCDIR}/maxpath.h
! builtins/exit.o: shell.h syntax.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h variables.h quit.h
  builtins/exit.o: dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
  builtins/fc.o: bashtypes.h ${BASHINCDIR}/posixstat.h
  builtins/fc.o: bashansi.h ${BASHINCDIR}/ansi_stdlib.h builtins.h command.h ${BASHINCDIR}/stdc.h 
  builtins/fc.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h ${BASHINCDIR}/maxpath.h
! builtins/fc.o: flags.h unwind_prot.h variables.h shell.h syntax.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h 
  builtins/fc.o: dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h quit.h 
  builtins/fc.o: $(DEFSRC)/bashgetopt.h bashhist.h
  builtins/fg_bg.o: bashtypes.h
  builtins/fg_bg.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h ${BASHINCDIR}/maxpath.h
! builtins/fg_bg.o: shell.h syntax.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h variables.h quit.h
  builtins/fg_bg.o: dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
  builtins/getopts.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h ${BASHINCDIR}/maxpath.h
! builtins/getopts.o: shell.h syntax.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h variables.h quit.h 
  builtins/getopts.o: dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
  builtins/hash.o: bashtypes.h
  builtins/hash.o: builtins.h command.h findcmd.h ${BASHINCDIR}/stdc.h $(DEFSRC)/common.h
  builtins/hash.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h ${BASHINCDIR}/maxpath.h
! builtins/hash.o: shell.h syntax.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h variables.h quit.h 
  builtins/help.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h ${BASHINCDIR}/maxpath.h
  builtins/help.o: dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
! builtins/help.o: shell.h syntax.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h variables.h quit.h
  builtins/help.o: $(GLOB_LIBSRC)/glob.h
  builtins/history.o: bashtypes.h
  builtins/history.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h ${BASHINCDIR}/maxpath.h
  builtins/history.o: quit.h dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
! builtins/history.o: ${BASHINCDIR}/filecntl.h shell.h syntax.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h
  builtins/history.o: bashhist.h variables.h 
  builtins/inlib.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h ${BASHINCDIR}/maxpath.h
! builtins/inlib.o: shell.h syntax.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h variables.h quit.h 
  builtins/inlib.o: dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
  builtins/jobs.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h ${BASHINCDIR}/maxpath.h
  builtins/jobs.o: quit.h $(DEFSRC)/bashgetopt.h
! builtins/jobs.o: shell.h syntax.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h variables.h 
  builtins/jobs.o: dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
  builtins/kill.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h ${BASHINCDIR}/maxpath.h
  builtins/kill.o: quit.h dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
! builtins/kill.o: shell.h syntax.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h trap.h unwind_prot.h variables.h 
  builtins/let.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h ${BASHINCDIR}/maxpath.h
  builtins/let.o: quit.h dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
! builtins/let.o: shell.h syntax.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h variables.h 
  builtins/printf.o: config.h ${BASHINCDIR}/memalloc.h bashjmp.h command.h error.h
  builtins/printf.o: general.h quit.h dispose_cmd.h make_cmd.h subst.h
! builtins/printf.o: externs.h sig.h pathnames.h shell.h syntax.h unwind_prot.h
  builtins/printf.o: variables.h ${BASHINCDIR}/stdc.h $(DEFSRC)/bashgetopt.h
  builtins/pushd.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h ${BASHINCDIR}/maxpath.h
  builtins/pushd.o: quit.h dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
! builtins/pushd.o: shell.h syntax.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h variables.h
  builtins/pushd.o: $(DEFSRC)/common.h
  builtins/read.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h ${BASHINCDIR}/maxpath.h
  builtins/read.o: quit.h dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
! builtins/read.o: shell.h syntax.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h variables.h 
  builtins/return.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h ${BASHINCDIR}/maxpath.h
  builtins/return.o: quit.h dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
! builtins/return.o: shell.h syntax.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h variables.h 
  builtins/set.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h ${BASHINCDIR}/maxpath.h
  builtins/set.o: quit.h dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
! builtins/set.o: shell.h syntax.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h variables.h flags.h
  builtins/setattr.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h ${BASHINCDIR}/maxpath.h
  builtins/setattr.o: quit.h $(DEFSRC)/common.h $(DEFSRC)/bashgetopt.h
! builtins/setattr.o: shell.h syntax.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h variables.h 
  builtins/setattr.o: dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
  builtins/shift.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h ${BASHINCDIR}/maxpath.h
  builtins/shift.o: quit.h dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
! builtins/shift.o: shell.h syntax.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h variables.h 
  builtins/shift.o: dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
  builtins/shopt.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h
  builtins/shopt.o: quit.h dispose_cmd.h make_cmd.h subst.h externs.h
! builtins/shopt.o: shell.h syntax.h bashjmp.h ${BASHINCDIR}/posixjmp.h unwind_prot.h variables.h ${BASHINCDIR}/maxpath.h
  builtins/shopt.o: $(DEFSRC)/common.h $(DEFSRC)/bashgetopt.h
  builtins/source.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h ${BASHINCDIR}/maxpath.h
  builtins/source.o: quit.h dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
! builtins/source.o: shell.h syntax.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h variables.h
  builtins/source.o: findcmd.h
  builtins/suspend.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h ${BASHINCDIR}/maxpath.h
  builtins/suspend.o: quit.h dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
! builtins/suspend.o: shell.h syntax.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h variables.h 
  builtins/test.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h ${BASHINCDIR}/maxpath.h
  builtins/test.o: quit.h dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
! builtins/test.o: shell.h syntax.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h variables.h 
  builtins/test.o: test.h
  builtins/times.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h ${BASHINCDIR}/maxpath.h
  builtins/times.o: quit.h dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
! builtins/times.o: shell.h syntax.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h variables.h 
  builtins/trap.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h ${BASHINCDIR}/maxpath.h
  builtins/trap.o: quit.h $(DEFSRC)/common.h
! builtins/trap.o: shell.h syntax.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h variables.h 
  builtins/trap.o: dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
  builtins/type.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h ${BASHINCDIR}/maxpath.h
  builtins/type.o: quit.h $(DEFSRC)/common.h findcmd.h
! builtins/type.o: shell.h syntax.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h variables.h
  builtins/type.o: dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
  builtins/ulimit.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h ${BASHINCDIR}/maxpath.h
  builtins/ulimit.o: quit.h dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
! builtins/ulimit.o: shell.h syntax.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h variables.h 
  builtins/umask.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h ${BASHINCDIR}/maxpath.h
  builtins/umask.o: quit.h dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
! builtins/umask.o: shell.h syntax.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h variables.h 
  builtins/wait.o: command.h config.h ${BASHINCDIR}/memalloc.h error.h general.h ${BASHINCDIR}/maxpath.h
  builtins/wait.o: quit.h dispose_cmd.h make_cmd.h subst.h externs.h ${BASHINCDIR}/stdc.h
! builtins/wait.o: shell.h syntax.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h unwind_prot.h variables.h
  
! builtins/complete.o: config.h shell.h syntax.h bashjmp.h ${BASHINCDIR}/posixjmp.h sig.h
  builtins/complete.o: unwind_prot.h variables.h
  builtins/complete.o: bashtypes.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h
diff -Nrc2 bash-2.04/NEWS bash-2.05/NEWS
*** bash-2.04/NEWS	Tue Mar 14 11:40:06 2000
--- bash-2.05/NEWS	Wed Apr  4 10:44:08 2001
***************
*** 1,2 ****
--- 1,69 ----
+ This is a terse description of the new features added to bash-2.05 since
+ the release of bash-2.04.  As always, the manual page (doc/bash.1) is
+ the place to look for complete descriptions.
+ 
+ 1.  New Features in Bash
+ 
+ a.  Added a new `--init-file' invocation argument as a synonym for `--rcfile',
+     per the new GNU coding standards.
+ 
+ b.  The /dev/tcp and /dev/udp redirections now accept service names as well as
+     port numbers.
+ 
+ c.  `complete' and `compgen' now take a `-o value' option, which controls some
+     of the aspects of that compspec.  Valid values are:
+ 
+         default - perform bash default completion if programmable
+                   completion produces no matches
+         dirnames - perform directory name completion if programmable
+                    completion produces no matches
+         filenames - tell readline that the compspec produces filenames,
+                     so it can do things like append slashes to
+                     directory names and suppress trailing spaces
+ 
+ d.  A new loadable builtin, realpath, which canonicalizes and expands symlinks
+     in pathname arguments.
+     
+ e.  When `set' is called without options, it prints function defintions in a
+     way that allows them to be reused as input.  This affects `declare' and 
+     `declare -p' as well.  This only happens when the shell is not in POSIX
+     mode, since POSIX.2 forbids this behavior.
+ 
+ f.  Bash-2.05 once again honors the current locale setting when processing
+     ranges within pattern matching bracket expressions (e.g., [A-Z]).
+ 
+ 2.  New Features in Readline
+ 
+ a.  The blink timeout for paren matching is now settable by applications,
+     via the rl_set_paren_blink_timeout() function.
+ 
+ b.  _rl_executing_macro has been renamed to rl_executing_macro, which means
+     it's now part of the public interface.
+ 
+ c.  Readline has a new variable, rl_readline_state, which is a bitmap that
+     encapsulates the current state of the library; intended for use by
+     callbacks and hook functions.
+ 
+ d.  New application-callable function rl_set_prompt(const char *prompt):
+     expands its prompt string argument and sets rl_prompt to the result.
+ 
+ e.  New application-callable function rl_set_screen_size(int rows, int cols):
+     public method for applications to set readline's idea of the screen
+     dimensions.
+ 
+ f.  New function, rl_get_screen_size (int *rows, int *columns), returns
+     readline's idea of the screen dimensions.
+ 
+ g.  The timeout in rl_gather_tyi (readline keyboard input polling function)
+     is now settable via a function (rl_set_keyboard_input_timeout()).
+ 
+ h.  Renamed the max_input_history variable to history_max_entries; the old
+     variable is maintained for backwards compatibility.
+ 
+ i.  The list of characters that separate words for the history tokenizer is
+     now settable with a variable:  history_word_delimiters.  The default
+     value is as before.
+ 
+ -------------------------------------------------------------------------------
  This is a terse description of the new features added to bash-2.04 since
  the release of bash-2.03.  As always, the manual page (doc/bash.1) is
diff -Nrc2 bash-2.04/NOTES bash-2.05/NOTES
*** bash-2.04/NOTES	Tue Jan 25 13:16:29 2000
--- bash-2.05/NOTES	Wed Apr  4 11:07:16 2001
***************
*** 52,58 ****
      fixes the problem.
  
! 5.  There is a problem with Red Hat Linux's `makewhatis' script.
!     Running `makewhatis' with bash-2.0 or later versions results
!     in error messages like this:
  
      /usr/sbin/makewhatis: cd: manpath: No such file or directory
--- 52,58 ----
      fixes the problem.
  
! 5.  There is a problem with the `makewhatis' script in older (pre-7.0)
!     versions of Red Hat Linux.  Running `makewhatis' with bash-2.0 or
!     later versions results in error messages like this:
  
      /usr/sbin/makewhatis: cd: manpath: No such file or directory
***************
*** 216,220 ****
      It's not possible to build a completely statically-linked binary, since
      part of the C library depends on dynamic linking.  The following recipe
!     assumes that you're using gcc and the Solaris ld (/usr/ccs/bin/ld).
  
  	configure --enable-static-link
--- 216,221 ----
      It's not possible to build a completely statically-linked binary, since
      part of the C library depends on dynamic linking.  The following recipe
!     assumes that you're using gcc and the Solaris ld (/usr/ccs/bin/ld) on
!     Solaris 2.5.x or 2.6:
  
  	configure --enable-static-link
***************
*** 252,255 ****
--- 253,267 ----
  	        libdl.so.1 =>    /etc/lib/libdl.so.1
  
+     On Solaris 7 (and presumably Solaris 8, though I do not run that), the
+     following recipe appears to work for gcc:
+ 
+ 	configure --enable-static-link
+ 	make STATIC_LD='-Wl,-Bstatic' LOCAL_LIBS='Wl,-Bdynamic -Wl,-R/etc/lib -ldl -Wl,-Bstatic'
+ 
+ 	thor.ins.cwru.edu(2)$ ldd bash
+ 	        libdl.so.1 =>    /etc/lib/libdl.so.1
+ 
+     Make the analogous changes if you are running Sun's C Compiler.
+ 
  12. Configuring bash to build it in a cross environment.  Currently only
      two native versions can be compiled this way, cygwin32 and x86 BeOS.
***************
*** 262,263 ****
--- 274,312 ----
  
      Similarly for cygwin32.
+ 
+ 13. Bash-2.05 has reverted to the bash-2.03 behavior of honoring the current
+     locale setting when processing ranges within pattern matching bracket
+     expressions ([A-Z]).  This is what POSIX.2 and SUSv2 specify.
+ 
+     The behavior of the matcher in bash-2.05 depends on the current LC_COLLATE
+     setting.  Setting this variable to `C' or `POSIX' will result in the
+     traditional behavior ([A-Z] matches all uppercase ASCII characters).
+     Many other locales, including the en_US locale (the default on many US
+     versions of Linux) collate the upper and lower case letters like this:
+ 
+ 	AaBb...Zz
+ 
+     which means that [A-Z] matches every letter except `z'.
+ 
+     The portable way to specify upper case letters is [:upper:] instead of
+     A-Z; lower case may be specified as [:lower:] instead of a-z.
+ 
+     Look at the manual pages for setlocale(3), strcoll(3), and, if it is
+     present, locale(1).  If you have locale(1), you can use it to find
+     your current locale information even if you do not have any of the
+     LC_ variables set.
+ 
+     My advice is to put
+ 
+         export LC_COLLATE=C
+ 
+     into /etc/profile and inspect any shell scripts run from cron for
+     constructs like [A-Z].  This will prevent things like
+ 
+ 	rm [A-Z]*
+ 
+     from removing every file in the current directory except those beginning
+     with `z' and still allow individual users to change the collation order.
+     Users may put the above command into their own profiles as well, of course.
+ 
+ 
diff -Nrc2 bash-2.04/README bash-2.05/README
*** bash-2.04/README	Fri Mar 17 16:46:59 2000
--- bash-2.05/README	Mon Mar 26 11:25:33 2001
***************
*** 2,6 ****
  ============
  
! This is GNU Bash, version 2.04.  Bash is the GNU Project's Bourne
  Again SHell, a complete implementation of the POSIX.2 shell spec,
  but also with interactive command line editing, job control on
--- 2,6 ----
  ============
  
! This is GNU Bash, version 2.05.  Bash is the GNU Project's Bourne
  Again SHell, a complete implementation of the POSIX.2 shell spec,
  but also with interactive command line editing, job control on
diff -Nrc2 bash-2.04/aclocal.m4 bash-2.05/aclocal.m4
*** bash-2.04/aclocal.m4	Tue Feb 22 11:41:01 2000
--- bash-2.05/aclocal.m4	Tue Nov 21 10:42:10 2000
***************
*** 1066,1080 ****
  
  AC_DEFUN(BASH_CHECK_GETPW_FUNCS,
! [AC_MSG_CHECKING(whether programs are able to redeclare getpw functions)
! AC_CACHE_VAL(bash_cv_can_redecl_getpw,
! [AC_TRY_COMPILE([#include <sys/types.h>
  #include <pwd.h>
! extern struct passwd *getpwent();
! extern struct passwd *getpwuid();
! extern struct passwd *getpwnam();],
! [struct passwd *z; z = getpwent(); z = getpwuid(0); z = getpwnam("root");],
!   bash_cv_can_redecl_getpw=yes,bash_cv_can_redecl_getpw=no)])
! AC_MSG_RESULT($bash_cv_can_redecl_getpw)
! if test $bash_cv_can_redecl_getpw = no; then
  AC_DEFINE(HAVE_GETPW_DECLS)
  fi
--- 1066,1082 ----
  
  AC_DEFUN(BASH_CHECK_GETPW_FUNCS,
! [AC_MSG_CHECKING(whether getpw functions are declared in pwd.h)
! AC_CACHE_VAL(bash_cv_getpw_declared,
! [AC_EGREP_CPP(getpwuid,
! [
! #include <sys/types.h>
! #ifdef HAVE_UNISTD_H
! #  include <unistd.h>
! #endif
  #include <pwd.h>
! ],
! bash_cv_getpw_declared=yes,bash_cv_getpw_declared=no)])
! AC_MSG_RESULT($bash_cv_getpw_declared)
! if test $bash_cv_getpw_declared = yes; then
  AC_DEFINE(HAVE_GETPW_DECLS)
  fi
***************
*** 1351,1355 ****
  AC_DEFUN(BASH_SYS_RESTARTABLE_SYSCALLS,
  [AC_REQUIRE([BASH_SIGNAL_CHECK])
! AC_CACHE_CHECK(for restartable system calls with posix sigaction,
  bash_cv_sys_restartable_syscalls,
  [AC_TRY_RUN(
--- 1353,1357 ----
  AC_DEFUN(BASH_SYS_RESTARTABLE_SYSCALLS,
  [AC_REQUIRE([BASH_SIGNAL_CHECK])
! AC_CACHE_CHECK(whether posix sigaction restarts system calls by default,
  bash_cv_sys_restartable_syscalls,
  [AC_TRY_RUN(
***************
*** 1357,1360 ****
--- 1359,1365 ----
     i.e. the pid of the child, which means that wait was restarted
     after getting the signal.  */
+ #ifdef HAVE_UNISTD_H
+ #  include <unistd.h>
+ #endif
  #include <sys/types.h>
  #include <signal.h>
***************
*** 1424,1427 ****
--- 1429,1463 ----
  if test $bash_cv_struct_timeval = yes; then
    AC_DEFINE(HAVE_TIMEVAL)
+ fi
+ ])
+ 
+ AC_DEFUN(BASH_CHECK_RTSIGS,
+ [AC_MSG_CHECKING(for unusable real-time signals due to large values)
+ AC_CACHE_VAL(bash_cv_unusable_rtsigs,
+ [AC_TRY_RUN([
+ #include <sys/types.h>
+ #include <signal.h>
+ 
+ #ifndef NSIG
+ #  define NSIG 64
+ #endif
+ 
+ main ()
+ {
+   int n_sigs = 2 * NSIG;
+ #ifdef SIGRTMIN
+   int rtmin = SIGRTMIN;
+ #else
+   int rtmin = 0;
+ #endif
+ 
+   exit(rtmin < n_sigs);
+ }], bash_cv_unusable_rtsigs=yes, bash_cv_unusable_rtsigs=no,
+     [AC_MSG_WARN(cannot check real-time signals if cross compiling -- defaulting to yes)
+      bash_cv_unusable_rtsigs=yes]
+ )])
+ AC_MSG_RESULT($bash_cv_unusable_rtsigs)
+ if test $bash_cv_unusable_rtsigs = yes; then
+ AC_DEFINE(UNUSABLE_RT_SIGNALS)
  fi
  ])
diff -Nrc2 bash-2.04/array.c bash-2.05/array.c
*** bash-2.04/array.c	Thu Aug  5 07:01:03 1999
--- bash-2.05/array.c	Fri Nov  3 11:20:00 2000
***************
*** 365,369 ****
  	for (ae = element_forw(a->head); ae != a->head; ae = element_forw(ae)) {
  		indstr = itos (element_index(ae));
! 		valstr = element_value (ae) ? double_quote (element_value(ae))
  					    : (char *)NULL;
  		elen = STRLEN (indstr) + 8 + STRLEN (valstr);
--- 365,369 ----
  	for (ae = element_forw(a->head); ae != a->head; ae = element_forw(ae)) {
  		indstr = itos (element_index(ae));
! 		valstr = element_value (ae) ? sh_double_quote (element_value(ae))
  					    : (char *)NULL;
  		elen = STRLEN (indstr) + 8 + STRLEN (valstr);
***************
*** 402,406 ****
  		return ((char *)NULL);
  
! 	vstr = single_quote (sv);
  	free (sv);
  	return (vstr);
--- 402,406 ----
  		return ((char *)NULL);
  
! 	vstr = sh_single_quote (sv);
  	free (sv);
  	return (vstr);
diff -Nrc2 bash-2.04/bashhist.c bash-2.05/bashhist.c
*** bash-2.04/bashhist.c	Fri Dec  3 11:49:29 1999
--- bash-2.05/bashhist.c	Tue Mar 13 14:54:46 2001
***************
*** 491,498 ****
       char *line;
  {
!   int should_add;
    HIST_ENTRY *temp;
  
!   should_add = hist_last_line_added = 0;
  
    /* Don't use the value of history_control to affect the second
--- 491,498 ----
       char *line;
  {
!   static int first_line_saved = 0;
    HIST_ENTRY *temp;
  
!   hist_last_line_added = 0;
  
    /* Don't use the value of history_control to affect the second
***************
*** 505,521 ****
  #endif
      {
!       if (literal_history || dstack.delimiter_depth != 0 || shell_comment (line) == 0)
  	bash_add_history (line);
        return;
      }
  
    switch (history_control)
      {
      case 0:
!       should_add = 1;
        break;
      case 1:
        if (*line != ' ')
! 	should_add = 1;
        break;
      case 3:
--- 505,526 ----
  #endif
      {
!       if (first_line_saved &&
! 	  (literal_history || dstack.delimiter_depth != 0 || shell_comment (line) == 0))
  	bash_add_history (line);
        return;
      }
  
+   /* This is the first line of a (possible multi-line) command.  Note whether
+      or not we should save the first line and remember it. */
+   first_line_saved = 0;
+ 
    switch (history_control)
      {
      case 0:
!       first_line_saved = 1;
        break;
      case 1:
        if (*line != ' ')
! 	first_line_saved = 1;
        break;
      case 3:
***************
*** 528,532 ****
  
        if (temp == 0 || STREQ (temp->line, line) == 0)
! 	should_add = 1;
  
        using_history ();
--- 533,537 ----
  
        if (temp == 0 || STREQ (temp->line, line) == 0)
! 	first_line_saved = 1;
  
        using_history ();
***************
*** 534,539 ****
      }
  
!   if (should_add && history_should_ignore (line) == 0)
      bash_add_history (line);
  }
  
--- 539,546 ----
      }
  
!   if (first_line_saved && history_should_ignore (line) == 0)
      bash_add_history (line);
+   else
+     first_line_saved = 0;
  }
  
diff -Nrc2 bash-2.04/bashline.c bash-2.05/bashline.c
*** bash-2.04/bashline.c	Fri Dec 31 15:03:51 1999
--- bash-2.05/bashline.c	Tue Mar  6 13:36:07 2001
***************
*** 55,102 ****
  
  #if defined (BRACE_COMPLETION)
! extern void bash_brace_completion ();
  #endif /* BRACE_COMPLETION */
  
  /* Functions bound to keys in Readline for Bash users. */
! static void shell_expand_line ();
! static void display_shell_version (), operate_and_get_next ();
! static void bash_ignore_filenames ();
! static void bash_ignore_everything ();
! static void cleanup_expansion_error (), set_up_new_line ();
  
  #if defined (BANG_HISTORY)
! static int history_expand_line ();
! static int tcsh_magic_space ();
  #endif /* BANG_HISTORY */
  #ifdef ALIAS
! static int alias_expand_line ();
  #endif
  #if defined (BANG_HISTORY) && defined (ALIAS)
! static int history_and_alias_expand_line ();
  #endif
  
  /* Helper functions for Readline. */
  static int bash_directory_completion_hook ();
! static void filename_completion_ignore ();
! static void bash_push_line ();
  
! static char **attempt_shell_completion ();
! static char *variable_completion_function ();
! static char *hostname_completion_function ();
! static char *command_subst_completion_function ();
! static void dynamic_complete_history ();
! 
! static char *glob_complete_word ();
! static void bash_glob_expand_word ();
! static void bash_glob_list_expansions ();
  
! static void snarf_hosts_from_file ();
! static void add_host_name ();
  
! static char *bash_dequote_filename ();
! static char *bash_quote_filename ();
  
  #if defined (ALIAS)
! static int posix_edit_macros ();
  #endif
  
--- 55,111 ----
  
  #if defined (BRACE_COMPLETION)
! extern int bash_brace_completion __P((int, int));
  #endif /* BRACE_COMPLETION */
  
+ /* Forward declarations */
+ 
+ extern char *command_word_completion_function __P((const char *, int));
+ 
  /* Functions bound to keys in Readline for Bash users. */
! static int shell_expand_line __P((int, int));
! static int display_shell_version __P((int, int));
! static int operate_and_get_next __P((int, int));
! 
! static int bash_ignore_filenames __P((char **));
! static int bash_ignore_everything __P((char **));
! 
! static void cleanup_expansion_error __P((void));
! static void set_up_new_line __P((char *));
  
  #if defined (BANG_HISTORY)
! static int history_expand_line __P((int, int));
! static int tcsh_magic_space __P((int, int));
  #endif /* BANG_HISTORY */
  #ifdef ALIAS
! static int alias_expand_line __P((int, int));
  #endif
  #if defined (BANG_HISTORY) && defined (ALIAS)
! static int history_and_alias_expand_line __P((int, int));
  #endif
  
  /* Helper functions for Readline. */
  static int bash_directory_completion_hook ();
! static int filename_completion_ignore ();
! static int bash_push_line __P((void));
  
! static char **attempt_shell_completion __P((const char *, int, int));
! static char *variable_completion_function __P((const char *, int));
! static char *hostname_completion_function __P((const char *, int));
! static char *command_subst_completion_function __P((const char *, int));
  
! static int dynamic_complete_history __P((int, int));
  
! static char *glob_complete_word __P((const char *, int));
! static int bash_glob_expand_word __P((int, int));
! static int bash_glob_list_expansions __P((int, int));
! 
! static void snarf_hosts_from_file __P((char *));
! static void add_host_name __P((char *));
! 
! static char *bash_dequote_filename __P((char *, int));
! static char *bash_quote_filename __P((char *, int, char *));
  
  #if defined (ALIAS)
! static int posix_edit_macros __P((int, int));
  #endif
  
***************
*** 108,116 ****
  /* Variables used here but defined in other files. */
  extern int posixly_correct, no_symbolic_links;
- extern int rl_explicit_arg;
  extern char *current_prompt_string, *ps1_prompt;
  extern STRING_INT_ALIST word_token_alist[];
- extern Function *rl_last_func;
- extern int rl_filename_completion_desired;
  
  /* SPECIFIC_COMPLETION_FUNCTIONS specifies that we have individual
--- 117,122 ----
***************
*** 121,139 ****
  
  #if defined (SPECIFIC_COMPLETION_FUNCTIONS)
! static void bash_specific_completion ();
! static void bash_complete_filename (), bash_possible_filename_completions ();
! static void bash_complete_filename_internal ();
! static void bash_complete_username (), bash_possible_username_completions ();
! static void bash_complete_username_internal ();
! static void bash_complete_hostname (), bash_possible_hostname_completions ();
! static void bash_complete_hostname_internal ();
! static void bash_complete_variable (), bash_possible_variable_completions ();
! static void bash_complete_variable_internal ();
! static void bash_complete_command (), bash_possible_command_completions ();
! static void bash_complete_command_internal ();
  #endif /* SPECIFIC_COMPLETION_FUNCTIONS */
  
  #if defined (VI_MODE)
! static void vi_edit_and_execute_command ();
  #endif
  
--- 127,152 ----
  
  #if defined (SPECIFIC_COMPLETION_FUNCTIONS)
! static int bash_specific_completion __P((int, rl_compentry_func_t *));
! 
! static int bash_complete_filename_internal __P((int));
! static int bash_complete_username_internal __P((int));
! static int bash_complete_hostname_internal __P((int));
! static int bash_complete_variable_internal __P((int));
! static int bash_complete_command_internal __P((int));
! 
! static int bash_complete_filename __P((int, int));
! static int bash_possible_filename_completions __P((int, int));
! static int bash_complete_username __P((int, int));
! static int bash_possible_username_completions __P((int, int));
! static int bash_complete_hostname __P((int, int));
! static int bash_possible_hostname_completions __P((int, int));
! static int bash_complete_variable __P((int, int));
! static int bash_possible_variable_completions __P((int, int));
! static int bash_complete_command __P((int, int));
! static int bash_possible_command_completions __P((int, int));
  #endif /* SPECIFIC_COMPLETION_FUNCTIONS */
  
  #if defined (VI_MODE)
! static int vi_edit_and_execute_command __P((int, int));
  #endif
  
***************
*** 152,156 ****
  static char *bash_nohostname_word_break_characters = " \t\n\"'><=;|&(:";
  
! static Function *old_rl_startup_hook = (Function *) NULL;
  
  /* What kind of quoting is performed by bash_quote_filename:
--- 165,169 ----
  static char *bash_nohostname_word_break_characters = " \t\n\"'><=;|&(:";
  
! static rl_hook_func_t *old_rl_startup_hook = (rl_hook_func_t *)NULL;
  
  /* What kind of quoting is performed by bash_quote_filename:
***************
*** 209,228 ****
    rl_readline_name = "Bash";
  
!   /* Bind up our special shell functions. */
!   rl_add_defun ("shell-expand-line", (Function *)shell_expand_line, -1);
!   rl_bind_key_in_map (CTRL('E'), (Function *)shell_expand_line, emacs_meta_keymap);
! 
!   /* Bind up our special shell functions. */
  #ifdef BANG_HISTORY
!   rl_add_defun ("history-expand-line", (Function *)history_expand_line, -1);
!   rl_bind_key_in_map ('^', (Function *)history_expand_line, emacs_meta_keymap);
! 
!   rl_add_defun ("magic-space", (Function *)tcsh_magic_space, -1);
  #endif
  
  #ifdef ALIAS
!   rl_add_defun ("alias-expand-line", (Function *)alias_expand_line, -1);
  #  ifdef BANG_HISTORY
!   rl_add_defun ("history-and-alias-expand-line", (Function *)history_and_alias_expand_line, -1);
  #  endif
  #endif
--- 222,237 ----
    rl_readline_name = "Bash";
  
!   /* Add bindable names before calling rl_initialize so they may be
!      referenced in the various inputrc files. */
!   rl_add_defun ("shell-expand-line", shell_expand_line, -1);
  #ifdef BANG_HISTORY
!   rl_add_defun ("history-expand-line", history_expand_line, -1);
!   rl_add_defun ("magic-space", tcsh_magic_space, -1);
  #endif
  
  #ifdef ALIAS
!   rl_add_defun ("alias-expand-line", alias_expand_line, -1);
  #  ifdef BANG_HISTORY
!   rl_add_defun ("history-and-alias-expand-line", history_and_alias_expand_line, -1);
  #  endif
  #endif
***************
*** 231,241 ****
    rl_add_defun ("insert-last-argument", rl_yank_last_arg, -1);
  
!   rl_add_defun
!     ("operate-and-get-next", (Function *)operate_and_get_next, CTRL('O'));
  
!   rl_add_defun
!     ("display-shell-version", (Function *)display_shell_version, -1);
!   rl_bind_key_in_map
!     (CTRL ('V'), (Function *)display_shell_version, emacs_ctlx_keymap);
  
    /* In Bash, the user can switch editing modes with "set -o [vi emacs]",
--- 240,281 ----
    rl_add_defun ("insert-last-argument", rl_yank_last_arg, -1);
  
!   rl_add_defun ("operate-and-get-next", operate_and_get_next, -1);
!   rl_add_defun ("display-shell-version", display_shell_version, -1);
! 
! #if defined (BRACE_COMPLETION)
!   rl_add_defun ("complete-into-braces", bash_brace_completion, -1);
! #endif
! 
! #if defined (SPECIFIC_COMPLETION_FUNCTIONS)
!   rl_add_defun ("complete-filename", bash_complete_filename, -1);
!   rl_add_defun ("possible-filename-completions", bash_possible_filename_completions, -1);
!   rl_add_defun ("complete-username", bash_complete_username, -1);
!   rl_add_defun ("possible-username-completions", bash_possible_username_completions, -1);
!   rl_add_defun ("complete-hostname", bash_complete_hostname, -1);
!   rl_add_defun ("possible-hostname-completions", bash_possible_hostname_completions, -1);
!   rl_add_defun ("complete-variable", bash_complete_variable, -1);
!   rl_add_defun ("possible-variable-completions", bash_possible_variable_completions, -1);
!   rl_add_defun ("complete-command", bash_complete_command, -1);
!   rl_add_defun ("possible-command-completions", bash_possible_command_completions, -1);
!   rl_add_defun ("glob-expand-word", bash_glob_expand_word, -1);
!   rl_add_defun ("glob-list-expansions", bash_glob_list_expansions, -1);
! #endif
! 
!   rl_add_defun ("dynamic-complete-history", dynamic_complete_history, -1);
! 
!   /* Bind defaults before binding our custom shell keybindings. */
!   if (RL_ISSTATE(RL_STATE_INITIALIZED) == 0)
!     rl_initialize ();
! 
!   /* Bind up our special shell functions. */
!   rl_bind_key_in_map (CTRL('E'), shell_expand_line, emacs_meta_keymap);
! 
!   /* Bind up our special shell functions. */
! #ifdef BANG_HISTORY
!   rl_bind_key_in_map ('^', history_expand_line, emacs_meta_keymap);
! #endif
  
!   rl_bind_key_in_map (CTRL ('O'), operate_and_get_next, emacs_standard_keymap);
!   rl_bind_key_in_map (CTRL ('V'), display_shell_version, emacs_ctlx_keymap);
  
    /* In Bash, the user can switch editing modes with "set -o [vi emacs]",
***************
*** 249,299 ****
  
  #if defined (BRACE_COMPLETION)
!   rl_add_defun ("complete-into-braces", (Function *)bash_brace_completion, -1);
!   rl_bind_key_in_map ('{', (Function *)bash_brace_completion, emacs_meta_keymap);
  #endif /* BRACE_COMPLETION */
  
  #if defined (SPECIFIC_COMPLETION_FUNCTIONS)
!   rl_add_defun ("complete-filename", (Function *)bash_complete_filename, -1);
!   rl_bind_key_in_map ('/', (Function *)bash_complete_filename, emacs_meta_keymap);
!   rl_add_defun ("possible-filename-completions",
! 		(Function *)bash_possible_filename_completions, -1);
!   rl_bind_key_in_map ('/', (Function *)bash_possible_filename_completions, emacs_ctlx_keymap);
! 
!   rl_add_defun ("complete-username", (Function *)bash_complete_username, -1);
!   rl_bind_key_in_map ('~', (Function *)bash_complete_username, emacs_meta_keymap);
!   rl_add_defun ("possible-username-completions",
! 		(Function *)bash_possible_username_completions, -1);
!   rl_bind_key_in_map ('~', (Function *)bash_possible_username_completions, emacs_ctlx_keymap);
! 
!   rl_add_defun ("complete-hostname", (Function *)bash_complete_hostname, -1);
!   rl_bind_key_in_map ('@', (Function *)bash_complete_hostname, emacs_meta_keymap);
!   rl_add_defun ("possible-hostname-completions",
! 		(Function *)bash_possible_hostname_completions, -1);
!   rl_bind_key_in_map ('@', (Function *)bash_possible_hostname_completions, emacs_ctlx_keymap);
! 
!   rl_add_defun ("complete-variable", (Function *)bash_complete_variable, -1);
!   rl_bind_key_in_map ('$', (Function *)bash_complete_variable, emacs_meta_keymap);
!   rl_add_defun ("possible-variable-completions",
! 		(Function *)bash_possible_variable_completions, -1);
!   rl_bind_key_in_map ('$', (Function *)bash_possible_variable_completions, emacs_ctlx_keymap);
! 
!   rl_add_defun ("complete-command", (Function *)bash_complete_command, -1);
!   rl_bind_key_in_map ('!', (Function *)bash_complete_command, emacs_meta_keymap);
!   rl_add_defun ("possible-command-completions",
! 		(Function *)bash_possible_command_completions, -1);
!   rl_bind_key_in_map ('!', (Function *)bash_possible_command_completions, emacs_ctlx_keymap);
! 
!   rl_add_defun ("glob-expand-word", (Function *)bash_glob_expand_word, -1);
!   rl_add_defun ("glob-list-expansions", (Function *)bash_glob_list_expansions, -1);
!   rl_bind_key_in_map ('*', (Function *)bash_glob_expand_word, emacs_ctlx_keymap);
!   rl_bind_key_in_map ('g', (Function *)bash_glob_list_expansions, emacs_ctlx_keymap);
  
  #endif /* SPECIFIC_COMPLETION_FUNCTIONS */
  
!   rl_add_defun ("dynamic-complete-history", (Function *)dynamic_complete_history, -1);
!   rl_bind_key_in_map (TAB, (Function *)dynamic_complete_history, emacs_meta_keymap);
  
    /* Tell the completer that we want a crack first. */
!   rl_attempted_completion_function = (CPPFunction *)attempt_shell_completion;
  
    /* Tell the completer that we might want to follow symbolic links or
--- 289,320 ----
  
  #if defined (BRACE_COMPLETION)
!   rl_bind_key_in_map ('{', bash_brace_completion, emacs_meta_keymap);
  #endif /* BRACE_COMPLETION */
  
  #if defined (SPECIFIC_COMPLETION_FUNCTIONS)
!   rl_bind_key_in_map ('/', bash_complete_filename, emacs_meta_keymap);
!   rl_bind_key_in_map ('/', bash_possible_filename_completions, emacs_ctlx_keymap);
! 
!   rl_bind_key_in_map ('~', bash_complete_username, emacs_meta_keymap);
!   rl_bind_key_in_map ('~', bash_possible_username_completions, emacs_ctlx_keymap);
! 
!   rl_bind_key_in_map ('@', bash_complete_hostname, emacs_meta_keymap);
!   rl_bind_key_in_map ('@', bash_possible_hostname_completions, emacs_ctlx_keymap);
! 
!   rl_bind_key_in_map ('$', bash_complete_variable, emacs_meta_keymap);
!   rl_bind_key_in_map ('$', bash_possible_variable_completions, emacs_ctlx_keymap);
! 
!   rl_bind_key_in_map ('!', bash_complete_command, emacs_meta_keymap);
!   rl_bind_key_in_map ('!', bash_possible_command_completions, emacs_ctlx_keymap);
! 
!   rl_bind_key_in_map ('*', bash_glob_expand_word, emacs_ctlx_keymap);
!   rl_bind_key_in_map ('g', bash_glob_list_expansions, emacs_ctlx_keymap);
  
  #endif /* SPECIFIC_COMPLETION_FUNCTIONS */
  
!   rl_bind_key_in_map (TAB, dynamic_complete_history, emacs_meta_keymap);
  
    /* Tell the completer that we want a crack first. */
!   rl_attempted_completion_function = attempt_shell_completion;
  
    /* Tell the completer that we might want to follow symbolic links or
***************
*** 302,311 ****
  
    /* Tell the filename completer we want a chance to ignore some names. */
!   rl_ignore_some_completions_function = (Function *)filename_completion_ignore;
  
  #if defined (VI_MODE)
!   rl_bind_key_in_map ('v', (Function *)vi_edit_and_execute_command, vi_movement_keymap);
  #  if defined (ALIAS)
!   rl_bind_key_in_map ('@', (Function *)posix_edit_macros, vi_movement_keymap);
  #  endif
  #endif
--- 323,332 ----
  
    /* Tell the filename completer we want a chance to ignore some names. */
!   rl_ignore_some_completions_function = filename_completion_ignore;
  
  #if defined (VI_MODE)
!   rl_bind_key_in_map ('v', vi_edit_and_execute_command, vi_movement_keymap);
  #  if defined (ALIAS)
!   rl_bind_key_in_map ('@', posix_edit_macros, vi_movement_keymap);
  #  endif
  #endif
***************
*** 319,323 ****
  
    /* characters that need to be quoted when appearing in filenames. */
!   rl_filename_quote_characters = " \t\n\\\"'@<>=;|&()#$`?*[!:";
    rl_filename_quoting_function = bash_quote_filename;
    rl_filename_dequoting_function = bash_dequote_filename;
--- 340,344 ----
  
    /* characters that need to be quoted when appearing in filenames. */
!   rl_filename_quote_characters = " \t\n\\\"'@<>=;|&()#$`?*[!:{";	/*}*/
    rl_filename_quoting_function = bash_quote_filename;
    rl_filename_dequoting_function = bash_dequote_filename;
***************
*** 340,346 ****
    tilde_initialize ();
    rl_attempted_completion_function = attempt_shell_completion;
!   rl_completion_entry_function = (Function *)NULL;
    rl_directory_completion_hook = bash_directory_completion_hook;
!   rl_ignore_some_completions_function = (Function *)filename_completion_ignore;
  }
  
--- 361,367 ----
    tilde_initialize ();
    rl_attempted_completion_function = attempt_shell_completion;
!   rl_completion_entry_function = NULL;
    rl_directory_completion_hook = bash_directory_completion_hook;
!   rl_ignore_some_completions_function = filename_completion_ignore;
  }
  
***************
*** 350,354 ****
  /* Push the contents of push_to_readline into the
     readline buffer. */
! static void
  bash_push_line ()
  {
--- 371,375 ----
  /* Push the contents of push_to_readline into the
     readline buffer. */
! static int
  bash_push_line ()
  {
***************
*** 360,363 ****
--- 381,385 ----
        rl_startup_hook = old_rl_startup_hook;
      }
+   return 0;
  }
  
***************
*** 372,385 ****
    push_to_readline = savestring (line);
    old_rl_startup_hook = rl_startup_hook;
!   rl_startup_hook = (Function *)bash_push_line;
  
    return (0);
  }
  
! static void
  display_shell_version (count, c)
       int count, c;
  {
!   crlf ();
    show_shell_version (0);
    putc ('\r', rl_outstream);
--- 394,407 ----
    push_to_readline = savestring (line);
    old_rl_startup_hook = rl_startup_hook;
!   rl_startup_hook = bash_push_line;
  
    return (0);
  }
  
! static int
  display_shell_version (count, c)
       int count, c;
  {
!   rl_crlf ();
    show_shell_version (0);
    putc ('\r', rl_outstream);
***************
*** 387,390 ****
--- 409,413 ----
    rl_on_new_line ();
    rl_redisplay ();
+   return 0;
  }
  
***************
*** 570,574 ****
      {
        if (STREQN (text, hostname_list[i], len) == 0)
!         continue;
  
        /* OK, it matches.  Add it to the list. */
--- 593,597 ----
      {
        if (STREQN (text, hostname_list[i], len) == 0)
! 	continue;
  
        /* OK, it matches.  Add it to the list. */
***************
*** 590,594 ****
  static int saved_history_line_to_use = -1;
  
! static void
  set_saved_history ()
  {
--- 613,617 ----
  static int saved_history_line_to_use = -1;
  
! static int
  set_saved_history ()
  {
***************
*** 599,603 ****
  }
  
! static void
  operate_and_get_next (count, c)
       int count, c;
--- 622,626 ----
  }
  
! static int
  operate_and_get_next (count, c)
       int count, c;
***************
*** 611,615 ****
    where = where_history ();
  
!   if ((history_is_stifled () && (history_length >= max_input_history)) ||
        (where >= history_length - 1))
      saved_history_line_to_use = where;
--- 634,638 ----
    where = where_history ();
  
!   if ((history_is_stifled () && (history_length >= history_max_entries)) ||
        (where >= history_length - 1))
      saved_history_line_to_use = where;
***************
*** 618,622 ****
  
    old_rl_startup_hook = rl_startup_hook;
!   rl_startup_hook = (Function *)set_saved_history;
  }
  
--- 641,647 ----
  
    old_rl_startup_hook = rl_startup_hook;
!   rl_startup_hook = set_saved_history;
! 
!   return 0;
  }
  
***************
*** 628,636 ****
  #define VI_EDIT_COMMAND "fc -e ${VISUAL:-${EDITOR:-vi}}"
  
! static void
  vi_edit_and_execute_command (count, c)
       int count, c;
  {
    char *command;
  
    /* Accept the current line. */
--- 653,662 ----
  #define VI_EDIT_COMMAND "fc -e ${VISUAL:-${EDITOR:-vi}}"
  
! static int
  vi_edit_and_execute_command (count, c)
       int count, c;
  {
    char *command;
+   int r;
  
    /* Accept the current line. */
***************
*** 655,660 ****
        command = savestring (VI_EDIT_COMMAND);
      }
!   parse_and_execute (command, "v", SEVAL_NOHIST);
    rl_line_buffer[0] = '\0';	/* XXX */
  }
  #endif /* VI_MODE */
--- 681,688 ----
        command = savestring (VI_EDIT_COMMAND);
      }
!   r = parse_and_execute (command, "v", SEVAL_NOHIST);
    rl_line_buffer[0] = '\0';	/* XXX */
+ 
+   return r;
  }
  #endif /* VI_MODE */
***************
*** 774,778 ****
  static char **
  attempt_shell_completion (text, start, end)
!      char *text;
       int start, end;
  {
--- 802,806 ----
  static char **
  attempt_shell_completion (text, start, end)
!      const char *text;
       int start, end;
  {
***************
*** 782,786 ****
    command_separator_chars = COMMAND_SEPARATORS;
    matches = (char **)NULL;
!   rl_ignore_some_completions_function = (Function *)filename_completion_ignore;
  
    /* Determine if this could be a command word.  It is if it appears at
--- 810,814 ----
    command_separator_chars = COMMAND_SEPARATORS;
    matches = (char **)NULL;
!   rl_ignore_some_completions_function = filename_completion_ignore;
  
    /* Determine if this could be a command word.  It is if it appears at
***************
*** 802,806 ****
        saveti = ti--;
        while (ti > -1 && (whitespace (rl_line_buffer[ti])))
!         ti--;
      }
  #endif
--- 830,834 ----
        saveti = ti--;
        while (ti > -1 && (whitespace (rl_line_buffer[ti])))
! 	ti--;
      }
  #endif
***************
*** 810,814 ****
      {
        /* Only do command completion at the start of a line when we
!          are prompting at the top level. */
        if (current_prompt_string == ps1_prompt)
  	in_command_position++;
--- 838,842 ----
      {
        /* Only do command completion at the start of a line when we
! 	 are prompting at the top level. */
        if (current_prompt_string == ps1_prompt)
  	in_command_position++;
***************
*** 819,823 ****
  
        if (check_redir (ti) == 1)
!         in_command_position = 0;
      }
    else
--- 847,851 ----
  
        if (check_redir (ti) == 1)
! 	in_command_position = 0;
      }
    else
***************
*** 841,845 ****
  	(in_command_position || (unclosed_pair (rl_line_buffer, start, "`") &&
  				 unclosed_pair (rl_line_buffer, end, "`"))))
!     matches = completion_matches (text, command_subst_completion_function);
  
  #if defined (PROGRAMMABLE_COMPLETION)
--- 869,873 ----
  	(in_command_position || (unclosed_pair (rl_line_buffer, start, "`") &&
  				 unclosed_pair (rl_line_buffer, end, "`"))))
!     matches = rl_completion_matches (text, command_subst_completion_function);
  
  #if defined (PROGRAMMABLE_COMPLETION)
***************
*** 863,874 ****
        /* XXX - if we found a COMPSPEC for the command, just return whatever
  	 the programmable completion code returns, and disable the default
! 	 filename completion that readline will do. */
        if (foundcs)
  	{
  	  /* Turn what the programmable completion code returns into what
  	     readline wants.  I should have made compute_lcd_of_matches
  	     external... */
! 	  matches = completion_matches (text, prog_complete_return);
! 	  rl_attempted_completion_over = 1;	/* no default */
  	  return (matches);
  	}
--- 891,908 ----
        /* XXX - if we found a COMPSPEC for the command, just return whatever
  	 the programmable completion code returns, and disable the default
! 	 filename completion that readline will do unless the COPT_DEFAULT
! 	 option has been set with the `-o default' option to complete. */
        if (foundcs)
  	{
+ 	  /* If the user specified that the compspec returns filenames, make
+ 	     sure that readline knows it.
+ 	  if (foundcs & COPT_FILENAMES)
+ 	    rl_filename_completion_desired = 1;
  	  /* Turn what the programmable completion code returns into what
  	     readline wants.  I should have made compute_lcd_of_matches
  	     external... */
! 	  matches = rl_completion_matches (text, prog_complete_return);
! 	  if ((foundcs & COPT_DEFAULT) == 0)
! 	    rl_attempted_completion_over = 1;	/* no default */
  	  return (matches);
  	}
***************
*** 880,886 ****
      {
        if (qc != '\'' && text[1] == '(') /* ) */
! 	matches = completion_matches (text, command_subst_completion_function);
        else
! 	matches = completion_matches (text, variable_completion_function);
      }
  
--- 914,920 ----
      {
        if (qc != '\'' && text[1] == '(') /* ) */
! 	matches = rl_completion_matches (text, command_subst_completion_function);
        else
! 	matches = rl_completion_matches (text, variable_completion_function);
      }
  
***************
*** 888,897 ****
       try completing this word as a username. */
    if (!matches && *text == '~' && !strchr (text, '/'))
!     matches = completion_matches (text, username_completion_function);
  
    /* Another one.  Why not?  If the word starts in '@', then look through
       the world of known hostnames for completion first. */
    if (!matches && perform_hostname_completion && *text == '@')
!     matches = completion_matches (text, hostname_completion_function);
  
    /* And last, (but not least) if this word is in a command position, then
--- 922,931 ----
       try completing this word as a username. */
    if (!matches && *text == '~' && !strchr (text, '/'))
!     matches = rl_completion_matches (text, rl_username_completion_function);
  
    /* Another one.  Why not?  If the word starts in '@', then look through
       the world of known hostnames for completion first. */
    if (!matches && perform_hostname_completion && *text == '@')
!     matches = rl_completion_matches (text, hostname_completion_function);
  
    /* And last, (but not least) if this word is in a command position, then
***************
*** 903,911 ****
  	{
  	  matches = (char **)NULL;
! 	  rl_ignore_some_completions_function = (Function *)bash_ignore_everything;
  	}
        else
  	{
! 	  matches = completion_matches (text, command_word_completion_function);
  	  /* If we are attempting command completion and nothing matches, we
  	     do not want readline to perform filename completion for us.  We
--- 937,945 ----
  	{
  	  matches = (char **)NULL;
! 	  rl_ignore_some_completions_function = bash_ignore_everything;
  	}
        else
  	{
! 	  matches = rl_completion_matches (text, command_word_completion_function);
  	  /* If we are attempting command completion and nothing matches, we
  	     do not want readline to perform filename completion for us.  We
***************
*** 914,918 ****
  	     filenames and leave directories in the match list. */
  	  if (matches == (char **)NULL)
! 	    rl_ignore_some_completions_function = (Function *)bash_ignore_filenames;
  	}
      }
--- 948,952 ----
  	     filenames and leave directories in the match list. */
  	  if (matches == (char **)NULL)
! 	    rl_ignore_some_completions_function = bash_ignore_filenames;
  	}
      }
***************
*** 920,926 ****
    /* This could be a globbing pattern, so try to expand it using pathname
       expansion. */
!   if (!matches && glob_pattern_p (text))
      {
!       matches = completion_matches (text, glob_complete_word);
        /* A glob expression that matches more than one filename is problematic.
  	 If we match more than one filename, punt. */
--- 954,960 ----
    /* This could be a globbing pattern, so try to expand it using pathname
       expansion. */
!   if (!matches && glob_pattern_p ((char *)text))	/* XXX fix const later */
      {
!       matches = rl_completion_matches (text, glob_complete_word);
        /* A glob expression that matches more than one filename is problematic.
  	 If we match more than one filename, punt. */
***************
*** 941,945 ****
  char *
  command_word_completion_function (hint_text, state)
!      char *hint_text;
       int state;
  {
--- 975,979 ----
  char *
  command_word_completion_function (hint_text, state)
!      const char *hint_text;
       int state;
  {
***************
*** 969,978 ****
  	 whether or not it is unique, and, if so, whether that filename
  	 is executable. */
!       if (absolute_program (hint_text))
  	{
  	  /* Perform tilde expansion on what's passed, so we don't end up
  	     passing filenames with tildes directly to stat(). */
  	  if (*hint_text == '~')
! 	    hint = bash_tilde_expand (hint_text);
  	  else
  	    hint = savestring (hint_text);
--- 1003,1012 ----
  	 whether or not it is unique, and, if so, whether that filename
  	 is executable. */
!       if (absolute_program ((char *)hint_text))
  	{
  	  /* Perform tilde expansion on what's passed, so we don't end up
  	     passing filenames with tildes directly to stat(). */
  	  if (*hint_text == '~')
! 	    hint = bash_tilde_expand ((char *)hint_text);
  	  else
  	    hint = savestring (hint_text);
***************
*** 1120,1124 ****
  
   inner:
!   val = filename_completion_function (filename_hint, istate);
    istate = 1;
  
--- 1154,1158 ----
  
   inner:
!   val = rl_filename_completion_function (filename_hint, istate);
    istate = 1;
  
***************
*** 1173,1177 ****
        /* If we have found a match, and it is an executable file or a
  	 directory name, return it. */
!       if (match && (executable_file (val) || is_directory (val)))
  	{
  	  free (val);
--- 1207,1211 ----
        /* If we have found a match, and it is an executable file or a
  	 directory name, return it. */
!       if (match && executable_or_directory (val))
  	{
  	  free (val);
***************
*** 1192,1200 ****
  static char *
  command_subst_completion_function (text, state)
!      char *text;
       int state;
  {
    static char **matches = (char **)NULL;
!   static char *orig_start, *filename_text = (char *)NULL;
    static int cmd_index, start_len;
    char *value;
--- 1226,1235 ----
  static char *
  command_subst_completion_function (text, state)
!      const char *text;
       int state;
  {
    static char **matches = (char **)NULL;
!   static const char *orig_start;
!   static char *filename_text = (char *)NULL;
    static int cmd_index, start_len;
    char *value;
***************
*** 1206,1217 ****
        orig_start = text;
        if (*text == '`')
!         text++;
        else if (*text == '$' && text[1] == '(')	/* ) */
!         text += 2;
        start_len = text - orig_start;
        filename_text = savestring (text);
        if (matches)
  	free (matches);
!       matches = completion_matches (filename_text, command_word_completion_function);
        cmd_index = 0;
      }
--- 1241,1252 ----
        orig_start = text;
        if (*text == '`')
! 	text++;
        else if (*text == '$' && text[1] == '(')	/* ) */
! 	text += 2;
        start_len = text - orig_start;
        filename_text = savestring (text);
        if (matches)
  	free (matches);
!       matches = rl_completion_matches (filename_text, command_word_completion_function);
        cmd_index = 0;
      }
***************
*** 1227,1233 ****
  
        if (start_len == 1)
!         value[0] = *orig_start;
        else
!         strncpy (value, orig_start, start_len);
  
        strcpy (value + start_len, matches[cmd_index]);
--- 1262,1268 ----
  
        if (start_len == 1)
! 	value[0] = *orig_start;
        else
! 	strncpy (value, orig_start, start_len);
  
        strcpy (value + start_len, matches[cmd_index]);
***************
*** 1241,1246 ****
  static char *
  variable_completion_function (text, state)
       int state;
-      char *text;
  {
    static char **varlist = (char **)NULL;
--- 1276,1281 ----
  static char *
  variable_completion_function (text, state)
+      const char *text;
       int state;
  {
    static char **varlist = (char **)NULL;
***************
*** 1262,1266 ****
  
        if (text[first_char_loc] == '{')
!         first_char_loc++;
  
        varname = savestring (text + first_char_loc);
--- 1297,1301 ----
  
        if (text[first_char_loc] == '{')
! 	first_char_loc++;
  
        varname = savestring (text + first_char_loc);
***************
*** 1291,1295 ****
        strcpy (value + first_char_loc, varlist[varlist_index]);
        if (first_char_loc == 2)
!         strcat (value, "}");
  
        varlist_index++;
--- 1326,1330 ----
        strcpy (value + first_char_loc, varlist[varlist_index]);
        if (first_char_loc == 2)
! 	strcat (value, "}");
  
        varlist_index++;
***************
*** 1301,1306 ****
  static char *
  hostname_completion_function (text, state)
       int state;
-      char *text;
  {
    static char **list = (char **)NULL;
--- 1336,1341 ----
  static char *
  hostname_completion_function (text, state)
+      const char *text;
       int state;
  {
    static char **list = (char **)NULL;
***************
*** 1417,1422 ****
  /* Expand aliases in the current readline line. */
  static int
! alias_expand_line (ignore)
!      int ignore;
  {
    char *new_line;
--- 1452,1457 ----
  /* Expand aliases in the current readline line. */
  static int
! alias_expand_line (count, ignore)
!      int count, ignore;
  {
    char *new_line;
***************
*** 1440,1445 ****
  /* History expand the line. */
  static int
! history_expand_line (ignore)
!      int ignore;
  {
    char *new_line;
--- 1475,1480 ----
  /* History expand the line. */
  static int
! history_expand_line (count, ignore)
!      int count, ignore;
  {
    char *new_line;
***************
*** 1460,1470 ****
  
  /* Expand history substitutions in the current line and then insert a
!    space wherever set_up_new_line decided to put rl_point. */
  static int
! tcsh_magic_space (ignore)
!      int ignore;
  {
!   if (history_expand_line (ignore) == 0)
!     {
        rl_insert (1, ' ');
        return (0);
--- 1495,1513 ----
  
  /* Expand history substitutions in the current line and then insert a
!    space (hopefully close to where we were before). */
  static int
! tcsh_magic_space (count, ignore)
!      int count, ignore;
  {
!   int dist_from_end, old_point;
! 
!   old_point = rl_point;
!   dist_from_end = rl_end - rl_point;
!   if (history_expand_line (count, ignore) == 0)
!     {
!       /* Try a simple heuristic from Stephen Gildea <gildea@intouchsys.com>.
! 	 This works if all expansions were before rl_point or if no expansions
! 	 were performed. */
!       rl_point = (old_point == 0) ? old_point : rl_end - dist_from_end;
        rl_insert (1, ' ');
        return (0);
***************
*** 1477,1482 ****
  /* History and alias expand the line. */
  static int
! history_and_alias_expand_line (ignore)
!      int ignore;
  {
    char *new_line;
--- 1520,1525 ----
  /* History and alias expand the line. */
  static int
! history_and_alias_expand_line (count, ignore)
!      int count, ignore;
  {
    char *new_line;
***************
*** 1513,1519 ****
     because we want the variable expansions as a separate undo'able
     set of operations. */
! static void
! shell_expand_line (ignore)
!      int ignore;
  {
    char *new_line;
--- 1556,1562 ----
     because we want the variable expansions as a separate undo'able
     set of operations. */
! static int
! shell_expand_line (count, ignore)
!      int count, ignore;
  {
    char *new_line;
***************
*** 1573,1579 ****
  	    rl_forward_word (1, 0);
  	}
      }
    else
!     cleanup_expansion_error ();
  }
  
--- 1616,1626 ----
  	    rl_forward_word (1, 0);
  	}
+       return 0;
      }
    else
!     {
!       cleanup_expansion_error ();
!       return 1;
!     }
  }
  
***************
*** 1619,1626 ****
  #ifndef NO_FORCE_FIGNORE
        if ((*name_func) (names[0]) == 0)
!         {
!           free (names[0]);
!           names[0] = (char *)NULL;
!         }
  #endif
        return;
--- 1666,1673 ----
  #ifndef NO_FORCE_FIGNORE
        if ((*name_func) (names[0]) == 0)
! 	{
! 	  free (names[0]);
! 	  names[0] = (char *)NULL;
! 	}
  #endif
        return;
***************
*** 1644,1648 ****
        else
  #ifndef NO_FORCE_FIGNORE
!         free (names[idx]);
  #else
  	oldnames[oidx++] = names[idx];
--- 1691,1695 ----
        else
  #ifndef NO_FORCE_FIGNORE
! 	free (names[idx]);
  #else
  	oldnames[oidx++] = names[idx];
***************
*** 1714,1718 ****
  #endif
  
! static void
  filename_completion_ignore (names)
       char **names;
--- 1761,1765 ----
  #endif
  
! static int
  filename_completion_ignore (names)
       char **names;
***************
*** 1726,1732 ****
  
    if (fignore.num_ignores == 0)
!     return;
  
    _ignore_completion_names (names, name_is_acceptable);
  }
  
--- 1773,1781 ----
  
    if (fignore.num_ignores == 0)
!     return 0;
  
    _ignore_completion_names (names, name_is_acceptable);
+ 
+   return 0;
  }
  
***************
*** 1750,1758 ****
  
  /* Remove files from NAMES, leaving directories. */
! static void
  bash_ignore_filenames (names)
       char **names;
  {
    _ignore_completion_names (names, test_for_directory);
  }
  
--- 1799,1808 ----
  
  /* Remove files from NAMES, leaving directories. */
! static int
  bash_ignore_filenames (names)
       char **names;
  {
    _ignore_completion_names (names, test_for_directory);
+   return 0;
  }
  
***************
*** 1764,1772 ****
  }
  
! static void
  bash_ignore_everything (names)
       char **names;
  {
    _ignore_completion_names (names, return_zero);
  }
  
--- 1814,1823 ----
  }
  
! static int
  bash_ignore_everything (names)
       char **names;
  {
    _ignore_completion_names (names, return_zero);
+   return 0;
  }
  
***************
*** 1830,1834 ****
        temp1 = make_absolute (local_dirname, t);
        free (t);
!       temp2 = canonicalize_pathname (temp1);
        /* If we can't canonicalize, bail. */
        if (temp2 == 0)
--- 1881,1885 ----
        temp1 = make_absolute (local_dirname, t);
        free (t);
!       temp2 = sh_canonpath (temp1, PATH_CHECKDOTDOT|PATH_CHECKEXISTS);
        /* If we can't canonicalize, bail. */
        if (temp2 == 0)
***************
*** 1839,1848 ****
        len1 = strlen (temp1);
        if (temp1[len1 - 1] == '/')
!         {
  	  len2 = strlen (temp2);
!           temp2 = xrealloc (temp2, len2 + 2);
!           temp2[len2] = '/';
!           temp2[len2 + 1] = '\0';
!         }
        free (local_dirname);
        *dirname = temp2;
--- 1890,1899 ----
        len1 = strlen (temp1);
        if (temp1[len1 - 1] == '/')
! 	{
  	  len2 = strlen (temp2);
! 	  temp2 = xrealloc (temp2, len2 + 2);
! 	  temp2[len2] = '/';
! 	  temp2[len2 + 1] = '\0';
! 	}
        free (local_dirname);
        *dirname = temp2;
***************
*** 1933,1949 ****
  }
  
! static void
  dynamic_complete_history (count, key)
       int count, key;
  {
!   Function *orig_func;
!   CPPFunction *orig_attempt_func;
  
    orig_func = rl_completion_entry_function;
    orig_attempt_func = rl_attempted_completion_function;
!   rl_completion_entry_function = (Function *)history_completion_generator;
!   rl_attempted_completion_function = (CPPFunction *)NULL;
  
!   if (rl_last_func == (Function *)dynamic_complete_history)
      rl_complete_internal ('?');
    else
--- 1984,2000 ----
  }
  
! static int
  dynamic_complete_history (count, key)
       int count, key;
  {
!   rl_compentry_func_t *orig_func;
!   rl_completion_func_t *orig_attempt_func;
  
    orig_func = rl_completion_entry_function;
    orig_attempt_func = rl_attempted_completion_function;
!   rl_completion_entry_function = history_completion_generator;
!   rl_attempted_completion_function = (rl_completion_func_t *)NULL;
  
!   if (rl_last_func == dynamic_complete_history)
      rl_complete_internal ('?');
    else
***************
*** 1955,2001 ****
  
  #if defined (SPECIFIC_COMPLETION_FUNCTIONS)
! static void
  bash_complete_username (ignore, ignore2)
       int ignore, ignore2;
  {
!   bash_complete_username_internal (TAB);
  }
  
! static void
  bash_possible_username_completions (ignore, ignore2)
       int ignore, ignore2;
  {
!   bash_complete_username_internal ('?');
  }
  
! static void
  bash_complete_username_internal (what_to_do)
       int what_to_do;
  {
!   bash_specific_completion
!     (what_to_do, (Function *)username_completion_function);
  }
  
! static void
  bash_complete_filename (ignore, ignore2)
       int ignore, ignore2;
  {
!   bash_complete_filename_internal (TAB);
  }
  
! static void
  bash_possible_filename_completions (ignore, ignore2)
       int ignore, ignore2;
  {
!   bash_complete_filename_internal ('?');
  }
  
! static void
  bash_complete_filename_internal (what_to_do)
       int what_to_do;
  {
!   Function  *orig_func, *orig_dir_func;
!   CPPFunction *orig_attempt_func;
!   char *orig_rl_completer_word_break_characters;
  
    orig_func = rl_completion_entry_function;
--- 2006,2053 ----
  
  #if defined (SPECIFIC_COMPLETION_FUNCTIONS)
! static int
  bash_complete_username (ignore, ignore2)
       int ignore, ignore2;
  {
!   return bash_complete_username_internal (TAB);
  }
  
! static int
  bash_possible_username_completions (ignore, ignore2)
       int ignore, ignore2;
  {
!   return bash_complete_username_internal ('?');
  }
  
! static int
  bash_complete_username_internal (what_to_do)
       int what_to_do;
  {
!   return bash_specific_completion (what_to_do, rl_username_completion_function);
  }
  
! static int
  bash_complete_filename (ignore, ignore2)
       int ignore, ignore2;
  {
!   return bash_complete_filename_internal (TAB);
  }
  
! static int
  bash_possible_filename_completions (ignore, ignore2)
       int ignore, ignore2;
  {
!   return bash_complete_filename_internal ('?');
  }
  
! static int
  bash_complete_filename_internal (what_to_do)
       int what_to_do;
  {
!   rl_compentry_func_t *orig_func;
!   rl_completion_func_t *orig_attempt_func;
!   rl_icppfunc_t *orig_dir_func;
!   const char *orig_rl_completer_word_break_characters;
!   int r;
  
    orig_func = rl_completion_entry_function;
***************
*** 2003,2012 ****
    orig_dir_func = rl_directory_completion_hook;
    orig_rl_completer_word_break_characters = rl_completer_word_break_characters;
!   rl_completion_entry_function = (Function *)filename_completion_function;
!   rl_attempted_completion_function = (CPPFunction *)NULL;
!   rl_directory_completion_hook = (Function *)NULL;
    rl_completer_word_break_characters = " \t\n\"\'";
  
!   rl_complete_internal (what_to_do);
  
    rl_completion_entry_function = orig_func;
--- 2055,2064 ----
    orig_dir_func = rl_directory_completion_hook;
    orig_rl_completer_word_break_characters = rl_completer_word_break_characters;
!   rl_completion_entry_function = rl_filename_completion_function;
!   rl_attempted_completion_function = (rl_completion_func_t *)NULL;
!   rl_directory_completion_hook = (rl_icppfunc_t *)NULL;
    rl_completer_word_break_characters = " \t\n\"\'";
  
!   r = rl_complete_internal (what_to_do);
  
    rl_completion_entry_function = orig_func;
***************
*** 2014,2088 ****
    rl_directory_completion_hook = orig_dir_func;
    rl_completer_word_break_characters = orig_rl_completer_word_break_characters;
  }
  
! static void
  bash_complete_hostname (ignore, ignore2)
       int ignore, ignore2;
  {
!   bash_complete_hostname_internal (TAB);
  }
  
! static void
  bash_possible_hostname_completions (ignore, ignore2)
       int ignore, ignore2;
  {
!   bash_complete_hostname_internal ('?');
  }
  
! static void
  bash_complete_variable (ignore, ignore2)
       int ignore, ignore2;
  {
!   bash_complete_variable_internal (TAB);
  }
  
! static void
  bash_possible_variable_completions (ignore, ignore2)
       int ignore, ignore2;
  {
!   bash_complete_variable_internal ('?');
  }
  
! static void
  bash_complete_command (ignore, ignore2)
       int ignore, ignore2;
  {
!   bash_complete_command_internal (TAB);
  }
  
! static void
  bash_possible_command_completions (ignore, ignore2)
       int ignore, ignore2;
  {
!   bash_complete_command_internal ('?');
  }
  
! static void
  bash_complete_hostname_internal (what_to_do)
       int what_to_do;
  {
!   bash_specific_completion
!     (what_to_do, (Function *)hostname_completion_function);
  }
  
! static void
  bash_complete_variable_internal (what_to_do)
       int what_to_do;
  {
!   bash_specific_completion
!     (what_to_do, (Function *)variable_completion_function);
  }
  
! static void
  bash_complete_command_internal (what_to_do)
       int what_to_do;
  {
!   bash_specific_completion
!     (what_to_do, (Function *)command_word_completion_function);
  }
  
  static char *
  glob_complete_word (text, state)
!      char *text;
       int state;
  {
--- 2066,2139 ----
    rl_directory_completion_hook = orig_dir_func;
    rl_completer_word_break_characters = orig_rl_completer_word_break_characters;
+ 
+   return r;
  }
  
! static int
  bash_complete_hostname (ignore, ignore2)
       int ignore, ignore2;
  {
!   return bash_complete_hostname_internal (TAB);
  }
  
! static int
  bash_possible_hostname_completions (ignore, ignore2)
       int ignore, ignore2;
  {
!   return bash_complete_hostname_internal ('?');
  }
  
! static int
  bash_complete_variable (ignore, ignore2)
       int ignore, ignore2;
  {
!   return bash_complete_variable_internal (TAB);
  }
  
! static int
  bash_possible_variable_completions (ignore, ignore2)
       int ignore, ignore2;
  {
!   return bash_complete_variable_internal ('?');
  }
  
! static int
  bash_complete_command (ignore, ignore2)
       int ignore, ignore2;
  {
!   return bash_complete_command_internal (TAB);
  }
  
! static int
  bash_possible_command_completions (ignore, ignore2)
       int ignore, ignore2;
  {
!   return bash_complete_command_internal ('?');
  }
  
! static int
  bash_complete_hostname_internal (what_to_do)
       int what_to_do;
  {
!   return bash_specific_completion (what_to_do, hostname_completion_function);
  }
  
! static int
  bash_complete_variable_internal (what_to_do)
       int what_to_do;
  {
!   return bash_specific_completion (what_to_do, variable_completion_function);
  }
  
! static int
  bash_complete_command_internal (what_to_do)
       int what_to_do;
  {
!   return bash_specific_completion (what_to_do, command_word_completion_function);
  }
  
  static char *
  glob_complete_word (text, state)
!      const char *text;
       int state;
  {
***************
*** 2095,2102 ****
        rl_filename_completion_desired = 1;
        if (matches)
!         free (matches);
        matches = shell_glob_filename (text);
        if (GLOB_FAILED (matches))
!         matches = (char **)NULL;
        ind = 0;
      }
--- 2146,2153 ----
        rl_filename_completion_desired = 1;
        if (matches)
! 	free (matches);
        matches = shell_glob_filename (text);
        if (GLOB_FAILED (matches))
! 	matches = (char **)NULL;
        ind = 0;
      }
***************
*** 2107,2148 ****
  }
  
! static void
  bash_glob_completion_internal (what_to_do)
       int what_to_do;
  {
!   bash_specific_completion (what_to_do, (Function *)glob_complete_word);
  }
  
! static void
  bash_glob_expand_word (count, key)
       int count, key;
  {
!   bash_glob_completion_internal ('*');
  }
  
! static void
  bash_glob_list_expansions (count, key)
       int count, key;
  {
!   bash_glob_completion_internal ('?');
  }
  
! static void
  bash_specific_completion (what_to_do, generator)
       int what_to_do;
!      Function *generator;
  {
!   Function *orig_func;
!   CPPFunction *orig_attempt_func;
  
    orig_func = rl_completion_entry_function;
    orig_attempt_func = rl_attempted_completion_function;
    rl_completion_entry_function = generator;
!   rl_attempted_completion_function = (CPPFunction *)NULL;
  
!   rl_complete_internal (what_to_do);
  
    rl_completion_entry_function = orig_func;
    rl_attempted_completion_function = orig_attempt_func;
  }
  
--- 2158,2202 ----
  }
  
! static int
  bash_glob_completion_internal (what_to_do)
       int what_to_do;
  {
!   return bash_specific_completion (what_to_do, glob_complete_word);
  }
  
! static int
  bash_glob_expand_word (count, key)
       int count, key;
  {
!   return bash_glob_completion_internal ('*');
  }
  
! static int
  bash_glob_list_expansions (count, key)
       int count, key;
  {
!   return bash_glob_completion_internal ('?');
  }
  
! static int
  bash_specific_completion (what_to_do, generator)
       int what_to_do;
!      rl_compentry_func_t *generator;
  {
!   rl_compentry_func_t *orig_func;
!   rl_completion_func_t *orig_attempt_func;
!   int r;
  
    orig_func = rl_completion_entry_function;
    orig_attempt_func = rl_attempted_completion_function;
    rl_completion_entry_function = generator;
!   rl_attempted_completion_function = NULL;
  
!   r = rl_complete_internal (what_to_do);
  
    rl_completion_entry_function = orig_func;
    rl_attempted_completion_function = orig_attempt_func;
+ 
+   return r;
  }
  
***************
*** 2156,2159 ****
--- 2210,2214 ----
  bash_dequote_filename (text, quote_char)
       char *text;
+      int quote_char;
  {
    char *ret, *p, *r;
***************
*** 2174,2187 ****
        /* Close quote. */
        if (quoted && *p == quoted)
!         {
!           quoted = 0;
!           continue;
!         }
        /* Open quote. */
        if (quoted == 0 && (*p == '\'' || *p == '"'))
!         {
!           quoted = *p;
!           continue;
!         }
        *r++ = *p;
      }
--- 2229,2242 ----
        /* Close quote. */
        if (quoted && *p == quoted)
! 	{
! 	  quoted = 0;
! 	  continue;
! 	}
        /* Open quote. */
        if (quoted == 0 && (*p == '\'' || *p == '"'))
! 	{
! 	  quoted = *p;
! 	  continue;
! 	}
        *r++ = *p;
      }
***************
*** 2216,2220 ****
  	 rl_completer_word_break_characters. */
        if (strchr (rl_completer_word_break_characters, *s))
!         *r++ = '\\';
        *r++ = *s;
      }
--- 2271,2275 ----
  	 rl_completer_word_break_characters. */
        if (strchr (rl_completer_word_break_characters, *s))
! 	*r++ = '\\';
        *r++ = *s;
      }
***************
*** 2269,2273 ****
  
    if (*qcp == '"' && history_expansion && cs == COMPLETE_DQUOTE &&
!         history_expansion_inhibited == 0 && strchr (mtext, '!'))
      {
        cs = COMPLETE_BSQUOTE;
--- 2324,2328 ----
  
    if (*qcp == '"' && history_expansion && cs == COMPLETE_DQUOTE &&
! 	history_expansion_inhibited == 0 && strchr (mtext, '!'))
      {
        cs = COMPLETE_BSQUOTE;
***************
*** 2279,2289 ****
      {
      case COMPLETE_DQUOTE:
!       rtext = double_quote (mtext);
        break;
      case COMPLETE_SQUOTE:
!       rtext = single_quote (mtext);
        break;
      case COMPLETE_BSQUOTE:
!       rtext = backslash_quote (mtext);
        break;
      }
--- 2334,2344 ----
      {
      case COMPLETE_DQUOTE:
!       rtext = sh_double_quote (mtext);
        break;
      case COMPLETE_SQUOTE:
!       rtext = sh_single_quote (mtext);
        break;
      case COMPLETE_BSQUOTE:
!       rtext = sh_backslash_quote (mtext);
        break;
      }
***************
*** 2339,2349 ****
  	}
        if (i < KEYMAP_SIZE)
!         xkmap = (Keymap)cmd_xmap[i].function;
        else
  	{
! 	  crlf ();
!           internal_error ("bash_execute_unix_command: cannot find keymap for command");
!           rl_forced_update_display ();
!           return 1;
  	}
      }
--- 2394,2404 ----
  	}
        if (i < KEYMAP_SIZE)
! 	xkmap = (Keymap)cmd_xmap[i].function;
        else
  	{
! 	  rl_crlf ();
! 	  internal_error ("bash_execute_unix_command: cannot find keymap for command");
! 	  rl_forced_update_display ();
! 	  return 1;
  	}
      }
***************
*** 2355,2363 ****
    if (cmd == 0)
      {
!       ding ();
        return 1;
      }
  
!   crlf ();	/* move to a new line */
  
    cmd = savestring (cmd);
--- 2410,2418 ----
    if (cmd == 0)
      {
!       rl_ding ();
        return 1;
      }
  
!   rl_crlf ();	/* move to a new line */
  
    cmd = savestring (cmd);
***************
*** 2412,2416 ****
  	}
        if (c == delim)
!         break;
      }
  
--- 2467,2471 ----
  	}
        if (c == delim)
! 	break;
      }
  
***************
*** 2467,2471 ****
    /* and bind the key sequence in the current keymap to a function that
       understands how to execute from CMD_XMAP */
!   rl_set_key (kseq, (Function *)bash_execute_unix_command, kmap);
    
    return 0;
--- 2522,2526 ----
    /* and bind the key sequence in the current keymap to a function that
       understands how to execute from CMD_XMAP */
!   rl_set_key (kseq, bash_execute_unix_command, kmap);
    
    return 0;
***************
*** 2477,2481 ****
  char **
  bash_directory_completion_matches (text)
!      char *text;
  {
    char **m1;
--- 2532,2536 ----
  char **
  bash_directory_completion_matches (text)
!      const char *text;
  {
    char **m1;
***************
*** 2484,2489 ****
  
    qc = (text[0] == '"' || text[0] == '\'') ? text[0] : 0;
!   dfn = bash_dequote_filename (text, qc);
!   m1 = completion_matches (dfn, filename_completion_function);
    free (dfn);
  
--- 2539,2544 ----
  
    qc = (text[0] == '"' || text[0] == '\'') ? text[0] : 0;
!   dfn = bash_dequote_filename ((char *)text, qc);
!   m1 = rl_completion_matches (dfn, rl_filename_completion_function);
    free (dfn);
  
diff -Nrc2 bash-2.04/bashline.h bash-2.05/bashline.h
*** bash-2.04/bashline.h	Thu Aug  5 07:02:25 1999
--- bash-2.05/bashline.h	Mon Nov 27 12:23:19 2000
***************
*** 34,43 ****
  
  /* Used by programmable completion code. */
! extern char *command_word_completion_function __P((char *, int));
  
  extern char **get_hostname_list __P((void));
  extern void clear_hostname_list __P((void));
  
! extern char **bash_directory_completion_matches __P((char *));
  
  #endif /* _BASHLINE_H_ */
--- 34,43 ----
  
  /* Used by programmable completion code. */
! extern char *command_word_completion_function __P((const char *, int));
  
  extern char **get_hostname_list __P((void));
  extern void clear_hostname_list __P((void));
  
! extern char **bash_directory_completion_matches __P((const char *));
  
  #endif /* _BASHLINE_H_ */
diff -Nrc2 bash-2.04/bracecomp.c bash-2.05/bracecomp.c
*** bash-2.04/bracecomp.c	Thu Aug  5 07:02:48 1999
--- bash-2.05/bracecomp.c	Fri Nov  3 11:22:00 2000
***************
*** 40,44 ****
  #include <readline/readline.h>
  
! extern char *backslash_quote ();
  
  /* Find greatest common prefix of two strings. */
--- 40,44 ----
  #include <readline/readline.h>
  
! extern char *sh_backslash_quote ();
  
  /* Find greatest common prefix of two strings. */
***************
*** 74,79 ****
    if (real_start == real_end)
      {
!       x = array[real_start] ? backslash_quote (array[real_start] + gcd_zero)
!  			    : backslash_quote (array[0]);
        return x;
      }
--- 74,79 ----
    if (real_start == real_end)
      {
!       x = array[real_start] ? sh_backslash_quote (array[real_start] + gcd_zero)
!  			    : sh_backslash_quote (array[0]);
        return x;
      }
***************
*** 114,118 ****
  	{
  	  x = savestring (array[start] + gcd_zero);
! 	  subterm = backslash_quote (x);
  	  free (x);
  	}
--- 114,118 ----
  	{
  	  x = savestring (array[start] + gcd_zero);
! 	  subterm = sh_backslash_quote (x);
  	  free (x);
  	}
***************
*** 125,129 ****
  	  strncpy (x, array[start] + gcd_zero, tlen);
  	  x[tlen] = '\0';
! 	  subterm = backslash_quote (x);
  	  free (x);
  	  result_size += strlen (subterm) + 1;
--- 125,129 ----
  	  strncpy (x, array[start] + gcd_zero, tlen);
  	  x[tlen] = '\0';
! 	  subterm = sh_backslash_quote (x);
  	  free (x);
  	  result_size += strlen (subterm) + 1;
***************
*** 148,152 ****
  }
  
! static void
  hack_braces_completion (names)
       char **names;
--- 148,152 ----
  }
  
! static int
  hack_braces_completion (names)
       char **names;
***************
*** 163,178 ****
      }
    names[0] = temp;
  }
  
  /* We handle quoting ourselves within hack_braces_completion, so we turn off
     rl_filename_quoting_desired and rl_filename_quoting_function. */
! void
! bash_brace_completion ()
  {
!   Function *orig_ignore_func;
!   Function *orig_entry_func;
!   CPFunction *orig_quoting_func;
!   CPPFunction *orig_attempt_func;
!   int orig_quoting_desired;
  
    orig_ignore_func = rl_ignore_some_completions_function;
--- 163,180 ----
      }
    names[0] = temp;
+   return 0;
  }
  
  /* We handle quoting ourselves within hack_braces_completion, so we turn off
     rl_filename_quoting_desired and rl_filename_quoting_function. */
! int
! bash_brace_completion (count, ignore)
!      int count, ignore;
  {
!   rl_compignore_func_t *orig_ignore_func;
!   rl_compentry_func_t *orig_entry_func;
!   rl_quote_func_t *orig_quoting_func;
!   rl_completion_func_t *orig_attempt_func;
!   int orig_quoting_desired, r;
  
    orig_ignore_func = rl_ignore_some_completions_function;
***************
*** 182,192 ****
    orig_quoting_desired = rl_filename_quoting_desired;
  
!   rl_completion_entry_function = (Function *) filename_completion_function;
!   rl_attempted_completion_function = NULL;
!   rl_ignore_some_completions_function = (Function *) hack_braces_completion;
!   rl_filename_quoting_function = NULL;
    rl_filename_quoting_desired = 0;
  
!   rl_complete_internal (TAB);
  
    rl_ignore_some_completions_function = orig_ignore_func;
--- 184,194 ----
    orig_quoting_desired = rl_filename_quoting_desired;
  
!   rl_completion_entry_function = rl_filename_completion_function;
!   rl_attempted_completion_function = (rl_completion_func_t *)NULL;
!   rl_ignore_some_completions_function = hack_braces_completion;
!   rl_filename_quoting_function = (rl_quote_func_t *)NULL;
    rl_filename_quoting_desired = 0;
  
!   r = rl_complete_internal (TAB);
  
    rl_ignore_some_completions_function = orig_ignore_func;
***************
*** 195,198 ****
--- 197,202 ----
    rl_filename_quoting_function = orig_quoting_func;
    rl_filename_quoting_desired = orig_quoting_desired;
+ 
+   return r;
  }
  #endif /* BRACE_EXPANSION && READLINE */
diff -Nrc2 bash-2.04/braces.c bash-2.05/braces.c
*** bash-2.04/braces.c	Thu Aug  5 07:18:03 1999
--- bash-2.05/braces.c	Wed Feb 14 16:51:23 2001
***************
*** 240,247 ****
  	 escape the quote character in a double-quoted string. */
        if (c == '\\' && (quoted == 0 || quoted == '"' || quoted == '`'))
!         {
!           pass_next = 1;
!           continue;
!         }
  
        if (quoted)
--- 240,247 ----
  	 escape the quote character in a double-quoted string. */
        if (c == '\\' && (quoted == 0 || quoted == '"' || quoted == '`'))
! 	{
! 	  pass_next = 1;
! 	  continue;
! 	}
  
        if (quoted)
diff -Nrc2 bash-2.04/builtins/Makefile.in bash-2.05/builtins/Makefile.in
*** bash-2.04/builtins/Makefile.in	Wed Jan 19 16:37:20 2000
--- bash-2.05/builtins/Makefile.in	Sat Oct 14 17:35:28 2000
***************
*** 214,218 ****
  # C files
  bashgetopt.o: ../config.h $(topdir)/bashansi.h $(BASHINCDIR)/ansi_stdlib.h
! bashgetopt.o: $(topdir)/shell.h $(topdir)/bashjmp.h
  bashgetopt.o: $(topdir)/command.h $(topdir)/general.h $(topdir)/error.h
  bashgetopt.o: $(topdir)/variables.h $(topdir)/quit.h $(BASHINCDIR)/maxpath.h
--- 214,218 ----
  # C files
  bashgetopt.o: ../config.h $(topdir)/bashansi.h $(BASHINCDIR)/ansi_stdlib.h
! bashgetopt.o: $(topdir)/shell.h $(topdir)/syntax.h $(topdir)/bashjmp.h
  bashgetopt.o: $(topdir)/command.h $(topdir)/general.h $(topdir)/error.h
  bashgetopt.o: $(topdir)/variables.h $(topdir)/quit.h $(BASHINCDIR)/maxpath.h
***************
*** 221,225 ****
  bashgetopt.o: $(topdir)/pathnames.h $(topdir)/externs.h $(srcdir)/common.h
  common.o: $(topdir)/bashtypes.h $(BASHINCDIR)/posixstat.h $(topdir)/bashansi.h $(BASHINCDIR)/ansi_stdlib.h
! common.o: $(topdir)/shell.h ../config.h $(topdir)/bashjmp.h $(BASHINCDIR)/posixjmp.h
  common.o: $(topdir)/sig.h $(topdir)/command.h
  common.o: $(topdir)/general.h $(BASHINCDIR)/stdc.h $(BASHINCDIR)/memalloc.h
--- 221,225 ----
  bashgetopt.o: $(topdir)/pathnames.h $(topdir)/externs.h $(srcdir)/common.h
  common.o: $(topdir)/bashtypes.h $(BASHINCDIR)/posixstat.h $(topdir)/bashansi.h $(BASHINCDIR)/ansi_stdlib.h
! common.o: $(topdir)/shell.h $(topdir)/syntax.h ../config.h $(topdir)/bashjmp.h $(BASHINCDIR)/posixjmp.h
  common.o: $(topdir)/sig.h $(topdir)/command.h
  common.o: $(topdir)/general.h $(BASHINCDIR)/stdc.h $(BASHINCDIR)/memalloc.h
***************
*** 232,236 ****
  evalfile.o: $(topdir)/bashtypes.h $(BASHINCDIR)/posixstat.h ${BASHINCDIR}/filecntl.h
  evalfile.o: $(topdir)/bashansi.h $(BASHINCDIR)/ansi_stdlib.h
! evalfile.o: $(topdir)/shell.h ../config.h $(topdir)/bashjmp.h
  evalfile.o: $(topdir)/command.h $(topdir)/general.h $(topdir)/error.h
  evalfile.o: $(topdir)/variables.h $(topdir)/quit.h $(BASHINCDIR)/maxpath.h
--- 232,236 ----
  evalfile.o: $(topdir)/bashtypes.h $(BASHINCDIR)/posixstat.h ${BASHINCDIR}/filecntl.h
  evalfile.o: $(topdir)/bashansi.h $(BASHINCDIR)/ansi_stdlib.h
! evalfile.o: $(topdir)/shell.h $(topdir)/syntax.h ../config.h $(topdir)/bashjmp.h
  evalfile.o: $(topdir)/command.h $(topdir)/general.h $(topdir)/error.h
  evalfile.o: $(topdir)/variables.h $(topdir)/quit.h $(BASHINCDIR)/maxpath.h
***************
*** 242,246 ****
  evalfile.o: $(topdir)/bashhist.h $(srcdir)/common.h
  evalstring.o: ../config.h $(topdir)/bashansi.h $(BASHINCDIR)/ansi_stdlib.h
! evalstring.o: $(topdir)/shell.h $(topdir)/bashjmp.h $(BASHINCDIR)/posixjmp.h
  evalstring.o: $(topdir)/sig.h $(topdir)/command.h $(topdir)/siglist.h
  evalstring.o: $(BASHINCDIR)/memalloc.h $(topdir)/variables.h $(topdir)/input.h
--- 242,246 ----
  evalfile.o: $(topdir)/bashhist.h $(srcdir)/common.h
  evalstring.o: ../config.h $(topdir)/bashansi.h $(BASHINCDIR)/ansi_stdlib.h
! evalstring.o: $(topdir)/shell.h $(topdir)/syntax.h $(topdir)/bashjmp.h $(BASHINCDIR)/posixjmp.h
  evalstring.o: $(topdir)/sig.h $(topdir)/command.h $(topdir)/siglist.h
  evalstring.o: $(BASHINCDIR)/memalloc.h $(topdir)/variables.h $(topdir)/input.h
***************
*** 252,256 ****
  evalstring.o: $(topdir)/bashhist.h $(srcdir)/common.h
  getopt.o: ../config.h $(BASHINCDIR)/memalloc.h
! getopt.o: $(topdir)/shell.h $(topdir)/bashjmp.h $(topdir)/command.h
  getopt.o: $(topdir)/general.h $(topdir)/error.h $(topdir)/variables.h
  getopt.o: $(topdir)/quit.h $(BASHINCDIR)/maxpath.h $(topdir)/unwind_prot.h
--- 252,256 ----
  evalstring.o: $(topdir)/bashhist.h $(srcdir)/common.h
  getopt.o: ../config.h $(BASHINCDIR)/memalloc.h
! getopt.o: $(topdir)/shell.h $(topdir)/syntax.h $(topdir)/bashjmp.h $(topdir)/command.h
  getopt.o: $(topdir)/general.h $(topdir)/error.h $(topdir)/variables.h
  getopt.o: $(topdir)/quit.h $(BASHINCDIR)/maxpath.h $(topdir)/unwind_prot.h
***************
*** 267,290 ****
  alias.o: $(topdir)/quit.h $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h
  alias.o: $(topdir)/subst.h $(topdir)/externs.h $(srcdir)/common.h
! alias.o: $(topdir)/shell.h $(topdir)/unwind_prot.h $(topdir)/variables.h
  bind.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h $(topdir)/error.h
  bind.o: $(topdir)/quit.h $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h
  bind.o: $(topdir)/subst.h $(topdir)/externs.h $(srcdir)/bashgetopt.h
  bind.o: $(topdir)/general.h $(BASHINCDIR)/maxpath.h $(topdir)/bashline.h
! bind.o: $(topdir)/shell.h $(topdir)/unwind_prot.h $(topdir)/variables.h 
  break.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h 
  break.o: $(topdir)/error.h $(topdir)/general.h
  break.o: $(topdir)/quit.h $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h
  break.o: $(topdir)/subst.h $(topdir)/externs.h $(BASHINCDIR)/maxpath.h
! break.o: $(topdir)/shell.h $(topdir)/unwind_prot.h $(topdir)/variables.h
  builtin.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h
  builtin.o: $(topdir)/error.h $(topdir)/general.h $(topdir)/externs.h
  builtin.o: $(topdir)/quit.h $(srcdir)/common.h $(BASHINCDIR)/maxpath.h
  builtin.o: $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h $(topdir)/subst.h
! builtin.o: $(topdir)/shell.h $(topdir)/unwind_prot.h $(topdir)/variables.h 
  cd.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h $(topdir)/error.h
  cd.o: $(topdir)/general.h $(topdir)/quit.h $(topdir)/dispose_cmd.h
  cd.o: $(topdir)/make_cmd.h $(topdir)/subst.h $(topdir)/externs.h
! cd.o: $(topdir)/shell.h $(topdir)/unwind_prot.h $(topdir)/variables.h
  cd.o: $(srcdir)/common.h $(BASHINCDIR)/maxpath.h
  command.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h
--- 267,290 ----
  alias.o: $(topdir)/quit.h $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h
  alias.o: $(topdir)/subst.h $(topdir)/externs.h $(srcdir)/common.h
! alias.o: $(topdir)/shell.h $(topdir)/syntax.h $(topdir)/unwind_prot.h $(topdir)/variables.h
  bind.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h $(topdir)/error.h
  bind.o: $(topdir)/quit.h $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h
  bind.o: $(topdir)/subst.h $(topdir)/externs.h $(srcdir)/bashgetopt.h
  bind.o: $(topdir)/general.h $(BASHINCDIR)/maxpath.h $(topdir)/bashline.h
! bind.o: $(topdir)/shell.h $(topdir)/syntax.h $(topdir)/unwind_prot.h $(topdir)/variables.h 
  break.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h 
  break.o: $(topdir)/error.h $(topdir)/general.h
  break.o: $(topdir)/quit.h $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h
  break.o: $(topdir)/subst.h $(topdir)/externs.h $(BASHINCDIR)/maxpath.h
! break.o: $(topdir)/shell.h $(topdir)/syntax.h $(topdir)/unwind_prot.h $(topdir)/variables.h
  builtin.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h
  builtin.o: $(topdir)/error.h $(topdir)/general.h $(topdir)/externs.h
  builtin.o: $(topdir)/quit.h $(srcdir)/common.h $(BASHINCDIR)/maxpath.h
  builtin.o: $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h $(topdir)/subst.h
! builtin.o: $(topdir)/shell.h $(topdir)/syntax.h $(topdir)/unwind_prot.h $(topdir)/variables.h 
  cd.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h $(topdir)/error.h
  cd.o: $(topdir)/general.h $(topdir)/quit.h $(topdir)/dispose_cmd.h
  cd.o: $(topdir)/make_cmd.h $(topdir)/subst.h $(topdir)/externs.h
! cd.o: $(topdir)/shell.h $(topdir)/syntax.h $(topdir)/unwind_prot.h $(topdir)/variables.h
  cd.o: $(srcdir)/common.h $(BASHINCDIR)/maxpath.h
  command.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h
***************
*** 292,305 ****
  command.o: $(topdir)/quit.h $(srcdir)/bashgetopt.h $(BASHINCDIR)/maxpath.h
  command.o: $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h $(topdir)/subst.h
! command.o: $(topdir)/shell.h $(topdir)/unwind_prot.h $(topdir)/variables.h 
  declare.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h
  declare.o: $(topdir)/error.h $(topdir)/general.h
  declare.o: $(topdir)/quit.h $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h
  declare.o: $(topdir)/subst.h $(topdir)/externs.h $(BASHINCDIR)/maxpath.h
! declare.o: $(topdir)/shell.h $(topdir)/unwind_prot.h $(topdir)/variables.h
  echo.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h $(topdir)/error.h
  echo.o: $(topdir)/general.h $(topdir)/subst.h $(topdir)/externs.h
  echo.o: $(topdir)/quit.h $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h
! echo.o: $(topdir)/shell.h $(topdir)/unwind_prot.h $(topdir)/variables.h
  echo.o: $(BASHINCDIR)/maxpath.h
  enable.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h
--- 292,305 ----
  command.o: $(topdir)/quit.h $(srcdir)/bashgetopt.h $(BASHINCDIR)/maxpath.h
  command.o: $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h $(topdir)/subst.h
! command.o: $(topdir)/shell.h $(topdir)/syntax.h $(topdir)/unwind_prot.h $(topdir)/variables.h 
  declare.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h
  declare.o: $(topdir)/error.h $(topdir)/general.h
  declare.o: $(topdir)/quit.h $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h
  declare.o: $(topdir)/subst.h $(topdir)/externs.h $(BASHINCDIR)/maxpath.h
! declare.o: $(topdir)/shell.h $(topdir)/syntax.h $(topdir)/unwind_prot.h $(topdir)/variables.h
  echo.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h $(topdir)/error.h
  echo.o: $(topdir)/general.h $(topdir)/subst.h $(topdir)/externs.h
  echo.o: $(topdir)/quit.h $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h
! echo.o: $(topdir)/shell.h $(topdir)/syntax.h $(topdir)/unwind_prot.h $(topdir)/variables.h
  echo.o: $(BASHINCDIR)/maxpath.h
  enable.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h
***************
*** 307,311 ****
  enable.o: $(topdir)/quit.h $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h
  enable.o: $(topdir)/subst.h $(topdir)/externs.h
! enable.o: $(topdir)/shell.h $(topdir)/unwind_prot.h $(topdir)/variables.h
  enable.o: $(BASHINCDIR)/maxpath.h
  enable.o: $(topdir)/pcomplete.h
--- 307,311 ----
  enable.o: $(topdir)/quit.h $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h
  enable.o: $(topdir)/subst.h $(topdir)/externs.h
! enable.o: $(topdir)/shell.h $(topdir)/syntax.h $(topdir)/unwind_prot.h $(topdir)/variables.h
  enable.o: $(BASHINCDIR)/maxpath.h
  enable.o: $(topdir)/pcomplete.h
***************
*** 314,318 ****
  eval.o: $(topdir)/quit.h $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h
  eval.o: $(topdir)/subst.h $(topdir)/externs.h
! eval.o: $(topdir)/shell.h $(topdir)/unwind_prot.h $(topdir)/variables.h
  eval.o: $(BASHINCDIR)/maxpath.h
  exec.o: $(topdir)/bashtypes.h
--- 314,318 ----
  eval.o: $(topdir)/quit.h $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h
  eval.o: $(topdir)/subst.h $(topdir)/externs.h
! eval.o: $(topdir)/shell.h $(topdir)/syntax.h $(topdir)/unwind_prot.h $(topdir)/variables.h
  eval.o: $(BASHINCDIR)/maxpath.h
  exec.o: $(topdir)/bashtypes.h
***************
*** 321,325 ****
  exec.o: $(topdir)/quit.h $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h
  exec.o: $(topdir)/subst.h $(topdir)/externs.h $(topdir)/flags.h
! exec.o: $(topdir)/shell.h $(topdir)/unwind_prot.h $(topdir)/variables.h
  exec.o: $(srcdir)/common.h $(topdir)/execute_cmd.h $(BASHINCDIR)/maxpath.h
  exec.o: $(topdir)/findcmd.h
--- 321,325 ----
  exec.o: $(topdir)/quit.h $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h
  exec.o: $(topdir)/subst.h $(topdir)/externs.h $(topdir)/flags.h
! exec.o: $(topdir)/shell.h $(topdir)/syntax.h $(topdir)/unwind_prot.h $(topdir)/variables.h
  exec.o: $(srcdir)/common.h $(topdir)/execute_cmd.h $(BASHINCDIR)/maxpath.h
  exec.o: $(topdir)/findcmd.h
***************
*** 329,333 ****
  exit.o: $(topdir)/quit.h $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h
  exit.o: $(topdir)/subst.h $(topdir)/externs.h
! exit.o: $(topdir)/shell.h $(topdir)/unwind_prot.h $(topdir)/variables.h
  exit.o: $(BASHINCDIR)/maxpath.h ./builtext.h
  fc.o: $(topdir)/bashtypes.h $(BASHINCDIR)/posixstat.h
--- 329,333 ----
  exit.o: $(topdir)/quit.h $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h
  exit.o: $(topdir)/subst.h $(topdir)/externs.h
! exit.o: $(topdir)/shell.h $(topdir)/syntax.h $(topdir)/unwind_prot.h $(topdir)/variables.h
  exit.o: $(BASHINCDIR)/maxpath.h ./builtext.h
  fc.o: $(topdir)/bashtypes.h $(BASHINCDIR)/posixstat.h
***************
*** 337,341 ****
  fc.o: $(topdir)/general.h $(BASHINCDIR)/maxpath.h
  fc.o: $(topdir)/quit.h $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h
! fc.o: $(topdir)/subst.h $(topdir)/externs.h $(topdir)/shell.h
  fc.o: $(topdir)/flags.h $(topdir)/unwind_prot.h $(topdir)/variables.h
  fc.o: $(topdir)/bashansi.h $(BASHINCDIR)/ansi_stdlib.h
--- 337,341 ----
  fc.o: $(topdir)/general.h $(BASHINCDIR)/maxpath.h
  fc.o: $(topdir)/quit.h $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h
! fc.o: $(topdir)/subst.h $(topdir)/externs.h $(topdir)/shell.h $(topdir)/syntax.h
  fc.o: $(topdir)/flags.h $(topdir)/unwind_prot.h $(topdir)/variables.h
  fc.o: $(topdir)/bashansi.h $(BASHINCDIR)/ansi_stdlib.h
***************
*** 345,359 ****
  fg_bg.o: $(topdir)/quit.h $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h
  fg_bg.o: $(topdir)/subst.h $(topdir)/externs.h $(BASHINCDIR)/maxpath.h
! fg_bg.o: $(topdir)/shell.h $(topdir)/unwind_prot.h $(topdir)/variables.h
  getopts.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h
  getopts.o: $(topdir)/error.h $(topdir)/general.h
  getopts.o: $(topdir)/quit.h $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h
  getopts.o: $(topdir)/subst.h $(topdir)/externs.h $(BASHINCDIR)/maxpath.h
! getopts.o: $(topdir)/shell.h $(topdir)/unwind_prot.h $(topdir)/variables.h
  hash.o: $(topdir)/builtins.h $(topdir)/command.h $(topdir)/quit.h
  hash.o: $(topdir)/findcmd.h $(topdir)/hashlib.h
  hash.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h
  hash.o: $(topdir)/error.h $(topdir)/general.h
! hash.o: $(topdir)/shell.h $(topdir)/unwind_prot.h $(topdir)/variables.h
  hash.o: $(srcdir)/common.h $(BASHINCDIR)/maxpath.h
  help.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h
--- 345,359 ----
  fg_bg.o: $(topdir)/quit.h $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h
  fg_bg.o: $(topdir)/subst.h $(topdir)/externs.h $(BASHINCDIR)/maxpath.h
! fg_bg.o: $(topdir)/shell.h $(topdir)/syntax.h $(topdir)/unwind_prot.h $(topdir)/variables.h
  getopts.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h
  getopts.o: $(topdir)/error.h $(topdir)/general.h
  getopts.o: $(topdir)/quit.h $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h
  getopts.o: $(topdir)/subst.h $(topdir)/externs.h $(BASHINCDIR)/maxpath.h
! getopts.o: $(topdir)/shell.h $(topdir)/syntax.h $(topdir)/unwind_prot.h $(topdir)/variables.h
  hash.o: $(topdir)/builtins.h $(topdir)/command.h $(topdir)/quit.h
  hash.o: $(topdir)/findcmd.h $(topdir)/hashlib.h
  hash.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h
  hash.o: $(topdir)/error.h $(topdir)/general.h
! hash.o: $(topdir)/shell.h $(topdir)/syntax.h $(topdir)/unwind_prot.h $(topdir)/variables.h
  hash.o: $(srcdir)/common.h $(BASHINCDIR)/maxpath.h
  help.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h
***************
*** 361,365 ****
  help.o: $(topdir)/quit.h $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h
  help.o: $(topdir)/subst.h $(topdir)/externs.h $(BASHINCDIR)/maxpath.h
! help.o: $(topdir)/shell.h $(topdir)/unwind_prot.h $(topdir)/variables.h
  history.o: $(topdir)/bashtypes.h
  history.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h
--- 361,365 ----
  help.o: $(topdir)/quit.h $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h
  help.o: $(topdir)/subst.h $(topdir)/externs.h $(BASHINCDIR)/maxpath.h
! help.o: $(topdir)/shell.h $(topdir)/syntax.h $(topdir)/unwind_prot.h $(topdir)/variables.h
  history.o: $(topdir)/bashtypes.h
  history.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h
***************
*** 367,375 ****
  history.o: $(topdir)/quit.h $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h
  history.o: $(topdir)/subst.h $(topdir)/externs.h
! history.o: ${BASHINCDIR}/filecntl.h $(topdir)/shell.h $(topdir)/unwind_prot.h
  history.o: $(topdir)/variables.h $(topdir)/bashhist.h $(BASHINCDIR)/maxpath.h
  inlib.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h
  inlib.o: $(topdir)/error.h $(topdir)/general.h
! inlib.o: $(topdir)/shell.h $(topdir)/unwind_prot.h $(topdir)/variables.h
  inlib.o: $(BASHINCDIR)/maxpath.h $(topdir)/subst.h $(topdir)/externs.h
  inlib.o: $(topdir)/quit.h $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h
--- 367,375 ----
  history.o: $(topdir)/quit.h $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h
  history.o: $(topdir)/subst.h $(topdir)/externs.h
! history.o: ${BASHINCDIR}/filecntl.h $(topdir)/shell.h $(topdir)/syntax.h $(topdir)/unwind_prot.h
  history.o: $(topdir)/variables.h $(topdir)/bashhist.h $(BASHINCDIR)/maxpath.h
  inlib.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h
  inlib.o: $(topdir)/error.h $(topdir)/general.h
! inlib.o: $(topdir)/shell.h $(topdir)/syntax.h $(topdir)/unwind_prot.h $(topdir)/variables.h
  inlib.o: $(BASHINCDIR)/maxpath.h $(topdir)/subst.h $(topdir)/externs.h
  inlib.o: $(topdir)/quit.h $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h
***************
*** 378,386 ****
  jobs.o: $(BASHINCDIR)/maxpath.h $(topdir)/externs.h
  jobs.o: $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h $(topdir)/subst.h
! jobs.o: $(topdir)/shell.h $(topdir)/unwind_prot.h $(topdir)/variables.h 
  kill.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h $(topdir)/error.h
  kill.o: $(topdir)/general.h $(topdir)/subst.h $(topdir)/externs.h
  kill.o: $(topdir)/quit.h $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h
! kill.o: $(topdir)/shell.h $(topdir)/trap.h $(topdir)/unwind_prot.h
  kill.o: $(topdir)/variables.h $(BASHINCDIR)/maxpath.h
  let.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h
--- 378,386 ----
  jobs.o: $(BASHINCDIR)/maxpath.h $(topdir)/externs.h
  jobs.o: $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h $(topdir)/subst.h
! jobs.o: $(topdir)/shell.h $(topdir)/syntax.h $(topdir)/unwind_prot.h $(topdir)/variables.h 
  kill.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h $(topdir)/error.h
  kill.o: $(topdir)/general.h $(topdir)/subst.h $(topdir)/externs.h
  kill.o: $(topdir)/quit.h $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h
! kill.o: $(topdir)/shell.h $(topdir)/syntax.h $(topdir)/trap.h $(topdir)/unwind_prot.h
  kill.o: $(topdir)/variables.h $(BASHINCDIR)/maxpath.h
  let.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h
***************
*** 388,397 ****
  let.o: $(topdir)/quit.h $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h
  let.o: $(topdir)/subst.h $(topdir)/externs.h $(BASHINCDIR)/maxpath.h
! let.o: $(topdir)/shell.h $(topdir)/unwind_prot.h $(topdir)/variables.h
  printf.o: ../config.h $(BASHINCDIR)/memalloc.h $(topdir)/bashjmp.h
  printf.o: $(topdir)/command.h $(topdir)/error.h $(topdir)/general.h
  printf.o: $(topdir)/quit.h $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h
  printf.o: $(topdir)/subst.h $(topdir)/externs.h $(topdir)/sig.h
! printf.o: $(topdir)/pathnames.h $(topdir)/shell.h $(topdir)/unwind_prot.h
  printf.o: $(topdir)/variables.h $(BASHINCDIR)/stdc.h $(srcdir)/bashgetopt.h
  pushd.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h
--- 388,397 ----
  let.o: $(topdir)/quit.h $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h
  let.o: $(topdir)/subst.h $(topdir)/externs.h $(BASHINCDIR)/maxpath.h
! let.o: $(topdir)/shell.h $(topdir)/syntax.h $(topdir)/unwind_prot.h $(topdir)/variables.h
  printf.o: ../config.h $(BASHINCDIR)/memalloc.h $(topdir)/bashjmp.h
  printf.o: $(topdir)/command.h $(topdir)/error.h $(topdir)/general.h
  printf.o: $(topdir)/quit.h $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h
  printf.o: $(topdir)/subst.h $(topdir)/externs.h $(topdir)/sig.h
! printf.o: $(topdir)/pathnames.h $(topdir)/shell.h $(topdir)/syntax.h $(topdir)/unwind_prot.h
  printf.o: $(topdir)/variables.h $(BASHINCDIR)/stdc.h $(srcdir)/bashgetopt.h
  pushd.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h
***************
*** 399,403 ****
  pushd.o: $(topdir)/quit.h $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h
  pushd.o: $(topdir)/subst.h $(topdir)/externs.h
! pushd.o: $(topdir)/shell.h $(topdir)/unwind_prot.h $(topdir)/variables.h
  pushd.o: $(BASHINCDIR)/maxpath.h $(srcdir)/common.h ./builtext.h
  read.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h
--- 399,403 ----
  pushd.o: $(topdir)/quit.h $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h
  pushd.o: $(topdir)/subst.h $(topdir)/externs.h
! pushd.o: $(topdir)/shell.h $(topdir)/syntax.h $(topdir)/unwind_prot.h $(topdir)/variables.h
  pushd.o: $(BASHINCDIR)/maxpath.h $(srcdir)/common.h ./builtext.h
  read.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h
***************
*** 405,409 ****
  read.o: $(topdir)/quit.h $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h
  read.o: $(topdir)/subst.h $(topdir)/externs.h $(BASHINCDIR)/maxpath.h
! read.o: $(topdir)/shell.h $(topdir)/unwind_prot.h $(topdir)/variables.h
  read.o: $(BASHINCDIR)/shtty.h
  return.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h
--- 405,409 ----
  read.o: $(topdir)/quit.h $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h
  read.o: $(topdir)/subst.h $(topdir)/externs.h $(BASHINCDIR)/maxpath.h
! read.o: $(topdir)/shell.h $(topdir)/syntax.h $(topdir)/unwind_prot.h $(topdir)/variables.h
  read.o: $(BASHINCDIR)/shtty.h
  return.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h
***************
*** 411,419 ****
  return.o: $(topdir)/quit.h $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h
  return.o: $(topdir)/subst.h $(topdir)/externs.h $(BASHINCDIR)/maxpath.h
! return.o: $(topdir)/shell.h $(topdir)/unwind_prot.h $(topdir)/variables.h
  set.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h
  set.o: $(topdir)/general.h $(topdir)/subst.h $(topdir)/externs.h
  set.o: $(topdir)/quit.h $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h
! set.o: $(topdir)/shell.h $(topdir)/unwind_prot.h $(topdir)/variables.h
  set.o: $(BASHINCDIR)/maxpath.h $(topdir)/error.h
  setattr.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h
--- 411,419 ----
  return.o: $(topdir)/quit.h $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h
  return.o: $(topdir)/subst.h $(topdir)/externs.h $(BASHINCDIR)/maxpath.h
! return.o: $(topdir)/shell.h $(topdir)/syntax.h $(topdir)/unwind_prot.h $(topdir)/variables.h
  set.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h
  set.o: $(topdir)/general.h $(topdir)/subst.h $(topdir)/externs.h
  set.o: $(topdir)/quit.h $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h
! set.o: $(topdir)/shell.h $(topdir)/syntax.h $(topdir)/unwind_prot.h $(topdir)/variables.h
  set.o: $(BASHINCDIR)/maxpath.h $(topdir)/error.h
  setattr.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h
***************
*** 422,446 ****
  setattr.o: $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h $(topdir)/subst.h
  setattr.o: $(topdir)/externs.h
! setattr.o: $(topdir)/shell.h $(topdir)/unwind_prot.h $(topdir)/variables.h 
  shift.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h
  shift.o: $(topdir)/error.h $(topdir)/general.h
  shift.o: $(topdir)/quit.h $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h
  shift.o: $(topdir)/subst.h $(topdir)/externs.h $(BASHINCDIR)/maxpath.h
! shift.o: $(topdir)/shell.h $(topdir)/unwind_prot.h $(topdir)/variables.h
  source.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h
  source.o: $(topdir)/error.h $(topdir)/general.h $(topdir)/findcmd.h
  source.o: $(topdir)/quit.h $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h
  source.o: $(topdir)/subst.h $(topdir)/externs.h $(BASHINCDIR)/maxpath.h
! source.o: $(topdir)/shell.h $(topdir)/unwind_prot.h $(topdir)/variables.h
  suspend.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h
  suspend.o: $(topdir)/error.h $(topdir)/general.h
  suspend.o: $(topdir)/quit.h $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h
  suspend.o: $(topdir)/subst.h $(topdir)/externs.h $(BASHINCDIR)/maxpath.h
! suspend.o: $(topdir)/shell.h $(topdir)/unwind_prot.h $(topdir)/variables.h
  test.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h
  test.o: $(topdir)/error.h $(topdir)/general.h
  test.o: $(topdir)/quit.h $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h
  test.o: $(topdir)/subst.h $(topdir)/externs.h $(BASHINCDIR)/maxpath.h
! test.o: $(topdir)/shell.h $(topdir)/unwind_prot.h $(topdir)/variables.h
  test.o: $(topdir)/test.h
  times.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h
--- 422,446 ----
  setattr.o: $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h $(topdir)/subst.h
  setattr.o: $(topdir)/externs.h
! setattr.o: $(topdir)/shell.h $(topdir)/syntax.h $(topdir)/unwind_prot.h $(topdir)/variables.h 
  shift.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h
  shift.o: $(topdir)/error.h $(topdir)/general.h
  shift.o: $(topdir)/quit.h $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h
  shift.o: $(topdir)/subst.h $(topdir)/externs.h $(BASHINCDIR)/maxpath.h
! shift.o: $(topdir)/shell.h $(topdir)/syntax.h $(topdir)/unwind_prot.h $(topdir)/variables.h
  source.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h
  source.o: $(topdir)/error.h $(topdir)/general.h $(topdir)/findcmd.h
  source.o: $(topdir)/quit.h $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h
  source.o: $(topdir)/subst.h $(topdir)/externs.h $(BASHINCDIR)/maxpath.h
! source.o: $(topdir)/shell.h $(topdir)/syntax.h $(topdir)/unwind_prot.h $(topdir)/variables.h
  suspend.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h
  suspend.o: $(topdir)/error.h $(topdir)/general.h
  suspend.o: $(topdir)/quit.h $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h
  suspend.o: $(topdir)/subst.h $(topdir)/externs.h $(BASHINCDIR)/maxpath.h
! suspend.o: $(topdir)/shell.h $(topdir)/syntax.h $(topdir)/unwind_prot.h $(topdir)/variables.h
  test.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h
  test.o: $(topdir)/error.h $(topdir)/general.h
  test.o: $(topdir)/quit.h $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h
  test.o: $(topdir)/subst.h $(topdir)/externs.h $(BASHINCDIR)/maxpath.h
! test.o: $(topdir)/shell.h $(topdir)/syntax.h $(topdir)/unwind_prot.h $(topdir)/variables.h
  test.o: $(topdir)/test.h
  times.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h
***************
*** 448,452 ****
  times.o: $(topdir)/quit.h $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h
  times.o: $(topdir)/subst.h $(topdir)/externs.h $(BASHINCDIR)/maxpath.h
! times.o: $(topdir)/shell.h $(topdir)/unwind_prot.h $(topdir)/variables.h
  times.o: $(BASHINCDIR)/posixtime.h
  trap.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h
--- 448,452 ----
  times.o: $(topdir)/quit.h $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h
  times.o: $(topdir)/subst.h $(topdir)/externs.h $(BASHINCDIR)/maxpath.h
! times.o: $(topdir)/shell.h $(topdir)/syntax.h $(topdir)/unwind_prot.h $(topdir)/variables.h
  times.o: $(BASHINCDIR)/posixtime.h
  trap.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h
***************
*** 454,458 ****
  trap.o: $(topdir)/quit.h $(srcdir)/common.h $(BASHINCDIR)/maxpath.h
  trap.o: $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h $(topdir)/subst.h
! trap.o: $(topdir)/shell.h $(topdir)/unwind_prot.h $(topdir)/variables.h
  trap.o: $(topdir)/findcmd.h
  type.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h
--- 454,458 ----
  trap.o: $(topdir)/quit.h $(srcdir)/common.h $(BASHINCDIR)/maxpath.h
  trap.o: $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h $(topdir)/subst.h
! trap.o: $(topdir)/shell.h $(topdir)/syntax.h $(topdir)/unwind_prot.h $(topdir)/variables.h
  trap.o: $(topdir)/findcmd.h
  type.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h
***************
*** 461,489 ****
  type.o: $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h $(topdir)/subst.h
  type.o: $(topdir)/externs.h $(topdir)/hashcmd.h
! type.o: $(topdir)/shell.h $(topdir)/unwind_prot.h $(topdir)/variables.h 
  ulimit.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h
  ulimit.o: $(topdir)/error.h $(topdir)/general.h
  ulimit.o: $(topdir)/quit.h $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h
  ulimit.o: $(topdir)/subst.h $(topdir)/externs.h $(BASHINCDIR)/maxpath.h
! ulimit.o: $(topdir)/shell.h $(topdir)/unwind_prot.h $(topdir)/variables.h
  umask.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h
  umask.o: $(topdir)/error.h $(topdir)/general.h
  umask.o: $(topdir)/quit.h $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h
  umask.o: $(topdir)/subst.h $(topdir)/externs.h $(BASHINCDIR)/maxpath.h
! umask.o: $(topdir)/shell.h $(topdir)/unwind_prot.h $(topdir)/variables.h
  wait.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h
  wait.o: $(topdir)/error.h $(topdir)/general.h
  wait.o: $(topdir)/quit.h $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h
  wait.o: $(topdir)/subst.h $(topdir)/externs.h $(BASHINCDIR)/maxpath.h
! wait.o: $(topdir)/shell.h $(topdir)/unwind_prot.h $(topdir)/variables.h
  shopt.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h
  shopt.o: $(topdir)/error.h $(topdir)/general.h 
  shopt.o: $(topdir)/quit.h $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h
  shopt.o: $(topdir)/subst.h $(topdir)/externs.h $(BASHINCDIR)/maxpath.h
! shopt.o: $(topdir)/shell.h $(topdir)/unwind_prot.h $(topdir)/variables.h
  shopt.o: $(srcdir)/common.h $(srcdir)/bashgetopt.h
  
  complete.o: ../config.h
! complete.o: ${topdir}/shell.h ${topdir}/bashjmp.h ${BASHINCDIR}/posixjmp.h ${topdir}/sig.h  
  complete.o: ${topdir}/unwind_prot.h ${topdir}/variables.h
  complete.o: ${topdir}/bashtypes.h ${topdir}/bashansi.h ${BASHINCDIR}/ansi_stdlib.h
--- 461,489 ----
  type.o: $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h $(topdir)/subst.h
  type.o: $(topdir)/externs.h $(topdir)/hashcmd.h
! type.o: $(topdir)/shell.h $(topdir)/syntax.h $(topdir)/unwind_prot.h $(topdir)/variables.h 
  ulimit.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h
  ulimit.o: $(topdir)/error.h $(topdir)/general.h
  ulimit.o: $(topdir)/quit.h $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h
  ulimit.o: $(topdir)/subst.h $(topdir)/externs.h $(BASHINCDIR)/maxpath.h
! ulimit.o: $(topdir)/shell.h $(topdir)/syntax.h $(topdir)/unwind_prot.h $(topdir)/variables.h
  umask.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h
  umask.o: $(topdir)/error.h $(topdir)/general.h
  umask.o: $(topdir)/quit.h $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h
  umask.o: $(topdir)/subst.h $(topdir)/externs.h $(BASHINCDIR)/maxpath.h
! umask.o: $(topdir)/shell.h $(topdir)/syntax.h $(topdir)/unwind_prot.h $(topdir)/variables.h
  wait.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h
  wait.o: $(topdir)/error.h $(topdir)/general.h
  wait.o: $(topdir)/quit.h $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h
  wait.o: $(topdir)/subst.h $(topdir)/externs.h $(BASHINCDIR)/maxpath.h
! wait.o: $(topdir)/shell.h $(topdir)/syntax.h $(topdir)/unwind_prot.h $(topdir)/variables.h
  shopt.o: $(topdir)/command.h ../config.h $(BASHINCDIR)/memalloc.h
  shopt.o: $(topdir)/error.h $(topdir)/general.h 
  shopt.o: $(topdir)/quit.h $(topdir)/dispose_cmd.h $(topdir)/make_cmd.h
  shopt.o: $(topdir)/subst.h $(topdir)/externs.h $(BASHINCDIR)/maxpath.h
! shopt.o: $(topdir)/shell.h $(topdir)/syntax.h $(topdir)/unwind_prot.h $(topdir)/variables.h
  shopt.o: $(srcdir)/common.h $(srcdir)/bashgetopt.h
  
  complete.o: ../config.h
! complete.o: ${topdir}/shell.h $(topdir)/syntax.h ${topdir}/bashjmp.h ${BASHINCDIR}/posixjmp.h ${topdir}/sig.h  
  complete.o: ${topdir}/unwind_prot.h ${topdir}/variables.h
  complete.o: ${topdir}/bashtypes.h ${topdir}/bashansi.h ${BASHINCDIR}/ansi_stdlib.h
diff -Nrc2 bash-2.04/builtins/alias.def bash-2.05/builtins/alias.def
*** bash-2.04/builtins/alias.def	Thu Aug  5 07:39:19 1999
--- bash-2.05/builtins/alias.def	Fri Nov  3 11:18:42 2000
***************
*** 199,203 ****
    char *value;
  
!   value = single_quote (alias->value);
    printf ("alias %s=%s\n", alias->name, value);
    free (value);
--- 199,203 ----
    char *value;
  
!   value = sh_single_quote (alias->value);
    printf ("alias %s=%s\n", alias->name, value);
    free (value);
diff -Nrc2 bash-2.04/builtins/bind.def bash-2.05/builtins/bind.def
*** bash-2.04/builtins/bind.def	Thu Aug  5 07:39:37 1999
--- bash-2.05/builtins/bind.def	Wed Feb 14 17:07:33 2001
***************
*** 190,197 ****
        kmap = rl_get_keymap_by_name (map_name);
        if (!kmap)
!         {
  	  builtin_error ("`%s': invalid keymap name", map_name);
  	  BIND_RETURN (EXECUTION_FAILURE);
!         }
      }
  
--- 190,197 ----
        kmap = rl_get_keymap_by_name (map_name);
        if (!kmap)
! 	{
  	  builtin_error ("`%s': invalid keymap name", map_name);
  	  BIND_RETURN (EXECUTION_FAILURE);
! 	}
      }
  
diff -Nrc2 bash-2.04/builtins/break.def bash-2.05/builtins/break.def
*** bash-2.04/builtins/break.def	Thu Aug  5 07:39:44 1999
--- bash-2.05/builtins/break.def	Wed Feb 21 12:03:00 2001
***************
*** 41,44 ****
--- 41,45 ----
  
  extern char *this_command_name;
+ extern int posixly_correct;
  
  static int check_loop_level ();
***************
*** 62,66 ****
  
    if (check_loop_level () == 0)
!     return (EXECUTION_FAILURE);
  
    newbreak = get_numeric_arg (list, 1);
--- 63,67 ----
  
    if (check_loop_level () == 0)
!     return (EXECUTION_SUCCESS);
  
    newbreak = get_numeric_arg (list, 1);
***************
*** 97,101 ****
  
    if (check_loop_level () == 0)
!     return (EXECUTION_FAILURE);
  
    newcont = get_numeric_arg (list, 1);
--- 98,102 ----
  
    if (check_loop_level () == 0)
!     return (EXECUTION_SUCCESS);
  
    newcont = get_numeric_arg (list, 1);
***************
*** 122,126 ****
  {
  #if defined (BREAK_COMPLAINS)
!   if (loop_level == 0)
      builtin_error ("only meaningful in a `for', `while', or `until' loop");
  #endif /* BREAK_COMPLAINS */
--- 123,127 ----
  {
  #if defined (BREAK_COMPLAINS)
!   if (loop_level == 0 && posixly_correct == 0)
      builtin_error ("only meaningful in a `for', `while', or `until' loop");
  #endif /* BREAK_COMPLAINS */
diff -Nrc2 bash-2.04/builtins/cd.def bash-2.05/builtins/cd.def
*** bash-2.04/builtins/cd.def	Mon Nov 29 12:13:38 1999
--- bash-2.05/builtins/cd.def	Wed Oct 11 11:10:20 2000
***************
*** 61,65 ****
  
  static char *cdspell ();
- static int spname (), mindist (), spdist ();
  
  /* Change this to 1 to get cd spelling correction by default. */
--- 61,64 ----
***************
*** 92,104 ****
    SHELL_VAR *tvar;
  
!   if (no_symlinks)
!     {
!       old_symlinks = no_symbolic_links;
!       no_symbolic_links = 1;
!       dirname = get_working_directory ("cd");
!       no_symbolic_links = old_symlinks;
!     }
!   else
!     dirname = get_working_directory ("cd");
  
    old_anm = array_needs_making;
--- 91,98 ----
    SHELL_VAR *tvar;
  
! #define tcwd the_current_working_directory
!   dirname = tcwd ? (no_symlinks ? sh_physpath (tcwd, 0) : tcwd)
!   		 : get_working_directory ("cd");
! #undef tcwd
  
    old_anm = array_needs_making;
***************
*** 119,126 ****
      }
  
!   FREE (dirname);
    return (EXECUTION_SUCCESS);
  }
  
  /* This builtin is ultimately the way that all user-visible commands should
     change the current working directory.  It is called by cd_to_string (),
--- 113,126 ----
      }
  
!   if (dirname && dirname != the_current_working_directory)
!     free (dirname);
    return (EXECUTION_SUCCESS);
  }
  
+ #define LCD_DOVARS	0x001
+ #define LCD_DOSPELL	0x002
+ #define LCD_PRINTPATH	0x004
+ #define LCD_FREEDIRNAME	0x010
+ 
  /* This builtin is ultimately the way that all user-visible commands should
     change the current working directory.  It is called by cd_to_string (),
***************
*** 132,137 ****
  {
    char *dirname, *cdpath, *path, *temp;
!   int path_index, no_symlinks, opt;
!   struct stat sb;
  
  #if defined (RESTRICTED_SHELL)
--- 132,136 ----
  {
    char *dirname, *cdpath, *path, *temp;
!   int path_index, no_symlinks, opt, lflag;
  
  #if defined (RESTRICTED_SHELL)
***************
*** 162,165 ****
--- 161,167 ----
    list = loptend;
  
+   lflag = (cdable_vars ? LCD_DOVARS : 0) |
+ 	  ((interactive && cdspelling) ? LCD_DOSPELL : 0);
+ 
    if (list == 0)
      {
***************
*** 172,181 ****
  	  return (EXECUTION_FAILURE);
  	}
! 
!       if (change_to_directory (dirname, no_symlinks) == 0)
! 	{
! 	  builtin_error ("%s: %s", dirname, strerror (errno));
! 	  return (EXECUTION_FAILURE);
! 	}
      }
    else if (list->word->word[0] == '-' && list->word->word[1] == '\0')
--- 174,178 ----
  	  return (EXECUTION_FAILURE);
  	}
!       lflag = 0;
      }
    else if (list->word->word[0] == '-' && list->word->word[1] == '\0')
***************
*** 184,287 ****
        dirname = get_string_value ("OLDPWD");
  
!       if (dirname == 0 || change_to_directory (dirname, no_symlinks) == 0)
  	{
! 	  if (dirname == 0)
! 	    builtin_error ("OLDPWD not set");
! 	  else
! 	    builtin_error ("%s: %s", dirname, strerror (errno));
  	  return (EXECUTION_FAILURE);
  	}
!       if (interactive)
! 	printf ("%s\n", dirname);
      }
!   else
      {
        dirname = list->word->word;
  
!       if (absolute_pathname (dirname) == 0 && (cdpath = get_string_value ("CDPATH")))
! 	{
! 	  /* Find directory in $CDPATH. */
! 	  path_index = 0;
! 	  while (path = extract_colon_unit (cdpath, &path_index))
! 	    {
! 	      /* OPT is 1 if the path element is non-empty */
! 	      opt = path[0] != '\0';
! 	      temp = sh_makepath (path, dirname, MP_DOTILDE);
! 	      free (path);
! 
! 	      if (stat (temp, &sb) < 0 || S_ISDIR (sb.st_mode) == 0)
! 		{
! 		  free (temp);
! 		  continue;
! 		}
! 
! 	      if (change_to_directory (temp, no_symlinks))
! 		{
! 		  /* POSIX.2 says that if a nonempty directory from CDPATH
! 		     is used to find the directory to change to, the new
! 		     directory name is echoed to stdout, whether or not
! 		     the shell is interactive. */
! 		  if (opt)
! 		    printf ("%s\n", no_symlinks ? temp : the_current_working_directory);
! 
! 		  free (temp);
! 		  /* Posix.2 says that after using CDPATH, the resultant
! 		     value of $PWD will not contain symlinks. */
! 		  return (bindpwd (posixly_correct || no_symlinks));
! 		}
! 	      else
! 		free (temp);
! 	    }
  
! 	  /* POSIX.2 says that if `.' does not appear in $CDPATH, we don't
! 	     try the current directory, so we just punt now with an error
! 	     message if POSIXLY_CORRECT is non-zero.  The check for cdpath[0]
! 	     is so we don't mistakenly treat a CDPATH value of "" as not
! 	     specifying the current directory. */
! 	  if (posixly_correct && cdpath[0])
  	    {
! 	      builtin_error ("%s: %s", dirname, strerror (ENOENT));
! 	      return (EXECUTION_FAILURE);
  	    }
  	}
  
!       if (change_to_directory (dirname, no_symlinks))
! 	return (bindpwd (no_symlinks));
! 
!       /* If the user requests it, then perhaps this is the name of
! 	 a shell variable, whose value contains the directory to
! 	 change to.  If that is the case, then change to that
! 	 directory. */
!       if (cdable_vars)
  	{
! 	  temp = get_string_value (dirname);
! 	  if (temp && change_to_directory (temp, no_symlinks))
! 	    {
! 	      printf ("%s\n", temp);
! 	      return (bindpwd (no_symlinks));
! 	    }
  	}
  
!       /* If the user requests it, try to find a directory name similar in
! 	 spelling to the one requested, in case the user made a simple
! 	 typo.  This is similar to the UNIX 8th and 9th Edition shells. */
!       if (interactive && cdspelling)
  	{
! 	  temp = cdspell (dirname);
! 	  if (temp && change_to_directory (temp, no_symlinks))
!             {
!               printf ("%s\n", temp);
!               free (temp);
!               return (bindpwd (no_symlinks));
!             }
!           else
! 	    FREE (temp);
  	}
  
!       builtin_error ("%s: %s", dirname, strerror (errno));
!       return (EXECUTION_FAILURE);
      }
  
!   return (bindpwd (no_symlinks));
  }
  
--- 181,277 ----
        dirname = get_string_value ("OLDPWD");
  
!       if (dirname == 0)
  	{
! 	  builtin_error ("OLDPWD not set");
  	  return (EXECUTION_FAILURE);
  	}
!       lflag = interactive ? LCD_PRINTPATH : 0;
      }
!   else if (absolute_pathname (list->word->word))
!     dirname = list->word->word;
!   else if (cdpath = get_string_value ("CDPATH"))
      {
        dirname = list->word->word;
  
!       /* Find directory in $CDPATH. */
!       path_index = 0;
!       while (path = extract_colon_unit (cdpath, &path_index))
! 	{
! 	  /* OPT is 1 if the path element is non-empty */
! 	  opt = path[0] != '\0';
! 	  temp = sh_makepath (path, dirname, MP_DOTILDE);
! 	  free (path);
  
! 	  if (change_to_directory (temp, no_symlinks))
  	    {
! 	      /* POSIX.2 says that if a nonempty directory from CDPATH
! 		 is used to find the directory to change to, the new
! 		 directory name is echoed to stdout, whether or not
! 		 the shell is interactive. */
! 	      if (opt)
! 		printf ("%s\n", no_symlinks ? temp : the_current_working_directory);
! 
! 	      free (temp);
! 	      /* Posix.2 says that after using CDPATH, the resultant
! 		 value of $PWD will not contain `.' or `..'. */
! 	      return (bindpwd (posixly_correct || no_symlinks));
  	    }
+ 	  else
+ 	    free (temp);
  	}
  
!       /* POSIX.2 says that if `.' does not appear in $CDPATH, we don't
! 	 try the current directory, so we just punt now with an error
! 	 message if POSIXLY_CORRECT is non-zero.  The check for cdpath[0]
! 	 is so we don't mistakenly treat a CDPATH value of "" as not
! 	 specifying the current directory. */
!       if (posixly_correct && cdpath[0])
  	{
! 	  builtin_error ("%s: %s", dirname, strerror (ENOENT));
! 	  return (EXECUTION_FAILURE);
  	}
+     }
+   else
+     dirname = list->word->word;
  
!   /* When we get here, DIRNAME is the directory to change to.  If we
!      chdir successfully, just return. */
!   if (change_to_directory (dirname, no_symlinks))
!     {
!       if (lflag & LCD_PRINTPATH)
! 	printf ("%s\n", dirname);
!       return (bindpwd (no_symlinks));
!     }
! 
!   /* If the user requests it, then perhaps this is the name of
!      a shell variable, whose value contains the directory to
!      change to. */
!   if (lflag & LCD_DOVARS)
!     {
!       temp = get_string_value (dirname);
!       if (temp && change_to_directory (temp, no_symlinks))
  	{
! 	  printf ("%s\n", temp);
! 	  return (bindpwd (no_symlinks));
  	}
+     }
  
!   /* If the user requests it, try to find a directory name similar in
!      spelling to the one requested, in case the user made a simple
!      typo.  This is similar to the UNIX 8th and 9th Edition shells. */
!   if (lflag & LCD_DOSPELL)
!     {
!       temp = cdspell (dirname);
!       if (temp && change_to_directory (temp, no_symlinks))
! 	{
! 	  printf ("%s\n", temp);
! 	  return (bindpwd (no_symlinks));
! 	}
!       else
! 	FREE (temp);
      }
  
!   builtin_error ("%s: %s", dirname, strerror (errno));
!   return (EXECUTION_FAILURE);
  }
  
***************
*** 303,307 ****
       WORD_LIST *list;
  {
!   char *directory, *buffer;
    int opt;
  
--- 293,297 ----
       WORD_LIST *list;
  {
!   char *directory;
    int opt;
  
***************
*** 325,347 ****
    list = loptend;
  
!   if (verbatim_pwd)
!     {
!       buffer = xmalloc (PATH_MAX);
!       directory = getcwd (buffer, PATH_MAX);
  
!       if (directory == 0)
! 	{
! 	  builtin_error ("%s: %s", bash_getcwd_errstr, strerror (errno));
! 	  free (buffer);
! 	}
!     }
!   else
!     directory = get_working_directory ("pwd");
  
    if (directory)
      {
        printf ("%s\n", directory);
        fflush (stdout);
!       free (directory);
        return (EXECUTION_SUCCESS);
      }
--- 315,335 ----
    list = loptend;
  
! #define tcwd the_current_working_directory
  
!   directory = tcwd ? (verbatim_pwd ? sh_physpath (tcwd, 0) : tcwd)
! 		   : get_working_directory ("pwd");
! #undef tcwd
  
    if (directory)
      {
        printf ("%s\n", directory);
+       if (directory != the_current_working_directory)
+ 	free (directory);
        fflush (stdout);
!       if (ferror (stdout))
! 	{
! 	  builtin_error ("write error: %s", strerror (errno));
! 	  return (EXECUTION_FAILURE);
! 	}
        return (EXECUTION_SUCCESS);
      }
***************
*** 351,355 ****
  
  /* Do the work of changing to the directory NEWDIR.  Handle symbolic
!    link following, etc. */
  
  static int
--- 339,346 ----
  
  /* Do the work of changing to the directory NEWDIR.  Handle symbolic
!    link following, etc.  This function *must* return with
!    the_current_working_directory either set to NULL (in which case
!    getcwd() will eventually be called), or set to a string corresponding
!    to the working directory.  Return 1 on success, 0 on failure. */
  
  static int
***************
*** 358,431 ****
       int nolinks;
  {
!   char *t;
! 
!   if (nolinks == 0)
!     {
!       int chdir_return = 0;
!       char *tdir = (char *)NULL;
! 
!       if (the_current_working_directory == 0)
! 	{
! 	  t = get_working_directory ("cd_links");
! 	  FREE (t);
! 	}
  
!       if (the_current_working_directory)
! 	t = make_absolute (newdir, the_current_working_directory);
!       else
! 	t = savestring (newdir);
  
!       /* TDIR is the canonicalized absolute pathname of the NEWDIR. */
!       tdir = canonicalize_pathname (t);
  
!       /* Use the canonicalized version of NEWDIR, or, if canonicalization
! 	 failed, use the non-canonical form. */
!       if (tdir && *tdir)
! 	free (t);
!       else
! 	{
! 	  FREE (tdir);
! 	  tdir = t;
! 	}
  
!       if (chdir (tdir) < 0)
! 	{
! 	  int err;
  
! 	  chdir_return = 0;
! 	  free (tdir);
  
! 	  err = errno;
  
! 	  /* We failed changing to the canonicalized directory name.  Try
! 	     what the user passed verbatim.  If we succeed, reinitialize
! 	     the_current_working_directory. */
! 	  if (chdir (newdir) == 0)
! 	    {
! 	      chdir_return = 1;
! 	      if (the_current_working_directory)
! 		{
! 		  free (the_current_working_directory);
! 		  the_current_working_directory = (char *)NULL;
! 		}
  
! 	      tdir = get_working_directory ("cd");
! 	      FREE (tdir);
! 	    }
! 	  else
! 	    errno = err;
! 	}
!       else
! 	{
! 	  chdir_return = 1;
  
! 	  FREE (the_current_working_directory);
! 	  the_current_working_directory = tdir;
! 	}
  
!       return (chdir_return);
      }
    else
!     return (chdir (newdir) == 0);
  }
  
--- 349,415 ----
       int nolinks;
  {
!   char *t, *tdir;
!   int err;
  
!   tdir = (char *)NULL;
  
!   if (the_current_working_directory == 0)
!     {
!       t = get_working_directory ("chdir");
!       FREE (t);
!     }
  
!   t = make_absolute (newdir, the_current_working_directory);
  
!   /* TDIR is either the canonicalized absolute pathname of NEWDIR
!      (nolinks == 0) or the absolute physical pathname of NEWDIR
!      (nolinks != 0). */
!   tdir = nolinks ? sh_physpath (t, 0)
! 		 : sh_canonpath (t, PATH_CHECKDOTDOT|PATH_CHECKEXISTS);
  
!   /* Use the canonicalized version of NEWDIR, or, if canonicalization
!      failed, use the non-canonical form. */
!   if (tdir && *tdir)
!     free (t);
!   else
!     {
!       FREE (tdir);
!       tdir = t;
!     }
  
!   /* If the chdir succeeds, update the_current_working_directory. */
!   if (chdir (nolinks ? newdir : tdir) == 0)
!     {
!       FREE (the_current_working_directory);
!       the_current_working_directory = tdir;
!       
!       return (1);
!     }
  
!   /* We failed to change to the appropriate directory name.  If we tried
!      what the user passed (nolinks != 0), punt now. */
!   if (nolinks)
!     return (0);
  
!   err = errno;
!   free (tdir);
  
!   /* We're not in physical mode (nolinks == 0), but we failed to change to
!      the canonicalized directory name (TDIR).  Try what the user passed
!      verbatim. If we succeed, reinitialize the_current_working_directory. */
!   if (chdir (newdir) == 0)
!     {
!       FREE (the_current_working_directory);
!       the_current_working_directory = (char *)NULL;
!       tdir = get_working_directory ("cd");
!       FREE (tdir);
  
!       return (1);
      }
    else
!     {
!       errno = err;
!       return (0);
!     }
  }
  
***************
*** 453,599 ****
        return guess;
      }
- }
- 
- /*
-  * `spname' and its helpers are inspired by the code in "The UNIX
-  * Programming Environment, Kernighan & Pike, Prentice-Hall 1984",
-  * pages 209 - 213.
-  */
- 
- /*
-  *	`spname' -- return a correctly spelled filename
-  *
-  *	int spname(char * oldname, char * newname)
-  *	Returns:  -1 if no reasonable match found
-  *		   0 if exact match found
-  *		   1 if corrected
-  *	Stores corrected name in `newname'.
-  */
- static int
- spname(oldname, newname)
-      char *oldname;
-      char *newname;
- {
-   char *op, *np, *p;
-   char guess[PATH_MAX + 1], best[PATH_MAX + 1];
- 
-   op = oldname;
-   np = newname;
-   for (;;)
-     {
-       while (*op == '/')    /* Skip slashes */
- 	*np++ = *op++;
-       *np = '\0';
- 
-       if (*op == '\0')    /* Exact or corrected */
-         {
- 	  /* `.' is rarely the right thing. */
- 	  if (oldname[1] == '\0' && newname[1] == '\0' &&
- 		oldname[0] != '.' && newname[0] == '.')
- 	    return -1;
- 	  return strcmp(oldname, newname) != 0;
-         }
- 
-       /* Copy next component into guess */
-       for (p = guess; *op != '/' && *op != '\0'; op++)
- 	if (p < guess + PATH_MAX)
- 	  *p++ = *op;
-       *p = '\0';
- 
-       if (mindist(newname, guess, best) >= 3)
- 	return -1;  /* Hopeless */
- 
-       /*
-        *  Add to end of newname
-        */
-       for (p = best; *np = *p++; np++)
- 	;
-     }
- }
- 
- /*
-  *  Search directory for a guess
-  */
- static int
- mindist(dir, guess, best)
-      char *dir;
-      char *guess;
-      char *best;
- {
-   DIR *fd;
-   struct dirent *dp;
-   int dist, x;
- 
-   dist = 3;    /* Worst distance */
-   if (*dir == '\0')
-     dir = ".";
- 
-   if ((fd = opendir(dir)) == NULL)
-     return dist;
- 
-   while ((dp = readdir(fd)) != NULL)
-     {
-       /*
-        *  Look for a better guess.  If the new guess is as
-        *  good as the current one, we take it.  This way,
-        *  any single character match will be a better match
-        *  than ".".
-        */
-       x = spdist(dp->d_name, guess);
-       if (x <= dist && x != 3)
- 	{
- 	  strcpy(best, dp->d_name);
- 	  dist = x;
- 	  if (dist == 0)    /* Exact match */
- 	    break;
- 	}
-     }
-   (void)closedir(fd);
- 
-   /* Don't return `.' */
-   if (best[0] == '.' && best[1] == '\0')
-     dist = 3;
-   return dist;
- }
- 
- /*
-  *  `spdist' -- return the "distance" between two names.
-  *
-  *  int spname(char * oldname, char * newname)
-  *  Returns:  0 if strings are identical
-  *      1 if two characters are transposed
-  *      2 if one character is wrong, added or deleted
-  *      3 otherwise
-  */
- static int
- spdist(cur, new)
-      char *cur, *new;
- {
-   while (*cur == *new)
-     {
-       if (*cur == '\0')
- 	return 0;    /* Exact match */
-       cur++;
-       new++;
-     }
- 
-   if (*cur)
-     {
-       if (*new)
- 	{
- 	  if (cur[1] && new[1] && cur[0] == new[1] && cur[1] == new[0] && strcmp (cur + 2, new + 2) == 0)
- 	    return 1;  /* Transposition */
- 
- 	  if (strcmp (cur + 1, new + 1) == 0)
- 	    return 2;  /* One character mismatch */
- 	}
- 
-       if (strcmp(&cur[1], &new[0]) == 0)
- 	return 2;    /* Extra character */
-     }
- 
-   if (*new && strcmp(cur, new + 1) == 0)
-     return 2;      /* Missing character */
- 
-   return 3;
  }
--- 437,439 ----
diff -Nrc2 bash-2.04/builtins/common.c bash-2.05/builtins/common.c
*** bash-2.04/builtins/common.c	Tue Dec  7 10:59:32 1999
--- bash-2.05/builtins/common.c	Wed Feb 14 17:05:11 2001
***************
*** 328,332 ****
  /* **************************************************************** */
  /*								    */
! /*	        Validating numeric input and arguments		    */
  /*								    */
  /* **************************************************************** */
--- 328,332 ----
  /* **************************************************************** */
  /*								    */
! /*		Validating numeric input and arguments		    */
  /*								    */
  /* **************************************************************** */
***************
*** 372,379 ****
  
    result = digits = 0;
!   while (*string && *string >= '0' && *string < '8')
      {
        digits++;
!       result = (result * 8) + *string++ - '0';
      }
  
--- 372,379 ----
  
    result = digits = 0;
!   while (*string && ISOCTAL (*string))
      {
        digits++;
!       result = (result * 8) + (*string++ - '0');
      }
  
***************
*** 417,424 ****
  	  fprintf (stderr, "%s: could not get current directory: %s: %s\n",
  		   (for_whom && *for_whom) ? for_whom : get_name_for_error (),
! 		   the_current_working_directory[0]
! 			? the_current_working_directory
! 			: bash_getcwd_errstr,
! 		   strerror (errno));
  
  	  free (the_current_working_directory);
--- 417,421 ----
  	  fprintf (stderr, "%s: could not get current directory: %s: %s\n",
  		   (for_whom && *for_whom) ? for_whom : get_name_for_error (),
! 		   bash_getcwd_errstr, strerror (errno));
  
  	  free (the_current_working_directory);
***************
*** 710,930 ****
    qsort (shell_builtins, num_shell_builtins, sizeof (struct builtin),
      (QSFUNC *)shell_builtin_compare);
- }
- 
- /* **************************************************************** */
- /*								    */
- /*	 Functions for quoting strings to be re-read as input	    */
- /*								    */
- /* **************************************************************** */
- 
- /* Return a new string which is the single-quoted version of STRING.
-    Used by alias and trap, among others. */
- char *
- single_quote (string)
-      char *string;
- {
-   register int c;
-   char *result, *r, *s;
- 
-   result = (char *)xmalloc (3 + (4 * strlen (string)));
-   r = result;
-   *r++ = '\'';
- 
-   for (s = string; s && (c = *s); s++)
-     {
-       *r++ = c;
- 
-       if (c == '\'')
- 	{
- 	  *r++ = '\\';	/* insert escaped single quote */
- 	  *r++ = '\'';
- 	  *r++ = '\'';	/* start new quoted string */
- 	}
-     }
- 
-   *r++ = '\'';
-   *r = '\0';
- 
-   return (result);
- }
- 
- /* Quote STRING using double quotes.  Return a new string. */
- char *
- double_quote (string)
-      char *string;
- {
-   register int c;
-   char *result, *r, *s;
- 
-   result = (char *)xmalloc (3 + (2 * strlen (string)));
-   r = result;
-   *r++ = '"';
- 
-   for (s = string; s && (c = *s); s++)
-     {
-       switch (c)
-         {
- 	case '"':
- 	case '$':
- 	case '`':
- 	case '\\':
- 	case '\n':		/* XXX */
- 	  *r++ = '\\';
- 	default:
- 	  *r++ = c;
- 	  break;
-         }
-     }
- 
-   *r++ = '"';
-   *r = '\0';
- 
-   return (result);
- }
- 
- /* Remove backslashes that are quoting characters that are special between
-    double quotes.  Return a new string. */
- char *
- un_double_quote (string)
-      char *string;
- {
-   register int c, pass_next;
-   char *result, *r, *s;
- 
-   r = result = xmalloc (strlen (string) + 1);
- 
-   for (pass_next = 0, s = string; s && (c = *s); s++)
-     {
-       if (pass_next)
- 	{
- 	  *r++ = c;
- 	  pass_next = 0;
- 	  continue;
- 	}
-       if (c == '\\' && strchr (slashify_in_quotes, s[1]))
- 	{
- 	  pass_next = 1;
- 	  continue;
- 	}
-       *r++ = c;
-     }
- 
-   *r = '\0';
-   return result;
- }
- 
- /* Quote special characters in STRING using backslashes.  Return a new
-    string. */
- char *
- backslash_quote (string)
-      char *string;
- {
-   int c;
-   char *result, *r, *s;
- 
-   result = xmalloc (2 * strlen (string) + 1);
- 
-   for (r = result, s = string; s && (c = *s); s++)
-     {
-       switch (c)
- 	{
- 	case ' ': case '\t': case '\n':		/* IFS white space */
- 	case '\'': case '"': case '\\':		/* quoting chars */
- 	case '|': case '&': case ';':		/* shell metacharacters */
- 	case '(': case ')': case '<': case '>':
- 	case '!': case '{': case '}':		/* reserved words */
- 	case '*': case '[': case '?': case ']':	/* globbing chars */
- 	case '^':
- 	case '$': case '`':			/* expansion chars */
- 	  *r++ = '\\';
- 	  *r++ = c;
- 	  break;
- #if 0
- 	case '~':				/* tilde expansion */
- 	  if (s == string || s[-1] == '=' || s[-1] == ':')
- 	    *r++ = '\\';
- 	  *r++ = c;
- 	  break;
- #endif
- 	case '#':				/* comment char */
- 	  if (s == string)
- 	    *r++ = '\\';
- 	  /* FALLTHROUGH */
- 	default:
- 	  *r++ = c;
- 	  break;
- 	}
-     }
- 
-   *r = '\0';
-   return (result);
- }
- 
- #if defined (PROMPT_STRING_DECODE)
- /* Quote characters that get special treatment when in double quotes in STRING
-    using backslashes.  Return a new string. */
- char *
- backslash_quote_for_double_quotes (string)
-      char *string;
- {
-   int c;
-   char *result, *r, *s;
- 
-   result = xmalloc (2 * strlen (string) + 1);
- 
-   for (r = result, s = string; s && (c = *s); s++)
-     {
-       switch (c)
- 	{
- 	case '"':
- 	case '$':
- 	case '`':
- 	case '\\':
- 	case '\n':
- 	  *r++ = '\\';
- 	  *r++ = c;
- 	  break;
- 	default:
- 	  *r++ = c;
- 	  break;
- 	}
-     }
- 
-   *r = '\0';
-   return (result);
- }
- #endif /* PROMPT_STRING_DECODE */
- 
- int
- contains_shell_metas (string)
-      char *string;
- {
-   char *s;
- 
-   for (s = string; s && *s; s++)
-     {
-       switch (*s)
- 	{
- 	case ' ': case '\t': case '\n':		/* IFS white space */
- 	case '\'': case '"': case '\\':		/* quoting chars */
- 	case '|': case '&': case ';':		/* shell metacharacters */
- 	case '(': case ')': case '<': case '>':
- 	case '!': case '{': case '}':		/* reserved words */
- 	case '*': case '[': case '?': case ']':	/* globbing chars */
- 	case '^':
- 	case '$': case '`':			/* expansion chars */
- 	  return (1);
- 	case '~':				/* tilde expansion */
- 	  if (s == string || s[-1] == '=' || s[-1] == ':')
- 	    return (1);
- 	case '#':
- 	  if (s == string)			/* comment char */
- 	    return (1);
- 	  /* FALLTHROUGH */
- 	default:
- 	  break;
- 	}
-     }
- 
-   return (0);
  }
--- 707,709 ----
diff -Nrc2 bash-2.04/builtins/common.h bash-2.05/builtins/common.h
*** bash-2.04/builtins/common.h	Tue Dec  7 11:00:06 1999
--- bash-2.05/builtins/common.h	Fri Oct 13 11:52:55 2000
***************
*** 71,81 ****
  extern void initialize_shell_builtins __P((void));
  
- extern char *single_quote __P((char *));
- extern char *double_quote __P((char *));
- extern char *un_double_quote __P((char *));
- extern char *backslash_quote __P((char *));
- extern char *backslash_quote_for_double_quotes __P((char *));
- extern int contains_shell_metas __P((char *));
- 
  /* Functions from set.def */
  extern void initialize_shell_options __P((int));
--- 71,74 ----
***************
*** 112,115 ****
--- 105,109 ----
  extern int maybe_execute_file __P((char *, int));
  extern int source_file __P((char *));
+ extern int fc_execute_file __P((char *));
  
  #endif /* !__COMMON_H */
diff -Nrc2 bash-2.04/builtins/complete.def bash-2.05/builtins/complete.def
*** bash-2.04/builtins/complete.def	Mon Feb 21 11:33:32 2000
--- bash-2.05/builtins/complete.def	Wed Feb 14 17:07:54 2001
***************
*** 25,29 ****
  $DEPENDS_ON PROGRAMMABLE_COMPLETION
  $FUNCTION complete_builtin
! $SHORT_DOC complete [-abcdefjkvu] [-pr] [-A action] [-G globpat] [-W wordlist] [-P prefix] [-S suffix] [-X filterpat] [-F function] [-C command] [name ...]
  For each NAME, specify how arguments are to be completed.
  If the -p option is supplied, or if no options are supplied, existing
--- 25,29 ----
  $DEPENDS_ON PROGRAMMABLE_COMPLETION
  $FUNCTION complete_builtin
! $SHORT_DOC complete [-abcdefjkvu] [-pr] [-o option] [-A action] [-G globpat] [-W wordlist] [-P prefix] [-S suffix] [-X filterpat] [-F function] [-C command] [name ...]
  For each NAME, specify how arguments are to be completed.
  If the -p option is supplied, or if no options are supplied, existing
***************
*** 91,94 ****
--- 91,104 ----
  };
  
+ static struct _compopt {
+   char *optname;
+   int optflag;
+ } compopts[] = {
+   { "default",	COPT_DEFAULT },
+   { "dirnames", COPT_DIRNAMES },
+   { "filenames",COPT_FILENAMES},
+   { (char *)NULL, 0 },
+ };
+ 
  static int
  find_compact (name)
***************
*** 103,113 ****
  }
  
! /* Build the actions from the options specified in LIST.  ACTP is a pointer
!    to an unsigned long in which to place the bitmap of actions.  PP, if
!    non-null, gets 1 if -p is supplied; RP, if non-null, gets 1 if -r is
!    supplied.  If either is null, the corresponding option generates an
!    error.  This also sets variables corresponding to options that take
!    arguments as a side effect; the caller should ensure that those variables
!    are set to NULL before calling build_actions.  Return value:
     	EX_USAGE = bad option
     	EXECUTION_SUCCESS = some options supplied
--- 113,137 ----
  }
  
! static int
! find_compopt (name)
!      char *name;
! {
!   register int i;
! 
!   for (i = 0; compopts[i].optname; i++)
!     if (STREQ (name, compopts[i].optname))
!       return i;
!   return -1;
! }
! 
! /* Build the actions and compspec options from the options specified in LIST.
!    ACTP is a pointer to an unsigned long in which to place the bitmap of
!    actions.  OPTP is a pointer to an unsigned long in which to place the
!    btmap of compspec options (arguments to `-o').  PP, if non-null, gets 1
!    if -p is supplied; RP, if non-null, gets 1 if -r is supplied.
!    If either is null, the corresponding option generates an error.
!    This also sets variables corresponding to options that take arguments as
!    a side effect; the caller should ensure that those variables are set to
!    NULL before calling build_actions.  Return value:
     	EX_USAGE = bad option
     	EXECUTION_SUCCESS = some options supplied
***************
*** 116,132 ****
  
  static int
! build_actions (list, pp, rp, actp)
       WORD_LIST *list;
       int *pp, *rp;
!      unsigned long *actp;
  {
    int opt, ind, pflag, rflag, opt_given;
!   unsigned long acts;
  
!   acts = (unsigned long)0L;
    opt_given = 0;
  
    reset_internal_getopt ();
!   while ((opt = internal_getopt (list, "abcdefjkpruvA:G:W:P:S:X:F:C:")) != -1)
      {
        opt_given = 1;
--- 140,156 ----
  
  static int
! build_actions (list, pp, rp, actp, optp)
       WORD_LIST *list;
       int *pp, *rp;
!      unsigned long *actp, *optp;
  {
    int opt, ind, pflag, rflag, opt_given;
!   unsigned long acts, copts;
  
!   acts = copts = (unsigned long)0L;
    opt_given = 0;
  
    reset_internal_getopt ();
!   while ((opt = internal_getopt (list, "abcdefjko:pruvA:G:W:P:S:X:F:C:")) != -1)
      {
        opt_given = 1;
***************
*** 189,192 ****
--- 213,225 ----
  	  acts |= CA_VARIABLE;
  	  break;
+ 	case 'o':
+ 	  ind = find_compopt (list_optarg);
+ 	  if (ind < 0)
+ 	    {
+ 	      builtin_error ("%s: invalid option name", list_optarg);
+ 	      return (EX_USAGE);
+ 	    }
+ 	  copts |= compopts[ind].optflag;
+ 	  break;
  	case 'A':
  	  ind = find_compact (list_optarg);
***************
*** 226,229 ****
--- 259,264 ----
  
    *actp = acts;
+   *optp = copts;
+ 
    return (opt_given ? EXECUTION_SUCCESS : EXECUTION_FAILURE);
  }
***************
*** 235,239 ****
  {
    int opt_given, pflag, rflag, rval;
!   unsigned long acts;
    char *cmd;
    COMPSPEC *cs;
--- 270,274 ----
  {
    int opt_given, pflag, rflag, rval;
!   unsigned long acts, copts;
    char *cmd;
    COMPSPEC *cs;
***************
*** 246,250 ****
  
    opt_given = pflag = rflag = 0;
!   acts = (unsigned long)0L;
    Aarg = Garg = Warg = Parg = Sarg = Xarg = Farg = Carg = (char *)NULL;
    cs = (COMPSPEC *)NULL;
--- 281,285 ----
  
    opt_given = pflag = rflag = 0;
!   acts = copts = (unsigned long)0L;
    Aarg = Garg = Warg = Parg = Sarg = Xarg = Farg = Carg = (char *)NULL;
    cs = (COMPSPEC *)NULL;
***************
*** 252,256 ****
    /* Build the actions from the arguments.  Also sets the [A-Z]arg variables
       as a side effect if they are supplied as options. */
!   rval = build_actions (list, &pflag, &rflag, &acts);
    if (rval == EX_USAGE)
      return (rval);
--- 287,291 ----
    /* Build the actions from the arguments.  Also sets the [A-Z]arg variables
       as a side effect if they are supplied as options. */
!   rval = build_actions (list, &pflag, &rflag, &acts, &copts);
    if (rval == EX_USAGE)
      return (rval);
***************
*** 291,294 ****
--- 326,330 ----
    cs = alloc_compspec ();
    cs->actions = acts;
+   cs->options = copts;
  
    cs->globpat = STRDUP (Garg);
***************
*** 305,309 ****
        cmd = list->word->word;
        if (add_progcomp (cmd, cs) == 0)
!         rval = EXECUTION_FAILURE;
      }
  
--- 341,345 ----
        cmd = list->word->word;
        if (add_progcomp (cmd, cs) == 0)
! 	rval = EXECUTION_FAILURE;
      }
  
***************
*** 333,337 ****
      if (a) \
        { \
!       	x = single_quote (a); \
  	printf ("%s %s ", f, x); \
  	free (x); \
--- 369,373 ----
      if (a) \
        { \
!       	x = sh_single_quote (a); \
  	printf ("%s %s ", f, x); \
  	free (x); \
***************
*** 357,360 ****
--- 393,402 ----
    } while (0)
  
+ #define PRINTCOMPOPT(a, f) \
+   do { \
+     if (copts & a) \
+       printf ("-o %s ", f); \
+   } while (0)
+ 
  static void
  print_one_completion (cmd, cs)
***************
*** 362,373 ****
       COMPSPEC *cs;
  {
!   unsigned long acts;
    char *x;
  
    printf ("complete ");
  
    acts = cs->actions;
  
!   /* simple flags first */
    PRINTOPT (CA_ALIAS, "-a");
    PRINTOPT (CA_BUILTIN, "-b");
--- 404,422 ----
       COMPSPEC *cs;
  {
!   unsigned long acts, copts;
    char *x;
  
    printf ("complete ");
  
+   copts = cs->options;
+ 
+   /* First, print the -o options. */
+   PRINTCOMPOPT (COPT_DEFAULT, "default");
+   PRINTCOMPOPT (COPT_DIRNAMES, "dirnames");
+   PRINTCOMPOPT (COPT_FILENAMES, "filenames");
+ 
    acts = cs->actions;
  
!   /* simple flags next */
    PRINTOPT (CA_ALIAS, "-a");
    PRINTOPT (CA_BUILTIN, "-b");
***************
*** 429,433 ****
        cs = find_compspec (l->word->word);
        if (cs)
!         print_one_completion (l->word->word, cs);
        else
  	{
--- 478,482 ----
        cs = find_compspec (l->word->word);
        if (cs)
! 	print_one_completion (l->word->word, cs);
        else
  	{
***************
*** 442,446 ****
  $DEPENDS_ON PROGRAMMABLE_COMPLETION
  $FUNCTION compgen_builtin
! $SHORT_DOC compgen [-abcdefjkvu] [-A action] [-G globpat] [-W wordlist] [-P prefix] [-S suffix] [-X filterpat] [-F function] [-C command] [word]
  Display the possible completions depending on the options.  Intended
  to be used from within a shell function generating possible completions.
--- 491,495 ----
  $DEPENDS_ON PROGRAMMABLE_COMPLETION
  $FUNCTION compgen_builtin
! $SHORT_DOC compgen [-abcdefjkvu] [-o option] [-A action] [-G globpat] [-W wordlist] [-P prefix] [-S suffix] [-X filterpat] [-F function] [-C command] [word]
  Display the possible completions depending on the options.  Intended
  to be used from within a shell function generating possible completions.
***************
*** 454,458 ****
  {
    int rval;
!   unsigned long acts;
    COMPSPEC *cs;
    STRINGLIST *sl;
--- 503,507 ----
  {
    int rval;
!   unsigned long acts, copts;
    COMPSPEC *cs;
    STRINGLIST *sl;
***************
*** 462,466 ****
      return (EXECUTION_SUCCESS);
  
!   acts = (unsigned long)0L;
    Aarg = Garg = Warg = Parg = Sarg = Xarg = Farg = Carg = (char *)NULL;
    cs = (COMPSPEC *)NULL;
--- 511,515 ----
      return (EXECUTION_SUCCESS);
  
!   acts = copts = (unsigned long)0L;
    Aarg = Garg = Warg = Parg = Sarg = Xarg = Farg = Carg = (char *)NULL;
    cs = (COMPSPEC *)NULL;
***************
*** 468,472 ****
    /* Build the actions from the arguments.  Also sets the [A-Z]arg variables
       as a side effect if they are supplied as options. */
!   rval = build_actions (list, (int *)NULL, (int *)NULL, &acts);
    if (rval == EX_USAGE)
      return (rval);
--- 517,521 ----
    /* Build the actions from the arguments.  Also sets the [A-Z]arg variables
       as a side effect if they are supplied as options. */
!   rval = build_actions (list, (int *)NULL, (int *)NULL, &acts, &copts);
    if (rval == EX_USAGE)
      return (rval);
***************
*** 486,489 ****
--- 535,539 ----
    cs = alloc_compspec ();
    cs->actions = acts;
+   cs->options = copts;
    cs->refcount = 1;
  
diff -Nrc2 bash-2.04/builtins/declare.def bash-2.05/builtins/declare.def
*** bash-2.04/builtins/declare.def	Thu Aug  5 07:40:55 1999
--- bash-2.05/builtins/declare.def	Wed Feb 14 17:08:37 2001
***************
*** 334,341 ****
  	    }
  
! 	  /* Cannot use declare to assign value to readonly variable. */
! 	  if (readonly_p (var) && offset)
  	    {
! 	      builtin_error ("%s: readonly variable", name);
  	      assign_error++;
  	      NEXT_VARIABLE ();
--- 334,343 ----
  	    }
  
! 	  /* Cannot use declare to assign value to readonly or noassign
! 	     variable. */
! 	  if ((readonly_p (var) || noassign_p (var)) && offset)
  	    {
! 	      if (readonly_p (var))
! 		builtin_error ("%s: readonly variable", name);
  	      assign_error++;
  	      NEXT_VARIABLE ();
***************
*** 348,352 ****
  	    {
  	      if (value[0] == '(' && strchr (value, ')'))
! 	        assigning_array_special = 1;
  	      else
  		{
--- 350,354 ----
  	    {
  	      if (value[0] == '(' && strchr (value, ')'))
! 		assigning_array_special = 1;
  	      else
  		{
diff -Nrc2 bash-2.04/builtins/enable.def bash-2.05/builtins/enable.def
*** bash-2.04/builtins/enable.def	Thu Aug  5 07:41:13 1999
--- bash-2.05/builtins/enable.def	Wed Feb 14 17:09:05 2001
***************
*** 165,169 ****
        filter = (flags & NFLAG) ? DISABLED : ENABLED;
        if (flags & SFLAG)
!         filter |= SPECIAL;
  
        result = dyn_load_builtin (list, filter, filename);
--- 165,169 ----
        filter = (flags & NFLAG) ? DISABLED : ENABLED;
        if (flags & SFLAG)
! 	filter |= SPECIAL;
  
        result = dyn_load_builtin (list, filter, filename);
***************
*** 327,334 ****
  
        if (old_builtin = builtin_address_internal (name, 1))
!         {
!           replaced++;
  	  FASTCOPY ((char *)b, (char *)old_builtin, sizeof (struct builtin));
!         }
        else
  	  new_builtins[new++] = b;
--- 327,334 ----
  
        if (old_builtin = builtin_address_internal (name, 1))
! 	{
! 	  replaced++;
  	  FASTCOPY ((char *)b, (char *)old_builtin, sizeof (struct builtin));
! 	}
        else
  	  new_builtins[new++] = b;
diff -Nrc2 bash-2.04/builtins/evalfile.c bash-2.05/builtins/evalfile.c
*** bash-2.04/builtins/evalfile.c	Thu Aug  5 07:41:32 1999
--- bash-2.05/builtins/evalfile.c	Wed Feb 14 17:05:16 2001
***************
*** 57,60 ****
--- 57,61 ----
  #define FEVAL_LONGJMP		0x010
  #define FEVAL_HISTORY		0x020
+ #define FEVAL_CHECKBINARY	0x040
  
  extern int interactive, interactive_shell, posixly_correct;
***************
*** 88,92 ****
  
        if (flags & FEVAL_LONGJMP)
!         {
  	  last_command_exit_value = 1;
  	  jump_to_top_level (EXITPROG);
--- 89,93 ----
  
        if (flags & FEVAL_LONGJMP)
! 	{
  	  last_command_exit_value = 1;
  	  jump_to_top_level (EXITPROG);
***************
*** 117,120 ****
--- 118,126 ----
        return ((flags & FEVAL_BUILTIN) ? EXECUTION_FAILURE : -1);
      }      
+ 
+ #if defined (__CYGWIN__) && defined (O_TEXT)
+   setmode (fd, O_TEXT);
+ #endif
+ 
    string = xmalloc (1 + file_size);
    result = read (fd, string, file_size);
***************
*** 137,141 ****
      }
        
!   if (check_binary_file ((unsigned char *)string, (result > 80) ? 80 : result))
      {
        free (string);
--- 143,148 ----
      }
        
!   if ((flags & FEVAL_CHECKBINARY) && 
!       check_binary_file ((unsigned char *)string, (result > 80) ? 80 : result))
      {
        free (string);
diff -Nrc2 bash-2.04/builtins/evalstring.c bash-2.05/builtins/evalstring.c
*** bash-2.04/builtins/evalstring.c	Fri Jan  7 16:17:16 2000
--- bash-2.05/builtins/evalstring.c	Wed Feb 14 17:05:23 2001
***************
*** 176,180 ****
  	    case DISCARD:
  	      run_unwind_frame ("pe_dispose");
! 	      last_command_exit_value = 1;	/* XXX */
  	      if (subshell_environment)
  		{
--- 176,180 ----
  	    case DISCARD:
  	      run_unwind_frame ("pe_dispose");
! 	      last_result = last_command_exit_value = EXECUTION_FAILURE; /* XXX */
  	      if (subshell_environment)
  		{
***************
*** 239,243 ****
  	      /* See if this is a candidate for $( <file ). */
  	      if (startup_state == 2 &&
! 		  subshell_environment == SUBSHELL_COMSUB &&
  		  *bash_input.location.string == '\0' &&
  		  command->type == cm_simple && !command->redirects &&
--- 239,243 ----
  	      /* See if this is a candidate for $( <file ). */
  	      if (startup_state == 2 &&
! 		  (subshell_environment & SUBSHELL_COMSUB) &&
  		  *bash_input.location.string == '\0' &&
  		  command->type == cm_simple && !command->redirects &&
***************
*** 278,283 ****
      {
        /* An interrupt during non-interactive execution in an
!          interactive shell (e.g. via $PROMPT_COMMAND) should
!          not cause the shell to exit. */
        interactive = interactive_shell;
        throw_to_top_level ();
--- 278,283 ----
      {
        /* An interrupt during non-interactive execution in an
! 	 interactive shell (e.g. via $PROMPT_COMMAND) should
! 	 not cause the shell to exit. */
        interactive = interactive_shell;
        throw_to_top_level ();
diff -Nrc2 bash-2.04/builtins/fc.def bash-2.05/builtins/fc.def
*** bash-2.04/builtins/fc.def	Thu Aug  5 07:42:12 1999
--- bash-2.05/builtins/fc.def	Wed Jan 17 11:51:50 2001
***************
*** 87,91 ****
  extern int unlink ();
  
! extern int fc_execute_file ();
  
  /* **************************************************************** */
--- 87,91 ----
  extern int unlink ();
  
! extern FILE *sh_mktmpfp __P((char *, int, char **));
  
  /* **************************************************************** */
***************
*** 162,166 ****
    char *ename, *command, *newcom, *line;
    HIST_ENTRY **hlist;
!   char fn[64];
  
    numbering = 1;
--- 162,166 ----
    char *ename, *command, *newcom, *line;
    HIST_ENTRY **hlist;
!   char *fn;
  
    numbering = 1;
***************
*** 328,339 ****
      {
        numbering = 0;
!       /* XXX - this is raceable */
!       sprintf (fn, "/tmp/bash%d", (int)time ((time_t *) 0) + (int)getpid ());
! 
!       stream = fopen (fn, "w");
! 
        if (stream == 0)
  	{
! 	  builtin_error ("cannot open temp file %s", fn);
  	  return (EXECUTION_FAILURE);
  	}
--- 328,336 ----
      {
        numbering = 0;
!       stream = sh_mktmpfp ("bash-fc", MT_USERANDOM|MT_USETMPDIR, &fn);
        if (stream == 0)
  	{
! 	  builtin_error ("cannot open temp file %s", fn ? fn : "");
! 	  FREE (fn);
  	  return (EXECUTION_FAILURE);
  	}
***************
*** 370,373 ****
--- 367,371 ----
      {
        unlink (fn);
+       free (fn);
        return (EXECUTION_FAILURE);
      }
***************
*** 382,385 ****
--- 380,384 ----
       will be echoed as they are read by the parser. */
    begin_unwind_frame ("fc builtin");
+   add_unwind_protect ((Function *)xfree, fn);
    add_unwind_protect (unlink, fn);
    unwind_protect_int (echo_input_at_read);
diff -Nrc2 bash-2.04/builtins/getopts.def bash-2.05/builtins/getopts.def
*** bash-2.04/builtins/getopts.def	Thu Aug  5 07:42:30 1999
--- bash-2.05/builtins/getopts.def	Wed Feb 14 17:09:23 2001
***************
*** 197,203 ****
        v = alloc_array (i + 1);
        for (i = 0; i < 10 && dollar_vars[i]; i++)
!         v[i] = dollar_vars[i];
        for (words = rest_of_args; words; words = words->next, i++)
!         v[i] = words->word->word;
        v[i] = (char *)NULL;
        sh_getopt_restore_state (v);
--- 197,203 ----
        v = alloc_array (i + 1);
        for (i = 0; i < 10 && dollar_vars[i]; i++)
! 	v[i] = dollar_vars[i];
        for (words = rest_of_args; words; words = words->next, i++)
! 	v[i] = words->word->word;
        v[i] = (char *)NULL;
        sh_getopt_restore_state (v);
diff -Nrc2 bash-2.04/builtins/hash.def bash-2.05/builtins/hash.def
*** bash-2.04/builtins/hash.def	Thu Sep 16 10:09:35 1999
--- bash-2.05/builtins/hash.def	Thu Oct 19 13:13:16 2000
***************
*** 42,45 ****
--- 42,47 ----
  #endif
  
+ #include <errno.h>
+ 
  #include "../bashansi.h"
  
***************
*** 120,124 ****
        w = list->word->word;
        if (pathname)
! 	remember_filename (w, pathname, 0, 0);
        else if (absolute_program (w))
  	continue;
--- 122,138 ----
        w = list->word->word;
        if (pathname)
! 	{
! 	  if (is_directory (pathname))
! 	    {
! #ifdef EISDIR
! 	      builtin_error ("%s: %s", pathname, strerror (EISDIR));
! #else
! 	      builtin_error ("%s: is a directory", pathname);
! #endif
! 	      opt = EXECUTION_FAILURE;
! 	    }
! 	  else
! 	    remember_filename (w, pathname, 0, 0);
! 	}
        else if (absolute_program (w))
  	continue;
diff -Nrc2 bash-2.04/builtins/history.def bash-2.05/builtins/history.def
*** bash-2.04/builtins/history.def	Thu Aug  5 07:42:51 1999
--- bash-2.05/builtins/history.def	Wed Feb 14 17:09:42 2001
***************
*** 158,162 ****
      {
        if (list)
!         return (expand_and_print_history (list));
        return (EXECUTION_SUCCESS);
      }
--- 158,162 ----
      {
        if (list)
! 	return (expand_and_print_history (list));
        return (EXECUTION_SUCCESS);
      }
***************
*** 327,334 ****
  	}
        else
!         {
  	  fputs (s, stdout);
  	  putchar ('\n');
!         }
        FREE (s);
        list = list->next;
--- 327,334 ----
  	}
        else
! 	{
  	  fputs (s, stdout);
  	  putchar ('\n');
! 	}
        FREE (s);
        list = list->next;
diff -Nrc2 bash-2.04/builtins/mkbuiltins.c bash-2.05/builtins/mkbuiltins.c
*** bash-2.04/builtins/mkbuiltins.c	Thu Aug  5 08:42:54 1999
--- bash-2.05/builtins/mkbuiltins.c	Wed Feb 14 17:06:45 2001
***************
*** 206,210 ****
        else if (strcmp (arg, "-nodocument") == 0)
  	no_long_document = 1;
! #endif /* !OLDCODE */        
        else
  	{
--- 206,210 ----
        else if (strcmp (arg, "-nodocument") == 0)
  	no_long_document = 1;
! #endif /* !OLDCODE */	
        else
  	{
***************
*** 615,622 ****
      {
        for (i = 0; builtin = (BUILTIN_DESC *)defs->builtins->array[i]; i++)
!         {
  	  free_builtin (builtin);
  	  free (builtin);
!         }
        array_free (defs->builtins);
      }
--- 615,622 ----
      {
        for (i = 0; builtin = (BUILTIN_DESC *)defs->builtins->array[i]; i++)
! 	{
  	  free_builtin (builtin);
  	  free (builtin);
! 	}
        array_free (defs->builtins);
      }
***************
*** 991,997 ****
    new = (BUILTIN_DESC *)xmalloc (sizeof (BUILTIN_DESC));
  
!   new->name         = savestring (builtin->name);
!   new->shortdoc     = savestring (builtin->shortdoc);
!   new->longdoc      = copy_string_array (builtin->longdoc);
    new->dependencies = copy_string_array (builtin->dependencies);
  
--- 991,997 ----
    new = (BUILTIN_DESC *)xmalloc (sizeof (BUILTIN_DESC));
  
!   new->name = savestring (builtin->name);
!   new->shortdoc = savestring (builtin->shortdoc);
!   new->longdoc = copy_string_array (builtin->longdoc);
    new->dependencies = copy_string_array (builtin->dependencies);
  
***************
*** 1152,1156 ****
  
  		  fprintf (externfile, "extern char *%s_doc[];\n",
! 			   builtin->docname ?builtin->docname : builtin->name);
  		}
  
--- 1152,1156 ----
  
  		  fprintf (externfile, "extern char *%s_doc[];\n",
! 			   builtin->docname ? builtin->docname : builtin->name);
  		}
  
diff -Nrc2 bash-2.04/builtins/printf.def bash-2.05/builtins/printf.def
*** bash-2.04/builtins/printf.def	Thu Aug  5 07:43:32 1999
--- bash-2.05/builtins/printf.def	Wed Feb 14 17:09:55 2001
***************
*** 89,93 ****
  static int getlong __P((long *));
  static int getulong __P((unsigned long *));
! static double getdouble __P((void));
  static int asciicode __P((void));
  
--- 89,93 ----
  static int getlong __P((long *));
  static int getulong __P((unsigned long *));
! static int getdouble __P((double *));
  static int asciicode __P((void));
  
***************
*** 95,99 ****
  static int retval;
  
! extern char *backslash_quote ();
  
  int
--- 95,99 ----
  static int retval;
  
! extern char *sh_backslash_quote ();
  
  int
***************
*** 256,260 ****
  
  		p = getstr ();
! 		xp = backslash_quote (p);
  		if (xp)
  		  {
--- 256,260 ----
  
  		p = getstr ();
! 		xp = sh_backslash_quote (p);
  		if (xp)
  		  {
***************
*** 308,312 ****
  		double p;
  
! 		p = getdouble ();
  		PF(start, p);
  		break;
--- 308,313 ----
  		double p;
  
! 		if (getdouble (&p))
! 		  PRETURN (EXECUTION_FAILURE);
  		PF(start, p);
  		break;
***************
*** 472,476 ****
        case 'b': *cp = '\b'; break;
  
!       case 'e': *cp = '\033'; break;	/* ESC -- non-ANSI */
  
        case 'f': *cp = '\f'; break;
--- 473,478 ----
        case 'b': *cp = '\b'; break;
  
!       case 'e':
!       case 'E': *cp = '\033'; break;	/* ESC -- non-ANSI */
  
        case 'f': *cp = '\f'; break;
***************
*** 485,489 ****
  
        /* %b octal constants are `\0' followed by one, two, or three
!          octal digits... */
        case '0':
  	for (temp = 3, evalue = 0; isoctal (*p) && temp--; p++)
--- 487,491 ----
  
        /* %b octal constants are `\0' followed by one, two, or three
! 	 octal digits... */
        case '0':
  	for (temp = 3, evalue = 0; isoctal (*p) && temp--; p++)
***************
*** 639,644 ****
    if (ret > INT_MAX)
      {
!       builtin_error ("%s: %s", garglist->word->word, strerror(ERANGE));
!       return (0);
      }
  
--- 641,651 ----
    if (ret > INT_MAX)
      {
!       builtin_error ("warning: %s: %s", garglist->word->word, strerror(ERANGE));
!       ret = INT_MAX;
!     }
!   else if (ret < INT_MIN)
!     {
!       builtin_error ("warning: %s: %s", garglist->word->word, strerror(ERANGE));
!       ret = INT_MIN;
      }
  
***************
*** 677,684 ****
      }
    else if (errno == ERANGE)
!     {
!       builtin_error ("%s: %s", garglist->word->word, strerror(ERANGE));
!       return (1);
!     }
  
    *lp = ret;
--- 684,688 ----
      }
    else if (errno == ERANGE)
!     builtin_error ("warning: %s: %s", garglist->word->word, strerror(ERANGE));
  
    *lp = ret;
***************
*** 715,722 ****
      }
    else if (errno == ERANGE)
!     {
!       builtin_error ("%s: %s", garglist->word->word, strerror(ERANGE));
!       return (1);
!     }
  
    *ulp = ret;
--- 719,723 ----
      }
    else if (errno == ERANGE)
!     builtin_error ("warning: %s: %s", garglist->word->word, strerror(ERANGE));
  
    *ulp = ret;
***************
*** 725,743 ****
  }
  
! static double
! getdouble ()
  {
    double ret;
  
    if (garglist == 0)
!     return ((double)0);
  
    if (garglist->word->word[0] == '\'' || garglist->word->word[0] == '"')
!     return ((double)asciicode ());
  
!   /* This should use strtod if it is available. */
!   ret = atof (garglist->word->word);
    garglist = garglist->next;
!   return (ret);
  }
  
--- 726,761 ----
  }
  
! static int
! getdouble (dp)
!      double *dp;
  {
    double ret;
+   char *ep;
  
    if (garglist == 0)
!     {
!       *dp = (double)0;
!       return (0);
!     }
  
    if (garglist->word->word[0] == '\'' || garglist->word->word[0] == '"')
!     {
!       *dp = (double)asciicode ();
!       return (0);
!     }
  
!   errno = 0;
!   ret = strtod (garglist->word->word, &ep);
!   if (*ep)
!     {
!       builtin_error ("%s: invalid number", garglist->word->word);
!       return (1);
!     }
!   else if (errno == ERANGE)
!     builtin_error ("warning: %s: %s", garglist->word->word, strerror(ERANGE));
! 
!   *dp = ret;
    garglist = garglist->next;
!   return (0);
  }
  
diff -Nrc2 bash-2.04/builtins/pushd.def bash-2.05/builtins/pushd.def
*** bash-2.04/builtins/pushd.def	Thu Aug  5 07:43:50 1999
--- bash-2.05/builtins/pushd.def	Wed Feb 14 17:10:37 2001
***************
*** 187,194 ****
  	}
        else if (ISOPTION (list->word->word, '-'))
!         {
!           list = list->next;
!           break;
!         }
        else if (list->word->word[0] == '-' && list->word->word[1] == '\0')
  	/* Let `pushd -' work like it used to. */
--- 187,194 ----
  	}
        else if (ISOPTION (list->word->word, '-'))
! 	{
! 	  list = list->next;
! 	  break;
! 	}
        else if (list->word->word[0] == '-' && list->word->word[1] == '\0')
  	/* Let `pushd -' work like it used to. */
***************
*** 297,308 ****
      {
        if (ISOPTION (list->word->word, 'n'))
!         {
!           flags |= NOCD;
!         }
        else if (ISOPTION (list->word->word, '-'))
!         {
!           list = list->next;
!           break;
!         }
        else if (((direction = list->word->word[0]) == '+') || direction == '-')
  	{
--- 297,308 ----
      {
        if (ISOPTION (list->word->word, 'n'))
! 	{
! 	  flags |= NOCD;
! 	}
        else if (ISOPTION (list->word->word, '-'))
! 	{
! 	  list = list->next;
! 	  break;
! 	}
        else if (((direction = list->word->word[0]) == '+') || direction == '-')
  	{
***************
*** 336,340 ****
      {
        i = ((flags & NOCD) == 0) ? cd_to_string (pushd_directory_list[directory_list_offset - 1])
!       			        : EXECUTION_SUCCESS;
        if (i != EXECUTION_SUCCESS)
  	return (i);
--- 336,340 ----
      {
        i = ((flags & NOCD) == 0) ? cd_to_string (pushd_directory_list[directory_list_offset - 1])
!       				: EXECUTION_SUCCESS;
        if (i != EXECUTION_SUCCESS)
  	return (i);
***************
*** 387,398 ****
  	}
        else if (ISOPTION (list->word->word, '-'))
!         {
!           list = list->next;
!           break;
!         }
        else if (*list->word->word == '+' || *list->word->word == '-')
!         {
!           int sign;
!           if (legal_number (w = list->word->word + 1, &i) == 0)
  	    {
  	      builtin_error (m_badarg, list->word->word);
--- 387,398 ----
  	}
        else if (ISOPTION (list->word->word, '-'))
! 	{
! 	  list = list->next;
! 	  break;
! 	}
        else if (*list->word->word == '+' || *list->word->word == '-')
! 	{
! 	  int sign;
! 	  if (legal_number (w = list->word->word + 1, &i) == 0)
  	    {
  	      builtin_error (m_badarg, list->word->word);
diff -Nrc2 bash-2.04/builtins/read.def bash-2.05/builtins/read.def
*** bash-2.04/builtins/read.def	Thu Aug  5 07:43:57 1999
--- bash-2.05/builtins/read.def	Wed Feb 14 17:10:46 2001
***************
*** 59,62 ****
--- 59,67 ----
  #include <errno.h>
  
+ #ifdef __CYGWIN__
+ #  include <fcntl.h>
+ #  include <io.h>
+ #endif
+ 
  #include "../shell.h"
  #include "common.h"
***************
*** 149,154 ****
      {
        switch (opt)
!         {
!         case 'r':
  	  raw = 1;
  	  break;
--- 154,159 ----
      {
        switch (opt)
! 	{
! 	case 'r':
  	  raw = 1;
  	  break;
***************
*** 212,224 ****
  
    begin_unwind_frame ("read_builtin");
-   add_unwind_protect (xfree, input_string);
  #if defined (READLINE)
    add_unwind_protect (xfree, rlbuf);
  #endif
-   interrupt_immediately++;
  
    input_is_tty = isatty (0);
    if (input_is_tty == 0)
! #ifndef __CYGWIN32__
      input_is_pipe = (lseek (0, 0L, SEEK_CUR) < 0) && (errno == ESPIPE);
  #else
--- 217,227 ----
  
    begin_unwind_frame ("read_builtin");
  #if defined (READLINE)
    add_unwind_protect (xfree, rlbuf);
  #endif
  
    input_is_tty = isatty (0);
    if (input_is_tty == 0)
! #ifndef __CYGWIN__
      input_is_pipe = (lseek (0, 0L, SEEK_CUR) < 0) && (errno == ESPIPE);
  #else
***************
*** 248,252 ****
  	 input redirection). */
        if ((fstat (0, &tsb) < 0) || S_ISREG (tsb.st_mode))
!         tmout = -1;
      }
  
--- 251,255 ----
  	 input redirection). */
        if ((fstat (0, &tsb) < 0) || S_ISREG (tsb.st_mode))
! 	tmout = -1;
      }
  
***************
*** 286,290 ****
  #endif
        if (input_is_tty)
!         {
  	  ttsave ();
  	  if (silent)
--- 289,293 ----
  #endif
        if (input_is_tty)
! 	{
  	  ttsave ();
  	  if (silent)
***************
*** 302,307 ****
--- 305,319 ----
      }
  
+   /* This *must* be the top unwind-protect on the stack, so the manipulation
+      of the unwind-protect stack after the realloc() works right. */
+   add_unwind_protect (xfree, input_string);
+   interrupt_immediately++;
+ 
    unbuffered_read = (nchars > 0) || (delim != '\n') || input_is_pipe;
  
+ #if defined (__CYGWIN__) && defined (O_TEXT)
+   setmode (0, O_TEXT);
+ #endif
+ 
    for (eof = 0;;)
      {
***************
*** 346,350 ****
  
        if (i + 2 >= size)
! 	input_string = xrealloc (input_string, size += 128);
  
        /* If the next character is to be accepted verbatim, a backslash
--- 358,366 ----
  
        if (i + 2 >= size)
! 	{
! 	  input_string = xrealloc (input_string, size += 128);
! 	  remove_unwind_protect ();
! 	  add_unwind_protect (xfree, input_string);
! 	}
  
        /* If the next character is to be accepted verbatim, a backslash
***************
*** 420,426 ****
        var = find_variable (arrayname);
        if (var == 0)
!         var = make_new_array_variable (arrayname);
        else if (array_p (var) == 0)
!         var = convert_var_to_array (var);
  
        empty_array (array_cell (var));
--- 436,442 ----
        var = find_variable (arrayname);
        if (var == 0)
! 	var = make_new_array_variable (arrayname);
        else if (array_p (var) == 0)
! 	var = convert_var_to_array (var);
  
        empty_array (array_cell (var));
***************
*** 442,446 ****
       same way, but I believe that the difference in behaviors is useful
       enough to not do it.  Without the bash behavior, there is no way
!      to read a line completely without interpretation or modification.
       If you disagree, change the occurrences of `#if 0' to `#if 1' below. */
    if (list == 0)
--- 458,463 ----
       same way, but I believe that the difference in behaviors is useful
       enough to not do it.  Without the bash behavior, there is no way
!      to read a line completely without interpretation or modification
!      unless you mess with $IFS (e.g., setting it to the empty string).
       If you disagree, change the occurrences of `#if 0' to `#if 1' below. */
    if (list == 0)
***************
*** 463,471 ****
  	var = bind_variable ("REPLY", input_string);
        VUNSETATTR (var, att_invisible);
! #if 0
!       free (orig_input_string);
! #else
        free (input_string);
- #endif
        return (retval);
      }
--- 480,485 ----
  	var = bind_variable ("REPLY", input_string);
        VUNSETATTR (var, att_invisible);
! 
        free (input_string);
        return (retval);
      }
***************
*** 573,580 ****
  #if 0
        if (legal_identifier (name) == 0)
!         {
  	  builtin_error ("`%s': not a valid identifier", name);
  	  return ((SHELL_VAR *)NULL);
!         }
  #endif
        return (bind_variable (name, value));
--- 587,594 ----
  #if 0
        if (legal_identifier (name) == 0)
! 	{
  	  builtin_error ("`%s': not a valid identifier", name);
  	  return ((SHELL_VAR *)NULL);
! 	}
  #endif
        return (bind_variable (name, value));
diff -Nrc2 bash-2.04/builtins/set.def bash-2.05/builtins/set.def
*** bash-2.04/builtins/set.def	Thu Aug  5 07:44:25 1999
--- bash-2.05/builtins/set.def	Wed Mar 28 14:47:55 2001
***************
*** 53,57 ****
  extern int noclobber, posixly_correct, ignoreeof, eof_encountered_limit;
  #if defined (READLINE)
! extern int rl_editing_mode, no_line_editing;
  #endif /* READLINE */
  
--- 53,57 ----
  extern int noclobber, posixly_correct, ignoreeof, eof_encountered_limit;
  #if defined (READLINE)
! extern int no_line_editing;
  #endif /* READLINE */
  
***************
*** 225,231 ****
      {
        if (STREQ (name, binary_o_options[i].name))
!         return (GET_BINARY_O_OPTION_VALUE (i, name));
      }
!         
    return (-1);
  }
--- 225,231 ----
      {
        if (STREQ (name, binary_o_options[i].name))
! 	return (GET_BINARY_O_OPTION_VALUE (i, name));
      }
! 
    return (-1);
  }
***************
*** 257,261 ****
  	on_or_off = &value;
        if (mode == -1 || mode == *on_or_off)
!         print_minus_o_option (o_options[i].name, *on_or_off, reusable);
      }
    for (i = 0; binary_o_options[i].name; i++)
--- 257,261 ----
  	on_or_off = &value;
        if (mode == -1 || mode == *on_or_off)
! 	print_minus_o_option (o_options[i].name, *on_or_off, reusable);
      }
    for (i = 0; binary_o_options[i].name; i++)
***************
*** 263,267 ****
        value = GET_BINARY_O_OPTION_VALUE (i, binary_o_options[i].name);
        if (mode == -1 || mode == value)
!         print_minus_o_option (binary_o_options[i].name, value, reusable);
      }
  }
--- 263,267 ----
        value = GET_BINARY_O_OPTION_VALUE (i, binary_o_options[i].name);
        if (mode == -1 || mode == value)
! 	print_minus_o_option (binary_o_options[i].name, value, reusable);
      }
  }
***************
*** 391,398 ****
      {
        if (STREQ (option_name, o_options[i].name))
!         {
!           option_char = o_options[i].letter;
!           break;
!         }
      }
    if (option_char == -1)
--- 391,398 ----
      {
        if (STREQ (option_name, o_options[i].name))
! 	{
! 	  option_char = o_options[i].letter;
! 	  break;
! 	}
      }
    if (option_char == -1)
***************
*** 421,429 ****
      }
  
!   vars = all_shell_functions ();
!   if (vars)
      {
!       print_var_list (vars);
!       free (vars);
      }
  }
--- 421,434 ----
      }
  
!   /* POSIX.2 does not allow function names and definitions to be output when
!      `set' is invoked without options (PASC Interp #202). */
!   if (posixly_correct == 0)
      {
!       vars = all_shell_functions ();
!       if (vars)
! 	{
! 	  print_func_list (vars);
! 	  free (vars);
! 	}
      }
  }
***************
*** 534,538 ****
  }
  
! /* Reset the values of the -o options that are not also shell flags. */
  void
  reset_shell_options ()
--- 539,545 ----
  }
  
! /* Reset the values of the -o options that are not also shell flags.  This is
!    called from execute_cmd.c:initialize_subshell() when setting up a subshell
!    to run an executable shell script without a leading `#!'. */
  void
  reset_shell_options ()
***************
*** 541,545 ****
    remember_on_history = 1;
  #endif
!   ignoreeof = posixly_correct = 0;
  }
  
--- 548,552 ----
    remember_on_history = 1;
  #endif
!   ignoreeof = 0;
  }
  
***************
*** 696,701 ****
  unset will only act on functions.  With neither flag, unset first
  tries to unset a variable, and if that fails, then tries to unset a
! function.  Some variables (such as PATH and IFS) cannot be unset; also
! see readonly.
  $END
  
--- 703,707 ----
  unset will only act on functions.  With neither flag, unset first
  tries to unset a variable, and if that fails, then tries to unset a
! function.  Some variables cannot be unset; also see readonly.
  $END
  
***************
*** 759,766 ****
  	 mode when unsetting a function. */
        if (((unset_function && posixly_correct) || !unset_function) && legal_identifier (name) == 0)
!         {
!           builtin_error ("`%s': not a valid identifier", name);
!           NEXT_VARIABLE ();
!         }
  
        var = unset_function ? find_function (name) : find_variable (name);
--- 765,772 ----
  	 mode when unsetting a function. */
        if (((unset_function && posixly_correct) || !unset_function) && legal_identifier (name) == 0)
! 	{
! 	  builtin_error ("`%s': not a valid identifier", name);
! 	  NEXT_VARIABLE ();
! 	}
  
        var = unset_function ? find_function (name) : find_variable (name);
diff -Nrc2 bash-2.04/builtins/setattr.def bash-2.05/builtins/setattr.def
*** bash-2.04/builtins/setattr.def	Thu Aug  5 07:44:32 1999
--- bash-2.05/builtins/setattr.def	Wed Feb 14 17:11:44 2001
***************
*** 170,174 ****
  	  assign = assignment (name);
  
!           if (assign)
  	    name[assign] = '\0';
  
--- 170,174 ----
  	  assign = assignment (name);
  
! 	  if (assign)
  	    name[assign] = '\0';
  
***************
*** 234,242 ****
  #if defined (ARRAY_VARS)
        if (attribute & att_array)
!         {
!           arrays_only++;
!           if (attribute != att_array)
  	    attribute &= ~att_array;
!         }
  #endif
  
--- 234,242 ----
  #if defined (ARRAY_VARS)
        if (attribute & att_array)
! 	{
! 	  arrays_only++;
! 	  if (attribute != att_array)
  	    attribute &= ~att_array;
! 	}
  #endif
  
***************
*** 247,251 ****
  #if defined (ARRAY_VARS)
  	      if (arrays_only && array_p (var) == 0)
! 	        continue;
  #endif
  	      if ((var->attributes & attribute) && invisible_p (var) == 0)
--- 247,251 ----
  #if defined (ARRAY_VARS)
  	      if (arrays_only && array_p (var) == 0)
! 		continue;
  #endif
  	      if ((var->attributes & attribute) && invisible_p (var) == 0)
***************
*** 286,299 ****
  
        if (function_p (var))
!         flags[i++] = 'f';
  
        if (integer_p (var))
!         flags[i++] = 'i';
  
        if (readonly_p (var))
!         flags[i++] = 'r';
  
        if (exported_p (var))
!         flags[i++] = 'x';
      }
    else
--- 286,299 ----
  
        if (function_p (var))
! 	flags[i++] = 'f';
  
        if (integer_p (var))
! 	flags[i++] = 'i';
  
        if (readonly_p (var))
! 	flags[i++] = 'r';
  
        if (exported_p (var))
! 	flags[i++] = 'x';
      }
    else
***************
*** 305,309 ****
  
        if (function_p (var))
!         flags[i++] = 'f';
      }
  
--- 305,309 ----
  
        if (function_p (var))
! 	flags[i++] = 'f';
      }
  
***************
*** 330,334 ****
    else
      {
!       x = double_quote (value_cell (var) ? value_cell (var) : "");
        printf ("%s=%s\n", var->name, x);
        free (x);
--- 330,334 ----
    else
      {
!       x = sh_double_quote (value_cell (var) ? value_cell (var) : "");
        printf ("%s=%s\n", var->name, x);
        free (x);
diff -Nrc2 bash-2.04/builtins/shopt.def bash-2.05/builtins/shopt.def
*** bash-2.04/builtins/shopt.def	Tue Sep 21 11:20:01 1999
--- bash-2.05/builtins/shopt.def	Wed Feb 14 17:11:56 2001
***************
*** 333,338 ****
  	rval = EXECUTION_FAILURE;
        if ((flags & QFLAG) == 0)
!         print_shopt (l->word->word, val, flags);
      }
    return (rval);
  }
--- 333,339 ----
  	rval = EXECUTION_FAILURE;
        if ((flags & QFLAG) == 0)
! 	print_shopt (l->word->word, val, flags);
      }
+ 
    return (rval);
  }
diff -Nrc2 bash-2.04/builtins/source.def bash-2.05/builtins/source.def
*** bash-2.04/builtins/source.def	Thu Aug  5 07:44:52 1999
--- bash-2.05/builtins/source.def	Tue Sep 26 10:05:04 2000
***************
*** 68,80 ****
  int source_uses_path = 1;
  
  /* If this . script is supplied arguments, we save the dollar vars and
     replace them with the script arguments for the duration of the script's
     execution.  If the script does not change the dollar vars, we restore
!    what we saved.  If the dollar vars are changed in the script, we leave
!    the new values alone and free the saved values. */
  static void
  maybe_pop_dollar_vars ()
  {
!   if (dollar_vars_changed ())
      {
        dispose_saved_dollar_vars ();
--- 68,85 ----
  int source_uses_path = 1;
  
+ /* If non-zero, `.' looks in the current directory if the filename argument
+    is not found in the $PATH. */
+ int source_searches_cwd = 1;
+ 
  /* If this . script is supplied arguments, we save the dollar vars and
     replace them with the script arguments for the duration of the script's
     execution.  If the script does not change the dollar vars, we restore
!    what we saved.  If the dollar vars are changed in the script, and we are
!    not executing a shell function, we leave the new values alone and free
!    the saved values. */
  static void
  maybe_pop_dollar_vars ()
  {
!   if (variable_context == 0 && dollar_vars_changed ())
      {
        dispose_saved_dollar_vars ();
***************
*** 118,122 ****
      filename = find_path_file (list->word->word);
    if (filename == 0)
!     filename = savestring (list->word->word);
  
    begin_unwind_frame ("source");
--- 123,135 ----
      filename = find_path_file (list->word->word);
    if (filename == 0)
!     {
!       if (source_searches_cwd == 0)
! 	{
! 	  builtin_error ("%s: file not found", list->word->word);
! 	  return (EXECUTION_FAILURE);
! 	}
!       else
! 	filename = savestring (list->word->word);
!     }
  
    begin_unwind_frame ("source");
diff -Nrc2 bash-2.04/builtins/trap.def bash-2.05/builtins/trap.def
*** bash-2.04/builtins/trap.def	Thu Aug  5 07:45:19 1999
--- bash-2.05/builtins/trap.def	Fri Nov  3 11:18:54 2000
***************
*** 80,84 ****
  #define IGNORE 2		/* Ignore this signal. */
  
! extern int interactive;
  
  int
--- 80,84 ----
  #define IGNORE 2		/* Ignore this signal. */
  
! extern int interactive, posixly_correct;
  
  int
***************
*** 202,206 ****
      return;
  
!   t = (p == (char *)IGNORE_SIG) ? (char *)NULL : single_quote (p);
    sn = signal_name (i);
    /* Make sure that signals whose names are unknown (for whatever reason)
--- 202,206 ----
      return;
  
!   t = (p == (char *)IGNORE_SIG) ? (char *)NULL : sh_single_quote (p);
    sn = signal_name (i);
    /* Make sure that signals whose names are unknown (for whatever reason)
***************
*** 208,211 ****
--- 208,218 ----
    if (STREQN (sn, "SIGJUNK", 7) || STREQN (sn, "unknown", 7))
      printf ("trap -- %s %d\n", t ? t : "''", i);
+   else if (posixly_correct)
+     {
+       if (STREQN (sn, "SIG", 3))
+ 	printf ("trap -- %s %s\n", t ? t : "''", sn+3);
+       else
+ 	printf ("trap -- %s %s\n", t ? t : "''", sn);
+     }
    else
      printf ("trap -- %s %s\n", t ? t : "''", sn);
diff -Nrc2 bash-2.04/builtins/type.def bash-2.05/builtins/type.def
*** bash-2.04/builtins/type.def	Mon Nov 29 12:11:18 1999
--- bash-2.05/builtins/type.def	Wed Feb 14 17:12:13 2001
***************
*** 124,133 ****
  	}
        else if (STREQ (flag, "all") || STREQ (flag, "-all"))
!         all = 1;
        else
  	{
!           prev = this;
!           this = this->next;
!           continue;
  	}
  
--- 124,133 ----
  	}
        else if (STREQ (flag, "all") || STREQ (flag, "-all"))
! 	all = 1;
        else
  	{
! 	  prev = this;
! 	  this = this->next;
! 	  continue;
  	}
  
***************
*** 235,239 ****
        else if (verbose == 4)
  	{
! 	  x = single_quote (alias->value);
  	  printf ("alias %s=%s\n", command, x);
  	  free (x);
--- 235,239 ----
        else if (verbose == 4)
  	{
! 	  x = sh_single_quote (alias->value);
  	  printf ("alias %s=%s\n", command, x);
  	  free (x);
***************
*** 318,322 ****
        f = file_status (command);
        if (f & FS_EXECABLE)
!         {
  	  if (verbose == 1)
  	    puts ("file");
--- 318,322 ----
        f = file_status (command);
        if (f & FS_EXECABLE)
! 	{
  	  if (verbose == 1)
  	    puts ("file");
***************
*** 330,334 ****
  	     name is supplied. */
  	  return (1);
!         }
      }
  
--- 330,334 ----
  	     name is supplied. */
  	  return (1);
! 	}
      }
  
diff -Nrc2 bash-2.04/builtins/ulimit.def bash-2.05/builtins/ulimit.def
*** bash-2.04/builtins/ulimit.def	Mon Jan 24 10:47:38 2000
--- bash-2.05/builtins/ulimit.def	Mon Dec 18 10:37:45 2000
***************
*** 203,206 ****
--- 203,209 ----
    { 'v',	RLIMIT_VIRTMEM, RLIMIT_VMBLKSZ, "virtual memory (kbytes)" },
  #endif
+ #ifdef RLIMIT_SWAP
+   { 'w',	RLIMIT_SWAP,	1024,	"swap size (kbytes)" },
+ #endif
    { -1, -1, -1, (char *)NULL }
  };
***************
*** 477,481 ****
--- 480,490 ----
        case RLIMIT_OPENFILES:
  #if defined (HAVE_SETDTABLESIZE)
+ #  if defined (__CYGWIN__)
+ 	/* Grrr... Cygwin declares setdtablesize as void. */
+ 	setdtablesize (newlim);
+ 	return 0;
+ #  else
  	return (setdtablesize (newlim));
+ #  endif
  #endif
        case RLIMIT_PIPESIZE:
***************
*** 496,499 ****
--- 505,509 ----
  #  endif /* HPUX9 */
        val = (current_user.euid != 0 && newlim == RLIM_INFINITY &&
+ 	       (mode & LIMIT_HARD) == 0 &&		/* XXX -- test */
  	       (limit.rlim_cur <= limit.rlim_max))
  		 ? limit.rlim_max : newlim;
diff -Nrc2 bash-2.04/builtins/umask.def bash-2.05/builtins/umask.def
*** bash-2.04/builtins/umask.def	Tue Feb 22 12:26:55 2000
--- bash-2.05/builtins/umask.def	Wed Feb 14 17:12:26 2001
***************
*** 189,193 ****
        /* Parse the `who' portion of the symbolic mode clause. */
        while (member (*s, "agou"))
!         {
  	  switch (c = *s++)
  	    {
--- 189,193 ----
        /* Parse the `who' portion of the symbolic mode clause. */
        while (member (*s, "agou"))
! 	{
  	  switch (c = *s++)
  	    {
diff -Nrc2 bash-2.04/builtins/wait.def bash-2.05/builtins/wait.def
*** bash-2.04/builtins/wait.def	Fri Aug  6 15:08:54 1999
--- bash-2.05/builtins/wait.def	Wed Jan 17 15:40:08 2001
***************
*** 67,71 ****
     the last one waited for. */
  
! #define WAIT_RETURN(s) do { run_unwind_frame ("wait_builtin"); return (s); } while (0)
  
  int
--- 67,77 ----
     the last one waited for. */
  
! #define WAIT_RETURN(s) \
!   do \
!     { \
!       interrupt_immediately = old_interrupt_immediately;\
!       return (s);\
!     } \
!   while (0)
  
  int
***************
*** 74,77 ****
--- 80,84 ----
  {
    int status, code;
+   volatile int old_interrupt_immediately;
  
    if (no_options (list))
***************
*** 80,85 ****
      list = loptend;
  
!   begin_unwind_frame ("wait_builtin");
!   unwind_protect_int (interrupt_immediately);
    interrupt_immediately++;
  
--- 87,91 ----
      list = loptend;
  
!   old_interrupt_immediately = interrupt_immediately;
    interrupt_immediately++;
  
diff -Nrc2 bash-2.04/command.h bash-2.05/command.h
*** bash-2.04/command.h	Thu Aug  5 07:03:21 1999
--- bash-2.05/command.h	Thu Oct  5 15:31:17 2000
***************
*** 40,43 ****
--- 40,46 ----
  #define HEREDOC_REDIRECT    -4  /* here-doc temp file can't be created */
  
+ #define CLOBBERING_REDIRECT(ri) \
+   (ri == r_output_direction || ri == r_err_and_out)
+ 
  #define OUTPUT_REDIRECT(ri) \
    (ri == r_output_direction || ri == r_input_output || ri == r_err_and_out)
***************
*** 65,68 ****
--- 68,72 ----
  #define W_NOSPLIT	0x10	/* Do not perform word splitting on this word. */
  #define W_NOGLOB	0x20	/* Do not perform globbing on this word. */
+ #define W_NOSPLIT2	0x40	/* Don't split word except for $@ expansion. */
  
  /* Possible values for subshell_environment */
***************
*** 71,74 ****
--- 75,79 ----
  #define SUBSHELL_COMSUB	0x04	/* subshell caused by `command` or $(command) */
  #define SUBSHELL_FORK	0x08	/* subshell caused by executing a disk command */
+ #define SUBSHELL_PIPE	0x10	/* subshell from a pipeline element */
  
  /* A structure which represents a word. */
diff -Nrc2 bash-2.04/config-bot.h bash-2.05/config-bot.h
*** bash-2.04/config-bot.h	Fri Dec 17 07:11:22 1999
--- bash-2.05/config-bot.h	Wed Feb  7 13:27:59 2001
***************
*** 1,3 ****
! /* config.h.bot */
  /* modify settings or make new ones based on what autoconf tells us. */
  
--- 1,3 ----
! /* config-bot.h */
  /* modify settings or make new ones based on what autoconf tells us. */
  
diff -Nrc2 bash-2.04/config-top.h bash-2.05/config-top.h
*** bash-2.04/config-top.h	Fri May 21 12:45:11 1999
--- bash-2.05/config-top.h	Wed Feb  7 13:28:14 2001
***************
*** 1,3 ****
! /* config.h.top */
  
  /* This contains various user-settable options not under the control of
--- 1,3 ----
! /* config-top.h */
  
  /* This contains various user-settable options not under the control of
diff -Nrc2 bash-2.04/config.h.in bash-2.05/config.h.in
*** bash-2.04/config.h.in	Mon Feb 14 15:48:38 2000
--- bash-2.05/config.h.in	Mon Oct  2 09:44:22 2000
***************
*** 143,146 ****
--- 143,150 ----
  /* Beginning of autoconf additions. */
  
+ #define DEFAULT_MAIL_DIRECTORY "/usr/spool/mail"
+ 
+ /* Memory management functions. */
+ 
  /* Define if using the bash version of malloc in lib/malloc/malloc.c */
  #undef USING_BASH_MALLOC
***************
*** 153,166 ****
  #undef CRAY_STACKSEG_END
  
- /* Define to the type of elements in the array set by `getgroups'.
-    Usually this is either `int' or `gid_t'.  */
- #undef GETGROUPS_T
- 
- /* Define if the `getpgrp' function takes no argument.  */
- #undef GETPGRP_VOID
- 
- /* Define to `int' if <sys/types.h> doesn't define.  */
- #undef gid_t
- 
  /* Define if you have alloca, as a function or macro.  */
  #undef HAVE_ALLOCA
--- 157,160 ----
***************
*** 169,198 ****
  #undef HAVE_ALLOCA_H
  
- /* Define if you don't have vprintf but do have _doprnt.  */
- #undef HAVE_DOPRNT
- 
- /* Define if system calls automatically restart after interruption
-    by a signal.  */
- #undef HAVE_RESTARTABLE_SYSCALLS
- 
- /* Define if you have <sys/wait.h> that is POSIX.1 compatible.  */
- #undef HAVE_SYS_WAIT_H
- 
- /* Define if you have <sys/time.h> */
- #undef HAVE_SYS_TIME_H
- 
- #undef TIME_WITH_SYS_TIME
- 
- #undef HAVE_SYS_TIMES_H
- 
- /* Define if you have the vprintf function.  */
- #undef HAVE_VPRINTF
- 
- #undef HAVE_WAIT3
- 
- #undef HAVE_SETOSTYPE
  
! /* Define if on MINIX.  */
! #undef _MINIX
  
  /* The number of bytes in a int.  */
--- 163,168 ----
  #undef HAVE_ALLOCA_H
  
  
! /* SYSTEM TYPES */
  
  /* The number of bytes in a int.  */
***************
*** 256,259 ****
--- 226,241 ----
  #undef time_t
  
+ /* Define to `int' if <sys/types.h> doesn't define.  */
+ #undef gid_t
+ 
+ /* Define if you have quad_t in <sys/types.h>. */
+ #undef HAVE_QUAD_T
+ 
+ #undef RLIMTYPE
+ 
+ /* Define to the type of elements in the array set by `getgroups'.
+    Usually this is either `int' or `gid_t'.  */
+ #undef GETGROUPS_T
+ 
  /* Define if the system does not provide POSIX.1 features except
     with this defined.  */
***************
*** 263,273 ****
  #undef _POSIX_SOURCE
  
! /* Define as the return type of signal handlers (int or void).  */
! #undef RETSIGTYPE
! 
! /* Define if the setvbuf function takes the buffering type as its second
!    argument and the buffer pointer as the third, as on System V
!    before release 3.  */
! #undef SETVBUF_REVERSED
  
  /* If using the C implementation of alloca, define if you know the
--- 245,249 ----
  #undef _POSIX_SOURCE
  
! /* Characteristics of the machine archictecture. */
  
  /* If using the C implementation of alloca, define if you know the
***************
*** 280,286 ****
--- 256,268 ----
  #undef STACK_DIRECTION
  
+ /* Define if the machine architecture is big-endian. */
+ #undef WORDS_BIGENDIAN
+ 
  /* Define if you have the ANSI C header files.  */
  #undef STDC_HEADERS
  
+ /* Check for the presence of certain non-function symbols in the system
+    libraries. */
+ 
  /* Define if `sys_siglist' is declared by <signal.h> or <unistd.h>.  */
  #undef SYS_SIGLIST_DECLARED
***************
*** 289,305 ****
  #undef UNDER_SYS_SIGLIST_DECLARED
  
! #undef DUP2_BROKEN
  
! #undef HAVE_GETHOSTBYNAME
  
! #undef HAVE_INET_ATON
  
! #undef HAVE_GETRLIMIT
  
- #undef HAVE_GETRUSAGE
  
! #undef HAVE_GETTIMEOFDAY
  
! #undef GWINSZ_IN_SYS_IOCTL
  
  #undef TIOCSTAT_IN_SYS_IOCTL
--- 271,288 ----
  #undef UNDER_SYS_SIGLIST_DECLARED
  
! #undef HAVE_SYS_SIGLIST
  
! #undef HAVE_UNDER_SYS_SIGLIST
  
! #undef HAVE_SYS_ERRLIST
  
! #undef HAVE_TIMEVAL
  
  
! /* Characteristics of some of the system structures. */
  
! #undef STRUCT_DIRENT_HAS_D_INO
! 
! #undef STRUCT_DIRENT_HAS_D_FILENO
  
  #undef TIOCSTAT_IN_SYS_IOCTL
***************
*** 307,343 ****
  #undef FIONREAD_IN_SYS_IOCTL
  
! #undef WORDS_BIGENDIAN
  
! #undef HAVE_HASH_BANG_EXEC
  
! #undef HAVE_BSD_SIGNALS
  
! #undef HAVE_POSIX_SIGNALS
  
! #undef HAVE_USG_SIGHOLD
  
! #undef HAVE_DEV_FD
  
- #undef DEV_FD_PREFIX
  
! #undef HAVE_DEV_STDIN
  
  #undef HAVE_GETPW_DECLS
  
- #undef HAVE_QUAD_T
- 
  #undef HAVE_RESOURCE
  
! #undef HAVE_STRSIGNAL
! 
! #undef HAVE_SYS_ERRLIST
! 
! #undef STAT_MACROS_BROKEN
  
! #undef HAVE_TIMEVAL
  
! #undef HAVE_MEMMOVE
  
! #undef HAVE_MKFIFO
  
  #undef NAMED_PIPES_MISSING
--- 290,320 ----
  #undef FIONREAD_IN_SYS_IOCTL
  
! #undef GWINSZ_IN_SYS_IOCTL
  
! #undef STRUCT_WINSIZE_IN_SYS_IOCTL
  
! #undef STRUCT_WINSIZE_IN_TERMIOS
  
! #undef SPEED_T_IN_SYS_TYPES
  
! #undef TERMIOS_LDISC
  
! #undef TERMIO_LDISC
  
  
! /* Characteristics of definitions in the system header files. */
  
  #undef HAVE_GETPW_DECLS
  
  #undef HAVE_RESOURCE
  
! #undef SBRK_DECLARED
  
! #undef PRINTF_DECLARED
  
! /* Characteristics of system calls and C library functions. */
  
! /* Define if the `getpgrp' function takes no argument.  */
! #undef GETPGRP_VOID
  
  #undef NAMED_PIPES_MISSING
***************
*** 347,395 ****
  #undef PGRP_PIPE
  
! #undef RLIMTYPE
  
! #undef SBRK_DECLARED
  
! #undef PRINTF_DECLARED
  
! #undef HAVE_SYS_SIGLIST
  
- #undef HAVE_TIMES
  
! #undef HAVE_UNDER_SYS_SIGLIST
  
! #undef VOID_SIGHANDLER
  
! #undef TERMIOS_LDISC
  
! #undef TERMIO_LDISC
  
! #undef ULIMIT_MAXFDS
  
- #undef GETCWD_BROKEN
  
! #undef STRUCT_DIRENT_HAS_D_INO
  
! #undef STRUCT_DIRENT_HAS_D_FILENO
  
! #undef STRUCT_WINSIZE_IN_SYS_IOCTL
  
! #undef STRUCT_WINSIZE_IN_TERMIOS
  
! #undef SPEED_T_IN_SYS_TYPES
  
! #undef CAN_REDEFINE_GETENV
  
! #undef MUST_REINSTALL_SIGHANDLERS
  
! #undef JOB_CONTROL_MISSING
  
! #undef HAVE_POSIX_SIGSETJMP
  
! #define DEFAULT_MAIL_DIRECTORY "/usr/spool/mail"
  
  /* Define if you have the bcopy function.  */
  #undef HAVE_BCOPY
  
  /* Define if you have the bzero function.  */
  #undef HAVE_BZERO
--- 324,385 ----
  #undef PGRP_PIPE
  
! /* Define if the setvbuf function takes the buffering type as its second
!    argument and the buffer pointer as the third, as on System V
!    before release 3.  */
! #undef SETVBUF_REVERSED
  
! #undef STAT_MACROS_BROKEN
  
! #undef ULIMIT_MAXFDS
  
! #undef CAN_REDEFINE_GETENV
  
  
! /* Characteristics of properties exported by the kernel. */
  
! /* Define if the kernel can exec files beginning with #! */
! #undef HAVE_HASH_BANG_EXEC
  
! /* Define if you have the /dev/fd devices to map open files into the file system. */
! #undef HAVE_DEV_FD
  
! /* Defined to /dev/fd or /proc/self/fd (linux). */
! #undef DEV_FD_PREFIX
  
! /* Define if you have the /dev/stdin device. */
! #undef HAVE_DEV_STDIN
  
  
! /* Type and behavior of signal handling functions. */
  
! /* Define as the return type of signal handlers (int or void).  */
! #undef RETSIGTYPE
  
! /* Define if return type of signal handlers is void */
! #undef VOID_SIGHANDLER
  
! #undef MUST_REINSTALL_SIGHANDLERS
  
! /* Define if system calls automatically restart after interruption
!    by a signal.  */
! #undef HAVE_RESTARTABLE_SYSCALLS
  
! #undef HAVE_BSD_SIGNALS
  
! #undef HAVE_POSIX_SIGNALS
  
! #undef HAVE_USG_SIGHOLD
  
! #undef UNUSABLE_RT_SIGNALS
  
! 
! /* Presence of system and C library functions. */
  
  /* Define if you have the bcopy function.  */
  #undef HAVE_BCOPY
  
+ /* Define if you have the bindtextdomain function.  */
+ #undef HAVE_BINDTEXTDOMAIN
+ 
  /* Define if you have the bzero function.  */
  #undef HAVE_BZERO
***************
*** 407,410 ****
--- 397,403 ----
  #undef HAVE_DLSYM
  
+ /* Define if you don't have vprintf but do have _doprnt.  */
+ #undef HAVE_DOPRNT
+ 
  /* Define if you have the dup2 function.  */
  #undef HAVE_DUP2
***************
*** 419,422 ****
--- 412,418 ----
  #undef HAVE_GETGROUPS
  
+ /* Define if you have the gethostbyname function.  */
+ #undef HAVE_GETHOSTBYNAME
+ 
  /* Define if you have the gethostname function.  */
  #undef HAVE_GETHOSTNAME
***************
*** 428,434 ****
--- 424,448 ----
  #undef HAVE_GETPEERNAME
  
+ /* Define if you have the getrlimit function.  */
+ #undef HAVE_GETRLIMIT
+ 
+ /* Define if you have the getrusage function.  */
+ #undef HAVE_GETRUSAGE
+ 
+ /* Define if you have the getservbyname function.  */
+ #undef HAVE_GETSERVBYNAME
+ 
+ /* Define if you have the gettext function. */
+ #undef HAVE_GETTEXT
+ 
+ /* Define if you have the gettimeofday function.  */
+ #undef HAVE_GETTIMEOFDAY
+ 
  /* Define if you have the getwd function.  */
  #undef HAVE_GETWD
  
+ /* Define if you have the inet_aton function.  */
+ #undef HAVE_INET_ATON
+ 
  /* Define if you have the killpg function.  */
  #undef HAVE_KILLPG
***************
*** 437,443 ****
--- 451,469 ----
  #undef HAVE_LSTAT
  
+ /* Define if you have the memmove function.  */
+ #undef HAVE_MEMMOVE
+ 
+ /* Define if you have the mkfifo function.  */
+ #undef HAVE_MKFIFO
+ 
+ /* Define if you have the pathconf function. */
+ #undef HAVE_PATHCONF
+ 
  /* Define if you have the putenv function.  */
  #undef HAVE_PUTENV
  
+ /* Define if you have the readlink function. */
+ #undef HAVE_READLINK
+ 
  /* Define if you have the rename function. */
  #undef HAVE_RENAME
***************
*** 461,464 ****
--- 487,493 ----
  #undef HAVE_SETLOCALE
  
+ /* Define if you have the setostype function.  */
+ #undef HAVE_SETOSTYPE
+ 
  /* Define if you have the setvbuf function.  */
  #undef HAVE_SETVBUF
***************
*** 467,470 ****
--- 496,502 ----
  #undef HAVE_SIGINTERRUPT
  
+ /* Define if you have the POSIX.1-style sigsetjmp function.  */
+ #undef HAVE_POSIX_SIGSETJMP
+ 
  /* Define if you have the strcasecmp function.  */
  #undef HAVE_STRCASECMP
***************
*** 473,476 ****
--- 505,511 ----
  #undef HAVE_STRCHR
  
+ /* Define if you have the strcoll function.  */
+ #undef HAVE_STRCOLL
+ 
  /* Define if you have the strerror function.  */
  #undef HAVE_STRERROR
***************
*** 488,518 ****
  #undef HAVE_STRTOUL
  
! /* Define if you have the tcgetattr function.  */
! #undef HAVE_TCGETATTR
  
  /* Define if you have the sysconf function. */
  #undef HAVE_SYSCONF
  
! /* Define if you have the uname function. */
! #undef HAVE_UNAME
  
! /* Define if you have the ulimit function. */
! #undef HAVE_ULIMIT
  
  #undef HAVE_TTYNAME
  
! #undef HAVE_WAITPID
  
! #undef HAVE_TCGETPGRP
  
! #undef HAVE_GETTEXT
  
! #undef HAVE_TEXTDOMAIN
  
! #undef HAVE_BINDTEXTDOMAIN
  
! #undef HAVE_STRCOLL
  
! #undef HAVE_TZSET
  
  /* Define if you have the <dirent.h> header file.  */
--- 523,570 ----
  #undef HAVE_STRTOUL
  
! /* Define if you have the strsignal function or macro. */
! #undef HAVE_STRSIGNAL
  
  /* Define if you have the sysconf function. */
  #undef HAVE_SYSCONF
  
! /* Define if you have the tcgetattr function.  */
! #undef HAVE_TCGETATTR
  
! /* Define if you have the tcgetpgrp function.  */
! #undef HAVE_TCGETPGRP
! 
! /* Define if you have the textdomain function.  */
! #undef HAVE_TEXTDOMAIN
! 
! /* Define if you have the times function.  */
! #undef HAVE_TIMES
  
+ /* Define if you have the ttyname function.  */
  #undef HAVE_TTYNAME
  
! /* Define if you have the tzset function. */
! #undef HAVE_TZSET
  
! /* Define if you have the ulimit function. */
! #undef HAVE_ULIMIT
  
! /* Define if you have the uname function. */
! #undef HAVE_UNAME
  
! /* Define if you have the vprintf function.  */
! #undef HAVE_VPRINTF
  
! /* Define if you have the waitpid function. */
! #undef HAVE_WAITPID
  
! /* Define if you have the wait3 function.  */
! #undef HAVE_WAIT3
  
! 
! /* Presence of certain system include files. */
! 
! /* Define if you have the <arpa/inet.h> header file. */
! #undef HAVE_ARPA_INET_H
  
  /* Define if you have the <dirent.h> header file.  */
***************
*** 522,525 ****
--- 574,580 ----
  #undef HAVE_DLFCN_H
  
+ /* Define if you have the <libintl.h> header file. */
+ #undef HAVE_LIBINTL_H
+ 
  /* Define if you have the <limits.h> header file.  */
  #undef HAVE_LIMITS_H
***************
*** 531,534 ****
--- 586,595 ----
  #undef HAVE_NDIR_H
  
+ /* Define if you have the <netdh.h> header file. */
+ #undef HAVE_NETDB_H
+ 
+ /* Define if you have the <netinet/in.h> header file. */
+ #undef HAVE_NETINET_IN_H
+ 
  /* Define if you have the <stdlib.h> header file.  */
  #undef HAVE_STDLIB_H
***************
*** 543,546 ****
--- 604,610 ----
  #undef HAVE_MEMORY_H
  
+ /* Define if you have the <stddef.h> header file. */
+ #undef HAVE_STDDEF_H
+ 
  /* Define if you have the <sys/dir.h> header file.  */
  #undef HAVE_SYS_DIR_H
***************
*** 573,576 ****
--- 637,651 ----
  #undef HAVE_SYS_STREAM_H
  
+ /* Define if you have <sys/time.h> */
+ #undef HAVE_SYS_TIME_H
+ 
+ #undef TIME_WITH_SYS_TIME
+ 
+ /* Define if you have <sys/times.h> */
+ #undef HAVE_SYS_TIMES_H
+ 
+ /* Define if you have <sys/wait.h> that is POSIX.1 compatible.  */
+ #undef HAVE_SYS_WAIT_H
+ 
  /* Define if you have the <termcap.h> header file.  */
  #undef HAVE_TERMCAP_H
***************
*** 588,605 ****
  #undef HAVE_VARARGS_H
  
! /* Define if you have the <libintl.h> header file. */
! #undef HAVE_LIBINTL_H
! 
! /* Define if you have the <stddef.h> header file. */
! #undef HAVE_STDDEF_H
! 
! /* Define if you have the <netdh.h> header file. */
! #undef HAVE_NETDB_H
! 
! /* Define if you have the <netinet/in.h> header file. */
! #undef HAVE_NETINET_IN_H
! 
! /* Define if you have the <arpa/inet.h> header file. */
! #undef HAVE_ARPA_INET_H
  
  #undef HAVE_LIBDL
--- 663,667 ----
  #undef HAVE_VARARGS_H
  
! /* Presence of certain system libraries. */
  
  #undef HAVE_LIBDL
***************
*** 609,612 ****
--- 671,678 ----
  #undef HAVE_LIBSOCKET
  
+ 
+ /* Define if on MINIX.  */
+ #undef _MINIX
+ 
  /* Are we running SVR5 (UnixWare 7)? */
  #undef SVR5
***************
*** 618,621 ****
--- 684,690 ----
  #undef SVR4
  
+ /* Define if job control is unusable or unsupported. */
+ #undef JOB_CONTROL_MISSING
+ 
  /* Do we need to define _KERNEL to get the RLIMIT_* defines from
     <sys/resource.h>? */
***************
*** 624,627 ****
--- 693,700 ----
  /* Do strcoll(3) and strcmp(3) give different results in the default locale? */
  #undef STRCOLL_BROKEN
+ 
+ #undef DUP2_BROKEN
+ 
+ #undef GETCWD_BROKEN
  
  #include "config-bot.h"
diff -Nrc2 bash-2.04/configure bash-2.05/configure
*** bash-2.04/configure	Tue Feb 22 11:46:17 2000
--- bash-2.05/configure	Tue Jan 23 12:57:28 2001
***************
*** 1,5 ****
  #! /bin/sh
  
! # From configure.in for Bash 2.04, version 2.77, from autoconf version 2.13
  
  
--- 1,7 ----
  #! /bin/sh
  
! # From configure.in for Bash 2.05, version 2.90, from autoconf version 2.13
! 
! 
  
  
***************
*** 722,726 ****
  
  echo $ac_n "checking host system type""... $ac_c" 1>&6
! echo "configure:725: checking host system type" >&5
  
  host_alias=$host
--- 724,728 ----
  
  echo $ac_n "checking host system type""... $ac_c" 1>&6
! echo "configure:727: checking host system type" >&5
  
  host_alias=$host
***************
*** 755,759 ****
  case "${host_cpu}-${host_os}" in
  alpha*-*)	opt_bash_malloc=no ;;	# alpha running osf/1 or linux
! *Ccray*-*)	opt_bash_malloc=no ;;	# Crays
  *-osf1*)	opt_bash_malloc=no ;;	# other osf/1 machines
  sparc-svr4*)	opt_bash_malloc=no ;;	# sparc SVR4, SVR4.2
--- 757,761 ----
  case "${host_cpu}-${host_os}" in
  alpha*-*)	opt_bash_malloc=no ;;	# alpha running osf/1 or linux
! *[Cc]ray*-*)	opt_bash_malloc=no ;;	# Crays
  *-osf1*)	opt_bash_malloc=no ;;	# other osf/1 machines
  sparc-svr4*)	opt_bash_malloc=no ;;	# sparc SVR4, SVR4.2
***************
*** 765,769 ****
  *-aix*)		opt_bash_malloc=no ;;	# AIX machines
  *-nextstep*)	opt_bash_malloc=no ;;	# NeXT machines running NeXTstep
! *-rhapsody*)	opt_bash_malloc=no ;;	# Apple Rhapsody
  *-dgux*)	opt_bash_malloc=no ;;	# DG/UX machines
  *-qnx*)		opt_bash_malloc=no ;;	# QNX 4.2
--- 767,773 ----
  *-aix*)		opt_bash_malloc=no ;;	# AIX machines
  *-nextstep*)	opt_bash_malloc=no ;;	# NeXT machines running NeXTstep
! *-macos*)	opt_bash_malloc=no ;;	# Apple MacOS X
! *-rhapsody*)	opt_bash_malloc=no ;;	# Apple Rhapsody (MacOS X)
! *-darwin*)	opt_bash_malloc=no ;;	# Apple Darwin (MacOS X)
  *-dgux*)	opt_bash_malloc=no ;;	# DG/UX machines
  *-qnx*)		opt_bash_malloc=no ;;	# QNX 4.2
***************
*** 771,775 ****
  *-bsdi2.1|*-bsdi3.?)	opt_bash_malloc=no ; : ${CC:=shlicc2} ;; # for loadable builtins
  *-beos*)	opt_bash_malloc=no ;;	# they say it's suitable
! *-cygwin32*)	opt_bash_malloc=no ;;	# Cygnus's CYGWIN32 environment
  esac
  
--- 775,780 ----
  *-bsdi2.1|*-bsdi3.?)	opt_bash_malloc=no ; : ${CC:=shlicc2} ;; # for loadable builtins
  *-beos*)	opt_bash_malloc=no ;;	# they say it's suitable
! *-cygwin*)	opt_bash_malloc=no ;;	# Cygnus's CYGWIN environment
! *-opennt*|*-interix*)	opt_bash_malloc=no ;;	# Interix, now owned by Microsoft
  esac
  
***************
*** 1180,1184 ****
  
  
! BASHVERS=2.04
  BASHPATCH=0
  
--- 1185,1189 ----
  
  
! BASHVERS=2.05
  BASHPATCH=0
  
***************
*** 1188,1192 ****
  set dummy gcc; ac_word=$2
  echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
! echo "configure:1191: checking for $ac_word" >&5
  if eval "test \"`echo '$''{'ac_cv_prog_CC'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
--- 1193,1197 ----
  set dummy gcc; ac_word=$2
  echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
! echo "configure:1196: checking for $ac_word" >&5
  if eval "test \"`echo '$''{'ac_cv_prog_CC'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
***************
*** 1218,1222 ****
  set dummy cc; ac_word=$2
  echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
! echo "configure:1221: checking for $ac_word" >&5
  if eval "test \"`echo '$''{'ac_cv_prog_CC'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
--- 1223,1227 ----
  set dummy cc; ac_word=$2
  echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
! echo "configure:1226: checking for $ac_word" >&5
  if eval "test \"`echo '$''{'ac_cv_prog_CC'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
***************
*** 1269,1273 ****
  set dummy cl; ac_word=$2
  echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
! echo "configure:1272: checking for $ac_word" >&5
  if eval "test \"`echo '$''{'ac_cv_prog_CC'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
--- 1274,1278 ----
  set dummy cl; ac_word=$2
  echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
! echo "configure:1277: checking for $ac_word" >&5
  if eval "test \"`echo '$''{'ac_cv_prog_CC'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
***************
*** 1301,1305 ****
  
  echo $ac_n "checking whether the C compiler ($CC $CFLAGS $LDFLAGS) works""... $ac_c" 1>&6
! echo "configure:1304: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) works" >&5
  
  ac_ext=c
--- 1306,1310 ----
  
  echo $ac_n "checking whether the C compiler ($CC $CFLAGS $LDFLAGS) works""... $ac_c" 1>&6
! echo "configure:1309: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) works" >&5
  
  ac_ext=c
***************
*** 1312,1321 ****
  cat > conftest.$ac_ext << EOF
  
! #line 1315 "configure"
  #include "confdefs.h"
  
  main(){return(0);}
  EOF
! if { (eval echo configure:1320: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    ac_cv_prog_cc_works=yes
    # If we can't run a trivial program, we are probably using a cross compiler.
--- 1317,1326 ----
  cat > conftest.$ac_ext << EOF
  
! #line 1320 "configure"
  #include "confdefs.h"
  
  main(){return(0);}
  EOF
! if { (eval echo configure:1325: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    ac_cv_prog_cc_works=yes
    # If we can't run a trivial program, we are probably using a cross compiler.
***************
*** 1343,1352 ****
  fi
  echo $ac_n "checking whether the C compiler ($CC $CFLAGS $LDFLAGS) is a cross-compiler""... $ac_c" 1>&6
! echo "configure:1346: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) is a cross-compiler" >&5
  echo "$ac_t""$ac_cv_prog_cc_cross" 1>&6
  cross_compiling=$ac_cv_prog_cc_cross
  
  echo $ac_n "checking whether we are using GNU C""... $ac_c" 1>&6
! echo "configure:1351: checking whether we are using GNU C" >&5
  if eval "test \"`echo '$''{'ac_cv_prog_gcc'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
--- 1348,1357 ----
  fi
  echo $ac_n "checking whether the C compiler ($CC $CFLAGS $LDFLAGS) is a cross-compiler""... $ac_c" 1>&6
! echo "configure:1351: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) is a cross-compiler" >&5
  echo "$ac_t""$ac_cv_prog_cc_cross" 1>&6
  cross_compiling=$ac_cv_prog_cc_cross
  
  echo $ac_n "checking whether we are using GNU C""... $ac_c" 1>&6
! echo "configure:1356: checking whether we are using GNU C" >&5
  if eval "test \"`echo '$''{'ac_cv_prog_gcc'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
***************
*** 1357,1361 ****
  #endif
  EOF
! if { ac_try='${CC-cc} -E conftest.c'; { (eval echo configure:1360: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }; } | egrep yes >/dev/null 2>&1; then
    ac_cv_prog_gcc=yes
  else
--- 1362,1366 ----
  #endif
  EOF
! if { ac_try='${CC-cc} -E conftest.c'; { (eval echo configure:1365: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }; } | egrep yes >/dev/null 2>&1; then
    ac_cv_prog_gcc=yes
  else
***************
*** 1376,1380 ****
  CFLAGS=
  echo $ac_n "checking whether ${CC-cc} accepts -g""... $ac_c" 1>&6
! echo "configure:1379: checking whether ${CC-cc} accepts -g" >&5
  if eval "test \"`echo '$''{'ac_cv_prog_cc_g'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
--- 1381,1385 ----
  CFLAGS=
  echo $ac_n "checking whether ${CC-cc} accepts -g""... $ac_c" 1>&6
! echo "configure:1384: checking whether ${CC-cc} accepts -g" >&5
  if eval "test \"`echo '$''{'ac_cv_prog_cc_g'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
***************
*** 1408,1412 ****
  
  echo $ac_n "checking whether large file support needs explicit enabling""... $ac_c" 1>&6
! echo "configure:1411: checking whether large file support needs explicit enabling" >&5
  ac_getconfs=''
  ac_result=yes
--- 1413,1417 ----
  
  echo $ac_n "checking whether large file support needs explicit enabling""... $ac_c" 1>&6
! echo "configure:1416: checking whether large file support needs explicit enabling" >&5
  ac_getconfs=''
  ac_result=yes
***************
*** 1441,1445 ****
  
  echo $ac_n "checking for POSIXized ISC""... $ac_c" 1>&6
! echo "configure:1444: checking for POSIXized ISC" >&5
  if test -d /etc/conf/kconfig.d &&
    grep _POSIX_VERSION /usr/include/sys/unistd.h >/dev/null 2>&1
--- 1446,1450 ----
  
  echo $ac_n "checking for POSIXized ISC""... $ac_c" 1>&6
! echo "configure:1449: checking for POSIXized ISC" >&5
  if test -d /etc/conf/kconfig.d &&
    grep _POSIX_VERSION /usr/include/sys/unistd.h >/dev/null 2>&1
***************
*** 1462,1466 ****
  
  echo $ac_n "checking how to run the C preprocessor""... $ac_c" 1>&6
! echo "configure:1465: checking how to run the C preprocessor" >&5
  # On Suns, sometimes $CPP names a directory.
  if test -n "$CPP" && test -d "$CPP"; then
--- 1467,1471 ----
  
  echo $ac_n "checking how to run the C preprocessor""... $ac_c" 1>&6
! echo "configure:1470: checking how to run the C preprocessor" >&5
  # On Suns, sometimes $CPP names a directory.
  if test -n "$CPP" && test -d "$CPP"; then
***************
*** 1477,1481 ****
    # not just through cpp.
    cat > conftest.$ac_ext <<EOF
! #line 1480 "configure"
  #include "confdefs.h"
  #include <assert.h>
--- 1482,1486 ----
    # not just through cpp.
    cat > conftest.$ac_ext <<EOF
! #line 1485 "configure"
  #include "confdefs.h"
  #include <assert.h>
***************
*** 1483,1487 ****
  EOF
  ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
! { (eval echo configure:1486: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
  ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
  if test -z "$ac_err"; then
--- 1488,1492 ----
  EOF
  ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
! { (eval echo configure:1491: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
  ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
  if test -z "$ac_err"; then
***************
*** 1494,1498 ****
    CPP="${CC-cc} -E -traditional-cpp"
    cat > conftest.$ac_ext <<EOF
! #line 1497 "configure"
  #include "confdefs.h"
  #include <assert.h>
--- 1499,1503 ----
    CPP="${CC-cc} -E -traditional-cpp"
    cat > conftest.$ac_ext <<EOF
! #line 1502 "configure"
  #include "confdefs.h"
  #include <assert.h>
***************
*** 1500,1504 ****
  EOF
  ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
! { (eval echo configure:1503: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
  ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
  if test -z "$ac_err"; then
--- 1505,1509 ----
  EOF
  ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
! { (eval echo configure:1508: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
  ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
  if test -z "$ac_err"; then
***************
*** 1511,1515 ****
    CPP="${CC-cc} -nologo -E"
    cat > conftest.$ac_ext <<EOF
! #line 1514 "configure"
  #include "confdefs.h"
  #include <assert.h>
--- 1516,1520 ----
    CPP="${CC-cc} -nologo -E"
    cat > conftest.$ac_ext <<EOF
! #line 1519 "configure"
  #include "confdefs.h"
  #include <assert.h>
***************
*** 1517,1521 ****
  EOF
  ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
! { (eval echo configure:1520: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
  ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
  if test -z "$ac_err"; then
--- 1522,1526 ----
  EOF
  ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
! { (eval echo configure:1525: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
  ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
  if test -z "$ac_err"; then
***************
*** 1543,1557 ****
  ac_safe=`echo "minix/config.h" | sed 'y%./+-%__p_%'`
  echo $ac_n "checking for minix/config.h""... $ac_c" 1>&6
! echo "configure:1546: checking for minix/config.h" >&5
  if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 1551 "configure"
  #include "confdefs.h"
  #include <minix/config.h>
  EOF
  ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
! { (eval echo configure:1556: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
  ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
  if test -z "$ac_err"; then
--- 1548,1562 ----
  ac_safe=`echo "minix/config.h" | sed 'y%./+-%__p_%'`
  echo $ac_n "checking for minix/config.h""... $ac_c" 1>&6
! echo "configure:1551: checking for minix/config.h" >&5
  if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 1556 "configure"
  #include "confdefs.h"
  #include <minix/config.h>
  EOF
  ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
! { (eval echo configure:1561: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
  ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
  if test -z "$ac_err"; then
***************
*** 1592,1601 ****
  
  echo $ac_n "checking for Cygwin environment""... $ac_c" 1>&6
! echo "configure:1595: checking for Cygwin environment" >&5
  if eval "test \"`echo '$''{'ac_cv_cygwin'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 1600 "configure"
  #include "confdefs.h"
  
--- 1597,1606 ----
  
  echo $ac_n "checking for Cygwin environment""... $ac_c" 1>&6
! echo "configure:1600: checking for Cygwin environment" >&5
  if eval "test \"`echo '$''{'ac_cv_cygwin'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 1605 "configure"
  #include "confdefs.h"
  
***************
*** 1608,1612 ****
  ; return 0; }
  EOF
! if { (eval echo configure:1611: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
    rm -rf conftest*
    ac_cv_cygwin=yes
--- 1613,1617 ----
  ; return 0; }
  EOF
! if { (eval echo configure:1616: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
    rm -rf conftest*
    ac_cv_cygwin=yes
***************
*** 1625,1634 ****
  test "$ac_cv_cygwin" = yes && CYGWIN=yes
  echo $ac_n "checking for mingw32 environment""... $ac_c" 1>&6
! echo "configure:1628: checking for mingw32 environment" >&5
  if eval "test \"`echo '$''{'ac_cv_mingw32'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 1633 "configure"
  #include "confdefs.h"
  
--- 1630,1639 ----
  test "$ac_cv_cygwin" = yes && CYGWIN=yes
  echo $ac_n "checking for mingw32 environment""... $ac_c" 1>&6
! echo "configure:1633: checking for mingw32 environment" >&5
  if eval "test \"`echo '$''{'ac_cv_mingw32'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 1638 "configure"
  #include "confdefs.h"
  
***************
*** 1637,1641 ****
  ; return 0; }
  EOF
! if { (eval echo configure:1640: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
    rm -rf conftest*
    ac_cv_mingw32=yes
--- 1642,1646 ----
  ; return 0; }
  EOF
! if { (eval echo configure:1645: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
    rm -rf conftest*
    ac_cv_mingw32=yes
***************
*** 1656,1660 ****
  
  echo $ac_n "checking for executable suffix""... $ac_c" 1>&6
! echo "configure:1659: checking for executable suffix" >&5
  if eval "test \"`echo '$''{'ac_cv_exeext'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
--- 1661,1665 ----
  
  echo $ac_n "checking for executable suffix""... $ac_c" 1>&6
! echo "configure:1664: checking for executable suffix" >&5
  if eval "test \"`echo '$''{'ac_cv_exeext'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
***************
*** 1666,1670 ****
    echo 'int main () { return 0; }' > conftest.$ac_ext
    ac_cv_exeext=
!   if { (eval echo configure:1669: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; }; then
      for file in conftest.*; do
        case $file in
--- 1671,1675 ----
    echo 'int main () { return 0; }' > conftest.$ac_ext
    ac_cv_exeext=
!   if { (eval echo configure:1674: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; }; then
      for file in conftest.*; do
        case $file in
***************
*** 1694,1698 ****
  if test "x$cross_compiling" = "xyes"; then
      case "${host}" in
!     *-cygwin32*)
  	cross_cache=${srcdir}/cross-build/cygwin32.cache
  	SIGNAMES_H='$(srcdir)/cross-build/win32sig.h'
--- 1699,1703 ----
  if test "x$cross_compiling" = "xyes"; then
      case "${host}" in
!     *-cygwin*)
  	cross_cache=${srcdir}/cross-build/cygwin32.cache
  	SIGNAMES_H='$(srcdir)/cross-build/win32sig.h'
***************
*** 1739,1742 ****
--- 1744,1748 ----
  	if test -n "$GCC" || test "$ac_cv_prog_gcc" = "yes"; then
  		STATIC_LD="-static"
+ 		LDFLAGS="$LDFLAGS -static"	# XXX experimental
  	fi
  fi
***************
*** 1749,1753 ****
  if test $ac_cv_prog_gcc = yes; then
      echo $ac_n "checking whether ${CC-cc} needs -traditional""... $ac_c" 1>&6
! echo "configure:1752: checking whether ${CC-cc} needs -traditional" >&5
  if eval "test \"`echo '$''{'ac_cv_prog_gcc_traditional'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
--- 1755,1759 ----
  if test $ac_cv_prog_gcc = yes; then
      echo $ac_n "checking whether ${CC-cc} needs -traditional""... $ac_c" 1>&6
! echo "configure:1758: checking whether ${CC-cc} needs -traditional" >&5
  if eval "test \"`echo '$''{'ac_cv_prog_gcc_traditional'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
***************
*** 1755,1759 ****
      ac_pattern="Autoconf.*'x'"
    cat > conftest.$ac_ext <<EOF
! #line 1758 "configure"
  #include "confdefs.h"
  #include <sgtty.h>
--- 1761,1765 ----
      ac_pattern="Autoconf.*'x'"
    cat > conftest.$ac_ext <<EOF
! #line 1764 "configure"
  #include "confdefs.h"
  #include <sgtty.h>
***************
*** 1773,1777 ****
    if test $ac_cv_prog_gcc_traditional = no; then
      cat > conftest.$ac_ext <<EOF
! #line 1776 "configure"
  #include "confdefs.h"
  #include <termio.h>
--- 1779,1783 ----
    if test $ac_cv_prog_gcc_traditional = no; then
      cat > conftest.$ac_ext <<EOF
! #line 1782 "configure"
  #include "confdefs.h"
  #include <termio.h>
***************
*** 1806,1810 ****
  else
  echo $ac_n "checking which library has the termcap functions""... $ac_c" 1>&6
! echo "configure:1809: checking which library has the termcap functions" >&5
  _bash_needmsg=
  fi
--- 1812,1816 ----
  else
  echo $ac_n "checking which library has the termcap functions""... $ac_c" 1>&6
! echo "configure:1815: checking which library has the termcap functions" >&5
  _bash_needmsg=
  fi
***************
*** 1813,1817 ****
  else
    echo $ac_n "checking for tgetent in -ltermcap""... $ac_c" 1>&6
! echo "configure:1816: checking for tgetent in -ltermcap" >&5
  ac_lib_var=`echo termcap'_'tgetent | sed 'y%./+-%__p_%'`
  if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
--- 1819,1823 ----
  else
    echo $ac_n "checking for tgetent in -ltermcap""... $ac_c" 1>&6
! echo "configure:1822: checking for tgetent in -ltermcap" >&5
  ac_lib_var=`echo termcap'_'tgetent | sed 'y%./+-%__p_%'`
  if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
***************
*** 1821,1825 ****
  LIBS="-ltermcap  $LIBS"
  cat > conftest.$ac_ext <<EOF
! #line 1824 "configure"
  #include "confdefs.h"
  /* Override any gcc2 internal prototype to avoid an error.  */
--- 1827,1831 ----
  LIBS="-ltermcap  $LIBS"
  cat > conftest.$ac_ext <<EOF
! #line 1830 "configure"
  #include "confdefs.h"
  /* Override any gcc2 internal prototype to avoid an error.  */
***************
*** 1832,1836 ****
  ; return 0; }
  EOF
! if { (eval echo configure:1835: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    eval "ac_cv_lib_$ac_lib_var=yes"
--- 1838,1842 ----
  ; return 0; }
  EOF
! if { (eval echo configure:1841: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    eval "ac_cv_lib_$ac_lib_var=yes"
***************
*** 1851,1855 ****
    echo "$ac_t""no" 1>&6
  echo $ac_n "checking for tgetent in -lcurses""... $ac_c" 1>&6
! echo "configure:1854: checking for tgetent in -lcurses" >&5
  ac_lib_var=`echo curses'_'tgetent | sed 'y%./+-%__p_%'`
  if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
--- 1857,1861 ----
    echo "$ac_t""no" 1>&6
  echo $ac_n "checking for tgetent in -lcurses""... $ac_c" 1>&6
! echo "configure:1860: checking for tgetent in -lcurses" >&5
  ac_lib_var=`echo curses'_'tgetent | sed 'y%./+-%__p_%'`
  if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
***************
*** 1859,1863 ****
  LIBS="-lcurses  $LIBS"
  cat > conftest.$ac_ext <<EOF
! #line 1862 "configure"
  #include "confdefs.h"
  /* Override any gcc2 internal prototype to avoid an error.  */
--- 1865,1869 ----
  LIBS="-lcurses  $LIBS"
  cat > conftest.$ac_ext <<EOF
! #line 1868 "configure"
  #include "confdefs.h"
  /* Override any gcc2 internal prototype to avoid an error.  */
***************
*** 1870,1874 ****
  ; return 0; }
  EOF
! if { (eval echo configure:1873: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    eval "ac_cv_lib_$ac_lib_var=yes"
--- 1876,1880 ----
  ; return 0; }
  EOF
! if { (eval echo configure:1879: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    eval "ac_cv_lib_$ac_lib_var=yes"
***************
*** 1889,1893 ****
    echo "$ac_t""no" 1>&6
  echo $ac_n "checking for tgetent in -lncurses""... $ac_c" 1>&6
! echo "configure:1892: checking for tgetent in -lncurses" >&5
  ac_lib_var=`echo ncurses'_'tgetent | sed 'y%./+-%__p_%'`
  if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
--- 1895,1899 ----
    echo "$ac_t""no" 1>&6
  echo $ac_n "checking for tgetent in -lncurses""... $ac_c" 1>&6
! echo "configure:1898: checking for tgetent in -lncurses" >&5
  ac_lib_var=`echo ncurses'_'tgetent | sed 'y%./+-%__p_%'`
  if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
***************
*** 1897,1901 ****
  LIBS="-lncurses  $LIBS"
  cat > conftest.$ac_ext <<EOF
! #line 1900 "configure"
  #include "confdefs.h"
  /* Override any gcc2 internal prototype to avoid an error.  */
--- 1903,1907 ----
  LIBS="-lncurses  $LIBS"
  cat > conftest.$ac_ext <<EOF
! #line 1906 "configure"
  #include "confdefs.h"
  /* Override any gcc2 internal prototype to avoid an error.  */
***************
*** 1908,1912 ****
  ; return 0; }
  EOF
! if { (eval echo configure:1911: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    eval "ac_cv_lib_$ac_lib_var=yes"
--- 1914,1918 ----
  ; return 0; }
  EOF
! if { (eval echo configure:1917: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    eval "ac_cv_lib_$ac_lib_var=yes"
***************
*** 1937,1941 ****
  if test "X$_bash_needmsg" = "Xyes"; then
  echo $ac_n "checking which library has the termcap functions""... $ac_c" 1>&6
! echo "configure:1940: checking which library has the termcap functions" >&5
  fi
  echo "$ac_t""using $bash_cv_termcap_lib" 1>&6
--- 1943,1947 ----
  if test "X$_bash_needmsg" = "Xyes"; then
  echo $ac_n "checking which library has the termcap functions""... $ac_c" 1>&6
! echo "configure:1946: checking which library has the termcap functions" >&5
  fi
  echo "$ac_t""using $bash_cv_termcap_lib" 1>&6
***************
*** 1961,1970 ****
  
  	echo $ac_n "checking version of installed readline library""... $ac_c" 1>&6
! echo "configure:1964: checking version of installed readline library" >&5
! 	_rl_version=`exec_prefix=${_rl_exec_prefix} ${CONFIG_SHELL-/bin/sh} ${srcdir}/support/rlvers.sh -C "${CC}" -L ${libdir} -T ${TERMCAP_LIB}`
  	echo "$ac_t""$_rl_version" 1>&6
  
  	case "$_rl_version" in
! 	4.[1-9]*|5*|6*|7*|8*|9*)	;;
  	*)	opt_with_installed_readline=no 
  		echo "configure: warning: installed readline library is too old to be linked with bash" 1>&2
--- 1967,1976 ----
  
  	echo $ac_n "checking version of installed readline library""... $ac_c" 1>&6
! echo "configure:1970: checking version of installed readline library" >&5
! 	_rl_version=`exec_prefix=${_rl_exec_prefix} ${CONFIG_SHELL-/bin/sh} ${srcdir}/support/rlvers.sh -C "${CC}" -L ${libdir} -I ${includedir} -T ${TERMCAP_LIB}`
  	echo "$ac_t""$_rl_version" 1>&6
  
  	case "$_rl_version" in
! 	4.[2-9]*|5*|6*|7*|8*|9*)	;;
  	*)	opt_with_installed_readline=no 
  		echo "configure: warning: installed readline library is too old to be linked with bash" 1>&2
***************
*** 2040,2044 ****
  # ./install, which can be erroneously created by make from ./install.sh.
  echo $ac_n "checking for a BSD compatible install""... $ac_c" 1>&6
! echo "configure:2043: checking for a BSD compatible install" >&5
  if test -z "$INSTALL"; then
  if eval "test \"`echo '$''{'ac_cv_path_install'+set}'`\" = set"; then
--- 2046,2050 ----
  # ./install, which can be erroneously created by make from ./install.sh.
  echo $ac_n "checking for a BSD compatible install""... $ac_c" 1>&6
! echo "configure:2049: checking for a BSD compatible install" >&5
  if test -z "$INSTALL"; then
  if eval "test \"`echo '$''{'ac_cv_path_install'+set}'`\" = set"; then
***************
*** 2095,2099 ****
  set dummy ar; ac_word=$2
  echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
! echo "configure:2098: checking for $ac_word" >&5
  if eval "test \"`echo '$''{'ac_cv_prog_AR'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
--- 2101,2105 ----
  set dummy ar; ac_word=$2
  echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
! echo "configure:2104: checking for $ac_word" >&5
  if eval "test \"`echo '$''{'ac_cv_prog_AR'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
***************
*** 2125,2129 ****
  set dummy ranlib; ac_word=$2
  echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
! echo "configure:2128: checking for $ac_word" >&5
  if eval "test \"`echo '$''{'ac_cv_prog_RANLIB'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
--- 2131,2135 ----
  set dummy ranlib; ac_word=$2
  echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
! echo "configure:2134: checking for $ac_word" >&5
  if eval "test \"`echo '$''{'ac_cv_prog_RANLIB'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
***************
*** 2157,2161 ****
  set dummy $ac_prog; ac_word=$2
  echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
! echo "configure:2160: checking for $ac_word" >&5
  if eval "test \"`echo '$''{'ac_cv_prog_YACC'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
--- 2163,2167 ----
  set dummy $ac_prog; ac_word=$2
  echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
! echo "configure:2166: checking for $ac_word" >&5
  if eval "test \"`echo '$''{'ac_cv_prog_YACC'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
***************
*** 2188,2192 ****
  
  echo $ac_n "checking whether ${MAKE-make} sets \${MAKE}""... $ac_c" 1>&6
! echo "configure:2191: checking whether ${MAKE-make} sets \${MAKE}" >&5
  set dummy ${MAKE-make}; ac_make=`echo "$2" | sed 'y%./+-%__p_%'`
  if eval "test \"`echo '$''{'ac_cv_prog_make_${ac_make}_set'+set}'`\" = set"; then
--- 2194,2198 ----
  
  echo $ac_n "checking whether ${MAKE-make} sets \${MAKE}""... $ac_c" 1>&6
! echo "configure:2197: checking whether ${MAKE-make} sets \${MAKE}" >&5
  set dummy ${MAKE-make}; ac_make=`echo "$2" | sed 'y%./+-%__p_%'`
  if eval "test \"`echo '$''{'ac_cv_prog_make_${ac_make}_set'+set}'`\" = set"; then
***************
*** 2224,2233 ****
  # for constant arguments.  Useless!
  echo $ac_n "checking for working alloca.h""... $ac_c" 1>&6
! echo "configure:2227: checking for working alloca.h" >&5
  if eval "test \"`echo '$''{'ac_cv_header_alloca_h'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 2232 "configure"
  #include "confdefs.h"
  #include <alloca.h>
--- 2230,2239 ----
  # for constant arguments.  Useless!
  echo $ac_n "checking for working alloca.h""... $ac_c" 1>&6
! echo "configure:2233: checking for working alloca.h" >&5
  if eval "test \"`echo '$''{'ac_cv_header_alloca_h'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 2238 "configure"
  #include "confdefs.h"
  #include <alloca.h>
***************
*** 2236,2240 ****
  ; return 0; }
  EOF
! if { (eval echo configure:2239: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    ac_cv_header_alloca_h=yes
--- 2242,2246 ----
  ; return 0; }
  EOF
! if { (eval echo configure:2245: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    ac_cv_header_alloca_h=yes
***************
*** 2257,2266 ****
  
  echo $ac_n "checking for alloca""... $ac_c" 1>&6
! echo "configure:2260: checking for alloca" >&5
  if eval "test \"`echo '$''{'ac_cv_func_alloca_works'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 2265 "configure"
  #include "confdefs.h"
  
--- 2263,2272 ----
  
  echo $ac_n "checking for alloca""... $ac_c" 1>&6
! echo "configure:2266: checking for alloca" >&5
  if eval "test \"`echo '$''{'ac_cv_func_alloca_works'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 2271 "configure"
  #include "confdefs.h"
  
***************
*** 2290,2294 ****
  ; return 0; }
  EOF
! if { (eval echo configure:2293: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    ac_cv_func_alloca_works=yes
--- 2296,2300 ----
  ; return 0; }
  EOF
! if { (eval echo configure:2299: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    ac_cv_func_alloca_works=yes
***************
*** 2322,2331 ****
  
  echo $ac_n "checking whether alloca needs Cray hooks""... $ac_c" 1>&6
! echo "configure:2325: checking whether alloca needs Cray hooks" >&5
  if eval "test \"`echo '$''{'ac_cv_os_cray'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 2330 "configure"
  #include "confdefs.h"
  #if defined(CRAY) && ! defined(CRAY2)
--- 2328,2337 ----
  
  echo $ac_n "checking whether alloca needs Cray hooks""... $ac_c" 1>&6
! echo "configure:2331: checking whether alloca needs Cray hooks" >&5
  if eval "test \"`echo '$''{'ac_cv_os_cray'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 2336 "configure"
  #include "confdefs.h"
  #if defined(CRAY) && ! defined(CRAY2)
***************
*** 2352,2361 ****
  for ac_func in _getb67 GETB67 getb67; do
    echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
! echo "configure:2355: checking for $ac_func" >&5
  if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 2360 "configure"
  #include "confdefs.h"
  /* System header to define __stub macros and hopefully few prototypes,
--- 2358,2367 ----
  for ac_func in _getb67 GETB67 getb67; do
    echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
! echo "configure:2361: checking for $ac_func" >&5
  if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 2366 "configure"
  #include "confdefs.h"
  /* System header to define __stub macros and hopefully few prototypes,
***************
*** 2380,2384 ****
  ; return 0; }
  EOF
! if { (eval echo configure:2383: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    eval "ac_cv_func_$ac_func=yes"
--- 2386,2390 ----
  ; return 0; }
  EOF
! if { (eval echo configure:2389: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    eval "ac_cv_func_$ac_func=yes"
***************
*** 2407,2411 ****
  
  echo $ac_n "checking stack direction for C alloca""... $ac_c" 1>&6
! echo "configure:2410: checking stack direction for C alloca" >&5
  if eval "test \"`echo '$''{'ac_cv_c_stack_direction'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
--- 2413,2417 ----
  
  echo $ac_n "checking stack direction for C alloca""... $ac_c" 1>&6
! echo "configure:2416: checking stack direction for C alloca" >&5
  if eval "test \"`echo '$''{'ac_cv_c_stack_direction'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
***************
*** 2415,2419 ****
  else
    cat > conftest.$ac_ext <<EOF
! #line 2418 "configure"
  #include "confdefs.h"
  find_stack_direction ()
--- 2421,2425 ----
  else
    cat > conftest.$ac_ext <<EOF
! #line 2424 "configure"
  #include "confdefs.h"
  find_stack_direction ()
***************
*** 2434,2438 ****
  }
  EOF
! if { (eval echo configure:2437: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
  then
    ac_cv_c_stack_direction=1
--- 2440,2444 ----
  }
  EOF
! if { (eval echo configure:2443: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
  then
    ac_cv_c_stack_direction=1
***************
*** 2456,2460 ****
  
  echo $ac_n "checking whether getpgrp takes no argument""... $ac_c" 1>&6
! echo "configure:2459: checking whether getpgrp takes no argument" >&5
  if eval "test \"`echo '$''{'ac_cv_func_getpgrp_void'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
--- 2462,2466 ----
  
  echo $ac_n "checking whether getpgrp takes no argument""... $ac_c" 1>&6
! echo "configure:2465: checking whether getpgrp takes no argument" >&5
  if eval "test \"`echo '$''{'ac_cv_func_getpgrp_void'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
***************
*** 2464,2468 ****
  else
    cat > conftest.$ac_ext <<EOF
! #line 2467 "configure"
  #include "confdefs.h"
  
--- 2470,2474 ----
  else
    cat > conftest.$ac_ext <<EOF
! #line 2473 "configure"
  #include "confdefs.h"
  
***************
*** 2519,2523 ****
  
  EOF
! if { (eval echo configure:2522: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
  then
    ac_cv_func_getpgrp_void=yes
--- 2525,2529 ----
  
  EOF
! if { (eval echo configure:2528: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
  then
    ac_cv_func_getpgrp_void=yes
***************
*** 2543,2547 ****
  
  echo $ac_n "checking whether setvbuf arguments are reversed""... $ac_c" 1>&6
! echo "configure:2546: checking whether setvbuf arguments are reversed" >&5
  if eval "test \"`echo '$''{'ac_cv_func_setvbuf_reversed'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
--- 2549,2553 ----
  
  echo $ac_n "checking whether setvbuf arguments are reversed""... $ac_c" 1>&6
! echo "configure:2552: checking whether setvbuf arguments are reversed" >&5
  if eval "test \"`echo '$''{'ac_cv_func_setvbuf_reversed'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
***************
*** 2551,2555 ****
  else
    cat > conftest.$ac_ext <<EOF
! #line 2554 "configure"
  #include "confdefs.h"
  #include <stdio.h>
--- 2557,2561 ----
  else
    cat > conftest.$ac_ext <<EOF
! #line 2560 "configure"
  #include "confdefs.h"
  #include <stdio.h>
***************
*** 2565,2569 ****
  }
  EOF
! if { (eval echo configure:2568: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
  then
    ac_cv_func_setvbuf_reversed=yes
--- 2571,2575 ----
  }
  EOF
! if { (eval echo configure:2574: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
  then
    ac_cv_func_setvbuf_reversed=yes
***************
*** 2589,2598 ****
  
  echo $ac_n "checking for vprintf""... $ac_c" 1>&6
! echo "configure:2592: checking for vprintf" >&5
  if eval "test \"`echo '$''{'ac_cv_func_vprintf'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 2597 "configure"
  #include "confdefs.h"
  /* System header to define __stub macros and hopefully few prototypes,
--- 2595,2604 ----
  
  echo $ac_n "checking for vprintf""... $ac_c" 1>&6
! echo "configure:2598: checking for vprintf" >&5
  if eval "test \"`echo '$''{'ac_cv_func_vprintf'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 2603 "configure"
  #include "confdefs.h"
  /* System header to define __stub macros and hopefully few prototypes,
***************
*** 2617,2621 ****
  ; return 0; }
  EOF
! if { (eval echo configure:2620: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    eval "ac_cv_func_vprintf=yes"
--- 2623,2627 ----
  ; return 0; }
  EOF
! if { (eval echo configure:2626: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    eval "ac_cv_func_vprintf=yes"
***************
*** 2641,2650 ****
  if test "$ac_cv_func_vprintf" != yes; then
  echo $ac_n "checking for _doprnt""... $ac_c" 1>&6
! echo "configure:2644: checking for _doprnt" >&5
  if eval "test \"`echo '$''{'ac_cv_func__doprnt'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 2649 "configure"
  #include "confdefs.h"
  /* System header to define __stub macros and hopefully few prototypes,
--- 2647,2656 ----
  if test "$ac_cv_func_vprintf" != yes; then
  echo $ac_n "checking for _doprnt""... $ac_c" 1>&6
! echo "configure:2650: checking for _doprnt" >&5
  if eval "test \"`echo '$''{'ac_cv_func__doprnt'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 2655 "configure"
  #include "confdefs.h"
  /* System header to define __stub macros and hopefully few prototypes,
***************
*** 2669,2673 ****
  ; return 0; }
  EOF
! if { (eval echo configure:2672: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    eval "ac_cv_func__doprnt=yes"
--- 2675,2679 ----
  ; return 0; }
  EOF
! if { (eval echo configure:2678: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    eval "ac_cv_func__doprnt=yes"
***************
*** 2694,2698 ****
  
  echo $ac_n "checking for wait3 that fills in rusage""... $ac_c" 1>&6
! echo "configure:2697: checking for wait3 that fills in rusage" >&5
  if eval "test \"`echo '$''{'ac_cv_func_wait3_rusage'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
--- 2700,2704 ----
  
  echo $ac_n "checking for wait3 that fills in rusage""... $ac_c" 1>&6
! echo "configure:2703: checking for wait3 that fills in rusage" >&5
  if eval "test \"`echo '$''{'ac_cv_func_wait3_rusage'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
***************
*** 2702,2706 ****
  else
    cat > conftest.$ac_ext <<EOF
! #line 2705 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
--- 2708,2712 ----
  else
    cat > conftest.$ac_ext <<EOF
! #line 2711 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
***************
*** 2733,2737 ****
  }
  EOF
! if { (eval echo configure:2736: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
  then
    ac_cv_func_wait3_rusage=yes
--- 2739,2743 ----
  }
  EOF
! if { (eval echo configure:2742: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
  then
    ac_cv_func_wait3_rusage=yes
***************
*** 2756,2760 ****
  
  echo $ac_n "checking for working strcoll""... $ac_c" 1>&6
! echo "configure:2759: checking for working strcoll" >&5
  if eval "test \"`echo '$''{'ac_cv_func_strcoll_works'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
--- 2762,2766 ----
  
  echo $ac_n "checking for working strcoll""... $ac_c" 1>&6
! echo "configure:2765: checking for working strcoll" >&5
  if eval "test \"`echo '$''{'ac_cv_func_strcoll_works'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
***************
*** 2764,2768 ****
  else
    cat > conftest.$ac_ext <<EOF
! #line 2767 "configure"
  #include "confdefs.h"
  #include <string.h>
--- 2770,2774 ----
  else
    cat > conftest.$ac_ext <<EOF
! #line 2773 "configure"
  #include "confdefs.h"
  #include <string.h>
***************
*** 2774,2778 ****
  }
  EOF
! if { (eval echo configure:2777: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
  then
    ac_cv_func_strcoll_works=yes
--- 2780,2784 ----
  }
  EOF
! if { (eval echo configure:2783: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
  then
    ac_cv_func_strcoll_works=yes
***************
*** 2799,2805 ****
  if test "$ac_cv_func_vprintf" = no; then
      echo $ac_n "checking for declaration of vprintf in stdio.h""... $ac_c" 1>&6
! echo "configure:2802: checking for declaration of vprintf in stdio.h" >&5
      cat > conftest.$ac_ext <<EOF
! #line 2804 "configure"
  #include "confdefs.h"
  #include <stdio.h>
--- 2805,2811 ----
  if test "$ac_cv_func_vprintf" = no; then
      echo $ac_n "checking for declaration of vprintf in stdio.h""... $ac_c" 1>&6
! echo "configure:2808: checking for declaration of vprintf in stdio.h" >&5
      cat > conftest.$ac_ext <<EOF
! #line 2810 "configure"
  #include "confdefs.h"
  #include <stdio.h>
***************
*** 2822,2831 ****
  
  echo $ac_n "checking return type of signal handlers""... $ac_c" 1>&6
! echo "configure:2825: checking return type of signal handlers" >&5
  if eval "test \"`echo '$''{'ac_cv_type_signal'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 2830 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
--- 2828,2837 ----
  
  echo $ac_n "checking return type of signal handlers""... $ac_c" 1>&6
! echo "configure:2831: checking return type of signal handlers" >&5
  if eval "test \"`echo '$''{'ac_cv_type_signal'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 2836 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
***************
*** 2844,2848 ****
  ; return 0; }
  EOF
! if { (eval echo configure:2847: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
    rm -rf conftest*
    ac_cv_type_signal=void
--- 2850,2854 ----
  ; return 0; }
  EOF
! if { (eval echo configure:2853: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
    rm -rf conftest*
    ac_cv_type_signal=void
***************
*** 2864,2873 ****
  
  echo $ac_n "checking for __setostype""... $ac_c" 1>&6
! echo "configure:2867: checking for __setostype" >&5
  if eval "test \"`echo '$''{'ac_cv_func___setostype'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 2872 "configure"
  #include "confdefs.h"
  /* System header to define __stub macros and hopefully few prototypes,
--- 2870,2879 ----
  
  echo $ac_n "checking for __setostype""... $ac_c" 1>&6
! echo "configure:2873: checking for __setostype" >&5
  if eval "test \"`echo '$''{'ac_cv_func___setostype'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 2878 "configure"
  #include "confdefs.h"
  /* System header to define __stub macros and hopefully few prototypes,
***************
*** 2892,2896 ****
  ; return 0; }
  EOF
! if { (eval echo configure:2895: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    eval "ac_cv_func___setostype=yes"
--- 2898,2902 ----
  ; return 0; }
  EOF
! if { (eval echo configure:2901: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    eval "ac_cv_func___setostype=yes"
***************
*** 2915,2924 ****
  
  echo $ac_n "checking for wait3""... $ac_c" 1>&6
! echo "configure:2918: checking for wait3" >&5
  if eval "test \"`echo '$''{'ac_cv_func_wait3'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 2923 "configure"
  #include "confdefs.h"
  /* System header to define __stub macros and hopefully few prototypes,
--- 2921,2930 ----
  
  echo $ac_n "checking for wait3""... $ac_c" 1>&6
! echo "configure:2924: checking for wait3" >&5
  if eval "test \"`echo '$''{'ac_cv_func_wait3'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 2929 "configure"
  #include "confdefs.h"
  /* System header to define __stub macros and hopefully few prototypes,
***************
*** 2943,2947 ****
  ; return 0; }
  EOF
! if { (eval echo configure:2946: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    eval "ac_cv_func_wait3=yes"
--- 2949,2953 ----
  ; return 0; }
  EOF
! if { (eval echo configure:2952: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    eval "ac_cv_func_wait3=yes"
***************
*** 2967,2976 ****
  
  echo $ac_n "checking for mkfifo""... $ac_c" 1>&6
! echo "configure:2970: checking for mkfifo" >&5
  if eval "test \"`echo '$''{'ac_cv_func_mkfifo'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 2975 "configure"
  #include "confdefs.h"
  /* System header to define __stub macros and hopefully few prototypes,
--- 2973,2982 ----
  
  echo $ac_n "checking for mkfifo""... $ac_c" 1>&6
! echo "configure:2976: checking for mkfifo" >&5
  if eval "test \"`echo '$''{'ac_cv_func_mkfifo'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 2981 "configure"
  #include "confdefs.h"
  /* System header to define __stub macros and hopefully few prototypes,
***************
*** 2995,2999 ****
  ; return 0; }
  EOF
! if { (eval echo configure:2998: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    eval "ac_cv_func_mkfifo=yes"
--- 3001,3005 ----
  ; return 0; }
  EOF
! if { (eval echo configure:3004: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    eval "ac_cv_func_mkfifo=yes"
***************
*** 3024,3036 ****
  for ac_func in dup2 select getdtablesize getgroups gethostname \
  		setdtablesize getpagesize killpg lstat getpeername sbrk \
! 		getrlimit getrusage gettimeofday waitpid tcgetpgrp rename
  do
  echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
! echo "configure:3030: checking for $ac_func" >&5
  if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 3035 "configure"
  #include "confdefs.h"
  /* System header to define __stub macros and hopefully few prototypes,
--- 3030,3043 ----
  for ac_func in dup2 select getdtablesize getgroups gethostname \
  		setdtablesize getpagesize killpg lstat getpeername sbrk \
! 		getrlimit getrusage gettimeofday waitpid tcgetpgrp \
! 		readlink rename
  do
  echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
! echo "configure:3037: checking for $ac_func" >&5
  if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 3042 "configure"
  #include "confdefs.h"
  /* System header to define __stub macros and hopefully few prototypes,
***************
*** 3055,3059 ****
  ; return 0; }
  EOF
! if { (eval echo configure:3058: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    eval "ac_cv_func_$ac_func=yes"
--- 3062,3066 ----
  ; return 0; }
  EOF
! if { (eval echo configure:3065: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    eval "ac_cv_func_$ac_func=yes"
***************
*** 3083,3096 ****
  		setlinebuf setlocale strchr strerror strtod strtol \
  		strtoul tcgetattr uname sysconf ulimit times tzset \
! 		siginterrupt memmove ttyname gethostbyname inet_aton \
! 		strpbrk setvbuf
  do
  echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
! echo "configure:3090: checking for $ac_func" >&5
  if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 3095 "configure"
  #include "confdefs.h"
  /* System header to define __stub macros and hopefully few prototypes,
--- 3090,3103 ----
  		setlinebuf setlocale strchr strerror strtod strtol \
  		strtoul tcgetattr uname sysconf ulimit times tzset \
! 		siginterrupt memmove ttyname gethostbyname getservbyname \
! 		inet_aton strpbrk setvbuf pathconf
  do
  echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
! echo "configure:3097: checking for $ac_func" >&5
  if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 3102 "configure"
  #include "confdefs.h"
  /* System header to define __stub macros and hopefully few prototypes,
***************
*** 3115,3119 ****
  ; return 0; }
  EOF
! if { (eval echo configure:3118: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    eval "ac_cv_func_$ac_func=yes"
--- 3122,3126 ----
  ; return 0; }
  EOF
! if { (eval echo configure:3125: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    eval "ac_cv_func_$ac_func=yes"
***************
*** 3144,3158 ****
  ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
  echo $ac_n "checking for $ac_hdr""... $ac_c" 1>&6
! echo "configure:3147: checking for $ac_hdr" >&5
  if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 3152 "configure"
  #include "confdefs.h"
  #include <$ac_hdr>
  EOF
  ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
! { (eval echo configure:3157: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
  ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
  if test -z "$ac_err"; then
--- 3151,3165 ----
  ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
  echo $ac_n "checking for $ac_hdr""... $ac_c" 1>&6
! echo "configure:3154: checking for $ac_hdr" >&5
  if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 3159 "configure"
  #include "confdefs.h"
  #include <$ac_hdr>
  EOF
  ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
! { (eval echo configure:3164: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
  ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
  if test -z "$ac_err"; then
***************
*** 3183,3192 ****
  do
  echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
! echo "configure:3186: checking for $ac_func" >&5
  if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 3191 "configure"
  #include "confdefs.h"
  /* System header to define __stub macros and hopefully few prototypes,
--- 3190,3199 ----
  do
  echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
! echo "configure:3193: checking for $ac_func" >&5
  if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 3198 "configure"
  #include "confdefs.h"
  /* System header to define __stub macros and hopefully few prototypes,
***************
*** 3211,3215 ****
  ; return 0; }
  EOF
! if { (eval echo configure:3214: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    eval "ac_cv_func_$ac_func=yes"
--- 3218,3222 ----
  ; return 0; }
  EOF
! if { (eval echo configure:3221: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    eval "ac_cv_func_$ac_func=yes"
***************
*** 3238,3242 ****
  if test "$ac_cv_func_bindtextdomain" = "no"; then
      echo $ac_n "checking for bindtextdomain in -lintl""... $ac_c" 1>&6
! echo "configure:3241: checking for bindtextdomain in -lintl" >&5
  ac_lib_var=`echo intl'_'bindtextdomain | sed 'y%./+-%__p_%'`
  if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
--- 3245,3249 ----
  if test "$ac_cv_func_bindtextdomain" = "no"; then
      echo $ac_n "checking for bindtextdomain in -lintl""... $ac_c" 1>&6
! echo "configure:3248: checking for bindtextdomain in -lintl" >&5
  ac_lib_var=`echo intl'_'bindtextdomain | sed 'y%./+-%__p_%'`
  if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
***************
*** 3246,3250 ****
  LIBS="-lintl  $LIBS"
  cat > conftest.$ac_ext <<EOF
! #line 3249 "configure"
  #include "confdefs.h"
  /* Override any gcc2 internal prototype to avoid an error.  */
--- 3253,3257 ----
  LIBS="-lintl  $LIBS"
  cat > conftest.$ac_ext <<EOF
! #line 3256 "configure"
  #include "confdefs.h"
  /* Override any gcc2 internal prototype to avoid an error.  */
***************
*** 3257,3261 ****
  ; return 0; }
  EOF
! if { (eval echo configure:3260: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    eval "ac_cv_lib_$ac_lib_var=yes"
--- 3264,3268 ----
  ; return 0; }
  EOF
! if { (eval echo configure:3267: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    eval "ac_cv_lib_$ac_lib_var=yes"
***************
*** 3288,3297 ****
  do
  echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
! echo "configure:3291: checking for $ac_func" >&5
  if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 3296 "configure"
  #include "confdefs.h"
  /* System header to define __stub macros and hopefully few prototypes,
--- 3295,3304 ----
  do
  echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
! echo "configure:3298: checking for $ac_func" >&5
  if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 3303 "configure"
  #include "confdefs.h"
  /* System header to define __stub macros and hopefully few prototypes,
***************
*** 3316,3320 ****
  ; return 0; }
  EOF
! if { (eval echo configure:3319: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    eval "ac_cv_func_$ac_func=yes"
--- 3323,3327 ----
  ; return 0; }
  EOF
! if { (eval echo configure:3326: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    eval "ac_cv_func_$ac_func=yes"
***************
*** 3345,3349 ****
  if test "$opt_static_link" != yes; then
  echo $ac_n "checking for dlopen in -ldl""... $ac_c" 1>&6
! echo "configure:3348: checking for dlopen in -ldl" >&5
  ac_lib_var=`echo dl'_'dlopen | sed 'y%./+-%__p_%'`
  if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
--- 3352,3356 ----
  if test "$opt_static_link" != yes; then
  echo $ac_n "checking for dlopen in -ldl""... $ac_c" 1>&6
! echo "configure:3355: checking for dlopen in -ldl" >&5
  ac_lib_var=`echo dl'_'dlopen | sed 'y%./+-%__p_%'`
  if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
***************
*** 3353,3357 ****
  LIBS="-ldl  $LIBS"
  cat > conftest.$ac_ext <<EOF
! #line 3356 "configure"
  #include "confdefs.h"
  /* Override any gcc2 internal prototype to avoid an error.  */
--- 3360,3364 ----
  LIBS="-ldl  $LIBS"
  cat > conftest.$ac_ext <<EOF
! #line 3363 "configure"
  #include "confdefs.h"
  /* Override any gcc2 internal prototype to avoid an error.  */
***************
*** 3364,3368 ****
  ; return 0; }
  EOF
! if { (eval echo configure:3367: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    eval "ac_cv_lib_$ac_lib_var=yes"
--- 3371,3375 ----
  ; return 0; }
  EOF
! if { (eval echo configure:3374: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    eval "ac_cv_lib_$ac_lib_var=yes"
***************
*** 3394,3403 ****
  do
  echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
! echo "configure:3397: checking for $ac_func" >&5
  if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 3402 "configure"
  #include "confdefs.h"
  /* System header to define __stub macros and hopefully few prototypes,
--- 3401,3410 ----
  do
  echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
! echo "configure:3404: checking for $ac_func" >&5
  if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 3409 "configure"
  #include "confdefs.h"
  /* System header to define __stub macros and hopefully few prototypes,
***************
*** 3422,3426 ****
  ; return 0; }
  EOF
! if { (eval echo configure:3425: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    eval "ac_cv_func_$ac_func=yes"
--- 3429,3433 ----
  ; return 0; }
  EOF
! if { (eval echo configure:3432: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    eval "ac_cv_func_$ac_func=yes"
***************
*** 3449,3458 ****
  
  echo $ac_n "checking for sys_siglist declaration in signal.h or unistd.h""... $ac_c" 1>&6
! echo "configure:3452: checking for sys_siglist declaration in signal.h or unistd.h" >&5
  if eval "test \"`echo '$''{'ac_cv_decl_sys_siglist'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 3457 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
--- 3456,3465 ----
  
  echo $ac_n "checking for sys_siglist declaration in signal.h or unistd.h""... $ac_c" 1>&6
! echo "configure:3459: checking for sys_siglist declaration in signal.h or unistd.h" >&5
  if eval "test \"`echo '$''{'ac_cv_decl_sys_siglist'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 3464 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
***************
*** 3466,3470 ****
  ; return 0; }
  EOF
! if { (eval echo configure:3469: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
    rm -rf conftest*
    ac_cv_decl_sys_siglist=yes
--- 3473,3477 ----
  ; return 0; }
  EOF
! if { (eval echo configure:3476: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
    rm -rf conftest*
    ac_cv_decl_sys_siglist=yes
***************
*** 3492,3501 ****
  ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
  echo $ac_n "checking for $ac_hdr that defines DIR""... $ac_c" 1>&6
! echo "configure:3495: checking for $ac_hdr that defines DIR" >&5
  if eval "test \"`echo '$''{'ac_cv_header_dirent_$ac_safe'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 3500 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
--- 3499,3508 ----
  ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
  echo $ac_n "checking for $ac_hdr that defines DIR""... $ac_c" 1>&6
! echo "configure:3502: checking for $ac_hdr that defines DIR" >&5
  if eval "test \"`echo '$''{'ac_cv_header_dirent_$ac_safe'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 3507 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
***************
*** 3505,3509 ****
  ; return 0; }
  EOF
! if { (eval echo configure:3508: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
    rm -rf conftest*
    eval "ac_cv_header_dirent_$ac_safe=yes"
--- 3512,3516 ----
  ; return 0; }
  EOF
! if { (eval echo configure:3515: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
    rm -rf conftest*
    eval "ac_cv_header_dirent_$ac_safe=yes"
***************
*** 3530,3534 ****
  if test $ac_header_dirent = dirent.h; then
  echo $ac_n "checking for opendir in -ldir""... $ac_c" 1>&6
! echo "configure:3533: checking for opendir in -ldir" >&5
  ac_lib_var=`echo dir'_'opendir | sed 'y%./+-%__p_%'`
  if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
--- 3537,3541 ----
  if test $ac_header_dirent = dirent.h; then
  echo $ac_n "checking for opendir in -ldir""... $ac_c" 1>&6
! echo "configure:3540: checking for opendir in -ldir" >&5
  ac_lib_var=`echo dir'_'opendir | sed 'y%./+-%__p_%'`
  if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
***************
*** 3538,3542 ****
  LIBS="-ldir  $LIBS"
  cat > conftest.$ac_ext <<EOF
! #line 3541 "configure"
  #include "confdefs.h"
  /* Override any gcc2 internal prototype to avoid an error.  */
--- 3545,3549 ----
  LIBS="-ldir  $LIBS"
  cat > conftest.$ac_ext <<EOF
! #line 3548 "configure"
  #include "confdefs.h"
  /* Override any gcc2 internal prototype to avoid an error.  */
***************
*** 3549,3553 ****
  ; return 0; }
  EOF
! if { (eval echo configure:3552: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    eval "ac_cv_lib_$ac_lib_var=yes"
--- 3556,3560 ----
  ; return 0; }
  EOF
! if { (eval echo configure:3559: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    eval "ac_cv_lib_$ac_lib_var=yes"
***************
*** 3571,3575 ****
  else
  echo $ac_n "checking for opendir in -lx""... $ac_c" 1>&6
! echo "configure:3574: checking for opendir in -lx" >&5
  ac_lib_var=`echo x'_'opendir | sed 'y%./+-%__p_%'`
  if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
--- 3578,3582 ----
  else
  echo $ac_n "checking for opendir in -lx""... $ac_c" 1>&6
! echo "configure:3581: checking for opendir in -lx" >&5
  ac_lib_var=`echo x'_'opendir | sed 'y%./+-%__p_%'`
  if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
***************
*** 3579,3583 ****
  LIBS="-lx  $LIBS"
  cat > conftest.$ac_ext <<EOF
! #line 3582 "configure"
  #include "confdefs.h"
  /* Override any gcc2 internal prototype to avoid an error.  */
--- 3586,3590 ----
  LIBS="-lx  $LIBS"
  cat > conftest.$ac_ext <<EOF
! #line 3589 "configure"
  #include "confdefs.h"
  /* Override any gcc2 internal prototype to avoid an error.  */
***************
*** 3590,3594 ****
  ; return 0; }
  EOF
! if { (eval echo configure:3593: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    eval "ac_cv_lib_$ac_lib_var=yes"
--- 3597,3601 ----
  ; return 0; }
  EOF
! if { (eval echo configure:3600: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    eval "ac_cv_lib_$ac_lib_var=yes"
***************
*** 3613,3622 ****
  
  echo $ac_n "checking whether time.h and sys/time.h may both be included""... $ac_c" 1>&6
! echo "configure:3616: checking whether time.h and sys/time.h may both be included" >&5
  if eval "test \"`echo '$''{'ac_cv_header_time'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 3621 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
--- 3620,3629 ----
  
  echo $ac_n "checking whether time.h and sys/time.h may both be included""... $ac_c" 1>&6
! echo "configure:3623: checking whether time.h and sys/time.h may both be included" >&5
  if eval "test \"`echo '$''{'ac_cv_header_time'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 3628 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
***************
*** 3627,3631 ****
  ; return 0; }
  EOF
! if { (eval echo configure:3630: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
    rm -rf conftest*
    ac_cv_header_time=yes
--- 3634,3638 ----
  ; return 0; }
  EOF
! if { (eval echo configure:3637: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
    rm -rf conftest*
    ac_cv_header_time=yes
***************
*** 3654,3668 ****
  ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
  echo $ac_n "checking for $ac_hdr""... $ac_c" 1>&6
! echo "configure:3657: checking for $ac_hdr" >&5
  if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 3662 "configure"
  #include "confdefs.h"
  #include <$ac_hdr>
  EOF
  ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
! { (eval echo configure:3667: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
  ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
  if test -z "$ac_err"; then
--- 3661,3675 ----
  ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
  echo $ac_n "checking for $ac_hdr""... $ac_c" 1>&6
! echo "configure:3664: checking for $ac_hdr" >&5
  if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 3669 "configure"
  #include "confdefs.h"
  #include <$ac_hdr>
  EOF
  ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
! { (eval echo configure:3674: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
  ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
  if test -z "$ac_err"; then
***************
*** 3696,3710 ****
  ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
  echo $ac_n "checking for $ac_hdr""... $ac_c" 1>&6
! echo "configure:3699: checking for $ac_hdr" >&5
  if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 3704 "configure"
  #include "confdefs.h"
  #include <$ac_hdr>
  EOF
  ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
! { (eval echo configure:3709: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
  ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
  if test -z "$ac_err"; then
--- 3703,3717 ----
  ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
  echo $ac_n "checking for $ac_hdr""... $ac_c" 1>&6
! echo "configure:3706: checking for $ac_hdr" >&5
  if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 3711 "configure"
  #include "confdefs.h"
  #include <$ac_hdr>
  EOF
  ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
! { (eval echo configure:3716: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
  ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
  if test -z "$ac_err"; then
***************
*** 3736,3750 ****
  ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
  echo $ac_n "checking for $ac_hdr""... $ac_c" 1>&6
! echo "configure:3739: checking for $ac_hdr" >&5
  if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 3744 "configure"
  #include "confdefs.h"
  #include <$ac_hdr>
  EOF
  ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
! { (eval echo configure:3749: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
  ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
  if test -z "$ac_err"; then
--- 3743,3757 ----
  ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
  echo $ac_n "checking for $ac_hdr""... $ac_c" 1>&6
! echo "configure:3746: checking for $ac_hdr" >&5
  if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 3751 "configure"
  #include "confdefs.h"
  #include <$ac_hdr>
  EOF
  ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
! { (eval echo configure:3756: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
  ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
  if test -z "$ac_err"; then
***************
*** 3776,3785 ****
  
  echo $ac_n "checking for inet_aton""... $ac_c" 1>&6
! echo "configure:3779: checking for inet_aton" >&5
  if eval "test \"`echo '$''{'bash_cv_func_inet_aton'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 3784 "configure"
  #include "confdefs.h"
  
--- 3783,3792 ----
  
  echo $ac_n "checking for inet_aton""... $ac_c" 1>&6
! echo "configure:3786: checking for inet_aton" >&5
  if eval "test \"`echo '$''{'bash_cv_func_inet_aton'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 3791 "configure"
  #include "confdefs.h"
  
***************
*** 3792,3796 ****
  ; return 0; }
  EOF
! if { (eval echo configure:3795: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    bash_cv_func_inet_aton=yes
--- 3799,3803 ----
  ; return 0; }
  EOF
! if { (eval echo configure:3802: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    bash_cv_func_inet_aton=yes
***************
*** 3816,3820 ****
  case "$host_os" in
  irix4*)	echo $ac_n "checking for getpwent in -lsun""... $ac_c" 1>&6
! echo "configure:3819: checking for getpwent in -lsun" >&5
  ac_lib_var=`echo sun'_'getpwent | sed 'y%./+-%__p_%'`
  if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
--- 3823,3827 ----
  case "$host_os" in
  irix4*)	echo $ac_n "checking for getpwent in -lsun""... $ac_c" 1>&6
! echo "configure:3826: checking for getpwent in -lsun" >&5
  ac_lib_var=`echo sun'_'getpwent | sed 'y%./+-%__p_%'`
  if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
***************
*** 3824,3828 ****
  LIBS="-lsun  $LIBS"
  cat > conftest.$ac_ext <<EOF
! #line 3827 "configure"
  #include "confdefs.h"
  /* Override any gcc2 internal prototype to avoid an error.  */
--- 3831,3835 ----
  LIBS="-lsun  $LIBS"
  cat > conftest.$ac_ext <<EOF
! #line 3834 "configure"
  #include "confdefs.h"
  /* Override any gcc2 internal prototype to avoid an error.  */
***************
*** 3835,3839 ****
  ; return 0; }
  EOF
! if { (eval echo configure:3838: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    eval "ac_cv_lib_$ac_lib_var=yes"
--- 3842,3846 ----
  ; return 0; }
  EOF
! if { (eval echo configure:3845: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    eval "ac_cv_lib_$ac_lib_var=yes"
***************
*** 3870,3874 ****
  else
  echo $ac_n "checking for socket library""... $ac_c" 1>&6
! echo "configure:3873: checking for socket library" >&5
  _bash_needmsg=yes
  fi
--- 3877,3881 ----
  else
  echo $ac_n "checking for socket library""... $ac_c" 1>&6
! echo "configure:3880: checking for socket library" >&5
  _bash_needmsg=yes
  fi
***************
*** 3877,3881 ****
  else
    echo $ac_n "checking for getpeername in -lsocket""... $ac_c" 1>&6
! echo "configure:3880: checking for getpeername in -lsocket" >&5
  ac_lib_var=`echo socket'_'getpeername | sed 'y%./+-%__p_%'`
  if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
--- 3884,3888 ----
  else
    echo $ac_n "checking for getpeername in -lsocket""... $ac_c" 1>&6
! echo "configure:3887: checking for getpeername in -lsocket" >&5
  ac_lib_var=`echo socket'_'getpeername | sed 'y%./+-%__p_%'`
  if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
***************
*** 3885,3889 ****
  LIBS="-lsocket -lnsl $LIBS"
  cat > conftest.$ac_ext <<EOF
! #line 3888 "configure"
  #include "confdefs.h"
  /* Override any gcc2 internal prototype to avoid an error.  */
--- 3892,3896 ----
  LIBS="-lsocket -lnsl $LIBS"
  cat > conftest.$ac_ext <<EOF
! #line 3895 "configure"
  #include "confdefs.h"
  /* Override any gcc2 internal prototype to avoid an error.  */
***************
*** 3896,3900 ****
  ; return 0; }
  EOF
! if { (eval echo configure:3899: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    eval "ac_cv_lib_$ac_lib_var=yes"
--- 3903,3907 ----
  ; return 0; }
  EOF
! if { (eval echo configure:3906: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    eval "ac_cv_lib_$ac_lib_var=yes"
***************
*** 3929,3933 ****
    else
      echo $ac_n "checking for libnsl""... $ac_c" 1>&6
! echo "configure:3932: checking for libnsl" >&5
      _bash_needmsg=yes
    fi
--- 3936,3940 ----
    else
      echo $ac_n "checking for libnsl""... $ac_c" 1>&6
! echo "configure:3939: checking for libnsl" >&5
      _bash_needmsg=yes
    fi
***************
*** 3936,3940 ****
  else
    echo $ac_n "checking for t_open in -lnsl""... $ac_c" 1>&6
! echo "configure:3939: checking for t_open in -lnsl" >&5
  ac_lib_var=`echo nsl'_'t_open | sed 'y%./+-%__p_%'`
  if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
--- 3943,3947 ----
  else
    echo $ac_n "checking for t_open in -lnsl""... $ac_c" 1>&6
! echo "configure:3946: checking for t_open in -lnsl" >&5
  ac_lib_var=`echo nsl'_'t_open | sed 'y%./+-%__p_%'`
  if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
***************
*** 3944,3948 ****
  LIBS="-lnsl  $LIBS"
  cat > conftest.$ac_ext <<EOF
! #line 3947 "configure"
  #include "confdefs.h"
  /* Override any gcc2 internal prototype to avoid an error.  */
--- 3951,3955 ----
  LIBS="-lnsl  $LIBS"
  cat > conftest.$ac_ext <<EOF
! #line 3954 "configure"
  #include "confdefs.h"
  /* Override any gcc2 internal prototype to avoid an error.  */
***************
*** 3955,3959 ****
  ; return 0; }
  EOF
! if { (eval echo configure:3958: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    eval "ac_cv_lib_$ac_lib_var=yes"
--- 3962,3966 ----
  ; return 0; }
  EOF
! if { (eval echo configure:3965: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    eval "ac_cv_lib_$ac_lib_var=yes"
***************
*** 4003,4007 ****
  else
  echo $ac_n "checking for gethostbyname in socket library""... $ac_c" 1>&6
! echo "configure:4006: checking for gethostbyname in socket library" >&5
  _bash_needmsg=
  fi
--- 4010,4014 ----
  else
  echo $ac_n "checking for gethostbyname in socket library""... $ac_c" 1>&6
! echo "configure:4013: checking for gethostbyname in socket library" >&5
  _bash_needmsg=
  fi
***************
*** 4010,4014 ****
  else
    cat > conftest.$ac_ext <<EOF
! #line 4013 "configure"
  #include "confdefs.h"
  #include <netdb.h>
--- 4017,4021 ----
  else
    cat > conftest.$ac_ext <<EOF
! #line 4020 "configure"
  #include "confdefs.h"
  #include <netdb.h>
***************
*** 4019,4023 ****
  ; return 0; }
  EOF
! if { (eval echo configure:4022: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    bash_cv_have_gethostbyname=yes
--- 4026,4030 ----
  ; return 0; }
  EOF
! if { (eval echo configure:4029: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    bash_cv_have_gethostbyname=yes
***************
*** 4034,4038 ****
  if test "X$_bash_needmsg" = Xyes; then
      echo $ac_n "checking for gethostbyname in socket library""... $ac_c" 1>&6
! echo "configure:4037: checking for gethostbyname in socket library" >&5
  fi
  echo "$ac_t""$bash_cv_have_gethostbyname" 1>&6
--- 4041,4045 ----
  if test "X$_bash_needmsg" = Xyes; then
      echo $ac_n "checking for gethostbyname in socket library""... $ac_c" 1>&6
! echo "configure:4044: checking for gethostbyname in socket library" >&5
  fi
  echo "$ac_t""$bash_cv_have_gethostbyname" 1>&6
***************
*** 4047,4056 ****
  
  echo $ac_n "checking for uid_t in sys/types.h""... $ac_c" 1>&6
! echo "configure:4050: checking for uid_t in sys/types.h" >&5
  if eval "test \"`echo '$''{'ac_cv_type_uid_t'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 4055 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
--- 4054,4063 ----
  
  echo $ac_n "checking for uid_t in sys/types.h""... $ac_c" 1>&6
! echo "configure:4057: checking for uid_t in sys/types.h" >&5
  if eval "test \"`echo '$''{'ac_cv_type_uid_t'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 4062 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
***************
*** 4081,4085 ****
  
  echo $ac_n "checking type of array argument to getgroups""... $ac_c" 1>&6
! echo "configure:4084: checking type of array argument to getgroups" >&5
  if eval "test \"`echo '$''{'ac_cv_type_getgroups'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
--- 4088,4092 ----
  
  echo $ac_n "checking type of array argument to getgroups""... $ac_c" 1>&6
! echo "configure:4091: checking type of array argument to getgroups" >&5
  if eval "test \"`echo '$''{'ac_cv_type_getgroups'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
***************
*** 4089,4093 ****
  else
    cat > conftest.$ac_ext <<EOF
! #line 4092 "configure"
  #include "confdefs.h"
  
--- 4096,4100 ----
  else
    cat > conftest.$ac_ext <<EOF
! #line 4099 "configure"
  #include "confdefs.h"
  
***************
*** 4114,4118 ****
  
  EOF
! if { (eval echo configure:4117: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
  then
      ac_cv_type_getgroups=gid_t
--- 4121,4125 ----
  
  EOF
! if { (eval echo configure:4124: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
  then
      ac_cv_type_getgroups=gid_t
***************
*** 4128,4132 ****
  if test $ac_cv_type_getgroups = cross; then
          cat > conftest.$ac_ext <<EOF
! #line 4131 "configure"
  #include "confdefs.h"
  #include <unistd.h>
--- 4135,4139 ----
  if test $ac_cv_type_getgroups = cross; then
          cat > conftest.$ac_ext <<EOF
! #line 4138 "configure"
  #include "confdefs.h"
  #include <unistd.h>
***************
*** 4152,4161 ****
  
  echo $ac_n "checking for ANSI C header files""... $ac_c" 1>&6
! echo "configure:4155: checking for ANSI C header files" >&5
  if eval "test \"`echo '$''{'ac_cv_header_stdc'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 4160 "configure"
  #include "confdefs.h"
  #include <stdlib.h>
--- 4159,4168 ----
  
  echo $ac_n "checking for ANSI C header files""... $ac_c" 1>&6
! echo "configure:4162: checking for ANSI C header files" >&5
  if eval "test \"`echo '$''{'ac_cv_header_stdc'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 4167 "configure"
  #include "confdefs.h"
  #include <stdlib.h>
***************
*** 4165,4169 ****
  EOF
  ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
! { (eval echo configure:4168: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
  ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
  if test -z "$ac_err"; then
--- 4172,4176 ----
  EOF
  ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
! { (eval echo configure:4175: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
  ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
  if test -z "$ac_err"; then
***************
*** 4182,4186 ****
    # SunOS 4.x string.h does not declare mem*, contrary to ANSI.
  cat > conftest.$ac_ext <<EOF
! #line 4185 "configure"
  #include "confdefs.h"
  #include <string.h>
--- 4189,4193 ----
    # SunOS 4.x string.h does not declare mem*, contrary to ANSI.
  cat > conftest.$ac_ext <<EOF
! #line 4192 "configure"
  #include "confdefs.h"
  #include <string.h>
***************
*** 4200,4204 ****
    # ISC 2.0.2 stdlib.h does not declare free, contrary to ANSI.
  cat > conftest.$ac_ext <<EOF
! #line 4203 "configure"
  #include "confdefs.h"
  #include <stdlib.h>
--- 4207,4211 ----
    # ISC 2.0.2 stdlib.h does not declare free, contrary to ANSI.
  cat > conftest.$ac_ext <<EOF
! #line 4210 "configure"
  #include "confdefs.h"
  #include <stdlib.h>
***************
*** 4221,4225 ****
  else
    cat > conftest.$ac_ext <<EOF
! #line 4224 "configure"
  #include "confdefs.h"
  #include <ctype.h>
--- 4228,4232 ----
  else
    cat > conftest.$ac_ext <<EOF
! #line 4231 "configure"
  #include "confdefs.h"
  #include <ctype.h>
***************
*** 4232,4236 ****
  
  EOF
! if { (eval echo configure:4235: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
  then
    :
--- 4239,4243 ----
  
  EOF
! if { (eval echo configure:4242: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
  then
    :
***************
*** 4256,4265 ****
  
  echo $ac_n "checking for off_t""... $ac_c" 1>&6
! echo "configure:4259: checking for off_t" >&5
  if eval "test \"`echo '$''{'ac_cv_type_off_t'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 4264 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
--- 4263,4272 ----
  
  echo $ac_n "checking for off_t""... $ac_c" 1>&6
! echo "configure:4266: checking for off_t" >&5
  if eval "test \"`echo '$''{'ac_cv_type_off_t'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 4271 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
***************
*** 4289,4298 ****
  
  echo $ac_n "checking for mode_t""... $ac_c" 1>&6
! echo "configure:4292: checking for mode_t" >&5
  if eval "test \"`echo '$''{'ac_cv_type_mode_t'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 4297 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
--- 4296,4305 ----
  
  echo $ac_n "checking for mode_t""... $ac_c" 1>&6
! echo "configure:4299: checking for mode_t" >&5
  if eval "test \"`echo '$''{'ac_cv_type_mode_t'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 4304 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
***************
*** 4322,4331 ****
  
  echo $ac_n "checking for uid_t in sys/types.h""... $ac_c" 1>&6
! echo "configure:4325: checking for uid_t in sys/types.h" >&5
  if eval "test \"`echo '$''{'ac_cv_type_uid_t'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 4330 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
--- 4329,4338 ----
  
  echo $ac_n "checking for uid_t in sys/types.h""... $ac_c" 1>&6
! echo "configure:4332: checking for uid_t in sys/types.h" >&5
  if eval "test \"`echo '$''{'ac_cv_type_uid_t'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 4337 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
***************
*** 4356,4365 ****
  
  echo $ac_n "checking for pid_t""... $ac_c" 1>&6
! echo "configure:4359: checking for pid_t" >&5
  if eval "test \"`echo '$''{'ac_cv_type_pid_t'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 4364 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
--- 4363,4372 ----
  
  echo $ac_n "checking for pid_t""... $ac_c" 1>&6
! echo "configure:4366: checking for pid_t" >&5
  if eval "test \"`echo '$''{'ac_cv_type_pid_t'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 4371 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
***************
*** 4389,4398 ****
  
  echo $ac_n "checking for size_t""... $ac_c" 1>&6
! echo "configure:4392: checking for size_t" >&5
  if eval "test \"`echo '$''{'ac_cv_type_size_t'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 4397 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
--- 4396,4405 ----
  
  echo $ac_n "checking for size_t""... $ac_c" 1>&6
! echo "configure:4399: checking for size_t" >&5
  if eval "test \"`echo '$''{'ac_cv_type_size_t'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 4404 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
***************
*** 4422,4431 ****
  
  echo $ac_n "checking for time_t""... $ac_c" 1>&6
! echo "configure:4425: checking for time_t" >&5
  if eval "test \"`echo '$''{'ac_cv_type_time_t'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 4430 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
--- 4429,4438 ----
  
  echo $ac_n "checking for time_t""... $ac_c" 1>&6
! echo "configure:4432: checking for time_t" >&5
  if eval "test \"`echo '$''{'ac_cv_type_time_t'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 4437 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
***************
*** 4456,4465 ****
  
  echo $ac_n "checking return type of signal handlers""... $ac_c" 1>&6
! echo "configure:4459: checking return type of signal handlers" >&5
  if eval "test \"`echo '$''{'ac_cv_type_signal'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 4464 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
--- 4463,4472 ----
  
  echo $ac_n "checking return type of signal handlers""... $ac_c" 1>&6
! echo "configure:4466: checking return type of signal handlers" >&5
  if eval "test \"`echo '$''{'ac_cv_type_signal'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 4471 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
***************
*** 4478,4482 ****
  ; return 0; }
  EOF
! if { (eval echo configure:4481: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
    rm -rf conftest*
    ac_cv_type_signal=void
--- 4485,4489 ----
  ; return 0; }
  EOF
! if { (eval echo configure:4488: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
    rm -rf conftest*
    ac_cv_type_signal=void
***************
*** 4498,4502 ****
  
  echo $ac_n "checking size of char""... $ac_c" 1>&6
! echo "configure:4501: checking size of char" >&5
  if eval "test \"`echo '$''{'ac_cv_sizeof_char'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
--- 4505,4509 ----
  
  echo $ac_n "checking size of char""... $ac_c" 1>&6
! echo "configure:4508: checking size of char" >&5
  if eval "test \"`echo '$''{'ac_cv_sizeof_char'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
***************
*** 4506,4510 ****
  else
    cat > conftest.$ac_ext <<EOF
! #line 4509 "configure"
  #include "confdefs.h"
  #include <stdio.h>
--- 4513,4517 ----
  else
    cat > conftest.$ac_ext <<EOF
! #line 4516 "configure"
  #include "confdefs.h"
  #include <stdio.h>
***************
*** 4517,4521 ****
  }
  EOF
! if { (eval echo configure:4520: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
  then
    ac_cv_sizeof_char=`cat conftestval`
--- 4524,4528 ----
  }
  EOF
! if { (eval echo configure:4527: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
  then
    ac_cv_sizeof_char=`cat conftestval`
***************
*** 4537,4541 ****
  
  echo $ac_n "checking size of short""... $ac_c" 1>&6
! echo "configure:4540: checking size of short" >&5
  if eval "test \"`echo '$''{'ac_cv_sizeof_short'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
--- 4544,4548 ----
  
  echo $ac_n "checking size of short""... $ac_c" 1>&6
! echo "configure:4547: checking size of short" >&5
  if eval "test \"`echo '$''{'ac_cv_sizeof_short'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
***************
*** 4545,4549 ****
  else
    cat > conftest.$ac_ext <<EOF
! #line 4548 "configure"
  #include "confdefs.h"
  #include <stdio.h>
--- 4552,4556 ----
  else
    cat > conftest.$ac_ext <<EOF
! #line 4555 "configure"
  #include "confdefs.h"
  #include <stdio.h>
***************
*** 4556,4560 ****
  }
  EOF
! if { (eval echo configure:4559: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
  then
    ac_cv_sizeof_short=`cat conftestval`
--- 4563,4567 ----
  }
  EOF
! if { (eval echo configure:4566: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
  then
    ac_cv_sizeof_short=`cat conftestval`
***************
*** 4576,4580 ****
  
  echo $ac_n "checking size of int""... $ac_c" 1>&6
! echo "configure:4579: checking size of int" >&5
  if eval "test \"`echo '$''{'ac_cv_sizeof_int'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
--- 4583,4587 ----
  
  echo $ac_n "checking size of int""... $ac_c" 1>&6
! echo "configure:4586: checking size of int" >&5
  if eval "test \"`echo '$''{'ac_cv_sizeof_int'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
***************
*** 4584,4588 ****
  else
    cat > conftest.$ac_ext <<EOF
! #line 4587 "configure"
  #include "confdefs.h"
  #include <stdio.h>
--- 4591,4595 ----
  else
    cat > conftest.$ac_ext <<EOF
! #line 4594 "configure"
  #include "confdefs.h"
  #include <stdio.h>
***************
*** 4595,4599 ****
  }
  EOF
! if { (eval echo configure:4598: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
  then
    ac_cv_sizeof_int=`cat conftestval`
--- 4602,4606 ----
  }
  EOF
! if { (eval echo configure:4605: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
  then
    ac_cv_sizeof_int=`cat conftestval`
***************
*** 4615,4619 ****
  
  echo $ac_n "checking size of long""... $ac_c" 1>&6
! echo "configure:4618: checking size of long" >&5
  if eval "test \"`echo '$''{'ac_cv_sizeof_long'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
--- 4622,4626 ----
  
  echo $ac_n "checking size of long""... $ac_c" 1>&6
! echo "configure:4625: checking size of long" >&5
  if eval "test \"`echo '$''{'ac_cv_sizeof_long'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
***************
*** 4623,4627 ****
  else
    cat > conftest.$ac_ext <<EOF
! #line 4626 "configure"
  #include "confdefs.h"
  #include <stdio.h>
--- 4630,4634 ----
  else
    cat > conftest.$ac_ext <<EOF
! #line 4633 "configure"
  #include "confdefs.h"
  #include <stdio.h>
***************
*** 4634,4638 ****
  }
  EOF
! if { (eval echo configure:4637: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
  then
    ac_cv_sizeof_long=`cat conftestval`
--- 4641,4645 ----
  }
  EOF
! if { (eval echo configure:4644: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
  then
    ac_cv_sizeof_long=`cat conftestval`
***************
*** 4654,4658 ****
  
  echo $ac_n "checking size of char *""... $ac_c" 1>&6
! echo "configure:4657: checking size of char *" >&5
  if eval "test \"`echo '$''{'ac_cv_sizeof_char_p'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
--- 4661,4665 ----
  
  echo $ac_n "checking size of char *""... $ac_c" 1>&6
! echo "configure:4664: checking size of char *" >&5
  if eval "test \"`echo '$''{'ac_cv_sizeof_char_p'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
***************
*** 4662,4666 ****
  else
    cat > conftest.$ac_ext <<EOF
! #line 4665 "configure"
  #include "confdefs.h"
  #include <stdio.h>
--- 4669,4673 ----
  else
    cat > conftest.$ac_ext <<EOF
! #line 4672 "configure"
  #include "confdefs.h"
  #include <stdio.h>
***************
*** 4673,4677 ****
  }
  EOF
! if { (eval echo configure:4676: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
  then
    ac_cv_sizeof_char_p=`cat conftestval`
--- 4680,4684 ----
  }
  EOF
! if { (eval echo configure:4683: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
  then
    ac_cv_sizeof_char_p=`cat conftestval`
***************
*** 4693,4697 ****
  
  echo $ac_n "checking size of double""... $ac_c" 1>&6
! echo "configure:4696: checking size of double" >&5
  if eval "test \"`echo '$''{'ac_cv_sizeof_double'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
--- 4700,4704 ----
  
  echo $ac_n "checking size of double""... $ac_c" 1>&6
! echo "configure:4703: checking size of double" >&5
  if eval "test \"`echo '$''{'ac_cv_sizeof_double'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
***************
*** 4701,4705 ****
  else
    cat > conftest.$ac_ext <<EOF
! #line 4704 "configure"
  #include "confdefs.h"
  #include <stdio.h>
--- 4708,4712 ----
  else
    cat > conftest.$ac_ext <<EOF
! #line 4711 "configure"
  #include "confdefs.h"
  #include <stdio.h>
***************
*** 4712,4716 ****
  }
  EOF
! if { (eval echo configure:4715: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
  then
    ac_cv_sizeof_double=`cat conftestval`
--- 4719,4723 ----
  }
  EOF
! if { (eval echo configure:4722: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
  then
    ac_cv_sizeof_double=`cat conftestval`
***************
*** 4733,4742 ****
  
  echo $ac_n "checking for u_int""... $ac_c" 1>&6
! echo "configure:4736: checking for u_int" >&5
  if eval "test \"`echo '$''{'ac_cv_type_u_int'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 4741 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
--- 4740,4749 ----
  
  echo $ac_n "checking for u_int""... $ac_c" 1>&6
! echo "configure:4743: checking for u_int" >&5
  if eval "test \"`echo '$''{'ac_cv_type_u_int'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 4748 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
***************
*** 4766,4775 ****
  
  echo $ac_n "checking for u_long""... $ac_c" 1>&6
! echo "configure:4769: checking for u_long" >&5
  if eval "test \"`echo '$''{'ac_cv_type_u_long'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 4774 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
--- 4773,4782 ----
  
  echo $ac_n "checking for u_long""... $ac_c" 1>&6
! echo "configure:4776: checking for u_long" >&5
  if eval "test \"`echo '$''{'ac_cv_type_u_long'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 4781 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
***************
*** 4802,4811 ****
  if test "$ac_cv_sizeof_short" = 2; then
    echo $ac_n "checking for bits16_t""... $ac_c" 1>&6
! echo "configure:4805: checking for bits16_t" >&5
  if eval "test \"`echo '$''{'ac_cv_type_bits16_t'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 4810 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
--- 4809,4818 ----
  if test "$ac_cv_sizeof_short" = 2; then
    echo $ac_n "checking for bits16_t""... $ac_c" 1>&6
! echo "configure:4812: checking for bits16_t" >&5
  if eval "test \"`echo '$''{'ac_cv_type_bits16_t'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 4817 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
***************
*** 4836,4845 ****
  elif test "$ac_cv_sizeof_char" = 2; then
    echo $ac_n "checking for bits16_t""... $ac_c" 1>&6
! echo "configure:4839: checking for bits16_t" >&5
  if eval "test \"`echo '$''{'ac_cv_type_bits16_t'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 4844 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
--- 4843,4852 ----
  elif test "$ac_cv_sizeof_char" = 2; then
    echo $ac_n "checking for bits16_t""... $ac_c" 1>&6
! echo "configure:4846: checking for bits16_t" >&5
  if eval "test \"`echo '$''{'ac_cv_type_bits16_t'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 4851 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
***************
*** 4870,4879 ****
  else
    echo $ac_n "checking for bits16_t""... $ac_c" 1>&6
! echo "configure:4873: checking for bits16_t" >&5
  if eval "test \"`echo '$''{'ac_cv_type_bits16_t'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 4878 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
--- 4877,4886 ----
  else
    echo $ac_n "checking for bits16_t""... $ac_c" 1>&6
! echo "configure:4880: checking for bits16_t" >&5
  if eval "test \"`echo '$''{'ac_cv_type_bits16_t'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 4885 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
***************
*** 4907,4916 ****
  if test "$ac_cv_sizeof_short" = 2; then
    echo $ac_n "checking for u_bits16_t""... $ac_c" 1>&6
! echo "configure:4910: checking for u_bits16_t" >&5
  if eval "test \"`echo '$''{'ac_cv_type_u_bits16_t'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 4915 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
--- 4914,4923 ----
  if test "$ac_cv_sizeof_short" = 2; then
    echo $ac_n "checking for u_bits16_t""... $ac_c" 1>&6
! echo "configure:4917: checking for u_bits16_t" >&5
  if eval "test \"`echo '$''{'ac_cv_type_u_bits16_t'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 4922 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
***************
*** 4941,4950 ****
  elif test "$ac_cv_sizeof_char" = 2; then
    echo $ac_n "checking for u_bits16_t""... $ac_c" 1>&6
! echo "configure:4944: checking for u_bits16_t" >&5
  if eval "test \"`echo '$''{'ac_cv_type_u_bits16_t'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 4949 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
--- 4948,4957 ----
  elif test "$ac_cv_sizeof_char" = 2; then
    echo $ac_n "checking for u_bits16_t""... $ac_c" 1>&6
! echo "configure:4951: checking for u_bits16_t" >&5
  if eval "test \"`echo '$''{'ac_cv_type_u_bits16_t'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 4956 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
***************
*** 4975,4984 ****
  else
    echo $ac_n "checking for u_bits16_t""... $ac_c" 1>&6
! echo "configure:4978: checking for u_bits16_t" >&5
  if eval "test \"`echo '$''{'ac_cv_type_u_bits16_t'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 4983 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
--- 4982,4991 ----
  else
    echo $ac_n "checking for u_bits16_t""... $ac_c" 1>&6
! echo "configure:4985: checking for u_bits16_t" >&5
  if eval "test \"`echo '$''{'ac_cv_type_u_bits16_t'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 4990 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
***************
*** 5012,5021 ****
  if test "$ac_cv_sizeof_int" = 4; then
    echo $ac_n "checking for bits32_t""... $ac_c" 1>&6
! echo "configure:5015: checking for bits32_t" >&5
  if eval "test \"`echo '$''{'ac_cv_type_bits32_t'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 5020 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
--- 5019,5028 ----
  if test "$ac_cv_sizeof_int" = 4; then
    echo $ac_n "checking for bits32_t""... $ac_c" 1>&6
! echo "configure:5022: checking for bits32_t" >&5
  if eval "test \"`echo '$''{'ac_cv_type_bits32_t'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 5027 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
***************
*** 5046,5055 ****
  elif test "$ac_cv_sizeof_long" = 4; then
    echo $ac_n "checking for bits32_t""... $ac_c" 1>&6
! echo "configure:5049: checking for bits32_t" >&5
  if eval "test \"`echo '$''{'ac_cv_type_bits32_t'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 5054 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
--- 5053,5062 ----
  elif test "$ac_cv_sizeof_long" = 4; then
    echo $ac_n "checking for bits32_t""... $ac_c" 1>&6
! echo "configure:5056: checking for bits32_t" >&5
  if eval "test \"`echo '$''{'ac_cv_type_bits32_t'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 5061 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
***************
*** 5080,5089 ****
  else
    echo $ac_n "checking for bits32_t""... $ac_c" 1>&6
! echo "configure:5083: checking for bits32_t" >&5
  if eval "test \"`echo '$''{'ac_cv_type_bits32_t'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 5088 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
--- 5087,5096 ----
  else
    echo $ac_n "checking for bits32_t""... $ac_c" 1>&6
! echo "configure:5090: checking for bits32_t" >&5
  if eval "test \"`echo '$''{'ac_cv_type_bits32_t'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 5095 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
***************
*** 5117,5126 ****
  if test "$ac_cv_sizeof_int" = 4; then
    echo $ac_n "checking for u_bits32_t""... $ac_c" 1>&6
! echo "configure:5120: checking for u_bits32_t" >&5
  if eval "test \"`echo '$''{'ac_cv_type_u_bits32_t'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 5125 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
--- 5124,5133 ----
  if test "$ac_cv_sizeof_int" = 4; then
    echo $ac_n "checking for u_bits32_t""... $ac_c" 1>&6
! echo "configure:5127: checking for u_bits32_t" >&5
  if eval "test \"`echo '$''{'ac_cv_type_u_bits32_t'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 5132 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
***************
*** 5151,5160 ****
  elif test "$ac_cv_sizeof_long" = 4; then
    echo $ac_n "checking for u_bits32_t""... $ac_c" 1>&6
! echo "configure:5154: checking for u_bits32_t" >&5
  if eval "test \"`echo '$''{'ac_cv_type_u_bits32_t'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 5159 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
--- 5158,5167 ----
  elif test "$ac_cv_sizeof_long" = 4; then
    echo $ac_n "checking for u_bits32_t""... $ac_c" 1>&6
! echo "configure:5161: checking for u_bits32_t" >&5
  if eval "test \"`echo '$''{'ac_cv_type_u_bits32_t'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 5166 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
***************
*** 5185,5194 ****
  else
    echo $ac_n "checking for u_bits32_t""... $ac_c" 1>&6
! echo "configure:5188: checking for u_bits32_t" >&5
  if eval "test \"`echo '$''{'ac_cv_type_u_bits32_t'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 5193 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
--- 5192,5201 ----
  else
    echo $ac_n "checking for u_bits32_t""... $ac_c" 1>&6
! echo "configure:5195: checking for u_bits32_t" >&5
  if eval "test \"`echo '$''{'ac_cv_type_u_bits32_t'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 5200 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
***************
*** 5222,5231 ****
  if test "$ac_sv_sizeof_char_p" = 8; then
    echo $ac_n "checking for bits64_t""... $ac_c" 1>&6
! echo "configure:5225: checking for bits64_t" >&5
  if eval "test \"`echo '$''{'ac_cv_type_bits64_t'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 5230 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
--- 5229,5238 ----
  if test "$ac_sv_sizeof_char_p" = 8; then
    echo $ac_n "checking for bits64_t""... $ac_c" 1>&6
! echo "configure:5232: checking for bits64_t" >&5
  if eval "test \"`echo '$''{'ac_cv_type_bits64_t'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 5237 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
***************
*** 5256,5265 ****
  elif test "$ac_cv_sizeof_double" = 8; then
    echo $ac_n "checking for bits64_t""... $ac_c" 1>&6
! echo "configure:5259: checking for bits64_t" >&5
  if eval "test \"`echo '$''{'ac_cv_type_bits64_t'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 5264 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
--- 5263,5272 ----
  elif test "$ac_cv_sizeof_double" = 8; then
    echo $ac_n "checking for bits64_t""... $ac_c" 1>&6
! echo "configure:5266: checking for bits64_t" >&5
  if eval "test \"`echo '$''{'ac_cv_type_bits64_t'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 5271 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
***************
*** 5290,5299 ****
  elif test "$ac_cv_sizeof_long" = 8; then
    echo $ac_n "checking for bits64_t""... $ac_c" 1>&6
! echo "configure:5293: checking for bits64_t" >&5
  if eval "test \"`echo '$''{'ac_cv_type_bits64_t'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 5298 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
--- 5297,5306 ----
  elif test "$ac_cv_sizeof_long" = 8; then
    echo $ac_n "checking for bits64_t""... $ac_c" 1>&6
! echo "configure:5300: checking for bits64_t" >&5
  if eval "test \"`echo '$''{'ac_cv_type_bits64_t'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 5305 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
***************
*** 5324,5333 ****
  else
    echo $ac_n "checking for bits64_t""... $ac_c" 1>&6
! echo "configure:5327: checking for bits64_t" >&5
  if eval "test \"`echo '$''{'ac_cv_type_bits64_t'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 5332 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
--- 5331,5340 ----
  else
    echo $ac_n "checking for bits64_t""... $ac_c" 1>&6
! echo "configure:5334: checking for bits64_t" >&5
  if eval "test \"`echo '$''{'ac_cv_type_bits64_t'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 5339 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
***************
*** 5362,5371 ****
  if test "$ac_cv_sizeof_int" = "$ac_cv_sizeof_char_p"; then
    echo $ac_n "checking for ptrdiff_t""... $ac_c" 1>&6
! echo "configure:5365: checking for ptrdiff_t" >&5
  if eval "test \"`echo '$''{'ac_cv_type_ptrdiff_t'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 5370 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
--- 5369,5378 ----
  if test "$ac_cv_sizeof_int" = "$ac_cv_sizeof_char_p"; then
    echo $ac_n "checking for ptrdiff_t""... $ac_c" 1>&6
! echo "configure:5372: checking for ptrdiff_t" >&5
  if eval "test \"`echo '$''{'ac_cv_type_ptrdiff_t'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 5377 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
***************
*** 5396,5405 ****
  elif test "$ac_cv_sizeof_long" = "$ac_cv_sizeof_char_p"; then
    echo $ac_n "checking for ptrdiff_t""... $ac_c" 1>&6
! echo "configure:5399: checking for ptrdiff_t" >&5
  if eval "test \"`echo '$''{'ac_cv_type_ptrdiff_t'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 5404 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
--- 5403,5412 ----
  elif test "$ac_cv_sizeof_long" = "$ac_cv_sizeof_char_p"; then
    echo $ac_n "checking for ptrdiff_t""... $ac_c" 1>&6
! echo "configure:5406: checking for ptrdiff_t" >&5
  if eval "test \"`echo '$''{'ac_cv_type_ptrdiff_t'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 5411 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
***************
*** 5430,5439 ****
  else
    echo $ac_n "checking for ptrdiff_t""... $ac_c" 1>&6
! echo "configure:5433: checking for ptrdiff_t" >&5
  if eval "test \"`echo '$''{'ac_cv_type_ptrdiff_t'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 5438 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
--- 5437,5446 ----
  else
    echo $ac_n "checking for ptrdiff_t""... $ac_c" 1>&6
! echo "configure:5440: checking for ptrdiff_t" >&5
  if eval "test \"`echo '$''{'ac_cv_type_ptrdiff_t'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 5445 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
***************
*** 5466,5475 ****
  
  echo $ac_n "checking whether stat file-mode macros are broken""... $ac_c" 1>&6
! echo "configure:5469: checking whether stat file-mode macros are broken" >&5
  if eval "test \"`echo '$''{'ac_cv_header_stat_broken'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 5474 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
--- 5473,5482 ----
  
  echo $ac_n "checking whether stat file-mode macros are broken""... $ac_c" 1>&6
! echo "configure:5476: checking whether stat file-mode macros are broken" >&5
  if eval "test \"`echo '$''{'ac_cv_header_stat_broken'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 5481 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
***************
*** 5523,5527 ****
  
  echo $ac_n "checking whether byte ordering is bigendian""... $ac_c" 1>&6
! echo "configure:5526: checking whether byte ordering is bigendian" >&5
  if eval "test \"`echo '$''{'ac_cv_c_bigendian'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
--- 5530,5534 ----
  
  echo $ac_n "checking whether byte ordering is bigendian""... $ac_c" 1>&6
! echo "configure:5533: checking whether byte ordering is bigendian" >&5
  if eval "test \"`echo '$''{'ac_cv_c_bigendian'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
***************
*** 5530,5534 ****
  # See if sys/param.h defines the BYTE_ORDER macro.
  cat > conftest.$ac_ext <<EOF
! #line 5533 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
--- 5537,5541 ----
  # See if sys/param.h defines the BYTE_ORDER macro.
  cat > conftest.$ac_ext <<EOF
! #line 5540 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
***************
*** 5541,5549 ****
  ; return 0; }
  EOF
! if { (eval echo configure:5544: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
    rm -rf conftest*
    # It does; now see whether it defined to BIG_ENDIAN or not.
  cat > conftest.$ac_ext <<EOF
! #line 5548 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
--- 5548,5556 ----
  ; return 0; }
  EOF
! if { (eval echo configure:5551: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
    rm -rf conftest*
    # It does; now see whether it defined to BIG_ENDIAN or not.
  cat > conftest.$ac_ext <<EOF
! #line 5555 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
***************
*** 5556,5560 ****
  ; return 0; }
  EOF
! if { (eval echo configure:5559: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
    rm -rf conftest*
    ac_cv_c_bigendian=yes
--- 5563,5567 ----
  ; return 0; }
  EOF
! if { (eval echo configure:5566: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
    rm -rf conftest*
    ac_cv_c_bigendian=yes
***************
*** 5576,5580 ****
  else
    cat > conftest.$ac_ext <<EOF
! #line 5579 "configure"
  #include "confdefs.h"
  main () {
--- 5583,5587 ----
  else
    cat > conftest.$ac_ext <<EOF
! #line 5586 "configure"
  #include "confdefs.h"
  main () {
***************
*** 5589,5593 ****
  }
  EOF
! if { (eval echo configure:5592: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
  then
    ac_cv_c_bigendian=no
--- 5596,5600 ----
  }
  EOF
! if { (eval echo configure:5599: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
  then
    ac_cv_c_bigendian=no
***************
*** 5616,5620 ****
  ac_msg="whether #! works in shell scripts"
  echo $ac_n "checking $ac_msg""... $ac_c" 1>&6
! echo "configure:5619: checking $ac_msg" >&5
  if eval "test \"`echo '$''{'ac_cv_sys_interpreter'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
--- 5623,5627 ----
  ac_msg="whether #! works in shell scripts"
  echo $ac_n "checking $ac_msg""... $ac_c" 1>&6
! echo "configure:5626: checking $ac_msg" >&5
  if eval "test \"`echo '$''{'ac_cv_sys_interpreter'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
***************
*** 5643,5647 ****
  fi
  echo $ac_n "checking for restartable system calls""... $ac_c" 1>&6
! echo "configure:5646: checking for restartable system calls" >&5
  if eval "test \"`echo '$''{'ac_cv_sys_restartable_syscalls'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
--- 5650,5654 ----
  fi
  echo $ac_n "checking for restartable system calls""... $ac_c" 1>&6
! echo "configure:5653: checking for restartable system calls" >&5
  if eval "test \"`echo '$''{'ac_cv_sys_restartable_syscalls'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
***************
*** 5651,5655 ****
  else
    cat > conftest.$ac_ext <<EOF
! #line 5654 "configure"
  #include "confdefs.h"
  /* Exit 0 (true) if wait returns something other than -1,
--- 5658,5662 ----
  else
    cat > conftest.$ac_ext <<EOF
! #line 5661 "configure"
  #include "confdefs.h"
  /* Exit 0 (true) if wait returns something other than -1,
***************
*** 5669,5673 ****
  
  EOF
! if { (eval echo configure:5672: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
  then
    ac_cv_sys_restartable_syscalls=yes
--- 5676,5680 ----
  
  EOF
! if { (eval echo configure:5679: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
  then
    ac_cv_sys_restartable_syscalls=yes
***************
*** 5694,5703 ****
  if test "$ac_cv_func_lstat" = "no"; then
  echo $ac_n "checking for lstat""... $ac_c" 1>&6
! echo "configure:5697: checking for lstat" >&5
  if eval "test \"`echo '$''{'bash_cv_func_lstat'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 5702 "configure"
  #include "confdefs.h"
  
--- 5701,5710 ----
  if test "$ac_cv_func_lstat" = "no"; then
  echo $ac_n "checking for lstat""... $ac_c" 1>&6
! echo "configure:5704: checking for lstat" >&5
  if eval "test \"`echo '$''{'bash_cv_func_lstat'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 5709 "configure"
  #include "confdefs.h"
  
***************
*** 5709,5713 ****
  ; return 0; }
  EOF
! if { (eval echo configure:5712: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    bash_cv_func_lstat=yes
--- 5716,5720 ----
  ; return 0; }
  EOF
! if { (eval echo configure:5719: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    bash_cv_func_lstat=yes
***************
*** 5732,5736 ****
  
  echo $ac_n "checking if dup2 fails to clear the close-on-exec flag""... $ac_c" 1>&6
! echo "configure:5735: checking if dup2 fails to clear the close-on-exec flag" >&5
  if eval "test \"`echo '$''{'bash_cv_dup2_broken'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
--- 5739,5743 ----
  
  echo $ac_n "checking if dup2 fails to clear the close-on-exec flag""... $ac_c" 1>&6
! echo "configure:5742: checking if dup2 fails to clear the close-on-exec flag" >&5
  if eval "test \"`echo '$''{'bash_cv_dup2_broken'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
***************
*** 5741,5745 ****
  else
    cat > conftest.$ac_ext <<EOF
! #line 5744 "configure"
  #include "confdefs.h"
  
--- 5748,5752 ----
  else
    cat > conftest.$ac_ext <<EOF
! #line 5751 "configure"
  #include "confdefs.h"
  
***************
*** 5761,5765 ****
  
  EOF
! if { (eval echo configure:5764: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
  then
    bash_cv_dup2_broken=yes
--- 5768,5772 ----
  
  EOF
! if { (eval echo configure:5771: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
  then
    bash_cv_dup2_broken=yes
***************
*** 5786,5790 ****
  
  echo $ac_n "checking whether pgrps need synchronization""... $ac_c" 1>&6
! echo "configure:5789: checking whether pgrps need synchronization" >&5
  if eval "test \"`echo '$''{'bash_cv_pgrp_pipe'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
--- 5793,5797 ----
  
  echo $ac_n "checking whether pgrps need synchronization""... $ac_c" 1>&6
! echo "configure:5796: checking whether pgrps need synchronization" >&5
  if eval "test \"`echo '$''{'bash_cv_pgrp_pipe'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
***************
*** 5795,5799 ****
  else
    cat > conftest.$ac_ext <<EOF
! #line 5798 "configure"
  #include "confdefs.h"
  
--- 5802,5806 ----
  else
    cat > conftest.$ac_ext <<EOF
! #line 5805 "configure"
  #include "confdefs.h"
  
***************
*** 5847,5851 ****
  
  EOF
! if { (eval echo configure:5850: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
  then
    bash_cv_pgrp_pipe=no
--- 5854,5858 ----
  
  EOF
! if { (eval echo configure:5857: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
  then
    bash_cv_pgrp_pipe=no
***************
*** 5872,5876 ****
  
  echo $ac_n "checking for type of signal functions""... $ac_c" 1>&6
! echo "configure:5875: checking for type of signal functions" >&5
  if eval "test \"`echo '$''{'bash_cv_signal_vintage'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
--- 5879,5883 ----
  
  echo $ac_n "checking for type of signal functions""... $ac_c" 1>&6
! echo "configure:5882: checking for type of signal functions" >&5
  if eval "test \"`echo '$''{'bash_cv_signal_vintage'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
***************
*** 5878,5882 ****
    
    cat > conftest.$ac_ext <<EOF
! #line 5881 "configure"
  #include "confdefs.h"
  #include <signal.h>
--- 5885,5889 ----
    
    cat > conftest.$ac_ext <<EOF
! #line 5888 "configure"
  #include "confdefs.h"
  #include <signal.h>
***************
*** 5891,5895 ****
  ; return 0; }
  EOF
! if { (eval echo configure:5894: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    bash_cv_signal_vintage=posix
--- 5898,5902 ----
  ; return 0; }
  EOF
! if { (eval echo configure:5901: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    bash_cv_signal_vintage=posix
***************
*** 5900,5904 ****
    
      cat > conftest.$ac_ext <<EOF
! #line 5903 "configure"
  #include "confdefs.h"
  #include <signal.h>
--- 5907,5911 ----
    
      cat > conftest.$ac_ext <<EOF
! #line 5910 "configure"
  #include "confdefs.h"
  #include <signal.h>
***************
*** 5910,5914 ****
  ; return 0; }
  EOF
! if { (eval echo configure:5913: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    bash_cv_signal_vintage=4.2bsd
--- 5917,5921 ----
  ; return 0; }
  EOF
! if { (eval echo configure:5920: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    bash_cv_signal_vintage=4.2bsd
***************
*** 5919,5923 ****
    
        cat > conftest.$ac_ext <<EOF
! #line 5922 "configure"
  #include "confdefs.h"
  
--- 5926,5930 ----
    
        cat > conftest.$ac_ext <<EOF
! #line 5929 "configure"
  #include "confdefs.h"
  
***************
*** 5932,5936 ****
  ; return 0; }
  EOF
! if { (eval echo configure:5935: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    bash_cv_signal_vintage=svr3
--- 5939,5943 ----
  ; return 0; }
  EOF
! if { (eval echo configure:5942: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    bash_cv_signal_vintage=svr3
***************
*** 5973,5978 ****
  if test "$ac_cv_sys_restartable_syscalls" = "no"; then
  
! echo $ac_n "checking for restartable system calls with posix sigaction""... $ac_c" 1>&6
! echo "configure:5977: checking for restartable system calls with posix sigaction" >&5
  if eval "test \"`echo '$''{'bash_cv_sys_restartable_syscalls'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
--- 5980,5985 ----
  if test "$ac_cv_sys_restartable_syscalls" = "no"; then
  
! echo $ac_n "checking whether posix sigaction restarts system calls by default""... $ac_c" 1>&6
! echo "configure:5984: checking whether posix sigaction restarts system calls by default" >&5
  if eval "test \"`echo '$''{'bash_cv_sys_restartable_syscalls'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
***************
*** 5982,5990 ****
  else
    cat > conftest.$ac_ext <<EOF
! #line 5985 "configure"
  #include "confdefs.h"
  /* Exit 0 (true) if wait returns something other than -1,
     i.e. the pid of the child, which means that wait was restarted
     after getting the signal.  */
  #include <sys/types.h>
  #include <signal.h>
--- 5989,6000 ----
  else
    cat > conftest.$ac_ext <<EOF
! #line 5992 "configure"
  #include "confdefs.h"
  /* Exit 0 (true) if wait returns something other than -1,
     i.e. the pid of the child, which means that wait was restarted
     after getting the signal.  */
+ #ifdef HAVE_UNISTD_H
+ #  include <unistd.h>
+ #endif
  #include <sys/types.h>
  #include <signal.h>
***************
*** 6016,6020 ****
  
  EOF
! if { (eval echo configure:6019: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
  then
    bash_cv_sys_restartable_syscalls=yes
--- 6026,6030 ----
  
  EOF
! if { (eval echo configure:6029: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
  then
    bash_cv_sys_restartable_syscalls=yes
***************
*** 6042,6051 ****
  
  echo $ac_n "checking for sys_errlist and sys_nerr""... $ac_c" 1>&6
! echo "configure:6045: checking for sys_errlist and sys_nerr" >&5
  if eval "test \"`echo '$''{'bash_cv_sys_errlist'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 6050 "configure"
  #include "confdefs.h"
  #include <errno.h>
--- 6052,6061 ----
  
  echo $ac_n "checking for sys_errlist and sys_nerr""... $ac_c" 1>&6
! echo "configure:6055: checking for sys_errlist and sys_nerr" >&5
  if eval "test \"`echo '$''{'bash_cv_sys_errlist'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 6060 "configure"
  #include "confdefs.h"
  #include <errno.h>
***************
*** 6056,6060 ****
  ; return 0; }
  EOF
! if { (eval echo configure:6059: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    bash_cv_sys_errlist=yes
--- 6066,6070 ----
  ; return 0; }
  EOF
! if { (eval echo configure:6069: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    bash_cv_sys_errlist=yes
***************
*** 6077,6081 ****
  
  echo $ac_n "checking for sys_siglist in system C library""... $ac_c" 1>&6
! echo "configure:6080: checking for sys_siglist in system C library" >&5
  if eval "test \"`echo '$''{'bash_cv_sys_siglist'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
--- 6087,6091 ----
  
  echo $ac_n "checking for sys_siglist in system C library""... $ac_c" 1>&6
! echo "configure:6090: checking for sys_siglist in system C library" >&5
  if eval "test \"`echo '$''{'bash_cv_sys_siglist'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
***************
*** 6086,6090 ****
  else
    cat > conftest.$ac_ext <<EOF
! #line 6089 "configure"
  #include "confdefs.h"
  
--- 6096,6100 ----
  else
    cat > conftest.$ac_ext <<EOF
! #line 6099 "configure"
  #include "confdefs.h"
  
***************
*** 6103,6107 ****
  }
  EOF
! if { (eval echo configure:6106: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
  then
    bash_cv_sys_siglist=yes
--- 6113,6117 ----
  }
  EOF
! if { (eval echo configure:6116: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
  then
    bash_cv_sys_siglist=yes
***************
*** 6126,6135 ****
  
  echo $ac_n "checking for _sys_siglist in signal.h or unistd.h""... $ac_c" 1>&6
! echo "configure:6129: checking for _sys_siglist in signal.h or unistd.h" >&5
  if eval "test \"`echo '$''{'bash_cv_decl_under_sys_siglist'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 6134 "configure"
  #include "confdefs.h"
  
--- 6136,6145 ----
  
  echo $ac_n "checking for _sys_siglist in signal.h or unistd.h""... $ac_c" 1>&6
! echo "configure:6139: checking for _sys_siglist in signal.h or unistd.h" >&5
  if eval "test \"`echo '$''{'bash_cv_decl_under_sys_siglist'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 6144 "configure"
  #include "confdefs.h"
  
***************
*** 6143,6147 ****
  ; return 0; }
  EOF
! if { (eval echo configure:6146: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
    rm -rf conftest*
    bash_cv_decl_under_sys_siglist=yes
--- 6153,6157 ----
  ; return 0; }
  EOF
! if { (eval echo configure:6156: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
    rm -rf conftest*
    bash_cv_decl_under_sys_siglist=yes
***************
*** 6164,6168 ****
  
  echo $ac_n "checking for _sys_siglist in system C library""... $ac_c" 1>&6
! echo "configure:6167: checking for _sys_siglist in system C library" >&5
  if eval "test \"`echo '$''{'bash_cv_under_sys_siglist'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
--- 6174,6178 ----
  
  echo $ac_n "checking for _sys_siglist in system C library""... $ac_c" 1>&6
! echo "configure:6177: checking for _sys_siglist in system C library" >&5
  if eval "test \"`echo '$''{'bash_cv_under_sys_siglist'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
***************
*** 6173,6177 ****
  else
    cat > conftest.$ac_ext <<EOF
! #line 6176 "configure"
  #include "confdefs.h"
  
--- 6183,6187 ----
  else
    cat > conftest.$ac_ext <<EOF
! #line 6186 "configure"
  #include "confdefs.h"
  
***************
*** 6190,6194 ****
  }
  EOF
! if { (eval echo configure:6193: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
  then
    bash_cv_under_sys_siglist=yes
--- 6200,6204 ----
  }
  EOF
! if { (eval echo configure:6203: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
  then
    bash_cv_under_sys_siglist=yes
***************
*** 6214,6223 ****
  
  echo $ac_n "checking whether signal handlers are of type void""... $ac_c" 1>&6
! echo "configure:6217: checking whether signal handlers are of type void" >&5
  if eval "test \"`echo '$''{'bash_cv_void_sighandler'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 6222 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
--- 6224,6233 ----
  
  echo $ac_n "checking whether signal handlers are of type void""... $ac_c" 1>&6
! echo "configure:6227: checking whether signal handlers are of type void" >&5
  if eval "test \"`echo '$''{'bash_cv_void_sighandler'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 6232 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
***************
*** 6234,6238 ****
  ; return 0; }
  EOF
! if { (eval echo configure:6237: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
    rm -rf conftest*
    bash_cv_void_sighandler=yes
--- 6244,6248 ----
  ; return 0; }
  EOF
! if { (eval echo configure:6247: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
    rm -rf conftest*
    bash_cv_void_sighandler=yes
***************
*** 6254,6263 ****
  
  echo $ac_n "checking for clock_t""... $ac_c" 1>&6
! echo "configure:6257: checking for clock_t" >&5
  if eval "test \"`echo '$''{'bash_cv_type_clock_t'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 6262 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
--- 6264,6273 ----
  
  echo $ac_n "checking for clock_t""... $ac_c" 1>&6
! echo "configure:6267: checking for clock_t" >&5
  if eval "test \"`echo '$''{'bash_cv_type_clock_t'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 6272 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
***************
*** 6290,6299 ****
  
  echo $ac_n "checking for sigset_t""... $ac_c" 1>&6
! echo "configure:6293: checking for sigset_t" >&5
  if eval "test \"`echo '$''{'bash_cv_type_sigset_t'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 6298 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
--- 6300,6309 ----
  
  echo $ac_n "checking for sigset_t""... $ac_c" 1>&6
! echo "configure:6303: checking for sigset_t" >&5
  if eval "test \"`echo '$''{'bash_cv_type_sigset_t'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 6308 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
***************
*** 6326,6335 ****
  
  echo $ac_n "checking for quad_t""... $ac_c" 1>&6
! echo "configure:6329: checking for quad_t" >&5
  if eval "test \"`echo '$''{'bash_cv_type_quad_t'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 6334 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
--- 6336,6345 ----
  
  echo $ac_n "checking for quad_t""... $ac_c" 1>&6
! echo "configure:6339: checking for quad_t" >&5
  if eval "test \"`echo '$''{'bash_cv_type_quad_t'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 6344 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
***************
*** 6367,6376 ****
  
  echo $ac_n "checking for size and type of struct rlimit fields""... $ac_c" 1>&6
! echo "configure:6370: checking for size and type of struct rlimit fields" >&5
  if eval "test \"`echo '$''{'bash_cv_type_rlimit'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 6375 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
--- 6377,6386 ----
  
  echo $ac_n "checking for size and type of struct rlimit fields""... $ac_c" 1>&6
! echo "configure:6380: checking for size and type of struct rlimit fields" >&5
  if eval "test \"`echo '$''{'bash_cv_type_rlimit'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 6385 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
***************
*** 6380,6384 ****
  ; return 0; }
  EOF
! if { (eval echo configure:6383: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
    rm -rf conftest*
    bash_cv_type_rlimit=rlim_t
--- 6390,6394 ----
  ; return 0; }
  EOF
! if { (eval echo configure:6393: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
    rm -rf conftest*
    bash_cv_type_rlimit=rlim_t
***************
*** 6393,6397 ****
  else
    cat > conftest.$ac_ext <<EOF
! #line 6396 "configure"
  #include "confdefs.h"
  
--- 6403,6407 ----
  else
    cat > conftest.$ac_ext <<EOF
! #line 6406 "configure"
  #include "confdefs.h"
  
***************
*** 6409,6413 ****
  }
  EOF
! if { (eval echo configure:6412: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
  then
    bash_cv_type_rlimit=quad_t
--- 6419,6423 ----
  }
  EOF
! if { (eval echo configure:6422: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
  then
    bash_cv_type_rlimit=quad_t
***************
*** 6441,6450 ****
  
  echo $ac_n "checking for a c_line member of struct termios""... $ac_c" 1>&6
! echo "configure:6444: checking for a c_line member of struct termios" >&5
  if eval "test \"`echo '$''{'bash_cv_termios_ldisc'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 6449 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
--- 6451,6460 ----
  
  echo $ac_n "checking for a c_line member of struct termios""... $ac_c" 1>&6
! echo "configure:6454: checking for a c_line member of struct termios" >&5
  if eval "test \"`echo '$''{'bash_cv_termios_ldisc'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 6459 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
***************
*** 6454,6458 ****
  ; return 0; }
  EOF
! if { (eval echo configure:6457: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
    rm -rf conftest*
    bash_cv_termios_ldisc=yes
--- 6464,6468 ----
  ; return 0; }
  EOF
! if { (eval echo configure:6467: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
    rm -rf conftest*
    bash_cv_termios_ldisc=yes
***************
*** 6474,6483 ****
  
  echo $ac_n "checking for a c_line member of struct termio""... $ac_c" 1>&6
! echo "configure:6477: checking for a c_line member of struct termio" >&5
  if eval "test \"`echo '$''{'bash_cv_termio_ldisc'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 6482 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
--- 6484,6493 ----
  
  echo $ac_n "checking for a c_line member of struct termio""... $ac_c" 1>&6
! echo "configure:6487: checking for a c_line member of struct termio" >&5
  if eval "test \"`echo '$''{'bash_cv_termio_ldisc'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 6492 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
***************
*** 6487,6491 ****
  ; return 0; }
  EOF
! if { (eval echo configure:6490: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
    rm -rf conftest*
    bash_cv_termio_ldisc=yes
--- 6497,6501 ----
  ; return 0; }
  EOF
! if { (eval echo configure:6500: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
    rm -rf conftest*
    bash_cv_termio_ldisc=yes
***************
*** 6508,6517 ****
  
  echo $ac_n "checking if struct dirent has a d_ino member""... $ac_c" 1>&6
! echo "configure:6511: checking if struct dirent has a d_ino member" >&5
  if eval "test \"`echo '$''{'bash_cv_dirent_has_dino'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 6516 "configure"
  #include "confdefs.h"
  
--- 6518,6527 ----
  
  echo $ac_n "checking if struct dirent has a d_ino member""... $ac_c" 1>&6
! echo "configure:6521: checking if struct dirent has a d_ino member" >&5
  if eval "test \"`echo '$''{'bash_cv_dirent_has_dino'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 6526 "configure"
  #include "confdefs.h"
  
***************
*** 6542,6546 ****
  ; return 0; }
  EOF
! if { (eval echo configure:6545: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
    rm -rf conftest*
    bash_cv_dirent_has_dino=yes
--- 6552,6556 ----
  ; return 0; }
  EOF
! if { (eval echo configure:6555: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
    rm -rf conftest*
    bash_cv_dirent_has_dino=yes
***************
*** 6564,6573 ****
  
  echo $ac_n "checking if struct dirent has a d_fileno member""... $ac_c" 1>&6
! echo "configure:6567: checking if struct dirent has a d_fileno member" >&5
  if eval "test \"`echo '$''{'bash_cv_dirent_has_d_fileno'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 6572 "configure"
  #include "confdefs.h"
  
--- 6574,6583 ----
  
  echo $ac_n "checking if struct dirent has a d_fileno member""... $ac_c" 1>&6
! echo "configure:6577: checking if struct dirent has a d_fileno member" >&5
  if eval "test \"`echo '$''{'bash_cv_dirent_has_d_fileno'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 6582 "configure"
  #include "confdefs.h"
  
***************
*** 6598,6602 ****
  ; return 0; }
  EOF
! if { (eval echo configure:6601: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
    rm -rf conftest*
    bash_cv_dirent_has_d_fileno=yes
--- 6608,6612 ----
  ; return 0; }
  EOF
! if { (eval echo configure:6611: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
    rm -rf conftest*
    bash_cv_dirent_has_d_fileno=yes
***************
*** 6619,6628 ****
  
  echo $ac_n "checking for struct winsize in sys/ioctl.h and termios.h""... $ac_c" 1>&6
! echo "configure:6622: checking for struct winsize in sys/ioctl.h and termios.h" >&5
  if eval "test \"`echo '$''{'bash_cv_struct_winsize_header'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 6627 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
--- 6629,6638 ----
  
  echo $ac_n "checking for struct winsize in sys/ioctl.h and termios.h""... $ac_c" 1>&6
! echo "configure:6632: checking for struct winsize in sys/ioctl.h and termios.h" >&5
  if eval "test \"`echo '$''{'bash_cv_struct_winsize_header'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 6637 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
***************
*** 6632,6636 ****
  ; return 0; }
  EOF
! if { (eval echo configure:6635: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
    rm -rf conftest*
    bash_cv_struct_winsize_header=ioctl_h
--- 6642,6646 ----
  ; return 0; }
  EOF
! if { (eval echo configure:6645: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
    rm -rf conftest*
    bash_cv_struct_winsize_header=ioctl_h
***************
*** 6640,6644 ****
    rm -rf conftest*
    cat > conftest.$ac_ext <<EOF
! #line 6643 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
--- 6650,6654 ----
    rm -rf conftest*
    cat > conftest.$ac_ext <<EOF
! #line 6653 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
***************
*** 6648,6652 ****
  ; return 0; }
  EOF
! if { (eval echo configure:6651: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
    rm -rf conftest*
    bash_cv_struct_winsize_header=termios_h
--- 6658,6662 ----
  ; return 0; }
  EOF
! if { (eval echo configure:6661: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
    rm -rf conftest*
    bash_cv_struct_winsize_header=termios_h
***************
*** 6680,6684 ****
  
  echo $ac_n "checking for struct timeval in sys/time.h and time.h""... $ac_c" 1>&6
! echo "configure:6683: checking for struct timeval in sys/time.h and time.h" >&5
  if eval "test \"`echo '$''{'bash_cv_struct_timeval'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
--- 6690,6694 ----
  
  echo $ac_n "checking for struct timeval in sys/time.h and time.h""... $ac_c" 1>&6
! echo "configure:6693: checking for struct timeval in sys/time.h and time.h" >&5
  if eval "test \"`echo '$''{'bash_cv_struct_timeval'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
***************
*** 6686,6690 ****
    
  cat > conftest.$ac_ext <<EOF
! #line 6689 "configure"
  #include "confdefs.h"
  #include <sys/time.h>
--- 6696,6700 ----
    
  cat > conftest.$ac_ext <<EOF
! #line 6699 "configure"
  #include "confdefs.h"
  #include <sys/time.h>
***************
*** 6697,6701 ****
    rm -rf conftest*
    cat > conftest.$ac_ext <<EOF
! #line 6700 "configure"
  #include "confdefs.h"
  #include <time.h>
--- 6707,6711 ----
    rm -rf conftest*
    cat > conftest.$ac_ext <<EOF
! #line 6710 "configure"
  #include "confdefs.h"
  #include <time.h>
***************
*** 6727,6736 ****
  
  echo $ac_n "checking for the existence of strsignal""... $ac_c" 1>&6
! echo "configure:6730: checking for the existence of strsignal" >&5
  if eval "test \"`echo '$''{'bash_cv_have_strsignal'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 6735 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
--- 6737,6746 ----
  
  echo $ac_n "checking for the existence of strsignal""... $ac_c" 1>&6
! echo "configure:6740: checking for the existence of strsignal" >&5
  if eval "test \"`echo '$''{'bash_cv_have_strsignal'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 6745 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
***************
*** 6740,6744 ****
  ; return 0; }
  EOF
! if { (eval echo configure:6743: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    bash_cv_have_strsignal=yes
--- 6750,6754 ----
  ; return 0; }
  EOF
! if { (eval echo configure:6753: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    bash_cv_have_strsignal=yes
***************
*** 6761,6765 ****
  
  echo $ac_n "checking if opendir() opens non-directories""... $ac_c" 1>&6
! echo "configure:6764: checking if opendir() opens non-directories" >&5
  if eval "test \"`echo '$''{'bash_cv_opendir_not_robust'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
--- 6771,6775 ----
  
  echo $ac_n "checking if opendir() opens non-directories""... $ac_c" 1>&6
! echo "configure:6774: checking if opendir() opens non-directories" >&5
  if eval "test \"`echo '$''{'bash_cv_opendir_not_robust'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
***************
*** 6771,6775 ****
  else
    cat > conftest.$ac_ext <<EOF
! #line 6774 "configure"
  #include "confdefs.h"
  
--- 6781,6785 ----
  else
    cat > conftest.$ac_ext <<EOF
! #line 6784 "configure"
  #include "confdefs.h"
  
***************
*** 6813,6817 ****
  }
  EOF
! if { (eval echo configure:6816: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
  then
    bash_cv_opendir_not_robust=yes
--- 6823,6827 ----
  }
  EOF
! if { (eval echo configure:6826: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
  then
    bash_cv_opendir_not_robust=yes
***************
*** 6836,6840 ****
  
  echo $ac_n "checking for declaration of printf in <stdio.h>""... $ac_c" 1>&6
! echo "configure:6839: checking for declaration of printf in <stdio.h>" >&5
  if eval "test \"`echo '$''{'bash_cv_printf_declared'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
--- 6846,6850 ----
  
  echo $ac_n "checking for declaration of printf in <stdio.h>""... $ac_c" 1>&6
! echo "configure:6849: checking for declaration of printf in <stdio.h>" >&5
  if eval "test \"`echo '$''{'bash_cv_printf_declared'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
***************
*** 6846,6850 ****
  else
    cat > conftest.$ac_ext <<EOF
! #line 6849 "configure"
  #include "confdefs.h"
  
--- 6856,6860 ----
  else
    cat > conftest.$ac_ext <<EOF
! #line 6859 "configure"
  #include "confdefs.h"
  
***************
*** 6863,6867 ****
  
  EOF
! if { (eval echo configure:6866: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
  then
    bash_cv_printf_declared=yes
--- 6873,6877 ----
  
  EOF
! if { (eval echo configure:6876: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
  then
    bash_cv_printf_declared=yes
***************
*** 6886,6890 ****
  
  echo $ac_n "checking whether ulimit can substitute for getdtablesize""... $ac_c" 1>&6
! echo "configure:6889: checking whether ulimit can substitute for getdtablesize" >&5
  if eval "test \"`echo '$''{'bash_cv_ulimit_maxfds'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
--- 6896,6900 ----
  
  echo $ac_n "checking whether ulimit can substitute for getdtablesize""... $ac_c" 1>&6
! echo "configure:6899: checking whether ulimit can substitute for getdtablesize" >&5
  if eval "test \"`echo '$''{'bash_cv_ulimit_maxfds'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
***************
*** 6896,6900 ****
  else
    cat > conftest.$ac_ext <<EOF
! #line 6899 "configure"
  #include "confdefs.h"
  
--- 6906,6910 ----
  else
    cat > conftest.$ac_ext <<EOF
! #line 6909 "configure"
  #include "confdefs.h"
  
***************
*** 6906,6910 ****
  
  EOF
! if { (eval echo configure:6909: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
  then
    bash_cv_ulimit_maxfds=yes
--- 6916,6920 ----
  
  EOF
! if { (eval echo configure:6919: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
  then
    bash_cv_ulimit_maxfds=yes
***************
*** 6929,6933 ****
  
  echo $ac_n "checking to see if getenv can be redefined""... $ac_c" 1>&6
! echo "configure:6932: checking to see if getenv can be redefined" >&5
  if eval "test \"`echo '$''{'bash_cv_getenv_redef'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
--- 6939,6943 ----
  
  echo $ac_n "checking to see if getenv can be redefined""... $ac_c" 1>&6
! echo "configure:6942: checking to see if getenv can be redefined" >&5
  if eval "test \"`echo '$''{'bash_cv_getenv_redef'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
***************
*** 6939,6943 ****
  else
    cat > conftest.$ac_ext <<EOF
! #line 6942 "configure"
  #include "confdefs.h"
  
--- 6949,6953 ----
  else
    cat > conftest.$ac_ext <<EOF
! #line 6952 "configure"
  #include "confdefs.h"
  
***************
*** 6974,6978 ****
  
  EOF
! if { (eval echo configure:6977: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
  then
    bash_cv_getenv_redef=yes
--- 6984,6988 ----
  
  EOF
! if { (eval echo configure:6987: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
  then
    bash_cv_getenv_redef=yes
***************
*** 6997,7001 ****
  
  echo $ac_n "checking if getcwd() calls popen()""... $ac_c" 1>&6
! echo "configure:7000: checking if getcwd() calls popen()" >&5
  if eval "test \"`echo '$''{'bash_cv_getcwd_calls_popen'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
--- 7007,7011 ----
  
  echo $ac_n "checking if getcwd() calls popen()""... $ac_c" 1>&6
! echo "configure:7010: checking if getcwd() calls popen()" >&5
  if eval "test \"`echo '$''{'bash_cv_getcwd_calls_popen'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
***************
*** 7007,7011 ****
  else
    cat > conftest.$ac_ext <<EOF
! #line 7010 "configure"
  #include "confdefs.h"
  
--- 7017,7021 ----
  else
    cat > conftest.$ac_ext <<EOF
! #line 7020 "configure"
  #include "confdefs.h"
  
***************
*** 7062,7066 ****
  
  EOF
! if { (eval echo configure:7065: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
  then
    bash_cv_getcwd_calls_popen=no
--- 7072,7076 ----
  
  EOF
! if { (eval echo configure:7075: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
  then
    bash_cv_getcwd_calls_popen=no
***************
*** 7085,7094 ****
  
  echo $ac_n "checking for declaration of sbrk in <unistd.h>""... $ac_c" 1>&6
! echo "configure:7088: checking for declaration of sbrk in <unistd.h>" >&5
  if eval "test \"`echo '$''{'bash_cv_sbrk_declared'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 7093 "configure"
  #include "confdefs.h"
  #include <unistd.h>
--- 7095,7104 ----
  
  echo $ac_n "checking for declaration of sbrk in <unistd.h>""... $ac_c" 1>&6
! echo "configure:7098: checking for declaration of sbrk in <unistd.h>" >&5
  if eval "test \"`echo '$''{'bash_cv_sbrk_declared'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 7103 "configure"
  #include "confdefs.h"
  #include <unistd.h>
***************
*** 7116,7120 ****
  
  echo $ac_n "checking for presence of POSIX-style sigsetjmp/siglongjmp""... $ac_c" 1>&6
! echo "configure:7119: checking for presence of POSIX-style sigsetjmp/siglongjmp" >&5
  if eval "test \"`echo '$''{'bash_cv_func_sigsetjmp'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
--- 7126,7130 ----
  
  echo $ac_n "checking for presence of POSIX-style sigsetjmp/siglongjmp""... $ac_c" 1>&6
! echo "configure:7129: checking for presence of POSIX-style sigsetjmp/siglongjmp" >&5
  if eval "test \"`echo '$''{'bash_cv_func_sigsetjmp'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
***************
*** 7126,7130 ****
  else
    cat > conftest.$ac_ext <<EOF
! #line 7129 "configure"
  #include "confdefs.h"
  
--- 7136,7140 ----
  else
    cat > conftest.$ac_ext <<EOF
! #line 7139 "configure"
  #include "confdefs.h"
  
***************
*** 7167,7171 ****
  }
  EOF
! if { (eval echo configure:7170: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
  then
    bash_cv_func_sigsetjmp=present
--- 7177,7181 ----
  }
  EOF
! if { (eval echo configure:7180: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
  then
    bash_cv_func_sigsetjmp=present
***************
*** 7191,7195 ****
  
  echo $ac_n "checking whether or not strcoll and strcmp differ""... $ac_c" 1>&6
! echo "configure:7194: checking whether or not strcoll and strcmp differ" >&5
  if eval "test \"`echo '$''{'bash_cv_func_strcoll_broken'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
--- 7201,7205 ----
  
  echo $ac_n "checking whether or not strcoll and strcmp differ""... $ac_c" 1>&6
! echo "configure:7204: checking whether or not strcoll and strcmp differ" >&5
  if eval "test \"`echo '$''{'bash_cv_func_strcoll_broken'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
***************
*** 7201,7205 ****
  else
    cat > conftest.$ac_ext <<EOF
! #line 7204 "configure"
  #include "confdefs.h"
  
--- 7211,7215 ----
  else
    cat > conftest.$ac_ext <<EOF
! #line 7214 "configure"
  #include "confdefs.h"
  
***************
*** 7240,7244 ****
  
  EOF
! if { (eval echo configure:7243: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
  then
    bash_cv_func_strcoll_broken=yes
--- 7250,7254 ----
  
  EOF
! if { (eval echo configure:7253: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
  then
    bash_cv_func_strcoll_broken=yes
***************
*** 7266,7270 ****
  
  echo $ac_n "checking if signal handlers must be reinstalled when invoked""... $ac_c" 1>&6
! echo "configure:7269: checking if signal handlers must be reinstalled when invoked" >&5
  if eval "test \"`echo '$''{'bash_cv_must_reinstall_sighandlers'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
--- 7276,7280 ----
  
  echo $ac_n "checking if signal handlers must be reinstalled when invoked""... $ac_c" 1>&6
! echo "configure:7279: checking if signal handlers must be reinstalled when invoked" >&5
  if eval "test \"`echo '$''{'bash_cv_must_reinstall_sighandlers'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
***************
*** 7276,7280 ****
  else
    cat > conftest.$ac_ext <<EOF
! #line 7279 "configure"
  #include "confdefs.h"
  
--- 7286,7290 ----
  else
    cat > conftest.$ac_ext <<EOF
! #line 7289 "configure"
  #include "confdefs.h"
  
***************
*** 7323,7327 ****
  
  EOF
! if { (eval echo configure:7326: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
  then
    bash_cv_must_reinstall_sighandlers=no
--- 7333,7337 ----
  
  EOF
! if { (eval echo configure:7336: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
  then
    bash_cv_must_reinstall_sighandlers=no
***************
*** 7347,7351 ****
  
  echo $ac_n "checking for presence of necessary job control definitions""... $ac_c" 1>&6
! echo "configure:7350: checking for presence of necessary job control definitions" >&5
  if eval "test \"`echo '$''{'bash_cv_job_control_missing'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
--- 7357,7361 ----
  
  echo $ac_n "checking for presence of necessary job control definitions""... $ac_c" 1>&6
! echo "configure:7360: checking for presence of necessary job control definitions" >&5
  if eval "test \"`echo '$''{'bash_cv_job_control_missing'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
***************
*** 7357,7361 ****
  else
    cat > conftest.$ac_ext <<EOF
! #line 7360 "configure"
  #include "confdefs.h"
  
--- 7367,7371 ----
  else
    cat > conftest.$ac_ext <<EOF
! #line 7370 "configure"
  #include "confdefs.h"
  
***************
*** 7404,7408 ****
  }
  EOF
! if { (eval echo configure:7407: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
  then
    bash_cv_job_control_missing=present
--- 7414,7418 ----
  }
  EOF
! if { (eval echo configure:7417: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
  then
    bash_cv_job_control_missing=present
***************
*** 7427,7431 ****
  
  echo $ac_n "checking for presence of named pipes""... $ac_c" 1>&6
! echo "configure:7430: checking for presence of named pipes" >&5
  if eval "test \"`echo '$''{'bash_cv_sys_named_pipes'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
--- 7437,7441 ----
  
  echo $ac_n "checking for presence of named pipes""... $ac_c" 1>&6
! echo "configure:7440: checking for presence of named pipes" >&5
  if eval "test \"`echo '$''{'bash_cv_sys_named_pipes'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
***************
*** 7437,7441 ****
  else
    cat > conftest.$ac_ext <<EOF
! #line 7440 "configure"
  #include "confdefs.h"
  
--- 7447,7451 ----
  else
    cat > conftest.$ac_ext <<EOF
! #line 7450 "configure"
  #include "confdefs.h"
  
***************
*** 7478,7482 ****
  }
  EOF
! if { (eval echo configure:7481: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
  then
    bash_cv_sys_named_pipes=present
--- 7488,7492 ----
  }
  EOF
! if { (eval echo configure:7491: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
  then
    bash_cv_sys_named_pipes=present
***************
*** 7502,7511 ****
  
  echo $ac_n "checking for TIOCGWINSZ in sys/ioctl.h""... $ac_c" 1>&6
! echo "configure:7505: checking for TIOCGWINSZ in sys/ioctl.h" >&5
  if eval "test \"`echo '$''{'bash_cv_tiocgwinsz_in_ioctl'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 7510 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
--- 7512,7521 ----
  
  echo $ac_n "checking for TIOCGWINSZ in sys/ioctl.h""... $ac_c" 1>&6
! echo "configure:7515: checking for TIOCGWINSZ in sys/ioctl.h" >&5
  if eval "test \"`echo '$''{'bash_cv_tiocgwinsz_in_ioctl'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 7520 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
***************
*** 7515,7519 ****
  ; return 0; }
  EOF
! if { (eval echo configure:7518: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
    rm -rf conftest*
    bash_cv_tiocgwinsz_in_ioctl=yes
--- 7525,7529 ----
  ; return 0; }
  EOF
! if { (eval echo configure:7528: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
    rm -rf conftest*
    bash_cv_tiocgwinsz_in_ioctl=yes
***************
*** 7536,7545 ****
  
  echo $ac_n "checking for TIOCSTAT in sys/ioctl.h""... $ac_c" 1>&6
! echo "configure:7539: checking for TIOCSTAT in sys/ioctl.h" >&5
  if eval "test \"`echo '$''{'bash_cv_tiocstat_in_ioctl'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 7544 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
--- 7546,7555 ----
  
  echo $ac_n "checking for TIOCSTAT in sys/ioctl.h""... $ac_c" 1>&6
! echo "configure:7549: checking for TIOCSTAT in sys/ioctl.h" >&5
  if eval "test \"`echo '$''{'bash_cv_tiocstat_in_ioctl'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 7554 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
***************
*** 7549,7553 ****
  ; return 0; }
  EOF
! if { (eval echo configure:7552: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
    rm -rf conftest*
    bash_cv_tiocstat_in_ioctl=yes
--- 7559,7563 ----
  ; return 0; }
  EOF
! if { (eval echo configure:7562: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
    rm -rf conftest*
    bash_cv_tiocstat_in_ioctl=yes
***************
*** 7570,7579 ****
  
  echo $ac_n "checking for FIONREAD in sys/ioctl.h""... $ac_c" 1>&6
! echo "configure:7573: checking for FIONREAD in sys/ioctl.h" >&5
  if eval "test \"`echo '$''{'bash_cv_fionread_in_ioctl'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 7578 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
--- 7580,7589 ----
  
  echo $ac_n "checking for FIONREAD in sys/ioctl.h""... $ac_c" 1>&6
! echo "configure:7583: checking for FIONREAD in sys/ioctl.h" >&5
  if eval "test \"`echo '$''{'bash_cv_fionread_in_ioctl'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 7588 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
***************
*** 7583,7587 ****
  ; return 0; }
  EOF
! if { (eval echo configure:7586: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
    rm -rf conftest*
    bash_cv_fionread_in_ioctl=yes
--- 7593,7597 ----
  ; return 0; }
  EOF
! if { (eval echo configure:7596: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
    rm -rf conftest*
    bash_cv_fionread_in_ioctl=yes
***************
*** 7605,7614 ****
  
  echo $ac_n "checking for speed_t in sys/types.h""... $ac_c" 1>&6
! echo "configure:7608: checking for speed_t in sys/types.h" >&5
  if eval "test \"`echo '$''{'bash_cv_speed_t_in_sys_types'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 7613 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
--- 7615,7624 ----
  
  echo $ac_n "checking for speed_t in sys/types.h""... $ac_c" 1>&6
! echo "configure:7618: checking for speed_t in sys/types.h" >&5
  if eval "test \"`echo '$''{'bash_cv_speed_t_in_sys_types'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 7623 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
***************
*** 7617,7621 ****
  ; return 0; }
  EOF
! if { (eval echo configure:7620: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
    rm -rf conftest*
    bash_cv_speed_t_in_sys_types=yes
--- 7627,7631 ----
  ; return 0; }
  EOF
! if { (eval echo configure:7630: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
    rm -rf conftest*
    bash_cv_speed_t_in_sys_types=yes
***************
*** 7637,7671 ****
  fi
  
! echo $ac_n "checking whether programs are able to redeclare getpw functions""... $ac_c" 1>&6
! echo "configure:7641: checking whether programs are able to redeclare getpw functions" >&5
! if eval "test \"`echo '$''{'bash_cv_can_redecl_getpw'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 7646 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
  #include <pwd.h>
! extern struct passwd *getpwent();
! extern struct passwd *getpwuid();
! extern struct passwd *getpwnam();
! int main() {
! struct passwd *z; z = getpwent(); z = getpwuid(0); z = getpwnam("root");
! ; return 0; }
  EOF
! if { (eval echo configure:7657: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
    rm -rf conftest*
!   bash_cv_can_redecl_getpw=yes
  else
-   echo "configure: failed program was:" >&5
-   cat conftest.$ac_ext >&5
    rm -rf conftest*
!   bash_cv_can_redecl_getpw=no
  fi
  rm -f conftest*
  fi
  
! echo "$ac_t""$bash_cv_can_redecl_getpw" 1>&6
! if test $bash_cv_can_redecl_getpw = no; then
  cat >> confdefs.h <<\EOF
  #define HAVE_GETPW_DECLS 1
--- 7647,7680 ----
  fi
  
! echo $ac_n "checking whether getpw functions are declared in pwd.h""... $ac_c" 1>&6
! echo "configure:7651: checking whether getpw functions are declared in pwd.h" >&5
! if eval "test \"`echo '$''{'bash_cv_getpw_declared'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 7656 "configure"
  #include "confdefs.h"
+ 
  #include <sys/types.h>
+ #ifdef HAVE_UNISTD_H
+ #  include <unistd.h>
+ #endif
  #include <pwd.h>
! 
  EOF
! if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
!   egrep "getpwuid" >/dev/null 2>&1; then
    rm -rf conftest*
!   bash_cv_getpw_declared=yes
  else
    rm -rf conftest*
!   bash_cv_getpw_declared=no
  fi
  rm -f conftest*
+ 
  fi
  
! echo "$ac_t""$bash_cv_getpw_declared" 1>&6
! if test $bash_cv_getpw_declared = yes; then
  cat >> confdefs.h <<\EOF
  #define HAVE_GETPW_DECLS 1
***************
*** 7674,7686 ****
  fi
  
  
  case "$host_os" in
  hpux*)	echo $ac_n "checking whether $host_os needs _KERNEL for RLIMIT defines""... $ac_c" 1>&6
! echo "configure:7680: checking whether $host_os needs _KERNEL for RLIMIT defines" >&5
  if eval "test \"`echo '$''{'bash_cv_kernel_rlimit'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 7685 "configure"
  #include "confdefs.h"
  
--- 7683,7750 ----
  fi
  
+ echo $ac_n "checking for unusable real-time signals due to large values""... $ac_c" 1>&6
+ echo "configure:7687: checking for unusable real-time signals due to large values" >&5
+ if eval "test \"`echo '$''{'bash_cv_unusable_rtsigs'+set}'`\" = set"; then
+   echo $ac_n "(cached) $ac_c" 1>&6
+ else
+   if test "$cross_compiling" = yes; then
+   echo "configure: warning: cannot check real-time signals if cross compiling -- defaulting to yes" 1>&2
+      bash_cv_unusable_rtsigs=yes
+ 
+ else
+   cat > conftest.$ac_ext <<EOF
+ #line 7697 "configure"
+ #include "confdefs.h"
+ 
+ #include <sys/types.h>
+ #include <signal.h>
+ 
+ #ifndef NSIG
+ #  define NSIG 64
+ #endif
+ 
+ main ()
+ {
+   int n_sigs = 2 * NSIG;
+ #ifdef SIGRTMIN
+   int rtmin = SIGRTMIN;
+ #else
+   int rtmin = 0;
+ #endif
+ 
+   exit(rtmin < n_sigs);
+ }
+ EOF
+ if { (eval echo configure:7719: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+ then
+   bash_cv_unusable_rtsigs=yes
+ else
+   echo "configure: failed program was:" >&5
+   cat conftest.$ac_ext >&5
+   rm -fr conftest*
+   bash_cv_unusable_rtsigs=no
+ fi
+ rm -fr conftest*
+ fi
+ 
+ fi
+ 
+ echo "$ac_t""$bash_cv_unusable_rtsigs" 1>&6
+ if test $bash_cv_unusable_rtsigs = yes; then
+ cat >> confdefs.h <<\EOF
+ #define UNUSABLE_RT_SIGNALS 1
+ EOF
+ 
+ fi
+ 
  
  case "$host_os" in
  hpux*)	echo $ac_n "checking whether $host_os needs _KERNEL for RLIMIT defines""... $ac_c" 1>&6
! echo "configure:7744: checking whether $host_os needs _KERNEL for RLIMIT defines" >&5
  if eval "test \"`echo '$''{'bash_cv_kernel_rlimit'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 7749 "configure"
  #include "confdefs.h"
  
***************
*** 7695,7699 ****
  ; return 0; }
  EOF
! if { (eval echo configure:7698: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
    rm -rf conftest*
    bash_cv_kernel_rlimit=no
--- 7759,7763 ----
  ; return 0; }
  EOF
! if { (eval echo configure:7762: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
    rm -rf conftest*
    bash_cv_kernel_rlimit=no
***************
*** 7703,7707 ****
    rm -rf conftest*
    cat > conftest.$ac_ext <<EOF
! #line 7706 "configure"
  #include "confdefs.h"
  
--- 7767,7771 ----
    rm -rf conftest*
    cat > conftest.$ac_ext <<EOF
! #line 7770 "configure"
  #include "confdefs.h"
  
***************
*** 7718,7722 ****
  ; return 0; }
  EOF
! if { (eval echo configure:7721: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
    rm -rf conftest*
    bash_cv_kernel_rlimit=yes
--- 7782,7786 ----
  ; return 0; }
  EOF
! if { (eval echo configure:7785: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
    rm -rf conftest*
    bash_cv_kernel_rlimit=yes
***************
*** 7752,7756 ****
  else
  echo $ac_n "checking which library has the termcap functions""... $ac_c" 1>&6
! echo "configure:7755: checking which library has the termcap functions" >&5
  _bash_needmsg=
  fi
--- 7816,7820 ----
  else
  echo $ac_n "checking which library has the termcap functions""... $ac_c" 1>&6
! echo "configure:7819: checking which library has the termcap functions" >&5
  _bash_needmsg=
  fi
***************
*** 7759,7763 ****
  else
    echo $ac_n "checking for tgetent in -ltermcap""... $ac_c" 1>&6
! echo "configure:7762: checking for tgetent in -ltermcap" >&5
  ac_lib_var=`echo termcap'_'tgetent | sed 'y%./+-%__p_%'`
  if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
--- 7823,7827 ----
  else
    echo $ac_n "checking for tgetent in -ltermcap""... $ac_c" 1>&6
! echo "configure:7826: checking for tgetent in -ltermcap" >&5
  ac_lib_var=`echo termcap'_'tgetent | sed 'y%./+-%__p_%'`
  if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
***************
*** 7767,7771 ****
  LIBS="-ltermcap  $LIBS"
  cat > conftest.$ac_ext <<EOF
! #line 7770 "configure"
  #include "confdefs.h"
  /* Override any gcc2 internal prototype to avoid an error.  */
--- 7831,7835 ----
  LIBS="-ltermcap  $LIBS"
  cat > conftest.$ac_ext <<EOF
! #line 7834 "configure"
  #include "confdefs.h"
  /* Override any gcc2 internal prototype to avoid an error.  */
***************
*** 7778,7782 ****
  ; return 0; }
  EOF
! if { (eval echo configure:7781: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    eval "ac_cv_lib_$ac_lib_var=yes"
--- 7842,7846 ----
  ; return 0; }
  EOF
! if { (eval echo configure:7845: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    eval "ac_cv_lib_$ac_lib_var=yes"
***************
*** 7797,7801 ****
    echo "$ac_t""no" 1>&6
  echo $ac_n "checking for tgetent in -lcurses""... $ac_c" 1>&6
! echo "configure:7800: checking for tgetent in -lcurses" >&5
  ac_lib_var=`echo curses'_'tgetent | sed 'y%./+-%__p_%'`
  if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
--- 7861,7865 ----
    echo "$ac_t""no" 1>&6
  echo $ac_n "checking for tgetent in -lcurses""... $ac_c" 1>&6
! echo "configure:7864: checking for tgetent in -lcurses" >&5
  ac_lib_var=`echo curses'_'tgetent | sed 'y%./+-%__p_%'`
  if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
***************
*** 7805,7809 ****
  LIBS="-lcurses  $LIBS"
  cat > conftest.$ac_ext <<EOF
! #line 7808 "configure"
  #include "confdefs.h"
  /* Override any gcc2 internal prototype to avoid an error.  */
--- 7869,7873 ----
  LIBS="-lcurses  $LIBS"
  cat > conftest.$ac_ext <<EOF
! #line 7872 "configure"
  #include "confdefs.h"
  /* Override any gcc2 internal prototype to avoid an error.  */
***************
*** 7816,7820 ****
  ; return 0; }
  EOF
! if { (eval echo configure:7819: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    eval "ac_cv_lib_$ac_lib_var=yes"
--- 7880,7884 ----
  ; return 0; }
  EOF
! if { (eval echo configure:7883: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    eval "ac_cv_lib_$ac_lib_var=yes"
***************
*** 7835,7839 ****
    echo "$ac_t""no" 1>&6
  echo $ac_n "checking for tgetent in -lncurses""... $ac_c" 1>&6
! echo "configure:7838: checking for tgetent in -lncurses" >&5
  ac_lib_var=`echo ncurses'_'tgetent | sed 'y%./+-%__p_%'`
  if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
--- 7899,7903 ----
    echo "$ac_t""no" 1>&6
  echo $ac_n "checking for tgetent in -lncurses""... $ac_c" 1>&6
! echo "configure:7902: checking for tgetent in -lncurses" >&5
  ac_lib_var=`echo ncurses'_'tgetent | sed 'y%./+-%__p_%'`
  if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
***************
*** 7843,7847 ****
  LIBS="-lncurses  $LIBS"
  cat > conftest.$ac_ext <<EOF
! #line 7846 "configure"
  #include "confdefs.h"
  /* Override any gcc2 internal prototype to avoid an error.  */
--- 7907,7911 ----
  LIBS="-lncurses  $LIBS"
  cat > conftest.$ac_ext <<EOF
! #line 7910 "configure"
  #include "confdefs.h"
  /* Override any gcc2 internal prototype to avoid an error.  */
***************
*** 7854,7858 ****
  ; return 0; }
  EOF
! if { (eval echo configure:7857: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    eval "ac_cv_lib_$ac_lib_var=yes"
--- 7918,7922 ----
  ; return 0; }
  EOF
! if { (eval echo configure:7921: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    eval "ac_cv_lib_$ac_lib_var=yes"
***************
*** 7883,7887 ****
  if test "X$_bash_needmsg" = "Xyes"; then
  echo $ac_n "checking which library has the termcap functions""... $ac_c" 1>&6
! echo "configure:7886: checking which library has the termcap functions" >&5
  fi
  echo "$ac_t""using $bash_cv_termcap_lib" 1>&6
--- 7947,7951 ----
  if test "X$_bash_needmsg" = "Xyes"; then
  echo $ac_n "checking which library has the termcap functions""... $ac_c" 1>&6
! echo "configure:7950: checking which library has the termcap functions" >&5
  fi
  echo "$ac_t""using $bash_cv_termcap_lib" 1>&6
***************
*** 7906,7910 ****
  
  echo $ac_n "checking whether /dev/fd is available""... $ac_c" 1>&6
! echo "configure:7909: checking whether /dev/fd is available" >&5
  if eval "test \"`echo '$''{'bash_cv_dev_fd'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
--- 7970,7974 ----
  
  echo $ac_n "checking whether /dev/fd is available""... $ac_c" 1>&6
! echo "configure:7973: checking whether /dev/fd is available" >&5
  if eval "test \"`echo '$''{'bash_cv_dev_fd'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
***************
*** 7942,7946 ****
  
  echo $ac_n "checking whether /dev/stdin stdout stderr are available""... $ac_c" 1>&6
! echo "configure:7945: checking whether /dev/stdin stdout stderr are available" >&5
  if eval "test \"`echo '$''{'bash_cv_dev_stdin'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
--- 8006,8010 ----
  
  echo $ac_n "checking whether /dev/stdin stdout stderr are available""... $ac_c" 1>&6
! echo "configure:8009: checking whether /dev/stdin stdout stderr are available" >&5
  if eval "test \"`echo '$''{'bash_cv_dev_stdin'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
***************
*** 7965,7969 ****
  
  echo $ac_n "checking for default mail directory""... $ac_c" 1>&6
! echo "configure:7968: checking for default mail directory" >&5
  if eval "test \"`echo '$''{'bash_cv_mail_dir'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
--- 8029,8033 ----
  
  echo $ac_n "checking for default mail directory""... $ac_c" 1>&6
! echo "configure:8032: checking for default mail directory" >&5
  if eval "test \"`echo '$''{'bash_cv_mail_dir'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
***************
*** 8063,8067 ****
  *qnx*)		LOCAL_CFLAGS="-Dqnx -F -3s" LOCAL_LDFLAGS="-3s -lunix -lncurses" ;;
  powerux*)	LOCAL_LIBS="-lgen" ;;
! cygwin32*)	LOCAL_LIBS="-luser32" ;;
  opennt*|interix*) LOCAL_CFLAGS="-DNO_MAIN_ENV_ARG" ;;
  esac
--- 8127,8131 ----
  *qnx*)		LOCAL_CFLAGS="-Dqnx -F -3s" LOCAL_LDFLAGS="-3s -lunix -lncurses" ;;
  powerux*)	LOCAL_LIBS="-lgen" ;;
! cygwin*)	LOCAL_LIBS="-luser32" ;;
  opennt*|interix*) LOCAL_CFLAGS="-DNO_MAIN_ENV_ARG" ;;
  esac
***************
*** 8074,8080 ****
  
  case "${host_os}" in
! freebsd3*)	if test -x /usr/bin/objformat && test "`/usr/bin/objformat`" = "elf" ; then
  			LOCAL_LDFLAGS=-rdynamic # allow dynamic loading
  		fi ;;
  esac
  
--- 8138,8146 ----
  
  case "${host_os}" in
! freebsd[3-9]*)
! 		if test -x /usr/bin/objformat && test "`/usr/bin/objformat`" = "elf" ; then
  			LOCAL_LDFLAGS=-rdynamic # allow dynamic loading
  		fi ;;
+ freebsdelf*)	LOCAL_LDFLAGS=-rdynamic ;;	# allow dynamic loading
  esac
  
***************
*** 8099,8104 ****
  then
  	echo $ac_n "checking shared object configuration for loadable builtins""... $ac_c" 1>&6
! echo "configure:8102: checking shared object configuration for loadable builtins" >&5
! 	eval `${CONFIG_SHELL-/bin/sh} ${srcdir}/support/shobj-conf -C "${CC}" -c ${host_cpu} -o ${host_os} -v ${host_vendor}`
  	
  	
--- 8165,8170 ----
  then
  	echo $ac_n "checking shared object configuration for loadable builtins""... $ac_c" 1>&6
! echo "configure:8168: checking shared object configuration for loadable builtins" >&5
! 	eval `${CONFIG_SHELL-/bin/sh} ${srcdir}/support/shobj-conf -C "${CC}" -c "${host_cpu}" -o "${host_os}" -v "${host_vendor}"`
  	
  	
diff -Nrc2 bash-2.04/configure.in bash-2.05/configure.in
*** bash-2.04/configure.in	Tue Feb 22 11:46:11 2000
--- bash-2.05/configure.in	Tue Jan 23 12:57:24 2001
***************
*** 1,4 ****
  dnl
! dnl Configure script for bash-2.04
  dnl
  dnl report bugs to chet@po.cwru.edu
--- 1,4 ----
  dnl
! dnl Configure script for bash-2.05
  dnl
  dnl report bugs to chet@po.cwru.edu
***************
*** 7,11 ****
  
  dnl checks for version info
! AC_REVISION([for Bash 2.04, version 2.77, from autoconf version] AC_ACVERSION)dnl
  
  AC_INIT(shell.h)
--- 7,11 ----
  
  dnl checks for version info
! AC_REVISION([for Bash 2.05, version 2.90, from autoconf version] AC_ACVERSION)dnl
  
  AC_INIT(shell.h)
***************
*** 33,42 ****
  #htmldir=
  
! dnl some systems should be configured without gnu malloc by default
  dnl and some need a special compiler or loader
  dnl look in the NOTES file for more
  case "${host_cpu}-${host_os}" in
  alpha*-*)	opt_bash_malloc=no ;;	# alpha running osf/1 or linux
! *[Cc]ray*-*)	opt_bash_malloc=no ;;	# Crays
  *-osf1*)	opt_bash_malloc=no ;;	# other osf/1 machines
  sparc-svr4*)	opt_bash_malloc=no ;;	# sparc SVR4, SVR4.2
--- 33,42 ----
  #htmldir=
  
! dnl some systems should be configured without the bash malloc by default
  dnl and some need a special compiler or loader
  dnl look in the NOTES file for more
  case "${host_cpu}-${host_os}" in
  alpha*-*)	opt_bash_malloc=no ;;	# alpha running osf/1 or linux
! *[[Cc]]ray*-*)	opt_bash_malloc=no ;;	# Crays
  *-osf1*)	opt_bash_malloc=no ;;	# other osf/1 machines
  sparc-svr4*)	opt_bash_malloc=no ;;	# sparc SVR4, SVR4.2
***************
*** 48,52 ****
  *-aix*)		opt_bash_malloc=no ;;	# AIX machines
  *-nextstep*)	opt_bash_malloc=no ;;	# NeXT machines running NeXTstep
! *-rhapsody*)	opt_bash_malloc=no ;;	# Apple Rhapsody
  *-dgux*)	opt_bash_malloc=no ;;	# DG/UX machines
  *-qnx*)		opt_bash_malloc=no ;;	# QNX 4.2
--- 48,54 ----
  *-aix*)		opt_bash_malloc=no ;;	# AIX machines
  *-nextstep*)	opt_bash_malloc=no ;;	# NeXT machines running NeXTstep
! *-macos*)	opt_bash_malloc=no ;;	# Apple MacOS X
! *-rhapsody*)	opt_bash_malloc=no ;;	# Apple Rhapsody (MacOS X)
! *-darwin*)	opt_bash_malloc=no ;;	# Apple Darwin (MacOS X)
  *-dgux*)	opt_bash_malloc=no ;;	# DG/UX machines
  *-qnx*)		opt_bash_malloc=no ;;	# QNX 4.2
***************
*** 54,58 ****
  *-bsdi2.1|*-bsdi3.?)	opt_bash_malloc=no ; : ${CC:=shlicc2} ;; # for loadable builtins
  *-beos*)	opt_bash_malloc=no ;;	# they say it's suitable
! *-cygwin32*)	opt_bash_malloc=no ;;	# Cygnus's CYGWIN32 environment
  esac
  
--- 56,61 ----
  *-bsdi2.1|*-bsdi3.?)	opt_bash_malloc=no ; : ${CC:=shlicc2} ;; # for loadable builtins
  *-beos*)	opt_bash_malloc=no ;;	# they say it's suitable
! *-cygwin*)	opt_bash_malloc=no ;;	# Cygnus's CYGWIN environment
! *-opennt*|*-interix*)	opt_bash_malloc=no ;;	# Interix, now owned by Microsoft
  esac
  
***************
*** 271,275 ****
  AC_EXEEXT
  
! dnl BEGIN changes for cross-building for cygwin32 and BeOS
  
  SIGNAMES_H=lsignames.h
--- 274,278 ----
  AC_EXEEXT
  
! dnl BEGIN changes for cross-building for cygwin and BeOS
  
  SIGNAMES_H=lsignames.h
***************
*** 284,288 ****
  if test "x$cross_compiling" = "xyes"; then
      case "${host}" in
!     *-cygwin32*)
  	cross_cache=${srcdir}/cross-build/cygwin32.cache
  	SIGNAMES_H='$(srcdir)/cross-build/win32sig.h'
--- 287,291 ----
  if test "x$cross_compiling" = "xyes"; then
      case "${host}" in
!     *-cygwin*)
  	cross_cache=${srcdir}/cross-build/cygwin32.cache
  	SIGNAMES_H='$(srcdir)/cross-build/win32sig.h'
***************
*** 334,337 ****
--- 337,341 ----
  	if test -n "$GCC" || test "$ac_cv_prog_gcc" = "yes"; then
  		STATIC_LD="-static"
+ 		LDFLAGS="$LDFLAGS -static"	# XXX experimental
  	fi
  fi
***************
*** 362,370 ****
  
  	AC_MSG_CHECKING(version of installed readline library)
! 	_rl_version=`exec_prefix=${_rl_exec_prefix} ${CONFIG_SHELL-/bin/sh} ${srcdir}/support/rlvers.sh -C "${CC}" -L ${libdir} -T ${TERMCAP_LIB}`
  	AC_MSG_RESULT($_rl_version)
  
  	case "$_rl_version" in
! 	4.[[1-9]]*|5*|6*|7*|8*|9*)	;;
  	*)	opt_with_installed_readline=no 
  		AC_MSG_WARN(installed readline library is too old to be linked with bash)
--- 366,374 ----
  
  	AC_MSG_CHECKING(version of installed readline library)
! 	_rl_version=`exec_prefix=${_rl_exec_prefix} ${CONFIG_SHELL-/bin/sh} ${srcdir}/support/rlvers.sh -C "${CC}" -L ${libdir} -I ${includedir} -T ${TERMCAP_LIB}`
  	AC_MSG_RESULT($_rl_version)
  
  	case "$_rl_version" in
! 	4.[[2-9]]*|5*|6*|7*|8*|9*)	;;
  	*)	opt_with_installed_readline=no 
  		AC_MSG_WARN(installed readline library is too old to be linked with bash)
***************
*** 467,471 ****
  AC_CHECK_FUNCS(dup2 select getdtablesize getgroups gethostname \
  		setdtablesize getpagesize killpg lstat getpeername sbrk \
! 		getrlimit getrusage gettimeofday waitpid tcgetpgrp rename)
  
  dnl checks for c library functions
--- 471,476 ----
  AC_CHECK_FUNCS(dup2 select getdtablesize getgroups gethostname \
  		setdtablesize getpagesize killpg lstat getpeername sbrk \
! 		getrlimit getrusage gettimeofday waitpid tcgetpgrp \
! 		readlink rename)
  
  dnl checks for c library functions
***************
*** 473,478 ****
  		setlinebuf setlocale strchr strerror strtod strtol \
  		strtoul tcgetattr uname sysconf ulimit times tzset \
! 		siginterrupt memmove ttyname gethostbyname inet_aton \
! 		strpbrk setvbuf)
  
  dnl checks for locale functions
--- 478,483 ----
  		setlinebuf setlocale strchr strerror strtod strtol \
  		strtoul tcgetattr uname sysconf ulimit times tzset \
! 		siginterrupt memmove ttyname gethostbyname getservbyname \
! 		inet_aton strpbrk setvbuf pathconf)
  
  dnl checks for locale functions
***************
*** 631,634 ****
--- 636,640 ----
  BASH_MISC_SPEED_T
  BASH_CHECK_GETPW_FUNCS
+ BASH_CHECK_RTSIGS
  
  dnl special checks
***************
*** 693,697 ****
  *qnx*)		LOCAL_CFLAGS="-Dqnx -F -3s" LOCAL_LDFLAGS="-3s -lunix -lncurses" ;;
  powerux*)	LOCAL_LIBS="-lgen" ;;
! cygwin32*)	LOCAL_LIBS="-luser32" ;;
  opennt*|interix*) LOCAL_CFLAGS="-DNO_MAIN_ENV_ARG" ;;
  esac
--- 699,703 ----
  *qnx*)		LOCAL_CFLAGS="-Dqnx -F -3s" LOCAL_LDFLAGS="-3s -lunix -lncurses" ;;
  powerux*)	LOCAL_LIBS="-lgen" ;;
! cygwin*)	LOCAL_LIBS="-luser32" ;;
  opennt*|interix*) LOCAL_CFLAGS="-DNO_MAIN_ENV_ARG" ;;
  esac
***************
*** 706,712 ****
  dnl FreeBSD-3.x can have either a.out or ELF
  case "${host_os}" in
! freebsd3*)	if test -x /usr/bin/objformat && test "`/usr/bin/objformat`" = "elf" ; then
  			LOCAL_LDFLAGS=-rdynamic # allow dynamic loading
  		fi ;;
  esac
  
--- 712,720 ----
  dnl FreeBSD-3.x can have either a.out or ELF
  case "${host_os}" in
! freebsd[[3-9]]*)
! 		if test -x /usr/bin/objformat && test "`/usr/bin/objformat`" = "elf" ; then
  			LOCAL_LDFLAGS=-rdynamic # allow dynamic loading
  		fi ;;
+ freebsdelf*)	LOCAL_LDFLAGS=-rdynamic ;;	# allow dynamic loading
  esac
  
***************
*** 731,735 ****
  then
  	AC_MSG_CHECKING(shared object configuration for loadable builtins)
! 	eval `${CONFIG_SHELL-/bin/sh} ${srcdir}/support/shobj-conf -C "${CC}" -c ${host_cpu} -o ${host_os} -v ${host_vendor}`
  	AC_SUBST(SHOBJ_CC)
  	AC_SUBST(SHOBJ_CFLAGS)
--- 739,743 ----
  then
  	AC_MSG_CHECKING(shared object configuration for loadable builtins)
! 	eval `${CONFIG_SHELL-/bin/sh} ${srcdir}/support/shobj-conf -C "${CC}" -c "${host_cpu}" -o "${host_os}" -v "${host_vendor}"`
  	AC_SUBST(SHOBJ_CC)
  	AC_SUBST(SHOBJ_CFLAGS)
diff -Nrc2 bash-2.04/copy_cmd.c bash-2.05/copy_cmd.c
*** bash-2.04/copy_cmd.c	Fri Dec 31 14:12:37 1999
--- bash-2.05/copy_cmd.c	Wed Feb 14 16:58:19 2001
***************
*** 40,44 ****
--- 40,48 ----
  
    new_word = (WORD_DESC *)xmalloc (sizeof (WORD_DESC));
+ #if 1
+   new_word->flags = w->flags;
+ #else
    FASTCOPY ((char *)w, (char *)new_word, sizeof (WORD_DESC));
+ #endif
    new_word->word = savestring (w->word);
    return (new_word);
***************
*** 292,295 ****
--- 296,301 ----
    new_def->name = copy_word (com->name);
    new_def->command = copy_command (com->command);
+   new_def->flags = com->flags;
+   new_def->line = com->line;
    return (new_def);
  }
***************
*** 339,344 ****
  
        case cm_subshell:
!         new_command->value.Subshell = copy_subshell_command (command->value.Subshell);
!         break;
  
        case cm_case:
--- 345,350 ----
  
        case cm_subshell:
! 	new_command->value.Subshell = copy_subshell_command (command->value.Subshell);
! 	break;
  
        case cm_case:
***************
*** 357,362 ****
  #if defined (DPAREN_ARITHMETIC)
        case cm_arith:
!         new_command->value.Arith = copy_arith_command (command->value.Arith);
!         break;
  #endif
  
--- 363,368 ----
  #if defined (DPAREN_ARITHMETIC)
        case cm_arith:
! 	new_command->value.Arith = copy_arith_command (command->value.Arith);
! 	break;
  #endif
  
diff -Nrc2 bash-2.04/doc/FAQ bash-2.05/doc/FAQ
*** bash-2.04/doc/FAQ	Thu Mar 16 16:27:35 2000
--- bash-2.05/doc/FAQ	Wed Apr  4 11:09:02 2001
***************
*** 1,3 ****
! This is the Bash FAQ, version 3.7, for Bash version 2.04.
  
  This document contains a set of frequently-asked questions concerning
--- 1,3 ----
! This is the Bash FAQ, version 3.11, for Bash version 2.05.
  
  This document contains a set of frequently-asked questions concerning
***************
*** 37,42 ****
  Section B:  The latest version
  
! B1) What's new in version 2.04?
! B2) Are there any user-visible incompatibilities between bash-2.04 and
      bash-1.14.7?
  
--- 37,42 ----
  Section B:  The latest version
  
! B1) What's new in version 2.05?
! B2) Are there any user-visible incompatibilities between bash-2.05 and
      bash-1.14.7?
  
***************
*** 71,74 ****
--- 71,78 ----
      not, and how can I make it understand them?
  E6) Why doesn't a while or for loop get suspended when I type ^Z?
+ E7) What about empty for loops in Makefiles?
+ E8) Why does the arithmetic evaluation code complain about `08'?
+ E9) Why does the pattern matching expression [A-Z]* match files beginning
+     with every letter except `z'?
  
  Section F:  Things to watch out for on certain Unix versions
***************
*** 131,135 ****
  A2)  What's the latest version?
  
! The latest version is 2.04, first made available on Friday, 17 March 2000.
  
  A3)  Where can I get it?
--- 135,139 ----
  A2)  What's the latest version?
  
! The latest version is 2.05, first made available on Monday, 9 April 2001.
  
  A3)  Where can I get it?
***************
*** 138,150 ****
  master GNU archive site, ftp.gnu.org, and its mirrors.  The
  latest version is also available for FTP from ftp.cwru.edu.
! The following URLs tell how to get version 2.04:
  
! ftp://ftp.gnu.org/pub/gnu/bash/bash-2.04.tar.gz
! ftp://ftp.cwru.edu/pub/bash/bash-2.04.tar.gz
  
  Formatted versions of the documentation are available with the URLs:
  
! ftp://ftp.gnu.org/pub/gnu/bash/bash-doc-2.04.tar.gz
! ftp://ftp.cwru.edu/pub/bash/bash-doc-2.04.tar.gz
  
  A4)  On what machines will bash run?
--- 142,154 ----
  master GNU archive site, ftp.gnu.org, and its mirrors.  The
  latest version is also available for FTP from ftp.cwru.edu.
! The following URLs tell how to get version 2.05:
  
! ftp://ftp.gnu.org/pub/gnu/bash/bash-2.05.tar.gz
! ftp://ftp.cwru.edu/pub/bash/bash-2.05.tar.gz
  
  Formatted versions of the documentation are available with the URLs:
  
! ftp://ftp.gnu.org/pub/gnu/bash/bash-doc-2.05.tar.gz
! ftp://ftp.cwru.edu/pub/bash/bash-doc-2.05.tar.gz
  
  A4)  On what machines will bash run?
***************
*** 161,165 ****
  
  Configuration specifics for Unix-like systems such as QNX and
! LynxOS are included in the distribution.  Bash-2.04 should 
  compile and run on Minix 2.0 (patches were contributed), but I
  don't believe anyone has built bash-2.x on earlier Minix versions
--- 165,169 ----
  
  Configuration specifics for Unix-like systems such as QNX and
! LynxOS are included in the distribution.  Bash-2.05 should 
  compile and run on Minix 2.0 (patches were contributed), but I
  don't believe anyone has built bash-2.x on earlier Minix versions
***************
*** 169,182 ****
  programming interface.  This includes Windows 95 and Windows NT.
  The port was done by Cygnus Solutions as part of their CYGWIN
! project.  For more information about the project, look at the URL
  
! http:/sourceware.cygnus.com/cygwin
  
  Cygnus originally ported bash-1.14.7, and that port was part of their
  early GNU-Win32 (the original name) releases.  Cygnus has also done a
! port of bash-2.02.1 to the CYGWIN environment, and it is available as
! part of their current release.  (They may have upgraded by now.)
  
! Bash-2.04 should require no local Cygnus changes to build and run under
  CYGWIN.
  
--- 173,187 ----
  programming interface.  This includes Windows 95 and Windows NT.
  The port was done by Cygnus Solutions as part of their CYGWIN
! project.  For more information about the project, look at the URLs
  
! http://www.cygwin.com/
! http://sourceware.cygnus.com/cygwin
  
  Cygnus originally ported bash-1.14.7, and that port was part of their
  early GNU-Win32 (the original name) releases.  Cygnus has also done a
! port of bash-2.04 to the CYGWIN environment, and it is available as
! part of their current release.
  
! Bash-2.05 should require no local Cygnus changes to build and run under
  CYGWIN.
  
***************
*** 186,208 ****
  ftp://ftp.gnustep.org//pub/win32/bash-alpha-nt-1.01.tar.gz
  
! Softway Systems has ported bash-2.01 to their Interix (nee OpenNT)
! system, a Unix subsystem for NT that replaces the Microsoft POSIX
! subsystem.  Check out http://www.interix.com for more information.
! Some support for Interix has been incorporated into bash, beginning
! with Bash-2.03.  It should be easier to build bash on Interix now,
! but Interix users should fetch
! 
! ftp://ftp.interix.com/pub/tw/unsup/bash.diffs.tar.gz
! 
! and read the README.OpenNT file in that archive.  It will detail the
! arguments `configure' needs to build on Interix.  A configure cache
! file for Interix is in the bash distribution in cross-build/opennt.cache;
! copy that to `config.cache' before starting configure.
! 
! D. J. Delorie has ported bash-1.14.7 to run under MS-DOS, as part of
! the DJGPP project.  For more information on the project, see
  
  http://www.delorie.com/djgpp/
  
  I picked up a binary of bash-1.14.7 that is purported to work with
  the DJGPP V2 environment from
--- 191,201 ----
  ftp://ftp.gnustep.org//pub/win32/bash-alpha-nt-1.01.tar.gz
  
! DJ Delorie has a port of bash-1.14.7 which runs under MS-DOS, as part
! of the DJGPP project.  For more information on the project, see
  
  http://www.delorie.com/djgpp/
  
+ I have been told that the original DJGPP port was done by Daisuke Aoyama.
+ 
  I picked up a binary of bash-1.14.7 that is purported to work with
  the DJGPP V2 environment from
***************
*** 375,384 ****
  Section B:  The latest version
  
! B1) What's new in version 2.04?
  
! Bash-2.04 contains the following new features (see the manual page for
! complete descriptions and the CHANGES and NEWS files in the bash-2.04
  distribution):
  
  o Programmable word completion with the new `complete' and `compgen' builtins;
    examples are provided in examples/complete/complete-examples
--- 368,404 ----
  Section B:  The latest version
  
! B1) What's new in version 2.05?
  
! Bash-2.05 contains the following new features (see the manual page for
! complete descriptions and the CHANGES and NEWS files in the bash-2.05
  distribution):
  
+ o This version has once again reverted to using locales and strcoll(3) when
+   processing pattern matching bracket expressions, as POSIX requires. 
+ o Added a new `--init-file' invocation argument as a synonym for `--rcfile',
+   per the new GNU coding standards.
+ o The /dev/tcp and /dev/udp redirections now accept service names as well as
+   port numbers.
+ o `complete' and `compgen' now take a `-o value' option, which controls some
+    of the aspects of that compspec.  Valid values are:
+ 
+         default - perform bash default completion if programmable
+                   completion produces no matches
+         dirnames - perform directory name completion if programmable
+                    completion produces no matches
+         filenames - tell readline that the compspec produces filenames,
+                     so it can do things like append slashes to
+                     directory names and suppress trailing spaces
+ o A new loadable builtin, realpath, which canonicalizes and expands symlinks
+   in pathname arguments.
+ o When `set' is called without options, it prints function defintions in a
+   way that allows them to be reused as input.  This affects `declare' and 
+   `declare -p' as well.  This only happens when the shell is not in POSIX
+    mode, since POSIX.2 forbids this behavior.
+ 
+ A short feature history dating from bash-2.0:
+ 
+ Bash-2.04 introduced the following new features:
+ 
  o Programmable word completion with the new `complete' and `compgen' builtins;
    examples are provided in examples/complete/complete-examples
***************
*** 386,390 ****
  o `bind' has a new `-x' option to bind key sequences to shell commands
  o The prompt expansion code has new `\j' and `\l' escape sequences
! o The `no_empty_command_completion' shell option, if enabled, inhibits
    command completion when TAB is typed on an empty line
  o `help' has a new `-s' option to print a usage synopsis
--- 406,410 ----
  o `bind' has a new `-x' option to bind key sequences to shell commands
  o The prompt expansion code has new `\j' and `\l' escape sequences
! o The `no_empty_cmd_completion' shell option, if enabled, inhibits
    command completion when TAB is typed on an empty line
  o `help' has a new `-s' option to print a usage synopsis
***************
*** 406,410 ****
  o The NON_INTERACTIVE_LOGIN_SHELLS #define has returned
  
! The version of Readline released with Bash-2.04, Readline-4.1, has several
  new features as well:
  
--- 426,430 ----
  o The NON_INTERACTIVE_LOGIN_SHELLS #define has returned
  
! The version of Readline released with Bash-2.04, Readline-4.1, had several
  new features as well:
  
***************
*** 418,423 ****
  
  
- A short feature history dating from bash-2.0:
- 
  Bash-2.03 had very few new features, in keeping with the convention
  that odd-numbered releases provide mainly bug fixes.  A number of new
--- 438,441 ----
***************
*** 506,514 ****
  test suite greatly expanded
  
! B2) Are there any user-visible incompatibilities between bash-2.04 and
      bash-1.14.7?
  
! There are a few incompatibilities between version 1.14.7 and version 2.04.
! They are detailed in the file COMPAT in the bash-2.04 distribution.
  
  Section C:  Differences from other Unix shells
--- 524,532 ----
  test suite greatly expanded
  
! B2) Are there any user-visible incompatibilities between bash-2.05 and
      bash-1.14.7?
  
! There are a few incompatibilities between version 1.14.7 and version 2.05.
! They are detailed in the file COMPAT in the bash-2.05 distribution.
  
  Section C:  Differences from other Unix shells
***************
*** 661,664 ****
--- 679,683 ----
  	tracked aliases
  	variables: ERRNO, FPATH, EDITOR, VISUAL
+ 	trap on ERR
  	co-processes (|&, >&p, <&p)
  	weirdly-scoped functions
***************
*** 679,683 ****
  C3)  Which new features in ksh-93 are not in bash, and which are?
  
! New things in ksh-93 not in bash-2.04:
  	associative arrays
  	floating point arithmetic
--- 698,702 ----
  C3)  Which new features in ksh-93 are not in bash, and which are?
  
! New things in ksh-93 not in bash-2.05:
  	associative arrays
  	floating point arithmetic
***************
*** 825,837 ****
  The details can be found in the documentation.  We have provided
  a shell script which does most of the work of conversion for you;
! this script can be found in ./examples/misc/alias-conv.sh.  Here is
  how you use it:
    
  Start csh in the normal way for you.  (e.g., `csh')
    
! Pipe the output of `alias' through `alias-conv.sh', saving the
  results into `bash_aliases':
    
! 	alias | alias-conv.sh >bash_aliases
    
  Edit `bash_aliases', carefully reading through any created
--- 844,856 ----
  The details can be found in the documentation.  We have provided
  a shell script which does most of the work of conversion for you;
! this script can be found in ./examples/misc/aliasconv.sh.  Here is
  how you use it:
    
  Start csh in the normal way for you.  (e.g., `csh')
    
! Pipe the output of `alias' through `aliasconv.sh', saving the
  results into `bash_aliases':
    
! 	alias | bash aliasconv.sh >bash_aliases
    
  Edit `bash_aliases', carefully reading through any created
***************
*** 968,972 ****
  
  This has to do with the parent-child relationship between Unix
! processes. 
  
  Each element of a pipeline runs in a separate process, a child of
--- 987,994 ----
  
  This has to do with the parent-child relationship between Unix
! processes.  It affects all commands run in pipelines, not just
! simple calls to `read'.  For example, piping a command's output
! into a `while' loop that repeatedly calls `read' will result in
! the same behavior.
  
  Each element of a pipeline runs in a separate process, a child of
***************
*** 1059,1062 ****
--- 1081,1178 ----
  may be stopped (and subsequently restarted) as a single unit.
  
+ E7) What about empty for loops in Makefiles?
+ 
+ It's fairly common to see constructs like this in automatically-generated
+ Makefiles:
+ 
+ SUBDIRS = @SUBDIRS@
+ 
+ 	...
+ 
+ subdirs-clean:
+ 	for d in ${SUBDIRS}; do \
+ 		( cd $$d && ${MAKE} ${MFLAGS} clean ) \
+ 	done
+ 
+ When SUBDIRS is empty, this results in a command like this being passed to
+ bash:
+ 
+ 	for d in ; do
+ 		( cd $d && ${MAKE} ${MFLAGS} clean )
+ 	done
+ 
+ This is a syntax error.  If the reserved word `in' is present, a word must
+ follow it before the semicolon or newline.  The language in the manual page
+ referring to the list of words being empty refers to the list after it is
+ expanded.  There must be at least one word following the `in' when the
+ construct is parsed.
+ 
+ The idiomatic Makefile solution is something like:
+ 
+ SUBDIRS = @SUBDIRS@
+ 
+ subdirs-clean:
+ 	subdirs=$SUBDIRS ; for d in $$subdirs; do \
+ 		( cd $$d && ${MAKE} ${MFLAGS} clean ) \
+ 	done
+ 
+ 
+ The POSIX.2 interpretation committee has considered this issue and declared
+ that the bash implemenation is correct, according to the standard:
+ 
+ http://www.pasc.org/interps/unofficial/db/p1003.2/pasc-1003.2-169.html
+ 
+ E8) Why does the arithmetic evaluation code complain about `08'?
+ 
+ The bash arithmetic evaluation code (used for `let', $(()), (()), and in
+ other places), interprets a leading `0' in numeric constants as denoting
+ an octal number, and a leading `0x' as denoting hexadecimal.  This is
+ in accordance with the POSIX.2 spec, section 2.9.2.1, which states that
+ arithmetic constants should be handled as signed long integers as defined
+ by the ANSI/ISO C standard.
+ 
+ The POSIX.2 interpretation committee has confirmed this:
+ 
+ http://www.pasc.org/interps/unofficial/db/p1003.2/pasc-1003.2-173.html
+ 
+ E9) Why does the pattern matching expression [A-Z]* match files beginning
+     with every letter except `z'?
+ 
+ Bash-2.05 and later versions have reverted to the bash-2.03 behavior of
+ honoring the current locale setting when processing ranges within pattern
+ matching bracket expressions ([A-Z]).  This is what POSIX.2 and SUSv2/XPG5
+ specify. 
+ 
+ The behavior of the matcher in bash-2.05 depends on the current LC_COLLATE
+ setting.  Setting this variable to `C' or `POSIX' will result in the
+ traditional behavior ([A-Z] matches all uppercase ASCII characters).
+ Many other locales, including the en_US locale (the default on many US
+ versions of Linux) collate the upper and lower case letters like this:
+ 
+ 	AaBb...Zz
+ 
+ which means that [A-Z] matches every letter except `z'.
+ 
+ The portable way to specify upper case letters is [:upper:] instead of
+ A-Z; lower case may be specified as [:lower:] instead of a-z.
+ 
+ Look at the manual pages for setlocale(3), strcoll(3), and, if it is
+ present, locale(1).  If you have locale(1), you can use it to find
+ your current locale information even if you do not have any of the
+ LC_ variables set.
+ 
+ My advice is to put
+ 
+ 	export LC_COLLATE=C
+ 
+ into /etc/profile and inspect any shell scripts run from cron for
+ constructs like [A-Z].  This will prevent things like
+ 
+ 	rm [A-Z]*
+ 
+ from removing every file in the current directory except those beginning
+ with `z' and still allow individual users to change the collation order.
+ Users may put the above command into their own profiles as well, of course.
+ 
  Section F:  Things to watch out for on certain Unix versions
  
***************
*** 1164,1168 ****
  loops and subshells require `command < file'.
  
! The file CWRU/sh-redir-hack in the bash-2.04 distribution is an
  (unofficial) patch to parse.y that will modify the grammar to
  support this construct.  It will not apply with `patch'; you must
--- 1280,1284 ----
  loops and subshells require `command < file'.
  
! The file CWRU/sh-redir-hack in the bash-2.05 distribution is an
  (unofficial) patch to parse.y that will modify the grammar to
  support this construct.  It will not apply with `patch'; you must
***************
*** 1411,1416 ****
  These are features I plan to include in a future version of bash.
  
! a bash debugger (a minimally-tested version is included with bash-2.04)
  associative arrays
  
  H4) What's on the bash `wish list' for future versions?
--- 1527,1536 ----
  These are features I plan to include in a future version of bash.
  
! a bash debugger (a minimally-tested version is included with bash-2.05)
  associative arrays
+ changes to the DEBUG trap to be compatible with ksh93 (which runs the
+ trap before each simple command, instead of after each one like previous
+ versions)
+ an implementation of the ksh-like ERR trap
  
  H4) What's on the bash `wish list' for future versions?
***************
*** 1429,1437 ****
  H5) When will the next release appear?
  
! The next version will appear sometime in 2000 or 2001.  Never make
  predictions. 
  
  
! This document is Copyright 1995-2000 by Chester Ramey.
  
  Permission is hereby granted, without written agreement and
--- 1549,1557 ----
  H5) When will the next release appear?
  
! The next version will appear sometime in 2001 or 2002.  Never make
  predictions. 
  
  
! This document is Copyright 1995-2001 by Chester Ramey.
  
  Permission is hereby granted, without written agreement and
diff -Nrc2 bash-2.04/doc/Makefile.in bash-2.05/doc/Makefile.in
*** bash-2.04/doc/Makefile.in	Tue Nov 30 14:53:13 1999
--- bash-2.05/doc/Makefile.in	Mon Mar 19 10:14:11 2001
***************
*** 111,118 ****
  nodvi: ps info text html
  
! PSFILES = bash.ps bashbug.ps readline.ps article.ps builtins.ps rbash.ps
  DVIFILES = bashref.dvi bashref.ps
  INFOFILES = bashref.info
! MAN0FILES = bash.0 bashbug.0 builtins.0 rbash.0 readline.0
  HTMLFILES = bashref.html bash.html
  
--- 111,118 ----
  nodvi: ps info text html
  
! PSFILES = bash.ps bashbug.ps article.ps builtins.ps rbash.ps
  DVIFILES = bashref.dvi bashref.ps
  INFOFILES = bashref.info
! MAN0FILES = bash.0 bashbug.0 builtins.0 rbash.0
  HTMLFILES = bashref.html bash.html
  
***************
*** 163,168 ****
  builtins.0: builtins.1 bash.1
  rbash.0: rbash.1 bash.1
- readline.0: readline.3
- readline.ps: readline.3
  article.ps: article.ms
  
--- 163,166 ----
***************
*** 213,218 ****
  installdirs:
  	-test -d $(man1dir) || $(SHELL) ${MKDIRS} $(man1dir)
- # uncomment the next line to create the directory for the readline man page
- #	-test -d $(man3dir) || $(SHELL) ${MKDIRS} $(man3dir)
  	-test -d $(infodir) || $(SHELL) ${MKDIRS} $(infodir)
  	-if [ -n "$(htmldir)" ]; then \
--- 211,214 ----
***************
*** 223,228 ****
  	-$(INSTALL_DATA) $(srcdir)/bash.1 $(man1dir)/bash.${man1ext}
  	-$(INSTALL_DATA) $(srcdir)/bashbug.1 $(man1dir)/bashbug.${man1ext}
- # uncomment the next line to install the readline man page
- #	-$(INSTALL_DATA) $(srcdir)/readline.3 $(man3dir)/readline.${man3ext}
  # uncomment the next line to install the builtins man page
  #	$(INSTALL_DATA) $(srcdir)/builtins.1 $(man1dir)/bash_builtins.${man1ext}
--- 219,222 ----
***************
*** 240,244 ****
  uninstall:
  	-$(RM) $(man1dir)/bash.${man1ext} $(man1dir)/bashbug.${man1ext}
- 	-$(RM) $(man3dir)/readline.${man3ext}
  	$(RM) $(infodir)/bash.info
  	-if [ -n "$(htmldir)" ]; then \
--- 234,237 ----
***************
*** 257,258 ****
--- 250,253 ----
  	cmp -s POSIX.NOTES ../CWRU/POSIX.NOTES || mv POSIX.NOTES ../CWRU/POSIX.NOTES
  	$(RM) POSIX.NOTES
+ 
+ xdist: inst posix
diff -Nrc2 bash-2.04/doc/bash.1 bash-2.05/doc/bash.1
*** bash-2.04/doc/bash.1	Tue Mar 14 11:37:56 2000
--- bash-2.05/doc/bash.1	Mon Mar  5 14:41:30 2001
***************
*** 7,16 ****
  .\"	chet@ins.CWRU.Edu
  .\"
! .\"	Last Change: Tue Mar 14 11:36:43 EST 2000
  .\"
  .\" bash_builtins, strip all but Built-Ins section
  .if \n(zZ=1 .ig zZ
  .if \n(zY=1 .ig zY
! .TH BASH 1 "2000 Mar 14" "GNU Bash-2.04"
  .\"
  .\" There's some problem with having a `@'
--- 7,16 ----
  .\"	chet@ins.CWRU.Edu
  .\"
! .\"	Last Change: Mon Mar  5 10:19:14 EST 2001
  .\"
  .\" bash_builtins, strip all but Built-Ins section
  .if \n(zZ=1 .ig zZ
  .if \n(zY=1 .ig zY
! .TH BASH 1 "2001 Mar 5" "GNU Bash-2.05"
  .\"
  .\" There's some problem with having a `@'
***************
*** 52,57 ****
  [file]
  .SH COPYRIGHT
! .if n Bash is Copyright (C) 1989-1999 by the Free Software Foundation, Inc.
! .if t Bash is Copyright \(co 1989-1999 by the Free Software Foundation, Inc.
  .SH DESCRIPTION
  .B Bash
--- 52,57 ----
  [file]
  .SH COPYRIGHT
! .if n Bash is Copyright (C) 1989-2001 by the Free Software Foundation, Inc.
! .if t Bash is Copyright \(co 1989-2001 by the Free Software Foundation, Inc.
  .SH DESCRIPTION
  .B Bash
***************
*** 111,115 ****
  These are the strings that
  are subject to language translation when the current locale
! is not C or POSIX.
  This implies the \fB\-n\fP option; no commands will be executed.
  .TP
--- 111,115 ----
  These are the strings that
  are subject to language translation when the current locale
! is not \fBC\fP or \fBPOSIX\fP.
  This implies the \fB\-n\fP option; no commands will be executed.
  .TP
***************
*** 142,145 ****
--- 142,159 ----
  Display a usage message on standard output and exit successfully.
  .TP
+ .PD 0
+ \fB\-\-init\-file\fP \fIfile\fP
+ .TP
+ \fB\-\-rcfile\fP \fIfile\fP
+ .PD
+ Execute commands from
+ .I file
+ instead of the standard personal initialization file
+ .I ~/.bashrc
+ if the shell is interactive (see
+ .SM
+ .B INVOCATION
+ below).
+ .TP
  .B \-\-login
  Make
***************
*** 179,193 ****
  .B \-\-posix
  Change the behavior of \fBbash\fP where the default operation differs
! from the POSIX 1003.2 standard to match the standard.
! .TP
! \fB\-\-rcfile\fP \fIfile\fP
! Execute commands from
! .I file
! instead of the standard personal initialization file
! .I ~/.bashrc
! if the shell is interactive (see
! .SM
! .B INVOCATION
! below).
  .TP
  .B \-\-restricted
--- 193,197 ----
  .B \-\-posix
  Change the behavior of \fBbash\fP where the default operation differs
! from the POSIX 1003.2 standard to match the standard (\fIposix mode\fP).
  .TP
  .B \-\-restricted
***************
*** 304,308 ****
  .sp .5
  .RS
! \f(CWif [ \-n "$BASH_ENV" ]; then . "$BASH_ENV"; fi\fP
  .RE
  .sp .5
--- 308,313 ----
  .sp .5
  .RS
! .if t \f(CWif [ \-n "$BASH_ENV" ]; then . "$BASH_ENV"; fi\fP
! .if n if [ \-n "$BASH_ENV" ]; then . "$BASH_ENV"; fi
  .RE
  .sp .5
***************
*** 1120,1124 ****
  .SM
  .B GROUPS
! have no effect and are silently discarded.
  If
  .SM
--- 1125,1129 ----
  .SM
  .B GROUPS
! have no effect and return an error status.
  If
  .SM
***************
*** 1224,1228 ****
  .SM
  .B FUNCNAME
! have no effect and are silently discarded.
  If
  .SM
--- 1229,1233 ----
  .SM
  .B FUNCNAME
! have no effect and return an error status.
  If
  .SM
***************
*** 1377,1381 ****
  and is set by the administrator who installs
  .BR bash .
! A common value is ``/usr/gnu/bin:/usr/local/bin:/usr/ucb:/bin:/usr/bin:.''.
  .TP
  .B HOME
--- 1382,1388 ----
  and is set by the administrator who installs
  .BR bash .
! A common value is
! .if t \f(CW/usr/gnu/bin:/usr/local/bin:/usr/ucb:/bin:/usr/bin:.\fP.
! .if n ``/usr/gnu/bin:/usr/local/bin:/usr/ucb:/bin:/usr/bin:.''.
  .TP
  .B HOME
***************
*** 1422,1426 ****
  checks for mail.  The default is 60 seconds.  When it is time to check
  for mail, the shell does so before displaying the primary prompt.
! If this variable is unset, the shell disables mail checking.
  .TP
  .B MAILPATH
--- 1429,1434 ----
  checks for mail.  The default is 60 seconds.  When it is time to check
  for mail, the shell does so before displaying the primary prompt.
! If this variable is unset, or set to a value that is not a number
! greater than or equal to zero, the shell disables mail checking.
  .TP
  .B MAILPATH
***************
*** 1579,1582 ****
--- 1587,1598 ----
  This variable determines the locale category used for number formatting.
  .TP
+ .B LINES
+ Used by the \fBselect\fP builtin command to determine the column length
+ for printing selection lists.  Automatically set upon receipt of a SIGWINCH.
+ .TP
+ .B COLUMNS
+ Used by the \fBselect\fP builtin command to determine the terminal width
+ when printing selection lists.  Automatically set upon receipt of a SIGWINCH.
+ .TP
  .B PROMPT_COMMAND
  If set, the value is executed as a command prior to issuing each primary
***************
*** 2503,2509 ****
  .B [...]
  Matches any one of the enclosed characters.  A pair of characters
! separated by a minus sign denotes a
! .IR range ;
! any character lexically between those two characters, inclusive,
  is matched.  If the first character following the
  .B [
--- 2519,2526 ----
  .B [...]
  Matches any one of the enclosed characters.  A pair of characters
! separated by a hyphen denotes a
! \fIrange expression\fP;
! any character that sorts between those two characters, inclusive,
! using the current locale's collating sequence and character set,
  is matched.  If the first character following the
  .B [
***************
*** 2513,2516 ****
--- 2530,2536 ----
  .B ^
  then any character not enclosed is matched.
+ The sorting order of characters in range expressions is determined by
+ the current locale and the value of the \fBLC_COLLATE\fP shell variable,
+ if set.
  A 
  .B \-
***************
*** 3991,3994 ****
--- 4011,4015 ----
  as a symbolic key name, possibly with \fIMeta\-\fP or \fIControl\-\fP
  prefixes, or as a key sequence.
+ .PP
  When using the form \fBkeyname\fP:\^\fIfunction\-name\fP or \fImacro\fP,
  .I keyname
***************
*** 4014,4018 ****
  is bound to run the macro
  expressed on the right hand side (that is, to insert the text
! .I "> output"
  into the line).
  .PP
--- 4035,4040 ----
  is bound to run the macro
  expressed on the right hand side (that is, to insert the text
! .if t \f(CW> output\fP
! .if n ``> output''
  into the line).
  .PP
***************
*** 4024,4028 ****
  an entire key sequence may be specified by placing the sequence
  within double quotes.  Some GNU Emacs style key escapes can be
! used, as in the following example.
  .sp
  .RS
--- 4046,4051 ----
  an entire key sequence may be specified by placing the sequence
  within double quotes.  Some GNU Emacs style key escapes can be
! used, as in the following example, but the symbolic character names
! are not recognized.
  .sp
  .RS
***************
*** 4044,4048 ****
  .I "ESC [ 1 1 ~"
  is bound to insert the text
! .BR "Function Key 1" .
  The full set of GNU Emacs style escape sequences is
  .RS
--- 4067,4073 ----
  .I "ESC [ 1 1 ~"
  is bound to insert the text
! .if t \f(CWFunction Key 1\fP.
! .if n ``Function Key 1''.
! .PP
  The full set of GNU Emacs style escape sequences is
  .RS
***************
*** 4468,4473 ****
  .B yank\-nth\-arg (M\-C\-y)
  Insert the first argument to the previous command (usually
! the second word on the previous line) at point (the current
! cursor position).  With an argument
  .IR n ,
  insert the \fIn\fPth word from the previous command (the words
--- 4493,4498 ----
  .B yank\-nth\-arg (M\-C\-y)
  Insert the first argument to the previous command (usually
! the second word on the previous line) at point.
! With an argument
  .IR n ,
  insert the \fIn\fPth word from the previous command (the words
***************
*** 4528,4532 ****
  .TP
  .B delete\-char (C\-d)
! Delete the character under the cursor.  If point is at the
  beginning of the line, there are no characters in the line, and
  the last character typed was not bound to \fBdelete\-char\fP,
--- 4553,4557 ----
  .TP
  .B delete\-char (C\-d)
! Delete the character at point.  If point is at the
  beginning of the line, there are no characters in the line, and
  the last character typed was not bound to \fBdelete\-char\fP,
***************
*** 4555,4567 ****
  .TP
  .B transpose\-chars (C\-t)
! Drag the character before point forward over the character at point.
! Point moves forward as well.
! If point is at the end of the line, then transpose the two characters
! before point.
  Negative arguments have no effect.
  .TP
  .B transpose\-words (M\-t)
  Drag the word before point past the word after point,
! moving the point over that word as well.
  .TP
  .B upcase\-word (M\-u)
--- 4580,4592 ----
  .TP
  .B transpose\-chars (C\-t)
! Drag the character before point forward over the character at point,
! moving point forward as well.
! If point is at the end of the line, then this transposes
! the two characters before point.
  Negative arguments have no effect.
  .TP
  .B transpose\-words (M\-t)
  Drag the word before point past the word after point,
! moving point over that word as well.
  .TP
  .B upcase\-word (M\-u)
***************
*** 4606,4610 ****
  .B unix\-word\-rubout (C\-w)
  Kill the word behind point, using white space as a word boundary.
- The word boundaries are different from \fBbackward\-kill\-word\fP.
  The killed text is saved on the kill-ring.
  .TP
--- 4631,4634 ----
***************
*** 4627,4631 ****
  .TP
  .B yank (C\-y)
! Yank the top of the kill ring into the buffer at the cursor.
  .TP
  .B yank\-pop (M\-y)
--- 4651,4655 ----
  .TP
  .B yank (C\-y)
! Yank the top of the kill ring into the buffer at point.
  .TP
  .B yank\-pop (M\-y)
***************
*** 4683,4688 ****
  Repeated execution of \fBmenu\-complete\fP steps through the list
  of possible completions, inserting each match in turn.
! At the end of the list of completions, the bell is rung and the
! original text is restored.
  An argument of \fIn\fP moves \fIn\fP positions forward in the list
  of matches; a negative argument may be used to move backward
--- 4707,4713 ----
  Repeated execution of \fBmenu\-complete\fP steps through the list
  of possible completions, inserting each match in turn.
! At the end of the list of completions, the bell is rung
! (subject to the setting of \Bbell\-style\fP)
! and the original text is restored.
  An argument of \fIn\fP moves \fIn\fP positions forward in the list
  of matches; a negative argument may be used to move backward
***************
*** 4803,4807 ****
  .TP
  .B set\-mark (C\-@, M\-<space>)
! Set the mark to the current point.  If a
  numeric argument is supplied, the mark is set to that position.
  .TP
--- 4828,4832 ----
  .TP
  .B set\-mark (C\-@, M\-<space>)
! Set the mark to the point.  If a
  numeric argument is supplied, the mark is set to that position.
  .TP
***************
*** 4976,4983 ****
  completions.
  .PP
! If a compspec is found, whatever it generates is returned to the completion
! code as the full set of possible completions.
  The default \fBbash\fP completions are not attempted, and the readline
  default of filename completion is disabled.
  .SH HISTORY
  When the
--- 5001,5015 ----
  completions.
  .PP
! If the previously-applied actions do not generate any matches, and the
! \fB\-o dirnames\fP option was supplied to \fBcomplete\fP when the
! compspec was defined, directory name completion is attempted.
! .PP
! By default, if a compspec is found, whatever it generates is returned
! to the completion code as the full set of possible completions.
  The default \fBbash\fP completions are not attempted, and the readline
  default of filename completion is disabled.
+ If the \fB-o default\fP option was supplied to \fBcomplete\fP when the
+ compspec was defined, readline's default completion will be performed
+ if the compspec generates no matches.
  .SH HISTORY
  When the
***************
*** 5378,5382 ****
  .SM
  .B PATH
! need not be executable.  The current directory is
  searched if no file is found in
  .SM
--- 5410,5415 ----
  .SM
  .B PATH
! need not be executable.
! When \fBbash\fP is not in \fIposix mode\fP, the current directory is
  searched if no file is found in
  .SM
***************
*** 5455,5459 ****
  names are
  \fIemacs, emacs\-standard, emacs\-meta, emacs\-ctlx, vi,
! vi\-command\fP, and
  .IR vi\-insert .
  \fIvi\fP is equivalent to \fIvi\-command\fP; \fIemacs\fP is
--- 5488,5492 ----
  names are
  \fIemacs, emacs\-standard, emacs\-meta, emacs\-ctlx, vi,
! vi\-move, vi\-command\fP, and
  .IR vi\-insert .
  \fIvi\fP is equivalent to \fIvi\-command\fP; \fIemacs\fP is
***************
*** 5640,5644 ****
  .TP
  .PD 0
! \fBcomplete\fP [\fB\-abcdefjkvu\fP] [\fB\-A\fP \fIaction\fP] [\fB\-G\fP \fIglobpat\fP] [\fB\-W\fP \fIwordlist\fP] [\fB\-P\fP \fIprefix\fP] [\fB\-S\fP \fIsuffix\fP]
  .br
  [\fB\-X\fP \fIfilterpat\fP] [\fB\-F\fP \fIfunction\fP] [\fB\-C\fP \fIcommand\fP] \fIname\fP [\fIname ...\fP]
--- 5673,5677 ----
  .TP
  .PD 0
! \fBcomplete\fP [\fB\-abcdefjkvu\fP] [\fB\-o\fP \fIcomp-option\fP] [\fB\-A\fP \fIaction\fP] [\fB\-G\fP \fIglobpat\fP] [\fB\-W\fP \fIwordlist\fP] [\fB\-P\fP \fIprefix\fP] [\fB\-S\fP \fIsuffix\fP]
  .br
  [\fB\-X\fP \fIfilterpat\fP] [\fB\-F\fP \fIfunction\fP] [\fB\-C\fP \fIcommand\fP] \fIname\fP [\fIname ...\fP]
***************
*** 5666,5669 ****
--- 5699,5720 ----
  .PD 0
  .TP 8
+ \fB\-o\fP \fIcomp-option\fP
+ The \fIcomp-option\fP controls several aspects of the compspec's behavior
+ beyond the simple generation of completions.
+ \fIcomp-option\fP may be one of:
+ .RS
+ .TP 8
+ .B default
+ Use readline's default completion if the compspec generates no matches.
+ .TP 8
+ .B dirnames
+ Perform directory name completion if the compspec generates no matches.
+ .TP 8
+ .B filenames
+ Tell readline that the compspec generates filenames, so it can perform any
+ filename\-specific processing (like adding a slash to directory names or
+ suppressing trailing spaces).  Intended to be used with shell functions.
+ .RE
+ .TP 8
  \fB\-A\fP \fIaction\fP
  The \fIaction\fP may be one of the following to generate a list of possible
***************
*** 5965,5969 ****
  option disables the interpretation of these escape characters,
  even on systems where they are interpreted by default.
! The \fBxpg_echo\fP shell option to the may be used to
  dynamically determine whether or not \fBecho\fP expands these
  escape characters by default.
--- 6016,6020 ----
  option disables the interpretation of these escape characters,
  even on systems where they are interpreted by default.
! The \fBxpg_echo\fP shell option may be used to
  dynamically determine whether or not \fBecho\fP expands these
  escape characters by default.
***************
*** 6030,6034 ****
  .B PATH
  instead of the shell builtin version, run
! \f(CWenable -n test\fP.
  The
  .B \-f
--- 6081,6086 ----
  .B PATH
  instead of the shell builtin version, run
! .if t \f(CWenable -n test\fP.
! .if n ``enable -n test''.
  The
  .B \-f
***************
*** 6886,6891 ****
  .TP 8
  .B \-a
! Automatically mark variables which are modified or created for export
! to the environment of subsequent commands.
  .TP 8
  .B \-b
--- 6938,6943 ----
  .TP 8
  .B \-a
! Automatically mark variables and functions which are modified or created
! for export to the environment of subsequent commands.
  .TP 8
  .B \-b
***************
*** 6979,6983 ****
  .TP 8
  .B ignoreeof
! The effect is as if the shell command \f(CWIGNOREEOF=10\fP had been executed
  (see
  .B Shell Variables
--- 7031,7038 ----
  .TP 8
  .B ignoreeof
! The effect is as if the shell command
! .if t \f(CWIGNOREEOF=10\fP
! .if n ``IGNOREEOF=10''
! had been executed
  (see
  .B Shell Variables
***************
*** 7024,7028 ****
  .B bash
  where the default operation differs
! from the POSIX 1003.2 standard to match the standard.
  .TP 8
  .B privileged
--- 7079,7083 ----
  .B bash
  where the default operation differs
! from the POSIX 1003.2 standard to match the standard (\fIposix mode\fP).
  .TP 8
  .B privileged
***************
*** 7622,7626 ****
  .I name
  were specified as a command name,
! or nothing if \f(CWtype -t name\fP
  would not return
  .IR file .
--- 7677,7683 ----
  .I name
  were specified as a command name,
! or nothing if
! .if t \f(CWtype -t name\fP
! .if n ``type -t name''
  would not return
  .IR file .
diff -Nrc2 bash-2.04/doc/bashref.info bash-2.05/doc/bashref.info
*** bash-2.04/doc/bashref.info	Tue Mar 14 13:53:13 2000
--- bash-2.05/doc/bashref.info	Wed Mar 28 15:13:37 2001
***************
*** 1,4 ****
! This is Info file bashref.info, produced by Makeinfo version 1.68 from
! the input file /usr/homes/chet/src/bash/src/doc/bashref.texi.
  
  INFO-DIR-SECTION Utilities
--- 1,4 ----
! This is bashref.info, produced by makeinfo version 4.0 from
! /usr/homes/chet/src/bash/src/doc/bashref.texi.
  
  INFO-DIR-SECTION Utilities
***************
*** 10,16 ****
  the Bash shell.
  
! This is Edition 2.4, last updated 14 March 2000,
  of `The GNU Bash Reference Manual',
! for `Bash', Version 2.04.
  
  Copyright (C) 1991-1999 Free Software Foundation, Inc.
--- 10,16 ----
  the Bash shell.
  
! This is Edition 2.5, last updated 28 Mar 2001,
  of `The GNU Bash Reference Manual',
! for `Bash', Version 2.05.
  
  Copyright (C) 1991-1999 Free Software Foundation, Inc.
***************
*** 39,44 ****
  the Bash shell.
  
!    This is Edition 2.4, last updated 14 March 2000, of `The GNU Bash
! Reference Manual', for `Bash', Version 2.04.
  
     Copyright (C) 1991, 1993, 1996 Free Software Foundation, Inc.
--- 39,44 ----
  the Bash shell.
  
!    This is Edition 2.5, last updated 28 Mar 2001, of `The GNU Bash
! Reference Manual', for `Bash', Version 2.05.
  
     Copyright (C) 1991, 1993, 1996 Free Software Foundation, Inc.
***************
*** 333,360 ****
  reads and executes a command.  Basically, the shell does the following:
  
!   1. Reads its input from a file (*note Shell Scripts::.), from a string
       supplied as an argument to the `-c' invocation option (*note
!      Invoking Bash::.), or from the user's terminal.
  
    2. Breaks the input into words and operators, obeying the quoting
       rules described in *Note Quoting::.  These tokens are separated by
       `metacharacters'.  Alias expansion is performed by this step
!      (*note Aliases::.).
  
    3. Parses the tokens into simple and compound commands (*note Shell
!      Commands::.).
  
!   4. Performs the various shell expansions (*note Shell Expansions::.),
       breaking the expanded tokens into lists of filenames (*note
!      Filename Expansion::.)  and commands and arguments.
  
!   5. Performs any necessary redirections (*note Redirections::.) and
       removes the redirection operators and their operands from the
       argument list.
  
!   6. Executes the command (*note Executing Commands::.).
  
    7. Optionally waits for the command to complete and collects its exit
!      status (*note Exit Status::.).
  
  
--- 333,360 ----
  reads and executes a command.  Basically, the shell does the following:
  
!   1. Reads its input from a file (*note Shell Scripts::), from a string
       supplied as an argument to the `-c' invocation option (*note
!      Invoking Bash::), or from the user's terminal.
  
    2. Breaks the input into words and operators, obeying the quoting
       rules described in *Note Quoting::.  These tokens are separated by
       `metacharacters'.  Alias expansion is performed by this step
!      (*note Aliases::).
  
    3. Parses the tokens into simple and compound commands (*note Shell
!      Commands::).
  
!   4. Performs the various shell expansions (*note Shell Expansions::),
       breaking the expanded tokens into lists of filenames (*note
!      Filename Expansion::) and commands and arguments.
  
!   5. Performs any necessary redirections (*note Redirections::) and
       removes the redirection operators and their operands from the
       argument list.
  
!   6. Executes the command (*note Executing Commands::).
  
    7. Optionally waits for the command to complete and collects its exit
!      status (*note Exit Status::).
  
  
***************
*** 382,390 ****
  recognized as such, and to prevent parameter expansion.
  
!    Each of the shell metacharacters (*note Definitions::.)  has special
  meaning to the shell and must be quoted if it is to represent itself.
  When the command history expansion facilities are being used, the
  HISTORY EXPANSION character, usually `!', must be quoted to prevent
! history expansion.  *Note Bash History Facilities:: for more details
  concerning history expansion.  There are three quoting mechanisms: the
  ESCAPE CHARACTER, single quotes, and double quotes.
--- 382,390 ----
  recognized as such, and to prevent parameter expansion.
  
!    Each of the shell metacharacters (*note Definitions::) has special
  meaning to the shell and must be quoted if it is to represent itself.
  When the command history expansion facilities are being used, the
  HISTORY EXPANSION character, usually `!', must be quoted to prevent
! history expansion.  *Note Bash History Facilities::, for more details
  concerning history expansion.  There are three quoting mechanisms: the
  ESCAPE CHARACTER, single quotes, and double quotes.
***************
*** 422,427 ****
  value of all characters within the quotes, with the exception of `$',
  ``', and `\'.  The characters `$' and ``' retain their special meaning
! within double quotes (*note Shell Expansions::.).  The backslash
! retains its special meaning only when followed by one of the following
  characters: `$', ``', `"', `\', or `newline'.  Within double quotes,
  backslashes that are followed by one of these characters are removed.
--- 422,427 ----
  value of all characters within the quotes, with the exception of `$',
  ``', and `\'.  The characters `$' and ``' retain their special meaning
! within double quotes (*note Shell Expansions::).  The backslash retains
! its special meaning only when followed by one of the following
  characters: `$', ``', `"', `\', or `newline'.  Within double quotes,
  backslashes that are followed by one of these characters are removed.
***************
*** 431,435 ****
  
     The special parameters `*' and `@' have special meaning when in
! double quotes (*note Shell Parameter Expansion::.).
  
  
--- 431,435 ----
  
     The special parameters `*' and `@' have special meaning when in
! double quotes (*note Shell Parameter Expansion::).
  
  
***************
*** 441,445 ****
     Words of the form `$'STRING'' are treated specially.  The word
  expands to STRING, with backslash-escaped characters replaced as
! specifed by the ANSI C standard.  Backslash escape sequences, if
  present, are decoded as follows:
  
--- 441,445 ----
     Words of the form `$'STRING'' are treated specially.  The word
  expands to STRING, with backslash-escaped characters replaced as
! specified by the ANSI C standard.  Backslash escape sequences, if
  present, are decoded as follows:
  
***************
*** 496,499 ****
--- 496,505 ----
  string is translated and replaced, the replacement is double-quoted.
  
+    Some systems use the message catalog selected by the `LC_MESSAGES'
+ shell variable.  Others create the name of the message catalog from the
+ value of the `TEXTDOMAIN' shell variable, possibly adding a suffix of
+ `.mo'.  If you use the `TEXTDOMAIN' variable, you may need to set the
+ `TEXTDOMAINDIR' variable to the location of the message catalog files.
+ 
  
  File: bashref.info,  Node: Comments,  Prev: Quoting,  Up: Shell Syntax
***************
*** 504,508 ****
     In a non-interactive shell, or an interactive shell in which the
  `interactive_comments' option to the `shopt' builtin is enabled (*note
! Bash Builtins::.), a word beginning with `#' causes that word and all
  remaining characters on that line to be ignored.  An interactive shell
  without the `interactive_comments' option enabled does not allow
--- 510,514 ----
     In a non-interactive shell, or an interactive shell in which the
  `interactive_comments' option to the `shopt' builtin is enabled (*note
! Bash Builtins::), a word beginning with `#' causes that word and all
  remaining characters on that line to be ignored.  An interactive shell
  without the `interactive_comments' option enabled does not allow
***************
*** 543,551 ****
     A simple command is the kind of command encountered most often.
  It's just a sequence of words separated by `blank's, terminated by one
! of the shell's control operators (*note Definitions::.).  The first
! word generally specifies a command to be executed, with the rest of the
  words being that command's arguments.
  
!    The return status (*note Exit Status::.) of a simple command is its
  exit status as provided by the POSIX 1003.1 `waitpid' function, or
  128+N if the command was terminated by signal N.
--- 549,557 ----
     A simple command is the kind of command encountered most often.
  It's just a sequence of words separated by `blank's, terminated by one
! of the shell's control operators (*note Definitions::).  The first word
! generally specifies a command to be executed, with the rest of the
  words being that command's arguments.
  
!    The return status (*note Exit Status::) of a simple command is its
  exit status as provided by the POSIX 1003.1 `waitpid' function, or
  128+N if the command was terminated by signal N.
***************
*** 577,588 ****
  cannot time these easily.
  
!    If the pipeline is not executed asynchronously (*note Lists::.), the
  shell waits for all commands in the pipeline to complete.
  
     Each command in a pipeline is executed in its own subshell (*note
! Command Execution Environment::.).  The exit status of a pipeline is
! the exit status of the last command in the pipeline.  If the reserved
! word `!' precedes the pipeline, the exit status is the logical negation
! of the exit status of the last command.
  
  
--- 583,594 ----
  cannot time these easily.
  
!    If the pipeline is not executed asynchronously (*note Lists::), the
  shell waits for all commands in the pipeline to complete.
  
     Each command in a pipeline is executed in its own subshell (*note
! Command Execution Environment::).  The exit status of a pipeline is the
! exit status of the last command in the pipeline.  If the reserved word
! `!' precedes the pipeline, the exit status is the logical negation of
! the exit status of the last command.
  
  
***************
*** 603,607 ****
  executing the command in the BACKGROUND.  The shell does not wait for
  the command to finish, and the return status is 0 (true).  When job
! control is not active (*note Job Control::.), the standard input for
  asynchronous commands, in the absence of any explicit redirections, is
  redirected from `/dev/null'.
--- 609,613 ----
  executing the command in the BACKGROUND.  The shell does not wait for
  the command to finish, and the return status is 0 (true).  When job
! control is not active (*note Job Control::), the standard input for
  asynchronous commands, in the absence of any explicit redirections, is
  redirected from `/dev/null'.
***************
*** 663,667 ****
       WORDS' is not present, the `for' command executes the COMMANDS
       once for each positional parameter that is set, as if `in "$@"'
!      had been specified (*note Special Parameters::.).  The return
       status is the exit status of the last command that executes.  If
       there are no items in the expansion of WORDS, no commands are
--- 669,673 ----
       WORDS' is not present, the `for' command executes the COMMANDS
       once for each positional parameter that is set, as if `in "$@"'
!      had been specified (*note Special Parameters::).  The return
       status is the exit status of the last command that executes.  If
       there are no items in the expansion of WORDS, no commands are
***************
*** 672,676 ****
            for (( EXPR1 ; EXPR2 ; EXPR3 )) ; do COMMANDS ; done
       First, the arithmetic expression EXPR1 is evaluated according to
!      the rules described below (*note Shell Arithmetic::.).  The
       arithmetic expression EXPR2 is then evaluated repeatedly until it
       evaluates to zero.  Each time EXPR2 evaluates to a non-zero value,
--- 678,682 ----
            for (( EXPR1 ; EXPR2 ; EXPR3 )) ; do COMMANDS ; done
       First, the arithmetic expression EXPR1 is evaluated according to
!      the rules described below (*note Shell Arithmetic::).  The
       arithmetic expression EXPR2 is then evaluated repeatedly until it
       evaluates to zero.  Each time EXPR2 evaluates to a non-zero value,
***************
*** 681,685 ****
       expressions is invalid.
  
!    The `break' and `continue' builtins (*note Bourne Shell Builtins::.)
  may be used to control loop execution.
  
--- 687,691 ----
       expressions is invalid.
  
!    The `break' and `continue' builtins (*note Bourne Shell Builtins::)
  may be used to control loop execution.
  
***************
*** 783,787 ****
  
       The arithmetic EXPRESSION is evaluated according to the rules
!      described below (*note Shell Arithmetic::.).  If the value of the
       expression is non-zero, the return status is 0; otherwise the
       return status is 1.  This is exactly equivalent to
--- 789,793 ----
  
       The arithmetic EXPRESSION is evaluated according to the rules
!      described below (*note Shell Arithmetic::).  If the value of the
       expression is non-zero, the return status is 0; otherwise the
       return status is 1.  This is exactly equivalent to
***************
*** 896,900 ****
     When a function is executed, the arguments to the function become
  the positional parameters during its execution (*note Positional
! Parameters::.).  The special parameter `#' that expands to the number of
  positional parameters is updated to reflect the change.  Positional
  parameter `0' is unchanged.  The `FUNCNAME' variable is set to the name
--- 902,906 ----
     When a function is executed, the arguments to the function become
  the positional parameters during its execution (*note Positional
! Parameters::).  The special parameter `#' that expands to the number of
  positional parameters is updated to reflect the change.  Positional
  parameter `0' is unchanged.  The `FUNCNAME' variable is set to the name
***************
*** 945,949 ****
  description of the `declare' builtin in *Note Bash Builtins::), then
  VALUE is subject to arithmetic expansion even if the `$((...))'
! expansion is not used (*note Arithmetic Expansion::.).  Word splitting
  is not performed, with the exception of `"$@"' as explained below.
  Filename expansion is not performed.
--- 951,955 ----
  description of the `declare' builtin in *Note Bash Builtins::), then
  VALUE is subject to arithmetic expansion even if the `$((...))'
! expansion is not used (*note Arithmetic Expansion::).  Word splitting
  is not performed, with the exception of `"$@"' as explained below.
  Filename expansion is not performed.
***************
*** 962,967 ****
  Positional parameters may not be assigned to with assignment statements.
  The `set' and `shift' builtins are used to set and unset them (*note
! Shell Builtin Commands::.).  The positional parameters are temporarily
! replaced when a shell function is executed (*note Shell Functions::.).
  
     When a positional parameter consisting of more than a single digit
--- 968,973 ----
  Positional parameters may not be assigned to with assignment statements.
  The `set' and `shift' builtins are used to set and unset them (*note
! Shell Builtin Commands::).  The positional parameters are temporarily
! replaced when a shell function is executed (*note Shell Functions::).
  
     When a positional parameter consisting of more than a single digit
***************
*** 1017,1025 ****
       Expands to the name of the shell or shell script.  This is set at
       shell initialization.  If Bash is invoked with a file of commands
!      (*note Shell Scripts::.), `$0' is set to the name of that file.
!      If Bash is started with the `-c' option (*note Invoking Bash::.),
!      then `$0' is set to the first argument after the string to be
!      executed, if one is present.  Otherwise, it is set to the filename
!      used to invoke Bash, as given by argument zero.
  
  `_'
--- 1023,1031 ----
       Expands to the name of the shell or shell script.  This is set at
       shell initialization.  If Bash is invoked with a file of commands
!      (*note Shell Scripts::), `$0' is set to the name of that file.  If
!      Bash is started with the `-c' option (*note Invoking Bash::), then
!      `$0' is set to the first argument after the string to be executed,
!      if one is present.  Otherwise, it is set to the filename used to
!      invoke Bash, as given by argument zero.
  
  `_'
***************
*** 1081,1088 ****
  change the number of words of the expansion; other expansions expand a
  single word to a single word.  The only exceptions to this are the
! expansions of `"$@"' (*note Special Parameters::.) and `"${NAME[@]}"'
! (*note Arrays::.).
  
!    After all expansions, `quote removal' (*note Quote Removal::.)  is
  performed.
  
--- 1087,1094 ----
  change the number of words of the expansion; other expansions expand a
  single word to a single word.  The only exceptions to this are the
! expansions of `"$@"' (*note Special Parameters::) and `"${NAME[@]}"'
! (*note Arrays::).
  
!    After all expansions, `quote removal' (*note Quote Removal::) is
  performed.
  
***************
*** 1095,1099 ****
     Brace expansion is a mechanism by which arbitrary strings may be
  generated.  This mechanism is similar to FILENAME EXPANSION (*note
! Filename Expansion::.), but the file names generated need not exist.
  Patterns to be brace expanded take the form of an optional PREAMBLE,
  followed by a series of comma-separated strings between a pair of
--- 1101,1105 ----
     Brace expansion is a mechanism by which arbitrary strings may be
  generated.  This mechanism is similar to FILENAME EXPANSION (*note
! Filename Expansion::), but the file names generated need not exist.
  Patterns to be brace expanded take the form of an optional PREAMBLE,
  followed by a series of comma-separated strings between a pair of
***************
*** 1150,1154 ****
  would be displayed by the `dirs' builtin invoked with the characters
  following tilde in the tilde-prefix as an argument (*note The Directory
! Stack::.).  If the tilde-prefix, sans the tilde, consists of a number
  without a leading `+' or `-', `+' is assumed.
  
--- 1156,1160 ----
  would be displayed by the `dirs' builtin invoked with the characters
  following tilde in the tilde-prefix as an argument (*note The Directory
! Stack::).  If the tilde-prefix, sans the tilde, consists of a number
  without a leading `+' or `-', `+' is assumed.
  
***************
*** 1254,1258 ****
       the substring of PARAMETER starting at the character specified by
       OFFSET.  LENGTH and OFFSET are arithmetic expressions (*note Shell
!      Arithmetic::.).  This is referred to as Substring Expansion.
  
       LENGTH must evaluate to a number greater than or equal to zero.
--- 1260,1264 ----
       the substring of PARAMETER starting at the character specified by
       OFFSET.  LENGTH and OFFSET are arithmetic expressions (*note Shell
!      Arithmetic::).  This is referred to as Substring Expansion.
  
       LENGTH must evaluate to a number greater than or equal to zero.
***************
*** 1280,1284 ****
  `${PARAMETER##WORD}'
       The WORD is expanded to produce a pattern just as in filename
!      expansion (*note Filename Expansion::.).  If the pattern matches
       the beginning of the expanded value of PARAMETER, then the result
       of the expansion is the expanded value of PARAMETER with the
--- 1286,1290 ----
  `${PARAMETER##WORD}'
       The WORD is expanded to produce a pattern just as in filename
!      expansion (*note Filename Expansion::).  If the pattern matches
       the beginning of the expanded value of PARAMETER, then the result
       of the expansion is the expanded value of PARAMETER with the
***************
*** 1374,1378 ****
  
     The evaluation is performed according to the rules listed below
! (*note Shell Arithmetic::.).  If the expression is invalid, Bash prints
  a message indicating failure to the standard error and no substitution
  occurs.
--- 1380,1384 ----
  
     The evaluation is performed according to the rules listed below
! (*note Shell Arithmetic::).  If the expression is invalid, Bash prints
  a message indicating failure to the standard error and no substitution
  occurs.
***************
*** 1446,1450 ****
  
     After word splitting, unless the `-f' option has been set (*note The
! Set Builtin::.), Bash scans each word for the characters `*', `?', and
  `['.  If one of these characters appears, then the word is regarded as
  a PATTERN, and replaced with an alphabetically sorted list of file
--- 1452,1456 ----
  
     After word splitting, unless the `-f' option has been set (*note The
! Set Builtin::), Bash scans each word for the characters `*', `?', and
  `['.  If one of these characters appears, then the word is regarded as
  a PATTERN, and replaced with an alphabetically sorted list of file
***************
*** 1455,1460 ****
  performed without regard to the case of alphabetic characters.
  
!    When a pattern is used for filename generation, the character `.'
! at the start of a filename or immediately following a slash must be
  matched explicitly, unless the shell option `dotglob' is set.  When
  matching a file name, the slash character must always be matched
--- 1461,1466 ----
  performed without regard to the case of alphabetic characters.
  
!    When a pattern is used for filename generation, the character `.' at
! the start of a filename or immediately following a slash must be
  matched explicitly, unless the shell option `dotglob' is set.  When
  matching a file name, the slash character must always be matched
***************
*** 1467,1471 ****
  filenames matching a pattern.  If `GLOBIGNORE' is set, each matching
  filename that also matches one of the patterns in `GLOBIGNORE' is
! removed from the list of matches.  The filenames `.' and `..'  are
  always ignored, even when `GLOBIGNORE' is set.  However, setting
  `GLOBIGNORE' has the effect of enabling the `dotglob' shell option, so
--- 1473,1477 ----
  filenames matching a pattern.  If `GLOBIGNORE' is set, each matching
  filename that also matches one of the patterns in `GLOBIGNORE' is
! removed from the list of matches.  The filenames `.' and `..' are
  always ignored, even when `GLOBIGNORE' is set.  However, setting
  `GLOBIGNORE' has the effect of enabling the `dotglob' shell option, so
***************
*** 1495,1504 ****
  `[...]'
       Matches any one of the enclosed characters.  A pair of characters
!      separated by a minus sign denotes a RANGE; any character lexically
!      between those two characters, inclusive, is matched.  If the first
!      character following the `[' is a `!'  or a `^' then any character
!      not enclosed is matched.  A `-' may be matched by including it as
!      the first or last character in the set.  A `]' may be matched by
!      including it as the first character in the set.
  
       Within `[' and `]', CHARACTER CLASSES can be specified using the
--- 1501,1523 ----
  `[...]'
       Matches any one of the enclosed characters.  A pair of characters
!      separated by a hyphen denotes a RANGE EXPRESSION; any character
!      that sorts between those two characters, inclusive, using the
!      current locale's collating sequence and character set, is matched.
!      If the first character following the `[' is a `!'  or a `^' then
!      any character not enclosed is matched.  A `-' may be matched by
!      including it as the first or last character in the set.  A `]' may
!      be matched by including it as the first character in the set.  The
!      sorting order of characters in range expressions is determined by
!      the current locale and the value of the `LC_COLLATE' shell
!      variable, if set.
! 
!      For example, in the default C locale, `[a-dx-z]' is equivalent to
!      `[abcdxyz]'.  Many locales sort characters in dictionary order,
!      and in these locales `[a-dx-z]' is typically not equivalent to
!      `[abcdxyz]'; it might be equivalent to `[aBbCcDdxXyYz]', for
!      example.  To obtain the traditional interpretation of ranges in
!      bracket expressions, you can force the use of the C locale by
!      setting the `LC_COLLATE' or `LC_ALL' environment variable to the
!      value `C'.
  
       Within `[' and `]', CHARACTER CLASSES can be specified using the
***************
*** 1515,1519 ****
       character C.
  
!      Within `[' and `]', the syntax `[.'SYMBOL`.]'  matches the
       collating symbol SYMBOL.
  
--- 1534,1538 ----
       character C.
  
!      Within `[' and `]', the syntax `[.'SYMBOL`.]' matches the
       collating symbol SYMBOL.
  
***************
*** 1770,1779 ****
  
    2. The words that are not variable assignments or redirections are
!      expanded (*note Shell Expansions::.).  If any words remain after
       expansion, the first word is taken to be the name of the command
       and the remaining words are the arguments.
  
    3. Redirections are performed as described above (*note
!      Redirections::.).
  
    4. The text after the `=' in each variable assignment undergoes tilde
--- 1789,1798 ----
  
    2. The words that are not variable assignments or redirections are
!      expanded (*note Shell Expansions::).  If any words remain after
       expansion, the first word is taken to be the name of the command
       and the remaining words are the arguments.
  
    3. Redirections are performed as described above (*note
!      Redirections::).
  
    4. The text after the `=' in each variable assignment undergoes tilde
***************
*** 1873,1880 ****
     * options enabled by `shopt'
  
!    * shell aliases defined with `alias' (*note Aliases::.)
  
     * various process IDs, including those of background jobs (*note
!      Lists::.), the value of `$$', and the value of `$PPID'
  
     When a simple command other than a builtin or shell function is to
--- 1892,1900 ----
     * options enabled by `shopt'
  
!    * shell aliases defined with `alias' (*note Aliases::)
  
     * various process IDs, including those of background jobs (*note
!      Lists::), the value of `$$', and the value of `$PPID'
! 
  
     When a simple command other than a builtin or shell function is to
***************
*** 1891,1899 ****
  
     * shell variables marked for export, along with variables exported
!      for the command, passed in the environment (*note Environment::.)
  
     * traps caught by the shell are reset to the values inherited from
       the shell's parent, and traps ignored by the shell are ignored
  
     A command invoked in this separate environment cannot affect the
  shell's execution environment.
--- 1911,1920 ----
  
     * shell variables marked for export, along with variables exported
!      for the command, passed in the environment (*note Environment::)
  
     * traps caught by the shell are reset to the values inherited from
       the shell's parent, and traps ignored by the shell are ignored
  
+ 
     A command invoked in this separate environment cannot affect the
  shell's execution environment.
***************
*** 1935,1939 ****
  environment seen by that command.
  
!    If the `-k' option is set (*note The Set Builtin::.), then all
  parameter assignments are placed in the environment for a command, not
  just those that precede the command name.
--- 1956,1960 ----
  environment seen by that command.
  
!    If the `-k' option is set (*note The Set Builtin::), then all
  parameter assignments are placed in the environment for a command, not
  just those that precede the command name.
***************
*** 1964,1969 ****
  
     The exit status is used by the Bash conditional commands (*note
! Conditional Constructs::.) and some of the list constructs (*note
! Lists::.).
  
     All of the Bash builtins return an exit status of zero if they
--- 1985,1990 ----
  
     The exit status is used by the Bash conditional commands (*note
! Conditional Constructs::) and some of the list constructs (*note
! Lists::).
  
     All of the Bash builtins return an exit status of zero if they
***************
*** 1983,1987 ****
  interruptible).  When Bash receives a `SIGINT', it breaks out of any
  executing loops.  In all cases, Bash ignores `SIGQUIT'.  If job control
! is in effect (*note Job Control::.), Bash ignores `SIGTTIN', `SIGTTOU',
  and `SIGTSTP'.
  
--- 2004,2008 ----
  interruptible).  When Bash receives a `SIGINT', it breaks out of any
  executing loops.  In all cases, Bash ignores `SIGQUIT'.  If job control
! is in effect (*note Job Control::), Bash ignores `SIGTTIN', `SIGTTOU',
  and `SIGTSTP'.
  
***************
*** 1998,2007 ****
  `SIGHUP'.  To prevent the shell from sending the `SIGHUP' signal to a
  particular job, it should be removed from the jobs table with the
! `disown' builtin (*note Job Control Builtins::.) or marked to not
  receive `SIGHUP' using `disown -h'.
  
     If the  `huponexit' shell option has been set with `shopt' (*note
! Bash Builtins::.), Bash sends a `SIGHUP' to all jobs when an
! interactive login shell exits.
  
     When Bash receives a signal for which a trap has been set while
--- 2019,2028 ----
  `SIGHUP'.  To prevent the shell from sending the `SIGHUP' signal to a
  particular job, it should be removed from the jobs table with the
! `disown' builtin (*note Job Control Builtins::) or marked to not
  receive `SIGHUP' using `disown -h'.
  
     If the  `huponexit' shell option has been set with `shopt' (*note
! Bash Builtins::), Bash sends a `SIGHUP' to all jobs when an interactive
! login shell exits.
  
     When Bash receives a signal for which a trap has been set while
***************
*** 2021,2025 ****
     A shell script is a text file containing shell commands.  When such
  a file is used as the first non-option argument when invoking Bash, and
! neither the `-c' nor `-s' option is supplied (*note Invoking Bash::.),
  Bash reads and executes commands from the file, then exits.  This mode
  of operation creates a non-interactive shell.  When Bash runs a shell
--- 2042,2046 ----
     A shell script is a text file containing shell commands.  When such
  a file is used as the first non-option argument when invoking Bash, and
! neither the `-c' nor `-s' option is supplied (*note Invoking Bash::),
  Bash reads and executes commands from the file, then exits.  This mode
  of operation creates a non-interactive shell.  When Bash runs a shell
***************
*** 2080,2084 ****
     Builtin commands are contained within the shell itself.  When the
  name of a builtin command is used as the first word of a simple command
! (*note Simple Commands::.), the shell executes the command directly,
  without invoking another program.  Builtin commands are necessary to
  implement functionality impossible or inconvenient to obtain with
--- 2101,2105 ----
     Builtin commands are contained within the shell itself.  When the
  name of a builtin command is used as the first word of a simple command
! (*note Simple Commands::), the shell executes the command directly,
  without invoking another program.  Builtin commands are necessary to
  implement functionality impossible or inconvenient to obtain with
***************
*** 2091,2098 ****
     Several builtin commands are described in other chapters:  builtin
  commands which provide the Bash interface to the job control facilities
! (*note Job Control Builtins::.), the directory stack (*note Directory
! Stack Builtins::.), the command history (*note Bash History
! Builtins::.), and the programmable completion facilities (*note
! Programmable Completion Builtins::.).
  
     Many of the builtins have been extended by POSIX or Bash.
--- 2112,2119 ----
     Several builtin commands are described in other chapters:  builtin
  commands which provide the Bash interface to the job control facilities
! (*note Job Control Builtins::), the directory stack (*note Directory
! Stack Builtins::), the command history (*note Bash History Builtins::),
! and the programmable completion facilities (*note Programmable
! Completion Builtins::).
  
     Many of the builtins have been extended by POSIX or Bash.
***************
*** 2117,2128 ****
       Read and execute commands from the FILENAME argument in the
       current shell context.  If FILENAME does not contain a slash, the
!      `PATH' variable is used to find FILENAME.  The current directory
!      is searched if FILENAME is not found in `$PATH'.  If any ARGUMENTS
!      are supplied, they become the positional parameters when FILENAME
!      is executed.  Otherwise the positional parameters are unchanged.
!      The return status is the exit status of the last command executed,
!      or zero if no commands are executed.  If FILENAME is not found, or
!      cannot be read, the return status is non-zero.  This builtin is
!      equivalent to `source'.
  
  `break'
--- 2138,2149 ----
       Read and execute commands from the FILENAME argument in the
       current shell context.  If FILENAME does not contain a slash, the
!      `PATH' variable is used to find FILENAME.  When Bash is not in
!      POSIX mode, the current directory is searched if FILENAME is not
!      found in `$PATH'.  If any ARGUMENTS are supplied, they become the
!      positional parameters when FILENAME is executed.  Otherwise the
!      positional parameters are unchanged.  The return status is the
!      exit status of the last command executed, or zero if no commands
!      are executed.  If FILENAME is not found, or cannot be read, the
!      return status is non-zero.  This builtin is equivalent to `source'.
  
  `break'
***************
*** 2328,2332 ****
            only if the second argument is null.  If the first argument
            is one of the unary conditional operators (*note Bash
!           Conditional Expressions::.), the expression is true if the
            unary test is true.  If the first argument is not a valid
            unary operator, the expression is false.
--- 2349,2353 ----
            only if the second argument is null.  If the first argument
            is one of the unary conditional operators (*note Bash
!           Conditional Expressions::), the expression is true if the
            unary test is true.  If the first argument is not a valid
            unary operator, the expression is false.
***************
*** 2334,2338 ****
      3 arguments
            If the second argument is one of the binary conditional
!           operators (*note Bash Conditional Expressions::.), the result
            of the expression is the result of the binary test using the
            first and third arguments as operands.  If the first argument
--- 2355,2359 ----
      3 arguments
            If the second argument is one of the binary conditional
!           operators (*note Bash Conditional Expressions::), the result
            of the expression is the result of the binary test using the
            first and third arguments as operands.  If the first argument
***************
*** 2438,2445 ****
            bind [-m KEYMAP] KEYSEQ:FUNCTION-NAME
  
!      Display current Readline (*note Command Line Editing::.)  key and
       function bindings, or bind a key sequence to a Readline function
       or macro.  The binding syntax accepted is identical to that of a
!      Readline initialization file (*note Readline Init File::.), but
       each binding must be passed as a separate argument:  e.g.,
       `"\C-x\C-r":re-read-init-file'.  Options, if supplied, have the
--- 2459,2466 ----
            bind [-m KEYMAP] KEYSEQ:FUNCTION-NAME
  
!      Display current Readline (*note Command Line Editing::) key and
       function bindings, or bind a key sequence to a Readline function
       or macro.  The binding syntax accepted is identical to that of a
!      Readline initialization file (*note Readline Init File::), but
       each binding must be passed as a separate argument:  e.g.,
       `"\C-x\C-r":re-read-init-file'.  Options, if supplied, have the
***************
*** 2449,2453 ****
            Use KEYMAP as the keymap to be affected by the subsequent
            bindings.  Acceptable KEYMAP names are `emacs',
!           `emacs-standard', `emacs-meta', `emacs-ctlx', `vi',
            `vi-command', and `vi-insert'.  `vi' is equivalent to
            `vi-command'; `emacs' is equivalent to `emacs-standard'.
--- 2470,2474 ----
            Use KEYMAP as the keymap to be affected by the subsequent
            bindings.  Acceptable KEYMAP names are `emacs',
!           `emacs-standard', `emacs-meta', `emacs-ctlx', `vi', `vi-move',
            `vi-command', and `vi-insert'.  `vi' is equivalent to
            `vi-command'; `emacs' is equivalent to `emacs-standard'.
***************
*** 2515,2519 ****
       the external command `ls' instead of calling the function
       recursively.  The `-p' option means to use a default value for
!      `$PATH' that is guaranteed to find all of the standard utilities.
       The return status in this case is 127 if COMMAND cannot be found
       or an error occurred, and the exit status of COMMAND otherwise.
--- 2536,2540 ----
       the external command `ls' instead of calling the function
       recursively.  The `-p' option means to use a default value for
!      `PATH' that is guaranteed to find all of the standard utilities.
       The return status in this case is 127 if COMMAND cannot be found
       or an error occurred, and the exit status of COMMAND otherwise.
***************
*** 2540,2544 ****
  
      `-a'
!           Each NAME is an array variable (*note Arrays::.).
  
      `-f'
--- 2561,2565 ----
  
      `-a'
!           Each NAME is an array variable (*note Arrays::).
  
      `-f'
***************
*** 2547,2551 ****
      `-i'
            The variable is to be treated as an integer; arithmetic
!           evaluation (*note Shell Arithmetic::.) is performed when the
            variable is assigned a value.
  
--- 2568,2572 ----
      `-i'
            The variable is to be treated as an integer; arithmetic
!           evaluation (*note Shell Arithmetic::) is performed when the
            variable is assigned a value.
  
***************
*** 2566,2570 ****
       attempt is made to assign a value to a readonly variable, an
       attempt is made to assign a value to an array variable without
!      using the compound assignment syntax (*note Arrays::.), one of the
       NAMES is not a valid shell variable name, an attempt is made to
       turn off readonly status for a readonly variable, an attempt is
--- 2587,2591 ----
       attempt is made to assign a value to a readonly variable, an
       attempt is made to assign a value to an array variable without
!      using the compound assignment syntax (*note Arrays::), one of the
       NAMES is not a valid shell variable name, an attempt is made to
       turn off readonly status for a readonly variable, an attempt is
***************
*** 2644,2648 ****
       The `-s' option restricts `enable' to the POSIX special builtins.
       If `-s' is used with `-f', the new builtin becomes a special
!      builtin (*note Special Builtins::.).
  
       The return status is zero unless a NAME is not a shell builtin or
--- 2665,2669 ----
       The `-s' option restricts `enable' to the POSIX special builtins.
       If `-s' is used with `-f', the new builtin becomes a special
!      builtin (*note Special Builtins::).
  
       The return status is zero unless a NAME is not a shell builtin or
***************
*** 2725,2730 ****
  
      `-e'
!           Readline (*note Command Line Editing::.) is used to obtain
!           the line.
  
      `-n NCHARS'
--- 2746,2751 ----
  
      `-e'
!           Readline (*note Command Line Editing::) is used to obtain the
!           line.
  
      `-n NCHARS'
***************
*** 2775,2779 ****
      `-o'
            Restricts the values of OPTNAME to be those defined for the
!           `-o' option to the `set' builtin (*note The Set Builtin::.).
  
       If either `-s' or `-u' is used with no OPTNAME arguments, the
--- 2796,2800 ----
      `-o'
            Restricts the values of OPTNAME to be those defined for the
!           `-o' option to the `set' builtin (*note The Set Builtin::).
  
       If either `-s' or `-u' is used with no OPTNAME arguments, the
***************
*** 2834,2838 ****
      `extglob'
            If set, the extended pattern matching features described above
!           (*note Pattern Matching::.) are enabled.
  
      `histappend'
--- 2855,2859 ----
      `extglob'
            If set, the extended pattern matching features described above
!           (*note Pattern Matching::) are enabled.
  
      `histappend'
***************
*** 2854,2863 ****
            If set, and Readline is being used, Bash will attempt to
            perform hostname completion when a word containing a `@' is
!           being completed (*note Commands For Completion::.).  This
            option is enabled by default.
  
      `huponexit'
            If set, Bash will send `SIGHUP' to all jobs when an
!           interactive login shell exits (*note Signals::.).
  
      `interactive_comments'
--- 2875,2884 ----
            If set, and Readline is being used, Bash will attempt to
            perform hostname completion when a word containing a `@' is
!           being completed (*note Commands For Completion::).  This
            option is enabled by default.
  
      `huponexit'
            If set, Bash will send `SIGHUP' to all jobs when an
!           interactive login shell exits (*note Signals::).
  
      `interactive_comments'
***************
*** 2891,2908 ****
      `progcomp'
            If set, the programmable completion facilities (*note
!           Programmable Completion::.) are enabled.  This option is
            enabled by default.
  
      `promptvars'
            If set, prompt strings undergo variable and parameter
!           expansion after being expanded (*note Printing a Prompt::.).
            This option is enabled by default.
  
      `restricted_shell'
            The shell sets this option if it is started in restricted mode
!           (*note The Restricted Shell::.).  The value may not be
!           changed.  This is not reset when the startup files are
!           executed, allowing the startup files to discover whether or
!           not a shell is restricted.
  
      `shift_verbose'
--- 2912,2929 ----
      `progcomp'
            If set, the programmable completion facilities (*note
!           Programmable Completion::) are enabled.  This option is
            enabled by default.
  
      `promptvars'
            If set, prompt strings undergo variable and parameter
!           expansion after being expanded (*note Printing a Prompt::).
            This option is enabled by default.
  
      `restricted_shell'
            The shell sets this option if it is started in restricted mode
!           (*note The Restricted Shell::).  The value may not be changed.
!           This is not reset when the startup files are executed,
!           allowing the startup files to discover whether or not a shell
!           is restricted.
  
      `shift_verbose'
***************
*** 2927,2931 ****
  `source'
            source FILENAME
!      A synonym for `.' (*note Bourne Shell Builtins::.).
  
  `type'
--- 2948,2952 ----
  `source'
            source FILENAME
!      A synonym for `.' (*note Bourne Shell Builtins::).
  
  `type'
***************
*** 3042,3046 ****
  
      `-a'
!           Mark variables which are modified or created for export.
  
      `-b'
--- 3063,3068 ----
  
      `-a'
!           Mark variables and function which are modified or created for
!           export to the environment of subsequent commands.
  
      `-b'
***************
*** 3051,3055 ****
      `-e'
            Exit immediately if a simple command (*note Simple
!           Commands::.) exits with a non-zero status, unless the command
            that fails is part of an `until' or `while' loop, part of an
            `if' statement, part of a `&&' or `||' list, or if the
--- 3073,3077 ----
      `-e'
            Exit immediately if a simple command (*note Simple
!           Commands::) exits with a non-zero status, unless the command
            that fails is part of an `until' or `while' loop, part of an
            `if' statement, part of a `&&' or `||' list, or if the
***************
*** 3069,3073 ****
  
      `-m'
!           Job control is enabled (*note Job Control::.).
  
      `-n'
--- 3091,3095 ----
  
      `-m'
!           Job control is enabled (*note Job Control::).
  
      `-n'
***************
*** 3087,3091 ****
           `emacs'
                 Use an `emacs'-style line editing interface (*note
!                Command Line Editing::.).
  
           `errexit'
--- 3109,3113 ----
           `emacs'
                 Use an `emacs'-style line editing interface (*note
!                Command Line Editing::).
  
           `errexit'
***************
*** 3136,3142 ****
                 Change the behavior of Bash where the default operation
                 differs from the POSIX 1003.2 standard to match the
!                standard (*note Bash POSIX Mode::.).  This is intended
!                to make Bash behave as a strict superset of that
!                standard.
  
           `privileged'
--- 3158,3163 ----
                 Change the behavior of Bash where the default operation
                 differs from the POSIX 1003.2 standard to match the
!                standard (*note Bash POSIX Mode::).  This is intended to
!                make Bash behave as a strict superset of that standard.
  
           `privileged'
***************
*** 3182,3186 ****
      `-B'
            The shell will perform brace expansion (*note Brace
!           Expansion::.).  This option is on by default.
  
      `-C'
--- 3203,3207 ----
      `-B'
            The shell will perform brace expansion (*note Brace
!           Expansion::).  This option is on by default.
  
      `-C'
***************
*** 3190,3195 ****
      `-H'
            Enable `!' style history substitution (*note History
!           Interaction::.).  This option is on by default for
!           interactive shells.
  
      `-P'
--- 3211,3216 ----
      `-H'
            Enable `!' style history substitution (*note History
!           Interaction::).  This option is on by default for interactive
!           shells.
  
      `-P'
***************
*** 3243,3247 ****
  
     For historical reasons, the POSIX 1003.2 standard has classified
! several builtin commands as *special*.  When Bash is executing in POSIX
  mode, the special builtins differ from other builtin commands in three
  respects:
--- 3264,3268 ----
  
     For historical reasons, the POSIX 1003.2 standard has classified
! several builtin commands as _special_.  When Bash is executing in POSIX
  mode, the special builtins differ from other builtin commands in three
  respects:
***************
*** 3295,3299 ****
       The current user's home directory; the default for the `cd' builtin
       command.  The value of this variable is also used by tilde
!      expansion (*note Tilde Expansion::.).
  
  `IFS'
--- 3316,3320 ----
       The current user's home directory; the default for the `cd' builtin
       command.  The value of this variable is also used by tilde
!      expansion (*note Tilde Expansion::).
  
  `IFS'
***************
*** 3344,3348 ****
     A few variables used by Bash are described in different chapters:
  variables for controlling the job control facilities (*note Job Control
! Variables::.).
  
  `BASH'
--- 3365,3369 ----
     A few variables used by Bash are described in different chapters:
  variables for controlling the job control facilities (*note Job Control
! Variables::).
  
  `BASH'
***************
*** 3359,3363 ****
  
  `BASH_VERSINFO'
!      A readonly array variable (*note Arrays::.)  whose members hold
       version information for this instance of Bash.  The values
       assigned to the array members are as follows:
--- 3380,3384 ----
  
  `BASH_VERSINFO'
!      A readonly array variable (*note Arrays::) whose members hold
       version information for this instance of Bash.  The values
       assigned to the array members are as follows:
***************
*** 3385,3389 ****
       current command line.  This variable is available only in shell
       functions invoked by the programmable completion facilities (*note
!      Programmable Completion::.).
  
  `COMP_CWORD'
--- 3406,3410 ----
       current command line.  This variable is available only in shell
       functions invoked by the programmable completion facilities (*note
!      Programmable Completion::).
  
  `COMP_CWORD'
***************
*** 3391,3400 ****
       cursor position.  This variable is available only in shell
       functions invoked by the programmable completion facilities (*note
!      Programmable Completion::.).
  
  `COMP_LINE'
       The current command line.  This variable is available only in
       shell functions and external commands invoked by the programmable
!      completion facilities (*note Programmable Completion::.).
  
  `COMP_POINT'
--- 3412,3421 ----
       cursor position.  This variable is available only in shell
       functions invoked by the programmable completion facilities (*note
!      Programmable Completion::).
  
  `COMP_LINE'
       The current command line.  This variable is available only in
       shell functions and external commands invoked by the programmable
!      completion facilities (*note Programmable Completion::).
  
  `COMP_POINT'
***************
*** 3404,3413 ****
       `${#COMP_LINE}'.  This variable is available only in shell
       functions and external commands invoked by the programmable
!      completion facilities (*note Programmable Completion::.).
  
  `COMPREPLY'
       An array variable from which Bash reads the possible completions
       generated by a shell function invoked by the programmable
!      completion facility (*note Programmable Completion::.).
  
  `DIRSTACK'
--- 3425,3434 ----
       `${#COMP_LINE}'.  This variable is available only in shell
       functions and external commands invoked by the programmable
!      completion facilities (*note Programmable Completion::).
  
  `COMPREPLY'
       An array variable from which Bash reads the possible completions
       generated by a shell function invoked by the programmable
!      completion facility (*note Programmable Completion::).
  
  `DIRSTACK'
***************
*** 3444,3455 ****
       An array variable containing the list of groups of which the
       current user is a member.  Assignments to `GROUPS' have no effect
!      and are silently discarded.  If `GROUPS' is unset, it loses its
       special properties, even if it is subsequently reset.
  
  `histchars'
       Up to three characters which control history expansion, quick
!      substitution, and tokenization (*note History Interaction::.).
!      The first character is the HISTORY EXPANSION character, that is,
!      the character which signifies the start of a history expansion,
       normally `!'.  The second character is the character which
       signifies `quick substitution' when seen as the first character on
--- 3465,3476 ----
       An array variable containing the list of groups of which the
       current user is a member.  Assignments to `GROUPS' have no effect
!      and return an error status.  If `GROUPS' is unset, it loses its
       special properties, even if it is subsequently reset.
  
  `histchars'
       Up to three characters which control history expansion, quick
!      substitution, and tokenization (*note History Interaction::).  The
!      first character is the HISTORY EXPANSION character, that is, the
!      character which signifies the start of a history expansion,
       normally `!'.  The second character is the character which
       signifies `quick substitution' when seen as the first character on
***************
*** 3470,3474 ****
       The name of any currently-executing shell function.  This variable
       exists only when a shell function is executing.  Assignments to
!      `FUNCNAME' have no effect and are silently discarded.  If
       `FUNCNAME' is unset, it loses its special properties, even if it
       is subsequently reset.
--- 3491,3495 ----
       The name of any currently-executing shell function.  This variable
       exists only when a shell function is executing.  Assignments to
!      `FUNCNAME' have no effect and return an error status.  If
       `FUNCNAME' is unset, it loses its special properties, even if it
       is subsequently reset.
***************
*** 3562,3575 ****
       range expressions, equivalence classes, and collating sequences
       within filename expansion and pattern matching (*note Filename
!      Expansion::.).
  
  `LC_CTYPE'
       This variable determines the interpretation of characters and the
       behavior of character classes within filename expansion and pattern
!      matching (*note Filename Expansion::.).
  
  `LC_MESSAGES'
       This variable determines the locale used to translate double-quoted
!      strings preceded by a `$' (*note Locale Translation::.).
  
  `LC_NUMERIC'
--- 3583,3596 ----
       range expressions, equivalence classes, and collating sequences
       within filename expansion and pattern matching (*note Filename
!      Expansion::).
  
  `LC_CTYPE'
       This variable determines the interpretation of characters and the
       behavior of character classes within filename expansion and pattern
!      matching (*note Filename Expansion::).
  
  `LC_MESSAGES'
       This variable determines the locale used to translate double-quoted
!      strings preceded by a `$' (*note Locale Translation::).
  
  `LC_NUMERIC'
***************
*** 3577,3580 ****
--- 3598,3611 ----
       formatting.
  
+ `LINES'
+      Used by the `select' builtin command to determine the column length
+      for printing selection lists.  Automatically set upon receipt of a
+      `SIGWINCH'.
+ 
+ `COLUMNS'
+      Used by the `select' builtin command to determine the terminal
+      width when printing selection lists.  Automatically set upon
+      receipt of a `SIGWINCH'.
+ 
  `LINENO'
       The line number in the script or shell function currently
***************
*** 3587,3591 ****
  `MAILCHECK'
       How often (in seconds) that the shell should check for mail in the
!      files specified in the `MAILPATH' or `MAIL' variables.
  
  `OLDPWD'
--- 3618,3626 ----
  `MAILCHECK'
       How often (in seconds) that the shell should check for mail in the
!      files specified in the `MAILPATH' or `MAIL' variables.  The
!      default is 60 seconds.  When it is time to check for mail, the
!      shell does so before displaying the primary prompt.  If this
!      variable is unset, or set to a value that is not a number greater
!      than or equal to zero, the shell disables mail checking.
  
  `OLDPWD'
***************
*** 3600,3604 ****
  
  `PIPESTATUS'
!      An array variable (*note Arrays::.)  containing a list of exit
       status values from the processes in the most-recently-executed
       foreground pipeline (which may contain only a single command).
--- 3635,3639 ----
  
  `PIPESTATUS'
!      An array variable (*note Arrays::) containing a list of exit
       status values from the processes in the most-recently-executed
       foreground pipeline (which may contain only a single command).
***************
*** 3619,3623 ****
  `PS4'
       The value is the prompt printed before the command line is echoed
!      when the `-x' option is set (*note The Set Builtin::.).  The first
       character of `PS4' is replicated multiple times, as necessary, to
       indicate multiple levels of indirection.  The default is `+ '.
--- 3654,3658 ----
  `PS4'
       The value is the prompt printed before the command line is echoed
!      when the `-x' option is set (*note The Set Builtin::).  The first
       character of `PS4' is replicated multiple times, as necessary, to
       indicate multiple levels of indirection.  The default is `+ '.
***************
*** 3643,3647 ****
       A colon-separated list of enabled shell options.  Each word in the
       list is a valid argument for the `-o' option to the `set' builtin
!      command (*note The Set Builtin::.).  The options appearing in
       `SHELLOPTS' are those reported as `on' by `set -o'.  If this
       variable is in the environment when Bash starts up, each shell
--- 3678,3682 ----
       A colon-separated list of enabled shell options.  Each word in the
       list is a valid argument for the `-o' option to the `set' builtin
!      command (*note The Set Builtin::).  The options appearing in
       `SHELLOPTS' are those reported as `on' by `set -o'.  If this
       variable is in the environment when Bash starts up, each shell
***************
*** 3738,3742 ****
  
     In addition to the single-character shell command-line options
! (*note The Set Builtin::.), there are several multi-character options
  that you can use.  These options must appear on the command line before
  the single-character options in order for them to be recognized.
--- 3773,3777 ----
  
     In addition to the single-character shell command-line options
! (*note The Set Builtin::), there are several multi-character options
  that you can use.  These options must appear on the command line before
  the single-character options in order for them to be recognized.
***************
*** 3753,3766 ****
       Display a usage message on standard output and exit sucessfully.
  
  `--login'
!      Make this shell act as if it were directly invoked by login.  This
!      is equivalent to `exec -l bash' but can be issued from another
!      shell, such as `csh'.  `exec bash --login' will replace the
!      current shell with a Bash login shell.  *Note Bash Startup
!      Files::, for a description of the special behavior of a login
!      shell.
  
  `--noediting'
!      Do not use the GNU Readline library (*note Command Line Editing::.)
       to read  command lines when the shell is interactive.
  
--- 3788,3807 ----
       Display a usage message on standard output and exit sucessfully.
  
+ `--init-file FILENAME'
+ `--rcfile FILENAME'
+      Execute commands from FILENAME (instead of `~/.bashrc') in an
+      interactive shell.
+ 
  `--login'
!      Make this shell act as if it had been directly invoked by login.
!      When the shell is interactive, this is equivalent to starting a
!      login shell with `exec -l bash'.  When the shell is not
!      interactive, the login shell startup files will be executed.
!      `exec bash --login' will replace the current shell with a Bash
!      login shell.  *Note Bash Startup Files::, for a description of the
!      special behavior of a login shell.
  
  `--noediting'
!      Do not use the GNU Readline library (*note Command Line Editing::)
       to read  command lines when the shell is interactive.
  
***************
*** 3782,3791 ****
       POSIX mode.
  
- `--rcfile FILENAME'
-      Execute commands from FILENAME (instead of `~/.bashrc') in an
-      interactive shell.
- 
  `--restricted'
!      Make the shell a restricted shell (*note The Restricted Shell::.).
  
  `--verbose'
--- 3823,3828 ----
       POSIX mode.
  
  `--restricted'
!      Make the shell a restricted shell (*note The Restricted Shell::).
  
  `--verbose'
***************
*** 3809,3813 ****
  
  `-r'
!      Make the shell a restricted shell (*note The Restricted Shell::.).
  
  `-s'
--- 3846,3850 ----
  
  `-r'
!      Make the shell a restricted shell (*note The Restricted Shell::).
  
  `-s'
***************
*** 3821,3825 ****
       the standard ouput.  These are the strings that are subject to
       language translation when the current locale is not `C' or `POSIX'
!      (*note Locale Translation::.).  This implies the `-n' option; no
       commands will be executed.
  
--- 3858,3862 ----
       the standard ouput.  These are the strings that are subject to
       language translation when the current locale is not `C' or `POSIX'
!      (*note Locale Translation::).  This implies the `-n' option; no
       commands will be executed.
  
***************
*** 3829,3847 ****
       and arguments.
  
!    An *interactive* shell is one started without non-option arguments,
  unless `-s' is specified, without specifying the `-c' option, and whose
  input and output are both connected to terminals (as determined by
  `isatty(3)'), or one started with the `-i' option.  *Note Interactive
! Shells:: for more information.
  
     If arguments remain after option processing, and neither the `-c'
  nor the `-s' option has been supplied, the first argument is assumed to
! be the name of a file containing shell commands (*note Shell
! Scripts::.).  When Bash is invoked in this fashion, `$0' is set to the
! name of the file, and the positional parameters are set to the
! remaining arguments.  Bash reads and executes commands from this file,
! then exits.  Bash's exit status is the exit status of the last command
! executed in the script.  If no commands are executed, the exit status
! is 0.
  
  
--- 3866,3883 ----
       and arguments.
  
!    An _interactive_ shell is one started without non-option arguments,
  unless `-s' is specified, without specifying the `-c' option, and whose
  input and output are both connected to terminals (as determined by
  `isatty(3)'), or one started with the `-i' option.  *Note Interactive
! Shells::, for more information.
  
     If arguments remain after option processing, and neither the `-c'
  nor the `-s' option has been supplied, the first argument is assumed to
! be the name of a file containing shell commands (*note Shell Scripts::).
! When Bash is invoked in this fashion, `$0' is set to the name of the
! file, and the positional parameters are set to the remaining arguments.
! Bash reads and executes commands from this file, then exits.  Bash's
! exit status is the exit status of the last command executed in the
! script.  If no commands are executed, the exit status is 0.
  
  
***************
*** 3854,3858 ****
  of the files exist but cannot be read, Bash reports an error.  Tildes
  are expanded in file names as described above under Tilde Expansion
! (*note Tilde Expansion::.).
  
     Interactive shells are described in *Note Interactive Shells::.
--- 3890,3894 ----
  of the files exist but cannot be read, Bash reports an error.  Tildes
  are expanded in file names as described above under Tilde Expansion
! (*note Tilde Expansion::).
  
     Interactive shells are described in *Note Interactive Shells::.
***************
*** 3900,3903 ****
--- 3936,3943 ----
  name.
  
+    As noted above, if a non-interactive shell is invoked with the
+ `--login' option, Bash attempts to read and execute commands from the
+ login shell startup files.
+ 
  Invoked with name `sh'
  ......................
***************
*** 3998,4004 ****
       esac
  
!    Alternatively, startup scripts may examine the variable `$PS1'; it
! is unset in non-interactive shells, and set in interactive shells.
! Thus:
  
       if [ -z "$PS1" ]; then
--- 4038,4043 ----
       esac
  
!    Alternatively, startup scripts may examine the variable `PS1'; it is
! unset in non-interactive shells, and set in interactive shells.  Thus:
  
       if [ -z "$PS1" ]; then
***************
*** 4020,4072 ****
       Startup Files::.
  
!   2. Job Control (*note Job Control::.) is enabled by default.  When job
       control is in effect, Bash ignores the keyboard-generated job
       control signals `SIGTTIN', `SIGTTOU', and `SIGTSTP'.
  
!   3. Bash expands and displays `$PS1' before reading the first line of
!      a command, and expands and displays `$PS2' before reading the
!      second and subsequent lines of a multi-line command.
  
    4. Bash executes the value of the `PROMPT_COMMAND' variable as a
       command before printing the primary prompt, `$PS1' (*note Bash
!      Variables::.).
  
!   5. Readline (*note Command Line Editing::.) is used to read commands
       from the user's terminal.
  
    6. Bash inspects the value of the `ignoreeof' option to `set -o'
       instead of exiting immediately when it receives an `EOF' on its
!      standard input when reading a command (*note The Set Builtin::.).
  
!   7. Command history (*note Bash History Facilities::.)  and history
!      expansion (*note History Interaction::.)  are enabled by default.
       Bash will save the command history to the file named by `$HISTFILE'
       when an interactive shell exits.
  
!   8. Alias expansion (*note Aliases::.) is performed by default.
  
    9. In the absence of any traps, Bash ignores `SIGTERM' (*note
!      Signals::.).
  
   10. In the absence of any traps, `SIGINT' is caught and handled
!      ((*note Signals::.).  `SIGINT' will interrupt some shell builtins.
  
   11. An interactive login shell sends a `SIGHUP' to all jobs on exit if
!      the `hupoxexit' shell option has been enabled (*note Signals::.).
  
   12. The `-n' invocation option is ignored, and `set -n' has no effect
!      (*note The Set Builtin::.).
  
   13. Bash will check for mail periodically, depending on the values of
       the `MAIL', `MAILPATH', and `MAILCHECK' shell variables (*note
!      Bash Variables::.).
  
   14. Expansion errors due to references to unbound shell variables after
       `set -u' has been enabled will not cause the shell to exit (*note
!      The Set Builtin::.).
  
   15. The shell will not exit on expansion errors caused by VAR being
       unset or null in `${VAR:?WORD}' expansions (*note Shell Parameter
!      Expansion::.).
  
   16. Redirection errors encountered by shell builtins will not cause the
--- 4059,4111 ----
       Startup Files::.
  
!   2. Job Control (*note Job Control::) is enabled by default.  When job
       control is in effect, Bash ignores the keyboard-generated job
       control signals `SIGTTIN', `SIGTTOU', and `SIGTSTP'.
  
!   3. Bash expands and displays `PS1' before reading the first line of a
!      command, and expands and displays `PS2' before reading the second
!      and subsequent lines of a multi-line command.
  
    4. Bash executes the value of the `PROMPT_COMMAND' variable as a
       command before printing the primary prompt, `$PS1' (*note Bash
!      Variables::).
  
!   5. Readline (*note Command Line Editing::) is used to read commands
       from the user's terminal.
  
    6. Bash inspects the value of the `ignoreeof' option to `set -o'
       instead of exiting immediately when it receives an `EOF' on its
!      standard input when reading a command (*note The Set Builtin::).
  
!   7. Command history (*note Bash History Facilities::) and history
!      expansion (*note History Interaction::) are enabled by default.
       Bash will save the command history to the file named by `$HISTFILE'
       when an interactive shell exits.
  
!   8. Alias expansion (*note Aliases::) is performed by default.
  
    9. In the absence of any traps, Bash ignores `SIGTERM' (*note
!      Signals::).
  
   10. In the absence of any traps, `SIGINT' is caught and handled
!      ((*note Signals::).  `SIGINT' will interrupt some shell builtins.
  
   11. An interactive login shell sends a `SIGHUP' to all jobs on exit if
!      the `hupoxexit' shell option has been enabled (*note Signals::).
  
   12. The `-n' invocation option is ignored, and `set -n' has no effect
!      (*note The Set Builtin::).
  
   13. Bash will check for mail periodically, depending on the values of
       the `MAIL', `MAILPATH', and `MAILCHECK' shell variables (*note
!      Bash Variables::).
  
   14. Expansion errors due to references to unbound shell variables after
       `set -u' has been enabled will not cause the shell to exit (*note
!      The Set Builtin::).
  
   15. The shell will not exit on expansion errors caused by VAR being
       unset or null in `${VAR:?WORD}' expansions (*note Shell Parameter
!      Expansion::).
  
   16. Redirection errors encountered by shell builtins will not cause the
***************
*** 4074,4081 ****
  
   17. When running in POSIX mode, a special builtin returning an error
!      status will not cause the shell to exit (*note Bash POSIX Mode::.).
  
   18. A failed `exec' will not cause the shell to exit (*note Bourne
!      Shell Builtins::.).
  
   19. Parser syntax errors will not cause the shell to exit.
--- 4113,4120 ----
  
   17. When running in POSIX mode, a special builtin returning an error
!      status will not cause the shell to exit (*note Bash POSIX Mode::).
  
   18. A failed `exec' will not cause the shell to exit (*note Bourne
!      Shell Builtins::).
  
   19. Parser syntax errors will not cause the shell to exit.
***************
*** 4087,4091 ****
   21. The shell will check the value of the `TMOUT' variable and exit if
       a command is not read within the specified number of seconds after
!      printing `$PS1' (*note Bash Variables::.).
  
  
--- 4126,4130 ----
   21. The shell will check the value of the `TMOUT' variable and exit if
       a command is not read within the specified number of seconds after
!      printing `$PS1' (*note Bash Variables::).
  
  
***************
*** 4182,4186 ****
       True if shell option OPTNAME is enabled.  The list of options
       appears in the description of the `-o' option to the `set' builtin
!      (*note The Set Builtin::.).
  
  `-z STRING'
--- 4221,4225 ----
       True if shell option OPTNAME is enabled.  The list of options
       appears in the description of the `-o' option to the `set' builtin
!      (*note The Set Builtin::).
  
  `-z STRING'
***************
*** 4331,4339 ****
     There is no mechanism for using arguments in the replacement text,
  as in `csh'.  If arguments are needed, a shell function should be used
! (*note Shell Functions::.).
  
     Aliases are not expanded when the shell is not interactive, unless
  the `expand_aliases' shell option is set using `shopt' (*note Bash
! Builtins::.).
  
     The rules concerning the definition and use of aliases are somewhat
--- 4370,4378 ----
     There is no mechanism for using arguments in the replacement text,
  as in `csh'.  If arguments are needed, a shell function should be used
! (*note Shell Functions::).
  
     Aliases are not expanded when the shell is not interactive, unless
  the `expand_aliases' shell option is set using `shopt' (*note Bash
! Builtins::).
  
     The rules concerning the definition and use of aliases are somewhat
***************
*** 4617,4626 ****
  history number of a command is its position in the history list, which
  may include commands restored from the history file (*note Bash History
! Facilities::.), while the command number is the position in the
! sequence of commands executed during the current shell session.
  
     After the string is decoded, it is expanded via parameter expansion,
  command substitution, arithmetic expansion, and quote removal, subject
! to the value of the `promptvars' shell option (*note Bash Builtins::.).
  
  
--- 4656,4665 ----
  history number of a command is its position in the history list, which
  may include commands restored from the history file (*note Bash History
! Facilities::), while the command number is the position in the sequence
! of commands executed during the current shell session.
  
     After the string is decoded, it is expanded via parameter expansion,
  command substitution, arithmetic expansion, and quote removal, subject
! to the value of the `promptvars' shell option (*note Bash Builtins::).
  
  
***************
*** 4683,4690 ****
       available with `shopt -s checkhash'.
  
!   2. The `>&' redirection does not redirect stdout and stderr.
  
    3. The message printed by the job control code and builtins when a job
!      exits with a non-zero status is `Done(status)'.
  
    4. Reserved words may not be aliased.
--- 4722,4731 ----
       available with `shopt -s checkhash'.
  
!   2. The message printed by the job control code and builtins when a job
!      exits with a non-zero status is `Done(status)'.
  
    3. The message printed by the job control code and builtins when a job
!      is stopped is `Stopped(SIGNAME)', where SIGNAME is, for example,
!      `SIGTSTP'.
  
    4. Reserved words may not be aliased.
***************
*** 4740,4744 ****
       contain any symbolic links, as if `cd -P' had been executed.
  
!  19. If `$CDPATH' is set, the `cd' builtin will not implicitly append
       the current directory to it.  This means that `cd' will fail if no
       valid directory name can be constructed from any of the entries in
--- 4781,4785 ----
       contain any symbolic links, as if `cd -P' had been executed.
  
!  19. If `CDPATH' is set, the `cd' builtin will not implicitly append
       the current directory to it.  This means that `cd' will fail if no
       valid directory name can be constructed from any of the entries in
***************
*** 4760,4766 ****
       persist in the shell environment after the builtin completes.
  
!  24. The `export' and `readonly' builtin commands display their output
       in the format required by POSIX 1003.2.
  
  
     There is other POSIX 1003.2 behavior that Bash does not implement.
--- 4801,4825 ----
       persist in the shell environment after the builtin completes.
  
!  24. Assignment statements preceding shell function calls persist in the
!      shell environment after the function returns, as if a POSIX
!      special builtin command had been executed.
! 
!  25. The `export' and `readonly' builtin commands display their output
       in the format required by POSIX 1003.2.
  
+  26. The `trap' builtin displays signal names without the leading `SIG'.
+ 
+  27. The `.' and `source' builtins do not search the current directory
+      for the filename argument if it is not found by searching `PATH'.
+ 
+  28. Subshells spawned to execute command substitutions inherit the
+      value of the `-e' option from the parent shell.  When not in POSIX
+      mode, Bash clears the `-e' option in such subshells.
+ 
+  29. Alias expansion is always enabled, even in non-interactive shells.
+ 
+  30. When the `set' builtin is invoked without options, it does not
+      display shell function names and definitions.
+ 
  
     There is other POSIX 1003.2 behavior that Bash does not implement.
***************
*** 4770,4773 ****
--- 4829,4842 ----
       builtins, not just special ones.
  
+   2. When a subshell is created to execute a shell script with execute
+      permission, but without a leading `#!', Bash sets `$0' to the full
+      pathname of the script as found by searching `$PATH', rather than
+      the command as typed by the user.
+ 
+   3. When using `.' to source a shell script found in `$PATH', bash
+      checks execute permission bits rather than read permission bits,
+      just as if it were searching for a command.
+ 
+ 
  
  File: bashref.info,  Node: Job Control,  Next: Using History Interactively,  Prev: Bash Features,  Up: Top
***************
*** 4861,4865 ****
  reporting changes in a job's status so as to not interrupt any other
  output.  If the the `-b' option to the `set' builtin is enabled, Bash
! reports such changes immediately (*note The Set Builtin::.).
  
     If an attempt to exit Bash is while jobs are stopped, the shell
--- 4930,4934 ----
  reporting changes in a job's status so as to not interrupt any other
  output.  If the the `-b' option to the `set' builtin is enabled, Bash
! reports such changes immediately (*note The Set Builtin::).
  
     If an attempt to exit Bash is while jobs are stopped, the shell
***************
*** 4990,4995 ****
       name of a stopped job.  The `substring' value provides
       functionality analogous to the `%?' job ID (*note Job Control
!      Basics::.).  If set to any other value, the supplied string must
!      be a prefix of a stopped job's name; this provides functionality
       analogous to the `%' job ID.
  
--- 5059,5064 ----
       name of a stopped job.  The `substring' value provides
       functionality analogous to the `%?' job ID (*note Job Control
!      Basics::).  If set to any other value, the supplied string must be
!      a prefix of a stopped job's name; this provides functionality
       analogous to the `%' job ID.
  
***************
*** 5028,5035 ****
  keystrokes.
  
!    The text <C-k> is read as `Control-K' and describes the character
  produced when the <k> key is pressed while the Control key is depressed.
  
!    The text <M-k> is read as `Meta-K' and describes the character
  produced when the Meta key (if you have one) is depressed, and the <k>
  key is pressed.  The Meta key is labeled <ALT> on many keyboards.  On
--- 5097,5104 ----
  keystrokes.
  
!    The text `C-k' is read as `Control-K' and describes the character
  produced when the <k> key is pressed while the Control key is depressed.
  
!    The text `M-k' is read as `Meta-K' and describes the character
  produced when the Meta key (if you have one) is depressed, and the <k>
  key is pressed.  The Meta key is labeled <ALT> on many keyboards.  On
***************
*** 5042,5057 ****
     If you do not have a Meta or <ALT> key, or another key working as a
  Meta key, the identical keystroke can be generated by typing <ESC>
! first, and then typing <k>.  Either process is known as "metafying" the
! <k> key.
  
!    The text <M-C-k> is read as `Meta-Control-k' and describes the
! character produced by "metafying" <C-k>.
  
     In addition, several keys have their own names.  Specifically,
  <DEL>, <ESC>, <LFD>, <SPC>, <RET>, and <TAB> all stand for themselves
! when seen in this text, or in an init file (*note Readline Init
! File::.).  If your keyboard lacks a <LFD> key, typing <C-j> will
! produce the desired character.  The <RET> key may be labeled <Return>
! or <Enter> on some keyboards.
  
  
--- 5111,5126 ----
     If you do not have a Meta or <ALT> key, or another key working as a
  Meta key, the identical keystroke can be generated by typing <ESC>
! _first_, and then typing <k>.  Either process is known as "metafying"
! the <k> key.
  
!    The text `M-C-k' is read as `Meta-Control-k' and describes the
! character produced by "metafying" `C-k'.
  
     In addition, several keys have their own names.  Specifically,
  <DEL>, <ESC>, <LFD>, <SPC>, <RET>, and <TAB> all stand for themselves
! when seen in this text, or in an init file (*note Readline Init File::).
! If your keyboard lacks a <LFD> key, typing <C-j> will produce the
! desired character.  The <RET> key may be labeled <Return> or <Enter> on
! some keyboards.
  
  
***************
*** 5068,5074 ****
  you move the cursor to the place that needs correction, and delete or
  insert the text of the corrections.  Then, when you are satisfied with
! the line, you simply press <RETURN>.  You do not have to be at the end
! of the line to press <RETURN>; the entire line is accepted regardless
! of the location of the cursor within the line.
  
  * Menu:
--- 5137,5143 ----
  you move the cursor to the place that needs correction, and delete or
  insert the text of the corrections.  Then, when you are satisfied with
! the line, you simply press <RET>.  You do not have to be at the end of
! the line to press <RET>; the entire line is accepted regardless of the
! location of the cursor within the line.
  
  * Menu:
***************
*** 5093,5098 ****
     Sometimes you may mistype a character, and not notice the error
  until you have typed several other characters.  In that case, you can
! type <C-b> to move the cursor to the left, and then correct your
! mistake.  Afterwards, you can move the cursor to the right with <C-f>.
  
     When you add text in the middle of a line, you will notice that
--- 5162,5167 ----
     Sometimes you may mistype a character, and not notice the error
  until you have typed several other characters.  In that case, you can
! type `C-b' to move the cursor to the left, and then correct your
! mistake.  Afterwards, you can move the cursor to the right with `C-f'.
  
     When you add text in the middle of a line, you will notice that
***************
*** 5104,5111 ****
  follows.
  
! <C-b>
       Move back one character.
  
! <C-f>
       Move forward one character.
  
--- 5173,5180 ----
  follows.
  
! `C-b'
       Move back one character.
  
! `C-f'
       Move forward one character.
  
***************
*** 5113,5117 ****
       Delete the character to the left of the cursor.
  
! <C-d>
       Delete the character underneath the cursor.
  
--- 5182,5186 ----
       Delete the character to the left of the cursor.
  
! `C-d'
       Delete the character underneath the cursor.
  
***************
*** 5119,5123 ****
       Insert the character into the line at the cursor.
  
! <C-_> or <C-x C-u>
       Undo the last editing command.  You can undo all the way back to an
       empty line.
--- 5188,5192 ----
       Insert the character into the line at the cursor.
  
! `C-_' or `C-x C-u'
       Undo the last editing command.  You can undo all the way back to an
       empty line.
***************
*** 5125,5129 ****
  (Depending on your configuration, the <Backspace> key be set to delete
  the character to the left of the cursor and the <DEL> key set to delete
! the character underneath the cursor, like <C-d>, rather than the
  character to the left of the cursor.)
  
--- 5194,5198 ----
  (Depending on your configuration, the <Backspace> key be set to delete
  the character to the left of the cursor and the <DEL> key set to delete
! the character underneath the cursor, like `C-d', rather than the
  character to the left of the cursor.)
  
***************
*** 5136,5159 ****
     The above table describes the most basic keystrokes that you need in
  order to do editing of the input line.  For your convenience, many
! other commands have been added in addition to <C-b>, <C-f>, <C-d>, and
  <DEL>.  Here are some commands for moving more rapidly about the line.
  
! <C-a>
       Move to the start of the line.
  
! <C-e>
       Move to the end of the line.
  
! <M-f>
       Move forward a word, where a word is composed of letters and
       digits.
  
! <M-b>
       Move backward a word.
  
! <C-l>
       Clear the screen, reprinting the current line at the top.
  
!    Notice how <C-f> moves forward a character, while <M-f> moves
  forward a word.  It is a loose convention that control keystrokes
  operate on characters while meta keystrokes operate on words.
--- 5205,5228 ----
     The above table describes the most basic keystrokes that you need in
  order to do editing of the input line.  For your convenience, many
! other commands have been added in addition to `C-b', `C-f', `C-d', and
  <DEL>.  Here are some commands for moving more rapidly about the line.
  
! `C-a'
       Move to the start of the line.
  
! `C-e'
       Move to the end of the line.
  
! `M-f'
       Move forward a word, where a word is composed of letters and
       digits.
  
! `M-b'
       Move backward a word.
  
! `C-l'
       Clear the screen, reprinting the current line at the top.
  
!    Notice how `C-f' moves forward a character, while `M-f' moves
  forward a word.  It is a loose convention that control keystrokes
  operate on characters while meta keystrokes operate on words.
***************
*** 5182,5213 ****
     Here is the list of commands for killing text.
  
! <C-k>
       Kill the text from the current cursor position to the end of the
       line.
  
! <M-d>
       Kill from the cursor to the end of the current word, or, if between
       words, to the end of the next word.  Word boundaries are the same
!      as those used by <M-f>.
  
! <M-DEL>
       Kill from the cursor the start of the previous word, or, if between
       words, to the start of the previous word.  Word boundaries are the
!      same as those used by <M-b>.
  
! <C-w>
       Kill from the cursor to the previous whitespace.  This is
!      different than <M-DEL> because the word boundaries differ.
  
     Here is how to "yank" the text back into the line.  Yanking means to
  copy the most-recently-killed text from the kill buffer.
  
! <C-y>
       Yank the most recently killed text back into the buffer at the
       cursor.
  
! <M-y>
       Rotate the kill-ring, and yank the new top.  You can only do this
!      if the prior command is <C-y> or <M-y>.
  
  
--- 5251,5282 ----
     Here is the list of commands for killing text.
  
! `C-k'
       Kill the text from the current cursor position to the end of the
       line.
  
! `M-d'
       Kill from the cursor to the end of the current word, or, if between
       words, to the end of the next word.  Word boundaries are the same
!      as those used by `M-f'.
  
! `M-<DEL>'
       Kill from the cursor the start of the previous word, or, if between
       words, to the start of the previous word.  Word boundaries are the
!      same as those used by `M-b'.
  
! `C-w'
       Kill from the cursor to the previous whitespace.  This is
!      different than `M-<DEL>' because the word boundaries differ.
  
     Here is how to "yank" the text back into the line.  Yanking means to
  copy the most-recently-killed text from the kill buffer.
  
! `C-y'
       Yank the most recently killed text back into the buffer at the
       cursor.
  
! `M-y'
       Rotate the kill-ring, and yank the new top.  You can only do this
!      if the prior command is `C-y' or `M-y'.
  
  
***************
*** 5229,5233 ****
  have typed one meta digit to get the argument started, you can type the
  remainder of the digits, and then the command.  For example, to give
! the <C-d> command an argument of 10, you could type `M-1 0 C-d'.
  
  
--- 5298,5303 ----
  have typed one meta digit to get the argument started, you can type the
  remainder of the digits, and then the command.  For example, to give
! the `C-d' command an argument of 10, you could type `M-1 0 C-d', which
! will delete the next ten characters on the input line.
  
  
***************
*** 5238,5243 ****
  
     Readline provides commands for searching through the command history
! (*note Bash History Facilities::.)  for lines containing a specified
! string.  There are two search modes:  INCREMENTAL and NON-INCREMENTAL.
  
     Incremental searches begin before the user has finished typing the
--- 5308,5314 ----
  
     Readline provides commands for searching through the command history
! (*note Bash History Facilities::) for lines containing a specified
! string.  There are two search modes:  "incremental" and
! "non-incremental".
  
     Incremental searches begin before the user has finished typing the
***************
*** 5246,5265 ****
  typed so far.  An incremental search requires only as many characters
  as needed to find the desired history entry.  To search backward in the
! history for a particular string, type <C-r>.  Typing <C-s> searches
  forward through the history.  The characters present in the value of
  the `isearch-terminators' variable are used to terminate an incremental
  search.  If that variable has not been assigned a value, the <ESC> and
! <C-J> characters will terminate an incremental search.  <C-g> will
  abort an incremental search and restore the original line.  When the
  search is terminated, the history entry containing the search string
  becomes the current line.
  
!    To find other matching entries in the history list, type <C-r> or
! <C-s> as appropriate.  This will search backward or forward in the
  history for the next entry matching the search string typed so far.
  Any other key sequence bound to a Readline command will terminate the
  search and execute that command.  For instance, a <RET> will terminate
  the search and accept the line, thereby executing the command from the
! history list.
  
     Non-incremental searches read the entire search string before
--- 5317,5337 ----
  typed so far.  An incremental search requires only as many characters
  as needed to find the desired history entry.  To search backward in the
! history for a particular string, type `C-r'.  Typing `C-s' searches
  forward through the history.  The characters present in the value of
  the `isearch-terminators' variable are used to terminate an incremental
  search.  If that variable has not been assigned a value, the <ESC> and
! `C-J' characters will terminate an incremental search.  `C-g' will
  abort an incremental search and restore the original line.  When the
  search is terminated, the history entry containing the search string
  becomes the current line.
  
!    To find other matching entries in the history list, type `C-r' or
! `C-s' as appropriate.  This will search backward or forward in the
  history for the next entry matching the search string typed so far.
  Any other key sequence bound to a Readline command will terminate the
  search and execute that command.  For instance, a <RET> will terminate
  the search and accept the line, thereby executing the command from the
! history list.  A movement command will terminate the search, make the
! last line found the current line, and begin editing.
  
     Non-incremental searches read the entire search string before
***************
*** 5304,5308 ****
  file.  Blank lines are ignored.  Lines beginning with a `#' are
  comments.  Lines beginning with a `$' indicate conditional constructs
! (*note Conditional Init Constructs::.).  Other lines denote variable
  settings and key bindings.
  
--- 5376,5380 ----
  file.  Blank lines are ignored.  Lines beginning with a `#' are
  comments.  Lines beginning with a `$' indicate conditional constructs
! (*note Conditional Init Constructs::).  Other lines denote variable
  settings and key bindings.
  
***************
*** 5310,5318 ****
       You can modify the run-time behavior of Readline by altering the
       values of variables in Readline using the `set' command within the
!      init file.  Here is how to change from the default Emacs-like key
!      binding to use `vi' line editing commands:
  
            set editing-mode vi
  
       The `bind -V' command lists the current Readline variable names
       and values.  *Note Bash Builtins::.
--- 5382,5397 ----
       You can modify the run-time behavior of Readline by altering the
       values of variables in Readline using the `set' command within the
!      init file.  The syntax is simple:
! 
!           set VARIABLE VALUE
! 
!      Here, for example, is how to change from the default Emacs-like
!      key binding to use `vi' line editing commands:
  
            set editing-mode vi
  
+      Variable names and values, where appropriate, are recognized
+      without regard to case.
+ 
       The `bind -V' command lists the current Readline variable names
       and values.  *Note Bash Builtins::.
***************
*** 5344,5348 ****
            greater than this value, Readline will ask the user whether
            or not he wishes to view them; otherwise, they are simply
!           listed.  The default limit is `100'.
  
      `convert-meta'
--- 5423,5428 ----
            greater than this value, Readline will ask the user whether
            or not he wishes to view them; otherwise, they are simply
!           listed.  This variable must be set to an integer value
!           greater than or equal to 0.  The default limit is `100'.
  
      `convert-meta'
***************
*** 5381,5385 ****
      `input-meta'
            If set to `on', Readline will enable eight-bit input (it will
!           not strip the eighth bit from the characters it reads),
            regardless of what the terminal claims it can support.  The
            default value is `off'.  The name `meta-flag' is a synonym
--- 5461,5465 ----
      `input-meta'
            If set to `on', Readline will enable eight-bit input (it will
!           not clear the eighth bit in the characters it reads),
            regardless of what the terminal claims it can support.  The
            default value is `off'.  The name `meta-flag' is a synonym
***************
*** 5389,5394 ****
            The string of characters that should terminate an incremental
            search without subsequently executing the character as a
!           command (*note Searching::.).  If this variable has not been
!           given a value, the characters <ESC> and <C-J> will terminate
            an incremental search.
  
--- 5469,5474 ----
            The string of characters that should terminate an incremental
            search without subsequently executing the character as a
!           command (*note Searching::).  If this variable has not been
!           given a value, the characters <ESC> and `C-J' will terminate
            an incremental search.
  
***************
*** 5396,5400 ****
            Sets Readline's idea of the current keymap for key binding
            commands.  Acceptable `keymap' names are `emacs',
!           `emacs-standard', `emacs-meta', `emacs-ctlx', `vi',
            `vi-command', and `vi-insert'.  `vi' is equivalent to
            `vi-command'; `emacs' is equivalent to `emacs-standard'.  The
--- 5476,5480 ----
            Sets Readline's idea of the current keymap for key binding
            commands.  Acceptable `keymap' names are `emacs',
!           `emacs-standard', `emacs-meta', `emacs-ctlx', `vi', `vi-move',
            `vi-command', and `vi-insert'.  `vi' is equivalent to
            `vi-command'; `emacs' is equivalent to `emacs-standard'.  The
***************
*** 5439,5447 ****
       description of what the command does.
  
!      Once you know the name of the command, simply place the name of
!      the key you wish to bind the command to, a colon, and then the
!      name of the command on a line in the init file.  The name of the
!      key can be expressed in different ways, depending on which is most
!      comfortable for you.
  
       The `bind -p' command displays Readline function names and
--- 5519,5530 ----
       description of what the command does.
  
!      Once you know the name of the command, simply place on a line in
!      the init file the name of the key you wish to bind the command to,
!      a colon, and then the name of the command.  The name of the key
!      can be expressed in different ways, depending on what you find most
!      comfortable.
! 
!      In addition to command names, readline allows keys to be bound to
!      a string that is inserted when the key is pressed (a MACRO).
  
       The `bind -p' command displays Readline function names and
***************
*** 5456,5464 ****
                 Control-o: "> output"
  
!           In the above example, <C-u> is bound to the function
!           `universal-argument', and <C-o> is bound to run the macro
            expressed on the right hand side (that is, to insert the text
            `> output' into the line).
  
      "KEYSEQ": FUNCTION-NAME or MACRO
            KEYSEQ differs from KEYNAME above in that strings denoting an
--- 5539,5552 ----
                 Control-o: "> output"
  
!           In the above example, `C-u' is bound to the function
!           `universal-argument', `M-DEL' is bound to the function
!           `backward-kill-word', and `C-o' is bound to run the macro
            expressed on the right hand side (that is, to insert the text
            `> output' into the line).
  
+           A number of symbolic character names are recognized while
+           processing this key binding syntax: DEL, ESC, ESCAPE, LFD,
+           NEWLINE, RET, RETURN, RUBOUT, SPACE, SPC, and TAB.
+ 
      "KEYSEQ": FUNCTION-NAME or MACRO
            KEYSEQ differs from KEYNAME above in that strings denoting an
***************
*** 5472,5480 ****
                 "\e[11~": "Function Key 1"
  
!           In the above example, <C-u> is bound to the function
            `universal-argument' (just as it was in the first example),
!           `<C-x> <C-r>' is bound to the function `re-read-init-file',
!           and `<ESC> <[> <1> <1> <~>' is bound to insert the text
!           `Function Key 1'.
  
       The following GNU Emacs style escape sequences are available when
--- 5560,5568 ----
                 "\e[11~": "Function Key 1"
  
!           In the above example, `C-u' is again bound to the function
            `universal-argument' (just as it was in the first example),
!           `C-x C-r' is bound to the function `re-read-init-file', and
!           `<ESC> <[> <1> <1> <~>' is bound to insert the text `Function
!           Key 1'.
  
       The following GNU Emacs style escape sequences are available when
***************
*** 5527,5535 ****
  
      `\NNN'
!           the character whose `ASCII' code is the octal value NNN (one
!           to three digits)
  
      `\xNNN'
!           the character whose `ASCII' code is the hexadecimal value NNN
            (one to three digits)
  
--- 5615,5623 ----
  
      `\NNN'
!           the character whose ASCII code is the octal value NNN (one to
!           three digits)
  
      `\xNNN'
!           the character whose ASCII code is the hexadecimal value NNN
            (one to three digits)
  
***************
*** 5580,5587 ****
            application-specific settings.  Each program using the
            Readline library sets the APPLICATION NAME, and you can test
!           for it.  This could be used to bind key sequences to
!           functions useful for a specific program.  For instance, the
!           following command adds a key sequence that quotes the current
!           or previous word in Bash:
                 $if Bash
                 # Quote the current or previous word
--- 5668,5675 ----
            application-specific settings.  Each program using the
            Readline library sets the APPLICATION NAME, and you can test
!           for a particular value.  This could be used to bind key
!           sequences to functions useful for a specific program.  For
!           instance, the following command adds a key sequence that
!           quotes the current or previous word in Bash:
                 $if Bash
                 # Quote the current or previous word
***************
*** 5599,5603 ****
  `$include'
       This directive takes a single filename as an argument and reads
!      commands and bindings from that file.
            $include /etc/inputrc
  
--- 5687,5692 ----
  `$include'
       This directive takes a single filename as an argument and reads
!      commands and bindings from that file.  For example, the following
!      directive reads from `/etc/inputrc':
            $include /etc/inputrc
  
***************
*** 5608,5612 ****
  ----------------
  
!    Here is an example of an inputrc file.  This illustrates key
  binding, variable assignment, and conditional syntax.
  
--- 5697,5701 ----
  ----------------
  
!    Here is an example of an INPUTRC file.  This illustrates key
  binding, variable assignment, and conditional syntax.
  
***************
*** 5730,5740 ****
  sequences.  You can list your key bindings by executing `bind -P' or,
  for a more terse format, suitable for an INPUTRC file, `bind -p'.
! (*Note Bash Builtins::.)
  
!    Command names without an accompanying key sequence are unbound by
! default.  In the following descriptions, POINT refers to the current
! cursor position, and MARK refers to a cursor position saved by the
  `set-mark' command.  The text between the point and mark is referred to
! as the REGION.
  
  
--- 5819,5829 ----
  sequences.  You can list your key bindings by executing `bind -P' or,
  for a more terse format, suitable for an INPUTRC file, `bind -p'.
! (*Note Bash Builtins::.)  Command names without an accompanying key
! sequence are unbound by default.
  
!    In the following descriptions, "point" refers to the current cursor
! position, and "mark" refers to a cursor position saved by the
  `set-mark' command.  The text between the point and mark is referred to
! as the "region".
  
  
***************
*** 5777,5791 ****
  -------------------------------------
  
! `accept-line (Newline, Return)'
       Accept the line regardless of where the cursor is.  If this line is
       non-empty, add it to the history list according to the setting of
!      the `HISTCONTROL' and `HISTIGNORE' variables.  If this line was a
!      history line, then restore the history line to its original state.
  
  `previous-history (C-p)'
!      Move `up' through the history list.
  
  `next-history (C-n)'
!      Move `down' through the history list.
  
  `beginning-of-history (M-<)'
--- 5866,5882 ----
  -------------------------------------
  
! `accept-line (Newline or Return)'
       Accept the line regardless of where the cursor is.  If this line is
       non-empty, add it to the history list according to the setting of
!      the `HISTCONTROL' and `HISTIGNORE' variables.  If this line is a
!      modified history line, then restore the history line to its
!      original state.
  
  `previous-history (C-p)'
!      Move `back' through the history list, fetching the previous
!      command.
  
  `next-history (C-n)'
!      Move `forward' through the history list, fetching the next command.
  
  `beginning-of-history (M-<)'
***************
*** 5827,5836 ****
  `yank-nth-arg (M-C-y)'
       Insert the first argument to the previous command (usually the
!      second word on the previous line).  With an argument N, insert the
!      Nth word from the previous command (the words in the previous
!      command begin with word 0).  A negative argument inserts the Nth
!      word from the end of the previous command.
  
! `yank-last-arg (M-., M-_)'
       Insert last argument to the previous command (the last word of the
       previous history entry).  With an argument, behave exactly like
--- 5918,5927 ----
  `yank-nth-arg (M-C-y)'
       Insert the first argument to the previous command (usually the
!      second word on the previous line) at point.  With an argument N,
!      insert the Nth word from the previous command (the words in the
!      previous command begin with word 0).  A negative argument inserts
!      the Nth word from the end of the previous command.
  
! `yank-last-arg (M-. or M-_)'
       Insert last argument to the previous command (the last word of the
       previous history entry).  With an argument, behave exactly like
***************
*** 5846,5853 ****
  
  `delete-char (C-d)'
!      Delete the character under the cursor.  If the cursor is at the
!      beginning of the line, there are no characters in the line, and
!      the last character typed was not bound to `delete-char', then
!      return `EOF'.
  
  `backward-delete-char (Rubout)'
--- 5937,5943 ----
  
  `delete-char (C-d)'
!      Delete the character at point.  If point is at the beginning of
!      the line, there are no characters in the line, and the last
!      character typed was not bound to `delete-char', then return EOF.
  
  `backward-delete-char (Rubout)'
***************
*** 5860,5866 ****
       deleted.  By default, this is not bound to a key.
  
! `quoted-insert (C-q, C-v)'
       Add the next character typed to the line verbatim.  This is how to
!      insert key sequences like <C-q>, for example.
  
  `self-insert (a, b, A, 1, !, ...)'
--- 5950,5956 ----
       deleted.  By default, this is not bound to a key.
  
! `quoted-insert (C-q or C-v)'
       Add the next character typed to the line verbatim.  This is how to
!      insert key sequences like `C-q', for example.
  
  `self-insert (a, b, A, 1, !, ...)'
***************
*** 5905,5910 ****
  
  `kill-whole-line ()'
!      Kill all characters on the current line, no matter point is.  By
!      default, this is unbound.
  
  `kill-word (M-d)'
--- 5995,6000 ----
  
  `kill-whole-line ()'
!      Kill all characters on the current line, no matter where point is.
!      By default, this is unbound.
  
  `kill-word (M-d)'
***************
*** 5913,5917 ****
       as `forward-word'.
  
! `backward-kill-word (M-DEL)'
       Kill the word behind point.  Word boundaries are the same as
       `backward-word'.
--- 6003,6007 ----
       as `forward-word'.
  
! `backward-kill-word (M-<DEL>)'
       Kill the word behind point.  Word boundaries are the same as
       `backward-word'.
***************
*** 5944,5953 ****
  
  `yank (C-y)'
!      Yank the top of the kill ring into the buffer at the current
!      cursor position.
  
  `yank-pop (M-y)'
       Rotate the kill-ring, and yank the new top.  You can only do this
!      if the prior command is yank or yank-pop.
  
  
--- 6034,6042 ----
  
  `yank (C-y)'
!      Yank the top of the kill ring into the buffer at point.
  
  `yank-pop (M-y)'
       Rotate the kill-ring, and yank the new top.  You can only do this
!      if the prior command is `yank' or `yank-pop'.
  
  
***************
*** 5959,5963 ****
  `digit-argument (M-0, M-1, ... M--)'
       Add this digit to the argument already accumulating, or start a new
!      argument.  <M-> starts a negative argument.
  
  `universal-argument ()'
--- 6048,6052 ----
  `digit-argument (M-0, M-1, ... M--)'
       Add this digit to the argument already accumulating, or start a new
!      argument.  `M--' starts a negative argument.
  
  `universal-argument ()'
***************
*** 5980,5998 ****
  -----------------------------
  
! `complete (TAB)'
!      Attempt to do completion on the text before the cursor.  This is
!      application-specific.  Generally, if you are typing a filename
!      argument, you can do filename completion; if you are typing a
!      command, you can do command completion; if you are typing in a
!      symbol to GDB, you can do symbol name completion; if you are
!      typing in a variable to Bash, you can do variable name completion,
!      and so on.  Bash attempts completion treating the text as a
!      variable (if the text begins with `$'), username (if the text
!      begins with `~'), hostname (if the text begins with `@'), or
!      command (including aliases and functions) in turn.  If none of
!      these produces a match, filename completion is attempted.
  
  `possible-completions (M-?)'
!      List the possible completions of the text before the cursor.
  
  `insert-completions (M-*)'
--- 6069,6083 ----
  -----------------------------
  
! `complete (<TAB>)'
!      Attempt to perform completion on the text before point.  The
!      actual completion performed is application-specific.  Bash
!      attempts completion treating the text as a variable (if the text
!      begins with `$'), username (if the text begins with `~'), hostname
!      (if the text begins with `@'), or command (including aliases and
!      functions) in turn.  If none of these produces a match, filename
!      completion is attempted.
  
  `possible-completions (M-?)'
!      List the possible completions of the text before point.
  
  `insert-completions (M-*)'
***************
*** 6005,6012 ****
       execution of `menu-complete' steps through the list of possible
       completions, inserting each match in turn.  At the end of the list
!      of completions, the bell is rung and the original text is restored.
!      An argument of N moves N positions forward in the list of matches;
!      a negative argument may be used to move backward through the list.
!      This command is intended to be bound to `TAB', but is unbound by
       default.
  
--- 6090,6098 ----
       execution of `menu-complete' steps through the list of possible
       completions, inserting each match in turn.  At the end of the list
!      of completions, the bell is rung (subject to the setting of
!      `bell-style') and the original text is restored.  An argument of N
!      moves N positions forward in the list of matches; a negative
!      argument may be used to move backward through the list.  This
!      command is intended to be bound to <TAB>, but is unbound by
       default.
  
***************
*** 6058,6062 ****
       it as a command name.
  
! `dynamic-complete-history (M-TAB)'
       Attempt completion on the text before point, comparing the text
       against lines from the history list for possible completion
--- 6144,6148 ----
       it as a command name.
  
! `dynamic-complete-history (M-<TAB>)'
       Attempt completion on the text before point, comparing the text
       against lines from the history list for possible completion
***************
*** 6066,6070 ****
       Perform filename completion and insert the list of possible
       completions enclosed within braces so the list is available to the
!      shell (*note Brace Expansion::.).
  
  
--- 6152,6156 ----
       Perform filename completion and insert the list of possible
       completions enclosed within braces so the list is available to the
!      shell (*note Brace Expansion::).
  
  
***************
*** 6103,6111 ****
       bound to the corresponding uppercase character.
  
! `prefix-meta (ESC)'
!      Make the next character typed be metafied.  This is for keyboards
!      without a meta key.  Typing `ESC f' is equivalent to typing `M-f'.
  
! `undo (C-_, C-x C-u)'
       Incremental undo, separately remembered for each line.
  
--- 6189,6197 ----
       bound to the corresponding uppercase character.
  
! `prefix-meta (<ESC>)'
!      Metafy the next character typed.  This is for keyboards without a
!      meta key.  Typing `<ESC> f' is equivalent to typing `M-f'.
  
! `undo (C-_ or C-x C-u)'
       Incremental undo, separately remembered for each line.
  
***************
*** 6118,6123 ****
  
  `set-mark (C-@)'
!      Set the mark to the current point.  If a numeric argument is
!      supplied, the mark is set to that position.
  
  `exchange-point-and-mark (C-x C-x)'
--- 6204,6209 ----
  
  `set-mark (C-@)'
!      Set the mark to the point.  If a numeric argument is supplied, the
!      mark is set to that position.
  
  `exchange-point-and-mark (C-x C-x)'
***************
*** 6156,6162 ****
  `dump-macros ()'
       Print all of the Readline key sequences bound to macros and the
!      strings they ouput.  If a numeric argument is supplied, the output
!      is formatted in such a way that it can be made part of an INPUTRC
!      file.  This command is unbound by default.
  
  `glob-expand-word (C-x *)'
--- 6242,6248 ----
  `dump-macros ()'
       Print all of the Readline key sequences bound to macros and the
!      strings they output.  If a numeric argument is supplied, the
!      output is formatted in such a way that it can be made part of an
!      INPUTRC file.  This command is unbound by default.
  
  `glob-expand-word (C-x *)'
***************
*** 6175,6179 ****
       Expand the line as the shell does.  This performs alias and
       history expansion as well as all of the shell word expansions
!      (*note Shell Expansions::.).
  
  `history-expand-line (M-^)'
--- 6261,6265 ----
       Expand the line as the shell does.  This performs alias and
       history expansion as well as all of the shell word expansions
!      (*note Shell Expansions::).
  
  `history-expand-line (M-^)'
***************
*** 6182,6194 ****
  `magic-space ()'
       Perform history expansion on the current line and insert a space
!      (*note History Interaction::.).
  
  `alias-expand-line ()'
!      Perform alias expansion on the current line (*note Aliases::.).
  
  `history-and-alias-expand-line ()'
       Perform history and alias expansion on the current line.
  
! `insert-last-argument (M-., M-_)'
       A synonym for `yank-last-arg'.
  
--- 6268,6280 ----
  `magic-space ()'
       Perform history expansion on the current line and insert a space
!      (*note History Interaction::).
  
  `alias-expand-line ()'
!      Perform alias expansion on the current line (*note Aliases::).
  
  `history-and-alias-expand-line ()'
       Perform history and alias expansion on the current line.
  
! `insert-last-argument (M-. or M-_)'
       A synonym for `yank-last-arg'.
  
***************
*** 6215,6219 ****
     In order to switch interactively between `emacs' and `vi' editing
  modes, use the `set -o emacs' and `set -o vi' commands (*note The Set
! Builtin::.).  The Readline default is `emacs' mode.
  
     When you enter a line in `vi' mode, you are already placed in
--- 6301,6305 ----
     In order to switch interactively between `emacs' and `vi' editing
  modes, use the `set -o emacs' and `set -o vi' commands (*note The Set
! Builtin::).  The Readline default is `emacs' mode.
  
     When you enter a line in `vi' mode, you are already placed in
***************
*** 6231,6235 ****
     When word completion is attempted for an argument to a command for
  which a completion specification (a COMPSPEC) has been defined using
! the `complete' builtin (*note Programmable Completion Builtins::.), the
  programmable completion facilities are invoked.
  
--- 6317,6321 ----
     When word completion is attempted for an argument to a command for
  which a completion specification (a COMPSPEC) has been defined using
! the `complete' builtin (*note Programmable Completion Builtins::), the
  programmable completion facilities are invoked.
  
***************
*** 6243,6247 ****
     Once a compspec has been found, it is used to generate the list of
  matching words.  If a compspec is not found, the default Bash completion
! described above (*note Commands For Completion::.) is performed.
  
     First, the actions specified by the compspec are used.  Only matches
--- 6329,6333 ----
     Once a compspec has been found, it is used to generate the list of
  matching words.  If a compspec is not found, the default Bash completion
! described above (*note Commands For Completion::) is performed.
  
     First, the actions specified by the compspec are used.  Only matches
***************
*** 6262,6268 ****
  is then expanded using brace expansion, tilde expansion, parameter and
  variable expansion, command substitution, arithmetic expansion, and
! pathname expansion, as described above (*note Shell Expansions::.).
! The results are split using the rules described above (*note Word
! Splitting::.).  The results of the expansion are prefix-matched against
  the word being completed, and the matching words become the possible
  completions.
--- 6348,6354 ----
  is then expanded using brace expansion, tilde expansion, parameter and
  variable expansion, command substitution, arithmetic expansion, and
! pathname expansion, as described above (*note Shell Expansions::).  The
! results are split using the rules described above (*note Word
! Splitting::).  The results of the expansion are prefix-matched against
  the word being completed, and the matching words become the possible
  completions.
***************
*** 6272,6276 ****
  command or function is invoked, the `COMP_LINE' and `COMP_POINT'
  variables are assigned values as described above (*note Bash
! Variables::.).  If a shell function is being invoked, the `COMP_WORDS'
  and `COMP_CWORD' variables are also set.  When the function or command
  is invoked, the first argument is the name of the command whose
--- 6358,6362 ----
  command or function is invoked, the `COMP_LINE' and `COMP_POINT'
  variables are assigned values as described above (*note Bash
! Variables::).  If a shell function is being invoked, the `COMP_WORDS'
  and `COMP_CWORD' variables are also set.  When the function or command
  is invoked, the first argument is the name of the command whose
***************
*** 6283,6289 ****
     Any function specified with `-F' is invoked first.  The function may
  use any of the shell facilities, including the `compgen' builtin
! described below (*note Programmable Completion Builtins::.), to
! generate the matches.  It must put the possible completions in the
! `COMPREPLY' array variable.
  
     Next, any command specified with the `-C' option is invoked in an
--- 6369,6375 ----
     Any function specified with `-F' is invoked first.  The function may
  use any of the shell facilities, including the `compgen' builtin
! described below (*note Programmable Completion Builtins::), to generate
! the matches.  It must put the possible completions in the `COMPREPLY'
! array variable.
  
     Next, any command specified with the `-C' option is invoked in an
***************
*** 6306,6313 ****
  completions.
  
!    If a compspec is found, whatever it generates is returned to the
! completion code as the full set of possible completions.  The default
! Bash completions are not attempted, and the Readline default of
! filename completion is disabled.
  
  
--- 6392,6406 ----
  completions.
  
!    If the previously-applied actions do not generate any matches, and
! the `-o dirnames' option was supplied to `complete' when the compspec
! was defined, directory name completion is attempted.
! 
!    By default, if a compspec is found, whatever it generates is
! returned to the completion code as the full set of possible completions.
! The default Bash completions are not attempted, and the Readline default
! of filename completion is disabled.  If the `-o default' option was
! supplied to `complete' when the compspec was defined, Readline's
! default completion will be performed if the compspec generates no
! matches.
  
  
***************
*** 6339,6343 ****
  
  `complete'
!           `complete [-abcdefjkvu] [-A ACTION] [-G GLOBPAT] [-W WORDLIST]
            [-P PREFIX] [-S SUFFIX] [-X FILTERPAT] [-F FUNCTION]
            [-C COMMAND] NAME [NAME ...]'
--- 6432,6436 ----
  
  `complete'
!           `complete [-abcdefjkvu] [-o COMP-OPTION] [-A ACTION] [-G GLOBPAT] [-W WORDLIST]
            [-P PREFIX] [-S SUFFIX] [-X FILTERPAT] [-F FUNCTION]
            [-C COMMAND] NAME [NAME ...]'
***************
*** 6353,6357 ****
       The process of applying these completion specifications when word
       completion is attempted is described above (*note Programmable
!      Completion::.).
  
       Other options, if specified, have the following meanings.  The
--- 6446,6450 ----
       The process of applying these completion specifications when word
       completion is attempted is described above (*note Programmable
!      Completion::).
  
       Other options, if specified, have the following meanings.  The
***************
*** 6360,6363 ****
--- 6453,6476 ----
       expansion before the `complete' builtin is invoked.
  
+     `-o COMP-OPTION'
+           The COMP-OPTION controls several aspects of the compspec's
+           behavior beyond the simple generation of completions.
+           COMP-OPTION may be one of:
+ 
+          `default'
+                Use readline's default completion if the compspec
+                generates no matches.
+ 
+          `dirnames'
+                Perform directory name completion if the compspec
+                generates no matches.
+ 
+          `filenames'
+                Tell Readline that the compspec generates filenames, so
+                it can perform any filename\-specific processing (like
+                adding a slash to directory names or suppressing
+                trailing spaces).  This option is intended to be used
+                with shell functions specified with `-F'.
+ 
      `-A ACTION'
            The ACTION may be one of the following to generate a list of
***************
*** 6372,6376 ****
           `binding'
                 Readline key binding names (*note Bindable Readline
!                Commands::.).
  
           `builtin'
--- 6485,6489 ----
           `binding'
                 Readline key binding names (*note Bindable Readline
!                Commands::).
  
           `builtin'
***************
*** 6402,6410 ****
           `helptopic'
                 Help topics as accepted by the `help' builtin (*note
!                Bash Builtins::.).
  
           `hostname'
                 Hostnames, as taken from the file specified by the
!                `HOSTFILE' shell variable (*note Bash Variables::.).
  
           `job'
--- 6515,6523 ----
           `helptopic'
                 Help topics as accepted by the `help' builtin (*note
!                Bash Builtins::).
  
           `hostname'
                 Hostnames, as taken from the file specified by the
!                `HOSTFILE' shell variable (*note Bash Variables::).
  
           `job'
***************
*** 6420,6428 ****
           `setopt'
                 Valid arguments for the `-o' option to the `set' builtin
!                (*note The Set Builtin::.).
  
           `shopt'
                 Shell option names as accepted by the `shopt' builtin
!                (*note Bash Builtins::.).
  
           `signal'
--- 6533,6541 ----
           `setopt'
                 Valid arguments for the `-o' option to the `set' builtin
!                (*note The Set Builtin::).
  
           `shopt'
                 Shell option names as accepted by the `shopt' builtin
!                (*note Bash Builtins::).
  
           `signal'
***************
*** 6506,6510 ****
  
     When the `-o history' option to the `set' builtin is enabled (*note
! The Set Builtin::.), the shell provides access to the COMMAND HISTORY,
  the list of commands previously typed.  The value of the `HISTSIZE'
  shell variable is used as the number of commands to save in a history
--- 6619,6623 ----
  
     When the `-o history' option to the `set' builtin is enabled (*note
! The Set Builtin::), the shell provides access to the "command history",
  the list of commands previously typed.  The value of the `HISTSIZE'
  shell variable is used as the number of commands to save in a history
***************
*** 6522,6526 ****
  `$HISTSIZE' lines are copied from the history list to the file named by
  `$HISTFILE'.  If the `histappend' shell option is set (*note Bash
! Builtins::.), the lines are appended to the history file, otherwise the
  history file is overwritten.  If `HISTFILE' is unset, or if the history
  file is unwritable, the history is not saved.  After saving the
--- 6635,6639 ----
  `$HISTSIZE' lines are copied from the history list to the file named by
  `$HISTFILE'.  If the `histappend' shell option is set (*note Bash
! Builtins::), the lines are appended to the history file, otherwise the
  history file is overwritten.  If `HISTFILE' is unset, or if the history
  file is unwritable, the history is not saved.  After saving the
***************
*** 6534,6538 ****
  When using command-line editing, search commands are available in each
  editing mode that provide access to the history list (*note Commands
! For History::.).
  
     The shell allows control over which commands are saved on the history
--- 6647,6651 ----
  When using command-line editing, search commands are available in each
  editing mode that provide access to the history list (*note Commands
! For History::).
  
     The shell allows control over which commands are saved on the history
***************
*** 6582,6586 ****
       A useful alias to use with the `fc' command is `r='fc -s'', so
       that typing `r cc' runs the last command beginning with `cc' and
!      typing `r' re-executes the last command (*note Aliases::.).
  
  `history'
--- 6695,6699 ----
       A useful alias to use with the `fc' command is `r='fc -s'', so
       that typing `r cc' runs the last command beginning with `cc' and
!      typing `r' re-executes the last command (*note Aliases::).
  
  `history'
***************
*** 6592,6597 ****
  
       With no options, display the history list with line numbers.
!      Lines prefixed with with a `*' have been modified.  An argument of
!      N lists only the last N lines.  Options, if supplied, have the
       following meanings:
  
--- 6705,6710 ----
  
       With no options, display the history list with line numbers.
!      Lines prefixed with a `*' have been modified.  An argument of N
!      lists only the last N lines.  Options, if supplied, have the
       following meanings:
  
***************
*** 6662,6666 ****
  
     Several shell options settable with the `shopt' builtin (*note Bash
! Builtins::.) may be used to tailor the behavior of history expansion.
  If the `histverify' shell option is enabled, and Readline is being
  used, history substitutions are not immediately passed to the shell
--- 6775,6779 ----
  
     Several shell options settable with the `shopt' builtin (*note Bash
! Builtins::) may be used to tailor the behavior of history expansion.
  If the `histverify' shell option is enabled, and Readline is being
  used, history substitutions are not immediately passed to the shell
***************
*** 7149,7166 ****
  `--enable-alias'
       Allow alias expansion and include the `alias' and `unalias'
!      builtins (*note Aliases::.).
  
  `--enable-arith-for-command'
       Include support for the alternate form of the `for' command that
       behaves like the C language `for' statement (*note Looping
!      Constructs::.).
  
  `--enable-array-variables'
       Include support for one-dimensional array shell variables (*note
!      Arrays::.).
  
  `--enable-bang-history'
       Include support for `csh'-like history substitution (*note History
!      Interaction::.).
  
  `--enable-brace-expansion'
--- 7262,7279 ----
  `--enable-alias'
       Allow alias expansion and include the `alias' and `unalias'
!      builtins (*note Aliases::).
  
  `--enable-arith-for-command'
       Include support for the alternate form of the `for' command that
       behaves like the C language `for' statement (*note Looping
!      Constructs::).
  
  `--enable-array-variables'
       Include support for one-dimensional array shell variables (*note
!      Arrays::).
  
  `--enable-bang-history'
       Include support for `csh'-like history substitution (*note History
!      Interaction::).
  
  `--enable-brace-expansion'
***************
*** 7171,7184 ****
       Include support for recognizing `time' as a reserved word and for
       displaying timing statistics for the pipeline following `time'
!      (*note Pipelines::.).  This allows pipelines as well as shell
       builtins and functions to be timed.
  
  `--enable-cond-command'
       Include support for the `[[' conditional command (*note
!      Conditional Constructs::.).
  
  `--enable-directory-stack'
       Include support for a `csh'-like directory stack and the `pushd',
!      `popd', and `dirs' builtins (*note The Directory Stack::.).
  
  `--enable-disabled-builtins'
--- 7284,7297 ----
       Include support for recognizing `time' as a reserved word and for
       displaying timing statistics for the pipeline following `time'
!      (*note Pipelines::).  This allows pipelines as well as shell
       builtins and functions to be timed.
  
  `--enable-cond-command'
       Include support for the `[[' conditional command (*note
!      Conditional Constructs::).
  
  `--enable-directory-stack'
       Include support for a `csh'-like directory stack and the `pushd',
!      `popd', and `dirs' builtins (*note The Directory Stack::).
  
  `--enable-disabled-builtins'
***************
*** 7190,7194 ****
  `--enable-dparen-arithmetic'
       Include support for the `((...))' command (*note Conditional
!      Constructs::.).
  
  `--enable-extended-glob'
--- 7303,7307 ----
  `--enable-dparen-arithmetic'
       Include support for the `((...))' command (*note Conditional
!      Constructs::).
  
  `--enable-extended-glob'
***************
*** 7198,7209 ****
  `--enable-help-builtin'
       Include the `help' builtin, which displays help on shell builtins
!      and variables (*note Bash Builtins::.).
  
  `--enable-history'
       Include command history and the `fc' and `history' builtin
!      commands (*note Bash History Facilities::.).
  
  `--enable-job-control'
!      This enables the job control features (*note Job Control::.), if
       the operating system supports them.
  
--- 7311,7322 ----
  `--enable-help-builtin'
       Include the `help' builtin, which displays help on shell builtins
!      and variables (*note Bash Builtins::).
  
  `--enable-history'
       Include command history and the `fc' and `history' builtin
!      commands (*note Bash History Facilities::).
  
  `--enable-job-control'
!      This enables the job control features (*note Job Control::), if
       the operating system supports them.
  
***************
*** 7211,7219 ****
       This enables the special handling of filenames of the form
       `/dev/tcp/HOST/PORT' and `/dev/udp/HOST/PORT' when used in
!      redirections (*note Redirections::.).
  
  `--enable-process-substitution'
!      This enables process substitution (*note Process Substitution::.)
!      if the operating system provides the necessary support.
  
  `--enable-prompt-string-decoding'
--- 7324,7332 ----
       This enables the special handling of filenames of the form
       `/dev/tcp/HOST/PORT' and `/dev/udp/HOST/PORT' when used in
!      redirections (*note Redirections::).
  
  `--enable-process-substitution'
!      This enables process substitution (*note Process Substitution::) if
!      the operating system provides the necessary support.
  
  `--enable-prompt-string-decoding'
***************
*** 7225,7234 ****
  `--enable-progcomp'
       Enable the programmable completion facilities (*note Programmable
!      Completion::.).  If Readline is not enabled, this option has no
       effect.
  
  `--enable-readline'
       Include support for command-line editing and history with the Bash
!      version of the Readline library (*note Command Line Editing::.).
  
  `--enable-restricted'
--- 7338,7347 ----
  `--enable-progcomp'
       Enable the programmable completion facilities (*note Programmable
!      Completion::).  If Readline is not enabled, this option has no
       effect.
  
  `--enable-readline'
       Include support for command-line editing and history with the Bash
!      version of the Readline library (*note Command Line Editing::).
  
  `--enable-restricted'
***************
*** 7239,7243 ****
  `--enable-select'
       Include the `select' builtin, which allows the generation of simple
!      menus (*note Conditional Constructs::.).
  
  `--enable-usg-echo-default'
--- 7352,7356 ----
  `--enable-select'
       Include the `select' builtin, which allows the generation of simple
!      menus (*note Conditional Constructs::).
  
  `--enable-usg-echo-default'
***************
*** 7304,7329 ****
  significance.  A number of these differences are explained in greater
  depth in previous sections.  This section uses the version of `sh'
! included SVR4.2 as the baseline reference.
  
     * Bash is POSIX-conformant, even where the POSIX specification
!      differs from traditional `sh' behavior.
  
     * Bash has multi-character invocation options (*note Invoking
!      Bash::.).
  
!    * Bash has command-line editing (*note Command Line Editing::.) and
       the `bind' builtin.
  
     * Bash provides a programmable word completion mechanism (*note
!      Programmable Completion::.), and two builtin commands, `complete'
       and `compgen', to manipulate it.
  
!    * Bash has command history (*note Bash History Facilities::.) and the
       `history' and `fc' builtins to manipulate it.
  
     * Bash implements `csh'-like history expansion (*note History
!      Interaction::.).
  
!    * Bash has one-dimensional array variables (*note Arrays::.), and the
       appropriate variable expansions and assignment syntax to use them.
       Several of the Bash builtins take options to act on arrays.  Bash
--- 7417,7442 ----
  significance.  A number of these differences are explained in greater
  depth in previous sections.  This section uses the version of `sh'
! included in SVR4.2 as the baseline reference.
  
     * Bash is POSIX-conformant, even where the POSIX specification
!      differs from traditional `sh' behavior (*note Bash POSIX Mode::).
  
     * Bash has multi-character invocation options (*note Invoking
!      Bash::).
  
!    * Bash has command-line editing (*note Command Line Editing::) and
       the `bind' builtin.
  
     * Bash provides a programmable word completion mechanism (*note
!      Programmable Completion::), and two builtin commands, `complete'
       and `compgen', to manipulate it.
  
!    * Bash has command history (*note Bash History Facilities::) and the
       `history' and `fc' builtins to manipulate it.
  
     * Bash implements `csh'-like history expansion (*note History
!      Interaction::).
  
!    * Bash has one-dimensional array variables (*note Arrays::), and the
       appropriate variable expansions and assignment syntax to use them.
       Several of the Bash builtins take options to act on arrays.  Bash
***************
*** 7332,7336 ****
     * The `$'...'' quoting syntax, which expands ANSI-C
       backslash-escaped characters in the text between the single quotes,
!      is supported (*note ANSI-C Quoting::.).
  
     * Bash supports the `$"..."' quoting syntax to do locale-specific
--- 7445,7449 ----
     * The `$'...'' quoting syntax, which expands ANSI-C
       backslash-escaped characters in the text between the single quotes,
!      is supported (*note ANSI-C Quoting::).
  
     * Bash supports the `$"..."' quoting syntax to do locale-specific
***************
*** 7338,7371 ****
       `-D', `--dump-strings', and `--dump-po-strings' invocation options
       list the translatable strings found in a script (*note Locale
!      Translation::.).
  
     * Bash implements the `!' keyword to negate the return value of a
!      pipeline (*note Pipelines::.).  Very useful when an `if' statement
       needs to act only if a test fails.
  
     * Bash has the `time' reserved word and command timing (*note
!      Pipelines::.).  The display of the timing statistics may be
       controlled with the `TIMEFORMAT' variable.
  
     * Bash implements the `for (( EXPR1 ; EXPR2 ; EXPR3 ))' arithmetic
       for command, similar to the C language (*note Looping
!      Constructs::.).
  
     * Bash includes the `select' compound command, which allows the
!      generation of simple menus (*note Conditional Constructs::.).
  
     * Bash includes the `[[' compound command, which makes conditional
!      testing part of the shell grammar (*note Conditional
!      Constructs::.).
  
!    * Bash includes brace expansion (*note Brace Expansion::.) and tilde
!      expansion (*note Tilde Expansion::.).
  
     * Bash implements command aliases and the `alias' and `unalias'
!      builtins (*note Aliases::.).
  
     * Bash provides shell arithmetic, the `((' compound command (*note
!      Conditional Constructs::.), and arithmetic expansion (*note Shell
!      Arithmetic::.).
  
     * Variables present in the shell's initial environment are
--- 7451,7483 ----
       `-D', `--dump-strings', and `--dump-po-strings' invocation options
       list the translatable strings found in a script (*note Locale
!      Translation::).
  
     * Bash implements the `!' keyword to negate the return value of a
!      pipeline (*note Pipelines::).  Very useful when an `if' statement
       needs to act only if a test fails.
  
     * Bash has the `time' reserved word and command timing (*note
!      Pipelines::).  The display of the timing statistics may be
       controlled with the `TIMEFORMAT' variable.
  
     * Bash implements the `for (( EXPR1 ; EXPR2 ; EXPR3 ))' arithmetic
       for command, similar to the C language (*note Looping
!      Constructs::).
  
     * Bash includes the `select' compound command, which allows the
!      generation of simple menus (*note Conditional Constructs::).
  
     * Bash includes the `[[' compound command, which makes conditional
!      testing part of the shell grammar (*note Conditional Constructs::).
  
!    * Bash includes brace expansion (*note Brace Expansion::) and tilde
!      expansion (*note Tilde Expansion::).
  
     * Bash implements command aliases and the `alias' and `unalias'
!      builtins (*note Aliases::).
  
     * Bash provides shell arithmetic, the `((' compound command (*note
!      Conditional Constructs::), and arithmetic expansion (*note Shell
!      Arithmetic::).
  
     * Variables present in the shell's initial environment are
***************
*** 7376,7406 ****
     * Bash includes the POSIX pattern removal `%', `#', `%%' and `##'
       expansions to remove leading or trailing substrings from variable
!      values (*note Shell Parameter Expansion::.).
  
     * The expansion `${#xx}', which returns the length of `${xx}', is
!      supported (*note Shell Parameter Expansion::.).
  
     * The expansion `${var:'OFFSET`[:'LENGTH`]}', which expands to the
       substring of `var''s value of length LENGTH, beginning at OFFSET,
!      is present (*note Shell Parameter Expansion::.).
  
     * The expansion `${var/[/]'PATTERN`[/'REPLACEMENT`]}', which matches
       PATTERN and replaces it with REPLACEMENT in the value of `var', is
!      available (*note Shell Parameter Expansion::.).
  
     * The expansion `${!PREFIX}*' expansion, which expands to the names
       of all shell variables whose names begin with PREFIX, is available
!      (*note Shell Parameter Expansion::.).
  
     * Bash has INDIRECT variable expansion using `${!word}' (*note Shell
!      Parameter Expansion::.).
  
     * Bash can expand positional parameters beyond `$9' using `${NUM}'.
  
     * The POSIX `$()' form of command substitution is implemented (*note
!      Command Substitution::.), and preferred to the Bourne shell's ```'
       (which is also implemented for backwards compatibility).
  
!    * Bash has process substitution (*note Process Substitution::.).
  
     * Bash automatically assigns variables that provide information
--- 7488,7518 ----
     * Bash includes the POSIX pattern removal `%', `#', `%%' and `##'
       expansions to remove leading or trailing substrings from variable
!      values (*note Shell Parameter Expansion::).
  
     * The expansion `${#xx}', which returns the length of `${xx}', is
!      supported (*note Shell Parameter Expansion::).
  
     * The expansion `${var:'OFFSET`[:'LENGTH`]}', which expands to the
       substring of `var''s value of length LENGTH, beginning at OFFSET,
!      is present (*note Shell Parameter Expansion::).
  
     * The expansion `${var/[/]'PATTERN`[/'REPLACEMENT`]}', which matches
       PATTERN and replaces it with REPLACEMENT in the value of `var', is
!      available (*note Shell Parameter Expansion::).
  
     * The expansion `${!PREFIX}*' expansion, which expands to the names
       of all shell variables whose names begin with PREFIX, is available
!      (*note Shell Parameter Expansion::).
  
     * Bash has INDIRECT variable expansion using `${!word}' (*note Shell
!      Parameter Expansion::).
  
     * Bash can expand positional parameters beyond `$9' using `${NUM}'.
  
     * The POSIX `$()' form of command substitution is implemented (*note
!      Command Substitution::), and preferred to the Bourne shell's ```'
       (which is also implemented for backwards compatibility).
  
!    * Bash has process substitution (*note Process Substitution::).
  
     * Bash automatically assigns variables that provide information
***************
*** 7411,7423 ****
  
     * The `IFS' variable is used to split only the results of expansion,
!      not all words (*note Word Splitting::.).  This closes a
       longstanding shell security hole.
  
     * Bash implements the full set of POSIX 1003.2 filename expansion
       operators, including CHARACTER CLASSES, EQUIVALENCE CLASSES, and
!      COLLATING SYMBOLS (*note Filename Expansion::.).
  
     * Bash implements extended pattern matching features when the
!      `extglob' shell option is enabled (*note Pattern Matching::.).
  
     * It is possible to have a variable and a function with the same
--- 7523,7535 ----
  
     * The `IFS' variable is used to split only the results of expansion,
!      not all words (*note Word Splitting::).  This closes a
       longstanding shell security hole.
  
     * Bash implements the full set of POSIX 1003.2 filename expansion
       operators, including CHARACTER CLASSES, EQUIVALENCE CLASSES, and
!      COLLATING SYMBOLS (*note Filename Expansion::).
  
     * Bash implements extended pattern matching features when the
!      `extglob' shell option is enabled (*note Pattern Matching::).
  
     * It is possible to have a variable and a function with the same
***************
*** 7426,7456 ****
     * Bash functions are permitted to have local variables using the
       `local' builtin, and thus useful recursive functions may be written
!      (*note Bash Builtins::.).
  
     * Variable assignments preceding commands affect only that command,
!      even builtins and functions (*note Environment::.).  In `sh', all
       variable assignments preceding commands are global unless the
       command is executed from the file system.
  
     * Bash performs filename expansion on filenames specified as operands
!      to input and output redirection operators (*note Redirections::.).
  
     * Bash contains the `<>' redirection operator, allowing a file to be
       opened for both reading and writing, and the `&>' redirection
       operator, for directing standard output and standard error to the
!      same file (*note Redirections::.).
  
     * Bash treats a number of filenames specially when they are used in
!      redirection operators (*note Redirections::.).
  
     * Bash can open network connections to arbitrary machines and
!      services with the redirection operators (*note Redirections::.).
  
     * The `noclobber' option is available to avoid overwriting existing
!      files with output redirection (*note The Set Builtin::.).  The
!      `>|' redirection operator may be used to override `noclobber'.
  
!    * The Bash `cd' and `pwd' builtins (*note Bourne Shell Builtins::.)
!      each take `-L' and `-P' builtins to switch between logical and
       physical modes.
  
--- 7538,7568 ----
     * Bash functions are permitted to have local variables using the
       `local' builtin, and thus useful recursive functions may be written
!      (*note Bash Builtins::).
  
     * Variable assignments preceding commands affect only that command,
!      even builtins and functions (*note Environment::).  In `sh', all
       variable assignments preceding commands are global unless the
       command is executed from the file system.
  
     * Bash performs filename expansion on filenames specified as operands
!      to input and output redirection operators (*note Redirections::).
  
     * Bash contains the `<>' redirection operator, allowing a file to be
       opened for both reading and writing, and the `&>' redirection
       operator, for directing standard output and standard error to the
!      same file (*note Redirections::).
  
     * Bash treats a number of filenames specially when they are used in
!      redirection operators (*note Redirections::).
  
     * Bash can open network connections to arbitrary machines and
!      services with the redirection operators (*note Redirections::).
  
     * The `noclobber' option is available to avoid overwriting existing
!      files with output redirection (*note The Set Builtin::).  The `>|'
!      redirection operator may be used to override `noclobber'.
  
!    * The Bash `cd' and `pwd' builtins (*note Bourne Shell Builtins::)
!      each take `-L' and `-P' options to switch between logical and
       physical modes.
  
***************
*** 7458,7476 ****
       and provides access to that builtin's functionality within the
       function via the `builtin' and `command' builtins (*note Bash
!      Builtins::.).
  
     * The `command' builtin allows selective disabling of functions when
!      command lookup is performed (*note Bash Builtins::.).
  
     * Individual builtins may be enabled or disabled using the `enable'
!      builtin (*note Bash Builtins::.).
  
     * The Bash `exec' builtin takes additional options that allow users
       to control the contents of the environment passed to the executed
       command, and what the zeroth argument to the command is to be
!      (*note Bourne Shell Builtins::.).
  
     * Shell functions may be exported to children via the environment
!      using `export -f' (*note Shell Functions::.).
  
     * The Bash `export', `readonly', and `declare' builtins can take a
--- 7570,7588 ----
       and provides access to that builtin's functionality within the
       function via the `builtin' and `command' builtins (*note Bash
!      Builtins::).
  
     * The `command' builtin allows selective disabling of functions when
!      command lookup is performed (*note Bash Builtins::).
  
     * Individual builtins may be enabled or disabled using the `enable'
!      builtin (*note Bash Builtins::).
  
     * The Bash `exec' builtin takes additional options that allow users
       to control the contents of the environment passed to the executed
       command, and what the zeroth argument to the command is to be
!      (*note Bourne Shell Builtins::).
  
     * Shell functions may be exported to children via the environment
!      using `export -f' (*note Shell Functions::).
  
     * The Bash `export', `readonly', and `declare' builtins can take a
***************
*** 7484,7496 ****
       arbitrary filename, even when that filename cannot be found by
       searching the `$PATH', using `hash -p' (*note Bourne Shell
!      Builtins::.).
  
     * Bash includes a `help' builtin for quick reference to shell
!      facilities (*note Bash Builtins::.).
  
     * The `printf' builtin is available to display formatted output
!      (*note Bash Builtins::.).
  
!    * The Bash `read' builtin (*note Bash Builtins::.)  will read a line
       ending in `\' with the `-r' option, and will use the `REPLY'
       variable as a default if no non-option arguments are supplied.
--- 7596,7608 ----
       arbitrary filename, even when that filename cannot be found by
       searching the `$PATH', using `hash -p' (*note Bourne Shell
!      Builtins::).
  
     * Bash includes a `help' builtin for quick reference to shell
!      facilities (*note Bash Builtins::).
  
     * The `printf' builtin is available to display formatted output
!      (*note Bash Builtins::).
  
!    * The Bash `read' builtin (*note Bash Builtins::) will read a line
       ending in `\' with the `-r' option, and will use the `REPLY'
       variable as a default if no non-option arguments are supplied.
***************
*** 7507,7523 ****
     * The `return' builtin may be used to abort execution of scripts
       executed with the `.' or `source' builtins (*note Bourne Shell
!      Builtins::.).
  
     * Bash includes the `shopt' builtin, for finer control of shell
!      optional capabilities (*note Bash Builtins::.).
  
     * Bash has much more optional behavior controllable with the `set'
!      builtin (*note The Set Builtin::.).
  
!    * The `test' builtin (*note Bourne Shell Builtins::.)  is slightly
       different, as it implements the POSIX algorithm, which specifies
       the behavior based on the number of arguments.
  
!    * The `trap' builtin (*note Bourne Shell Builtins::.)  allows a
       `DEBUG' pseudo-signal specification, similar to `EXIT'.  Commands
       specified with a `DEBUG' trap are executed after every simple
--- 7619,7635 ----
     * The `return' builtin may be used to abort execution of scripts
       executed with the `.' or `source' builtins (*note Bourne Shell
!      Builtins::).
  
     * Bash includes the `shopt' builtin, for finer control of shell
!      optional capabilities (*note Bash Builtins::).
  
     * Bash has much more optional behavior controllable with the `set'
!      builtin (*note The Set Builtin::).
  
!    * The `test' builtin (*note Bourne Shell Builtins::) is slightly
       different, as it implements the POSIX algorithm, which specifies
       the behavior based on the number of arguments.
  
!    * The `trap' builtin (*note Bourne Shell Builtins::) allows a
       `DEBUG' pseudo-signal specification, similar to `EXIT'.  Commands
       specified with a `DEBUG' trap are executed after every simple
***************
*** 7525,7547 ****
  
     * The Bash `type' builtin is more extensive and gives more
!      information about the names it finds (*note Bash Builtins::.).
  
     * The Bash `umask' builtin permits a `-p' option to cause the output
       to be displayed in the form of a `umask' command that may be
!      reused as input (*note Bourne Shell Builtins::.).
  
     * Bash implements a `csh'-like directory stack, and provides the
       `pushd', `popd', and `dirs' builtins to manipulate it (*note The
!      Directory Stack::.).  Bash also makes the directory stack visible
       as the value of the `DIRSTACK' shell variable.
  
     * Bash interprets special backslash-escaped characters in the prompt
!      strings when interactive (*note Printing a Prompt::.).
  
     * The Bash restricted mode is more useful (*note The Restricted
!      Shell::.); the SVR4.2 shell restricted mode is too limited.
  
     * The `disown' builtin can remove a job from the internal shell job
!      table (*note Job Control Builtins::.) or suppress the sending of
       `SIGHUP' to a job when the shell exits as the result of a `SIGHUP'.
  
--- 7637,7659 ----
  
     * The Bash `type' builtin is more extensive and gives more
!      information about the names it finds (*note Bash Builtins::).
  
     * The Bash `umask' builtin permits a `-p' option to cause the output
       to be displayed in the form of a `umask' command that may be
!      reused as input (*note Bourne Shell Builtins::).
  
     * Bash implements a `csh'-like directory stack, and provides the
       `pushd', `popd', and `dirs' builtins to manipulate it (*note The
!      Directory Stack::).  Bash also makes the directory stack visible
       as the value of the `DIRSTACK' shell variable.
  
     * Bash interprets special backslash-escaped characters in the prompt
!      strings when interactive (*note Printing a Prompt::).
  
     * The Bash restricted mode is more useful (*note The Restricted
!      Shell::); the SVR4.2 shell restricted mode is too limited.
  
     * The `disown' builtin can remove a job from the internal shell job
!      table (*note Job Control Builtins::) or suppress the sending of
       `SIGHUP' to a job when the shell exits as the result of a `SIGHUP'.
  
***************
*** 7556,7559 ****
--- 7668,7672 ----
     * The SVR4.2 `sh' uses a `TIMEOUT' variable like Bash uses `TMOUT'.
  
+ 
  More features unique to Bash may be found in *Note Bash Features::.
  
***************
*** 7720,7723 ****
--- 7833,7837 ----
  * bell-style:                            Readline Init File Syntax.
  * CDPATH:                                Bourne Shell Variables.
+ * COLUMNS:                               Bash Variables.
  * comment-begin:                         Readline Init File Syntax.
  * COMP_CWORD:                            Bash Variables.
***************
*** 7764,7767 ****
--- 7878,7882 ----
  * LC_NUMERIC:                            Bash Variables.
  * LINENO:                                Bash Variables.
+ * LINES:                                 Bash Variables.
  * MACHTYPE:                              Bash Variables.
  * MAIL:                                  Bourne Shell Variables.
***************
*** 7805,7813 ****
  
  * abort (C-g):                           Miscellaneous Commands.
! * accept-line (Newline, Return):         Commands For History.
  * backward-char (C-b):                   Commands For Moving.
  * backward-delete-char (Rubout):         Commands For Text.
  * backward-kill-line (C-x Rubout):       Commands For Killing.
! * backward-kill-word (M-DEL):            Commands For Killing.
  * backward-word (M-b):                   Commands For Moving.
  * beginning-of-history (M-<):            Commands For History.
--- 7920,7928 ----
  
  * abort (C-g):                           Miscellaneous Commands.
! * accept-line (Newline or Return):       Commands For History.
  * backward-char (C-b):                   Commands For Moving.
  * backward-delete-char (Rubout):         Commands For Text.
  * backward-kill-line (C-x Rubout):       Commands For Killing.
! * backward-kill-word (M-<DEL>):          Commands For Killing.
  * backward-word (M-b):                   Commands For Moving.
  * beginning-of-history (M-<):            Commands For History.
***************
*** 7818,7822 ****
  * character-search-backward (M-C-]):     Miscellaneous Commands.
  * clear-screen (C-l):                    Commands For Moving.
! * complete (TAB):                        Commands For Completion.
  * copy-backward-word ():                 Commands For Killing.
  * copy-forward-word ():                  Commands For Killing.
--- 7933,7937 ----
  * character-search-backward (M-C-]):     Miscellaneous Commands.
  * clear-screen (C-l):                    Commands For Moving.
! * complete (<TAB>):                      Commands For Completion.
  * copy-backward-word ():                 Commands For Killing.
  * copy-forward-word ():                  Commands For Killing.
***************
*** 7852,7858 ****
  * non-incremental-reverse-search-history (M-p): Commands For History.
  * possible-completions (M-?):            Commands For Completion.
! * prefix-meta (ESC):                     Miscellaneous Commands.
  * previous-history (C-p):                Commands For History.
! * quoted-insert (C-q, C-v):              Commands For Text.
  * re-read-init-file (C-x C-r):           Miscellaneous Commands.
  * redraw-current-line ():                Commands For Moving.
--- 7967,7973 ----
  * non-incremental-reverse-search-history (M-p): Commands For History.
  * possible-completions (M-?):            Commands For Completion.
! * prefix-meta (<ESC>):                   Miscellaneous Commands.
  * previous-history (C-p):                Commands For History.
! * quoted-insert (C-q or C-v):            Commands For Text.
  * re-read-init-file (C-x C-r):           Miscellaneous Commands.
  * redraw-current-line ():                Commands For Moving.
***************
*** 7864,7868 ****
  * transpose-chars (C-t):                 Commands For Text.
  * transpose-words (M-t):                 Commands For Text.
! * undo (C-_, C-x C-u):                   Miscellaneous Commands.
  * universal-argument ():                 Numeric Arguments.
  * unix-line-discard (C-u):               Commands For Killing.
--- 7979,7983 ----
  * transpose-chars (C-t):                 Commands For Text.
  * transpose-words (M-t):                 Commands For Text.
! * undo (C-_ or C-x C-u):                 Miscellaneous Commands.
  * universal-argument ():                 Numeric Arguments.
  * unix-line-discard (C-u):               Commands For Killing.
***************
*** 7870,7874 ****
  * upcase-word (M-u):                     Commands For Text.
  * yank (C-y):                            Commands For Killing.
! * yank-last-arg (M-., M-_):              Commands For History.
  * yank-nth-arg (M-C-y):                  Commands For History.
  * yank-pop (M-y):                        Commands For Killing.
--- 7985,7989 ----
  * upcase-word (M-u):                     Commands For Text.
  * yank (C-y):                            Commands For Killing.
! * yank-last-arg (M-. or M-_):            Commands For History.
  * yank-nth-arg (M-C-y):                  Commands For History.
  * yank-pop (M-y):                        Commands For Killing.
***************
*** 7917,7922 ****
  * event designators:                     Event Designators.
  * execution environment:                 Command Execution Environment.
! * exit status <1>:                       Exit Status.
! * exit status:                           Definitions.
  * expansion:                             Shell Expansions.
  * expansion, arithmetic:                 Arithmetic Expansion.
--- 8032,8037 ----
  * event designators:                     Event Designators.
  * execution environment:                 Command Execution Environment.
! * exit status <1>:                       Definitions.
! * exit status:                           Exit Status.
  * expansion:                             Shell Expansions.
  * expansion, arithmetic:                 Arithmetic Expansion.
***************
*** 7945,7950 ****
  * interactive shell:                     Invoking Bash.
  * job:                                   Definitions.
! * job control <1>:                       Job Control Basics.
! * job control:                           Definitions.
  * kill ring:                             Readline Killing Commands.
  * killing text:                          Readline Killing Commands.
--- 8060,8065 ----
  * interactive shell:                     Invoking Bash.
  * job:                                   Definitions.
! * job control <1>:                       Definitions.
! * job control:                           Job Control Basics.
  * kill ring:                             Readline Killing Commands.
  * killing text:                          Readline Killing Commands.
***************
*** 7983,7988 ****
  * signal:                                Definitions.
  * signal handling:                       Signals.
! * special builtin <1>:                   Special Builtins.
! * special builtin:                       Definitions.
  * startup files:                         Bash Startup Files.
  * suspending jobs:                       Job Control Basics.
--- 8098,8103 ----
  * signal:                                Definitions.
  * signal handling:                       Signals.
! * special builtin <1>:                   Definitions.
! * special builtin:                       Special Builtins.
  * startup files:                         Bash Startup Files.
  * suspending jobs:                       Job Control Basics.
***************
*** 7990,7993 ****
--- 8105,8109 ----
  * token:                                 Definitions.
  * variable, shell:                       Shell Parameters.
+ * variables, readline:                   Readline Init File Syntax.
  * word:                                  Definitions.
  * word splitting:                        Word Splitting.
***************
*** 7997,8121 ****
  
  Tag Table:
! Node: Top1185
! Node: Introduction3316
! Node: What is Bash?3541
! Node: What is a shell?4642
! Node: Definitions6876
! Node: Basic Shell Features9542
! Node: Shell Syntax10766
! Node: Shell Operation11790
! Node: Quoting13085
! Node: Escape Character14345
! Node: Single Quotes14817
! Node: Double Quotes15152
! Node: ANSI-C Quoting16055
! Node: Locale Translation16957
! Node: Comments17378
! Node: Shell Commands17984
! Node: Simple Commands18865
! Node: Pipelines19488
! Node: Lists21015
! Node: Looping Constructs22529
! Node: Conditional Constructs24976
! Node: Command Grouping30918
! Node: Shell Functions32295
! Node: Shell Parameters34833
! Node: Positional Parameters36159
! Node: Special Parameters37052
! Node: Shell Expansions39711
! Node: Brace Expansion41635
! Node: Tilde Expansion43305
! Node: Shell Parameter Expansion45637
! Node: Command Substitution52439
! Node: Arithmetic Expansion53761
! Node: Process Substitution54606
! Node: Word Splitting55643
! Node: Filename Expansion57095
! Node: Pattern Matching59055
! Node: Quote Removal61450
! Node: Redirections61736
! Node: Executing Commands68607
! Node: Simple Command Expansion69274
! Node: Command Search and Execution71197
! Node: Command Execution Environment73194
! Node: Environment75648
! Node: Exit Status77300
! Node: Signals78497
! Node: Shell Scripts80392
! Node: Shell Builtin Commands82776
! Node: Bourne Shell Builtins84211
! Node: Bash Builtins99107
! Node: The Set Builtin123146
! Node: Special Builtins129959
! Node: Shell Variables130931
! Node: Bourne Shell Variables131367
! Node: Bash Variables133147
! Node: Bash Features147888
! Node: Invoking Bash148770
! Node: Bash Startup Files153441
! Node: Interactive Shells158148
! Node: What is an Interactive Shell?158550
! Node: Is this Shell Interactive?159185
! Node: Interactive Shell Behavior159991
! Node: Bash Conditional Expressions163279
! Node: Shell Arithmetic166574
! Node: Aliases169005
! Node: Arrays171510
! Node: The Directory Stack174530
! Node: Directory Stack Builtins175236
! Node: Printing a Prompt178114
! Node: The Restricted Shell180486
! Node: Bash POSIX Mode181964
! Node: Job Control186258
! Node: Job Control Basics186724
! Node: Job Control Builtins190939
! Node: Job Control Variables195234
! Node: Command Line Editing196384
! Node: Introduction and Notation197382
! Node: Readline Interaction198999
! Node: Readline Bare Essentials200191
! Node: Readline Movement Commands201971
! Node: Readline Killing Commands202927
! Node: Readline Arguments204832
! Node: Searching205806
! Node: Readline Init File207685
! Node: Readline Init File Syntax208739
! Node: Conditional Init Constructs218285
! Node: Sample Init File220723
! Node: Bindable Readline Commands223892
! Node: Commands For Moving225085
! Node: Commands For History225933
! Node: Commands For Text228727
! Node: Commands For Killing230678
! Node: Numeric Arguments232644
! Node: Commands For Completion233770
! Node: Keyboard Macros237602
! Node: Miscellaneous Commands238160
! Node: Readline vi Mode242534
! Node: Programmable Completion243444
! Node: Programmable Completion Builtins248120
! Node: Using History Interactively254226
! Node: Bash History Facilities254905
! Node: Bash History Builtins257466
! Node: History Interaction261038
! Node: Event Designators263590
! Node: Word Designators264517
! Node: Modifiers266146
! Node: Installing Bash267463
! Node: Basic Installation268605
! Node: Compilers and Options271723
! Node: Compiling For Multiple Architectures272457
! Node: Installation Names274114
! Node: Specifying the System Type274837
! Node: Sharing Defaults275544
! Node: Operation Controls276209
! Node: Optional Features277160
! Node: Reporting Bugs284581
! Node: Major Differences From The Bourne Shell285678
! Node: Builtin Index299726
! Node: Reserved Word Index303317
! Node: Variable Index304793
! Node: Function Index310465
! Node: Concept Index314955
  
  End Tag Table
--- 8113,8237 ----
  
  Tag Table:
! Node: Top1157
! Node: Introduction3286
! Node: What is Bash?3511
! Node: What is a shell?4612
! Node: Definitions6846
! Node: Basic Shell Features9512
! Node: Shell Syntax10736
! Node: Shell Operation11760
! Node: Quoting13045
! Node: Escape Character14304
! Node: Single Quotes14776
! Node: Double Quotes15111
! Node: ANSI-C Quoting16012
! Node: Locale Translation16915
! Node: Comments17690
! Node: Shell Commands18295
! Node: Simple Commands19176
! Node: Pipelines19797
! Node: Lists21322
! Node: Looping Constructs22835
! Node: Conditional Constructs25279
! Node: Command Grouping31220
! Node: Shell Functions32597
! Node: Shell Parameters35134
! Node: Positional Parameters36459
! Node: Special Parameters37350
! Node: Shell Expansions40008
! Node: Brace Expansion41928
! Node: Tilde Expansion43597
! Node: Shell Parameter Expansion45928
! Node: Command Substitution52728
! Node: Arithmetic Expansion54050
! Node: Process Substitution54894
! Node: Word Splitting55931
! Node: Filename Expansion57383
! Node: Pattern Matching59341
! Node: Quote Removal62472
! Node: Redirections62758
! Node: Executing Commands69629
! Node: Simple Command Expansion70296
! Node: Command Search and Execution72217
! Node: Command Execution Environment74214
! Node: Environment76667
! Node: Exit Status78318
! Node: Signals79513
! Node: Shell Scripts81405
! Node: Shell Builtin Commands83788
! Node: Bourne Shell Builtins85218
! Node: Bash Builtins100145
! Node: The Set Builtin124177
! Node: Special Builtins131034
! Node: Shell Variables132006
! Node: Bourne Shell Variables132442
! Node: Bash Variables134221
! Node: Bash Features149565
! Node: Invoking Bash150447
! Node: Bash Startup Files155232
! Node: Interactive Shells160102
! Node: What is an Interactive Shell?160504
! Node: Is this Shell Interactive?161139
! Node: Interactive Shell Behavior161945
! Node: Bash Conditional Expressions165212
! Node: Shell Arithmetic168506
! Node: Aliases170937
! Node: Arrays173440
! Node: The Directory Stack176460
! Node: Directory Stack Builtins177166
! Node: Printing a Prompt180044
! Node: The Restricted Shell182414
! Node: Bash POSIX Mode183892
! Node: Job Control189520
! Node: Job Control Basics189986
! Node: Job Control Builtins194200
! Node: Job Control Variables198495
! Node: Command Line Editing199644
! Node: Introduction and Notation200642
! Node: Readline Interaction202259
! Node: Readline Bare Essentials203445
! Node: Readline Movement Commands205225
! Node: Readline Killing Commands206181
! Node: Readline Arguments208090
! Node: Searching209125
! Node: Readline Init File211115
! Node: Readline Init File Syntax212169
! Node: Conditional Init Constructs222372
! Node: Sample Init File224896
! Node: Bindable Readline Commands228065
! Node: Commands For Moving229264
! Node: Commands For History230112
! Node: Commands For Text233000
! Node: Commands For Killing234933
! Node: Numeric Arguments236883
! Node: Commands For Completion238010
! Node: Keyboard Macros241590
! Node: Miscellaneous Commands242148
! Node: Readline vi Mode246510
! Node: Programmable Completion247419
! Node: Programmable Completion Builtins252467
! Node: Using History Interactively259374
! Node: Bash History Facilities260053
! Node: Bash History Builtins262613
! Node: History Interaction266179
! Node: Event Designators268730
! Node: Word Designators269657
! Node: Modifiers271286
! Node: Installing Bash272603
! Node: Basic Installation273745
! Node: Compilers and Options276863
! Node: Compiling For Multiple Architectures277597
! Node: Installation Names279254
! Node: Specifying the System Type279977
! Node: Sharing Defaults280684
! Node: Operation Controls281349
! Node: Optional Features282300
! Node: Reporting Bugs289705
! Node: Major Differences From The Bourne Shell290802
! Node: Builtin Index304814
! Node: Reserved Word Index308405
! Node: Variable Index309881
! Node: Function Index315667
! Node: Concept Index320157
  
  End Tag Table
diff -Nrc2 bash-2.04/doc/bashref.texi bash-2.05/doc/bashref.texi
*** bash-2.04/doc/bashref.texi	Tue Mar 14 11:38:33 2000
--- bash-2.05/doc/bashref.texi	Wed Mar 28 14:49:52 2001
***************
*** 6,16 ****
  
  @ignore
! Last Change: Tue Mar 14 11:38:10 EST 2000
  @end ignore
  
! @set EDITION 2.4
! @set VERSION 2.04
! @set UPDATED 14 March 2000
! @set UPDATE-MONTH March 2000
  
  @iftex
--- 6,16 ----
  
  @ignore
! Last Change: Wed Mar 28 14:48:38 EST 2001
  @end ignore
  
! @set EDITION 2.5
! @set VERSION 2.05
! @set UPDATED 28 Mar 2001
! @set UPDATE-MONTH Mar 2001
  
  @iftex
***************
*** 414,418 ****
  @item
  Reads its input from a file (@pxref{Shell Scripts}), from a string
! supplied as an argument to the @samp{-c} invocation option
  (@pxref{Invoking Bash}), or from the user's terminal.
  
--- 414,418 ----
  @item
  Reads its input from a file (@pxref{Shell Scripts}), from a string
! supplied as an argument to the @option{-c} invocation option
  (@pxref{Invoking Bash}), or from the user's terminal.
  
***************
*** 471,475 ****
  When the command history expansion facilities are being used, the
  @var{history expansion} character, usually @samp{!}, must be quoted
! to prevent history expansion.  @xref{Bash History Facilities} for
  more details concerning history expansion.
  There are three quoting mechanisms: the
--- 471,475 ----
  When the command history expansion facilities are being used, the
  @var{history expansion} character, usually @samp{!}, must be quoted
! to prevent history expansion.  @xref{Bash History Facilities}, for
  more details concerning history expansion.
  There are three quoting mechanisms: the
***************
*** 518,522 ****
  Words of the form @code{$'@var{string}'} are treated specially.  The
  word expands to @var{string}, with backslash-escaped characters replaced
! as specifed by the ANSI C standard.  Backslash escape sequences, if
  present, are decoded as follows:
  
--- 518,522 ----
  Words of the form @code{$'@var{string}'} are treated specially.  The
  word expands to @var{string}, with backslash-escaped characters replaced
! as specified by the ANSI C standard.  Backslash escape sequences, if
  present, are decoded as follows:
  
***************
*** 565,568 ****
--- 565,575 ----
  double-quoted.
  
+ Some systems use the message catalog selected by the @env{LC_MESSAGES}
+ shell variable.  Others create the name of the message catalog from the
+ value of the @env{TEXTDOMAIN} shell variable, possibly adding a
+ suffix of @samp{.mo}.  If you use the @env{TEXTDOMAIN} variable, you
+ may need to set the @env{TEXTDOMAINDIR} variable to the location of
+ the message catalog files.
+ 
  @node Comments
  @subsection Comments
***************
*** 642,648 ****
  The statistics currently consist of elapsed (wall-clock) time and
  user and system time consumed by the command's execution.
! The @samp{-p} option changes the output format to that specified
  by @sc{posix}.
! The @code{TIMEFORMAT} variable may be set to a format string that
  specifies how the timing information should be displayed.
  @xref{Bash Variables}, for a description of the available formats.
--- 649,655 ----
  The statistics currently consist of elapsed (wall-clock) time and
  user and system time consumed by the command's execution.
! The @option{-p} option changes the output format to that specified
  by @sc{posix}.
! The @env{TIMEFORMAT} variable may be set to a format string that
  specifies how the timing information should be displayed.
  @xref{Bash Variables}, for a description of the available formats.
***************
*** 875,879 ****
  @samp{in @var{words}} is omitted, the positional parameters are printed,
  as if @samp{in "$@@"} had been specifed.
! The @code{PS3} prompt is then displayed and a line is read from the
  standard input.
  If the line consists of a number corresponding to one of the displayed
--- 882,886 ----
  @samp{in @var{words}} is omitted, the positional parameters are printed,
  as if @samp{in "$@@"} had been specifed.
! The @env{PS3} prompt is then displayed and a line is read from the
  standard input.
  If the line consists of a number corresponding to one of the displayed
***************
*** 882,886 ****
  If @code{EOF} is read, the @code{select} command completes.
  Any other value read causes @var{name} to be set to null.
! The line read is saved in the variable @code{REPLY}.
  
  The @var{commands} are executed after each selection until a
--- 889,893 ----
  If @code{EOF} is read, the @code{select} command completes.
  Any other value read causes @var{name} to be set to null.
! The line read is saved in the variable @env{REPLY}.
  
  The @var{commands} are executed after each selection until a
***************
*** 1047,1051 ****
  positional parameters is updated to reflect the change.
  Positional parameter @code{0} is unchanged.
! The @code{FUNCNAME} variable is set to the name of the function
  while the function is executing.
  
--- 1054,1058 ----
  positional parameters is updated to reflect the change.
  Positional parameter @code{0} is unchanged.
! The @env{FUNCNAME} variable is set to the name of the function
  while the function is executing.
  
***************
*** 1140,1150 ****
  expansion occurs within double quotes, it expands to a single word
  with the value of each parameter separated by the first character
! of the @code{IFS}
  special variable.  That is, @code{"$*"} is equivalent
  to @code{"$1@var{c}$2@var{c}@dots{}"}, where @var{c}
  is the first character of the value of the @code{IFS}
  variable.
! If @code{IFS} is unset, the parameters are separated by spaces.
! If @code{IFS} is null, the parameters are joined without intervening
  separators.
  
--- 1147,1157 ----
  expansion occurs within double quotes, it expands to a single word
  with the value of each parameter separated by the first character
! of the @env{IFS}
  special variable.  That is, @code{"$*"} is equivalent
  to @code{"$1@var{c}$2@var{c}@dots{}"}, where @var{c}
  is the first character of the value of the @code{IFS}
  variable.
! If @env{IFS} is unset, the parameters are separated by spaces.
! If @env{IFS} is null, the parameters are joined without intervening
  separators.
  
***************
*** 1170,1174 ****
  invocation, by the @code{set}
  builtin command, or those set by the shell itself
! (such as the @samp{-i} option).
  
  @item $
--- 1177,1181 ----
  invocation, by the @code{set}
  builtin command, or those set by the shell itself
! (such as the @option{-i} option).
  
  @item $
***************
*** 1184,1188 ****
  shell initialization.  If Bash is invoked with a file of commands
  (@pxref{Shell Scripts}), @code{$0} is set to the name of that file.
! If Bash is started with the @samp{-c} option (@pxref{Invoking Bash}),
  then @code{$0} is set to the first argument after the string to be
  executed, if one is present.  Otherwise, it is set
--- 1191,1195 ----
  shell initialization.  If Bash is invoked with a file of commands
  (@pxref{Shell Scripts}), @code{$0} is set to the name of that file.
! If Bash is started with the @option{-c} option (@pxref{Invoking Bash}),
  then @code{$0} is set to the first argument after the string to be
  executed, if one is present.  Otherwise, it is set
***************
*** 1312,1317 ****
  possible @var{login name}.
  If this login name is the null string, the tilde is replaced with the
! value of the @code{HOME} shell variable.
! If @code{HOME} is unset, the home directory of the user executing the
  shell is substituted instead.
  Otherwise, the tilde-prefix is replaced with the home directory
--- 1319,1324 ----
  possible @var{login name}.
  If this login name is the null string, the tilde is replaced with the
! value of the @env{HOME} shell variable.
! If @env{HOME} is unset, the home directory of the user executing the
  shell is substituted instead.
  Otherwise, the tilde-prefix is replaced with the home directory
***************
*** 1319,1325 ****
  
  If the tilde-prefix is @samp{~+}, the value of
! the shell variable @code{PWD} replaces the tilde-prefix.
  If the tilde-prefix is @samp{~-}, the value of the shell variable
! @code{OLDPWD}, if it is set, is substituted.
  
  If the characters following the tilde in the tilde-prefix consist of a
--- 1326,1332 ----
  
  If the tilde-prefix is @samp{~+}, the value of
! the shell variable @env{PWD} replaces the tilde-prefix.
  If the tilde-prefix is @samp{~-}, the value of the shell variable
! @env{OLDPWD}, if it is set, is substituted.
  
  If the characters following the tilde in the tilde-prefix consist of a
***************
*** 1339,1343 ****
  In these cases, tilde expansion is also performed.
  Consequently, one may use file names with tildes in assignments to
! @code{PATH}, @code{MAILPATH}, and @code{CDPATH},
  and the shell assigns the expanded value.
  
--- 1346,1350 ----
  In these cases, tilde expansion is also performed.
  Consequently, one may use file names with tildes in assignments to
! @env{PATH}, @env{MAILPATH}, and @env{CDPATH},
  and the shell assigns the expanded value.
  
***************
*** 1466,1470 ****
  @item $@{!@var{prefix}*@}
  Expands to the names of variables whose names begin with @var{prefix},
! separated by the first character of the @code{IFS} special variable.
  
  @item $@{#@var{parameter}@}
--- 1473,1477 ----
  @item $@{!@var{prefix}*@}
  Expands to the names of variables whose names begin with @var{prefix},
! separated by the first character of the @env{IFS} special variable.
  
  @item $@{#@var{parameter}@}
***************
*** 1636,1655 ****
  word splitting.
  
! The shell treats each character of @code{$IFS}
  as a delimiter, and splits the results of the other
  expansions into words on these characters.  If
! @code{IFS} is unset, or its value is exactly @code{<space><tab><newline>},
! the default, then any sequence of @code{IFS}
! characters serves to delimit words.  If @code{IFS}
  has a value other than the default, then sequences of
  the whitespace characters @code{space} and @code{tab}
  are ignored at the beginning and end of the
  word, as long as the whitespace character is in the
! value of @code{IFS} (an @code{IFS} whitespace character).
! Any character in @code{IFS} that is not @code{IFS}
! whitespace, along with any adjacent @code{IFS}
! whitespace characters, delimits a field.  A sequence of @code{IFS}
  whitespace characters is also treated as a delimiter.
! If the value of @code{IFS} is null, no word splitting occurs.
  
  Explicit null arguments (@code{""} or @code{''}) are retained.
--- 1643,1662 ----
  word splitting.
  
! The shell treats each character of @env{$IFS}
  as a delimiter, and splits the results of the other
  expansions into words on these characters.  If
! @env{IFS} is unset, or its value is exactly @code{<space><tab><newline>},
! the default, then any sequence of @env{IFS}
! characters serves to delimit words.  If @env{IFS}
  has a value other than the default, then sequences of
  the whitespace characters @code{space} and @code{tab}
  are ignored at the beginning and end of the
  word, as long as the whitespace character is in the
! value of @env{IFS} (an @env{IFS} whitespace character).
! Any character in @env{IFS} that is not @env{IFS}
! whitespace, along with any adjacent @env{IFS}
! whitespace characters, delimits a field.  A sequence of @env{IFS}
  whitespace characters is also treated as a delimiter.
! If the value of @env{IFS} is null, no word splitting occurs.
  
  Explicit null arguments (@code{""} or @code{''}) are retained.
***************
*** 1672,1676 ****
  @cindex pathname expansion
  
! After word splitting, unless the @samp{-f} option has been set
  (@pxref{The Set Builtin}), Bash scans each word for the characters
  @samp{*}, @samp{?}, and @samp{[}.
--- 1679,1683 ----
  @cindex pathname expansion
  
! After word splitting, unless the @option{-f} option has been set
  (@pxref{The Set Builtin}), Bash scans each word for the characters
  @samp{*}, @samp{?}, and @samp{[}.
***************
*** 1697,1714 ****
  and @code{dotglob} options.
  
! The @code{GLOBIGNORE}
  shell variable may be used to restrict the set of filenames matching a
! pattern.  If @code{GLOBIGNORE}
  is set, each matching filename that also matches one of the patterns in
! @code{GLOBIGNORE} is removed from the list of matches.  The filenames
  @file{.} and @file{..}
! are always ignored, even when @code{GLOBIGNORE}
! is set.  However, setting @code{GLOBIGNORE} has the effect of
  enabling the @code{dotglob}
  shell option, so all other filenames beginning with a
  @samp{.} will match.
  To get the old behavior of ignoring filenames beginning with a
! @samp{.}, make @samp{.*} one of the patterns in @code{GLOBIGNORE}.
! The @code{dotglob} option is disabled when @code{GLOBIGNORE}
  is unset.
  
--- 1704,1721 ----
  and @code{dotglob} options.
  
! The @env{GLOBIGNORE}
  shell variable may be used to restrict the set of filenames matching a
! pattern.  If @env{GLOBIGNORE}
  is set, each matching filename that also matches one of the patterns in
! @env{GLOBIGNORE} is removed from the list of matches.  The filenames
  @file{.} and @file{..}
! are always ignored, even when @env{GLOBIGNORE}
! is set.  However, setting @env{GLOBIGNORE} has the effect of
  enabling the @code{dotglob}
  shell option, so all other filenames beginning with a
  @samp{.} will match.
  To get the old behavior of ignoring filenames beginning with a
! @samp{.}, make @samp{.*} one of the patterns in @env{GLOBIGNORE}.
! The @code{dotglob} option is disabled when @env{GLOBIGNORE}
  is unset.
  
***************
*** 1731,1736 ****
  @item [@dots{}]
  Matches any one of the enclosed characters.  A pair of characters
! separated by a minus sign denotes a @var{range};
! any character lexically between those two characters, inclusive,
  is matched.  If the first character following the
  @samp{[} is a @samp{!}  or a @samp{^}
--- 1738,1744 ----
  @item [@dots{}]
  Matches any one of the enclosed characters.  A pair of characters
! separated by a hyphen denotes a @var{range expression};
! any character that sorts between those two characters, inclusive,
! using the current locale's collating sequence and character set,
  is matched.  If the first character following the
  @samp{[} is a @samp{!}  or a @samp{^}
***************
*** 1739,1742 ****
--- 1747,1761 ----
  in the set.  A @samp{]} may be matched by including it as the first
  character in the set.
+ The sorting order of characters in range expressions is determined by
+ the current locale and the value of the @env{LC_COLLATE} shell variable,
+ if set.
+ 
+ For example, in the default C locale, @samp{[a-dx-z]} is equivalent to
+ @samp{[abcdxyz]}.  Many locales sort characters in dictionary order, and in
+ these locales @samp{[a-dx-z]} is typically not equivalent to @samp{[abcdxyz]};
+ it might be equivalent to @samp{[aBbCcDdxXyYz]}, for example.  To obtain
+ the traditional interpretation of ranges in bracket expressions, you can
+ force the use of the C locale by setting the @env{LC_COLLATE} or
+ @env{LC_ALL} environment variable to the value @samp{C}.
  
  Within @samp{[} and @samp{]}, @var{character classes} can be specified
***************
*** 2098,2106 ****
  If the name is neither a shell function nor a builtin,
  and contains no slashes, Bash searches each element of
! @code{$PATH} for a directory containing an executable file
  by that name.  Bash uses a hash table to remember the full
! pathnames of executable files to avoid multiple @code{PATH} searches
  (see the description of @code{hash} in @ref{Bourne Shell Builtins}).
! A full search of the directories in @code{$PATH}
  is performed only if the command is not found in the hash table.
  If the search is unsuccessful, the shell prints an error
--- 2117,2125 ----
  If the name is neither a shell function nor a builtin,
  and contains no slashes, Bash searches each element of
! @env{$PATH} for a directory containing an executable file
  by that name.  Bash uses a hash table to remember the full
! pathnames of executable files to avoid multiple @env{PATH} searches
  (see the description of @code{hash} in @ref{Bourne Shell Builtins}).
! A full search of the directories in @env{$PATH}
  is performed only if the command is not found in the hash table.
  If the search is unsuccessful, the shell prints an error
***************
*** 2170,2174 ****
  various process @sc{id}s, including those of background jobs
  (@pxref{Lists}), the value of @code{$$}, and the value of
! @code{$PPID}
  
  @end itemize
--- 2189,2193 ----
  various process @sc{id}s, including those of background jobs
  (@pxref{Lists}), the value of @code{$$}, and the value of
! @env{$PPID}
  
  @end itemize
***************
*** 2242,2246 ****
  by that command.
  
! If the @samp{-k} option is set (@pxref{The Set Builtin}), then all
  parameter assignments are placed in the environment for a command,
  not just those that precede the command name.
--- 2261,2265 ----
  by that command.
  
! If the @option{-k} option is set (@pxref{The Set Builtin}), then all
  parameter assignments are placed in the environment for a command,
  not just those that precede the command name.
***************
*** 2330,2334 ****
  A shell script is a text file containing shell commands.  When such
  a file is used as the first non-option argument when invoking Bash,
! and neither the @samp{-c} nor @samp{-s} option is supplied
  (@pxref{Invoking Bash}), 
  Bash reads and executes commands from the file, then exits.  This
--- 2349,2353 ----
  A shell script is a text file containing shell commands.  When such
  a file is used as the first non-option argument when invoking Bash,
! and neither the @option{-c} nor @option{-s} option is supplied
  (@pxref{Invoking Bash}), 
  Bash reads and executes commands from the file, then exits.  This
***************
*** 2342,2346 ****
  A shell script may be made executable by using the @code{chmod} command
  to turn on the execute bit.  When Bash finds such a file while
! searching the @code{$PATH} for a command, it spawns a subshell to
  execute it.  In other words, executing
  @example
--- 2361,2365 ----
  A shell script may be made executable by using the @code{chmod} command
  to turn on the execute bit.  When Bash finds such a file while
! searching the @env{$PATH} for a command, it spawns a subshell to
  execute it.  In other words, executing
  @example
***************
*** 2436,2442 ****
  Read and execute commands from the @var{filename} argument in the
  current shell context.  If @var{filename} does not contain a slash,
! the @code{PATH} variable is used to find
! @var{filename}.  The current directory is searched if @var{filename}
! is not found in @code{$PATH}.
  If any @var{arguments} are supplied, they become the positional
  parameters when @var{filename} is executed.  Otherwise the positional
--- 2455,2461 ----
  Read and execute commands from the @var{filename} argument in the
  current shell context.  If @var{filename} does not contain a slash,
! the @env{PATH} variable is used to find @var{filename}.
! When Bash is not in @sc{posix} mode, the current directory is searched
! if @var{filename} is not found in @env{$PATH}.
  If any @var{arguments} are supplied, they become the positional
  parameters when @var{filename} is executed.  Otherwise the positional
***************
*** 2463,2473 ****
  @end example
  Change the current working directory to @var{directory}.  If @var{directory}
! is not given, the value of the @code{HOME} shell variable is used.  If the
! shell variable @code{CDPATH} exists, it is used as a search path.  If
! @var{directory} begins with a slash, @code{CDPATH} is not used.
! The @samp{-P} option means
  to not follow symbolic links; symbolic links are followed by default
! or with the @samp{-L} option.
! If @var{directory} is @samp{-}, it is equivalent to @code{$OLDPWD}.
  The return status is zero if the directory is successfully changed,
  non-zero otherwise.
--- 2482,2492 ----
  @end example
  Change the current working directory to @var{directory}.  If @var{directory}
! is not given, the value of the @env{HOME} shell variable is used.  If the
! shell variable @env{CDPATH} exists, it is used as a search path.  If
! @var{directory} begins with a slash, @env{CDPATH} is not used.
! The @option{-P} option means
  to not follow symbolic links; symbolic links are followed by default
! or with the @option{-L} option.
! If @var{directory} is @samp{-}, it is equivalent to @env{$OLDPWD}.
  The return status is zero if the directory is successfully changed,
  non-zero otherwise.
***************
*** 2503,2512 ****
  If @var{command}
  is supplied, it replaces the shell without creating a new process.
! If the @samp{-l} option is supplied, the shell places a dash at the
  beginning of the zeroth arg passed to @var{command}.
  This is what the @code{login} program does.
! The @samp{-c} option causes @var{command} to be executed with an empty
  environment.
! If @samp{-a} is supplied, the shell passes @var{name} as the zeroth
  argument to @var{command}.
  If no @var{command} is specified, redirections may be used to affect
--- 2522,2531 ----
  If @var{command}
  is supplied, it replaces the shell without creating a new process.
! If the @option{-l} option is supplied, the shell places a dash at the
  beginning of the zeroth arg passed to @var{command}.
  This is what the @code{login} program does.
! The @option{-c} option causes @var{command} to be executed with an empty
  environment.
! If @option{-a} is supplied, the shell passes @var{name} as the zeroth
  argument to @var{command}.
  If no @var{command} is specified, redirections may be used to affect
***************
*** 2529,2540 ****
  @end example
  Mark each @var{name} to be passed to child processes
! in the environment.  If the @samp{-f} option is supplied, the @var{name}s
  refer to shell functions; otherwise the names refer to shell variables.
! The @samp{-n} option means to no longer mark each @var{name} for export.
! If no @var{names} are supplied, or if the @samp{-p} option is given, a
  list of exported names is displayed.
! The @samp{-p} option displays output in a form that may be reused as input.
  The return status is zero unless an invalid option is supplied, one of
! the names is not a valid shell variable name, or @samp{-f} is supplied
  with a name that is not a shell function.
  
--- 2548,2559 ----
  @end example
  Mark each @var{name} to be passed to child processes
! in the environment.  If the @option{-f} option is supplied, the @var{name}s
  refer to shell functions; otherwise the names refer to shell variables.
! The @option{-n} option means to no longer mark each @var{name} for export.
! If no @var{names} are supplied, or if the @option{-p} option is given, a
  list of exported names is displayed.
! The @option{-p} option displays output in a form that may be reused as input.
  The return status is zero unless an invalid option is supplied, one of
! the names is not a valid shell variable name, or @option{-f} is supplied
  with a name that is not a shell function.
  
***************
*** 2554,2563 ****
  @var{name} if it does not exist,
  and the index of the next argument to be processed into the
! variable @code{OPTIND}.
! @code{OPTIND} is initialized to 1 each time the shell or a shell script
  is invoked.
  When an option requires an argument,
! @code{getopts} places that argument into the variable @code{OPTARG}.
! The shell does not reset @code{OPTIND} automatically; it must be manually
  reset between multiple calls to @code{getopts} within the same shell
  invocation if a new set of parameters is to be used.
--- 2573,2582 ----
  @var{name} if it does not exist,
  and the index of the next argument to be processed into the
! variable @env{OPTIND}.
! @env{OPTIND} is initialized to 1 each time the shell or a shell script
  is invoked.
  When an option requires an argument,
! @code{getopts} places that argument into the variable @env{OPTARG}.
! The shell does not reset @env{OPTIND} automatically; it must be manually
  reset between multiple calls to @code{getopts} within the same shell
  invocation if a new set of parameters is to be used.
***************
*** 2565,2569 ****
  When the end of options is encountered, @code{getopts} exits with a
  return value greater than zero.
! @code{OPTIND} is set to the index of the first non-option argument,
  and @code{name} is set to @samp{?}.
  
--- 2584,2588 ----
  When the end of options is encountered, @code{getopts} exits with a
  return value greater than zero.
! @env{OPTIND} is set to the index of the first non-option argument,
  and @code{name} is set to @samp{?}.
  
***************
*** 2577,2581 ****
  are printed when invalid options or missing option arguments are
  encountered.
! If the variable @code{OPTERR}
  is set to 0, no error messages will be displayed, even if the first
  character of @code{optstring} is not a colon.
--- 2596,2600 ----
  are printed when invalid options or missing option arguments are
  encountered.
! If the variable @env{OPTERR}
  is set to 0, no error messages will be displayed, even if the first
  character of @code{optstring} is not a colon.
***************
*** 2583,2589 ****
  If an invalid option is seen,
  @code{getopts} places @samp{?} into @var{name} and, if not silent,
! prints an error message and unsets @code{OPTARG}.
  If @code{getopts} is silent, the option character found is placed in
! @code{OPTARG} and no diagnostic message is printed.
  
  If a required argument is not found, and @code{getopts}
--- 2602,2608 ----
  If an invalid option is seen,
  @code{getopts} places @samp{?} into @var{name} and, if not silent,
! prints an error message and unsets @env{OPTARG}.
  If @code{getopts} is silent, the option character found is placed in
! @env{OPTARG} and no diagnostic message is printed.
  
  If a required argument is not found, and @code{getopts}
***************
*** 2591,2595 ****
  @code{OPTARG} is unset, and a diagnostic message is printed.
  If @code{getopts} is silent, then a colon (@samp{:}) is placed in
! @var{name} and @code{OPTARG} is set to the option character found.
  
  @item hash
--- 2610,2614 ----
  @code{OPTARG} is unset, and a diagnostic message is printed.
  If @code{getopts} is silent, then a colon (@samp{:}) is placed in
! @var{name} and @env{OPTARG} is set to the option character found.
  
  @item hash
***************
*** 2601,2608 ****
  so they need not be searched for on subsequent invocations.
  The commands are found by searching through the directories listed in
! @code{$PATH}.
! The @samp{-p} option inhibits the path search, and @var{filename} is
  used as the location of @var{name}.
! The @samp{-r} option causes the shell to forget all remembered locations.
  If no arguments are given, information about remembered commands is printed.
  The return status is zero unless a @var{name} is not found or an invalid
--- 2620,2627 ----
  so they need not be searched for on subsequent invocations.
  The commands are found by searching through the directories listed in
! @env{$PATH}.
! The @option{-p} option inhibits the path search, and @var{filename} is
  used as the location of @var{name}.
! The @option{-r} option causes the shell to forget all remembered locations.
  If no arguments are given, information about remembered commands is printed.
  The return status is zero unless a @var{name} is not found or an invalid
***************
*** 2615,2621 ****
  @end example
  Print the absolute pathname of the current working directory.
! If the @samp{-P} option is supplied, the pathname printed will not
  contain symbolic links.
! If the @samp{-L} option is supplied, the pathname printed may contain
  symbolic links.
  The return status is zero unless an error is encountered while
--- 2634,2640 ----
  @end example
  Print the absolute pathname of the current working directory.
! If the @option{-P} option is supplied, the pathname printed will not
  contain symbolic links.
! If the @option{-L} option is supplied, the pathname printed may contain
  symbolic links.
  The return status is zero unless an error is encountered while
***************
*** 2630,2643 ****
  Mark each @var{name} as readonly.
  The values of these names may not be changed by subsequent assignment.
! If the @samp{-f} option is supplied, each @var{name} refers to a shell
  function.
! The @samp{-a} option means each @var{name} refers to an array variable.
! If no @var{name} arguments are given, or if the @samp{-p}
  option is supplied, a list of all readonly names is printed.
! The @samp{-p} option causes output to be displayed in a format that
  may be reused as input.
  The return status is zero unless an invalid option is supplied, one of
  the @var{name} arguments is not a valid shell variable or function name,
! or the @samp{-f} option is supplied with a name that is not a shell function.
  
  @item return
--- 2649,2662 ----
  Mark each @var{name} as readonly.
  The values of these names may not be changed by subsequent assignment.
! If the @option{-f} option is supplied, each @var{name} refers to a shell
  function.
! The @option{-a} option means each @var{name} refers to an array variable.
! If no @var{name} arguments are given, or if the @option{-p}
  option is supplied, a list of all readonly names is printed.
! The @option{-p} option causes output to be displayed in a format that
  may be reused as input.
  The return status is zero unless an invalid option is supplied, one of
  the @var{name} arguments is not a valid shell variable or function name,
! or the @option{-f} option is supplied with a name that is not a shell function.
  
  @item return
***************
*** 2765,2772 ****
  If @var{arg} is the null string, then the signal specified by
  each @var{sigspec} is ignored by the shell and commands it invokes.
! If @var{arg} is not present and @samp{-p} has been supplied,
  the shell displays the trap commands associated with each @var{sigspec}.
  If no arguments are supplied, or
! only @samp{-p} is given, @code{trap} prints the list of commands
  associated with each signal number in a form that may be reused as
  shell input.
--- 2784,2791 ----
  If @var{arg} is the null string, then the signal specified by
  each @var{sigspec} is ignored by the shell and commands it invokes.
! If @var{arg} is not present and @option{-p} has been supplied,
  the shell displays the trap commands associated with each @var{sigspec}.
  If no arguments are supplied, or
! only @option{-p} is given, @code{trap} prints the list of commands
  associated with each signal number in a form that may be reused as
  shell input.
***************
*** 2777,2781 ****
  If a @var{sigspec} is @code{DEBUG}, the command @var{arg} is executed
  after every simple command.
! The @samp{-l} option causes the shell to print a list of signal names
  and their corresponding numbers.
  
--- 2796,2800 ----
  If a @var{sigspec} is @code{DEBUG}, the command @var{arg} is executed
  after every simple command.
! The @option{-l} option causes the shell to print a list of signal names
  and their corresponding numbers.
  
***************
*** 2796,2803 ****
  if not, it is interpreted as a symbolic mode mask similar
  to that accepted by the @code{chmod} command.  If @var{mode} is
! omitted, the current value of the mask is printed.  If the @samp{-S}
  option is supplied without a @var{mode} argument, the mask is printed
  in a symbolic format.
! If the  @samp{-p} option is supplied, and @var{mode}
  is omitted, the output is in a form that may be reused as input.
  The return status is zero if the mode is successfully changed or if
--- 2815,2822 ----
  if not, it is interpreted as a symbolic mode mask similar
  to that accepted by the @code{chmod} command.  If @var{mode} is
! omitted, the current value of the mask is printed.  If the @option{-S}
  option is supplied without a @var{mode} argument, the mask is printed
  in a symbolic format.
! If the  @option{-p} option is supplied, and @var{mode}
  is omitted, the output is in a form that may be reused as input.
  The return status is zero if the mode is successfully changed or if
***************
*** 2814,2820 ****
  @end example
  Each variable or function @var{name} is removed.
! If no options are supplied, or the @samp{-v} option is given, each
  @var{name} refers to a shell variable. 
! If the @samp{-f} option is given, the @var{name}s refer to shell
  functions, and the function definition is removed.
  Readonly variables and functions may not be unset.
--- 2833,2839 ----
  @end example
  Each variable or function @var{name} is removed.
! If no options are supplied, or the @option{-v} option is given, each
  @var{name} refers to a shell variable. 
! If the @option{-f} option is given, the @var{name}s refer to shell
  functions, and the function definition is removed.
  Readonly variables and functions may not be unset.
***************
*** 2838,2842 ****
  @end example
  
! Without arguments or with the @samp{-p} option, @code{alias} prints
  the list of aliases on the standard output in a form that allows
  them to be reused as input.
--- 2857,2861 ----
  @end example
  
! Without arguments or with the @option{-p} option, @code{alias} prints
  the list of aliases on the standard output in a form that allows
  them to be reused as input.
***************
*** 2875,2878 ****
--- 2894,2898 ----
  @code{emacs-ctlx},
  @code{vi},
+ @code{vi-move},
  @code{vi-command}, and
  @code{vi-insert}.
***************
*** 2947,2955 ****
  named @var{command}.
  Only shell builtin commands or commands found by searching the
! @code{PATH} are executed.
  If there is a shell function named @code{ls}, running @samp{command ls}
  within the function will execute the external command @code{ls}
  instead of calling the function recursively.
! The @samp{-p} option means to use a default value for @code{$PATH}
  that is guaranteed to find all of the standard utilities.
  The return status in this case is 127 if @var{command} cannot be
--- 2967,2975 ----
  named @var{command}.
  Only shell builtin commands or commands found by searching the
! @env{PATH} are executed.
  If there is a shell function named @code{ls}, running @samp{command ls}
  within the function will execute the external command @code{ls}
  instead of calling the function recursively.
! The @option{-p} option means to use a default value for @env{PATH}
  that is guaranteed to find all of the standard utilities.
  The return status in this case is 127 if @var{command} cannot be
***************
*** 2957,2964 ****
  otherwise.
  
! If either the @samp{-V} or @samp{-v} option is supplied, a
! description of @var{command} is printed.  The @samp{-v} option
  causes a single word indicating the command or file name used to
! invoke @var{command} to be displayed; the @samp{-V} option produces
  a more verbose description.  In this case, the return status is
  zero if @var{command} is found, and non-zero if not.
--- 2977,2984 ----
  otherwise.
  
! If either the @option{-V} or @option{-v} option is supplied, a
! description of @var{command} is printed.  The @option{-v} option
  causes a single word indicating the command or file name used to
! invoke @var{command} to be displayed; the @option{-V} option produces
  a more verbose description.  In this case, the return status is
  zero if @var{command} is found, and non-zero if not.
***************
*** 2973,2981 ****
  are given, then display the values of variables instead. 
  
! The @samp{-p} option will display the attributes and values of each
! @var{name}.  When @samp{-p} is used, additional options are ignored.
! The @samp{-F} option inhibits the display of function definitions;
! only the function name and attributes are printed.  @samp{-F} implies
! @samp{-f}.  The following options can be used to restrict output
  to variables with the specified attributes or to give variables
  attributes:
--- 2993,3001 ----
  are given, then display the values of variables instead. 
  
! The @option{-p} option will display the attributes and values of each
! @var{name}.  When @option{-p} is used, additional options are ignored.
! The @option{-F} option inhibits the display of function definitions;
! only the function name and attributes are printed.  @option{-F} implies
! @option{-f}.  The following options can be used to restrict output
  to variables with the specified attributes or to give variables
  attributes:
***************
*** 3014,3018 ****
  an attempt is made to turn off readonly status for a readonly variable,
  an attempt is made to turn off array status for an array variable,
! or an attempt is made to display a non-existent function with @samp{-f}.
  
  @item echo
--- 3034,3038 ----
  an attempt is made to turn off readonly status for a readonly variable,
  an attempt is made to turn off array status for an array variable,
! or an attempt is made to display a non-existent function with @option{-f}.
  
  @item echo
***************
*** 3024,3031 ****
  newline.
  The return status is always 0.
! If @samp{-n} is specified, the trailing newline is suppressed.
! If the @samp{-e} option is given, interpretation of the following
  backslash-escaped characters is enabled.
! The @samp{-E} option disables the interpretation of these escape characters,
  even on systems where they are interpreted by default.
  The @code{xpg_echo} shell option may be used to
--- 3044,3051 ----
  newline.
  The return status is always 0.
! If @option{-n} is specified, the trailing newline is suppressed.
! If the @option{-e} option is given, interpretation of the following
  backslash-escaped characters is enabled.
! The @option{-E} option disables the interpretation of these escape characters,
  even on systems where they are interpreted by default.
  The @code{xpg_echo} shell option may be used to
***************
*** 3071,3092 ****
  as a shell builtin to be executed without specifying a full pathname,
  even though the shell normally searches for builtins before disk commands.
! If @samp{-n} is used, the @var{name}s become disabled.  Otherwise
  @var{name}s are enabled.  For example, to use the @code{test} binary
! found via @code{$PATH} instead of the shell builtin version, type
  @samp{enable -n test}.
  
! If the @samp{-p} option is supplied, or no @var{name} arguments appear,
  a list of shell builtins is printed.  With no other arguments, the list
  consists of all enabled shell builtins.
! The @samp{-a} option means to list
  each builtin with an indication of whether or not it is enabled. 
  
! The @samp{-f} option means to load the new builtin command @var{name}
  from shared object @var{filename}, on systems that support dynamic loading.
! The @samp{-d} option will delete a builtin loaded with @samp{-f}.
  
  If there are no options, a list of the shell builtins is displayed.
! The @samp{-s} option restricts @code{enable} to the @sc{posix} special
! builtins.  If @samp{-s} is used with @samp{-f}, the new builtin becomes
  a special builtin (@pxref{Special Builtins}).
  
--- 3091,3112 ----
  as a shell builtin to be executed without specifying a full pathname,
  even though the shell normally searches for builtins before disk commands.
! If @option{-n} is used, the @var{name}s become disabled.  Otherwise
  @var{name}s are enabled.  For example, to use the @code{test} binary
! found via @env{$PATH} instead of the shell builtin version, type
  @samp{enable -n test}.
  
! If the @option{-p} option is supplied, or no @var{name} arguments appear,
  a list of shell builtins is printed.  With no other arguments, the list
  consists of all enabled shell builtins.
! The @option{-a} option means to list
  each builtin with an indication of whether or not it is enabled. 
  
! The @option{-f} option means to load the new builtin command @var{name}
  from shared object @var{filename}, on systems that support dynamic loading.
! The @option{-d} option will delete a builtin loaded with @option{-f}.
  
  If there are no options, a list of the shell builtins is displayed.
! The @option{-s} option restricts @code{enable} to the @sc{posix} special
! builtins.  If @option{-s} is used with @option{-f}, the new builtin becomes
  a special builtin (@pxref{Special Builtins}).
  
***************
*** 3103,3107 ****
  on all commands matching @var{pattern}, otherwise a list of
  the builtins is printed.
! The @samp{-s} option restricts the information displayed to a short
  usage synopsis.
  The return status is zero unless no command matches @var{pattern}.
--- 3123,3127 ----
  on all commands matching @var{pattern}, otherwise a list of
  the builtins is printed.
! The @option{-s} option restricts the information displayed to a short
  usage synopsis.
  The return status is zero unless no command matches @var{pattern}.
***************
*** 3174,3183 ****
  If there are fewer words read from the standard input than names,
  the remaining names are assigned empty values.
! The characters in the value of the @code{IFS} variable
  are used to split the line into words.
  The backslash character @samp{\} may be used to remove any special
  meaning for the next character read and for line continuation.
  If no names are supplied, the line read is assigned to the
! variable @code{REPLY}.
  The return code is zero, unless end-of-file is encountered or @code{read}
  times out.
--- 3194,3203 ----
  If there are fewer words read from the standard input than names,
  the remaining names are assigned empty values.
! The characters in the value of the @env{IFS} variable
  are used to split the line into words.
  The backslash character @samp{\} may be used to remove any special
  meaning for the next character read and for line continuation.
  If no names are supplied, the line read is assigned to the
! variable @env{REPLY}.
  The return code is zero, unless end-of-file is encountered or @code{read}
  times out.
***************
*** 3231,3237 ****
  @end example
  Toggle the values of variables controlling optional shell behavior.
! With no options, or with the @samp{-p} option, a list of all settable
  options is displayed, with an indication of whether or not each is set.
! The @samp{-p} option causes output to be displayed in a form that
  may be reused as input.
  Other options have the following meanings:
--- 3251,3257 ----
  @end example
  Toggle the values of variables controlling optional shell behavior.
! With no options, or with the @option{-p} option, a list of all settable
  options is displayed, with an indication of whether or not each is set.
! The @option{-p} option causes output to be displayed in a form that
  may be reused as input.
  Other options have the following meanings:
***************
*** 3247,3251 ****
  Suppresses normal output; the return status
  indicates whether the @var{optname} is set or unset.
! If multiple @var{optname} arguments are given with @samp{-q},
  the return status is zero if all @var{optnames} are enabled;
  non-zero otherwise.
--- 3267,3271 ----
  Suppresses normal output; the return status
  indicates whether the @var{optname} is set or unset.
! If multiple @var{optname} arguments are given with @option{-q},
  the return status is zero if all @var{optnames} are enabled;
  non-zero otherwise.
***************
*** 3253,3261 ****
  @item -o
  Restricts the values of
! @var{optname} to be those defined for the @samp{-o} option to the
  @code{set} builtin (@pxref{The Set Builtin}).
  @end table
  
! If either @samp{-s} or @samp{-u}
  is used with no @var{optname} arguments, the display is limited to
  those options which are set or unset, respectively.
--- 3273,3281 ----
  @item -o
  Restricts the values of
! @var{optname} to be those defined for the @option{-o} option to the
  @code{set} builtin (@pxref{The Set Builtin}).
  @end table
  
! If either @option{-s} or @option{-u}
  is used with no @var{optname} arguments, the display is limited to
  those options which are set or unset, respectively.
***************
*** 3294,3298 ****
  If set, Bash checks the window size after each command
  and, if necessary, updates the values of    
! @code{LINES} and @code{COLUMNS}.
  
  @item cmdhist
--- 3314,3318 ----
  If set, Bash checks the window size after each command
  and, if necessary, updates the values of    
! @env{LINES} and @env{COLUMNS}.
  
  @item cmdhist
***************
*** 3323,3327 ****
  @item histappend
  If set, the history list is appended to the file named by the value
! of the @code{HISTFILE}
  variable when the shell exits, rather than overwriting the file.
  
--- 3343,3347 ----
  @item histappend
  If set, the history list is appended to the file named by the value
! of the @env{HISTFILE}
  variable when the shell exits, rather than overwriting the file.
  
***************
*** 3365,3369 ****
  @item no_empty_cmd_completion
  If set, and Readline is being used, Bash will not attempt to search
! the @code{PATH} for possible completions when completion is attempted
  on an empty line.
  
--- 3385,3389 ----
  @item no_empty_cmd_completion
  If set, and Readline is being used, Bash will not attempt to search
! the @env{PATH} for possible completions when completion is attempted
  on an empty line.
  
***************
*** 3399,3403 ****
  
  @item sourcepath
! If set, the @code{source} builtin uses the value of @code{PATH}
  to find the directory containing the file supplied as an argument.
  This option is enabled by default.
--- 3419,3423 ----
  
  @item sourcepath
! If set, the @code{source} builtin uses the value of @env{PATH}
  to find the directory containing the file supplied as an argument.
  This option is enabled by default.
***************
*** 3430,3434 ****
  command name.
  
! If the @samp{-t} option is used, @code{type} prints a single word
  which is one of @samp{alias}, @samp{function}, @samp{builtin},
  @samp{file} or @samp{keyword},
--- 3450,3454 ----
  command name.
  
! If the @option{-t} option is used, @code{type} prints a single word
  which is one of @samp{alias}, @samp{function}, @samp{builtin},
  @samp{file} or @samp{keyword},
***************
*** 3438,3448 ****
  @code{type} returns a failure status.
  
! If the @samp{-p} option is used, @code{type} either returns the name
! of the disk file that would be executed, or nothing if @samp{-t}
  would not return @samp{file}.
  
! If the @samp{-a} option is used, @code{type} returns all of the places
  that contain an executable named @var{file}.
! This includes aliases and functions, if and only if the @samp{-p} option
  is not also used.
  
--- 3458,3468 ----
  @code{type} returns a failure status.
  
! If the @option{-p} option is used, @code{type} either returns the name
! of the disk file that would be executed, or nothing if @option{-t}
  would not return @samp{file}.
  
! If the @option{-a} option is used, @code{type} returns all of the places
  that contain an executable named @var{file}.
! This includes aliases and functions, if and only if the @option{-p} option
  is not also used.
  
***************
*** 3514,3523 ****
  If @var{limit} is given, it is the new value of the specified resource.
  Otherwise, the current value of the soft limit for the specified resource
! is printed, unless the @samp{-H} option is supplied.
! When setting new limits, if neither @samp{-H} nor @samp{-S} is supplied,
  both the hard and soft limits are set.
! If no option is given, then @samp{-f} is assumed.  Values are in 1024-byte
! increments, except for @samp{-t}, which is in seconds, @samp{-p},
! which is in units of 512-byte blocks, and @samp{-n} and @samp{-u}, which
  are unscaled values.
  
--- 3534,3543 ----
  If @var{limit} is given, it is the new value of the specified resource.
  Otherwise, the current value of the soft limit for the specified resource
! is printed, unless the @option{-H} option is supplied.
! When setting new limits, if neither @option{-H} nor @option{-S} is supplied,
  both the hard and soft limits are set.
! If no option is given, then @option{-f} is assumed.  Values are in 1024-byte
! increments, except for @option{-t}, which is in seconds, @option{-p},
! which is in units of 512-byte blocks, and @option{-n} and @option{-u}, which
  are unscaled values.
  
***************
*** 3532,3536 ****
  @end example
  
! Remove each @var{name} from the list of aliases.  If @samp{-a} is
  supplied, all aliases are removed.
  Aliases are described in @ref{Aliases}.
--- 3552,3556 ----
  @end example
  
! Remove each @var{name} from the list of aliases.  If @option{-a} is
  supplied, all aliases are removed.
  Aliases are described in @ref{Aliases}.
***************
*** 3559,3563 ****
  @table @code
  @item -a
! Mark variables which are modified or created for export.
  
  @item -b
--- 3579,3584 ----
  @table @code
  @item -a
! Mark variables and function which are modified or created for export
! to the environment of subsequent commands.
  
  @item -b
***************
*** 3671,3677 ****
  @item -p
  Turn on privileged mode.
! In this mode, the @code{$BASH_ENV} and @code{$ENV} files are not
  processed, shell functions are not inherited from the environment,
! and the @code{SHELLOPTS} variable, if it appears in the environment,
  is ignored.
  If the shell is started with the effective user (group) id not equal to the
--- 3692,3698 ----
  @item -p
  Turn on privileged mode.
! In this mode, the @env{$BASH_ENV} and @env{$ENV} files are not
  processed, shell functions are not inherited from the environment,
! and the @env{SHELLOPTS} variable, if it appears in the environment,
  is ignored.
  If the shell is started with the effective user (group) id not equal to the
***************
*** 3742,3747 ****
  @item -
  Signal the end of options, cause all remaining @var{arguments}
! to be assigned to the positional parameters.  The @samp{-x}
! and @samp{-v}  options are turned off.
  If there are no arguments, the positional parameters remain unchanged.
  @end table
--- 3763,3768 ----
  @item -
  Signal the end of options, cause all remaining @var{arguments}
! to be assigned to the positional parameters.  The @option{-x}
! and @option{-v}  options are turned off.
  If there are no arguments, the positional parameters remain unchanged.
  @end table
***************
*** 3824,3828 ****
  
  @item MAIL
! If this parameter is set to a filename and the @code{MAILPATH} variable
  is not set, Bash informs the user of the arrival of mail in
  the specified file.
--- 3845,3849 ----
  
  @item MAIL
! If this parameter is set to a filename and the @env{MAILPATH} variable
  is not set, Bash informs the user of the arrival of mail in
  the specified file.
***************
*** 3850,3854 ****
  The primary prompt string.  The default value is @samp{\s-\v\$ }.
  @xref{Printing a Prompt}, for the complete list of escape
! sequences that are expanded before @code{PS1} is displayed.
  
  @item PS2
--- 3871,3875 ----
  The primary prompt string.  The default value is @samp{\s-\v\$ }.
  @xref{Printing a Prompt}, for the complete list of escape
! sequences that are expanded before @env{PS1} is displayed.
  
  @item PS2
***************
*** 3903,3907 ****
  
  @item BASH_VERSINFO[5]
! The value of @code{MACHTYPE}.
  
  @end table
--- 3924,3928 ----
  
  @item BASH_VERSINFO[5]
! The value of @env{MACHTYPE}.
  
  @end table
***************
*** 3914,3918 ****
  
  @item COMP_CWORD
! An index into @code{$@{COMP_WORDS@}} of the word containing the current
  cursor position.
  This variable is available only in shell functions invoked by the
--- 3935,3939 ----
  
  @item COMP_CWORD
! An index into @env{$@{COMP_WORDS@}} of the word containing the current
  cursor position.
  This variable is available only in shell functions invoked by the
***************
*** 3947,3951 ****
  builtins must be used to add and remove directories.
  Assignment to this variable will not change the current directory.
! If @code{DIRSTACK} is unset, it loses its special properties, even if
  it is subsequently reset.
  
--- 3968,3972 ----
  builtins must be used to add and remove directories.
  Assignment to this variable will not change the current directory.
! If @env{DIRSTACK} is unset, it loses its special properties, even if
  it is subsequently reset.
  
***************
*** 3955,3959 ****
  
  @item FCEDIT
! The editor used as a default by the @samp{-e} option to the @code{fc}
  builtin command.
  
--- 3976,3980 ----
  
  @item FCEDIT
! The editor used as a default by the @option{-e} option to the @code{fc}
  builtin command.
  
***************
*** 3962,3966 ****
  filename completion.
  A file name whose suffix matches one of the entries in 
! @code{FIGNORE}
  is excluded from the list of matched file names.  A sample
  value is @samp{.o:~}
--- 3983,3987 ----
  filename completion.
  A file name whose suffix matches one of the entries in 
! @env{FIGNORE}
  is excluded from the list of matched file names.  A sample
  value is @samp{.o:~}
***************
*** 3970,3974 ****
  be ignored by filename expansion.
  If a filename matched by a filename expansion pattern also matches one
! of the patterns in @code{GLOBIGNORE}, it is removed from the list
  of matches.
  
--- 3991,3995 ----
  be ignored by filename expansion.
  If a filename matched by a filename expansion pattern also matches one
! of the patterns in @env{GLOBIGNORE}, it is removed from the list
  of matches.
  
***************
*** 3976,3981 ****
  An array variable containing the list of groups of which the current    
  user is a member.
! Assignments to @code{GROUPS} have no effect and are silently discarded.
! If @code{GROUPS} is unset, it loses its special properties, even if it is
  subsequently reset.
  
--- 3997,4002 ----
  An array variable containing the list of groups of which the current    
  user is a member.
! Assignments to @env{GROUPS} have no effect and return an error status.
! If @env{GROUPS} is unset, it loses its special properties, even if it is
  subsequently reset.
  
***************
*** 3996,4000 ****
  @item HISTCMD
  The history number, or index in the history list, of the current
! command.  If @code{HISTCMD} is unset, it loses its special properties,
  even if it is subsequently reset.
  
--- 4017,4021 ----
  @item HISTCMD
  The history number, or index in the history list, of the current
! command.  If @env{HISTCMD} is unset, it loses its special properties,
  even if it is subsequently reset.
  
***************
*** 4002,4007 ****
  The name of any currently-executing shell function.      
  This variable exists only when a shell function is executing.
! Assignments to @code{FUNCNAME} have no effect and are silently discarded.
! If @code{FUNCNAME} is unset, it loses its special properties, even if
  it is subsequently reset.
  
--- 4023,4028 ----
  The name of any currently-executing shell function.      
  This variable exists only when a shell function is executing.
! Assignments to @env{FUNCNAME} have no effect and return an error status.
! If @env{FUNCNAME} is unset, it loses its special properties, even if
  it is subsequently reset.
  
***************
*** 4016,4020 ****
  The second and subsequent lines of a multi-line compound command are
  not tested, and are added to the history regardless of the value of
! @code{HISTCONTROL}.
  
  @item HISTIGNORE
--- 4037,4041 ----
  The second and subsequent lines of a multi-line compound command are
  not tested, and are added to the history regardless of the value of
! @env{HISTCONTROL}.
  
  @item HISTIGNORE
***************
*** 4023,4027 ****
  anchored at the beginning of the line and must match the complete
  line (no implicit @samp{*} is appended).  Each pattern is tested
! against the line after the checks specified by @code{HISTCONTROL}
  are applied.  In addition to the normal shell pattern matching
  characters, @samp{&} matches the previous history line.  @samp{&}
--- 4044,4048 ----
  anchored at the beginning of the line and must match the complete
  line (no implicit @samp{*} is appended).  Each pattern is tested
! against the line after the checks specified by @env{HISTCONTROL}
  are applied.  In addition to the normal shell pattern matching
  characters, @samp{&} matches the previous history line.  @samp{&}
***************
*** 4030,4036 ****
  The second and subsequent lines of a multi-line compound command are
  not tested, and are added to the history regardless of the value of
! @code{HISTIGNORE}.
  
! @code{HISTIGNORE} subsumes the function of @code{HISTCONTROL}.  A
  pattern of @samp{&} is identical to @code{ignoredups}, and a
  pattern of @samp{[ ]*} is identical to @code{ignorespace}. 
--- 4051,4057 ----
  The second and subsequent lines of a multi-line compound command are
  not tested, and are added to the history regardless of the value of
! @env{HISTIGNORE}.
  
! @env{HISTIGNORE} subsumes the function of @env{HISTCONTROL}.  A
  pattern of @samp{&} is identical to @code{ignoredups}, and a
  pattern of @samp{[ ]*} is identical to @code{ignorespace}. 
***************
*** 4062,4068 ****
  value is changed, Bash adds the contents of the new file to the
  existing list.
! If @code{HOSTFILE} is set, but has no value, Bash attempts to read 
  @file{/etc/hosts} to obtain the list of possible hostname completions.
! When @code{HOSTFILE} is unset, the hostname list is cleared.
  
  @item HOSTNAME
--- 4083,4089 ----
  value is changed, Bash adds the contents of the new file to the
  existing list.
! If @env{HOSTFILE} is set, but has no value, Bash attempts to read 
  @file{/etc/hosts} to obtain the list of possible hostname completions.
! When @env{HOSTFILE} is unset, the hostname list is cleared.
  
  @item HOSTNAME
***************
*** 4091,4095 ****
  
  @item LC_ALL
! This variable overrides the value of @code{LANG} and any other
  @code{LC_} variable specifying a locale category.
  
--- 4112,4116 ----
  
  @item LC_ALL
! This variable overrides the value of @env{LANG} and any other
  @code{LC_} variable specifying a locale category.
  
***************
*** 4113,4116 ****
--- 4134,4147 ----
  This variable determines the locale category used for number formatting.
  
+ @item LINES
+ Used by the @code{select} builtin command to determine the column length
+ for printing selection lists.  Automatically set upon receipt of a
+ @code{SIGWINCH}.
+ 
+ @item COLUMNS
+ Used by the @code{select} builtin command to determine the terminal width
+ when printing selection lists.  Automatically set upon receipt of a
+ @code{SIGWINCH}.
+ 
  @item LINENO
  The line number in the script or shell function currently executing.
***************
*** 4122,4126 ****
  @item MAILCHECK
  How often (in seconds) that the shell should check for mail in the
! files specified in the @code{MAILPATH} or @code{MAIL} variables.
  
  @item OLDPWD
--- 4153,4161 ----
  @item MAILCHECK
  How often (in seconds) that the shell should check for mail in the
! files specified in the @env{MAILPATH} or @env{MAIL} variables.
! The default is 60 seconds.  When it is time to check
! for mail, the shell does so before displaying the primary prompt.
! If this variable is unset, or set to a value that is not a number
! greater than or equal to zero, the shell disables mail checking.
  
  @item OLDPWD
***************
*** 4146,4150 ****
  @item PROMPT_COMMAND
  If set, the value is interpreted as a command to execute
! before the printing of each primary prompt (@code{$PS1}).
  
  @item PS3
--- 4181,4185 ----
  @item PROMPT_COMMAND
  If set, the value is interpreted as a command to execute
! before the printing of each primary prompt (@env{$PS1}).
  
  @item PS3
***************
*** 4155,4160 ****
  @item PS4
  The value is the prompt printed before the command line is echoed
! when the @samp{-x} option is set (@pxref{The Set Builtin}).
! The first character of @code{PS4} is replicated multiple times, as
  necessary, to indicate multiple levels of indirection.
  The default is @samp{+ }.
--- 4190,4195 ----
  @item PS4
  The value is the prompt printed before the command line is echoed
! when the @option{-x} option is set (@pxref{The Set Builtin}).
! The first character of @env{PS4} is replicated multiple times, as
  necessary, to indicate multiple levels of indirection.
  The default is @samp{+ }.
***************
*** 4180,4186 ****
  @item SHELLOPTS
  A colon-separated list of enabled shell options.  Each word in
! the list is a valid argument for the @samp{-o} option to the
  @code{set} builtin command (@pxref{The Set Builtin}).
! The options appearing in @code{SHELLOPTS} are those reported
  as @samp{on} by @samp{set -o}.
  If this variable is in the environment when Bash
--- 4215,4221 ----
  @item SHELLOPTS
  A colon-separated list of enabled shell options.  Each word in
! the list is a valid argument for the @option{-o} option to the
  @code{set} builtin command (@pxref{The Set Builtin}).
! The options appearing in @env{SHELLOPTS} are those reported
  as @samp{on} by @samp{set -o}.
  If this variable is in the environment when Bash
***************
*** 4292,4307 ****
  is printed on the standard ouput
  in the @sc{gnu} @code{gettext} PO (portable object) file format.
! Equivalent to @samp{-D} except for the output format.
  
  @item --dump-strings
! Equivalent to @samp{-D}.
  
  @item --help
  Display a usage message on standard output and exit sucessfully.
  
  @item --login
! Make this shell act as if it were directly invoked by login.
! This is equivalent to @samp{exec -l bash} but can be issued from
! another shell, such as @code{csh}.  @samp{exec bash --login}
  will replace the current shell with a Bash login shell.
  @xref{Bash Startup Files}, for a description of the special behavior
--- 4327,4350 ----
  is printed on the standard ouput
  in the @sc{gnu} @code{gettext} PO (portable object) file format.
! Equivalent to @option{-D} except for the output format.
  
  @item --dump-strings
! Equivalent to @option{-D}.
  
  @item --help
  Display a usage message on standard output and exit sucessfully.
  
+ @item --init-file @var{filename}
+ @itemx --rcfile @var{filename}
+ Execute commands from @var{filename} (instead of @file{~/.bashrc})
+ in an interactive shell.
+ 
  @item --login
! Make this shell act as if it had been directly invoked by login.
! When the shell is interactive, this is equivalent to starting a
! login shell with @samp{exec -l bash}.
! When the shell is not interactive, the login shell startup files will
! be executed.
! @samp{exec bash --login}
  will replace the current shell with a Bash login shell.
  @xref{Bash Startup Files}, for a description of the special behavior
***************
*** 4330,4342 ****
  @sc{posix} mode.
  
- @item --rcfile @var{filename}
- Execute commands from @var{filename} (instead of @file{~/.bashrc})
- in an interactive shell.
- 
  @item --restricted
  Make the shell a restricted shell (@pxref{The Restricted Shell}).
  
  @item --verbose
! Equivalent to @samp{-v}.  Print shell input lines as they're read.
  
  @item --version
--- 4373,4381 ----
  @sc{posix} mode.
  
  @item --restricted
  Make the shell a restricted shell (@pxref{The Restricted Shell}).
  
  @item --verbose
! Equivalent to @option{-v}.  Print shell input lines as they're read.
  
  @item --version
***************
*** 4374,4378 ****
  are subject to language translation when the current locale
  is not @code{C} or @code{POSIX} (@pxref{Locale Translation}).
! This implies the @samp{-n} option; no commands will be executed.
  
  @item --
--- 4413,4417 ----
  are subject to language translation when the current locale
  is not @code{C} or @code{POSIX} (@pxref{Locale Translation}).
! This implies the @option{-n} option; no commands will be executed.
  
  @item --
***************
*** 4385,4396 ****
  @cindex interactive shell
  An @emph{interactive} shell is one started without non-option arguments,
! unless @samp{-s} is specified,
! without specifying the @samp{-c} option, and whose input and output are both
  connected to terminals (as determined by @code{isatty(3)}), or one
! started with the @samp{-i} option.  @xref{Interactive Shells} for more
  information.
  
  If arguments remain after option processing, and neither the
! @samp{-c} nor the @samp{-s}
  option has been supplied, the first argument is assumed to
  be the name of a file containing shell commands (@pxref{Shell Scripts}).
--- 4424,4435 ----
  @cindex interactive shell
  An @emph{interactive} shell is one started without non-option arguments,
! unless @option{-s} is specified,
! without specifying the @option{-c} option, and whose input and output are both
  connected to terminals (as determined by @code{isatty(3)}), or one
! started with the @option{-i} option.  @xref{Interactive Shells}, for more
  information.
  
  If arguments remain after option processing, and neither the
! @option{-c} nor the @option{-s}
  option has been supplied, the first argument is assumed to
  be the name of a file containing shell commands (@pxref{Shell Scripts}).
***************
*** 4413,4425 ****
  Interactive shells are described in @ref{Interactive Shells}.
  
! @subsubheading Invoked as an interactive login shell, or with @samp{--login}
  
  When Bash is invoked as an interactive login shell, or as a
! non-interactive shell with the @samp{--login} option, it first reads and
  executes commands from the file @file{/etc/profile}, if that file exists.
  After reading that file, it looks for @file{~/.bash_profile},
  @file{~/.bash_login}, and @file{~/.profile}, in that order, and reads
  and executes commands from the first one that exists and is readable.
! The @samp{--noprofile} option may be used when the shell is started to
  inhibit this behavior.
  
--- 4452,4464 ----
  Interactive shells are described in @ref{Interactive Shells}.
  
! @subsubheading Invoked as an interactive login shell, or with @option{--login}
  
  When Bash is invoked as an interactive login shell, or as a
! non-interactive shell with the @option{--login} option, it first reads and
  executes commands from the file @file{/etc/profile}, if that file exists.
  After reading that file, it looks for @file{~/.bash_profile},
  @file{~/.bash_login}, and @file{~/.profile}, in that order, and reads
  and executes commands from the first one that exists and is readable.
! The @option{--noprofile} option may be used when the shell is started to
  inhibit this behavior.
  
***************
*** 4431,4436 ****
  When an interactive shell that is not a login shell is started, Bash
  reads and executes commands from @file{~/.bashrc}, if that file exists.
! This may be inhibited by using the @samp{--norc} option.
! The @samp{--rcfile @var{file}} option will force Bash to read and
  execute commands from @var{file} instead of @file{~/.bashrc}.
  
--- 4470,4475 ----
  When an interactive shell that is not a login shell is started, Bash
  reads and executes commands from @file{~/.bashrc}, if that file exists.
! This may be inhibited by using the @option{--norc} option.
! The @option{--rcfile @var{file}} option will force Bash to read and
  execute commands from @var{file} instead of @file{~/.bashrc}.
  
***************
*** 4445,4449 ****
  
  When Bash is started non-interactively, to run a shell script,
! for example, it looks for the variable @code{BASH_ENV} in the environment,
  expands its value if it appears there, and uses the expanded value as
  the name of a file to read and execute.  Bash behaves as if the
--- 4484,4488 ----
  
  When Bash is started non-interactively, to run a shell script,
! for example, it looks for the variable @env{BASH_ENV} in the environment,
  expands its value if it appears there, and uses the expanded value as
  the name of a file to read and execute.  Bash behaves as if the
***************
*** 4453,4459 ****
  @end example
  @noindent
! but the value of the @code{PATH} variable is not used to search for the
  file name.
  
  @subsubheading Invoked with name @code{sh}
  
--- 4492,4502 ----
  @end example
  @noindent
! but the value of the @env{PATH} variable is not used to search for the
  file name.
  
+ As noted above, if a non-interactive shell is invoked with the
+ @option{--login} option, Bash attempts to read and execute commands from the
+ login shell startup files. 
+ 
  @subsubheading Invoked with name @code{sh}
  
***************
*** 4463,4475 ****
  
  When invoked as an interactive login shell, or as a non-interactive
! shell with the @samp{--login} option, it first attempts to read
  and execute commands from @file{/etc/profile} and @file{~/.profile}, in
  that order.
! The @samp{--noprofile} option may be used to inhibit this behavior.
  When invoked as an interactive shell with the name @code{sh}, Bash
! looks for the variable @code{ENV}, expands its value if it is defined,
  and uses the expanded value as the name of a file to read and execute.
  Since a shell invoked as @code{sh} does not attempt to read and execute
! commands from any other startup files, the @samp{--rcfile} option has
  no effect.
  A non-interactive shell invoked with the name @code{sh} does not attempt
--- 4506,4518 ----
  
  When invoked as an interactive login shell, or as a non-interactive
! shell with the @option{--login} option, it first attempts to read
  and execute commands from @file{/etc/profile} and @file{~/.profile}, in
  that order.
! The @option{--noprofile} option may be used to inhibit this behavior.
  When invoked as an interactive shell with the name @code{sh}, Bash
! looks for the variable @env{ENV}, expands its value if it is defined,
  and uses the expanded value as the name of a file to read and execute.
  Since a shell invoked as @code{sh} does not attempt to read and execute
! commands from any other startup files, the @option{--rcfile} option has
  no effect.
  A non-interactive shell invoked with the name @code{sh} does not attempt
***************
*** 4482,4488 ****
  
  When Bash is started in @sc{posix} mode, as with the
! @samp{--posix} command line option, it follows the @sc{posix} standard
  for startup files.
! In this mode, interactive shells expand the @code{ENV} variable
  and commands are read and executed from the file whose name is the
  expanded value.
--- 4525,4531 ----
  
  When Bash is started in @sc{posix} mode, as with the
! @option{--posix} command line option, it follows the @sc{posix} standard
  for startup files.
! In this mode, interactive shells expand the @env{ENV} variable
  and commands are read and executed from the file whose name is the
  expanded value.
***************
*** 4496,4501 ****
  file exists and is readable.
  It will not do this if invoked as @code{sh}.
! The @samp{--norc} option may be used to inhibit this behavior, and the
! @samp{--rcfile} option may be used to force another file to be read, but
  @code{rshd} does not generally invoke the shell with those options or
  allow them to be specified.
--- 4539,4544 ----
  file exists and is readable.
  It will not do this if invoked as @code{sh}.
! The @option{--norc} option may be used to inhibit this behavior, and the
! @option{--rcfile} option may be used to force another file to be read, but
  @code{rshd} does not generally invoke the shell with those options or
  allow them to be specified.
***************
*** 4506,4510 ****
  real user (group) id, and the @code{-p} option is not supplied, no startup
  files are read, shell functions are not inherited from the environment,
! the @code{SHELLOPTS} variable, if it appears in the environment, is ignored,
  and the effective user id is set to the real user id.
  If the @code{-p} option is supplied at invocation, the startup behavior is
--- 4549,4553 ----
  real user (group) id, and the @code{-p} option is not supplied, no startup
  files are read, shell functions are not inherited from the environment,
! the @env{SHELLOPTS} variable, if it appears in the environment, is ignored,
  and the effective user id is set to the real user id.
  If the @code{-p} option is supplied at invocation, the startup behavior is
***************
*** 4526,4539 ****
  
  An interactive shell
! is one started without non-option arguments, unless @samp{-s} is
! specified, without specifiying the @samp{-c} option, and
  whose input and output are both
  connected to terminals (as determined by @code{isatty(3)}),
! or one started with the @samp{-i} option.
  
  An interactive shell generally reads from and writes to a user's
  terminal.
  
! The @samp{-s} invocation option may be used to set the positional parameters
  when an interactive shell is started.
  
--- 4569,4582 ----
  
  An interactive shell
! is one started without non-option arguments, unless @option{-s} is
! specified, without specifiying the @option{-c} option, and
  whose input and output are both
  connected to terminals (as determined by @code{isatty(3)}),
! or one started with the @option{-i} option.
  
  An interactive shell generally reads from and writes to a user's
  terminal.
  
! The @option{-s} invocation option may be used to set the positional parameters
  when an interactive shell is started.
  
***************
*** 4554,4558 ****
  
  Alternatively, startup scripts may examine the variable
! @code{$PS1}; it is unset in non-interactive shells, and set in
  interactive shells.  Thus:
  
--- 4597,4601 ----
  
  Alternatively, startup scripts may examine the variable
! @env{PS1}; it is unset in non-interactive shells, and set in
  interactive shells.  Thus:
  
***************
*** 4581,4591 ****
  
  @item
! Bash expands and displays @code{$PS1} before reading the first line
! of a command, and expands and displays @code{$PS2} before reading the
  second and subsequent lines of a multi-line command.
  
  @item
! Bash executes the value of the @code{PROMPT_COMMAND} variable as a command
! before printing the primary prompt, @code{$PS1}
  (@pxref{Bash Variables}).
  
--- 4624,4634 ----
  
  @item
! Bash expands and displays @env{PS1} before reading the first line
! of a command, and expands and displays @env{PS2} before reading the
  second and subsequent lines of a multi-line command.
  
  @item
! Bash executes the value of the @env{PROMPT_COMMAND} variable as a command
! before printing the primary prompt, @env{$PS1}
  (@pxref{Bash Variables}).
  
***************
*** 4603,4607 ****
  and history expansion (@pxref{History Interaction})
  are enabled by default.
! Bash will save the command history to the file named by @code{$HISTFILE}
  when an interactive shell exits.
  
--- 4646,4650 ----
  and history expansion (@pxref{History Interaction})
  are enabled by default.
! Bash will save the command history to the file named by @env{$HISTFILE}
  when an interactive shell exits.
  
***************
*** 4623,4632 ****
  
  @item
! The @samp{-n} invocation option is ignored, and @samp{set -n} has
  no effect (@pxref{The Set Builtin}).
  
  @item
  Bash will check for mail periodically, depending on the values of the
! @code{MAIL}, @code{MAILPATH}, and @code{MAILCHECK} shell variables
  (@pxref{Bash Variables}).
  
--- 4666,4675 ----
  
  @item
! The @option{-n} invocation option is ignored, and @samp{set -n} has
  no effect (@pxref{The Set Builtin}).
  
  @item
  Bash will check for mail periodically, depending on the values of the
! @env{MAIL}, @env{MAILPATH}, and @env{MAILCHECK} shell variables
  (@pxref{Bash Variables}).
  
***************
*** 4661,4667 ****
  
  @item
! The shell will check the value of the @code{TMOUT} variable and exit
  if a command is not read within the specified number of seconds after
! printing @code{$PS1} (@pxref{Bash Variables}).
  
  @end enumerate
--- 4704,4710 ----
  
  @item
! The shell will check the value of the @env{TMOUT} variable and exit
  if a command is not read within the specified number of seconds after
! printing @env{$PS1} (@pxref{Bash Variables}).
  
  @end enumerate
***************
*** 4760,4764 ****
  @item -o @var{optname}
  True if shell option @var{optname} is enabled.
! The list of options appears in the description of the @samp{-o}
  option to the @code{set} builtin (@pxref{The Set Builtin}).
  
--- 4803,4807 ----
  @item -o @var{optname}
  True if shell option @var{optname} is enabled.
! The list of options appears in the description of the @option{-o}
  option to the @code{set} builtin (@pxref{The Set Builtin}).
  
***************
*** 5011,5015 ****
  @code{$@{name[*]@}} expands to a single word with
  the value of each array member separated by the first character of the
! @code{IFS} variable, and @code{$@{name[@@]@}} expands each element of
  @var{name} to a separate word.  When there are no array members,
  @code{$@{name[@@]@}} expands to nothing.  This is analogous to the
--- 5054,5058 ----
  @code{$@{name[*]@}} expands to a single word with
  the value of each array member separated by the first character of the
! @env{IFS} variable, and @code{$@{name[@@]@}} expands each element of
  @var{name} to a separate word.  When there are no array members,
  @code{$@{name[@@]@}} expands to nothing.  This is analogous to the
***************
*** 5030,5036 ****
  
  The @code{declare}, @code{local}, and @code{readonly}
! builtins each accept a @samp{-a}
  option to specify an array.  The @code{read}
! builtin accepts a @samp{-a}
  option to assign a list of words read from the standard input
  to an array, and can read values from the standard input into
--- 5073,5079 ----
  
  The @code{declare}, @code{local}, and @code{readonly}
! builtins each accept a @option{-a}
  option to specify an array.  The @code{read}
! builtin accepts a @option{-a}
  option to assign a list of words read from the standard input
  to an array, and can read values from the standard input into
***************
*** 5056,5060 ****
  
  The contents of the directory stack are also visible
! as the value of the @code{DIRSTACK} shell variable.
  
  @node Directory Stack Builtins
--- 5099,5103 ----
  
  The contents of the directory stack are also visible
! as the value of the @env{DIRSTACK} shell variable.
  
  @node Directory Stack Builtins
***************
*** 5152,5157 ****
  @cindex prompting
  
! The value of the variable @code{PROMPT_COMMAND} is examined just before
! Bash prints each primary prompt.  If @code{PROMPT_COMMAND} is set and
  has a non-null value, then the
  value is executed just as if it had been typed on the command line.
--- 5195,5200 ----
  @cindex prompting
  
! The value of the variable @env{PROMPT_COMMAND} is examined just before
! Bash prints each primary prompt.  If @env{PROMPT_COMMAND} is set and
  has a non-null value, then the
  value is executed just as if it had been typed on the command line.
***************
*** 5197,5201 ****
  The current working directory.
  @item \W
! The basename of @code{$PWD}.
  @item \!
  The history number of this command.
--- 5240,5244 ----
  The current working directory.
  @item \W
! The basename of @env{$PWD}.
  @item \!
  The history number of this command.
***************
*** 5232,5236 ****
  
  If Bash is started with the name @code{rbash}, or the
! @samp{--restricted}
  option is supplied at invocation, the shell becomes restricted.
  A restricted shell is used to
--- 5275,5279 ----
  
  If Bash is started with the name @code{rbash}, or the
! @option{--restricted}
  option is supplied at invocation, the shell becomes restricted.
  A restricted shell is used to
***************
*** 5242,5247 ****
  Changing directories with the @code{cd} builtin.
  @item
! Setting or unsetting the values of the @code{SHELL}, @code{PATH},
! @code{ENV}, or @code{BASH_ENV} variables.
  @item
  Specifying command names containing slashes.
--- 5285,5290 ----
  Changing directories with the @code{cd} builtin.
  @item
! Setting or unsetting the values of the @env{SHELL}, @env{PATH},
! @env{ENV}, or @env{BASH_ENV} variables.
  @item
  Specifying command names containing slashes.
***************
*** 5250,5259 ****
  builtin command.
  @item
! Specifying a filename containing a slash as an argument to the @samp{-p}
  option to the @code{hash} builtin command.
  @item
  Importing function definitions from the shell environment at startup.
  @item
! Parsing the value of @code{SHELLOPTS} from the shell environment at startup.
  @item
  Redirecting output using the @samp{>}, @samp{>|}, @samp{<>}, @samp{>&},
--- 5293,5302 ----
  builtin command.
  @item
! Specifying a filename containing a slash as an argument to the @option{-p}
  option to the @code{hash} builtin command.
  @item
  Importing function definitions from the shell environment at startup.
  @item
! Parsing the value of @env{SHELLOPTS} from the shell environment at startup.
  @item
  Redirecting output using the @samp{>}, @samp{>|}, @samp{<>}, @samp{>&},
***************
*** 5263,5269 ****
  @item
  Adding or deleting builtin commands with the
! @samp{-f} and @samp{-d} options to the @code{enable} builtin.
  @item
! Specifying the @samp{-p} option to the @code{command} builtin.
  @item
  Turning off restricted mode with @samp{set +r} or @samp{set +o restricted}.
--- 5306,5312 ----
  @item
  Adding or deleting builtin commands with the
! @option{-f} and @option{-d} options to the @code{enable} builtin.
  @item
! Specifying the @option{-p} option to the @code{command} builtin.
  @item
  Turning off restricted mode with @samp{set +r} or @samp{set +o restricted}.
***************
*** 5274,5278 ****
  @cindex POSIX Mode
  
! Starting Bash with the @samp{--posix} command-line option or executing
  @samp{set -o posix} while Bash is running will cause Bash to conform more
  closely to the @sc{posix} 1003.2 standard by changing the behavior to
--- 5317,5321 ----
  @cindex POSIX Mode
  
! Starting Bash with the @option{--posix} command-line option or executing
  @samp{set -o posix} while Bash is running will cause Bash to conform more
  closely to the @sc{posix} 1003.2 standard by changing the behavior to
***************
*** 5284,5296 ****
  @item
  When a command in the hash table no longer exists, Bash will re-search
! @code{$PATH} to find the new location.  This is also available with
  @samp{shopt -s checkhash}.
  
  @item
! The @samp{>&} redirection does not redirect stdout and stderr.
  
  @item
  The message printed by the job control code and builtins when a job
! exits with a non-zero status is `Done(status)'.
  
  @item
--- 5327,5341 ----
  @item
  When a command in the hash table no longer exists, Bash will re-search
! @env{$PATH} to find the new location.  This is also available with
  @samp{shopt -s checkhash}.
  
  @item
! The message printed by the job control code and builtins when a job
! exits with a non-zero status is `Done(status)'.
  
  @item
  The message printed by the job control code and builtins when a job
! is stopped is `Stopped(@var{signame})', where @var{signame} is, for
! example, @code{SIGTSTP}.
  
  @item
***************
*** 5298,5305 ****
  
  @item
! The @sc{posix} 1003.2 @code{PS1} and @code{PS2} expansions of @samp{!} to
  the history number and @samp{!!} to @samp{!} are enabled,
! and parameter expansion is performed on the values of @code{PS1} and
! @code{PS2} regardless of the setting of the @code{promptvars} option.
  
  @item
--- 5343,5350 ----
  
  @item
! The @sc{posix} 1003.2 @env{PS1} and @env{PS2} expansions of @samp{!} to
  the history number and @samp{!!} to @samp{!} are enabled,
! and parameter expansion is performed on the values of @env{PS1} and
! @env{PS2} regardless of the setting of the @code{promptvars} option.
  
  @item
***************
*** 5308,5312 ****
  
  @item
! The @sc{posix} 1003.2 startup files are executed (@code{$ENV}) rather than
  the normal Bash files.
  
--- 5353,5357 ----
  
  @item
! The @sc{posix} 1003.2 startup files are executed (@env{$ENV}) rather than
  the normal Bash files.
  
***************
*** 5317,5321 ****
  @item
  The default history file is @file{~/.sh_history} (this is the
! default value of @code{$HISTFILE}).
  
  @item
--- 5362,5366 ----
  @item
  The default history file is @file{~/.sh_history} (this is the
! default value of @env{$HISTFILE}).
  
  @item
***************
*** 5358,5370 ****
  @item
  If the @code{cd} builtin finds a directory to change to
! using @code{$CDPATH}, the
! value it assigns to the @code{PWD} variable does not contain any
  symbolic links, as if @samp{cd -P} had been executed.
  
  @item
! If @code{$CDPATH} is set, the @code{cd} builtin will not implicitly
  append the current directory to it.  This means that @code{cd} will
  fail if no valid directory name can be constructed from
! any of the entries in @code{$CDPATH}, even if the a directory with
  the same name as the name given as an argument to @code{cd} exists
  in the current directory.
--- 5403,5415 ----
  @item
  If the @code{cd} builtin finds a directory to change to
! using @env{$CDPATH}, the
! value it assigns to the @env{PWD} variable does not contain any
  symbolic links, as if @samp{cd -P} had been executed.
  
  @item
! If @env{CDPATH} is set, the @code{cd} builtin will not implicitly
  append the current directory to it.  This means that @code{cd} will
  fail if no valid directory name can be constructed from
! any of the entries in @env{$CDPATH}, even if the a directory with
  the same name as the name given as an argument to @code{cd} exists
  in the current directory.
***************
*** 5390,5396 ****
--- 5435,5466 ----
  
  @item
+ Assignment statements preceding shell function calls persist in the
+ shell environment after the function returns, as if a @sc{posix}
+ special builtin command had been executed.
+ 
+ @item
  The @code{export} and @code{readonly} builtin commands display their
  output in the format required by @sc{posix} 1003.2.
  
+ @item
+ The @code{trap} builtin displays signal names without the leading
+ @code{SIG}.
+ 
+ @item
+ The @code{.} and @code{source} builtins do not search the current directory
+ for the filename argument if it is not found by searching @env{PATH}.
+ 
+ @item
+ Subshells spawned to execute command substitutions inherit the value of
+ the @option{-e} option from the parent shell.  When not in @sc{posix} mode,
+ Bash clears the @option{-e} option in such subshells.
+ 
+ @item
+ Alias expansion is always enabled, even in non-interactive shells.
+ 
+ @item
+ When the @code{set} builtin is invoked without options, it does not display
+ shell function names and definitions.
+ 
  @end enumerate
  
***************
*** 5402,5405 ****
--- 5472,5487 ----
  Assignment statements affect the execution environment of all
  builtins, not just special ones.
+ 
+ @item
+ When a subshell is created to execute a shell script with execute permission,
+ but without a leading @samp{#!}, Bash sets @code{$0} to the full pathname of
+ the script as found by searching @code{$PATH}, rather than the command as
+ typed by the user.
+ 
+ @item
+ When using @samp{.} to source a shell script found in @code{$PATH}, bash
+ checks execute permission bits rather than read permission bits, just as
+ if it were searching for a command.
+ 
  @end enumerate
  
***************
*** 5505,5509 ****
  before reporting changes in a job's status so as to not interrupt
  any other output.  If the 
! the @samp{-b} option to the @code{set} builtin is enabled,
  Bash reports such changes immediately (@pxref{The Set Builtin}).
  
--- 5587,5591 ----
  before reporting changes in a job's status so as to not interrupt
  any other output.  If the 
! the @option{-b} option to the @code{set} builtin is enabled,
  Bash reports such changes immediately (@pxref{The Set Builtin}).
  
***************
*** 5577,5581 ****
  listed.
  
! If the @samp{-x} option is supplied, @code{jobs} replaces any
  @var{jobspec} found in @var{command} or @var{arguments} with the
  corresponding process group @sc{id}, and executes @var{command},
--- 5659,5663 ----
  listed.
  
! If the @option{-x} option is supplied, @code{jobs} replaces any
  @var{jobspec} found in @var{command} or @var{arguments} with the
  corresponding process group @sc{id}, and executes @var{command},
***************
*** 5593,5598 ****
  the @code{SIG} prefix) or a signal number; @var{signum} is a signal number.
  If @var{sigspec} and @var{signum} are not present, @code{SIGTERM} is used.
! The @samp{-l} option lists the signal names.
! If any arguments are supplied when @samp{-l} is given, the names of the
  signals corresponding to the arguments are listed, and the return status
  is zero.
--- 5675,5680 ----
  the @code{SIG} prefix) or a signal number; @var{signum} is a signal number.
  If @var{sigspec} and @var{signum} are not present, @code{SIGTERM} is used.
! The @option{-l} option lists the signal names.
! If any arguments are supplied when @option{-l} is given, the names of the
  signals corresponding to the arguments are listed, and the return status
  is zero.
***************
*** 5623,5633 ****
  Without options, each @var{jobspec} is removed from the table of
  active jobs.
! If the @samp{-h} option is given, the job is not removed from the table,
  but is marked so that @code{SIGHUP} is not sent to the job if the shell
  receives a @code{SIGHUP}.
! If @var{jobspec} is not present, and neither the @samp{-a} nor @samp{-r}
  option is supplied, the current job is used.
! If no @var{jobspec} is supplied, the @samp{-a} option means to remove or
! mark all jobs; the @samp{-r} option without a @var{jobspec}
  argument restricts operation to running jobs.
  
--- 5705,5715 ----
  Without options, each @var{jobspec} is removed from the table of
  active jobs.
! If the @option{-h} option is given, the job is not removed from the table,
  but is marked so that @code{SIGHUP} is not sent to the job if the shell
  receives a @code{SIGHUP}.
! If @var{jobspec} is not present, and neither the @option{-a} nor @option{-r}
  option is supplied, the current job is used.
! If no @var{jobspec} is supplied, the @option{-a} option means to remove or
! mark all jobs; the @option{-r} option without a @var{jobspec}
  argument restricts operation to running jobs.
  
***************
*** 5638,5642 ****
  @end example
  Suspend the execution of this shell until it receives a
! @code{SIGCONT} signal.  The @samp{-f} option means to suspend
  even if the shell is a login shell.
  
--- 5720,5724 ----
  @end example
  Suspend the execution of this shell until it receives a
! @code{SIGCONT} signal.  The @option{-f} option means to suspend
  even if the shell is a login shell.
  
***************
*** 5835,5839 ****
  directory where you want the object files and executables to go and run
  the @code{configure} script from the source directory.  You may need to
! supply the @samp{--srcdir=PATH} argument to tell @code{configure} where the
  source files are.  @code{configure} automatically checks for the
  source code in the directory that @code{configure} is in and in `..'.
--- 5917,5921 ----
  directory where you want the object files and executables to go and run
  the @code{configure} script from the source directory.  You may need to
! supply the @option{--srcdir=PATH} argument to tell @code{configure} where the
  source files are.  @code{configure} automatically checks for the
  source code in the directory that @code{configure} is in and in `..'.
***************
*** 5866,5875 ****
  @file{/usr/local/bin}, @file{/usr/local/man}, etc.  You can
  specify an installation prefix other than @file{/usr/local} by
! giving @code{configure} the option @samp{--prefix=@var{PATH}}. 
  
  You can specify separate installation prefixes for
  architecture-specific files and architecture-independent files. 
  If you give @code{configure} the option
! @samp{--exec-prefix=@var{PATH}}, @samp{make install} will use
  @var{PATH} as the prefix for installing programs and libraries.
  Documentation and other data files will still use the regular prefix. 
--- 5948,5957 ----
  @file{/usr/local/bin}, @file{/usr/local/man}, etc.  You can
  specify an installation prefix other than @file{/usr/local} by
! giving @code{configure} the option @option{--prefix=@var{PATH}}. 
  
  You can specify separate installation prefixes for
  architecture-specific files and architecture-independent files. 
  If you give @code{configure} the option
! @option{--exec-prefix=@var{PATH}}, @samp{make install} will use
  @var{PATH} as the prefix for installing programs and libraries.
  Documentation and other data files will still use the regular prefix. 
***************
*** 5882,5886 ****
  will run on.  Usually @code{configure} can figure that
  out, but if it prints a message saying it can not guess the host
! type, give it the @samp{--host=TYPE} option.  @samp{TYPE} can
  either be a short name for the system type, such as @samp{sun4},
  or a canonical name with three fields: @samp{CPU-COMPANY-SYSTEM}
--- 5964,5968 ----
  will run on.  Usually @code{configure} can figure that
  out, but if it prints a message saying it can not guess the host
! type, give it the @option{--host=TYPE} option.  @samp{TYPE} can
  either be a short name for the system type, such as @samp{sun4},
  or a canonical name with three fields: @samp{CPU-COMPANY-SYSTEM}
***************
*** 5940,5953 ****
  @section Optional Features
  
! The Bash @code{configure} has a number of @samp{--enable-@var{feature}}
  options, where @var{feature} indicates an optional part of Bash.
! There are also several @samp{--with-@var{package}} options,
  where @var{package} is something like @samp{bash-malloc} or @samp{purify}.
  To turn off the default use of a package, use
! @samp{--without-@var{package}}.  To configure Bash without a feature
! that is enabled by default, use @samp{--disable-@var{feature}}.
  
! Here is a complete list of the @samp{--enable-} and
! @samp{--with-} options that the Bash @code{configure} recognizes. 
  
  @table @code
--- 6022,6035 ----
  @section Optional Features
  
! The Bash @code{configure} has a number of @option{--enable-@var{feature}}
  options, where @var{feature} indicates an optional part of Bash.
! There are also several @option{--with-@var{package}} options,
  where @var{package} is something like @samp{bash-malloc} or @samp{purify}.
  To turn off the default use of a package, use
! @option{--without-@var{package}}.  To configure Bash without a feature
! that is enabled by default, use @option{--disable-@var{feature}}.
  
! Here is a complete list of the @option{--enable-} and
! @option{--with-} options that the Bash @code{configure} recognizes. 
  
  @table @code
***************
*** 5997,6001 ****
  @end table
  
! There are several @samp{--enable-} options that alter how Bash is
  compiled and linked, rather than changing run-time features.
  
--- 6079,6083 ----
  @end table
  
! There are several @option{--enable-} options that alter how Bash is
  compiled and linked, rather than changing run-time features.
  
***************
*** 6095,6099 ****
  @item --enable-prompt-string-decoding
  Turn on the interpretation of a number of backslash-escaped characters
! in the @code{$PS1}, @code{$PS2}, @code{$PS3}, and @code{$PS4} prompt
  strings.  See @ref{Printing a Prompt}, for a complete list of prompt
  string escape sequences.
--- 6177,6181 ----
  @item --enable-prompt-string-decoding
  Turn on the interpretation of a number of backslash-escaped characters
! in the @env{$PS1}, @env{$PS2}, @env{$PS3}, and @env{$PS4} prompt
  strings.  See @ref{Printing a Prompt}, for a complete list of prompt
  string escape sequences.
***************
*** 6122,6126 ****
  @item --enable-xpg-echo-default
  Make the @code{echo} builtin expand backslash-escaped characters by default,
! without requiring the @samp{-e} option.
  This sets the default value of the @code{xpg_echo} shell option to @code{on},
  which makes the Bash @code{echo} behave more like the version specified in
--- 6204,6208 ----
  @item --enable-xpg-echo-default
  Make the @code{echo} builtin expand backslash-escaped characters by default,
! without requiring the @option{-e} option.
  This sets the default value of the @code{xpg_echo} shell option to @code{on},
  which makes the Bash @code{echo} behave more like the version specified in
***************
*** 6187,6191 ****
  number of these differences are explained in greater depth in
  previous sections.
! This section uses the version of @code{sh} included SVR4.2 as
  the baseline reference.
  
--- 6269,6273 ----
  number of these differences are explained in greater depth in
  previous sections.
! This section uses the version of @code{sh} included in SVR4.2 as
  the baseline reference.
  
***************
*** 6194,6198 ****
  @item
  Bash is @sc{posix}-conformant, even where the @sc{posix} specification
! differs from traditional @code{sh} behavior.
  
  @item
--- 6276,6280 ----
  @item
  Bash is @sc{posix}-conformant, even where the @sc{posix} specification
! differs from traditional @code{sh} behavior (@pxref{Bash POSIX Mode}).
  
  @item
***************
*** 6230,6234 ****
  Bash supports the @code{$"@dots{}"} quoting syntax to do
  locale-specific translation of the characters between the double
! quotes.  The @samp{-D}, @samp{--dump-strings}, and @samp{--dump-po-strings}
  invocation options list the translatable strings found in a script
  (@pxref{Locale Translation}).
--- 6312,6316 ----
  Bash supports the @code{$"@dots{}"} quoting syntax to do
  locale-specific translation of the characters between the double
! quotes.  The @option{-D}, @option{--dump-strings}, and @option{--dump-po-strings}
  invocation options list the translatable strings found in a script
  (@pxref{Locale Translation}).
***************
*** 6242,6246 ****
  Bash has the @code{time} reserved word and command timing (@pxref{Pipelines}).
  The display of the timing statistics may be controlled with the
! @code{TIMEFORMAT} variable.
  
  @item
--- 6324,6328 ----
  Bash has the @code{time} reserved word and command timing (@pxref{Pipelines}).
  The display of the timing statistics may be controlled with the
! @env{TIMEFORMAT} variable.
  
  @item
***************
*** 6320,6331 ****
  @item
  Bash automatically assigns variables that provide information about the
! current user (@code{UID}, @code{EUID}, and @code{GROUPS}), the current host
! (@code{HOSTTYPE}, @code{OSTYPE}, @code{MACHTYPE}, and @code{HOSTNAME}),
! and the instance of Bash that is running (@code{BASH},
! @code{BASH_VERSION}, and @code{BASH_VERSINFO}).  @xref{Bash Variables},
  for details.
  
  @item
! The @code{IFS} variable is used to split only the results of expansion,
  not all words (@pxref{Word Splitting}).
  This closes a longstanding shell security hole.
--- 6402,6413 ----
  @item
  Bash automatically assigns variables that provide information about the
! current user (@env{UID}, @env{EUID}, and @env{GROUPS}), the current host
! (@env{HOSTTYPE}, @env{OSTYPE}, @env{MACHTYPE}, and @env{HOSTNAME}),
! and the instance of Bash that is running (@env{BASH},
! @env{BASH_VERSION}, and @env{BASH_VERSINFO}).  @xref{Bash Variables},
  for details.
  
  @item
! The @env{IFS} variable is used to split only the results of expansion,
  not all words (@pxref{Word Splitting}).
  This closes a longstanding shell security hole.
***************
*** 6381,6385 ****
  @item
  The Bash @code{cd} and @code{pwd} builtins (@pxref{Bourne Shell Builtins})
! each take @samp{-L} and @samp{-P} builtins to switch between logical and
  physical modes.
  
--- 6463,6467 ----
  @item
  The Bash @code{cd} and @code{pwd} builtins (@pxref{Bourne Shell Builtins})
! each take @option{-L} and @option{-P} options to switch between logical and
  physical modes.
  
***************
*** 6409,6415 ****
  @item
  The Bash @code{export}, @code{readonly}, and @code{declare} builtins can
! take a @samp{-f} option to act on shell functions, a @samp{-p} option to
  display variables with various attributes set in a format that can be
! used as shell input, a @samp{-n} option to remove various variable
  attributes, and @samp{name=value} arguments to set variable attributes
  and values simultaneously.
--- 6491,6497 ----
  @item
  The Bash @code{export}, @code{readonly}, and @code{declare} builtins can
! take a @option{-f} option to act on shell functions, a @option{-p} option to
  display variables with various attributes set in a format that can be
! used as shell input, a @option{-n} option to remove various variable
  attributes, and @samp{name=value} arguments to set variable attributes
  and values simultaneously.
***************
*** 6418,6422 ****
  The Bash @code{hash} builtin allows a name to be associated with
  an arbitrary filename, even when that filename cannot be found by
! searching the @code{$PATH}, using @samp{hash -p}
  (@pxref{Bourne Shell Builtins}).
  
--- 6500,6504 ----
  The Bash @code{hash} builtin allows a name to be associated with
  an arbitrary filename, even when that filename cannot be found by
! searching the @env{$PATH}, using @samp{hash -p}
  (@pxref{Bourne Shell Builtins}).
  
***************
*** 6432,6446 ****
  The Bash @code{read} builtin (@pxref{Bash Builtins})
  will read a line ending in @samp{\} with
! the @samp{-r} option, and will use the @code{REPLY} variable as a
  default if no non-option arguments are supplied.
  The Bash @code{read} builtin
! also accepts a prompt string with the @samp{-p} option and will use
! Readline to obtain the line when given the @samp{-e} option.
  The @code{read} builtin also has additional options to control input:
! the @samp{-s} option will turn off echoing of input characters as
! they are read, the @samp{-t} option will allow @code{read} to time out
  if input does not arrive within a specified number of seconds, the
! @samp{-n} option will allow reading only a specified number of
! characters rather than a full line, and the @samp{-d} option will read
  until a particular character rather than newline.
  
--- 6514,6528 ----
  The Bash @code{read} builtin (@pxref{Bash Builtins})
  will read a line ending in @samp{\} with
! the @option{-r} option, and will use the @env{REPLY} variable as a
  default if no non-option arguments are supplied.
  The Bash @code{read} builtin
! also accepts a prompt string with the @option{-p} option and will use
! Readline to obtain the line when given the @option{-e} option.
  The @code{read} builtin also has additional options to control input:
! the @option{-s} option will turn off echoing of input characters as
! they are read, the @option{-t} option will allow @code{read} to time out
  if input does not arrive within a specified number of seconds, the
! @option{-n} option will allow reading only a specified number of
! characters rather than a full line, and the @option{-d} option will read
  until a particular character rather than newline.
  
***************
*** 6475,6479 ****
  
  @item
! The Bash @code{umask} builtin permits a @samp{-p} option to cause
  the output to be displayed in the form of a @code{umask} command
  that may be reused as input (@pxref{Bourne Shell Builtins}).
--- 6557,6561 ----
  
  @item
! The Bash @code{umask} builtin permits a @option{-p} option to cause
  the output to be displayed in the form of a @code{umask} command
  that may be reused as input (@pxref{Bourne Shell Builtins}).
***************
*** 6484,6488 ****
  (@pxref{The Directory Stack}).
  Bash also makes the directory stack visible as the value of the
! @code{DIRSTACK} shell variable.
  
  @item
--- 6566,6570 ----
  (@pxref{The Directory Stack}).
  Bash also makes the directory stack visible as the value of the
! @env{DIRSTACK} shell variable.
  
  @item
***************
*** 6508,6516 ****
  
  @item
! Bash does not use the @code{SHACCT} variable or perform shell accounting.
  
  @item
! The SVR4.2 @code{sh} uses a @code{TIMEOUT} variable like Bash uses
! @code{TMOUT}.
  
  @end itemize
--- 6590,6598 ----
  
  @item
! Bash does not use the @env{SHACCT} variable or perform shell accounting.
  
  @item
! The SVR4.2 @code{sh} uses a @env{TIMEOUT} variable like Bash uses
! @env{TMOUT}.
  
  @end itemize
***************
*** 6545,6549 ****
  @item
  In a questionable attempt at security, the SVR4.2 shell,
! when invoked without the @samp{-p} option, will alter its real
  and effective @sc{uid} and @sc{gid} if they are less than some
  magic threshold value, commonly 100.
--- 6627,6631 ----
  @item
  In a questionable attempt at security, the SVR4.2 shell,
! when invoked without the @option{-p} option, will alter its real
  and effective @sc{uid} and @sc{gid} if they are less than some
  magic threshold value, commonly 100.
***************
*** 6555,6560 ****
  
  @item
! The SVR4.2 shell does not allow the @code{IFS}, @code{MAILCHECK},
! @code{PATH}, @code{PS1}, or @code{PS2} variables to be unset.
  
  @item
--- 6637,6642 ----
  
  @item
! The SVR4.2 shell does not allow the @env{IFS}, @env{MAILCHECK},
! @env{PATH}, @env{PS1}, or @env{PS2} variables to be unset.
  
  @item
diff -Nrc2 bash-2.04/doc/readline.3 bash-2.05/doc/readline.3
*** bash-2.04/doc/readline.3	Fri Aug  6 15:43:04 1999
--- bash-2.05/doc/readline.3	Wed Dec 31 19:00:00 1969
***************
*** 1,1205 ****
- .\"
- .\" MAN PAGE COMMENTS to
- .\"
- .\"	Chet Ramey
- .\"	Information Network Services
- .\"	Case Western Reserve University
- .\"	chet@ins.CWRU.Edu
- .\"
- .\"	Last Change: Tue Jun  1 13:28:03 EDT 1999
- .\"
- .TH READLINE 3 "1999 Jun 1" GNU
- .\"
- .\" File Name macro.  This used to be `.PN', for Path Name,
- .\" but Sun doesn't seem to like that very much.
- .\"
- .de FN
- \fI\|\\$1\|\fP
- ..
- .SH NAME
- readline \- get a line from a user with editing
- .SH SYNOPSIS
- .LP
- .nf
- .ft B
- #include <stdio.h>
- #include <readline.h>
- #include <history.h>
- .ft
- .fi
- .LP
- .nf
- .ft B
- char *readline (prompt)
- char *prompt;
- .ft
- .fi
- .SH COPYRIGHT
- .if n Readline is Copyright (C) 1989, 1991, 1993, 1995, 1996 by the Free Software Foundation, Inc.
- .if t Readline is Copyright \(co 1989, 1991, 1993, 1995, 1996 by the Free Software Foundation, Inc.
- .SH DESCRIPTION
- .LP
- .B readline
- will read a line from the terminal
- and return it, using
- .B prompt
- as a prompt.  If 
- .B prompt
- is null, no prompt is issued.  The line returned is allocated with
- .IR malloc (3),
- so the caller must free it when finished.  The line returned
- has the final newline removed, so only the text of the line
- remains.
- .LP
- .B readline
- offers editing capabilities while the user is entering the
- line.
- By default, the line editing commands
- are similar to those of emacs.
- A vi\-style line editing interface is also available.
- .SH RETURN VALUE
- .LP
- .B readline
- returns the text of the line read.  A blank line
- returns the empty string.  If
- .B EOF
- is encountered while reading a line, and the line is empty,
- .B NULL
- is returned.  If an
- .B EOF
- is read with a non\-empty line, it is
- treated as a newline.
- .SH NOTATION
- .LP
- An emacs-style notation is used to denote
- keystrokes.  Control keys are denoted by C\-\fIkey\fR, e.g., C\-n
- means Control\-N.  Similarly, 
- .I meta
- keys are denoted by M\-\fIkey\fR, so M\-x means Meta\-X.  (On keyboards
- without a 
- .I meta
- key, M\-\fIx\fP means ESC \fIx\fP, i.e., press the Escape key
- then the
- .I x
- key.  This makes ESC the \fImeta prefix\fP.
- The combination M\-C\-\fIx\fP means ESC\-Control\-\fIx\fP,
- or press the Escape key
- then hold the Control key while pressing the
- .I x
- key.)
- .PP
- Readline commands may be given numeric
- .IR arguments ,
- which normally act as a repeat count.  Sometimes, however, it is the
- sign of the argument that is significant.  Passing a negative argument
- to a command that acts in the forward direction (e.g., \fBkill\-line\fP)
- causes that command to act in a backward direction.  Commands whose
- behavior with arguments deviates from this are noted.
- .PP
- When a command is described as \fIkilling\fP text, the text
- deleted is saved for possible future retrieval
- (\fIyanking\fP).  The killed text is saved in a
- \fIkill ring\fP.  Consecutive kills cause the text to be
- accumulated into one unit, which can be yanked all at once. 
- Commands which do not kill text separate the chunks of text
- on the kill ring.
- .SH INITIALIZATION FILE
- .LP
- Readline is customized by putting commands in an initialization
- file (the \fIinputrc\fP file).
- The name of this file is taken from the value of the
- .B INPUTRC
- environment variable.  If that variable is unset, the default is
- .IR ~/.inputrc .
- When a program which uses the readline library starts up, the
- init file is read, and the key bindings and variables are set.
- There are only a few basic constructs allowed in the
- readline init file.  Blank lines are ignored.
- Lines beginning with a \fB#\fP are comments.
- Lines beginning with a \fB$\fP indicate conditional constructs.
- Other lines denote key bindings and variable settings.
- Each program using this library may add its own commands
- and bindings.
- .PP
- For example, placing
- .RS
- .PP
- M\-Control\-u: universal\-argument
- .RE
- or
- .RS
- C\-Meta\-u: universal\-argument
- .RE
- into the 
- .I inputrc
- would make M\-C\-u execute the readline command
- .IR universal\-argument .
- .PP
- The following symbolic character names are recognized while
- processing key bindings:
- .IR RUBOUT ,
- .IR DEL ,
- .IR ESC ,
- .IR LFD ,
- .IR NEWLINE ,
- .IR RET ,
- .IR RETURN ,
- .IR SPC ,
- .IR SPACE ,
- and
- .IR TAB .
- .PP
- In addition to command names, readline allows keys to be bound
- to a string that is inserted when the key is pressed (a \fImacro\fP).
- .PP
- .SS Key Bindings
- .PP
- The syntax for controlling key bindings in the
- .I inputrc
- file is simple.  All that is required is the name of the
- command or the text of a macro and a key sequence to which
- it should be bound. The name may be specified in one of two ways:
- as a symbolic key name, possibly with \fIMeta\-\fP or \fIControl\-\fP
- prefixes, or as a key sequence.
- When using the form \fBkeyname\fP:\^\fIfunction-name\fP or \fImacro\fP,
- .I keyname
- is the name of a key spelled out in English.  For example:
- .sp
- .RS
- Control\-u: universal\-argument
- .br
- Meta\-Rubout: backward\-kill\-word
- .br
- Control\-o: ">&output"
- .RE
- .LP
- In the above example,
- .I C\-u
- is bound to the function
- .BR universal\-argument ,
- .I M-DEL
- is bound to the function
- .BR backward\-kill\-word ,
- and
- .I C\-o
- is bound to run the macro
- expressed on the right hand side (that is, to insert the text
- .I >&output
- into the line).
- .PP
- In the second form, \fB"keyseq"\fP:\^\fIfunction\-name\fP or \fImacro\fP,
- .B keyseq
- differs from
- .B keyname
- above in that strings denoting
- an entire key sequence may be specified by placing the sequence
- within double quotes.  Some GNU Emacs style key escapes can be
- used, as in the following example.
- .sp
- .RS
- "\eC\-u": universal\-argument
- .br
- "\eC\-x\eC\-r": re\-read\-init\-file
- .br
- "\ee[11~": "Function Key 1"
- .RE
- .PP
- In this example,
- .I C-u
- is again bound to the function
- .BR universal\-argument .
- .I "C-x C-r"
- is bound to the function
- .BR re\-read\-init\-file ,
- and 
- .I "ESC [ 1 1 ~"
- is bound to insert the text
- .BR "Function Key 1" .
- The full set of GNU Emacs style escape sequences is
- .RS
- .PD 0
- .TP
- .B \eC\-
- control prefix
- .TP
- .B \eM\-
- meta prefix
- .TP
- .B \ee
- an escape character
- .TP
- .B \e\e
- backslash
- .TP
- .B \e"
- literal "
- .TP
- .B \e'
- literal '
- .RE
- .PD
- .PP
- In addition to the GNU Emacs style escape sequences, a second
- set of backslash escapes is available:
- .RS
- .PD 0
- .TP
- .B \ea
- alert (bell)
- .TP
- .B \eb
- backspace
- .TP
- .B \ed
- delete
- .TP
- .B \ef
- form feed
- .TP
- .B \en
- newline
- .TP
- .B \er
- carriage return
- .TP
- .B \et
- horizontal tab
- .TP
- .B \ev
- vertical tab
- .TP
- .B \e\fInnn\fP
- the character whose ASCII code is the octal value \fInnn\fP
- (one to three digits)
- .TP
- .B \ex\fInnn\fP
- the character whose ASCII code is the hexadecimal value \fInnn\fP
- (one to three digits)
- .RE
- .PD
- .PP
- When entering the text of a macro, single or double quotes should
- be used to indicate a macro definition.  Unquoted text
- is assumed to be a function name.
- In the macro body, the backslash escapes described above are expanded.
- Backslash will quote any other character in the macro text,
- including " and '.
- .PP
- .B Bash
- allows the current readline key bindings to be displayed or modified
- with the
- .B bind
- builtin command.  The editing mode may be switched during interactive
- use by using the
- .B \-o
- option to the
- .B set
- builtin command.  Other programs using this library provide
- similar mechanisms.  The
- .I inputrc
- file may be edited and re-read if a program does not provide
- any other means to incorporate new bindings.
- .SS Variables
- .PP
- Readline has variables that can be used to further customize its
- behavior.  A variable may be set in the
- .I inputrc
- file with a statement of the form
- .RS
- .PP
- \fBset\fP \fIvariable\-name\fP \fIvalue\fP
- .RE
- .PP
- Except where noted, readline variables can take the values
- .B On
- or
- .BR Off .
- The variables and their default values are:
- .PP
- .PD 0
- .TP
- .B bell\-style (audible)
- Controls what happens when readline wants to ring the terminal bell.
- If set to \fBnone\fP, readline never rings the bell.  If set to
- \fBvisible\fP, readline uses a visible bell if one is available.
- If set to \fBaudible\fP, readline attempts to ring the terminal's bell.
- .TP
- .B comment\-begin (``#'')
- The string that is inserted in \fBvi\fP mode when the
- .B insert\-comment
- command is executed.
- This command is bound to
- .B M\-#
- in emacs mode and to
- .B #
- in vi command mode.
- .TP 
- .B completion\-ignore\-case (Off)
- If set to \fBOn\fP, readline performs filename matching and completion
- in a case\-insensitive fashion.
- .TP
- .B completion\-query\-items (100)
- This determines when the user is queried about viewing
- the number of possible completions
- generated by the \fBpossible\-completions\fP command.
- It may be set to any integer value greater than or equal to
- zero.  If the number of possible completions is greater than
- or equal to the value of this variable, the user is asked whether
- or not he wishes to view them; otherwise they are simply listed
- on the terminal.
- .TP
- .B convert\-meta (On)
- If set to \fBOn\fP, readline will convert characters with the
- eighth bit set to an ASCII key sequence
- by stripping the eighth bit and prepending an
- escape character (in effect, using escape as the \fImeta prefix\fP).
- .TP
- .B disable\-completion (Off)
- If set to \fBOn\fP, readline will inhibit word completion.  Completion 
- characters will be inserted into the line as if they had been
- mapped to \fBself-insert\fP.
- .TP
- .B editing\-mode (emacs)
- Controls whether readline begins with a set of key bindings similar
- to \fIemacs\fP or \fIvi\fP.
- .B editing\-mode
- can be set to either
- .B emacs
- or
- .BR vi .
- .TP
- .B enable\-keypad (Off)
- When set to \fBOn\fP, readline will try to enable the application
- keypad when it is called.  Some systems need this to enable the
- arrow keys.
- .TP
- .B expand\-tilde (Off)
- If set to \fBon\fP, tilde expansion is performed when readline
- attempts word completion.
- .TP
- .B horizontal\-scroll\-mode (Off)
- When set to \fBOn\fP, makes readline use a single line for display,
- scrolling the input horizontally on a single screen line when it
- becomes longer than the screen width rather than wrapping to a new line.
- .TP
- .B input\-meta (Off)
- If set to \fBOn\fP, readline will enable eight-bit input (that is,
- it will not strip the high bit from the characters it reads),
- regardless of what the terminal claims it can support.  The name
- .B meta\-flag
- is a synonym for this variable.
- .TP
- .B isearch\-terminators (``C\-[C\-J'')
- The string of characters that should terminate an incremental
- search without subsequently executing the character as a command.
- If this variable has not been given a value, the characters
- \fIESC\fP and \fIC\-J\fP will terminate an incremental search.
- .TP
- .B keymap (emacs)
- Set the current readline keymap.  The set of legal keymap names is
- \fIemacs, emacs-standard, emacs-meta, emacs-ctlx, vi, vi-move,
- vi-command\fP, and
- .IR vi-insert .
- \fIvi\fP is equivalent to \fIvi-command\fP; \fIemacs\fP is
- equivalent to \fIemacs-standard\fP.  The default value is
- .IR emacs ;
- the value of
- .B editing\-mode
- also affects the default keymap.
- .TP
- .B mark\-directories (On)
- If set to \fBOn\fP, complete<d directory names have a slash
- appended.
- .TP
- .B mark\-modified\-lines (Off)
- If set to \fBOn\fP, history lines that have been modified are displayed
- with a preceding asterisk (\fB*\fP).
- .TP
- .B output\-meta (Off)
- If set to \fBOn\fP, readline will display characters with the
- eighth bit set directly rather than as a meta-prefixed escape
- sequence.
- .TP
- .B print\-completions\-horizontally (Off)
- If set to \fBOn\fP, readline will display completions with matches
- sorted horizontally in alphabetical order, rather than down the screen.
- .TP
- .B show\-all\-if\-ambiguous (Off)
- This alters the default behavior of the completion functions.  If
- set to
- .BR on ,
- words which have more than one possible completion cause the
- matches to be listed immediately instead of ringing the bell.
- .TP
- .B visible\-stats (Off)
- If set to \fBOn\fP, a character denoting a file's type as reported  
- by \fBstat\fP(2) is appended to the filename when listing possible
- completions.
- .PD
- .SS Conditional Constructs
- .PP
- Readline implements a facility similar in spirit to the conditional
- compilation features of the C preprocessor which allows key
- bindings and variable settings to be performed as the result
- of tests.  There are four parser directives used.
- .IP \fB$if\fP
- The 
- .B $if
- construct allows bindings to be made based on the
- editing mode, the terminal being used, or the application using
- readline.  The text of the test extends to the end of the line;
- no characters are required to isolate it.
- .RS
- .IP \fBmode\fP
- The \fBmode=\fP form of the \fB$if\fP directive is used to test
- whether readline is in emacs or vi mode.
- This may be used in conjunction
- with the \fBset keymap\fP command, for instance, to set bindings in
- the \fIemacs-standard\fP and \fIemacs-ctlx\fP keymaps only if
- readline is starting out in emacs mode.
- .IP \fBterm\fP
- The \fBterm=\fP form may be used to include terminal-specific
- key bindings, perhaps to bind the key sequences output by the
- terminal's function keys.  The word on the right side of the
- .B =
- is tested against the full name of the terminal and the portion
- of the terminal name before the first \fB\-\fP.  This allows
- .I sun
- to match both
- .I sun
- and
- .IR sun\-cmd ,
- for instance.
- .IP \fBapplication\fP
- The \fBapplication\fP construct is used to include
- application-specific settings.  Each program using the readline
- library sets the \fIapplication name\fP, and an initialization
- file can test for a particular value.
- This could be used to bind key sequences to functions useful for
- a specific program.  For instance, the following command adds a
- key sequence that quotes the current or previous word in Bash:
- .sp 1
- .RS
- .nf
- \fB$if\fP bash
- # Quote the current or previous word
- "\eC-xq": "\eeb\e"\eef\e""
- \fB$endif\fP
- .fi
- .RE
- .RE
- .IP \fB$endif\fP
- This command, as seen in the previous example, terminates an
- \fB$if\fP command.
- .IP \fB$else\fP
- Commands in this branch of the \fB$if\fP directive are executed if
- the test fails.
- .IP \fB$include\fP
- This directive takes a single filename as an argument and reads commands
- and bindings from that file.  For example, the following directive
- would read \fI/etc/inputrc\fP:
- .sp 1
- .RS
- .nf
- \fB$include\fP \^ \fI/etc/inputrc\fP
- .fi 
- .RE
- .SH SEARCHING
- .PP
- Readline provides commands for searching through the command history
- for lines containing a specified string.
- There are two search modes:
- .I incremental
- and
- .IR non-incremental .
- .PP
- Incremental searches begin before the user has finished typing the
- search string.
- As each character of the search string is typed, readline displays
- the next entry from the history matching the string typed so far.
- An incremental search requires only as many characters as needed to
- find the desired history entry.
- The characters present in the value of the \fIisearch-terminators\fP
- variable are used to terminate an incremental search.
- If that variable has not been assigned a value the Escape and
- Control-J characters will terminate an incremental search.
- Control-G will abort an incremental search and restore the original
- line.
- When the search is terminated, the history entry containing the
- search string becomes the current line.
- To find other matching entries in the history list, type Control-S or
- Control-R as appropriate.
- This will search backward or forward in the history for the next
- line matching the search string typed so far.
- Any other key sequence bound to a readline command will terminate
- the search and execute that command.
- For instance, a \fInewline\fP will terminate the search and accept
- the line, thereby executing the command from the history list.
- .PP
- Non-incremental searches read the entire search string before starting
- to search for matching history lines.  The search string may be
- typed by the user or be part of the contents of the current line.
- .SH EDITING COMMANDS
- .PP
- The following is a list of the names of the commands and the default
- key sequences to which they are bound.
- Command names without an accompanying key sequence are unbound by default.
- .SS Commands for Moving
- .PP
- .PD 0
- .TP
- .B beginning\-of\-line (C\-a)
- Move to the start of the current line.
- .TP
- .B end\-of\-line (C\-e)
- Move to the end of the line.
- .TP
- .B forward\-char (C\-f)
- Move forward a character.
- .TP
- .B backward\-char (C\-b)
- Move back a character.
- .TP
- .B forward\-word (M\-f)
- Move forward to the end of the next word.  Words are composed of
- alphanumeric characters (letters and digits).
- .TP
- .B backward\-word (M\-b)
- Move back to the start of the current or previous word.  Words are
- composed of alphanumeric characters (letters and digits).
- .TP
- .B clear\-screen (C\-l)
- Clear the screen leaving the current line at the top of the screen.
- With an argument, refresh the current line without clearing the
- screen.
- .TP
- .B redraw\-current\-line
- Refresh the current line.
- .PD
- .SS Commands for Manipulating the History
- .PP
- .PD 0
- .TP
- .B accept\-line (Newline, Return)
- Accept the line regardless of where the cursor is.  If this line is
- non-empty, add it to the history list. If the line is a modified
- history line, then restore the history line to its original state.
- .TP
- .B previous\-history (C\-p)
- Fetch the previous command from the history list, moving back in
- the list.
- .TP
- .B next\-history (C\-n)
- Fetch the next command from the history list, moving forward in the
- list.
- .TP
- .B beginning\-of\-history (M\-<)
- Move to the first line in the history.
- .TP
- .B end\-of\-history (M\->)
- Move to the end of the input history, i.e., the line currently being
- entered.
- .TP
- .B reverse\-search\-history (C\-r)
- Search backward starting at the current line and moving `up' through
- the history as necessary.  This is an incremental search.
- .TP
- .B forward\-search\-history (C\-s)
- Search forward starting at the current line and moving `down' through
- the history as necessary.  This is an incremental search.
- .TP
- .B non\-incremental\-reverse\-search\-history (M\-p)
- Search backward through the history starting at the current line
- using a non-incremental search for a string supplied by the user.
- .TP
- .B non\-incremental\-forward\-search\-history (M\-n)
- Search forward through the history using a non-incremental search
- for a string supplied by the user.
- .TP
- .B history\-search\-forward
- Search forward through the history for the string of characters
- between the start of the current line and the current cursor
- position (the \fIpoint\fP).
- This is a non-incremental search.
- .TP
- .B history\-search\-backward
- Search backward through the history for the string of characters
- between the start of the current line and the point.
- This is a non-incremental search.
- .TP
- .B yank\-nth\-arg (M\-C\-y)
- Insert the first argument to the previous command (usually
- the second word on the previous line) at point (the current
- cursor position).  With an argument
- .IR n ,
- insert the \fIn\fPth word from the previous command (the words
- in the previous command begin with word 0).  A negative argument
- inserts the \fIn\fPth word from the end of the previous command.
- .TP
- .B
- yank\-last\-arg (M\-.\^, M\-_\^)
- Insert the last argument to the previous command (the last word of
- the previous history entry).  With an argument,
- behave exactly like \fByank\-nth\-arg\fP.
- Successive calls to \fByank\-last\-arg\fP move back through the history
- list, inserting the last argument of each line in turn.
- .PD
- .SS Commands for Changing Text
- .PP
- .PD 0
- .TP
- .B delete\-char (C\-d)
- Delete the character under the cursor.  If point is at the
- beginning of the line, there are no characters in the line, and
- the last character typed was not bound to \fBBdelete\-char\fP, then return
- .SM
- .BR EOF .
- .TP
- .B backward\-delete\-char (Rubout)
- Delete the character behind the cursor.  When given a numeric argument,
- save the deleted text on the kill ring.
- .TP
- .B forward\-backward\-delete\-char   
- Delete the character under the cursor, unless the cursor is at the
- end of the line, in which case the character behind the cursor is
- deleted.  By default, this is not bound to a key.
- .TP
- .B quoted\-insert (C\-q, C\-v)
- Add the next character that you type to the line verbatim.  This is
- how to insert characters like \fBC\-q\fP, for example.
- .TP
- .B tab\-insert (M-TAB)
- Insert a tab character.
- .TP
- .B self\-insert (a,\ b,\ A,\ 1,\ !,\ ...)
- Insert the character typed.
- .TP
- .B transpose\-chars (C\-t)
- Drag the character before point forward over the character at point.
- Point moves forward as well.  If point is at the end of the line, then
- transpose the two characters before point.  Negative arguments don't work.
- .TP
- .B transpose\-words (M\-t)
- Drag the word behind the cursor past the word in front of the cursor
- moving the cursor over that word as well.
- .TP
- .B upcase\-word (M\-u)
- Uppercase the current (or following) word.  With a negative argument,
- uppercase the previous word, but do not move point.
- .TP
- .B downcase\-word (M\-l)
- Lowercase the current (or following) word.  With a negative argument,
- lowercase the previous word, but do not move point.
- .TP
- .B capitalize\-word (M\-c)
- Capitalize the current (or following) word.  With a negative argument,
- capitalize the previous word, but do not move point.
- .PD
- .SS Killing and Yanking
- .PP
- .PD 0
- .TP
- .B kill\-line (C\-k)
- Kill the text from the current cursor position to the end of the line.
- .TP
- .B backward\-kill\-line (C\-x Rubout)
- Kill backward to the beginning of the line.
- .TP
- .B unix\-line\-discard (C\-u)
- Kill backward from point to the beginning of the line.
- The killed text is saved on the kill-ring.
- .\" There is no real difference between this and backward-kill-line
- .TP
- .B kill\-whole\-line
- Kill all characters on the current line, no matter where the
- cursor is.
- .TP
- .B kill\-word  (M\-d)
- Kill from the cursor to the end of the current word, or if between
- words, to the end of the next word.  Word boundaries are the same as
- those used by \fBforward\-word\fP.
- .TP
- .B backward\-kill\-word (M\-Rubout)
- Kill the word behind the cursor.  Word boundaries are the same as
- those used by \fBbackward\-word\fP.
- .TP
- .B unix\-word\-rubout (C\-w)
- Kill the word behind the cursor, using white space as a word boundary.
- The word boundaries are different from
- .BR backward\-kill\-word .
- .TP
- .B delete\-horizontal\-space (M\-\e)
- Delete all spaces and tabs around point.
- .TP
- .B kill\-region
- Kill the text between the point and \fImark\fP (saved cursor position).
- This text is referred to as the \fIregion\fP.
- .TP
- .B copy\-region\-as\-kill
- Copy the text in the region to the kill buffer.
- .TP
- .B copy\-backward\-word
- Copy the word before point to the kill buffer.
- The word boundaries are the same as \fBbackward\-word\fP.
- .TP
- .B copy\-forward\-word
- Copy the word following point to the kill buffer.
- The word boundaries are the same as \fBforward\-word\fP.
- .TP
- .B yank (C\-y)
- Yank the top of the kill ring into the buffer at the cursor.
- .TP
- .B yank\-pop (M\-y)
- Rotate the kill ring, and yank the new top.  Only works following
- .B yank
- or
- .BR yank\-pop .
- .PD
- .SS Numeric Arguments
- .PP
- .PD 0
- .TP
- .B digit\-argument (M\-0, M\-1, ..., M\-\-)
- Add this digit to the argument already accumulating, or start a new
- argument.  M\-\- starts a negative argument.
- .TP
- .B universal\-argument
- This is another way to specify an argument.
- If this command is followed by one or more digits, optionally with a
- leading minus sign, those digits define the argument.
- If the command is followed by digits, executing
- .B universal\-argument
- again ends the numeric argument, but is otherwise ignored.
- As a special case, if this command is immediately followed by a
- character that is neither a digit or minus sign, the argument count
- for the next command is multiplied by four.
- The argument count is initially one, so executing this function the
- first time makes the argument count four, a second time makes the
- argument count sixteen, and so on.
- .PD
- .SS Completing
- .PP
- .PD 0
- .TP
- .B complete (TAB)
- Attempt to perform completion on the text before point.
- The actual completion performed is application-specific.
- .BR Bash ,
- for instance, attempts completion treating the text as a variable
- (if the text begins with \fB$\fP), username (if the text begins with
- \fB~\fP), hostname (if the text begins with \fB@\fP), or
- command (including aliases and functions) in turn.  If none
- of these produces a match, filename completion is attempted.
- .BR Gdb ,
- on the other hand,
- allows completion of program functions and variables, and
- only attempts filename completion under certain circumstances.
- .TP
- .B possible\-completions (M\-?)
- List the possible completions of the text before point.
- .TP
- .B insert\-completions (M\-*)
- Insert all completions of the text before point
- that would have been generated by
- \fBpossible\-completions\fP.
- .TP
- .B menu\-complete
- Similar to \fBcomplete\fP, but replaces the word to be completed
- with a single match from the list of possible completions.
- Repeated execution of \fBmenu\-complete\fP steps through the list
- of possible completions, inserting each match in turn.
- At the end of the list of completions, the bell is rung and the
- original text is restored.
- An argument of \fIn\fP moves \fIn\fP positions forward in the list
- of matches; a negative argument may be used to move backward 
- through the list.
- This command is intended to be bound to \fBTAB\fP, but is unbound
- by default.
- .TP
- .B delete\-char\-or\-list
- Deletes the character under the cursor if not at the beginning or
- end of the line (like \fBdelete-char\fP).
- If at the end of the line, behaves identically to
- \fBpossible-completions\fP.
- This command is unbound by default.
- .PD
- .SS Keyboard Macros
- .PP
- .PD 0
- .TP
- .B start\-kbd\-macro (C\-x (\^)
- Begin saving the characters typed into the current keyboard macro.
- .TP
- .B end\-kbd\-macro (C\-x )\^)
- Stop saving the characters typed into the current keyboard macro
- and store the definition.
- .TP
- .B call\-last\-kbd\-macro (C\-x e)
- Re-execute the last keyboard macro defined, by making the characters
- in the macro appear as if typed at the keyboard.
- .PD
- .SS Miscellaneous
- .PP
- .PD 0
- .TP
- .B re\-read\-init\-file (C\-x C\-r)
- Read in the contents of the \fIinputrc\fP file, and incorporate
- any bindings or variable assignments found there.
- .TP
- .B abort (C\-g)
- Abort the current editing command and
- ring the terminal's bell (subject to the setting of
- .BR bell\-style ).
- .TP
- .B do\-uppercase\-version (M\-a, M\-b, M\-\fIx\fP, ...)
- If the metafied character \fIx\fP is lowercase, run the command
- that is bound to the corresponding uppercase character.
- .TP
- .B prefix\-meta (ESC)
- Metafy the next character typed.
- .SM
- .B ESC
- .B f
- is equivalent to
- .BR Meta\-f .
- .TP
- .B undo (C\-_, C\-x C\-u)
- Incremental undo, separately remembered for each line.
- .TP
- .B revert\-line (M\-r)
- Undo all changes made to this line.  This is like executing the
- .B undo
- command enough times to return the line to its initial state.
- .TP
- .B tilde\-expand (M\-&)
- Perform tilde expansion on the current word.
- .TP
- .B set\-mark (C\-@, M-<space>)
- Set the mark to the current point.  If a
- numeric argument is supplied, the mark is set to that position.
- .TP
- .B exchange\-point\-and\-mark (C\-x C\-x)
- Swap the point with the mark.  The current cursor position is set to
- the saved position, and the old cursor position is saved as the mark.
- .TP
- .B character\-search (C\-])
- A character is read and point is moved to the next occurrence of that
- character.  A negative count searches for previous occurrences.
- .TP
- .B character\-search\-backward (M\-C\-])
- A character is read and point is moved to the previous occurrence of that
- character.  A negative count searches for subsequent occurrences.
- .TP
- .B insert\-comment (M\-#)
- The value of the readline
- .B comment\-begin
- variable is inserted at the beginning of the current line, and the line
- is accepted as if a newline had been typed.  This makes the current line
- a shell comment.
- .TP
- .B dump\-functions
- Print all of the functions and their key bindings to the
- readline output stream.  If a numeric argument is supplied,
- the output is formatted in such a way that it can be made part
- of an \fIinputrc\fP file.
- .TP
- .B dump\-variables
- Print all of the settable variables and their values to the
- readline output stream.  If a numeric argument is supplied,
- the output is formatted in such a way that it can be made part
- of an \fIinputrc\fP file.
- .TP
- .B dump\-macros
- Print all of the readline key sequences bound to macros and the
- strings they ouput.  If a numeric argument is supplied,
- the output is formatted in such a way that it can be made part
- of an \fIinputrc\fP file.
- .TP
- .B emacs\-editing\-mode (C\-e)
- When in
- .B vi
- editing mode, this causes a switch to
- .B emacs
- editing mode.
- .TP
- .B vi\-editing\-mode (M\-C\-j)
- When in
- .B emacs
- editing mode, this causes a switch to
- .B vi
- editing mode.
- .PD
- .SH DEFAULT KEY BINDINGS
- .LP
- The following is a list of the default emacs and vi bindings.
- Characters with the 8th bit set are written as M\-<character>, and
- are referred to as
- .I metafied
- characters.
- The printable ASCII characters not mentioned in the list of emacs
- standard bindings are bound to the
- .I self\-insert
- function, which just inserts the given character into the input line.
- In vi insertion mode, all characters not specifically mentioned are
- bound to
- .IR self\-insert .
- Characters assigned to signal generation by
- .IR stty (1)
- or the terminal driver, such as C-Z or C-C,
- retain that function.
- Upper and lower case
- .I metafied
- characters are bound to the same function in the emacs mode
- meta keymap.
- The remaining characters are unbound, which causes readline
- to ring the bell (subject to the setting of the
- .B bell\-style
- variable).
- .SS Emacs Mode
- .RS +.6i
- .nf
- .ta 2.5i
- .sp
- Emacs Standard bindings
- .sp
- "C-@"  set-mark
- "C-A"  beginning-of-line
- "C-B"  backward-char
- "C-D"  delete-char
- "C-E"  end-of-line
- "C-F"  forward-char
- "C-G"  abort
- "C-H"  backward-delete-char
- "C-I"  complete
- "C-J"  accept-line
- "C-K"  kill-line
- "C-L"  clear-screen
- "C-M"  accept-line
- "C-N"  next-history
- "C-P"  previous-history
- "C-Q"  quoted-insert
- "C-R"  reverse-search-history
- "C-S"  forward-search-history
- "C-T"  transpose-chars
- "C-U"  unix-line-discard
- "C-V"  quoted-insert
- "C-W"  unix-word-rubout
- "C-Y"  yank
- "C-]"  character-search
- "C-_"  undo
- "\^ " to "/"  self-insert
- "0"  to "9"  self-insert
- ":"  to "~"  self-insert
- "C-?"  backward-delete-char
- .PP
- Emacs Meta bindings
- .sp
- "M-C-G"  abort
- "M-C-H"  backward-kill-word
- "M-C-I"  tab-insert
- "M-C-J"  vi-editing-mode
- "M-C-M"  vi-editing-mode
- "M-C-R"  revert-line
- "M-C-Y"  yank-nth-arg
- "M-C-["  complete
- "M-C-]"  character-search-backward
- "M-space"  set-mark
- "M-#"  insert-comment
- "M-&"  tilde-expand
- "M-*"  insert-completions
- "M--"  digit-argument
- "M-."  yank-last-arg
- "M-0"  digit-argument
- "M-1"  digit-argument
- "M-2"  digit-argument
- "M-3"  digit-argument
- "M-4"  digit-argument
- "M-5"  digit-argument
- "M-6"  digit-argument
- "M-7"  digit-argument
- "M-8"  digit-argument
- "M-9"  digit-argument
- "M-<"  beginning-of-history
- "M-="  possible-completions
- "M->"  end-of-history
- "M-?"  possible-completions
- "M-B"  backward-word
- "M-C"  capitalize-word
- "M-D"  kill-word
- "M-F"  forward-word
- "M-L"  downcase-word
- "M-N"  non-incremental-forward-search-history
- "M-P"  non-incremental-reverse-search-history
- "M-R"  revert-line
- "M-T"  transpose-words
- "M-U"  upcase-word
- "M-Y"  yank-pop
- "M-\e"  delete-horizontal-space
- "M-~"  tilde-expand
- "M-C-?"  backward-delete-word
- "M-_"  yank-last-arg
- .PP
- Emacs Control-X bindings
- .sp
- "C-XC-G"  abort
- "C-XC-R"  re-read-init-file
- "C-XC-U"  undo
- "C-XC-X"  exchange-point-and-mark
- "C-X("  start-kbd-macro
- "C-X)"  end-kbd-macro
- "C-XE"  call-last-kbd-macro
- "C-XC-?"  backward-kill-line
- .sp
- .RE
- .SS VI Mode bindings
- .RS +.6i
- .nf
- .ta 2.5i
- .sp
- .PP
- VI Insert Mode functions
- .sp
- "C-D"  vi-eof-maybe
- "C-H"  backward-delete-char
- "C-I"  complete
- "C-J"  accept-line
- "C-M"  accept-line
- "C-R"  reverse-search-history
- "C-S"  forward-search-history
- "C-T"  transpose-chars
- "C-U"  unix-line-discard
- "C-V"  quoted-insert
- "C-W"  unix-word-rubout
- "C-Y"  yank
- "C-["  vi-movement-mode
- "C-_"  undo
- "\^ " to "~"  self-insert
- "C-?"  backward-delete-char
- .PP
- VI Command Mode functions
- .sp
- "C-D"  vi-eof-maybe
- "C-E"  emacs-editing-mode
- "C-G"  abort
- "C-H"  backward-char
- "C-J"  accept-line
- "C-K"  kill-line
- "C-L"  clear-screen
- "C-M"  accept-line
- "C-N"  next-history
- "C-P"  previous-history
- "C-Q"  quoted-insert
- "C-R"  reverse-search-history
- "C-S"  forward-search-history
- "C-T"  transpose-chars
- "C-U"  unix-line-discard
- "C-V"  quoted-insert
- "C-W"  unix-word-rubout
- "C-Y"  yank
- "\^ "  forward-char
- "#"  insert-comment
- "$"  end-of-line
- "%"  vi-match
- "&"  vi-tilde-expand
- "*"  vi-complete
- "+"  next-history
- ","  vi-char-search
- "-"  previous-history
- "."  vi-redo
- "/"  vi-search
- "0"  beginning-of-line
- "1" to "9"  vi-arg-digit
- ";"  vi-char-search
- "="  vi-complete
- "?"  vi-search
- "A"  vi-append-eol
- "B"  vi-prev-word
- "C"  vi-change-to
- "D"  vi-delete-to
- "E"  vi-end-word
- "F"  vi-char-search
- "G"  vi-fetch-history
- "I"  vi-insert-beg
- "N"  vi-search-again
- "P"  vi-put
- "R"  vi-replace
- "S"  vi-subst
- "T"  vi-char-search
- "U"  revert-line
- "W"  vi-next-word
- "X"  backward-delete-char
- "Y"  vi-yank-to
- "\e"  vi-complete
- "^"  vi-first-print
- "_"  vi-yank-arg
- "`"  vi-goto-mark
- "a"  vi-append-mode
- "b"  vi-prev-word
- "c"  vi-change-to
- "d"  vi-delete-to
- "e"  vi-end-word
- "f"  vi-char-search
- "h"  backward-char
- "i"  vi-insertion-mode
- "j"  next-history
- "k"  prev-history
- "l"  forward-char
- "m"  vi-set-mark
- "n"  vi-search-again
- "p"  vi-put
- "r"  vi-change-char
- "s"  vi-subst
- "t"  vi-char-search
- "u"  undo
- "w"  vi-next-word
- "x"  vi-delete
- "y"  vi-yank-to
- "|"  vi-column
- "~"  vi-change-case
- .RE
- .SH "SEE ALSO"
- .PD 0
- .TP
- \fIThe Gnu Readline Library\fP, Brian Fox and Chet Ramey
- .TP
- \fIThe Gnu History Library\fP, Brian Fox and Chet Ramey
- .TP
- \fIbash\fP(1)
- .PD
- .SH FILES
- .PD 0
- .TP
- .FN ~/.inputrc
- Individual \fBreadline\fP initialization file
- .PD
- .SH AUTHORS
- Brian Fox, Free Software Foundation
- .br
- bfox@gnu.org
- .PP
- Chet Ramey, Case Western Reserve University
- .br
- chet@ins.CWRU.Edu
- .SH BUG REPORTS
- If you find a bug in
- .B readline,
- you should report it.  But first, you should
- make sure that it really is a bug, and that it appears in the latest
- version of the
- .B readline
- library that you have.
- .PP
- Once you have determined that a bug actually exists, mail a
- bug report to \fIbug\-readline\fP@\fIgnu.org\fP.
- If you have a fix, you are welcome to mail that
- as well!  Suggestions and `philosophical' bug reports may be mailed
- to \fPbug-readline\fP@\fIgnu.org\fP or posted to the Usenet
- newsgroup
- .BR gnu.bash.bug .
- .PP
- Comments and bug reports concerning
- this manual page should be directed to
- .IR chet@ins.CWRU.Edu .
- .SH BUGS
- .PP
- It's too big and too slow.
--- 0 ----
diff -Nrc2 bash-2.04/doc/texinfo.tex bash-2.05/doc/texinfo.tex
*** bash-2.04/doc/texinfo.tex	Tue Jul  1 15:36:48 1997
--- bash-2.05/doc/texinfo.tex	Thu Nov  2 09:50:52 2000
***************
*** 1,50 ****
! %% TeX macros to handle texinfo files
! 
! %  Copyright (C) 1985, 86, 88, 90, 91, 92, 93,
! %                94, 95, 1996 Free Software Foundation, Inc.
! 
! %This texinfo.tex file is free software; you can redistribute it and/or
! %modify it under the terms of the GNU General Public License as
! %published by the Free Software Foundation; either version 2, or (at
! %your option) any later version.
! 
! %This texinfo.tex file is distributed in the hope that it will be
! %useful, but WITHOUT ANY WARRANTY; without even the implied warranty
! %of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! %General Public License for more details.
! 
! %You should have received a copy of the GNU General Public License
! %along with this texinfo.tex file; see the file COPYING.  If not, write
! %to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! %Boston, MA 02111-1307, USA.
! 
! 
! %In other words, you are welcome to use, share and improve this program.
! %You are forbidden to forbid anyone else to use, share and improve
! %what you give them.   Help stamp out software-hoarding!
! 
! 
! % Send bug reports to bug-texinfo@prep.ai.mit.edu.
! % Please include a *precise* test case in each bug report.
! 
! 
! % Make it possible to create a .fmt file just by loading this file:
! % if the underlying format is not loaded, start by loading it now.
! % Added by gildea November 1993.
  \expandafter\ifx\csname fmtname\endcsname\relax\input plain\fi
  
! % This automatically updates the version number based on RCS.
! \def\deftexinfoversion$#1: #2 ${\def\texinfoversion{#2}}
! \deftexinfoversion$Revision: 2.185 $
! \message{Loading texinfo package [Version \texinfoversion]:}
  
  % If in a .fmt file, print the version number
  % and turn on active characters that we couldn't do earlier because
  % they might have appeared in the input file name.
! \everyjob{\message{[Texinfo version \texinfoversion]}\message{}
    \catcode`+=\active \catcode`\_=\active}
  
  % Save some parts of plain tex whose names we will redefine.
- 
  \let\ptexb=\b
  \let\ptexbullet=\bullet
--- 1,71 ----
! % texinfo.tex -- TeX macros to handle Texinfo files.
! %
! % Load plain if necessary, i.e., if running under initex.
  \expandafter\ifx\csname fmtname\endcsname\relax\input plain\fi
+ %
+ \def\texinfoversion{1999-09-25.10}
+ %
+ % Copyright (C) 1985, 86, 88, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99
+ % Free Software Foundation, Inc.
+ %
+ % This texinfo.tex file is free software; you can redistribute it and/or
+ % modify it under the terms of the GNU General Public License as
+ % published by the Free Software Foundation; either version 2, or (at
+ % your option) any later version.
+ %
+ % This texinfo.tex file is distributed in the hope that it will be
+ % useful, but WITHOUT ANY WARRANTY; without even the implied warranty
+ % of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ % General Public License for more details.
+ %
+ % You should have received a copy of the GNU General Public License
+ % along with this texinfo.tex file; see the file COPYING.  If not, write
+ % to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ % Boston, MA 02111-1307, USA.
+ %
+ % In other words, you are welcome to use, share and improve this program.
+ % You are forbidden to forbid anyone else to use, share and improve
+ % what you give them.   Help stamp out software-hoarding!
+ %
+ % Please try the latest version of texinfo.tex before submitting bug
+ % reports; you can get the latest version from:
+ %   ftp://ftp.gnu.org/gnu/texinfo.tex
+ %   (and all GNU mirrors, see http://www.gnu.org/order/ftp.html)
+ %   ftp://texinfo.org/tex/texinfo.tex
+ %   ftp://us.ctan.org/macros/texinfo/texinfo.tex
+ %   (and all CTAN mirrors, finger ctan@us.ctan.org for a list).
+ %   /home/gd/gnu/doc/texinfo.tex on the GNU machines.
+ % The texinfo.tex in any given Texinfo distribution could well be out
+ % of date, so if that's what you're using, please check.
+ % Texinfo has a small home page at http://texinfo.org/.
+ %
+ % Send bug reports to bug-texinfo@gnu.org.  Please include including a
+ % complete document in each bug report with which we can reproduce the
+ % problem.  Patches are, of course, greatly appreciated.
+ %
+ % To process a Texinfo manual with TeX, it's most reliable to use the
+ % texi2dvi shell script that comes with the distribution.  For a simple
+ % manual foo.texi, however, you can get away with this:
+ %   tex foo.texi
+ %   texindex foo.??
+ %   tex foo.texi
+ %   tex foo.texi
+ %   dvips foo.dvi -o # or whatever, to process the dvi file; this makes foo.ps.
+ % The extra runs of TeX get the cross-reference information correct.
+ % Sometimes one run after texindex suffices, and sometimes you need more
+ % than two; texi2dvi does it as many times as necessary.
+ %
+ % It is possible to adapt texinfo.tex for other languages.  You can get
+ % the existing language-specific files from ftp://ftp.gnu.org/gnu/texinfo/.
  
! \message{Loading texinfo [version \texinfoversion]:}
  
  % If in a .fmt file, print the version number
  % and turn on active characters that we couldn't do earlier because
  % they might have appeared in the input file name.
! \everyjob{\message{[Texinfo version \texinfoversion]}%
    \catcode`+=\active \catcode`\_=\active}
  
  % Save some parts of plain tex whose names we will redefine.
  \let\ptexb=\b
  \let\ptexbullet=\bullet
***************
*** 54,58 ****
  \let\ptexdots=\dots
  \let\ptexend=\end
! \let\ptexequiv = \equiv
  \let\ptexi=\i
  \let\ptexlbrace=\{
--- 75,80 ----
  \let\ptexdots=\dots
  \let\ptexend=\end
! \let\ptexequiv=\equiv
! \let\ptexexclam=\!
  \let\ptexi=\i
  \let\ptexlbrace=\{
***************
*** 60,78 ****
  \let\ptexstar=\*
  \let\ptext=\t
- \let\ptextilde=\~
- 
- % Be sure we're in horizontal mode when doing a tie, since we make space
- % equivalent to this in @example-like environments. Otherwise, a space
- % at the beginning of a line will start with \penalty -- and
- % since \penalty is valid in vertical mode, we'd end up putting the
- % penalty on the vertical list instead of in the new paragraph.
- {\catcode`@ = 11
-  % Avoid using \@M directly, because that causes trouble
-  % if the definition is written into an index file.
-  \global\let\tiepenalty = \@M
-  \gdef\tie{\leavevmode\penalty\tiepenalty\ }
- }
- \let\~ = \tie                  % And make it available as @~.
  
  
  \message{Basics,}
--- 82,89 ----
  \let\ptexstar=\*
  \let\ptext=\t
  
+ % We never want plain's outer \+ definition in Texinfo.
+ % For @tex, we can use \tabalign.
+ \let\+ = \relax
  
  \message{Basics,}
***************
*** 83,98 ****
  \newlinechar = `^^J
  
! % Set up fixed words for English.
! \ifx\putwordChapter\undefined{\gdef\putwordChapter{Chapter}}\fi%
! \def\putwordInfo{Info}%
! \ifx\putwordSee\undefined{\gdef\putwordSee{See}}\fi%
! \ifx\putwordsee\undefined{\gdef\putwordsee{see}}\fi%
! \ifx\putwordfile\undefined{\gdef\putwordfile{file}}\fi%
! \ifx\putwordpage\undefined{\gdef\putwordpage{page}}\fi%
! \ifx\putwordsection\undefined{\gdef\putwordsection{section}}\fi%
! \ifx\putwordSection\undefined{\gdef\putwordSection{Section}}\fi%
! \ifx\putwordTableofContents\undefined{\gdef\putwordTableofContents{Table of Contents}}\fi%
! \ifx\putwordShortContents\undefined{\gdef\putwordShortContents{Short Contents}}\fi%
! \ifx\putwordAppendix\undefined{\gdef\putwordAppendix{Appendix}}\fi%
  
  % Ignore a token.
--- 94,138 ----
  \newlinechar = `^^J
  
! % Set up fixed words for English if not already set.
! \ifx\putwordAppendix\undefined  \gdef\putwordAppendix{Appendix}\fi
! \ifx\putwordChapter\undefined   \gdef\putwordChapter{Chapter}\fi
! \ifx\putwordfile\undefined      \gdef\putwordfile{file}\fi
! \ifx\putwordin\undefined        \gdef\putwordin{in}\fi
! \ifx\putwordIndexIsEmpty\undefined     \gdef\putwordIndexIsEmpty{(Index is empty)}\fi
! \ifx\putwordIndexNonexistent\undefined \gdef\putwordIndexNonexistent{(Index is nonexistent)}\fi
! \ifx\putwordInfo\undefined      \gdef\putwordInfo{Info}\fi
! \ifx\putwordInstanceVariableof\undefined \gdef\putwordInstanceVariableof{Instance Variable of}\fi
! \ifx\putwordMethodon\undefined  \gdef\putwordMethodon{Method on}\fi
! \ifx\putwordNoTitle\undefined   \gdef\putwordNoTitle{No Title}\fi
! \ifx\putwordof\undefined        \gdef\putwordof{of}\fi
! \ifx\putwordon\undefined        \gdef\putwordon{on}\fi
! \ifx\putwordpage\undefined      \gdef\putwordpage{page}\fi
! \ifx\putwordsection\undefined   \gdef\putwordsection{section}\fi
! \ifx\putwordSection\undefined   \gdef\putwordSection{Section}\fi
! \ifx\putwordsee\undefined       \gdef\putwordsee{see}\fi
! \ifx\putwordSee\undefined       \gdef\putwordSee{See}\fi
! \ifx\putwordShortTOC\undefined  \gdef\putwordShortTOC{Short Contents}\fi
! \ifx\putwordTOC\undefined       \gdef\putwordTOC{Table of Contents}\fi
! %
! \ifx\putwordMJan\undefined \gdef\putwordMJan{January}\fi
! \ifx\putwordMFeb\undefined \gdef\putwordMFeb{February}\fi
! \ifx\putwordMMar\undefined \gdef\putwordMMar{March}\fi
! \ifx\putwordMApr\undefined \gdef\putwordMApr{April}\fi
! \ifx\putwordMMay\undefined \gdef\putwordMMay{May}\fi
! \ifx\putwordMJun\undefined \gdef\putwordMJun{June}\fi
! \ifx\putwordMJul\undefined \gdef\putwordMJul{July}\fi
! \ifx\putwordMAug\undefined \gdef\putwordMAug{August}\fi
! \ifx\putwordMSep\undefined \gdef\putwordMSep{September}\fi
! \ifx\putwordMOct\undefined \gdef\putwordMOct{October}\fi
! \ifx\putwordMNov\undefined \gdef\putwordMNov{November}\fi
! \ifx\putwordMDec\undefined \gdef\putwordMDec{December}\fi
! %
! \ifx\putwordDefmac\undefined    \gdef\putwordDefmac{Macro}\fi
! \ifx\putwordDefspec\undefined   \gdef\putwordDefspec{Special Form}\fi
! \ifx\putwordDefvar\undefined    \gdef\putwordDefvar{Variable}\fi
! \ifx\putwordDefopt\undefined    \gdef\putwordDefopt{User Option}\fi
! \ifx\putwordDeftypevar\undefined\gdef\putwordDeftypevar{Variable}\fi
! \ifx\putwordDeffunc\undefined   \gdef\putwordDeffunc{Function}\fi
! \ifx\putwordDeftypefun\undefined\gdef\putwordDeftypefun{Function}\fi
  
  % Ignore a token.
***************
*** 103,110 ****
  \hyphenation{mini-buf-fer mini-buf-fers}
  \hyphenation{eshell}
  
  % Margin to add to right of even pages, to left of odd pages.
! \newdimen \bindingoffset  
! \newdimen \normaloffset   
  \newdimen\pagewidth \newdimen\pageheight
  
--- 143,151 ----
  \hyphenation{mini-buf-fer mini-buf-fers}
  \hyphenation{eshell}
+ \hyphenation{white-space}
  
  % Margin to add to right of even pages, to left of odd pages.
! \newdimen \bindingoffset
! \newdimen \normaloffset
  \newdimen\pagewidth \newdimen\pageheight
  
***************
*** 114,117 ****
--- 155,159 ----
  %
  \def\gloggingall{\begingroup \globaldefs = 1 \loggingall \endgroup}%
+ \ifx\eTeXversion\undefined
  \def\loggingall{\tracingcommands2 \tracingstats2
     \tracingpages1 \tracingoutput1 \tracinglostchars1
***************
*** 119,198 ****
     \showboxbreadth\maxdimen\showboxdepth\maxdimen
  }%
  
! %---------------------Begin change-----------------------
  %
! %%%% For @cropmarks command.
! % Dimensions to add cropmarks at corners Added by P. A. MacKay, 12 Nov. 1986
  %
! \newdimen\cornerlong \newdimen\cornerthick
! \newdimen \topandbottommargin
! \newdimen \outerhsize \newdimen \outervsize
! \cornerlong=1pc\cornerthick=.3pt        % These set size of cropmarks
! \outerhsize=7in
! %\outervsize=9.5in
! % Alternative @smallbook page size is 9.25in
! \outervsize=9.25in
! \topandbottommargin=.75in
  %
! %---------------------End change-----------------------
  
  % \onepageout takes a vbox as an argument.  Note that \pagecontents
  % does insertions, but you have to call it yourself.
- \chardef\PAGE=255  \output={\onepageout{\pagecontents\PAGE}}
  \def\onepageout#1{%
!   \hoffset=\normaloffset
    \ifodd\pageno  \advance\hoffset by \bindingoffset
    \else \advance\hoffset by -\bindingoffset\fi
    {%
!     \escapechar = `\\ % use backslash in output files.
!     \indexdummies
      \shipout\vbox{%
!       {\let\hsize=\pagewidth \makeheadline}%
        \pagebody{#1}%
!       {\let\hsize=\pagewidth \makefootline}%
!     }%
!   }%
    \advancepageno
    \ifnum\outputpenalty>-20000 \else\dosupereject\fi
  }
  
- %%%% For @cropmarks command %%%%
- 
- % Here is a modification of the main output routine for Near East Publications
- % This provides right-angle cropmarks at all four corners.
- % The contents of the page are centerlined into the cropmarks,
- % and any desired binding offset is added as an \hskip on either
- % site of the centerlined box.  (P. A. MacKay, 12 November, 1986)
- %
- \def\croppageout#1{\hoffset=0pt % make sure this doesn't mess things up
- {\escapechar=`\\\relax % makes sure backslash is used in output files.
-                  \shipout
-                  \vbox to \outervsize{\hsize=\outerhsize
-                  \vbox{\line{\ewtop\hfill\ewtop}}
-                  \nointerlineskip
-                  \line{\vbox{\moveleft\cornerthick\nstop}
-                        \hfill
-                        \vbox{\moveright\cornerthick\nstop}}
-                  \vskip \topandbottommargin
-                  \centerline{\ifodd\pageno\hskip\bindingoffset\fi
-                         \vbox{
-                         {\let\hsize=\pagewidth \makeheadline}
-                         \pagebody{#1}
-                         {\let\hsize=\pagewidth \makefootline}}
-                         \ifodd\pageno\else\hskip\bindingoffset\fi}
-                  \vskip \topandbottommargin plus1fill minus1fill
-                  \boxmaxdepth\cornerthick
-                  \line{\vbox{\moveleft\cornerthick\nsbot}
-                        \hfill
-                        \vbox{\moveright\cornerthick\nsbot}}
-                  \nointerlineskip
-                  \vbox{\line{\ewbot\hfill\ewbot}}
-         }}
-   \advancepageno
-   \ifnum\outputpenalty>-20000 \else\dosupereject\fi}
- %
- % Do @cropmarks to get crop marks
- \def\cropmarks{\let\onepageout=\croppageout }
- 
  \newinsert\margin \dimen\margin=\maxdimen
  
--- 161,271 ----
     \showboxbreadth\maxdimen\showboxdepth\maxdimen
  }%
+ \else
+ \def\loggingall{\tracingcommands3 \tracingstats2
+    \tracingpages1 \tracingoutput1 \tracinglostchars1
+    \tracingmacros2 \tracingparagraphs1 \tracingrestores1
+    \tracingscantokens1 \tracingassigns1 \tracingifs1
+    \tracinggroups1 \tracingnesting2
+    \showboxbreadth\maxdimen\showboxdepth\maxdimen
+ }%
+ \fi
  
! % For @cropmarks command.
! % Do @cropmarks to get crop marks.
  %
! \newif\ifcropmarks
! \let\cropmarks = \cropmarkstrue
  %
! % Dimensions to add cropmarks at corners.
! % Added by P. A. MacKay, 12 Nov. 1986
  %
! \newdimen\outerhsize \newdimen\outervsize % set by the paper size routines
! \newdimen\cornerlong  \cornerlong=1pc
! \newdimen\cornerthick \cornerthick=.3pt
! \newdimen\topandbottommargin \topandbottommargin=.75in
! 
! % Main output routine.
! \chardef\PAGE = 255
! \output = {\onepageout{\pagecontents\PAGE}}
! 
! \newbox\headlinebox
! \newbox\footlinebox
  
  % \onepageout takes a vbox as an argument.  Note that \pagecontents
  % does insertions, but you have to call it yourself.
  \def\onepageout#1{%
!   \ifcropmarks \hoffset=0pt \else \hoffset=\normaloffset \fi
!   %
    \ifodd\pageno  \advance\hoffset by \bindingoffset
    \else \advance\hoffset by -\bindingoffset\fi
+   %
+   % Do this outside of the \shipout so @code etc. will be expanded in
+   % the headline as they should be, not taken literally (outputting ''code).
+   \setbox\headlinebox = \vbox{\let\hsize=\pagewidth \makeheadline}%
+   \setbox\footlinebox = \vbox{\let\hsize=\pagewidth \makefootline}%
+   %
    {%
!     % Have to do this stuff outside the \shipout because we want it to
!     % take effect in \write's, yet the group defined by the \vbox ends
!     % before the \shipout runs.
!     %
!     \escapechar = `\\     % use backslash in output files.
!     \indexdummies         % don't expand commands in the output.
!     \normalturnoffactive  % \ in index entries must not stay \, e.g., if
!                    % the page break happens to be in the middle of an example.
      \shipout\vbox{%
!       \ifcropmarks \vbox to \outervsize\bgroup
!         \hsize = \outerhsize
!         \vskip-\topandbottommargin
!         \vtop to0pt{%
!           \line{\ewtop\hfil\ewtop}%
!           \nointerlineskip
!           \line{%
!             \vbox{\moveleft\cornerthick\nstop}%
!             \hfill
!             \vbox{\moveright\cornerthick\nstop}%
!           }%
!           \vss}%
!         \vskip\topandbottommargin
!         \line\bgroup
!           \hfil % center the page within the outer (page) hsize.
!           \ifodd\pageno\hskip\bindingoffset\fi
!           \vbox\bgroup
!       \fi
!       %
!       \unvbox\headlinebox
        \pagebody{#1}%
!       \ifdim\ht\footlinebox > 0pt
!         % Only leave this space if the footline is nonempty.
!         % (We lessened \vsize for it in \oddfootingxxx.)
!         % The \baselineskip=24pt in plain's \makefootline has no effect.
!         \vskip 2\baselineskip
!         \unvbox\footlinebox
!       \fi
!       %
!       \ifpdfmakepagedest \pdfmkdest{\the\pageno} \fi
!       %
!       \ifcropmarks
!           \egroup % end of \vbox\bgroup
!         \hfil\egroup % end of (centering) \line\bgroup
!         \vskip\topandbottommargin plus1fill minus1fill
!         \boxmaxdepth = \cornerthick
!         \vbox to0pt{\vss
!           \line{%
!             \vbox{\moveleft\cornerthick\nsbot}%
!             \hfill
!             \vbox{\moveright\cornerthick\nsbot}%
!           }%
!           \nointerlineskip
!           \line{\ewbot\hfil\ewbot}%
!         }%
!       \egroup % \vbox from first cropmarks clause
!       \fi
!     }% end of \shipout\vbox
!   }% end of group with \turnoffactive
    \advancepageno
    \ifnum\outputpenalty>-20000 \else\dosupereject\fi
  }
  
  \newinsert\margin \dimen\margin=\maxdimen
  
***************
*** 208,212 ****
  }
  
- %
  % Here are the rules for the cropmarks.  Note that they are
  % offset so that the space between them is truly \outerhsize or \outervsize
--- 281,284 ----
***************
*** 303,311 ****
  \newif\ifENV \ENVfalse \def\inENV{\ifENV\relax\else\ENVtrue\fi}
  \def\ENVcheck{%
! \ifENV\errmessage{Still within an environment.  Type Return to continue.}
  \endgroup\fi} % This is not perfect, but it should reduce lossage
  
  % @begin foo  is the same as @foo, for now.
! \newhelp\EMsimple{Type <Return> to continue.}
  
  \outer\def\begin{\parsearg\beginxxx}
--- 375,383 ----
  \newif\ifENV \ENVfalse \def\inENV{\ifENV\relax\else\ENVtrue\fi}
  \def\ENVcheck{%
! \ifENV\errmessage{Still within an environment; press RETURN to continue}
  \endgroup\fi} % This is not perfect, but it should reduce lossage
  
  % @begin foo  is the same as @foo, for now.
! \newhelp\EMsimple{Press RETURN to continue.}
  
  \outer\def\begin{\parsearg\beginxxx}
***************
*** 366,370 ****
  % @@ prints an @
  % Kludge this until the fonts are right (grr).
! \def\@{{\tt \char '100}}
  
  % This is turned off because it was never documented
--- 438,442 ----
  % @@ prints an @
  % Kludge this until the fonts are right (grr).
! \def\@{{\tt\char64}}
  
  % This is turned off because it was never documented
***************
*** 376,381 ****
  
  % Used to generate quoted braces.
! \def\mylbrace {{\tt \char '173}}
! \def\myrbrace {{\tt \char '175}}
  \let\{=\mylbrace
  \let\}=\myrbrace
--- 448,453 ----
  
  % Used to generate quoted braces.
! \def\mylbrace {{\tt\char123}}
! \def\myrbrace {{\tt\char125}}
  \let\{=\mylbrace
  \let\}=\myrbrace
***************
*** 414,417 ****
--- 486,501 ----
  }
  
+ % Be sure we're in horizontal mode when doing a tie, since we make space
+ % equivalent to this in @example-like environments. Otherwise, a space
+ % at the beginning of a line will start with \penalty -- and
+ % since \penalty is valid in vertical mode, we'd end up putting the
+ % penalty on the vertical list instead of in the new paragraph.
+ {\catcode`@ = 11
+  % Avoid using \@M directly, because that causes trouble
+  % if the definition is written into an index file.
+  \global\let\tiepenalty = \@M
+  \gdef\tie{\leavevmode\penalty\tiepenalty\ }
+ }
+ 
  % @: forces normal size whitespace following.
  \def\:{\spacefactor=1000 }
***************
*** 423,434 ****
  \def\.{.\spacefactor=3000 }
  
- % @enddots{} is an end-of-sentence ellipsis.
- \gdef\enddots{$\mathinner{\ldotp\ldotp\ldotp\ldotp}$\spacefactor=3000}
- 
  % @! is an end-of-sentence bang.
! \gdef\!{!\spacefactor=3000 }
  
  % @? is an end-of-sentence query.
! \gdef\?{?\spacefactor=3000 }
  
  % @w prevents a word break.  Without the \leavevmode, @w at the
--- 507,515 ----
  \def\.{.\spacefactor=3000 }
  
  % @! is an end-of-sentence bang.
! \def\!{!\spacefactor=3000 }
  
  % @? is an end-of-sentence query.
! \def\?{?\spacefactor=3000 }
  
  % @w prevents a word break.  Without the \leavevmode, @w at the
***************
*** 514,552 ****
  %% if the depth of the box does not fit.
  %{\baselineskip=0pt%
! %\vtop to #1\mil{\vfil}\kern -#1\mil\penalty 10000
  %\prevdepth=-1000pt
  %}}
  
  \def\needx#1{%
!   % Go into vertical mode, so we don't make a big box in the middle of a
    % paragraph.
    \par
    %
!   % Don't add any leading before our big empty box, but allow a page
!   % break, since the best break might be right here.
!   \allowbreak
!   \nointerlineskip
!   \vtop to #1\mil{\vfil}%
!   %
!   % TeX does not even consider page breaks if a penalty added to the
!   % main vertical list is 10000 or more.  But in order to see if the
!   % empty box we just added fits on the page, we must make it consider
!   % page breaks.  On the other hand, we don't want to actually break the
!   % page after the empty box.  So we use a penalty of 9999.
!   %
!   % There is an extremely small chance that TeX will actually break the
!   % page at this \penalty, if there are no other feasible breakpoints in
!   % sight.  (If the user is using lots of big @group commands, which
!   % almost-but-not-quite fill up a page, TeX will have a hard time doing
!   % good page breaking, for example.)  However, I could not construct an
!   % example where a page broke at this \penalty; if it happens in a real
!   % document, then we can reconsider our strategy.
!   \penalty9999
!   %
!   % Back up by the size of the box, whether we did a page break or not.
!   \kern -#1\mil
!   %
!   % Do not allow a page break right after this kern.
!   \nobreak
  }
  
--- 595,639 ----
  %% if the depth of the box does not fit.
  %{\baselineskip=0pt%
! %\vtop to #1\mil{\vfil}\kern -#1\mil\nobreak
  %\prevdepth=-1000pt
  %}}
  
  \def\needx#1{%
!   % Ensure vertical mode, so we don't make a big box in the middle of a
    % paragraph.
    \par
    %
!   % If the @need value is less than one line space, it's useless.
!   \dimen0 = #1\mil
!   \dimen2 = \ht\strutbox
!   \advance\dimen2 by \dp\strutbox
!   \ifdim\dimen0 > \dimen2
!     %
!     % Do a \strut just to make the height of this box be normal, so the
!     % normal leading is inserted relative to the preceding line.
!     % And a page break here is fine.
!     \vtop to #1\mil{\strut\vfil}%
!     %
!     % TeX does not even consider page breaks if a penalty added to the
!     % main vertical list is 10000 or more.  But in order to see if the
!     % empty box we just added fits on the page, we must make it consider
!     % page breaks.  On the other hand, we don't want to actually break the
!     % page after the empty box.  So we use a penalty of 9999.
!     %
!     % There is an extremely small chance that TeX will actually break the
!     % page at this \penalty, if there are no other feasible breakpoints in
!     % sight.  (If the user is using lots of big @group commands, which
!     % almost-but-not-quite fill up a page, TeX will have a hard time doing
!     % good page breaking, for example.)  However, I could not construct an
!     % example where a page broke at this \penalty; if it happens in a real
!     % document, then we can reconsider our strategy.
!     \penalty9999
!     %
!     % Back up by the size of the box, whether we did a page break or not.
!     \kern -#1\mil
!     %
!     % Do not allow a page break right after this kern.
!     \nobreak
!   \fi
  }
  
***************
*** 555,564 ****
  \let\br = \par
  
! % @dots{}  output some dots
  
- \def\dots{$\ldots$}
  
  % @page    forces the start of a new page
! 
  \def\page{\par\vfill\supereject}
  
--- 642,673 ----
  \let\br = \par
  
! % @dots{} output an ellipsis using the current font.
! % We do .5em per period so that it has the same spacing in a typewriter
! % font as three actual period characters.
! %
! \def\dots{%
!   \leavevmode
!   \hbox to 1.5em{%
!     \hskip 0pt plus 0.25fil minus 0.25fil
!     .\hss.\hss.%
!     \hskip 0pt plus 0.5fil minus 0.5fil
!   }%
! }
! 
! % @enddots{} is an end-of-sentence ellipsis.
! %
! \def\enddots{%
!   \leavevmode
!   \hbox to 2em{%
!     \hskip 0pt plus 0.25fil minus 0.25fil
!     .\hss.\hss.\hss.%
!     \hskip 0pt plus 0.5fil minus 0.5fil
!   }%
!   \spacefactor=3000
! }
  
  
  % @page    forces the start of a new page
! %
  \def\page{\par\vfill\supereject}
  
***************
*** 627,1017 ****
  % @ignore ... @end ignore  is another way to write a comment
  
! \def\comment{\catcode 64=\other \catcode 123=\other \catcode 125=\other%
! \parsearg \commentxxx}
! 
! \def\commentxxx #1{\catcode 64=0 \catcode 123=1 \catcode 125=2 }
  
  \let\c=\comment
  
! % @paragraphindent  is defined for the Info formatting commands only.
! \let\paragraphindent=\comment
! 
! % Prevent errors for section commands.
! % Used in @ignore and in failing conditionals.
! \def\ignoresections{%
! \let\chapter=\relax
! \let\unnumbered=\relax
! \let\top=\relax
! \let\unnumberedsec=\relax
! \let\unnumberedsection=\relax
! \let\unnumberedsubsec=\relax
! \let\unnumberedsubsection=\relax
! \let\unnumberedsubsubsec=\relax
! \let\unnumberedsubsubsection=\relax
! \let\section=\relax
! \let\subsec=\relax
! \let\subsubsec=\relax
! \let\subsection=\relax
! \let\subsubsection=\relax
! \let\appendix=\relax
! \let\appendixsec=\relax
! \let\appendixsection=\relax
! \let\appendixsubsec=\relax
! \let\appendixsubsection=\relax
! \let\appendixsubsubsec=\relax
! \let\appendixsubsubsection=\relax
! \let\contents=\relax
! \let\smallbook=\relax
! \let\titlepage=\relax
  }
  
! % Used in nested conditionals, where we have to parse the Texinfo source
! % and so want to turn off most commands, in case they are used
! % incorrectly.
! %
! \def\ignoremorecommands{%
!   \let\defcodeindex = \relax
!   \let\defcv = \relax
!   \let\deffn = \relax
!   \let\deffnx = \relax
!   \let\defindex = \relax
!   \let\defivar = \relax
!   \let\defmac = \relax
!   \let\defmethod = \relax
!   \let\defop = \relax
!   \let\defopt = \relax
!   \let\defspec = \relax
!   \let\deftp = \relax
!   \let\deftypefn = \relax
!   \let\deftypefun = \relax
!   \let\deftypevar = \relax
!   \let\deftypevr = \relax
!   \let\defun = \relax
!   \let\defvar = \relax
!   \let\defvr = \relax
!   \let\ref = \relax
!   \let\xref = \relax
!   \let\printindex = \relax
!   \let\pxref = \relax
!   \let\settitle = \relax
!   \let\setchapternewpage = \relax
!   \let\setchapterstyle = \relax
!   \let\everyheading = \relax
!   \let\evenheading = \relax
!   \let\oddheading = \relax
!   \let\everyfooting = \relax
!   \let\evenfooting = \relax
!   \let\oddfooting = \relax
!   \let\headings = \relax
!   \let\include = \relax
!   \let\lowersections = \relax
!   \let\down = \relax
!   \let\raisesections = \relax
!   \let\up = \relax
!   \let\set = \relax
!   \let\clear = \relax
!   \let\item = \relax
  }
  
! % Ignore @ignore ... @end ignore.
  %
! \def\ignore{\doignore{ignore}}
  
! % Also ignore @ifinfo, @ifhtml, @html, @menu, and @direntry text.
  %
! \def\ifinfo{\doignore{ifinfo}}
! \def\ifhtml{\doignore{ifhtml}}
! \def\html{\doignore{html}}
! \def\menu{\doignore{menu}}
! \def\direntry{\doignore{direntry}}
! 
! % Also ignore @macro ... @end macro.  The user must run texi2dvi,
! % which runs makeinfo to do macro expansion.  Ignore @unmacro, too.
! \def\macro{\doignore{macro}}
! \let\unmacro = \comment
  
  
! % @dircategory CATEGORY  -- specify a category of the dir file
! % which this file should belong to.  Ignore this in TeX.
! \let\dircategory = \comment
  
! % Ignore text until a line `@end #1'.
  %
! \def\doignore#1{\begingroup
!   % Don't complain about control sequences we have declared \outer.
!   \ignoresections
!   %
!   % Define a command to swallow text until we reach `@end #1'.
!   \long\def\doignoretext##1\end #1{\enddoignore}%
!   %
!   % Make sure that spaces turn into tokens that match what \doignoretext wants.
!   \catcode32 = 10
!   %
!   % And now expand that command.
!   \doignoretext
  }
  
! % What we do to finish off ignored text.
  %
! \def\enddoignore{\endgroup\ignorespaces}%
  
! \newif\ifwarnedobs\warnedobsfalse
! \def\obstexwarn{%
!   \ifwarnedobs\relax\else
!   % We need to warn folks that they may have trouble with TeX 3.0.
!   % This uses \immediate\write16 rather than \message to get newlines.
!     \immediate\write16{}
!     \immediate\write16{***WARNING*** for users of Unix TeX 3.0!}
!     \immediate\write16{This manual trips a bug in TeX version 3.0 (tex hangs).}
!     \immediate\write16{If you are running another version of TeX, relax.}
!     \immediate\write16{If you are running Unix TeX 3.0, kill this TeX process.}
!     \immediate\write16{  Then upgrade your TeX installation if you can.}
!     \immediate\write16{  (See ftp://ftp.gnu.ai.mit.edu/pub/gnu/TeX.README.)}
!     \immediate\write16{If you are stuck with version 3.0, run the}
!     \immediate\write16{  script ``tex3patch'' from the Texinfo distribution}
!     \immediate\write16{  to use a workaround.}
!     \immediate\write16{}
!     \global\warnedobstrue
      \fi
! }
! 
! % **In TeX 3.0, setting text in \nullfont hangs tex.  For a
! % workaround (which requires the file ``dummy.tfm'' to be installed),
! % uncomment the following line:
! %%%%%\font\nullfont=dummy\let\obstexwarn=\relax
! 
! % Ignore text, except that we keep track of conditional commands for
! % purposes of nesting, up to an `@end #1' command.
! %
! \def\nestedignore#1{%
!   \obstexwarn
!   % We must actually expand the ignored text to look for the @end
!   % command, so that nested ignore constructs work.  Thus, we put the
!   % text into a \vbox and then do nothing with the result.  To minimize
!   % the change of memory overflow, we follow the approach outlined on
!   % page 401 of the TeXbook: make the current font be a dummy font.
!   %
!   \setbox0 = \vbox\bgroup
!     % Don't complain about control sequences we have declared \outer.
!     \ignoresections
!     %
!     % Define `@end #1' to end the box, which will in turn undefine the
!     % @end command again.
!     \expandafter\def\csname E#1\endcsname{\egroup\ignorespaces}%
!     %
!     % We are going to be parsing Texinfo commands.  Most cause no
!     % trouble when they are used incorrectly, but some commands do
!     % complicated argument parsing or otherwise get confused, so we
!     % undefine them.
!     %
!     % We can't do anything about stray @-signs, unfortunately;
!     % they'll produce `undefined control sequence' errors.
!     \ignoremorecommands
!     %
!     % Set the current font to be \nullfont, a TeX primitive, and define
!     % all the font commands to also use \nullfont.  We don't use
!     % dummy.tfm, as suggested in the TeXbook, because not all sites
!     % might have that installed.  Therefore, math mode will still
!     % produce output, but that should be an extremely small amount of
!     % stuff compared to the main input.
!     %
!     \nullfont
!     \let\tenrm = \nullfont  \let\tenit = \nullfont  \let\tensl = \nullfont
!     \let\tenbf = \nullfont  \let\tentt = \nullfont  \let\smallcaps = \nullfont
!     \let\tensf = \nullfont
!     % Similarly for index fonts (mostly for their use in
!     % smallexample)
!     \let\indrm = \nullfont  \let\indit = \nullfont  \let\indsl = \nullfont
!     \let\indbf = \nullfont  \let\indtt = \nullfont  \let\indsc = \nullfont
!     \let\indsf = \nullfont
!     %
!     % Don't complain when characters are missing from the fonts.
!     \tracinglostchars = 0
!     %
!     % Don't bother to do space factor calculations.
!     \frenchspacing
!     %
!     % Don't report underfull hboxes.
!     \hbadness = 10000
!     %
!     % Do minimal line-breaking.
!     \pretolerance = 10000
!     %
!     % Do not execute instructions in @tex
!     \def\tex{\doignore{tex}}
! }
! 
! % @set VAR sets the variable VAR to an empty value.
! % @set VAR REST-OF-LINE sets VAR to the value REST-OF-LINE.
! %
! % Since we want to separate VAR from REST-OF-LINE (which might be
! % empty), we can't just use \parsearg; we have to insert a space of our
! % own to delimit the rest of the line, and then take it out again if we
! % didn't need it.  Make sure the catcode of space is correct to avoid
! % losing inside @example, for instance.
! %
! \def\set{\begingroup\catcode` =10 \parsearg\setxxx}
! \def\setxxx#1{\setyyy#1 \endsetyyy}
! \def\setyyy#1 #2\endsetyyy{%
!   \def\temp{#2}%
!   \ifx\temp\empty \global\expandafter\let\csname SET#1\endcsname = \empty
!   \else \setzzz{#1}#2\endsetzzz % Remove the trailing space \setxxx inserted.
!   \fi
!   \endgroup
! }
! % Can't use \xdef to pre-expand #2 and save some time, since \temp or
! % \next or other control sequences that we've defined might get us into
! % an infinite loop. Consider `@set foo @cite{bar}'.
! \def\setzzz#1#2 \endsetzzz{\expandafter\gdef\csname SET#1\endcsname{#2}}
! 
! % @clear VAR clears (i.e., unsets) the variable VAR.
! %
! \def\clear{\parsearg\clearxxx}
! \def\clearxxx#1{\global\expandafter\let\csname SET#1\endcsname=\relax}
! 
! % @value{foo} gets the text saved in variable foo.
! %
! \def\value#1{\expandafter
!                 \ifx\csname SET#1\endcsname\relax
!                         {\{No value for ``#1''\}}
!                 \else \csname SET#1\endcsname \fi}
! 
! % @ifset VAR ... @end ifset reads the `...' iff VAR has been defined
! % with @set.
! %
! \def\ifset{\parsearg\ifsetxxx}
! \def\ifsetxxx #1{%
!   \expandafter\ifx\csname SET#1\endcsname\relax
!     \expandafter\ifsetfail
!   \else
!     \expandafter\ifsetsucceed
!   \fi
! }
! \def\ifsetsucceed{\conditionalsucceed{ifset}}
! \def\ifsetfail{\nestedignore{ifset}}
! \defineunmatchedend{ifset}
! 
! % @ifclear VAR ... @end ifclear reads the `...' iff VAR has never been
! % defined with @set, or has been undefined with @clear.
! %
! \def\ifclear{\parsearg\ifclearxxx}
! \def\ifclearxxx #1{%
!   \expandafter\ifx\csname SET#1\endcsname\relax
!     \expandafter\ifclearsucceed
!   \else
!     \expandafter\ifclearfail
!   \fi
! }
! \def\ifclearsucceed{\conditionalsucceed{ifclear}}
! \def\ifclearfail{\nestedignore{ifclear}}
! \defineunmatchedend{ifclear}
! 
! % @iftex always succeeds; we read the text following, through @end
! % iftex).  But `@end iftex' should be valid only after an @iftex.
! %
! \def\iftex{\conditionalsucceed{iftex}}
! \defineunmatchedend{iftex}
! 
! % We can't just want to start a group at @iftex (for example) and end it
! % at @end iftex, since then @set commands inside the conditional have no
! % effect (they'd get reverted at the end of the group).  So we must
! % define \Eiftex to redefine itself to be its previous value.  (We can't
! % just define it to fail again with an ``unmatched end'' error, since
! % the @ifset might be nested.)
! %
! \def\conditionalsucceed#1{%
!   \edef\temp{%
!     % Remember the current value of \E#1.
!     \let\nece{prevE#1} = \nece{E#1}%
!     %
!     % At the `@end #1', redefine \E#1 to be its previous value.
!     \def\nece{E#1}{\let\nece{E#1} = \nece{prevE#1}}%
!   }%
!   \temp
! }
! 
! % We need to expand lots of \csname's, but we don't want to expand the
! % control sequences after we've constructed them.
! %
! \def\nece#1{\expandafter\noexpand\csname#1\endcsname}
! 
! % @asis just yields its argument.  Used with @table, for example.
! %
! \def\asis#1{#1}
! 
! % @math means output in math mode.
! % We don't use $'s directly in the definition of \math because control
! % sequences like \math are expanded when the toc file is written.  Then,
! % we read the toc file back, the $'s will be normal characters (as they
! % should be, according to the definition of Texinfo).  So we must use a
! % control sequence to switch into and out of math mode.
! %
! % This isn't quite enough for @math to work properly in indices, but it
! % seems unlikely it will ever be needed there.
! %
! \let\implicitmath = $
! \def\math#1{\implicitmath #1\implicitmath}
! 
! % @bullet and @minus need the same treatment as @math, just above.
! \def\bullet{\implicitmath\ptexbullet\implicitmath}
! \def\minus{\implicitmath-\implicitmath}
! 
! \def\node{\ENVcheck\parsearg\nodezzz}
! \def\nodezzz#1{\nodexxx [#1,]}
! \def\nodexxx[#1,#2]{\gdef\lastnode{#1}}
! \let\nwnode=\node
! \let\lastnode=\relax
! 
! \def\donoderef{\ifx\lastnode\relax\else
! \expandafter\expandafter\expandafter\setref{\lastnode}\fi
! \global\let\lastnode=\relax}
! 
! \def\unnumbnoderef{\ifx\lastnode\relax\else
! \expandafter\expandafter\expandafter\unnumbsetref{\lastnode}\fi
! \global\let\lastnode=\relax}
! 
! \def\appendixnoderef{\ifx\lastnode\relax\else
! \expandafter\expandafter\expandafter\appendixsetref{\lastnode}\fi
! \global\let\lastnode=\relax}
! 
! % @refill is a no-op.
! \let\refill=\relax
! 
! % @setfilename is done at the beginning of every texinfo file.
! % So open here the files we need to have open while reading the input.
! % This makes it possible to make a .fmt file for texinfo.
! \def\setfilename{%
!    \readauxfile
!    \opencontents
!    \openindices
!    \fixbackslash  % Turn off hack to swallow `\input texinfo'.
!    \global\let\setfilename=\comment % Ignore extra @setfilename cmds.
!    \comment % Ignore the actual filename.
! }
! 
! % @bye.
! \outer\def\bye{\pagealignmacro\tracingstats=1\ptexend}
! 
! % \def\macro#1{\begingroup\ignoresections\catcode`\#=6\def\macrotemp{#1}\parsearg\macroxxx}
! % \def\macroxxx#1#2 \end macro{%
! % \expandafter\gdef\macrotemp#1{#2}%
! % \endgroup}
! 
! %\def\linemacro#1{\begingroup\ignoresections\catcode`\#=6\def\macrotemp{#1}\parsearg\linemacroxxx}
! %\def\linemacroxxx#1#2 \end linemacro{%
! %\let\parsearg=\relax
! %\edef\macrotempx{\csname M\butfirst\expandafter\string\macrotemp\endcsname}%
! %\expandafter\xdef\macrotemp{\parsearg\macrotempx}%
! %\expandafter\gdef\macrotempx#1{#2}%
! %\endgroup}
! 
! %\def\butfirst#1{}
  
  
  \message{fonts,}
- 
  % Font-change commands.
  
! % Texinfo supports the sans serif font style, which plain TeX does not.
  % So we set up a \sf analogous to plain's \rm, etc.
  \newfam\sffam
--- 736,1028 ----
  % @ignore ... @end ignore  is another way to write a comment
  
! \def\comment{\begingroup \catcode`\^^M=\other%
! \catcode`\@=\other \catcode`\{=\other \catcode`\}=\other%
! \commentxxx}
! {\catcode`\^^M=\other \gdef\commentxxx#1^^M{\endgroup}}
  
  \let\c=\comment
  
! % @paragraphindent NCHARS
! % We'll use ems for NCHARS, close enough.
! % We cannot implement @paragraphindent asis, though.
! % 
! \def\asisword{asis} % no translation, these are keywords
! \def\noneword{none}
! %
! \def\paragraphindent{\parsearg\doparagraphindent}
! \def\doparagraphindent#1{%
!   \def\temp{#1}%
!   \ifx\temp\asisword
!   \else
!     \ifx\temp\noneword
!       \defaultparindent = 0pt
!     \else
!       \defaultparindent = #1em
!     \fi
!   \fi
!   \parindent = \defaultparindent
  }
  
! % @exampleindent NCHARS
! % We'll use ems for NCHARS like @paragraphindent.
! % It seems @exampleindent asis isn't necessary, but
! % I preserve it to make it similar to @paragraphindent.
! \def\exampleindent{\parsearg\doexampleindent}
! \def\doexampleindent#1{%
!   \def\temp{#1}%
!   \ifx\temp\asisword
!   \else
!     \ifx\temp\noneword
!       \lispnarrowing = 0pt
!     \else
!       \lispnarrowing = #1em
!     \fi
!   \fi
  }
  
! % @asis just yields its argument.  Used with @table, for example.
  %
! \def\asis#1{#1}
  
! % @math means output in math mode.
! % We don't use $'s directly in the definition of \math because control
! % sequences like \math are expanded when the toc file is written.  Then,
! % we read the toc file back, the $'s will be normal characters (as they
! % should be, according to the definition of Texinfo).  So we must use a
! % control sequence to switch into and out of math mode.
  %
! % This isn't quite enough for @math to work properly in indices, but it
! % seems unlikely it will ever be needed there.
! %
! \let\implicitmath = $
! \def\math#1{\implicitmath #1\implicitmath}
  
+ % @bullet and @minus need the same treatment as @math, just above.
+ \def\bullet{\implicitmath\ptexbullet\implicitmath}
+ \def\minus{\implicitmath-\implicitmath}
  
! % @refill is a no-op.
! \let\refill=\relax
  
! % If working on a large document in chapters, it is convenient to
! % be able to disable indexing, cross-referencing, and contents, for test runs.
! % This is done with @novalidate (before @setfilename).
  %
! \newif\iflinks \linkstrue % by default we want the aux files.
! \let\novalidate = \linksfalse
! 
! % @setfilename is done at the beginning of every texinfo file.
! % So open here the files we need to have open while reading the input.
! % This makes it possible to make a .fmt file for texinfo.
! \def\setfilename{%
!    \iflinks
!      \readauxfile
!    \fi % \openindices needs to do some work in any case.
!    \openindices
!    \fixbackslash  % Turn off hack to swallow `\input texinfo'.
!    \global\let\setfilename=\comment % Ignore extra @setfilename cmds.
!    %
!    % If texinfo.cnf is present on the system, read it.
!    % Useful for site-wide @afourpaper, etc.
!    % Just to be on the safe side, close the input stream before the \input.
!    \openin 1 texinfo.cnf
!    \ifeof1 \let\temp=\relax \else \def\temp{\input texinfo.cnf }\fi
!    \closein1
!    \temp
!    %
!    \comment % Ignore the actual filename.
  }
  
! % Called from \setfilename.
  %
! \def\openindices{%
!   \newindex{cp}%
!   \newcodeindex{fn}%
!   \newcodeindex{vr}%
!   \newcodeindex{tp}%
!   \newcodeindex{ky}%
!   \newcodeindex{pg}%
! }
  
! % @bye.
! \outer\def\bye{\pagealignmacro\tracingstats=1\ptexend}
! 
! 
! \message{pdf,}
! % adobe `portable' document format
! \newcount\tempnum
! \newcount\lnkcount
! \newtoks\filename
! \newcount\filenamelength
! \newcount\pgn
! \newtoks\toksA
! \newtoks\toksB
! \newtoks\toksC
! \newtoks\toksD
! \newbox\boxA
! \newcount\countA
! \newif\ifpdf
! \newif\ifpdfmakepagedest
! 
! \ifx\pdfoutput\undefined
!   \pdffalse
!   \let\pdfmkdest = \gobble
!   \let\pdfurl = \gobble
!   \let\endlink = \relax
!   \let\linkcolor = \relax
!   \let\pdfmakeoutlines = \relax
! \else
!   \pdftrue
!   \pdfoutput = 1
!   \input pdfcolor
!   \def\dopdfimage#1#2#3{%
!     \def\imagewidth{#2}%
!     \def\imageheight{#3}%
!     \ifnum\pdftexversion < 14
!       \pdfimage
!     \else
!       \pdfximage
      \fi
!       \ifx\empty\imagewidth\else width \imagewidth \fi
!       \ifx\empty\imageheight\else height \imageheight \fi
!       {#1.pdf}%
!     \ifnum\pdftexversion < 14 \else
!       \pdfrefximage \pdflastximage
!     \fi}
!   \def\pdfmkdest#1{\pdfdest name{#1@} xyz}
!   \def\pdfmkpgn#1{#1@}
!   \let\linkcolor = \Cyan
!   \def\endlink{\Black\pdfendlink}
!   % Adding outlines to PDF; macros for calculating structure of outlines
!   % come from Petr Olsak
!   \def\expnumber#1{\expandafter\ifx\csname#1\endcsname\relax 0%
!     \else \csname#1\endcsname \fi}
!   \def\advancenumber#1{\tempnum=\expnumber{#1}\relax
!     \advance\tempnum by1
!     \expandafter\xdef\csname#1\endcsname{\the\tempnum}}
!   \def\pdfmakeoutlines{{%
!     \openin 1 \jobname.toc
!     \ifeof 1\else\bgroup
!       \closein 1 
!       \indexnofonts
!       \def\tt{}
!       % thanh's hack / proper braces in bookmarks  
!       \edef\mylbrace{\iftrue \string{\else}\fi}\let\{=\mylbrace
!       \edef\myrbrace{\iffalse{\else\string}\fi}\let\}=\myrbrace
!       %
!       \def\chapentry ##1##2##3{}
!       \def\unnumbchapentry ##1##2{}
!       \def\secentry ##1##2##3##4{\advancenumber{chap##2}}
!       \def\unnumbsecentry ##1##2{}
!       \def\subsecentry ##1##2##3##4##5{\advancenumber{sec##2.##3}}
!       \def\unnumbsubsecentry ##1##2{}
!       \def\subsubsecentry ##1##2##3##4##5##6{\advancenumber{subsec##2.##3.##4}}
!       \def\unnumbsubsubsecentry ##1##2{}
!       \input \jobname.toc
!       \def\chapentry ##1##2##3{%
!         \pdfoutline goto name{\pdfmkpgn{##3}}count-\expnumber{chap##2}{##1}}
!       \def\unnumbchapentry ##1##2{%
!         \pdfoutline goto name{\pdfmkpgn{##2}}{##1}}
!       \def\secentry ##1##2##3##4{%
!         \pdfoutline goto name{\pdfmkpgn{##4}}count-\expnumber{sec##2.##3}{##1}}
!       \def\unnumbsecentry ##1##2{%
!         \pdfoutline goto name{\pdfmkpgn{##2}}{##1}}
!       \def\subsecentry ##1##2##3##4##5{%
!         \pdfoutline goto name{\pdfmkpgn{##5}}count-\expnumber{subsec##2.##3.##4}{##1}}
!       \def\unnumbsubsecentry ##1##2{%
!         \pdfoutline goto name{\pdfmkpgn{##2}}{##1}}
!       \def\subsubsecentry ##1##2##3##4##5##6{%
!         \pdfoutline goto name{\pdfmkpgn{##6}}{##1}}
!       \def\unnumbsubsubsecentry ##1##2{%
!         \pdfoutline goto name{\pdfmkpgn{##2}}{##1}}
!       \input \jobname.toc
!     \egroup\fi
!   }}
!   \def\makelinks #1,{%
!     \def\params{#1}\def\E{END}%
!     \ifx\params\E
!       \let\nextmakelinks=\relax
!     \else
!       \let\nextmakelinks=\makelinks
!       \ifnum\lnkcount>0,\fi
!       \picknum{#1}%
!       \startlink attr{/Border [0 0 0]} 
!         goto name{\pdfmkpgn{\the\pgn}}%
!       \linkcolor #1%
!       \advance\lnkcount by 1%
!       \endlink
!     \fi
!     \nextmakelinks
!   }
!   \def\picknum#1{\expandafter\pn#1}
!   \def\pn#1{%
!     \def\p{#1}%
!     \ifx\p\lbrace
!       \let\nextpn=\ppn
!     \else
!       \let\nextpn=\ppnn
!       \def\first{#1}
!     \fi
!     \nextpn
!   }
!   \def\ppn#1{\pgn=#1\gobble}
!   \def\ppnn{\pgn=\first}
!   \def\pdfmklnk#1{\lnkcount=0\makelinks #1,END,}
!   \def\addtokens#1#2{\edef\addtoks{\noexpand#1={\the#1#2}}\addtoks}
!   \def\skipspaces#1{\def\PP{#1}\def\D{|}%
!     \ifx\PP\D\let\nextsp\relax
!     \else\let\nextsp\skipspaces
!       \ifx\p\space\else\addtokens{\filename}{\PP}%
!         \advance\filenamelength by 1
!       \fi
!     \fi
!     \nextsp}
!   \def\getfilename#1{\filenamelength=0\expandafter\skipspaces#1|\relax}
!   \ifnum\pdftexversion < 14
!     \let \startlink \pdfannotlink
!   \else
!     \let \startlink \pdfstartlink
!   \fi
!   \def\pdfurl#1{%
!     \begingroup
!       \normalturnoffactive\def\@{@}%
!       \leavevmode\Red
!       \startlink attr{/Border [0 0 0]}%
!         user{/Subtype /Link /A << /S /URI /URI (#1) >>}%
!         % #1
!     \endgroup}
!   \def\pdfgettoks#1.{\setbox\boxA=\hbox{\toksA={#1.}\toksB={}\maketoks}}
!   \def\addtokens#1#2{\edef\addtoks{\noexpand#1={\the#1#2}}\addtoks}
!   \def\adn#1{\addtokens{\toksC}{#1}\global\countA=1\let\next=\maketoks}
!   \def\poptoks#1#2|ENDTOKS|{\let\first=#1\toksD={#1}\toksA={#2}}
!   \def\maketoks{%
!     \expandafter\poptoks\the\toksA|ENDTOKS|
!     \ifx\first0\adn0
!     \else\ifx\first1\adn1 \else\ifx\first2\adn2 \else\ifx\first3\adn3
!     \else\ifx\first4\adn4 \else\ifx\first5\adn5 \else\ifx\first6\adn6
!     \else\ifx\first7\adn7 \else\ifx\first8\adn8 \else\ifx\first9\adn9 
!     \else
!       \ifnum0=\countA\else\makelink\fi
!       \ifx\first.\let\next=\done\else
!         \let\next=\maketoks
!         \addtokens{\toksB}{\the\toksD}
!         \ifx\first,\addtokens{\toksB}{\space}\fi
!       \fi
!     \fi\fi\fi\fi\fi\fi\fi\fi\fi\fi
!     \next}
!   \def\makelink{\addtokens{\toksB}%
!     {\noexpand\pdflink{\the\toksC}}\toksC={}\global\countA=0}
!   \def\pdflink#1{%
!     \startlink attr{/Border [0 0 0]} goto name{\mkpgn{#1}}
!     \linkcolor #1\endlink}
!   \def\mkpgn#1{#1@} 
!   \def\done{\edef\st{\global\noexpand\toksA={\the\toksB}}\st}
! \fi % \ifx\pdfoutput
  
  
  \message{fonts,}
  % Font-change commands.
  
! % Texinfo sort of supports the sans serif font style, which plain TeX does not.
  % So we set up a \sf analogous to plain's \rm, etc.
  \newfam\sffam
***************
*** 1022,1027 ****
  \def\ttsl{\tenttsl}
  
! %% Try out Computer Modern fonts at \magstephalf
! \let\mainmagstep=\magstephalf
  
  % Set the font macro #1 to the font named #2, adding on the
--- 1033,1039 ----
  \def\ttsl{\tenttsl}
  
! % Use Computer Modern fonts at \magstephalf (11pt).
! \newcount\mainmagstep
! \mainmagstep=\magstephalf
  
  % Set the font macro #1 to the font named #2, adding on the
***************
*** 1078,1097 ****
  \def\df{\let\tentt=\deftt \let\tenbf = \defbf \bf}
  
! % Fonts for indices and small examples (9pt).
! % We actually use the slanted font rather than the italic,
! % because texinfo normally uses the slanted fonts for that.
! % Do not make many font distinctions in general in the index, since they
! % aren't very useful.
! \setfont\ninett\ttshape{9}{1000}
! \setfont\indrm\rmshape{9}{1000}
! \setfont\indit\slshape{9}{1000}
! \let\indsl=\indit
! \let\indtt=\ninett
! \let\indttsl=\ninett
! \let\indsf=\indrm
! \let\indbf=\indrm
! \setfont\indsc\scshape{10}{900}
! \font\indi=cmmi9
! \font\indsy=cmsy9
  
  % Chapter (and unnumbered) fonts (17.28pt).
--- 1090,1117 ----
  \def\df{\let\tentt=\deftt \let\tenbf = \defbf \bf}
  
! % Fonts for indices, footnotes, small examples (9pt).
! \setfont\smallrm\rmshape{9}{1000}
! \setfont\smalltt\ttshape{9}{1000}
! \setfont\smallbf\bfshape{10}{900}
! \setfont\smallit\itshape{9}{1000}
! \setfont\smallsl\slshape{9}{1000}
! \setfont\smallsf\sfshape{9}{1000}
! \setfont\smallsc\scshape{10}{900}
! \setfont\smallttsl\ttslshape{10}{900}
! \font\smalli=cmmi9
! \font\smallsy=cmsy9
! 
! % Fonts for title page:
! \setfont\titlerm\rmbshape{12}{\magstep3}
! \setfont\titleit\itbshape{10}{\magstep4}
! \setfont\titlesl\slbshape{10}{\magstep4}
! \setfont\titlett\ttbshape{12}{\magstep3}
! \setfont\titlettsl\ttslshape{10}{\magstep4}
! \setfont\titlesf\sfbshape{17}{\magstep1}
! \let\titlebf=\titlerm
! \setfont\titlesc\scbshape{10}{\magstep4}
! \font\titlei=cmmi12 scaled \magstep3
! \font\titlesy=cmsy10 scaled \magstep4
! \def\authorrm{\secrm}
  
  % Chapter (and unnumbered) fonts (17.28pt).
***************
*** 1101,1105 ****
  \setfont\chaptt\ttbshape{12}{\magstep2}
  \setfont\chapttsl\ttslshape{10}{\magstep3}
! \setfont\chapsf\sfbshape{12}{\magstep2}
  \let\chapbf=\chaprm
  \setfont\chapsc\scbshape{10}{\magstep3}
--- 1121,1125 ----
  \setfont\chaptt\ttbshape{12}{\magstep2}
  \setfont\chapttsl\ttslshape{10}{\magstep3}
! \setfont\chapsf\sfbshape{17}{1000}
  \let\chapbf=\chaprm
  \setfont\chapsc\scbshape{10}{\magstep3}
***************
*** 1138,1154 ****
  \setfont\ssecsl\slbshape{10}{1315}
  \setfont\ssectt\ttbshape{12}{\magstephalf}
! \setfont\ssecttsl\ttslshape{10}{\magstep1}
  \setfont\ssecsf\sfbshape{12}{\magstephalf}
  \let\ssecbf\ssecrm
  \setfont\ssecsc\scbshape{10}{\magstep1}
  \font\sseci=cmmi12 scaled \magstephalf
! \font\ssecsy=cmsy10 scaled \magstep1
  % The smallcaps and symbol fonts should actually be scaled \magstep1.5,
  % but that is not a standard magnification.
  
- % Fonts for title page:
- \setfont\titlerm\rmbshape{12}{\magstep3}
- \let\authorrm = \secrm
- 
  % In order for the font changes to affect most math symbols and letters,
  % we have to define the \textfont of the standard families.  Since
--- 1158,1170 ----
  \setfont\ssecsl\slbshape{10}{1315}
  \setfont\ssectt\ttbshape{12}{\magstephalf}
! \setfont\ssecttsl\ttslshape{10}{1315}
  \setfont\ssecsf\sfbshape{12}{\magstephalf}
  \let\ssecbf\ssecrm
  \setfont\ssecsc\scbshape{10}{\magstep1}
  \font\sseci=cmmi12 scaled \magstephalf
! \font\ssecsy=cmsy10 scaled 1315
  % The smallcaps and symbol fonts should actually be scaled \magstep1.5,
  % but that is not a standard magnification.
  
  % In order for the font changes to affect most math symbols and letters,
  % we have to define the \textfont of the standard families.  Since
***************
*** 1175,1178 ****
--- 1191,1201 ----
    \let\tensf=\textsf \let\teni=\texti \let\tensy=\textsy \let\tenttsl=\textttsl
    \resetmathfonts}
+ \def\titlefonts{%
+   \let\tenrm=\titlerm \let\tenit=\titleit \let\tensl=\titlesl
+   \let\tenbf=\titlebf \let\tentt=\titlett \let\smallcaps=\titlesc
+   \let\tensf=\titlesf \let\teni=\titlei \let\tensy=\titlesy
+   \let\tenttsl=\titlettsl
+   \resetmathfonts \setleading{25pt}}
+ \def\titlefont#1{{\titlefonts\rm #1}}
  \def\chapfonts{%
    \let\tenrm=\chaprm \let\tenit=\chapit \let\tensl=\chapsl
***************
*** 1191,1199 ****
    \resetmathfonts \setleading{15pt}}
  \let\subsubsecfonts = \subsecfonts % Maybe make sssec fonts scaled magstephalf?
! \def\indexfonts{%
!   \let\tenrm=\indrm \let\tenit=\indit \let\tensl=\indsl
!   \let\tenbf=\indbf \let\tentt=\indtt \let\smallcaps=\indsc
!   \let\tensf=\indsf \let\teni=\indi \let\tensy=\indsy \let\tenttsl=\indttsl
!   \resetmathfonts \setleading{12pt}}
  
  % Set up the default fonts, so we can use them for creating boxes.
--- 1214,1223 ----
    \resetmathfonts \setleading{15pt}}
  \let\subsubsecfonts = \subsecfonts % Maybe make sssec fonts scaled magstephalf?
! \def\smallfonts{%
!   \let\tenrm=\smallrm \let\tenit=\smallit \let\tensl=\smallsl
!   \let\tenbf=\smallbf \let\tentt=\smalltt \let\smallcaps=\smallsc
!   \let\tensf=\smallsf \let\teni=\smalli \let\tensy=\smallsy
!   \let\tenttsl=\smallttsl
!   \resetmathfonts \setleading{11pt}}
  
  % Set up the default fonts, so we can use them for creating boxes.
***************
*** 1201,1204 ****
--- 1225,1232 ----
  \textfonts
  
+ % Define these so they can be easily changed for other fonts.
+ \def\angleleft{$\langle$}
+ \def\angleright{$\rangle$}
+ 
  % Count depth in font-changes, for error checks
  \newcount\fontdepth \fontdepth=0
***************
*** 1215,1225 ****
  % unless the following character is such as not to need one.
  \def\smartitalicx{\ifx\next,\else\ifx\next-\else\ifx\next.\else\/\fi\fi\fi}
! \def\smartitalic#1{{\sl #1}\futurelet\next\smartitalicx}
  
  \let\i=\smartitalic
! \let\var=\smartitalic
! \let\dfn=\smartitalic
  \let\emph=\smartitalic
! \let\cite=\smartitalic
  
  \def\b#1{{\bf #1}}
--- 1243,1254 ----
  % unless the following character is such as not to need one.
  \def\smartitalicx{\ifx\next,\else\ifx\next-\else\ifx\next.\else\/\fi\fi\fi}
! \def\smartslanted#1{{\sl #1}\futurelet\next\smartitalicx}
! \def\smartitalic#1{{\it #1}\futurelet\next\smartitalicx}
  
  \let\i=\smartitalic
! \let\var=\smartslanted
! \let\dfn=\smartslanted
  \let\emph=\smartitalic
! \let\cite=\smartslanted
  
  \def\b#1{{\bf #1}}
***************
*** 1238,1257 ****
  }
  \let\ttfont=\t
! \def\samp #1{`\tclose{#1}'\null}
! \setfont\smallrm\rmshape{8}{1000}
! \font\smallsy=cmsy9
! \def\key#1{{\smallrm\textfont2=\smallsy \leavevmode\hbox{%
!   \raise0.4pt\hbox{$\langle$}\kern-.08em\vtop{%
      \vbox{\hrule\kern-0.4pt
!      \hbox{\raise0.4pt\hbox{\vphantom{$\langle$}}#1}}%
      \kern-0.4pt\hrule}%
!   \kern-.06em\raise0.4pt\hbox{$\rangle$}}}}
  % The old definition, with no lozenge:
  %\def\key #1{{\ttsl \nohyphenation \uppercase{#1}}\null}
  \def\ctrl #1{{\tt \rawbackslash \hat}#1}
  
  \let\file=\samp
! \let\url=\samp % perhaps include a hypertex \special eventually
! \def\email#1{$\langle${\tt #1}$\rangle$}
  
  % @code is a modification of @t,
--- 1267,1286 ----
  }
  \let\ttfont=\t
! \def\samp#1{`\tclose{#1}'\null}
! \setfont\keyrm\rmshape{8}{1000}
! \font\keysy=cmsy9
! \def\key#1{{\keyrm\textfont2=\keysy \leavevmode\hbox{%
!   \raise0.4pt\hbox{\angleleft}\kern-.08em\vtop{%
      \vbox{\hrule\kern-0.4pt
!      \hbox{\raise0.4pt\hbox{\vphantom{\angleleft}}#1}}%
      \kern-0.4pt\hrule}%
!   \kern-.06em\raise0.4pt\hbox{\angleright}}}}
  % The old definition, with no lozenge:
  %\def\key #1{{\ttsl \nohyphenation \uppercase{#1}}\null}
  \def\ctrl #1{{\tt \rawbackslash \hat}#1}
  
+ % @file, @option are the same as @samp.
  \let\file=\samp
! \let\option=\samp
  
  % @code is a modification of @t,
***************
*** 1288,1305 ****
  %  -- rms.
  {
! \catcode`\-=\active
! \catcode`\_=\active
! \global\def\code{\begingroup \catcode`\-=\active \let-\codedash \catcode`\_=\active \let_\codeunder \codex}
! % The following is used by \doprintindex to insure that long function names
! % wrap around.  It is necessary for - and _ to be active before the index is
! % read from the file, as \entry parses the arguments long before \code is
! % ever called.  -- mycroft
! \global\def\indexbreaks{\catcode`\-=\active \let-\realdash \catcode`\_=\active \let_\realunder}
  }
  
  \def\realdash{-}
- \def\realunder{_}
  \def\codedash{-\discretionary{}{}{}}
! \def\codeunder{\normalunderscore\discretionary{}{}{}}
  \def\codex #1{\tclose{#1}\endgroup}
  
--- 1317,1337 ----
  %  -- rms.
  {
!   \catcode`\-=\active
!   \catcode`\_=\active
!   %
!   \global\def\code{\begingroup
!     \catcode`\-=\active \let-\codedash
!     \catcode`\_=\active \let_\codeunder
!     \codex
!   }
!   %
!   % If we end up with any active - characters when handling the index,
!   % just treat them as a normal -.
!   \global\def\indexbreaks{\catcode`\-=\active \let-\realdash}
  }
  
  \def\realdash{-}
  \def\codedash{-\discretionary{}{}{}}
! \def\codeunder{\ifusingtt{\normalunderscore\discretionary{}{}{}}{\_}}
  \def\codex #1{\tclose{#1}\endgroup}
  
***************
*** 1308,1317 ****
  % @kbd is like @code, except that if the argument is just one @key command,
  % then @kbd has no effect.
! %
  \def\xkey{\key}
  \def\kbdfoo#1#2#3\par{\def\one{#1}\def\three{#3}\def\threex{??}%
  \ifx\one\xkey\ifx\threex\three \key{#2}%
! \else{\tclose{\ttsl\look}}\fi
! \else{\tclose{\ttsl\look}}\fi}
  
  % Check if we are currently using a typewriter font.  Since all the
--- 1340,1421 ----
  % @kbd is like @code, except that if the argument is just one @key command,
  % then @kbd has no effect.
! 
! % @kbdinputstyle -- arg is `distinct' (@kbd uses slanted tty font always),
! %   `example' (@kbd uses ttsl only inside of @example and friends),
! %   or `code' (@kbd uses normal tty font always).
! \def\kbdinputstyle{\parsearg\kbdinputstylexxx}
! \def\kbdinputstylexxx#1{%
!   \def\arg{#1}%
!   \ifx\arg\worddistinct
!     \gdef\kbdexamplefont{\ttsl}\gdef\kbdfont{\ttsl}%
!   \else\ifx\arg\wordexample
!     \gdef\kbdexamplefont{\ttsl}\gdef\kbdfont{\tt}%
!   \else\ifx\arg\wordcode
!     \gdef\kbdexamplefont{\tt}\gdef\kbdfont{\tt}%
!   \fi\fi\fi
! }
! \def\worddistinct{distinct}
! \def\wordexample{example}
! \def\wordcode{code}
! 
! % Default is kbdinputdistinct.  (Too much of a hassle to call the macro,
! % the catcodes are wrong for parsearg to work.)
! \gdef\kbdexamplefont{\ttsl}\gdef\kbdfont{\ttsl}
! 
  \def\xkey{\key}
  \def\kbdfoo#1#2#3\par{\def\one{#1}\def\three{#3}\def\threex{??}%
  \ifx\one\xkey\ifx\threex\three \key{#2}%
! \else{\tclose{\kbdfont\look}}\fi
! \else{\tclose{\kbdfont\look}}\fi}
! 
! % For @url, @env, @command quotes seem unnecessary, so use \code.
! \let\url=\code
! \let\env=\code
! \let\command=\code
! 
! % @uref (abbreviation for `urlref') takes an optional (comma-separated)
! % second argument specifying the text to display and an optional third
! % arg as text to display instead of (rather than in addition to) the url
! % itself.  First (mandatory) arg is the url.  Perhaps eventually put in
! % a hypertex \special here.
! %
! \def\uref#1{\douref #1,,,\finish}
! \def\douref#1,#2,#3,#4\finish{\begingroup
!   \unsepspaces
!   \pdfurl{#1}%
!   \setbox0 = \hbox{\ignorespaces #3}%
!   \ifdim\wd0 > 0pt
!     \unhbox0 % third arg given, show only that
!   \else
!     \setbox0 = \hbox{\ignorespaces #2}%
!     \ifdim\wd0 > 0pt
!       \ifpdf
!         \unhbox0             % PDF: 2nd arg given, show only it
!       \else
!         \unhbox0\ (\code{#1})% DVI: 2nd arg given, show both it and url
!       \fi
!     \else
!       \code{#1}% only url given, so show it
!     \fi
!   \fi
!   \endlink
! \endgroup}
! 
! % rms does not like angle brackets --karl, 17may97.
! % So now @email is just like @uref, unless we are pdf.
! % 
! %\def\email#1{\angleleft{\tt #1}\angleright}
! \ifpdf
!   \def\email#1{\doemail#1,,\finish}
!   \def\doemail#1,#2,#3\finish{\begingroup
!     \unsepspaces
!     \pdfurl{mailto:#1}%
!     \setbox0 = \hbox{\ignorespaces #2}%
!     \ifdim\wd0>0pt\unhbox0\else\code{#1}\fi
!     \endlink
!   \endgroup}
! \else
!   \let\email=\uref
! \fi
  
  % Check if we are currently using a typewriter font.  Since all the
***************
*** 1319,1328 ****
  % shrink), and it is reasonable to expect all typewriter fonts to have
  % this property, we can check that font parameter.
! % 
  \def\ifmonospace{\ifdim\fontdimen3\font=0pt }
  
  % Typeset a dimension, e.g., `in' or `pt'.  The only reason for the
! % argument is to make the input look right: @dmn{pt} instead of
! % @dmn{}pt.
  %
  \def\dmn#1{\thinspace #1}
--- 1423,1431 ----
  % shrink), and it is reasonable to expect all typewriter fonts to have
  % this property, we can check that font parameter.
! %
  \def\ifmonospace{\ifdim\fontdimen3\font=0pt }
  
  % Typeset a dimension, e.g., `in' or `pt'.  The only reason for the
! % argument is to make the input look right: @dmn{pt} instead of @dmn{}pt.
  %
  \def\dmn#1{\thinspace #1}
***************
*** 1335,1343 ****
  %\def\l#1{{\li #1}\null}
  
  \def\r#1{{\rm #1}}              % roman font
- % Use of \lowercase was suggested.
  \def\sc#1{{\smallcaps#1}}       % smallcaps font
  \def\ii#1{{\it #1}}             % italic font
  
  % @pounds{} is a sterling sign.
  \def\pounds{{\it\$}}
--- 1438,1449 ----
  %\def\l#1{{\li #1}\null}
  
+ % Explicit font changes: @r, @sc, undocumented @ii.
  \def\r#1{{\rm #1}}              % roman font
  \def\sc#1{{\smallcaps#1}}       % smallcaps font
  \def\ii#1{{\it #1}}             % italic font
  
+ % @acronym downcases the argument and prints in smallcaps.
+ \def\acronym#1{{\smallcaps \lowercase{#1}}}
+ 
  % @pounds{} is a sterling sign.
  \def\pounds{{\it\$}}
***************
*** 1350,1358 ****
  
  % First the title page.  Must do @settitle before @titlepage.
- \def\titlefont#1{{\titlerm #1}}
- 
  \newif\ifseenauthor
  \newif\iffinishedtitlepage
  
  \def\shorttitlepage{\parsearg\shorttitlepagezzz}
  \def\shorttitlepagezzz #1{\begingroup\hbox{}\vskip 1.5in \chaprm \centerline{#1}%
--- 1456,1470 ----
  
  % First the title page.  Must do @settitle before @titlepage.
  \newif\ifseenauthor
  \newif\iffinishedtitlepage
  
+ % Do an implicit @contents or @shortcontents after @end titlepage if the
+ % user says @setcontentsaftertitlepage or @setshortcontentsaftertitlepage.
+ %
+ \newif\ifsetcontentsaftertitlepage
+  \let\setcontentsaftertitlepage = \setcontentsaftertitlepagetrue
+ \newif\ifsetshortcontentsaftertitlepage
+  \let\setshortcontentsaftertitlepage = \setshortcontentsaftertitlepagetrue
+ 
  \def\shorttitlepage{\parsearg\shorttitlepagezzz}
  \def\shorttitlepagezzz #1{\begingroup\hbox{}\vskip 1.5in \chaprm \centerline{#1}%
***************
*** 1361,1367 ****
  \def\titlepage{\begingroup \parindent=0pt \textfonts
     \let\subtitlerm=\tenrm
- % I deinstalled the following change because \cmr12 is undefined.
- % This change was not in the ChangeLog anyway.  --rms.
- %   \let\subtitlerm=\cmr12
     \def\subtitlefont{\subtitlerm \normalbaselineskip = 13pt \normalbaselines}%
     %
--- 1473,1476 ----
***************
*** 1373,1377 ****
     % Now you can print the title using @title.
     \def\title{\parsearg\titlezzz}%
!    \def\titlezzz##1{\leftline{\titlefont{##1}}
                      % print a rule at the page bottom also.
                      \finishedtitlepagefalse
--- 1482,1486 ----
     % Now you can print the title using @title.
     \def\title{\parsearg\titlezzz}%
!    \def\titlezzz##1{\leftline{\titlefonts\rm ##1}
                      % print a rule at the page bottom also.
                      \finishedtitlepagefalse
***************
*** 1412,1415 ****
--- 1521,1541 ----
     \oldpage
     \endgroup
+    %
+    % If they want short, they certainly want long too.
+    \ifsetshortcontentsaftertitlepage
+      \shortcontents
+      \contents
+      \global\let\shortcontents = \relax
+      \global\let\contents = \relax
+    \fi
+    %
+    \ifsetcontentsaftertitlepage
+      \contents
+      \global\let\contents = \relax
+      \global\let\shortcontents = \relax
+    \fi
+    %
+    \ifpdf \pdfmakepagedesttrue \fi
+    %
     \HEADINGSon
  }
***************
*** 1425,1432 ****
  \let\thispage=\folio
  
! \newtoks \evenheadline    % Token sequence for heading line of even pages
! \newtoks \oddheadline     % Token sequence for heading line of odd pages
! \newtoks \evenfootline    % Token sequence for footing line of even pages
! \newtoks \oddfootline     % Token sequence for footing line of odd pages
  
  % Now make Tex use those variables
--- 1551,1558 ----
  \let\thispage=\folio
  
! \newtoks\evenheadline    % headline on even pages
! \newtoks\oddheadline     % headline on odd pages
! \newtoks\evenfootline    % footline on even pages
! \newtoks\oddfootline     % footline on odd pages
  
  % Now make Tex use those variables
***************
*** 1462,1469 ****
  \global\oddheadline={\rlap{\centerline{#2}}\line{#1\hfil#3}}}
  
! \gdef\everyheadingxxx #1{\everyheadingyyy #1@|@|@|@|\finish}
! \gdef\everyheadingyyy #1@|#2@|#3@|#4\finish{%
! \global\evenheadline={\rlap{\centerline{#2}}\line{#1\hfil#3}}
! \global\oddheadline={\rlap{\centerline{#2}}\line{#1\hfil#3}}}
  
  \gdef\evenfootingxxx #1{\evenfootingyyy #1@|@|@|@|\finish}
--- 1588,1592 ----
  \global\oddheadline={\rlap{\centerline{#2}}\line{#1\hfil#3}}}
  
! \gdef\everyheadingxxx#1{\oddheadingxxx{#1}\evenheadingxxx{#1}}%
  
  \gdef\evenfootingxxx #1{\evenfootingyyy #1@|@|@|@|\finish}
***************
*** 1473,1482 ****
  \gdef\oddfootingxxx #1{\oddfootingyyy #1@|@|@|@|\finish}
  \gdef\oddfootingyyy #1@|#2@|#3@|#4\finish{%
! \global\oddfootline={\rlap{\centerline{#2}}\line{#1\hfil#3}}}
  
! \gdef\everyfootingxxx #1{\everyfootingyyy #1@|@|@|@|\finish}
! \gdef\everyfootingyyy #1@|#2@|#3@|#4\finish{%
! \global\evenfootline={\rlap{\centerline{#2}}\line{#1\hfil#3}}
! \global\oddfootline={\rlap{\centerline{#2}}\line{#1\hfil#3}}}
  %
  }% unbind the catcode of @.
--- 1596,1608 ----
  \gdef\oddfootingxxx #1{\oddfootingyyy #1@|@|@|@|\finish}
  \gdef\oddfootingyyy #1@|#2@|#3@|#4\finish{%
!   \global\oddfootline = {\rlap{\centerline{#2}}\line{#1\hfil#3}}%
!   %
!   % Leave some space for the footline.  Hopefully ok to assume
!   % @evenfooting will not be used by itself.
!   \global\advance\pageheight by -\baselineskip
!   \global\advance\vsize by -\baselineskip
! }
  
! \gdef\everyfootingxxx#1{\oddfootingxxx{#1}\evenfootingxxx{#1}}
  %
  }% unbind the catcode of @.
***************
*** 1546,1565 ****
  % Subroutines used in generating headings
  % Produces Day Month Year style of output.
! \def\today{\number\day\space
! \ifcase\month\or
! January\or February\or March\or April\or May\or June\or
! July\or August\or September\or October\or November\or December\fi
! \space\number\year}
! 
! % Use this if you want the Month Day, Year style of output.
! %\def\today{\ifcase\month\or
! %January\or February\or March\or April\or May\or June\or
! %July\or August\or September\or October\or November\or December\fi
! %\space\number\day, \number\year}
! 
! % @settitle line...  specifies the title of the document, for headings
! % It generates no output of its own
  
! \def\thistitle{No Title}
  \def\settitle{\parsearg\settitlezzz}
  \def\settitlezzz #1{\gdef\thistitle{#1}}
--- 1672,1687 ----
  % Subroutines used in generating headings
  % Produces Day Month Year style of output.
! \def\today{%
!   \number\day\space
!   \ifcase\month
!   \or\putwordMJan\or\putwordMFeb\or\putwordMMar\or\putwordMApr
!   \or\putwordMMay\or\putwordMJun\or\putwordMJul\or\putwordMAug
!   \or\putwordMSep\or\putwordMOct\or\putwordMNov\or\putwordMDec
!   \fi
!   \space\number\year}
  
! % @settitle line...  specifies the title of the document, for headings.
! % It generates no output of its own.
! \def\thistitle{\putwordNoTitle}
  \def\settitle{\parsearg\settitlezzz}
  \def\settitlezzz #1{\gdef\thistitle{#1}}
***************
*** 1567,1582 ****
  
  \message{tables,}
- 
- % @tabs -- simple alignment
- 
- % These don't work.  For one thing, \+ is defined as outer.
- % So these macros cannot even be defined.
- 
- %\def\tabs{\parsearg\tabszzz}
- %\def\tabszzz #1{\settabs\+#1\cr}
- %\def\tabline{\parsearg\tablinezzz}
- %\def\tablinezzz #1{\+#1\cr}
- %\def\&{&}
- 
  % Tables -- @table, @ftable, @vtable, @item(x), @kitem(x), @xitem(x).
  
--- 1689,1692 ----
***************
*** 1622,1630 ****
    \nobreak % This prevents a break before @itemx.
    %
-   % Be sure we are not still in the middle of a paragraph.
-   %{\parskip = 0in
-   %\par
-   %}%
-   %
    % If the item text does not fit in the space we have, put it on a line
    % by itself, and do not allow a page break either before or after that
--- 1732,1735 ----
***************
*** 1655,1665 ****
    \else
      % The item text fits into the space.  Start a paragraph, so that the
!     % following text (if any) will end up on the same line.  Since that
!     % text will be indented by \tableindent, we make the item text be in
!     % a zero-width box.
      \noindent
!     \rlap{\hskip -\tableindent\box0}\ignorespaces%
!     \endgroup%
!     \itemxneedsnegativevskiptrue%
    \fi
  }
--- 1760,1774 ----
    \else
      % The item text fits into the space.  Start a paragraph, so that the
!     % following text (if any) will end up on the same line.
      \noindent
!     % Do this with kerns and \unhbox so that if there is a footnote in
!     % the item text, it can migrate to the main vertical list and
!     % eventually be printed.
!     \nobreak\kern-\tableindent
!     \dimen0 = \itemmax  \advance\dimen0 by \itemmargin \advance\dimen0 by -\wd0
!     \unhbox0
!     \nobreak\kern\dimen0
!     \endgroup
!     \itemxneedsnegativevskiptrue
    \fi
  }
***************
*** 1672,1678 ****
  \def\xitemx{\errmessage{@xitemx while not in a table}}
  
! %% Contains a kludge to get @end[description] to work
  \def\description{\tablez{\dontindex}{1}{}{}{}{}}
  
  \def\table{\begingroup\inENV\obeylines\obeyspaces\tablex}
  {\obeylines\obeyspaces%
--- 1781,1788 ----
  \def\xitemx{\errmessage{@xitemx while not in a table}}
  
! % Contains a kludge to get @end[description] to work.
  \def\description{\tablez{\dontindex}{1}{}{}{}{}}
  
+ % @table, @ftable, @vtable.
  \def\table{\begingroup\inENV\obeylines\obeyspaces\tablex}
  {\obeylines\obeyspaces%
***************
*** 1734,1738 ****
  
  \def\itemizezzz #1{%
!   \begingroup % ended by the @end itemsize
    \itemizey {#1}{\Eitemize}
  }
--- 1844,1848 ----
  
  \def\itemizezzz #1{%
!   \begingroup % ended by the @end itemize
    \itemizey {#1}{\Eitemize}
  }
***************
*** 1862,1866 ****
  \advance\itemno by 1
  {\let\par=\endgraf \smallbreak}%
! \ifhmode \errmessage{\in hmode at itemizeitem}\fi
  {\parskip=0in \hskip 0pt
  \hbox to 0pt{\hss \itemcontents\hskip \itemmargin}%
--- 1972,1976 ----
  \advance\itemno by 1
  {\let\par=\endgraf \smallbreak}%
! \ifhmode \errmessage{In hmode at itemizeitem}\fi
  {\parskip=0in \hskip 0pt
  \hbox to 0pt{\hss \itemcontents\hskip \itemmargin}%
***************
*** 1880,1884 ****
  % To make preamble:
  %
! % Either define widths of columns in terms of percent of \hsize: 
  %   @multitable @columnfractions .25 .3 .45
  %   @item ...
--- 1990,1994 ----
  % To make preamble:
  %
! % Either define widths of columns in terms of percent of \hsize:
  %   @multitable @columnfractions .25 .3 .45
  %   @item ...
***************
*** 1889,2073 ****
  
  
! % Or use a template:
! %   @multitable {Column 1 template} {Column 2 template} {Column 3 template}
! %   @item ...
! %   using the widest term desired in each column.
  %
! % For those who want to use more than one line's worth of words in
! % the preamble, break the line within one argument and it
! % will parse correctly, i.e.,
  %
! %     @multitable {Column 1 template} {Column 2 template} {Column 3 
! %      template}
! % Not:
! %     @multitable {Column 1 template} {Column 2 template} 
! %      {Column 3 template}
! 
! % Each new table line starts with @item, each subsequent new column 
! % starts with @tab. Empty columns may be produced by supplying @tab's
! % with nothing between them for as many times as empty columns are needed,
! % ie, @tab@tab@tab will produce two empty columns.
! 
! % @item, @tab, @multitable or @end multitable do not need to be on their
! % own lines, but it will not hurt if they are.
! 
! % Sample multitable:
! 
! %   @multitable {Column 1 template} {Column 2 template} {Column 3 template}
! %   @item first col stuff @tab second col stuff @tab third col
! %   @item 
! %   first col stuff 
! %   @tab 
! %   second col stuff 
! %   @tab 
! %   third col 
! %   @item first col stuff @tab second col stuff 
! %   @tab Many paragraphs of text may be used in any column.
! %     
! %         They will wrap at the width determined by the template.
! %   @item@tab@tab This will be in third column.
! %   @end multitable
! 
! % Default dimensions may be reset by user.
! % @multitableparskip is vertical space between paragraphs in table.
! % @multitableparindent is paragraph indent in table.
! % @multitablecolmargin is horizontal space to be left between columns.
! % @multitablelinespace is space to leave between table items, baseline
! %                                                            to baseline.
! %   0pt means it depends on current normal line spacing.
! 
! %%%%
! % Dimensions 
! 
! \newskip\multitableparskip
! \newskip\multitableparindent
! \newdimen\multitablecolspace
! \newskip\multitablelinespace
! \multitableparskip=0pt
! \multitableparindent=6pt
! \multitablecolspace=12pt
! \multitablelinespace=0pt
! 
! %%%%
! % Macros used to set up halign preamble:
! \let\endsetuptable\relax
! \def\xendsetuptable{\endsetuptable}
! \let\columnfractions\relax
! \def\xcolumnfractions{\columnfractions}
! \newif\ifsetpercent
  
! %% 2/1/96, to allow fractions to be given with more than one digit.
! \def\pickupwholefraction#1 {\global\advance\colcount by1 %
! \expandafter\xdef\csname col\the\colcount\endcsname{.#1\hsize}%
! \setuptable}
  
! \newcount\colcount
! \def\setuptable#1{\def\firstarg{#1}%
! \ifx\firstarg\xendsetuptable\let\go\relax%
! \else
!   \ifx\firstarg\xcolumnfractions\global\setpercenttrue%
    \else
!     \ifsetpercent
!        \let\go\pickupwholefraction   % In this case arg of setuptable
!                                      % is the decimal point before the
!                                      % number given in percent of hsize.
!                                      % We don't need this so we don't use it.
!     \else
!        \global\advance\colcount by1
!        \setbox0=\hbox{#1 }% Add a normal word space as a separator;
!                           % typically that is always in the input, anyway.
!        \expandafter\xdef\csname col\the\colcount\endcsname{\the\wd0}%
!     \fi%
!   \fi%
! \ifx\go\pickupwholefraction\else\let\go\setuptable\fi%
! \fi\go}
! 
! %%%%
! % multitable syntax
! \def\tab{&\hskip1sp\relax} % 2/2/96
!                            % tiny skip here makes sure this column space is
!                            % maintained, even if it is never used.
! 
! 
! %%%%
! % @multitable ... @end multitable definitions:
  
! \def\multitable{\parsearg\dotable}
  
! \def\dotable#1{\bgroup
! \let\item\cr
! \tolerance=9500
! \hbadness=9500
! \setmultitablespacing
! \parskip=\multitableparskip
! \parindent=\multitableparindent
! \overfullrule=0pt
! \global\colcount=0\relax%
! \def\Emultitable{\global\setpercentfalse\global\everycr{}\cr\egroup\egroup}%
!  % To parse everything between @multitable and @item :
! \setuptable#1 \endsetuptable
!  % Need to reset this to 0 after \setuptable.
! \global\colcount=0\relax% 
!  %
!  % This preamble sets up a generic column definition, which will
!  % be used as many times as user calls for columns.
!  % \vtop will set a single line and will also let text wrap and 
!  % continue for many paragraphs if desired.
! \halign\bgroup&\global\advance\colcount by 1\relax%
! \multistrut\vtop{\hsize=\expandafter\csname col\the\colcount\endcsname
!  % In order to keep entries from bumping into each other
!  % we will add a \leftskip of \multitablecolspace to all columns after
!  % the first one.
!  %  If a template has been used, we will add \multitablecolspace 
!  % to the width of each template entry.
!  %  If user has set preamble in terms of percent of \hsize
!  % we will use that dimension as the width of the column, and
!  % the \leftskip will keep entries from bumping into each other.
!  % Table will start at left margin and final column will justify at
!  % right margin.
! \ifnum\colcount=1
! \else
!   \ifsetpercent
    \else
!    % If user has <not> set preamble in terms of percent of \hsize
!    % we will advance \hsize by \multitablecolspace 
!   \advance\hsize by \multitablecolspace
    \fi
-  % In either case we will make \leftskip=\multitablecolspace:
- \leftskip=\multitablecolspace
- \fi
- \noindent##\multistrut}\cr%
-  % \everycr will reset column counter, \colcount, at the end of
-  % each line. Every column  entry will cause \colcount to advance by one. 
-  % The table preamble
-  % looks at the current \colcount to find the correct column width.
- \global\everycr{\noalign{%
- \filbreak%% keeps underfull box messages off when table breaks over pages.
- \global\colcount=0\relax}}
  }
  
! \def\setmultitablespacing{% test to see if user has set \multitablelinespace.
! % If so, do nothing. If not, give it an appropriate dimension based on
! % current baselineskip.
! \ifdim\multitablelinespace=0pt
! %% strut to put in table in case some entry doesn't have descenders,
! %% to keep lines equally spaced
! \let\multistrut = \strut
! %% Test to see if parskip is larger than space between lines of
! %% table. If not, do nothing. 
! %%        If so, set to same dimension as multitablelinespace.
! \else
! \gdef\multistrut{\vrule height\multitablelinespace depth\dp0
! width0pt\relax} \fi
! \ifdim\multitableparskip>\multitablelinespace
! \global\multitableparskip=\multitablelinespace
! \global\advance\multitableparskip-7pt %% to keep parskip somewhat smaller
!                                       %% than skip between lines in the table.
! \fi%
! \ifdim\multitableparskip=0pt
! \global\multitableparskip=\multitablelinespace
! \global\advance\multitableparskip-7pt %% to keep parskip somewhat smaller
!                                       %% than skip between lines in the table.
! \fi}
  
  
--- 1999,2563 ----
  
  
! % Or use a template:
! %   @multitable {Column 1 template} {Column 2 template} {Column 3 template}
! %   @item ...
! %   using the widest term desired in each column.
! %
! % For those who want to use more than one line's worth of words in
! % the preamble, break the line within one argument and it
! % will parse correctly, i.e.,
! %
! %     @multitable {Column 1 template} {Column 2 template} {Column 3
! %      template}
! % Not:
! %     @multitable {Column 1 template} {Column 2 template}
! %      {Column 3 template}
! 
! % Each new table line starts with @item, each subsequent new column
! % starts with @tab. Empty columns may be produced by supplying @tab's
! % with nothing between them for as many times as empty columns are needed,
! % ie, @tab@tab@tab will produce two empty columns.
! 
! % @item, @tab, @multitable or @end multitable do not need to be on their
! % own lines, but it will not hurt if they are.
! 
! % Sample multitable:
! 
! %   @multitable {Column 1 template} {Column 2 template} {Column 3 template}
! %   @item first col stuff @tab second col stuff @tab third col
! %   @item
! %   first col stuff
! %   @tab
! %   second col stuff
! %   @tab
! %   third col
! %   @item first col stuff @tab second col stuff
! %   @tab Many paragraphs of text may be used in any column.
! %
! %         They will wrap at the width determined by the template.
! %   @item@tab@tab This will be in third column.
! %   @end multitable
! 
! % Default dimensions may be reset by user.
! % @multitableparskip is vertical space between paragraphs in table.
! % @multitableparindent is paragraph indent in table.
! % @multitablecolmargin is horizontal space to be left between columns.
! % @multitablelinespace is space to leave between table items, baseline
! %                                                            to baseline.
! %   0pt means it depends on current normal line spacing.
! %
! \newskip\multitableparskip
! \newskip\multitableparindent
! \newdimen\multitablecolspace
! \newskip\multitablelinespace
! \multitableparskip=0pt
! \multitableparindent=6pt
! \multitablecolspace=12pt
! \multitablelinespace=0pt
! 
! % Macros used to set up halign preamble:
! %
! \let\endsetuptable\relax
! \def\xendsetuptable{\endsetuptable}
! \let\columnfractions\relax
! \def\xcolumnfractions{\columnfractions}
! \newif\ifsetpercent
! 
! % #1 is the part of the @columnfraction before the decimal point, which
! % is presumably either 0 or the empty string (but we don't check, we
! % just throw it away).  #2 is the decimal part, which we use as the
! % percent of \hsize for this column.
! \def\pickupwholefraction#1.#2 {%
!   \global\advance\colcount by 1
!   \expandafter\xdef\csname col\the\colcount\endcsname{.#2\hsize}%
!   \setuptable
! }
! 
! \newcount\colcount
! \def\setuptable#1{%
!   \def\firstarg{#1}%
!   \ifx\firstarg\xendsetuptable
!     \let\go = \relax
!   \else
!     \ifx\firstarg\xcolumnfractions
!       \global\setpercenttrue
!     \else
!       \ifsetpercent
!          \let\go\pickupwholefraction
!       \else
!          \global\advance\colcount by 1
!          \setbox0=\hbox{#1\unskip }% Add a normal word space as a separator;
!                             % typically that is always in the input, anyway.
!          \expandafter\xdef\csname col\the\colcount\endcsname{\the\wd0}%
!       \fi
!     \fi
!     \ifx\go\pickupwholefraction
!       % Put the argument back for the \pickupwholefraction call, so
!       % we'll always have a period there to be parsed.
!       \def\go{\pickupwholefraction#1}%
!     \else
!       \let\go = \setuptable
!     \fi%
!   \fi
!   \go
! }
! 
! % This used to have \hskip1sp.  But then the space in a template line is
! % not enough.  That is bad.  So let's go back to just & until we
! % encounter the problem it was intended to solve again.
! % --karl, nathan@acm.org, 20apr99.
! \def\tab{&}
! 
! % @multitable ... @end multitable definitions:
! %
! \def\multitable{\parsearg\dotable}
! \def\dotable#1{\bgroup
!   \vskip\parskip
!   \let\item\crcr
!   \tolerance=9500
!   \hbadness=9500
!   \setmultitablespacing
!   \parskip=\multitableparskip
!   \parindent=\multitableparindent
!   \overfullrule=0pt
!   \global\colcount=0
!   \def\Emultitable{\global\setpercentfalse\cr\egroup\egroup}%
!   %
!   % To parse everything between @multitable and @item:
!   \setuptable#1 \endsetuptable
!   %
!   % \everycr will reset column counter, \colcount, at the end of
!   % each line. Every column entry will cause \colcount to advance by one.
!   % The table preamble
!   % looks at the current \colcount to find the correct column width.
!   \everycr{\noalign{%
!   %
!   % \filbreak%% keeps underfull box messages off when table breaks over pages.
!   % Maybe so, but it also creates really weird page breaks when the table
!   % breaks over pages. Wouldn't \vfil be better?  Wait until the problem
!   % manifests itself, so it can be fixed for real --karl.
!     \global\colcount=0\relax}}%
!   %
!   % This preamble sets up a generic column definition, which will
!   % be used as many times as user calls for columns.
!   % \vtop will set a single line and will also let text wrap and
!   % continue for many paragraphs if desired.
!   \halign\bgroup&\global\advance\colcount by 1\relax
!     \multistrut\vtop{\hsize=\expandafter\csname col\the\colcount\endcsname
!   %
!   % In order to keep entries from bumping into each other
!   % we will add a \leftskip of \multitablecolspace to all columns after
!   % the first one.
!   %
!   % If a template has been used, we will add \multitablecolspace
!   % to the width of each template entry.
!   %
!   % If the user has set preamble in terms of percent of \hsize we will
!   % use that dimension as the width of the column, and the \leftskip
!   % will keep entries from bumping into each other.  Table will start at
!   % left margin and final column will justify at right margin.
!   %
!   % Make sure we don't inherit \rightskip from the outer environment.
!   \rightskip=0pt
!   \ifnum\colcount=1
!     % The first column will be indented with the surrounding text.
!     \advance\hsize by\leftskip
!   \else
!     \ifsetpercent \else
!       % If user has not set preamble in terms of percent of \hsize
!       % we will advance \hsize by \multitablecolspace.
!       \advance\hsize by \multitablecolspace
!     \fi
!    % In either case we will make \leftskip=\multitablecolspace:
!   \leftskip=\multitablecolspace
!   \fi
!   % Ignoring space at the beginning and end avoids an occasional spurious
!   % blank line, when TeX decides to break the line at the space before the
!   % box from the multistrut, so the strut ends up on a line by itself.
!   % For example:
!   % @multitable @columnfractions .11 .89
!   % @item @code{#}
!   % @tab Legal holiday which is valid in major parts of the whole country.
!   % Is automatically provided with highlighting sequences respectively marking
!   % characters.
!   \noindent\ignorespaces##\unskip\multistrut}\cr
! }
! 
! \def\setmultitablespacing{% test to see if user has set \multitablelinespace.
! % If so, do nothing. If not, give it an appropriate dimension based on
! % current baselineskip.
! \ifdim\multitablelinespace=0pt
! \setbox0=\vbox{X}\global\multitablelinespace=\the\baselineskip
! \global\advance\multitablelinespace by-\ht0
! %% strut to put in table in case some entry doesn't have descenders,
! %% to keep lines equally spaced
! \let\multistrut = \strut
! \else
! %% FIXME: what is \box0 supposed to be?
! \gdef\multistrut{\vrule height\multitablelinespace depth\dp0
! width0pt\relax} \fi
! %% Test to see if parskip is larger than space between lines of
! %% table. If not, do nothing.
! %%        If so, set to same dimension as multitablelinespace.
! \ifdim\multitableparskip>\multitablelinespace
! \global\multitableparskip=\multitablelinespace
! \global\advance\multitableparskip-7pt %% to keep parskip somewhat smaller
!                                       %% than skip between lines in the table.
! \fi%
! \ifdim\multitableparskip=0pt
! \global\multitableparskip=\multitablelinespace
! \global\advance\multitableparskip-7pt %% to keep parskip somewhat smaller
!                                       %% than skip between lines in the table.
! \fi}
! 
! 
! \message{conditionals,}
! % Prevent errors for section commands.
! % Used in @ignore and in failing conditionals.
! \def\ignoresections{%
!   \let\chapter=\relax
!   \let\unnumbered=\relax
!   \let\top=\relax
!   \let\unnumberedsec=\relax
!   \let\unnumberedsection=\relax
!   \let\unnumberedsubsec=\relax
!   \let\unnumberedsubsection=\relax
!   \let\unnumberedsubsubsec=\relax
!   \let\unnumberedsubsubsection=\relax
!   \let\section=\relax
!   \let\subsec=\relax
!   \let\subsubsec=\relax
!   \let\subsection=\relax
!   \let\subsubsection=\relax
!   \let\appendix=\relax
!   \let\appendixsec=\relax
!   \let\appendixsection=\relax
!   \let\appendixsubsec=\relax
!   \let\appendixsubsection=\relax
!   \let\appendixsubsubsec=\relax
!   \let\appendixsubsubsection=\relax
!   \let\contents=\relax
!   \let\smallbook=\relax
!   \let\titlepage=\relax
! }
! 
! % Used in nested conditionals, where we have to parse the Texinfo source
! % and so want to turn off most commands, in case they are used
! % incorrectly.
! %
! \def\ignoremorecommands{%
!   \let\defcodeindex = \relax
!   \let\defcv = \relax
!   \let\deffn = \relax
!   \let\deffnx = \relax
!   \let\defindex = \relax
!   \let\defivar = \relax
!   \let\defmac = \relax
!   \let\defmethod = \relax
!   \let\defop = \relax
!   \let\defopt = \relax
!   \let\defspec = \relax
!   \let\deftp = \relax
!   \let\deftypefn = \relax
!   \let\deftypefun = \relax
!   \let\deftypeivar = \relax
!   \let\deftypeop = \relax
!   \let\deftypevar = \relax
!   \let\deftypevr = \relax
!   \let\defun = \relax
!   \let\defvar = \relax
!   \let\defvr = \relax
!   \let\ref = \relax
!   \let\xref = \relax
!   \let\printindex = \relax
!   \let\pxref = \relax
!   \let\settitle = \relax
!   \let\setchapternewpage = \relax
!   \let\setchapterstyle = \relax
!   \let\everyheading = \relax
!   \let\evenheading = \relax
!   \let\oddheading = \relax
!   \let\everyfooting = \relax
!   \let\evenfooting = \relax
!   \let\oddfooting = \relax
!   \let\headings = \relax
!   \let\include = \relax
!   \let\lowersections = \relax
!   \let\down = \relax
!   \let\raisesections = \relax
!   \let\up = \relax
!   \let\set = \relax
!   \let\clear = \relax
!   \let\item = \relax
! }
! 
! % Ignore @ignore ... @end ignore.
! %
! \def\ignore{\doignore{ignore}}
! 
! % Ignore @ifinfo, @ifhtml, @ifnottex, @html, @menu, and @direntry text.
! %
! \def\ifinfo{\doignore{ifinfo}}
! \def\ifhtml{\doignore{ifhtml}}
! \def\ifnottex{\doignore{ifnottex}}
! \def\html{\doignore{html}}
! \def\menu{\doignore{menu}}
! \def\direntry{\doignore{direntry}}
! 
! % @dircategory CATEGORY  -- specify a category of the dir file
! % which this file should belong to.  Ignore this in TeX.
! \let\dircategory = \comment
! 
! % Ignore text until a line `@end #1'.
! %
! \def\doignore#1{\begingroup
!   % Don't complain about control sequences we have declared \outer.
!   \ignoresections
!   %
!   % Define a command to swallow text until we reach `@end #1'.
!   % This @ is a catcode 12 token (that is the normal catcode of @ in
!   % this texinfo.tex file).  We change the catcode of @ below to match.
!   \long\def\doignoretext##1@end #1{\enddoignore}%
!   %
!   % Make sure that spaces turn into tokens that match what \doignoretext wants.
!   \catcode32 = 10
!   %
!   % Ignore braces, too, so mismatched braces don't cause trouble.
!   \catcode`\{ = 9
!   \catcode`\} = 9
!   %
!   % We must not have @c interpreted as a control sequence.
!   \catcode`\@ = 12
!   %
!   % Make the letter c a comment character so that the rest of the line
!   % will be ignored. This way, the document can have (for example)
!   %   @c @end ifinfo
!   % and the @end ifinfo will be properly ignored.
!   % (We've just changed @ to catcode 12.)
!   \catcode`\c = 14
!   %
!   % And now expand that command.
!   \doignoretext
! }
! 
! % What we do to finish off ignored text.
! %
! \def\enddoignore{\endgroup\ignorespaces}%
! 
! \newif\ifwarnedobs\warnedobsfalse
! \def\obstexwarn{%
!   \ifwarnedobs\relax\else
!   % We need to warn folks that they may have trouble with TeX 3.0.
!   % This uses \immediate\write16 rather than \message to get newlines.
!     \immediate\write16{}
!     \immediate\write16{WARNING: for users of Unix TeX 3.0!}
!     \immediate\write16{This manual trips a bug in TeX version 3.0 (tex hangs).}
!     \immediate\write16{If you are running another version of TeX, relax.}
!     \immediate\write16{If you are running Unix TeX 3.0, kill this TeX process.}
!     \immediate\write16{  Then upgrade your TeX installation if you can.}
!     \immediate\write16{  (See ftp://ftp.gnu.org/pub/gnu/TeX.README.)}
!     \immediate\write16{If you are stuck with version 3.0, run the}
!     \immediate\write16{  script ``tex3patch'' from the Texinfo distribution}
!     \immediate\write16{  to use a workaround.}
!     \immediate\write16{}
!     \global\warnedobstrue
!     \fi
! }
! 
! % **In TeX 3.0, setting text in \nullfont hangs tex.  For a
! % workaround (which requires the file ``dummy.tfm'' to be installed),
! % uncomment the following line:
! %%%%%\font\nullfont=dummy\let\obstexwarn=\relax
! 
! % Ignore text, except that we keep track of conditional commands for
! % purposes of nesting, up to an `@end #1' command.
! %
! \def\nestedignore#1{%
!   \obstexwarn
!   % We must actually expand the ignored text to look for the @end
!   % command, so that nested ignore constructs work.  Thus, we put the
!   % text into a \vbox and then do nothing with the result.  To minimize
!   % the change of memory overflow, we follow the approach outlined on
!   % page 401 of the TeXbook: make the current font be a dummy font.
!   %
!   \setbox0 = \vbox\bgroup
!     % Don't complain about control sequences we have declared \outer.
!     \ignoresections
!     %
!     % Define `@end #1' to end the box, which will in turn undefine the
!     % @end command again.
!     \expandafter\def\csname E#1\endcsname{\egroup\ignorespaces}%
!     %
!     % We are going to be parsing Texinfo commands.  Most cause no
!     % trouble when they are used incorrectly, but some commands do
!     % complicated argument parsing or otherwise get confused, so we
!     % undefine them.
!     %
!     % We can't do anything about stray @-signs, unfortunately;
!     % they'll produce `undefined control sequence' errors.
!     \ignoremorecommands
!     %
!     % Set the current font to be \nullfont, a TeX primitive, and define
!     % all the font commands to also use \nullfont.  We don't use
!     % dummy.tfm, as suggested in the TeXbook, because not all sites
!     % might have that installed.  Therefore, math mode will still
!     % produce output, but that should be an extremely small amount of
!     % stuff compared to the main input.
!     %
!     \nullfont
!     \let\tenrm=\nullfont \let\tenit=\nullfont \let\tensl=\nullfont
!     \let\tenbf=\nullfont \let\tentt=\nullfont \let\smallcaps=\nullfont
!     \let\tensf=\nullfont
!     % Similarly for index fonts (mostly for their use in smallexample).
!     \let\smallrm=\nullfont \let\smallit=\nullfont \let\smallsl=\nullfont
!     \let\smallbf=\nullfont \let\smalltt=\nullfont \let\smallsc=\nullfont
!     \let\smallsf=\nullfont
!     %
!     % Don't complain when characters are missing from the fonts.
!     \tracinglostchars = 0
!     %
!     % Don't bother to do space factor calculations.
!     \frenchspacing
!     %
!     % Don't report underfull hboxes.
!     \hbadness = 10000
!     %
!     % Do minimal line-breaking.
!     \pretolerance = 10000
!     %
!     % Do not execute instructions in @tex
!     \def\tex{\doignore{tex}}%
!     % Do not execute macro definitions.
!     % `c' is a comment character, so the word `macro' will get cut off.
!     \def\macro{\doignore{ma}}%
! }
! 
! % @set VAR sets the variable VAR to an empty value.
! % @set VAR REST-OF-LINE sets VAR to the value REST-OF-LINE.
  %
! % Since we want to separate VAR from REST-OF-LINE (which might be
! % empty), we can't just use \parsearg; we have to insert a space of our
! % own to delimit the rest of the line, and then take it out again if we
! % didn't need it.  Make sure the catcode of space is correct to avoid
! % losing inside @example, for instance.
  %
! \def\set{\begingroup\catcode` =10
!   \catcode`\-=12 \catcode`\_=12 % Allow - and _ in VAR.
!   \parsearg\setxxx}
! \def\setxxx#1{\setyyy#1 \endsetyyy}
! \def\setyyy#1 #2\endsetyyy{%
!   \def\temp{#2}%
!   \ifx\temp\empty \global\expandafter\let\csname SET#1\endcsname = \empty
!   \else \setzzz{#1}#2\endsetzzz % Remove the trailing space \setxxx inserted.
!   \fi
!   \endgroup
! }
! % Can't use \xdef to pre-expand #2 and save some time, since \temp or
! % \next or other control sequences that we've defined might get us into
! % an infinite loop. Consider `@set foo @cite{bar}'.
! \def\setzzz#1#2 \endsetzzz{\expandafter\gdef\csname SET#1\endcsname{#2}}
  
! % @clear VAR clears (i.e., unsets) the variable VAR.
! %
! \def\clear{\parsearg\clearxxx}
! \def\clearxxx#1{\global\expandafter\let\csname SET#1\endcsname=\relax}
  
! % @value{foo} gets the text saved in variable foo.
! {
!   \catcode`\_ = \active
!   %
!   % We might end up with active _ or - characters in the argument if
!   % we're called from @code, as @code{@value{foo-bar_}}.  So \let any
!   % such active characters to their normal equivalents.
!   \gdef\value{\begingroup
!     \catcode`\-=12 \catcode`\_=12
!     \indexbreaks \let_\normalunderscore
!     \valuexxx}
! }
! \def\valuexxx#1{\expandablevalue{#1}\endgroup}
! 
! % We have this subroutine so that we can handle at least some @value's
! % properly in indexes (we \let\value to this in \indexdummies).  Ones
! % whose names contain - or _ still won't work, but we can't do anything
! % about that.  The command has to be fully expandable, since the result
! % winds up in the index file.  This means that if the variable's value
! % contains other Texinfo commands, it's almost certain it will fail
! % (although perhaps we could fix that with sufficient work to do a
! % one-level expansion on the result, instead of complete).
! %
! \def\expandablevalue#1{%
!   \expandafter\ifx\csname SET#1\endcsname\relax
!     {[No value for ``#1'']}%
    \else
!     \csname SET#1\endcsname
!   \fi
! }
  
! % @ifset VAR ... @end ifset reads the `...' iff VAR has been defined
! % with @set.
! %
! \def\ifset{\parsearg\ifsetxxx}
! \def\ifsetxxx #1{%
!   \expandafter\ifx\csname SET#1\endcsname\relax
!     \expandafter\ifsetfail
!   \else
!     \expandafter\ifsetsucceed
!   \fi
! }
! \def\ifsetsucceed{\conditionalsucceed{ifset}}
! \def\ifsetfail{\nestedignore{ifset}}
! \defineunmatchedend{ifset}
  
! % @ifclear VAR ... @end ifclear reads the `...' iff VAR has never been
! % defined with @set, or has been undefined with @clear.
! %
! \def\ifclear{\parsearg\ifclearxxx}
! \def\ifclearxxx #1{%
!   \expandafter\ifx\csname SET#1\endcsname\relax
!     \expandafter\ifclearsucceed
    \else
!     \expandafter\ifclearfail
    \fi
  }
+ \def\ifclearsucceed{\conditionalsucceed{ifclear}}
+ \def\ifclearfail{\nestedignore{ifclear}}
+ \defineunmatchedend{ifclear}
  
! % @iftex, @ifnothtml, @ifnotinfo always succeed; we read the text
! % following, through the first @end iftex (etc.).  Make `@end iftex'
! % (etc.) valid only after an @iftex.
! %
! \def\iftex{\conditionalsucceed{iftex}}
! \def\ifnothtml{\conditionalsucceed{ifnothtml}}
! \def\ifnotinfo{\conditionalsucceed{ifnotinfo}}
! \defineunmatchedend{iftex}
! \defineunmatchedend{ifnothtml}
! \defineunmatchedend{ifnotinfo}
! 
! % We can't just want to start a group at @iftex (for example) and end it
! % at @end iftex, since then @set commands inside the conditional have no
! % effect (they'd get reverted at the end of the group).  So we must
! % define \Eiftex to redefine itself to be its previous value.  (We can't
! % just define it to fail again with an ``unmatched end'' error, since
! % the @ifset might be nested.)
! %
! \def\conditionalsucceed#1{%
!   \edef\temp{%
!     % Remember the current value of \E#1.
!     \let\nece{prevE#1} = \nece{E#1}%
!     %
!     % At the `@end #1', redefine \E#1 to be its previous value.
!     \def\nece{E#1}{\let\nece{E#1} = \nece{prevE#1}}%
!   }%
!   \temp
! }
! 
! % We need to expand lots of \csname's, but we don't want to expand the
! % control sequences after we've constructed them.
! %
! \def\nece#1{\expandafter\noexpand\csname#1\endcsname}
! 
! % @defininfoenclose.
! \let\definfoenclose=\comment
  
  
***************
*** 2087,2096 ****
  % The name of an index should be no more than 2 characters long
  % for the sake of vms.
! 
! \def\newindex #1{
! \expandafter\newwrite \csname#1indfile\endcsname% Define number for output file
! \openout \csname#1indfile\endcsname \jobname.#1 % Open the file
! \expandafter\xdef\csname#1index\endcsname{%     % Define \xxxindex
! \noexpand\doindex {#1}}
  }
  
--- 2577,2588 ----
  % The name of an index should be no more than 2 characters long
  % for the sake of vms.
! %
! \def\newindex#1{%
!   \iflinks
!     \expandafter\newwrite \csname#1indfile\endcsname
!     \openout \csname#1indfile\endcsname \jobname.#1 % Open the file
!   \fi
!   \expandafter\xdef\csname#1index\endcsname{%     % Define @#1index
!     \noexpand\doindex{#1}}
  }
  
***************
*** 2101,2109 ****
  % Define @defcodeindex, like @defindex except put all entries in @code.
  
! \def\newcodeindex #1{
! \expandafter\newwrite \csname#1indfile\endcsname% Define number for output file
! \openout \csname#1indfile\endcsname \jobname.#1 % Open the file
! \expandafter\xdef\csname#1index\endcsname{%     % Define \xxxindex
! \noexpand\docodeindex {#1}}
  }
  
--- 2593,2603 ----
  % Define @defcodeindex, like @defindex except put all entries in @code.
  
! \def\newcodeindex#1{%
!   \iflinks
!     \expandafter\newwrite \csname#1indfile\endcsname
!     \openout \csname#1indfile\endcsname \jobname.#1
!   \fi
!   \expandafter\xdef\csname#1index\endcsname{%
!     \noexpand\docodeindex{#1}}
  }
  
***************
*** 2112,2129 ****
  % @synindex foo bar    makes index foo feed into index bar.
  % Do this instead of @defindex foo if you don't want it as a separate index.
! \def\synindex #1 #2 {%
! \expandafter\let\expandafter\synindexfoo\expandafter=\csname#2indfile\endcsname
! \expandafter\let\csname#1indfile\endcsname=\synindexfoo
! \expandafter\xdef\csname#1index\endcsname{%     % Define \xxxindex
! \noexpand\doindex {#2}}%
  }
  
  % @syncodeindex foo bar   similar, but put all entries made for index foo
  % inside @code.
! \def\syncodeindex #1 #2 {%
! \expandafter\let\expandafter\synindexfoo\expandafter=\csname#2indfile\endcsname
! \expandafter\let\csname#1indfile\endcsname=\synindexfoo
! \expandafter\xdef\csname#1index\endcsname{%     % Define \xxxindex
! \noexpand\docodeindex {#2}}%
  }
  
--- 2606,2627 ----
  % @synindex foo bar    makes index foo feed into index bar.
  % Do this instead of @defindex foo if you don't want it as a separate index.
! % The \closeout helps reduce unnecessary open files; the limit on the
! % Acorn RISC OS is a mere 16 files.
! \def\synindex#1 #2 {%
!   \expandafter\let\expandafter\synindexfoo\expandafter=\csname#2indfile\endcsname
!   \expandafter\closeout\csname#1indfile\endcsname
!   \expandafter\let\csname#1indfile\endcsname=\synindexfoo
!   \expandafter\xdef\csname#1index\endcsname{% define \xxxindex
!     \noexpand\doindex{#2}}%
  }
  
  % @syncodeindex foo bar   similar, but put all entries made for index foo
  % inside @code.
! \def\syncodeindex#1 #2 {%
!   \expandafter\let\expandafter\synindexfoo\expandafter=\csname#2indfile\endcsname
!   \expandafter\closeout\csname#1indfile\endcsname
!   \expandafter\let\csname#1indfile\endcsname=\synindexfoo
!   \expandafter\xdef\csname#1index\endcsname{% define \xxxindex
!     \noexpand\docodeindex{#2}}%
  }
  
***************
*** 2146,2149 ****
--- 2644,2648 ----
  
  \def\indexdummies{%
+ \def\ { }%
  % Take care of the plain tex accent commands.
  \def\"{\realbackslash "}%
***************
*** 2175,2180 ****
  % laboriously list every single command here.)
  \def\@{@}% will be @@ when we switch to @ as escape char.
! %\let\{ = \lbracecmd
! %\let\} = \rbracecmd
  \def\_{{\realbackslash _}}%
  \def\w{\realbackslash w }%
--- 2674,2682 ----
  % laboriously list every single command here.)
  \def\@{@}% will be @@ when we switch to @ as escape char.
! % Need these in case \tex is in effect and \{ is a \delimiter again.
! % But can't use \lbracecmd and \rbracecmd because texindex assumes
! % braces and backslashes are used only as delimiters.  
! \let\{ = \mylbrace
! \let\} = \myrbrace
  \def\_{{\realbackslash _}}%
  \def\w{\realbackslash w }%
***************
*** 2187,2196 ****
  \def\less{\realbackslash less}%
  \def\hat{\realbackslash hat}%
- %\def\char{\realbackslash char}%
  \def\TeX{\realbackslash TeX}%
  \def\dots{\realbackslash dots }%
! \def\copyright{\realbackslash copyright }%
  \def\tclose##1{\realbackslash tclose {##1}}%
  \def\code##1{\realbackslash code {##1}}%
  \def\dotless##1{\realbackslash dotless {##1}}%
  \def\samp##1{\realbackslash samp {##1}}%
--- 2689,2708 ----
  \def\less{\realbackslash less}%
  \def\hat{\realbackslash hat}%
  \def\TeX{\realbackslash TeX}%
  \def\dots{\realbackslash dots }%
! \def\result{\realbackslash result}%
! \def\equiv{\realbackslash equiv}%
! \def\expansion{\realbackslash expansion}%
! \def\print{\realbackslash print}%
! \def\error{\realbackslash error}%
! \def\point{\realbackslash point}%
! \def\copyright{\realbackslash copyright}%
  \def\tclose##1{\realbackslash tclose {##1}}%
  \def\code##1{\realbackslash code {##1}}%
+ \def\uref##1{\realbackslash uref {##1}}%
+ \def\url##1{\realbackslash url {##1}}%
+ \def\env##1{\realbackslash env {##1}}%
+ \def\command##1{\realbackslash command {##1}}%
+ \def\option##1{\realbackslash option {##1}}%
  \def\dotless##1{\realbackslash dotless {##1}}%
  \def\samp##1{\realbackslash samp {##1}}%
***************
*** 2200,2203 ****
--- 2712,2716 ----
  \def\i##1{\realbackslash i {##1}}%
  \def\b##1{\realbackslash b {##1}}%
+ \def\sc##1{\realbackslash sc {##1}}%
  \def\cite##1{\realbackslash cite {##1}}%
  \def\key##1{\realbackslash key {##1}}%
***************
*** 2207,2211 ****
--- 2720,2733 ----
  \def\dfn##1{\realbackslash dfn {##1}}%
  \def\emph##1{\realbackslash emph {##1}}%
+ \def\acronym##1{\realbackslash acronym {##1}}%
+ %
+ % Handle some cases of @value -- where the variable name does not
+ % contain - or _, and the value does not contain any
+ % (non-fully-expandable) commands.
+ \let\value = \expandablevalue
+ %
  \unsepspaces
+ % Turn off macro expansion
+ \turnoffmacros
  }
  
***************
*** 2264,2267 ****
--- 2786,2795 ----
  \let\tclose=\indexdummyfont
  \let\code=\indexdummyfont
+ \let\url=\indexdummyfont
+ \let\uref=\indexdummyfont
+ \let\env=\indexdummyfont
+ \let\acronym=\indexdummyfont
+ \let\command=\indexdummyfont
+ \let\option=\indexdummyfont
  \let\file=\indexdummyfont
  \let\samp=\indexdummyfont
***************
*** 2279,2290 ****
  
  {\catcode`\@=0 \catcode`\\=\other
! @gdef@realbackslash{\}}
  
  \let\indexbackslash=0  %overridden during \printindex.
  
! \let\SETmarginindex=\relax %initialize!
! % workhorse for all \fooindexes
! % #1 is name of index, #2 is stuff to put there
! \def\doind #1#2{%
    % Put the index entry in the margin if desired.
    \ifx\SETmarginindex\relax\else
--- 2807,2828 ----
  
  {\catcode`\@=0 \catcode`\\=\other
!  @gdef@realbackslash{\}}
  
  \let\indexbackslash=0  %overridden during \printindex.
+ \let\SETmarginindex=\relax % put index entries in margin (undocumented)?
+ 
+ % For \ifx comparisons.
+ \def\emptymacro{\empty}
+ 
+ % Most index entries go through here, but \dosubind is the general case.
+ %
+ \def\doind#1#2{\dosubind{#1}{#2}\empty}
  
! % Workhorse for all \fooindexes.
! % #1 is name of index, #2 is stuff to put there, #3 is subentry --
! % \empty if called from \doind, as we usually are.  The main exception
! % is with defuns, which call us directly.
! %
! \def\dosubind#1#2#3{%
    % Put the index entry in the margin if desired.
    \ifx\SETmarginindex\relax\else
***************
*** 2297,2316 ****
        \escapechar=`\\
        {%
!         \let\folio=0 % We will expand all macros now EXCEPT \folio.
          \def\rawbackslashxx{\indexbackslash}% \indexbackslash isn't defined now
          % so it will be output as is; and it will print as backslash.
          %
!         % First process the index-string with all font commands turned off
!         % to get the string to sort by.
!         {\indexnofonts \xdef\indexsorttmp{#2}}%
          %
!         % Now produce the complete index entry, with both the sort key and the
!         % original text, including any font commands.
          \toks0 = {#2}%
          \edef\temp{%
            \write\csname#1indfile\endcsname{%
              \realbackslash entry{\indexsorttmp}{\folio}{\the\toks0}}%
          }%
!         \temp
        }%
      }%
--- 2835,2901 ----
        \escapechar=`\\
        {%
!         \let\folio = 0% We will expand all macros now EXCEPT \folio.
          \def\rawbackslashxx{\indexbackslash}% \indexbackslash isn't defined now
          % so it will be output as is; and it will print as backslash.
          %
!         \def\thirdarg{#3}%
!         %
!         % If third arg is present, precede it with space in sort key.
!         \ifx\thirdarg\emptymacro
!           \let\subentry = \empty
!         \else
!           \def\subentry{ #3}%
!         \fi
!         %
!         % First process the index entry with all font commands turned
!         % off to get the string to sort by.
!         {\indexnofonts \xdef\indexsorttmp{#2\subentry}}%
          %
!         % Now the real index entry with the fonts.
          \toks0 = {#2}%
+         %
+         % If third (subentry) arg is present, add it to the index
+         % string.  And include a space.
+         \ifx\thirdarg\emptymacro \else
+           \toks0 = \expandafter{\the\toks0 \space #3}%
+         \fi
+         %
+         % Set up the complete index entry, with both the sort key
+         % and the original text, including any font commands.  We write
+         % three arguments to \entry to the .?? file, texindex reduces to
+         % two when writing the .??s sorted result.
          \edef\temp{%
            \write\csname#1indfile\endcsname{%
              \realbackslash entry{\indexsorttmp}{\folio}{\the\toks0}}%
          }%
!         %
!         % If a skip is the last thing on the list now, preserve it
!         % by backing up by \lastskip, doing the \write, then inserting
!         % the skip again.  Otherwise, the whatsit generated by the
!         % \write will make \lastskip zero.  The result is that sequences
!         % like this:
!         % @end defun
!         % @tindex whatever
!         % @defun ...
!         % will have extra space inserted, because the \medbreak in the
!         % start of the @defun won't see the skip inserted by the @end of
!         % the previous defun.
!         %
!         % But don't do any of this if we're not in vertical mode.  We
!         % don't want to do a \vskip and prematurely end a paragraph.
!         %
!         % Avoid page breaks due to these extra skips, too.
!         %
!         \iflinks
!           \ifvmode
!             \skip0 = \lastskip
!             \ifdim\lastskip = 0pt \else \nobreak\vskip-\lastskip \fi
!           \fi
!           %
!           \temp % do the write
!           %
!           %
!           \ifvmode \ifdim\skip0 = 0pt \else \nobreak\vskip\skip0 \fi \fi
!         \fi
        }%
      }%
***************
*** 2319,2342 ****
  }
  
- \def\dosubind #1#2#3{%
- {\count10=\lastpenalty %
- {\indexdummies % Must do this here, since \bf, etc expand at this stage
- \escapechar=`\\%
- {\let\folio=0%
- \def\rawbackslashxx{\indexbackslash}%
- %
- % Now process the index-string once, with all font commands turned off,
- % to get the string to sort the index by.
- {\indexnofonts
- \xdef\temp1{#2 #3}%
- }%
- % Now produce the complete index entry.  We process the index-string again,
- % this time with font commands expanded, to get what to print in the index.
- \edef\temp{%
- \write \csname#1indfile\endcsname{%
- \realbackslash entry {\temp1}{\folio}{#2}{#3}}}%
- \temp }%
- }\penalty\count10}}
- 
  % The index entry written in the file actually looks like
  %  \entry {sortstring}{page}{topic}
--- 2904,2907 ----
***************
*** 2371,2397 ****
  % Define the macros used in formatting output of the sorted index material.
  
! % This is what you call to cause a particular index to get printed.
! % Write
! % @unnumbered Function Index
! % @printindex fn
! 
  \def\printindex{\parsearg\doprintindex}
- 
  \def\doprintindex#1{\begingroup
    \dobreak \chapheadingskip{10000}%
    %
!   \indexfonts \rm
    \tolerance = 9500
    \indexbreaks
-   \def\indexbackslash{\rawbackslashxx}%
-   % Index files are almost Texinfo source, but we use \ as the escape
-   % character.  It would be better to use @, but that's too big a change
-   % to make right now.
-   \catcode`\\ = 0
-   \catcode`\@ = 11
-   \escapechar = `\\
-   \begindoublecolumns
    %
    % See if the index file exists and is nonempty.
    \openin 1 \jobname.#1s
    \ifeof 1
--- 2936,2956 ----
  % Define the macros used in formatting output of the sorted index material.
  
! % @printindex causes a particular index (the ??s file) to get printed.
! % It does not print any chapter heading (usually an @unnumbered).
! %
  \def\printindex{\parsearg\doprintindex}
  \def\doprintindex#1{\begingroup
    \dobreak \chapheadingskip{10000}%
    %
!   \smallfonts \rm
    \tolerance = 9500
    \indexbreaks
    %
    % See if the index file exists and is nonempty.
+   % Change catcode of @ here so that if the index file contains
+   % \initial {@}
+   % as its first line, TeX doesn't complain about mismatched braces
+   % (because it thinks @} is a control sequence).
+   \catcode`\@ = 11
    \openin 1 \jobname.#1s
    \ifeof 1
***************
*** 2400,2404 ****
      % index.  The easiest way to prevent this problem is to make sure
      % there is some text.
!     (Index is nonexistent)
    \else
      %
--- 2959,2963 ----
      % index.  The easiest way to prevent this problem is to make sure
      % there is some text.
!     \putwordIndexNonexistent
    \else
      %
***************
*** 2408,2418 ****
      \read 1 to \temp
      \ifeof 1
!       (Index is empty)
      \else
        \input \jobname.#1s
      \fi
    \fi
    \closein 1
-   \enddoublecolumns
  \endgroup}
  
--- 2967,2984 ----
      \read 1 to \temp
      \ifeof 1
!       \putwordIndexIsEmpty
      \else
+       % Index files are almost Texinfo source, but we use \ as the escape
+       % character.  It would be better to use @, but that's too big a change
+       % to make right now.
+       \def\indexbackslash{\rawbackslashxx}%
+       \catcode`\\ = 0
+       \escapechar = `\\
+       \begindoublecolumns
        \input \jobname.#1s
+       \enddoublecolumns
      \fi
    \fi
    \closein 1
  \endgroup}
  
***************
*** 2420,2432 ****
  % Change them to control the appearance of the index.
  
! % Same as \bigskipamount except no shrink.
! % \balancecolumns gets confused if there is any shrink.
! \newskip\initialskipamount \initialskipamount 12pt plus4pt
! 
! \def\initial #1{%
! {\let\tentt=\sectt \let\tt=\sectt \let\sf=\sectt
! \ifdim\lastskip<\initialskipamount
! \removelastskip \penalty-200 \vskip \initialskipamount\fi
! \line{\secbf#1\hfill}\kern 2pt\penalty10000}}
  
  % This typesets a paragraph consisting of #1, dot leaders, and then #2
--- 2986,3012 ----
  % Change them to control the appearance of the index.
  
! \def\initial#1{{%
!   % Some minor font changes for the special characters.
!   \let\tentt=\sectt \let\tt=\sectt \let\sf=\sectt
!   %
!   % Remove any glue we may have, we'll be inserting our own.
!   \removelastskip
!   %
!   % We like breaks before the index initials, so insert a bonus.
!   \penalty -300
!   %
!   % Typeset the initial.  Making this add up to a whole number of
!   % baselineskips increases the chance of the dots lining up from column
!   % to column.  It still won't often be perfect, because of the stretch
!   % we need before each entry, but it's better.
!   %
!   % No shrink because it confuses \balancecolumns.
!   \vskip 1.67\baselineskip plus .5\baselineskip
!   \leftline{\secbf #1}%
!   \vskip .33\baselineskip plus .1\baselineskip
!   %
!   % Do our best not to break after the initial.
!   \nobreak
! }}
  
  % This typesets a paragraph consisting of #1, dot leaders, and then #2
***************
*** 2434,2438 ****
  % entries.  The paragraph is indented by \leftskip.
  %
! \def\entry #1#2{\begingroup
    %
    % Start a new paragraph if necessary, so our assignments below can't
--- 3014,3018 ----
  % entries.  The paragraph is indented by \leftskip.
  %
! \def\entry#1#2{\begingroup
    %
    % Start a new paragraph if necessary, so our assignments below can't
***************
*** 2457,2461 ****
    % \hangafter is reset to 1 (which is the value we want) at the start
    % of each paragraph, so we need not do anything with that.
!   \hangindent=2em
    %
    % When the entry text needs to be broken, just fill out the first line
--- 3037,3041 ----
    % \hangafter is reset to 1 (which is the value we want) at the start
    % of each paragraph, so we need not do anything with that.
!   \hangindent = 2em
    %
    % When the entry text needs to be broken, just fill out the first line
***************
*** 2463,2466 ****
--- 3043,3049 ----
    \rightskip = 0pt plus1fil
    %
+   % A bit of stretch before each entry for the benefit of balancing columns.
+   \vskip 0pt plus1pt
+   %
    % Start a ``paragraph'' for the index entry so the line breaking
    % parameters we've set above will have an effect.
***************
*** 2487,2491 ****
      % part of (the primitive) \par.  Without it, a spurious underfull
      % \hbox ensues.
!     \ #2% The page number ends the paragraph.
    \fi%
    \par
--- 3070,3078 ----
      % part of (the primitive) \par.  Without it, a spurious underfull
      % \hbox ensues.
!     \ifpdf
!       \pdfgettoks#2.\ \the\toksA % The page number ends the paragraph.
!     \else
!       \ #2% The page number ends the paragraph.
!     \fi
    \fi%
    \par
***************
*** 2516,2525 ****
  \def\begindoublecolumns{\begingroup % ended by \enddoublecolumns
    % Grab any single-column material above us.
!   \output = {\global\setbox\partialpage
!     =\vbox{\unvbox255\kern -\topskip \kern \baselineskip}}%
!   \eject
    %
!   % Now switch to the double-column output routine.
!   \output={\doublecolumnout}%
    %
    % Change the page size parameters.  We could do this once outside this
--- 3103,3129 ----
  \def\begindoublecolumns{\begingroup % ended by \enddoublecolumns
    % Grab any single-column material above us.
!   \output = {%
!     %
!     % Here is a possibility not foreseen in manmac: if we accumulate a
!     % whole lot of material, we might end up calling this \output
!     % routine twice in a row (see the doublecol-lose test, which is
!     % essentially a couple of indexes with @setchapternewpage off).  In
!     % that case we just ship out what is in \partialpage with the normal
!     % output routine.  Generally, \partialpage will be empty when this
!     % runs and this will be a no-op.  See the indexspread.tex test case.
!     \ifvoid\partialpage \else
!       \onepageout{\pagecontents\partialpage}%
!     \fi
!     %
!     \global\setbox\partialpage = \vbox{%
!       % Unvbox the main output page.
!       \unvbox\PAGE
!       \kern-\topskip \kern\baselineskip
!     }%
!   }%
!   \eject % run that output routine to set \partialpage
    %
!   % Use the double-column output routine for subsequent pages.
!   \output = {\doublecolumnout}%
    %
    % Change the page size parameters.  We could do this once outside this
***************
*** 2527,2537 ****
    % format, but then we repeat the same computation.  Repeating a couple
    % of assignments once per index is clearly meaningless for the
!   % execution time, so we may as well do it once.
    %
    % First we halve the line length, less a little for the gutter between
    % the columns.  We compute the gutter based on the line length, so it
    % changes automatically with the paper format.  The magic constant
!   % below is chosen so that the gutter has the same value (well, +- <
!   % 1pt) as it did when we hard-coded it.
    %
    % We put the result in a separate register, \doublecolumhsize, so we
--- 3131,3141 ----
    % format, but then we repeat the same computation.  Repeating a couple
    % of assignments once per index is clearly meaningless for the
!   % execution time, so we may as well do it in one place.
    %
    % First we halve the line length, less a little for the gutter between
    % the columns.  We compute the gutter based on the line length, so it
    % changes automatically with the paper format.  The magic constant
!   % below is chosen so that the gutter has the same value (well, +-<1pt)
!   % as it did when we hard-coded it.
    %
    % We put the result in a separate register, \doublecolumhsize, so we
***************
*** 2546,2551 ****
--- 3150,3160 ----
    % Double the \vsize as well.  (We don't need a separate register here,
    % since nobody clobbers \vsize.)
+   \advance\vsize by -\ht\partialpage
    \vsize = 2\vsize
  }
+ 
+ % The double-column output routine for all double-column pages except
+ % the last.
+ %
  \def\doublecolumnout{%
    \splittopskip=\topskip \splitmaxdepth=\maxdepth
***************
*** 2553,2652 ****
    % (undoubled) page height minus any material left over from the
    % previous page.
!   \dimen@=\pageheight \advance\dimen@ by-\ht\partialpage
!   % box0 will be the left-hand column, box1 the right.
    \setbox0=\vsplit255 to\dimen@ \setbox2=\vsplit255 to\dimen@
    \onepageout\pagesofar
!   \unvbox255 \penalty\outputpenalty
  }
  \def\pagesofar{%
!   % The contents of the output page -- any previous material,
!   % followed by the two boxes we just split.
    \unvbox\partialpage
    \hsize = \doublecolumnhsize
!   \wd0=\hsize \wd2=\hsize \hbox to\pagewidth{\box0\hfil\box2}%
  }
  \def\enddoublecolumns{%
!   \output={\balancecolumns}\eject % split what we have
!   \endgroup
!   % Back to normal single-column typesetting, but take account of the
!   % fact that we just accumulated some stuff on the output page.
!   \pagegoal=\vsize 
  }
  \def\balancecolumns{%
!   % Called on the last page of the double column material.
!   \setbox0=\vbox{\unvbox255}%
    \dimen@ = \ht0
    \advance\dimen@ by \topskip
    \advance\dimen@ by-\baselineskip
!   \divide\dimen@ by 2
    \splittopskip = \topskip
    % Loop until we get a decent breakpoint.
!   {\vbadness=10000 \loop \global\setbox3=\copy0
!     \global\setbox1=\vsplit3 to\dimen@
!     \ifdim\ht3>\dimen@ \global\advance\dimen@ by1pt \repeat}%
    \setbox0=\vbox to\dimen@{\unvbox1}%
    \setbox2=\vbox to\dimen@{\unvbox3}%
    \pagesofar
  }
! \catcode `\@=\other
  
  
  \message{sectioning,}
! % Define chapters, sections, etc.
  
! \newcount \chapno
! \newcount \secno        \secno=0
! \newcount \subsecno     \subsecno=0
! \newcount \subsubsecno  \subsubsecno=0
  
  % This counter is funny since it counts through charcodes of letters A, B, ...
! \newcount \appendixno  \appendixno = `\@
! \def\appendixletter{\char\the\appendixno}
! 
! \newwrite \contentsfile
! % This is called from \setfilename.
! \def\opencontents{\openout \contentsfile = \jobname.toc}
  
  % Each @chapter defines this as the name of the chapter.
! % page headings and footings can use it.  @section does likewise
! 
! \def\thischapter{} \def\thissection{}
! \def\seccheck#1{\if \pageno<0 %
! \errmessage{@#1 not allowed after generating table of contents}\fi
! %
! }
! 
! \def\chapternofonts{%
! \let\rawbackslash=\relax%
! \let\frenchspacing=\relax%
! \def\result{\realbackslash result}
! \def\equiv{\realbackslash equiv}
! \def\expansion{\realbackslash expansion}
! \def\print{\realbackslash print}
! \def\TeX{\realbackslash TeX}
! \def\dots{\realbackslash dots}
! \def\copyright{\realbackslash copyright}
! \def\tt{\realbackslash tt}
! \def\bf{\realbackslash bf }
! \def\w{\realbackslash w}
! \def\less{\realbackslash less}
! \def\gtr{\realbackslash gtr}
! \def\hat{\realbackslash hat}
! \def\char{\realbackslash char}
! \def\tclose##1{\realbackslash tclose {##1}}
! \def\code##1{\realbackslash code {##1}}
! \def\samp##1{\realbackslash samp {##1}}
! \def\r##1{\realbackslash r {##1}}
! \def\b##1{\realbackslash b {##1}}
! \def\key##1{\realbackslash key {##1}}
! \def\file##1{\realbackslash file {##1}}
! \def\kbd##1{\realbackslash kbd {##1}}
! % These are redefined because @smartitalic wouldn't work inside xdef.
! \def\i##1{\realbackslash i {##1}}
! \def\cite##1{\realbackslash cite {##1}}
! \def\var##1{\realbackslash var {##1}}
! \def\emph##1{\realbackslash emph {##1}}
! \def\dfn##1{\realbackslash dfn {##1}}
! }
  
  \newcount\absseclevel % used to calculate proper heading level
--- 3162,3287 ----
    % (undoubled) page height minus any material left over from the
    % previous page.
!   \dimen@ = \vsize
!   \divide\dimen@ by 2
!   %
!   % box0 will be the left-hand column, box2 the right.
    \setbox0=\vsplit255 to\dimen@ \setbox2=\vsplit255 to\dimen@
    \onepageout\pagesofar
!   \unvbox255
!   \penalty\outputpenalty
  }
  \def\pagesofar{%
!   % Re-output the contents of the output page -- any previous material,
!   % followed by the two boxes we just split, in box0 and box2.
    \unvbox\partialpage
+   %
    \hsize = \doublecolumnhsize
!   \wd0=\hsize \wd2=\hsize
!   \hbox to\pagewidth{\box0\hfil\box2}%
  }
  \def\enddoublecolumns{%
!   \output = {%
!     % Split the last of the double-column material.  Leave it on the
!     % current page, no automatic page break.
!     \balancecolumns
!     %
!     % If we end up splitting too much material for the current page,
!     % though, there will be another page break right after this \output
!     % invocation ends.  Having called \balancecolumns once, we do not
!     % want to call it again.  Therefore, reset \output to its normal
!     % definition right away.  (We hope \balancecolumns will never be
!     % called on to balance too much material, but if it is, this makes
!     % the output somewhat more palatable.)
!     \global\output = {\onepageout{\pagecontents\PAGE}}%
!   }%
!   \eject
!   \endgroup % started in \begindoublecolumns
!   %
!   % \pagegoal was set to the doubled \vsize above, since we restarted
!   % the current page.  We're now back to normal single-column
!   % typesetting, so reset \pagegoal to the normal \vsize (after the
!   % \endgroup where \vsize got restored).
!   \pagegoal = \vsize
  }
  \def\balancecolumns{%
!   % Called at the end of the double column material.
!   \setbox0 = \vbox{\unvbox255}% like \box255 but more efficient, see p.120.
    \dimen@ = \ht0
    \advance\dimen@ by \topskip
    \advance\dimen@ by-\baselineskip
!   \divide\dimen@ by 2 % target to split to
!   %debug\message{final 2-column material height=\the\ht0, target=\the\dimen@.}%
    \splittopskip = \topskip
    % Loop until we get a decent breakpoint.
!   {%
!     \vbadness = 10000
!     \loop
!       \global\setbox3 = \copy0
!       \global\setbox1 = \vsplit3 to \dimen@
!     \ifdim\ht3>\dimen@
!       \global\advance\dimen@ by 1pt
!     \repeat
!   }%
!   %debug\message{split to \the\dimen@, column heights: \the\ht1, \the\ht3.}%
    \setbox0=\vbox to\dimen@{\unvbox1}%
    \setbox2=\vbox to\dimen@{\unvbox3}%
+   %
    \pagesofar
  }
! \catcode`\@ = \other
  
  
  \message{sectioning,}
! % Chapters, sections, etc.
  
! \newcount\chapno
! \newcount\secno        \secno=0
! \newcount\subsecno     \subsecno=0
! \newcount\subsubsecno  \subsubsecno=0
  
  % This counter is funny since it counts through charcodes of letters A, B, ...
! \newcount\appendixno  \appendixno = `\@
! % \def\appendixletter{\char\the\appendixno}
! % We do the following for the sake of pdftex, which needs the actual
! % letter in the expansion, not just typeset.
! \def\appendixletter{%
!   \ifnum\appendixno=`A A%
!   \else\ifnum\appendixno=`B B%
!   \else\ifnum\appendixno=`C C%
!   \else\ifnum\appendixno=`D D%
!   \else\ifnum\appendixno=`E E%
!   \else\ifnum\appendixno=`F F%
!   \else\ifnum\appendixno=`G G%
!   \else\ifnum\appendixno=`H H%
!   \else\ifnum\appendixno=`I I%
!   \else\ifnum\appendixno=`J J%
!   \else\ifnum\appendixno=`K K%
!   \else\ifnum\appendixno=`L L%
!   \else\ifnum\appendixno=`M M%
!   \else\ifnum\appendixno=`N N%
!   \else\ifnum\appendixno=`O O%
!   \else\ifnum\appendixno=`P P%
!   \else\ifnum\appendixno=`Q Q%
!   \else\ifnum\appendixno=`R R%
!   \else\ifnum\appendixno=`S S%
!   \else\ifnum\appendixno=`T T%
!   \else\ifnum\appendixno=`U U%
!   \else\ifnum\appendixno=`V V%
!   \else\ifnum\appendixno=`W W%
!   \else\ifnum\appendixno=`X X%
!   \else\ifnum\appendixno=`Y Y%
!   \else\ifnum\appendixno=`Z Z%
!   % The \the is necessary, despite appearances, because \appendixletter is
!   % expanded while writing the .toc file.  \char\appendixno is not
!   % expandable, thus it is written literally, thus all appendixes come out
!   % with the same letter (or @) in the toc without it.
!   \else\char\the\appendixno
!   \fi\fi\fi\fi\fi\fi\fi\fi\fi\fi\fi\fi\fi
!   \fi\fi\fi\fi\fi\fi\fi\fi\fi\fi\fi\fi\fi}
  
  % Each @chapter defines this as the name of the chapter.
! % page headings and footings can use it.  @section does likewise.
! \def\thischapter{}
! \def\thissection{}
  
  \newcount\absseclevel % used to calculate proper heading level
***************
*** 2720,2730 ****
  }
  
! 
  \def\thischaptername{No Chapter Title}
  \outer\def\chapter{\parsearg\chapteryyy}
  \def\chapteryyy #1{\numhead0{#1}} % normally numhead0 calls chapterzzz
! \def\chapterzzz #1{\seccheck{chapter}%
  \secno=0 \subsecno=0 \subsubsecno=0
! \global\advance \chapno by 1 \message{\putwordChapter \the\chapno}%
  \chapmacro {#1}{\the\chapno}%
  \gdef\thissection{#1}%
--- 3355,3365 ----
  }
  
! % @chapter, @appendix, @unnumbered.
  \def\thischaptername{No Chapter Title}
  \outer\def\chapter{\parsearg\chapteryyy}
  \def\chapteryyy #1{\numhead0{#1}} % normally numhead0 calls chapterzzz
! \def\chapterzzz #1{%
  \secno=0 \subsecno=0 \subsubsecno=0
! \global\advance \chapno by 1 \message{\putwordChapter\space \the\chapno}%
  \chapmacro {#1}{\the\chapno}%
  \gdef\thissection{#1}%
***************
*** 2733,2765 ****
  % because we don't want its macros evaluated now.
  \xdef\thischapter{\putwordChapter{} \the\chapno: \noexpand\thischaptername}%
! {\chapternofonts%
! \edef\temp{{\realbackslash chapentry {#1}{\the\chapno}{\noexpand\folio}}}%
! \escapechar=`\\%
! \write \contentsfile \temp  %
! \donoderef %
  \global\let\section = \numberedsec
  \global\let\subsection = \numberedsubsec
  \global\let\subsubsection = \numberedsubsubsec
! }}
  
  \outer\def\appendix{\parsearg\appendixyyy}
  \def\appendixyyy #1{\apphead0{#1}} % normally apphead0 calls appendixzzz
! \def\appendixzzz #1{\seccheck{appendix}%
  \secno=0 \subsecno=0 \subsubsecno=0
! \global\advance \appendixno by 1 \message{Appendix \appendixletter}%
  \chapmacro {#1}{\putwordAppendix{} \appendixletter}%
  \gdef\thissection{#1}%
  \gdef\thischaptername{#1}%
  \xdef\thischapter{\putwordAppendix{} \appendixletter: \noexpand\thischaptername}%
! {\chapternofonts%
! \edef\temp{{\realbackslash chapentry
!   {#1}{\putwordAppendix{} \appendixletter}{\noexpand\folio}}}%
! \escapechar=`\\%
! \write \contentsfile \temp  %
! \appendixnoderef %
  \global\let\section = \appendixsec
  \global\let\subsection = \appendixsubsec
  \global\let\subsubsection = \appendixsubsubsec
! }}
  
  % @centerchap is like @unnumbered, but the heading is centered.
--- 3368,3400 ----
  % because we don't want its macros evaluated now.
  \xdef\thischapter{\putwordChapter{} \the\chapno: \noexpand\thischaptername}%
! \toks0 = {#1}%
! \edef\temp{\noexpand\writetocentry{\realbackslash chapentry{\the\toks0}%
!                                   {\the\chapno}}}%
! \temp
! \donoderef
  \global\let\section = \numberedsec
  \global\let\subsection = \numberedsubsec
  \global\let\subsubsection = \numberedsubsubsec
! }
  
  \outer\def\appendix{\parsearg\appendixyyy}
  \def\appendixyyy #1{\apphead0{#1}} % normally apphead0 calls appendixzzz
! \def\appendixzzz #1{%
  \secno=0 \subsecno=0 \subsubsecno=0
! \global\advance \appendixno by 1
! \message{\putwordAppendix\space \appendixletter}%
  \chapmacro {#1}{\putwordAppendix{} \appendixletter}%
  \gdef\thissection{#1}%
  \gdef\thischaptername{#1}%
  \xdef\thischapter{\putwordAppendix{} \appendixletter: \noexpand\thischaptername}%
! \toks0 = {#1}%
! \edef\temp{\noexpand\writetocentry{\realbackslash chapentry{\the\toks0}%
!                        {\putwordAppendix{} \appendixletter}}}%
! \temp
! \appendixnoderef
  \global\let\section = \appendixsec
  \global\let\subsection = \appendixsubsec
  \global\let\subsubsection = \appendixsubsubsec
! }
  
  % @centerchap is like @unnumbered, but the heading is centered.
***************
*** 2767,2774 ****
  \def\centerchapyyy #1{{\let\unnumbchapmacro=\centerchapmacro \unnumberedyyy{#1}}}
  
  \outer\def\top{\parsearg\unnumberedyyy}
  \outer\def\unnumbered{\parsearg\unnumberedyyy}
  \def\unnumberedyyy #1{\unnmhead0{#1}} % normally unnmhead0 calls unnumberedzzz
! \def\unnumberedzzz #1{\seccheck{unnumbered}%
  \secno=0 \subsecno=0 \subsubsecno=0
  %
--- 3402,3411 ----
  \def\centerchapyyy #1{{\let\unnumbchapmacro=\centerchapmacro \unnumberedyyy{#1}}}
  
+ % @top is like @unnumbered.
  \outer\def\top{\parsearg\unnumberedyyy}
+ 
  \outer\def\unnumbered{\parsearg\unnumberedyyy}
  \def\unnumberedyyy #1{\unnmhead0{#1}} % normally unnmhead0 calls unnumberedzzz
! \def\unnumberedzzz #1{%
  \secno=0 \subsecno=0 \subsubsecno=0
  %
***************
*** 2782,2925 ****
  % as a result of the \message, we just want `@cite' itself.  We use
  % \the<toks register> to achieve this: TeX expands \the<toks> only once,
! % simply yielding the contents of the <toks register>.
  \toks0 = {#1}\message{(\the\toks0)}%
  %
  \unnumbchapmacro {#1}%
  \gdef\thischapter{#1}\gdef\thissection{#1}%
! {\chapternofonts%
! \edef\temp{{\realbackslash unnumbchapentry {#1}{\noexpand\folio}}}%
! \escapechar=`\\%
! \write \contentsfile \temp  %
! \unnumbnoderef %
  \global\let\section = \unnumberedsec
  \global\let\subsection = \unnumberedsubsec
  \global\let\subsubsection = \unnumberedsubsubsec
! }}
  
  \outer\def\numberedsec{\parsearg\secyyy}
  \def\secyyy #1{\numhead1{#1}} % normally calls seczzz
! \def\seczzz #1{\seccheck{section}%
  \subsecno=0 \subsubsecno=0 \global\advance \secno by 1 %
  \gdef\thissection{#1}\secheading {#1}{\the\chapno}{\the\secno}%
! {\chapternofonts%
! \edef\temp{{\realbackslash secentry %
! {#1}{\the\chapno}{\the\secno}{\noexpand\folio}}}%
! \escapechar=`\\%
! \write \contentsfile \temp %
! \donoderef %
! \penalty 10000 %
! }}
  
  \outer\def\appendixsection{\parsearg\appendixsecyyy}
  \outer\def\appendixsec{\parsearg\appendixsecyyy}
  \def\appendixsecyyy #1{\apphead1{#1}} % normally calls appendixsectionzzz
! \def\appendixsectionzzz #1{\seccheck{appendixsection}%
  \subsecno=0 \subsubsecno=0 \global\advance \secno by 1 %
  \gdef\thissection{#1}\secheading {#1}{\appendixletter}{\the\secno}%
! {\chapternofonts%
! \edef\temp{{\realbackslash secentry %
! {#1}{\appendixletter}{\the\secno}{\noexpand\folio}}}%
! \escapechar=`\\%
! \write \contentsfile \temp %
! \appendixnoderef %
! \penalty 10000 %
! }}
  
  \outer\def\unnumberedsec{\parsearg\unnumberedsecyyy}
  \def\unnumberedsecyyy #1{\unnmhead1{#1}} % normally calls unnumberedseczzz
! \def\unnumberedseczzz #1{\seccheck{unnumberedsec}%
  \plainsecheading {#1}\gdef\thissection{#1}%
! {\chapternofonts%
! \edef\temp{{\realbackslash unnumbsecentry{#1}{\noexpand\folio}}}%
! \escapechar=`\\%
! \write \contentsfile \temp %
! \unnumbnoderef %
! \penalty 10000 %
! }}
  
  \outer\def\numberedsubsec{\parsearg\numberedsubsecyyy}
  \def\numberedsubsecyyy #1{\numhead2{#1}} % normally calls numberedsubseczzz
! \def\numberedsubseczzz #1{\seccheck{subsection}%
  \gdef\thissection{#1}\subsubsecno=0 \global\advance \subsecno by 1 %
  \subsecheading {#1}{\the\chapno}{\the\secno}{\the\subsecno}%
! {\chapternofonts%
! \edef\temp{{\realbackslash subsecentry %
! {#1}{\the\chapno}{\the\secno}{\the\subsecno}{\noexpand\folio}}}%
! \escapechar=`\\%
! \write \contentsfile \temp %
! \donoderef %
! \penalty 10000 %
! }}
  
  \outer\def\appendixsubsec{\parsearg\appendixsubsecyyy}
  \def\appendixsubsecyyy #1{\apphead2{#1}} % normally calls appendixsubseczzz
! \def\appendixsubseczzz #1{\seccheck{appendixsubsec}%
  \gdef\thissection{#1}\subsubsecno=0 \global\advance \subsecno by 1 %
  \subsecheading {#1}{\appendixletter}{\the\secno}{\the\subsecno}%
! {\chapternofonts%
! \edef\temp{{\realbackslash subsecentry %
! {#1}{\appendixletter}{\the\secno}{\the\subsecno}{\noexpand\folio}}}%
! \escapechar=`\\%
! \write \contentsfile \temp %
! \appendixnoderef %
! \penalty 10000 %
! }}
  
  \outer\def\unnumberedsubsec{\parsearg\unnumberedsubsecyyy}
  \def\unnumberedsubsecyyy #1{\unnmhead2{#1}} %normally calls unnumberedsubseczzz
! \def\unnumberedsubseczzz #1{\seccheck{unnumberedsubsec}%
  \plainsubsecheading {#1}\gdef\thissection{#1}%
! {\chapternofonts%
! \edef\temp{{\realbackslash unnumbsubsecentry{#1}{\noexpand\folio}}}%
! \escapechar=`\\%
! \write \contentsfile \temp %
! \unnumbnoderef %
! \penalty 10000 %
! }}
  
  \outer\def\numberedsubsubsec{\parsearg\numberedsubsubsecyyy}
  \def\numberedsubsubsecyyy #1{\numhead3{#1}} % normally numberedsubsubseczzz
! \def\numberedsubsubseczzz #1{\seccheck{subsubsection}%
  \gdef\thissection{#1}\global\advance \subsubsecno by 1 %
  \subsubsecheading {#1}
    {\the\chapno}{\the\secno}{\the\subsecno}{\the\subsubsecno}%
! {\chapternofonts%
! \edef\temp{{\realbackslash subsubsecentry %
!   {#1}
!   {\the\chapno}{\the\secno}{\the\subsecno}{\the\subsubsecno}
!   {\noexpand\folio}}}%
! \escapechar=`\\%
! \write \contentsfile \temp %
! \donoderef %
! \penalty 10000 %
! }}
  
  \outer\def\appendixsubsubsec{\parsearg\appendixsubsubsecyyy}
  \def\appendixsubsubsecyyy #1{\apphead3{#1}} % normally appendixsubsubseczzz
! \def\appendixsubsubseczzz #1{\seccheck{appendixsubsubsec}%
  \gdef\thissection{#1}\global\advance \subsubsecno by 1 %
  \subsubsecheading {#1}
    {\appendixletter}{\the\secno}{\the\subsecno}{\the\subsubsecno}%
! {\chapternofonts%
! \edef\temp{{\realbackslash subsubsecentry{#1}%
!   {\appendixletter}
!   {\the\secno}{\the\subsecno}{\the\subsubsecno}{\noexpand\folio}}}%
! \escapechar=`\\%
! \write \contentsfile \temp %
! \appendixnoderef %
! \penalty 10000 %
! }}
  
  \outer\def\unnumberedsubsubsec{\parsearg\unnumberedsubsubsecyyy}
  \def\unnumberedsubsubsecyyy #1{\unnmhead3{#1}} %normally unnumberedsubsubseczzz
! \def\unnumberedsubsubseczzz #1{\seccheck{unnumberedsubsubsec}%
  \plainsubsubsecheading {#1}\gdef\thissection{#1}%
! {\chapternofonts%
! \edef\temp{{\realbackslash unnumbsubsubsecentry{#1}{\noexpand\folio}}}%
! \escapechar=`\\%
! \write \contentsfile \temp %
! \unnumbnoderef %
! \penalty 10000 %
! }}
  
  % These are variants which are not "outer", so they can appear in @ifinfo.
--- 3419,3555 ----
  % as a result of the \message, we just want `@cite' itself.  We use
  % \the<toks register> to achieve this: TeX expands \the<toks> only once,
! % simply yielding the contents of <toks register>.  (We also do this for
! % the toc entries.)
  \toks0 = {#1}\message{(\the\toks0)}%
  %
  \unnumbchapmacro {#1}%
  \gdef\thischapter{#1}\gdef\thissection{#1}%
! \toks0 = {#1}%
! \edef\temp{\noexpand\writetocentry{\realbackslash unnumbchapentry{\the\toks0}}}%
! \temp
! \unnumbnoderef
  \global\let\section = \unnumberedsec
  \global\let\subsection = \unnumberedsubsec
  \global\let\subsubsection = \unnumberedsubsubsec
! }
  
+ % Sections.
  \outer\def\numberedsec{\parsearg\secyyy}
  \def\secyyy #1{\numhead1{#1}} % normally calls seczzz
! \def\seczzz #1{%
  \subsecno=0 \subsubsecno=0 \global\advance \secno by 1 %
  \gdef\thissection{#1}\secheading {#1}{\the\chapno}{\the\secno}%
! \toks0 = {#1}%
! \edef\temp{\noexpand\writetocentry{\realbackslash secentry{\the\toks0}%
!                                   {\the\chapno}{\the\secno}}}%
! \temp
! \donoderef
! \nobreak
! }
  
  \outer\def\appendixsection{\parsearg\appendixsecyyy}
  \outer\def\appendixsec{\parsearg\appendixsecyyy}
  \def\appendixsecyyy #1{\apphead1{#1}} % normally calls appendixsectionzzz
! \def\appendixsectionzzz #1{%
  \subsecno=0 \subsubsecno=0 \global\advance \secno by 1 %
  \gdef\thissection{#1}\secheading {#1}{\appendixletter}{\the\secno}%
! \toks0 = {#1}%
! \edef\temp{\noexpand\writetocentry{\realbackslash secentry{\the\toks0}%
!                                   {\appendixletter}{\the\secno}}}%
! \temp
! \appendixnoderef
! \nobreak
! }
  
  \outer\def\unnumberedsec{\parsearg\unnumberedsecyyy}
  \def\unnumberedsecyyy #1{\unnmhead1{#1}} % normally calls unnumberedseczzz
! \def\unnumberedseczzz #1{%
  \plainsecheading {#1}\gdef\thissection{#1}%
! \toks0 = {#1}%
! \edef\temp{\noexpand\writetocentry{\realbackslash unnumbsecentry{\the\toks0}}}%
! \temp
! \unnumbnoderef
! \nobreak
! }
  
+ % Subsections.
  \outer\def\numberedsubsec{\parsearg\numberedsubsecyyy}
  \def\numberedsubsecyyy #1{\numhead2{#1}} % normally calls numberedsubseczzz
! \def\numberedsubseczzz #1{%
  \gdef\thissection{#1}\subsubsecno=0 \global\advance \subsecno by 1 %
  \subsecheading {#1}{\the\chapno}{\the\secno}{\the\subsecno}%
! \toks0 = {#1}%
! \edef\temp{\noexpand\writetocentry{\realbackslash subsecentry{\the\toks0}%
!                                     {\the\chapno}{\the\secno}{\the\subsecno}}}%
! \temp
! \donoderef
! \nobreak
! }
  
  \outer\def\appendixsubsec{\parsearg\appendixsubsecyyy}
  \def\appendixsubsecyyy #1{\apphead2{#1}} % normally calls appendixsubseczzz
! \def\appendixsubseczzz #1{%
  \gdef\thissection{#1}\subsubsecno=0 \global\advance \subsecno by 1 %
  \subsecheading {#1}{\appendixletter}{\the\secno}{\the\subsecno}%
! \toks0 = {#1}%
! \edef\temp{\noexpand\writetocentry{\realbackslash subsecentry{\the\toks0}%
!                                 {\appendixletter}{\the\secno}{\the\subsecno}}}%
! \temp
! \appendixnoderef
! \nobreak
! }
  
  \outer\def\unnumberedsubsec{\parsearg\unnumberedsubsecyyy}
  \def\unnumberedsubsecyyy #1{\unnmhead2{#1}} %normally calls unnumberedsubseczzz
! \def\unnumberedsubseczzz #1{%
  \plainsubsecheading {#1}\gdef\thissection{#1}%
! \toks0 = {#1}%
! \edef\temp{\noexpand\writetocentry{\realbackslash unnumbsubsecentry%
!                                     {\the\toks0}}}%
! \temp
! \unnumbnoderef
! \nobreak
! }
  
+ % Subsubsections.
  \outer\def\numberedsubsubsec{\parsearg\numberedsubsubsecyyy}
  \def\numberedsubsubsecyyy #1{\numhead3{#1}} % normally numberedsubsubseczzz
! \def\numberedsubsubseczzz #1{%
  \gdef\thissection{#1}\global\advance \subsubsecno by 1 %
  \subsubsecheading {#1}
    {\the\chapno}{\the\secno}{\the\subsecno}{\the\subsubsecno}%
! \toks0 = {#1}%
! \edef\temp{\noexpand\writetocentry{\realbackslash subsubsecentry{\the\toks0}%
!   {\the\chapno}{\the\secno}{\the\subsecno}{\the\subsubsecno}}}%
! \temp
! \donoderef
! \nobreak
! }
  
  \outer\def\appendixsubsubsec{\parsearg\appendixsubsubsecyyy}
  \def\appendixsubsubsecyyy #1{\apphead3{#1}} % normally appendixsubsubseczzz
! \def\appendixsubsubseczzz #1{%
  \gdef\thissection{#1}\global\advance \subsubsecno by 1 %
  \subsubsecheading {#1}
    {\appendixletter}{\the\secno}{\the\subsecno}{\the\subsubsecno}%
! \toks0 = {#1}%
! \edef\temp{\noexpand\writetocentry{\realbackslash subsubsecentry{\the\toks0}%
!   {\appendixletter}{\the\secno}{\the\subsecno}{\the\subsubsecno}}}%
! \temp
! \appendixnoderef
! \nobreak
! }
  
  \outer\def\unnumberedsubsubsec{\parsearg\unnumberedsubsubsecyyy}
  \def\unnumberedsubsubsecyyy #1{\unnmhead3{#1}} %normally unnumberedsubsubseczzz
! \def\unnumberedsubsubseczzz #1{%
  \plainsubsubsecheading {#1}\gdef\thissection{#1}%
! \toks0 = {#1}%
! \edef\temp{\noexpand\writetocentry{\realbackslash unnumbsubsubsecentry%
!                                     {\the\toks0}}}%
! \temp
! \unnumbnoderef
! \nobreak
! }
  
  % These are variants which are not "outer", so they can appear in @ifinfo.
***************
*** 2950,2955 ****
  % Define @majorheading, @heading and @subheading
  
! % NOTE on use of \vbox for chapter headings, section headings, and
! % such:
  %       1) We use \vbox rather than the earlier \line to permit
  %          overlong headings to fold.
--- 3580,3584 ----
  % Define @majorheading, @heading and @subheading
  
! % NOTE on use of \vbox for chapter headings, section headings, and such:
  %       1) We use \vbox rather than the earlier \line to permit
  %          overlong headings to fold.
***************
*** 2998,3007 ****
  \def\setchapternewpage #1 {\csname CHAPPAG#1\endcsname}
  
! \def\CHAPPAGoff{
  \global\let\contentsalignmacro = \chappager
  \global\let\pchapsepmacro=\chapbreak
  \global\let\pagealignmacro=\chappager}
  
! \def\CHAPPAGon{
  \global\let\contentsalignmacro = \chappager
  \global\let\pchapsepmacro=\chappager
--- 3627,3636 ----
  \def\setchapternewpage #1 {\csname CHAPPAG#1\endcsname}
  
! \def\CHAPPAGoff{%
  \global\let\contentsalignmacro = \chappager
  \global\let\pchapsepmacro=\chapbreak
  \global\let\pagealignmacro=\chappager}
  
! \def\CHAPPAGon{%
  \global\let\contentsalignmacro = \chappager
  \global\let\pchapsepmacro=\chappager
***************
*** 3057,3061 ****
  \chapoddpage {\chapfonts \vbox{\hyphenpenalty=10000\tolerance=5000
                         \parindent=0pt\raggedright
!                        \rm #1\hfill}}\bigskip \par\penalty 10000 %
  }
  
--- 3686,3690 ----
  \chapoddpage {\chapfonts \vbox{\hyphenpenalty=10000\tolerance=5000
                         \parindent=0pt\raggedright
!                        \rm #1\hfill}}\bigskip \par\nobreak
  }
  
***************
*** 3068,3072 ****
  \chapoddpage {\chapfonts \vbox{\hyphenpenalty=10000\tolerance=5000
                         \parindent=0pt
!                        \hfill {\rm #1}\hfill}}\bigskip \par\penalty 10000 %
  }
  
--- 3697,3701 ----
  \chapoddpage {\chapfonts \vbox{\hyphenpenalty=10000\tolerance=5000
                         \parindent=0pt
!                        \hfill {\rm #1}\hfill}}\bigskip \par\nobreak
  }
  
***************
*** 3097,3101 ****
  
  % Print any size section title.
! % 
  % #1 is the section type (sec/subsec/subsubsec), #2 is the section
  % number (maybe empty), #3 the text.
--- 3726,3730 ----
  
  % Print any size section title.
! %
  % #1 is the section type (sec/subsec/subsubsec), #2 is the section
  % number (maybe empty), #3 the text.
***************
*** 3121,3129 ****
  
  
! \message{toc printing,}
! % Finish up the main text and prepare to read what we've written
! % to \contentsfile.
  
  \newskip\contentsrightmargin \contentsrightmargin=1in
  \def\startcontents#1{%
     % If @setchapternewpage on, and @headings double, the contents should
--- 3750,3780 ----
  
  
! \message{toc,}
! % Table of contents.
! \newwrite\tocfile
! 
! % Write an entry to the toc file, opening it if necessary.
! % Called from @chapter, etc.  We supply {\folio} at the end of the
! % argument, which will end up as the last argument to the \...entry macro.
! %
! % We open the .toc file here instead of at @setfilename or any other
! % given time so that @contents can be put in the document anywhere.
! %
! \newif\iftocfileopened
! \def\writetocentry#1{%
!   \iftocfileopened\else
!     \immediate\openout\tocfile = \jobname.toc
!     \global\tocfileopenedtrue
!   \fi
!   \iflinks \write\tocfile{#1{\folio}}\fi
! }
  
  \newskip\contentsrightmargin \contentsrightmargin=1in
+ \newcount\savepageno
+ \newcount\lastnegativepageno \lastnegativepageno = -1
+ 
+ % Finish up the main text and prepare to read what we've written
+ % to \tocfile.
+ %
  \def\startcontents#1{%
     % If @setchapternewpage on, and @headings double, the contents should
***************
*** 3132,3161 ****
     % From: Torbjorn Granlund <tege@matematik.su.se>
     \contentsalignmacro
!    \immediate\closeout \contentsfile
!    \ifnum \pageno>0
!       \pageno = -1              % Request roman numbered pages.
!    \fi
     % Don't need to put `Contents' or `Short Contents' in the headline.
     % It is abundantly clear what they are.
     \unnumbchapmacro{#1}\def\thischapter{}%
     \begingroup                  % Set up to handle contents files properly.
        \catcode`\\=0  \catcode`\{=1  \catcode`\}=2  \catcode`\@=11
!       \catcode`\^=7 % to see ^^e4 as \"a etc. juha@piuha.ydi.vtt.fi
        \raggedbottom             % Worry more about breakpoints than the bottom.
        \advance\hsize by -\contentsrightmargin % Don't use the full line length.
  }
  
  
  % Normal (long) toc.
! \outer\def\contents{%
!    \startcontents{\putwordTableofContents}%
!       \input \jobname.toc
     \endgroup
!    \vfill \eject
  }
  
  % And just the chapters.
! \outer\def\summarycontents{%
!    \startcontents{\putwordShortContents}%
        %
        \let\chapentry = \shortchapentry
--- 3783,3824 ----
     % From: Torbjorn Granlund <tege@matematik.su.se>
     \contentsalignmacro
!    \immediate\closeout\tocfile
!    %
     % Don't need to put `Contents' or `Short Contents' in the headline.
     % It is abundantly clear what they are.
     \unnumbchapmacro{#1}\def\thischapter{}%
+    \savepageno = \pageno
     \begingroup                  % Set up to handle contents files properly.
        \catcode`\\=0  \catcode`\{=1  \catcode`\}=2  \catcode`\@=11
!       % We can't do this, because then an actual ^ in a section
!       % title fails, e.g., @chapter ^ -- exponentiation.  --karl, 9jul97.
!       %\catcode`\^=7 % to see ^^e4 as \"a etc. juha@piuha.ydi.vtt.fi
        \raggedbottom             % Worry more about breakpoints than the bottom.
        \advance\hsize by -\contentsrightmargin % Don't use the full line length.
+       %
+       % Roman numerals for page numbers.
+       \ifnum \pageno>0 \pageno = \lastnegativepageno \fi
  }
  
  
  % Normal (long) toc.
! \def\contents{%
!    \startcontents{\putwordTOC}%
!      \openin 1 \jobname.toc
!      \ifeof 1 \else
!        \closein 1
!        \input \jobname.toc
!      \fi
!      \vfill \eject
!      \contentsalignmacro % in case @setchapternewpage odd is in effect
!      \pdfmakeoutlines
     \endgroup
!    \lastnegativepageno = \pageno
!    \pageno = \savepageno
  }
  
  % And just the chapters.
! \def\summarycontents{%
!    \startcontents{\putwordShortTOC}%
        %
        \let\chapentry = \shortchapentry
***************
*** 3173,3182 ****
        \def\subsubsecentry ##1##2##3##4##5##6{}
        \def\unnumbsubsubsecentry ##1##2{}
!       \input \jobname.toc
     \endgroup
!    \vfill \eject
  }
  \let\shortcontents = \summarycontents
  
  % These macros generate individual entries in the table of contents.
  % The first argument is the chapter or section name.
--- 3836,3856 ----
        \def\subsubsecentry ##1##2##3##4##5##6{}
        \def\unnumbsubsubsecentry ##1##2{}
!       \openin 1 \jobname.toc
!       \ifeof 1 \else
!         \closein 1
!         \input \jobname.toc
!       \fi
!      \vfill \eject
!      \contentsalignmacro % in case @setchapternewpage odd is in effect
     \endgroup
!    \lastnegativepageno = \pageno
!    \pageno = \savepageno
  }
  \let\shortcontents = \summarycontents
  
+ \ifpdf
+   \pdfcatalog{/PageMode /UseOutlines}%
+ \fi
+ 
  % These macros generate individual entries in the table of contents.
  % The first argument is the chapter or section name.
***************
*** 3189,3193 ****
  % See comments in \dochapentry re vbox and related settings
  \def\shortchapentry#1#2#3{%
!   \tocentry{\shortchaplabel{#2}\labelspace #1}{\doshortpageno{#3}}%
  }
  
--- 3863,3867 ----
  % See comments in \dochapentry re vbox and related settings
  \def\shortchapentry#1#2#3{%
!   \tocentry{\shortchaplabel{#2}\labelspace #1}{\doshortpageno\bgroup#3\egroup}%
  }
  
***************
*** 3197,3204 ****
  % command in the toc file for appendices, instead of using \chapentry
  % for both, but it doesn't seem worth it.
! \setbox0 = \hbox{\shortcontrm \putwordAppendix }
! \newdimen\shortappendixwidth \shortappendixwidth = \wd0
! 
  \def\shortchaplabel#1{%
    % We typeset #1 in a box of constant width, regardless of the text of
    % #1, so the chapter titles will come out aligned.
--- 3871,3882 ----
  % command in the toc file for appendices, instead of using \chapentry
  % for both, but it doesn't seem worth it.
! %
! \newdimen\shortappendixwidth
! %
  \def\shortchaplabel#1{%
+   % Compute width of word "Appendix", may change with language.
+   \setbox0 = \hbox{\shortcontrm \putwordAppendix}%
+   \shortappendixwidth = \wd0
+   %
    % We typeset #1 in a box of constant width, regardless of the text of
    % #1, so the chapter titles will come out aligned.
***************
*** 3215,3219 ****
  
  \def\unnumbchapentry#1#2{\dochapentry{#1}{#2}}
! \def\shortunnumberedentry#1#2{\tocentry{#1}{\doshortpageno{#2}}}
  
  % Sections.
--- 3893,3897 ----
  
  \def\unnumbchapentry#1#2{\dochapentry{#1}{#2}}
! \def\shortunnumberedentry#1#2{\tocentry{#1}{\doshortpageno\bgroup#2\egroup}}
  
  % Sections.
***************
*** 3242,3246 ****
     \begingroup
       \chapentryfonts
!      \tocentry{#1}{\dopageno{#2}}%
     \endgroup
     \nobreak\vskip .25\baselineskip plus.1\baselineskip
--- 3920,3924 ----
     \begingroup
       \chapentryfonts
!      \tocentry{#1}{\dopageno\bgroup#2\egroup}%
     \endgroup
     \nobreak\vskip .25\baselineskip plus.1\baselineskip
***************
*** 3249,3263 ****
  \def\dosecentry#1#2{\begingroup
    \secentryfonts \leftskip=\tocindent
!   \tocentry{#1}{\dopageno{#2}}%
  \endgroup}
  
  \def\dosubsecentry#1#2{\begingroup
    \subsecentryfonts \leftskip=2\tocindent
!   \tocentry{#1}{\dopageno{#2}}%
  \endgroup}
  
  \def\dosubsubsecentry#1#2{\begingroup
    \subsubsecentryfonts \leftskip=3\tocindent
!   \tocentry{#1}{\dopageno{#2}}%
  \endgroup}
  
--- 3927,3941 ----
  \def\dosecentry#1#2{\begingroup
    \secentryfonts \leftskip=\tocindent
!   \tocentry{#1}{\dopageno\bgroup#2\egroup}%
  \endgroup}
  
  \def\dosubsecentry#1#2{\begingroup
    \subsecentryfonts \leftskip=2\tocindent
!   \tocentry{#1}{\dopageno\bgroup#2\egroup}%
  \endgroup}
  
  \def\dosubsubsecentry#1#2{\begingroup
    \subsubsecentryfonts \leftskip=3\tocindent
!   \tocentry{#1}{\dopageno\bgroup#2\egroup}%
  \endgroup}
  
***************
*** 3266,3274 ****
  % can't do that in the \entry macro, since index entries might consist
  % of hyphenated-identifiers-that-do-not-fit-on-a-line-and-nothing-else.)
- %
- % \turnoffactive is for the sake of @" used for umlauts.
  \def\tocentry#1#2{\begingroup
    \vskip 0pt plus1pt % allow a little stretch for the sake of nice page breaks
!   \entry{\turnoffactive #1}{\turnoffactive #2}%
  \endgroup}
  
--- 3944,3953 ----
  % can't do that in the \entry macro, since index entries might consist
  % of hyphenated-identifiers-that-do-not-fit-on-a-line-and-nothing-else.)
  \def\tocentry#1#2{\begingroup
    \vskip 0pt plus1pt % allow a little stretch for the sake of nice page breaks
!   % Do not use \turnoffactive in these arguments.  Since the toc is
!   % typeset in cmr, so characters such as _ would come out wrong; we
!   % have to do the usual translation tricks.
!   \entry{#1}{#2}%
  \endgroup}
  
***************
*** 3286,3289 ****
--- 3965,3969 ----
  
  \message{environments,}
+ % @foo ... @end foo.
  
  % Since these characters are used in examples, it should be an even number of
***************
*** 3336,3364 ****
  
  \def\tex{\begingroup
! \catcode `\\=0 \catcode `\{=1 \catcode `\}=2
! \catcode `\$=3 \catcode `\&=4 \catcode `\#=6
! \catcode `\^=7 \catcode `\_=8 \catcode `\~=13 \let~=\tie
! \catcode `\%=14
! \catcode 43=12 % plus
! \catcode`\"=12
! \catcode`\==12
! \catcode`\|=12
! \catcode`\<=12
! \catcode`\>=12
! \escapechar=`\\
! %
! \let\,=\ptexcomma
! \let\~=\ptextilde
! \let\{=\ptexlbrace
! \let\}=\ptexrbrace
! \let\.=\ptexdot
! \let\*=\ptexstar
! \let\dots=\ptexdots
! \def\endldots{\mathinner{\ldots\ldots\ldots\ldots}}
! \def\enddots{\relax\ifmmode\endldots\else$\mathsurround=0pt \endldots\,$\fi}
! \def\@{@}%
! \let\bullet=\ptexbullet
! \let\b=\ptexb \let\c=\ptexc \let\i=\ptexi \let\t=\ptext
! %
  \let\Etex=\endgroup}
  
--- 4016,4049 ----
  
  \def\tex{\begingroup
!   \catcode `\\=0 \catcode `\{=1 \catcode `\}=2
!   \catcode `\$=3 \catcode `\&=4 \catcode `\#=6
!   \catcode `\^=7 \catcode `\_=8 \catcode `\~=13 \let~=\tie
!   \catcode `\%=14
!   \catcode 43=12 % plus
!   \catcode`\"=12
!   \catcode`\==12
!   \catcode`\|=12
!   \catcode`\<=12
!   \catcode`\>=12
!   \escapechar=`\\
!   %
!   \let\b=\ptexb
!   \let\bullet=\ptexbullet
!   \let\c=\ptexc
!   \let\,=\ptexcomma
!   \let\.=\ptexdot
!   \let\dots=\ptexdots
!   \let\equiv=\ptexequiv
!   \let\!=\ptexexclam
!   \let\i=\ptexi
!   \let\{=\ptexlbrace
!   \let\+=\tabalign
!   \let\}=\ptexrbrace
!   \let\*=\ptexstar
!   \let\t=\ptext
!   %
!   \def\endldots{\mathinner{\ldots\ldots\ldots\ldots}}%
!   \def\enddots{\relax\ifmmode\endldots\else$\mathsurround=0pt \endldots\,$\fi}%
!   \def\@{@}%
  \let\Etex=\endgroup}
  
***************
*** 3405,3410 ****
  \let\nonarrowing=\relax
  
! %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
! % \cartouche: draw rectangle w/rounded corners around argument
  \font\circle=lcircle10
  \newdimen\circthick
--- 4090,4095 ----
  \let\nonarrowing=\relax
  
! % @cartouche ... @end cartouche: draw rectangle w/rounded corners around
! % environment contents.
  \font\circle=lcircle10
  \newdimen\circthick
***************
*** 3433,3439 ****
                            \advance\cartinner by-\rskip
          \cartouter=\hsize
!         \advance\cartouter by 18pt % allow for 3pt kerns on either
  %                                    side, and for 6pt waste from
! %                                    each corner char
          \normbskip=\baselineskip \normpskip=\parskip \normlskip=\lineskip
          % Flag to tell @lisp, etc., not to narrow margin.
--- 4118,4124 ----
                            \advance\cartinner by-\rskip
          \cartouter=\hsize
!         \advance\cartouter by 18.4pt % allow for 3pt kerns on either
  %                                    side, and for 6pt waste from
! %                                    each corner char, and rule thickness
          \normbskip=\baselineskip \normpskip=\parskip \normlskip=\lineskip
          % Flag to tell @lisp, etc., not to narrow margin.
***************
*** 3489,3534 ****
  }
  
! % To ending an @example-like environment, we first end the paragraph
! % (via \afterenvbreak's vertical glue), and then the group.  That way we
! % keep the zero \parskip that the environments set -- \parskip glue
! % will be inserted at the beginning of the next paragraph in the
! % document, after the environment.
  %
! \def\nonfillfinish{\afterenvbreak\endgroup}%
  
! % This macro is
  \def\lisp{\begingroup
    \nonfillstart
    \let\Elisp = \nonfillfinish
    \tt
!   \rawbackslash % have \ input char produce \ char from current font
!   \gobble
  }
  
! % Define the \E... control sequence only if we are inside the
! % environment, so the error checking in \end will work.
! %
! % We must call \lisp last in the definition, since it reads the
! % return following the @example (or whatever) command.
! %
  \def\example{\begingroup \def\Eexample{\nonfillfinish\endgroup}\lisp}
- \def\smallexample{\begingroup \def\Esmallexample{\nonfillfinish\endgroup}\lisp}
- \def\smalllisp{\begingroup \def\Esmalllisp{\nonfillfinish\endgroup}\lisp}
  
! % @smallexample and @smalllisp.  This is not used unless the @smallbook
! % command is given.  Originally contributed by Pavel@xerox.
! %
  \def\smalllispx{\begingroup
!   \nonfillstart
!   \let\Esmalllisp = \nonfillfinish
!   \let\Esmallexample = \nonfillfinish
!   %
!   % Smaller fonts for small examples.
!   \indexfonts \tt
!   \rawbackslash % make \ output the \ character from the current font (tt)
!   \gobble
  }
  
! % This is @display; same as @lisp except use roman font.
  %
  \def\display{\begingroup
--- 4174,4223 ----
  }
  
! % Define the \E... control sequence only if we are inside the particular
! % environment, so the error checking in \end will work.
  %
! % To end an @example-like environment, we first end the paragraph (via
! % \afterenvbreak's vertical glue), and then the group.  That way we keep
! % the zero \parskip that the environments set -- \parskip glue will be
! % inserted at the beginning of the next paragraph in the document, after
! % the environment.
! %
! \def\nonfillfinish{\afterenvbreak\endgroup}
  
! % @lisp: indented, narrowed, typewriter font.
  \def\lisp{\begingroup
    \nonfillstart
    \let\Elisp = \nonfillfinish
    \tt
!   \let\kbdfont = \kbdexamplefont % Allow @kbd to do something special.
!   \gobble       % eat return
  }
  
! % @example: Same as @lisp.
  \def\example{\begingroup \def\Eexample{\nonfillfinish\endgroup}\lisp}
  
! % @small... is usually equivalent to the non-small (@smallbook
! % redefines).  We must call \example (or whatever) last in the
! % definition, since it reads the return following the @example (or
! % whatever) command.
! %
! % This actually allows (for example) @end display inside an
! % @smalldisplay.  Too bad, but makeinfo will catch the error anyway.
! %
! \def\smalldisplay{\begingroup\def\Esmalldisplay{\nonfillfinish\endgroup}\display}
! \def\smallexample{\begingroup\def\Esmallexample{\nonfillfinish\endgroup}\lisp}
! \def\smallformat{\begingroup\def\Esmallformat{\nonfillfinish\endgroup}\format}
! \def\smalllisp{\begingroup\def\Esmalllisp{\nonfillfinish\endgroup}\lisp}
! 
! % Real @smallexample and @smalllisp (when @smallbook): use smaller fonts.
! % Originally contributed by Pavel@xerox.
  \def\smalllispx{\begingroup
!   \def\Esmalllisp{\nonfillfinish\endgroup}%
!   \def\Esmallexample{\nonfillfinish\endgroup}%
!   \smallfonts
!   \lisp
  }
  
! % @display: same as @lisp except keep current font.
  %
  \def\display{\begingroup
***************
*** 3538,3542 ****
  }
  
! % This is @format; same as @display except don't narrow margins.
  %
  \def\format{\begingroup
--- 4227,4239 ----
  }
  
! % @smalldisplay (when @smallbook): @display plus smaller fonts.
! %
! \def\smalldisplayx{\begingroup
!   \def\Esmalldisplay{\nonfillfinish\endgroup}%
!   \smallfonts \rm
!   \display
! }
! 
! % @format: same as @display except don't narrow margins.
  %
  \def\format{\begingroup
***************
*** 3547,3558 ****
  }
  
! % @flushleft (same as @format) and @flushright.
  %
! \def\flushleft{\begingroup
!   \let\nonarrowing = t
!   \nonfillstart
!   \let\Eflushleft = \nonfillfinish
!   \gobble
  }
  \def\flushright{\begingroup
    \let\nonarrowing = t
--- 4244,4261 ----
  }
  
! % @smallformat (when @smallbook): @format plus smaller fonts.
  %
! \def\smallformatx{\begingroup
!   \def\Esmallformat{\nonfillfinish\endgroup}%
!   \smallfonts \rm
!   \format
  }
+ 
+ % @flushleft (same as @format).
+ %
+ \def\flushleft{\begingroup \def\Eflushleft{\nonfillfinish\endgroup}\format}
+ 
+ % @flushright.
+ %
  \def\flushright{\begingroup
    \let\nonarrowing = t
***************
*** 3560,3564 ****
    \let\Eflushright = \nonfillfinish
    \advance\leftskip by 0pt plus 1fill
!   \gobble}
  
  % @quotation does normal linebreaking (hence we can't use \nonfillstart)
--- 4263,4268 ----
    \let\Eflushright = \nonfillfinish
    \advance\leftskip by 0pt plus 1fill
!   \gobble
! }
  
  % @quotation does normal linebreaking (hence we can't use \nonfillstart)
***************
*** 3583,3589 ****
  }
  
  \message{defuns,}
! % Define formatter for defuns
! % First, allow user to change definition object font (\df) internally
  \def\setdeffont #1 {\csname DEF#1\endcsname}
  
--- 4287,4295 ----
  }
  
+ 
  \message{defuns,}
! % @defun etc.
! 
! % Allow user to change definition object font (\df) internally
  \def\setdeffont #1 {\csname DEF#1\endcsname}
  
***************
*** 3619,3624 ****
  % Definitions of (, ) and & used in args for functions.
  % This is the definition of ( outside of all parentheses.
! \gdef\oprm#1 {{\rm\char`\(}#1 \bf \let(=\opnested %
! \global\advance\parencount by 1 }
  %
  % This is the definition of ( when already inside a level of parens.
--- 4325,4331 ----
  % Definitions of (, ) and & used in args for functions.
  % This is the definition of ( outside of all parentheses.
! \gdef\oprm#1 {{\rm\char`\(}#1 \bf \let(=\opnested
!   \global\advance\parencount by 1
! }
  %
  % This is the definition of ( when already inside a level of parens.
***************
*** 3626,3632 ****
  %
  \gdef\clrm{% Print a paren in roman if it is taking us back to depth of 0.
! % also in that case restore the outer-level definition of (.
! \ifnum \parencount=1 {\rm \char `\)}\sl \let(=\oprm \else \char `\) \fi
! \global\advance \parencount by -1 }
  % If we encounter &foo, then turn on ()-hacking afterwards
  \gdef\amprm#1 {{\rm\&#1}\let(=\oprm \let)=\clrm\ }
--- 4333,4339 ----
  %
  \gdef\clrm{% Print a paren in roman if it is taking us back to depth of 0.
!   % also in that case restore the outer-level definition of (.
!   \ifnum \parencount=1 {\rm \char `\)}\sl \let(=\oprm \else \char `\) \fi
!   \global\advance \parencount by -1 }
  % If we encounter &foo, then turn on ()-hacking afterwards
  \gdef\amprm#1 {{\rm\&#1}\let(=\oprm \let)=\clrm\ }
***************
*** 3636,3641 ****
  %% These parens (in \boldbrax) actually are a little bolder than the
  %% contained text.  This is especially needed for [ and ]
! \def\opnr{{\sf\char`\(}} \def\clnr{{\sf\char`\)}} \def\ampnr{\&}
! \def\lbrb{{\bf\char`\[}} \def\rbrb{{\bf\char`\]}}
  
  % First, defname, which formats the header line itself.
--- 4343,4357 ----
  %% These parens (in \boldbrax) actually are a little bolder than the
  %% contained text.  This is especially needed for [ and ]
! \def\opnr{{\sf\char`\(}\global\advance\parencount by 1 }
! \def\clnr{{\sf\char`\)}\global\advance\parencount by -1 }
! \let\ampnr = \&
! \def\lbrb{{\bf\char`\[}}
! \def\rbrb{{\bf\char`\]}}
! 
! % Active &'s sneak into the index arguments, so make sure it's defined.
! {
!   \catcode`& = 13
!   \global\let& = \ampnr
! }
  
  % First, defname, which formats the header line itself.
***************
*** 3648,3658 ****
  \dimen2=\leftskip
  \advance\dimen2 by -\defbodyindent
! \dimen3=\rightskip
! \advance\dimen3 by -\defbodyindent
! \noindent        %
  \setbox0=\hbox{\hskip \deflastargmargin{\rm #2}\hskip \deftypemargin}%
  \dimen0=\hsize \advance \dimen0 by -\wd0 % compute size for first line
  \dimen1=\hsize \advance \dimen1 by -\defargsindent %size for continuations
! \parshape 2 0in \dimen0 \defargsindent \dimen1     %
  % Now output arg 2 ("Function" or some such)
  % ending at \deftypemargin from the right margin,
--- 4364,4372 ----
  \dimen2=\leftskip
  \advance\dimen2 by -\defbodyindent
! \noindent
  \setbox0=\hbox{\hskip \deflastargmargin{\rm #2}\hskip \deftypemargin}%
  \dimen0=\hsize \advance \dimen0 by -\wd0 % compute size for first line
  \dimen1=\hsize \advance \dimen1 by -\defargsindent %size for continuations
! \parshape 2 0in \dimen0 \defargsindent \dimen1
  % Now output arg 2 ("Function" or some such)
  % ending at \deftypemargin from the right margin,
***************
*** 3660,3665 ****
  {% Adjust \hsize to exclude the ambient margins,
  % so that \rightline will obey them.
! \advance \hsize by -\dimen2 \advance \hsize by -\dimen3
! \rlap{\rightline{{\rm #2}\hskip \deftypemargin}}}%
  % Make all lines underfull and no complaints:
  \tolerance=10000 \hbadness=10000
--- 4374,4379 ----
  {% Adjust \hsize to exclude the ambient margins,
  % so that \rightline will obey them.
! \advance \hsize by -\dimen2
! \rlap{\rightline{{\rm #2}\hskip -1.25pc }}}%
  % Make all lines underfull and no complaints:
  \tolerance=10000 \hbadness=10000
***************
*** 3682,3686 ****
  \def#2{\begingroup\obeylines\activeparens\spacesplit#3}%
  \parindent=0in
! \advance\leftskip by \defbodyindent \advance \rightskip by \defbodyindent
  \exdentamount=\defbodyindent
  \begingroup %
--- 4396,4400 ----
  \def#2{\begingroup\obeylines\activeparens\spacesplit#3}%
  \parindent=0in
! \advance\leftskip by \defbodyindent
  \exdentamount=\defbodyindent
  \begingroup %
***************
*** 3688,3692 ****
  \obeylines\activeparens\spacesplit#3}
  
! \def\defmethparsebody #1#2#3#4 {\begingroup\inENV %
  \medbreak %
  % Define the end token that this defining construct specifies
--- 4402,4411 ----
  \obeylines\activeparens\spacesplit#3}
  
! % #1 is the \E... control sequence to end the definition (which we define).
! % #2 is the \...x control sequence for consecutive fns (which we define).
! % #3 is the control sequence to call to resume processing.
! % #4, delimited by the space, is the class name.
! %
! \def\defmethparsebody#1#2#3#4 {\begingroup\inENV %
  \medbreak %
  % Define the end token that this defining construct specifies
***************
*** 3695,3702 ****
  \def#2##1 {\begingroup\obeylines\activeparens\spacesplit{#3{##1}}}%
  \parindent=0in
! \advance\leftskip by \defbodyindent \advance \rightskip by \defbodyindent
  \exdentamount=\defbodyindent
  \begingroup\obeylines\activeparens\spacesplit{#3{#4}}}
  
  \def\defopparsebody #1#2#3#4#5 {\begingroup\inENV %
  \medbreak %
--- 4414,4455 ----
  \def#2##1 {\begingroup\obeylines\activeparens\spacesplit{#3{##1}}}%
  \parindent=0in
! \advance\leftskip by \defbodyindent
  \exdentamount=\defbodyindent
  \begingroup\obeylines\activeparens\spacesplit{#3{#4}}}
  
+ % Used for @deftypemethod and @deftypeivar.
+ % #1 is the \E... control sequence to end the definition (which we define).
+ % #2 is the \...x control sequence for consecutive fns (which we define).
+ % #3 is the control sequence to call to resume processing.
+ % #4, delimited by a space, is the class name.
+ % #5 is the method's return type.
+ %
+ \def\deftypemethparsebody#1#2#3#4 #5 {\begingroup\inENV
+   \medbreak
+   \def#1{\endgraf\endgroup\medbreak}%
+   \def#2##1 ##2 {\begingroup\obeylines\activeparens\spacesplit{#3{##1}{##2}}}%
+   \parindent=0in
+   \advance\leftskip by \defbodyindent
+   \exdentamount=\defbodyindent
+   \begingroup\obeylines\activeparens\spacesplit{#3{#4}{#5}}}
+ 
+ % Used for @deftypeop.  The change from \deftypemethparsebody is an
+ % extra argument at the beginning which is the `category', instead of it
+ % being the hardwired string `Method' or `Instance Variable'.  We have
+ % to account for this both in the \...x definition and in parsing the
+ % input at hand.  Thus also need a control sequence (passed as #5) for
+ % the \E... definition to assign the category name to.
+ % 
+ \def\deftypeopparsebody#1#2#3#4#5 #6 {\begingroup\inENV
+   \medbreak
+   \def#1{\endgraf\endgroup\medbreak}%
+   \def#2##1 ##2 ##3 {%
+     \def#4{##1}%
+     \begingroup\obeylines\activeparens\spacesplit{#3{##2}{##3}}}%
+   \parindent=0in
+   \advance\leftskip by \defbodyindent
+   \exdentamount=\defbodyindent
+   \begingroup\obeylines\activeparens\spacesplit{#3{#5}{#6}}}
+ 
  \def\defopparsebody #1#2#3#4#5 {\begingroup\inENV %
  \medbreak %
***************
*** 3707,3711 ****
  \begingroup\obeylines\activeparens\spacesplit{#3{##2}}}%
  \parindent=0in
! \advance\leftskip by \defbodyindent \advance \rightskip by \defbodyindent
  \exdentamount=\defbodyindent
  \begingroup\obeylines\activeparens\spacesplit{#3{#5}}}
--- 4460,4464 ----
  \begingroup\obeylines\activeparens\spacesplit{#3{##2}}}%
  \parindent=0in
! \advance\leftskip by \defbodyindent
  \exdentamount=\defbodyindent
  \begingroup\obeylines\activeparens\spacesplit{#3{#5}}}
***************
*** 3722,3726 ****
  \def#2{\begingroup\obeylines\spacesplit#3}%
  \parindent=0in
! \advance\leftskip by \defbodyindent \advance \rightskip by \defbodyindent
  \exdentamount=\defbodyindent
  \begingroup %
--- 4475,4479 ----
  \def#2{\begingroup\obeylines\spacesplit#3}%
  \parindent=0in
! \advance\leftskip by \defbodyindent
  \exdentamount=\defbodyindent
  \begingroup %
***************
*** 3730,3734 ****
  % This is used for \def{tp,vr}parsebody.  It could probably be used for
  % some of the others, too, with some judicious conditionals.
! % 
  \def\parsebodycommon#1#2#3{%
    \begingroup\inENV %
--- 4483,4487 ----
  % This is used for \def{tp,vr}parsebody.  It could probably be used for
  % some of the others, too, with some judicious conditionals.
! %
  \def\parsebodycommon#1#2#3{%
    \begingroup\inENV %
***************
*** 3739,3743 ****
    \def#2##1 {\begingroup\obeylines\spacesplit{#3{##1}}}%
    \parindent=0in
!   \advance\leftskip by \defbodyindent \advance \rightskip by \defbodyindent
    \exdentamount=\defbodyindent
    \begingroup\obeylines
--- 4492,4496 ----
    \def#2##1 {\begingroup\obeylines\spacesplit{#3{##1}}}%
    \parindent=0in
!   \advance\leftskip by \defbodyindent
    \exdentamount=\defbodyindent
    \begingroup\obeylines
***************
*** 3764,3778 ****
  
  % Fine, but then we have to eventually remove the \empty *and* the
! % braces (if any).  That's what this does, putting the result in \tptemp.
! % 
! \def\removeemptybraces\empty#1\relax{\def\tptemp{#1}}%
  
  % After \spacesplit has done its work, this is called -- #1 is the final
  % thing to call, #2 the type name (which starts with \empty), and #3
  % (which might be empty) the arguments.
! % 
  \def\parsetpheaderline#1#2#3{%
!   \removeemptybraces#2\relax
!   #1{\tptemp}{#3}%
  }%
  
--- 4517,4530 ----
  
  % Fine, but then we have to eventually remove the \empty *and* the
! % braces (if any).  That's what this does.
! %
! \def\removeemptybraces\empty#1\relax{#1}
  
  % After \spacesplit has done its work, this is called -- #1 is the final
  % thing to call, #2 the type name (which starts with \empty), and #3
  % (which might be empty) the arguments.
! %
  \def\parsetpheaderline#1#2#3{%
!   #1{\removeemptybraces#2\relax}{#3}%
  }%
  
***************
*** 3785,3789 ****
  \begingroup\obeylines\spacesplit{#3{##2}}}%
  \parindent=0in
! \advance\leftskip by \defbodyindent \advance \rightskip by \defbodyindent
  \exdentamount=\defbodyindent
  \begingroup\obeylines\spacesplit{#3{#5}}}
--- 4537,4541 ----
  \begingroup\obeylines\spacesplit{#3{##2}}}%
  \parindent=0in
! \advance\leftskip by \defbodyindent
  \exdentamount=\defbodyindent
  \begingroup\obeylines\spacesplit{#3{#5}}}
***************
*** 3809,3822 ****
  % Use this to expand the args and terminate the paragraph they make up
  
! \def\defunargs #1{\functionparens \sl
  % Expand, preventing hyphenation at `-' chars.
  % Note that groups don't affect changes in \hyphenchar.
! \hyphenchar\tensl=0
  #1%
! \hyphenchar\tensl=45
! \ifnum\parencount=0 \else \errmessage{unbalanced parens in @def arguments}\fi%
  \interlinepenalty=10000
  \advance\rightskip by 0pt plus 1fil
! \endgraf\penalty 10000\vskip -\parskip\penalty 10000%
  }
  
--- 4561,4575 ----
  % Use this to expand the args and terminate the paragraph they make up
  
! \def\defunargs#1{\functionparens \sl
  % Expand, preventing hyphenation at `-' chars.
  % Note that groups don't affect changes in \hyphenchar.
! % Set the font temporarily and use \font in case \setfont made \tensl a macro.
! {\tensl\hyphenchar\font=0}%
  #1%
! {\tensl\hyphenchar\font=45}%
! \ifnum\parencount=0 \else \errmessage{Unbalanced parentheses in @def}\fi%
  \interlinepenalty=10000
  \advance\rightskip by 0pt plus 1fil
! \endgraf\nobreak\vskip -\parskip\nobreak
  }
  
***************
*** 3829,3833 ****
  \interlinepenalty=10000
  \advance\rightskip by 0pt plus 1fil
! \endgraf\penalty 10000\vskip -\parskip\penalty 10000%
  }
  
--- 4582,4586 ----
  \interlinepenalty=10000
  \advance\rightskip by 0pt plus 1fil
! \endgraf\nobreak\vskip -\parskip\nobreak
  }
  
***************
*** 3848,3852 ****
  
  \def\defunheader #1#2{\doind {fn}{\code{#1}}% Make entry in function index
! \begingroup\defname {#1}{Function}%
  \defunargs {#2}\endgroup %
  \catcode 61=\other % Turn off change made in \defparsebody
--- 4601,4605 ----
  
  \def\defunheader #1#2{\doind {fn}{\code{#1}}% Make entry in function index
! \begingroup\defname {#1}{\putwordDeffunc}%
  \defunargs {#2}\endgroup %
  \catcode 61=\other % Turn off change made in \defparsebody
***************
*** 3862,3866 ****
  \def\deftypefunheaderx #1#2 #3\relax{%
  \doind {fn}{\code{#2}}% Make entry in function index
! \begingroup\defname {\defheaderxcond#1\relax$$$#2}{Function}%
  \deftypefunargs {#3}\endgroup %
  \catcode 61=\other % Turn off change made in \defparsebody
--- 4615,4619 ----
  \def\deftypefunheaderx #1#2 #3\relax{%
  \doind {fn}{\code{#2}}% Make entry in function index
! \begingroup\defname {\defheaderxcond#1\relax$$$#2}{\putwordDeftypefun}%
  \deftypefunargs {#3}\endgroup %
  \catcode 61=\other % Turn off change made in \defparsebody
***************
*** 3893,3897 ****
  
  \def\defmacheader #1#2{\doind {fn}{\code{#1}}% Make entry in function index
! \begingroup\defname {#1}{Macro}%
  \defunargs {#2}\endgroup %
  \catcode 61=\other % Turn off change made in \defparsebody
--- 4646,4650 ----
  
  \def\defmacheader #1#2{\doind {fn}{\code{#1}}% Make entry in function index
! \begingroup\defname {#1}{\putwordDefmac}%
  \defunargs {#2}\endgroup %
  \catcode 61=\other % Turn off change made in \defparsebody
***************
*** 3903,3942 ****
  
  \def\defspecheader #1#2{\doind {fn}{\code{#1}}% Make entry in function index
! \begingroup\defname {#1}{Special Form}%
  \defunargs {#2}\endgroup %
  \catcode 61=\other % Turn off change made in \defparsebody
  }
  
! % This definition is run if you use @defunx
! % anywhere other than immediately after a @defun or @defunx.
! 
! \def\deffnx #1 {\errmessage{@deffnx in invalid context}}
! \def\defunx #1 {\errmessage{@defunx in invalid context}}
! \def\defmacx #1 {\errmessage{@defmacx in invalid context}}
! \def\defspecx #1 {\errmessage{@defspecx in invalid context}}
! \def\deftypefnx #1 {\errmessage{@deftypefnx in invalid context}}
! \def\deftypeunx #1 {\errmessage{@deftypeunx in invalid context}}
! 
! % @defmethod, and so on
! 
! % @defop {Funny Method} foo-class frobnicate argument
! 
  \def\defop #1 {\def\defoptype{#1}%
  \defopparsebody\Edefop\defopx\defopheader\defoptype}
! 
! \def\defopheader #1#2#3{%
! \dosubind {fn}{\code{#2}}{on #1}% Make entry in function index
! \begingroup\defname {#2}{\defoptype{} on #1}%
  \defunargs {#3}\endgroup %
  }
  
! % @defmethod == @defop Method
  
! \def\defmethod{\defmethparsebody\Edefmethod\defmethodx\defmethodheader}
  
! \def\defmethodheader #1#2#3{%
! \dosubind {fn}{\code{#2}}{on #1}% entry in function index
! \begingroup\defname {#2}{Method on #1}%
! \defunargs {#3}\endgroup %
  }
  
--- 4656,4730 ----
  
  \def\defspecheader #1#2{\doind {fn}{\code{#1}}% Make entry in function index
! \begingroup\defname {#1}{\putwordDefspec}%
  \defunargs {#2}\endgroup %
  \catcode 61=\other % Turn off change made in \defparsebody
  }
  
! % @defop CATEGORY CLASS OPERATION ARG...
! %
  \def\defop #1 {\def\defoptype{#1}%
  \defopparsebody\Edefop\defopx\defopheader\defoptype}
! %
! \def\defopheader#1#2#3{%
! \dosubind {fn}{\code{#2}}{\putwordon\ #1}% Make entry in function index
! \begingroup\defname {#2}{\defoptype\ \putwordon\ #1}%
  \defunargs {#3}\endgroup %
  }
  
! % @deftypeop CATEGORY CLASS TYPE OPERATION ARG...
! %
! \def\deftypeop #1 {\def\deftypeopcategory{#1}%
!   \deftypeopparsebody\Edeftypeop\deftypeopx\deftypeopheader
!                        \deftypeopcategory}
! %
! % #1 is the class name, #2 the data type, #3 the operation name, #4 the args.
! \def\deftypeopheader#1#2#3#4{%
!   \dosubind{fn}{\code{#3}}{\putwordon\ \code{#1}}% entry in function index
!   \begingroup
!     \defname{\defheaderxcond#2\relax$$$#3}
!             {\deftypeopcategory\ \putwordon\ \code{#1}}%
!     \deftypefunargs{#4}%
!   \endgroup
! }
  
! % @deftypemethod CLASS TYPE METHOD ARG...
! %
! \def\deftypemethod{%
!   \deftypemethparsebody\Edeftypemethod\deftypemethodx\deftypemethodheader}
! %
! % #1 is the class name, #2 the data type, #3 the method name, #4 the args.
! \def\deftypemethodheader#1#2#3#4{%
!   \dosubind{fn}{\code{#3}}{\putwordon\ \code{#1}}% entry in function index
!   \begingroup
!     \defname{\defheaderxcond#2\relax$$$#3}{\putwordMethodon\ \code{#1}}%
!     \deftypefunargs{#4}%
!   \endgroup
! }
  
! % @deftypeivar CLASS TYPE VARNAME
! %
! \def\deftypeivar{%
!   \deftypemethparsebody\Edeftypeivar\deftypeivarx\deftypeivarheader}
! %
! % #1 is the class name, #2 the data type, #3 the variable name.
! \def\deftypeivarheader#1#2#3{%
!   \dosubind{vr}{\code{#3}}{\putwordof\ \code{#1}}% entry in variable index
!   \begingroup
!     \defname{#3}{\putwordInstanceVariableof\ \code{#1}}%
!     \defvarargs{#3}%
!   \endgroup
! }
! 
! % @defmethod == @defop Method
! %
! \def\defmethod{\defmethparsebody\Edefmethod\defmethodx\defmethodheader}
! %
! % #1 is the class name, #2 the method name, #3 the args.
! \def\defmethodheader#1#2#3{%
!   \dosubind{fn}{\code{#2}}{\putwordon\ \code{#1}}% entry in function index
!   \begingroup
!     \defname{#2}{\putwordMethodon\ \code{#1}}%
!     \defunargs{#3}%
!   \endgroup
  }
  
***************
*** 3947,3975 ****
  
  \def\defcvarheader #1#2#3{%
! \dosubind {vr}{\code{#2}}{of #1}% Make entry in var index
! \begingroup\defname {#2}{\defcvtype{} of #1}%
  \defvarargs {#3}\endgroup %
  }
  
! % @defivar == @defcv {Instance Variable}
! 
  \def\defivar{\defvrparsebody\Edefivar\defivarx\defivarheader}
! 
! \def\defivarheader #1#2#3{%
! \dosubind {vr}{\code{#2}}{of #1}% Make entry in var index
! \begingroup\defname {#2}{Instance Variable of #1}%
! \defvarargs {#3}\endgroup %
  }
  
! % These definitions are run if you use @defmethodx, etc.,
! % anywhere other than immediately after a @defmethod, etc.
! 
! \def\defopx #1 {\errmessage{@defopx in invalid context}}
! \def\defmethodx #1 {\errmessage{@defmethodx in invalid context}}
! \def\defcvx #1 {\errmessage{@defcvx in invalid context}}
! \def\defivarx #1 {\errmessage{@defivarx in invalid context}}
! 
! % Now @defvar
! 
  % First, define the processing that is wanted for arguments of @defvar.
  % This is actually simple: just print them in roman.
--- 4735,4756 ----
  
  \def\defcvarheader #1#2#3{%
! \dosubind {vr}{\code{#2}}{\putwordof\ #1}% Make entry in var index
! \begingroup\defname {#2}{\defcvtype\ \putwordof\ #1}%
  \defvarargs {#3}\endgroup %
  }
  
! % @defivar CLASS VARNAME == @defcv {Instance Variable} CLASS VARNAME
! %
  \def\defivar{\defvrparsebody\Edefivar\defivarx\defivarheader}
! %
! \def\defivarheader#1#2#3{%
!   \dosubind {vr}{\code{#2}}{\putwordof\ #1}% entry in var index
!   \begingroup
!     \defname{#2}{\putwordInstanceVariableof\ #1}%
!     \defvarargs{#3}%
!   \endgroup
  }
  
! % @defvar
  % First, define the processing that is wanted for arguments of @defvar.
  % This is actually simple: just print them in roman.
***************
*** 3977,3981 ****
  \def\defvarargs #1{\normalparens #1%
  \interlinepenalty=10000
! \endgraf\penalty 10000\vskip -\parskip\penalty 10000}
  
  % @defvr Counter foo-count
--- 4758,4762 ----
  \def\defvarargs #1{\normalparens #1%
  \interlinepenalty=10000
! \endgraf\nobreak\vskip -\parskip\nobreak}
  
  % @defvr Counter foo-count
***************
*** 3991,3995 ****
  
  \def\defvarheader #1#2{\doind {vr}{\code{#1}}% Make entry in var index
! \begingroup\defname {#1}{Variable}%
  \defvarargs {#2}\endgroup %
  }
--- 4772,4776 ----
  
  \def\defvarheader #1#2{\doind {vr}{\code{#1}}% Make entry in var index
! \begingroup\defname {#1}{\putwordDefvar}%
  \defvarargs {#2}\endgroup %
  }
***************
*** 4000,4004 ****
  
  \def\defoptheader #1#2{\doind {vr}{\code{#1}}% Make entry in var index
! \begingroup\defname {#1}{User Option}%
  \defvarargs {#2}\endgroup %
  }
--- 4781,4785 ----
  
  \def\defoptheader #1#2{\doind {vr}{\code{#1}}% Make entry in var index
! \begingroup\defname {#1}{\putwordDefopt}%
  \defvarargs {#2}\endgroup %
  }
***************
*** 4008,4018 ****
  \def\deftypevar{\defvarparsebody\Edeftypevar\deftypevarx\deftypevarheader}
  
! % #1 is the data type.  #2 is the name.
  \def\deftypevarheader #1#2{%
! \doind {vr}{\code{#2}}% Make entry in variables index
! \begingroup\defname {\defheaderxcond#1\relax$$$#2}{Variable}%
  \interlinepenalty=10000
! \endgraf\penalty 10000\vskip -\parskip\penalty 10000
  \endgroup}
  
  % @deftypevr {Global Flag} int enable
--- 4789,4801 ----
  \def\deftypevar{\defvarparsebody\Edeftypevar\deftypevarx\deftypevarheader}
  
! % #1 is the data type.  #2 is the name, perhaps followed by text that
! % is actually part of the data type, which should not be put into the index.
  \def\deftypevarheader #1#2{%
! \dovarind#2 \relax% Make entry in variables index
! \begingroup\defname {\defheaderxcond#1\relax$$$#2}{\putwordDeftypevar}%
  \interlinepenalty=10000
! \endgraf\nobreak\vskip -\parskip\nobreak
  \endgroup}
+ \def\dovarind#1 #2\relax{\doind{vr}{\code{#1}}}
  
  % @deftypevr {Global Flag} int enable
***************
*** 4020,4038 ****
  \def\deftypevr{\defvrparsebody\Edeftypevr\deftypevrx\deftypevrheader}
  
! \def\deftypevrheader #1#2#3{\doind {vr}{\code{#3}}%
  \begingroup\defname {\defheaderxcond#2\relax$$$#3}{#1}
  \interlinepenalty=10000
! \endgraf\penalty 10000\vskip -\parskip\penalty 10000
  \endgroup}
  
- % This definition is run if you use @defvarx
- % anywhere other than immediately after a @defvar or @defvarx.
- 
- \def\defvrx #1 {\errmessage{@defvrx in invalid context}}
- \def\defvarx #1 {\errmessage{@defvarx in invalid context}}
- \def\defoptx #1 {\errmessage{@defoptx in invalid context}}
- \def\deftypevarx #1 {\errmessage{@deftypevarx in invalid context}}
- \def\deftypevrx #1 {\errmessage{@deftypevrx in invalid context}}
- 
  % Now define @deftp
  % Args are printed in bold, a slight difference from @defvar.
--- 4803,4812 ----
  \def\deftypevr{\defvrparsebody\Edeftypevr\deftypevrx\deftypevrheader}
  
! \def\deftypevrheader #1#2#3{\dovarind#3 \relax%
  \begingroup\defname {\defheaderxcond#2\relax$$$#3}{#1}
  \interlinepenalty=10000
! \endgraf\nobreak\vskip -\parskip\nobreak
  \endgroup}
  
  % Now define @deftp
  % Args are printed in bold, a slight difference from @defvar.
***************
*** 4047,4090 ****
  \begingroup\defname {#2}{#1}\deftpargs{#3}\endgroup}
  
! % This definition is run if you use @deftpx, etc
! % anywhere other than immediately after a @deftp, etc.
  
! \def\deftpx #1 {\errmessage{@deftpx in invalid context}}
  
  
! \message{cross reference,}
! % Define cross-reference macros
! \newwrite \auxfile
  
! \newif\ifhavexrefs  % True if xref values are known.
  \newif\ifwarnedxrefs  % True if we warned once that they aren't known.
  
! % @inforef is simple.
  \def\inforef #1{\inforefzzz #1,,,,**}
  \def\inforefzzz #1,#2,#3,#4**{\putwordSee{} \putwordInfo{} \putwordfile{} \file{\ignorespaces #3{}},
    node \samp{\ignorespaces#1{}}}
  
! % \setref{foo} defines a cross-reference point named foo.
  
! \def\setref#1{%
! \dosetq{#1-title}{Ytitle}%
! \dosetq{#1-pg}{Ypagenumber}%
! \dosetq{#1-snt}{Ysectionnumberandtype}}
! 
! \def\unnumbsetref#1{%
! \dosetq{#1-title}{Ytitle}%
! \dosetq{#1-pg}{Ypagenumber}%
! \dosetq{#1-snt}{Ynothing}}
! 
! \def\appendixsetref#1{%
! \dosetq{#1-title}{Ytitle}%
! \dosetq{#1-pg}{Ypagenumber}%
! \dosetq{#1-snt}{Yappendixletterandtype}}
! 
! % \xref, \pxref, and \ref generate cross-references to specified points.
! % For \xrefX, #1 is the node name, #2 the name of the Info
! % cross-reference, #3 the printed node name, #4 the name of the Info
! % file, #5 the name of the printed manual.  All but the node name can be
! % omitted.
  %
  \def\pxref#1{\putwordsee{} \xrefX[#1,,,,,,,]}
--- 4821,5206 ----
  \begingroup\defname {#2}{#1}\deftpargs{#3}\endgroup}
  
! % These definitions are used if you use @defunx (etc.)
! % anywhere other than immediately after a @defun or @defunx.
! % 
! \def\defcvx#1 {\errmessage{@defcvx in invalid context}}
! \def\deffnx#1 {\errmessage{@deffnx in invalid context}}
! \def\defivarx#1 {\errmessage{@defivarx in invalid context}}
! \def\defmacx#1 {\errmessage{@defmacx in invalid context}}
! \def\defmethodx#1 {\errmessage{@defmethodx in invalid context}}
! \def\defoptx #1 {\errmessage{@defoptx in invalid context}}
! \def\defopx#1 {\errmessage{@defopx in invalid context}}
! \def\defspecx#1 {\errmessage{@defspecx in invalid context}}
! \def\deftpx#1 {\errmessage{@deftpx in invalid context}}
! \def\deftypefnx#1 {\errmessage{@deftypefnx in invalid context}}
! \def\deftypefunx#1 {\errmessage{@deftypefunx in invalid context}}
! \def\deftypeivarx#1 {\errmessage{@deftypeivarx in invalid context}}
! \def\deftypemethodx#1 {\errmessage{@deftypemethodx in invalid context}}
! \def\deftypeopx#1 {\errmessage{@deftypeopx in invalid context}}
! \def\deftypevarx#1 {\errmessage{@deftypevarx in invalid context}}
! \def\deftypevrx#1 {\errmessage{@deftypevrx in invalid context}}
! \def\defunx#1 {\errmessage{@defunx in invalid context}}
! \def\defvarx#1 {\errmessage{@defvarx in invalid context}}
! \def\defvrx#1 {\errmessage{@defvrx in invalid context}}
! 
! 
! \message{macros,}
! % @macro.
! 
! % To do this right we need a feature of e-TeX, \scantokens,
! % which we arrange to emulate with a temporary file in ordinary TeX.
! \ifx\eTeXversion\undefined
!  \newwrite\macscribble
!  \def\scanmacro#1{%
!    \begingroup \newlinechar`\^^M
!    % Undo catcode changes of \startcontents and \doprintindex
!    \catcode`\@=0 \catcode`\\=12 \escapechar=`\@
!    % Append \endinput to make sure that TeX does not see the ending newline.
!    \toks0={#1\endinput}%
!    \immediate\openout\macscribble=\jobname.tmp
!    \immediate\write\macscribble{\the\toks0}%
!    \immediate\closeout\macscribble
!    \let\xeatspaces\eatspaces
!    \input \jobname.tmp
!    \endgroup
! }
! \else
! \def\scanmacro#1{%
! \begingroup \newlinechar`\^^M
! % Undo catcode changes of \startcontents and \doprintindex
! \catcode`\@=0 \catcode`\\=12 \escapechar=`\@
! \let\xeatspaces\eatspaces\scantokens{#1\endinput}\endgroup}
! \fi
! 
! \newcount\paramno   % Count of parameters
! \newtoks\macname    % Macro name
! \newif\ifrecursive  % Is it recursive?
! \def\macrolist{}    % List of all defined macros in the form
!                     % \do\macro1\do\macro2...
! 
! % Utility routines.
! % Thisdoes \let #1 = #2, except with \csnames.
! \def\cslet#1#2{%
! \expandafter\expandafter
! \expandafter\let
! \expandafter\expandafter
! \csname#1\endcsname
! \csname#2\endcsname}
  
! % Trim leading and trailing spaces off a string.
! % Concepts from aro-bend problem 15 (see CTAN).
! {\catcode`\@=11
! \gdef\eatspaces #1{\expandafter\trim@\expandafter{#1 }}
! \gdef\trim@ #1{\trim@@ @#1 @ #1 @ @@}
! \gdef\trim@@ #1@ #2@ #3@@{\trim@@@\empty #2 @}
! \def\unbrace#1{#1}
! \unbrace{\gdef\trim@@@ #1 } #2@{#1}
! }
! 
! % Trim a single trailing ^^M off a string.
! {\catcode`\^^M=12\catcode`\Q=3%
! \gdef\eatcr #1{\eatcra #1Q^^MQ}%
! \gdef\eatcra#1^^MQ{\eatcrb#1Q}%
! \gdef\eatcrb#1Q#2Q{#1}%
! }
! 
! % Macro bodies are absorbed as an argument in a context where
! % all characters are catcode 10, 11 or 12, except \ which is active
! % (as in normal texinfo). It is necessary to change the definition of \.
! 
! % It's necessary to have hard CRs when the macro is executed. This is
! % done by  making ^^M (\endlinechar) catcode 12 when reading the macro
! % body, and then making it the \newlinechar in \scanmacro.
! 
! \def\macrobodyctxt{%
!   \catcode`\~=12
!   \catcode`\^=12
!   \catcode`\_=12
!   \catcode`\|=12
!   \catcode`\<=12
!   \catcode`\>=12
!   \catcode`\+=12
!   \catcode`\{=12
!   \catcode`\}=12
!   \catcode`\@=12
!   \catcode`\^^M=12
!   \usembodybackslash}
! 
! \def\macroargctxt{%
!   \catcode`\~=12
!   \catcode`\^=12
!   \catcode`\_=12
!   \catcode`\|=12
!   \catcode`\<=12
!   \catcode`\>=12
!   \catcode`\+=12
!   \catcode`\@=12
!   \catcode`\\=12}
! 
! % \mbodybackslash is the definition of \ in @macro bodies.
! % It maps \foo\ => \csname macarg.foo\endcsname => #N
! % where N is the macro parameter number.
! % We define \csname macarg.\endcsname to be \realbackslash, so
! % \\ in macro replacement text gets you a backslash.
! 
! {\catcode`@=0 @catcode`@\=@active
!  @gdef@usembodybackslash{@let\=@mbodybackslash}
!  @gdef@mbodybackslash#1\{@csname macarg.#1@endcsname}
! }
! \expandafter\def\csname macarg.\endcsname{\realbackslash}
! 
! \def\macro{\recursivefalse\parsearg\macroxxx}
! \def\rmacro{\recursivetrue\parsearg\macroxxx}
! 
! \def\macroxxx#1{%
!   \getargs{#1}%           now \macname is the macname and \argl the arglist
!   \ifx\argl\empty       % no arguments
!      \paramno=0%
!   \else
!      \expandafter\parsemargdef \argl;%
!   \fi
!   \if1\csname ismacro.\the\macname\endcsname
!      \message{Warning: redefining \the\macname}%
!   \else
!      \expandafter\ifx\csname \the\macname\endcsname \relax
!      \else \errmessage{The name \the\macname\space is reserved}\fi
!      \global\cslet{macsave.\the\macname}{\the\macname}%
!      \global\expandafter\let\csname ismacro.\the\macname\endcsname=1%
!      % Add the macroname to \macrolist
!      \toks0 = \expandafter{\macrolist\do}%
!      \xdef\macrolist{\the\toks0
!        \expandafter\noexpand\csname\the\macname\endcsname}%
!   \fi
!   \begingroup \macrobodyctxt
!   \ifrecursive \expandafter\parsermacbody
!   \else \expandafter\parsemacbody
!   \fi}
! 
! \def\unmacro{\parsearg\unmacroxxx}
! \def\unmacroxxx#1{%
!   \if1\csname ismacro.#1\endcsname
!     \global\cslet{#1}{macsave.#1}%
!     \global\expandafter\let \csname ismacro.#1\endcsname=0%
!     % Remove the macro name from \macrolist
!     \begingroup
!       \edef\tempa{\expandafter\noexpand\csname#1\endcsname}%
!       \def\do##1{%
!         \def\tempb{##1}%
!         \ifx\tempa\tempb
!           % remove this
!         \else
!           \toks0 = \expandafter{\newmacrolist\do}%
!           \edef\newmacrolist{\the\toks0\expandafter\noexpand\tempa}%
!         \fi}%
!       \def\newmacrolist{}%
!       % Execute macro list to define \newmacrolist
!       \macrolist
!       \global\let\macrolist\newmacrolist
!     \endgroup
!   \else
!     \errmessage{Macro #1 not defined}%
!   \fi
! }
! 
! % This makes use of the obscure feature that if the last token of a
! % <parameter list> is #, then the preceding argument is delimited by
! % an opening brace, and that opening brace is not consumed.
! \def\getargs#1{\getargsxxx#1{}}
! \def\getargsxxx#1#{\getmacname #1 \relax\getmacargs}
! \def\getmacname #1 #2\relax{\macname={#1}}
! \def\getmacargs#1{\def\argl{#1}}
! 
! % Parse the optional {params} list.  Set up \paramno and \paramlist
! % so \defmacro knows what to do.  Define \macarg.blah for each blah
! % in the params list, to be ##N where N is the position in that list.
! % That gets used by \mbodybackslash (above).
! 
! % We need to get `macro parameter char #' into several definitions.
! % The technique used is stolen from LaTeX:  let \hash be something
! % unexpandable, insert that wherever you need a #, and then redefine
! % it to # just before using the token list produced.
! %
! % The same technique is used to protect \eatspaces till just before
! % the macro is used.
! 
! \def\parsemargdef#1;{\paramno=0\def\paramlist{}%
!         \let\hash\relax\let\xeatspaces\relax\parsemargdefxxx#1,;,}
! \def\parsemargdefxxx#1,{%
!   \if#1;\let\next=\relax
!   \else \let\next=\parsemargdefxxx
!     \advance\paramno by 1%
!     \expandafter\edef\csname macarg.\eatspaces{#1}\endcsname
!         {\xeatspaces{\hash\the\paramno}}%
!     \edef\paramlist{\paramlist\hash\the\paramno,}%
!   \fi\next}
! 
! % These two commands read recursive and nonrecursive macro bodies.
! % (They're different since rec and nonrec macros end differently.)
! 
! \long\def\parsemacbody#1@end macro%
! {\xdef\temp{\eatcr{#1}}\endgroup\defmacro}%
! \long\def\parsermacbody#1@end rmacro%
! {\xdef\temp{\eatcr{#1}}\endgroup\defmacro}%
! 
! % This defines the macro itself. There are six cases: recursive and
! % nonrecursive macros of zero, one, and many arguments.
! % Much magic with \expandafter here.
! % \xdef is used so that macro definitions will survive the file
! % they're defined in; @include reads the file inside a group.
! \def\defmacro{%
!   \let\hash=##% convert placeholders to macro parameter chars
!   \ifrecursive
!     \ifcase\paramno
!     % 0
!       \expandafter\xdef\csname\the\macname\endcsname{%
!         \noexpand\scanmacro{\temp}}%
!     \or % 1
!       \expandafter\xdef\csname\the\macname\endcsname{%
!          \bgroup\noexpand\macroargctxt
!          \noexpand\braceorline
!          \expandafter\noexpand\csname\the\macname xxx\endcsname}%
!       \expandafter\xdef\csname\the\macname xxx\endcsname##1{%
!          \egroup\noexpand\scanmacro{\temp}}%
!     \else % many
!       \expandafter\xdef\csname\the\macname\endcsname{%
!          \bgroup\noexpand\macroargctxt
!          \noexpand\csname\the\macname xx\endcsname}%
!       \expandafter\xdef\csname\the\macname xx\endcsname##1{%
!           \expandafter\noexpand\csname\the\macname xxx\endcsname ##1,}%
!       \expandafter\expandafter
!       \expandafter\xdef
!       \expandafter\expandafter
!         \csname\the\macname xxx\endcsname
!           \paramlist{\egroup\noexpand\scanmacro{\temp}}%
!     \fi
!   \else
!     \ifcase\paramno
!     % 0
!       \expandafter\xdef\csname\the\macname\endcsname{%
!         \noexpand\norecurse{\the\macname}%
!         \noexpand\scanmacro{\temp}\egroup}%
!     \or % 1
!       \expandafter\xdef\csname\the\macname\endcsname{%
!          \bgroup\noexpand\macroargctxt
!          \noexpand\braceorline
!          \expandafter\noexpand\csname\the\macname xxx\endcsname}%
!       \expandafter\xdef\csname\the\macname xxx\endcsname##1{%
!         \egroup
!         \noexpand\norecurse{\the\macname}%
!         \noexpand\scanmacro{\temp}\egroup}%
!     \else % many
!       \expandafter\xdef\csname\the\macname\endcsname{%
!          \bgroup\noexpand\macroargctxt
!          \expandafter\noexpand\csname\the\macname xx\endcsname}%
!       \expandafter\xdef\csname\the\macname xx\endcsname##1{%
!           \expandafter\noexpand\csname\the\macname xxx\endcsname ##1,}%
!       \expandafter\expandafter
!       \expandafter\xdef
!       \expandafter\expandafter
!       \csname\the\macname xxx\endcsname
!       \paramlist{%
!           \egroup
!           \noexpand\norecurse{\the\macname}%
!           \noexpand\scanmacro{\temp}\egroup}%
!     \fi
!   \fi}
  
+ \def\norecurse#1{\bgroup\cslet{#1}{macsave.#1}}
  
! % \braceorline decides whether the next nonwhitespace character is a
! % {.  If so it reads up to the closing }, if not, it reads the whole
! % line.  Whatever was read is then fed to the next control sequence
! % as an argument (by \parsebrace or \parsearg)
! \def\braceorline#1{\let\next=#1\futurelet\nchar\braceorlinexxx}
! \def\braceorlinexxx{%
!   \ifx\nchar\bgroup\else
!     \expandafter\parsearg
!   \fi \next}
! 
! % We mant to disable all macros during \shipout so that they are not
! % expanded by \write.
! \def\turnoffmacros{\begingroup \def\do##1{\let\noexpand##1=\relax}%
!   \edef\next{\macrolist}\expandafter\endgroup\next}
! 
! 
! % @alias.
! % We need some trickery to remove the optional spaces around the equal
! % sign.  Just make them active and then expand them all to nothing.
! \def\alias{\begingroup\obeyspaces\parsearg\aliasxxx}
! \def\aliasxxx #1{\aliasyyy#1\relax}
! \def\aliasyyy #1=#2\relax{\ignoreactivespaces
! \edef\next{\global\let\expandafter\noexpand\csname#1\endcsname=%
!            \expandafter\noexpand\csname#2\endcsname}%
! \expandafter\endgroup\next}
  
! 
! \message{cross references,}
! % @xref etc.
! 
! \newwrite\auxfile
! 
! \newif\ifhavexrefs    % True if xref values are known.
  \newif\ifwarnedxrefs  % True if we warned once that they aren't known.
  
! % @inforef is relatively simple.
  \def\inforef #1{\inforefzzz #1,,,,**}
  \def\inforefzzz #1,#2,#3,#4**{\putwordSee{} \putwordInfo{} \putwordfile{} \file{\ignorespaces #3{}},
    node \samp{\ignorespaces#1{}}}
  
! % @node's job is to define \lastnode.
! \def\node{\ENVcheck\parsearg\nodezzz}
! \def\nodezzz#1{\nodexxx [#1,]}
! \def\nodexxx[#1,#2]{\gdef\lastnode{#1}}
! \let\nwnode=\node
! \let\lastnode=\relax
! 
! % The sectioning commands (@chapter, etc.) call these.
! \def\donoderef{%
!   \ifx\lastnode\relax\else
!     \expandafter\expandafter\expandafter\setref{\lastnode}%
!       {Ysectionnumberandtype}%
!     \global\let\lastnode=\relax
!   \fi
! }
! \def\unnumbnoderef{%
!   \ifx\lastnode\relax\else
!     \expandafter\expandafter\expandafter\setref{\lastnode}{Ynothing}%
!     \global\let\lastnode=\relax
!   \fi
! }
! \def\appendixnoderef{%
!   \ifx\lastnode\relax\else
!     \expandafter\expandafter\expandafter\setref{\lastnode}%
!       {Yappendixletterandtype}%
!     \global\let\lastnode=\relax
!   \fi
! }
! 
  
! % @anchor{NAME} -- define xref target at arbitrary point.
! %
! \newcount\savesfregister
! \gdef\savesf{\relax \ifhmode \savesfregister=\spacefactor \fi}
! \gdef\restoresf{\relax \ifhmode \spacefactor=\savesfregister \fi}
! \gdef\anchor#1{\savesf \setref{#1}{Ynothing}\restoresf \ignorespaces}
! 
! % \setref{NAME}{SNT} defines a cross-reference point NAME, namely
! % NAME-title, NAME-pg, and NAME-SNT.  Called from \foonoderef.  We have
! % to set \indexdummies so commands such as @code in a section title
! % aren't expanded.  It would be nicer not to expand the titles in the
! % first place, but there's so many layers that that is hard to do.
! %
! \def\setref#1#2{{%
!   \indexdummies
!   \pdfmkdest{#1}%
!   \dosetq{#1-title}{Ytitle}%
!   \dosetq{#1-pg}{Ypagenumber}%
!   \dosetq{#1-snt}{#2}%
! }}
! 
! % @xref, @pxref, and @ref generate cross-references.  For \xrefX, #1 is
! % the node name, #2 the name of the Info cross-reference, #3 the printed
! % node name, #4 the name of the Info file, #5 the name of the printed
! % manual.  All but the node name can be omitted.
  %
  \def\pxref#1{\putwordsee{} \xrefX[#1,,,,,,,]}
***************
*** 4092,4095 ****
--- 5208,5212 ----
  \def\ref#1{\xrefX[#1,,,,,,,]}
  \def\xrefX[#1,#2,#3,#4,#5,#6]{\begingroup
+   \unsepspaces
    \def\printedmanual{\ignorespaces #5}%
    \def\printednodename{\ignorespaces #3}%
***************
*** 4104,4108 ****
        % Use the actual chapter/section title appear inside
        % the square brackets.  Use the real section title if we have it.
!       \ifdim \wd1>0pt%
          % It is in another manual, so we don't have it.
          \def\printednodename{\ignorespaces #1}%
--- 5221,5225 ----
        % Use the actual chapter/section title appear inside
        % the square brackets.  Use the real section title if we have it.
!       \ifdim \wd1 > 0pt
          % It is in another manual, so we don't have it.
          \def\printednodename{\ignorespaces #1}%
***************
*** 4125,4130 ****
    % is a loss.  Therefore, we give the text of the node name again, so it
    % is as if TeX is seeing it for the first time.
    \ifdim \wd1 > 0pt
!     \putwordsection{} ``\printednodename'' in \cite{\printedmanual}%
    \else
      % _ (for example) has to be the character _ for the purposes of the
--- 5242,5260 ----
    % is a loss.  Therefore, we give the text of the node name again, so it
    % is as if TeX is seeing it for the first time.
+   \ifpdf
+     \leavevmode
+     \getfilename{#4}%
+     \ifnum\filenamelength>0
+       \startlink attr{/Border [0 0 0]}%
+         goto file{\the\filename.pdf} name{#1@}%
+     \else
+       \startlink attr{/Border [0 0 0]}%
+         goto name{#1@}%
+     \fi
+     \linkcolor
+   \fi
+   %
    \ifdim \wd1 > 0pt
!     \putwordsection{} ``\printednodename'' \putwordin{} \cite{\printedmanual}%
    \else
      % _ (for example) has to be the character _ for the purposes of the
***************
*** 4133,4149 ****
      % printing. So we \turnoffactive for the \refx-snt, back on for the
      % printing, back off for the \refx-pg.
!     {\turnoffactive \refx{#1-snt}{}}%
!     \space [\printednodename],\space
      \turnoffactive \putwordpage\tie\refx{#1-pg}{}%
    \fi
  \endgroup}
  
  % \dosetq is the interface for calls from other macros
  
! % Use \turnoffactive so that punctuation chars such as underscore
! % work in node names.
! \def\dosetq #1#2{{\let\folio=0 \turnoffactive \auxhat%
! \edef\next{\write\auxfile{\internalsetq {#1}{#2}}}%
! \next}}
  
  % \internalsetq {foo}{page} expands into
--- 5263,5293 ----
      % printing. So we \turnoffactive for the \refx-snt, back on for the
      % printing, back off for the \refx-pg.
!     {\normalturnoffactive
!      % Only output a following space if the -snt ref is nonempty; for
!      % @unnumbered and @anchor, it won't be.
!      \setbox2 = \hbox{\ignorespaces \refx{#1-snt}{}}%
!      \ifdim \wd2 > 0pt \refx{#1-snt}\space\fi
!     }%
!     % [mynode],
!     [\printednodename],\space
!     % page 3
      \turnoffactive \putwordpage\tie\refx{#1-pg}{}%
    \fi
+   \endlink
  \endgroup}
  
  % \dosetq is the interface for calls from other macros
  
! % Use \normalturnoffactive so that punctuation chars such as underscore
! % and backslash work in node names.  (\turnoffactive doesn't do \.)
! \def\dosetq#1#2{%
!   {\let\folio=0%
!    \normalturnoffactive
!    \edef\next{\write\auxfile{\internalsetq{#1}{#2}}}%
!    \iflinks
!      \next
!    \fi
!   }%
! }
  
  % \internalsetq {foo}{page} expands into
***************
*** 4196,4206 ****
    \expandafter\ifx\csname X#1\endcsname\relax
      % If not defined, say something at least.
!     $\langle$un\-de\-fined$\rangle$%
!     \ifhavexrefs
!       \message{\linenumber Undefined cross reference `#1'.}%
!     \else
!       \ifwarnedxrefs\else
!         \global\warnedxrefstrue
!         \message{Cross reference values unknown; you must run TeX again.}%
        \fi
      \fi
--- 5340,5352 ----
    \expandafter\ifx\csname X#1\endcsname\relax
      % If not defined, say something at least.
!     \angleleft un\-de\-fined\angleright
!     \iflinks
!       \ifhavexrefs
!         \message{\linenumber Undefined cross reference `#1'.}%
!       \else
!         \ifwarnedxrefs\else
!           \global\warnedxrefstrue
!           \message{Cross reference values unknown; you must run TeX again.}%
!         \fi
        \fi
      \fi
***************
*** 4212,4293 ****
  }
  
- % Read the last existing aux file, if any.  No error if none exists.
- 
  % This is the macro invoked by entries in the aux file.
! \def\xrdef #1#2{
! {\catcode`\'=\other\expandafter \gdef \csname X#1\endcsname {#2}}}
  
! \def\readauxfile{%
! \begingroup
! \catcode `\^^@=\other
! \catcode `\=\other
! \catcode `\=\other
! \catcode `\^^C=\other
! \catcode `\^^D=\other
! \catcode `\^^E=\other
! \catcode `\^^F=\other
! \catcode `\^^G=\other
! \catcode `\^^H=\other
! \catcode `\=\other
! \catcode `\^^L=\other
! \catcode `\=\other
! \catcode `\=\other
! \catcode `\=\other
! \catcode `\=\other
! \catcode `\=\other
! \catcode `\=\other
! \catcode `\=\other
! \catcode `\=\other
! \catcode `\=\other
! \catcode `\=\other
! \catcode `\=\other
! \catcode `\=\other
! \catcode 26=\other
! \catcode `\^^[=\other
! \catcode `\^^\=\other
! \catcode `\^^]=\other
! \catcode `\^^^=\other
! \catcode `\^^_=\other
! \catcode `\@=\other
! \catcode `\^=\other
! \catcode `\~=\other
! \catcode `\[=\other
! \catcode `\]=\other
! \catcode`\"=\other
! \catcode`\_=\other
! \catcode`\|=\other
! \catcode`\<=\other
! \catcode`\>=\other
! \catcode `\$=\other
! \catcode `\#=\other
! \catcode `\&=\other
! % `\+ does not work, so use 43.
! \catcode 43=\other
! % Make the characters 128-255 be printing characters
! {%
!   \count 1=128
!   \def\loop{%
!     \catcode\count 1=\other
!     \advance\count 1 by 1
!     \ifnum \count 1<256 \loop \fi
    }%
! }%
! % the aux file uses ' as the escape.
! % Turn off \ as an escape so we do not lose on
! % entries which were dumped with control sequences in their names.
! % For example, 'xrdef {$\leq $-fun}{page ...} made by @defun ^^
! % Reference to such entries still does not work the way one would wish,
! % but at least they do not bomb out when the aux file is read in.
! \catcode `\{=1 \catcode `\}=2
! \catcode `\%=\other
! \catcode `\'=0
! \catcode`\^=7 % to make ^^e4 etc usable in xref tags 
! \catcode `\\=\other
! \openin 1 \jobname.aux
! \ifeof 1 \else \closein 1 \input \jobname.aux \global\havexrefstrue
! \global\warnedobstrue
! \fi
! % Open the new aux file.  Tex will close it automatically at exit.
! \openout \auxfile=\jobname.aux
  \endgroup}
  
--- 5358,5456 ----
  }
  
  % This is the macro invoked by entries in the aux file.
! %
! \def\xrdef#1{\begingroup
!   % Reenable \ as an escape while reading the second argument.
!   \catcode`\\ = 0
!   \afterassignment\endgroup
!   \expandafter\gdef\csname X#1\endcsname
! }
  
! % Read the last existing aux file, if any.  No error if none exists.
! \def\readauxfile{\begingroup
!   \catcode`\^^@=\other
!   \catcode`\^^A=\other
!   \catcode`\^^B=\other
!   \catcode`\^^C=\other
!   \catcode`\^^D=\other
!   \catcode`\^^E=\other
!   \catcode`\^^F=\other
!   \catcode`\^^G=\other
!   \catcode`\^^H=\other
!   \catcode`\^^K=\other
!   \catcode`\^^L=\other
!   \catcode`\^^N=\other
!   \catcode`\^^P=\other
!   \catcode`\^^Q=\other
!   \catcode`\^^R=\other
!   \catcode`\^^S=\other
!   \catcode`\^^T=\other
!   \catcode`\^^U=\other
!   \catcode`\^^V=\other
!   \catcode`\^^W=\other
!   \catcode`\^^X=\other
!   \catcode`\^^Z=\other
!   \catcode`\^^[=\other
!   \catcode`\^^\=\other
!   \catcode`\^^]=\other
!   \catcode`\^^^=\other
!   \catcode`\^^_=\other
!   \catcode`\@=\other
!   \catcode`\^=\other
!   % It was suggested to define this as 7, which would allow ^^e4 etc.
!   % in xref tags, i.e., node names.  But since ^^e4 notation isn't
!   % supported in the main text, it doesn't seem desirable.  Furthermore,
!   % that is not enough: for node names that actually contain a ^
!   % character, we would end up writing a line like this: 'xrdef {'hat
!   % b-title}{'hat b} and \xrdef does a \csname...\endcsname on the first
!   % argument, and \hat is not an expandable control sequence.  It could
!   % all be worked out, but why?  Either we support ^^ or we don't.
!   %
!   % The other change necessary for this was to define \auxhat:
!   % \def\auxhat{\def^{'hat }}% extra space so ok if followed by letter
!   % and then to call \auxhat in \setq.
!   %
!   \catcode`\~=\other
!   \catcode`\[=\other
!   \catcode`\]=\other
!   \catcode`\"=\other
!   \catcode`\_=\other
!   \catcode`\|=\other
!   \catcode`\<=\other
!   \catcode`\>=\other
!   \catcode`\$=\other
!   \catcode`\#=\other
!   \catcode`\&=\other
!   \catcode`+=\other % avoid \+ for paranoia even though we've turned it off
!   % Make the characters 128-255 be printing characters
!   {%
!     \count 1=128
!     \def\loop{%
!       \catcode\count 1=\other
!       \advance\count 1 by 1
!       \ifnum \count 1<256 \loop \fi
!     }%
    }%
!   % The aux file uses ' as the escape (for now).
!   % Turn off \ as an escape so we do not lose on
!   % entries which were dumped with control sequences in their names.
!   % For example, 'xrdef {$\leq $-fun}{page ...} made by @defun ^^
!   % Reference to such entries still does not work the way one would wish,
!   % but at least they do not bomb out when the aux file is read in.
!   \catcode`\{=1
!   \catcode`\}=2
!   \catcode`\%=\other
!   \catcode`\'=0
!   \catcode`\\=\other
!   %
!   \openin 1 \jobname.aux
!   \ifeof 1 \else
!     \closein 1
!     \input \jobname.aux
!     \global\havexrefstrue
!     \global\warnedobstrue
!   \fi
!   % Open the new aux file.  TeX will close it automatically at exit.
!   \openout\auxfile=\jobname.aux
  \endgroup}
  
***************
*** 4304,4308 ****
  \def\supereject{\par\penalty -20000\footnoteno =0 }
  
! % @footnotestyle is meaningful for info output only..
  \let\footnotestyle=\comment
  
--- 5467,5471 ----
  \def\supereject{\par\penalty -20000\footnoteno =0 }
  
! % @footnotestyle is meaningful for info output only.
  \let\footnotestyle=\comment
  
***************
*** 4330,4334 ****
  % footnote text as a parameter.  Our footnotes don't need to be so general.
  %
! \long\gdef\footnotezzz#1{\insert\footins{%
    % We want to typeset this text as a normal paragraph, even if the
    % footnote reference occurs in (for example) a display environment.
--- 5493,5501 ----
  % footnote text as a parameter.  Our footnotes don't need to be so general.
  %
! % Oh yes, they do; otherwise, @ifset and anything else that uses
! % \parseargline fail inside footnotes because the tokens are fixed when
! % the footnote is read.  --karl, 16nov96.
! %
! \long\gdef\footnotezzz{\insert\footins\bgroup
    % We want to typeset this text as a normal paragraph, even if the
    % footnote reference occurs in (for example) a display environment.
***************
*** 4344,4347 ****
--- 5511,5516 ----
    \parindent\defaultparindent
    %
+   \smallfonts \rm
+   %
    % Hang the footnote text off the number.
    \hang
***************
*** 4352,4357 ****
    % provide a place where TeX can split the footnote.
    \footstrut
!   #1\strut}%
  }
  
  }%end \catcode `\@=11
--- 5521,5531 ----
    % provide a place where TeX can split the footnote.
    \footstrut
!   \futurelet\next\fo@t
  }
+ \def\fo@t{\ifcat\bgroup\noexpand\next \let\next\f@@t
+   \else\let\next\f@t\fi \next}
+ \def\f@@t{\bgroup\aftergroup\@foot\let\next}
+ \def\f@t#1{#1\@foot}
+ \def\@foot{\strut\par\egroup}
  
  }%end \catcode `\@=11
***************
*** 4410,4436 ****
  \def\finalout{\overfullrule=0pt}
  
  
- % End of control word definitions.
  
! \message{and turning on texinfo input format.}
  
! \def\openindices{%
!    \newindex{cp}%
!    \newcodeindex{fn}%
!    \newcodeindex{vr}%
!    \newcodeindex{tp}%
!    \newcodeindex{ky}%
!    \newcodeindex{pg}%
  }
  
! % Set some numeric style parameters, for 8.5 x 11 format.
  
! \hsize = 6in
! \hoffset = .25in
  \newdimen\defaultparindent \defaultparindent = 15pt
- \parindent = \defaultparindent
- \parskip 3pt plus 2pt minus 1pt
- \setleading{13.2pt}
- \advance\topskip by 1.2cm
  
  \chapheadingskip = 15pt plus 4pt minus 2pt
--- 5584,5688 ----
  \def\finalout{\overfullrule=0pt}
  
+ % @image.  We use the macros from epsf.tex to support this.
+ % If epsf.tex is not installed and @image is used, we complain.
+ %
+ % Check for and read epsf.tex up front.  If we read it only at @image
+ % time, we might be inside a group, and then its definitions would get
+ % undone and the next image would fail.
+ \openin 1 = epsf.tex
+ \ifeof 1 \else
+   \closein 1
+   % Do not bother showing banner with post-v2.7 epsf.tex (available in
+   % doc/epsf.tex until it shows up on ctan).
+   \def\epsfannounce{\toks0 = }%
+   \input epsf.tex
+ \fi
+ %
+ % We will only complain once about lack of epsf.tex.
+ \newif\ifwarnednoepsf
+ \newhelp\noepsfhelp{epsf.tex must be installed for images to
+   work.  It is also included in the Texinfo distribution, or you can get
+   it from ftp://tug.org/tex/epsf.tex.}
+ %
+ \def\image#1{%
+   \ifx\epsfbox\undefined
+     \ifwarnednoepsf \else
+       \errhelp = \noepsfhelp
+       \errmessage{epsf.tex not found, images will be ignored}%
+       \global\warnednoepsftrue
+     \fi
+   \else
+     \imagexxx #1,,,\finish
+   \fi
+ }
+ %
+ % Arguments to @image:
+ % #1 is (mandatory) image filename; we tack on .eps extension.
+ % #2 is (optional) width, #3 is (optional) height.
+ % #4 is just the usual extra ignored arg for parsing this stuff.
+ \def\imagexxx#1,#2,#3,#4\finish{%
+   \ifpdf
+     \centerline{\dopdfimage{#1}{#2}{#3}}%
+   \else
+     % \epsfbox itself resets \epsf?size at each figure.
+     \setbox0 = \hbox{\ignorespaces #2}\ifdim\wd0 > 0pt \epsfxsize=#2\relax \fi
+     \setbox0 = \hbox{\ignorespaces #3}\ifdim\wd0 > 0pt \epsfysize=#3\relax \fi
+     \begingroup
+       \catcode`\^^M = 5 % in case we're inside an example
+       % If the image is by itself, center it.
+       \ifvmode
+         \nobreak\bigskip
+         % Usually we'll have text after the image which will insert
+         % \parskip glue, so insert it here too to equalize the space
+         % above and below. 
+         \nobreak\vskip\parskip
+         \nobreak
+         \centerline{\epsfbox{#1.eps}}%
+         \bigbreak
+       \else
+         % In the middle of a paragraph, no extra space.
+         \epsfbox{#1.eps}%
+       \fi
+     \endgroup
+   \fi
+ }
  
  
! \message{localization,}
! % and i18n.
  
! % @documentlanguage is usually given very early, just after
! % @setfilename.  If done too late, it may not override everything
! % properly.  Single argument is the language abbreviation.
! % It would be nice if we could set up a hyphenation file here.
! %
! \def\documentlanguage{\parsearg\dodocumentlanguage}
! \def\dodocumentlanguage#1{%
!   \tex % read txi-??.tex file in plain TeX.
!   % Read the file if it exists.
!   \openin 1 txi-#1.tex
!   \ifeof1
!     \errhelp = \nolanghelp
!     \errmessage{Cannot read language file txi-#1.tex}%
!     \let\temp = \relax
!   \else
!     \def\temp{\input txi-#1.tex }%
!   \fi
!   \temp
!   \endgroup
  }
+ \newhelp\nolanghelp{The given language definition file cannot be found or
+ is empty.  Maybe you need to install it?  In the current directory
+ should work if nowhere else does.}
+ 
  
! % @documentencoding should change something in TeX eventually, most
! % likely, but for now just recognize it.
! \let\documentencoding = \comment
  
! 
! % Page size parameters.
! %
  \newdimen\defaultparindent \defaultparindent = 15pt
  
  \chapheadingskip = 15pt plus 4pt minus 2pt
***************
*** 4439,4443 ****
  
  % Prevent underfull vbox error messages.
! \vbadness=10000
  
  % Following George Bush, just get rid of widows and orphans.
--- 5691,5698 ----
  
  % Prevent underfull vbox error messages.
! \vbadness = 10000
! 
! % Don't be so finicky about underfull hboxes, either.
! \hbadness = 2000
  
  % Following George Bush, just get rid of widows and orphans.
***************
*** 4448,4546 ****
  % using an old version of TeX, don't do anything.  We want the amount of
  % stretch added to depend on the line length, hence the dependence on
! % \hsize.  This makes it come to about 9pt for the 8.5x11 format.
  %
! \ifx\emergencystretch\thisisundefined
!   % Allow us to assign to \emergencystretch anyway.
!   \def\emergencystretch{\dimen0}%
! \else
!   \emergencystretch = \hsize
!   \divide\emergencystretch by 45
! \fi
! 
! % Use @smallbook to reset parameters for 7x9.5 format  (or else 7x9.25)
! \def\smallbook{
!   \global\chapheadingskip = 15pt plus 4pt minus 2pt
!   \global\secheadingskip = 12pt plus 3pt minus 2pt
!   \global\subsecheadingskip = 9pt plus 2pt minus 2pt
!   %
!   \global\lispnarrowing = 0.3in
!   \setleading{12pt}
!   \advance\topskip by -1cm
!   \global\parskip 2pt plus 1pt
!   \global\hsize = 5in
!   \global\vsize=7.5in
!   \global\tolerance=700
!   \global\hfuzz=1pt
!   \global\contentsrightmargin=0pt
!   \global\deftypemargin=0pt
!   \global\defbodyindent=.5cm
!   %
!   \global\pagewidth=\hsize
!   \global\pageheight=\vsize
!   %
!   \global\let\smalllisp=\smalllispx
!   \global\let\smallexample=\smalllispx
!   \global\def\Esmallexample{\Esmalllisp}
  }
  
  % Use @afourpaper to print on European A4 paper.
! \def\afourpaper{
! \global\tolerance=700
! \global\hfuzz=1pt
! \setleading{12pt}
! \global\parskip 15pt plus 1pt
! 
! \global\vsize= 53\baselineskip
! \advance\vsize by \topskip
! %\global\hsize=   5.85in     % A4 wide 10pt
! \global\hsize=  6.5in
! \global\outerhsize=\hsize
! \global\advance\outerhsize by 0.5in
! \global\outervsize=\vsize
! \global\advance\outervsize by 0.6in
! 
! \global\pagewidth=\hsize
! \global\pageheight=\vsize
! }
! 
! \bindingoffset=0pt
! \normaloffset=\hoffset
! \pagewidth=\hsize
! \pageheight=\vsize
! 
! % Allow control of the text dimensions.  Parameters in order: textheight;
! % textwidth; voffset; hoffset; binding offset; topskip.
! % All require a dimension;
! % header is additional; added length extends the bottom of the page.
! 
! \def\changepagesizes#1#2#3#4#5#6{
!  \global\vsize= #1
!  \global\topskip= #6
!  \advance\vsize by \topskip
!  \global\voffset= #3
!  \global\hsize= #2
!  \global\outerhsize=\hsize
!  \global\advance\outerhsize by 0.5in
!  \global\outervsize=\vsize
!  \global\advance\outervsize by 0.6in
!  \global\pagewidth=\hsize
!  \global\pageheight=\vsize
!  \global\normaloffset= #4
!  \global\bindingoffset= #5}
  
  % A specific text layout, 24x15cm overall, intended for A4 paper.  Top margin
  % 29mm, hence bottom margin 28mm, nominal side margin 3cm.
! \def\afourlatex
!         {\global\tolerance=700
!         \global\hfuzz=1pt
!         \setleading{12pt}
!         \global\parskip 15pt plus 1pt
!         \advance\baselineskip by 1.6pt
!         \changepagesizes{237mm}{150mm}{3.6mm}{3.6mm}{3mm}{7mm}
!         }
  
  % Use @afourwide to print on European A4 paper in wide format.
! \def\afourwide{\afourpaper
! \changepagesizes{9.5in}{6.5in}{\hoffset}{\normaloffset}{\bindingoffset}{7mm}}
  
  % Define macros to output various characters with catcode for normal text.
--- 5703,5825 ----
  % using an old version of TeX, don't do anything.  We want the amount of
  % stretch added to depend on the line length, hence the dependence on
! % \hsize.  We call this whenever the paper size is set.
  %
! \def\setemergencystretch{%
!   \ifx\emergencystretch\thisisundefined
!     % Allow us to assign to \emergencystretch anyway.
!     \def\emergencystretch{\dimen0}%
!   \else
!     \emergencystretch = .15\hsize
!   \fi
  }
  
+ % Parameters in order: 1) textheight; 2) textwidth; 3) voffset;
+ % 4) hoffset; 5) binding offset; 6) topskip.  Then whoever calls us can
+ % set \parskip and call \setleading for \baselineskip.
+ %
+ \def\internalpagesizes#1#2#3#4#5#6{%
+   \voffset = #3\relax
+   \topskip = #6\relax
+   \splittopskip = \topskip
+   %
+   \vsize = #1\relax
+   \advance\vsize by \topskip
+   \outervsize = \vsize
+   \advance\outervsize by 2\topandbottommargin
+   \pageheight = \vsize
+   %
+   \hsize = #2\relax
+   \outerhsize = \hsize
+   \advance\outerhsize by 0.5in
+   \pagewidth = \hsize
+   %
+   \normaloffset = #4\relax
+   \bindingoffset = #5\relax
+   %
+   \parindent = \defaultparindent
+   \setemergencystretch
+ }
+ 
+ % @letterpaper (the default).
+ \def\letterpaper{{\globaldefs = 1
+   \parskip = 3pt plus 2pt minus 1pt
+   \setleading{13.2pt}%
+   %
+   % If page is nothing but text, make it come out even.
+   \internalpagesizes{46\baselineskip}{6in}{\voffset}{.25in}{\bindingoffset}{36pt}%
+ }}
+ 
+ % Use @smallbook to reset parameters for 7x9.5 (or so) format.
+ \def\smallbook{{\globaldefs = 1
+   \parskip = 2pt plus 1pt
+   \setleading{12pt}%
+   %
+   \internalpagesizes{7.5in}{5.in}{\voffset}{.25in}{\bindingoffset}{16pt}%
+   %
+   \lispnarrowing = 0.3in
+   \tolerance = 700
+   \hfuzz = 1pt
+   \contentsrightmargin = 0pt
+   \deftypemargin = 0pt
+   \defbodyindent = .5cm
+   %
+   \let\smalldisplay = \smalldisplayx
+   \let\smallexample = \smalllispx
+   \let\smallformat = \smallformatx
+   \let\smalllisp = \smalllispx
+ }}
+ 
  % Use @afourpaper to print on European A4 paper.
! \def\afourpaper{{\globaldefs = 1
!   \setleading{12pt}%
!   \parskip = 3pt plus 2pt minus 1pt
!   %
!   \internalpagesizes{53\baselineskip}{160mm}{\voffset}{4mm}{\bindingoffset}{44pt}%
!   %
!   \tolerance = 700
!   \hfuzz = 1pt
! }}
  
  % A specific text layout, 24x15cm overall, intended for A4 paper.  Top margin
  % 29mm, hence bottom margin 28mm, nominal side margin 3cm.
! \def\afourlatex{{\globaldefs = 1
!   \setleading{13.6pt}%
!   %
!   \afourpaper
!   \internalpagesizes{237mm}{150mm}{3.6mm}{3.6mm}{3mm}{7mm}%
!   %
!   \globaldefs = 0
! }}
  
  % Use @afourwide to print on European A4 paper in wide format.
! \def\afourwide{%
!   \afourpaper
!   \internalpagesizes{9.5in}{6.5in}{\hoffset}{\normaloffset}{\bindingoffset}{7mm}%
!   %
!   \globaldefs = 0
! }
! 
! % @pagesizes TEXTHEIGHT[,TEXTWIDTH]
! % Perhaps we should allow setting the margins, \topskip, \parskip,
! % and/or leading, also. Or perhaps we should compute them somehow.
! %
! \def\pagesizes{\parsearg\pagesizesxxx}
! \def\pagesizesxxx#1{\pagesizesyyy #1,,\finish}
! \def\pagesizesyyy#1,#2,#3\finish{{%
!   \setbox0 = \hbox{\ignorespaces #2}\ifdim\wd0 > 0pt \hsize=#2\relax \fi
!   \globaldefs = 1
!   %
!   \parskip = 3pt plus 2pt minus 1pt
!   \setleading{13.2pt}%
!   %
!   \internalpagesizes{#1}{\hsize}{\voffset}{\normaloffset}{\bindingoffset}{44pt}%
! }}
! 
! % Set default to letter.
! %
! \letterpaper
! 
! 
! \message{and turning on texinfo input format.}
  
  % Define macros to output various characters with catcode for normal text.
***************
*** 4553,4556 ****
--- 5832,5836 ----
  \catcode`\>=\other
  \catcode`\+=\other
+ \catcode`\$=\other
  \def\normaldoublequote{"}
  \def\normaltilde{~}
***************
*** 4561,4564 ****
--- 5841,5845 ----
  \def\normalgreater{>}
  \def\normalplus{+}
+ \def\normaldollar{$}
  
  % This macro is used to make a character print one way in ttfont
***************
*** 4571,4575 ****
  % typewriter fonts to have this, we can check that font parameter.
  %
! \def\ifusingtt#1#2{\ifdim \fontdimen3\the\font=0pt #1\else #2\fi}
  
  % Turn off all special characters except @
--- 5852,5862 ----
  % typewriter fonts to have this, we can check that font parameter.
  %
! \def\ifusingtt#1#2{\ifdim \fontdimen3\font=0pt #1\else #2\fi}
! 
! % Same as above, but check for italic font.  Actually this also catches
! % non-italic slanted fonts since it is impossible to distinguish them from
! % italic fonts.  But since this is only used by $ and it uses \sl anyway
! % this is not a problem.
! \def\ifusingit#1#2{\ifdim \fontdimen1\font>0pt #1\else #2\fi}
  
  % Turn off all special characters except @
***************
*** 4579,4589 ****
  
  \catcode`\"=\active
! \def\activedoublequote{{\tt \char '042}}
  \let"=\activedoublequote
  \catcode`\~=\active
! \def~{{\tt \char '176}}
  \chardef\hat=`\^
  \catcode`\^=\active
- \def\auxhat{\def^{'hat}}
  \def^{{\tt \hat}}
  
--- 5866,5875 ----
  
  \catcode`\"=\active
! \def\activedoublequote{{\tt\char34}}
  \let"=\activedoublequote
  \catcode`\~=\active
! \def~{{\tt\char126}}
  \chardef\hat=`\^
  \catcode`\^=\active
  \def^{{\tt \hat}}
  
***************
*** 4594,4598 ****
  
  \catcode`\|=\active
! \def|{{\tt \char '174}}
  \chardef \less=`\<
  \catcode`\<=\active
--- 5880,5884 ----
  
  \catcode`\|=\active
! \def|{{\tt\char124}}
  \chardef \less=`\<
  \catcode`\<=\active
***************
*** 4603,4606 ****
--- 5889,5894 ----
  \catcode`\+=\active
  \def+{{\tt \char 43}}
+ \catcode`\$=\active
+ \def${\ifusingit{{\sl\$}}\normaldollar}
  %\catcode 27=\active
  %\def^^[{$\diamondsuit$}
***************
*** 4633,4639 ****
  \def\normalbackslash{{\tt\rawbackslashxx}}
  
- % Say @foo, not \foo, in error messages.
- \escapechar=`\@
- 
  % \catcode 17=0   % Define control-q
  \catcode`\\=\active
--- 5921,5924 ----
***************
*** 4649,4653 ****
  @let<=@normalless
  @let>=@normalgreater
! @let+=@normalplus}
  
  @def@normalturnoffactive{@let"=@normaldoublequote
--- 5934,5939 ----
  @let<=@normalless
  @let>=@normalgreater
! @let+=@normalplus
! @let$=@normaldollar}
  
  @def@normalturnoffactive{@let"=@normaldoublequote
***************
*** 4659,4663 ****
  @let<=@normalless
  @let>=@normalgreater
! @let+=@normalplus}
  
  % Make _ and + \other characters, temporarily.
--- 5945,5950 ----
  @let<=@normalless
  @let>=@normalgreater
! @let+=@normalplus
! @let$=@normaldollar}
  
  % Make _ and + \other characters, temporarily.
***************
*** 4678,4692 ****
  % file name, in case not using a pre-dumped format.
  %
! @gdef@fixbackslash{@ifx\@eatinput @let\ = @normalbackslash @fi
!   @catcode`+=@active @catcode`@_=@active}
  
! %% These look ok in all fonts, so just make them not special.  The @rm below
! %% makes sure that the current font starts out as the newly loaded cmr10
! @catcode`@$=@other @catcode`@%=@other @catcode`@&=@other @catcode`@#=@other
  
  @textfonts
  @rm
  
  @c Local variables:
  @c page-delimiter: "^\\\\message"
  @c End:
--- 5965,5992 ----
  % file name, in case not using a pre-dumped format.
  %
! @gdef@fixbackslash{%
!   @ifx\@eatinput @let\ = @normalbackslash @fi
!   @catcode`+=@active
!   @catcode`@_=@active
! }
! 
! % Say @foo, not \foo, in error messages.
! @escapechar = `@@
  
! % These look ok in all fonts, so just make them not special.  
! @catcode`@& = @other
! @catcode`@# = @other
! @catcode`@% = @other
  
+ @c Set initial fonts.
  @textfonts
  @rm
  
+ 
  @c Local variables:
+ @c eval: (add-hook 'write-file-hooks 'time-stamp)
  @c page-delimiter: "^\\\\message"
+ @c time-stamp-start: "def\\\\texinfoversion{"
+ @c time-stamp-format: "%:y-%02m-%02d.%02H"
+ @c time-stamp-end: "}"
  @c End:
diff -Nrc2 bash-2.04/error.c bash-2.05/error.c
*** bash-2.04/error.c	Thu Aug  5 07:04:01 1999
--- bash-2.05/error.c	Mon Mar 26 10:36:07 2001
***************
*** 435,438 ****
--- 435,439 ----
  }
  
+ #ifdef DEBUG
  void
  #if defined (PREFER_STDARG)
***************
*** 501,504 ****
--- 502,506 ----
  
  #endif /* USE_VARARGS */
+ #endif /* DEBUG */
  
  static char *cmd_error_table[] = {
diff -Nrc2 bash-2.04/eval.c bash-2.05/eval.c
*** bash-2.04/eval.c	Sat Feb  5 16:51:44 2000
--- bash-2.05/eval.c	Wed Feb 14 16:58:24 2001
***************
*** 141,148 ****
  	    exec_done:
  	      if (current_command)
! 	        {
  		  dispose_command (current_command);
  		  current_command = (COMMAND *)NULL;
! 	        }
  
  	      QUIT;
--- 141,148 ----
  	    exec_done:
  	      if (current_command)
! 		{
  		  dispose_command (current_command);
  		  current_command = (COMMAND *)NULL;
! 		}
  
  	      QUIT;
diff -Nrc2 bash-2.04/examples/complete/complete-examples bash-2.05/examples/complete/complete-examples
*** bash-2.04/examples/complete/complete-examples	Fri Jan 21 13:07:45 2000
--- bash-2.05/examples/complete/complete-examples	Mon Nov 20 11:33:57 2000
***************
*** 353,357 ****
  	if [[ $prev == -A ]]; then
  		COMPREPLY=(alias arrayvar binding builtin command directory \
! disabled enabled export file function helptopic hostname job keyword \
  running setopt shopt signal stopped variable)
  		return 0
--- 353,357 ----
  	if [[ $prev == -A ]]; then
  		COMPREPLY=(alias arrayvar binding builtin command directory \
! disabled enabled export file 'function' helptopic hostname job keyword \
  running setopt shopt signal stopped variable)
  		return 0
***************
*** 401,405 ****
  
  	# make reads `makefile' before `Makefile'
! 	if [ -f makefile ]; then
  		mdef=makefile
  	elif [ -f Makefile ]; then
--- 401,409 ----
  
  	# make reads `makefile' before `Makefile'
! 	# GNU make reads `GNUmakefile' before all other makefiles, but we
! 	# check that we're completing `gmake' before checking for it
! 	if [ -f GNUmakefile ] && [ ${COMP_WORDS[0]} == gmake ]; then
! 		mdef=GNUmakefile
! 	elif [ -f makefile ]; then
  		mdef=makefile
  	elif [ -f Makefile ]; then
***************
*** 459,467 ****
  
  complete -f -X '*.gz' gzip
  complete -f -X '*.Z' compress
  complete -f -X '!*.+(gz|tgz|Gz)' gunzip gzcat zcat zmore
  complete -f -X '!*.Z' uncompress zmore zcat
! 
! complete -f -X '!*.+(gif|jpg|jpeg|GIF|JPG|bmp)' xv
  
  complete -f -X '!*.pl' perl perl5
--- 463,473 ----
  
  complete -f -X '*.gz' gzip
+ complete -f -X '*.bz2' bzip2
  complete -f -X '*.Z' compress
  complete -f -X '!*.+(gz|tgz|Gz)' gunzip gzcat zcat zmore
  complete -f -X '!*.Z' uncompress zmore zcat
! complete -f -X '!*.bz2' bunzip2
! complete -f -X '!*.zip' unzip
! complete -f -X '!*.+(gif|jpg|jpeg|GIF|JPG|JPEG|bmp)' xv
  
  complete -f -X '!*.pl' perl perl5
***************
*** 473,480 ****
  
  complete -f -X '!*.+(ps|PS)' gs gv ghostview psselect pswrap
! complete -f -X '!*.+(dvi|DVI)' dvips xdvi dviselect dvitype
! complete -f -X '!*.+(pdf|PDF)' acroread
  complete -f -X '!*.texi*' makeinfo texi2dvi texi2html
  complete -f -X '!*.+(tex|TEX)' tex latex slitex
  
  #
--- 479,489 ----
  
  complete -f -X '!*.+(ps|PS)' gs gv ghostview psselect pswrap
! complete -f -X '!*.+(dvi|DVI)' dvips xdvi dviselect dvitype catdvi
! complete -f -X '!*.+(pdf|PDF)' acroread4
  complete -f -X '!*.texi*' makeinfo texi2dvi texi2html
  complete -f -X '!*.+(tex|TEX)' tex latex slitex
+ 
+ complete -f -X '!*.+(mp3|MP3)' mpg123
+ complete -f -X '!*.+(htm|html)' links w3m lynx
  
  #
diff -Nrc2 bash-2.04/examples/complete/complete.freebsd bash-2.05/examples/complete/complete.freebsd
*** bash-2.04/examples/complete/complete.freebsd	Wed Dec 31 19:00:00 1969
--- bash-2.05/examples/complete/complete.freebsd	Mon Feb  5 16:51:11 2001
***************
*** 0 ****
--- 1,31 ----
+ #Date: Wed, 31 Jan 2001 12:53:56 -0800
+ #From: Aaron Smith <aaron@mutex.org>
+ #To: freebsd-ports@freebsd.org
+ #Subject: useful bash completion function for pkg commands
+ #Message-ID: <20010131125356.G52003@gelatinous.com>
+ 
+ #hi all. i just wanted to share this bash completion function i wrote that
+ #completes package names for pkg_info and pkg_delete. i find this a great
+ #help when dealing with port management. programmed completion requires
+ #bash-2.04.
+ 
+ _pkg_func ()
+ {   
+     local cur
+ 
+     cur=${COMP_WORDS[COMP_CWORD]}
+ 
+     if [[ $cur == '-' ]]; then
+         if [[ ${COMP_WORDS[0]} == 'pkg_info' ]]; then
+                 COMPREPLY=(-a -c -d -D -i -k -r -R -p -L -q -I -m -v -e -l)
+                 return 0;
+         elif [[ ${COMP_WORDS[0]} == 'pkg_delete' ]]; then
+                 COMPREPLY=(-v -D -d -n -f -p)
+                 return 0;
+         fi
+     fi
+ 
+     COMPREPLY=( $(compgen -d /var/db/pkg/$cur | sed sN/var/db/pkg/NNg) )
+     return 0
+ }
+ complete -F _pkg_func pkg_delete pkg_info
diff -Nrc2 bash-2.04/examples/complete/complete.ianmac bash-2.05/examples/complete/complete.ianmac
*** bash-2.04/examples/complete/complete.ianmac	Wed Dec 31 19:00:00 1969
--- bash-2.05/examples/complete/complete.ianmac	Thu Jul 13 09:43:26 2000
***************
*** 0 ****
--- 1,433 ----
+ #####
+ #To: chet@po.cwru.edu, sarahmckenna@lucent.com
+ #Message-Id: <slrn8mqioc.msb.ian@lovelorn.linuxcare.com>
+ #Posted-To: comp.unix.shell, gnu.bash.bug
+ #Subject: bash 2.04 programmable completion examples
+ #Reply-To: ian@linuxcare.com, ian@caliban.org
+ #Summary: examples of programmable completion for bash 2.04
+ #Date: Thu, 13 Jul 2000 00:52:33 -0400 (EDT)
+ #From: ianmacd@linuxcare.com (Ian Macdonald)
+ #####
+ 
+ #########################################################################
+ # Turn on extended globbing
+ shopt -s extglob
+ 
+ # A lot of the following one-liners were taken directly from the
+ # completion examples provided with the bash 2.04 source distribution
+ 
+ # Make directory commands see only directories
+ complete -d cd mkdir rmdir pushd
+ 
+ # Make file commands see only files
+ complete -f cat less more chown ln strip
+ complete -f -X '*.gz' gzip
+ complete -f -X '*.Z' compress
+ complete -f -X '!*.+(Z|gz|tgz|Gz)' gunzip zcat zmore
+ complete -f -X '!*.Z' uncompress zmore zcat
+ complete -f -X '!*.+(gif|jpg|jpeg|GIF|JPG|bmp)' ee xv
+ complete -f -X '!*.+(ps|PS|ps.gz)' gv
+ complete -f -X '!*.+(dvi|DVI)' dvips xdvi dviselect dvitype
+ complete -f -X '!*.+(pdf|PDF)' acroread xpdf
+ complete -f -X '!*.texi*' makeinfo texi2dvi texi2html
+ complete -f -X '!*.+(tex|TEX)' tex latex slitex
+ complete -f -X '!*.+(mp3|MP3)' mpg123
+ 
+ # kill sees only signals
+ complete -A signal kill -P '%'
+ 
+ # user commands see only users
+ complete -u finger su usermod userdel passwd
+ 
+ # bg completes with stopped jobs
+ complete -A stopped -P '%' bg
+ 
+ # other job commands
+ complete -j -P '%' fg jobs disown
+ 
+ # network commands complete with hostname
+ complete -A hostname ssh rsh telnet rlogin ftp ping fping host traceroute \
+ 	    nslookup
+ 
+ # export and others complete with shell variables
+ complete -v export local readonly unset
+ 
+ # set completes with set options
+ complete -A setopt set
+ 
+ # shopt completes with shopt options
+ complete -A shopt shopt
+ 
+ # helptopics
+ complete -A helptopic help
+ 
+ # unalias completes with aliases
+ complete -a unalias
+ 
+ # various commands complete with commands
+ complete -c command type nohup exec nice eval strace gdb
+ 
+ # bind completes with readline bindings (make this more intelligent)
+ complete -A binding bind
+ 
+ # Now we get to the meat of the file, the functions themselves. Some
+ # of these are works in progress. Most assume GNU versions of the
+ # tools in question and may require modifications for use on vanilla
+ # UNIX systems.
+ #
+ # A couple of functions may have non-portable, Linux specific code in
+ # them, but this will be noted where applicable
+ 
+ 
+ # GNU chown(1) completion. This should be expanded to allow the use of
+ # ':' as well as '.' as the user.group separator.
+ #
+ _chown ()
+ {
+ 	local cur prev user group
+ 
+         COMPREPLY=()
+         cur=${COMP_WORDS[COMP_CWORD]}
+         prev=${COMP_WORDS[COMP_CWORD-1]}
+ 
+ 	# do not attempt completion if we're specifying an option
+ 	if [ "${cur:0:1}" = "-" ]; then return 0; fi
+ 
+ 	# first parameter on line or first since an option?
+ 	if [ $COMP_CWORD -eq 1 ] || [ "${prev:0:1}" = "-" ]; then
+ 		case "$cur" in
+ 		[a-zA-Z]*.*)
+ 			user=${cur%.*}
+ 			group=${cur#*.}
+ 			COMPREPLY=( $( awk 'BEGIN {FS=":"} \
+ 					{if ($1 ~ /^'$group'/) print $1}' \
+ 					/etc/group ) )
+ 			for (( i=0; i < ${#COMPREPLY[@]}; i++ )); do
+ 				COMPREPLY[i]=$user.${COMPREPLY[i]}
+ 			done
+ 			return 0
+ 			;;
+ 		*)
+ 			COMPREPLY=( $( compgen -u $cur -S '.' ) )
+ 			return 0
+ 			;;
+ 		esac
+ 	else
+ 		COMPREPLY=( $( compgen -f $cur ) )
+ 	fi
+ 
+ 	return 0
+ }
+ complete -F _chown chown
+ 
+ # umount(8) completion. This relies on the mount point being the third
+ # space-delimited field in the output of mount(8)
+ #
+ _umount ()
+ {
+ 	local cur
+ 
+         COMPREPLY=()
+         cur=${COMP_WORDS[COMP_CWORD]}
+ 
+ 	# could rewrite the cut | grep to be a sed command, but this is
+ 	# clearer and doesn't result in much overhead
+ 	COMPREPLY=( $( mount | cut -d' ' -f 3 | grep ^$cur) )
+ 	return 0
+ }
+ complete -F _umount umount
+ 
+ # GID completion. This will get a list of all valid group names from
+ # /etc/group and should work anywhere.
+ #
+ _gid_func ()
+ {
+ 	local cur
+ 
+         COMPREPLY=()
+         cur=${COMP_WORDS[COMP_CWORD]}
+ 	COMPREPLY=( $( awk 'BEGIN {FS=":"} {if ($1 ~ /^'$cur'/) print $1}' \
+ 			   /etc/group ) )
+ 	return 0
+ }
+ complete -F _gid_func groupdel groupmod
+ 
+ # mount(8) completion. This will pull a list of possible mounts out of
+ # /etc/fstab, unless the word being completed contains a ':', which
+ # would indicate the specification of an NFS server. In that case, we
+ # query the server for a list of all available exports and complete on
+ # that instead.
+ #
+ _mount ()
+ 
+ {       local cur
+ 
+         COMPREPLY=()
+         cur=${COMP_WORDS[COMP_CWORD]}
+ 
+ 	case "$cur" in
+ 	*:*)
+ 	      COMPREPLY=( $( /usr/sbin/showmount -e --no-headers ${cur%%:*} |\
+ 			       grep ^${cur#*:} | awk '{print $1}'))
+ 		return 0
+ 		;;
+ 	*)
+ 		COMPREPLY=( $( awk '{if ($2 ~ /\//) print $2}' /etc/fstab | \
+ 			       grep ^$cur ))
+ 		return 0
+ 		;;
+ 	esac
+ }
+ complete -F _mount mount
+ 
+ # Linux rmmod(1) completion. This completes on a list of all currently
+ # installed kernel modules.
+ #
+ _rmmod ()
+ {
+ 	local cur
+ 
+         COMPREPLY=()
+         cur=${COMP_WORDS[COMP_CWORD]}
+ 
+ 	COMPREPLY=($( lsmod | awk '{if (NR != 1 && $1 ~ /^'$cur'/) print $1}'))
+ 	return 0
+ }
+ complete -F _rmmod rmmod
+ 
+ # Linux insmod(1) completion. This completes on a list of all
+ # available modules for the version of the kernel currently running.
+ #
+ _insmod ()
+ {
+ 	local cur modpath
+ 
+         COMPREPLY=()
+         cur=${COMP_WORDS[COMP_CWORD]}
+ 	modpath=/lib/modules/`uname -r`
+ 
+ 	COMPREPLY=($( ls -R $modpath | sed -ne 's/^\('$cur'.*\)\.o$/\1/p'))
+ 	return 0
+ }
+ complete -F _insmod insmod depmod modprobe
+ 
+ # man(1) completion. This relies on the security enhanced version of
+ # GNU locate(1). UNIX variants having non-numeric man page sections
+ # other than l, m and n should add the appropriate sections to the
+ # first clause of the case statement.
+ #
+ # This is Linux specific, in that 'man <section> <page>' is the
+ # expected syntax. This allows one to do something like
+ # 'man 3 str<tab>' to obtain a list of all string handling syscalls on
+ # the system.
+ #
+ _man ()
+ {
+ 	local cur prev
+ 
+         COMPREPLY=()
+         cur=${COMP_WORDS[COMP_CWORD]}
+         prev=${COMP_WORDS[COMP_CWORD-1]}
+ 
+ 	case "$prev" in
+ 	[0-9lmn])
+ 		COMPREPLY=($( slocate -ql 0 -r '/man/man'$prev'/'$cur | \
+ 		      sed -ne 's/^.*\/\('$cur'[^.\/]*\)\..*$/\1/p' ))
+ 		return 0
+ 		;;
+ 	*)
+ 		COMPREPLY=($( slocate -ql 0 -r '/man/man./'$cur | \
+ 		      sed -ne 's/^.*\/\('$cur'[^.\/]*\)\..*$/\1/p' ))
+ 		return 0
+ 		;;
+ 	esac
+ }
+ complete -F _man man
+ 
+ # Linux killall(1) completion. This wouldn't be much use on, say,
+ # Solaris, where killall does exactly that: kills ALL processes.
+ #
+ # This could be improved. For example, it currently doesn't take
+ # command line options into account
+ #
+ _killall ()
+ {
+ 	local cur prev
+ 
+         COMPREPLY=()
+         cur=${COMP_WORDS[COMP_CWORD]}
+         prev=${COMP_WORDS[COMP_CWORD-1]}
+ 
+ 	case "$prev" in
+ 	-[A-Z0-9]*)
+ 		# get a list of processes (the first sed evaluation
+ 		# takes care of swapped out processes, the second
+ 		# takes care of getting the basename of the process)
+ 	       COMPREPLY=( $( ps ahx | awk '{if ($5 ~ /^'$cur'/) print $5}' | \
+ 			       sed -e 's#[]\[]##g' -e 's#^.*/##' ))
+ 		return 0
+ 		;;
+ 	esac
+ 
+ 	# first parameter can be either a signal or a process
+ 	if [ $COMP_CWORD -eq 1 ]; then
+ 		# standard signal completion is rather braindead, so we need
+ 		# to hack around to get what we want here, which is to
+ 		# complete on a dash, followed by the signal name minus
+ 		# the SIG prefix
+ 		COMPREPLY=( $( compgen -A signal SIG${cur#-} ))
+ 		for (( i=0; i < ${#COMPREPLY[@]}; i++ )); do
+ 			COMPREPLY[i]=-${COMPREPLY[i]#SIG}
+ 		done
+ 	fi
+ 
+ 	# get processes, adding to signals if applicable
+ 	COMPREPLY=( ${COMPREPLY[*]} $( ps ahx | \
+ 		                       awk '{if ($5 ~ /^'$cur'/) print $5}' | \
+ 				       sed -e 's#[]\[]##g' -e 's#^.*/##' ))
+ 	return 0
+ }
+ complete -F _killall killall
+ 
+ # GNU find(1) completion. This makes heavy use of ksh style extended
+ # globs and contains Linux specific code for completing the parameter
+ # to the -fstype option.
+ #
+ _find ()
+ {
+ 	local cur prev
+ 
+         COMPREPLY=()
+         cur=${COMP_WORDS[COMP_CWORD]#-}
+         prev=${COMP_WORDS[COMP_CWORD-1]}
+ 
+ 	case "$prev" in
+ 	-@(max|min)depth)
+ 		COMPREPLY=( $( compgen -W '0 1 2 3 4 5 6 7 8 9' ) )
+ 		return 0
+ 		;;
+ 	-?(a)newer|-fls|-fprint?(0|f))
+ 		COMPREPLY=( $( compgen -f $cur ) )
+ 		return 0
+ 		;;
+ 	-fstype)
+ 		# this is highly non-portable (the option to -d is a tab)
+ 		COMPREPLY=( $( cut -d'	' -f 2 /proc/filesystems | grep ^$cur ) )
+ 		return 0
+ 		;;
+ 	-gid)
+ 		COMPREPLY=( $( awk 'BEGIN {FS=":"} \
+ 				{if ($3 ~ /^'$cur'/) print $3}' /etc/group ) )
+ 		return 0
+ 		;;
+ 	-group)
+ 		COMPREPLY=( $( awk 'BEGIN {FS=":"} \
+ 				{if ($1 ~ /^'$cur'/) print $1}' /etc/group ) )
+ 		return 0
+ 		;;
+ 	-?(x)type)
+ 		COMPREPLY=( $( compgen -W 'b c d p f l s' $cur ) )
+ 		return 0
+ 		;;
+ 	-uid)
+ 		COMPREPLY=( $( awk 'BEGIN {FS=":"} \
+ 				{if ($3 ~ /^'$cur'/) print $3}' /etc/passwd ) )
+ 		return 0
+ 		;;
+ 	-user)
+ 		COMPREPLY=( $( compgen -u $cur ) )
+ 		return 0
+ 		;;
+ 	-[acm]min|-[acm]time|-?(i)?(l)name|-inum|-?(i)path|-?(i)regex| \
+ 	-links|-perm|-size|-used|-exec|-ok|-printf)
+ 		# do nothing, just wait for a parameter to be given
+ 		return 0
+ 		;;
+ 	esac
+ 
+ 	# complete using basic options ($cur has had its dash removed here,
+ 	# as otherwise compgen will bomb out with an error, since it thinks
+ 	# the dash is an option to itself)
+ 	COMPREPLY=( $( compgen -W 'daystart depth follow help maxdepth \
+ 			mindepth mount noleaf version xdev amin anewer atime \
+ 			cmin cnewer ctime empty false fstype gid group ilname \
+ 			iname inum ipath iregex links lname mmin mtime name \
+ 			newer nouser nogroup perm regex size true type uid \
+ 			used user xtype exec fls fprint fprint0 fprintf ok \
+ 			print print0 printf prune ls' $cur ) )
+ 
+ 	# this removes any options from the list of completions that have
+ 	# already been specified somewhere on the command line.
+ 	COMPREPLY=( $( echo "${COMP_WORDS[@]}-" | \
+ 		       (while read -d '-' i; do
+ 			    [ "$i" == "" ] && continue
+ 			    # flatten array with spaces on either side,
+ 			    # otherwise we cannot grep on word boundaries of
+ 			    # first and last word
+ 			    COMPREPLY=" ${COMPREPLY[@]} "
+ 			    # remove word from list of completions
+ 			    COMPREPLY=( ${COMPREPLY/ ${i%% *} / } )
+ 		        done
+ 		        echo ${COMPREPLY[@]})
+ 		  ) )
+ 	
+ 	# put dashes back
+ 	for (( i=0; i < ${#COMPREPLY[@]}; i++ )); do
+ 		COMPREPLY[i]=-${COMPREPLY[i]}
+ 	done
+ 		
+ 	return 0
+ }
+ complete -F _find find
+ 
+ # Linux ifconfig(8) completion
+ #
+ _ifconfig ()
+ {
+ 	local cur
+ 
+         COMPREPLY=()
+         cur=${COMP_WORDS[COMP_CWORD]}
+ 
+ 	case "${COMP_WORDS[1]}" in
+ 	-|*[0-9]*)
+ 		COMPREPLY=( $( compgen -W '-a up down arp promisc allmulti \
+ 					   metric mtu dstaddr netmask add del \
+ 					   tunnel irq io_addr mem_start media \
+ 					   broadcast pointopoint hw multicast \
+ 					   address txqueuelen' $cur ))
+ 		COMPREPLY=( $( echo " ${COMP_WORDS[@]}" | \
+ 			       (while read -d ' ' i; do
+ 				   [ "$i" == "" ] && continue
+ 				   # flatten array with spaces on either side,
+ 				   # otherwise we cannot grep on word
+ 				   # boundaries of first and last word
+ 				   COMPREPLY=" ${COMPREPLY[@]} "
+ 				   # remove word from list of completions
+ 				   COMPREPLY=( ${COMPREPLY/ $i / } )
+ 				done
+ 			        echo ${COMPREPLY[@]})
+ 			  ) )
+ 		return 0
+ 		;;
+ 	esac
+ 
+ 	COMPREPLY=( $( ifconfig -a | sed -ne 's/^\('$cur'[^ ]*\).*$/\1/p' ))
+ }
+ complete -F _ifconfig ifconfig
+ 
+ # Linux ipsec(8) completion (for FreeS/WAN). Very basic.
+ #
+ _ipsec ()
+ {
+ 	local cur
+ 
+         COMPREPLY=()
+         cur=${COMP_WORDS[COMP_CWORD]}
+ 
+ 	COMPREPLY=( $( compgen -W 'auto barf eroute klipsdebug look manual \
+ 				   pluto ranbits rsasigkey setup showdefaults \
+ 				   showhostkey spi spigrp tncfg whack' $cur ))
+ }
+ complete -F _ipsec ipsec
+ #########################################################################
diff -Nrc2 bash-2.04/examples/complete/complete2.ianmac bash-2.05/examples/complete/complete2.ianmac
*** bash-2.04/examples/complete/complete2.ianmac	Wed Dec 31 19:00:00 1969
--- bash-2.05/examples/complete/complete2.ianmac	Mon Aug 14 09:44:59 2000
***************
*** 0 ****
--- 1,271 ----
+ #####
+ #From: ian@linuxcare.com (Ian Macdonald)
+ #Newsgroups: comp.unix.shell
+ #Subject: More bash 2.04 completions
+ #Date: 12 Aug 2000 09:53:40 GMT
+ #Organization: Linuxcare, Inc.
+ #Lines: 274
+ #Message-ID: <slrn8pa7l2.jgm.ian@lovelorn.linuxcare.com>
+ #Reply-To: ian@linuxcare.com
+ #####
+ 
+ # Turn on extended globbing
+ shopt -s extglob
+ 
+ # cvs(1) completion
+ #
+ _cvs ()
+ {
+ 	local cur prev
+ 
+         COMPREPLY=()
+         cur=${COMP_WORDS[COMP_CWORD]}
+         prev=${COMP_WORDS[COMP_CWORD-1]}
+ 
+ 	if [ $COMP_CWORD -eq 1 ] || [ "${prev:0:1}" = "-" ]; then
+ 		COMPREPLY=( $( compgen -W 'add admin checkout commit diff \
+ 		export history import log rdiff release remove rtag status \
+ 		tag update' $cur ))
+ 	else
+ 		COMPREPLY=( $( compgen -f $cur ))
+ 	fi
+ 	return 0
+ }
+ complete -F _cvs cvs
+ 
+ # rpm(8) completion. This isn't exhaustive yet, but still provides
+ # quite a lot of functionality.
+ # 
+ _rpm()
+ {
+ 	dashify()
+ 	{
+ 		local i
+ 
+ 		for (( i=0; i < ${#COMPREPLY[@]}; i++ )); do
+ 			if [ ${#COMPREPLY[i]} -le 2 ]; then
+ 				COMPREPLY[i]=-${COMPREPLY[i]}
+ 			else
+ 				COMPREPLY[i]=--${COMPREPLY[i]}
+ 			fi
+ 		done
+ 	}
+ 
+ 	local cur cur_nodash prev
+ 
+         COMPREPLY=()
+         cur=${COMP_WORDS[COMP_CWORD]}
+ 	cur_nodash=${cur#-}
+         prev=${COMP_WORDS[COMP_CWORD-1]}
+ 
+ 	if [ $COMP_CWORD = 1 ]; then
+ 		# first parameter on line
+ 		case "$cur" in
+ 		-b*)
+ 			COMPREPLY=( $( compgen -W 'ba bb bc bi bl bp bs' \
+ 				       $cur_nodash ) )
+ 			dashify
+ 			return 0
+ 			;;
+ 		-t*)
+ 			COMPREPLY=( $( compgen -W 'ta tb tc ti tl tp ts' \
+ 				       $cur_nodash ) )
+ 			dashify
+ 			return 0
+ 			;;
+ 		--*)
+ 			COMPREPLY=( $( compgen -W 'help version initdb \
+ 			checksig recompile rebuild resign addsign rebuilddb \
+ 			showrc setperms setgids' ${cur_nodash#-} ) )
+ 			dashify;
+ 			return 0
+ 			;;
+ 		*)
+ 			COMPREPLY=( $( compgen -W 'b e F i q t U V' \
+ 				       $cur_nodash ) )
+ 			dashify
+ 			return 0
+ 			;;
+ 		esac
+ 	fi
+ 
+ 	case "${COMP_WORDS[1]}" in
+ 	-[iFU]*)
+ 		# complete on list of relevant options
+ 		COMPREPLY=( $( compgen -W 'percent force test replacepkgs \
+ 		replacefiles root excludedocs includedocs noscripts rcfile \
+ 		ignorearch dbpath prefix ignoreos nodeps allfiles ftpproxy \
+ 		ftpport justdb httpproxy httpport noorder relocate badreloc \
+ 		notriggers excludepath ignoresize oldpackage' ${cur_nodash#-} ))
+ 		dashify;
+ 		# return if $cur is an option
+ 		[ "${cur:0:1}" = "-" ] && return 0
+ 		# add a list of RPMS to possible completions
+ 		COMPREPLY=( ${COMPREPLY[@]} $( compgen -G $cur\*.rpm ) )
+ 		return 0
+ 		;;
+ 	-qp*)
+ 		# complete on list of relevant options
+ 		COMPREPLY=( $( compgen -W 'scripts root rcfile whatprovides \
+ 		whatrequires requires triggeredby ftpport ftpproxy httpproxy \
+ 		httpport provides triggers dump changelog dbpath filesbypkg' \
+ 		${cur_nodash#-} ) )
+ 		dashify;
+ 		# return if $cur is an option
+ 		[ "${cur:0:1}" = "-" ] && return 0
+ 		# add a list of RPMS to possible completions
+ 		COMPREPLY=( ${COMPREPLY[@]} $( compgen -G $cur\*.rpm ) )
+ 		return 0
+ 		;;
+ 	-*f)
+ 		# standard filename completion
+ 		COMPREPLY=( $( compgen -f $cur ) )
+ 		return 0
+ 		;;
+ 	-e)
+ 		# complete on list of relevant options
+ 		COMPREPLY=( $( compgen -W 'allmatches noscripts notriggers \
+ 		nodeps test' ${cur_nodash#-} ) )
+ 		dashify;
+ 		# return if $cur is an option
+ 		[ "${cur:0:1}" = "-" ] && return 0
+ 		# complete on basename of installed RPMs
+ 		COMPREPLY=( $( rpm -qa | \
+ 		   sed -ne 's/^\('$cur'.*\)-[0-9a-zA-Z._]\+-[0-9.]\+$/\1/p' ) )
+ 		return 0
+ 		;;
+ 	-qa*)
+ 		# complete on list of relevant options
+ 		COMPREPLY=( $( compgen -W 'scripts root rcfile whatprovides \
+ 		whatrequires requires triggeredby ftpport ftpproxy httpproxy \
+ 		httpport provides triggers dump changelog dbpath specfile \
+ 		querybynumber last filesbypkg' ${cur_nodash#-} ) )
+ 		dashify;
+ 		return 0
+ 		;;
+ 	-q*)
+ 		# complete on list of relevant options
+ 		COMPREPLY=( $( compgen -W 'scripts root rcfile whatprovides \
+ 		whatrequires requires triggeredby ftpport ftpproxy httpproxy \
+ 		httpport provides triggers dump changelog dbpath specfile \
+ 		querybynumber last filesbypkg' ${cur_nodash#-} ) )
+ 		dashify;
+ 		# return if $cur is an option
+ 		[ "${cur:0:1}" = "-" ] && return 0
+ 		# add a list of RPMS to possible completions
+ 		COMPREPLY=( ${COMPREPLY[@]} $( rpm -qa | \
+ 		   sed -ne 's/^\('$cur'.*\)-[0-9a-zA-Z._]\+-[0-9.]\+$/\1/p' ) )
+ 		return 0
+ 		;;
+ 	-[Vy]*)
+ 		# complete on list of relevant options
+ 		COMPREPLY=( $( compgen -W 'root rcfile dbpath nodeps nofiles \
+ 		noscripts nomd5 nopgp' ${cur_nodash#-} ) )
+ 		dashify;
+ 		# return if $cur is an option
+ 		[ "${cur:0:1}" = "-" ] && return 0
+ 		# add a list of RPMS to possible completions
+ 		COMPREPLY=( ${COMPREPLY[@]} $( rpm -qa | \
+ 		   sed -ne 's/^\('$cur'.*\)-[0-9a-zA-Z._]\+-[0-9.]\+$/\1/p' ) )
+ 		return 0
+ 		;;
+ 	-b*)
+ 		# complete on list of relevant options
+ 		COMPREPLY=( $( compgen -W 'short-circuit timecheck clean \
+ 		rmsource test sign buildroot target buildarch buildos' \
+ 		${cur_nodash#-} ) )
+ 		dashify;
+ 		# return if $cur is an option
+ 		[ "${cur:0:1}" = "-" ] && return 0
+ 		# complete on .spec files
+ 		COMPREPLY=( $( compgen -G $cur\*.spec ) )
+ 		return 0
+ 		;;
+ 	-t*)
+ 		# complete on list of relevant options
+ 		COMPREPLY=( $( compgen -W 'short-circuit timecheck clean \
+ 		rmsource test sign buildroot target buildarch buildos' \
+ 		${cur_nodash#-} ) )
+ 		dashify;
+ 		# return if $cur is an option
+ 		[ "${cur:0:1}" = "-" ] && return 0
+ 		# complete on .tar.gz files
+ 		COMPREPLY=( $( compgen -G $cur\*.tar.gz ) )
+ 		return 0
+ 		;;
+ 	--re@(build|compile))
+ 		# complete on source RPMs
+ 		COMPREPLY=( $( compgen -G $cur\*.src.rpm ) )
+ 		return 0
+ 		;;
+ 	--@(checksig|@(re|add)sign))
+ 		# complete on RPMs
+ 		COMPREPLY=( $( compgen -G $cur\*.rpm ) )
+ 		return 0
+ 		;;
+ 	--set@(perms|gids))
+ 		# complete on installed RPMs
+ 		COMPREPLY=( ${COMPREPLY[@]} $( rpm -qa | \
+ 		   sed -ne 's/^\('$cur'.*\)-[0-9a-zA-Z._]\+-[0-9.]\+$/\1/p' ) )
+ 		return 0
+ 		;;
+ 	esac
+ }
+ complete -F _rpm rpm
+ 
+ # chsh(1) completion
+ #
+ _chsh()
+ {
+ 	local cur prev
+ 
+         COMPREPLY=()
+         cur=${COMP_WORDS[COMP_CWORD]}
+         prev=${COMP_WORDS[COMP_CWORD-1]}
+ 
+ 	if [ "$prev" = "-s" ]; then
+ 		COMPREPLY=( $( chsh -l | grep ^$cur ) )
+ 	else
+ 		COMPREPLY=( $( compgen -u $cur ) )
+ 	fi
+ }
+ complete -F _chsh chsh
+ 
+ # chkconfig(8) completion
+ #
+ _chkconfig()
+ {
+ 	local cur prev
+ 
+         COMPREPLY=()
+         cur=${COMP_WORDS[COMP_CWORD]}
+ 	cur_nodash=${cur#--}
+         prev=${COMP_WORDS[COMP_CWORD-1]}
+ 
+ 	if [ $COMP_CWORD -eq 1 ]; then
+ 		COMPREPLY=( $( compgen -W 'list add del level' $cur_nodash ) )
+ 		for (( i=0; i < ${#COMPREPLY[@]}; i++ )); do
+ 			COMPREPLY[i]=--${COMPREPLY[i]}
+ 		done
+ 		return 0
+ 	fi
+ 
+ 	if [ $COMP_CWORD -eq 4 ]; then
+ 		COMPREPLY=( $( compgen -W 'on off reset' $cur ) )
+ 		return 0
+ 	fi
+ 
+ 	case "$prev" in
+ 	@([1-6]|--@(list|add|del)))
+ 		COMPREPLY=( $( compgen -W "`(cd /etc/rc.d/init.d; echo *)`" \
+ 			       $cur) )
+ 		return 0
+ 		;;
+ 	--level)
+ 		COMPREPLY=( $( compgen -W '1 2 3 4 5 6' $cur ) )
+ 		return 0
+ 		;;
+ 	esac
+ }
+ complete -F _chkconfig chkconfig
+ ###
diff -Nrc2 bash-2.04/examples/functions/array-to-string bash-2.05/examples/functions/array-to-string
*** bash-2.04/examples/functions/array-to-string	Wed Dec 31 19:00:00 1969
--- bash-2.05/examples/functions/array-to-string	Tue Nov 21 11:56:16 2000
***************
*** 0 ****
--- 1,15 ----
+ #! /bin/bash
+ 
+ # Format: array_to_string vname_of_array vname_of_string separator
+ array_to_string()
+ {
+ 	(( ($# < 2) || ($# > 3) )) && {
+ 		 "$FUNCNAME: usage: $FUNCNAME arrayname stringname [separator]"
+ 		return 2
+ 	}
+ 
+ 	local array=$1 string=$2
+ 	((3==$#)) && [[ $3 = ? ]] && local IFS="${3}${IFS}"
+ 	eval $string="\"\${$array[*]}\""
+ 	return 0
+ }
diff -Nrc2 bash-2.04/examples/functions/emptydir bash-2.05/examples/functions/emptydir
*** bash-2.04/examples/functions/emptydir	Wed Dec 31 19:00:00 1969
--- bash-2.05/examples/functions/emptydir	Tue Nov 21 11:35:16 2000
***************
*** 0 ****
--- 1,28 ----
+ #! /bin/bash
+ #
+ #Derived from:
+ #
+ #From: damercer@mmm.com (Dan Mercer)
+ #Newsgroups: comp.unix.admin,comp.unix.shell,comp.unix.programmer,comp.sys.sun.admin
+ #Subject: Re: Command to find out if a directory is empty
+ #Date: 17 Aug 2000 14:35:56 GMT
+ #Message-ID: <8ngt8c$fmr$1@magnum.mmm.com>
+ 
+ # usage: emptydir [dirname] ;  default dirname is "."
+ 
+ emptydir()
+ {
+ 	typeset file dir=${1:-.}
+ 	[[ -d $dir ]] || {
+ 		echo "$FUNCNAME: $dir is not a directory" >&2
+ 		return 2
+ 	}
+ 	for file in $dir/.* $dir/*
+ 	do
+ 		case ${file#$dir/} in
+ 		.|..) ;;
+ 		\*) [[ -e $file ]];let $?;return;;
+ 		*) return 1;;
+ 		esac
+ 	done
+ }
diff -Nrc2 bash-2.04/examples/functions/fact bash-2.05/examples/functions/fact
*** bash-2.04/examples/functions/fact	Mon Dec 30 16:17:33 1991
--- bash-2.05/examples/functions/fact	Fri Feb 23 11:05:26 2001
***************
*** 10,13 ****
          return ;
      fi;
!     echo $[ $num * $(fact $[ $num - 1 ])]
  }
--- 10,13 ----
          return ;
      fi;
!     echo $(( $num * $(fact $(( $num - 1 )) ) ))
  }
diff -Nrc2 bash-2.04/examples/functions/gethtml bash-2.05/examples/functions/gethtml
*** bash-2.04/examples/functions/gethtml	Wed Dec 31 19:00:00 1969
--- bash-2.05/examples/functions/gethtml	Wed Jan 17 13:09:59 2001
***************
*** 0 ****
--- 1,35 ----
+ #
+ # get_html -- get a web page from a remote server
+ #
+ # Original Author: Jeff Korn <jlk@cs.princeton.edu>
+ # Modified for bash by Chet Ramey <chet@po.cwru.edu>
+ #
+ # Example: get_html cnswww.cns.cwru.edu /~chet/ | more
+ 
+ get_html()
+ {
+ 	local host port
+ 
+ 	(($# < 2)) && {
+ 		echo "usage: $FUNCNAME hostname path [port]" >&2
+ 		return 1
+ 	}
+ 
+ 	host="$1"
+ 	port="${3:-80}"
+ 
+         exec 3<> /dev/tcp/$host/$port || {
+ 		echo "$FUNCNAME: $host/$port: cannot connect" >&2
+ 		exit 1
+ 	}
+ 
+         echo -e "GET $2 HTTP/1.0\n" >&3
+ 
+ 	cat <&3
+ 
+ 	exec 3<&-
+ 
+ 	return 0
+ }
+ 
+ get_html "$@"
diff -Nrc2 bash-2.04/examples/functions/ksh-cd bash-2.05/examples/functions/ksh-cd
*** bash-2.04/examples/functions/ksh-cd	Wed Dec 31 19:00:00 1969
--- bash-2.05/examples/functions/ksh-cd	Fri Feb 23 11:44:49 2001
***************
*** 0 ****
--- 1,35 ----
+ #
+ # ksh-like `cd': cd [-LP] [dir [change]]
+ #
+ cd()
+ {
+ 	OPTIND=1
+ 	while getopts "LP" opt
+ 	do
+ 		case $opt in
+ 		L|P)	CDOPTS="$CDOPTS -$opt" ;;
+ 		*)	echo "$FUNCNAME: usage: $FUNCNAME [-LP] [dir] [change]" >&2
+ 			return 2;;
+ 		esac
+ 	done
+ 
+ 	shift $(( $OPTIND - 1 ))
+ 
+ 	case $# in
+ 	0)	builtin cd $CDOPTS "$HOME" ;;
+ 	1) 	builtin cd $CDOPTS "$@" ;;
+ 	2)	old="$1" new="$2"
+ 		case "$PWD" in
+ 		*$old*)	;;
+ 		*)	 echo "${0##*/}: $FUNCNAME: bad substitution" >&2 ; return 1 ;;
+ 		esac
+ 
+ 		dir=${PWD//$old/$new}
+ 
+ 		builtin cd $CDOPTS "$dir" && echo "$PWD"
+ 
+ 		;;
+ 	*)	echo "${0##*/}: $FUNCNAME: usage: $FUNCNAME [-LP] [dir] [change]" >&2
+ 		return 2 ;;
+ 	esac
+ }
diff -Nrc2 bash-2.04/examples/functions/kshenv bash-2.05/examples/functions/kshenv
*** bash-2.04/examples/functions/kshenv	Mon May  3 18:37:39 1999
--- bash-2.05/examples/functions/kshenv	Fri Feb 23 11:53:29 2001
***************
*** 110,134 ****
  #}
  
  cd()
  {
  	case $# in
! 	0)	builtin cd "$HOME" ;;
! 	1) 	builtin cd "$@" ;;
! 	2)	old="$1"
! 		new="$2"
! 		# dir=$(echo "$PWD" | sed "s:$old:$new:g")
! 		dir=${PWD//$old/$new}
! 		case "$dir" in
! 		"$PWD")	case "$PWD" in
! 			*$old*) ;;
! 			*) echo "$FUNCNAME: bad substitution" >&2 ; return 1 ;;
! 			esac ;;
! 		*)	echo "$dir"
! 			builtin cd "$dir"
! 			;;
  		esac
  		;;
! 	*)	echo "$FUNCNAME: usage: $FUNCNAME [-LP] [dir] [change]" >&2
! 		return 1 ;;
  	esac
  }
--- 110,146 ----
  #}
  
+ #
+ # ksh-like `cd': cd [-LP] [dir [change]]
+ #
  cd()
  {
+ 	OPTIND=1
+ 	while getopts "LP" opt
+ 	do
+ 		case $opt in
+ 		L|P)	CDOPTS="$CDOPTS -$opt" ;;
+ 		*)	echo "$FUNCNAME: usage: $FUNCNAME [-LP] [dir] [change]" >&2
+ 			return 2;;
+ 		esac
+ 	done
+ 
+ 	shift $(( $OPTIND - 1 ))
+ 
  	case $# in
! 	0)	builtin cd $CDOPTS "$HOME" ;;
! 	1) 	builtin cd $CDOPTS "$@" ;;
! 	2)	old="$1" new="$2"
! 		case "$PWD" in
! 		*$old*)	;;
! 		*)	 echo "${0##*/}: $FUNCNAME: bad substitution" >&2 ; return 1 ;;
  		esac
+ 
+ 		dir=${PWD//$old/$new}
+ 
+ 		builtin cd $CDOPTS "$dir" && echo "$PWD"
+ 
  		;;
! 	*)	echo "${0##*/}: $FUNCNAME: usage: $FUNCNAME [-LP] [dir] [change]" >&2
! 		return 2 ;;
  	esac
  }
diff -Nrc2 bash-2.04/examples/functions/lowercase bash-2.05/examples/functions/lowercase
*** bash-2.04/examples/functions/lowercase	Tue Nov  2 17:17:48 1999
--- bash-2.05/examples/functions/lowercase	Mon Apr 17 16:55:21 2000
***************
*** 12,16 ****
  		[ -f "$file" ] || continue
  		filename=${file##*/}
! 		case "$filename" in
  		*/*)    dirname=${file%/*} ;;
  		*) dirname=.;;
--- 12,16 ----
  		[ -f "$file" ] || continue
  		filename=${file##*/}
! 		case "$file" in
  		*/*)    dirname=${file%/*} ;;
  		*) dirname=.;;
diff -Nrc2 bash-2.04/examples/functions/recurse bash-2.05/examples/functions/recurse
*** bash-2.04/examples/functions/recurse	Wed Dec 31 19:00:00 1969
--- bash-2.05/examples/functions/recurse	Tue Nov 21 11:24:05 2000
***************
*** 0 ****
--- 1,64 ----
+ #!/bin/bash
+ 
+ #From: kaz@ashi.footprints.net (Kaz Kylheku)
+ #Newsgroups: comp.os.linux.misc
+ #Subject: Re: bash question: subdirectories
+ #Message-ID: <slrn8a0gu9.v5n.kaz@ashi.FootPrints.net>
+ #Date: Tue, 08 Feb 2000 16:24:35 GMT
+ 
+ #Actually it can be made to. That is to say, it is possible to code a recursive
+ #descender function in the bash language. Here is an example. 
+ #
+ #What is nice about this is that you can embed the function into your shell
+ #script. The function changes the current working directory as it descends.
+ #So it can handle arbitrarily deep paths. Whereas paths generated by the
+ #find command can cause a problem when they get too long; the kernel has a
+ #hard limit on the length of the string passed to the open() and other
+ #system calls. 
+ 
+ #There are races; what if the directory tree is blown away during the traversal?
+ #The function won't be able to crawl back up using the .. link and will just
+ #bail.
+ 
+ # Recursive Directory Traverser
+ # Author: Kaz Kylheku
+ # Date: Feb 27, 1999
+ # Copyright 1999
+ 
+ # Function parameter usage:
+ # $1 directory to search
+ # $2 pattern to search for
+ # $3 command to execute
+ # $4 secret argument for passing down path
+ 
+ function recurse
+ {
+     local file
+     local path
+ 
+     if [ "$4" = "" ] ; then
+         path="${1%/}/"
+     else
+         path="$4$1/"
+     fi
+ 
+     if cd "$1" ; then
+         for file in $2; do
+             if [ -f "$file" -o -d "$file" ]; then
+                 eval "$3"
+             fi
+         done
+         for file in .* * ; do
+             if [ "$file" = "." -o "$file" = ".." ] ; then
+                 continue
+             fi
+             if [ -d "$file" -a ! -L "$file" ]; then
+                 recurse "$file" "$2" "$3" "$path"
+             fi
+         done
+         cd ..
+     fi
+ }
+ 
+ recurse "$1" "$2" 'echo "$path$file"'
+ 
diff -Nrc2 bash-2.04/examples/functions/sort-pos-params bash-2.05/examples/functions/sort-pos-params
*** bash-2.04/examples/functions/sort-pos-params	Wed Dec 31 19:00:00 1969
--- bash-2.05/examples/functions/sort-pos-params	Tue Mar 20 09:34:38 2001
***************
*** 0 ****
--- 1,50 ----
+ # Sort the positional paramters.
+ # Make sure the positional parameters are passed as arguments to the function.
+ # If -u is the first arg, remove duplicate array members.
+ sort_posparams()
+ {
+ 	local -a R
+ 	local u
+ 
+ 	case "$1" in
+ 	-u)	u=-u ; shift ;;
+ 	esac
+ 
+ 	# if you want the case of no positional parameters to return success,
+ 	# remove the error message and return 0
+ 	if [ $# -eq 0 ]; then
+ 		echo "$FUNCNAME: argument expected" >&2
+ 		return 1
+ 	fi
+ 
+ 	# make R a copy of the positional parameters
+ 	R=( "${@}" )
+ 
+ 	# sort R.
+ 	R=( $( printf "%s\n" "${R[@]}" | sort $u) )
+ 
+ 	printf "%s\n" "${R[@]}"
+ 	return 0
+ }
+ 
+ # will print everything on separate lines
+ set -- 3 1 4 1 5 9 2 6 5 3 2
+ sort_posparams "$@"
+ 
+ # sets without preserving quoted parameters
+ set -- $( sort_posparams "$@" )
+ echo "$@"
+ echo $#
+ 
+ # sets preserving quoted parameters, beware pos params with embedded newlines
+ set -- 'a b' 'a c' 'x z'
+ 
+ oifs=$IFS
+ IFS=$'\n'
+ set -- $( sort_posparams "$@" )
+ IFS="$oifs"
+ 
+ echo "$@"
+ echo $#
+ 
+ sort_posparams
diff -Nrc2 bash-2.04/examples/loadables/Makefile.in bash-2.05/examples/loadables/Makefile.in
*** bash-2.04/examples/loadables/Makefile.in	Thu Aug  5 10:50:40 1999
--- bash-2.05/examples/loadables/Makefile.in	Wed Dec  6 11:26:45 2000
***************
*** 68,72 ****
  ALLPROG = print truefalse sleep pushd finfo logname basename dirname \
  	  tty pathchk tee head mkdir rmdir sprintf printenv id whoami \
! 	  uname sync push ln unlink
  OTHERPROG = necho getconf hello cat
  
--- 68,72 ----
  ALLPROG = print truefalse sleep pushd finfo logname basename dirname \
  	  tty pathchk tee head mkdir rmdir sprintf printenv id whoami \
! 	  uname sync push ln unlink cut realpath
  OTHERPROG = necho getconf hello cat
  
***************
*** 165,168 ****
--- 165,173 ----
  	$(SHOBJ_LD) $(SHOBJ_LDFLAGS) $(SHOBJ_XLDFLAGS) -o $@ unlink.o $(SHOBJ_LIBS)
  
+ cut:	cut.o
+ 	$(SHOBJ_LD) $(SHOBJ_LDFLAGS) $(SHOBJ_XLDFLAGS) -o $@ cut.o $(SHOBJ_LIBS)
+ 
+ realpath:	realpath.o
+ 	$(SHOBJ_LD) $(SHOBJ_LDFLAGS) $(SHOBJ_XLDFLAGS) -o $@ realpath.o $(SHOBJ_LIBS)
  
  # pushd is a special case.  We use the same source that the builtin version
***************
*** 215,216 ****
--- 220,222 ----
  push.o: push.c
  mkdir.o: mkdir.c
+ realpath.o: realpath.c
diff -Nrc2 bash-2.04/examples/loadables/cut.c bash-2.05/examples/loadables/cut.c
*** bash-2.04/examples/loadables/cut.c	Wed Dec 31 19:00:00 1969
--- bash-2.05/examples/loadables/cut.c	Fri Jul  7 11:30:02 2000
***************
*** 0 ****
--- 1,376 ----
+ /*
+  * Copyright (c) 1989, 1993
+  *	The Regents of the University of California.  All rights reserved.
+  *
+  * This code is derived from software contributed to Berkeley by
+  * Adam S. Moskowitz of Menlo Consulting and Marciano Pitargue.
+  *
+  * Redistribution and use in source and binary forms, with or without
+  * modification, are permitted provided that the following conditions
+  * are met:
+  * 1. Redistributions of source code must retain the above copyright
+  *    notice, this list of conditions and the following disclaimer.
+  * 2. Redistributions in binary form must reproduce the above copyright
+  *    notice, this list of conditions and the following disclaimer in the
+  *    documentation and/or other materials provided with the distribution.
+  * 3. All advertising materials mentioning features or use of this software
+  *    must display the following acknowledgement:
+  *	This product includes software developed by the University of
+  *	California, Berkeley and its contributors.
+  * 4. Neither the name of the University nor the names of its contributors
+  *    may be used to endorse or promote products derived from this software
+  *    without specific prior written permission.
+  *
+  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+  * SUCH DAMAGE.
+  */
+ 
+ #ifndef lint
+ static const char copyright[] =
+ "@(#) Copyright (c) 1989, 1993\n\
+ 	The Regents of the University of California.  All rights reserved.\n";
+ #endif /* not lint */
+ 
+ #ifndef lint
+ static const char sccsid[] = "@(#)cut.c	8.3 (Berkeley) 5/4/95";
+ #endif /* not lint */
+ 
+ #include <config.h>
+ 
+ #include <ctype.h>
+ #include <stdio.h>
+ #include <errno.h>
+ 
+ #include "bashansi.h"
+ 
+ #ifdef HAVE_LIMITS_H
+ #  include <limits.h>
+ #endif
+ 
+ #ifdef HAVE_UNISTD_H
+ #  include <unistd.h>
+ #endif
+ 
+ #include "builtins.h"
+ #include "shell.h"
+ #include "bashgetopt.h"
+ 
+ #if !defined (errno)
+ extern int	errno;
+ #endif
+ 
+ #if !defined (_POSIX2_LINE_MAX)
+ #  define _POSIX2_LINE_MAX 2048
+ #endif
+ 
+ static int	cflag;
+ static char	dchar;
+ static int	dflag;
+ static int	fflag;
+ static int	sflag;
+ 
+ static int autostart, autostop, maxval;
+ static char positions[_POSIX2_LINE_MAX + 1];
+ 
+ static int	c_cut __P((FILE *, char *));
+ static int	f_cut __P((FILE *, char *));
+ static int	get_list __P((char *));
+ static char	*_cut_strsep __P((char **, const char *));
+ 
+ int
+ cut_builtin(list)
+ 	WORD_LIST *list;
+ {
+ 	FILE *fp;
+ 	int (*fcn) __P((FILE *, char *)) = NULL;
+ 	int ch;
+ 
+ 	fcn = NULL;
+ 	dchar = '\t';			/* default delimiter is \t */
+ 
+ 	/* Since we don't support multi-byte characters, the -c and -b 
+ 	   options are equivalent, and the -n option is meaningless. */
+ 	reset_internal_getopt ();
+ 	while ((ch = internal_getopt (list, "b:c:d:f:sn")) != -1)
+ 		switch(ch) {
+ 		case 'b':
+ 		case 'c':
+ 			fcn = c_cut;
+ 			if (get_list(list_optarg) < 0)
+ 				return (EXECUTION_FAILURE);
+ 			cflag = 1;
+ 			break;
+ 		case 'd':
+ 			dchar = *list_optarg;
+ 			dflag = 1;
+ 			break;
+ 		case 'f':
+ 			fcn = f_cut;
+ 			if (get_list(list_optarg) < 0)
+ 				return (EXECUTION_FAILURE);
+ 			fflag = 1;
+ 			break;
+ 		case 's':
+ 			sflag = 1;
+ 			break;
+ 		case 'n':
+ 			break;
+ 		case '?':
+ 		default:
+ 			builtin_usage();
+ 			return (EX_USAGE);
+ 		}
+ 
+ 	list = loptend;
+ 
+ 	if (fflag) {
+ 		if (cflag) {
+ 			builtin_usage();
+ 			return (EX_USAGE);
+ 		}
+ 	} else if (!cflag || dflag || sflag) {
+ 		builtin_usage();
+ 		return (EX_USAGE);
+ 	}
+ 
+ 	if (list) {
+ 		while (list) {
+ 			fp = fopen(list->word->word, "r");
+ 			if (fp == 0) {
+ 				builtin_error("%s", list->word->word);
+ 				return (EXECUTION_FAILURE);
+ 			}
+ 			ch = (*fcn)(fp, list->word->word);
+ 			(void)fclose(fp);
+ 			if (ch < 0)
+ 				return (EXECUTION_FAILURE);
+ 			list = list->next;
+ 		}
+ 	} else {
+ 		ch = (*fcn)(stdin, "stdin");
+ 		if (ch < 0)
+ 			return (EXECUTION_FAILURE);
+ 	}
+ 
+ 	return (EXECUTION_SUCCESS);
+ }
+ 
+ static int
+ get_list(list)
+ 	char *list;
+ {
+ 	int setautostart, start, stop;
+ 	char *pos;
+ 	char *p;
+ 
+ 	/*
+ 	 * set a byte in the positions array to indicate if a field or
+ 	 * column is to be selected; use +1, it's 1-based, not 0-based.
+ 	 * This parser is less restrictive than the Draft 9 POSIX spec.
+ 	 * POSIX doesn't allow lists that aren't in increasing order or
+ 	 * overlapping lists.  We also handle "-3-5" although there's no
+ 	 * real reason too.
+ 	 */
+ 	for (; (p = _cut_strsep(&list, ", \t")) != NULL;) {
+ 		setautostart = start = stop = 0;
+ 		if (*p == '-') {
+ 			++p;
+ 			setautostart = 1;
+ 		}
+ 		if (isdigit((unsigned char)*p)) {
+ 			start = stop = strtol(p, &p, 10);
+ 			if (setautostart && start > autostart)
+ 				autostart = start;
+ 		}
+ 		if (*p == '-') {
+ 			if (isdigit((unsigned char)p[1]))
+ 				stop = strtol(p + 1, &p, 10);
+ 			if (*p == '-') {
+ 				++p;
+ 				if (!autostop || autostop > stop)
+ 					autostop = stop;
+ 			}
+ 		}
+ 		if (*p) {
+ 			builtin_error("[-cf] list: illegal list value");
+ 			return -1;
+ 		}
+ 		if (!stop || !start) {
+ 			builtin_error("[-cf] list: values may not include zero");
+ 			return -1;
+ 		}
+ 		if (stop > _POSIX2_LINE_MAX) {
+ 			builtin_error("[-cf] list: %d too large (max %d)",
+ 				       stop, _POSIX2_LINE_MAX);
+ 			return -1;
+ 		}
+ 		if (maxval < stop)
+ 			maxval = stop;
+ 		for (pos = positions + start; start++ <= stop; *pos++ = 1);
+ 	}
+ 
+ 	/* overlapping ranges */
+ 	if (autostop && maxval > autostop)
+ 		maxval = autostop;
+ 
+ 	/* set autostart */
+ 	if (autostart)
+ 		memset(positions + 1, '1', autostart);
+ 
+ 	return 0;
+ }
+ 
+ /* ARGSUSED */
+ static int
+ c_cut(fp, fname)
+ 	FILE *fp;
+ 	char *fname;
+ {
+ 	int ch, col;
+ 	char *pos;
+ 
+ 	ch = 0;
+ 	for (;;) {
+ 		pos = positions + 1;
+ 		for (col = maxval; col; --col) {
+ 			if ((ch = getc(fp)) == EOF)
+ 				return;
+ 			if (ch == '\n')
+ 				break;
+ 			if (*pos++)
+ 				(void)putchar(ch);
+ 		}
+ 		if (ch != '\n') {
+ 			if (autostop)
+ 				while ((ch = getc(fp)) != EOF && ch != '\n')
+ 					(void)putchar(ch);
+ 			else
+ 				while ((ch = getc(fp)) != EOF && ch != '\n');
+ 		}
+ 		(void)putchar('\n');
+ 	}
+ 	return (0);
+ }
+ 
+ static int
+ f_cut(fp, fname)
+ 	FILE *fp;
+ 	char *fname;
+ {
+ 	int ch, field, isdelim;
+ 	char *pos, *p, sep;
+ 	int output;
+ 	char lbuf[_POSIX2_LINE_MAX + 1];
+ 
+ 	for (sep = dchar; fgets(lbuf, sizeof(lbuf), fp);) {
+ 		output = 0;
+ 		for (isdelim = 0, p = lbuf;; ++p) {
+ 			if (!(ch = *p)) {
+ 				builtin_error("%s: line too long.", fname);
+ 				return -1;
+ 			}
+ 			/* this should work if newline is delimiter */
+ 			if (ch == sep)
+ 				isdelim = 1;
+ 			if (ch == '\n') {
+ 				if (!isdelim && !sflag)
+ 					(void)printf("%s", lbuf);
+ 				break;
+ 			}
+ 		}
+ 		if (!isdelim)
+ 			continue;
+ 
+ 		pos = positions + 1;
+ 		for (field = maxval, p = lbuf; field; --field, ++pos) {
+ 			if (*pos) {
+ 				if (output++)
+ 					(void)putchar(sep);
+ 				while ((ch = *p++) != '\n' && ch != sep)
+ 					(void)putchar(ch);
+ 			} else {
+ 				while ((ch = *p++) != '\n' && ch != sep)
+ 					continue;
+ 			}
+ 			if (ch == '\n')
+ 				break;
+ 		}
+ 		if (ch != '\n') {
+ 			if (autostop) {
+ 				if (output)
+ 					(void)putchar(sep);
+ 				for (; (ch = *p) != '\n'; ++p)
+ 					(void)putchar(ch);
+ 			} else
+ 				for (; (ch = *p) != '\n'; ++p);
+ 		}
+ 		(void)putchar('\n');
+ 	}
+ 	return (0);
+ }
+ 
+ /*
+  * Get next token from string *stringp, where tokens are possibly-empty
+  * strings separated by characters from delim.
+  *
+  * Writes NULs into the string at *stringp to end tokens.
+  * delim need not remain constant from call to call.
+  * On return, *stringp points past the last NUL written (if there might
+  * be further tokens), or is NULL (if there are definitely no more tokens).
+  *
+  * If *stringp is NULL, strsep returns NULL.
+  */
+ static char *
+ _cut_strsep(stringp, delim)
+ 	register char **stringp;
+ 	register const char *delim;
+ {
+ 	register char *s;
+ 	register const char *spanp;
+ 	register int c, sc;
+ 	char *tok;
+ 
+ 	if ((s = *stringp) == NULL)
+ 		return (NULL);
+ 	for (tok = s;;) {
+ 		c = *s++;
+ 		spanp = delim;
+ 		do {
+ 			if ((sc = *spanp++) == c) {
+ 				if (c == 0)
+ 					s = NULL;
+ 				else
+ 					s[-1] = 0;
+ 				*stringp = s;
+ 				return (tok);
+ 			}
+ 		} while (sc != 0);
+ 	}
+ 	/* NOTREACHED */
+ }
+ 
+ static char *cut_doc[] = {
+ 	"Select portions of each line (as specified by LIST) from each FILE",
+ 	"(by default, the standard input), and write them to the standard output.",
+ 	"Items specified by LIST are either column positions or fields delimited",
+ 	"by a special character.  Column numbering starts at 1.",
+ 	(char *)0
+ };
+ 
+ struct builtin cut_struct = {
+ 	"cut",
+ 	cut_builtin,
+ 	BUILTIN_ENABLED,
+ 	cut_doc,
+ 	"cut -b list [-n] [file ...] OR cut -c list [file ...] OR cut -f list [-s] [-d delim] [file ...]",
+ 	0
+ };
diff -Nrc2 bash-2.04/examples/loadables/finfo.c bash-2.05/examples/loadables/finfo.c
*** bash-2.04/examples/loadables/finfo.c	Fri Nov 13 11:42:40 1998
--- bash-2.05/examples/loadables/finfo.c	Thu Feb 15 10:41:38 2001
***************
*** 10,13 ****
--- 10,14 ----
  #include <errno.h>
  
+ #include "bashansi.h"
  #include "shell.h"
  #include "builtins.h"
***************
*** 18,22 ****
  #endif
  
- extern char	*strrchr();
  extern char	**make_builtin_argv ();
  
--- 19,22 ----
***************
*** 138,142 ****
--- 138,146 ----
  		r = fstat(fd, &st);
  	} else
+ #ifdef HAVE_LSTAT
+ 		r = lstat(f, &st);
+ #else
  		r = stat(f, &st);
+ #endif
  	if (r < 0) {
  		builtin_error("%s: cannot stat: %s", f, strerror(errno));
diff -Nrc2 bash-2.04/examples/loadables/getconf.c bash-2.05/examples/loadables/getconf.c
*** bash-2.04/examples/loadables/getconf.c	Tue Sep 21 12:28:35 1999
--- bash-2.05/examples/loadables/getconf.c	Fri May 19 12:13:38 2000
***************
*** 56,60 ****
  {
    const char *name;
!   enum { SYSCONF, CONFSTR, PATHCONF, CONSTANT } type;
    long value;
  };
--- 56,60 ----
  {
    const char *name;
!   enum { SYSCONF, CONFSTR, PATHCONF, CONSTANT, G_UNDEF } type;
    long value;
  };
***************
*** 106,122 ****
--- 106,158 ----
  
    /* POSIX.2 Utility Limit Minimum Values */
+ #ifdef _POSIX2_BC_BASE_MAX
    { "POSIX2_BC_BASE_MAX",	CONSTANT,	_POSIX2_BC_BASE_MAX	},
+ #else
+   { "POSIX2_BC_BASE_MAX",	G_UNDEF,	-1			},
+ #endif
+ #ifdef _POSIX2_BC_DIM_MAX
    { "POSIX2_BC_DIM_MAX",	CONSTANT,	_POSIX2_BC_DIM_MAX	},
+ #else
+   { "POSIX2_BC_DIM_MAX",	G_UNDEF,	-1			},
+ #endif
+ #ifdef _POSIX2_BC_SCALE_MAX
    { "POSIX2_BC_SCALE_MAX",	CONSTANT,	_POSIX2_BC_SCALE_MAX	},
+ #else
+   { "POSIX2_BC_SCALE_MAX",	G_UNDEF,	-1			},
+ #endif
+ #ifdef _POSIX2_BC_STRING_MAX
    { "POSIX2_BC_STRING_MAX",	CONSTANT,	_POSIX2_BC_STRING_MAX	},
+ #else
+   { "POSIX2_BC_STRING_MAX",	G_UNDEF,	-1			},
+ #endif
+ #ifdef _POSIX2_COLL_WEIGHTS_MAX
    { "POSIX2_COLL_WEIGHTS_MAX",	CONSTANT,	_POSIX2_COLL_WEIGHTS_MAX },
+ #else
+   { "POSIX2_COLL_WEIGHTS_MAX",	G_UNDEF,	-1			 },
+ #endif
  #if defined (_POSIX2_EQUIV_CLASS_MAX)
    { "POSIX2_EQUIV_CLASS_MAX",	CONSTANT,	_POSIX2_EQUIV_CLASS_MAX	},
  #endif
+ #ifdef _POSIX2_EXPR_NEST_MAX
    { "POSIX2_EXPR_NEST_MAX",	CONSTANT,	_POSIX2_EXPR_NEST_MAX	},
+ #else
+   { "POSIX2_EXPR_NEST_MAX",	G_UNDEF,	-1			},
+ #endif
+ #ifdef _POSIX2_LINE_MAX
    { "POSIX2_LINE_MAX",		CONSTANT,	_POSIX2_LINE_MAX	},
+ #else
+   { "POSIX2_LINE_MAX",		G_UNDEF,	-1			},
+ #endif
+ #ifdef _POSIX2_RE_DUP_MAX
    { "POSIX2_RE_DUP_MAX",	CONSTANT,	_POSIX2_RE_DUP_MAX	},
+ #else
+   { "POSIX2_RE_DUP_MAX",	G_UNDEF,	-1			},
+ #endif
  #if defined (_POSIX2_VERSION)
    { "POSIX2_VERSION",		CONSTANT,	_POSIX2_VERSION		},
+ #else
+ #  if !defined (_SC_2_VERSION)
+   { "POSIX2_VERSION",		G_UNDEF,	-1			},
+ #  endif
  #endif
  
***************
*** 147,164 ****
--- 183,230 ----
  
    /* POSIX.2 Optional Facility Configuration Values */
+ #ifdef _SC_2_C_BIND
    { "POSIX2_C_BIND",		SYSCONF,	_SC_2_C_BIND		},
+ #else
+   { "POSIX2_C_BIND",		G_UNDEF,	-1			},
+ #endif
+ #ifdef _SC_2_C_DEV
    { "POSIX2_C_DEV",		SYSCONF,	_SC_2_C_DEV		},
+ #else
+   { "POSIX2_C_DEV",		G_UNDEF,	-1			},
+ #endif
  #if defined (_SC_2_C_VERSION)
    { "POSIX2_C_VERSION",		SYSCONF,	_SC_2_C_VERSION		},
+ #else
+   { "POSIX2_C_VERSION",		G_UNDEF,	-1			},
  #endif
  #if defined (_SC_2_CHAR_TERM)
    { "POSIX2_CHAR_TERM",		SYSCONF,	_SC_2_CHAR_TERM		},
+ #else
+   { "POSIX2_CHAR_TERM",		G_UNDEF,	-1			},
  #endif
+ #ifdef _SC_2_FORT_DEV
    { "POSIX2_FORT_DEV",		SYSCONF,	_SC_2_FORT_DEV		},
+ #else
+   { "POSIX2_FORT_DEV",		G_UNDEF,	-1			},
+ #endif
+ #ifdef _SC_2_FORT_RUN
    { "POSIX2_FORT_RUN",		SYSCONF,	_SC_2_FORT_RUN		},
+ #else
+   { "POSIX2_FORT_RUN",		G_UNDEF,	-1			},
+ #endif
+ #ifdef _SC_2_LOCALEDEF
    { "POSIX2_LOCALEDEF",		SYSCONF,	_SC_2_LOCALEDEF		},
+ #else
+   { "POSIX2_LOCALEDEF",		G_UNDEF,	-1			},
+ #endif
+ #ifdef _SC_2_SW_DEV
    { "POSIX2_SW_DEV",		SYSCONF,	_SC_2_SW_DEV		},
+ #else
+   { "POSIX2_SW_DEV",		G_UNDEF,	-1			},
+ #endif
  #if defined (_SC2_UPE)
    { "POSIX2_UPE",		SYSCONF,	_SC_2_UPE		},
+ #else
+   { "POSIX2_UPE",		G_UNDEF,	-1			},
  #endif
  #if !defined (_POSIX2_VERSION) && defined (_SC_2_VERSION)
***************
*** 450,453 ****
--- 516,523 ----
  
  	switch (cp->type) {
+ 	case G_UNDEF:
+ 		printf("undefined\n");
+ 		break;
+ 
  	case CONSTANT:
  		printf("%ld\n", cp->value);
***************
*** 509,513 ****
  	}
  
! 	return (ferror(stdout) ? EXECUTION_FAILURE : EXECUTION_SUCCESS);
  }
  
--- 579,584 ----
  	}
  
! 	return ((ferror(stdout) || cp->type == G_UNDEF) ? EXECUTION_FAILURE
! 							: EXECUTION_SUCCESS);
  }
  
diff -Nrc2 bash-2.04/examples/loadables/push.c bash-2.05/examples/loadables/push.c
*** bash-2.04/examples/loadables/push.c	Wed Dec 31 19:00:00 1969
--- bash-2.05/examples/loadables/push.c	Fri Nov 13 11:30:45 1998
***************
*** 0 ****
--- 1,95 ----
+ /*
+  * push - anyone remember TOPS-20?
+  *
+  */
+ 
+ #include <config.h>
+ #include <stdio.h>
+ #include <errno.h>
+ 
+ #include "builtins.h"
+ #include "shell.h"
+ #include "jobs.h"
+ #include "bashgetopt.h"
+ 
+ #ifndef errno
+ extern int errno;
+ #endif
+ 
+ extern int dollar_dollar_pid;
+ extern int last_command_exit_value;
+ 
+ int
+ push_builtin (list)
+      WORD_LIST *list;
+ {
+   pid_t pid;
+   int xstatus, opt;
+ 
+   xstatus = EXECUTION_SUCCESS;
+   reset_internal_getopt ();
+   while ((opt = internal_getopt (list, "")) != -1)
+     {
+       switch (opt)
+ 	{
+ 	default:
+ 	  builtin_usage ();
+ 	  return (EX_USAGE);
+ 	}
+     }
+   list = loptend;  
+ 
+   pid = make_child (savestring ("push"), 0);
+   if (pid == -1)
+     {
+       builtin_error ("cannot fork: %s", strerror (errno));
+       return (EXECUTION_FAILURE);
+     }
+   else if (pid == 0)
+     {
+       /* Shell variable adjustments: $SHLVL, $$, $PPID, $! */
+       adjust_shell_level (1);
+       dollar_dollar_pid = getpid ();
+       set_ppid ();
+ 
+       /* Clean up job control stuff. */
+       stop_making_children ();
+       cleanup_the_pipeline ();
+       delete_all_jobs (0);
+ 
+       last_asynchronous_pid = NO_PID;
+ 
+       /* Make sure the job control code has the right values for
+ 	 the shell's process group and tty process group, and that
+ 	 the signals are set correctly for job control. */
+       initialize_job_control (0);
+       initialize_job_signals ();
+ 
+       /* And read commands until exit. */
+       reader_loop ();
+       exit_shell (last_command_exit_value);
+     }
+   else
+     {
+       stop_pipeline (0, (COMMAND *)NULL);
+       xstatus = wait_for (pid);
+       return (xstatus);
+     }   
+ }
+ 
+ char *push_doc[] = {
+ 	"Create a child that is an exact duplicate of the running shell",
+ 	"and wait for it to exit.  The $SHLVL, $!, $$, and $PPID variables",
+ 	"are adjusted in the child.  The return value is the exit status",
+ 	"of the child.",
+ 	(char *)NULL
+ };
+ 
+ struct builtin push_struct = {
+ 	"push",
+ 	push_builtin,
+ 	BUILTIN_ENABLED,
+ 	push_doc,
+ 	"push",
+ 	0
+ };
diff -Nrc2 bash-2.04/examples/loadables/realpath.c bash-2.05/examples/loadables/realpath.c
*** bash-2.04/examples/loadables/realpath.c	Wed Dec 31 19:00:00 1969
--- bash-2.05/examples/loadables/realpath.c	Tue Feb  6 10:10:35 2001
***************
*** 0 ****
--- 1,119 ----
+ /*
+  * realpath -- canonicalize pathnames, resolving symlinks
+  *
+  * usage: realpath [-csv] pathname [pathname...]
+  *
+  * options:	-c	check whether or not each resolved path exists
+  *		-s	no output, exit status determines whether path is valid
+  *		-v	produce verbose output
+  *
+  *
+  * exit status:	0	if all pathnames resolved
+  *		1	if any of the pathname arguments could not be resolved
+  *
+  *
+  * Bash loadable builtin version
+  *
+  * Chet Ramey
+  * chet@po.cwru.edu
+  */
+ 
+ #include "config.h"
+ 
+ #include <sys/types.h>
+ #include <sys/stat.h>
+ 
+ #include <stdio.h>
+ #ifdef HAVE_UNISTD_H
+ #  include <unistd.h>
+ #endif
+ #include "bashansi.h"
+ #include <maxpath.h>
+ #include <errno.h>
+ 
+ #include "builtins.h"
+ #include "shell.h"
+ #include "bashgetopt.h"
+ 
+ #ifndef errno
+ extern int	errno;
+ #endif
+ 
+ extern char	*sh_realpath();
+ 
+ realpath_builtin(list)
+ WORD_LIST	*list;
+ {
+ 	int	opt, cflag, vflag, sflag, es;
+ 	char	*r, realbuf[PATH_MAX], *p;
+ 	struct stat sb;
+ 
+ 	if (list == 0) {
+ 		builtin_usage();
+ 		return (EX_USAGE);
+ 	}
+ 
+ 	vflag = cflag = sflag = 0;
+ 	reset_internal_getopt();
+ 	while ((opt = internal_getopt (list, "csv")) != -1) {
+ 		switch (opt) {
+ 		case 'c':
+ 			cflag = 1;
+ 			break;
+ 		case 's':
+ 			sflag = 1;
+ 			break;
+ 		case 'v':
+ 			vflag = 1;
+ 			break;
+ 		default:
+ 			usage();
+ 		}
+ 	}
+ 
+ 	list = loptend;
+ 
+ 	if (list == 0)
+ 		usage();
+ 
+ 	for (es = EXECUTION_SUCCESS; list; list = list->next) {
+ 		p = list->word->word;
+ 		r = sh_realpath(p, realbuf);
+ 		if (r == 0) {
+ 			es = EXECUTION_FAILURE;
+ 			if (sflag == 0)
+ 				builtin_error("%s: cannot resolve: %s", p, strerror(errno));
+ 			continue;
+ 		}
+ 		if (cflag && (stat(realbuf, &sb) < 0)) {
+ 			es = EXECUTION_FAILURE;
+ 			if (sflag == 0)
+ 				builtin_error("%s: %s", p, strerror(errno));
+ 			continue;
+ 		}
+ 		if (sflag == 0) {
+ 			if (vflag)
+ 				printf ("%s -> ", p);
+ 			printf("%s\n", realbuf);
+ 		}
+ 	}
+ 	return es;
+ }
+ 
+ char *realpath_doc[] = {
+ 	"Display the canonicalized version of each PATHNAME argument, resolving",
+ 	"symbolic links.  The -c option checks whether or not each resolved name",
+ 	"exists.  The -s option produces no output; the exit status determines the",
+ 	"valididty of each PATHNAME.  The -v option produces verbose output.  The",
+ 	"exit status is 0 if each PATHNAME was resolved; non-zero otherwise.",
+ 	(char *)NULL
+ };
+ 
+ struct builtin realpath_struct = {
+ 	"realpath",		/* builtin name */
+ 	realpath_builtin,	/* function implementing the builtin */
+ 	BUILTIN_ENABLED,	/* initial flags for builtin */
+ 	realpath_doc,		/* array of long documentation strings */
+ 	"realpath [-csv] pathname [pathname...]",	/* usage synopsis */
+ 	0			/* reserved for internal use */
+ };
diff -Nrc2 bash-2.04/examples/scripts/adventure.sh bash-2.05/examples/scripts/adventure.sh
*** bash-2.04/examples/scripts/adventure.sh	Wed Jun 23 12:44:31 1999
--- bash-2.05/examples/scripts/adventure.sh	Mon Jun 12 16:49:33 2000
***************
*** 100,104 ****
  LIM=.limbo			# $HOME/$LIM contains "destroyed" objects
  mkdir $LIM || {
! 	echo "ash: cannot mkdir $LIM: exiting
  	exit 1
  }
--- 100,104 ----
  LIM=.limbo			# $HOME/$LIM contains "destroyed" objects
  mkdir $LIM || {
! 	echo "ash: cannot mkdir $LIM: exiting"
  	exit 1
  }
diff -Nrc2 bash-2.04/examples/scripts/cat.sh bash-2.05/examples/scripts/cat.sh
*** bash-2.04/examples/scripts/cat.sh	Wed Dec 31 19:00:00 1969
--- bash-2.05/examples/scripts/cat.sh	Fri Mar 26 12:35:44 1999
***************
*** 0 ****
--- 1,12 ----
+ shcat()
+ {
+ 	while read -r ; do
+ 		echo "$REPLY"
+ 	done
+ }
+ 
+ if [ -n "$1" ]; then
+ 	shcat < "$1"
+ else
+ 	shcat
+ fi
diff -Nrc2 bash-2.04/examples/scripts/dd-ex.sh bash-2.05/examples/scripts/dd-ex.sh
*** bash-2.04/examples/scripts/dd-ex.sh	Wed Dec 31 19:00:00 1969
--- bash-2.05/examples/scripts/dd-ex.sh	Wed Sep  6 11:45:41 2000
***************
*** 0 ****
--- 1,476 ----
+ #!/bin/sh
+ 
+ # this is a line editor using only /bin/sh, /bin/dd and /bin/rm
+ 
+ # /bin/rm is not really required, but it is nice to clean up temporary files
+ 
+ PATH=
+ dd=/bin/dd
+ rm=/bin/rm
+ 
+ # temporary files we might need
+ tmp=/tmp/silly.$$
+ ed=/tmp/ed.$$
+ trap "$rm -f $tmp $tmp.1 $tmp.2 $tmp.3 $tmp.4 $tmp.5 $tmp.6 $ed.a $ed.b $ed.c; exit" 0 1 2 3
+ 
+ # from now on, no more rm - the above trap is enough
+ unset rm
+ 
+ # we do interesting things with IFS, but better save it...
+ saveIFS="$IFS"
+ 
+ # in case "echo" is not a shell builtin...
+ 
+ Echo () {
+ case "$1" in
+   -n) shift
+       $dd of=$tmp 2>/dev/null <<EOF 
+ $@
+ EOF
+       IFS="+"
+       set `$dd if=$tmp bs=1 of=/dev/null skip=1 2>&1`
+       IFS="$saveIFS"
+       $dd if=$tmp bs=1 count=$1 2>/dev/null
+       ;;
+   *)  $dd 2>/dev/null <<EOF 
+ $@
+ EOF
+       ;;
+ esac
+ }
+ 
+ # this is used to generate garbage files
+ 
+ true () {
+   return 0
+ }
+ 
+ false () {
+   return 1
+ }
+ 
+ zero () {
+   ( trap 'go=false' 13
+     go=true
+     while $go
+     do
+       $dd "if=$0"
+       case "$?" in
+ 	0) ;;
+ 	*) go=false ;;
+       esac
+     done
+   ) 2>/dev/null
+ }
+ 
+ # arithmetic using dd!
+ 
+ # add variable n1 n2 n3...
+ # assigns n1+n2+n3+... to variable
+ 
+ add () {
+   result="$1"
+   shift
+   $dd if=/dev/null of=$tmp bs=1 2>/dev/null
+   for n in "$@"
+   do
+     case "$n" in
+       0) ;;
+       *) zero | $dd of=$tmp.1 bs=1 "count=$n" 2>/dev/null
+ 	 ( $dd if=$tmp; $dd if=$tmp.1 ) 2>/dev/null | $dd of=$tmp.2 2>/dev/null
+ 	 $dd if=$tmp.2 of=$tmp 2>/dev/null
+ 	 ;;
+     esac
+   done
+   IFS="+"
+   set `$dd if=$tmp bs=1 of=/dev/null 2>&1`
+   IFS="$saveIFS"
+   eval $result='$1'
+ }
+ 
+ # subtract variable n1 n2
+ # subtracts n2 from n1, assigns result to variable
+ 
+ subtract () {
+   result="$1"
+   zero | $dd of=$tmp bs=1 "count=$2" 2>/dev/null
+   IFS="+"
+   set `$dd if=$tmp bs=1 of=/dev/null "skip=$3" 2>&1`
+   IFS="$saveIFS"
+   case "$1" in
+     dd*) set 0 ;;
+   esac
+   eval $result='$1'
+ }
+ 
+ # multiply variable n1 n2
+ # variable = n1 * n2
+ 
+ multiply () {
+   result="$1"
+   zero | $dd "bs=$2" of=$tmp "count=$3" 2>/dev/null
+   IFS="+"
+   set `$dd if=$tmp bs=1 of=/dev/null 2>&1`
+   IFS="$saveIFS"
+   eval $result='$1'
+ }
+ 
+ # divide variable n1 n2
+ # variable = int( n1 / n2 )
+ 
+ divide () {
+   result="$1"
+   zero | $dd bs=1 of=$tmp "count=$2" 2>/dev/null
+   IFS="+"
+   set `$dd if=$tmp "bs=$3" of=/dev/null 2>&1`
+   IFS="$saveIFS"
+   eval $result='$1'
+ }
+ 
+ # compare variable n1 n2 sets variable to lt if n1<n2, gt if n1>n2, eq if n1==n2
+ 
+ compare () {
+   res="$1"
+   n1="$2"
+   n2="$3"
+   subtract somename "$n1" "$n2"
+   case "$somename" in
+     0) ;;
+     *) eval $res=gt; return;
+   esac
+   subtract somename "$n2" "$n1"
+   case "$somename" in
+     0) ;;
+     *) eval $res=lt; return;
+   esac
+   eval $res=eq
+ }
+ 
+ # lt n1 n2 returns true if n1 < n2
+ 
+ lt () {
+   n1="$1"
+   n2="$2"
+   subtract somename "$n2" "$n1"
+   case "$somename" in
+     0) return 1 ;;
+   esac
+   return 0
+ }
+ 
+ # le n1 n2 returns true if n1 <= n2
+ 
+ le () {
+   n1="$1"
+   n2="$2"
+   subtract somename "$n1" "$n2"
+   case "$somename" in
+     0) return 0 ;;
+   esac
+   return 1
+ }
+ 
+ # gt n1 n2 returns true if n1 > n2
+ 
+ gt () {
+   n1="$1"
+   n2="$2"
+   subtract somename "$n1" "$n2"
+   case "$somename" in
+     0) return 1 ;;
+   esac
+   return 0
+ }
+ 
+ # ge n1 n2 returns true if n1 >= n2
+ 
+ ge () {
+   n1="$1"
+   n2="$2"
+   subtract somename "$n2" "$n1"
+   case "$somename" in
+     0) return 0 ;;
+   esac
+   return 1
+ }
+ 
+ # useful functions for the line editor
+ 
+ # open a file - copy it to the buffers
+ 
+ open () {
+   file="$1"
+   set `$dd "if=$file" of=/dev/null 2>&1`
+   case "$1" in
+     dd*) return 1
+   esac
+   # copy the first line to $ed.c
+   go=true
+   len=0
+   while $go
+   do
+     case "`$dd "if=$file" bs=1 skip=$len count=1 2>/dev/null`" in
+       ?*) go=true ;;
+       *) go=false ;;
+     esac
+     add len 1 $len
+   done
+   # now $len is the length of the first line (including newline)
+   $dd "if=$file" bs=1 count=$len of=$ed.c 2>/dev/null
+   $dd "if=$file" bs=1 skip=$len of=$ed.b 2>/dev/null
+   $dd if=/dev/null of=$ed.a 2>/dev/null
+   lineno=1
+ }
+ 
+ # save a file - copy the buffers to the file
+ 
+ save () {
+   # make a backup copy of the original
+   $dd "if=$1" "of=$1.bak" 2>/dev/null
+   # and save
+   ( $dd if=$ed.a; $dd if=$ed.c; $dd if=$ed.b ) > "$1" 2>/dev/null
+ }
+ 
+ # replace n1 n2 bla replaces n2 chars of current line, starting n1-th
+ 
+ replace () {
+   $dd if=$ed.c of=$tmp.1 bs=1 "count=$1" 2>/dev/null
+   ( $dd if=$ed.c "skip=$1" bs=1 | $dd of=$tmp.2 bs=1 "skip=$2" ) 2>/dev/null
+   shift
+   shift
+   ( $dd if=$tmp.1; Echo -n "$@"; $dd if=$tmp.2 ) > $tmp.3 2>/dev/null
+   $dd if=$tmp.3 of=$ed.c 2>/dev/null
+ }
+ 
+ # rstring n s bla
+ # replace the n-th occurence of s with bla
+ 
+ rstring () {
+   n="$1"
+   shift;
+   # first we have to find it - this is fun!
+   # we have $tmp.4 => text before string, $tmp.5 => text after
+   $dd if=/dev/null of=$tmp.4 2>/dev/null
+   $dd if=$ed.c of=$tmp.5 2>/dev/null
+   string="$1"
+   shift
+   $dd of=$tmp.6 2>/dev/null <<EOF
+ $@
+ EOF
+   while :
+   do
+     case "`$dd if=$tmp.5 2>/dev/null`" in
+       $string*)
+ 	  if lt $n 2
+ 	  then
+ 	    # now we want to replace the string
+ 	    Echo -n "$@" > $tmp.2
+ 	    Echo -n "$string" > $tmp.1
+ 	    IFS="+"
+ 	    set `$dd bs=1 if=$tmp.1 of=/dev/null 2>&1`
+ 	    IFS="$saveIFS"
+ 	    slen=$1
+ 	    IFS="+"
+ 	    ( $dd if=$tmp.4; $dd if=$tmp.2; $dd if=$tmp.5 bs=1 skip=$slen ) \
+ 		  2>/dev/null > $tmp
+ 	    $dd if=$tmp of=$ed.c 2>/dev/null
+ 	    return 0
+ 	  else
+ 	    subtract n $n 1
+ 	    ( $dd if=$tmp.4; $dd if=$tmp.5 bs=1 count=1 ) > $tmp 2>/dev/null
+ 	    $dd if=$tmp of=$tmp.4 2>/dev/null
+ 	    # and remove it from $tmp.5
+ 	    $dd if=$tmp.5 of=$tmp bs=1 skip=1 2>/dev/null
+ 	    $dd if=$tmp of=$tmp.5 2>/dev/null
+ 	  fi
+ 	  ;;
+       ?*) # add one more byte...
+ 	  ( $dd if=$tmp.4; $dd if=$tmp.5 bs=1 count=1 ) > $tmp 2>/dev/null
+ 	  $dd if=$tmp of=$tmp.4 2>/dev/null
+ 	  # and remove it from $tmp.5
+ 	  $dd if=$tmp.5 of=$tmp bs=1 skip=1 2>/dev/null
+ 	  $dd if=$tmp of=$tmp.5 2>/dev/null
+ 	  ;;
+       *)  # not found
+ 	  return 1
+ 	  ;;
+     esac
+   done
+ }
+ 
+ # skip to next line
+ next () {
+   add l $lineno 1
+   ( $dd if=$ed.a; $dd if=$ed.c ) 2>/dev/null > $tmp.3
+   $dd if=$ed.b of=$tmp.4 2>/dev/null
+   open $tmp.4
+   $dd if=$tmp.3 of=$ed.a 2>/dev/null
+   lineno=$l
+ }
+ 
+ # delete current line
+ delete () {
+   l=$lineno
+   $dd if=$ed.a 2>/dev/null > $tmp.1
+   $dd if=$ed.b of=$tmp.2 2>/dev/null
+   open $tmp.2
+   $dd if=$tmp.1 of=$ed.a 2>/dev/null
+   lineno=$l
+ }
+ 
+ # insert before current line (without changing current)
+ insert () {
+   ( $dd if=$ed.a; Echo "$@" ) 2>/dev/null > $tmp.1
+   $dd if=$tmp.1 of=$ed.a 2>/dev/null
+   add lineno $lineno 1
+ }
+ 
+ # previous line
+ prev () {
+   case "$lineno" in
+     1) ;;
+     *) subtract lineno $lineno 1
+        # read last line of $ed.a
+        IFS='+'
+        set `$dd if=$ed.a of=/dev/null bs=1 2>&1`
+        IFS="$saveIFS"
+        size=$1
+        # empty?
+        case "$size" in
+ 	 0) return ;;
+        esac
+        subtract size $size 1
+        # skip final newline
+        case "$size" in
+ 	 0) ;;
+ 	 *) subtract size1 $size 1
+ 	    case "`$dd if=$ed.a bs=1 skip=$size count=1 2>/dev/null`" in
+ 	      ?*) ;;
+ 	      *) size=$size1 ;;
+ 	    esac
+ 	    ;;
+        esac
+        go=true
+        while $go
+        do
+ 	 case "$size" in
+ 	   0) go=false ;;
+ 	   *) case "`$dd if=$ed.a bs=1 skip=$size count=1 2>/dev/null`" in
+ 	        ?*)  go=true; subtract size $size 1 ;;
+ 	        *)   go=false; add size $size 1 ;;
+ 	      esac
+ 	      ;;
+ 	 esac
+        done
+        # now $size is the size of the first n-1 lines
+        # add $ed.c to $ed.b
+        ( $dd if=$ed.c; $dd if=$ed.b ) 2>/dev/null > $tmp.5
+        $dd if=$tmp.5 of=$ed.b 2>/dev/null
+        # move line to ed.c
+        case "$size" in
+ 	 0) $dd if=$ed.a of=$ed.c 2>/dev/null
+ 	    $dd if=/dev/null of=$tmp.5 2>/dev/null
+ 	    ;;
+ 	 *) $dd if=$ed.a of=$ed.c bs=1 skip=$size 2>/dev/null
+ 	    $dd if=$ed.a of=$tmp.5 bs=1 count=$size 2>/dev/null
+ 	    ;;
+        esac
+        # move rest to ed.a
+        $dd if=$tmp.5 of=$ed.a 2>/dev/null
+     ;;
+   esac
+ }
+ 
+ # goes to a given line
+ goto () {
+   rl="$1"
+   compare bla "$rl" $lineno
+   case "$bla" in
+     eq) return
+ 	;;
+     gt) while gt "$rl" $lineno
+ 	do
+ 	  next
+ 	done
+ 	;;
+     lt) while lt "$rl" $lineno
+ 	do
+ 	  prev
+ 	done
+ 	;;
+   esac
+ }
+ 
+ lineout () {
+   Echo -n "$lineno: "
+   $dd if=$ed.c 2>/dev/null
+ }
+ 
+ state=closed
+ name=
+ autoprint=true
+ 
+ while true
+ do
+   Echo -n '> '
+   read cmd arg
+   case "$cmd:$state" in
+     open:open) Echo "There is a file open already" ;;
+     open:*) if open "$arg"
+ 	    then state=open; name="$arg"; $autoprint
+ 	    else Echo "Cannot open $arg"
+ 	    fi
+ 	    ;;
+     new:open) Echo "There is a file open already" ;;
+     new:*)  open "$arg"
+ 	    state=open
+ 	    name="$arg"
+ 	    $autoprint
+ 	    ;;
+     close:changed) Echo "Use 'discard' or 'save'" ;;
+     close:closed) Echo "Closed already" ;;
+     close:*) state=closed ;;
+     save:closed) Echo "There isn't a file to save" ;;
+     save:*) case "$arg" in
+ 	      ?*) save "$arg" ;;
+ 	      *) save "$name" ;;
+ 	    esac
+ 	    state=open
+ 	    ;;
+     discard:changed) Echo "Your problem!"; state=closed ;;
+     discard:*) state=closed ;;
+     print:closed) Echo "No current file" ;;
+     print:*) lineout ;;
+     goto:closed) Echo "No current file" ;;
+     goto:*) goto "$arg"; $autoprint ;;
+     next:closed) Echo "No current file" ;;
+     next:*) next; $autoprint ;;
+     prev:closed) Echo "No current file" ;;
+     prev:*) prev; $autoprint ;;
+     name:closed) Echo "No current file" ;;
+     name:*) name="$arg" ;;
+     replace:closed) Echo "No current file" ;;
+     replace:*) if rstring 1 $arg
+ 	       then state=changed; $autoprint
+ 	       else Echo "Not found"
+ 	       fi
+ 	       ;;
+     nreplace:closed) Echo "No current file" ;;
+     nreplace:*) if rstring $arg
+ 		then state=changed; $autoprint
+ 		else Echo "Not found"
+ 		fi
+ 		;;
+     delete:closed) Echo "No current file" ;;
+     delete:*) delete; state=changed; $autoprint ;;
+     insert:closed) Echo "No current file" ;;
+     insert:*) insert "$arg"; prev; state=changed; $autoprint ;;
+     quit:changed) Echo "Use 'save' or 'discard'" ;;
+     quit:*) Echo "bye"; exit;;
+     autoprint:*) autoprint="lineout" ;;
+     noprint:*) autoprint="" ;;
+     :*) ;;
+     *) Echo "Command not understood" ;;
+   esac
+ done
+ 
diff -Nrc2 bash-2.04/execute_cmd.c bash-2.05/execute_cmd.c
*** bash-2.04/execute_cmd.c	Tue Jan 25 11:29:11 2000
--- bash-2.05/execute_cmd.c	Thu Mar 22 10:17:23 2001
***************
*** 461,466 ****
  			      asynchronous);
        if (paren_pid == 0)
!         exit (execute_in_subshell (command, asynchronous, pipe_in, pipe_out, fds_to_close));
!         /* NOTREACHED */
        else
  	{
--- 461,466 ----
  			      asynchronous);
        if (paren_pid == 0)
! 	exit (execute_in_subshell (command, asynchronous, pipe_in, pipe_out, fds_to_close));
! 	/* NOTREACHED */
        else
  	{
***************
*** 1058,1062 ****
  
  /* Execute a command that's supposed to be in a subshell.  This must be
!    called after make_child and we must be running in the child process. */
  static int
  execute_in_subshell (command, asynchronous, pipe_in, pipe_out, fds_to_close)
--- 1058,1063 ----
  
  /* Execute a command that's supposed to be in a subshell.  This must be
!    called after make_child and we must be running in the child process.
!    The caller will return or exit() immediately with the value this returns. */
  static int
  execute_in_subshell (command, asynchronous, pipe_in, pipe_out, fds_to_close)
***************
*** 1066,1070 ****
       struct fd_bitmap *fds_to_close;
  {
!   int user_subshell, return_code, function_value, should_redir_stdin;
    COMMAND *tcom;
  
--- 1067,1072 ----
       struct fd_bitmap *fds_to_close;
  {
!   int user_subshell, return_code, function_value, should_redir_stdin, invert;
!   int ois;
    COMMAND *tcom;
  
***************
*** 1073,1077 ****
--- 1075,1081 ----
  			  stdin_redirects (command->redirects) == 0);
  
+   invert = (command->flags & CMD_INVERT_RETURN) != 0;
    user_subshell = command->type == cm_subshell || ((command->flags & CMD_WANT_SUBSHELL) != 0);
+ 
    command->flags &= ~(CMD_FORCE_SUBSHELL | CMD_WANT_SUBSHELL | CMD_INVERT_RETURN);
  
***************
*** 1099,1104 ****
        original_pgrp = -1;
  #endif /* JOB_CONTROL */
        interactive_shell = 0;
!       expand_aliases = 0;
        asynchronous = 0;
      }
--- 1103,1114 ----
        original_pgrp = -1;
  #endif /* JOB_CONTROL */
+       ois = interactive_shell;
        interactive_shell = 0;
!       /* This test is to prevent alias expansion by interactive shells that
! 	 run `(command) &' but to allow scripts that have enabled alias
! 	 expansion with `shopt -s expand_alias' to continue to expand
! 	 aliases. */
!       if (ois != interactive_shell)
! 	expand_aliases = 0;
        asynchronous = 0;
      }
***************
*** 1152,1156 ****
      {
        if (do_redirections (command->redirects, 1, 0, 0) != 0)
! 	exit (EXECUTION_FAILURE);
  
        dispose_redirects (command->redirects);
--- 1162,1166 ----
      {
        if (do_redirections (command->redirects, 1, 0, 0) != 0)
! 	exit (invert ? EXECUTION_SUCCESS : EXECUTION_FAILURE);
  
        dispose_redirects (command->redirects);
***************
*** 1163,1170 ****
       might be able to get away without forking and simply exec.
       This means things like ( sleep 10 ) will only cause one fork.
!      If we're timing the command, however, we cannot do this
!      optimization. */
    if (user_subshell && (tcom->type == cm_simple || tcom->type == cm_subshell) &&
!       (tcom->flags & CMD_TIME_PIPELINE) == 0)
      {
        tcom->flags |= CMD_NO_FORK;
--- 1173,1181 ----
       might be able to get away without forking and simply exec.
       This means things like ( sleep 10 ) will only cause one fork.
!      If we're timing the command or inverting its return value, however,
!      we cannot do this optimization. */
    if (user_subshell && (tcom->type == cm_simple || tcom->type == cm_subshell) &&
!       ((tcom->flags & CMD_TIME_PIPELINE) == 0) &&
!       ((tcom->flags & CMD_INVERT_RETURN) == 0))
      {
        tcom->flags |= CMD_NO_FORK;
***************
*** 1173,1176 ****
--- 1184,1190 ----
      }
  
+   invert = (tcom->flags & CMD_INVERT_RETURN) != 0;
+   tcom->flags &= ~CMD_INVERT_RETURN;
+ 
    /* If we're inside a function while executing this subshell, we
       need to handle a possible `return'. */
***************
*** 1185,1188 ****
--- 1199,1207 ----
        (tcom, asynchronous, NO_PIPE, NO_PIPE, fds_to_close);
  
+   /* If we are asked to, invert the return value. */
+   if (invert)
+     return_code = (return_code == EXECUTION_SUCCESS) ? EXECUTION_FAILURE
+ 						     : EXECUTION_SUCCESS;
+ 
    /* If we were explicitly placed in a subshell with (), we need
       to do the `shell cleanup' things, such as running traps[0]. */
***************
*** 1514,1520 ****
        this_command_name = (char *)NULL;
        v = bind_variable (identifier, list->word->word);
!       if (readonly_p (v))
  	{
! 	  if (interactive_shell == 0 && posixly_correct)
  	    {
  	      last_command_exit_value = EXECUTION_FAILURE;
--- 1533,1539 ----
        this_command_name = (char *)NULL;
        v = bind_variable (identifier, list->word->word);
!       if (readonly_p (v) || noassign_p (v))
  	{
! 	  if (readonly_p (v) && interactive_shell == 0 && posixly_correct)
  	    {
  	      last_command_exit_value = EXECUTION_FAILURE;
***************
*** 1635,1639 ****
        REAP ();
        if (expresult == 0)
!         break;
  
        /* Execute the body of the arithmetic for command. */
--- 1654,1658 ----
        REAP ();
        if (expresult == 0)
! 	break;
  
        /* Execute the body of the arithmetic for command. */
***************
*** 1889,1895 ****
  
        v = bind_variable (identifier, selection);
!       if (readonly_p (v))
  	{
! 	  if (interactive_shell == 0 && posixly_correct)
  	    {
  	      last_command_exit_value = EXECUTION_FAILURE;
--- 1908,1914 ----
  
        v = bind_variable (identifier, selection);
!       if (readonly_p (v) || noassign_p (v))
  	{
! 	  if (readonly_p (v) && interactive_shell == 0 && posixly_correct)
  	    {
  	      last_command_exit_value = EXECUTION_FAILURE;
***************
*** 1959,1963 ****
      }
  
!   wlist = expand_word_no_split (case_command->word, 0);
    word = wlist ? string_list (wlist) : savestring ("");
    dispose_words (wlist);
--- 1978,1982 ----
      }
  
!   wlist = expand_word_unsplit (case_command->word, 0);
    word = wlist ? string_list (wlist) : savestring ("");
    dispose_words (wlist);
***************
*** 2405,2408 ****
--- 2424,2431 ----
  	  simple_command->flags |= CMD_NO_FORK;
  
+ 	  subshell_environment = (pipe_in != NO_PIPE || pipe_out != NO_PIPE)
+ 					? (SUBSHELL_PIPE|SUBSHELL_FORK)
+ 	  				: (SUBSHELL_ASYNC|SUBSHELL_FORK);
+ 
  	  /* We need to do this before piping to handle some really
  	     pathological cases where one of the pipe file descriptors
***************
*** 2415,2419 ****
  
  	  last_asynchronous_pid = old_last_async_pid;
- 	  subshell_environment = async ? SUBSHELL_ASYNC : SUBSHELL_FORK;
  	}
        else
--- 2438,2441 ----
***************
*** 2582,2586 ****
    if (builtin || func)
      {
!        if (already_forked)
  	{
  	  /* reset_terminating_signals (); */	/* XXX */
--- 2604,2608 ----
    if (builtin || func)
      {
!       if (already_forked)
  	{
  	  /* reset_terminating_signals (); */	/* XXX */
***************
*** 2715,2726 ****
  	  dispose_used_env_vars ();
  	}
! #if 0
!       else
! 	builtin_env = (char **)NULL;
! #endif
      }
  
    result = ((*builtin) (words->next));
  
    if (subshell == 0 && (builtin == source_builtin || builtin == eval_builtin))
      {
--- 2737,2760 ----
  	  dispose_used_env_vars ();
  	}
!       /* Otherwise we inherit builtin_env from our caller. */
!     }
! 
!   /* `return' does a longjmp() back to a saved environment in execute_function.
!      If a variable assignment list preceded the command, and the shell is
!      running in POSIX mode, we need to merge that into the shell_variables
!      table, since `return' is a POSIX special builtin. */
!   if (posixly_correct && subshell == 0 && builtin == return_builtin && temporary_env)
!     {
!       begin_unwind_frame ("return_temp_env");
!       add_unwind_protect (merge_temporary_env, (char *)NULL);
      }
  
    result = ((*builtin) (words->next));
  
+   /* This shouldn't happen, but in case `return' comes back instead of
+      longjmp'ing, we need to unwind. */
+   if (posixly_correct && subshell == 0 && builtin == return_builtin && temporary_env)
+     discard_unwind_frame ("return_temp_env");
+ 
    if (subshell == 0 && (builtin == source_builtin || builtin == eval_builtin))
      {
***************
*** 2730,2739 ****
        if (posixly_correct && builtin_env)
  	merge_builtin_env ();
! #if 0
!       dispose_builtin_env ();
!       discard_unwind_frame ("builtin_env");
! #else
        run_unwind_frame ("builtin_env");
- #endif
      }
  
--- 2764,2769 ----
        if (posixly_correct && builtin_env)
  	merge_builtin_env ();
! 
        run_unwind_frame ("builtin_env");
      }
  
***************
*** 2802,2813 ****
      {
        function_env = copy_array (temporary_env);
        if (subshell == 0)
! 	add_unwind_protect (dispose_function_env, (char *)NULL);
        dispose_used_env_vars ();
      }
! #if 0
!   else
!     function_env = (char **)NULL;
! #endif
  
    remember_args (words->next, 1);
--- 2832,2848 ----
      {
        function_env = copy_array (temporary_env);
+       /* In POSIX mode, variable assignments preceding function names are
+ 	 supposed to persist in the environment after the function returns,
+ 	 as if a special builtin command had been executed. */
        if (subshell == 0)
! 	{
! 	  if (posixly_correct)
! 	    add_unwind_protect (merge_function_env, (char *)NULL);
! 	  else
! 	    add_unwind_protect (dispose_function_env, (char *)NULL);
! 	}
        dispose_used_env_vars ();
      }
!     /* Otherwise, we inherit function_env from our caller. */
  
    remember_args (words->next, 1);
***************
*** 2969,2972 ****
--- 3004,3008 ----
    int result;
    REDIRECT *saved_undo_list;
+   Function *saved_this_shell_builtin;
  
    if (do_redirections (redirects, 1, 1, 0) != 0)
***************
*** 2978,2981 ****
--- 3014,3018 ----
      }
  
+   saved_this_shell_builtin = this_shell_builtin;
    saved_undo_list = redirection_undo_list;
  
***************
*** 3003,3006 ****
--- 3040,3058 ----
      result = execute_function (var, words, flags, fds_to_close, 0, 0);
  
+   /* If we are executing the `command' builtin, but this_shell_builtin is
+      set to `exec_builtin', we know that we have something like
+      `command exec [redirection]', since otherwise `exec' would have
+      overwritten the shell and we wouldn't get here.  In this case, we
+      want to behave as if the `command' builtin had not been specified
+      and preserve the redirections. */
+   if (builtin == command_builtin && this_shell_builtin == exec_builtin)
+     {
+       if (saved_undo_list)
+ 	dispose_redirects (saved_undo_list);
+       redirection_undo_list = exec_redirection_undo_list;
+       saved_undo_list = exec_redirection_undo_list = (REDIRECT *)NULL;      
+       discard_unwind_frame ("saved_redirects");
+     }
+ 
    if (saved_undo_list)
      {
***************
*** 3187,3190 ****
--- 3239,3260 ----
     The word immediately following the #! is the interpreter to execute.
     A single argument to the interpreter is allowed. */
+ 
+ /* CPP defines to decide whether a particular index into the #! line
+    corresponds to a valid interpreter name or argument character, or
+    whitespace.  The MSDOS define is to allow \r to be treated the same
+    as \n. */
+ 
+ #if !defined (MSDOS)
+ #  define STRINGCHAR(ind) \
+     (!whitespace (sample[ind]) && sample[ind] != '\n' && ind < sample_len)
+ #  define WHITECHAR(ind) \
+     (whitespace (sample[ind]) && sample[ind] != '\n' && ind < sample_len)
+ #else	/* MSDOS */
+ #  define STRINGCHAR(ind) \
+     (!whitespace (sample[ind]) && sample[ind] != '\n' && sample[ind] != '\r' && ind < sample_len)
+ #  define WHITECHAR(ind) \
+     (whitespace (sample[ind]) && sample[ind] != '\n' && sample[ind] != '\r' && ind < sample_len)
+ #endif	/* MSDOS */
+ 
  static int
  execute_shell_script (sample, sample_len, command, args, env)
***************
*** 3202,3244 ****
      ;
  
!   for (start = i;
!        !whitespace (sample[i]) && sample[i] != '\n' && i < sample_len;
!        i++)
      ;
  
- #if 1
    execname = substring ((char *)sample, start, i);
- #else
-   larry = i - start;
-   execname = xmalloc (1 + larry);
-   strncpy (execname, (char *)(sample + start), larry);
-   execname[larry] = '\0';
- #endif
    size_increment = 1;
  
    /* Now the argument, if any. */
!   firstarg = (char *)NULL;
!   for (start = i;
!        whitespace (sample[i]) && sample[i] != '\n' && i < sample_len;
!        i++)
      ;
  
    /* If there is more text on the line, then it is an argument for the
       interpreter. */
!   if (i < sample_len && sample[i] != '\n' && !whitespace (sample[i]))
      {
!       for (start = i;
! 	   !whitespace (sample[i]) && sample[i] != '\n' && i < sample_len;
! 	   i++)
  	;
- #if 1
        firstarg = substring ((char *)sample, start, i);
- #else
-       larry = i - start;
-       firstarg = xmalloc (1 + larry);
-       strncpy (firstarg, (char *)(sample + start), larry);
-       firstarg[larry] = '\0';
- #endif
- 
        size_increment = 2;
      }
--- 3272,3293 ----
      ;
  
!   for (start = i; STRINGCHAR(i); i++)
      ;
  
    execname = substring ((char *)sample, start, i);
    size_increment = 1;
  
    /* Now the argument, if any. */
!   for (firstarg = (char *)NULL, start = i; WHITECHAR(i); i++)
      ;
  
    /* If there is more text on the line, then it is an argument for the
       interpreter. */
! 
!   if (STRINGCHAR(i))  
      {
!       for (start = i; STRINGCHAR(i); i++)
  	;
        firstarg = substring ((char *)sample, start, i);
        size_increment = 2;
      }
***************
*** 3264,3267 ****
--- 3313,3319 ----
    return (shell_execve (execname, args, env));
  }
+ #undef STRINGCHAR
+ #undef WHITECHAR
+ 
  #endif /* !HAVE_HASH_BANG_EXEC */
  
***************
*** 3291,3294 ****
--- 3343,3357 ----
    reset_shopt_options ();
  
+   /* Zero out builtin_env, since this could be a shell script run from a
+      sourced file with a temporary environment supplied to the `source/.'
+      builtin.  Such variables are not supposed to be exported (empirical
+      testing with sh and ksh). */
+   builtin_env = 0;
+ 
+   clear_unwind_protect_list (0);
+ 
+   /* We're no longer inside a shell function. */
+   variable_context = return_catch_flag = 0;
+ 
    /* If we're not interactive, close the file descriptor from which we're
       reading the current shell script. */
***************
*** 3303,3306 ****
--- 3366,3383 ----
  #endif
  
+ #define READ_SAMPLE_BUF(file, buf, len) \
+   do \
+     { \
+       fd = open(file, O_RDONLY); \
+       if (fd >= 0) \
+ 	{ \
+ 	  len = read (fd, (char *)buf, 80); \
+ 	  close (fd); \
+ 	} \
+       else \
+ 	len = -1; \
+     } \
+   while (0)
+       
  /* Call execve (), handling interpreting shell scripts, and handling
     exec failures. */
***************
*** 3312,3329 ****
    struct stat finfo;
    int larray, i, fd;
  
    SETOSTYPE (0);		/* Some systems use for USG/POSIX semantics */
    execve (command, args, env);
    SETOSTYPE (1);
  
    /* If we get to this point, then start checking out the file.
       Maybe it is something we can hack ourselves. */
!   if (errno != ENOEXEC)
      {
-       i = errno;
        if ((stat (command, &finfo) == 0) && (S_ISDIR (finfo.st_mode)))
  	internal_error ("%s: is a directory", command);
        else
  	{
  	  errno = i;
  	  file_error (command);
--- 3389,3417 ----
    struct stat finfo;
    int larray, i, fd;
+   unsigned char sample[80];
+   int sample_len;
  
    SETOSTYPE (0);		/* Some systems use for USG/POSIX semantics */
    execve (command, args, env);
+   i = errno;			/* error from execve() */
    SETOSTYPE (1);
  
    /* If we get to this point, then start checking out the file.
       Maybe it is something we can hack ourselves. */
!   if (i != ENOEXEC)
      {
        if ((stat (command, &finfo) == 0) && (S_ISDIR (finfo.st_mode)))
  	internal_error ("%s: is a directory", command);
        else
  	{
+ #if defined (HAVE_HASH_BANG_EXEC)
+ 	  READ_SAMPLE_BUF (command, sample, sample_len);
+ 	  if (sample_len > 2 && sample[0] == '#' && sample[1] == '!')
+ 	    {
+ 	      errno = i;
+ 	      sys_error ("%s: bad interpreter", command);
+ 	      return (EX_NOEXEC);
+ 	    }
+ #endif
  	  errno = i;
  	  file_error (command);
***************
*** 3335,3373 ****
       If it begins with #!, then help out people with losing operating
       systems.  Otherwise, check to see if it is a binary file by seeing
!      if the first line (or up to 80 characters) are in the ASCII set.
!      Execute the contents as shell commands. */
!   fd = open (command, O_RDONLY);
!   if (fd >= 0)
      {
-       unsigned char sample[80];
-       int sample_len;
- 
-       sample_len = read (fd, (char *)sample, 80);
-       close (fd);
- 
-       if (sample_len == 0)
- 	return (EXECUTION_SUCCESS);
- 
-       /* Is this supposed to be an executable script?
- 	 If so, the format of the line is "#! interpreter [argument]".
- 	 A single argument is allowed.  The BSD kernel restricts
- 	 the length of the entire line to 32 characters (32 bytes
- 	 being the size of the BSD exec header), but we allow 80
- 	 characters. */
-       if (sample_len > 0)
- 	{
  #if !defined (HAVE_HASH_BANG_EXEC)
! 	  if (sample[0] == '#' && sample[1] == '!')
! 	    return (execute_shell_script (sample, sample_len, command, args, env));
! 	  else
  #endif
! 	  if (check_binary_file (sample, sample_len))
! 	    {
! 	      internal_error ("%s: cannot execute binary file", command);
! 	      return (EX_BINARY_FILE);
! 	    }
  	}
      }
  
    initialize_subshell ();
  
--- 3423,3457 ----
       If it begins with #!, then help out people with losing operating
       systems.  Otherwise, check to see if it is a binary file by seeing
!      if the contents of the first line (or up to 80 characters) are in the
!      ASCII set.  If it's a text file, execute the contents as shell commands,
!      otherwise return 126 (EX_BINARY_FILE). */
!   READ_SAMPLE_BUF (command, sample, sample_len);
! 
!   if (sample_len == 0)
!     return (EXECUTION_SUCCESS);
! 
!   /* Is this supposed to be an executable script?
!      If so, the format of the line is "#! interpreter [argument]".
!      A single argument is allowed.  The BSD kernel restricts
!      the length of the entire line to 32 characters (32 bytes
!      being the size of the BSD exec header), but we allow 80
!      characters. */
!   if (sample_len > 0)
      {
  #if !defined (HAVE_HASH_BANG_EXEC)
!       if (sample_len > 2 && sample[0] == '#' && sample[1] == '!')
! 	return (execute_shell_script (sample, sample_len, command, args, env));
!       else
  #endif
!       if (check_binary_file (sample, sample_len))
! 	{
! 	  internal_error ("%s: cannot execute binary file", command);
! 	  return (EX_BINARY_FILE);
  	}
      }
  
+   /* We have committed to attempting to execute the contents of this file
+      as shell commands. */
+ 
    initialize_subshell ();
  
***************
*** 3431,3437 ****
  
    var = find_function (name->word);
!   if (var && readonly_p (var))
      {
!       internal_error ("%s: readonly function", var->name);
        return (EXECUTION_FAILURE);
      }
--- 3515,3522 ----
  
    var = find_function (name->word);
!   if (var && (readonly_p (var) || noassign_p (var)))
      {
!       if (readonly_p (var))
! 	internal_error ("%s: readonly function", var->name);
        return (EXECUTION_FAILURE);
      }
diff -Nrc2 bash-2.04/expr.c bash-2.05/expr.c
*** bash-2.04/expr.c	Tue Jan 25 17:09:07 2000
--- bash-2.05/expr.c	Wed Feb 14 16:58:32 2001
***************
*** 418,421 ****
--- 418,424 ----
  	      lvalue |= value;
  	      break;
+ 	    case BXOR:
+ 	      lvalue ^= value;
+ 	      break;
  	    default:
  	      free (lhs);
***************
*** 462,468 ****
  #endif
        if (set_noeval)
!         noeval--;
        if (curtok != COL)
!         evalerror ("`:' expected for conditional expression");
        readtok ();
        if (curtok == 0)
--- 465,471 ----
  #endif
        if (set_noeval)
! 	noeval--;
        if (curtok != COL)
! 	evalerror ("`:' expected for conditional expression");
        readtok ();
        if (curtok == 0)
***************
*** 476,480 ****
        val2 = explor ();
        if (set_noeval)
!         noeval--;
        rval = cval ? val1 : val2;
        lasttok = COND;
--- 479,483 ----
        val2 = explor ();
        if (set_noeval)
! 	noeval--;
        rval = cval ? val1 : val2;
        lasttok = COND;
***************
*** 696,701 ****
  
    while ((curtok == MUL) ||
!          (curtok == DIV) ||
!          (curtok == MOD))
      {
        int op = curtok;
--- 699,704 ----
  
    while ((curtok == MUL) ||
! 	 (curtok == DIV) ||
! 	 (curtok == MOD))
      {
        int op = curtok;
***************
*** 709,717 ****
  
        if (op == MUL)
!         val1 *= val2;
        else if (op == DIV)
!         val1 /= val2;
        else if (op == MOD)
!         val1 %= val2;
      }
    return (val1);
--- 712,720 ----
  
        if (op == MUL)
! 	val1 *= val2;
        else if (op == DIV)
! 	val1 /= val2;
        else if (op == MOD)
! 	val1 %= val2;
      }
    return (val1);
***************
*** 774,778 ****
        readtok ();
        if (curtok != STR)
!         /* readtok() catches this */
  	evalerror ("identifier expected after pre-increment or pre-decrement");
  
--- 777,781 ----
        readtok ();
        if (curtok != STR)
! 	/* readtok() catches this */
  	evalerror ("identifier expected after pre-increment or pre-decrement");
  
***************
*** 907,911 ****
  	 preserve old behavior if a construct like --x=9 is given. */
        if (lasttok == PREINC || lasttok == PREDEC || peektok != EQ)
!         {
  #if defined (ARRAY_VARS)
  	  value = (e == ']') ? get_array_value (tokstr, 0) : get_string_value (tokstr);
--- 910,914 ----
  	 preserve old behavior if a construct like --x=9 is given. */
        if (lasttok == PREINC || lasttok == PREDEC || peektok != EQ)
! 	{
  #if defined (ARRAY_VARS)
  	  value = (e == ']') ? get_array_value (tokstr, 0) : get_string_value (tokstr);
***************
*** 920,926 ****
  	    FREE (value);	/* get_array_value returns newly-allocated memory */
  #endif
!         }
        else
!         tokval = 0;
  
        lasttok = curtok;
--- 923,929 ----
  	    FREE (value);	/* get_array_value returns newly-allocated memory */
  #endif
! 	}
        else
! 	tokval = 0;
  
        lasttok = curtok;
***************
*** 978,987 ****
  	c = LOR;
        else if ((c == '*') && (c1 == '*'))
!         c = POWER;
        else if ((c == '-') && (c1 == '-') && legal_variable_starter (*cp))
!         c = PREDEC;
        else if ((c == '+') && (c1 == '+') && legal_variable_starter (*cp))
!         c = PREINC;
!       else if (c1 == EQ && member(c, "*/%+-&^|"))
  	{
  	  assigntok = c;	/* a OP= b */
--- 981,990 ----
  	c = LOR;
        else if ((c == '*') && (c1 == '*'))
! 	c = POWER;
        else if ((c == '-') && (c1 == '-') && legal_variable_starter (*cp))
! 	c = PREDEC;
        else if ((c == '+') && (c1 == '+') && legal_variable_starter (*cp))
! 	c = PREINC;
!       else if (c1 == EQ && member (c, "*/%+-&^|"))
  	{
  	  assigntok = c;	/* a OP= b */
***************
*** 1134,1140 ****
        v = evalexp (argv[i], &expok);
        if (expok == 0)
!         fprintf (stderr, "%s: expression error\n", argv[i]);
        else
!         printf ("'%s' -> %ld\n", argv[i], v);
      }
    exit (0);
--- 1137,1143 ----
        v = evalexp (argv[i], &expok);
        if (expok == 0)
! 	fprintf (stderr, "%s: expression error\n", argv[i]);
        else
! 	printf ("'%s' -> %ld\n", argv[i], v);
      }
    exit (0);
diff -Nrc2 bash-2.04/externs.h bash-2.05/externs.h
*** bash-2.04/externs.h	Fri Jan  7 16:17:45 2000
--- bash-2.05/externs.h	Fri Nov  3 11:25:31 2000
***************
*** 96,108 ****
  
  /* Declarations for functions defined in stringlib.c */
- extern char *ansicstr __P((char *, int, int, int *, int *));
- extern int find_name_in_array __P((char *, char **));
- extern char **alloc_array __P((int));
- extern int array_len __P((char **));
- extern void free_array_members __P((char **));
- extern void free_array __P((char **));
- extern char **copy_array __P((char **));
- extern int qsort_string_compare ();
- extern void sort_char_array __P((char **));
  extern char **word_list_to_argv __P((WORD_LIST *, int, int, int *));
  extern WORD_LIST *argv_to_word_list __P((char **, int, int));
--- 96,99 ----
***************
*** 114,122 ****
  extern void strip_leading __P((char *));
  extern void strip_trailing __P((char *, int, int));
- extern char *strindex __P((char *, char *));
  extern void xbcopy __P((char *, char *, int));
  
  /* Functions from the bash library, lib/sh/libsh.a.  These should really
     go into a separate include file. */
  /* Declarations for functions defined in lib/sh/getcwd.c */
  #if !defined (HAVE_GETCWD)
--- 105,120 ----
  extern void strip_leading __P((char *));
  extern void strip_trailing __P((char *, int, int));
  extern void xbcopy __P((char *, char *, int));
  
  /* Functions from the bash library, lib/sh/libsh.a.  These should really
     go into a separate include file. */
+ 
+ /* declarations for functions defined in lib/sh/clktck.c */
+ extern long get_clk_tck __P((void));
+ 
+ /* declarations for functions defined in lib/sh/clock.c */
+ extern void clock_t_to_secs ();
+ extern void print_clock_t ();
+ 
  /* Declarations for functions defined in lib/sh/getcwd.c */
  #if !defined (HAVE_GETCWD)
***************
*** 128,157 ****
  extern char *itos __P((int));
  
! /* Declarations for  functions defined in lib/sh/oslib.c */
! extern long get_clk_tck __P((void));
  
! #if !defined (strerror)
! extern char *strerror __P((int));
! #endif
  
! #if !defined (HAVE_STRCASECMP)
! extern int strncasecmp __P((const char *, const char *, int));
! extern int strcasecmp __P((const char *, const char *));
! #endif /* HAVE_STRCASECMP */
  
  extern int dup2 __P((int, int));
  
  #if !defined (HAVE_GETHOSTNAME)
  extern int gethostname __P((char *, int));
  #endif /* !HAVE_GETHOSTNAME */
  
! #if !defined (HAVE_GETDTABLESIZE)
! extern int getdtablesize __P((void));
! #endif /* !HAVE_GETDTABLESIZE */
  
  #if !defined (HAVE_SETLINEBUF)
  extern int setlinebuf ();
  #endif
  
  /* declarations for functions defined in lib/sh/strtod.c */
  #if !defined (HAVE_STRTOD)
--- 126,223 ----
  extern char *itos __P((int));
  
! /* declarations for functions defined in lib/sh/makepath.c */
! #define MP_DOTILDE	0x01
! #define MP_DOCWD	0x02
! #define MP_RMDOT	0x04
  
! extern char *sh_makepath __P((char *, char *, int));
  
! /* declarations for functions defined in lib/sh/netopen.c */
! extern int netopen __P((char *));
! 
! /* Declarations for  functions defined in lib/sh/oslib.c */
  
  extern int dup2 __P((int, int));
  
+ #if !defined (HAVE_GETDTABLESIZE)
+ extern int getdtablesize __P((void));
+ #endif /* !HAVE_GETDTABLESIZE */
+ 
  #if !defined (HAVE_GETHOSTNAME)
  extern int gethostname __P((char *, int));
  #endif /* !HAVE_GETHOSTNAME */
  
! /* declarations for functions defined in lib/sh/pathcanon.c */
! #define PATH_CHECKDOTDOT	0x0001
! #define PATH_CHECKEXISTS	0x0002
! #define PATH_HARDPATH		0x0004
! #define PATH_NOALLOC		0x0008
! 
! extern char *sh_canonpath __P((char *, int));
! 
! /* declarations for functions defined in lib/sh/pathphys.c */
! extern char *sh_physpath __P((char *, int));
! extern char *sh_realpath __P((const char *, char *));
  
+ /* declarations for functions defined in lib/sh/setlinebuf.c */
  #if !defined (HAVE_SETLINEBUF)
  extern int setlinebuf ();
  #endif
  
+ /* declarations for functions defined in lib/sh/shquote.c */
+ extern char *sh_single_quote __P((char *));
+ extern char *sh_double_quote __P((char *));
+ extern char *sh_un_double_quote __P((char *));
+ extern char *sh_backslash_quote __P((char *));
+ extern char *sh_backslash_quote_for_double_quotes __P((char *));
+ extern int sh_contains_shell_metas __P((char *));
+ 
+ /* declarations for functions defined in lib/sh/spell.c */
+ extern int spname __P((char *, char *));
+ 
+ /* declarations for functions defined in lib/sh/strcasecmp.c */
+ #if !defined (HAVE_STRCASECMP)
+ extern int strncasecmp __P((const char *, const char *, int));
+ extern int strcasecmp __P((const char *, const char *));
+ #endif /* HAVE_STRCASECMP */
+ 
+ /* declarations for functions defined in lib/sh/strerror.c */
+ #if !defined (strerror)
+ extern char *strerror __P((int));
+ #endif
+ 
+ /* declarations for functions defined in lib/sh/strindex.c */
+ extern char *strindex __P((const char *, const char *));
+ 
+ /* declarations for functions and structures defined in lib/sh/stringlist.c */
+ 
+ /* This is a general-purpose argv-style array struct. */
+ typedef struct _list_of_strings {
+   char **list;
+   int list_size;
+   int list_len;
+ } STRINGLIST;
+ 
+ extern STRINGLIST *alloc_stringlist __P((int));
+ extern STRINGLIST *realloc_stringlist __P((STRINGLIST *, int));
+ extern void free_stringlist __P((STRINGLIST *));
+ extern STRINGLIST *copy_stringlist __P((STRINGLIST *));
+ extern STRINGLIST *merge_stringlists __P((STRINGLIST *, STRINGLIST *));
+ extern STRINGLIST *append_stringlist __P((STRINGLIST *, STRINGLIST *));
+ extern STRINGLIST *prefix_suffix_stringlist __P((STRINGLIST *, char *, char *));
+ extern void print_stringlist __P((STRINGLIST *, char *));
+ extern void sort_stringlist __P((STRINGLIST *));
+ 
+ /* declarations for functions defined in lib/sh/stringvec.c */
+ 
+ extern int find_name_in_array __P((char *, char **));
+ extern char **alloc_array __P((int));
+ extern int array_len __P((char **));
+ extern void free_array_members __P((char **));
+ extern void free_array __P((char **));
+ extern char **copy_array __P((char **));
+ extern int qsort_string_compare ();
+ extern void sort_char_array __P((char **));
+ 
  /* declarations for functions defined in lib/sh/strtod.c */
  #if !defined (HAVE_STRTOD)
***************
*** 169,184 ****
  #endif
  
! /* declarations for functions defined in lib/sh/zread.c */
! extern int zread __P((int, char *, size_t));
! extern int zread1 __P((int, char *, size_t));
! extern int zreadc __P((int, char *));
! extern void zreset __P((void));
! extern void zsyncfd __P((int));
! 
! /* declarations for functions defined in lib/sh/zwrite.c */
! extern int zwrite __P((int, unsigned char *, size_t));
! 
! /* declarations for functions defined in lib/sh/netopen.c */
! extern int netopen __P((char *));
  
  /* declarations for functions defined in lib/sh/timeval.c.  No prototypes
--- 235,241 ----
  #endif
  
! /* declarations for functions defined in lib/sh/strtrans.c */
! extern char *ansicstr __P((char *, int, int, int *, int *));
! extern char *ansic_quote __P((char *, int, int *));
  
  /* declarations for functions defined in lib/sh/timeval.c.  No prototypes
***************
*** 188,201 ****
  extern void print_timeval ();
  
! /* declarations for functions defined in lib/sh/clock.c */
! extern void clock_t_to_secs ();
! extern void print_clock_t ();
  
! /* declarations for functions defined in lib/sh/makepath.c */
! #define MP_DOTILDE	0x01
! #define MP_DOCWD	0x02
! #define MP_RMDOT	0x04
  
! extern char *sh_makepath __P((char *, char *, int));
  
  #endif /* _EXTERNS_H_ */
--- 245,266 ----
  extern void print_timeval ();
  
! /* declarations for functions defined in lib/sh/tmpfile.c */
! #define MT_USETMPDIR		0x0001
! #define MT_READWRITE		0x0002
! #define MT_USERANDOM		0x0004
! 
! extern char *sh_mktmpname __P((char *, int));
! extern int sh_mktmpfd __P((char *, int, char **));
! /* extern FILE *sh_mktmpfp __P((char *, int, char **)); */
  
! /* declarations for functions defined in lib/sh/zread.c */
! extern int zread __P((int, char *, size_t));
! extern int zread1 __P((int, char *, size_t));
! extern int zreadc __P((int, char *));
! extern void zreset __P((void));
! extern void zsyncfd __P((int));
  
! /* declarations for functions defined in lib/sh/zwrite.c */
! extern int zwrite __P((int, unsigned char *, size_t));
  
  #endif /* _EXTERNS_H_ */
diff -Nrc2 bash-2.04/findcmd.c bash-2.05/findcmd.c
*** bash-2.04/findcmd.c	Mon Nov 29 12:33:31 1999
--- bash-2.05/findcmd.c	Tue Feb 20 15:19:10 2001
***************
*** 161,164 ****
--- 161,174 ----
  }
  
+ int
+ executable_or_directory (file)
+      char *file;
+ {
+   int s;
+ 
+   s = file_status (file);
+   return ((s & FS_EXECABLE) || (s & FS_DIRECTORY));
+ }
+ 
  /* Locate the executable file referenced by NAME, searching along
     the contents of the shell PATH variable.  Return a new string
***************
*** 306,315 ****
  	 it, so don't bother trying again. */
        if (temp_path)
!         {
  	  command = find_user_command_in_path (pathname, value_cell (path),
  					       FS_EXEC_PREFERRED|FS_NODIRS);
  	  if (tempvar_p (path))
  	    dispose_variable (path);
!         }
        else
  	command = find_user_command (pathname);
--- 316,325 ----
  	 it, so don't bother trying again. */
        if (temp_path)
! 	{
  	  command = find_user_command_in_path (pathname, value_cell (path),
  					       FS_EXEC_PREFERRED|FS_NODIRS);
  	  if (tempvar_p (path))
  	    dispose_variable (path);
! 	}
        else
  	command = find_user_command (pathname);
***************
*** 558,562 ****
       the contents of FILE_TO_LOSE_ON which is NULL when the search
       required an executable, or non-NULL if a file was found and the
!      search would accept a non-executable as a last resort. */
    return (file_to_lose_on);
  }
--- 568,580 ----
       the contents of FILE_TO_LOSE_ON which is NULL when the search
       required an executable, or non-NULL if a file was found and the
!      search would accept a non-executable as a last resort.  If the
!      caller specified FS_NODIRS, and file_to_lose_on is a directory,
!      return NULL. */
!   if (file_to_lose_on && (flags & FS_NODIRS) && is_directory (file_to_lose_on))
!     {
!       free (file_to_lose_on);
!       file_to_lose_on = (char *)NULL;
!     }
! 
    return (file_to_lose_on);
  }
diff -Nrc2 bash-2.04/findcmd.h bash-2.05/findcmd.h
*** bash-2.04/findcmd.h	Thu Aug  5 07:06:01 1999
--- bash-2.05/findcmd.h	Tue Feb 20 15:14:09 2001
***************
*** 27,30 ****
--- 27,31 ----
  extern int executable_file __P((char *));
  extern int is_directory __P((char *));
+ extern int executable_or_directory __P((char *));
  extern char *find_user_command __P((char *));
  extern char *find_path_file __P((char *));
diff -Nrc2 bash-2.04/flags.c bash-2.05/flags.c
*** bash-2.04/flags.c	Thu Aug  5 07:20:28 1999
--- bash-2.05/flags.c	Wed Feb 14 16:58:48 2001
***************
*** 250,254 ****
      case 'r':
        if (on_or_off == FLAG_ON)
!         maybe_make_restricted (shell_name);
        break;
  #endif
--- 250,254 ----
      case 'r':
        if (on_or_off == FLAG_ON)
! 	maybe_make_restricted (shell_name);
        break;
  #endif
diff -Nrc2 bash-2.04/general.c bash-2.05/general.c
*** bash-2.04/general.c	Mon Nov 29 14:20:29 1999
--- bash-2.05/general.c	Wed Feb 28 13:23:24 2001
***************
*** 51,56 ****
--- 51,60 ----
  #endif
  
+ extern int interactive_shell, expand_aliases;
  extern int interrupt_immediately;
  extern int interactive_comments;
+ extern int check_hashed_filenames;
+ extern int source_uses_path;
+ extern int source_searches_cwd;
  
  /* A standard error message to use when getcwd() returns NULL. */
***************
*** 62,66 ****
       int on;
  {
!   interactive_comments = on != 0;
  }
  
--- 66,81 ----
       int on;
  {
!   /* Things that should be turned on when posix mode is enabled. */
!   if (on != 0)
!     {
!       interactive_comments = source_uses_path = expand_aliases = 1;
!     }
! 
!   /* Things that should be turned on when posix mode is disabled. */
!   if (on == 0)
!     {
!       source_searches_cwd = 1;
!       expand_aliases = interactive_shell;
!     }
  }
  
***************
*** 132,142 ****
       char *string;
  {
!   while (*string)
!     {
!       if (!digit (*string))
! 	return (0);
!       else
! 	string++;
!     }
    return (1);
  }
--- 147,156 ----
       char *string;
  {
!   register char *s;
! 
!   for (s = string; *s; s++)
!     if (isdigit (*s) == 0)
!       return (0);
! 
    return (1);
  }
***************
*** 158,161 ****
--- 172,179 ----
    value = strtol (string, &ep, 10);
  
+   /* Skip any trailing whitespace, since strtol does not. */
+   while (whitespace (*ep))
+     ep++;
+ 
    /* If *string is not '\0' but *ep is '\0' on return, the entire string
       is valid. */
***************
*** 188,192 ****
      {
        if (legal_variable_char (*s) == 0)
!         return (0);
      }
    return (1);
--- 206,210 ----
      {
        if (legal_variable_char (*s) == 0)
! 	return (0);
      }
    return (1);
***************
*** 235,239 ****
  /* Make sure no-delay mode is not set on file descriptor FD. */
  int
! unset_nodelay_mode (fd)
       int fd;
  {
--- 253,257 ----
  /* Make sure no-delay mode is not set on file descriptor FD. */
  int
! sh_unset_nodelay_mode (fd)
       int fd;
  {
***************
*** 395,567 ****
  /* **************************************************************** */
  
- /* Return 1 if PATH corresponds to a directory. */
- static int
- canon_stat (path)
-      char *path;
- {
-   int l;
-   char *s;
-   struct stat sb;
- 
-   l = strlen (path);
-   s = xmalloc (l + 3);
-   strcpy (s, path);
-   s[l] = '/';
-   s[l+1] = '.';
-   s[l+2] = '\0';
-   l = stat (s, &sb) == 0 && S_ISDIR (sb.st_mode);
-   free (s);
-   return l;
- }
- 
- /* Canonicalize PATH, and return a new path.  The new path differs from PATH
-    in that:
- 	Multple `/'s are collapsed to a single `/'.
- 	Leading `./'s and trailing `/.'s are removed.
- 	Trailing `/'s are removed.
- 	Non-leading `../'s and trailing `..'s are handled by removing
- 	portions of the path. */
- char *
- canonicalize_pathname (path)
-      char *path;
- {
-   register int i, start;
-   char stub_char;
-   char *result;
- 
-   /* The result cannot be larger than the input PATH. */
-   result = savestring (path);
- 
-   stub_char = (*path == '/') ? '/' : '.';
- 
-   /* Walk along RESULT looking for things to compact. */
-   i = 0;
-   while (1)
-     {
-       if (!result[i])
- 	break;
- 
-       while (result[i] && result[i] != '/')
- 	i++;
- 
-       start = i++;
- 
-       /* If we didn't find any slashes, then there is nothing left to do. */
-       if (!result[start])
- 	break;
- 
-       /* Handle multiple `/'s in a row. */
-       while (result[i] == '/')
- 	i++;
- 
- #if 0
-       if ((start + 1) != i)
- #else
-       /* Leave a leading `//' alone, as POSIX requires. */
-       if ((start + 1) != i && (start != 0 || i != 2))
- #endif
- 	{
- 	  strcpy (result + start + 1, result + i);
- 	  i = start + 1;
- 	  /* Make sure that what we have so far corresponds to a directory.
- 	     If it does not, just punt. */
- 	  if (*result)
- 	    {
- 	      char c;
- 	      c = result[start];
- 	      result[start] = '\0';
- 	      if (canon_stat (result) == 0)
- 		{
- 		  free (result);
- 		  return ((char *)NULL);
- 		}
- 	      result[start] = c;
- 	    }
- 	}
- #if 0
-       /* Handle backslash-quoted `/'. */
-       if (start > 0 && result[start - 1] == '\\')
- 	continue;
- #endif
- 
-       /* Check for trailing `/'. */
-       if (start && !result[i])
- 	{
- 	zero_last:
- 	  result[--i] = '\0';
- 	  break;
- 	}
- 
-       /* Check for `../', `./' or trailing `.' by itself. */
-       if (result[i] == '.')
- 	{
- 	  /* Handle trailing `.' by itself. */
- 	  if (!result[i + 1])
- 	    goto zero_last;
- 
- 	  /* Handle `./'. */
- 	  if (result[i + 1] == '/')
- 	    {
- 	      strcpy (result + i, result + i + 1);
- 	      i = (start < 0) ? 0 : start;
- 	      continue;
- 	    }
- 
- 	  /* Handle `../' or trailing `..' by itself. */
- 	  if (result[i + 1] == '.' &&
- 	      (result[i + 2] == '/' || !result[i + 2]))
- 	    {
- 	      /* Make sure that the last component corresponds to a directory
- 		 before blindly chopping it off. */
- 	      if (i)
- 		{
- 		  result[i] = '\0';
- 		  if (canon_stat (result) == 0)
- 		    {
- 		      free (result);
- 		      return ((char *)NULL);
- 		    }
- 		  result[i] = '.';
- 		}
- 	      while (--start > -1 && result[start] != '/');
- 	      strcpy (result + start + 1, result + i + 2);
- #if 0	/* Unnecessary */
- 	      if (*result && canon_stat (result) == 0)
- 		{
- 		  free (result);
- 		  return ((char *)NULL);
- 		}
- #endif
- 	      i = (start < 0) ? 0 : start;
- 	      continue;
- 	    }
- 	}
-     }
- 
-   if (!*result)
-     {
-       *result = stub_char;
-       result[1] = '\0';
-     }
- 
-   /* If the result starts with `//', but the original path does not, we
-      can turn the // into /. */
-   if ((result[0] == '/' && result[1] == '/' && result[2] != '/') &&
-       (path[0] != '/' || path[1] != '/' || path[2] == '/'))
-     {
-       char *r2;
-       if (result[2] == '\0')	/* short-circuit for bare `//' */
- 	result[1] = '\0';
-       else
- 	{
- 	  r2 = savestring (result + 1);
- 	  free (result);
- 	  result = r2;
- 	}
-     }
- 
-   return (result);
- }
- 
  /* Turn STRING (a pathname) into an absolute pathname, assuming that
     DOT_PATH contains the symbolic location of `.'.  This always
--- 413,416 ----
***************
*** 574,578 ****
    char *result;
  
!   if (dot_path == 0 || *string == '/')
      result = savestring (string);
    else
--- 423,427 ----
    char *result;
  
!   if (dot_path == 0 || ABSPATH(string))
      result = savestring (string);
    else
***************
*** 582,602 ****
  }
  
! /* Return 1 if STRING contains an absolute pathname, else 0. */
  int
  absolute_pathname (string)
       char *string;
  {
!   if (!string || !*string)
      return (0);
  
!   if (*string == '/')
      return (1);
  
-   if (*string++ == '.')
-     {
-       if (!*string || *string == '/' ||
- 	   (*string == '.' && (string[1] == '\0' || string[1] == '/')))
- 	return (1);
-     }
    return (0);
  }
--- 431,452 ----
  }
  
! /* Return 1 if STRING contains an absolute pathname, else 0.  Used by `cd'
!    to decide whether or not to look up a directory name in $CDPATH. */
  int
  absolute_pathname (string)
       char *string;
  {
!   if (string == 0 || *string == '\0')
      return (0);
  
!   if (ABSPATH(string))
!     return (1);
! 
!   if (string[0] == '.' && PATHSEP(string[1]))	/* . and ./ */
!     return (1);
! 
!   if (string[0] == '.' && string[1] == '.' && PATHSEP(string[2]))	/* .. and ../ */
      return (1);
  
    return (0);
  }
***************
*** 620,624 ****
    char *p;
  
!   if (!absolute_pathname (string))
      return (string);
  
--- 470,474 ----
    char *p;
  
!   if (absolute_pathname (string) == 0)
      return (string);
  
***************
*** 639,643 ****
    file = (*file == '~') ? bash_tilde_expand (file) : savestring (file);
  
!   if ((*file == '/') && absolute_pathname (file))
      return (file);
  
--- 489,493 ----
    file = (*file == '~') ? bash_tilde_expand (file) : savestring (file);
  
!   if (ABSPATH(file))
      return (file);
  
***************
*** 858,862 ****
      {
        for (i = ngroups; i > 0; i--)
!         group_array[i] = group_array[i - 1];
        group_array[0] = current_user.gid;
        ngroups++;
--- 708,712 ----
      {
        for (i = ngroups; i > 0; i--)
! 	group_array[i] = group_array[i - 1];
        group_array[0] = current_user.gid;
        ngroups++;
***************
*** 869,874 ****
      {
        for (i = 0; i < ngroups; i++)
!         if (group_array[i] == current_user.gid)
!           break;
        if (i < ngroups)
  	{
--- 719,724 ----
      {
        for (i = 0; i < ngroups; i++)
! 	if (group_array[i] == current_user.gid)
! 	  break;
        if (i < ngroups)
  	{
diff -Nrc2 bash-2.04/general.h bash-2.05/general.h
*** bash-2.04/general.h	Mon Aug 16 12:22:29 1999
--- bash-2.05/general.h	Wed Feb 14 16:53:05 2001
***************
*** 80,88 ****
  
  #ifndef digit
! #define digit(c)  ((c) >= '0' && (c) <= '9')
  #endif
  
  #ifndef isletter
! #define isletter(c) (((c) >= 'A' && (c) <= 'Z') || ((c) >= 'a' && (c) <= 'z'))
  #endif
  
--- 80,88 ----
  
  #ifndef digit
! #define digit(c)  (isdigit(c))
  #endif
  
  #ifndef isletter
! #define isletter(c) (isalpha(c))
  #endif
  
***************
*** 91,94 ****
--- 91,98 ----
  #endif
  
+ #ifndef ISOCTAL
+ #define ISOCTAL(c)  ((c) >= '0' && (c) <= '7')
+ #endif
+ 
  /* Define exactly what a legal shell identifier consists of. */
  #define legal_variable_starter(c) (isletter(c) || (c == '_'))
***************
*** 116,120 ****
  #define REVERSE_LIST(list, type) \
    ((list && list->next) ? (type)reverse_list ((GENERIC_LIST *)list) \
!   			: (type)(list))
  
  #if __GNUC__ > 1
--- 120,124 ----
  #define REVERSE_LIST(list, type) \
    ((list && list->next) ? (type)reverse_list ((GENERIC_LIST *)list) \
! 			: (type)(list))
  
  #if __GNUC__ > 1
***************
*** 179,182 ****
--- 183,203 ----
  #define FS_NODIRS	  0x20
  
+ /* Some useful definitions for Unix pathnames.  Argument convention:
+    x == string, c == character */
+ 
+ #if !defined (__CYGWIN__)
+ #  define ABSPATH(x)	((x)[0] == '/')
+ #  define RELPATH(x)	((x)[0] != '/')
+ #else /* __CYGWIN__ */
+ #  define ABSPATH(x)	(((x)[0] && isalpha((x)[0]) && (x)[1] == ':' && (x)[2] == '/') || (x)[0] == '/')
+ #  define RELPATH(x)	(!(x)[0] || ((x)[1] != ':' && (x)[0] != '/'))
+ #endif /* __CYGWIN__ */
+ 
+ #define ROOTEDPATH(x)	(ABSPATH(x))
+ 
+ #define DIRSEP	'/'
+ #define ISDIRSEP(c)	((c) == '/')
+ #define PATHSEP(c)	(ISDIRSEP(c) || (c) == 0)
+ 
  /* Declarations for functions defined in xmalloc.c */
  extern char *xmalloc __P((size_t));
***************
*** 197,201 ****
  extern int check_identifier __P((WORD_DESC *, int));
  
! extern int unset_nodelay_mode __P((int));
  extern void check_dev_tty __P((void));
  extern int same_file ();	/* too many problems with prototype */
--- 218,222 ----
  extern int check_identifier __P((WORD_DESC *, int));
  
! extern int sh_unset_nodelay_mode __P((int));
  extern void check_dev_tty __P((void));
  extern int same_file ();	/* too many problems with prototype */
***************
*** 203,207 ****
  extern int check_binary_file __P((unsigned char *, int));
  
- extern char *canonicalize_pathname __P((char *));
  extern char *make_absolute __P((char *, char *));
  extern int absolute_pathname __P((char *));
--- 224,227 ----
diff -Nrc2 bash-2.04/hashlib.c bash-2.05/hashlib.c
*** bash-2.04/hashlib.c	Thu Aug  5 07:20:48 1999
--- bash-2.05/hashlib.c	Wed Feb 14 16:58:55 2001
***************
*** 271,275 ****
        fprintf (stderr, "\tslot %3d: ", slot);
        for (bcount = 0; bc; bc = bc->next)
!         bcount++;
  
        fprintf (stderr, "%d\n", bcount);
--- 271,275 ----
        fprintf (stderr, "\tslot %3d: ", slot);
        for (bcount = 0; bc; bc = bc->next)
! 	bcount++;
  
        fprintf (stderr, "%d\n", bcount);
***************
*** 311,317 ****
        char *temp_string;
        if (fgets (string, sizeof (string), stdin) == 0)
!         break;
        if (!*string)
!         break;
        temp_string = savestring (string);
        tt = add_hash_item (temp_string, table);
--- 311,317 ----
        char *temp_string;
        if (fgets (string, sizeof (string), stdin) == 0)
! 	break;
        if (!*string)
! 	break;
        temp_string = savestring (string);
        tt = add_hash_item (temp_string, table);
diff -Nrc2 bash-2.04/include/ansi_stdlib.h bash-2.05/include/ansi_stdlib.h
*** bash-2.04/include/ansi_stdlib.h	Thu Aug  5 07:49:32 1999
--- bash-2.05/include/ansi_stdlib.h	Thu Sep  7 12:07:49 2000
***************
*** 28,31 ****
--- 28,34 ----
  extern long int atol ();
  
+ extern double atof ();
+ extern double strtod ();
+ 
  /* Memory allocation functions. */
  extern char *malloc ();
diff -Nrc2 bash-2.04/include/shtty.h bash-2.05/include/shtty.h
*** bash-2.04/include/shtty.h	Thu Aug  5 07:50:57 1999
--- bash-2.05/include/shtty.h	Thu Mar 23 14:33:24 2000
***************
*** 1,3 ****
! /* Copyright (C) 1999 Free Software Foundation, Inc.
  
  /* This file is part of GNU Bash, the Bourne Again SHell.
--- 1,3 ----
! /* Copyright (C) 1999 Free Software Foundation, Inc. */
  
  /* This file is part of GNU Bash, the Bourne Again SHell.
diff -Nrc2 bash-2.04/input.c bash-2.05/input.c
*** bash-2.04/input.c	Tue Feb 22 13:04:00 2000
--- bash-2.05/input.c	Tue Feb 13 15:39:59 2001
***************
*** 101,104 ****
--- 101,113 ----
  #endif /* !SEEK_CUR */
  
+ #ifdef max
+ #  undef max
+ #endif
+ #define max(a, b)	(((a) > (b)) ? (a) : (b))
+ #ifdef min
+ #  undef min
+ #endif
+ #define min(a, b)	((a) > (b) ? (b) : (a))
+ 
  extern int return_EOF ();
  
***************
*** 115,120 ****
  static int nbuffers;
  
- #define max(a, b)  (((a) > (b)) ? (a) : (b))
- 
  #define ALLOCATE_BUFFERS(n) \
  	do { if ((n) >= nbuffers) allocate_buffers (n); } while (0)
--- 124,127 ----
***************
*** 174,177 ****
--- 181,263 ----
  }
  
+ int
+ set_bash_input_fd (fd)
+      int fd;
+ {
+   if (bash_input.type == st_bstream)
+     bash_input.location.buffered_fd = fd;
+   else if (interactive_shell == 0)
+     default_buffered_input = fd;
+   return 0;
+ }
+ 
+ int
+ fd_is_bash_input (fd)
+      int fd;
+ {
+   if (bash_input.type == st_bstream && bash_input.location.buffered_fd == fd)
+     return 1;
+   else if (interactive_shell == 0 && default_buffered_input == fd)
+     return 1;
+   return 0;
+ }
+ 
+ /* Save the buffered stream corresponding to file descriptor FD (which bash
+    is using to read input) to a buffered stream associated with NEW_FD.  If
+    NEW_FD is -1, a new file descriptor is allocated with fcntl.  The new
+    file descriptor is returned on success, -1 on error. */
+ int
+ save_bash_input (fd, new_fd)
+      int fd, new_fd;
+ {
+   int nfd;
+ 
+   /* Sync the stream so we can re-read from the new file descriptor.  We
+      might be able to avoid this by copying the buffered stream verbatim
+      to the new file descriptor. */
+   if (buffers[fd])
+     sync_buffered_stream (fd);
+ 
+   /* Now take care of duplicating the file descriptor that bash is
+      using for input, so we can reinitialize it later. */
+   nfd = (new_fd == -1) ? fcntl (fd, F_DUPFD, 10) : new_fd;
+   if (nfd == -1)
+     {
+       if (fcntl (fd, F_GETFD, 0) == 0)
+ 	sys_error ("cannot allocate new file descriptor for bash input from fd %d", fd);
+       return -1;
+     }
+ 
+   if (buffers[nfd])
+     {
+       /* What's this?  A stray buffer without an associated open file
+ 	 descriptor?  Free up the buffer and report the error. */
+       internal_error ("check_bash_input: buffer already exists for new fd %d", nfd);
+       free_buffered_stream (buffers[nfd]);
+     }
+ 
+   /* Reinitialize bash_input.location. */
+   if (bash_input.type == st_bstream)
+     {
+       bash_input.location.buffered_fd = nfd;
+       fd_to_buffered_stream (nfd);
+       close_buffered_fd (fd);	/* XXX */
+     }
+   else
+     /* If the current input type is not a buffered stream, but the shell
+        is not interactive and therefore using a buffered stream to read
+        input (e.g. with an `eval exec 3>output' inside a script), note
+        that the input fd has been changed.  pop_stream() looks at this
+        value and adjusts the input fd to the new value of
+        default_buffered_input accordingly. */
+     bash_input_fd_changed++;
+ 
+   if (default_buffered_input == fd)
+     default_buffered_input = nfd;
+ 
+   SET_CLOSE_ON_EXEC (nfd);
+   return nfd;
+ }
+ 
  /* Check that file descriptor FD is not the one that bash is currently
     using to read input from a script.  FD is about to be duplicated onto,
***************
*** 180,184 ****
     possible and necessary -- scripts read from stdin are still unbuffered),
     allocate a new file descriptor to use for bash input, and re-initialize
!    the buffered stream. */
  int
  check_bash_input (fd)
--- 266,274 ----
     possible and necessary -- scripts read from stdin are still unbuffered),
     allocate a new file descriptor to use for bash input, and re-initialize
!    the buffered stream.  Make sure the file descriptor used to save bash
!    input is set close-on-exec. Returns 0 on success, -1 on failure.  This
!    works only if fd is > 0 -- if fd == 0 and bash is reading input from
!    fd 0, save_bash_input is used instead, to cooperate with input
!    redirection (look at redir.c:add_undo_redirect()). */
  int
  check_bash_input (fd)
***************
*** 187,236 ****
    int nfd;
  
!   if (fd > 0 && ((bash_input.type == st_bstream && bash_input.location.buffered_fd == fd) ||
!   		 (interactive_shell == 0 && default_buffered_input == fd)))
!     {
!       /* Sync the stream so we can re-read from the new file descriptor.  We
! 	 might be able to avoid this by copying the buffered stream verbatim
! 	 to the new file descriptor. */
!       if (buffers[fd])
! 	sync_buffered_stream (fd);
! 
!       /* Now take care of duplicating the file descriptor that bash is
! 	 using for input, so we can reinitialize it later. */
!       nfd = fcntl (fd, F_DUPFD, 10);
!       if (nfd == -1)
! 	{
! 	  if (fcntl (fd, F_GETFD, 0) == 0)
! 	    sys_error ("cannot allocate new file descriptor for bash input from fd %d", fd);
! 	  return -1;
! 	}
! 
!       if (buffers[nfd])
! 	{
! 	  /* What's this?  A stray buffer without an associated open file
! 	     descriptor?  Free up the buffer and report the error. */
! 	  internal_error ("check_bash_input: buffer already exists for new fd %d", nfd);
! 	  free_buffered_stream (buffers[nfd]);
! 	}
! 
!       /* Reinitialize bash_input.location. */
!       if (bash_input.type == st_bstream)
! 	{
! 	  bash_input.location.buffered_fd = nfd;
! 	  fd_to_buffered_stream (nfd);
! 	  close_buffered_fd (fd);	/* XXX */
! 	}
!       else
! 	/* If the current input type is not a buffered stream, but the shell
! 	   is not interactive and therefore using a buffered stream to read
! 	   input (e.g. with an `eval exec 3>output' inside a script), note
! 	   that the input fd has been changed.  pop_stream() looks at this
! 	   value and adjusts the input fd to the new value of
! 	   default_buffered_input accordingly. */
! 	bash_input_fd_changed++;
! 
!       if (default_buffered_input == fd)
! 	default_buffered_input = nfd;
!     }
    return 0;
  }
--- 277,282 ----
    int nfd;
  
!   if (fd > 0 && fd_is_bash_input (fd))
!     return ((save_bash_input (fd, -1) == -1) ? -1 : 0);
    return 0;
  }
***************
*** 265,270 ****
      buffers[fd2]->b_fd = fd2;
  
!   if (is_bash_input && !buffers[fd2])
!     fd_to_buffered_stream (fd2);
  
    return (fd2);
--- 311,320 ----
      buffers[fd2]->b_fd = fd2;
  
!   if (is_bash_input)
!     {
!       if (!buffers[fd2])
! 	fd_to_buffered_stream (fd2);
!       buffers[fd2]->b_flag |= B_WASBASHINPUT;
!     }
  
    return (fd2);
***************
*** 272,280 ****
  
  /* Return 1 if a seek on FD will succeed. */
! #ifndef __CYGWIN32__
  #  define fd_is_seekable(fd) (lseek ((fd), 0L, SEEK_CUR) >= 0)
  #else
  #  define fd_is_seekable(fd) 0
! #endif /* __CYGWIN32__ */
  
  /* Take FD, a file descriptor, and create and return a buffered stream
--- 322,330 ----
  
  /* Return 1 if a seek on FD will succeed. */
! #ifndef __CYGWIN__
  #  define fd_is_seekable(fd) (lseek ((fd), 0L, SEEK_CUR) >= 0)
  #else
  #  define fd_is_seekable(fd) 0
! #endif /* __CYGWIN__ */
  
  /* Take FD, a file descriptor, and create and return a buffered stream
***************
*** 295,305 ****
      }
  
!   if (fd_is_seekable (fd) == 0)
      size = 1;
-   else
-     size = (size_t)((sb.st_size > MAX_INPUT_BUFFER_SIZE)
- 				? MAX_INPUT_BUFFER_SIZE
- 				: sb.st_size);
-       
    buffer = (char *)xmalloc (size);
  
--- 345,351 ----
      }
  
!   size = (fd_is_seekable (fd)) ? min (sb.st_size, MAX_INPUT_BUFFER_SIZE) : 1;
!   if (size == 0)
      size = 1;
    buffer = (char *)xmalloc (size);
  
***************
*** 382,385 ****
--- 428,436 ----
  {
    bp->b_used = zread (bp->b_fd, bp->b_buffer, bp->b_size);
+ #if defined (__CYGWIN__)
+   /* If on cygwin, translate \r\n to \n. */
+   if (bp->b_buffer[bp->b_used - 1] == '\r' && bp->b_buffer[bp->b_used] == '\n')
+     bp->b_buffer[--bp->b_used] = '\n';
+ #endif
    if (bp->b_used <= 0)
      {
***************
*** 423,429 ****
    off_t chars_left;
  
!   bp = buffers[bfd];
!   if (!bp)
      return (-1);
    chars_left = bp->b_used - bp->b_inputp;
    if (chars_left)
--- 474,480 ----
    off_t chars_left;
  
!   if (buffers == 0 || (bp = buffers[bfd]) == 0)
      return (-1);
+ 
    chars_left = bp->b_used - bp->b_inputp;
    if (chars_left)
***************
*** 436,440 ****
--- 487,499 ----
  buffered_getchar ()
  {
+ #if !defined (DJGPP)
    return (bufstream_getc (buffers[bash_input.location.buffered_fd]));
+ #else
+   /* On DJGPP, ignore \r. */
+   int ch;
+   while ((ch = bufstream_getc (buffers[bash_input.location.buffered_fd])) == '\r')
+     ;
+   return ch;
+ #endif
  }
  
diff -Nrc2 bash-2.04/input.h bash-2.05/input.h
*** bash-2.04/input.h	Fri Sep 17 10:11:18 1999
--- bash-2.05/input.h	Tue Feb 13 15:02:25 2001
***************
*** 41,47 ****
  #undef B_UNBUFF
  
! #define B_EOF		0x1
! #define B_ERROR		0x2
! #define B_UNBUFF	0x4
  
  /* A buffered stream.  Like a FILE *, but with our own buffering and
--- 41,48 ----
  #undef B_UNBUFF
  
! #define B_EOF		0x01
! #define B_ERROR		0x02
! #define B_UNBUFF	0x04
! #define B_WASBASHINPUT	0x08
  
  /* A buffered stream.  Like a FILE *, but with our own buffering and
***************
*** 107,110 ****
--- 108,114 ----
  #if defined (BUFFERED_INPUT)
  /* Functions from input.c. */
+ extern int fd_is_bash_input __P((int));
+ extern int set_bash_input_fd __P((int));
+ extern int save_bash_input __P((int, int));
  extern int check_bash_input __P((int));
  extern int duplicate_buffered_stream __P((int, int));
diff -Nrc2 bash-2.04/jobs.c bash-2.05/jobs.c
*** bash-2.04/jobs.c	Fri Feb 25 11:11:11 2000
--- bash-2.05/jobs.c	Mon Mar 26 13:08:24 2001
***************
*** 132,136 ****
  
  #if defined (READLINE)
! extern void _rl_set_screen_size ();
  #endif
  
--- 132,136 ----
  
  #if defined (READLINE)
! extern void rl_set_screen_size __P((int, int));
  #endif
  
***************
*** 141,144 ****
--- 141,145 ----
  extern int interrupt_immediately, last_command_exit_value;
  extern int loop_level, breaking;
+ extern int sourcelevel;
  extern Function *this_shell_builtin;
  extern char *shell_name, *this_command_name;
***************
*** 151,156 ****
--- 152,159 ----
  static int statsize;
  #endif
+ static int set_job_status_and_cleanup ();
  static void setjstatus ();
  static void get_new_window_size ();
+ static void run_sigchld_trap ();
  
  /* The array of known jobs. */
***************
*** 214,219 ****
  static char *job_working_directory ();
  static pid_t find_last_pid (), last_pid ();
! static int set_new_line_discipline (), map_over_jobs (), last_running_job ();
! static int most_recent_job_in_state (), last_stopped_job (), find_job ();
  static void notify_of_job_status (), cleanup_dead_jobs (), discard_pipeline ();
  static void add_process (), set_current_job (), reset_current ();
--- 217,223 ----
  static char *job_working_directory ();
  static pid_t find_last_pid (), last_pid ();
! static int set_new_line_discipline (), map_over_jobs ();
! static int job_last_running (), job_last_stopped ();
! static int most_recent_job_in_state (), find_job ();
  static void notify_of_job_status (), cleanup_dead_jobs (), discard_pipeline ();
  static void add_process (), set_current_job (), reset_current ();
***************
*** 240,243 ****
--- 244,252 ----
  static int jobs_list_frozen;
  
+ static sigset_t empty_sigset;
+ static sigset_t sigchld_sigset;
+ 
+ static char retcode_name_buffer[64];
+ 
  #if !defined (_POSIX_VERSION)
  
***************
*** 507,511 ****
  	   */
  	  if (job_control && newjob->pgrp)
! 	    give_terminal_to (newjob->pgrp);
  	}
      }
--- 516,520 ----
  	   */
  	  if (job_control && newjob->pgrp)
! 	    give_terminal_to (newjob->pgrp, 0);
  	}
      }
***************
*** 676,679 ****
--- 685,691 ----
    sigset_t set, oset;
  
+   if (job_slots == 0)
+     return 0;
+ 
    BLOCK_CHILD (set, oset);
  
***************
*** 843,846 ****
--- 855,905 ----
  }
  
+ static char *
+ printable_job_status (j, p, format)
+      int j;
+      PROCESS *p;
+      int format;
+ {
+   static char *temp;
+   int es;
+ 
+   temp = "Done";
+ 
+   if (STOPPED (j) && format == 0)
+     {
+       if (posixly_correct == 0 || p == 0 || (WIFSTOPPED (p->status) == 0))
+ 	temp = "Stopped";
+       else
+ 	{
+ 	  temp = retcode_name_buffer;
+ 	  sprintf (temp, "Stopped(%s)", signal_name (WSTOPSIG (p->status)));
+ 	}
+     }
+   else if (RUNNING (j))
+     temp = "Running";
+   else
+     {
+       if (WIFSTOPPED (p->status))
+ 	temp = (char *)strsignal (WSTOPSIG (p->status));
+       else if (WIFSIGNALED (p->status))
+ 	temp = (char *)strsignal (WTERMSIG (p->status));
+       else if (WIFEXITED (p->status))
+ 	{
+ 	  temp = retcode_name_buffer;
+ 	  es = WEXITSTATUS (p->status);
+ 	  if (es == 0)
+ 	    strcpy (temp, "Done");
+ 	  else if (posixly_correct)
+ 	    sprintf (temp, "Done(%d)", es);
+ 	  else
+ 	    sprintf (temp, "Exit %d", es);
+ 	}
+       else
+ 	temp = "Unknown status";
+     }
+ 
+   return temp;
+ }
+ 
  /* This is the way to print out information on a job if you
     know the index.  FORMAT is:
***************
*** 874,878 ****
    PROCESS *first, *last, *show;
    int es, name_padding;
!   char retcode_name_buffer[20], *temp;
  
    if (p == 0)
--- 933,937 ----
    PROCESS *first, *last, *show;
    int es, name_padding;
!   char *temp;
  
    if (p == 0)
***************
*** 896,927 ****
  	{
  	  show = format ? p : last;
! 	  temp = "Done";
! 
! 	  if (STOPPED (job_index) && format == 0)
! 	    temp = "Stopped";
! 
! 	  else if (RUNNING (job_index))
! 	    temp = "Running";
! 	  else
! 	    {
! 	      if (WIFSTOPPED (show->status))
! 		temp = (char *)strsignal (WSTOPSIG (show->status));
! 	      else if (WIFSIGNALED (show->status))
! 		temp = (char *)strsignal (WTERMSIG (show->status));
! 	      else if (WIFEXITED (show->status))
! 		{
! 		  temp = retcode_name_buffer;
! 		  es = WEXITSTATUS (show->status);
! 
! 		  if (es == 0)
! 		    strcpy (temp, "Done");
! 		  else if (posixly_correct)
! 		    sprintf (temp, "Done(%d)", es);
! 		  else
! 		    sprintf (temp, "Exit %d", es);
! 		}
! 	      else
! 		temp = "Unknown status";
! 	    }
  
  	  if (p != first)
--- 955,959 ----
  	{
  	  show = format ? p : last;
! 	  temp = printable_job_status (job_index, show, format);
  
  	  if (p != first)
***************
*** 943,947 ****
  	      es = STRLEN (temp);
  	      if (es == 0)
! 	        es = 2;	/* strlen ("| ") */
  	      name_padding = LONGEST_SIGNAL_DESC - es;
  
--- 975,979 ----
  	      es = STRLEN (temp);
  	      if (es == 0)
! 		es = 2;	/* strlen ("| ") */
  	      name_padding = LONGEST_SIGNAL_DESC - es;
  
***************
*** 1022,1026 ****
      fprintf (stream, "[%d]%c ", job_index + 1,
  	      (job_index == current_job) ? '+':
! 	        (job_index == previous_job) ? '-' : ' ');
  
    if (format == JLIST_NONINTERACTIVE)
--- 1054,1058 ----
      fprintf (stream, "[%d]%c ", job_index + 1,
  	      (job_index == current_job) ? '+':
! 		(job_index == previous_job) ? '-' : ' ');
  
    if (format == JLIST_NONINTERACTIVE)
***************
*** 1172,1176 ****
  	    {
  #endif
! 	      /* XXX - By convention (and assumption above), if
  		 pipeline_pgrp == shell_pgrp, we are making a child for
  		 command substitution.
--- 1204,1208 ----
  	    {
  #endif
! 	      /* By convention (and assumption above), if
  		 pipeline_pgrp == shell_pgrp, we are making a child for
  		 command substitution.
***************
*** 1179,1183 ****
  		 pipeline, for example). */
  	      if (async_p == 0 && pipeline_pgrp != shell_pgrp)
! 		give_terminal_to (pipeline_pgrp);
  
  #if defined (PGRP_PIPE)
--- 1211,1215 ----
  		 pipeline, for example). */
  	      if (async_p == 0 && pipeline_pgrp != shell_pgrp)
! 		give_terminal_to (pipeline_pgrp, 0);
  
  #if defined (PGRP_PIPE)
***************
*** 1222,1226 ****
  	      /* Don't twiddle terminal pgrps in the parent!  This is the bug,
  		 not the good thing of twiddling them in the child! */
! 	      /* give_terminal_to (pipeline_pgrp); */
  	    }
  	  /* This is done on the recommendation of the Rationale section of
--- 1254,1258 ----
  	      /* Don't twiddle terminal pgrps in the parent!  This is the bug,
  		 not the good thing of twiddling them in the child! */
! 	      /* give_terminal_to (pipeline_pgrp, 0); */
  	    }
  	  /* This is done on the recommendation of the Rationale section of
***************
*** 1272,1289 ****
     to the state of the tty. */
  
  #if defined (NEW_TTY_DRIVER)
- static struct sgttyb shell_tty_info;
  static struct tchars shell_tchars;
  static struct ltchars shell_ltchars;
  #endif /* NEW_TTY_DRIVER */
  
- #if defined (TERMIO_TTY_DRIVER)
- static struct termio shell_tty_info;
- #endif /* TERMIO_TTY_DRIVER */
- 
- #if defined (TERMIOS_TTY_DRIVER)
- static struct termios shell_tty_info;
- #endif /* TERMIOS_TTY_DRIVER */
- 
  #if defined (NEW_TTY_DRIVER) && defined (DRAIN_OUTPUT)
  /* Since the BSD tty driver does not allow us to change the tty modes
--- 1304,1314 ----
     to the state of the tty. */
  
+ static TTYSTRUCT shell_tty_info;
+ 
  #if defined (NEW_TTY_DRIVER)
  static struct tchars shell_tchars;
  static struct ltchars shell_ltchars;
  #endif /* NEW_TTY_DRIVER */
  
  #if defined (NEW_TTY_DRIVER) && defined (DRAIN_OUTPUT)
  /* Since the BSD tty driver does not allow us to change the tty modes
***************
*** 1553,1557 ****
        restore_sigint_handler ();
        /* If we got a SIGINT while in `wait', and SIGINT is trapped, do
!          what POSIX.2 says (see builtins/wait.def for more info). */
        if (this_shell_builtin && this_shell_builtin == wait_builtin &&
  	  signal_is_trapped (SIGINT) &&
--- 1578,1582 ----
        restore_sigint_handler ();
        /* If we got a SIGINT while in `wait', and SIGINT is trapped, do
! 	 what POSIX.2 says (see builtins/wait.def for more info). */
        if (this_shell_builtin && this_shell_builtin == wait_builtin &&
  	  signal_is_trapped (SIGINT) &&
***************
*** 1588,1592 ****
  }
  
! static int
  raw_job_exit_status (job)
  {
--- 1613,1619 ----
  }
  
! /* Return the exit status of the last process in the pipeline for job JOB.
!    This is the exit status of the entire job. */
! static WAIT
  raw_job_exit_status (job)
  {
***************
*** 1597,1601 ****
  }
  
! static int
  job_exit_status (job)
       int job;
--- 1624,1631 ----
  }
  
! /* Return the exit status of job JOB.  This is the exit status of the last
!    (rightmost) process in the job's pipeline, modified if the job was killed
!    by a signal or stopped. */
! static WAIT
  job_exit_status (job)
       int job;
***************
*** 1610,1614 ****
        if (child == 0) \
  	{ \
! 	  give_terminal_to (shell_pgrp); \
  	  UNBLOCK_CHILD (oset); \
  	  internal_error ("wait_for: No record of process %d", pid); \
--- 1640,1644 ----
        if (child == 0) \
  	{ \
! 	  give_terminal_to (shell_pgrp, 0); \
  	  UNBLOCK_CHILD (oset); \
  	  internal_error ("wait_for: No record of process %d", pid); \
***************
*** 1627,1637 ****
       pid_t pid;
  {
!   int job, termination_state, r, s;
    register PROCESS *child;
    sigset_t set, oset;
    register PROCESS *p;
- #if 0
-   int job_state, any_stopped;
- #endif
  
    /* In the case that this code is interrupted, and we longjmp () out of it,
--- 1657,1665 ----
       pid_t pid;
  {
!   int job, termination_state, r;
!   WAIT s;
    register PROCESS *child;
    sigset_t set, oset;
    register PROCESS *p;
  
    /* In the case that this code is interrupted, and we longjmp () out of it,
***************
*** 1665,1695 ****
  
        /* If this child is part of a job, then we are really waiting for the
!          job to finish.  Otherwise, we are waiting for the child to finish.
!          We check for JDEAD in case the job state has been set by waitchld
!          after receipt of a SIGCHLD. */
        if (job == NO_JOB)
  	job = find_job (pid);
  
! #if 0
!       /* XXX - let waitchld take care of setting this.  If the job has
! 	 already exited before this is called, sigchld_handler will have
! 	 called waitchld and this will be set to JDEAD. */
!       if (job != NO_JOB && JOBSTATE (job) != JDEAD)
! 	{
! 	  job_state = any_stopped = 0;
! 	  p = jobs[job]->pipe;
! 	  do
! 	    {
! 	      job_state |= p->running;
! 	      if (p->running == 0)
! 		any_stopped |= WIFSTOPPED (p->status);
! 	      p = p->next;
! 	    }
! 	  while (p != jobs[job]->pipe);
! 
! 	  if (job_state == 0)
! 	    jobs[job]->state = any_stopped ? JSTOPPED : JDEAD;
! 	}
! #endif
  
        if (child->running || (job != NO_JOB && RUNNING (job)))
--- 1693,1705 ----
  
        /* If this child is part of a job, then we are really waiting for the
! 	 job to finish.  Otherwise, we are waiting for the child to finish.
! 	 We check for JDEAD in case the job state has been set by waitchld
! 	 after receipt of a SIGCHLD. */
        if (job == NO_JOB)
  	job = find_job (pid);
  
!       /* waitchld() takes care of setting the state of the job.  If the job
! 	 has already exited before this is called, sigchld_handler will have
! 	 called waitchld and the state will be set to JDEAD. */
  
        if (child->running || (job != NO_JOB && RUNNING (job)))
***************
*** 1725,1728 ****
--- 1735,1750 ----
  	      goto wait_for_return;
  	    }
+ 
+ 	  /* If child is marked as running, but waitpid() returns -1/ECHILD,
+ 	     there is something wrong.  Somewhere, wait should have returned
+ 	     that child's pid.  Mark the child as not running and the job,
+ 	     if it exists, as JDEAD. */
+ 	  if (r == -1 && errno == ECHILD)
+ 	    {
+ 	      child->running = 0;
+ 	      child->status = 0;	/* XXX */
+ 	      if (job != NO_JOB)
+ 		jobs[job]->state = JDEAD;
+ 	    }
  #endif /* WAITPID_BROKEN */
  	}
***************
*** 1765,1769 ****
  #endif
  
!       give_terminal_to (shell_pgrp);
      }
  
--- 1787,1791 ----
  #endif
  
!       give_terminal_to (shell_pgrp, 0);
      }
  
***************
*** 1800,1814 ****
  	    {
  	      set_tty_state ();
! #if 0
! 	      /* If the foreground job was suspended with ^Z (SIGTSTP), and
! 		 the user has requested it, get a possibly new window size. */
! 	      if (check_window_size && WIFSTOPPED (s) &&
! 		    (WSTOPSIG (s) == SIGTSTP) &&
! 		    job == current_job)
! #else
  	      /* If the current job was stopped or killed by a signal, and
  		 the user has requested it, get a possibly new window size */
  	      if (check_window_size && job == current_job)
- #endif
  		get_new_window_size (0);
  	    }
--- 1822,1829 ----
  	    {
  	      set_tty_state ();
! 
  	      /* If the current job was stopped or killed by a signal, and
  		 the user has requested it, get a possibly new window size */
  	      if (check_window_size && job == current_job)
  		get_new_window_size (0);
  	    }
***************
*** 1835,1849 ****
  		}
  	    }
- 
- 	  notify_and_cleanup ();
- 	}
-       else
- 	{
- 	  /* If this job is dead, and the shell is not interactive, make
- 	     sure we turn on the notify bit so we don't get an unwanted
- 	     message about the job's termination, and so delete_job really
- 	     clears the slot in the jobs table. */
- 	  notify_and_cleanup ();
  	}
      }
  
--- 1850,1861 ----
  		}
  	    }
  	}
+ 
+       /* If this job is dead, notify the user of the status.  If the shell
+ 	 is interactive, this will display a message on the terminal.  If
+ 	 the shell is not interactive, make sure we turn on the notify bit
+ 	 so we don't get an unwanted message about the job's termination,
+ 	 and so delete_job really clears the slot in the jobs table. */
+       notify_and_cleanup ();
      }
  
***************
*** 1897,1901 ****
      return;
  
!   if (interactive || interactive_shell == 0)
      notify_of_job_status ();
  
--- 1909,1913 ----
      return;
  
!   if (interactive || interactive_shell == 0 || sourcelevel)
      notify_of_job_status ();
  
***************
*** 1940,1944 ****
     found. */
  static int
! last_stopped_job (job)
       int job;
  {
--- 1952,1956 ----
     found. */
  static int
! job_last_stopped (job)
       int job;
  {
***************
*** 1949,1953 ****
     found. */
  static int
! last_running_job (job)
       int job;
  {
--- 1961,1965 ----
     found. */
  static int
! job_last_running (job)
       int job;
  {
***************
*** 1981,1985 ****
    if (STOPPED (current_job))
      {
!       candidate = last_stopped_job (current_job);
  
        if (candidate != NO_JOB)
--- 1993,1997 ----
    if (STOPPED (current_job))
      {
!       candidate = job_last_stopped (current_job);
  
        if (candidate != NO_JOB)
***************
*** 1997,2002 ****
       JSTOPPED. */
  
!   candidate = RUNNING (current_job) ? last_running_job (current_job)
! 				    : last_running_job (job_slots);
  
    if (candidate != NO_JOB)
--- 2009,2014 ----
       JSTOPPED. */
  
!   candidate = RUNNING (current_job) ? job_last_running (current_job)
! 				    : job_last_running (job_slots);
  
    if (candidate != NO_JOB)
***************
*** 2035,2043 ****
        /* Second choice: the most recently stopped job. */
        if (candidate == NO_JOB)
! 	candidate = last_stopped_job (job_slots);
  
        /* Third choice: the newest running job. */
        if (candidate == NO_JOB)
! 	candidate = last_running_job (job_slots);
      }
  
--- 2047,2055 ----
        /* Second choice: the most recently stopped job. */
        if (candidate == NO_JOB)
! 	candidate = job_last_stopped (job_slots);
  
        /* Third choice: the newest running job. */
        if (candidate == NO_JOB)
! 	candidate = job_last_running (job_slots);
      }
  
***************
*** 2085,2097 ****
    sigset_t set, oset;
    char *wd;
! #if defined (NEW_TTY_DRIVER)
!   static struct sgttyb save_stty;
! #endif
! #if defined (TERMIO_TTY_DRIVER)
!   static struct termio save_stty;
! #endif
! #if defined (TERMIOS_TTY_DRIVER)
!   static struct termios save_stty;
! #endif
  
    BLOCK_CHILD (set, oset);
--- 2097,2101 ----
    sigset_t set, oset;
    char *wd;
!   static TTYSTRUCT save_stty;
  
    BLOCK_CHILD (set, oset);
***************
*** 2159,2163 ****
        /* Give the terminal to this job. */
        if (IS_JOBCONTROL (job))
! 	give_terminal_to (jobs[job]->pgrp);
      }
    else
--- 2163,2167 ----
        /* Give the terminal to this job. */
        if (IS_JOBCONTROL (job))
! 	give_terminal_to (jobs[job]->pgrp, 0);
      }
    else
***************
*** 2289,2294 ****
    PROCESS *child;
    pid_t pid;
!   int call_set_current, last_stopped_job, job, children_exited;
!   int job_state, any_stopped, any_tstped, waitpid_flags, tstatus;
  
    call_set_current = children_exited = 0;
--- 2293,2297 ----
    PROCESS *child;
    pid_t pid;
!   int call_set_current, last_stopped_job, job, children_exited, waitpid_flags;
  
    call_set_current = children_exited = 0;
***************
*** 2298,2302 ****
      {
        /* We don't want to be notified about jobs stopping if job control
!          is not active.  XXX - was interactive_shell instead of job_control */
        waitpid_flags = (job_control && subshell_environment == 0)
  			? WUNTRACED
--- 2301,2305 ----
      {
        /* We don't want to be notified about jobs stopping if job control
! 	 is not active.  XXX - was interactive_shell instead of job_control */
        waitpid_flags = (job_control && subshell_environment == 0)
  			? WUNTRACED
***************
*** 2347,2484 ****
    
        if (job == NO_JOB)
!         continue;
! 
!       /* Note that we're resetting `child' here because we now want to
! 	 deal with the job. */
!       child = jobs[job]->pipe;
!       jobs[job]->flags &= ~J_NOTIFIED;
! 
!       /* If all children are not running, but any of them is
! 	 stopped, then the job is stopped, not dead. */
!       job_state = any_stopped = any_tstped = 0;
!       do
! 	{
! 	  job_state |= child->running;
! 	  if (child->running == 0 && (WIFSTOPPED (child->status)))
! 	    {
! 	      any_stopped = 1;
! 	      any_tstped |= interactive && job_control &&
! 			    (WSTOPSIG (child->status) == SIGTSTP);
! 	    }
! 	  child = child->next;
! 	}
!       while (child != jobs[job]->pipe);
! 
!       /* If job_state != 0, the job is still running, so don't bother with
! 	 setting the process exit status and job state. */
!       if (job_state != 0)
!         continue;
! 
!       /* The job is either stopped or dead.  Set the state of the job
! 	 accordingly. */
!       if (any_stopped)
! 	{
! 	  jobs[job]->state = JSTOPPED;
! 	  jobs[job]->flags &= ~J_FOREGROUND;
! 	  call_set_current++;
! 	  last_stopped_job = job;
! 	  /* Suspending a job with SIGTSTP breaks all active loops. */
! 	  if (any_tstped && loop_level)
! 	    breaking = loop_level;
! 	}
!       else
! 	{
! 	  /* ASSERT(child == jobs[job]->pipe); */
! 	  jobs[job]->state = JDEAD;
! 	  if (job == last_stopped_job)
! 	    last_stopped_job = NO_JOB;
! 
! 	  if (IS_FOREGROUND (job))
! 	    setjstatus (job);		/* XXX */
! 
! 	  /* If this job has a cleanup function associated with it, call it
! 	     with `cleanarg' as the single argument, then set the function
! 	     pointer to NULL so it is not inadvertently called twice.  The
! 	     cleanup function is responsible for deallocating cleanarg. */
! 	  if (jobs[job]->j_cleanup)
! 	    {
! 	      (*jobs[job]->j_cleanup) (jobs[job]->cleanarg);
! 	      jobs[job]->j_cleanup = (VFunction *)NULL;
! 	    }
! 
! 	  /* XXX
! 	     If we're running a shell script and we get a SIGINT with a
! 	     SIGINT trap handler, but the foreground job handles it and
! 	     does not exit due to SIGINT, run the trap handler but do not
! 	     otherwise act as if we got the interrupt. */
! 	  if (wait_sigint_received && interactive_shell == 0 &&
! 	      WIFSIGNALED (child->status) == 0 && IS_FOREGROUND (job) &&
! 	      signal_is_trapped (SIGINT))
! 	    {
! 	      wait_sigint_received = 0;
! 	      last_command_exit_value = process_exit_status (child->status);
! 
! 	      jobs_list_frozen = 1;
! 	      tstatus = maybe_call_trap_handler (SIGINT);
! 	      jobs_list_frozen = 0;
! 	    }
  
! 	  /* If the foreground job is killed by SIGINT when
! 	     job control is not active, we need to perform
! 	     some special handling.
! 
! 	     The check of wait_sigint_received is a way to
! 	     determine if the SIGINT came from the keyboard
! 	     (in which case the shell has already seen it,
! 	     and wait_sigint_received is non-zero, because
! 	     keyboard signals are sent to process groups)
! 	     or via kill(2) to the foreground process by
! 	     another process (or itself).  If the shell did
! 	     receive the SIGINT, it needs to perform normal
! 	     SIGINT processing. */
! 	  else if (wait_sigint_received && (WTERMSIG (child->status) == SIGINT) &&
! 	      IS_FOREGROUND (job) && IS_JOBCONTROL (job) == 0)
! 	    {
! 	      wait_sigint_received = 0;
  
! 	      /* If SIGINT is trapped, set the exit status so
! 		 that the trap handler can see it. */
! 	      if (signal_is_trapped (SIGINT))
! 		last_command_exit_value = process_exit_status (child->status);
! 
! 	      /* If the signal is trapped, let the trap handler
! 		 get it no matter what and simply return if
! 		 the trap handler returns.
! 		 maybe_call_trap_handler() may cause dead jobs
! 		 to be removed from the job table because of
! 		 a call to execute_command.  Watch out for this. */
! 	      jobs_list_frozen = 1;
! 	      tstatus = maybe_call_trap_handler (SIGINT);
! 	      jobs_list_frozen = 0;
! 	      if (tstatus == 0 && old_sigint_handler != INVALID_SIGNAL_HANDLER)
! 		{
! 		  /* wait_sigint_handler () has already seen SIGINT and
! 		     allowed the wait builtin to jump out.  We need to
! 		     call the original SIGINT handler, if necessary.  If
! 		     the original handler is SIG_DFL, we need to resend
! 		     the signal to ourselves. */
! 		  SigHandler *temp_handler;
! 
! 		  temp_handler = old_sigint_handler;
! 		  /* Bogus.  If we've reset the signal handler as the result
! 		     of a trap caught on SIGINT, then old_sigint_handler
! 		     will point to trap_handler, which now knows nothing about
! 		     SIGINT (if we reset the sighandler to the default).
! 		     In this case, we have to fix things up.  What a crock. */
! 		  if (temp_handler == trap_handler && signal_is_trapped (SIGINT) == 0)
! 		    temp_handler = trap_to_sighandler (SIGINT);
! 		  restore_sigint_handler ();
! 		  if (temp_handler == SIG_DFL)
! 		    termination_unwind_protect (SIGINT);
! 		  else if (temp_handler != SIG_IGN)
! 		    (*temp_handler) (SIGINT);
! 		}
! 	    }
! 	}
      }
    while ((sigchld || block == 0) && pid > (pid_t)0);
--- 2350,2361 ----
    
        if (job == NO_JOB)
! 	continue;
  
!       call_set_current += set_job_status_and_cleanup (job);
  
!       if (STOPPED (job))
! 	last_stopped_job = job;
!       else if (DEADJOB (job) && last_stopped_job == job)
! 	last_stopped_job = NO_JOB;
      }
    while ((sigchld || block == 0) && pid > (pid_t)0);
***************
*** 2497,2539 ****
    if (job_control && signal_is_trapped (SIGCHLD) && children_exited &&
        trap_list[SIGCHLD] != (char *)IGNORE_SIG)
!     {
!       char *trap_command;
!       int i;
! 
!       /* Turn off the trap list during the call to parse_and_execute ()
! 	 to avoid potentially infinite recursive calls.  Preserve the
! 	 values of last_command_exit_value, last_made_pid, and the_pipeline
! 	 around the execution of the trap commands. */
!       trap_command = savestring (trap_list[SIGCHLD]);
! 
!       begin_unwind_frame ("SIGCHLD trap");
!       unwind_protect_int (last_command_exit_value);
!       if (sizeof (pid_t) == sizeof (short))
! 	unwind_protect_short (last_made_pid);
!       else
! 	unwind_protect_int (last_made_pid);
!       unwind_protect_int (interrupt_immediately);
!       unwind_protect_int (jobs_list_frozen);
!       unwind_protect_pointer (the_pipeline);
!       unwind_protect_pointer (subst_assign_varlist);
! 
!       /* We have to add the commands this way because they will be run
! 	 in reverse order of adding.  We don't want maybe_set_sigchld_trap ()
! 	 to reference freed memory. */
!       add_unwind_protect ((Function *)xfree, trap_command);
!       add_unwind_protect ((Function *)maybe_set_sigchld_trap, trap_command);
! 
!       subst_assign_varlist = (WORD_LIST *)NULL;
!       the_pipeline = (PROCESS *)NULL;
!       restore_default_signal (SIGCHLD);
!       jobs_list_frozen = 1;
!       for (i = 0; i < children_exited; i++)
! 	{
! 	  interrupt_immediately = 1;
! 	  parse_and_execute (savestring (trap_command), "trap", SEVAL_NOHIST);
! 	}
! 
!       run_unwind_frame ("SIGCHLD trap");
!     }
  
    /* We have successfully recorded the useful information about this process
--- 2374,2378 ----
    if (job_control && signal_is_trapped (SIGCHLD) && children_exited &&
        trap_list[SIGCHLD] != (char *)IGNORE_SIG)
!     run_sigchld_trap (children_exited);
  
    /* We have successfully recorded the useful information about this process
***************
*** 2547,2550 ****
--- 2386,2621 ----
  }
  
+ /* Set the status of JOB and perform any necessary cleanup if the job is
+    marked as JDEAD.
+ 
+    Currently, the cleanup activity is restricted to handling any SIGINT
+    received while waiting for a foreground job to finish. */
+ static int
+ set_job_status_and_cleanup (job)
+      int job;
+ {
+   PROCESS *child;
+   int tstatus, job_state, any_stopped, any_tstped, call_set_current;
+   SigHandler *temp_handler;
+ 
+   child = jobs[job]->pipe;
+   jobs[job]->flags &= ~J_NOTIFIED;
+ 
+   call_set_current = 0;
+ 
+   /*
+    * COMPUTE JOB STATUS
+    */
+ 
+   /* If all children are not running, but any of them is  stopped, then
+      the job is stopped, not dead. */
+   job_state = any_stopped = any_tstped = 0;
+   do
+     {
+       job_state |= child->running;
+       if (child->running == 0 && (WIFSTOPPED (child->status)))
+ 	{
+ 	  any_stopped = 1;
+ 	  any_tstped |= interactive && job_control &&
+ 			    (WSTOPSIG (child->status) == SIGTSTP);
+ 	}
+       child = child->next;
+     }
+   while (child != jobs[job]->pipe);
+ 
+   /* If job_state != 0, the job is still running, so don't bother with
+      setting the process exit status and job state. */
+   if (job_state != 0)
+     return 0;
+ 
+   /*
+    * SET JOB STATUS
+    */
+ 
+   /* The job is either stopped or dead.  Set the state of the job accordingly. */
+   if (any_stopped)
+     {
+       jobs[job]->state = JSTOPPED;
+       jobs[job]->flags &= ~J_FOREGROUND;
+       call_set_current++;
+       /* Suspending a job with SIGTSTP breaks all active loops. */
+       if (any_tstped && loop_level)
+ 	breaking = loop_level;
+     }
+   else
+     {
+       jobs[job]->state = JDEAD;
+ 
+       if (IS_FOREGROUND (job))
+ 	setjstatus (job);
+ 
+       /* If this job has a cleanup function associated with it, call it
+ 	 with `cleanarg' as the single argument, then set the function
+ 	 pointer to NULL so it is not inadvertently called twice.  The
+ 	 cleanup function is responsible for deallocating cleanarg. */
+       if (jobs[job]->j_cleanup)
+ 	{
+ 	  (*jobs[job]->j_cleanup) (jobs[job]->cleanarg);
+ 	  jobs[job]->j_cleanup = (VFunction *)NULL;
+ 	}
+     }
+ 
+   /*
+    * CLEANUP
+    *
+    * Currently, we just do special things if we got a SIGINT while waiting
+    * for a foreground job to complete
+    */
+ 
+   if (jobs[job]->state == JDEAD)
+     {
+       /* If we're running a shell script and we get a SIGINT with a
+ 	 SIGINT trap handler, but the foreground job handles it and
+ 	 does not exit due to SIGINT, run the trap handler but do not
+ 	 otherwise act as if we got the interrupt. */
+       if (wait_sigint_received && interactive_shell == 0 &&
+ 	  WIFSIGNALED (child->status) == 0 && IS_FOREGROUND (job) &&
+ 	  signal_is_trapped (SIGINT))
+ 	{
+ 	  wait_sigint_received = 0;
+ 	  last_command_exit_value = process_exit_status (child->status);
+ 
+ 	  jobs_list_frozen = 1;
+ 	  tstatus = maybe_call_trap_handler (SIGINT);
+ 	  jobs_list_frozen = 0;
+ 	}
+ 
+       /* If the foreground job is killed by SIGINT when job control is not
+ 	 active, we need to perform some special handling.
+ 
+ 	 The check of wait_sigint_received is a way to determine if the
+ 	 SIGINT came from the keyboard (in which case the shell has already
+ 	 seen it, and wait_sigint_received is non-zero, because keyboard
+ 	 signals are sent to process groups) or via kill(2) to the foreground
+ 	 process by another process (or itself).  If the shell did receive the
+ 	 SIGINT, it needs to perform normal SIGINT processing. */
+       else if (wait_sigint_received && (WTERMSIG (child->status) == SIGINT) &&
+ 	      IS_FOREGROUND (job) && IS_JOBCONTROL (job) == 0)
+ 	{
+ 	  wait_sigint_received = 0;
+ 
+ 	  /* If SIGINT is trapped, set the exit status so that the trap
+ 	     handler can see it. */
+ 	  if (signal_is_trapped (SIGINT))
+ 	    last_command_exit_value = process_exit_status (child->status);
+ 
+ 	  /* If the signal is trapped, let the trap handler get it no matter
+ 	     what and simply return if the trap handler returns.
+ 	    maybe_call_trap_handler() may cause dead jobs to be removed from
+ 	    the job table because of a call to execute_command.  We work
+ 	    around this by setting JOBS_LIST_FROZEN. */
+ 	  jobs_list_frozen = 1;
+ 	  tstatus = maybe_call_trap_handler (SIGINT);
+ 	  jobs_list_frozen = 0;
+ 	  if (tstatus == 0 && old_sigint_handler != INVALID_SIGNAL_HANDLER)
+ 	    {
+ 	      /* wait_sigint_handler () has already seen SIGINT and
+ 		 allowed the wait builtin to jump out.  We need to
+ 		 call the original SIGINT handler, if necessary.  If
+ 		 the original handler is SIG_DFL, we need to resend
+ 		 the signal to ourselves. */
+ 
+ 	      temp_handler = old_sigint_handler;
+ 
+ 	      /* Bogus.  If we've reset the signal handler as the result
+ 		 of a trap caught on SIGINT, then old_sigint_handler
+ 		 will point to trap_handler, which now knows nothing about
+ 		 SIGINT (if we reset the sighandler to the default).
+ 		 In this case, we have to fix things up.  What a crock. */
+ 	      if (temp_handler == trap_handler && signal_is_trapped (SIGINT) == 0)
+ 		  temp_handler = trap_to_sighandler (SIGINT);
+ 		restore_sigint_handler ();
+ 		if (temp_handler == SIG_DFL)
+ 		  termination_unwind_protect (SIGINT);
+ 		else if (temp_handler != SIG_IGN)
+ 		  (*temp_handler) (SIGINT);
+ 	    }
+ 	}
+     }
+ 
+   return call_set_current;
+ }
+ 
+ /* Build the array of values for the $PIPESTATUS variable from the set of
+    exit statuses of all processes in the job J. */
+ static void
+ setjstatus (j)
+      int j;
+ {
+ #if defined (ARRAY_VARS)
+   register int i;
+   register PROCESS *p;
+ 
+   for (i = 1, p = jobs[j]->pipe; p->next != jobs[j]->pipe; p = p->next, i++)
+     ;
+   i++;
+   if (statsize <= i)
+     {
+       pstatuses = (int *)xrealloc (pstatuses, i * sizeof (int));
+       statsize = i;
+     }
+   i = 0;
+   p = jobs[j]->pipe;
+   do
+     {
+       pstatuses[i++] = process_exit_status (p->status);
+       p = p->next;
+     }
+   while (p != jobs[j]->pipe);
+ 
+   pstatuses[i] = -1;	/* sentinel */
+   set_pipestatus_array (pstatuses);
+ #endif
+ }
+ 
+ static void
+ run_sigchld_trap (nchild)
+      int nchild;
+ {
+   char *trap_command;
+   int i;
+ 
+   /* Turn off the trap list during the call to parse_and_execute ()
+      to avoid potentially infinite recursive calls.  Preserve the
+      values of last_command_exit_value, last_made_pid, and the_pipeline
+      around the execution of the trap commands. */
+   trap_command = savestring (trap_list[SIGCHLD]);
+ 
+   begin_unwind_frame ("SIGCHLD trap");
+   unwind_protect_int (last_command_exit_value);
+   if (sizeof (pid_t) == sizeof (short))
+     unwind_protect_short (last_made_pid);
+   else
+     unwind_protect_int (last_made_pid);
+   unwind_protect_int (interrupt_immediately);
+   unwind_protect_int (jobs_list_frozen);
+   unwind_protect_pointer (the_pipeline);
+   unwind_protect_pointer (subst_assign_varlist);
+ 
+   /* We have to add the commands this way because they will be run
+      in reverse order of adding.  We don't want maybe_set_sigchld_trap ()
+      to reference freed memory. */
+   add_unwind_protect ((Function *)xfree, trap_command);
+   add_unwind_protect ((Function *)maybe_set_sigchld_trap, trap_command);
+ 
+   subst_assign_varlist = (WORD_LIST *)NULL;
+   the_pipeline = (PROCESS *)NULL;
+ 
+   restore_default_signal (SIGCHLD);
+   jobs_list_frozen = 1;
+   for (i = 0; i < nchild; i++)
+     {
+       interrupt_immediately = 1;
+       parse_and_execute (savestring (trap_command), "trap", SEVAL_NOHIST);
+     }
+ 
+   run_unwind_frame ("SIGCHLD trap");
+ }
+ 
  /* Function to call when you want to notify people of changes
     in job status.  This prints out all jobs which are pending
***************
*** 2559,2562 ****
--- 2630,2636 ----
    WAIT s;
  
+   if (jobs == 0 || job_slots == 0)
+     return;
+ 
    sigemptyset (&set);
    sigaddset (&set, SIGCHLD);
***************
*** 2569,2577 ****
        if (jobs[job] && IS_NOTIFIED (job) == 0)
  	{
- #if 0
- 	  s = jobs[job]->pipe->status;
- #else
  	  s = raw_job_exit_status (job);
- #endif
  	  termsig = WTERMSIG (s);
  
--- 2643,2647 ----
***************
*** 2611,2615 ****
  #endif
  		  signal_is_trapped (termsig) == 0)
! 	        {
  		  fprintf (stderr, "%s: line %d: ", get_name_for_error (), line_number);
  		  pretty_print_job (job, JLIST_NONINTERACTIVE, stderr);
--- 2681,2685 ----
  #endif
  		  signal_is_trapped (termsig) == 0)
! 		{
  		  fprintf (stderr, "%s: line %d: ", get_name_for_error (), line_number);
  		  pretty_print_job (job, JLIST_NONINTERACTIVE, stderr);
***************
*** 2747,2760 ****
  	  if (shell_pgrp != original_pgrp && shell_pgrp != terminal_pgrp)
  	    {
! 	      if (give_terminal_to (shell_pgrp) < 0)		/* XXX */
  		{
! 		  setpgid (0, original_pgrp);			/* XXX */
! 		  shell_pgrp = original_pgrp;			/* XXX */
! 		  job_control = 0;				/* XXX */
  		}
  	    }
  	}
        if (job_control == 0)
!         internal_error ("no job control in this shell");	/* XXX */
      }
  
--- 2817,2830 ----
  	  if (shell_pgrp != original_pgrp && shell_pgrp != terminal_pgrp)
  	    {
! 	      if (give_terminal_to (shell_pgrp, 0) < 0)
  		{
! 		  setpgid (0, original_pgrp);
! 		  shell_pgrp = original_pgrp;
! 		  job_control = 0;
  		}
  	    }
  	}
        if (job_control == 0)
! 	internal_error ("no job control in this shell");
      }
  
***************
*** 2772,2775 ****
--- 2842,2856 ----
  }
  
+ #ifdef DEBUG
+ void
+ debug_print_pgrps ()
+ {
+   itrace("original_pgrp = %d shell_pgrp = %d terminal_pgrp = %d",
+ 	 original_pgrp, shell_pgrp, terminal_pgrp);
+   itrace("tcgetpgrp(%d) -> %d, getpgid(0) -> %d",
+ 	 shell_tty, tcgetpgrp (shell_tty), getpgid(0));
+ }
+ #endif
+ 
  /* Set the line discipline to the best this system has to offer.
     Return -1 if this is not possible. */
***************
*** 2831,2835 ****
  static SigHandler *old_tstp, *old_ttou, *old_ttin;
  static SigHandler *old_cont = (SigHandler *)SIG_DFL;
! static sighandler stop_signal_handler (), cont_signal_handler ();
  
  #if defined (TIOCGWINSZ) && defined (SIGWINCH)
--- 2912,2916 ----
  static SigHandler *old_tstp, *old_ttou, *old_ttin;
  static SigHandler *old_cont = (SigHandler *)SIG_DFL;
! static sighandler sigstop_sighandler (), sigcont_sighandler ();
  
  #if defined (TIOCGWINSZ) && defined (SIGWINCH)
***************
*** 2848,2854 ****
        shell_tty_info.c_winsize = win;	/* structure copying */
  #endif
!       set_lines_and_columns (win.ws_row, win.ws_col);
  #if defined (READLINE)
!       _rl_set_screen_size (win.ws_row, win.ws_col);
  #endif
      }
--- 2929,2935 ----
        shell_tty_info.c_winsize = win;	/* structure copying */
  #endif
!       sh_set_lines_and_columns (win.ws_row, win.ws_col);
  #if defined (READLINE)
!       rl_set_screen_size (win.ws_row, win.ws_col);
  #endif
      }
***************
*** 2903,2909 ****
    else if (job_control)
      {
!       old_tstp = set_signal_handler (SIGTSTP, stop_signal_handler);
!       old_ttou = set_signal_handler (SIGTTOU, stop_signal_handler);
!       old_ttin = set_signal_handler (SIGTTIN, stop_signal_handler);
      }
    /* Leave these things alone for non-interactive shells without job
--- 2984,2990 ----
    else if (job_control)
      {
!       old_tstp = set_signal_handler (SIGTSTP, sigstop_sighandler);
!       old_ttou = set_signal_handler (SIGTTOU, sigstop_sighandler);
!       old_ttin = set_signal_handler (SIGTTIN, sigstop_sighandler);
      }
    /* Leave these things alone for non-interactive shells without job
***************
*** 2913,2917 ****
  /* Here we handle CONT signals. */
  static sighandler
! cont_signal_handler (sig)
       int sig;
  {
--- 2994,2998 ----
  /* Here we handle CONT signals. */
  static sighandler
! sigcont_sighandler (sig)
       int sig;
  {
***************
*** 2925,2929 ****
  /* Here we handle stop signals while we are running not as a login shell. */
  static sighandler
! stop_signal_handler (sig)
       int sig;
  {
--- 3006,3010 ----
  /* Here we handle stop signals while we are running not as a login shell. */
  static sighandler
! sigstop_sighandler (sig)
       int sig;
  {
***************
*** 2932,2938 ****
    set_signal_handler (SIGTTIN, old_ttin);
  
!   old_cont = set_signal_handler (SIGCONT, cont_signal_handler);
  
!   give_terminal_to (shell_pgrp);
  
    kill (getpid (), sig);
--- 3013,3019 ----
    set_signal_handler (SIGTTIN, old_ttin);
  
!   old_cont = set_signal_handler (SIGCONT, sigcont_sighandler);
  
!   give_terminal_to (shell_pgrp, 0);
  
    kill (getpid (), sig);
***************
*** 2943,2948 ****
  /* Give the terminal to PGRP.  */
  int
! give_terminal_to (pgrp)
       pid_t pgrp;
  {
    sigset_t set, oset;
--- 3024,3030 ----
  /* Give the terminal to PGRP.  */
  int
! give_terminal_to (pgrp, force)
       pid_t pgrp;
+      int force;
  {
    sigset_t set, oset;
***************
*** 2950,2954 ****
  
    r = 0;
!   if (job_control)
      {
        sigemptyset (&set);
--- 3032,3036 ----
  
    r = 0;
!   if (job_control || force)
      {
        sigemptyset (&set);
***************
*** 3079,3101 ****
        /* Count the number of dead jobs */
        for (i = ndead = 0; force == 0 && i < job_slots; i++)
!         {
!           if (jobs[i] && DEADJOB (i))
  	    ndead++;
!         }
  
        /* Don't do anything if the number of jobs is less than CHILD_MAX and
  	 we're not forcing a cleanup. */
        if (force == 0 && ndead <= CHILD_MAX)
!         {
!           UNBLOCK_CHILD (oset);
!           return;
!         }
  
        /* Mark enough dead jobs as notified that we keep CHILD_MAX jobs in
!          the list.  This isn't exactly right yet; changes need to be made
!          to stop_pipeline so we don't mark the newer jobs after we've
!          created CHILD_MAX slots in the jobs array. */
        for (i = 0; i < job_slots; i++)
!         {
  	  if (jobs[i] && DEADJOB (i) && (interactive_shell || (find_last_pid (i) != last_asynchronous_pid)))
  	    {
--- 3161,3183 ----
        /* Count the number of dead jobs */
        for (i = ndead = 0; force == 0 && i < job_slots; i++)
! 	{
! 	  if (jobs[i] && DEADJOB (i))
  	    ndead++;
! 	}
  
        /* Don't do anything if the number of jobs is less than CHILD_MAX and
  	 we're not forcing a cleanup. */
        if (force == 0 && ndead <= CHILD_MAX)
! 	{
! 	  UNBLOCK_CHILD (oset);
! 	  return;
! 	}
  
        /* Mark enough dead jobs as notified that we keep CHILD_MAX jobs in
! 	 the list.  This isn't exactly right yet; changes need to be made
! 	 to stop_pipeline so we don't mark the newer jobs after we've
! 	 created CHILD_MAX slots in the jobs array. */
        for (i = 0; i < job_slots; i++)
! 	{
  	  if (jobs[i] && DEADJOB (i) && (interactive_shell || (find_last_pid (i) != last_asynchronous_pid)))
  	    {
***************
*** 3104,3108 ****
  		break;
  	    }
!         }
  
        UNBLOCK_CHILD (oset);
--- 3186,3190 ----
  		break;
  	    }
! 	}
  
        UNBLOCK_CHILD (oset);
***************
*** 3153,3157 ****
  
        if (original_pgrp >= 0)
! 	give_terminal_to (original_pgrp);
      }
  
--- 3235,3239 ----
  
        if (original_pgrp >= 0)
! 	give_terminal_to (original_pgrp, 1);
      }
  
***************
*** 3221,3252 ****
  
  #endif /* PGRP_PIPE */
- 
- static void
- setjstatus (j)
-      int j;
- {
- #if defined (ARRAY_VARS)
-   register int i;
-   register PROCESS *p;
- 
-   for (i = 1, p = jobs[j]->pipe; p->next != jobs[j]->pipe; p = p->next, i++)
-     ;
-   i++;
-   if (statsize <= i)
-     {
-       pstatuses = (int *)xrealloc (pstatuses, i * sizeof (int));
-       statsize = i;
-     }
-   i = 0;
-   p = jobs[j]->pipe;
-   do
-     {
-       pstatuses[i++] = process_exit_status (p->status);
-       p = p->next;
-     }
-   while (p != jobs[j]->pipe);
- 
-   pstatuses[i] = -1;	/* sentinel */
-   set_pipestatus_array (pstatuses);
- #endif
- }
--- 3303,3304 ----
diff -Nrc2 bash-2.04/jobs.h bash-2.05/jobs.h
*** bash-2.04/jobs.h	Thu Aug  5 07:08:24 1999
--- bash-2.05/jobs.h	Mon Mar 26 11:03:37 2001
***************
*** 152,156 ****
  extern int initialize_job_control __P((int));
  extern void initialize_job_signals __P((void));
! extern int give_terminal_to __P((pid_t));
  
  extern void set_sigwinch_handler __P((void));
--- 152,156 ----
  extern int initialize_job_control __P((int));
  extern void initialize_job_signals __P((void));
! extern int give_terminal_to __P((pid_t, int));
  
  extern void set_sigwinch_handler __P((void));
diff -Nrc2 bash-2.04/lib/glob/fnmatch.c bash-2.05/lib/glob/fnmatch.c
*** bash-2.04/lib/glob/fnmatch.c	Wed Sep 22 16:31:02 1999
--- bash-2.05/lib/glob/fnmatch.c	Fri Mar 16 13:24:27 2001
***************
*** 10,19 ****
     Software Foundation; either version 2, or (at your option) any later
     version.
!               
     Bash is distributed in the hope that it will be useful, but WITHOUT ANY
     WARRANTY; without even the implied warranty of MERCHANTABILITY or
     FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
     for more details.
!                          
     You should have received a copy of the GNU General Public License along
     with Bash; see the file COPYING.  If not, write to the Free Software
--- 10,19 ----
     Software Foundation; either version 2, or (at your option) any later
     version.
! 	      
     Bash is distributed in the hope that it will be useful, but WITHOUT ANY
     WARRANTY; without even the implied warranty of MERCHANTABILITY or
     FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
     for more details.
! 			 
     You should have received a copy of the GNU General Public License along
     with Bash; see the file COPYING.  If not, write to the Free Software
***************
*** 23,27 ****
  
  #include <stdio.h>	/* for debugging */
!                                 
  #include "fnmatch.h"
  #include "collsyms.h"
--- 23,27 ----
  
  #include <stdio.h>	/* for debugging */
! 				
  #include "fnmatch.h"
  #include "collsyms.h"
***************
*** 69,84 ****
  #endif
  
! /* We don't use strcoll(3) for range comparisons in bracket expressions,
!    even if we have it, since it can have unwanted side effects in locales
     other than POSIX or US.  For instance, in the de locale, [A-Z] matches
!    all characters.  So, for ranges we use ASCII collation, and for
!    collating symbol equivalence we use strcoll().  The casts to int are
!    to handle tests that use unsigned chars. */
! 
! #define rangecmp(c1, c2)	((int)(c1) - (int)(c2))
  
  #if defined (HAVE_STRCOLL)
  /* Helper function for collating symbol equivalence. */
! static int rangecmp2 (c1, c2)
       int c1, c2;
  {
--- 69,80 ----
  #endif
  
! /* We use strcoll(3) for range comparisons in bracket expressions,
!    even though it can have unwanted side effects in locales
     other than POSIX or US.  For instance, in the de locale, [A-Z] matches
!    all characters. */
  
  #if defined (HAVE_STRCOLL)
  /* Helper function for collating symbol equivalence. */
! static int rangecmp (c1, c2)
       int c1, c2;
  {
***************
*** 102,106 ****
  }
  #else /* !HAVE_STRCOLL */
! #  define rangecmp2(c1, c2)	((int)(c1) - (int)(c2))
  #endif /* !HAVE_STRCOLL */
  
--- 98,102 ----
  }
  #else /* !HAVE_STRCOLL */
! #  define rangecmp(c1, c2)	((int)(c1) - (int)(c2))
  #endif /* !HAVE_STRCOLL */
  
***************
*** 109,113 ****
       int c1, c2;
  {
!   return (rangecmp2 (c1, c2) == 0);
  }
  #else
--- 105,109 ----
       int c1, c2;
  {
!   return (rangecmp (c1, c2) == 0);
  }
  #else
***************
*** 125,129 ****
      {
        if (STREQN(csp->name, s, len) && csp->name[len] == '\0')
!         return (csp->code);
      }
    if (len == 1)
--- 121,125 ----
      {
        if (STREQN(csp->name, s, len) && csp->name[len] == '\0')
! 	return (csp->code);
      }
    if (len == 1)
***************
*** 167,170 ****
--- 163,171 ----
      return FNM_NOMATCH;
  
+ #if DEBUG_MATCHING
+ fprintf(stderr, "gmatch: string = %s; se = %s\n", string, se);
+ fprintf(stderr, "gmatch: pattern = %s; pe = %s\n", pattern, pe);
+ #endif
+ 
    while (p < pe)
      {
***************
*** 271,275 ****
  #endif
  	      if (p == pe)
! 	        break;
  	    }
  
--- 272,276 ----
  #endif
  	      if (p == pe)
! 		break;
  	    }
  
***************
*** 291,295 ****
  		   possible match.  We can check the first character if
  		   we're not doing an extended glob match. */
! 		if ((flags & FNM_EXTMATCH) == 0 && c != '[' && FOLD (*n) != c1)
  		  continue;
  
--- 292,296 ----
  		   possible match.  We can check the first character if
  		   we're not doing an extended glob match. */
! 		if ((flags & FNM_EXTMATCH) == 0 && c != '[' && FOLD (*n) != c1) /*]*/
  		  continue;
  
***************
*** 298,302 ****
  		   character. */
  		if ((flags & FNM_EXTMATCH) && p[1] != '(' && /*)*/
! 		    strchr ("?*+@!", *p) == 0 && c != '[' && FOLD (*n) != c1)
  		  continue;
  
--- 299,303 ----
  		   character. */
  		if ((flags & FNM_EXTMATCH) && p[1] != '(' && /*)*/
! 		    strchr ("?*+@!", *p) == 0 && c != '[' && FOLD (*n) != c1) /*]*/
  		  continue;
  
***************
*** 340,344 ****
      /* The FNM_LEADING_DIR flag says that "foo*" matches "foobar/frobozz".  */
      return 0;
!           
    return (FNM_NOMATCH);
  }
--- 341,345 ----
      /* The FNM_LEADING_DIR flag says that "foo*" matches "foobar/frobozz".  */
      return 0;
! 	  
    return (FNM_NOMATCH);
  }
***************
*** 356,360 ****
  
    p++;				/* move past the `.' */
!           
    for (pc = 0; p[pc]; pc++)
      if (p[pc] == '.' && p[pc+1] == ']')
--- 357,361 ----
  
    p++;				/* move past the `.' */
! 	  
    for (pc = 0; p[pc]; pc++)
      if (p[pc] == '.' && p[pc+1] == ']')
***************
*** 383,387 ****
    /* POSIX.2 3.13.1 says that an exclamation mark (`!') shall replace the
       circumflex (`^') in its role in a `nonmatching list'.  A bracket
!      expression starging with an unquoted circumflex character produces
       unspecified results.  This implementation treats the two identically. */
    if (not = (*p == '!' || *p == '^'))
--- 384,388 ----
    /* POSIX.2 3.13.1 says that an exclamation mark (`!') shall replace the
       circumflex (`^') in its role in a `nonmatching list'.  A bracket
!      expression starting with an unquoted circumflex character produces
       unspecified results.  This implementation treats the two identically. */
    if (not = (*p == '!' || *p == '^'))
***************
*** 405,421 ****
  	  p += 4;
  	  if (collequiv (test, pc))
! 	    goto matched;
  	  else
  	    {
  	      c = *p++;
  	      if (c == '\0')
! 		return ((test == '[') ? savep : (char *)0);
  	      c = FOLD (c);
  	      continue;
  	    }
!         }
  
        /* POSIX.2 character class expression.  See POSIX.2 2.8.3.2. */
!       if (c == '[' && *p == ':')
  	{
  	  pc = 0;	/* make sure invalid char classes don't match. */
--- 406,427 ----
  	  p += 4;
  	  if (collequiv (test, pc))
! 	    {
! /*[*/	      /* Move past the closing `]', since the first thing we do at
! 		 the `matched:' label is back p up one. */
! 	      p++;
! 	      goto matched;
! 	    }
  	  else
  	    {
  	      c = *p++;
  	      if (c == '\0')
! 		return ((test == '[') ? savep : (char *)0); /*]*/
  	      c = FOLD (c);
  	      continue;
  	    }
! 	}
  
        /* POSIX.2 character class expression.  See POSIX.2 2.8.3.2. */
!       if (c == '[' && *p == ':')	/*]*/
  	{
  	  pc = 0;	/* make sure invalid char classes don't match. */
***************
*** 447,451 ****
--- 453,462 ----
  	    { pc = isascii (test); p += 8; }
  	  if (pc)
+ 	    {
+ /*[*/	      /* Move past the closing `]', since the first thing we do at
+ 		 the `matched:' label is back p up one. */
+ 	      p++;
  	      goto matched;
+ 	    }
  	  else
  	    {
***************
*** 456,460 ****
  		return ((test == '[') ? savep : (char *)0);
  	      else if (c == ']')
! 	        break;
  	      c = FOLD (c);
  	      continue;
--- 467,471 ----
  		return ((test == '[') ? savep : (char *)0);
  	      else if (c == ']')
! 		break;
  	      c = FOLD (c);
  	      continue;
***************
*** 529,533 ****
  	    {
  	      if (c == ']')
! 	        break;
  	      c = FOLD (c);
  	      continue;
--- 540,544 ----
  	    {
  	      if (c == ']')
! 		break;
  	      c = FOLD (c);
  	      continue;
***************
*** 546,550 ****
--- 557,566 ----
  matched:
    /* Skip the rest of the [...] that already matched.  */
+ #if 0
    brcnt = (c != ']') + (c == '[' && (*p == '=' || *p == ':' || *p == '.'));
+ #else
+   c = *--p;
+   brcnt = 1;
+ #endif
    while (brcnt > 0)
      {
***************
*** 555,561 ****
        c = *p++;
        if (c == '[' && (*p == '=' || *p == ':' || *p == '.'))
!         brcnt++;
        else if (c == ']')
!         brcnt--;
        else if (!(flags & FNM_NOESCAPE) && c == '\\')
  	{
--- 571,577 ----
        c = *p++;
        if (c == '[' && (*p == '=' || *p == ':' || *p == '.'))
! 	brcnt++;
        else if (c == ']')
! 	brcnt--;
        else if (!(flags & FNM_NOESCAPE) && c == '\\')
  	{
***************
*** 594,620 ****
       int delim;
  {
!   int pnest, bnest;
!   char *s, c;
  
!   pnest = bnest = 0;
    for (s = string; c = *s; s++)
      {
        if (s >= end)
!         return (s);
        switch (c)
  	{
  	case '\0':
  	  return ((char *)0);
  	case '[':
! 	  bnest++;
  	  break;
  	case ']':
  	  if (bnest)
! 	    bnest--;
  	  break;
  	case '(':
  	  if (bnest == 0)
  	    pnest++;
  	  break;
  	case ')':
  #if 0
--- 610,663 ----
       int delim;
  {
!   int pnest, bnest, cchar;
!   char *s, c, *bfirst;
  
!   pnest = bnest = cchar = 0;
!   bfirst = 0;
    for (s = string; c = *s; s++)
      {
        if (s >= end)
! 	return (s);
        switch (c)
  	{
  	case '\0':
  	  return ((char *)0);
+ 
+ 	/* `[' is not special inside a bracket expression, but it may
+ 	   introduce one of the special POSIX bracket expressions
+ 	   ([.SYM.], [=c=], [: ... :]) that needs special handling. */
  	case '[':
! 	  if (bnest == 0)
! 	    {
! 	      bfirst = s + 1;
! 	      if (*bfirst == '!' || *bfirst == '^')
! 		bfirst++;
! 	      bnest++;
! 	    }
! 	  else if (s[1] == ':' || s[1] == '.' || s[1] == '=')
! 	    cchar = s[1];
  	  break;
+ 
+ 	/* `]' is not special if it's the first char (after a leading `!'
+ 	   or `^') in a bracket expression or if it's part of one of the
+ 	   special POSIX bracket expressions ([.SYM.], [=c=], [: ... :]) */
  	case ']':
  	  if (bnest)
! 	    {
! 	      if (cchar && s[-1] == cchar)
! 		cchar = 0;
! 	      else if (s != bfirst)
! 		{
! 		  bnest--;
! 		  bfirst = 0;
! 		}
! 	    }
  	  break;
+ 
  	case '(':
  	  if (bnest == 0)
  	    pnest++;
  	  break;
+ 
  	case ')':
  #if 0
***************
*** 628,631 ****
--- 671,675 ----
  #endif
  	  break;
+ 
  	case '|':
  	  if (bnest == 0 && pnest == 0 && delim == '|')
***************
*** 679,683 ****
    int m1, m2;
  
! #if 0
  fprintf(stderr, "extmatch: xc = %c\n", xc);
  fprintf(stderr, "extmatch: s = %s; se = %s\n", s, se);
--- 723,727 ----
    int m1, m2;
  
! #if DEBUG_MATCHING
  fprintf(stderr, "extmatch: xc = %c\n", xc);
  fprintf(stderr, "extmatch: s = %s; se = %s\n", s, se);
***************
*** 702,707 ****
  
        /* OK, we have to do this the hard way.  First, we make sure one of
!          the subpatterns matches, then we try to match the rest of the
!          string. */
        for (psub = p + 1; ; psub = pnext)
  	{
--- 746,751 ----
  
        /* OK, we have to do this the hard way.  First, we make sure one of
! 	 the subpatterns matches, then we try to match the rest of the
! 	 string. */
        for (psub = p + 1; ; psub = pnext)
  	{
***************
*** 719,723 ****
  		      (s != srest && gmatch (srest, se, p - 1, pe, flags) == 0);
  	      if (m1 && m2)
! 	        return (0);
  	    }
  	  if (pnext == prest)
--- 763,767 ----
  		      (s != srest && gmatch (srest, se, p - 1, pe, flags) == 0);
  	      if (m1 && m2)
! 		return (0);
  	    }
  	  if (pnext == prest)
***************
*** 766,770 ****
  	    }
  	  if (m1 == 0 && gmatch (srest, se, prest, pe, flags) == 0)
! 	    return (0);	
  	}
        return (FNM_NOMATCH);
--- 810,814 ----
  	    }
  	  if (m1 == 0 && gmatch (srest, se, prest, pe, flags) == 0)
! 	    return (0);
  	}
        return (FNM_NOMATCH);
diff -Nrc2 bash-2.04/lib/glob/glob.c bash-2.05/lib/glob/glob.c
*** bash-2.04/lib/glob/glob.c	Mon Feb 14 15:44:54 2000
--- bash-2.05/lib/glob/glob.c	Wed Feb 14 16:53:39 2001
***************
*** 344,348 ****
  
        /* Compute the flags that will be passed to fnmatch().  We don't
!          need to do this every time through the loop. */
        flags = (noglob_dot_filenames ? FNM_PERIOD : 0) | FNM_PATHNAME;
  
--- 344,348 ----
  
        /* Compute the flags that will be passed to fnmatch().  We don't
! 	 need to do this every time through the loop. */
        flags = (noglob_dot_filenames ? FNM_PERIOD : 0) | FNM_PATHNAME;
  
***************
*** 481,492 ****
        if (result[i] == NULL)
  	return (NULL);
! #if 1
        strcpy (result[i], dir);
        if (add_slash)
!         result[i][l] = '/';
        strcpy (result[i] + l + add_slash, array[i]);
- #else
-       (void)sprintf (result[i], "%s%s%s", dir, add_slash ? "/" : "", array[i]);
- #endif
      }
    result[i] = NULL;
--- 481,489 ----
        if (result[i] == NULL)
  	return (NULL);
! 
        strcpy (result[i], dir);
        if (add_slash)
! 	result[i][l] = '/';
        strcpy (result[i] + l + add_slash, array[i]);
      }
    result[i] = NULL;
diff -Nrc2 bash-2.04/lib/malloc/gmalloc.c bash-2.05/lib/malloc/gmalloc.c
*** bash-2.04/lib/malloc/gmalloc.c	Thu Aug  5 07:58:03 1999
--- bash-2.05/lib/malloc/gmalloc.c	Wed Feb 14 17:01:40 2001
***************
*** 652,656 ****
  	      if (_heaplimit != 0 && block + lastblocks == _heaplimit &&
  		  /* We can't do this if we will have to make the heap info
!                      table bigger to accomodate the new space.  */
  		  block + wantblocks <= heapsize &&
  		  get_contiguous_space ((wantblocks - lastblocks) * BLOCKSIZE,
--- 652,656 ----
  	      if (_heaplimit != 0 && block + lastblocks == _heaplimit &&
  		  /* We can't do this if we will have to make the heap info
! 		     table bigger to accomodate the new space.  */
  		  block + wantblocks <= heapsize &&
  		  get_contiguous_space ((wantblocks - lastblocks) * BLOCKSIZE,
***************
*** 1166,1170 ****
  		 have been coalesced with its neighbors.  */
  	      if (_heapindex == block)
! 	        (void) imalloc (blocks * BLOCKSIZE);
  	      else
  		{
--- 1166,1170 ----
  		 have been coalesced with its neighbors.  */
  	      if (_heapindex == block)
! 		(void) imalloc (blocks * BLOCKSIZE);
  	      else
  		{
diff -Nrc2 bash-2.04/lib/malloc/malloc.c bash-2.05/lib/malloc/malloc.c
*** bash-2.04/lib/malloc/malloc.c	Fri Oct  1 15:39:32 1999
--- bash-2.05/lib/malloc/malloc.c	Wed Feb 14 17:01:50 2001
***************
*** 279,282 ****
--- 279,287 ----
  static int maxbuck;	/* highest bucket receiving allocation request. */
  
+ #ifdef SHELL
+ extern int interrupt_immediately;
+ extern int signal_is_trapped ();
+ #endif
+ 
  #if 0
  /* Coalesce two adjacent free blocks off the free list for size NU - 1,
***************
*** 401,404 ****
--- 406,437 ----
  
  static void
+ block_signals (setp, osetp)
+      sigset_t *setp, *osetp;
+ {
+ #ifdef HAVE_POSIX_SIGNALS
+   sigfillset (setp);
+   sigemptyset (osetp);
+   sigprocmask (SIG_BLOCK, setp, osetp);
+ #else
+ #  if defined (HAVE_BSD_SIGNALS)
+   *osetp = sigsetmask (-1);
+ #  endif
+ #endif
+ }
+ 
+ static void
+ unblock_signals (setp, osetp)
+      sigset_t *setp, *osetp;
+ {
+ #ifdef HAVE_POSIX_SIGNALS
+   sigprocmask (SIG_SETMASK, osetp, (sigset_t *)NULL);
+ #else
+ #  if defined (HAVE_BSD_SIGNALS)
+   sigsetmask (*osetp);
+ #  endif
+ #endif
+ }
+   
+ static void
  morecore (nu)			/* ask system for more memory */
       register int nu;		/* size index to get more of  */
***************
*** 408,424 ****
    register long siz;
    long sbrk_amt;		/* amount to get via sbrk() */
  
    /* Block all signals in case we are executed from a signal handler. */
! #if defined (HAVE_BSD_SIGNALS)
!   int oldmask;
!   oldmask = sigsetmask (-1);
! #else
! #  if defined (HAVE_POSIX_SIGNALS)
!   sigset_t set, oset;
!   sigfillset (&set);
!   sigemptyset (&oset);
!   sigprocmask (SIG_BLOCK, &set, &oset);
! #  endif /* HAVE_POSIX_SIGNALS */
! #endif /* HAVE_BSD_SIGNALS */
  
    siz = 1 << (nu + 3);	/* size of desired block for nextf[nu] */
--- 441,456 ----
    register long siz;
    long sbrk_amt;		/* amount to get via sbrk() */
+   sigset_t set, oset;
+   int blocked_sigs;
  
    /* Block all signals in case we are executed from a signal handler. */
!   blocked_sigs = 0;
! #ifdef SHELL
!   if (interrupt_immediately || signal_is_trapped (SIGINT) || signal_is_trapped (SIGCHLD))
! #endif
!     {
!       block_signals (&set, &oset);
!       blocked_sigs = 1;
!     }
  
    siz = 1 << (nu + 3);	/* size of desired block for nextf[nu] */
***************
*** 451,455 ****
        bcoalesce (nu);
        if (nextf[nu] != 0)
!         goto morecore_done;
      }
  #endif
--- 483,487 ----
        bcoalesce (nu);
        if (nextf[nu] != 0)
! 	goto morecore_done;
      }
  #endif
***************
*** 508,520 ****
  
  morecore_done:
! #if defined (HAVE_BSD_SIGNALS)
!   sigsetmask (oldmask);
! #else
! #  if defined (HAVE_POSIX_SIGNALS)
!   sigprocmask (SIG_SETMASK, &oset, (sigset_t *)NULL);
! #  else
!   ; /* nothing to do, but need a null statement before the brace */
! #  endif
! #endif /* HAVE_BSD_SIGNALS */
  }
  
--- 540,545 ----
  
  morecore_done:
!   if (blocked_sigs)
!     unblock_signals (&set, &oset);
  }
  
***************
*** 558,585 ****
        pagesz = getpagesize ();
        if (pagesz < 1024)
!         pagesz = 1024;
        /* OK, how much do we need to allocate to make things page-aligned?
!          This partial page is wasted space.  Once we figure out how much
!          to advance the break pointer, go ahead and do it. */
        sbrk_needed = pagesz - ((long)sbrk (0) & (pagesz - 1));	/* sbrk(0) % pagesz */
        if (sbrk_needed < 0)
!         sbrk_needed += pagesz;
        /* Now allocate the wasted space. */
        if (sbrk_needed)
!         {
  #ifdef MALLOC_STATS
  	  _mstats.nsbrk++;
  	  _mstats.tsbrk += sbrk_needed;
  #endif
!           if ((long)sbrk (sbrk_needed) == -1)
!             return (NULL);
!         }
        nunits = 0;
        nbytes = 8;
        while (pagesz > nbytes)
!         {
!           nbytes <<= 1;
!           nunits++;
!         }
        pagebucket = nunits;
      }
--- 583,610 ----
        pagesz = getpagesize ();
        if (pagesz < 1024)
! 	pagesz = 1024;
        /* OK, how much do we need to allocate to make things page-aligned?
! 	 This partial page is wasted space.  Once we figure out how much
! 	 to advance the break pointer, go ahead and do it. */
        sbrk_needed = pagesz - ((long)sbrk (0) & (pagesz - 1));	/* sbrk(0) % pagesz */
        if (sbrk_needed < 0)
! 	sbrk_needed += pagesz;
        /* Now allocate the wasted space. */
        if (sbrk_needed)
! 	{
  #ifdef MALLOC_STATS
  	  _mstats.nsbrk++;
  	  _mstats.tsbrk += sbrk_needed;
  #endif
! 	  if ((long)sbrk (sbrk_needed) == -1)
! 	    return (NULL);
! 	}
        nunits = 0;
        nbytes = 8;
        while (pagesz > nbytes)
! 	{
! 	  nbytes <<= 1;
! 	  nunits++;
! 	}
        pagebucket = nunits;
      }
***************
*** 606,613 ****
        amt = pagesz;
        while (nbytes > amt)
!         {
!           amt <<= 1;
!           nunits++;
!         }
      }
  
--- 631,638 ----
        amt = pagesz;
        while (nbytes > amt)
! 	{
! 	  amt <<= 1;
! 	  nunits++;
! 	}
      }
  
***************
*** 925,928 ****
--- 950,954 ----
  void
  print_malloc_stats (s)
+      char *s;
  {
    _print_malloc_stats (s, stderr);
***************
*** 934,937 ****
--- 960,964 ----
  void
  trace_malloc_stats (s)
+      char *s;
  {
    char ibuf[32], *ip;
diff -Nrc2 bash-2.04/lib/readline/COPYING bash-2.05/lib/readline/COPYING
*** bash-2.04/lib/readline/COPYING	Thu Aug  5 08:40:59 1999
--- bash-2.05/lib/readline/COPYING	Thu Aug  5 10:46:22 1999
***************
*** 306,310 ****
      You should have received a copy of the GNU General Public License
      along with this program; if not, write to the Free Software
!     Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  
  Also add information on how to contact you by electronic and paper mail.
--- 306,310 ----
      You should have received a copy of the GNU General Public License
      along with this program; if not, write to the Free Software
!     Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA
  
  Also add information on how to contact you by electronic and paper mail.
diff -Nrc2 bash-2.04/lib/readline/Makefile.in bash-2.05/lib/readline/Makefile.in
*** bash-2.04/lib/readline/Makefile.in	Thu Aug  5 10:55:05 1999
--- bash-2.05/lib/readline/Makefile.in	Mon Nov 27 12:09:48 2000
***************
*** 73,82 ****
  	   $(srcdir)/history.c $(srcdir)/histsearch.c $(srcdir)/histexpand.c \
  	   $(srcdir)/histfile.c $(srcdir)/nls.c $(srcdir)/search.c \
! 	   $(srcdir)/shell.c $(srcdir)/tilde.c $(srcdir)/savestring.c
  
  # The header files for this library.
  HSOURCES = readline.h rldefs.h chardefs.h keymaps.h history.h histlib.h \
  	   posixstat.h posixdir.h posixjmp.h tilde.h rlconf.h rltty.h \
! 	   ansi_stdlib.h rlstdc.h tcap.h rlprivate.h rlshell.h
  
  HISTOBJ = history.o histexpand.o histfile.o histsearch.o shell.o savestring.o
--- 73,84 ----
  	   $(srcdir)/history.c $(srcdir)/histsearch.c $(srcdir)/histexpand.c \
  	   $(srcdir)/histfile.c $(srcdir)/nls.c $(srcdir)/search.c \
! 	   $(srcdir)/shell.c $(srcdir)/tilde.c $(srcdir)/savestring.c \
! 	   $(srcdir)/compat.c
  
  # The header files for this library.
  HSOURCES = readline.h rldefs.h chardefs.h keymaps.h history.h histlib.h \
  	   posixstat.h posixdir.h posixjmp.h tilde.h rlconf.h rltty.h \
! 	   ansi_stdlib.h rlstdc.h tcap.h xmalloc.h rlprivate.h rlshell.h \
! 	   rltypedefs.h
  
  HISTOBJ = history.o histexpand.o histfile.o histsearch.o shell.o savestring.o
***************
*** 85,89 ****
  	  rltty.o complete.o bind.o isearch.o display.o signals.o \
  	  util.o kill.o undo.o macro.o input.o callback.o terminal.o \
! 	  nls.o $(HISTOBJ) $(TILDEOBJ) xmalloc.o
  
  # The texinfo files which document this library.
--- 87,91 ----
  	  rltty.o complete.o bind.o isearch.o display.o signals.o \
  	  util.o kill.o undo.o macro.o input.o callback.o terminal.o \
! 	  nls.o $(HISTOBJ) $(TILDEOBJ) xmalloc.o compat.o
  
  # The texinfo files which document this library.
***************
*** 99,103 ****
  THINGS_TO_TAR = $(SOURCES) $(SUPPORT)
  
! INSTALLED_HEADERS = readline.h chardefs.h keymaps.h history.h tilde.h
  
  ##########################################################################
--- 101,106 ----
  THINGS_TO_TAR = $(SOURCES) $(SUPPORT)
  
! INSTALLED_HEADERS = readline.h chardefs.h keymaps.h history.h tilde.h \
! 		    rlstdc.h rlconf.h rltypedefs.h
  
  ##########################################################################
***************
*** 148,165 ****
  bind.o: ansi_stdlib.h posixstat.h
  bind.o: rldefs.h ${BUILD_DIR}/config.h rlconf.h
! bind.o: readline.h keymaps.h chardefs.h tilde.h
  bind.o: history.h rlstdc.h
  callback.o: rlconf.h
  callback.o: rldefs.h ${BUILD_DIR}/config.h rlconf.h
! callback.o: readline.h keymaps.h chardefs.h tilde.h rlstdc.h
  complete.o: ansi_stdlib.h posixdir.h posixstat.h
  complete.o: rldefs.h ${BUILD_DIR}/config.h rlconf.h
! complete.o: readline.h keymaps.h chardefs.h tilde.h rlstdc.h
  display.o: ansi_stdlib.h posixstat.h
  display.o: rldefs.h ${BUILD_DIR}/config.h rlconf.h
  display.o: tcap.h
! display.o: readline.h keymaps.h chardefs.h tilde.h
  display.o: history.h rlstdc.h
! funmap.o: readline.h keymaps.h chardefs.h tilde.h
  funmap.o: rlconf.h ansi_stdlib.h rlstdc.h
  funmap.o: ${BUILD_DIR}/config.h
--- 151,169 ----
  bind.o: ansi_stdlib.h posixstat.h
  bind.o: rldefs.h ${BUILD_DIR}/config.h rlconf.h
! bind.o: readline.h keymaps.h rltypedefs.h chardefs.h tilde.h
  bind.o: history.h rlstdc.h
  callback.o: rlconf.h
  callback.o: rldefs.h ${BUILD_DIR}/config.h rlconf.h
! callback.o: readline.h keymaps.h rltypedefs.h chardefs.h tilde.h rlstdc.h
! compat.o: rlstdc.h
  complete.o: ansi_stdlib.h posixdir.h posixstat.h
  complete.o: rldefs.h ${BUILD_DIR}/config.h rlconf.h
! complete.o: readline.h keymaps.h rltypedefs.h chardefs.h tilde.h rlstdc.h
  display.o: ansi_stdlib.h posixstat.h
  display.o: rldefs.h ${BUILD_DIR}/config.h rlconf.h
  display.o: tcap.h
! display.o: readline.h keymaps.h rltypedefs.h chardefs.h tilde.h
  display.o: history.h rlstdc.h
! funmap.o: readline.h keymaps.h rltypedefs.h chardefs.h tilde.h
  funmap.o: rlconf.h ansi_stdlib.h rlstdc.h
  funmap.o: ${BUILD_DIR}/config.h
***************
*** 178,205 ****
  input.o: ansi_stdlib.h
  input.o: rldefs.h ${BUILD_DIR}/config.h rlconf.h
! input.o: readline.h keymaps.h chardefs.h tilde.h rlstdc.h
  isearch.o: rldefs.h ${BUILD_DIR}/config.h rlconf.h
! isearch.o: readline.h keymaps.h chardefs.h tilde.h
  isearch.o: ansi_stdlib.h history.h rlstdc.h
  keymaps.o: emacs_keymap.c vi_keymap.c
! keymaps.o: keymaps.h chardefs.h rlconf.h ansi_stdlib.h
! keymaps.o: readline.h keymaps.h chardefs.h tilde.h
  keymaps.o: ${BUILD_DIR}/config.h rlstdc.h
  kill.o: ansi_stdlib.h
  kill.o: rldefs.h ${BUILD_DIR}/config.h rlconf.h
! kill.o: readline.h keymaps.h chardefs.h tilde.h
  kill.o: history.h rlstdc.h
  macro.o: ansi_stdlib.h
  macro.o: rldefs.h ${BUILD_DIR}/config.h rlconf.h
! macro.o: readline.h keymaps.h chardefs.h tilde.h
  macro.o: history.h rlstdc.h
  nls.o: ansi_stdlib.h
  nls.o: rldefs.h ${BUILD_DIR}/config.h rlconf.h
! nls.o: readline.h keymaps.h chardefs.h tilde.h
  nls.o: history.h rlstdc.h
  parens.o: rlconf.h
  parens.o: ${BUILD_DIR}/config.h
! parens.o: readline.h keymaps.h chardefs.h tilde.h rlstdc.h
! readline.o: readline.h keymaps.h chardefs.h tilde.h
  readline.o: rldefs.h ${BUILD_DIR}/config.h rlconf.h
  readline.o: history.h rlstdc.h
--- 182,209 ----
  input.o: ansi_stdlib.h
  input.o: rldefs.h ${BUILD_DIR}/config.h rlconf.h
! input.o: readline.h keymaps.h rltypedefs.h chardefs.h tilde.h rlstdc.h
  isearch.o: rldefs.h ${BUILD_DIR}/config.h rlconf.h
! isearch.o: readline.h keymaps.h rltypedefs.h chardefs.h tilde.h
  isearch.o: ansi_stdlib.h history.h rlstdc.h
  keymaps.o: emacs_keymap.c vi_keymap.c
! keymaps.o: keymaps.h rltypedefs.h chardefs.h rlconf.h ansi_stdlib.h
! keymaps.o: readline.h keymaps.h rltypedefs.h chardefs.h tilde.h
  keymaps.o: ${BUILD_DIR}/config.h rlstdc.h
  kill.o: ansi_stdlib.h
  kill.o: rldefs.h ${BUILD_DIR}/config.h rlconf.h
! kill.o: readline.h keymaps.h rltypedefs.h chardefs.h tilde.h
  kill.o: history.h rlstdc.h
  macro.o: ansi_stdlib.h
  macro.o: rldefs.h ${BUILD_DIR}/config.h rlconf.h
! macro.o: readline.h keymaps.h rltypedefs.h chardefs.h tilde.h
  macro.o: history.h rlstdc.h
  nls.o: ansi_stdlib.h
  nls.o: rldefs.h ${BUILD_DIR}/config.h rlconf.h
! nls.o: readline.h keymaps.h rltypedefs.h chardefs.h tilde.h
  nls.o: history.h rlstdc.h
  parens.o: rlconf.h
  parens.o: ${BUILD_DIR}/config.h
! parens.o: readline.h keymaps.h rltypedefs.h chardefs.h tilde.h rlstdc.h
! readline.o: readline.h keymaps.h rltypedefs.h chardefs.h tilde.h
  readline.o: rldefs.h ${BUILD_DIR}/config.h rlconf.h
  readline.o: history.h rlstdc.h
***************
*** 207,221 ****
  rltty.o: rldefs.h ${BUILD_DIR}/config.h rlconf.h
  rltty.o: rltty.h
! rltty.o: readline.h keymaps.h chardefs.h tilde.h rlstdc.h
  search.o: rldefs.h ${BUILD_DIR}/config.h rlconf.h
! search.o: readline.h keymaps.h chardefs.h tilde.h
  search.o: ansi_stdlib.h history.h rlstdc.h
  shell.o: ${BUILD_DIR}/config.h ansi_stdlib.h
  signals.o: rldefs.h ${BUILD_DIR}/config.h rlconf.h
! signals.o: readline.h keymaps.h chardefs.h tilde.h
  signals.o: history.h rlstdc.h
  terminal.o: rldefs.h ${BUILD_DIR}/config.h rlconf.h
  terminal.o: tcap.h
! terminal.o: readline.h keymaps.h chardefs.h tilde.h
  terminal.o: history.h rlstdc.h
  tilde.o: ansi_stdlib.h
--- 211,225 ----
  rltty.o: rldefs.h ${BUILD_DIR}/config.h rlconf.h
  rltty.o: rltty.h
! rltty.o: readline.h keymaps.h rltypedefs.h chardefs.h tilde.h rlstdc.h
  search.o: rldefs.h ${BUILD_DIR}/config.h rlconf.h
! search.o: readline.h keymaps.h rltypedefs.h chardefs.h tilde.h
  search.o: ansi_stdlib.h history.h rlstdc.h
  shell.o: ${BUILD_DIR}/config.h ansi_stdlib.h
  signals.o: rldefs.h ${BUILD_DIR}/config.h rlconf.h
! signals.o: readline.h keymaps.h rltypedefs.h chardefs.h tilde.h
  signals.o: history.h rlstdc.h
  terminal.o: rldefs.h ${BUILD_DIR}/config.h rlconf.h
  terminal.o: tcap.h
! terminal.o: readline.h keymaps.h rltypedefs.h chardefs.h tilde.h
  terminal.o: history.h rlstdc.h
  tilde.o: ansi_stdlib.h
***************
*** 224,234 ****
  undo.o: ansi_stdlib.h
  undo.o: rldefs.h ${BUILD_DIR}/config.h rlconf.h
! undo.o: readline.h keymaps.h chardefs.h tilde.h
  undo.o: history.h rlstdc.h
  util.o: posixjmp.h ansi_stdlib.h
  util.o: rldefs.h ${BUILD_DIR}/config.h rlconf.h
! util.o: readline.h keymaps.h chardefs.h tilde.h rlstdc.h
  vi_mode.o: rldefs.h ${BUILD_DIR}/config.h rlconf.h
! vi_mode.o: readline.h keymaps.h chardefs.h tilde.h
  vi_mode.o: history.h ansi_stdlib.h rlstdc.h
  xmalloc.o: ${BUILD_DIR}/config.h ansi_stdlib.h
--- 228,238 ----
  undo.o: ansi_stdlib.h
  undo.o: rldefs.h ${BUILD_DIR}/config.h rlconf.h
! undo.o: readline.h keymaps.h rltypedefs.h chardefs.h tilde.h
  undo.o: history.h rlstdc.h
  util.o: posixjmp.h ansi_stdlib.h
  util.o: rldefs.h ${BUILD_DIR}/config.h rlconf.h
! util.o: readline.h keymaps.h rltypedefs.h chardefs.h tilde.h rlstdc.h
  vi_mode.o: rldefs.h ${BUILD_DIR}/config.h rlconf.h
! vi_mode.o: readline.h keymaps.h rltypedefs.h chardefs.h tilde.h
  vi_mode.o: history.h ansi_stdlib.h rlstdc.h
  xmalloc.o: ${BUILD_DIR}/config.h ansi_stdlib.h
***************
*** 285,288 ****
--- 289,293 ----
  bind.o: bind.c
  callback.o: callback.c
+ compat.o: compat.c
  complete.o: complete.c
  display.o: display.c
diff -Nrc2 bash-2.04/lib/readline/ansi_stdlib.h bash-2.05/lib/readline/ansi_stdlib.h
*** bash-2.04/lib/readline/ansi_stdlib.h	Thu Aug  5 07:49:32 1999
--- bash-2.05/lib/readline/ansi_stdlib.h	Thu Sep  7 12:07:49 2000
***************
*** 28,31 ****
--- 28,34 ----
  extern long int atol ();
  
+ extern double atof ();
+ extern double strtod ();
+ 
  /* Memory allocation functions. */
  extern char *malloc ();
diff -Nrc2 bash-2.04/lib/readline/bind.c bash-2.05/lib/readline/bind.c
*** bash-2.04/lib/readline/bind.c	Tue Aug 24 14:19:22 1999
--- bash-2.05/lib/readline/bind.c	Mon Mar  5 10:10:07 2001
***************
*** 69,75 ****
  Keymap rl_binding_keymap;
  
! static int _rl_read_init_file __P((char *, int));
  static int glean_key_from_name __P((char *));
! static int substring_member_of_array __P((char *, char **));
  
  static int currently_reading_init_file;
--- 69,75 ----
  Keymap rl_binding_keymap;
  
! static int _rl_read_init_file __P((const char *, int));
  static int glean_key_from_name __P((char *));
! static int substring_member_of_array __P((char *, const char **));
  
  static int currently_reading_init_file;
***************
*** 84,94 ****
  /* **************************************************************** */
  
! /* rl_add_defun (char *name, Function *function, int key)
     Add NAME to the list of named functions.  Make FUNCTION be the function
     that gets called.  If KEY is not -1, then bind it. */
  int
  rl_add_defun (name, function, key)
!      char *name;
!      Function *function;
       int key;
  {
--- 84,94 ----
  /* **************************************************************** */
  
! /* rl_add_defun (char *name, rl_command_func_t *function, int key)
     Add NAME to the list of named functions.  Make FUNCTION be the function
     that gets called.  If KEY is not -1, then bind it. */
  int
  rl_add_defun (name, function, key)
!      const char *name;
!      rl_command_func_t *function;
       int key;
  {
***************
*** 103,107 ****
  rl_bind_key (key, function)
       int key;
!      Function *function;
  {
    if (key < 0)
--- 103,107 ----
  rl_bind_key (key, function)
       int key;
!      rl_command_func_t *function;
  {
    if (key < 0)
***************
*** 134,138 ****
  rl_bind_key_in_map (key, function, map)
       int key;
!      Function *function;
       Keymap map;
  {
--- 134,138 ----
  rl_bind_key_in_map (key, function, map)
       int key;
!      rl_command_func_t *function;
       Keymap map;
  {
***************
*** 153,157 ****
       int key;
  {
!   return (rl_bind_key (key, (Function *)NULL));
  }
  
--- 153,157 ----
       int key;
  {
!   return (rl_bind_key (key, (rl_command_func_t *)NULL));
  }
  
***************
*** 163,167 ****
       Keymap map;
  {
!   return (rl_bind_key_in_map (key, (Function *)NULL, map));
  }
  
--- 163,167 ----
       Keymap map;
  {
!   return (rl_bind_key_in_map (key, (rl_command_func_t *)NULL, map));
  }
  
***************
*** 169,173 ****
  int
  rl_unbind_function_in_map (func, map)
!      Function *func;
       Keymap map;
  {
--- 169,173 ----
  int
  rl_unbind_function_in_map (func, map)
!      rl_command_func_t *func;
       Keymap map;
  {
***************
*** 178,182 ****
        if (map[i].type == ISFUNC && map[i].function == func)
  	{
! 	  map[i].function = (Function *)NULL;
  	  rval = 1;
  	}
--- 178,182 ----
        if (map[i].type == ISFUNC && map[i].function == func)
  	{
! 	  map[i].function = (rl_command_func_t *)NULL;
  	  rval = 1;
  	}
***************
*** 187,194 ****
  int
  rl_unbind_command_in_map (command, map)
!      char *command;
       Keymap map;
  {
!   Function *func;
  
    func = rl_named_function (command);
--- 187,194 ----
  int
  rl_unbind_command_in_map (command, map)
!      const char *command;
       Keymap map;
  {
!   rl_command_func_t *func;
  
    func = rl_named_function (command);
***************
*** 203,208 ****
  int
  rl_set_key (keyseq, function, map)
!      char *keyseq;
!      Function *function;
       Keymap map;
  {
--- 203,208 ----
  int
  rl_set_key (keyseq, function, map)
!      const char *keyseq;
!      rl_command_func_t *function;
       Keymap map;
  {
***************
*** 215,219 ****
  int
  rl_macro_bind (keyseq, macro, map)
!      char *keyseq, *macro;
       Keymap map;
  {
--- 215,219 ----
  int
  rl_macro_bind (keyseq, macro, map)
!      const char *keyseq, *macro;
       Keymap map;
  {
***************
*** 240,244 ****
  rl_generic_bind (type, keyseq, data, map)
       int type;
!      char *keyseq, *data;
       Keymap map;
  {
--- 240,245 ----
  rl_generic_bind (type, keyseq, data, map)
       int type;
!      const char *keyseq;
!      char *data;
       Keymap map;
  {
***************
*** 310,314 ****
  int
  rl_translate_keyseq (seq, array, len)
!      char *seq, *array;
       int *len;
  {
--- 311,316 ----
  int
  rl_translate_keyseq (seq, array, len)
!      const char *seq;
!      char *array;
       int *len;
  {
***************
*** 514,520 ****
     If STRING doesn't have a matching function, then a NULL pointer
     is returned. */
! Function *
  rl_named_function (string)
!      char *string;
  {
    register int i;
--- 516,522 ----
     If STRING doesn't have a matching function, then a NULL pointer
     is returned. */
! rl_command_func_t *
  rl_named_function (string)
!      const char *string;
  {
    register int i;
***************
*** 525,529 ****
      if (_rl_stricmp (funmap[i]->name, string) == 0)
        return (funmap[i]->function);
!   return ((Function *)NULL);
  }
  
--- 527,531 ----
      if (_rl_stricmp (funmap[i]->name, string) == 0)
        return (funmap[i]->function);
!   return ((rl_command_func_t *)NULL);
  }
  
***************
*** 533,539 ****
     type of the object pointed to.  One of ISFUNC (function), ISKMAP (keymap),
     or ISMACR (macro). */
! Function *
  rl_function_of_keyseq (keyseq, map, type)
!      char *keyseq;
       Keymap map;
       int *type;
--- 535,541 ----
     type of the object pointed to.  One of ISFUNC (function), ISKMAP (keymap),
     or ISMACR (macro). */
! rl_command_func_t *
  rl_function_of_keyseq (keyseq, map, type)
!      const char *keyseq;
       Keymap map;
       int *type;
***************
*** 586,590 ****
  	}
      }
!   return ((Function *) NULL);
  }
  
--- 588,592 ----
  	}
      }
!   return ((rl_command_func_t *) NULL);
  }
  
***************
*** 593,597 ****
  
  /* The file we're currently reading key bindings from. */
! static char *current_readline_init_file;
  static int current_readline_init_include_level;
  static int current_readline_init_lineno;
--- 595,599 ----
  
  /* The file we're currently reading key bindings from. */
! static const char *current_readline_init_file;
  static int current_readline_init_include_level;
  static int current_readline_init_lineno;
***************
*** 660,664 ****
  {
    int r;
!   r = rl_read_init_file ((char *)NULL);
    rl_set_keymap_from_edit_mode ();
    return r;
--- 662,666 ----
  {
    int r;
!   r = rl_read_init_file ((const char *)NULL);
    rl_set_keymap_from_edit_mode ();
    return r;
***************
*** 674,678 ****
  int
  rl_read_init_file (filename)
!      char *filename;
  {
    /* Default the filename. */
--- 676,680 ----
  int
  rl_read_init_file (filename)
!      const char *filename;
  {
    /* Default the filename. */
***************
*** 681,685 ****
        filename = last_readline_init_file;
        if (filename == 0)
!         filename = get_env_value ("INPUTRC");
        if (filename == 0)
  	filename = DEFAULT_INPUTRC;
--- 683,687 ----
        filename = last_readline_init_file;
        if (filename == 0)
!         filename = sh_get_env_value ("INPUTRC");
        if (filename == 0)
  	filename = DEFAULT_INPUTRC;
***************
*** 699,703 ****
  static int
  _rl_read_init_file (filename, include_level)
!      char *filename;
       int include_level;
  {
--- 701,705 ----
  static int
  _rl_read_init_file (filename, include_level)
!      const char *filename;
       int include_level;
  {
***************
*** 734,738 ****
        for (i = 0; line + i != end && line[i] != '\n'; i++);
  
! #if defined (__CYGWIN32__)
        /* ``Be liberal in what you accept.'' */
        if (line[i] == '\n' && line[i-1] == '\r')
--- 736,740 ----
        for (i = 0; line + i != end && line[i] != '\n'; i++);
  
! #if defined (__CYGWIN__)
        /* ``Be liberal in what you accept.'' */
        if (line[i] == '\n' && line[i-1] == '\r')
***************
*** 781,788 ****
  /* **************************************************************** */
  
  /* Conditionals. */
  
  /* Calling programs set this to have their argv[0]. */
! char *rl_readline_name = "other";
  
  /* Stack of previous values of parsing_conditionalized_out. */
--- 783,801 ----
  /* **************************************************************** */
  
+ typedef int _rl_parser_func_t __P((char *));
+ 
+ /* Things that mean `Control'. */
+ const char *_rl_possible_control_prefixes[] = {
+   "Control-", "C-", "CTRL-", (const char *)NULL
+ };
+ 
+ const char *_rl_possible_meta_prefixes[] = {
+   "Meta", "M-", (const char *)NULL
+ };
+ 
  /* Conditionals. */
  
  /* Calling programs set this to have their argv[0]. */
! const char *rl_readline_name = "other";
  
  /* Stack of previous values of parsing_conditionalized_out. */
***************
*** 906,910 ****
       char *args;
  {
!   char *old_init_file, *e;
    int old_line_number, old_include_level, r;
  
--- 919,924 ----
       char *args;
  {
!   const char *old_init_file;
!   char *e;
    int old_line_number, old_include_level, r;
  
***************
*** 919,923 ****
    if (e)
      *e = '\0';
!   r = _rl_read_init_file (args, old_include_level + 1);
  
    current_readline_init_file = old_init_file;
--- 933,937 ----
    if (e)
      *e = '\0';
!   r = _rl_read_init_file ((const char *)args, old_include_level + 1);
  
    current_readline_init_file = old_init_file;
***************
*** 930,935 ****
  /* Associate textual names with actual functions. */
  static struct {
!   char *name;
!   Function *function;
  } parser_directives [] = {
    { "if", parser_if },
--- 944,949 ----
  /* Associate textual names with actual functions. */
  static struct {
!   const char *name;
!   _rl_parser_func_t *function;
  } parser_directives [] = {
    { "if", parser_if },
***************
*** 937,941 ****
    { "else", parser_else },
    { "include", parser_include },
!   { (char *)0x0, (Function *)0x0 }
  };
  
--- 951,955 ----
    { "else", parser_else },
    { "include", parser_include },
!   { (char *)0x0, (_rl_parser_func_t *)0x0 }
  };
  
***************
*** 1181,1188 ****
  
    /* Add in control and meta bits. */
!   if (substring_member_of_array (string, possible_control_prefixes))
      key = CTRL (_rl_to_upper (key));
  
!   if (substring_member_of_array (string, possible_meta_prefixes))
      key = META (key);
  
--- 1195,1202 ----
  
    /* Add in control and meta bits. */
!   if (substring_member_of_array (string, _rl_possible_control_prefixes))
      key = CTRL (_rl_to_upper (key));
  
!   if (substring_member_of_array (string, _rl_possible_meta_prefixes))
      key = META (key);
  
***************
*** 1222,1226 ****
  
  static struct {
!   char *name;
    int *value;
    int flags;
--- 1236,1240 ----
  
  static struct {
!   const char *name;
    int *value;
    int flags;
***************
*** 1266,1270 ****
       int i;
  {
!   char *name;
  
    name = boolean_varlist[i].name;
--- 1280,1284 ----
       int i;
  {
!   const char *name;
  
    name = boolean_varlist[i].name;
***************
*** 1281,1284 ****
--- 1295,1300 ----
  }
  
+ typedef int _rl_sv_func_t __P((const char *));
+ 
  /* These *must* correspond to the array indices for the appropriate
     string variable.  (Though they're not used right now.) */
***************
*** 1293,1307 ****
  
  /* Forward declarations */
! static int sv_bell_style __P((char *));
! static int sv_combegin __P((char *));
! static int sv_compquery __P((char *));
! static int sv_editmode __P((char *));
! static int sv_isrchterm __P((char *));
! static int sv_keymap __P((char *));
  
  static struct {
!   char *name;
    int flags;
!   Function *set_func;
  } string_varlist[] = {
    { "bell-style",	V_STRING,	sv_bell_style },
--- 1309,1323 ----
  
  /* Forward declarations */
! static int sv_bell_style __P((const char *));
! static int sv_combegin __P((const char *));
! static int sv_compquery __P((const char *));
! static int sv_editmode __P((const char *));
! static int sv_isrchterm __P((const char *));
! static int sv_keymap __P((const char *));
  
  static struct {
!   const char *name;
    int flags;
!   _rl_sv_func_t *set_func;
  } string_varlist[] = {
    { "bell-style",	V_STRING,	sv_bell_style },
***************
*** 1340,1344 ****
  int
  rl_variable_bind (name, value)
!      char *name, *value;
  {
    register int i;
--- 1356,1360 ----
  int
  rl_variable_bind (name, value)
!      const char *name, *value;
  {
    register int i;
***************
*** 1368,1372 ****
  static int
  sv_editmode (value)
!      char *value;
  {
    if (_rl_strnicmp (value, "vi", 2) == 0)
--- 1384,1388 ----
  static int
  sv_editmode (value)
!      const char *value;
  {
    if (_rl_strnicmp (value, "vi", 2) == 0)
***************
*** 1389,1393 ****
  static int
  sv_combegin (value)
!      char *value;
  {
    if (value && *value)
--- 1405,1409 ----
  static int
  sv_combegin (value)
!      const char *value;
  {
    if (value && *value)
***************
*** 1402,1406 ****
  static int
  sv_compquery (value)
!      char *value;
  {
    int nval = 100;
--- 1418,1422 ----
  static int
  sv_compquery (value)
!      const char *value;
  {
    int nval = 100;
***************
*** 1418,1422 ****
  static int
  sv_keymap (value)
!      char *value;
  {
    Keymap kmap;
--- 1434,1438 ----
  static int
  sv_keymap (value)
!      const char *value;
  {
    Keymap kmap;
***************
*** 1435,1439 ****
  static int
  sv_bell_style (value)
!      char *value;
  {
    if (value == 0 || *value == '\0')
--- 1451,1455 ----
  static int
  sv_bell_style (value)
!      const char *value;
  {
    if (value == 0 || *value == '\0')
***************
*** 1452,1456 ****
  static int
  sv_isrchterm (value)
!      char *value;
  {
    int beg, end, delim;
--- 1468,1472 ----
  static int
  sv_isrchterm (value)
!      const char *value;
  {
    int beg, end, delim;
***************
*** 1490,1494 ****
  
  typedef struct {
!   char *name;
    int value;
  } assoc_list;
--- 1506,1510 ----
  
  typedef struct {
!   const char *name;
    int value;
  } assoc_list;
***************
*** 1524,1528 ****
  /* Auxiliary functions to manage keymaps. */
  static struct {
!   char *name;
    Keymap map;
  } keymap_names[] = {
--- 1540,1544 ----
  /* Auxiliary functions to manage keymaps. */
  static struct {
!   const char *name;
    Keymap map;
  } keymap_names[] = {
***************
*** 1542,1551 ****
  Keymap
  rl_get_keymap_by_name (name)
!      char *name;
  {
    register int i;
  
    for (i = 0; keymap_names[i].name; i++)
!     if (strcmp (name, keymap_names[i].name) == 0)
        return (keymap_names[i].map);
    return ((Keymap) NULL);
--- 1558,1567 ----
  Keymap
  rl_get_keymap_by_name (name)
!      const char *name;
  {
    register int i;
  
    for (i = 0; keymap_names[i].name; i++)
!     if (_rl_stricmp (name, keymap_names[i].name) == 0)
        return (keymap_names[i].map);
    return ((Keymap) NULL);
***************
*** 1559,1563 ****
    for (i = 0; keymap_names[i].name; i++)
      if (map == keymap_names[i].map)
!       return (keymap_names[i].name);
    return ((char *)NULL);
  }
--- 1575,1579 ----
    for (i = 0; keymap_names[i].name; i++)
      if (map == keymap_names[i].map)
!       return ((char *)keymap_names[i].name);
    return ((char *)NULL);
  }
***************
*** 1617,1621 ****
  {
    register int i;
!   char **funmap_names;
  
    funmap_names = rl_funmap_names ();
--- 1633,1637 ----
  {
    register int i;
!   const char **funmap_names;
  
    funmap_names = rl_funmap_names ();
***************
*** 1707,1711 ****
  char **
  rl_invoking_keyseqs_in_map (function, map)
!      Function *function;
       Keymap map;
  {
--- 1723,1727 ----
  char **
  rl_invoking_keyseqs_in_map (function, map)
!      rl_command_func_t *function;
       Keymap map;
  {
***************
*** 1807,1811 ****
  char **
  rl_invoking_keyseqs (function)
!      Function *function;
  {
    return (rl_invoking_keyseqs_in_map (function, _rl_keymap));
--- 1823,1827 ----
  char **
  rl_invoking_keyseqs (function)
!      rl_command_func_t *function;
  {
    return (rl_invoking_keyseqs_in_map (function, _rl_keymap));
***************
*** 1820,1825 ****
  {
    register int i;
!   char **names;
!   char *name;
  
    names = rl_funmap_names ();
--- 1836,1841 ----
  {
    register int i;
!   const char **names;
!   const char *name;
  
    names = rl_funmap_names ();
***************
*** 1829,1833 ****
    for (i = 0; name = names[i]; i++)
      {
!       Function *function;
        char **invokers;
  
--- 1845,1849 ----
    for (i = 0; name = names[i]; i++)
      {
!       rl_command_func_t *function;
        char **invokers;
  
***************
*** 1986,1990 ****
  {
    int i;
!   char *kname;
  
    for (i = 0; boolean_varlist[i].name; i++)
--- 2002,2006 ----
  {
    int i;
!   const char *kname;
  
    for (i = 0; boolean_varlist[i].name; i++)
***************
*** 2074,2081 ****
  void
  _rl_bind_if_unbound (keyseq, default_func)
!      char *keyseq;
!      Function *default_func;
  {
!   Function *func;
  
    if (keyseq)
--- 2090,2097 ----
  void
  _rl_bind_if_unbound (keyseq, default_func)
!      const char *keyseq;
!      rl_command_func_t *default_func;
  {
!   rl_command_func_t *func;
  
    if (keyseq)
***************
*** 2090,2094 ****
  static int
  substring_member_of_array (string, array)
!      char *string, **array;
  {
    while (*array)
--- 2106,2111 ----
  static int
  substring_member_of_array (string, array)
!      char *string;
!      const char **array;
  {
    while (*array)
diff -Nrc2 bash-2.04/lib/readline/callback.c bash-2.05/lib/readline/callback.c
*** bash-2.04/lib/readline/callback.c	Thu Aug  5 08:17:29 1999
--- bash-2.05/lib/readline/callback.c	Tue Dec 12 14:48:21 2000
***************
*** 53,57 ****
     signals handled all the time, except during calls to the user's function. */
  
! VFunction *rl_linefunc;		/* user callback function */
  static int in_handler;		/* terminal_prepped and signals set? */
  
--- 53,57 ----
     signals handled all the time, except during calls to the user's function. */
  
! rl_vcpfunc_t *rl_linefunc;		/* user callback function */
  static int in_handler;		/* terminal_prepped and signals set? */
  
***************
*** 79,87 ****
  void
  rl_callback_handler_install (prompt, linefunc)
!      char *prompt;
!      VFunction *linefunc;
  {
!   rl_prompt = prompt;
!   rl_visible_prompt_length = rl_prompt ? rl_expand_prompt (rl_prompt) : 0;
    rl_linefunc = linefunc;
    _rl_callback_newline ();
--- 79,86 ----
  void
  rl_callback_handler_install (prompt, linefunc)
!      const char *prompt;
!      rl_vcpfunc_t *linefunc;
  {
!   rl_set_prompt (prompt);
    rl_linefunc = linefunc;
    _rl_callback_newline ();
***************
*** 103,124 ****
    eof = readline_internal_char ();
  
!   if (rl_done)
      {
!       line = readline_internal_teardown (eof);
  
!       (*rl_deprep_term_function) ();
  #if defined (HANDLE_SIGNALS)
!       rl_clear_signals ();
  #endif
!       in_handler = 0;
!       (*rl_linefunc) (line);
  
!     /* If the user did not clear out the line, do it for him. */
!     if (rl_line_buffer[0])
!       _rl_init_line_state ();
! 
!     /* Redisplay the prompt if readline_handler_{install,remove} not called. */
!       if (in_handler == 0 && rl_linefunc)
! 	_rl_callback_newline ();
      }
  }
--- 102,132 ----
    eof = readline_internal_char ();
  
!   /* We loop in case some function has pushed input back with rl_execute_next. */
!   for (;;)
      {
!       if (rl_done)
! 	{
! 	  line = readline_internal_teardown (eof);
  
! 	  (*rl_deprep_term_function) ();
  #if defined (HANDLE_SIGNALS)
! 	  rl_clear_signals ();
  #endif
! 	  in_handler = 0;
! 	  (*rl_linefunc) (line);
  
! 	  /* If the user did not clear out the line, do it for him. */
! 	  if (rl_line_buffer[0])
! 	    _rl_init_line_state ();
! 
! 	  /* Redisplay the prompt if readline_handler_{install,remove}
! 	     not called. */
! 	  if (in_handler == 0 && rl_linefunc)
! 	    _rl_callback_newline ();
! 	}
!       if (rl_pending_input)
! 	eof = readline_internal_char ();
!       else
!         break;
      }
  }
diff -Nrc2 bash-2.04/lib/readline/chardefs.h bash-2.05/lib/readline/chardefs.h
*** bash-2.04/lib/readline/chardefs.h	Thu Aug  5 08:17:37 1999
--- bash-2.05/lib/readline/chardefs.h	Wed Sep 13 17:20:15 2000
***************
*** 52,56 ****
  #define largest_char 255		    /* Largest character value. */
  
! #define CTRL_CHAR(c) ((c) < control_character_threshold && (c) >= 0)
  #define META_CHAR(c) ((c) > meta_character_threshold && (c) <= largest_char)
  
--- 52,56 ----
  #define largest_char 255		    /* Largest character value. */
  
! #define CTRL_CHAR(c) ((c) < control_character_threshold && (((c) & 0x80) == 0))
  #define META_CHAR(c) ((c) > meta_character_threshold && (c) <= largest_char)
  
diff -Nrc2 bash-2.04/lib/readline/compat.c bash-2.05/lib/readline/compat.c
*** bash-2.04/lib/readline/compat.c	Wed Dec 31 19:00:00 1969
--- bash-2.05/lib/readline/compat.c	Tue Feb  6 14:15:13 2001
***************
*** 0 ****
--- 1,113 ----
+ /* compat.c -- backwards compatibility functions. */
+ 
+ /* Copyright (C) 2000 Free Software Foundation, Inc.
+ 
+    This file is part of the GNU Readline Library, a library for
+    reading lines of text with interactive input and history editing.
+ 
+    The GNU Readline Library is free software; you can redistribute it
+    and/or modify it under the terms of the GNU General Public License
+    as published by the Free Software Foundation; either version 2, or
+    (at your option) any later version.
+ 
+    The GNU Readline Library is distributed in the hope that it will be
+    useful, but WITHOUT ANY WARRANTY; without even the implied warranty
+    of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+ 
+    The GNU General Public License is often shipped with GNU software, and
+    is generally kept in a file called COPYING or LICENSE.  If you do not
+    have a copy of the license, write to the Free Software Foundation,
+    59 Temple Place, Suite 330, Boston, MA 02111 USA. */
+ #define READLINE_LIBRARY
+ 
+ #if defined (HAVE_CONFIG_H)
+ #  include <config.h>
+ #endif
+ 
+ #include <stdio.h>
+ 
+ #include "rlstdc.h"
+ #include "rltypedefs.h"
+ 
+ extern void rl_free_undo_list __P((void));
+ extern int rl_maybe_save_line __P((void));
+ extern int rl_maybe_unsave_line __P((void));
+ extern int rl_maybe_replace_line __P((void));
+ 
+ extern int rl_crlf __P((void));
+ extern int rl_ding __P((void));
+ extern int rl_alphabetic __P((int));
+ 
+ extern char **rl_completion_matches __P((const char *, rl_compentry_func_t *));
+ extern char *rl_username_completion_function __P((const char *, int));
+ extern char *rl_filename_completion_function __P((const char *, int));
+ 
+ /* Provide backwards-compatible entry points for old function names. */
+ 
+ void
+ free_undo_list ()
+ {
+   rl_free_undo_list ();
+ }
+ 
+ int
+ maybe_replace_line ()
+ {
+   return rl_maybe_replace_line ();
+ }
+ 
+ int
+ maybe_save_line ()
+ {
+   return rl_maybe_save_line ();
+ }
+ 
+ int
+ maybe_unsave_line ()
+ {
+   return rl_maybe_unsave_line ();
+ }
+ 
+ int
+ ding ()
+ {
+   return rl_ding ();
+ }
+ 
+ int
+ crlf ()
+ {
+   return rl_crlf ();
+ }
+ 
+ int
+ alphabetic (c)
+      int c;
+ {
+   return rl_alphabetic (c);
+ }
+ 
+ char **
+ completion_matches (s, f)
+      const char *s;
+      rl_compentry_func_t *f;
+ {
+   return rl_completion_matches (s, f);
+ }
+ 
+ char *
+ username_completion_function (s, i)
+      const char *s;
+      int i;
+ {
+   return rl_username_completion_function (s, i);
+ }
+ 
+ char *
+ filename_completion_function (s, i)
+      const char *s;
+      int i;
+ {
+   return rl_filename_completion_function (s, i);
+ }
diff -Nrc2 bash-2.04/lib/readline/complete.c bash-2.05/lib/readline/complete.c
*** bash-2.04/lib/readline/complete.c	Tue Feb 22 13:50:05 2000
--- bash-2.05/lib/readline/complete.c	Wed Feb 14 07:47:18 2001
***************
*** 50,65 ****
  
  #include <pwd.h>
- #if !defined (HAVE_GETPW_DECLS)
- extern struct passwd *getpwent ();
- #endif /* USG && !HAVE_GETPW_DECLS */
- 
- /* ISC systems don't define getpwent() if _POSIX_SOURCE is defined. */
- #if defined (isc386) && defined (_POSIX_SOURCE)
- #  if defined (__STDC__)
- extern struct passwd *getpwent (void);
- #  else
- extern struct passwd *getpwent ();
- #  endif /* !__STDC__ */
- #endif /* isc386 && _POSIX_SOURCE */
  
  #include "posixdir.h"
--- 50,53 ----
***************
*** 80,83 ****
--- 68,77 ----
  #endif
  
+ /* Most systems don't declare getpwent in <pwd.h> if _POSIX_SOURCE is
+    defined. */
+ #if !defined (HAVE_GETPW_DECLS) || defined (_POSIX_SOURCE)
+ extern struct passwd *getpwent __P((void));
+ #endif /* !HAVE_GETPW_DECLS || _POSIX_SOURCE */
+ 
  /* If non-zero, then this is the address of a function to call when
     completing a word would normally display the list of possible matches.
***************
*** 87,95 ****
     number of strings in that array, and MAX_LENGTH is the length of the
     longest string in that array. */
! VFunction *rl_completion_display_matches_hook = (VFunction *)NULL;
! 
! /* Forward declarations for functions defined and used in this file. */
! char *filename_completion_function __P((char *, int));
! char **completion_matches __P((char *, CPFunction *));
  
  #if defined (VISIBLE_STATS)
--- 81,85 ----
     number of strings in that array, and MAX_LENGTH is the length of the
     longest string in that array. */
! rl_compdisp_func_t *rl_completion_display_matches_hook = (rl_compdisp_func_t *)NULL;
  
  #if defined (VISIBLE_STATS)
***************
*** 101,105 ****
  
  static char *rl_quote_filename __P((char *, int, char *));
- static char *rl_strpbrk __P((char *, char *));
  
  static char **remove_duplicate_matches __P((char **));
--- 91,94 ----
***************
*** 108,112 ****
  static void insert_all_matches __P((char **, int, char *));
  static void display_matches __P((char **));
! static int compute_lcd_of_matches __P((char **, int, char *));
  
  /* **************************************************************** */
--- 97,101 ----
  static void insert_all_matches __P((char **, int, char *));
  static void display_matches __P((char **));
! static int compute_lcd_of_matches __P((char **, int, const char *));
  
  /* **************************************************************** */
***************
*** 147,151 ****
     completing on a directory name.  The function is called with
     the address of a string (the current directory name) as an arg. */
! Function *rl_directory_completion_hook = (Function *)NULL;
  
  /* Non-zero means readline completion functions perform tilde expansion. */
--- 136,142 ----
     completing on a directory name.  The function is called with
     the address of a string (the current directory name) as an arg. */
! rl_icppfunc_t *rl_directory_completion_hook = (rl_icppfunc_t *)NULL;
! 
! rl_icppfunc_t *rl_directory_rewrite_hook = (rl_icppfunc_t *)NULL;
  
  /* Non-zero means readline completion functions perform tilde expansion. */
***************
*** 153,159 ****
  
  /* Pointer to the generator function for completion_matches ().
!    NULL means to use filename_completion_function (), the default filename
     completer. */
! Function *rl_completion_entry_function = (Function *)NULL;
  
  /* Pointer to alternative function to create matches.
--- 144,150 ----
  
  /* Pointer to the generator function for completion_matches ().
!    NULL means to use rl_filename_completion_function (), the default filename
     completer. */
! rl_compentry_func_t *rl_completion_entry_function = (rl_compentry_func_t *)NULL;
  
  /* Pointer to alternative function to create matches.
***************
*** 164,168 ****
     rl_completion_entry_function to try to match, otherwise use the
     array of strings returned. */
! CPPFunction *rl_attempted_completion_function = (CPPFunction *)NULL;
  
  /* Non-zero means to suppress normal filename completion after the
--- 155,159 ----
     rl_completion_entry_function to try to match, otherwise use the
     array of strings returned. */
! rl_completion_func_t *rl_attempted_completion_function = (rl_completion_func_t *)NULL;
  
  /* Non-zero means to suppress normal filename completion after the
***************
*** 183,195 ****
     completer routine.  The contents of this variable is what breaks words
     in the shell, i.e. " \t\n\"\\'`@$><=" */
! char *rl_basic_word_break_characters = " \t\n\"\\'`@$><=;|&{(";
  
  /* List of basic quoting characters. */
! char *rl_basic_quote_characters = "\"'";
  
  /* The list of characters that signal a break between words for
     rl_complete_internal.  The default list is the contents of
     rl_basic_word_break_characters.  */
! char *rl_completer_word_break_characters = (char *)NULL;
  
  /* List of characters which can be used to quote a substring of the line.
--- 174,186 ----
     completer routine.  The contents of this variable is what breaks words
     in the shell, i.e. " \t\n\"\\'`@$><=" */
! const char *rl_basic_word_break_characters = " \t\n\"\\'`@$><=;|&{(";
  
  /* List of basic quoting characters. */
! const char *rl_basic_quote_characters = "\"'";
  
  /* The list of characters that signal a break between words for
     rl_complete_internal.  The default list is the contents of
     rl_basic_word_break_characters.  */
! const char *rl_completer_word_break_characters = (const char *)NULL;
  
  /* List of characters which can be used to quote a substring of the line.
***************
*** 197,209 ****
     rl_completer_word_break_characters are treated as any other character,
     unless they also appear within this list. */
! char *rl_completer_quote_characters = (char *)NULL;
  
  /* List of characters that should be quoted in filenames by the completer. */
! char *rl_filename_quote_characters = (char *)NULL;
  
  /* List of characters that are word break characters, but should be left
     in TEXT when it is passed to the completion function.  The shell uses
     this to help determine what kind of completing to do. */
! char *rl_special_prefixes = (char *)NULL;
  
  /* If non-zero, then disallow duplicates in the matches. */
--- 188,200 ----
     rl_completer_word_break_characters are treated as any other character,
     unless they also appear within this list. */
! const char *rl_completer_quote_characters = (const char *)NULL;
  
  /* List of characters that should be quoted in filenames by the completer. */
! const char *rl_filename_quote_characters = (const char *)NULL;
  
  /* List of characters that are word break characters, but should be left
     in TEXT when it is passed to the completion function.  The shell uses
     this to help determine what kind of completing to do. */
! const char *rl_special_prefixes = (const char *)NULL;
  
  /* If non-zero, then disallow duplicates in the matches. */
***************
*** 231,235 ****
     free()'d if they are deleted. The main intent of this function is
     to implement FIGNORE a la SunOS csh. */
! Function *rl_ignore_some_completions_function = (Function *)NULL;
  
  /* Set to a function to quote a filename in an application-specific fashion.
--- 222,226 ----
     free()'d if they are deleted. The main intent of this function is
     to implement FIGNORE a la SunOS csh. */
! rl_compignore_func_t *rl_ignore_some_completions_function = (rl_compignore_func_t *)NULL;
  
  /* Set to a function to quote a filename in an application-specific fashion.
***************
*** 237,241 ****
     and a pointer to the quoting character to be used, which the function can
     reset if desired. */
! CPFunction *rl_filename_quoting_function = rl_quote_filename;
           
  /* Function to call to remove quoting characters from a filename.  Called
--- 228,232 ----
     and a pointer to the quoting character to be used, which the function can
     reset if desired. */
! rl_quote_func_t *rl_filename_quoting_function = rl_quote_filename;
           
  /* Function to call to remove quoting characters from a filename.  Called
***************
*** 243,252 ****
     with matching names in the file system.  Readline doesn't do anything
     with this; it's set only by applications. */
! CPFunction *rl_filename_dequoting_function = (CPFunction *)NULL;
  
  /* Function to call to decide whether or not a word break character is
     quoted.  If a character is quoted, it does not break words for the
     completer. */
! Function *rl_char_is_quoted_p = (Function *)NULL;
  
  /* Character appended to completed words when at the end of the line.  The
--- 234,243 ----
     with matching names in the file system.  Readline doesn't do anything
     with this; it's set only by applications. */
! rl_dequote_func_t *rl_filename_dequoting_function = (rl_dequote_func_t *)NULL;
  
  /* Function to call to decide whether or not a word break character is
     quoted.  If a character is quoted, it does not break words for the
     completer. */
! rl_linebuf_func_t *rl_char_is_quoted_p = (rl_linebuf_func_t *)NULL;
  
  /* Character appended to completed words when at the end of the line.  The
***************
*** 270,274 ****
  /* Complete the word at or before point.  You have supplied the function
     that does the initial simple matching selection algorithm (see
!    completion_matches ()).  The default is to do filename completion. */
  int
  rl_complete (ignore, invoking_key)
--- 261,265 ----
  /* Complete the word at or before point.  You have supplied the function
     that does the initial simple matching selection algorithm (see
!    rl_completion_matches ()).  The default is to do filename completion. */
  int
  rl_complete (ignore, invoking_key)
***************
*** 306,330 ****
  /************************************/
  
- /* Find the first occurrence in STRING1 of any character from STRING2.
-    Return a pointer to the character in STRING1. */
- static char *
- rl_strpbrk (string1, string2)
-      char *string1, *string2;
- {
-   register char *scan;
- 
-   for (; *string1; string1++)
-     {
-       for (scan = string2; *scan; scan++)
- 	{
- 	  if (*string1 == *scan)
- 	    {
- 	      return (string1);
- 	    }
- 	}
-     }
-   return ((char *)NULL);
- }
- 
  /* The user must press "y" or "n". Non-zero return means "y" pressed. */
  static int
--- 297,300 ----
***************
*** 335,339 ****
--- 305,312 ----
    for (;;)
      {
+       RL_SETSTATE(RL_STATE_MOREINPUT);
        c = rl_read_key ();
+       RL_UNSETSTATE(RL_STATE_MOREINPUT);
+ 
        if (c == 'y' || c == 'Y' || c == ' ')
  	return (1);
***************
*** 342,346 ****
        if (c == ABORT_CHAR)
  	_rl_abort_internal ();
!       ding ();
      }
  }
--- 315,319 ----
        if (c == ABORT_CHAR)
  	_rl_abort_internal ();
!       rl_ding ();
      }
  }
***************
*** 572,576 ****
  	    }
  
! 	  if (rl_line_buffer[scan] == '\\')
  	    {
  	      pass_next = 1;
--- 545,553 ----
  	    }
  
! 	  /* Shell-like semantics for single quotes -- don't allow backslash
! 	     to quote anything in single quotes, especially not the closing
! 	     quote.  If you don't like this, take out the check on the value
! 	     of quote_char. */
! 	  if (quote_char != '\'' && rl_line_buffer[scan] == '\\')
  	    {
  	      pass_next = 1;
***************
*** 672,676 ****
       char *text;
       int start, end;
!      Function *our_func;
       int found_quote, quote_char;
  {
--- 649,653 ----
       char *text;
       int start, end;
!      rl_compentry_func_t *our_func;
       int found_quote, quote_char;
  {
***************
*** 696,700 ****
    temp = (char *)NULL;
  
!   if (found_quote && our_func == (Function *)filename_completion_function &&
        rl_filename_dequoting_function)
      {
--- 673,677 ----
    temp = (char *)NULL;
  
!   if (found_quote && our_func == rl_filename_completion_function &&
        rl_filename_dequoting_function)
      {
***************
*** 704,708 ****
      }
  
!   matches = completion_matches (text, (CPFunction *)our_func);
    FREE (temp);
    return matches;  
--- 681,685 ----
      }
  
!   matches = rl_completion_matches (text, our_func);
    FREE (temp);
    return matches;  
***************
*** 776,780 ****
       char **match_list;
       int matches;
!      char *text;
  {
    register int i, c1, c2, si;
--- 753,757 ----
       char **match_list;
       int matches;
!      const char *text;
  {
    register int i, c1, c2, si;
***************
*** 902,910 ****
    /* How many items of MAX length can we fit in the screen window? */
    max += 2;
!   limit = screenwidth / max;
!   if (limit != 1 && (limit * max == screenwidth))
      limit--;
  
!   /* Avoid a possible floating exception.  If max > screenwidth,
       limit will be 0 and a divide-by-zero fault will result. */
    if (limit == 0)
--- 879,887 ----
    /* How many items of MAX length can we fit in the screen window? */
    max += 2;
!   limit = _rl_screenwidth / max;
!   if (limit != 1 && (limit * max == _rl_screenwidth))
      limit--;
  
!   /* Avoid a possible floating exception.  If max > _rl_screenwidth,
       limit will be 0 and a divide-by-zero fault will result. */
    if (limit == 0)
***************
*** 922,926 ****
      qsort (matches + 1, len, sizeof (char *), (QSFUNC *)_rl_qsort_string_compare);
  
!   crlf ();
  
    if (_rl_print_completions_horizontally == 0)
--- 899,903 ----
      qsort (matches + 1, len, sizeof (char *), (QSFUNC *)_rl_qsort_string_compare);
  
!   rl_crlf ();
  
    if (_rl_print_completions_horizontally == 0)
***************
*** 944,948 ****
  	      l += count;
  	    }
! 	  crlf ();
  	}
      }
--- 921,925 ----
  	      l += count;
  	    }
! 	  rl_crlf ();
  	}
      }
***************
*** 958,962 ****
  	    {
  	      if (i && (limit > 1) && (i % limit) == 0)
! 		crlf ();
  	      else
  		for (k = 0; k < max - printed_len; k++)
--- 935,939 ----
  	    {
  	      if (i && (limit > 1) && (i % limit) == 0)
! 		rl_crlf ();
  	      else
  		for (k = 0; k < max - printed_len; k++)
***************
*** 964,968 ****
  	    }
  	}
!       crlf ();
      }
  }
--- 941,945 ----
  	    }
  	}
!       rl_crlf ();
      }
  }
***************
*** 993,999 ****
      {
        temp = printable_part (matches[0]);
!       crlf ();
        print_filename (temp, matches[0]);
!       crlf ();
  
        rl_forced_update_display ();
--- 970,976 ----
      {
        temp = printable_part (matches[0]);
!       rl_crlf ();
        print_filename (temp, matches[0]);
!       rl_crlf ();
  
        rl_forced_update_display ();
***************
*** 1027,1036 ****
    if (len >= rl_completion_query_items)
      {
!       crlf ();
        fprintf (rl_outstream, "Display all %d possibilities? (y or n)", len);
        fflush (rl_outstream);
        if (get_y_or_n () == 0)
  	{
! 	  crlf ();
  
  	  rl_forced_update_display ();
--- 1004,1013 ----
    if (len >= rl_completion_query_items)
      {
!       rl_crlf ();
        fprintf (rl_outstream, "Display all %d possibilities? (y or n)", len);
        fflush (rl_outstream);
        if (get_y_or_n () == 0)
  	{
! 	  rl_crlf ();
  
  	  rl_forced_update_display ();
***************
*** 1080,1084 ****
  	 matches needs to be quoted. */
        should_quote = rl_filename_quote_characters
! 			? (rl_strpbrk (match, rl_filename_quote_characters) != 0)
  			: 0;
  
--- 1057,1061 ----
  	 matches needs to be quoted. */
        should_quote = rl_filename_quote_characters
! 			? (_rl_strpbrk (match, rl_filename_quote_characters) != 0)
  			: 0;
  
***************
*** 1233,1241 ****
  {
    char **matches;
!   Function *our_func;
    int start, end, delimiter, found_quote, i;
    char *text, *saved_line_buffer;
    char quote_char;
  
    /* Only the completion entry function can change these. */
    rl_filename_completion_desired = 0;
--- 1210,1219 ----
  {
    char **matches;
!   rl_compentry_func_t *our_func;
    int start, end, delimiter, found_quote, i;
    char *text, *saved_line_buffer;
    char quote_char;
  
+   RL_SETSTATE(RL_STATE_COMPLETING);
    /* Only the completion entry function can change these. */
    rl_filename_completion_desired = 0;
***************
*** 1246,1250 ****
    our_func = rl_completion_entry_function
  		? rl_completion_entry_function
! 		: (Function *)filename_completion_function;
  
    /* We now look backwards for the start of a filename/variable word. */
--- 1224,1228 ----
    our_func = rl_completion_entry_function
  		? rl_completion_entry_function
! 		: rl_filename_completion_function;
  
    /* We now look backwards for the start of a filename/variable word. */
***************
*** 1267,1291 ****
    if (matches == 0)
      {
!       ding ();
        FREE (saved_line_buffer);
        return (0);
      }
  
- #if 0
-   /* If we are matching filenames, our_func will have been set to
-      filename_completion_function */
-   i = our_func == (Function *)filename_completion_function;
- #else
    /* If we are matching filenames, the attempted completion function will
       have set rl_filename_completion_desired to a non-zero value.  The basic
!      filename_completion_function does this. */
    i = rl_filename_completion_desired;
- #endif
  
    if (postprocess_matches (&matches, i) == 0)
      {
!       ding ();
        FREE (saved_line_buffer);
        completion_changed_buffer = 0;
        return (0);
      }
--- 1245,1265 ----
    if (matches == 0)
      {
!       rl_ding ();
        FREE (saved_line_buffer);
+       RL_UNSETSTATE(RL_STATE_COMPLETING);
        return (0);
      }
  
    /* If we are matching filenames, the attempted completion function will
       have set rl_filename_completion_desired to a non-zero value.  The basic
!      rl_filename_completion_function does this. */
    i = rl_filename_completion_desired;
  
    if (postprocess_matches (&matches, i) == 0)
      {
!       rl_ding ();
        FREE (saved_line_buffer);
        completion_changed_buffer = 0;
+       RL_UNSETSTATE(RL_STATE_COMPLETING);
        return (0);
      }
***************
*** 1315,1319 ****
  	    }
  	  else if (rl_editing_mode != vi_mode)
! 	    ding ();	/* There are other matches remaining. */
  	}
        else
--- 1289,1293 ----
  	    }
  	  else if (rl_editing_mode != vi_mode)
! 	    rl_ding ();	/* There are other matches remaining. */
  	}
        else
***************
*** 1332,1337 ****
      default:
        fprintf (stderr, "\r\nreadline: bad value %d for what_to_do in rl_complete\n", what_to_do);
!       ding ();
        FREE (saved_line_buffer);
        return 1;
      }
--- 1306,1312 ----
      default:
        fprintf (stderr, "\r\nreadline: bad value %d for what_to_do in rl_complete\n", what_to_do);
!       rl_ding ();
        FREE (saved_line_buffer);
+       RL_UNSETSTATE(RL_STATE_COMPLETING);
        return 1;
      }
***************
*** 1346,1349 ****
--- 1321,1325 ----
      }
  
+   RL_UNSETSTATE(RL_STATE_COMPLETING);
    return 0;
  }
***************
*** 1368,1374 ****
   */
  char **
! completion_matches (text, entry_function)
!      char *text;
!      CPFunction *entry_function;
  {
    /* Number of slots in match_list. */
--- 1344,1350 ----
   */
  char **
! rl_completion_matches (text, entry_function)
!      const char *text;
!      rl_compentry_func_t *entry_function;
  {
    /* Number of slots in match_list. */
***************
*** 1415,1420 ****
     character (usually `~').  */
  char *
! username_completion_function (text, state)
!      char *text;
       int state;
  {
--- 1391,1396 ----
     character (usually `~').  */
  char *
! rl_username_completion_function (text, state)
!      const char *text;
       int state;
  {
***************
*** 1472,1477 ****
     completion for a command. */
  char *
! filename_completion_function (text, state)
!      char *text;
       int state;
  {
--- 1448,1453 ----
     completion for a command. */
  char *
! rl_filename_completion_function (text, state)
!      const char *text;
       int state;
  {
***************
*** 1543,1546 ****
--- 1519,1525 ----
  	}
  
+       if (rl_directory_rewrite_hook)
+ 	(*rl_directory_rewrite_hook) (&dirname);
+ 
        if (rl_directory_completion_hook && (*rl_directory_completion_hook) (&dirname))
  	{
***************
*** 1642,1647 ****
  	    {
  	      dirlen = strlen (users_dirname);
! 	      temp = xmalloc (1 + dirlen + D_NAMLEN (entry));
  	      strcpy (temp, users_dirname);
  	    }
  
--- 1621,1629 ----
  	    {
  	      dirlen = strlen (users_dirname);
! 	      temp = xmalloc (2 + dirlen + D_NAMLEN (entry));
  	      strcpy (temp, users_dirname);
+ 	      /* Make sure that temp has a trailing slash here. */
+ 	      if (users_dirname[dirlen - 1] != '/')
+ 		temp[dirlen++] = '/';
  	    }
  
***************
*** 1668,1672 ****
       int count, ignore;
  {
!   Function *our_func;
    int matching_filenames, found_quote;
  
--- 1650,1654 ----
       int count, ignore;
  {
!   rl_compentry_func_t *our_func;
    int matching_filenames, found_quote;
  
***************
*** 1698,1702 ****
        our_func = rl_completion_entry_function
  			? rl_completion_entry_function
! 			: (Function *)filename_completion_function;
  
        /* We now look backwards for the start of a filename/variable word. */
--- 1680,1684 ----
        our_func = rl_completion_entry_function
  			? rl_completion_entry_function
! 			: rl_filename_completion_function;
  
        /* We now look backwards for the start of a filename/variable word. */
***************
*** 1717,1733 ****
  					our_func, found_quote, quote_char);
  
- #if 0
-       /* If we are matching filenames, our_func will have been set to
- 	 filename_completion_function */
-       matching_filenames = our_func == (Function *)filename_completion_function;
- #else
        /* If we are matching filenames, the attempted completion function will
  	 have set rl_filename_completion_desired to a non-zero value.  The basic
! 	 filename_completion_function does this. */
        matching_filenames = rl_filename_completion_desired;
! #endif
        if (matches == 0 || postprocess_matches (&matches, matching_filenames) == 0)
  	{
!     	  ding ();
  	  FREE (matches);
  	  matches = (char **)0;
--- 1699,1710 ----
  					our_func, found_quote, quote_char);
  
        /* If we are matching filenames, the attempted completion function will
  	 have set rl_filename_completion_desired to a non-zero value.  The basic
! 	 rl_filename_completion_function does this. */
        matching_filenames = rl_filename_completion_desired;
! 
        if (matches == 0 || postprocess_matches (&matches, matching_filenames) == 0)
  	{
!     	  rl_ding ();
  	  FREE (matches);
  	  matches = (char **)0;
***************
*** 1750,1754 ****
    if (matches == 0 || match_list_size == 0) 
      {
!       ding ();
        FREE (matches);
        matches = (char **)0;
--- 1727,1731 ----
    if (matches == 0 || match_list_size == 0) 
      {
!       rl_ding ();
        FREE (matches);
        matches = (char **)0;
***************
*** 1763,1767 ****
    if (match_list_index == 0 && match_list_size > 1)
      {
!       ding ();
        insert_match (orig_text, orig_start, MULT_MATCH, &quote_char);
      }
--- 1740,1744 ----
    if (match_list_index == 0 && match_list_size > 1)
      {
!       rl_ding ();
        insert_match (orig_text, orig_start, MULT_MATCH, &quote_char);
      }
diff -Nrc2 bash-2.04/lib/readline/display.c bash-2.05/lib/readline/display.c
*** bash-2.04/lib/readline/display.c	Thu Sep 16 11:19:40 1999
--- bash-2.05/lib/readline/display.c	Fri Feb  2 13:25:10 2001
***************
*** 60,64 ****
  
  #if defined (HACK_TERMCAP_MOTION)
! extern char *term_forward_char;
  #endif
  
--- 60,64 ----
  
  #if defined (HACK_TERMCAP_MOTION)
! extern char *_rl_term_forward_char;
  #endif
  
***************
*** 104,108 ****
  
  /* Application-specific redisplay function. */
! VFunction *rl_redisplay_function = rl_redisplay;
  
  /* Global variables declared here. */
--- 104,108 ----
  
  /* Application-specific redisplay function. */
! rl_voidfunc_t *rl_redisplay_function = rl_redisplay;
  
  /* Global variables declared here. */
***************
*** 143,148 ****
  static int line_size = 1024;
  
  static char *local_prompt, *local_prompt_prefix;
! static int visible_length, prefix_length;
  
  /* The number of invisible characters in the line currently being
--- 143,151 ----
  static int line_size = 1024;
  
+ /* Variables to keep track of the expanded prompt string, which may
+    include invisible characters. */
+ 
  static char *local_prompt, *local_prompt_prefix;
! static int prompt_visible_length, prompt_prefix_length;
  
  /* The number of invisible characters in the line currently being
***************
*** 150,158 ****
  static int visible_wrap_offset;
  
! /* static so it can be shared between rl_redisplay and update_line */
  static int wrap_offset;
  
! /* The index of the last invisible_character in the prompt string. */
! static int last_invisible;
  
  /* The length (buffer offset) of the first line of the last (possibly
--- 153,162 ----
  static int visible_wrap_offset;
  
! /* The number of invisible characters in the prompt string.  Static so it
!    can be shared between rl_redisplay and update_line */
  static int wrap_offset;
  
! /* The index of the last invisible character in the prompt string. */
! static int prompt_last_invisible;
  
  /* The length (buffer offset) of the first line of the last (possibly
***************
*** 160,167 ****
  static int visible_first_line_len;
  
  /* Expand the prompt string S and return the number of visible
     characters in *LP, if LP is not null.  This is currently more-or-less
     a placeholder for expansion.  LIP, if non-null is a place to store the
!    index of the last invisible character in the returned string. */
  
  /* Current implementation:
--- 164,180 ----
  static int visible_first_line_len;
  
+ /* Number of invisible characters on the first physical line of the prompt.
+    Only valid when the number of physical characters in the prompt exceeds
+    (or is equal to) _rl_screenwidth. */
+ static int prompt_invis_chars_first_line;
+ 
+ static int prompt_last_screen_line;
+ 
  /* Expand the prompt string S and return the number of visible
     characters in *LP, if LP is not null.  This is currently more-or-less
     a placeholder for expansion.  LIP, if non-null is a place to store the
!    index of the last invisible character in the returned string. NIFLP,
!    if non-zero, is a place to store the number of invisible characters in
!    the first prompt line. */
  
  /* Current implementation:
***************
*** 173,182 ****
  
  static char *
! expand_prompt (pmt, lp, lip)
       char *pmt;
!      int *lp, *lip;
  {
    char *r, *ret, *p;
!   int l, rl, last, ignoring;
  
    /* Short-circuit if we can. */
--- 186,195 ----
  
  static char *
! expand_prompt (pmt, lp, lip, niflp)
       char *pmt;
!      int *lp, *lip, *niflp;
  {
    char *r, *ret, *p;
!   int l, rl, last, ignoring, ninvis, invfl;
  
    /* Short-circuit if we can. */
***************
*** 191,196 ****
    l = strlen (pmt);
    r = ret = xmalloc (l + 1);
!   
!   for (rl = ignoring = last = 0, p = pmt; p && *p; p++)
      {
        /* This code strips the invisible character string markers
--- 204,211 ----
    l = strlen (pmt);
    r = ret = xmalloc (l + 1);
! 
!   invfl = 0;	/* invisible chars in first line of prompt */
! 
!   for (rl = ignoring = last = ninvis = 0, p = pmt; p && *p; p++)
      {
        /* This code strips the invisible character string markers
***************
*** 212,218 ****
--- 227,240 ----
  	  if (!ignoring)
  	    rl++;
+ 	  else
+ 	    ninvis++;
+ 	  if (rl == _rl_screenwidth)
+ 	    invfl = ninvis;
  	}
      }
  
+   if (rl < _rl_screenwidth)
+     invfl = ninvis;
+ 
    *r = '\0';
    if (lp)
***************
*** 220,223 ****
--- 242,247 ----
    if (lip)
      *lip = last;
+   if (niflp)
+     *niflp = invfl;
    return ret;
  }
***************
*** 231,235 ****
    char *ret;
  
!   ret = expand_prompt (pmt, (int *)NULL, (int *)NULL);
    return ret;
  }
--- 255,259 ----
    char *ret;
  
!   ret = expand_prompt (pmt, (int *)NULL, (int *)NULL, (int *)NULL);
    return ret;
  }
***************
*** 243,248 ****
   * local_prompt_prefix = portion before last newline of rl_display_prompt,
   *			 expanded via expand_prompt
!  * visible_length = number of visible characters in local_prompt
!  * prefix_length = number of visible characters in local_prompt_prefix
   *
   * This function is called once per call to readline().  It may also be
--- 267,272 ----
   * local_prompt_prefix = portion before last newline of rl_display_prompt,
   *			 expanded via expand_prompt
!  * prompt_visible_length = number of visible characters in local_prompt
!  * prompt_prefix_length = number of visible characters in local_prompt_prefix
   *
   * This function is called once per call to readline().  It may also be
***************
*** 260,269 ****
  
    /* Clear out any saved values. */
!   if (local_prompt)
!     free (local_prompt);
!   if (local_prompt_prefix)
!     free (local_prompt_prefix);
    local_prompt = local_prompt_prefix = (char *)0;
!   last_invisible = visible_length = 0;
  
    if (prompt == 0 || *prompt == 0)
--- 284,292 ----
  
    /* Clear out any saved values. */
!   FREE (local_prompt);
!   FREE (local_prompt_prefix);
! 
    local_prompt = local_prompt_prefix = (char *)0;
!   prompt_last_invisible = prompt_visible_length = 0;
  
    if (prompt == 0 || *prompt == 0)
***************
*** 273,280 ****
    if (!p)
      {
!       /* The prompt is only one line. */
!       local_prompt = expand_prompt (prompt, &visible_length, &last_invisible);
        local_prompt_prefix = (char *)0;
!       return (visible_length);
      }
    else
--- 296,305 ----
    if (!p)
      {
!       /* The prompt is only one logical line, though it might wrap. */
!       local_prompt = expand_prompt (prompt, &prompt_visible_length,
! 					    &prompt_last_invisible,
! 					    &prompt_invis_chars_first_line);
        local_prompt_prefix = (char *)0;
!       return (prompt_visible_length);
      }
    else
***************
*** 282,292 ****
        /* The prompt spans multiple lines. */
        t = ++p;
!       local_prompt = expand_prompt (p, &visible_length, &last_invisible);
        c = *t; *t = '\0';
        /* The portion of the prompt string up to and including the
  	 final newline is now null-terminated. */
!       local_prompt_prefix = expand_prompt (prompt, &prefix_length, (int *)NULL);
        *t = c;
!       return (prefix_length);
      }
  }
--- 307,321 ----
        /* The prompt spans multiple lines. */
        t = ++p;
!       local_prompt = expand_prompt (p, &prompt_visible_length,
! 				       &prompt_last_invisible,
! 				       &prompt_invis_chars_first_line);
        c = *t; *t = '\0';
        /* The portion of the prompt string up to and including the
  	 final newline is now null-terminated. */
!       local_prompt_prefix = expand_prompt (prompt, &prompt_prefix_length,
! 						   (int *)NULL,
! 						   &prompt_invis_chars_first_line);
        *t = c;
!       return (prompt_prefix_length);
      }
  }
***************
*** 400,404 ****
  	}
        line[out] = '\0';
!       wrap_offset = local_len - visible_length;
      }
    else
--- 429,433 ----
  	}
        line[out] = '\0';
!       wrap_offset = local_len - prompt_visible_length;
      }
    else
***************
*** 433,437 ****
        out += pmtlen;
        line[out] = '\0';
!       wrap_offset = 0;
      }
  
--- 462,466 ----
        out += pmtlen;
        line[out] = '\0';
!       wrap_offset = prompt_invis_chars_first_line = 0;
      }
  
***************
*** 448,452 ****
        do { \
  	lpos++; \
! 	if (lpos >= screenwidth) \
  	  { \
  	    if (newlines >= (inv_lbsize - 2)) \
--- 477,481 ----
        do { \
  	lpos++; \
! 	if (lpos >= _rl_screenwidth) \
  	  { \
  	    if (newlines >= (inv_lbsize - 2)) \
***************
*** 464,482 ****
    lpos = out - wrap_offset;
  
!   /* XXX - what if lpos is already >= screenwidth before we start drawing the
       contents of the command line? */
!   while (lpos >= screenwidth)
      {
!       /* XXX - possible fix from Darin Johnson <darin@acuson.com> for prompt
! 	 string with invisible characters that is longer than the screen
! 	 width.  XXX - this doesn't work right if invisible characters have
! 	 to be put on the second screen line -- it adds too much (the number
! 	 of invisible chars after the screenwidth). */
!       temp = ((newlines + 1) * screenwidth) + ((newlines == 0) ? wrap_offset : 0);
  
        inv_lbreaks[++newlines] = temp;
!       lpos -= screenwidth;
      }
  
    lb_linenum = 0;
    for (in = 0; in < rl_end; in++)
--- 493,526 ----
    lpos = out - wrap_offset;
  
!   /* prompt_invis_chars_first_line is the number of invisible characters in
!      the first physical line of the prompt.
!      wrap_offset - prompt_invis_chars_first_line is the number of invis
!      chars on the second line. */
! 
!   /* what if lpos is already >= _rl_screenwidth before we start drawing the
       contents of the command line? */
!   while (lpos >= _rl_screenwidth)
      {
!       /* fix from Darin Johnson <darin@acuson.com> for prompt string with
!          invisible characters that is longer than the screen width.  The
!          prompt_invis_chars_first_line variable could be made into an array
!          saying how many invisible characters there are per line, but that's
!          probably too much work for the benefit gained.  How many people have
!          prompts that exceed two physical lines? */
!       temp = ((newlines + 1) * _rl_screenwidth) +
!              ((newlines == 0) ? prompt_invis_chars_first_line : 0) +
!              ((newlines == 1) ? wrap_offset : 0);
  
        inv_lbreaks[++newlines] = temp;
!       lpos -= _rl_screenwidth;
      }
  
+   prompt_last_screen_line = newlines;
+ 
+   /* Draw the rest of the line (after the prompt) into invisible_line, keeping
+      track of where the cursor is (c_pos), the number of the line containing
+      the cursor (lb_linenum), the last line number (lb_botlin and inv_botlin).
+      It maintains an array of line breaks for display (inv_lbreaks).
+      This handles expanding tabs for display and displaying meta characters. */
    lb_linenum = 0;
    for (in = 0; in < rl_end; in++)
***************
*** 504,510 ****
  	      sprintf (line + out, "\\%o", c);
  
! 	      if (lpos + 4 >= screenwidth)
  		{
! 		  temp = screenwidth - lpos;
  		  CHECK_INV_LBREAKS ();
  		  inv_lbreaks[++newlines] = out + temp;
--- 548,554 ----
  	      sprintf (line + out, "\\%o", c);
  
! 	      if (lpos + 4 >= _rl_screenwidth)
  		{
! 		  temp = _rl_screenwidth - lpos;
  		  CHECK_INV_LBREAKS ();
  		  inv_lbreaks[++newlines] = out + temp;
***************
*** 525,529 ****
        else if (c == '\t')
  	{
! 	  register int temp, newout;
  
  #if 0
--- 569,573 ----
        else if (c == '\t')
  	{
! 	  register int newout;
  
  #if 0
***************
*** 533,540 ****
  #endif
  	  temp = newout - out;
! 	  if (lpos + temp >= screenwidth)
  	    {
  	      register int temp2;
! 	      temp2 = screenwidth - lpos;
  	      CHECK_INV_LBREAKS ();
  	      inv_lbreaks[++newlines] = out + temp2;
--- 577,584 ----
  #endif
  	  temp = newout - out;
! 	  if (lpos + temp >= _rl_screenwidth)
  	    {
  	      register int temp2;
! 	      temp2 = _rl_screenwidth - lpos;
  	      CHECK_INV_LBREAKS ();
  	      inv_lbreaks[++newlines] = out + temp2;
***************
*** 551,555 ****
  	}
  #endif
!       else if (c == '\n' && _rl_horizontal_scroll_mode == 0 && term_up && *term_up)
  	{
  	  line[out++] = '\0';	/* XXX - sentinel */
--- 595,599 ----
  	}
  #endif
!       else if (c == '\n' && _rl_horizontal_scroll_mode == 0 && _rl_term_up && *_rl_term_up)
  	{
  	  line[out++] = '\0';	/* XXX - sentinel */
***************
*** 583,587 ****
    cursor_linenum = lb_linenum;
  
!   /* C_POS == position in buffer where cursor should be placed. */
  
    /* PWP: now is when things get a bit hairy.  The visible and invisible
--- 627,632 ----
    cursor_linenum = lb_linenum;
  
!   /* C_POS == position in buffer where cursor should be placed.
!      CURSOR_LINENUM == line number where the cursor should be placed. */
  
    /* PWP: now is when things get a bit hairy.  The visible and invisible
***************
*** 594,598 ****
       horizontally scroll it. */
  
!   if (_rl_horizontal_scroll_mode == 0 && term_up && *term_up)
      {
        int nleft, pos, changed_screen_line;
--- 639,643 ----
       horizontally scroll it. */
  
!   if (_rl_horizontal_scroll_mode == 0 && _rl_term_up && *_rl_term_up)
      {
        int nleft, pos, changed_screen_line;
***************
*** 605,610 ****
  	     only display a screenful.  We should display the last screen,
  	     not the first.  */
! 	  if (out >= screenchars)
! 	    out = screenchars - 1;
  
  	  /* The first line is at character position 0 in the buffer.  The
--- 650,655 ----
  	     only display a screenful.  We should display the last screen,
  	     not the first.  */
! 	  if (out >= _rl_screenchars)
! 	    out = _rl_screenchars - 1;
  
  	  /* The first line is at character position 0 in the buffer.  The
***************
*** 636,640 ****
  		  (_rl_last_c_pos < visible_first_line_len))
  		{
! 		  nleft = screenwidth + wrap_offset - _rl_last_c_pos;
  		  if (nleft)
  		    _rl_clear_to_eol (nleft);
--- 681,685 ----
  		  (_rl_last_c_pos < visible_first_line_len))
  		{
! 		  nleft = _rl_screenwidth + wrap_offset - _rl_last_c_pos;
  		  if (nleft)
  		    _rl_clear_to_eol (nleft);
***************
*** 657,661 ****
  		  _rl_move_cursor_relative (0, tt);
  		  _rl_clear_to_eol
! 		    ((linenum == _rl_vis_botlin) ? strlen (tt) : screenwidth);
  		}
  	    }
--- 702,706 ----
  		  _rl_move_cursor_relative (0, tt);
  		  _rl_clear_to_eol
! 		    ((linenum == _rl_vis_botlin) ? strlen (tt) : _rl_screenwidth);
  		}
  	    }
***************
*** 668,672 ****
  	    {
  	      _rl_move_vert (cursor_linenum);
! 	      /* If we moved up to the line with the prompt using term_up,
  		 the physical cursor position on the screen stays the same,
  		 but the buffer position needs to be adjusted to account
--- 713,717 ----
  	    {
  	      _rl_move_vert (cursor_linenum);
! 	      /* If we moved up to the line with the prompt using _rl_term_up,
  		 the physical cursor position on the screen stays the same,
  		 but the buffer position needs to be adjusted to account
***************
*** 681,693 ****
  	     only need to reprint it if the cursor is before the last
  	     invisible character in the prompt string. */
! 	  nleft = visible_length + wrap_offset;
  	  if (cursor_linenum == 0 && wrap_offset > 0 && _rl_last_c_pos > 0 &&
! 	      _rl_last_c_pos <= last_invisible && local_prompt)
  	    {
  #if defined (__MSDOS__)
  	      putc ('\r', rl_outstream);
  #else
! 	      if (term_cr)
! 		tputs (term_cr, 1, _rl_output_character_function);
  #endif
  	      _rl_output_some_chars (local_prompt, nleft);
--- 726,738 ----
  	     only need to reprint it if the cursor is before the last
  	     invisible character in the prompt string. */
! 	  nleft = prompt_visible_length + wrap_offset;
  	  if (cursor_linenum == 0 && wrap_offset > 0 && _rl_last_c_pos > 0 &&
! 	      _rl_last_c_pos <= prompt_last_invisible && local_prompt)
  	    {
  #if defined (__MSDOS__)
  	      putc ('\r', rl_outstream);
  #else
! 	      if (_rl_term_cr)
! 		tputs (_rl_term_cr, 1, _rl_output_character_function);
  #endif
  	      _rl_output_some_chars (local_prompt, nleft);
***************
*** 728,736 ****
        /* The number of characters that will be displayed before the cursor. */
        ndisp = c_pos - wrap_offset;
!       nleft  = visible_length + wrap_offset;
        /* Where the new cursor position will be on the screen.  This can be
  	 longer than SCREENWIDTH; if it is, lmargin will be adjusted. */
        phys_c_pos = c_pos - (last_lmargin ? last_lmargin : wrap_offset);
!       t = screenwidth / 3;
  
        /* If the number of characters had already exceeded the screenwidth,
--- 773,781 ----
        /* The number of characters that will be displayed before the cursor. */
        ndisp = c_pos - wrap_offset;
!       nleft  = prompt_visible_length + wrap_offset;
        /* Where the new cursor position will be on the screen.  This can be
  	 longer than SCREENWIDTH; if it is, lmargin will be adjusted. */
        phys_c_pos = c_pos - (last_lmargin ? last_lmargin : wrap_offset);
!       t = _rl_screenwidth / 3;
  
        /* If the number of characters had already exceeded the screenwidth,
***************
*** 740,744 ****
  	 width, compute the starting offset so that the cursor is about
  	 two-thirds of the way across the screen. */
!       if (phys_c_pos > screenwidth - 2)
  	{
  	  lmargin = c_pos - (2 * t);
--- 785,789 ----
  	 width, compute the starting offset so that the cursor is about
  	 two-thirds of the way across the screen. */
!       if (phys_c_pos > _rl_screenwidth - 2)
  	{
  	  lmargin = c_pos - (2 * t);
***************
*** 750,754 ****
  	    lmargin = nleft;
  	}
!       else if (ndisp < screenwidth - 2)		/* XXX - was -1 */
  	lmargin = 0;
        else if (phys_c_pos < 1)
--- 795,799 ----
  	    lmargin = nleft;
  	}
!       else if (ndisp < _rl_screenwidth - 2)		/* XXX - was -1 */
  	lmargin = 0;
        else if (phys_c_pos < 1)
***************
*** 772,776 ****
  	 right edge of the screen.  If LMARGIN is 0, we need to take the
  	 wrap offset into account. */
!       t = lmargin + M_OFFSET (lmargin, wrap_offset) + screenwidth;
        if (t < out)
  	line[t - 1] = '>';
--- 817,821 ----
  	 right edge of the screen.  If LMARGIN is 0, we need to take the
  	 wrap offset into account. */
!       t = lmargin + M_OFFSET (lmargin, wrap_offset) + _rl_screenwidth;
        if (t < out)
  	line[t - 1] = '>';
***************
*** 782,787 ****
  		       &invisible_line[lmargin],
  		       0,
! 		       screenwidth + visible_wrap_offset,
! 		       screenwidth + (lmargin ? 0 : wrap_offset),
  		       0);
  
--- 827,832 ----
  		       &invisible_line[lmargin],
  		       0,
! 		       _rl_screenwidth + visible_wrap_offset,
! 		       _rl_screenwidth + (lmargin ? 0 : wrap_offset),
  		       0);
  
***************
*** 794,803 ****
  	      t < visible_first_line_len)
  	    {
! 	      nleft = screenwidth - t;
  	      _rl_clear_to_eol (nleft);
  	    }
  	  visible_first_line_len = out - lmargin - M_OFFSET (lmargin, wrap_offset);
! 	  if (visible_first_line_len > screenwidth)
! 	    visible_first_line_len = screenwidth;
  
  	  _rl_move_cursor_relative (c_pos - lmargin, &invisible_line[lmargin]);
--- 839,848 ----
  	      t < visible_first_line_len)
  	    {
! 	      nleft = _rl_screenwidth - t;
  	      _rl_clear_to_eol (nleft);
  	    }
  	  visible_first_line_len = out - lmargin - M_OFFSET (lmargin, wrap_offset);
! 	  if (visible_first_line_len > _rl_screenwidth)
! 	    visible_first_line_len = _rl_screenwidth;
  
  	  _rl_move_cursor_relative (c_pos - lmargin, &invisible_line[lmargin]);
***************
*** 809,817 ****
    /* Swap visible and non-visible lines. */
    {
!     char *temp = visible_line;
      int *itemp = vis_lbreaks, ntemp = vis_lbsize;
  
      visible_line = invisible_line;
!     invisible_line = temp;
  
      vis_lbreaks = inv_lbreaks;
--- 854,862 ----
    /* Swap visible and non-visible lines. */
    {
!     char *vtemp = visible_line;
      int *itemp = vis_lbreaks, ntemp = vis_lbsize;
  
      visible_line = invisible_line;
!     invisible_line = vtemp;
  
      vis_lbreaks = inv_lbreaks;
***************
*** 863,867 ****
       position of the cursor. */
    temp = _rl_last_c_pos - W_OFFSET(_rl_last_v_pos, visible_wrap_offset);
!   if (temp == screenwidth && _rl_term_autowrap && !_rl_horizontal_scroll_mode
        && _rl_last_v_pos == current_line - 1)
      {
--- 908,912 ----
       position of the cursor. */
    temp = _rl_last_c_pos - W_OFFSET(_rl_last_v_pos, visible_wrap_offset);
!   if (temp == _rl_screenwidth && _rl_term_autowrap && !_rl_horizontal_scroll_mode
        && _rl_last_v_pos == current_line - 1)
      {
***************
*** 940,950 ****
    od = ofd - old;	/* index of first difference in visible line */
    if (current_line == 0 && !_rl_horizontal_scroll_mode &&
!       term_cr && lendiff > visible_length && _rl_last_c_pos > 0 &&
!       od > lendiff && _rl_last_c_pos < last_invisible)
      {
  #if defined (__MSDOS__)
        putc ('\r', rl_outstream);
  #else
!       tputs (term_cr, 1, _rl_output_character_function);
  #endif
        _rl_output_some_chars (local_prompt, lendiff);
--- 985,995 ----
    od = ofd - old;	/* index of first difference in visible line */
    if (current_line == 0 && !_rl_horizontal_scroll_mode &&
!       _rl_term_cr && lendiff > prompt_visible_length && _rl_last_c_pos > 0 &&
!       od >= lendiff && _rl_last_c_pos <= prompt_last_invisible)
      {
  #if defined (__MSDOS__)
        putc ('\r', rl_outstream);
  #else
!       tputs (_rl_term_cr, 1, _rl_output_character_function);
  #endif
        _rl_output_some_chars (local_prompt, lendiff);
***************
*** 974,985 ****
  	 of lines, make sure we actually cause the new line to wrap
  	 around on auto-wrapping terminals. */
!       if (terminal_can_insert && ((2 * temp) >= lendiff || term_IC) && (!_rl_term_autowrap || !gl))
  	{
! 	  /* If lendiff > visible_length and _rl_last_c_pos == 0 and
  	     _rl_horizontal_scroll_mode == 1, inserting the characters with
! 	     term_IC or term_ic will screw up the screen because of the
  	     invisible characters.  We need to just draw them. */
  	  if (*ols && (!_rl_horizontal_scroll_mode || _rl_last_c_pos > 0 ||
! 			lendiff <= visible_length || !current_invis_chars))
  	    {
  	      insert_some_chars (nfd, lendiff);
--- 1019,1030 ----
  	 of lines, make sure we actually cause the new line to wrap
  	 around on auto-wrapping terminals. */
!       if (_rl_terminal_can_insert && ((2 * temp) >= lendiff || _rl_term_IC) && (!_rl_term_autowrap || !gl))
  	{
! 	  /* If lendiff > prompt_visible_length and _rl_last_c_pos == 0 and
  	     _rl_horizontal_scroll_mode == 1, inserting the characters with
! 	     _rl_term_IC or _rl_term_ic will screw up the screen because of the
  	     invisible characters.  We need to just draw them. */
  	  if (*ols && (!_rl_horizontal_scroll_mode || _rl_last_c_pos > 0 ||
! 			lendiff <= prompt_visible_length || !current_invis_chars))
  	    {
  	      insert_some_chars (nfd, lendiff);
***************
*** 1022,1026 ****
      {
        /* If possible and inexpensive to use terminal deletion, then do so. */
!       if (term_dc && (2 * temp) >= -lendiff)
  	{
  	  /* If all we're doing is erasing the invisible characters in the
--- 1067,1071 ----
      {
        /* If possible and inexpensive to use terminal deletion, then do so. */
!       if (_rl_term_dc && (2 * temp) >= -lendiff)
  	{
  	  /* If all we're doing is erasing the invisible characters in the
***************
*** 1107,1111 ****
       to use the real screenwidth. Readline's notion of screenwidth might be
       one less, see terminal.c. */
!   real_screenwidth = screenwidth + (_rl_term_autowrap ? 0 : 1);
    _rl_last_v_pos = l / real_screenwidth;
    /* If the prompt length is a multiple of real_screenwidth, we don't know
--- 1152,1156 ----
       to use the real screenwidth. Readline's notion of screenwidth might be
       one less, see terminal.c. */
!   real_screenwidth = _rl_screenwidth + (_rl_term_autowrap ? 0 : 1);
    _rl_last_v_pos = l / real_screenwidth;
    /* If the prompt length is a multiple of real_screenwidth, we don't know
***************
*** 1152,1156 ****
  _rl_move_cursor_relative (new, data)
       int new;
!      char *data;
  {
    register int i;
--- 1197,1201 ----
  _rl_move_cursor_relative (new, data)
       int new;
!      const char *data;
  {
    register int i;
***************
*** 1164,1173 ****
    i = _rl_last_c_pos - W_OFFSET(_rl_last_v_pos, visible_wrap_offset);
    if (new == 0 || CR_FASTER (new, _rl_last_c_pos) ||
!       (_rl_term_autowrap && i == screenwidth))
      {
  #if defined (__MSDOS__)
        putc ('\r', rl_outstream);
  #else
!       tputs (term_cr, 1, _rl_output_character_function);
  #endif /* !__MSDOS__ */
        _rl_last_c_pos = 0;
--- 1209,1218 ----
    i = _rl_last_c_pos - W_OFFSET(_rl_last_v_pos, visible_wrap_offset);
    if (new == 0 || CR_FASTER (new, _rl_last_c_pos) ||
!       (_rl_term_autowrap && i == _rl_screenwidth))
      {
  #if defined (__MSDOS__)
        putc ('\r', rl_outstream);
  #else
!       tputs (_rl_term_cr, 1, _rl_output_character_function);
  #endif /* !__MSDOS__ */
        _rl_last_c_pos = 0;
***************
*** 1186,1192 ****
  	 data is underneath the cursor. */
  #if defined (HACK_TERMCAP_MOTION)
!       if (term_forward_char)
  	for (i = _rl_last_c_pos; i < new; i++)
! 	  tputs (term_forward_char, 1, _rl_output_character_function);
        else
  	for (i = _rl_last_c_pos; i < new; i++)
--- 1231,1237 ----
  	 data is underneath the cursor. */
  #if defined (HACK_TERMCAP_MOTION)
!       if (_rl_term_forward_char)
  	for (i = _rl_last_c_pos; i < new; i++)
! 	  tputs (_rl_term_forward_char, 1, _rl_output_character_function);
        else
  	for (i = _rl_last_c_pos; i < new; i++)
***************
*** 1209,1213 ****
    register int delta, i;
  
!   if (_rl_last_v_pos == to || to > screenheight)
      return;
  
--- 1254,1258 ----
    register int delta, i;
  
!   if (_rl_last_v_pos == to || to > _rl_screenheight)
      return;
  
***************
*** 1219,1223 ****
        putc ('\r', rl_outstream);
  #else
!       tputs (term_cr, 1, _rl_output_character_function);
  #endif
        _rl_last_c_pos = 0;
--- 1264,1268 ----
        putc ('\r', rl_outstream);
  #else
!       tputs (_rl_term_cr, 1, _rl_output_character_function);
  #endif
        _rl_last_c_pos = 0;
***************
*** 1225,1231 ****
    else
      {			/* delta < 0 */
!       if (term_up && *term_up)
  	for (i = 0; i < -delta; i++)
! 	  tputs (term_up, 1, _rl_output_character_function);
      }
  
--- 1270,1276 ----
    else
      {			/* delta < 0 */
!       if (_rl_term_up && *_rl_term_up)
  	for (i = 0; i < -delta; i++)
! 	  tputs (_rl_term_up, 1, _rl_output_character_function);
      }
  
***************
*** 1361,1369 ****
    saved_local_prompt = local_prompt;
    saved_local_prefix = local_prompt_prefix;
!   saved_last_invisible = last_invisible;
!   saved_visible_length = visible_length;
  
    local_prompt = local_prompt_prefix = (char *)0;
!   last_invisible = visible_length = 0;
  }
  
--- 1406,1414 ----
    saved_local_prompt = local_prompt;
    saved_local_prefix = local_prompt_prefix;
!   saved_last_invisible = prompt_last_invisible;
!   saved_visible_length = prompt_visible_length;
  
    local_prompt = local_prompt_prefix = (char *)0;
!   prompt_last_invisible = prompt_visible_length = 0;
  }
  
***************
*** 1371,1383 ****
  rl_restore_prompt ()
  {
!   if (local_prompt)
!     free (local_prompt);
!   if (local_prompt_prefix)
!     free (local_prompt_prefix);
  
    local_prompt = saved_local_prompt;
    local_prompt_prefix = saved_local_prefix;
!   last_invisible = saved_last_invisible;
!   visible_length = saved_visible_length;
  }
  
--- 1416,1426 ----
  rl_restore_prompt ()
  {
!   FREE (local_prompt);
!   FREE (local_prompt_prefix);
  
    local_prompt = saved_local_prompt;
    local_prompt_prefix = saved_local_prefix;
!   prompt_last_invisible = saved_last_invisible;
!   prompt_visible_length = saved_visible_length;
  }
  
***************
*** 1409,1414 ****
        pmt[len+1] = '\0';
        local_prompt = savestring (pmt);
!       last_invisible = saved_last_invisible;
!       visible_length = saved_visible_length + 1;
      }
    return pmt;
--- 1452,1457 ----
        pmt[len+1] = '\0';
        local_prompt = savestring (pmt);
!       prompt_last_invisible = saved_last_invisible;
!       prompt_visible_length = saved_visible_length + 1;
      }
    return pmt;
***************
*** 1437,1442 ****
       int count;
  {
!   if (term_clreol)
!     tputs (term_clreol, 1, _rl_output_character_function);
    else if (count)
      space_to_eol (count);
--- 1480,1485 ----
       int count;
  {
!   if (_rl_term_clreol)
!     tputs (_rl_term_clreol, 1, _rl_output_character_function);
    else if (count)
      space_to_eol (count);
***************
*** 1460,1467 ****
  _rl_clear_screen ()
  {
!   if (term_clrpag)
!     tputs (term_clrpag, 1, _rl_output_character_function);
    else
!     crlf ();
  }
  
--- 1503,1510 ----
  _rl_clear_screen ()
  {
!   if (_rl_term_clrpag)
!     tputs (_rl_term_clrpag, 1, _rl_output_character_function);
    else
!     rl_crlf ();
  }
  
***************
*** 1473,1480 ****
  {
    /* If IC is defined, then we do not have to "enter" insert mode. */
!   if (term_IC)
      {
        char *buffer;
!       buffer = tgoto (term_IC, 0, count);
        tputs (buffer, 1, _rl_output_character_function);
        _rl_output_some_chars (string, count);
--- 1516,1523 ----
  {
    /* If IC is defined, then we do not have to "enter" insert mode. */
!   if (_rl_term_IC)
      {
        char *buffer;
!       buffer = tgoto (_rl_term_IC, 0, count);
        tputs (buffer, 1, _rl_output_character_function);
        _rl_output_some_chars (string, count);
***************
*** 1485,1497 ****
  
        /* If we have to turn on insert-mode, then do so. */
!       if (term_im && *term_im)
! 	tputs (term_im, 1, _rl_output_character_function);
  
        /* If there is a special command for inserting characters, then
  	 use that first to open up the space. */
!       if (term_ic && *term_ic)
  	{
  	  for (i = count; i--; )
! 	    tputs (term_ic, 1, _rl_output_character_function);
  	}
  
--- 1528,1540 ----
  
        /* If we have to turn on insert-mode, then do so. */
!       if (_rl_term_im && *_rl_term_im)
! 	tputs (_rl_term_im, 1, _rl_output_character_function);
  
        /* If there is a special command for inserting characters, then
  	 use that first to open up the space. */
!       if (_rl_term_ic && *_rl_term_ic)
  	{
  	  for (i = count; i--; )
! 	    tputs (_rl_term_ic, 1, _rl_output_character_function);
  	}
  
***************
*** 1501,1506 ****
        /* If there is a string to turn off insert mode, we had best use
  	 it now. */
!       if (term_ei && *term_ei)
! 	tputs (term_ei, 1, _rl_output_character_function);
      }
  }
--- 1544,1549 ----
        /* If there is a string to turn off insert mode, we had best use
  	 it now. */
!       if (_rl_term_ei && *_rl_term_ei)
! 	tputs (_rl_term_ei, 1, _rl_output_character_function);
      }
  }
***************
*** 1511,1528 ****
       int count;
  {
!   if (count > screenwidth)	/* XXX */
      return;
  
!   if (term_DC && *term_DC)
      {
        char *buffer;
!       buffer = tgoto (term_DC, count, count);
        tputs (buffer, count, _rl_output_character_function);
      }
    else
      {
!       if (term_dc && *term_dc)
  	while (count--)
! 	  tputs (term_dc, 1, _rl_output_character_function);
      }
  }
--- 1554,1571 ----
       int count;
  {
!   if (count > _rl_screenwidth)	/* XXX */
      return;
  
!   if (_rl_term_DC && *_rl_term_DC)
      {
        char *buffer;
!       buffer = tgoto (_rl_term_DC, count, count);
        tputs (buffer, count, _rl_output_character_function);
      }
    else
      {
!       if (_rl_term_dc && *_rl_term_dc)
  	while (count--)
! 	  tputs (_rl_term_dc, 1, _rl_output_character_function);
      }
  }
***************
*** 1544,1548 ****
    _rl_move_vert (_rl_vis_botlin);
    /* If we've wrapped lines, remove the final xterm line-wrap flag. */
!   if (full_lines && _rl_term_autowrap && (VIS_LLEN(_rl_vis_botlin) == screenwidth))
      {
        char *last_line;
--- 1587,1591 ----
    _rl_move_vert (_rl_vis_botlin);
    /* If we've wrapped lines, remove the final xterm line-wrap flag. */
!   if (full_lines && _rl_term_autowrap && (VIS_LLEN(_rl_vis_botlin) == _rl_screenwidth))
      {
        char *last_line;
***************
*** 1552,1561 ****
        last_line = &visible_line[vis_lbreaks[_rl_vis_botlin]];
  #endif
!       _rl_move_cursor_relative (screenwidth - 1, last_line);
        _rl_clear_to_eol (0);
!       putc (last_line[screenwidth - 1], rl_outstream);
      }
    _rl_vis_botlin = 0;
!   crlf ();
    fflush (rl_outstream);
    rl_display_fixed++;
--- 1595,1604 ----
        last_line = &visible_line[vis_lbreaks[_rl_vis_botlin]];
  #endif
!       _rl_move_cursor_relative (_rl_screenwidth - 1, last_line);
        _rl_clear_to_eol (0);
!       putc (last_line[_rl_screenwidth - 1], rl_outstream);
      }
    _rl_vis_botlin = 0;
!   rl_crlf ();
    fflush (rl_outstream);
    rl_display_fixed++;
***************
*** 1566,1575 ****
  cr ()
  {
!   if (term_cr)
      {
  #if defined (__MSDOS__)
        putc ('\r', rl_outstream);
  #else
!       tputs (term_cr, 1, _rl_output_character_function);
  #endif
        _rl_last_c_pos = 0;
--- 1609,1618 ----
  cr ()
  {
!   if (_rl_term_cr)
      {
  #if defined (__MSDOS__)
        putc ('\r', rl_outstream);
  #else
!       tputs (_rl_term_cr, 1, _rl_output_character_function);
  #endif
        _rl_last_c_pos = 0;
***************
*** 1585,1589 ****
  {
    char *oldp, *oldl, *oldlprefix;
!   int oldlen, oldlast, oldplen;
  
    /* Geez, I should make this a struct. */
--- 1628,1632 ----
  {
    char *oldp, *oldl, *oldlprefix;
!   int oldlen, oldlast, oldplen, oldninvis;
  
    /* Geez, I should make this a struct. */
***************
*** 1591,1600 ****
    oldl = local_prompt;
    oldlprefix = local_prompt_prefix;
!   oldlen = visible_length;
!   oldplen = prefix_length;
!   oldlast = last_invisible;
  
    rl_display_prompt = t;
!   local_prompt = expand_prompt (t, &visible_length, &last_invisible);
    local_prompt_prefix = (char *)NULL;
    rl_forced_update_display ();
--- 1634,1646 ----
    oldl = local_prompt;
    oldlprefix = local_prompt_prefix;
!   oldlen = prompt_visible_length;
!   oldplen = prompt_prefix_length;
!   oldlast = prompt_last_invisible;
!   oldninvis = prompt_invis_chars_first_line;
  
    rl_display_prompt = t;
!   local_prompt = expand_prompt (t, &prompt_visible_length,
! 				   &prompt_last_invisible,
! 				   &prompt_invis_chars_first_line);
    local_prompt_prefix = (char *)NULL;
    rl_forced_update_display ();
***************
*** 1603,1609 ****
    local_prompt = oldl;
    local_prompt_prefix = oldlprefix;
!   visible_length = oldlen;
!   prefix_length = oldplen;
!   last_invisible = oldlast;
  }
        
--- 1649,1656 ----
    local_prompt = oldl;
    local_prompt_prefix = oldlprefix;
!   prompt_visible_length = oldlen;
!   prompt_prefix_length = oldplen;
!   prompt_last_invisible = oldlast;
!   prompt_invis_chars_first_line = oldninvis;
  }
        
***************
*** 1616,1637 ****
    /* Clear the current line and put the cursor at column 0.  Make sure
       the right thing happens if we have wrapped to a new screen line. */
!   if (term_cr)
      {
  #if defined (__MSDOS__)
        putc ('\r', rl_outstream);
  #else
!       tputs (term_cr, 1, _rl_output_character_function);
  #endif
        _rl_last_c_pos = 0;
  #if defined (__MSDOS__)
!       space_to_eol (screenwidth);
        putc ('\r', rl_outstream);
  #else
!       if (term_clreol)
! 	tputs (term_clreol, 1, _rl_output_character_function);
        else
  	{
! 	  space_to_eol (screenwidth);
! 	  tputs (term_cr, 1, _rl_output_character_function);
  	}
  #endif
--- 1663,1684 ----
    /* Clear the current line and put the cursor at column 0.  Make sure
       the right thing happens if we have wrapped to a new screen line. */
!   if (_rl_term_cr)
      {
  #if defined (__MSDOS__)
        putc ('\r', rl_outstream);
  #else
!       tputs (_rl_term_cr, 1, _rl_output_character_function);
  #endif
        _rl_last_c_pos = 0;
  #if defined (__MSDOS__)
!       space_to_eol (_rl_screenwidth);
        putc ('\r', rl_outstream);
  #else
!       if (_rl_term_clreol)
! 	tputs (_rl_term_clreol, 1, _rl_output_character_function);
        else
  	{
! 	  space_to_eol (_rl_screenwidth);
! 	  tputs (_rl_term_cr, 1, _rl_output_character_function);
  	}
  #endif
***************
*** 1640,1644 ****
      }
    else
!     crlf ();
  
    /* Redraw only the last line of a multi-line prompt. */
--- 1687,1691 ----
      }
    else
!     rl_crlf ();
  
    /* Redraw only the last line of a multi-line prompt. */
***************
*** 1681,1690 ****
       editing buffer. */
    if (rl_display_prompt == rl_prompt)
!     nleft = _rl_last_c_pos - screenwidth - rl_visible_prompt_length;
    else
!     nleft = _rl_last_c_pos - screenwidth;
  
    if (nleft > 0)
!     ret = 1 + nleft / screenwidth;
    else
      ret = 0;
--- 1728,1737 ----
       editing buffer. */
    if (rl_display_prompt == rl_prompt)
!     nleft = _rl_last_c_pos - _rl_screenwidth - rl_visible_prompt_length;
    else
!     nleft = _rl_last_c_pos - _rl_screenwidth;
  
    if (nleft > 0)
!     ret = 1 + nleft / _rl_screenwidth;
    else
      ret = 0;
diff -Nrc2 bash-2.04/lib/readline/doc/hist.texinfo bash-2.05/lib/readline/doc/hist.texinfo
*** bash-2.04/lib/readline/doc/hist.texinfo	Thu Aug  5 08:25:11 1999
--- bash-2.05/lib/readline/doc/hist.texinfo	Fri Feb  2 11:37:12 2001
***************
*** 19,23 ****
  typed input.
  
! Copyright (C) 1988-1999 Free Software Foundation, Inc.
  
  Permission is granted to make and distribute verbatim copies of
--- 19,23 ----
  typed input.
  
! Copyright (C) 1988-2001 Free Software Foundation, Inc.
  
  Permission is granted to make and distribute verbatim copies of
***************
*** 74,78 ****
  
  @vskip 0pt plus 1filll
! Copyright @copyright{} 1988-1999 Free Software Foundation, Inc.
  @end titlepage
  
--- 74,78 ----
  
  @vskip 0pt plus 1filll
! Copyright @copyright{} 1988-2001 Free Software Foundation, Inc.
  @end titlepage
  
diff -Nrc2 bash-2.04/lib/readline/doc/hstech.texinfo bash-2.05/lib/readline/doc/hstech.texinfo
*** bash-2.04/lib/readline/doc/hstech.texinfo	Tue Sep 21 10:43:27 1999
--- bash-2.05/lib/readline/doc/hstech.texinfo	Mon Mar 12 05:37:38 2001
***************
*** 2,6 ****
  This file documents the user interface to the GNU History library.
  
! Copyright (C) 1988, 1991, 1994, 1996 Free Software Foundation, Inc.
  Authored by Brian Fox and Chet Ramey.
  
--- 2,6 ----
  This file documents the user interface to the GNU History library.
  
! Copyright (C) 1988-2001 Free Software Foundation, Inc.
  Authored by Brian Fox and Chet Ramey.
  
***************
*** 28,34 ****
  
  This chapter describes how to interface programs that you write
! with the GNU History Library.
  It should be considered a technical guide.
! For information on the interactive use of GNU History, @pxref{Using
  History Interactively}.
  
--- 28,34 ----
  
  This chapter describes how to interface programs that you write
! with the @sc{gnu} History Library.
  It should be considered a technical guide.
! For information on the interactive use of @sc{gnu} History, @pxref{Using
  History Interactively}.
  
***************
*** 44,51 ****
  @section Introduction to History
  
! Many programs read input from the user a line at a time.  The GNU History
! library is able to keep track of those lines, associate arbitrary data with
! each line, and utilize information from previous lines in composing new
! ones.
  
  The programmer using the History library has available functions
--- 44,51 ----
  @section Introduction to History
  
! Many programs read input from the user a line at a time.  The @sc{gnu}
! History library is able to keep track of those lines, associate arbitrary
! data with each line, and utilize information from previous lines in
! composing new ones. 
  
  The programmer using the History library has available functions
***************
*** 81,87 ****
  
  @example
  typedef struct _hist_entry @{
    char *line;
!   char *data;
  @} HIST_ENTRY;
  @end example
--- 81,89 ----
  
  @example
+ typedef void *histdata_t;
+ 
  typedef struct _hist_entry @{
    char *line;
!   histdata_t data;
  @} HIST_ENTRY;
  @end example
***************
*** 96,105 ****
  
  @example
! /* A structure used to pass the current state of the history stuff around. */
  typedef struct _hist_state @{
!   HIST_ENTRY **entries;         /* Pointer to the entries themselves. */
!   int offset;                   /* The location pointer within this array. */
!   int length;                   /* Number of elements within this array. */
!   int size;                     /* Number of slots allocated to this array. */
    int flags;
  @} HISTORY_STATE;
--- 98,109 ----
  
  @example
! /*
!  * A structure used to pass around the current state of the history.
!  */
  typedef struct _hist_state @{
!   HIST_ENTRY **entries; /* Pointer to the entries themselves. */
!   int offset;           /* The location pointer within this array. */
!   int length;           /* Number of elements within this array. */
!   int size;             /* Number of slots allocated to this array. */
    int flags;
  @} HISTORY_STATE;
***************
*** 113,117 ****
  
  This section describes the calling sequence for the various functions
! present in GNU History.
  
  @menu
--- 117,121 ----
  
  This section describes the calling sequence for the various functions
! exported by the @sc{gnu} History library.
  
  @menu
***************
*** 140,149 ****
  functions in your program.
  
! @deftypefun void using_history ()
  Begin a session in which the history functions might be used.  This
  initializes the interactive variables.
  @end deftypefun
  
! @deftypefun {HISTORY_STATE *} history_get_history_state ()
  Return a structure describing the current state of the input history.
  @end deftypefun
--- 144,153 ----
  functions in your program.
  
! @deftypefun void using_history (void)
  Begin a session in which the history functions might be used.  This
  initializes the interactive variables.
  @end deftypefun
  
! @deftypefun {HISTORY_STATE *} history_get_history_state (void)
  Return a structure describing the current state of the input history.
  @end deftypefun
***************
*** 159,163 ****
  parameters managing the list itself.
  
! @deftypefun void add_history (char *string)
  Place @var{string} at the end of the history list.  The associated data
  field (if any) is set to @code{NULL}.
--- 163,167 ----
  parameters managing the list itself.
  
! @deftypefun void add_history (const char *string)
  Place @var{string} at the end of the history list.  The associated data
  field (if any) is set to @code{NULL}.
***************
*** 170,174 ****
  @end deftypefun
  
! @deftypefun {HIST_ENTRY *} replace_history_entry (int which, char *line, char *data)
  Make the history entry at offset @var{which} have @var{line} and @var{data}.
  This returns the old entry so you can dispose of the data.  In the case
--- 174,178 ----
  @end deftypefun
  
! @deftypefun {HIST_ENTRY *} replace_history_entry (int which, const char *line, histdata_t data)
  Make the history entry at offset @var{which} have @var{line} and @var{data}.
  This returns the old entry so you can dispose of the data.  In the case
***************
*** 176,180 ****
  @end deftypefun
  
! @deftypefun void clear_history ()
  Clear the history list by deleting all the entries.
  @end deftypefun
--- 180,184 ----
  @end deftypefun
  
! @deftypefun void clear_history (void)
  Clear the history list by deleting all the entries.
  @end deftypefun
***************
*** 184,188 ****
  @end deftypefun
  
! @deftypefun int unstifle_history ()
  Stop stifling the history.  This returns the previous amount the
  history was stifled.  The value is positive if the history was
--- 188,192 ----
  @end deftypefun
  
! @deftypefun int unstifle_history (void)
  Stop stifling the history.  This returns the previous amount the
  history was stifled.  The value is positive if the history was
***************
*** 190,194 ****
  @end deftypefun
  
! @deftypefun int history_is_stifled ()
  Returns non-zero if the history is stifled, zero if it is not.
  @end deftypefun
--- 194,198 ----
  @end deftypefun
  
! @deftypefun int history_is_stifled (void)
  Returns non-zero if the history is stifled, zero if it is not.
  @end deftypefun
***************
*** 200,216 ****
  individual list entries.
  
! @deftypefun {HIST_ENTRY **} history_list ()
! Return a @code{NULL} terminated array of @code{HIST_ENTRY} which is the
  current input history.  Element 0 of this list is the beginning of time.
  If there is no history, return @code{NULL}.
  @end deftypefun
  
! @deftypefun int where_history ()
  Returns the offset of the current history element.
  @end deftypefun
  
! @deftypefun {HIST_ENTRY *} current_history ()
  Return the history entry at the current position, as determined by
! @code{where_history ()}.  If there is no entry there, return a @code{NULL}
  pointer.
  @end deftypefun
--- 204,220 ----
  individual list entries.
  
! @deftypefun {HIST_ENTRY **} history_list (void)
! Return a @code{NULL} terminated array of @code{HIST_ENTRY *} which is the
  current input history.  Element 0 of this list is the beginning of time.
  If there is no history, return @code{NULL}.
  @end deftypefun
  
! @deftypefun int where_history (void)
  Returns the offset of the current history element.
  @end deftypefun
  
! @deftypefun {HIST_ENTRY *} current_history (void)
  Return the history entry at the current position, as determined by
! @code{where_history()}.  If there is no entry there, return a @code{NULL}
  pointer.
  @end deftypefun
***************
*** 218,226 ****
  @deftypefun {HIST_ENTRY *} history_get (int offset)
  Return the history entry at position @var{offset}, starting from
! @code{history_base}.  If there is no entry there, or if @var{offset}
  is greater than the history length, return a @code{NULL} pointer.
  @end deftypefun
  
! @deftypefun int history_total_bytes ()
  Return the number of bytes that the primary history entries are using.
  This function returns the sum of the lengths of all the lines in the
--- 222,231 ----
  @deftypefun {HIST_ENTRY *} history_get (int offset)
  Return the history entry at position @var{offset}, starting from
! @code{history_base} (@pxref{History Variables}).
! If there is no entry there, or if @var{offset}
  is greater than the history length, return a @code{NULL} pointer.
  @end deftypefun
  
! @deftypefun int history_total_bytes (void)
  Return the number of bytes that the primary history entries are using.
  This function returns the sum of the lengths of all the lines in the
***************
*** 235,243 ****
  
  @deftypefun int history_set_pos (int pos)
! Set the position in the history list to @var{pos}, an absolute index
  into the list.
  @end deftypefun
  
! @deftypefun {HIST_ENTRY *} previous_history ()
  Back up the current history offset to the previous history entry, and
  return a pointer to that entry.  If there is no previous entry, return
--- 240,250 ----
  
  @deftypefun int history_set_pos (int pos)
! Set the current history offset to @var{pos}, an absolute index
  into the list.
+ Returns 1 on success, 0 if @var{pos} is less than zero or greater
+ than the number of history entries.
  @end deftypefun
  
! @deftypefun {HIST_ENTRY *} previous_history (void)
  Back up the current history offset to the previous history entry, and
  return a pointer to that entry.  If there is no previous entry, return
***************
*** 245,249 ****
  @end deftypefun
  
! @deftypefun {HIST_ENTRY *} next_history ()
  Move the current history offset forward to the next history entry, and
  return the a pointer to that entry.  If there is no next entry, return
--- 252,256 ----
  @end deftypefun
  
! @deftypefun {HIST_ENTRY *} next_history (void)
  Move the current history offset forward to the next history entry, and
  return the a pointer to that entry.  If there is no next entry, return
***************
*** 261,268 ****
  @cindex anchored search
  
! @deftypefun int history_search (char *string, int direction)
! Search the history for @var{string}, starting at the current history
! offset.  If @var{direction} < 0, then the search is through previous entries,
! else through subsequent.  If @var{string} is found, then
  the current history index is set to that history entry, and the value
  returned is the offset in the line of the entry where
--- 268,276 ----
  @cindex anchored search
  
! @deftypefun int history_search (const char *string, int direction)
! Search the history for @var{string}, starting at the current history offset.
! If @var{direction} is less than 0, then the search is through
! previous entries, otherwise through subsequent entries.
! If @var{string} is found, then
  the current history index is set to that history entry, and the value
  returned is the offset in the line of the entry where
***************
*** 271,284 ****
  @end deftypefun
  
! @deftypefun int history_search_prefix (char *string, int direction)
  Search the history for @var{string}, starting at the current history
  offset.  The search is anchored: matching lines must begin with
! @var{string}.  If @var{direction} < 0, then the search is through previous
! entries, else through subsequent.  If @var{string} is found, then the
  current history index is set to that entry, and the return value is 0. 
  Otherwise, nothing is changed, and a -1 is returned. 
  @end deftypefun
  
! @deftypefun int history_search_pos (char *string, int direction, int pos)
  Search for @var{string} in the history list, starting at @var{pos}, an
  absolute index into the list.  If @var{direction} is negative, the search
--- 279,293 ----
  @end deftypefun
  
! @deftypefun int history_search_prefix (const char *string, int direction)
  Search the history for @var{string}, starting at the current history
  offset.  The search is anchored: matching lines must begin with
! @var{string}.  If @var{direction} is less than 0, then the search is
! through previous entries, otherwise through subsequent entries.
! If @var{string} is found, then the
  current history index is set to that entry, and the return value is 0. 
  Otherwise, nothing is changed, and a -1 is returned. 
  @end deftypefun
  
! @deftypefun int history_search_pos (const char *string, int direction, int pos)
  Search for @var{string} in the history list, starting at @var{pos}, an
  absolute index into the list.  If @var{direction} is negative, the search
***************
*** 293,306 ****
  This section documents the functions for managing a history file.
  
! @deftypefun int read_history (char *filename)
! Add the contents of @var{filename} to the history list, a line at a
! time.  If @var{filename} is @code{NULL}, then read from
! @file{~/.history}.  Returns 0 if successful, or errno if not.
  @end deftypefun
  
! @deftypefun int read_history_range (char *filename, int from, int to)
  Read a range of lines from @var{filename}, adding them to the history list.
! Start reading at line @var{from} and end at @var{to}.  If
! @var{from} is zero, start at the beginning.  If @var{to} is less than
  @var{from}, then read until the end of the file.  If @var{filename} is
  @code{NULL}, then read from @file{~/.history}.  Returns 0 if successful,
--- 302,315 ----
  This section documents the functions for managing a history file.
  
! @deftypefun int read_history (const char *filename)
! Add the contents of @var{filename} to the history list, a line at a time.
! If @var{filename} is @code{NULL}, then read from @file{~/.history}.
! Returns 0 if successful, or @code{errno} if not.
  @end deftypefun
  
! @deftypefun int read_history_range (const char *filename, int from, int to)
  Read a range of lines from @var{filename}, adding them to the history list.
! Start reading at line @var{from} and end at @var{to}.
! If @var{from} is zero, start at the beginning.  If @var{to} is less than
  @var{from}, then read until the end of the file.  If @var{filename} is
  @code{NULL}, then read from @file{~/.history}.  Returns 0 if successful,
***************
*** 308,325 ****
  @end deftypefun
  
! @deftypefun int write_history (char *filename)
  Write the current history to @var{filename}, overwriting @var{filename}
! if necessary.  If @var{filename} is
! @code{NULL}, then write the history list to @file{~/.history}.  Values
! returned are as in @code{read_history ()}.
  @end deftypefun
  
! @deftypefun int append_history (int nelements, char *filename)
  Append the last @var{nelements} of the history list to @var{filename}.
  @end deftypefun
  
! @deftypefun int history_truncate_file (char *filename, int nlines)
  Truncate the history file @var{filename}, leaving only the last
  @var{nlines} lines.
  @end deftypefun
  
--- 317,339 ----
  @end deftypefun
  
! @deftypefun int write_history (const char *filename)
  Write the current history to @var{filename}, overwriting @var{filename}
! if necessary.
! If @var{filename} is @code{NULL}, then write the history list to
! @file{~/.history}.
! Returns 0 on success, or @code{errno} on a read or write error.
  @end deftypefun
  
! @deftypefun int append_history (int nelements, const char *filename)
  Append the last @var{nelements} of the history list to @var{filename}.
+ If @var{filename} is @code{NULL}, then append to @file{~/.history}.
+ Returns 0 on success, or @code{errno} on a read or write error.
  @end deftypefun
  
! @deftypefun int history_truncate_file (const char *filename, int nlines)
  Truncate the history file @var{filename}, leaving only the last
  @var{nlines} lines.
+ If @var{filename} is @code{NULL}, then @file{~/.history} is truncated.
+ Returns 0 on success, or @code{errno} on failure.
  @end deftypefun
  
***************
*** 327,331 ****
  @subsection History Expansion
  
! These functions implement @code{csh}-like history expansion.
  
  @deftypefun int history_expand (char *string, char **output)
--- 341,345 ----
  @subsection History Expansion
  
! These functions implement history expansion.
  
  @deftypefun int history_expand (char *string, char **output)
***************
*** 335,339 ****
  @item 0
  If no expansions took place (or, if the only change in
! the text was the de-slashifying of the history expansion
  character);
  @item 1
--- 349,353 ----
  @item 0
  If no expansions took place (or, if the only change in
! the text was the removal of escape characters preceding the history expansion
  character);
  @item 1
***************
*** 350,359 ****
  @end deftypefun
  
! @deftypefun {char *} history_arg_extract (int first, int last, char *string)
! Extract a string segment consisting of the @var{first} through @var{last}
! arguments present in @var{string}.  Arguments are broken up as in Bash.
! @end deftypefun
! 
! @deftypefun {char *} get_history_event (char *string, int *cindex, int qchar)
  Returns the text of the history event beginning at @var{string} +
  @var{*cindex}.  @var{*cindex} is modified to point to after the event
--- 364,368 ----
  @end deftypefun
  
! @deftypefun {char *} get_history_event (const char *string, int *cindex, int qchar)
  Returns the text of the history event beginning at @var{string} +
  @var{*cindex}.  @var{*cindex} is modified to point to after the event
***************
*** 364,372 ****
  @end deftypefun
  
! @deftypefun {char **} history_tokenize (char *string)
  Return an array of tokens parsed out of @var{string}, much as the
! shell might.  The tokens are split on white space and on the
! characters @code{()<>;&|$}, and shell quoting conventions are
! obeyed.
  @end deftypefun
  
--- 373,387 ----
  @end deftypefun
  
! @deftypefun {char **} history_tokenize (const char *string)
  Return an array of tokens parsed out of @var{string}, much as the
! shell might.  The tokens are split on the characters in the
! @var{history_word_delimiters} variable,
! and shell quoting conventions are obeyed.
! @end deftypefun
! 
! @deftypefun {char *} history_arg_extract (int first, int last, const char *string)
! Extract a string segment consisting of the @var{first} through @var{last}
! arguments present in @var{string}.  Arguments are split using
! @code{history_tokenize}.
  @end deftypefun
  
***************
*** 374,379 ****
  @section History Variables
  
! This section describes the externally visible variables exported by
! the GNU History Library.
  
  @deftypevar int history_base
--- 389,394 ----
  @section History Variables
  
! This section describes the externally-visible variables exported by
! the @sc{gnu} History Library.
  
  @deftypevar int history_base
***************
*** 385,395 ****
  @end deftypevar
  
! @deftypevar int max_input_history
  The maximum number of history entries.  This must be changed using
! @code{stifle_history ()}.
  @end deftypevar
  
  @deftypevar char history_expansion_char
! The character that starts a history event.  The default is @samp{!}.
  @end deftypevar
  
--- 400,411 ----
  @end deftypevar
  
! @deftypevar int history_max_entries
  The maximum number of history entries.  This must be changed using
! @code{stifle_history()}.
  @end deftypevar
  
  @deftypevar char history_expansion_char
! The character that introduces a history event.  The default is @samp{!}.
! Setting this to 0 inhibits history expansion.
  @end deftypevar
  
***************
*** 406,418 ****
  @end deftypevar
  
  @deftypevar {char *} history_no_expand_chars
  The list of characters which inhibit history expansion if found immediately
! following @var{history_expansion_char}.  The default is whitespace and
! @samp{=}.
  @end deftypevar
  
  @deftypevar {char *} history_search_delimiter_chars
  The list of additional characters which can delimit a history search
! string, in addition to whitespace, @samp{:} and @samp{?} in the case of
  a substring search.  The default is empty.
  @end deftypevar
--- 422,439 ----
  @end deftypevar
  
+ @deftypevar {char *} history_word_delimiters
+ The characters that separate tokens for \fBhistory_tokenize()\fP.
+ The default value is @code{" \t\n()<>;&|"}.
+ @end deftypevar
+ 
  @deftypevar {char *} history_no_expand_chars
  The list of characters which inhibit history expansion if found immediately
! following @var{history_expansion_char}.  The default is space, tab, newline,
! carriage return, and @samp{=}.
  @end deftypevar
  
  @deftypevar {char *} history_search_delimiter_chars
  The list of additional characters which can delimit a history search
! string, in addition to space, TAB, @samp{:} and @samp{?} in the case of
  a substring search.  The default is empty.
  @end deftypevar
***************
*** 423,429 ****
  @end deftypevar
  
! @deftypevar {Function *} history_inhibit_expansion_function
  This should be set to the address of a function that takes two arguments:
! a @code{char *} (@var{string}) and an integer index into that string (@var{i}).
  It should return a non-zero value if the history expansion starting at
  @var{string[i]} should not be performed; zero if the expansion should
--- 444,451 ----
  @end deftypevar
  
! @deftypevar {rl_linebuf_func_t *} history_inhibit_expansion_function
  This should be set to the address of a function that takes two arguments:
! a @code{char *} (@var{string})
! and an @code{int} index into that string (@var{i}).
  It should return a non-zero value if the history expansion starting at
  @var{string[i]} should not be performed; zero if the expansion should
***************
*** 431,435 ****
  It is intended for use by applications like Bash that use the history
  expansion character for additional purposes.
! By default, this variable is set to NULL.
  @end deftypevar
  
--- 453,457 ----
  It is intended for use by applications like Bash that use the history
  expansion character for additional purposes.
! By default, this variable is set to @code{NULL}.
  @end deftypevar
  
***************
*** 437,444 ****
  @section History Programming Example
  
! The following program demonstrates simple use of the GNU History Library.
  
  @smallexample
! main ()
  @{
    char line[1024], *t;
--- 459,471 ----
  @section History Programming Example
  
! The following program demonstrates simple use of the @sc{gnu} History Library.
  
  @smallexample
! #include <stdio.h>
! #include <readline/history.h>
! 
! main (argc, argv)
!      int argc;
!      char **argv;
  @{
    char line[1024], *t;
diff -Nrc2 bash-2.04/lib/readline/doc/hsuser.texinfo bash-2.05/lib/readline/doc/hsuser.texinfo
*** bash-2.04/lib/readline/doc/hsuser.texinfo	Fri Dec 17 07:01:17 1999
--- bash-2.05/lib/readline/doc/hsuser.texinfo	Wed Nov 22 12:42:50 2000
***************
*** 39,45 ****
  @end ifset
  @ifclear BashFeatures
! This chapter describes how to use the GNU History Library interactively,
  from a user's standpoint.  It should be considered a user's guide.  For
! information on using the GNU History Library in your own programs,
  @pxref{Programming with GNU History}.
  @end ifclear
--- 39,45 ----
  @end ifset
  @ifclear BashFeatures
! This chapter describes how to use the @sc{gnu} History Library interactively,
  from a user's standpoint.  It should be considered a user's guide.  For
! information on using the @sc{gnu} History Library in your own programs,
  @pxref{Programming with GNU History}.
  @end ifclear
***************
*** 66,76 ****
  @cindex history list
  
! When the @samp{-o history} option to the @code{set} builtin
  is enabled (@pxref{The Set Builtin}),
! the shell provides access to the @var{command history},
  the list of commands previously typed.
! The value of the @code{HISTSIZE} shell variable is used as the
  number of commands to save in a history list.
! The text of the last @code{$HISTSIZE}
  commands (default 500) is saved.
  The shell stores each command in the history list prior to
--- 66,76 ----
  @cindex history list
  
! When the @option{-o history} option to the @code{set} builtin
  is enabled (@pxref{The Set Builtin}),
! the shell provides access to the @dfn{command history},
  the list of commands previously typed.
! The value of the @env{HISTSIZE} shell variable is used as the
  number of commands to save in a history list.
! The text of the last @env{$HISTSIZE}
  commands (default 500) is saved.
  The shell stores each command in the history list prior to
***************
*** 78,99 ****
  but after history expansion is performed, subject to the
  values of the shell variables
! @code{HISTIGNORE} and @code{HISTCONTROL}.
  
  When the shell starts up, the history is initialized from the
! file named by the @code{HISTFILE} variable (default @file{~/.bash_history}).
! The file named by the value of @code{HISTFILE} is truncated, if
  necessary, to contain no more than the number of lines specified by
! the value of the @code{HISTFILESIZE} variable.
  When an interactive shell exits, the last
! @code{$HISTSIZE} lines are copied from the history list to the file
! named by @code{$HISTFILE}.
  If the @code{histappend} shell option is set (@pxref{Bash Builtins}),
  the lines are appended to the history file,
  otherwise the history file is overwritten.
! If @code{HISTFILE}
  is unset, or if the history file is unwritable, the history is
  not saved.  After saving the history, the history file is truncated
! to contain no more than @code{$HISTFILESIZE}
! lines.  If @code{HISTFILESIZE} is not set, no truncation is performed.
  
  The builtin command @code{fc} may be used to list or edit and re-execute
--- 78,99 ----
  but after history expansion is performed, subject to the
  values of the shell variables
! @env{HISTIGNORE} and @env{HISTCONTROL}.
  
  When the shell starts up, the history is initialized from the
! file named by the @env{HISTFILE} variable (default @file{~/.bash_history}).
! The file named by the value of @env{HISTFILE} is truncated, if
  necessary, to contain no more than the number of lines specified by
! the value of the @env{HISTFILESIZE} variable.
  When an interactive shell exits, the last
! @env{$HISTSIZE} lines are copied from the history list to the file
! named by @env{$HISTFILE}.
  If the @code{histappend} shell option is set (@pxref{Bash Builtins}),
  the lines are appended to the history file,
  otherwise the history file is overwritten.
! If @env{HISTFILE}
  is unset, or if the history file is unwritable, the history is
  not saved.  After saving the history, the history file is truncated
! to contain no more than @env{$HISTFILESIZE}
! lines.  If @env{HISTFILESIZE} is not set, no truncation is performed.
  
  The builtin command @code{fc} may be used to list or edit and re-execute
***************
*** 106,110 ****
  
  The shell allows control over which commands are saved on the history
! list.  The @code{HISTCONTROL} and @code{HISTIGNORE}
  variables may be set to cause the shell to save only a subset of the
  commands entered.
--- 106,110 ----
  
  The shell allows control over which commands are saved on the history
! list.  The @env{HISTCONTROL} and @env{HISTIGNORE}
  variables may be set to cause the shell to save only a subset of the
  commands entered.
***************
*** 142,154 ****
  current command number).  If @var{last} is not specified it is set to
  @var{first}.  If @var{first} is not specified it is set to the previous
! command for editing and @minus{}16 for listing.  If the @samp{-l} flag is
! given, the commands are listed on standard output.  The @samp{-n} flag
! suppresses the command numbers when listing.  The @samp{-r} flag
  reverses the order of the listing.  Otherwise, the editor given by
  @var{ename} is invoked on a file containing those commands.  If
  @var{ename} is not given, the value of the following variable expansion
  is used: @code{$@{FCEDIT:-$@{EDITOR:-vi@}@}}.  This says to use the
! value of the @code{FCEDIT} variable if set, or the value of the
! @code{EDITOR} variable if that is set, or @code{vi} if neither is set.
  When editing is complete, the edited commands are echoed and executed.
  
--- 142,154 ----
  current command number).  If @var{last} is not specified it is set to
  @var{first}.  If @var{first} is not specified it is set to the previous
! command for editing and @minus{}16 for listing.  If the @option{-l} flag is
! given, the commands are listed on standard output.  The @option{-n} flag
! suppresses the command numbers when listing.  The @option{-r} flag
  reverses the order of the listing.  Otherwise, the editor given by
  @var{ename} is invoked on a file containing those commands.  If
  @var{ename} is not given, the value of the following variable expansion
  is used: @code{$@{FCEDIT:-$@{EDITOR:-vi@}@}}.  This says to use the
! value of the @env{FCEDIT} variable if set, or the value of the
! @env{EDITOR} variable if that is set, or @code{vi} if neither is set.
  When editing is complete, the edited commands are echoed and executed.
  
***************
*** 171,175 ****
  
  With no options, display the history list with line numbers.
! Lines prefixed with with a @samp{*} have been modified.
  An argument of @var{n} lists only the last @var{n} lines.
  Options, if supplied, have the following meanings:
--- 171,175 ----
  
  With no options, display the history list with line numbers.
! Lines prefixed with a @samp{*} have been modified.
  An argument of @var{n} lists only the last @var{n} lines.
  Options, if supplied, have the following meanings:
***************
*** 212,219 ****
  @end table
  
! When any of the @samp{-w}, @samp{-r}, @samp{-a}, or @samp{-n} options is
  used, if @var{filename}
  is given, then it is used as the history file.  If not, then
! the value of the @code{HISTFILE} variable is used.
  
  @end table
--- 212,219 ----
  @end table
  
! When any of the @option{-w}, @option{-r}, @option{-a}, or @option{-n} options is
  used, if @var{filename}
  is given, then it is used as the history file.  If not, then
! the value of the @env{HISTFILE} variable is used.
  
  @end table
***************
*** 261,267 ****
  shell option is enabled, a failed history expansion will be
  reloaded into the Readline editing buffer for correction.
! The @samp{-p} option to the @code{history} builtin command
  may be used to see what a history expansion will do before using it.
! The @samp{-s} option to the @code{history} builtin may be used to
  add commands to the end of the history list without actually executing
  them, so that they are available for subsequent recall.
--- 261,267 ----
  shell option is enabled, a failed history expansion will be
  reloaded into the Readline editing buffer for correction.
! The @option{-p} option to the @code{history} builtin command
  may be used to see what a history expansion will do before using it.
! The @option{-s} option to the @code{history} builtin may be used to
  add commands to the end of the history list without actually executing
  them, so that they are available for subsequent recall.
diff -Nrc2 bash-2.04/lib/readline/doc/manvers.texinfo bash-2.05/lib/readline/doc/manvers.texinfo
*** bash-2.04/lib/readline/doc/manvers.texinfo	Wed Jan 19 12:16:33 2000
--- bash-2.05/lib/readline/doc/manvers.texinfo	Mon Mar 12 05:36:47 2001
***************
*** 1,6 ****
! @set EDITION 4.1
! @set VERSION 4.1
! @set UPDATED 2000 January 19
! @set UPDATE-MONTH January 2000
  
! @set LASTCHANGE Wed Jan 19 12:16:30 EST 2000
--- 1,6 ----
! @set EDITION 4.2-beta
! @set VERSION 4.2-beta
! @set UPDATED 2001 Mar 12
! @set UPDATE-MONTH Mar 2001
  
! @set LASTCHANGE Mon Mar 12 05:36:44 EST 2001
diff -Nrc2 bash-2.04/lib/readline/doc/rlman.texinfo bash-2.05/lib/readline/doc/rlman.texinfo
*** bash-2.04/lib/readline/doc/rlman.texinfo	Thu Aug  5 08:25:33 1999
--- bash-2.05/lib/readline/doc/rlman.texinfo	Fri Feb  2 11:49:17 2001
***************
*** 19,23 ****
  to provide a command line interface.
  
! Copyright (C) 1988-1999 Free Software Foundation, Inc.
  
  Permission is granted to make and distribute verbatim copies of
--- 19,23 ----
  to provide a command line interface.
  
! Copyright (C) 1988-2001 Free Software Foundation, Inc.
  
  Permission is granted to make and distribute verbatim copies of
***************
*** 74,78 ****
  
  @vskip 0pt plus 1filll
! Copyright @copyright{} 1988-1999 Free Software Foundation, Inc.
  @end titlepage
  
--- 74,78 ----
  
  @vskip 0pt plus 1filll
! Copyright @copyright{} 1988-2001 Free Software Foundation, Inc.
  @end titlepage
  
diff -Nrc2 bash-2.04/lib/readline/doc/rltech.texinfo bash-2.05/lib/readline/doc/rltech.texinfo
*** bash-2.04/lib/readline/doc/rltech.texinfo	Mon Feb 28 10:55:08 2000
--- bash-2.05/lib/readline/doc/rltech.texinfo	Mon Mar 12 05:42:09 2001
***************
*** 9,13 ****
  to provide a command line interface.
  
! Copyright (C) 1988, 1994, 1996, 1998, 1999 Free Software Foundation, Inc.
  
  Permission is granted to make and distribute verbatim copies of
--- 9,13 ----
  to provide a command line interface.
  
! Copyright (C) 1988-2001 Free Software Foundation, Inc.
  
  Permission is granted to make and distribute verbatim copies of
***************
*** 36,42 ****
  @chapter Programming with GNU Readline
  
! This chapter describes the interface between the GNU Readline Library and
  other programs.  If you are a programmer, and you wish to include the
! features found in GNU Readline
  such as completion, line editing, and interactive history manipulation
  in your own programs, this section is for you.
--- 36,42 ----
  @chapter Programming with GNU Readline
  
! This chapter describes the interface between the @sc{gnu} Readline Library and
  other programs.  If you are a programmer, and you wish to include the
! features found in @sc{gnu} Readline
  such as completion, line editing, and interactive history manipulation
  in your own programs, this section is for you.
***************
*** 62,77 ****
  Readline is sufficient.  This section describes how to use Readline in
  the simplest way possible, perhaps to replace calls in your code to
! @code{gets()} or @code{fgets ()}.
  
  @findex readline
  @cindex readline, function
! The function @code{readline ()} prints a prompt and then reads and returns
! a single line of text from the user.  The line @code{readline}
! returns is allocated with @code{malloc ()}; you should @code{free ()}
! the line when you are done with it.  The declaration for @code{readline}
! in ANSI C is
  
  @example
! @code{char *readline (char *@var{prompt});}
  @end example
  
--- 62,79 ----
  Readline is sufficient.  This section describes how to use Readline in
  the simplest way possible, perhaps to replace calls in your code to
! @code{gets()} or @code{fgets()}.
  
  @findex readline
  @cindex readline, function
! 
! The function @code{readline()} prints a prompt @var{prompt}
! and then reads and returns a single line of text from the user.
! If @var{prompt} is @code{NULL} or the empty string, no prompt is displayed.
! The line @code{readline} returns is allocated with @code{malloc()};
! the caller should @code{free()} the line when it has finished with it.
! The declaration for @code{readline} in ANSI C is
  
  @example
! @code{char *readline (const char *@var{prompt});}
  @end example
  
***************
*** 91,95 ****
  
  If you want the user to be able to get at the line later, (with
! @key{C-p} for example), you must call @code{add_history ()} to save the
  line away in a @dfn{history} list of such lines.
  
--- 93,97 ----
  
  If you want the user to be able to get at the line later, (with
! @key{C-p} for example), you must call @code{add_history()} to save the
  line away in a @dfn{history} list of such lines.
  
***************
*** 103,107 ****
  It is preferable to avoid saving empty lines on the history list, since
  users rarely have a burning need to reuse a blank line.  Here is
! a function which usefully replaces the standard @code{gets ()} library
  function, and has the advantage of no static buffer to overflow:
  
--- 105,109 ----
  It is preferable to avoid saving empty lines on the history list, since
  users rarely have a burning need to reuse a blank line.  Here is
! a function which usefully replaces the standard @code{gets()} library
  function, and has the advantage of no static buffer to overflow:
  
***************
*** 136,150 ****
  completion: completion on file names.  If you do not want Readline to
  complete on filenames, you can change the binding of the @key{TAB} key
! with @code{rl_bind_key ()}.
  
  @example
! @code{int rl_bind_key (int @var{key}, int (*@var{function})());}
  @end example
  
! @code{rl_bind_key ()} takes two arguments: @var{key} is the character that
  you want to bind, and @var{function} is the address of the function to
! call when @var{key} is pressed.  Binding @key{TAB} to @code{rl_insert ()}
  makes @key{TAB} insert itself.
! @code{rl_bind_key ()} returns non-zero if @var{key} is not a valid
  ASCII character code (between 0 and 255).
  
--- 138,152 ----
  completion: completion on file names.  If you do not want Readline to
  complete on filenames, you can change the binding of the @key{TAB} key
! with @code{rl_bind_key()}.
  
  @example
! @code{int rl_bind_key (int @var{key}, rl_command_func_t *@var{function});}
  @end example
  
! @code{rl_bind_key()} takes two arguments: @var{key} is the character that
  you want to bind, and @var{function} is the address of the function to
! call when @var{key} is pressed.  Binding @key{TAB} to @code{rl_insert()}
  makes @key{TAB} insert itself.
! @code{rl_bind_key()} returns non-zero if @var{key} is not a valid
  ASCII character code (between 0 and 255).
  
***************
*** 155,159 ****
  
  This code should be executed once at the start of your program; you
! might write a function called @code{initialize_readline ()} which
  performs this and other desired initializations, such as installing
  custom completers (@pxref{Custom Completers}).
--- 157,161 ----
  
  This code should be executed once at the start of your program; you
! might write a function called @code{initialize_readline()} which
  performs this and other desired initializations, such as installing
  custom completers (@pxref{Custom Completers}).
***************
*** 176,217 ****
  
  @menu
! * The Function Type::	C declarations to make code readable.
  * Function Writing::	Variables and calling conventions.
  @end menu
  
! @node The Function Type
! @subsection The Function Type
  
! For readabilty, we declare a new type of object, called
! @dfn{Function}.  A @code{Function} is a C function which
! returns an @code{int}.  The type declaration for @code{Function} is:
  
! @noindent
! @code{typedef int Function ();}
  
! The reason for declaring this new type is to make it easier to write
! code describing pointers to C functions.  Let us say we had a variable
! called @var{func} which was a pointer to a function.  Instead of the
! classic C declaration
  
! @code{int (*)()func;}
  
  @noindent
  we may write
  
! @code{Function *func;}
  
! @noindent
! Similarly, there are
  
! @example
! typedef void VFunction ();
! typedef char *CPFunction (); @r{and}
! typedef char **CPPFunction ();
! @end example
  
! @noindent
! for functions returning no value, @code{pointer to char}, and
! @code{pointer to pointer to char}, respectively.
  
  @node Function Writing
--- 178,246 ----
  
  @menu
! * Readline Typedefs::	C declarations to make code readable.
  * Function Writing::	Variables and calling conventions.
  @end menu
  
! @node Readline Typedefs
! @subsection Readline Typedefs
  
! For readabilty, we declare a number of new object types, all pointers
! to functions.
  
! The reason for declaring these new types is to make it easier to write
! code describing pointers to C functions with appropriately prototyped
! arguments and return values.
! 
! For instance, say we want to declare a variable @var{func} as a pointer
! to a function which takes two @code{int} arguments and returns an
! @code{int} (this is the type of all of the Readline bindable functions).
! Instead of the classic C declaration
  
! @code{int (*func)();}
! 
! @noindent
! or the ANSI-C style declaration
  
! @code{int (*func)(int, int);}
  
  @noindent
  we may write
  
! @code{rl_command_func_t *func;}
  
! The full list of function pointer types available is
  
! @table @code
! @item typedef int rl_command_func_t (int, int);
  
! @item typedef char *rl_compentry_func_t (const char *, int);
! 
! @item typedef char **rl_completion_func_t (const char *, int, int);
! 
! @item typedef char *rl_quote_func_t (char *, int, char *);
! 
! @item typedef char *rl_dequote_func_t (char *, int);
! 
! @item typedef int rl_compignore_func_t (char **);
! 
! @item typedef void rl_compdisp_func_t (char **, int, int);
! 
! @item typedef int rl_hook_func_t (void);
! 
! @item typedef int rl_getc_func_t (FILE *);
! 
! @item typedef int rl_linebuf_func_t (char *, int);
! 
! @item typedef int rl_intfunc_t (int);
! @item #define rl_ivoidfunc_t rl_hook_func_t
! @item typedef int rl_icpfunc_t (char *);
! @item typedef int rl_icppfunc_t (char **);
! 
! @item typedef void rl_voidfunc_t (void);
! @item typedef void rl_vintfunc_t (int);
! @item typedef void rl_vcpfunc_t (char *);
! @item typedef void rl_vcppfunc_t (char **);
! 
! @end table
  
  @node Function Writing
***************
*** 266,270 ****
  
  @deftypevar int rl_mark
! The mark (saved position) in the current line.  If set, the mark
  and point define a @emph{region}.
  @end deftypevar
--- 295,299 ----
  
  @deftypevar int rl_mark
! The @var{mark} (saved position) in the current line.  If set, the mark
  and point define a @emph{region}.
  @end deftypevar
***************
*** 275,278 ****
--- 304,313 ----
  @end deftypevar
  
+ @deftypevar int rl_num_chars_to_read
+ Setting this to a positive value before calling @code{readline()} causes
+ Readline to return after accepting that many characters, rather
+ than reading up to a character bound to @code{accept-line}.
+ @end deftypevar
+ 
  @deftypevar int rl_pending_input
  Setting this to a value makes it the next keystroke read.  This is a
***************
*** 280,283 ****
--- 315,324 ----
  @end deftypevar
  
+ @deftypevar int rl_dispatching
+ Set to a non-zero value if a function is being called from a key binding;
+ zero otherwise.  Application functions can test this to discover whether
+ they were called directly or by Readline's dispatching mechanism.
+ @end deftypevar
+ 
  @deftypevar int rl_erase_empty_line
  Setting this to a non-zero value causes Readline to completely erase
***************
*** 289,293 ****
  @deftypevar {char *} rl_prompt
  The prompt Readline uses.  This is set from the argument to
! @code{readline ()}, and should not be assigned to directly.
  @end deftypevar
  
--- 330,336 ----
  @deftypevar {char *} rl_prompt
  The prompt Readline uses.  This is set from the argument to
! @code{readline()}, and should not be assigned to directly.
! The @code{rl_set_prompt()} function (@pxref{Redisplay}) may
! be used to modify the prompt string after calling @code{readline()}.
  @end deftypevar
  
***************
*** 302,314 ****
  @end deftypevar
  
! @deftypevar {char *} rl_library_version
  The version number of this revision of the library.
  @end deftypevar
  
! @deftypevar {char *} rl_terminal_name
! The terminal type, used for initialization.
  @end deftypevar
  
! @deftypevar {char *} rl_readline_name
  This variable is set to a unique name by each application using Readline.
  The value allows conditional parsing of the inputrc file
--- 345,364 ----
  @end deftypevar
  
! @deftypevar {const char *} rl_library_version
  The version number of this revision of the library.
  @end deftypevar
  
! @deftypevar {int} rl_gnu_readline_p
! Always set to 1, denoting that this is @sc{gnu} readline rather than some
! emulation.
! @end deftypevar
! 
! @deftypevar {const char *} rl_terminal_name
! The terminal type, used for initialization.  If not set by the application,
! Readline sets this to the value of the @env{TERM} environment variable
! the first time it is called.
  @end deftypevar
  
! @deftypevar {const char *} rl_readline_name
  This variable is set to a unique name by each application using Readline.
  The value allows conditional parsing of the inputrc file
***************
*** 324,333 ****
  @end deftypevar
  
! @deftypevar {Function *} rl_startup_hook
  If non-zero, this is the address of a function to call just
  before @code{readline} prints the first prompt.
  @end deftypevar
  
! @deftypevar {Function *} rl_pre_input_hook
  If non-zero, this is the address of a function to call after
  the first prompt has been printed and just before @code{readline}
--- 374,389 ----
  @end deftypevar
  
! @deftypevar {rl_command_func_t *} rl_last_func
! The address of the last command function Readline executed.  May be used to
! test whether or not a function is being executed twice in succession, for
! example.
! @end deftypevar
! 
! @deftypevar {rl_hook_func_t *} rl_startup_hook
  If non-zero, this is the address of a function to call just
  before @code{readline} prints the first prompt.
  @end deftypevar
  
! @deftypevar {rl_hook_func_t *} rl_pre_input_hook
  If non-zero, this is the address of a function to call after
  the first prompt has been printed and just before @code{readline}
***************
*** 335,357 ****
  @end deftypevar
  
! @deftypevar {Function *} rl_event_hook
  If non-zero, this is the address of a function to call periodically
! when readline is waiting for terminal input.
  @end deftypevar
  
! @deftypevar {Function *} rl_getc_function
! If non-zero, @code{readline} will call indirectly through this pointer
  to get a character from the input stream.  By default, it is set to
! @code{rl_getc}, the default @code{readline} character input function
! (@pxref{Utility Functions}).
  @end deftypevar
  
! @deftypevar {VFunction *} rl_redisplay_function
! If non-zero, @code{readline} will call indirectly through this pointer
  to update the display with the current contents of the editing buffer.
! By default, it is set to @code{rl_redisplay}, the default @code{readline}
  redisplay function (@pxref{Redisplay}).
  @end deftypevar
  
  @deftypevar {Keymap} rl_executing_keymap
  This variable is set to the keymap (@pxref{Keymaps}) in which the
--- 391,431 ----
  @end deftypevar
  
! @deftypevar {rl_hook_func_t *} rl_event_hook
  If non-zero, this is the address of a function to call periodically
! when Readline is waiting for terminal input.
! By default, this will be called at most ten times a second if there
! is no keyboard input.
  @end deftypevar
  
! @deftypevar {rl_getc_func_t *} rl_getc_function
! If non-zero, Readline will call indirectly through this pointer
  to get a character from the input stream.  By default, it is set to
! @code{rl_getc}, the default Readline character input function
! (@pxref{Character Input}).
  @end deftypevar
  
! @deftypevar {rl_voidfunc_t *} rl_redisplay_function
! If non-zero, Readline will call indirectly through this pointer
  to update the display with the current contents of the editing buffer.
! By default, it is set to @code{rl_redisplay}, the default Readline
  redisplay function (@pxref{Redisplay}).
  @end deftypevar
  
+ @deftypevar {rl_vintfunc_t *} rl_prep_term_function
+ If non-zero, Readline will call indirectly through this pointer
+ to initialize the terminal.  The function takes a single argument, an
+ @code{int} flag that says whether or not to use eight-bit characters.
+ By default, this is set to @code{rl_prep_terminal}
+ (@pxref{Terminal Management}).
+ @end deftypevar
+ 
+ @deftypevar {rl_voidfunc_t *} rl_deprep_term_function
+ If non-zero, Readline will call indirectly through this pointer
+ to reset the terminal.  This function should undo the effects of
+ @code{rl_prep_term_function}.
+ By default, this is set to @code{rl_deprep_terminal}
+ (@pxref{Terminal Management}).
+ @end deftypevar
+ 
  @deftypevar {Keymap} rl_executing_keymap
  This variable is set to the keymap (@pxref{Keymaps}) in which the
***************
*** 364,367 ****
--- 438,514 ----
  @end deftypevar 
  
+ @deftypevar {char *} rl_executing_macro
+ This variable is set to the text of any currently-executing macro.
+ @end deftypevar
+ 
+ @deftypevar {int} rl_readline_state
+ A variable with bit values that encapsulate the current Readline state.
+ A bit is set with the @code{RL_SETSTATE} macro, and unset with the
+ @code{RL_UNSETSTATE} macro.  Use the @code{RL_ISSTATE} macro to test
+ whether a particular state bit is set.  Current state bits include:
+ 
+ @table @code
+ @item RL_STATE_NONE
+ Readline has not yet been called, nor has it begun to intialize.
+ @item RL_STATE_INITIALIZING
+ Readline is initializing its internal data structures.
+ @item RL_STATE_INITIALIZED
+ Readline has completed its initialization.
+ @item RL_STATE_TERMPREPPED
+ Readline has modified the terminal modes to do its own input and redisplay.
+ @item RL_STATE_READCMD
+ Readline is reading a command from the keyboard.
+ @item RL_STATE_METANEXT
+ Readline is reading more input after reading the meta-prefix character.
+ @item RL_STATE_DISPATCHING
+ Readline is dispatching to a command.
+ @item RL_STATE_MOREINPUT
+ Readline is reading more input while executing an editing command.
+ @item RL_STATE_ISEARCH
+ Readline is performing an incremental history search.
+ @item RL_STATE_NSEARCH
+ Readline is performing a non-incremental history search.
+ @item RL_STATE_SEARCH
+ Readline is searching backward or forward through the history for a string.
+ @item RL_STATE_NUMERICARG
+ Readline is reading a numeric argument.
+ @item RL_STATE_MACROINPUT
+ Readline is currently getting its input from a previously-defined keyboard
+ macro.
+ @item RL_STATE_MACRODEF
+ Readline is currently reading characters defining a keyboard macro.
+ @item RL_STATE_OVERWRITE
+ Readline is in overwrite mode.
+ @item RL_STATE_COMPLETING
+ Readline is performing word completion.
+ @item RL_STATE_SIGHANDLER
+ Readline is currently executing the readline signal handler.
+ @item RL_STATE_UNDOING
+ Readline is performing an undo.
+ @item RL_STATE_DONE
+ Readline has read a key sequence bound to @code{accept-line}
+ and is about to return the line to the caller.
+ @end table
+ 
+ @end deftypevar
+ 
+ @deftypevar {int} rl_explicit_arg
+ Set to a non-zero value if an explicit numeric argument was specified by
+ the user.  Only valid in a bindable command function.
+ @end deftypevar
+ 
+ @deftypevar {int} rl_numeric_arg
+ Set to the value of any numeric argument explicitly specified by the user
+ before executing the current Readline function.  Only valid in a bindable
+ command function.
+ @end deftypevar
+ 
+ @deftypevar {int} rl_editing_mode
+ Set to a value denoting Readline's current editing mode.  A value of
+ @var{1} means Readline is currently in emacs mode; @var{0}
+ means that vi mode is active.
+ @end deftypevar
+ 
+ 
  @node Readline Convenience Functions
  @section Readline Convenience Functions
***************
*** 376,381 ****
--- 523,532 ----
  * Redisplay::		Functions to control line display.
  * Modifying Text::	Functions to modify @code{rl_line_buffer}.
+ * Character Input::	Functions to read keyboard input.
+ * Terminal Management::	Functions to manage terminal settings.
  * Utility Functions::	Generally useful functions and hooks.
+ * Miscellaneous Functions::	Functions that don't fall into any category.
  * Alternate Interface::	Using Readline in a `callback' fashion.
+ * A Readline Example::		An example Readline function.
  @end menu
  
***************
*** 397,404 ****
  well.  Readline provides a function for doing that:
  
! @deftypefun int rl_add_defun (char *name, Function *function, int key)
  Add @var{name} to the list of named functions.  Make @var{function} be
  the function that gets called.  If @var{key} is not -1, then bind it to
! @var{function} using @code{rl_bind_key ()}.
  @end deftypefun
  
--- 548,555 ----
  well.  Readline provides a function for doing that:
  
! @deftypefun int rl_add_defun (const char *name, rl_command_func_t *function, int key)
  Add @var{name} to the list of named functions.  Make @var{function} be
  the function that gets called.  If @var{key} is not -1, then bind it to
! @var{function} using @code{rl_bind_key()}.
  @end deftypefun
  
***************
*** 417,423 ****
  Readline which keymap to use.
  
! @deftypefun Keymap rl_make_bare_keymap ()
  Returns a new, empty keymap.  The space for the keymap is allocated with
! @code{malloc ()}; you should @code{free ()} it when you are done.
  @end deftypefun
  
--- 568,575 ----
  Readline which keymap to use.
  
! @deftypefun Keymap rl_make_bare_keymap (void)
  Returns a new, empty keymap.  The space for the keymap is allocated with
! @code{malloc()}; the caller should free it by calling
! @code{rl_discard_keymap()} when done.
  @end deftypefun
  
***************
*** 426,430 ****
  @end deftypefun
  
! @deftypefun Keymap rl_make_keymap ()
  Return a new keymap with the printing characters bound to rl_insert,
  the lowercase Meta characters bound to run their equivalents, and
--- 578,582 ----
  @end deftypefun
  
! @deftypefun Keymap rl_make_keymap (void)
  Return a new keymap with the printing characters bound to rl_insert,
  the lowercase Meta characters bound to run their equivalents, and
***************
*** 439,443 ****
  change which keymap is active.
  
! @deftypefun Keymap rl_get_keymap ()
  Returns the currently active keymap.
  @end deftypefun
--- 591,595 ----
  change which keymap is active.
  
! @deftypefun Keymap rl_get_keymap (void)
  Returns the currently active keymap.
  @end deftypefun
***************
*** 447,451 ****
  @end deftypefun
  
! @deftypefun Keymap rl_get_keymap_by_name (char *name)
  Return the keymap matching @var{name}.  @var{name} is one which would
  be supplied in a @code{set keymap} inputrc line (@pxref{Readline Init File}).
--- 599,603 ----
  @end deftypefun
  
! @deftypefun Keymap rl_get_keymap_by_name (const char *name)
  Return the keymap matching @var{name}.  @var{name} is one which would
  be supplied in a @code{set keymap} inputrc line (@pxref{Readline Init File}).
***************
*** 460,465 ****
  @subsection Binding Keys
  
! You associate keys with functions through the keymap.  Readline has
! several internal keymaps: @code{emacs_standard_keymap},
  @code{emacs_meta_keymap}, @code{emacs_ctlx_keymap},
  @code{vi_movement_keymap}, and @code{vi_insertion_keymap}.
--- 612,617 ----
  @subsection Binding Keys
  
! Key sequences are associate with functions through the keymap.
! Readline has several internal keymaps: @code{emacs_standard_keymap},
  @code{emacs_meta_keymap}, @code{emacs_ctlx_keymap},
  @code{vi_movement_keymap}, and @code{vi_insertion_keymap}.
***************
*** 467,473 ****
  this manual assume that.
  
! Since @code{readline} installs a set of default key bindings the first
  time it is called, there is always the danger that a custom binding
! installed before the first call to @code{readline} will be overridden.
  An alternate mechanism is to install custom key bindings in an
  initialization function assigned to the @code{rl_startup_hook} variable
--- 619,625 ----
  this manual assume that.
  
! Since @code{readline()} installs a set of default key bindings the first
  time it is called, there is always the danger that a custom binding
! installed before the first call to @code{readline()} will be overridden.
  An alternate mechanism is to install custom key bindings in an
  initialization function assigned to the @code{rl_startup_hook} variable
***************
*** 476,485 ****
  These functions manage key bindings.
  
! @deftypefun int rl_bind_key (int key, Function *function)
  Binds @var{key} to @var{function} in the currently active keymap.
  Returns non-zero in the case of an invalid @var{key}.
  @end deftypefun
  
! @deftypefun int rl_bind_key_in_map (int key, Function *function, Keymap map)
  Bind @var{key} to @var{function} in @var{map}.  Returns non-zero in the case
  of an invalid @var{key}.
--- 628,637 ----
  These functions manage key bindings.
  
! @deftypefun int rl_bind_key (int key, rl_command_func_t *function)
  Binds @var{key} to @var{function} in the currently active keymap.
  Returns non-zero in the case of an invalid @var{key}.
  @end deftypefun
  
! @deftypefun int rl_bind_key_in_map (int key, rl_command_func_t *function, Keymap map)
  Bind @var{key} to @var{function} in @var{map}.  Returns non-zero in the case
  of an invalid @var{key}.
***************
*** 496,508 ****
  @end deftypefun
  
! @deftypefun int rl_unbind_function_in_map (Function *function, Keymap map)
  Unbind all keys that execute @var{function} in @var{map}.
  @end deftypefun
  
! @deftypefun int rl_unbind_command_in_map (char *command, Keymap map)
  Unbind all keys that are bound to @var{command} in @var{map}.
  @end deftypefun
  
! @deftypefun int rl_generic_bind (int type, char *keyseq, char *data, Keymap map)
  Bind the key sequence represented by the string @var{keyseq} to the arbitrary
  pointer @var{data}.  @var{type} says what kind of data is pointed to by
--- 648,666 ----
  @end deftypefun
  
! @deftypefun int rl_unbind_function_in_map (rl_command_func_t *function, Keymap map)
  Unbind all keys that execute @var{function} in @var{map}.
  @end deftypefun
  
! @deftypefun int rl_unbind_command_in_map (const char *command, Keymap map)
  Unbind all keys that are bound to @var{command} in @var{map}.
  @end deftypefun
  
! @deftypefun int rl_set_key (const char *keyseq, rl_command_func_t *function, Keymap map)
! Bind the key sequence represented by the string @var{keyseq} to the function
! @var{function}.  This makes new keymaps as
! necessary.  The initial keymap in which to do bindings is @var{map}.
! @end deftypefun
! 
! @deftypefun int rl_generic_bind (int type, const char *keyseq, char *data, Keymap map)
  Bind the key sequence represented by the string @var{keyseq} to the arbitrary
  pointer @var{data}.  @var{type} says what kind of data is pointed to by
***************
*** 518,522 ****
  @end deftypefun
  
! @deftypefun int rl_read_init_file (char *filename)
  Read keybindings and variable assignments from @var{filename}
  (@pxref{Readline Init File}).
--- 676,680 ----
  @end deftypefun
  
! @deftypefun int rl_read_init_file (const char *filename)
  Read keybindings and variable assignments from @var{filename}
  (@pxref{Readline Init File}).
***************
*** 527,549 ****
  
  These functions allow you to find out what keys invoke named functions
! and the functions invoked by a particular key sequence.
  
! @deftypefun {Function *} rl_named_function (char *name)
  Return the function with name @var{name}.
  @end deftypefun
  
! @deftypefun {Function *} rl_function_of_keyseq (char *keyseq, Keymap map, int *type)
  Return the function invoked by @var{keyseq} in keymap @var{map}.
! If @var{map} is NULL, the current keymap is used.  If @var{type} is
! not NULL, the type of the object is returned in it (one of @code{ISFUNC},
! @code{ISKMAP}, or @code{ISMACR}).
  @end deftypefun
  
! @deftypefun {char **} rl_invoking_keyseqs (Function *function)
  Return an array of strings representing the key sequences used to
  invoke @var{function} in the current keymap.
  @end deftypefun
  
! @deftypefun {char **} rl_invoking_keyseqs_in_map (Function *function, Keymap map)
  Return an array of strings representing the key sequences used to
  invoke @var{function} in the keymap @var{map}.
--- 685,708 ----
  
  These functions allow you to find out what keys invoke named functions
! and the functions invoked by a particular key sequence.  You may also
! associate a new function name with an arbitrary function.
  
! @deftypefun {rl_command_func_t *} rl_named_function (const char *name)
  Return the function with name @var{name}.
  @end deftypefun
  
! @deftypefun {rl_command_func_t *} rl_function_of_keyseq (const char *keyseq, Keymap map, int *type)
  Return the function invoked by @var{keyseq} in keymap @var{map}.
! If @var{map} is @code{NULL}, the current keymap is used.  If @var{type} is
! not @code{NULL}, the type of the object is returned in the @code{int} variable
! it points to (one of @code{ISFUNC}, @code{ISKMAP}, or @code{ISMACR}).
  @end deftypefun
  
! @deftypefun {char **} rl_invoking_keyseqs (rl_command_func_t *function)
  Return an array of strings representing the key sequences used to
  invoke @var{function} in the current keymap.
  @end deftypefun
  
! @deftypefun {char **} rl_invoking_keyseqs_in_map (rl_command_func_t *function, Keymap map)
  Return an array of strings representing the key sequences used to
  invoke @var{function} in the keymap @var{map}.
***************
*** 557,568 ****
  @end deftypefun
  
! @deftypefun void rl_list_funmap_names ()
  Print the names of all bindable Readline functions to @code{rl_outstream}.
  @end deftypefun
  
! @deftypefun {char **} rl_funmap_names ()
  Return a NULL terminated array of known function names.  The array is
  sorted.  The array itself is allocated, but not the strings inside.  You
! should free () the array when you done, but not the pointrs.
  @end deftypefun
  
--- 716,732 ----
  @end deftypefun
  
! @deftypefun void rl_list_funmap_names (void)
  Print the names of all bindable Readline functions to @code{rl_outstream}.
  @end deftypefun
  
! @deftypefun {const char **} rl_funmap_names (void)
  Return a NULL terminated array of known function names.  The array is
  sorted.  The array itself is allocated, but not the strings inside.  You
! should @code{free()} the array when you are done, but not the pointers.
! @end deftypefun
! 
! @deftypefun int rl_add_funmap_entry (const char *name, rl_command_func_t *function)
! Add @var{name} to the list of bindable Readline command names, and make
! @var{function} the function to be called when @var{name} is invoked.
  @end deftypefun
  
***************
*** 572,586 ****
  Supporting the undo command is a painless thing, and makes your
  functions much more useful.  It is certainly easy to try
! something if you know you can undo it.  I could use an undo function for
! the stock market.
  
  If your function simply inserts text once, or deletes text once, and
! uses @code{rl_insert_text ()} or @code{rl_delete_text ()} to do it, then
  undoing is already done for you automatically.
  
  If you do multiple insertions or multiple deletions, or any combination
  of these operations, you should group them together into one operation.
! This is done with @code{rl_begin_undo_group ()} and
! @code{rl_end_undo_group ()}.
  
  The types of events that can be undone are:
--- 736,749 ----
  Supporting the undo command is a painless thing, and makes your
  functions much more useful.  It is certainly easy to try
! something if you know you can undo it.
  
  If your function simply inserts text once, or deletes text once, and
! uses @code{rl_insert_text()} or @code{rl_delete_text()} to do it, then
  undoing is already done for you automatically.
  
  If you do multiple insertions or multiple deletions, or any combination
  of these operations, you should group them together into one operation.
! This is done with @code{rl_begin_undo_group()} and
! @code{rl_end_undo_group()}.
  
  The types of events that can be undone are:
***************
*** 592,610 ****
  Notice that @code{UNDO_DELETE} means to insert some text, and
  @code{UNDO_INSERT} means to delete some text.  That is, the undo code
! tells undo what to undo, not how to undo it.  @code{UNDO_BEGIN} and
! @code{UNDO_END} are tags added by @code{rl_begin_undo_group ()} and
! @code{rl_end_undo_group ()}.
  
! @deftypefun int rl_begin_undo_group ()
  Begins saving undo information in a group construct.  The undo
! information usually comes from calls to @code{rl_insert_text ()} and
! @code{rl_delete_text ()}, but could be the result of calls to
! @code{rl_add_undo ()}.
  @end deftypefun
  
! @deftypefun int rl_end_undo_group ()
  Closes the current undo group started with @code{rl_begin_undo_group
! ()}.  There should be one call to @code{rl_end_undo_group ()}
! for each call to @code{rl_begin_undo_group ()}.
  @end deftypefun
  
--- 755,773 ----
  Notice that @code{UNDO_DELETE} means to insert some text, and
  @code{UNDO_INSERT} means to delete some text.  That is, the undo code
! tells what to undo, not how to undo it.  @code{UNDO_BEGIN} and
! @code{UNDO_END} are tags added by @code{rl_begin_undo_group()} and
! @code{rl_end_undo_group()}.
  
! @deftypefun int rl_begin_undo_group (void)
  Begins saving undo information in a group construct.  The undo
! information usually comes from calls to @code{rl_insert_text()} and
! @code{rl_delete_text()}, but could be the result of calls to
! @code{rl_add_undo()}.
  @end deftypefun
  
! @deftypefun int rl_end_undo_group (void)
  Closes the current undo group started with @code{rl_begin_undo_group
! ()}.  There should be one call to @code{rl_end_undo_group()}
! for each call to @code{rl_begin_undo_group()}.
  @end deftypefun
  
***************
*** 614,622 ****
  @end deftypefun
  
! @deftypefun void free_undo_list ()
  Free the existing undo list.
  @end deftypefun
  
! @deftypefun int rl_do_undo ()
  Undo the first thing on the undo list.  Returns @code{0} if there was
  nothing to undo, non-zero if something was undone.
--- 777,785 ----
  @end deftypefun
  
! @deftypefun void rl_free_undo_list (void)
  Free the existing undo list.
  @end deftypefun
  
! @deftypefun int rl_do_undo (void)
  Undo the first thing on the undo list.  Returns @code{0} if there was
  nothing to undo, non-zero if something was undone.
***************
*** 624,628 ****
  
  Finally, if you neither insert nor delete text, but directly modify the
! existing text (e.g., change its case), call @code{rl_modifying ()}
  once, just before you modify the text.  You must supply the indices of
  the text range that you are going to modify.
--- 787,791 ----
  
  Finally, if you neither insert nor delete text, but directly modify the
! existing text (e.g., change its case), call @code{rl_modifying()}
  once, just before you modify the text.  You must supply the indices of
  the text range that you are going to modify.
***************
*** 637,656 ****
  @subsection Redisplay
  
! @deftypefun void rl_redisplay ()
  Change what's displayed on the screen to reflect the current contents
  of @code{rl_line_buffer}.
  @end deftypefun
  
! @deftypefun int rl_forced_update_display ()
  Force the line to be updated and redisplayed, whether or not
  Readline thinks the screen display is correct.
  @end deftypefun
  
! @deftypefun int rl_on_new_line ()
  Tell the update functions that we have moved onto a new (empty) line,
  usually after ouputting a newline.
  @end deftypefun
  
! @deftypefun int rl_on_new_line_with_prompt ()
  Tell the update functions that we have moved onto a new line, with
  @var{rl_prompt} already displayed.
--- 800,819 ----
  @subsection Redisplay
  
! @deftypefun void rl_redisplay (void)
  Change what's displayed on the screen to reflect the current contents
  of @code{rl_line_buffer}.
  @end deftypefun
  
! @deftypefun int rl_forced_update_display (void)
  Force the line to be updated and redisplayed, whether or not
  Readline thinks the screen display is correct.
  @end deftypefun
  
! @deftypefun int rl_on_new_line (void)
  Tell the update functions that we have moved onto a new (empty) line,
  usually after ouputting a newline.
  @end deftypefun
  
! @deftypefun int rl_on_new_line_with_prompt (void)
  Tell the update functions that we have moved onto a new line, with
  @var{rl_prompt} already displayed.
***************
*** 661,693 ****
  @end deftypefun
  
! @deftypefun int rl_reset_line_state ()
  Reset the display state to a clean state and redisplay the current line
  starting on a new line.
  @end deftypefun
  
! @deftypefun int rl_message (va_alist)
! The arguments are a string as would be supplied to @code{printf}.  The
! resulting string is displayed in the @dfn{echo area}.  The echo area
  is also used to display numeric arguments and search strings.
  @end deftypefun
  
! @deftypefun int rl_clear_message ()
  Clear the message in the echo area.
  @end deftypefun
  
! @deftypefun void rl_save_prompt ()
  Save the local Readline prompt display state in preparation for
! displaying a new message in the message area with @code{rl_message}.
  @end deftypefun
  
! @deftypefun void rl_restore_prompt ()
  Restore the local Readline prompt display state saved by the most
  recent call to @code{rl_save_prompt}.
  @end deftypefun
  
  @node Modifying Text
  @subsection Modifying Text
  
! @deftypefun int rl_insert_text (char *text)
  Insert @var{text} into the line at the current cursor position.
  @end deftypefun
--- 824,886 ----
  @end deftypefun
  
! @deftypefun int rl_reset_line_state (void)
  Reset the display state to a clean state and redisplay the current line
  starting on a new line.
  @end deftypefun
  
! @deftypefun int rl_crlf (void)
! Move the cursor to the start of the next screen line.
! @end deftypefun
! 
! @deftypefun int rl_show_char (int c)
! Display character @var{c} on @code{rl_outstream}.
! If Readline has not been set to display meta characters directly, this
! will convert meta characters to a meta-prefixed key sequence.
! This is intended for use by applications which wish to do their own
! redisplay.
! @end deftypefun
! 
! @deftypefun int rl_message (const char *, @dots{})
! The arguments are a format string as would be supplied to @code{printf},
! possibly containing conversion specifications such as @samp{%d}, and
! any additional arguments necessary to satisfy the conversion specifications.
! The resulting string is displayed in the @dfn{echo area}.  The echo area
  is also used to display numeric arguments and search strings.
  @end deftypefun
  
! @deftypefun int rl_clear_message (void)
  Clear the message in the echo area.
  @end deftypefun
  
! @deftypefun void rl_save_prompt (void)
  Save the local Readline prompt display state in preparation for
! displaying a new message in the message area with @code{rl_message()}.
  @end deftypefun
  
! @deftypefun void rl_restore_prompt (void)
  Restore the local Readline prompt display state saved by the most
  recent call to @code{rl_save_prompt}.
  @end deftypefun
  
+ @deftypefun int rl_expand_prompt (char *prompt)
+ Expand any special character sequences in @var{prompt} and set up the
+ local Readline prompt redisplay variables.
+ This function is called by @code{readline()}.  It may also be called to
+ expand the primary prompt if the @code{rl_on_new_line_with_prompt()}
+ function or @code{rl_already_prompted} variable is used.
+ It returns the number of visible characters on the last line of the
+ (possibly multi-line) prompt.
+ @end deftypefun
+ 
+ @deftypefun int rl_set_prompt (const char *prompt)
+ Make Readline use @var{prompt} for subsequent redisplay.  This calls
+ @code{rl_expand_prompt()} to expand the prompt and sets @code{rl_prompt}
+ to the result.
+ @end deftypefun
+ 
  @node Modifying Text
  @subsection Modifying Text
  
! @deftypefun int rl_insert_text (const char *text)
  Insert @var{text} into the line at the current cursor position.
  @end deftypefun
***************
*** 711,725 ****
  @end deftypefun
  
! @node Utility Functions
! @subsection Utility Functions
! 
! @deftypefun int rl_read_key ()
! Return the next character available.  This handles input inserted into
! the input stream via @var{pending input} (@pxref{Readline Variables})
! and @code{rl_stuff_char ()}, macros, and characters read from the keyboard.
! @end deftypefun
! 
! @deftypefun int rl_getc (FILE *)
! Return the next character available from the keyboard.
  @end deftypefun
  
--- 904,928 ----
  @end deftypefun
  
! @deftypefun int rl_push_macro_input (char *macro)
! Cause @var{macro} to be inserted into the line, as if it had been invoked
! by a key bound to a macro.  Not especially useful; use
! @code{rl_insert_text()} instead.
! @end deftypefun
! 
! @node Character Input
! @subsection Character Input
! 
! @deftypefun int rl_read_key (void)
! Return the next character available from Readline's current input stream.
! This handles input inserted into
! the input stream via @var{rl_pending_input} (@pxref{Readline Variables})
! and @code{rl_stuff_char()}, macros, and characters read from the keyboard.
! While waiting for input, this function will call any function assigned to
! the @code{rl_event_hook} variable.
! @end deftypefun
! 
! @deftypefun int rl_getc (FILE *stream)
! Return the next character available from @var{stream}, which is assumed to
! be the keyboard.
  @end deftypefun
  
***************
*** 727,761 ****
  Insert @var{c} into the Readline input stream.  It will be "read"
  before Readline attempts to read characters from the terminal with
! @code{rl_read_key ()}.
  @end deftypefun
  
! @deftypefun int rl_extend_line_buffer (int len)
! Ensure that @code{rl_line_buffer} has enough space to hold @var{len}
! characters, possibly reallocating it if necessary.
  @end deftypefun
  
! @deftypefun int rl_initialize ()
! Initialize or re-initialize Readline's internal state.
  @end deftypefun
  
! @deftypefun int rl_reset_terminal (char *terminal_name)
  Reinitialize Readline's idea of the terminal settings using
  @var{terminal_name} as the terminal type (e.g., @code{vt100}).
! If @var{terminal_name} is NULL, the value of the @code{TERM}
  environment variable is used.
  @end deftypefun
  
! @deftypefun int alphabetic (int c)
! Return 1 if @var{c} is an alphabetic character.
  @end deftypefun
  
! @deftypefun int numeric (int c)
! Return 1 if @var{c} is a numeric character.
  @end deftypefun
  
! @deftypefun int ding ()
  Ring the terminal bell, obeying the setting of @code{bell-style}.
  @end deftypefun
  
  @deftypefun void rl_display_match_list (char **matches, int len, int max)
  A convenience function for displaying a list of strings in
--- 930,1005 ----
  Insert @var{c} into the Readline input stream.  It will be "read"
  before Readline attempts to read characters from the terminal with
! @code{rl_read_key()}.
  @end deftypefun
  
! @deftypefun int rl_execute_next (int c)
! Make @var{c} be the next command to be executed when @code{rl_read_key()}
! is called.  This sets @var{rl_pending_input}.
  @end deftypefun
  
! @deftypefun int rl_clear_pending_input (void)
! Unset @var{rl_pending_input}, effectively negating the effect of any
! previous call to @code{rl_execute_next()}.  This works only if the
! pending input has not already been read with @code{rl_read_key()}.
! @end deftypefun
! 
! @deftypefun int rl_set_keyboard_input_timeout (int u)
! While waiting for keyboard input in @code{rl_read_key()}, Readline will
! wait for @var{u} microseconds for input before calling any function
! assigned to @code{rl_event_hook}.  The default waiting period is
! one-tenth of a second.  Returns the old timeout value.
  @end deftypefun
  
! @node Terminal Management
! @subsection Terminal Management
! 
! @deftypefun void rl_prep_terminal (int meta_flag)
! Modify the terminal settings for Readline's use, so @code{readline()}
! can read a single character at a time from the keyboard.
! The @var{meta_flag} argument should be non-zero if Readline should
! read eight-bit input.
! @end deftypefun
! 
! @deftypefun void rl_deprep_terminal (void)
! Undo the effects of @code{rl_prep_terminal()}, leaving the terminal in
! the state in which it was before the most recent call to
! @code{rl_prep_terminal()}.
! @end deftypefun
! 
! @deftypefun void rl_tty_set_default_bindings (Keymap kmap)
! Read the operating system's terminal editing characters (as would be displayed
! by @code{stty}) to their Readline equivalents.  The bindings are performed
! in @var{kmap}.
! @end deftypefun
! 
! @deftypefun int rl_reset_terminal (const char *terminal_name)
  Reinitialize Readline's idea of the terminal settings using
  @var{terminal_name} as the terminal type (e.g., @code{vt100}).
! If @var{terminal_name} is @code{NULL}, the value of the @code{TERM}
  environment variable is used.
  @end deftypefun
  
! @node Utility Functions
! @subsection Utility Functions
! 
! @deftypefun int rl_extend_line_buffer (int len)
! Ensure that @code{rl_line_buffer} has enough space to hold @var{len}
! characters, possibly reallocating it if necessary.
  @end deftypefun
  
! @deftypefun int rl_initialize (void)
! Initialize or re-initialize Readline's internal state.
! It's not strictly necessary to call this; @code{readline()} calls it before
! reading any input.
  @end deftypefun
  
! @deftypefun int rl_ding (void)
  Ring the terminal bell, obeying the setting of @code{bell-style}.
  @end deftypefun
  
+ @deftypefun int rl_alphabetic (int c)
+ Return 1 if @var{c} is an alphabetic character.
+ @end deftypefun
+ 
  @deftypefun void rl_display_match_list (char **matches, int len, int max)
  A convenience function for displaying a list of strings in
***************
*** 768,799 ****
  @end deftypefun
  
! The following are implemented as macros, defined in @code{chartypes.h}.
  
! @deftypefun int uppercase_p (int c)
  Return 1 if @var{c} is an uppercase alphabetic character.
  @end deftypefun
  
! @deftypefun int lowercase_p (int c)
  Return 1 if @var{c} is a lowercase alphabetic character.
  @end deftypefun
  
! @deftypefun int digit_p (int c)
  Return 1 if @var{c} is a numeric character.
  @end deftypefun
  
! @deftypefun int to_upper (int c)
  If @var{c} is a lowercase alphabetic character, return the corresponding
  uppercase character.
  @end deftypefun
  
! @deftypefun int to_lower (int c)
  If @var{c} is an uppercase alphabetic character, return the corresponding
  lowercase character.
  @end deftypefun
  
! @deftypefun int digit_value (int c)
  If @var{c} is a number, return the value it represents.
  @end deftypefun
  
  @node Alternate Interface
  @subsection Alternate Interface
--- 1012,1080 ----
  @end deftypefun
  
! The following are implemented as macros, defined in @code{chardefs.h}.
! Applications should refrain from using them.
  
! @deftypefun int _rl_uppercase_p (int c)
  Return 1 if @var{c} is an uppercase alphabetic character.
  @end deftypefun
  
! @deftypefun int _rl_lowercase_p (int c)
  Return 1 if @var{c} is a lowercase alphabetic character.
  @end deftypefun
  
! @deftypefun int _rl_digit_p (int c)
  Return 1 if @var{c} is a numeric character.
  @end deftypefun
  
! @deftypefun int _rl_to_upper (int c)
  If @var{c} is a lowercase alphabetic character, return the corresponding
  uppercase character.
  @end deftypefun
  
! @deftypefun int _rl_to_lower (int c)
  If @var{c} is an uppercase alphabetic character, return the corresponding
  lowercase character.
  @end deftypefun
  
! @deftypefun int _rl_digit_value (int c)
  If @var{c} is a number, return the value it represents.
  @end deftypefun
  
+ @node Miscellaneous Functions
+ @subsection Miscellaneous Functions
+ 
+ @deftypefun int rl_macro_bind (const char *keyseq, const char *macro, Keymap map)
+ Bind the key sequence @var{keyseq} to invoke the macro @var{macro}.
+ The binding is performed in @var{map}.  When @var{keyseq} is invoked, the
+ @var{macro} will be inserted into the line.  This function is deprecated;
+ use @code{rl_generic_bind()} instead.
+ @end deftypefun
+ 
+ @deftypefun void rl_macro_dumper (int readable)
+ Print the key sequences bound to macros and their values, using
+ the current keymap, to @code{rl_outstream}.
+ If @var{readable} is non-zero, the list is formatted in such a way
+ that it can be made part of an @code{inputrc} file and re-read.
+ @end deftypefun
+ 
+ @deftypefun int rl_variable_bind (const char *variable, const char *value)
+ Make the Readline variable @var{variable} have @var{value}.
+ This behaves as if the readline command
+ @samp{set @var{variable} @var{value}} had been executed in an @code{inputrc}
+ file (@pxref{Readline Init File Syntax}).
+ @end deftypefun
+ 
+ @deftypefun void rl_variable_dumper (int readable)
+ Print the readline variable names and their current values
+ to @code{rl_outstream}.
+ If @var{readable} is non-zero, the list is formatted in such a way
+ that it can be made part of an @code{inputrc} file and re-read.
+ @end deftypefun
+ 
+ @deftypefun int rl_set_paren_blink_timeout (int u)
+ Set the time interval (in microseconds) that Readline waits when showing
+ a balancing character when @code{blink-matching-paren} has been enabled.
+ @end deftypefun
+ 
  @node Alternate Interface
  @subsection Alternate Interface
***************
*** 806,816 ****
  are functions available to make this easy.
  
! @deftypefun void rl_callback_handler_install (char *prompt, Vfunction *lhandler)
  Set up the terminal for readline I/O and display the initial
  expanded value of @var{prompt}.  Save the value of @var{lhandler} to
! use as a callback when a complete line of input has been entered.
  @end deftypefun
  
! @deftypefun void rl_callback_read_char ()
  Whenever an application determines that keyboard input is available, it
  should call @code{rl_callback_read_char()}, which will read the next
--- 1087,1098 ----
  are functions available to make this easy.
  
! @deftypefun void rl_callback_handler_install (const char *prompt, rl_vcpfunc_t *lhandler)
  Set up the terminal for readline I/O and display the initial
  expanded value of @var{prompt}.  Save the value of @var{lhandler} to
! use as a function to call when a complete line of input has been entered.
! The function takes the text of the line as an argument.
  @end deftypefun
  
! @deftypefun void rl_callback_read_char (void)
  Whenever an application determines that keyboard input is available, it
  should call @code{rl_callback_read_char()}, which will read the next
***************
*** 822,831 ****
  @end deftypefun
  
! @deftypefun void rl_callback_handler_remove ()
  Restore the terminal to its initial state and remove the line handler.
  This may be called from within a callback as well as independently.
  @end deftypefun
  
! @subsection An Example
  
  Here is a function which changes lowercase characters to their uppercase
--- 1104,1114 ----
  @end deftypefun
  
! @deftypefun void rl_callback_handler_remove (void)
  Restore the terminal to its initial state and remove the line handler.
  This may be called from within a callback as well as independently.
  @end deftypefun
  
! @node A Readline Example
! @subsection A Readline Example
  
  Here is a function which changes lowercase characters to their uppercase
***************
*** 882,889 ****
    for (i = start; i != end; i++)
      @{
!       if (uppercase_p (rl_line_buffer[i]))
!         rl_line_buffer[i] = to_lower (rl_line_buffer[i]);
!       else if (lowercase_p (rl_line_buffer[i]))
!         rl_line_buffer[i] = to_upper (rl_line_buffer[i]);
      @}
    /* Move point to on top of the last character changed. */
--- 1165,1172 ----
    for (i = start; i != end; i++)
      @{
!       if (_rl_uppercase_p (rl_line_buffer[i]))
!         rl_line_buffer[i] = _rl_to_lower (rl_line_buffer[i]);
!       else if (_rl_lowercase_p (rl_line_buffer[i]))
!         rl_line_buffer[i] = _rl_to_upper (rl_line_buffer[i]);
      @}
    /* Move point to on top of the last character changed. */
***************
*** 898,908 ****
  Signals are asynchronous events sent to a process by the Unix kernel,
  sometimes on behalf of another process.  They are intended to indicate
! exceptional events, like a user pressing the interrupt key on his
! terminal, or a network connection being broken.  There is a class of
! signals that can be sent to the process currently reading input from
! the keyboard.  Since Readline changes the terminal attributes when it
! is called, it needs to perform special processing when a signal is
! received to restore the terminal to a sane state, or provide application
! writers with functions to do so manually.
  
  Readline contains an internal signal handler that is installed for a
--- 1181,1191 ----
  Signals are asynchronous events sent to a process by the Unix kernel,
  sometimes on behalf of another process.  They are intended to indicate
! exceptional events, like a user pressing the interrupt key on his terminal,
! or a network connection being broken.  There is a class of signals that can
! be sent to the process currently reading input from the keyboard.  Since
! Readline changes the terminal attributes when it is called, it needs to
! perform special processing when such a signal is received in order to
! restore the terminal to a sane state, or provide application writers with
! functions to do so manually. 
  
  Readline contains an internal signal handler that is installed for a
***************
*** 911,916 ****
  When one of these signals is received, the signal handler
  will reset the terminal attributes to those that were in effect before
! @code{readline ()} was called, reset the signal handling to what it was
! before @code{readline ()} was called, and resend the signal to the calling
  application.
  If and when the calling application's signal handler returns, Readline
--- 1194,1199 ----
  When one of these signals is received, the signal handler
  will reset the terminal attributes to those that were in effect before
! @code{readline()} was called, reset the signal handling to what it was
! before @code{readline()} was called, and resend the signal to the calling
  application.
  If and when the calling application's signal handler returns, Readline
***************
*** 918,933 ****
  When a @code{SIGINT} is received, the Readline signal handler performs
  some additional work, which will cause any partially-entered line to be
! aborted (see the description of @code{rl_free_line_state ()}).
  
  There is an additional Readline signal handler, for @code{SIGWINCH}, which
  the kernel sends to a process whenever the terminal's size changes (for
  example, if a user resizes an @code{xterm}).  The Readline @code{SIGWINCH}
! handler updates Readline's internal screen size state, and then calls any
! @code{SIGWINCH} signal handler the calling application has installed. 
  Readline calls the application's @code{SIGWINCH} signal handler without
  resetting the terminal to its original state.  If the application's signal
  handler does more than update its idea of the terminal size and return (for
  example, a @code{longjmp} back to a main processing loop), it @emph{must}
! call @code{rl_cleanup_after_signal ()} (described below), to restore the
  terminal state. 
  
--- 1201,1216 ----
  When a @code{SIGINT} is received, the Readline signal handler performs
  some additional work, which will cause any partially-entered line to be
! aborted (see the description of @code{rl_free_line_state()} below).
  
  There is an additional Readline signal handler, for @code{SIGWINCH}, which
  the kernel sends to a process whenever the terminal's size changes (for
  example, if a user resizes an @code{xterm}).  The Readline @code{SIGWINCH}
! handler updates Readline's internal screen size information, and then calls
! any @code{SIGWINCH} signal handler the calling application has installed. 
  Readline calls the application's @code{SIGWINCH} signal handler without
  resetting the terminal to its original state.  If the application's signal
  handler does more than update its idea of the terminal size and return (for
  example, a @code{longjmp} back to a main processing loop), it @emph{must}
! call @code{rl_cleanup_after_signal()} (described below), to restore the
  terminal state. 
  
***************
*** 935,939 ****
  control whether or not it will catch certain signals and act on them
  when they are received.  It is important that applications change the
! values of these variables only when calling @code{readline ()}, not in
  a signal handler, so Readline's internal signal state is not corrupted.
  
--- 1218,1222 ----
  control whether or not it will catch certain signals and act on them
  when they are received.  It is important that applications change the
! values of these variables only when calling @code{readline()}, not in
  a signal handler, so Readline's internal signal state is not corrupted.
  
***************
*** 961,965 ****
  @deftypefun void rl_cleanup_after_signal (void)
  This function will reset the state of the terminal to what it was before
! @code{readline ()} was called, and remove the Readline signal handlers for
  all signals, depending on the values of @code{rl_catch_signals} and
  @code{rl_catch_sigwinch}.
--- 1244,1248 ----
  @deftypefun void rl_cleanup_after_signal (void)
  This function will reset the state of the terminal to what it was before
! @code{readline()} was called, and remove the Readline signal handlers for
  all signals, depending on the values of @code{rl_catch_signals} and
  @code{rl_catch_sigwinch}.
***************
*** 970,974 ****
  (undo information, any partial history entry, any partially-entered
  keyboard macro, and any partially-entered numeric argument).  This
! should be called before @code{rl_cleanup_after_signal ()}.  The
  Readline signal handler for @code{SIGINT} calls this to abort the
  current input line.
--- 1253,1257 ----
  (undo information, any partial history entry, any partially-entered
  keyboard macro, and any partially-entered numeric argument).  This
! should be called before @code{rl_cleanup_after_signal()}.  The
  Readline signal handler for @code{SIGINT} calls this to abort the
  current input line.
***************
*** 982,990 ****
  
  If an application does not wish Readline to catch @code{SIGWINCH}, it may
! call @code{rl_resize_terminal ()} to force Readline to update its idea of
! the terminal size when a @code{SIGWINCH} is received.
  
  @deftypefun void rl_resize_terminal (void)
! Update Readline's internal screen size.
  @end deftypefun
  
--- 1265,1288 ----
  
  If an application does not wish Readline to catch @code{SIGWINCH}, it may
! call @code{rl_resize_terminal()} or @code{rl_set_screen_size()} to force
! Readline to update its idea of the terminal size when a @code{SIGWINCH}
! is received.
  
  @deftypefun void rl_resize_terminal (void)
! Update Readline's internal screen size by reading values from the kernel.
! @end deftypefun
! 
! @deftypefun void rl_set_screen_size (int rows, int cols)
! Set Readline's idea of the terminal size to @var{rows} rows and
! @var{cols} columns.
! @end deftypefun
! 
! If an application does not want to install a @code{SIGWINCH} handler, but
! is still interested in the screen dimensions, Readline's idea of the screen
! size may be queried.
! 
! @deftypefun void rl_get_screen_size (int *rows, int *cols)
! Return Readline's idea of the terminal's size in the
! variables pointed to by the arguments.
  @end deftypefun
  
***************
*** 1000,1004 ****
  @deftypefun int rl_clear_signals (void)
  Remove all of the Readline signal handlers installed by
! @code{rl_set_signals ()}.
  @end deftypefun
  
--- 1298,1302 ----
  @deftypefun int rl_clear_signals (void)
  Remove all of the Readline signal handlers installed by
! @code{rl_set_signals()}.
  @end deftypefun
  
***************
*** 1035,1043 ****
  @enumerate
  @item
! The user-interface function @code{rl_complete ()}.  This function is
! called with the same arguments as other Readline
! functions intended for interactive use:  @var{count} and
! @var{invoking_key}.  It isolates the word to be completed and calls
! @code{completion_matches ()} to generate a list of possible completions.
  It then either lists the possible completions, inserts the possible
  completions, or actually performs the
--- 1333,1341 ----
  @enumerate
  @item
! The user-interface function @code{rl_complete()}.  This function is
! called with the same arguments as other bindable Readline functions:
! @var{count} and @var{invoking_key}.
! It isolates the word to be completed and calls
! @code{rl_completion_matches()} to generate a list of possible completions.
  It then either lists the possible completions, inserts the possible
  completions, or actually performs the
***************
*** 1045,1062 ****
  
  @item
! The internal function @code{completion_matches ()} uses your
! @dfn{generator} function to generate the list of possible matches, and
! then returns the array of these matches.  You should place the address
! of your generator function in @code{rl_completion_entry_function}.
  
  @item
  The generator function is called repeatedly from
! @code{completion_matches ()}, returning a string each time.  The
  arguments to the generator function are @var{text} and @var{state}.
  @var{text} is the partial word to be completed.  @var{state} is zero the
  first time the function is called, allowing the generator to perform
  any necessary initialization, and a positive non-zero integer for
! each subsequent call.  When the generator function returns
! @code{(char *)NULL} this signals @code{completion_matches ()} that there are
  no more possibilities left.  Usually the generator function computes the
  list of possible completions when @var{state} is zero, and returns them
--- 1343,1361 ----
  
  @item
! The internal function @code{rl_completion_matches()} uses an
! application-supplied @dfn{generator} function to generate the list of
! possible matches, and then returns the array of these matches.
! The caller should place the address of its generator function in
! @code{rl_completion_entry_function}.
  
  @item
  The generator function is called repeatedly from
! @code{rl_completion_matches()}, returning a string each time.  The
  arguments to the generator function are @var{text} and @var{state}.
  @var{text} is the partial word to be completed.  @var{state} is zero the
  first time the function is called, allowing the generator to perform
  any necessary initialization, and a positive non-zero integer for
! each subsequent call.  The generator function returns
! @code{(char *)NULL} to inform @code{rl_completion_matches()} that there are
  no more possibilities left.  Usually the generator function computes the
  list of possible completions when @var{state} is zero, and returns them
***************
*** 1070,1081 ****
  Complete the word at or before point.  You have supplied the function
  that does the initial simple matching selection algorithm (see
! @code{completion_matches ()}).  The default is to do filename completion.
  @end deftypefun
  
! @deftypevar {Function *} rl_completion_entry_function
! This is a pointer to the generator function for @code{completion_matches
! ()}.  If the value of @code{rl_completion_entry_function} is
! @code{(Function *)NULL} then the default filename generator function,
! @code{filename_completion_function ()}, is used.
  @end deftypevar
  
--- 1369,1381 ----
  Complete the word at or before point.  You have supplied the function
  that does the initial simple matching selection algorithm (see
! @code{rl_completion_matches()}).  The default is to do filename completion.
  @end deftypefun
  
! @deftypevar {rl_compentry_func_t *} rl_completion_entry_function
! This is a pointer to the generator function for
! @code{rl_completion_matches()}.
! If the value of @code{rl_completion_entry_function} is
! @code{NULL} then the default filename generator
! function, @code{rl_filename_completion_function()}, is used.
  @end deftypevar
  
***************
*** 1098,1122 ****
  Complete the word at or before point.  You have supplied the function
  that does the initial simple matching selection algorithm (see
! @code{completion_matches ()} and @code{rl_completion_entry_function}).
  The default is to do filename
! completion.  This calls @code{rl_complete_internal ()} with an
  argument depending on @var{invoking_key}.
  @end deftypefun
  
! @deftypefun int rl_possible_completions (int count, int invoking_key))
  List the possible completions.  See description of @code{rl_complete
! ()}.  This calls @code{rl_complete_internal ()} with an argument of
  @samp{?}.
  @end deftypefun
  
! @deftypefun int rl_insert_completions (int count, int invoking_key))
  Insert the list of possible completions into the line, deleting the
! partially-completed word.  See description of @code{rl_complete ()}.
! This calls @code{rl_complete_internal ()} with an argument of @samp{*}.
  @end deftypefun
  
! @deftypefun {char **} completion_matches (char *text, CPFunction *entry_func)
! Returns an array of @code{(char *)} which is a list of completions for
! @var{text}.  If there are no completions, returns @code{(char **)NULL}.
  The first entry in the returned array is the substitution for @var{text}.
  The remaining entries are the possible completions.  The array is
--- 1398,1422 ----
  Complete the word at or before point.  You have supplied the function
  that does the initial simple matching selection algorithm (see
! @code{rl_completion_matches()} and @code{rl_completion_entry_function}).
  The default is to do filename
! completion.  This calls @code{rl_complete_internal()} with an
  argument depending on @var{invoking_key}.
  @end deftypefun
  
! @deftypefun int rl_possible_completions (int count, int invoking_key)
  List the possible completions.  See description of @code{rl_complete
! ()}.  This calls @code{rl_complete_internal()} with an argument of
  @samp{?}.
  @end deftypefun
  
! @deftypefun int rl_insert_completions (int count, int invoking_key)
  Insert the list of possible completions into the line, deleting the
! partially-completed word.  See description of @code{rl_complete()}.
! This calls @code{rl_complete_internal()} with an argument of @samp{*}.
  @end deftypefun
  
! @deftypefun {char **} rl_completion_matches (const char *text, rl_compentry_func_t *entry_func)
! Returns an array of strings which is a list of completions for
! @var{text}.  If there are no completions, returns @code{NULL}.
  The first entry in the returned array is the substitution for @var{text}.
  The remaining entries are the possible completions.  The array is
***************
*** 1124,1128 ****
  
  @var{entry_func} is a function of two args, and returns a
! @code{(char *)}.  The first argument is @var{text}.  The second is a
  state argument; it is zero on the first call, and non-zero on subsequent
  calls.  @var{entry_func} returns a @code{NULL}  pointer to the caller
--- 1424,1428 ----
  
  @var{entry_func} is a function of two args, and returns a
! @code{char *}.  The first argument is @var{text}.  The second is a
  state argument; it is zero on the first call, and non-zero on subsequent
  calls.  @var{entry_func} returns a @code{NULL}  pointer to the caller
***************
*** 1130,1142 ****
  @end deftypefun
  
! @deftypefun {char *} filename_completion_function (char *text, int state)
! A generator function for filename completion in the general case.  Note
! that completion in Bash is a little different because of all
! the pathnames that must be followed when looking up completions for a
! command.  The Bash source is a useful reference for writing custom
! completion functions.
  @end deftypefun
  
! @deftypefun {char *} username_completion_function (char *text, int state)
  A completion generator for usernames.  @var{text} contains a partial
  username preceded by a random character (usually @samp{~}).  As with all
--- 1430,1442 ----
  @end deftypefun
  
! @deftypefun {char *} rl_filename_completion_function (const char *text, int state)
! A generator function for filename completion in the general case.
! @var{text} is a partial filename.
! The Bash source is a useful reference for writing custom
! completion functions (the Bash completion functions call this and other
! Readline functions).
  @end deftypefun
  
! @deftypefun {char *} rl_username_completion_function (const char *text, int state)
  A completion generator for usernames.  @var{text} contains a partial
  username preceded by a random character (usually @samp{~}).  As with all
***************
*** 1148,1171 ****
  @subsection Completion Variables
  
! @deftypevar {Function *} rl_completion_entry_function
! A pointer to the generator function for @code{completion_matches ()}.
! @code{NULL} means to use @code{filename_completion_function ()}, the default
  filename completer.
  @end deftypevar
  
! @deftypevar {CPPFunction *} rl_attempted_completion_function
  A pointer to an alternative function to create matches.
  The function is called with @var{text}, @var{start}, and @var{end}.
! @var{start} and @var{end} are indices in @code{rl_line_buffer} saying
! what the boundaries of @var{text} are.  If this function exists and
! returns @code{NULL}, or if this variable is set to @code{NULL}, then
! @code{rl_complete ()} will call the value of
  @code{rl_completion_entry_function} to generate matches, otherwise the
  array of strings returned will be used.
  @end deftypevar
  
! @deftypevar {CPFunction *} rl_filename_quoting_function
! A pointer to a function that will quote a filename in an application-
! specific fashion.  This is called if filename completion is being
  attempted and one of the characters in @code{rl_filename_quote_characters}
  appears in a completed filename.  The function is called with
--- 1448,1474 ----
  @subsection Completion Variables
  
! @deftypevar {rl_compentry_func_t *} rl_completion_entry_function
! A pointer to the generator function for @code{rl_completion_matches()}.
! @code{NULL} means to use @code{rl_filename_completion_function()}, the default
  filename completer.
  @end deftypevar
  
! @deftypevar {rl_completion_func_t *} rl_attempted_completion_function
  A pointer to an alternative function to create matches.
  The function is called with @var{text}, @var{start}, and @var{end}.
! @var{start} and @var{end} are indices in @code{rl_line_buffer} defining
! the boundaries of @var{text}, which is a character string.
! If this function exists and returns @code{NULL}, or if this variable is
! set to @code{NULL}, then @code{rl_complete()} will call the value of
  @code{rl_completion_entry_function} to generate matches, otherwise the
  array of strings returned will be used.
+ If this function sets the @code{rl_attempted_completion_over}
+ variable to a non-zero value, Readline will not perform its default
+ completion even if this function returns no matches.
  @end deftypevar
  
! @deftypevar {rl_quote_func_t *} rl_filename_quoting_function
! A pointer to a function that will quote a filename in an
! application-specific fashion.  This is called if filename completion is being
  attempted and one of the characters in @code{rl_filename_quote_characters}
  appears in a completed filename.  The function is called with
***************
*** 1179,1183 ****
  @end deftypevar
  
! @deftypevar {CPFunction *} rl_filename_dequoting_function
  A pointer to a function that will remove application-specific quoting
  characters from a filename before completion is attempted, so those
--- 1482,1486 ----
  @end deftypevar
  
! @deftypevar {rl_dequote_func_t *} rl_filename_dequoting_function
  A pointer to a function that will remove application-specific quoting
  characters from a filename before completion is attempted, so those
***************
*** 1189,1196 ****
  @end deftypevar
  
! @deftypevar {Function *} rl_char_is_quoted_p
  A pointer to a function to call that determines whether or not a specific
  character in the line buffer is quoted, according to whatever quoting
! mechanism the program calling readline uses.  The function is called with
  two arguments: @var{text}, the text of the line, and @var{index}, the
  index of the character in the line.  It is used to decide whether a
--- 1492,1499 ----
  @end deftypevar
  
! @deftypevar {rl_linebuf_func_t *} rl_char_is_quoted_p
  A pointer to a function to call that determines whether or not a specific
  character in the line buffer is quoted, according to whatever quoting
! mechanism the program calling Readline uses.  The function is called with
  two arguments: @var{text}, the text of the line, and @var{index}, the
  index of the character in the line.  It is used to decide whether a
***************
*** 1205,1227 ****
  @end deftypevar
  
! @deftypevar {char *} rl_basic_word_break_characters
  The basic list of characters that signal a break between words for the
  completer routine.  The default value of this variable is the characters
! which break words for completion in Bash, i.e.,
  @code{" \t\n\"\\'`@@$><=;|&@{("}.
  @end deftypevar
  
! @deftypevar {char *} rl_basic_quote_characters
! List of quote characters which can cause a word break.
  @end deftypevar
  
! @deftypevar {char *} rl_completer_word_break_characters
  The list of characters that signal a break between words for
! @code{rl_complete_internal ()}.  The default list is the value of
  @code{rl_basic_word_break_characters}.
  @end deftypevar
  
! @deftypevar {char *} rl_completer_quote_characters
! List of characters which can be used to quote a substring of the line.
  Completion occurs on the entire substring, and within the substring
  @code{rl_completer_word_break_characters} are treated as any other character,
--- 1508,1530 ----
  @end deftypevar
  
! @deftypevar {const char *} rl_basic_word_break_characters
  The basic list of characters that signal a break between words for the
  completer routine.  The default value of this variable is the characters
! which break words for completion in Bash:
  @code{" \t\n\"\\'`@@$><=;|&@{("}.
  @end deftypevar
  
! @deftypevar {const char *} rl_basic_quote_characters
! A list of quote characters which can cause a word break.
  @end deftypevar
  
! @deftypevar {const char *} rl_completer_word_break_characters
  The list of characters that signal a break between words for
! @code{rl_complete_internal()}.  The default list is the value of
  @code{rl_basic_word_break_characters}.
  @end deftypevar
  
! @deftypevar {const char *} rl_completer_quote_characters
! A list of characters which can be used to quote a substring of the line.
  Completion occurs on the entire substring, and within the substring
  @code{rl_completer_word_break_characters} are treated as any other character,
***************
*** 1229,1238 ****
  @end deftypevar
  
! @deftypevar {char *} rl_filename_quote_characters
  A list of characters that cause a filename to be quoted by the completer
  when they appear in a completed filename.  The default is the null string.
  @end deftypevar
  
! @deftypevar {char *} rl_special_prefixes
  The list of characters that are word break characters, but should be
  left in @var{text} when it is passed to the completion function.
--- 1532,1541 ----
  @end deftypevar
  
! @deftypevar {const char *} rl_filename_quote_characters
  A list of characters that cause a filename to be quoted by the completer
  when they appear in a completed filename.  The default is the null string.
  @end deftypevar
  
! @deftypevar {const char *} rl_special_prefixes
  The list of characters that are word break characters, but should be
  left in @var{text} when it is passed to the completion function.
***************
*** 1253,1257 ****
  
  @deftypevar int rl_ignore_completion_duplicates
! If non-zero, then disallow duplicates in the matches.  Default is 1.
  @end deftypevar
  
--- 1556,1561 ----
  
  @deftypevar int rl_ignore_completion_duplicates
! If non-zero, then duplicates in the matches are removed.
! The default is 1.
  @end deftypevar
  
***************
*** 1261,1266 ****
  within a completion entry generator function.  If it is set to a non-zero
  value, directory names have a slash appended and Readline attempts to
! quote completed filenames if they contain any embedded word break
! characters.
  @end deftypevar
  
--- 1565,1571 ----
  within a completion entry generator function.  If it is set to a non-zero
  value, directory names have a slash appended and Readline attempts to
! quote completed filenames if they contain any characters in
! @code{rl_filename_quote_characters} and @code{rl_filename_quoting_desired}
! is set to a non-zero value.
  @end deftypevar
  
***************
*** 1275,1284 ****
  @end deftypevar
  
  @deftypevar int rl_inhibit_completion
! If this variable is non-zero, completion is inhibit<ed.  The completion
  character will be inserted as any other bound to @code{self-insert}.
  @end deftypevar
  
! @deftypevar {Function *} rl_ignore_some_completions_function
  This function, if defined, is called by the completer when real filename
  completion is done, after all the matching names have been generated.
--- 1580,1603 ----
  @end deftypevar
  
+ @deftypevar int rl_attempted_completion_over
+ If an application-specific completion function assigned to
+ @code{rl_attempted_completion_function} sets this variable to a non-zero
+ value, Readline will not perform its default filename completion even
+ if the application's completion function returns no matches.
+ It should be set only by an application's completion function.
+ @end deftypevar
+ 
+ @deftypevar int rl_completion_type
+ Set to a character describing the type of completion Readline is currently
+ attempting; see the description of @code{rl_complete_internal()}
+ (@pxref{Completion Functions}) for the list of characters.
+ @end deftypevar
+ 
  @deftypevar int rl_inhibit_completion
! If this variable is non-zero, completion is inhibited.  The completion
  character will be inserted as any other bound to @code{self-insert}.
  @end deftypevar
  
! @deftypevar {rl_compignore_func_t *} rl_ignore_some_completions_function
  This function, if defined, is called by the completer when real filename
  completion is done, after all the matching names have been generated.
***************
*** 1290,1301 ****
  @end deftypevar
  
! @deftypevar {Function *} rl_directory_completion_hook
  This function, if defined, is allowed to modify the directory portion
  of filenames Readline completes.  It is called with the address of a
! string (the current directory name) as an argument.  It could be used
! to expand symbolic links or shell variables in pathnames.
  @end deftypevar
  
! @deftypevar {VFunction *} rl_completion_display_matches_hook
  If non-zero, then this is the address of a function to call when
  completing a word would normally display the list of possible matches.
--- 1609,1626 ----
  @end deftypevar
  
! @deftypevar {rl_icppfunc_t *} rl_directory_completion_hook
  This function, if defined, is allowed to modify the directory portion
  of filenames Readline completes.  It is called with the address of a
! string (the current directory name) as an argument, and may modify that string.
! If the string is replaced with a new string, the old value should be freed.
! Any modified directory name should have a trailing slash.
! The modified value will be displayed as part of the completion, replacing
! the directory portion of the pathname the user typed.
! It returns an integer that should be non-zero if the function modifies
! its directory argument.
! It could be used to expand symbolic links or shell variables in pathnames.
  @end deftypevar
  
! @deftypevar {rl_compdisp_func_t *} rl_completion_display_matches_hook
  If non-zero, then this is the address of a function to call when
  completing a word would normally display the list of possible matches.
***************
*** 1335,1344 ****
  #include <readline/history.h>
  
- extern char *getwd ();
  extern char *xmalloc ();
  
  /* The names of functions that actually do the manipulation. */
! int com_list (), com_view (), com_rename (), com_stat (), com_pwd ();
! int com_delete (), com_help (), com_cd (), com_quit ();
  
  /* A structure which contains information on the commands this program
--- 1660,1675 ----
  #include <readline/history.h>
  
  extern char *xmalloc ();
  
  /* The names of functions that actually do the manipulation. */
! int com_list __P((char *));
! int com_view __P((char *));
! int com_rename __P((char *));
! int com_stat __P((char *));
! int com_pwd __P((char *));
! int com_delete __P((char *));
! int com_help __P((char *));
! int com_cd __P((char *));
! int com_quit __P((char *));
  
  /* A structure which contains information on the commands this program
***************
*** 1347,1351 ****
  typedef struct @{
    char *name;			/* User printable name of the function. */
!   Function *func;		/* Function to call to do the job. */
    char *doc;			/* Documentation for this function.  */
  @} COMMAND;
--- 1678,1682 ----
  typedef struct @{
    char *name;			/* User printable name of the function. */
!   rl_icpfunc_t *func;		/* Function to call to do the job. */
    char *doc;			/* Documentation for this function.  */
  @} COMMAND;
***************
*** 1363,1367 ****
    @{ "stat", com_stat, "Print out statistics on FILE" @},
    @{ "view", com_view, "View the contents of FILE" @},
!   @{ (char *)NULL, (Function *)NULL, (char *)NULL @}
  @};
  
--- 1694,1698 ----
    @{ "stat", com_stat, "Print out statistics on FILE" @},
    @{ "view", com_view, "View the contents of FILE" @},
!   @{ (char *)NULL, (rl_icpfunc_t *)NULL, (char *)NULL @}
  @};
  
***************
*** 1373,1377 ****
  char *progname;
  
! /* When non-zero, this global means the user is done using this program. */
  int done;
  
--- 1704,1708 ----
  char *progname;
  
! /* When non-zero, this means the user is done using this program. */
  int done;
  
***************
*** 1503,1512 ****
  /* **************************************************************** */
  
! char *command_generator ();
! char **fileman_completion ();
  
! /* Tell the GNU Readline library how to complete.  We want to try to complete
!    on command names if this is the first word in the line, or on filenames
!    if not. */
  initialize_readline ()
  @{
--- 1834,1843 ----
  /* **************************************************************** */
  
! char *command_generator __P((const char *, int));
! char **fileman_completion __P((const char *, int, int));
  
! /* Tell the GNU Readline library how to complete.  We want to try to
!    complete on command names if this is the first word in the line, or
!    on filenames if not. */
  initialize_readline ()
  @{
***************
*** 1515,1529 ****
  
    /* Tell the completer that we want a crack first. */
!   rl_attempted_completion_function = (CPPFunction *)fileman_completion;
  @}
  
! /* Attempt to complete on the contents of TEXT.  START and END bound the
!    region of rl_line_buffer that contains the word to complete.  TEXT is
!    the word to complete.  We can use the entire contents of rl_line_buffer
!    in case we want to do some simple parsing.  Return the array of matches,
!    or NULL if there aren't any. */
  char **
  fileman_completion (text, start, end)
!      char *text;
       int start, end;
  @{
--- 1846,1860 ----
  
    /* Tell the completer that we want a crack first. */
!   rl_attempted_completion_function = fileman_completion;
  @}
  
! /* Attempt to complete on the contents of TEXT.  START and END
!    bound the region of rl_line_buffer that contains the word to
!    complete.  TEXT is the word to complete.  We can use the entire
!    contents of rl_line_buffer in case we want to do some simple
!    parsing.  Returnthe array of matches, or NULL if there aren't any. */
  char **
  fileman_completion (text, start, end)
!      const char *text;
       int start, end;
  @{
***************
*** 1536,1550 ****
       directory. */
    if (start == 0)
!     matches = completion_matches (text, command_generator);
  
    return (matches);
  @}
  
! /* Generator function for command completion.  STATE lets us know whether
!    to start from scratch; without any state (i.e. STATE == 0), then we
!    start at the top of the list. */
  char *
  command_generator (text, state)
!      char *text;
       int state;
  @{
--- 1867,1881 ----
       directory. */
    if (start == 0)
!     matches = rl_completion_matches (text, command_generator);
  
    return (matches);
  @}
  
! /* Generator function for command completion.  STATE lets us
!    know whether to start from scratch; without any state
!    (i.e. STATE == 0), then we start at the top of the list. */
  char *
  command_generator (text, state)
!      const char *text;
       int state;
  @{
***************
*** 1552,1558 ****
    char *name;
  
!   /* If this is a new word to complete, initialize now.  This includes
!      saving the length of TEXT for efficiency, and initializing the index
!      variable to 0. */
    if (!state)
      @{
--- 1883,1889 ----
    char *name;
  
!   /* If this is a new word to complete, initialize now.  This
!      includes saving the length of TEXT for efficiency, and
!      initializing the index variable to 0. */
    if (!state)
      @{
***************
*** 1561,1565 ****
      @}
  
!   /* Return the next name which partially matches from the command list. */
    while (name = commands[list_index].name)
      @{
--- 1892,1897 ----
      @}
  
!   /* Return the next name which partially matches from the
!      command list. */
    while (name = commands[list_index].name)
      @{
***************
*** 1706,1710 ****
    char dir[1024], *s;
  
!   s = getwd (dir);
    if (s == 0)
      @{
--- 2038,2042 ----
    char dir[1024], *s;
  
!   s = getcwd (dir, sizeof(dir) - 1);
    if (s == 0)
      @{
***************
*** 1717,1721 ****
  @}
  
! /* The user wishes to quit using this program.  Just set DONE non-zero. */
  com_quit (arg)
       char *arg;
--- 2049,2054 ----
  @}
  
! /* The user wishes to quit using this program.  Just set DONE
!    non-zero. */
  com_quit (arg)
       char *arg;
diff -Nrc2 bash-2.04/lib/readline/doc/rluser.texinfo bash-2.05/lib/readline/doc/rluser.texinfo
*** bash-2.04/lib/readline/doc/rluser.texinfo	Tue Feb 22 12:19:32 2000
--- bash-2.05/lib/readline/doc/rluser.texinfo	Mon Mar  5 11:11:53 2001
***************
*** 11,15 ****
  GNU Readline Library.
  
! Copyright (C) 1988-1999 Free Software Foundation, Inc.
  
  Authored by Brian Fox and Chet Ramey.
--- 11,15 ----
  GNU Readline Library.
  
! Copyright (C) 1988-2000 Free Software Foundation, Inc.
  
  Authored by Brian Fox and Chet Ramey.
***************
*** 73,81 ****
  keystrokes.
  
! The text @key{C-k} is read as `Control-K' and describes the character
  produced when the @key{k} key is pressed while the Control key
  is depressed.
  
! The text @key{M-k} is read as `Meta-K' and describes the character
  produced when the Meta key (if you have one) is depressed, and the @key{k}
  key is pressed.
--- 73,81 ----
  keystrokes.
  
! The text @kbd{C-k} is read as `Control-K' and describes the character
  produced when the @key{k} key is pressed while the Control key
  is depressed.
  
! The text @kbd{M-k} is read as `Meta-K' and describes the character
  produced when the Meta key (if you have one) is depressed, and the @key{k}
  key is pressed.
***************
*** 90,98 ****
  If you do not have a Meta or @key{ALT} key, or another key working as
  a Meta key, the identical keystroke can be generated by typing @key{ESC}
! @i{first}, and then typing @key{k}.
  Either process is known as @dfn{metafying} the @key{k} key.
  
! The text @key{M-C-k} is read as `Meta-Control-k' and describes the
! character produced by @dfn{metafying} @key{C-k}.
  
  In addition, several keys have their own names.  Specifically,
--- 90,98 ----
  If you do not have a Meta or @key{ALT} key, or another key working as
  a Meta key, the identical keystroke can be generated by typing @key{ESC}
! @emph{first}, and then typing @key{k}.
  Either process is known as @dfn{metafying} the @key{k} key.
  
! The text @kbd{M-C-k} is read as `Meta-Control-k' and describes the
! character produced by @dfn{metafying} @kbd{C-k}.
  
  In addition, several keys have their own names.  Specifically,
***************
*** 116,121 ****
  you move the cursor to the place that needs correction, and delete or
  insert the text of the corrections.  Then, when you are satisfied with
! the line, you simply press @key{RETURN}.  You do not have to be at the
! end of the line to press @key{RETURN}; the entire line is accepted
  regardless of the location of the cursor within the line.
  
--- 116,121 ----
  you move the cursor to the place that needs correction, and delete or
  insert the text of the corrections.  Then, when you are satisfied with
! the line, you simply press @key{RET}.  You do not have to be at the
! end of the line to press @key{RET}; the entire line is accepted
  regardless of the location of the cursor within the line.
  
***************
*** 141,147 ****
  Sometimes you may mistype a character, and
  not notice the error until you have typed several other characters.  In
! that case, you can type @key{C-b} to move the cursor to the left, and then
  correct your mistake.  Afterwards, you can move the cursor to the right
! with @key{C-f}.
  
  When you add text in the middle of a line, you will notice that characters
--- 141,147 ----
  Sometimes you may mistype a character, and
  not notice the error until you have typed several other characters.  In
! that case, you can type @kbd{C-b} to move the cursor to the left, and then
  correct your mistake.  Afterwards, you can move the cursor to the right
! with @kbd{C-f}.
  
  When you add text in the middle of a line, you will notice that characters
***************
*** 153,167 ****
  
  @table @asis
! @item @key{C-b}
  Move back one character.
! @item @key{C-f}
  Move forward one character.
  @item @key{DEL} or @key{Backspace}
  Delete the character to the left of the cursor.
! @item @key{C-d}
  Delete the character underneath the cursor.
  @item @w{Printing characters}
  Insert the character into the line at the cursor.
! @item @key{C-_} or @key{C-x C-u}
  Undo the last editing command.  You can undo all the way back to an
  empty line.
--- 153,167 ----
  
  @table @asis
! @item @kbd{C-b}
  Move back one character.
! @item @kbd{C-f}
  Move forward one character.
  @item @key{DEL} or @key{Backspace}
  Delete the character to the left of the cursor.
! @item @kbd{C-d}
  Delete the character underneath the cursor.
  @item @w{Printing characters}
  Insert the character into the line at the cursor.
! @item @kbd{C-_} or @kbd{C-x C-u}
  Undo the last editing command.  You can undo all the way back to an
  empty line.
***************
*** 171,175 ****
  (Depending on your configuration, the @key{Backspace} key be set to
  delete the character to the left of the cursor and the @key{DEL} key set
! to delete the character underneath the cursor, like @key{C-d}, rather
  than the character to the left of the cursor.)
  
--- 171,175 ----
  (Depending on your configuration, the @key{Backspace} key be set to
  delete the character to the left of the cursor and the @key{DEL} key set
! to delete the character underneath the cursor, like @kbd{C-d}, rather
  than the character to the left of the cursor.)
  
***************
*** 180,188 ****
  The above table describes the most basic keystrokes that you need
  in order to do editing of the input line.  For your convenience, many
! other commands have been added in addition to @key{C-b}, @key{C-f},
! @key{C-d}, and @key{DEL}.  Here are some commands for moving more rapidly
  about the line.
  
! @table @key
  @item C-a
  Move to the start of the line.
--- 180,188 ----
  The above table describes the most basic keystrokes that you need
  in order to do editing of the input line.  For your convenience, many
! other commands have been added in addition to @kbd{C-b}, @kbd{C-f},
! @kbd{C-d}, and @key{DEL}.  Here are some commands for moving more rapidly
  about the line.
  
! @table @kbd
  @item C-a
  Move to the start of the line.
***************
*** 197,201 ****
  @end table
  
! Notice how @key{C-f} moves forward a character, while @key{M-f} moves
  forward a word.  It is a loose convention that control keystrokes
  operate on characters while meta keystrokes operate on words.
--- 197,201 ----
  @end table
  
! Notice how @kbd{C-f} moves forward a character, while @kbd{M-f} moves
  forward a word.  It is a loose convention that control keystrokes
  operate on characters while meta keystrokes operate on words.
***************
*** 226,230 ****
  Here is the list of commands for killing text.
  
! @table @key
  @item C-k
  Kill the text from the current cursor position to the end of the line.
--- 226,230 ----
  Here is the list of commands for killing text.
  
! @table @kbd
  @item C-k
  Kill the text from the current cursor position to the end of the line.
***************
*** 233,246 ****
  Kill from the cursor to the end of the current word, or, if between
  words, to the end of the next word.
! Word boundaries are the same as those used by @key{M-f}.
  
! @item M-DEL
  Kill from the cursor the start of the previous word, or, if between
  words, to the start of the previous word.
! Word boundaries are the same as those used by @key{M-b}.
  
  @item C-w
  Kill from the cursor to the previous whitespace.  This is different than
! @key{M-DEL} because the word boundaries differ.
  
  @end table
--- 233,246 ----
  Kill from the cursor to the end of the current word, or, if between
  words, to the end of the next word.
! Word boundaries are the same as those used by @kbd{M-f}.
  
! @item M-@key{DEL}
  Kill from the cursor the start of the previous word, or, if between
  words, to the start of the previous word.
! Word boundaries are the same as those used by @kbd{M-b}.
  
  @item C-w
  Kill from the cursor to the previous whitespace.  This is different than
! @kbd{M-@key{DEL}} because the word boundaries differ.
  
  @end table
***************
*** 249,253 ****
  means to copy the most-recently-killed text from the kill buffer.
  
! @table @key
  @item C-y
  Yank the most recently killed text back into the buffer at the cursor.
--- 249,253 ----
  means to copy the most-recently-killed text from the kill buffer.
  
! @table @kbd
  @item C-y
  Yank the most recently killed text back into the buffer at the cursor.
***************
*** 255,259 ****
  @item M-y
  Rotate the kill-ring, and yank the new top.  You can only do this if
! the prior command is @key{C-y} or @key{M-y}.
  @end table
  
--- 255,259 ----
  @item M-y
  Rotate the kill-ring, and yank the new top.  You can only do this if
! the prior command is @kbd{C-y} or @kbd{M-y}.
  @end table
  
***************
*** 273,277 ****
  you have typed one meta digit to get the argument started, you can type
  the remainder of the digits, and then the command.  For example, to give
! the @key{C-d} command an argument of 10, you could type @samp{M-1 0 C-d}.
  
  @node Searching
--- 273,278 ----
  you have typed one meta digit to get the argument started, you can type
  the remainder of the digits, and then the command.  For example, to give
! the @kbd{C-d} command an argument of 10, you could type @samp{M-1 0 C-d},
! which will delete the next ten characters on the input line.
  
  @node Searching
***************
*** 283,287 ****
  @end ifset
  for lines containing a specified string.
! There are two search modes:  @var{incremental} and @var{non-incremental}.
  
  Incremental searches begin before the user has finished typing the
--- 284,288 ----
  @end ifset
  for lines containing a specified string.
! There are two search modes:  @dfn{incremental} and @dfn{non-incremental}.
  
  Incremental searches begin before the user has finished typing the
***************
*** 292,306 ****
  find the desired history entry.
  To search backward in the history for a particular string, type
! @key{C-r}.  Typing @key{C-s} searches forward through the history.
  The characters present in the value of the @code{isearch-terminators} variable
  are used to terminate an incremental search.
  If that variable has not been assigned a value, the @key{ESC} and
! @key{C-J} characters will terminate an incremental search.
! @key{C-g} will abort an incremental search and restore the original line.
  When the search is terminated, the history entry containing the
  search string becomes the current line.
  
! To find other matching entries in the history list, type @key{C-r} or
! @key{C-s} as appropriate.
  This will search backward or forward in the history for the next
  entry matching the search string typed so far.
--- 293,307 ----
  find the desired history entry.
  To search backward in the history for a particular string, type
! @kbd{C-r}.  Typing @kbd{C-s} searches forward through the history.
  The characters present in the value of the @code{isearch-terminators} variable
  are used to terminate an incremental search.
  If that variable has not been assigned a value, the @key{ESC} and
! @kbd{C-J} characters will terminate an incremental search.
! @kbd{C-g} will abort an incremental search and restore the original line.
  When the search is terminated, the history entry containing the
  search string becomes the current line.
  
! To find other matching entries in the history list, type @kbd{C-r} or
! @kbd{C-s} as appropriate.
  This will search backward or forward in the history for the next
  entry matching the search string typed so far.
***************
*** 309,312 ****
--- 310,315 ----
  For instance, a @key{RET} will terminate the search and accept
  the line, thereby executing the command from the history list.
+ A movement command will terminate the search, make the last line found
+ the current line, and begin editing.
  
  Non-incremental searches read the entire search string before starting
***************
*** 325,332 ****
  The name of this
  @ifset BashFeatures
! file is taken from the value of the shell variable @code{INPUTRC}.  If
  @end ifset
  @ifclear BashFeatures
! file is taken from the value of the environment variable @code{INPUTRC}.  If
  @end ifclear
  that variable is unset, the default is @file{~/.inputrc}.
--- 328,335 ----
  The name of this
  @ifset BashFeatures
! file is taken from the value of the shell variable @env{INPUTRC}.  If
  @end ifset
  @ifclear BashFeatures
! file is taken from the value of the environment variable @env{INPUTRC}.  If
  @end ifclear
  that variable is unset, the default is @file{~/.inputrc}.
***************
*** 360,364 ****
  You can modify the run-time behavior of Readline by
  altering the values of variables in Readline
! using the @code{set} command within the init file.  Here is how to
  change from the default Emacs-like key binding to use
  @code{vi} line editing commands:
--- 363,375 ----
  You can modify the run-time behavior of Readline by
  altering the values of variables in Readline
! using the @code{set} command within the init file.
! The syntax is simple:
! 
! @example
! set @var{variable} @var{value}
! @end example
! 
! @noindent
! Here, for example, is how to
  change from the default Emacs-like key binding to use
  @code{vi} line editing commands:
***************
*** 368,371 ****
--- 379,385 ----
  @end example
  
+ Variable names and values, where appropriate, are recognized without regard
+ to case. 
+ 
  @ifset BashFeatures
  The @w{@code{bind -V}} command lists the current Readline variable names
***************
*** 376,379 ****
--- 390,394 ----
  variables.
  
+ @cindex variables, readline
  @table @code
  
***************
*** 403,413 ****
  number of possible completions is greater than this value,
  Readline will ask the user whether or not he wishes to view
! them; otherwise, they are simply listed.  The default limit is
! @code{100}.
  
  @item convert-meta
  @vindex convert-meta
  If set to @samp{on}, Readline will convert characters with the
! eighth bit set to an ASCII key sequence by stripping the eighth
  bit and prefixing an @key{ESC} character, converting them to a
  meta-prefixed key sequence.  The default value is @samp{on}.
--- 418,429 ----
  number of possible completions is greater than this value,
  Readline will ask the user whether or not he wishes to view
! them; otherwise, they are simply listed.
! This variable must be set to an integer value greater than or equal to 0.
! The default limit is @code{100}.
  
  @item convert-meta
  @vindex convert-meta
  If set to @samp{on}, Readline will convert characters with the
! eighth bit set to an @sc{ascii} key sequence by stripping the eighth
  bit and prefixing an @key{ESC} character, converting them to a
  meta-prefixed key sequence.  The default value is @samp{on}.
***************
*** 449,453 ****
  @vindex meta-flag
  If set to @samp{on}, Readline will enable eight-bit input (it
! will not strip the eighth bit from the characters it reads),
  regardless of what the terminal claims it can support.  The
  default value is @samp{off}.  The name @code{meta-flag} is a
--- 465,469 ----
  @vindex meta-flag
  If set to @samp{on}, Readline will enable eight-bit input (it
! will not clear the eighth bit in the characters it reads),
  regardless of what the terminal claims it can support.  The
  default value is @samp{off}.  The name @code{meta-flag} is a
***************
*** 459,463 ****
  subsequently executing the character as a command (@pxref{Searching}).
  If this variable has not been given a value, the characters @key{ESC} and
! @key{C-J} will terminate an incremental search.
  
  @item keymap
--- 475,479 ----
  subsequently executing the character as a command (@pxref{Searching}).
  If this variable has not been given a value, the characters @key{ESC} and
! @kbd{C-J} will terminate an incremental search.
  
  @item keymap
***************
*** 470,473 ****
--- 486,490 ----
  @code{emacs-ctlx},
  @code{vi},
+ @code{vi-move},
  @code{vi-command}, and
  @code{vi-insert}.
***************
*** 521,529 ****
  the command does.
  
! Once you know the name of the command, simply place the name of the key
  you wish to bind the command to, a colon, and then the name of the
! command on a line in the init file.  The name of the key
! can be expressed in different ways, depending on which is most
! comfortable for you.
  
  @ifset BashFeatures
--- 538,550 ----
  the command does.
  
! Once you know the name of the command, simply place on a line
! in the init file the name of the key
  you wish to bind the command to, a colon, and then the name of the
! command.  The name of the key
! can be expressed in different ways, depending on what you find most
! comfortable.
! 
! In addition to command names, readline allows keys to be bound
! to a string that is inserted when the key is pressed (a @var{macro}).
  
  @ifset BashFeatures
***************
*** 542,550 ****
  @end example
  
! In the above example, @key{C-u} is bound to the function
! @code{universal-argument}, and @key{C-o} is bound to run the macro
  expressed on the right hand side (that is, to insert the text
  @samp{> output} into the line).
  
  @item @w{"@var{keyseq}": @var{function-name} or @var{macro}}
  @var{keyseq} differs from @var{keyname} above in that strings
--- 563,588 ----
  @end example
  
! In the above example, @kbd{C-u} is bound to the function
! @code{universal-argument},
! @kbd{M-DEL} is bound to the function @code{backward-kill-word}, and
! @kbd{C-o} is bound to run the macro
  expressed on the right hand side (that is, to insert the text
  @samp{> output} into the line).
  
+ A number of symbolic character names are recognized while
+ processing this key binding syntax:
+ @var{DEL},
+ @var{ESC},
+ @var{ESCAPE},
+ @var{LFD},
+ @var{NEWLINE},
+ @var{RET},
+ @var{RETURN},
+ @var{RUBOUT},
+ @var{SPACE},
+ @var{SPC},
+ and
+ @var{TAB}.
+ 
  @item @w{"@var{keyseq}": @var{function-name} or @var{macro}}
  @var{keyseq} differs from @var{keyname} above in that strings
***************
*** 560,566 ****
  @end example
  
! In the above example, @key{C-u} is bound to the function
  @code{universal-argument} (just as it was in the first example),
! @samp{@key{C-x} @key{C-r}} is bound to the function @code{re-read-init-file},
  and @samp{@key{ESC} @key{[} @key{1} @key{1} @key{~}} is bound to insert
  the text @samp{Function Key 1}.
--- 598,604 ----
  @end example
  
! In the above example, @kbd{C-u} is again bound to the function
  @code{universal-argument} (just as it was in the first example),
! @samp{@kbd{C-x} @kbd{C-r}} is bound to the function @code{re-read-init-file},
  and @samp{@key{ESC} @key{[} @key{1} @key{1} @key{~}} is bound to insert
  the text @samp{Function Key 1}.
***************
*** 607,614 ****
  vertical tab
  @item \@var{nnn}
! the character whose @code{ASCII} code is the octal value @var{nnn}
  (one to three digits)
  @item \x@var{nnn}
! the character whose @code{ASCII} code is the hexadecimal value @var{nnn}
  (one to three digits)
  @end table
--- 645,652 ----
  vertical tab
  @item \@var{nnn}
! the character whose @sc{ascii} code is the octal value @var{nnn}
  (one to three digits)
  @item \x@var{nnn}
! the character whose @sc{ascii} code is the hexadecimal value @var{nnn}
  (one to three digits)
  @end table
***************
*** 620,624 ****
  Backslash will quote any other character in the macro text,
  including @samp{"} and @samp{'}.
! For example, the following binding will make @samp{C-x \}
  insert a single @samp{\} into the line:
  @example
--- 658,662 ----
  Backslash will quote any other character in the macro text,
  including @samp{"} and @samp{'}.
! For example, the following binding will make @samp{@kbd{C-x} \}
  insert a single @samp{\} into the line:
  @example
***************
*** 664,668 ****
  The @var{application} construct is used to include
  application-specific settings.  Each program using the Readline
! library sets the @var{application name}, and you can test for it. 
  This could be used to bind key sequences to functions useful for
  a specific program.  For instance, the following command adds a
--- 702,707 ----
  The @var{application} construct is used to include
  application-specific settings.  Each program using the Readline
! library sets the @var{application name}, and you can test for
! a particular value. 
  This could be used to bind key sequences to functions useful for
  a specific program.  For instance, the following command adds a
***************
*** 687,690 ****
--- 726,730 ----
  This directive takes a single filename as an argument and reads commands
  and bindings from that file.
+ For example, the following directive reads from @file{/etc/inputrc}:
  @example
  $include /etc/inputrc
***************
*** 695,699 ****
  @subsection Sample Init File
  
! Here is an example of an inputrc file.  This illustrates key
  binding, variable assignment, and conditional syntax.
  
--- 735,739 ----
  @subsection Sample Init File
  
! Here is an example of an @var{inputrc} file.  This illustrates key
  binding, variable assignment, and conditional syntax.
  
***************
*** 820,829 ****
  @var{inputrc} file, @w{@code{bind -p}}.  (@xref{Bash Builtins}.)
  @end ifset
- 
  Command names without an accompanying key sequence are unbound by default.
! In the following descriptions, @var{point} refers to the current cursor
! position, and @var{mark} refers to a cursor position saved by the
  @code{set-mark} command.
! The text between the point and mark is referred to as the @var{region}.
  
  @node Commands For Moving
--- 860,869 ----
  @var{inputrc} file, @w{@code{bind -p}}.  (@xref{Bash Builtins}.)
  @end ifset
  Command names without an accompanying key sequence are unbound by default.
! 
! In the following descriptions, @dfn{point} refers to the current cursor
! position, and @dfn{mark} refers to a cursor position saved by the
  @code{set-mark} command.
! The text between the point and mark is referred to as the @dfn{region}.
  
  @node Commands For Moving
***************
*** 863,885 ****
  
  @ftable @code
! @item accept-line (Newline, Return)
  @ifset BashFeatures
! Accept the line regardless of where the cursor is.  If this line is
  non-empty, add it to the history list according to the setting of
! the @code{HISTCONTROL} and @code{HISTIGNORE} variables.
! If this line was a history line, then restore the history line to its
! original state.
  @end ifset
  @ifclear BashFeatures
! Accept the line regardless of where the cursor is.  If this line is
! non-empty, add it to the history list.  If this line was a history
! line, then restore the history line to its original state.
  @end ifclear
  
  @item previous-history (C-p)
! Move `up' through the history list.
  
  @item next-history (C-n)
! Move `down' through the history list.
  
  @item beginning-of-history (M-<)
--- 903,929 ----
  
  @ftable @code
! @item accept-line (Newline or Return)
  @ifset BashFeatures
! Accept the line regardless of where the cursor is.
! If this line is
  non-empty, add it to the history list according to the setting of
! the @env{HISTCONTROL} and @env{HISTIGNORE} variables.
! If this line is a modified history line, then restore the history line
! to its original state.
  @end ifset
  @ifclear BashFeatures
! Accept the line regardless of where the cursor is.
! If this line is
! non-empty, it may be added to the history list for future recall with
! @code{add_history()}.
! If this line is a modified history line, the history line is restored
! to its original state.
  @end ifclear
  
  @item previous-history (C-p)
! Move `back' through the history list, fetching the previous command.
  
  @item next-history (C-n)
! Move `forward' through the history list, fetching the next command.
  
  @item beginning-of-history (M-<)
***************
*** 921,930 ****
  @item yank-nth-arg (M-C-y)
  Insert the first argument to the previous command (usually
! the second word on the previous line).  With an argument @var{n},
  insert the @var{n}th word from the previous command (the words
  in the previous command begin with word 0).  A negative argument
  inserts the @var{n}th word from the end of the previous command.
  
! @item yank-last-arg (M-., M-_)
  Insert last argument to the previous command (the last word of the
  previous history entry).  With an
--- 965,975 ----
  @item yank-nth-arg (M-C-y)
  Insert the first argument to the previous command (usually
! the second word on the previous line) at point.
! With an argument @var{n},
  insert the @var{n}th word from the previous command (the words
  in the previous command begin with word 0).  A negative argument
  inserts the @var{n}th word from the end of the previous command.
  
! @item yank-last-arg (M-. or M-_)
  Insert last argument to the previous command (the last word of the
  previous history entry).  With an
***************
*** 940,947 ****
  @ftable @code
  @item delete-char (C-d)
! Delete the character under the cursor.  If the cursor is at the
  beginning of the line, there are no characters in the line, and
  the last character typed was not bound to @code{delete-char}, then
! return @code{EOF}.
  
  @item backward-delete-char (Rubout)
--- 985,992 ----
  @ftable @code
  @item delete-char (C-d)
! Delete the character at point.  If point is at the
  beginning of the line, there are no characters in the line, and
  the last character typed was not bound to @code{delete-char}, then
! return @sc{eof}.
  
  @item backward-delete-char (Rubout)
***************
*** 954,967 ****
  deleted.  By default, this is not bound to a key.
  
! @item quoted-insert (C-q, C-v)
  Add the next character typed to the line verbatim.  This is
! how to insert key sequences like @key{C-q}, for example.
  
  @ifclear BashFeatures
! @item tab-insert (M-TAB)
  Insert a tab character.
  @end ifclear
  
! @item self-insert (a, b, A, 1, !, ...)
  Insert yourself.
  
--- 999,1012 ----
  deleted.  By default, this is not bound to a key.
  
! @item quoted-insert (C-q or C-v)
  Add the next character typed to the line verbatim.  This is
! how to insert key sequences like @kbd{C-q}, for example.
  
  @ifclear BashFeatures
! @item tab-insert (M-@key{TAB})
  Insert a tab character.
  @end ifclear
  
! @item self-insert (a, b, A, 1, !, @dots{})
  Insert yourself.
  
***************
*** 1007,1011 ****
  
  @item kill-whole-line ()
! Kill all characters on the current line, no matter point is.
  By default, this is unbound.
  
--- 1052,1056 ----
  
  @item kill-whole-line ()
! Kill all characters on the current line, no matter where point is.
  By default, this is unbound.
  
***************
*** 1015,1019 ****
  Word boundaries are the same as @code{forward-word}.
  
! @item backward-kill-word (M-DEL)
  Kill the word behind point.
  Word boundaries are the same as @code{backward-word}.
--- 1060,1064 ----
  Word boundaries are the same as @code{forward-word}.
  
! @item backward-kill-word (M-@key{DEL})
  Kill the word behind point.
  Word boundaries are the same as @code{backward-word}.
***************
*** 1045,1054 ****
  
  @item yank (C-y)
! Yank the top of the kill ring into the buffer at the current
! cursor position.
  
  @item yank-pop (M-y)
  Rotate the kill-ring, and yank the new top.  You can only do this if
! the prior command is yank or yank-pop.
  @end ftable
  
--- 1090,1098 ----
  
  @item yank (C-y)
! Yank the top of the kill ring into the buffer at point.
  
  @item yank-pop (M-y)
  Rotate the kill-ring, and yank the new top.  You can only do this if
! the prior command is @code{yank} or @code{yank-pop}.
  @end ftable
  
***************
*** 1057,1063 ****
  @ftable @code
  
! @item digit-argument (M-0, M-1, ... M--)
  Add this digit to the argument already accumulating, or start a new
! argument.  @key{M--} starts a negative argument.
  
  @item universal-argument ()
--- 1101,1107 ----
  @ftable @code
  
! @item digit-argument (@kbd{M-0}, @kbd{M-1}, @dots{} @kbd{M--})
  Add this digit to the argument already accumulating, or start a new
! argument.  @kbd{M--} starts a negative argument.
  
  @item universal-argument ()
***************
*** 1080,1090 ****
  
  @ftable @code
! @item complete (TAB)
! Attempt to do completion on the text before the cursor.  This is
! application-specific.  Generally, if you are typing a filename
! argument, you can do filename completion; if you are typing a command,
! you can do command completion; if you are typing in a symbol to GDB, you
! can do symbol name completion; if you are typing in a variable to Bash,
! you can do variable name completion, and so on.
  @ifset BashFeatures
  Bash attempts completion treating the text as a variable (if the
--- 1124,1130 ----
  
  @ftable @code
! @item complete (@key{TAB})
! Attempt to perform completion on the text before point.
! The actual completion performed is application-specific.
  @ifset BashFeatures
  Bash attempts completion treating the text as a variable (if the
***************
*** 1094,1100 ****
  of these produces a match, filename completion is attempted.
  @end ifset
  
  @item possible-completions (M-?)
! List the possible completions of the text before the cursor.
  
  @item insert-completions (M-*)
--- 1134,1143 ----
  of these produces a match, filename completion is attempted.
  @end ifset
+ @ifclear BashFeatures
+ The default is filename completion.
+ @end ifclear
  
  @item possible-completions (M-?)
! List the possible completions of the text before point.
  
  @item insert-completions (M-*)
***************
*** 1107,1116 ****
  Repeated execution of @code{menu-complete} steps through the list
  of possible completions, inserting each match in turn.
! At the end of the list of completions, the bell is rung and the
! original text is restored.
  An argument of @var{n} moves @var{n} positions forward in the list
  of matches; a negative argument may be used to move backward
  through the list.
! This command is intended to be bound to @code{TAB}, but is unbound
  by default.
  
--- 1150,1160 ----
  Repeated execution of @code{menu-complete} steps through the list
  of possible completions, inserting each match in turn.
! At the end of the list of completions, the bell is rung
! (subject to the setting of @code{bell-style})
! and the original text is restored.
  An argument of @var{n} moves @var{n} positions forward in the list
  of matches; a negative argument may be used to move backward
  through the list.
! This command is intended to be bound to @key{TAB}, but is unbound
  by default.
  
***************
*** 1165,1169 ****
  treating it as a command name.
  
! @item dynamic-complete-history (M-TAB)
  Attempt completion on the text before point, comparing
  the text against lines from the history list for possible
--- 1209,1213 ----
  treating it as a command name.
  
! @item dynamic-complete-history (M-@key{TAB})
  Attempt completion on the text before point, comparing
  the text against lines from the history list for possible
***************
*** 1212,1221 ****
  that is bound to the corresponding uppercase character.
  
! @item prefix-meta (ESC)
! Make the next character typed be metafied.  This is for keyboards
! without a meta key.  Typing @samp{ESC f} is equivalent to typing
! @samp{M-f}.
  
! @item undo (C-_, C-x C-u)
  Incremental undo, separately remembered for each line.
  
--- 1256,1265 ----
  that is bound to the corresponding uppercase character.
  
! @item prefix-meta (@key{ESC})
! Metafy the next character typed.  This is for keyboards
! without a meta key.  Typing @samp{@key{ESC} f} is equivalent to typing
! @kbd{M-f}.
  
! @item undo (C-_ or C-x C-u)
  Incremental undo, separately remembered for each line.
  
***************
*** 1233,1237 ****
  
  @item set-mark (C-@@)
! Set the mark to the current point.  If a
  numeric argument is supplied, the mark is set to that position.
  
--- 1277,1281 ----
  
  @item set-mark (C-@@)
! Set the mark to the point.  If a
  numeric argument is supplied, the mark is set to that position.
  
***************
*** 1272,1276 ****
  @item dump-macros ()
  Print all of the Readline key sequences bound to macros and the
! strings they ouput.  If a numeric argument is supplied,
  the output is formatted in such a way that it can be made part
  of an @var{inputrc} file.  This command is unbound by default.
--- 1316,1320 ----
  @item dump-macros ()
  Print all of the Readline key sequences bound to macros and the
! strings they output.  If a numeric argument is supplied,
  the output is formatted in such a way that it can be made part
  of an @var{inputrc} file.  This command is unbound by default.
***************
*** 1306,1310 ****
  Perform history and alias expansion on the current line.
  
! @item insert-last-argument (M-., M-_)
  A synonym for @code{yank-last-arg}.
  
--- 1350,1354 ----
  Perform history and alias expansion on the current line.
  
! @item insert-last-argument (M-. or M-_)
  A synonym for @code{yank-last-arg}.
  
***************
*** 1329,1333 ****
  editing functions, it does contain enough to allow simple editing
  of the line.  The Readline @code{vi} mode behaves as specified in
! the @sc{POSIX} 1003.2 standard.
  
  @ifset BashFeatures
--- 1373,1377 ----
  editing functions, it does contain enough to allow simple editing
  of the line.  The Readline @code{vi} mode behaves as specified in
! the @sc{posix} 1003.2 standard.
  
  @ifset BashFeatures
***************
*** 1338,1342 ****
  @ifclear BashFeatures
  In order to switch interactively between @code{emacs} and @code{vi}
! editing modes, use the command M-C-j (toggle-editing-mode).
  @end ifclear
  The Readline default is @code{emacs} mode.
--- 1382,1387 ----
  @ifclear BashFeatures
  In order to switch interactively between @code{emacs} and @code{vi}
! editing modes, use the command @kbd{M-C-j} (bound to emacs-editing-mode
! when in @code{vi} mode and to vi-editing-mode in @code{emacs} mode).
  @end ifclear
  The Readline default is @code{emacs} mode.
***************
*** 1375,1392 ****
  Only matches which are prefixed by the word being completed are
  returned.
! When the @samp{-f} or @samp{-d} option is used for filename or
! directory name completion, the shell variable @code{FIGNORE} is
  used to filter the matches.
! @xref{Bash Variables}, for a description of @code{FIGNORE}.
  
  Any completions specified by a filename expansion pattern to the
! @samp{-G} option are generated next.
  The words generated by the pattern need not match the word being completed.
! The @code{GLOBIGNORE} shell variable is not used to filter the matches,
! but the @code{FIGNORE} shell variable is used.
  
! Next, the string specified as the argument to the @samp{-W} option
  is considered.
! The string is first split using the characters in the @code{IFS}
  special variable as delimiters.
  Shell quoting is honored.
--- 1420,1437 ----
  Only matches which are prefixed by the word being completed are
  returned.
! When the @option{-f} or @option{-d} option is used for filename or
! directory name completion, the shell variable @env{FIGNORE} is
  used to filter the matches.
! @xref{Bash Variables}, for a description of @env{FIGNORE}.
  
  Any completions specified by a filename expansion pattern to the
! @option{-G} option are generated next.
  The words generated by the pattern need not match the word being completed.
! The @env{GLOBIGNORE} shell variable is not used to filter the matches,
! but the @env{FIGNORE} shell variable is used.
  
! Next, the string specified as the argument to the @option{-W} option
  is considered.
! The string is first split using the characters in the @env{IFS}
  special variable as delimiters.
  Shell quoting is honored.
***************
*** 1401,1410 ****
  
  After these matches have been generated, any shell function or command
! specified with the @samp{-F} and @samp{-C} options is invoked.
! When the command or function is invoked, the @code{COMP_LINE} and
! @code{COMP_POINT} variables are assigned values as described above
  (@pxref{Bash Variables}).
! If a shell function is being invoked, the @code{COMP_WORDS} and
! @code{COMP_CWORD} variables are also set.
  When the function or command is invoked, the first argument is the
  name of the command whose arguments are being completed, the
--- 1446,1455 ----
  
  After these matches have been generated, any shell function or command
! specified with the @option{-F} and @option{-C} options is invoked.
! When the command or function is invoked, the @env{COMP_LINE} and
! @env{COMP_POINT} variables are assigned values as described above
  (@pxref{Bash Variables}).
! If a shell function is being invoked, the @env{COMP_WORDS} and
! @env{COMP_CWORD} variables are also set.
  When the function or command is invoked, the first argument is the
  name of the command whose arguments are being completed, the
***************
*** 1415,1426 ****
  the matches.
  
! Any function specified with @samp{-F} is invoked first.
  The function may use any of the shell facilities, including the
  @code{compgen} builtin described below
  (@pxref{Programmable Completion Builtins}), to generate the matches.
! It must put the possible completions in the @code{COMPREPLY} array
  variable.
  
! Next, any command specified with the @samp{-C} option is invoked
  in an environment equivalent to command substitution.
  It should print a list of completions, one per line, to
--- 1460,1471 ----
  the matches.
  
! Any function specified with @option{-F} is invoked first.
  The function may use any of the shell facilities, including the
  @code{compgen} builtin described below
  (@pxref{Programmable Completion Builtins}), to generate the matches.
! It must put the possible completions in the @env{COMPREPLY} array
  variable.
  
! Next, any command specified with the @option{-C} option is invoked
  in an environment equivalent to command substitution.
  It should print a list of completions, one per line, to
***************
*** 1429,1433 ****
  
  After all of the possible completions are generated, any filter
! specified with the @samp{-X} option is applied to the list.
  The filter is a pattern as used for pathname expansion; a @samp{&}
  in the pattern is replaced with the text of the word being completed.
--- 1474,1478 ----
  
  After all of the possible completions are generated, any filter
! specified with the @option{-X} option is applied to the list.
  The filter is a pattern as used for pathname expansion; a @samp{&}
  in the pattern is replaced with the text of the word being completed.
***************
*** 1438,1450 ****
  not matching the pattern will be removed.
  
! Finally, any prefix and suffix specified with the @samp{-P} and @samp{-S}
  options are added to each member of the completion list, and the result is
  returned to the Readline completion code as the list of possible
  completions.
  
! If a compspec is found, whatever it generates is returned to the completion
! code as the full set of possible completions.
! The default Bash completions are not attempted, and the Readline
! default of filename completion is disabled.
  
  @node Programmable Completion Builtins
--- 1483,1502 ----
  not matching the pattern will be removed.
  
! Finally, any prefix and suffix specified with the @option{-P} and @option{-S}
  options are added to each member of the completion list, and the result is
  returned to the Readline completion code as the list of possible
  completions.
  
! If the previously-applied actions do not generate any matches, and the
! @option{-o dirnames} option was supplied to @code{complete} when the
! compspec was defined, directory name completion is attempted. 
! 
! By default, if a compspec is found, whatever it generates is returned to
! the completion code as the full set of possible completions.
! The default Bash completions are not attempted, and the Readline default
! of filename completion is disabled.
! If the @option{-o default} option was supplied to @code{complete} when the
! compspec was defined, Readline's default completion will be performed
! if the compspec generates no matches.
  
  @node Programmable Completion Builtins
***************
*** 1465,1471 ****
  the @var{option}s, which may be any option accepted by the
  @code{complete}
! builtin with the exception of @samp{-p} and @samp{-r}, and write
  the matches to the standard output.
! When using the @samp{-F} or @samp{-C} options, the various shell variables
  set by the programmable completion facilities, while available, will not
  have useful values.
--- 1517,1523 ----
  the @var{option}s, which may be any option accepted by the
  @code{complete}
! builtin with the exception of @option{-p} and @option{-r}, and write
  the matches to the standard output.
! When using the @option{-F} or @option{-C} options, the various shell variables
  set by the programmable completion facilities, while available, will not
  have useful values.
***************
*** 1483,1487 ****
  @btindex complete
  @example
! @code{complete [-abcdefjkvu] [-A @var{action}] [-G @var{globpat}] [-W @var{wordlist}]
  [-P @var{prefix}] [-S @var{suffix}] [-X @var{filterpat}] [-F @var{function}]
  [-C @var{command}] @var{name} [@var{name} @dots{}]}
--- 1535,1539 ----
  @btindex complete
  @example
! @code{complete [-abcdefjkvu] [-o @var{comp-option}] [-A @var{action}] [-G @var{globpat}] [-W @var{wordlist}]
  [-P @var{prefix}] [-S @var{suffix}] [-X @var{filterpat}] [-F @var{function}]
  [-C @var{command}] @var{name} [@var{name} @dots{}]}
***************
*** 1490,1497 ****
  
  Specify how arguments to each @var{name} should be completed.
! If the @samp{-p} option is supplied, or if no options are supplied, existing
  completion specifications are printed in a way that allows them to be
  reused as input.
! The @samp{-r} option removes a completion specification for
  each @var{name}, or, if no @var{name}s are supplied, all
  completion specifications.
--- 1542,1549 ----
  
  Specify how arguments to each @var{name} should be completed.
! If the @option{-p} option is supplied, or if no options are supplied, existing
  completion specifications are printed in a way that allows them to be
  reused as input.
! The @option{-r} option removes a completion specification for
  each @var{name}, or, if no @var{name}s are supplied, all
  completion specifications.
***************
*** 1501,1510 ****
  
  Other options, if specified, have the following meanings.
! The arguments to the @samp{-G}, @samp{-W}, and @samp{-X} options
! (and, if necessary, the @samp{-P} and @samp{-S} options)
  should be quoted to protect them from expansion before the
  @code{complete} builtin is invoked.
  
  @table @code
  @item -A @var{action}
  The @var{action} may be one of the following to generate a list of possible
--- 1553,1583 ----
  
  Other options, if specified, have the following meanings.
! The arguments to the @option{-G}, @option{-W}, and @option{-X} options
! (and, if necessary, the @option{-P} and @option{-S} options)
  should be quoted to protect them from expansion before the
  @code{complete} builtin is invoked.
  
+ 
+ @table @code
+ @item -o @var{comp-option}
+ The @var{comp-option} controls several aspects of the compspec's behavior
+ beyond the simple generation of completions.
+ @var{comp-option} may be one of: 
+ 
  @table @code
+ 
+ @item default
+ Use readline's default completion if the compspec generates no matches.
+ 
+ @item dirnames
+ Perform directory name completion if the compspec generates no matches.
+ 
+ @item filenames
+ Tell Readline that the compspec generates filenames, so it can perform any
+ filename\-specific processing (like adding a slash to directory names or
+ suppressing trailing spaces).  This option is intended to be used with
+ shell functions specified with @option{-F}.
+ @end table
+ 
  @item -A @var{action}
  The @var{action} may be one of the following to generate a list of possible
***************
*** 1513,1517 ****
  @table @code
  @item alias
! Alias names.  May also be specified as @samp{-a}.
  
  @item arrayvar
--- 1586,1590 ----
  @table @code
  @item alias
! Alias names.  May also be specified as @option{-a}.
  
  @item arrayvar
***************
*** 1522,1532 ****
  
  @item builtin
! Names of shell builtin commands.  May also be specified as @samp{-b}.
  
  @item command
! Command names.  May also be specified as @samp{-c}.
  
  @item directory
! Directory names.  May also be specified as @samp{-d}.
  
  @item disabled
--- 1595,1605 ----
  
  @item builtin
! Names of shell builtin commands.  May also be specified as @option{-b}.
  
  @item command
! Command names.  May also be specified as @option{-c}.
  
  @item directory
! Directory names.  May also be specified as @option{-d}.
  
  @item disabled
***************
*** 1537,1544 ****
  
  @item export
! Names of exported shell variables.  May also be specified as @samp{-e}.
  
  @item file
! File names.  May also be specified as @samp{-f}.
  
  @item function
--- 1610,1617 ----
  
  @item export
! Names of exported shell variables.  May also be specified as @option{-e}.
  
  @item file
! File names.  May also be specified as @option{-f}.
  
  @item function
***************
*** 1550,1560 ****
  @item hostname
  Hostnames, as taken from the file specified by the
! @code{HOSTFILE} shell variable (@pxref{Bash Variables}).
  
  @item job
! Job names, if job control is active.  May also be specified as @samp{-j}.
  
  @item keyword
! Shell reserved words.  May also be specified as @samp{-k}.
  
  @item running
--- 1623,1633 ----
  @item hostname
  Hostnames, as taken from the file specified by the
! @env{HOSTFILE} shell variable (@pxref{Bash Variables}).
  
  @item job
! Job names, if job control is active.  May also be specified as @option{-j}.
  
  @item keyword
! Shell reserved words.  May also be specified as @option{-k}.
  
  @item running
***************
*** 1562,1566 ****
  
  @item setopt
! Valid arguments for the @samp{-o} option to the @code{set} builtin
  (@pxref{The Set Builtin}).
  
--- 1635,1639 ----
  
  @item setopt
! Valid arguments for the @option{-o} option to the @code{set} builtin
  (@pxref{The Set Builtin}).
  
***************
*** 1576,1583 ****
  
  @item user
! User names.  May also be specified as @samp{-u}.
  
  @item variable
! Names of all shell variables.  May also be specified as @samp{-v}.
  @end table
  
--- 1649,1656 ----
  
  @item user
! User names.  May also be specified as @option{-u}.
  
  @item variable
! Names of all shell variables.  May also be specified as @option{-v}.
  @end table
  
***************
*** 1588,1592 ****
  @item -W @var{wordlist}
  The @var{wordlist} is split using the characters in the
! @code{IFS} special variable as delimiters, and each resultant word
  is expanded.
  The possible completions are the members of the resultant list which
--- 1661,1665 ----
  @item -W @var{wordlist}
  The @var{wordlist} is split using the characters in the
! @env{IFS} special variable as delimiters, and each resultant word
  is expanded.
  The possible completions are the members of the resultant list which
***************
*** 1601,1605 ****
  environment.
  When it finishes, the possible completions are retrieved from the value
! of the @code{COMPREPLY} array variable.
  
  @item -X @var{filterpat}
--- 1674,1678 ----
  environment.
  When it finishes, the possible completions are retrieved from the value
! of the @env{COMPREPLY} array variable.
  
  @item -X @var{filterpat}
***************
*** 1621,1625 ****
  
  The return value is true unless an invalid option is supplied, an option
! other than @samp{-p} or @samp{-r} is supplied without a @var{name}
  argument, an attempt is made to remove a completion specification for
  a @var{name} for which no specification exists, or
--- 1694,1698 ----
  
  The return value is true unless an invalid option is supplied, an option
! other than @option{-p} or @option{-r} is supplied without a @var{name}
  argument, an attempt is made to remove a completion specification for
  a @var{name} for which no specification exists, or
diff -Nrc2 bash-2.04/lib/readline/doc/rluserman.texinfo bash-2.05/lib/readline/doc/rluserman.texinfo
*** bash-2.04/lib/readline/doc/rluserman.texinfo	Thu Aug  5 08:25:28 1999
--- bash-2.05/lib/readline/doc/rluserman.texinfo	Fri Feb  2 11:59:01 2001
***************
*** 11,15 ****
  @dircategory Libraries
  @direntry
! * Readline: (readline).       The GNU readline library API
  @end direntry
  
--- 11,15 ----
  @dircategory Libraries
  @direntry
! * RLuserman: (rluserman).       The GNU readline library User's Manual.
  @end direntry
  
***************
*** 18,22 ****
  programs that need to provide a command line interface.
  
! Copyright (C) 1988-1999 Free Software Foundation, Inc.
  
  Permission is granted to make and distribute verbatim copies of
--- 18,22 ----
  programs that need to provide a command line interface.
  
! Copyright (C) 1988-2001 Free Software Foundation, Inc.
  
  Permission is granted to make and distribute verbatim copies of
***************
*** 73,77 ****
  
  @vskip 0pt plus 1filll
! Copyright @copyright{} 1988-1999 Free Software Foundation, Inc.
  @end titlepage
  
--- 73,77 ----
  
  @vskip 0pt plus 1filll
! Copyright @copyright{} 1988-2001 Free Software Foundation, Inc.
  @end titlepage
  
diff -Nrc2 bash-2.04/lib/readline/emacs_keymap.c bash-2.05/lib/readline/emacs_keymap.c
*** bash-2.04/lib/readline/emacs_keymap.c	Thu Aug  5 08:03:00 1999
--- bash-2.05/lib/readline/emacs_keymap.c	Mon Oct 30 12:01:50 2000
***************
*** 34,179 ****
  
    /* Control keys. */
!   { ISFUNC, rl_set_mark },		/* Control-@ */
!   { ISFUNC, rl_beg_of_line },		/* Control-a */
!   { ISFUNC, rl_backward },		/* Control-b */
!   { ISFUNC, (Function *)0x0 },		/* Control-c */
!   { ISFUNC, rl_delete },		/* Control-d */
!   { ISFUNC, rl_end_of_line },		/* Control-e */
!   { ISFUNC, rl_forward },		/* Control-f */
!   { ISFUNC, rl_abort },			/* Control-g */
!   { ISFUNC, rl_rubout },		/* Control-h */
!   { ISFUNC, rl_complete },		/* Control-i */
!   { ISFUNC, rl_newline },		/* Control-j */
!   { ISFUNC, rl_kill_line },		/* Control-k */
!   { ISFUNC, rl_clear_screen },		/* Control-l */
!   { ISFUNC, rl_newline },		/* Control-m */
!   { ISFUNC, rl_get_next_history },	/* Control-n */
!   { ISFUNC, (Function *)0x0 },		/* Control-o */
!   { ISFUNC, rl_get_previous_history },	/* Control-p */
!   { ISFUNC, rl_quoted_insert },		/* Control-q */
!   { ISFUNC, rl_reverse_search_history }, /* Control-r */
!   { ISFUNC, rl_forward_search_history }, /* Control-s */
!   { ISFUNC, rl_transpose_chars },	/* Control-t */
!   { ISFUNC, rl_unix_line_discard },	/* Control-u */
!   { ISFUNC, rl_quoted_insert },		/* Control-v */
!   { ISFUNC, rl_unix_word_rubout },	/* Control-w */
!   { ISKMAP, (Function *)emacs_ctlx_keymap },	/* Control-x */
!   { ISFUNC, rl_yank },			/* Control-y */
!   { ISFUNC, (Function *)0x0 },		/* Control-z */
!   { ISKMAP, (Function *)emacs_meta_keymap }, /* Control-[ */
!   { ISFUNC, (Function *)0x0 },		/* Control-\ */
!   { ISFUNC, rl_char_search },		/* Control-] */
!   { ISFUNC, (Function *)0x0 },		/* Control-^ */
!   { ISFUNC, rl_undo_command },		/* Control-_ */
  
    /* The start of printing characters. */
!   { ISFUNC, rl_insert },	/* SPACE */
!   { ISFUNC, rl_insert },	/* ! */
!   { ISFUNC, rl_insert },	/* " */
!   { ISFUNC, rl_insert },	/* # */
!   { ISFUNC, rl_insert },	/* $ */
!   { ISFUNC, rl_insert },	/* % */
!   { ISFUNC, rl_insert },	/* & */
!   { ISFUNC, rl_insert },	/* ' */
!   { ISFUNC, rl_insert },	/* ( */
!   { ISFUNC, rl_insert },	/* ) */
!   { ISFUNC, rl_insert },	/* * */
!   { ISFUNC, rl_insert },	/* + */
!   { ISFUNC, rl_insert },	/* , */
!   { ISFUNC, rl_insert },	/* - */
!   { ISFUNC, rl_insert },	/* . */
!   { ISFUNC, rl_insert },	/* / */
! 
!   /* Regular digits. */
!   { ISFUNC, rl_insert },	/* 0 */
!   { ISFUNC, rl_insert },	/* 1 */
!   { ISFUNC, rl_insert },	/* 2 */
!   { ISFUNC, rl_insert },	/* 3 */
!   { ISFUNC, rl_insert },	/* 4 */
!   { ISFUNC, rl_insert },	/* 5 */
!   { ISFUNC, rl_insert },	/* 6 */
!   { ISFUNC, rl_insert },	/* 7 */
!   { ISFUNC, rl_insert },	/* 8 */
!   { ISFUNC, rl_insert },	/* 9 */
  
    /* A little more punctuation. */
!   { ISFUNC, rl_insert },	/* : */
!   { ISFUNC, rl_insert },	/* ; */
!   { ISFUNC, rl_insert },	/* < */
!   { ISFUNC, rl_insert },	/* = */
!   { ISFUNC, rl_insert },	/* > */
!   { ISFUNC, rl_insert },	/* ? */
!   { ISFUNC, rl_insert },	/* @ */
  
    /* Uppercase alphabet. */
!   { ISFUNC, rl_insert },	/* A */
!   { ISFUNC, rl_insert },	/* B */
!   { ISFUNC, rl_insert },	/* C */
!   { ISFUNC, rl_insert },	/* D */
!   { ISFUNC, rl_insert },	/* E */
!   { ISFUNC, rl_insert },	/* F */
!   { ISFUNC, rl_insert },	/* G */
!   { ISFUNC, rl_insert },	/* H */
!   { ISFUNC, rl_insert },	/* I */
!   { ISFUNC, rl_insert },	/* J */
!   { ISFUNC, rl_insert },	/* K */
!   { ISFUNC, rl_insert },	/* L */
!   { ISFUNC, rl_insert },	/* M */
!   { ISFUNC, rl_insert },	/* N */
!   { ISFUNC, rl_insert },	/* O */
!   { ISFUNC, rl_insert },	/* P */
!   { ISFUNC, rl_insert },	/* Q */
!   { ISFUNC, rl_insert },	/* R */
!   { ISFUNC, rl_insert },	/* S */
!   { ISFUNC, rl_insert },	/* T */
!   { ISFUNC, rl_insert },	/* U */
!   { ISFUNC, rl_insert },	/* V */
!   { ISFUNC, rl_insert },	/* W */
!   { ISFUNC, rl_insert },	/* X */
!   { ISFUNC, rl_insert },	/* Y */
!   { ISFUNC, rl_insert },	/* Z */
  
    /* Some more punctuation. */
!   { ISFUNC, rl_insert },	/* [ */
!   { ISFUNC, rl_insert },	/* \ */
!   { ISFUNC, rl_insert },	/* ] */
!   { ISFUNC, rl_insert },	/* ^ */
!   { ISFUNC, rl_insert },	/* _ */
!   { ISFUNC, rl_insert },	/* ` */
  
    /* Lowercase alphabet. */
!   { ISFUNC, rl_insert },	/* a */
!   { ISFUNC, rl_insert },	/* b */
!   { ISFUNC, rl_insert },	/* c */
!   { ISFUNC, rl_insert },	/* d */
!   { ISFUNC, rl_insert },	/* e */
!   { ISFUNC, rl_insert },	/* f */
!   { ISFUNC, rl_insert },	/* g */
!   { ISFUNC, rl_insert },	/* h */
!   { ISFUNC, rl_insert },	/* i */
!   { ISFUNC, rl_insert },	/* j */
!   { ISFUNC, rl_insert },	/* k */
!   { ISFUNC, rl_insert },	/* l */
!   { ISFUNC, rl_insert },	/* m */
!   { ISFUNC, rl_insert },	/* n */
!   { ISFUNC, rl_insert },	/* o */
!   { ISFUNC, rl_insert },	/* p */
!   { ISFUNC, rl_insert },	/* q */
!   { ISFUNC, rl_insert },	/* r */
!   { ISFUNC, rl_insert },	/* s */
!   { ISFUNC, rl_insert },	/* t */
!   { ISFUNC, rl_insert },	/* u */
!   { ISFUNC, rl_insert },	/* v */
!   { ISFUNC, rl_insert },	/* w */
!   { ISFUNC, rl_insert },	/* x */
!   { ISFUNC, rl_insert },	/* y */
!   { ISFUNC, rl_insert },	/* z */
  
    /* Final punctuation. */
!   { ISFUNC, rl_insert },	/* { */
!   { ISFUNC, rl_insert },	/* | */
!   { ISFUNC, rl_insert },	/* } */
!   { ISFUNC, rl_insert },	/* ~ */
!   { ISFUNC, rl_rubout },	/* RUBOUT */
  
  #if KEYMAP_SIZE > 128
--- 34,179 ----
  
    /* Control keys. */
!   { ISFUNC, rl_set_mark },			/* Control-@ */
!   { ISFUNC, rl_beg_of_line },			/* Control-a */
!   { ISFUNC, rl_backward },			/* Control-b */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-c */
!   { ISFUNC, rl_delete },			/* Control-d */
!   { ISFUNC, rl_end_of_line },			/* Control-e */
!   { ISFUNC, rl_forward },			/* Control-f */
!   { ISFUNC, rl_abort },				/* Control-g */
!   { ISFUNC, rl_rubout },			/* Control-h */
!   { ISFUNC, rl_complete },			/* Control-i */
!   { ISFUNC, rl_newline },			/* Control-j */
!   { ISFUNC, rl_kill_line },			/* Control-k */
!   { ISFUNC, rl_clear_screen },			/* Control-l */
!   { ISFUNC, rl_newline },			/* Control-m */
!   { ISFUNC, rl_get_next_history },		/* Control-n */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-o */
!   { ISFUNC, rl_get_previous_history },		/* Control-p */
!   { ISFUNC, rl_quoted_insert },			/* Control-q */
!   { ISFUNC, rl_reverse_search_history },	/* Control-r */
!   { ISFUNC, rl_forward_search_history },	/* Control-s */
!   { ISFUNC, rl_transpose_chars },		/* Control-t */
!   { ISFUNC, rl_unix_line_discard },		/* Control-u */
!   { ISFUNC, rl_quoted_insert },			/* Control-v */
!   { ISFUNC, rl_unix_word_rubout },		/* Control-w */
!   { ISKMAP, (rl_command_func_t *)emacs_ctlx_keymap },	/* Control-x */
!   { ISFUNC, rl_yank },				/* Control-y */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-z */
!   { ISKMAP, (rl_command_func_t *)emacs_meta_keymap }, /* Control-[ */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-\ */
!   { ISFUNC, rl_char_search },			/* Control-] */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-^ */
!   { ISFUNC, rl_undo_command },			/* Control-_ */
  
    /* The start of printing characters. */
!   { ISFUNC, rl_insert },		/* SPACE */
!   { ISFUNC, rl_insert },		/* ! */
!   { ISFUNC, rl_insert },		/* " */
!   { ISFUNC, rl_insert },		/* # */
!   { ISFUNC, rl_insert },		/* $ */
!   { ISFUNC, rl_insert },		/* % */
!   { ISFUNC, rl_insert },		/* & */
!   { ISFUNC, rl_insert },		/* ' */
!   { ISFUNC, rl_insert },		/* ( */
!   { ISFUNC, rl_insert },		/* ) */
!   { ISFUNC, rl_insert },		/* * */
!   { ISFUNC, rl_insert },		/* + */
!   { ISFUNC, rl_insert },		/* , */
!   { ISFUNC, rl_insert },		/* - */
!   { ISFUNC, rl_insert },		/* . */
!   { ISFUNC, rl_insert },		/* / */
! 	
! 	  /* Regular digits. */
!   { ISFUNC, rl_insert },		/* 0 */
!   { ISFUNC, rl_insert },		/* 1 */
!   { ISFUNC, rl_insert },		/* 2 */
!   { ISFUNC, rl_insert },		/* 3 */
!   { ISFUNC, rl_insert },		/* 4 */
!   { ISFUNC, rl_insert },		/* 5 */
!   { ISFUNC, rl_insert },		/* 6 */
!   { ISFUNC, rl_insert },		/* 7 */
!   { ISFUNC, rl_insert },		/* 8 */
!   { ISFUNC, rl_insert },		/* 9 */
  
    /* A little more punctuation. */
!   { ISFUNC, rl_insert },		/* : */
!   { ISFUNC, rl_insert },		/* ; */
!   { ISFUNC, rl_insert },		/* < */
!   { ISFUNC, rl_insert },		/* = */
!   { ISFUNC, rl_insert },		/* > */
!   { ISFUNC, rl_insert },		/* ? */
!   { ISFUNC, rl_insert },		/* @ */
  
    /* Uppercase alphabet. */
!   { ISFUNC, rl_insert },		/* A */
!   { ISFUNC, rl_insert },		/* B */
!   { ISFUNC, rl_insert },		/* C */
!   { ISFUNC, rl_insert },		/* D */
!   { ISFUNC, rl_insert },		/* E */
!   { ISFUNC, rl_insert },		/* F */
!   { ISFUNC, rl_insert },		/* G */
!   { ISFUNC, rl_insert },		/* H */
!   { ISFUNC, rl_insert },		/* I */
!   { ISFUNC, rl_insert },		/* J */
!   { ISFUNC, rl_insert },		/* K */
!   { ISFUNC, rl_insert },		/* L */
!   { ISFUNC, rl_insert },		/* M */
!   { ISFUNC, rl_insert },		/* N */
!   { ISFUNC, rl_insert },		/* O */
!   { ISFUNC, rl_insert },		/* P */
!   { ISFUNC, rl_insert },		/* Q */
!   { ISFUNC, rl_insert },		/* R */
!   { ISFUNC, rl_insert },		/* S */
!   { ISFUNC, rl_insert },		/* T */
!   { ISFUNC, rl_insert },		/* U */
!   { ISFUNC, rl_insert },		/* V */
!   { ISFUNC, rl_insert },		/* W */
!   { ISFUNC, rl_insert },		/* X */
!   { ISFUNC, rl_insert },		/* Y */
!   { ISFUNC, rl_insert },		/* Z */
  
    /* Some more punctuation. */
!   { ISFUNC, rl_insert },		/* [ */
!   { ISFUNC, rl_insert },		/* \ */
!   { ISFUNC, rl_insert },		/* ] */
!   { ISFUNC, rl_insert },		/* ^ */
!   { ISFUNC, rl_insert },		/* _ */
!   { ISFUNC, rl_insert },		/* ` */
  
    /* Lowercase alphabet. */
!   { ISFUNC, rl_insert },		/* a */
!   { ISFUNC, rl_insert },		/* b */
!   { ISFUNC, rl_insert },		/* c */
!   { ISFUNC, rl_insert },		/* d */
!   { ISFUNC, rl_insert },		/* e */
!   { ISFUNC, rl_insert },		/* f */
!   { ISFUNC, rl_insert },		/* g */
!   { ISFUNC, rl_insert },		/* h */
!   { ISFUNC, rl_insert },		/* i */
!   { ISFUNC, rl_insert },		/* j */
!   { ISFUNC, rl_insert },		/* k */
!   { ISFUNC, rl_insert },		/* l */
!   { ISFUNC, rl_insert },		/* m */
!   { ISFUNC, rl_insert },		/* n */
!   { ISFUNC, rl_insert },		/* o */
!   { ISFUNC, rl_insert },		/* p */
!   { ISFUNC, rl_insert },		/* q */
!   { ISFUNC, rl_insert },		/* r */
!   { ISFUNC, rl_insert },		/* s */
!   { ISFUNC, rl_insert },		/* t */
!   { ISFUNC, rl_insert },		/* u */
!   { ISFUNC, rl_insert },		/* v */
!   { ISFUNC, rl_insert },		/* w */
!   { ISFUNC, rl_insert },		/* x */
!   { ISFUNC, rl_insert },		/* y */
!   { ISFUNC, rl_insert },		/* z */
  
    /* Final punctuation. */
!   { ISFUNC, rl_insert },		/* { */
!   { ISFUNC, rl_insert },		/* | */
!   { ISFUNC, rl_insert },		/* } */
!   { ISFUNC, rl_insert },		/* ~ */
!   { ISFUNC, rl_rubout },		/* RUBOUT */
  
  #if KEYMAP_SIZE > 128
***************
*** 181,216 ****
       These might be used in some
       character sets. */
!   { ISFUNC, rl_insert },	/* ? */
!   { ISFUNC, rl_insert },	/* ? */
!   { ISFUNC, rl_insert },	/* ? */
!   { ISFUNC, rl_insert },	/* ? */
!   { ISFUNC, rl_insert },	/* ? */
!   { ISFUNC, rl_insert },	/* ? */
!   { ISFUNC, rl_insert },	/* ? */
!   { ISFUNC, rl_insert },	/* ? */
!   { ISFUNC, rl_insert },	/* ? */
!   { ISFUNC, rl_insert },	/* ? */
!   { ISFUNC, rl_insert },	/* ? */
!   { ISFUNC, rl_insert },	/* ? */
!   { ISFUNC, rl_insert },	/* ? */
!   { ISFUNC, rl_insert },	/* ? */
!   { ISFUNC, rl_insert },	/* ? */
!   { ISFUNC, rl_insert },	/* ? */
!   { ISFUNC, rl_insert },	/* ? */
!   { ISFUNC, rl_insert },	/* ? */
!   { ISFUNC, rl_insert },	/* ? */
!   { ISFUNC, rl_insert },	/* ? */
!   { ISFUNC, rl_insert },	/* ? */
!   { ISFUNC, rl_insert },	/* ? */
!   { ISFUNC, rl_insert },	/* ? */
!   { ISFUNC, rl_insert },	/* ? */
!   { ISFUNC, rl_insert },	/* ? */
!   { ISFUNC, rl_insert },	/* ? */
!   { ISFUNC, rl_insert },	/* ? */
!   { ISFUNC, rl_insert },	/* ? */
!   { ISFUNC, rl_insert },	/* ? */
!   { ISFUNC, rl_insert },	/* ? */
!   { ISFUNC, rl_insert },	/* ? */
!   { ISFUNC, rl_insert },	/* ? */
  
    /* ISO Latin-1 characters (160 - 255) */
--- 181,216 ----
       These might be used in some
       character sets. */
!   { ISFUNC, rl_insert },		/* ? */
!   { ISFUNC, rl_insert },		/* ? */
!   { ISFUNC, rl_insert },		/* ? */
!   { ISFUNC, rl_insert },		/* ? */
!   { ISFUNC, rl_insert },		/* ? */
!   { ISFUNC, rl_insert },		/* ? */
!   { ISFUNC, rl_insert },		/* ? */
!   { ISFUNC, rl_insert },		/* ? */
!   { ISFUNC, rl_insert },		/* ? */
!   { ISFUNC, rl_insert },		/* ? */
!   { ISFUNC, rl_insert },		/* ? */
!   { ISFUNC, rl_insert },		/* ? */
!   { ISFUNC, rl_insert },		/* ? */
!   { ISFUNC, rl_insert },		/* ? */
!   { ISFUNC, rl_insert },		/* ? */
!   { ISFUNC, rl_insert },		/* ? */
!   { ISFUNC, rl_insert },		/* ? */
!   { ISFUNC, rl_insert },		/* ? */
!   { ISFUNC, rl_insert },		/* ? */
!   { ISFUNC, rl_insert },		/* ? */
!   { ISFUNC, rl_insert },		/* ? */
!   { ISFUNC, rl_insert },		/* ? */
!   { ISFUNC, rl_insert },		/* ? */
!   { ISFUNC, rl_insert },		/* ? */
!   { ISFUNC, rl_insert },		/* ? */
!   { ISFUNC, rl_insert },		/* ? */
!   { ISFUNC, rl_insert },		/* ? */
!   { ISFUNC, rl_insert },		/* ? */
!   { ISFUNC, rl_insert },		/* ? */
!   { ISFUNC, rl_insert },		/* ? */
!   { ISFUNC, rl_insert },		/* ? */
!   { ISFUNC, rl_insert },		/* ? */
  
    /* ISO Latin-1 characters (160 - 255) */
***************
*** 317,392 ****
  
    /* Meta keys.  Just like above, but the high bit is set. */
!   { ISFUNC, (Function *)0x0 },	/* Meta-Control-@ */
!   { ISFUNC, (Function *)0x0 },	/* Meta-Control-a */
!   { ISFUNC, (Function *)0x0 },	/* Meta-Control-b */
!   { ISFUNC, (Function *)0x0 },	/* Meta-Control-c */
!   { ISFUNC, (Function *)0x0 },	/* Meta-Control-d */
!   { ISFUNC, (Function *)0x0 },	/* Meta-Control-e */
!   { ISFUNC, (Function *)0x0 },	/* Meta-Control-f */
!   { ISFUNC, rl_abort },		/* Meta-Control-g */
    { ISFUNC, rl_backward_kill_word },	/* Meta-Control-h */
!   { ISFUNC, rl_tab_insert },	/* Meta-Control-i */
!   { ISFUNC, rl_vi_editing_mode }, /* Meta-Control-j */
!   { ISFUNC, (Function *)0x0 },	/* Meta-Control-k */
!   { ISFUNC, (Function *)0x0 },	/* Meta-Control-l */
!   { ISFUNC, rl_vi_editing_mode }, /* Meta-Control-m */
!   { ISFUNC, (Function *)0x0 },	/* Meta-Control-n */
!   { ISFUNC, (Function *)0x0 },	/* Meta-Control-o */
!   { ISFUNC, (Function *)0x0 },	/* Meta-Control-p */
!   { ISFUNC, (Function *)0x0 },	/* Meta-Control-q */
!   { ISFUNC, rl_revert_line },	/* Meta-Control-r */
!   { ISFUNC, (Function *)0x0 },	/* Meta-Control-s */
!   { ISFUNC, (Function *)0x0 },	/* Meta-Control-t */
!   { ISFUNC, (Function *)0x0 },	/* Meta-Control-u */
!   { ISFUNC, (Function *)0x0 },	/* Meta-Control-v */
!   { ISFUNC, (Function *)0x0 },	/* Meta-Control-w */
!   { ISFUNC, (Function *)0x0 },	/* Meta-Control-x */
!   { ISFUNC, rl_yank_nth_arg },	/* Meta-Control-y */
!   { ISFUNC, (Function *)0x0 },	/* Meta-Control-z */
  
!   { ISFUNC, rl_complete },	/* Meta-Control-[ */
!   { ISFUNC, (Function *)0x0 },	/* Meta-Control-\ */
    { ISFUNC, rl_backward_char_search },	/* Meta-Control-] */
!   { ISFUNC, (Function *)0x0 },	/* Meta-Control-^ */
!   { ISFUNC, (Function *)0x0 },	/* Meta-Control-_ */
  
    /* The start of printing characters. */
!   { ISFUNC, rl_set_mark },	/* Meta-SPACE */
!   { ISFUNC, (Function *)0x0 },	/* Meta-! */
!   { ISFUNC, (Function *)0x0 },	/* Meta-" */
!   { ISFUNC, rl_insert_comment },/* Meta-# */
!   { ISFUNC, (Function *)0x0 },	/* Meta-$ */
!   { ISFUNC, (Function *)0x0 },	/* Meta-% */
!   { ISFUNC, rl_tilde_expand },	/* Meta-& */
!   { ISFUNC, (Function *)0x0 },	/* Meta-' */
!   { ISFUNC, (Function *)0x0 },	/* Meta-( */
!   { ISFUNC, (Function *)0x0 },	/* Meta-) */
    { ISFUNC, rl_insert_completions },	/* Meta-* */
!   { ISFUNC, (Function *)0x0 },	/* Meta-+ */
!   { ISFUNC, (Function *)0x0 },	/* Meta-, */
!   { ISFUNC, rl_digit_argument }, /* Meta-- */
!   { ISFUNC, rl_yank_last_arg},	/* Meta-. */
!   { ISFUNC, (Function *)0x0 },	/* Meta-/ */
  
    /* Regular digits. */
!   { ISFUNC, rl_digit_argument }, /* Meta-0 */
!   { ISFUNC, rl_digit_argument }, /* Meta-1 */
!   { ISFUNC, rl_digit_argument }, /* Meta-2 */
!   { ISFUNC, rl_digit_argument }, /* Meta-3 */
!   { ISFUNC, rl_digit_argument }, /* Meta-4 */
!   { ISFUNC, rl_digit_argument }, /* Meta-5 */
!   { ISFUNC, rl_digit_argument }, /* Meta-6 */
!   { ISFUNC, rl_digit_argument }, /* Meta-7 */
!   { ISFUNC, rl_digit_argument }, /* Meta-8 */
!   { ISFUNC, rl_digit_argument }, /* Meta-9 */
  
    /* A little more punctuation. */
!   { ISFUNC, (Function *)0x0 },		/* Meta-: */
!   { ISFUNC, (Function *)0x0 },		/* Meta-; */
    { ISFUNC, rl_beginning_of_history },	/* Meta-< */
    { ISFUNC, rl_possible_completions },	/* Meta-= */
    { ISFUNC, rl_end_of_history },	/* Meta-> */
    { ISFUNC, rl_possible_completions },	/* Meta-? */
!   { ISFUNC, (Function *)0x0 },		/* Meta-@ */
  
    /* Uppercase alphabet. */
--- 317,392 ----
  
    /* Meta keys.  Just like above, but the high bit is set. */
!   { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-Control-@ */
!   { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-Control-a */
!   { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-Control-b */
!   { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-Control-c */
!   { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-Control-d */
!   { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-Control-e */
!   { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-Control-f */
!   { ISFUNC, rl_abort },			/* Meta-Control-g */
    { ISFUNC, rl_backward_kill_word },	/* Meta-Control-h */
!   { ISFUNC, rl_tab_insert },		/* Meta-Control-i */
!   { ISFUNC, rl_vi_editing_mode },	/* Meta-Control-j */
!   { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-Control-k */
!   { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-Control-l */
!   { ISFUNC, rl_vi_editing_mode }, 	/* Meta-Control-m */
!   { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-Control-n */
!   { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-Control-o */
!   { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-Control-p */
!   { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-Control-q */
!   { ISFUNC, rl_revert_line },		/* Meta-Control-r */
!   { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-Control-s */
!   { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-Control-t */
!   { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-Control-u */
!   { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-Control-v */
!   { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-Control-w */
!   { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-Control-x */
!   { ISFUNC, rl_yank_nth_arg },		/* Meta-Control-y */
!   { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-Control-z */
  
!   { ISFUNC, rl_complete },		/* Meta-Control-[ */
!   { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-Control-\ */
    { ISFUNC, rl_backward_char_search },	/* Meta-Control-] */
!   { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-Control-^ */
!   { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-Control-_ */
  
    /* The start of printing characters. */
!   { ISFUNC, rl_set_mark },		/* Meta-SPACE */
!   { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-! */
!   { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-" */
!   { ISFUNC, rl_insert_comment },	/* Meta-# */
!   { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-$ */
!   { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-% */
!   { ISFUNC, rl_tilde_expand },		/* Meta-& */
!   { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-' */
!   { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-( */
!   { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-) */
    { ISFUNC, rl_insert_completions },	/* Meta-* */
!   { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-+ */
!   { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-, */
!   { ISFUNC, rl_digit_argument }, 	/* Meta-- */
!   { ISFUNC, rl_yank_last_arg},		/* Meta-. */
!   { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-/ */
  
    /* Regular digits. */
!   { ISFUNC, rl_digit_argument }, 	/* Meta-0 */
!   { ISFUNC, rl_digit_argument }, 	/* Meta-1 */
!   { ISFUNC, rl_digit_argument }, 	/* Meta-2 */
!   { ISFUNC, rl_digit_argument }, 	/* Meta-3 */
!   { ISFUNC, rl_digit_argument }, 	/* Meta-4 */
!   { ISFUNC, rl_digit_argument }, 	/* Meta-5 */
!   { ISFUNC, rl_digit_argument }, 	/* Meta-6 */
!   { ISFUNC, rl_digit_argument }, 	/* Meta-7 */
!   { ISFUNC, rl_digit_argument }, 	/* Meta-8 */
!   { ISFUNC, rl_digit_argument }, 	/* Meta-9 */
  
    /* A little more punctuation. */
!   { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-: */
!   { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-; */
    { ISFUNC, rl_beginning_of_history },	/* Meta-< */
    { ISFUNC, rl_possible_completions },	/* Meta-= */
    { ISFUNC, rl_end_of_history },	/* Meta-> */
    { ISFUNC, rl_possible_completions },	/* Meta-? */
!   { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-@ */
  
    /* Uppercase alphabet. */
***************
*** 419,594 ****
  
    /* Some more punctuation. */
!   { ISFUNC, (Function *)0x0 },		/* Meta-[ */	/* was rl_arrow_keys */
    { ISFUNC, rl_delete_horizontal_space },	/* Meta-\ */
!   { ISFUNC, (Function *)0x0 },		/* Meta-] */
!   { ISFUNC, (Function *)0x0 },		/* Meta-^ */
!   { ISFUNC, rl_yank_last_arg },		/* Meta-_ */
!   { ISFUNC, (Function *)0x0 },		/* Meta-` */
  
    /* Lowercase alphabet. */
!   { ISFUNC, (Function *)0x0 },	/* Meta-a */
!   { ISFUNC, rl_backward_word },	/* Meta-b */
!   { ISFUNC, rl_capitalize_word }, /* Meta-c */
!   { ISFUNC, rl_kill_word },	/* Meta-d */
!   { ISFUNC, (Function *)0x0 },	/* Meta-e */
!   { ISFUNC, rl_forward_word },	/* Meta-f */
!   { ISFUNC, (Function *)0x0 },	/* Meta-g */
!   { ISFUNC, (Function *)0x0 },	/* Meta-h */
!   { ISFUNC, (Function *)0x0 },	/* Meta-i */
!   { ISFUNC, (Function *)0x0 },	/* Meta-j */
!   { ISFUNC, (Function *)0x0 },	/* Meta-k */
!   { ISFUNC, rl_downcase_word },	/* Meta-l */
!   { ISFUNC, (Function *)0x0 },	/* Meta-m */
    { ISFUNC, rl_noninc_forward_search },	/* Meta-n */
!   { ISFUNC, (Function *)0x0 },	/* Meta-o */	/* was rl_arrow_keys */
    { ISFUNC, rl_noninc_reverse_search },	/* Meta-p */
!   { ISFUNC, (Function *)0x0 },	/* Meta-q */
!   { ISFUNC, rl_revert_line },	/* Meta-r */
!   { ISFUNC, (Function *)0x0 },	/* Meta-s */
!   { ISFUNC, rl_transpose_words }, /* Meta-t */
!   { ISFUNC, rl_upcase_word },	/* Meta-u */
!   { ISFUNC, (Function *)0x0 },	/* Meta-v */
!   { ISFUNC, (Function *)0x0 },	/* Meta-w */
!   { ISFUNC, (Function *)0x0 },	/* Meta-x */
!   { ISFUNC, rl_yank_pop },	/* Meta-y */
!   { ISFUNC, (Function *)0x0 },	/* Meta-z */
  
    /* Final punctuation. */
!   { ISFUNC, (Function *)0x0 },	/* Meta-{ */
!   { ISFUNC, (Function *)0x0 },	/* Meta-| */
!   { ISFUNC, (Function *)0x0 },	/* Meta-} */
!   { ISFUNC, rl_tilde_expand },	/* Meta-~ */
!   { ISFUNC, rl_backward_kill_word }, /* Meta-rubout */
  
  #if KEYMAP_SIZE > 128
    /* Undefined keys. */
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 }
  #endif /* KEYMAP_SIZE > 128 */
  };
--- 419,594 ----
  
    /* Some more punctuation. */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* Meta-[ */	/* was rl_arrow_keys */
    { ISFUNC, rl_delete_horizontal_space },	/* Meta-\ */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* Meta-] */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* Meta-^ */
!   { ISFUNC, rl_yank_last_arg },			/* Meta-_ */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* Meta-` */
  
    /* Lowercase alphabet. */
!   { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-a */
!   { ISFUNC, rl_backward_word },		/* Meta-b */
!   { ISFUNC, rl_capitalize_word }, 	/* Meta-c */
!   { ISFUNC, rl_kill_word },		/* Meta-d */
!   { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-e */
!   { ISFUNC, rl_forward_word },		/* Meta-f */
!   { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-g */
!   { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-h */
!   { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-i */
!   { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-j */
!   { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-k */
!   { ISFUNC, rl_downcase_word },		/* Meta-l */
!   { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-m */
    { ISFUNC, rl_noninc_forward_search },	/* Meta-n */
!   { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-o */	/* was rl_arrow_keys */
    { ISFUNC, rl_noninc_reverse_search },	/* Meta-p */
!   { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-q */
!   { ISFUNC, rl_revert_line },		/* Meta-r */
!   { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-s */
!   { ISFUNC, rl_transpose_words }, 	/* Meta-t */
!   { ISFUNC, rl_upcase_word },		/* Meta-u */
!   { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-v */
!   { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-w */
!   { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-x */
!   { ISFUNC, rl_yank_pop },		/* Meta-y */
!   { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-z */
  
    /* Final punctuation. */
!   { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-{ */
!   { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-| */
!   { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-} */
!   { ISFUNC, rl_tilde_expand },		/* Meta-~ */
!   { ISFUNC, rl_backward_kill_word },	/* Meta-rubout */
  
  #if KEYMAP_SIZE > 128
    /* Undefined keys. */
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 }
  #endif /* KEYMAP_SIZE > 128 */
  };
***************
*** 597,873 ****
  
    /* Control keys. */
!   { ISFUNC, (Function *)0x0 },		/* Control-@ */
!   { ISFUNC, (Function *)0x0 },		/* Control-a */
!   { ISFUNC, (Function *)0x0 },		/* Control-b */
!   { ISFUNC, (Function *)0x0 },		/* Control-c */
!   { ISFUNC, (Function *)0x0 },		/* Control-d */
!   { ISFUNC, (Function *)0x0 },		/* Control-e */
!   { ISFUNC, (Function *)0x0 },		/* Control-f */
!   { ISFUNC, rl_abort },			/* Control-g */
!   { ISFUNC, (Function *)0x0 },		/* Control-h */
!   { ISFUNC, (Function *)0x0 },		/* Control-i */
!   { ISFUNC, (Function *)0x0 },		/* Control-j */
!   { ISFUNC, (Function *)0x0 },		/* Control-k */
!   { ISFUNC, (Function *)0x0 },		/* Control-l */
!   { ISFUNC, (Function *)0x0 },		/* Control-m */
!   { ISFUNC, (Function *)0x0 },		/* Control-n */
!   { ISFUNC, (Function *)0x0 },		/* Control-o */
!   { ISFUNC, (Function *)0x0 },		/* Control-p */
!   { ISFUNC, (Function *)0x0 },		/* Control-q */
!   { ISFUNC, rl_re_read_init_file },	/* Control-r */
!   { ISFUNC, (Function *)0x0 },		/* Control-s */
!   { ISFUNC, (Function *)0x0 },		/* Control-t */
!   { ISFUNC, rl_undo_command },		/* Control-u */
!   { ISFUNC, (Function *)0x0 },		/* Control-v */
!   { ISFUNC, (Function *)0x0 },		/* Control-w */
!   { ISFUNC, rl_exchange_point_and_mark },/* Control-x */
!   { ISFUNC, (Function *)0x0 },		/* Control-y */
!   { ISFUNC, (Function *)0x0 },		/* Control-z */
!   { ISFUNC, (Function *)0x0 },		/* Control-[ */
!   { ISFUNC, (Function *)0x0 },		/* Control-\ */
!   { ISFUNC, (Function *)0x0 },		/* Control-] */
!   { ISFUNC, (Function *)0x0 },		/* Control-^ */
!   { ISFUNC, (Function *)0x0 },		/* Control-_ */
  
    /* The start of printing characters. */
!   { ISFUNC, (Function *)0x0 },		/* SPACE */
!   { ISFUNC, (Function *)0x0 },		/* ! */
!   { ISFUNC, (Function *)0x0 },		/* " */
!   { ISFUNC, (Function *)0x0 },		/* # */
!   { ISFUNC, (Function *)0x0 },		/* $ */
!   { ISFUNC, (Function *)0x0 },		/* % */
!   { ISFUNC, (Function *)0x0 },		/* & */
!   { ISFUNC, (Function *)0x0 },		/* ' */
!   { ISFUNC, rl_start_kbd_macro },	/* ( */
!   { ISFUNC, rl_end_kbd_macro  },	/* ) */
!   { ISFUNC, (Function *)0x0 },		/* * */
!   { ISFUNC, (Function *)0x0 },		/* + */
!   { ISFUNC, (Function *)0x0 },		/* , */
!   { ISFUNC, (Function *)0x0 },		/* - */
!   { ISFUNC, (Function *)0x0 },		/* . */
!   { ISFUNC, (Function *)0x0 },		/* / */
  
    /* Regular digits. */
!   { ISFUNC, (Function *)0x0 },		/* 0 */
!   { ISFUNC, (Function *)0x0 },		/* 1 */
!   { ISFUNC, (Function *)0x0 },		/* 2 */
!   { ISFUNC, (Function *)0x0 },		/* 3 */
!   { ISFUNC, (Function *)0x0 },		/* 4 */
!   { ISFUNC, (Function *)0x0 },		/* 5 */
!   { ISFUNC, (Function *)0x0 },		/* 6 */
!   { ISFUNC, (Function *)0x0 },		/* 7 */
!   { ISFUNC, (Function *)0x0 },		/* 8 */
!   { ISFUNC, (Function *)0x0 },		/* 9 */
  
    /* A little more punctuation. */
!   { ISFUNC, (Function *)0x0 },	/* : */
!   { ISFUNC, (Function *)0x0 },	/* ; */
!   { ISFUNC, (Function *)0x0 },	/* < */
!   { ISFUNC, (Function *)0x0 },	/* = */
!   { ISFUNC, (Function *)0x0 },	/* > */
!   { ISFUNC, (Function *)0x0 },	/* ? */
!   { ISFUNC, (Function *)0x0 },	/* @ */
  
    /* Uppercase alphabet. */
!   { ISFUNC, rl_do_lowercase_version },	/* A */
!   { ISFUNC, rl_do_lowercase_version },	/* B */
!   { ISFUNC, rl_do_lowercase_version },	/* C */
!   { ISFUNC, rl_do_lowercase_version },	/* D */
!   { ISFUNC, rl_do_lowercase_version },	/* E */
!   { ISFUNC, rl_do_lowercase_version },	/* F */
!   { ISFUNC, rl_do_lowercase_version },	/* G */
!   { ISFUNC, rl_do_lowercase_version },	/* H */
!   { ISFUNC, rl_do_lowercase_version },	/* I */
!   { ISFUNC, rl_do_lowercase_version },	/* J */
!   { ISFUNC, rl_do_lowercase_version },	/* K */
!   { ISFUNC, rl_do_lowercase_version },	/* L */
!   { ISFUNC, rl_do_lowercase_version },	/* M */
!   { ISFUNC, rl_do_lowercase_version },	/* N */
!   { ISFUNC, rl_do_lowercase_version },	/* O */
!   { ISFUNC, rl_do_lowercase_version },	/* P */
!   { ISFUNC, rl_do_lowercase_version },	/* Q */
!   { ISFUNC, rl_do_lowercase_version },	/* R */
!   { ISFUNC, rl_do_lowercase_version },	/* S */
!   { ISFUNC, rl_do_lowercase_version },	/* T */
!   { ISFUNC, rl_do_lowercase_version },	/* U */
!   { ISFUNC, rl_do_lowercase_version },	/* V */
!   { ISFUNC, rl_do_lowercase_version },	/* W */
!   { ISFUNC, rl_do_lowercase_version },	/* X */
!   { ISFUNC, rl_do_lowercase_version },	/* Y */
!   { ISFUNC, rl_do_lowercase_version },	/* Z */
  
    /* Some more punctuation. */
!   { ISFUNC, (Function *)0x0 },		/* [ */
!   { ISFUNC, (Function *)0x0 },		/* \ */
!   { ISFUNC, (Function *)0x0 },		/* ] */
!   { ISFUNC, (Function *)0x0 },		/* ^ */
!   { ISFUNC, (Function *)0x0 },		/* _ */
!   { ISFUNC, (Function *)0x0 },		/* ` */
  
    /* Lowercase alphabet. */
!   { ISFUNC, (Function *)0x0 },		/* a */
!   { ISFUNC, (Function *)0x0 },		/* b */
!   { ISFUNC, (Function *)0x0 },		/* c */
!   { ISFUNC, (Function *)0x0 },		/* d */
!   { ISFUNC, rl_call_last_kbd_macro },	/* e */
!   { ISFUNC, (Function *)0x0 },		/* f */
!   { ISFUNC, (Function *)0x0 },		/* g */
!   { ISFUNC, (Function *)0x0 },		/* h */
!   { ISFUNC, (Function *)0x0 },		/* i */
!   { ISFUNC, (Function *)0x0 },		/* j */
!   { ISFUNC, (Function *)0x0 },		/* k */
!   { ISFUNC, (Function *)0x0 },		/* l */
!   { ISFUNC, (Function *)0x0 },		/* m */
!   { ISFUNC, (Function *)0x0 },		/* n */
!   { ISFUNC, (Function *)0x0 },		/* o */
!   { ISFUNC, (Function *)0x0 },		/* p */
!   { ISFUNC, (Function *)0x0 },		/* q */
!   { ISFUNC, (Function *)0x0 },		/* r */
!   { ISFUNC, (Function *)0x0 },		/* s */
!   { ISFUNC, (Function *)0x0 },		/* t */
!   { ISFUNC, (Function *)0x0 },		/* u */
!   { ISFUNC, (Function *)0x0 },		/* v */
!   { ISFUNC, (Function *)0x0 },		/* w */
!   { ISFUNC, (Function *)0x0 },		/* x */
!   { ISFUNC, (Function *)0x0 },		/* y */
!   { ISFUNC, (Function *)0x0 },		/* z */
  
    /* Final punctuation. */
!   { ISFUNC, (Function *)0x0 },		/* { */
!   { ISFUNC, (Function *)0x0 },		/* | */
!   { ISFUNC, (Function *)0x0 },		/* } */
!   { ISFUNC, (Function *)0x0 },		/* ~ */
!   { ISFUNC, rl_backward_kill_line },	/* RUBOUT */
  
  #if KEYMAP_SIZE > 128
    /* Undefined keys. */
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 }
  #endif /* KEYMAP_SIZE > 128 */
  };
--- 597,873 ----
  
    /* Control keys. */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-@ */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-a */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-b */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-c */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-d */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-e */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-f */
!   { ISFUNC, rl_abort },				/* Control-g */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-h */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-i */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-j */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-k */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-l */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-m */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-n */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-o */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-p */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-q */
!   { ISFUNC, rl_re_read_init_file },		/* Control-r */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-s */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-t */
!   { ISFUNC, rl_undo_command },			/* Control-u */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-v */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-w */
!   { ISFUNC, rl_exchange_point_and_mark },	/* Control-x */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-y */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-z */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-[ */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-\ */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-] */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-^ */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-_ */
  
    /* The start of printing characters. */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* SPACE */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* ! */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* " */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* # */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* $ */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* % */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* & */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* ' */
!   { ISFUNC, rl_start_kbd_macro },		/* ( */
!   { ISFUNC, rl_end_kbd_macro  },		/* ) */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* * */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* + */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* , */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* - */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* . */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* / */
  
    /* Regular digits. */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* 0 */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* 1 */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* 2 */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* 3 */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* 4 */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* 5 */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* 6 */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* 7 */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* 8 */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* 9 */
  
    /* A little more punctuation. */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* : */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* ; */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* < */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* = */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* > */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* ? */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* @ */
  
    /* Uppercase alphabet. */
!   { ISFUNC, rl_do_lowercase_version },		/* A */
!   { ISFUNC, rl_do_lowercase_version },		/* B */
!   { ISFUNC, rl_do_lowercase_version },		/* C */
!   { ISFUNC, rl_do_lowercase_version },		/* D */
!   { ISFUNC, rl_do_lowercase_version },		/* E */
!   { ISFUNC, rl_do_lowercase_version },		/* F */
!   { ISFUNC, rl_do_lowercase_version },		/* G */
!   { ISFUNC, rl_do_lowercase_version },		/* H */
!   { ISFUNC, rl_do_lowercase_version },		/* I */
!   { ISFUNC, rl_do_lowercase_version },		/* J */
!   { ISFUNC, rl_do_lowercase_version },		/* K */
!   { ISFUNC, rl_do_lowercase_version },		/* L */
!   { ISFUNC, rl_do_lowercase_version },		/* M */
!   { ISFUNC, rl_do_lowercase_version },		/* N */
!   { ISFUNC, rl_do_lowercase_version },		/* O */
!   { ISFUNC, rl_do_lowercase_version },		/* P */
!   { ISFUNC, rl_do_lowercase_version },		/* Q */
!   { ISFUNC, rl_do_lowercase_version },		/* R */
!   { ISFUNC, rl_do_lowercase_version },		/* S */
!   { ISFUNC, rl_do_lowercase_version },		/* T */
!   { ISFUNC, rl_do_lowercase_version },		/* U */
!   { ISFUNC, rl_do_lowercase_version },		/* V */
!   { ISFUNC, rl_do_lowercase_version },		/* W */
!   { ISFUNC, rl_do_lowercase_version },		/* X */
!   { ISFUNC, rl_do_lowercase_version },		/* Y */
!   { ISFUNC, rl_do_lowercase_version },		/* Z */
  
    /* Some more punctuation. */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* [ */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* \ */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* ] */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* ^ */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* _ */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* ` */
  
    /* Lowercase alphabet. */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* a */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* b */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* c */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* d */
!   { ISFUNC, rl_call_last_kbd_macro },		/* e */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* f */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* g */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* h */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* i */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* j */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* k */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* l */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* m */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* n */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* o */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* p */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* q */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* r */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* s */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* t */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* u */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* v */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* w */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* x */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* y */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* z */
  
    /* Final punctuation. */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* { */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* | */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* } */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* ~ */
!   { ISFUNC, rl_backward_kill_line },		/* RUBOUT */
  
  #if KEYMAP_SIZE > 128
    /* Undefined keys. */
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 }
  #endif /* KEYMAP_SIZE > 128 */
  };
diff -Nrc2 bash-2.04/lib/readline/examples/excallback.c bash-2.05/lib/readline/examples/excallback.c
*** bash-2.04/lib/readline/examples/excallback.c	Thu Sep  2 10:57:14 1999
--- bash-2.05/lib/readline/examples/excallback.c	Mon Jul 10 10:52:46 2000
***************
*** 154,157 ****
--- 154,159 ----
      fprintf(stderr, "|%s|\n", line);
    }
+ 
+   free (line);
  }
  
diff -Nrc2 bash-2.04/lib/readline/examples/fileman.c bash-2.05/lib/readline/examples/fileman.c
*** bash-2.04/lib/readline/examples/fileman.c	Thu Sep  2 16:45:52 1999
--- bash-2.05/lib/readline/examples/fileman.c	Tue Dec 12 15:05:24 2000
***************
*** 42,47 ****
  
  /* The names of functions that actually do the manipulation. */
! int com_list (), com_view (), com_rename (), com_stat (), com_pwd ();
! int com_delete (), com_help (), com_cd (), com_quit ();
  
  /* A structure which contains information on the commands this program
--- 42,54 ----
  
  /* The names of functions that actually do the manipulation. */
! int com_list __P((char *));
! int com_view __P((char *));
! int com_rename __P((char *));
! int com_stat __P((char *));
! int com_pwd __P((char *));
! int com_delete __P((char *));
! int com_help __P((char *));
! int com_cd __P((char *));
! int com_quit __P((char *));
  
  /* A structure which contains information on the commands this program
***************
*** 50,54 ****
  typedef struct {
    char *name;			/* User printable name of the function. */
!   Function *func;		/* Function to call to do the job. */
    char *doc;			/* Documentation for this function.  */
  } COMMAND;
--- 57,61 ----
  typedef struct {
    char *name;			/* User printable name of the function. */
!   rl_icpfunc_t *func;		/* Function to call to do the job. */
    char *doc;			/* Documentation for this function.  */
  } COMMAND;
***************
*** 66,70 ****
    { "stat", com_stat, "Print out statistics on FILE" },
    { "view", com_view, "View the contents of FILE" },
!   { (char *)NULL, (Function *)NULL, (char *)NULL }
  };
  
--- 73,77 ----
    { "stat", com_stat, "Print out statistics on FILE" },
    { "view", com_view, "View the contents of FILE" },
!   { (char *)NULL, (rl_icpfunc_t *)NULL, (char *)NULL }
  };
  
***************
*** 206,211 ****
  /* **************************************************************** */
  
! char *command_generator ();
! char **fileman_completion ();
  
  /* Tell the GNU Readline library how to complete.  We want to try to complete
--- 213,218 ----
  /* **************************************************************** */
  
! char *command_generator __P((const char *, int));
! char **fileman_completion __P((const char *, int, int));
  
  /* Tell the GNU Readline library how to complete.  We want to try to complete
***************
*** 218,222 ****
  
    /* Tell the completer that we want a crack first. */
!   rl_attempted_completion_function = (CPPFunction *)fileman_completion;
  }
  
--- 225,229 ----
  
    /* Tell the completer that we want a crack first. */
!   rl_attempted_completion_function = fileman_completion;
  }
  
***************
*** 228,232 ****
  char **
  fileman_completion (text, start, end)
!      char *text;
       int start, end;
  {
--- 235,239 ----
  char **
  fileman_completion (text, start, end)
!      const char *text;
       int start, end;
  {
***************
*** 239,243 ****
       directory. */
    if (start == 0)
!     matches = completion_matches (text, command_generator);
  
    return (matches);
--- 246,250 ----
       directory. */
    if (start == 0)
!     matches = rl_completion_matches (text, command_generator);
  
    return (matches);
***************
*** 249,253 ****
  char *
  command_generator (text, state)
!      char *text;
       int state;
  {
--- 256,260 ----
  char *
  command_generator (text, state)
!      const char *text;
       int state;
  {
diff -Nrc2 bash-2.04/lib/readline/examples/histexamp.c bash-2.05/lib/readline/examples/histexamp.c
*** bash-2.04/lib/readline/examples/histexamp.c	Fri Jul 29 15:44:55 1994
--- bash-2.05/lib/readline/examples/histexamp.c	Tue Feb  6 10:35:21 2001
***************
*** 1,3 ****
! main ()
  {
    char line[1024], *t;
--- 1,13 ----
! #include <stdio.h>
! 
! #ifdef READLINE_LIBRARY
! #  include "history.h"
! #else
! #  include <readline/history.h>
! #endif
! 
! main (argc, argv)
!      int argc;
!      char **argv;
  {
    char line[1024], *t;
diff -Nrc2 bash-2.04/lib/readline/examples/manexamp.c bash-2.05/lib/readline/examples/manexamp.c
*** bash-2.04/lib/readline/examples/manexamp.c	Tue Jul 26 12:51:42 1994
--- bash-2.05/lib/readline/examples/manexamp.c	Fri Feb  2 12:14:15 2001
***************
*** 4,11 ****
  #include <readline/readline.h>
  
- 
  /* **************************************************************** */
  /*                                                                  */
! *   			How to Emulate gets ()			    */
  /*                                                                  */
  /* **************************************************************** */
--- 4,10 ----
  #include <readline/readline.h>
  
  /* **************************************************************** */
  /*                                                                  */
! /*   			How to Emulate gets ()			    */
  /*                                                                  */
  /* **************************************************************** */
***************
*** 83,90 ****
    for (; start != end; start += direction)
      {
!       if (uppercase_p (rl_line_buffer[start]))
! 	rl_line_buffer[start] = to_lower (rl_line_buffer[start]);
!       else if (lowercase_p (rl_line_buffer[start]))
! 	rl_line_buffer[start] = to_upper (rl_line_buffer[start]);
      }
  
--- 82,89 ----
    for (; start != end; start += direction)
      {
!       if (_rl_uppercase_p (rl_line_buffer[start]))
! 	rl_line_buffer[start] = _rl_to_lower (rl_line_buffer[start]);
!       else if (_rl_lowercase_p (rl_line_buffer[start]))
! 	rl_line_buffer[start] = _rl_to_upper (rl_line_buffer[start]);
      }
  
***************
*** 92,94 ****
    rl_point = end - direction;
  }
- 
--- 91,92 ----
diff -Nrc2 bash-2.04/lib/readline/examples/rl.c bash-2.05/lib/readline/examples/rl.c
*** bash-2.04/lib/readline/examples/rl.c	Mon Nov  8 16:22:03 1999
--- bash-2.05/lib/readline/examples/rl.c	Wed Nov  1 14:04:30 2000
***************
*** 39,43 ****
        rl_insert_text (deftext);
        deftext = (char *)NULL;
!       rl_startup_hook = (Function *)NULL;
      }
    return 0;
--- 39,43 ----
        rl_insert_text (deftext);
        deftext = (char *)NULL;
!       rl_startup_hook = (rl_hook_func_t *)NULL;
      }
    return 0;
***************
*** 127,131 ****
      exit (1);
  
!   puts (temp);
    exit (0);
  }
--- 127,131 ----
      exit (1);
  
!   printf ("%s\n", temp);
    exit (0);
  }
diff -Nrc2 bash-2.04/lib/readline/funmap.c bash-2.05/lib/readline/funmap.c
*** bash-2.04/lib/readline/funmap.c	Mon Jan 24 10:58:31 2000
--- bash-2.05/lib/readline/funmap.c	Wed Nov  8 12:38:13 2000
***************
*** 47,51 ****
  #endif
  
! extern int _rl_qsort_string_compare ();
  
  FUNMAP **funmap;
--- 47,51 ----
  #endif
  
! extern int _rl_qsort_string_compare __P((char **, char **));
  
  FUNMAP **funmap;
***************
*** 109,113 ****
    { "non-incremental-forward-search-history-again", rl_noninc_forward_search_again },
    { "non-incremental-reverse-search-history-again", rl_noninc_reverse_search_again },
! #ifdef __CYGWIN32__
    { "paste-from-clipboard", rl_paste_from_clipboard },
  #endif
--- 109,113 ----
    { "non-incremental-forward-search-history-again", rl_noninc_forward_search_again },
    { "non-incremental-reverse-search-history-again", rl_noninc_reverse_search_again },
! #ifdef __CYGWIN__
    { "paste-from-clipboard", rl_paste_from_clipboard },
  #endif
***************
*** 143,147 ****
    { "vi-back-to-indent", rl_vi_back_to_indent },
    { "vi-bWord", rl_vi_bWord },
-   { "vi-bracktype", rl_vi_bracktype },
    { "vi-bword", rl_vi_bword },
    { "vi-change-case", rl_vi_change_case },
--- 143,146 ----
***************
*** 183,193 ****
  #endif /* VI_MODE */
  
!  {(char *)NULL, (Function *)NULL }
  };
  
  int
  rl_add_funmap_entry (name, function)
!      char *name;
!      Function *function;
  {
    if (funmap_entry + 2 >= funmap_size)
--- 182,192 ----
  #endif /* VI_MODE */
  
!  {(char *)NULL, (rl_command_func_t *)NULL }
  };
  
  int
  rl_add_funmap_entry (name, function)
!      const char *name;
!      rl_command_func_t *function;
  {
    if (funmap_entry + 2 >= funmap_size)
***************
*** 226,233 ****
     is sorted.  The array itself is allocated, but not the strings inside.
     You should free () the array when you done, but not the pointrs. */
! char **
  rl_funmap_names ()
  {
!   char **result;
    int result_size, result_index;
  
--- 225,232 ----
     is sorted.  The array itself is allocated, but not the strings inside.
     You should free () the array when you done, but not the pointrs. */
! const char **
  rl_funmap_names ()
  {
!   const char **result;
    int result_size, result_index;
  
***************
*** 235,244 ****
    rl_initialize_funmap ();
  
!   for (result_index = result_size = 0, result = (char **)NULL; funmap[result_index]; result_index++)
      {
        if (result_index + 2 > result_size)
  	{
  	  result_size += 20;
! 	  result = (char **)xrealloc (result, result_size * sizeof (char *));
  	}
  
--- 234,243 ----
    rl_initialize_funmap ();
  
!   for (result_index = result_size = 0, result = (const char **)NULL; funmap[result_index]; result_index++)
      {
        if (result_index + 2 > result_size)
  	{
  	  result_size += 20;
! 	  result = (const char **)xrealloc (result, result_size * sizeof (char *));
  	}
  
***************
*** 250,260 ****
    return (result);
  }
- 
- /* Things that mean `Control'. */
- char *possible_control_prefixes[] = {
-   "Control-", "C-", "CTRL-", (char *)NULL
- };
- 
- char *possible_meta_prefixes[] = {
-   "Meta", "M-", (char *)NULL
- };
--- 249,250 ----
diff -Nrc2 bash-2.04/lib/readline/histexpand.c bash-2.05/lib/readline/histexpand.c
*** bash-2.04/lib/readline/histexpand.c	Thu Aug  5 08:03:35 1999
--- bash-2.05/lib/readline/histexpand.c	Tue Mar  6 14:09:25 2001
***************
*** 57,60 ****
--- 57,62 ----
  #define HISTORY_QUOTE_CHARACTERS	"\"'`"
  
+ typedef int _hist_search_func_t __P((const char *, int));
+ 
  static char error_pointer;
  
***************
*** 92,98 ****
  int history_quotes_inhibit_expansion = 0;
  
  /* If set, this points to a function that is called to verify that a
     particular history expansion should be performed. */
! Function *history_inhibit_expansion_function;
  
  /* **************************************************************** */
--- 94,103 ----
  int history_quotes_inhibit_expansion = 0;
  
+ /* Used to split words by history_tokenize_internal. */
+ char *history_word_delimiters = HISTORY_WORD_DELIMITERS;
+ 
  /* If set, this points to a function that is called to verify that a
     particular history expansion should be performed. */
! rl_linebuf_func_t *history_inhibit_expansion_function;
  
  /* **************************************************************** */
***************
*** 123,127 ****
  char *
  get_history_event (string, caller_index, delimiting_quote)
!      char *string;
       int *caller_index;
       int delimiting_quote;
--- 128,132 ----
  char *
  get_history_event (string, caller_index, delimiting_quote)
!      const char *string;
       int *caller_index;
       int delimiting_quote;
***************
*** 131,135 ****
    HIST_ENTRY *entry;
    int which, sign, local_index, substring_okay;
!   Function *search_func;
    char *temp;
  
--- 136,140 ----
    HIST_ENTRY *entry;
    int which, sign, local_index, substring_okay;
!   _hist_search_func_t *search_func;
    char *temp;
  
***************
*** 341,345 ****
        int start, current, errtype;
  {
!   char *temp, *emsg;
    int ll, elen;
  
--- 346,351 ----
        int start, current, errtype;
  {
!   char *temp;
!   const char *emsg;
    int ll, elen;
  
***************
*** 623,627 ****
  	case 's':
  	  {
! 	    char *new_event, *t;
  	    int delimiter, failed, si, l_temp;
  
--- 629,633 ----
  	case 's':
  	  {
! 	    char *new_event;
  	    int delimiter, failed, si, l_temp;
  
***************
*** 742,746 ****
  
        if (want_quotes == 'q')
! 	x = single_quote (temp);
        else if (want_quotes == 'x')
  	x = quote_breaks (temp);
--- 748,752 ----
  
        if (want_quotes == 'q')
! 	x = sh_single_quote (temp);
        else if (want_quotes == 'x')
  	x = quote_breaks (temp);
***************
*** 817,820 ****
--- 823,829 ----
    char *temp;
  
+   if (output == 0)
+     return 0;
+ 
    /* Setting the history expansion character to 0 inhibits all
       history expansion. */
***************
*** 866,870 ****
  	     Skip the rest of the line and break out of the loop. */
  	  if (history_comment_char && string[i] == history_comment_char &&
! 	      (i == 0 || member (string[i - 1], HISTORY_WORD_DELIMITERS)))
  	    {
  	      while (string[i])
--- 875,879 ----
  	     Skip the rest of the line and break out of the loop. */
  	  if (history_comment_char && string[i] == history_comment_char &&
! 	      (i == 0 || member (string[i - 1], history_word_delimiters)))
  	    {
  	      while (string[i])
***************
*** 964,968 ****
  
  	case -2:		/* history_comment_char */
! 	  if (i == 0 || member (string[i - 1], HISTORY_WORD_DELIMITERS))
  	    {
  	      temp = xmalloc (l - i + 1);
--- 973,977 ----
  
  	case -2:		/* history_comment_char */
! 	  if (i == 0 || member (string[i - 1], history_word_delimiters))
  	    {
  	      temp = xmalloc (l - i + 1);
***************
*** 1152,1156 ****
  history_arg_extract (first, last, string)
       int first, last;
!      char *string;
  {
    register int i, len;
--- 1161,1165 ----
  history_arg_extract (first, last, string)
       int first, last;
!      const char *string;
  {
    register int i, len;
***************
*** 1218,1222 ****
  static char **
  history_tokenize_internal (string, wind, indp)
!      char *string;
       int wind, *indp;
  {
--- 1227,1231 ----
  static char **
  history_tokenize_internal (string, wind, indp)
!      const char *string;
       int wind, *indp;
  {
***************
*** 1225,1228 ****
--- 1234,1242 ----
    int len, delimiter;
  
+   /* If we're searching for a string that's not part of a word (e.g., " "),
+      make sure we set *INDP to a reasonable value. */
+   if (indp && wind != -1)
+     *indp = -1;
+ 
    /* Get a token, and stuff it into RESULT.  The tokens are split
       exactly where the shell would split them. */
***************
*** 1299,1303 ****
  	    }
  
! 	  if (!delimiter && (member (string[i], HISTORY_WORD_DELIMITERS)))
  	    break;
  
--- 1313,1317 ----
  	    }
  
! 	  if (!delimiter && (member (string[i], history_word_delimiters)))
  	    break;
  
***************
*** 1329,1333 ****
  char **
  history_tokenize (string)
!      char *string;
  {
    return (history_tokenize_internal (string, -1, (int *)NULL));
--- 1343,1347 ----
  char **
  history_tokenize (string)
!      const char *string;
  {
    return (history_tokenize_internal (string, -1, (int *)NULL));
***************
*** 1346,1350 ****
  
    words = history_tokenize_internal (line, ind, &wind);
!   if (wind == -1)
      return ((char *)NULL);
    s = words[wind];
--- 1360,1364 ----
  
    words = history_tokenize_internal (line, ind, &wind);
!   if (wind == -1 || words == 0)
      return ((char *)NULL);
    s = words[wind];
diff -Nrc2 bash-2.04/lib/readline/histfile.c bash-2.05/lib/readline/histfile.c
*** bash-2.04/lib/readline/histfile.c	Thu Aug  5 08:04:04 1999
--- bash-2.05/lib/readline/histfile.c	Tue Mar  6 13:14:27 2001
***************
*** 85,91 ****
  static char *
  history_filename (filename)
!      char *filename;
  {
!   char *return_val, *home;
    int home_len;
  
--- 85,92 ----
  static char *
  history_filename (filename)
!      const char *filename;
  {
!   char *return_val;
!   const char *home;
    int home_len;
  
***************
*** 95,99 ****
      return (return_val);
    
!   home = get_env_value ("HOME");
  
    if (home == 0)
--- 96,100 ----
      return (return_val);
    
!   home = sh_get_env_value ("HOME");
  
    if (home == 0)
***************
*** 122,126 ****
  int
  read_history (filename)
!      char *filename;
  {
    return (read_history_range (filename, 0, -1));
--- 123,127 ----
  int
  read_history (filename)
!      const char *filename;
  {
    return (read_history_range (filename, 0, -1));
***************
*** 134,138 ****
  int
  read_history_range (filename, from, to)
!      char *filename;
       int from, to;
  {
--- 135,139 ----
  int
  read_history_range (filename, from, to)
!      const char *filename;
       int from, to;
  {
***************
*** 222,233 ****
  
  /* Truncate the history file FNAME, leaving only LINES trailing lines.
!    If FNAME is NULL, then use ~/.history. */
  int
  history_truncate_file (fname, lines)
!      char *fname;
       int lines;
  {
    register int i;
!   int file, chars_read;
    char *buffer, *filename;
    struct stat finfo;
--- 223,235 ----
  
  /* Truncate the history file FNAME, leaving only LINES trailing lines.
!    If FNAME is NULL, then use ~/.history.  Returns 0 on success, errno
!    on failure. */
  int
  history_truncate_file (fname, lines)
!      const char *fname;
       int lines;
  {
    register int i;
!   int file, chars_read, rv;
    char *buffer, *filename;
    struct stat finfo;
***************
*** 237,247 ****
    filename = history_filename (fname);
    file = open (filename, O_RDONLY|O_BINARY, 0666);
  
    if (file == -1 || fstat (file, &finfo) == -1)
!     goto truncate_exit;
  
!   /* Don't try to truncate non-regular files. */
!   if (S_ISREG(finfo.st_mode) == 0)
!     goto truncate_exit;
  
    file_size = (size_t)finfo.st_size;
--- 239,263 ----
    filename = history_filename (fname);
    file = open (filename, O_RDONLY|O_BINARY, 0666);
+   rv = 0;
  
+   /* Don't try to truncate non-regular files. */
    if (file == -1 || fstat (file, &finfo) == -1)
!     {
!       rv = errno;
!       if (file != -1)
! 	close (file);
!       goto truncate_exit;
!     }
  
!   if (S_ISREG (finfo.st_mode) == 0)
!     {
!       close (file);
! #ifdef EFTYPE
!       rv = EFTYPE;
! #else
!       rv = EINVAL;
! #endif
!       goto truncate_exit;
!     }
  
    file_size = (size_t)finfo.st_size;
***************
*** 252,256 ****
        close (file);
  #if defined (EFBIG)
!       errno = EFBIG;
  #endif
        goto truncate_exit;
--- 268,276 ----
        close (file);
  #if defined (EFBIG)
!       rv = errno = EFBIG;
! #elif defined (EOVERFLOW)
!       rv = errno = EOVERFLOW;
! #else
!       rv = errno = EINVAL;
  #endif
        goto truncate_exit;
***************
*** 262,266 ****
  
    if (chars_read <= 0)
!     goto truncate_exit;
  
    /* Count backwards from the end of buffer until we have passed
--- 282,289 ----
  
    if (chars_read <= 0)
!     {
!       rv = (chars_read < 0) ? errno : 0;
!       goto truncate_exit;
!     }
  
    /* Count backwards from the end of buffer until we have passed
***************
*** 303,307 ****
  
    free (filename);
!   return 0;
  }
  
--- 326,330 ----
  
    free (filename);
!   return rv;
  }
  
***************
*** 311,323 ****
  static int
  history_do_write (filename, nelements, overwrite)
!      char *filename;
       int nelements, overwrite;
  {
    register int i;
    char *output;
!   int file, mode;
  
    mode = overwrite ? O_WRONLY|O_CREAT|O_TRUNC|O_BINARY : O_WRONLY|O_APPEND|O_BINARY;
    output = history_filename (filename);
  
    if ((file = open (output, mode, 0600)) == -1)
--- 334,347 ----
  static int
  history_do_write (filename, nelements, overwrite)
!      const char *filename;
       int nelements, overwrite;
  {
    register int i;
    char *output;
!   int file, mode, rv;
  
    mode = overwrite ? O_WRONLY|O_CREAT|O_TRUNC|O_BINARY : O_WRONLY|O_APPEND|O_BINARY;
    output = history_filename (filename);
+   rv = 0;
  
    if ((file = open (output, mode, 0600)) == -1)
***************
*** 353,357 ****
        }
  
!     write (file, buffer, buffer_size);
      free (buffer);
    }
--- 377,382 ----
        }
  
!     if (write (file, buffer, buffer_size) < 0)
!       rv = errno;
      free (buffer);
    }
***************
*** 361,365 ****
    FREE (output);
  
!   return (0);
  }
  
--- 386,390 ----
    FREE (output);
  
!   return (rv);
  }
  
***************
*** 369,373 ****
  append_history (nelements, filename)
       int nelements;
!      char *filename;
  {
    return (history_do_write (filename, nelements, HISTORY_APPEND));
--- 394,398 ----
  append_history (nelements, filename)
       int nelements;
!      const char *filename;
  {
    return (history_do_write (filename, nelements, HISTORY_APPEND));
***************
*** 379,383 ****
  int
  write_history (filename)
!      char *filename;
  {
    return (history_do_write (filename, history_length, HISTORY_OVERWRITE));
--- 404,408 ----
  int
  write_history (filename)
!      const char *filename;
  {
    return (history_do_write (filename, history_length, HISTORY_OVERWRITE));
diff -Nrc2 bash-2.04/lib/readline/histlib.h bash-2.05/lib/readline/histlib.h
*** bash-2.04/lib/readline/histlib.h	Thu Aug  5 08:04:18 1999
--- bash-2.05/lib/readline/histlib.h	Mon Oct 30 14:18:45 2000
***************
*** 23,35 ****
  #define _HISTLIB_H_
  
- /* Function pointers can be declared as (Function *)foo. */
- #if !defined (_FUNCTION_DEF)
- #  define _FUNCTION_DEF
- typedef int Function ();
- typedef void VFunction ();
- typedef char *CPFunction ();
- typedef char **CPPFunction ();
- #endif /* _FUNCTION_DEF */
- 
  #if !defined (STREQ)
  #define STREQ(a, b)	(((a)[0] == (b)[0]) && (strcmp ((a), (b)) == 0))
--- 23,26 ----
diff -Nrc2 bash-2.04/lib/readline/history.c bash-2.05/lib/readline/history.c
*** bash-2.04/lib/readline/history.c	Thu Aug  5 08:04:31 1999
--- bash-2.05/lib/readline/history.c	Tue Mar  6 13:34:44 2001
***************
*** 74,78 ****
  /* If HISTORY_STIFLED is non-zero, then this is the maximum number of
     entries to remember. */
! int max_input_history;
  
  /* The current location of the interactive history pointer.  Just makes
--- 74,79 ----
  /* If HISTORY_STIFLED is non-zero, then this is the maximum number of
     entries to remember. */
! int history_max_entries;
! int max_input_history;	/* backwards compatibility */
  
  /* The current location of the interactive history pointer.  Just makes
***************
*** 135,141 ****
    register int i, result;
  
!   result = 0;
! 
!   for (i = 0; the_history && the_history[i]; i++)
      result += strlen (the_history[i]->line);
  
--- 136,140 ----
    register int i, result;
  
!   for (i = result = 0; the_history && the_history[i]; i++)
      result += strlen (the_history[i]->line);
  
***************
*** 218,231 ****
  void
  add_history (string)
!      char *string;
  {
    HIST_ENTRY *temp;
  
!   if (history_stifled && (history_length == max_input_history))
      {
        register int i;
  
        /* If the history is stifled, and history_length is zero,
! 	 and it equals max_input_history, we don't save items. */
        if (history_length == 0)
  	return;
--- 217,230 ----
  void
  add_history (string)
!      const char *string;
  {
    HIST_ENTRY *temp;
  
!   if (history_stifled && (history_length == history_max_entries))
      {
        register int i;
  
        /* If the history is stifled, and history_length is zero,
! 	 and it equals history_max_entries, we don't save items. */
        if (history_length == 0)
  	return;
***************
*** 278,290 ****
  replace_history_entry (which, line, data)
       int which;
!      char *line;
       histdata_t data;
  {
!   HIST_ENTRY *temp = (HIST_ENTRY *)xmalloc (sizeof (HIST_ENTRY));
!   HIST_ENTRY *old_value;
  
    if (which >= history_length)
      return ((HIST_ENTRY *)NULL);
  
    old_value = the_history[which];
  
--- 277,289 ----
  replace_history_entry (which, line, data)
       int which;
!      const char *line;
       histdata_t data;
  {
!   HIST_ENTRY *temp, *old_value;
  
    if (which >= history_length)
      return ((HIST_ENTRY *)NULL);
  
+   temp = (HIST_ENTRY *)xmalloc (sizeof (HIST_ENTRY));
    old_value = the_history[which];
  
***************
*** 304,307 ****
--- 303,307 ----
  {
    HIST_ENTRY *return_value;
+   register int i;
  
    if (which >= history_length || !history_length)
***************
*** 309,313 ****
    else
      {
-       register int i;
        return_value = the_history[which];
  
--- 309,312 ----
***************
*** 326,329 ****
--- 325,330 ----
       int max;
  {
+   register int i, j;
+ 
    if (max < 0)
      max = 0;
***************
*** 331,336 ****
    if (history_length > max)
      {
-       register int i, j;
- 
        /* This loses because we cannot free the data. */
        for (i = 0, j = history_length - max; i < j; i++)
--- 332,335 ----
***************
*** 348,352 ****
  
    history_stifled = 1;
!   max_input_history = max;
  }
  
--- 347,351 ----
  
    history_stifled = 1;
!   max_input_history = history_max_entries = max;
  }
  
***************
*** 360,367 ****
      {
        history_stifled = 0;
!       return (-max_input_history);
      }
  
!   return (max_input_history);
  }
  
--- 359,366 ----
      {
        history_stifled = 0;
!       return (-history_max_entries);
      }
  
!   return (history_max_entries);
  }
  
diff -Nrc2 bash-2.04/lib/readline/history.h bash-2.05/lib/readline/history.h
*** bash-2.04/lib/readline/history.h	Thu Aug  5 08:04:45 1999
--- bash-2.05/lib/readline/history.h	Tue Mar  6 13:54:26 2001
***************
*** 29,42 ****
  #if defined READLINE_LIBRARY
  #  include "rlstdc.h"
  #else
  #  include <readline/rlstdc.h>
! #endif
! 
! #if !defined (_FUNCTION_DEF)
! #  define _FUNCTION_DEF
! typedef int Function ();
! typedef void VFunction ();
! typedef char *CPFunction ();
! typedef char **CPPFunction ();
  #endif
  
--- 29,36 ----
  #if defined READLINE_LIBRARY
  #  include "rlstdc.h"
+ #  include "rltypedefs.h"
  #else
  #  include <readline/rlstdc.h>
! #  include <readline/rltypedefs.h>
  #endif
  
***************
*** 81,85 ****
  /* Place STRING at the end of the history list.
     The associated data field (if any) is set to NULL. */
! extern void add_history __P((char *));
  
  /* A reasonably useless function, only here for completeness.  WHICH
--- 75,79 ----
  /* Place STRING at the end of the history list.
     The associated data field (if any) is set to NULL. */
! extern void add_history __P((const char *));
  
  /* A reasonably useless function, only here for completeness.  WHICH
***************
*** 91,95 ****
     the old entry so you can dispose of the data.  In the case of an
     invalid WHICH, a NULL pointer is returned. */
! extern HIST_ENTRY *replace_history_entry __P((int, char *, histdata_t));
  
  /* Clear the history list and start over. */
--- 85,89 ----
     the old entry so you can dispose of the data.  In the case of an
     invalid WHICH, a NULL pointer is returned. */
! extern HIST_ENTRY *replace_history_entry __P((int, const char *, histdata_t));
  
  /* Clear the history list and start over. */
***************
*** 153,162 ****
     is the offset in the line of that history entry that the string was
     found in.  Otherwise, nothing is changed, and a -1 is returned. */
! extern int history_search __P((char *, int));
  
  /* Search the history for STRING, starting at history_offset.
     The search is anchored: matching lines must begin with string.
     DIRECTION is as in history_search(). */
! extern int history_search_prefix __P((char *, int));
  
  /* Search for STRING in the history list, starting at POS, an
--- 147,156 ----
     is the offset in the line of that history entry that the string was
     found in.  Otherwise, nothing is changed, and a -1 is returned. */
! extern int history_search __P((const char *, int));
  
  /* Search the history for STRING, starting at history_offset.
     The search is anchored: matching lines must begin with string.
     DIRECTION is as in history_search(). */
! extern int history_search_prefix __P((const char *, int));
  
  /* Search for STRING in the history list, starting at POS, an
***************
*** 165,169 ****
     Returns the absolute index of the history element where STRING
     was found, or -1 otherwise. */
! extern int history_search_pos __P((char *, int, int));
  
  /* Managing the history file. */
--- 159,163 ----
     Returns the absolute index of the history element where STRING
     was found, or -1 otherwise. */
! extern int history_search_pos __P((const char *, int, int));
  
  /* Managing the history file. */
***************
*** 172,176 ****
     If FILENAME is NULL, then read from ~/.history.  Returns 0 if
     successful, or errno if not. */
! extern int read_history __P((char *));
  
  /* Read a range of lines from FILENAME, adding them to the history list.
--- 166,170 ----
     If FILENAME is NULL, then read from ~/.history.  Returns 0 if
     successful, or errno if not. */
! extern int read_history __P((const char *));
  
  /* Read a range of lines from FILENAME, adding them to the history list.
***************
*** 179,195 ****
     until the end of the file.  If FILENAME is NULL, then read from
     ~/.history.  Returns 0 if successful, or errno if not. */
! extern int read_history_range __P((char *, int, int));
  
  /* Write the current history to FILENAME.  If FILENAME is NULL,
     then write the history list to ~/.history.  Values returned
     are as in read_history ().  */
! extern int write_history __P((char *));
  
  /* Append NELEMENT entries to FILENAME.  The entries appended are from
     the end of the list minus NELEMENTs up to the end of the list. */
! extern int append_history __P((int, char *));
  
  /* Truncate the history file, leaving only the last NLINES lines. */
! extern int history_truncate_file __P((char *, int));
  
  /* History expansion. */
--- 173,189 ----
     until the end of the file.  If FILENAME is NULL, then read from
     ~/.history.  Returns 0 if successful, or errno if not. */
! extern int read_history_range __P((const char *, int, int));
  
  /* Write the current history to FILENAME.  If FILENAME is NULL,
     then write the history list to ~/.history.  Values returned
     are as in read_history ().  */
! extern int write_history __P((const char *));
  
  /* Append NELEMENT entries to FILENAME.  The entries appended are from
     the end of the list minus NELEMENTs up to the end of the list. */
! extern int append_history __P((int, const char *));
  
  /* Truncate the history file, leaving only the last NLINES lines. */
! extern int history_truncate_file __P((const char *, int));
  
  /* History expansion. */
***************
*** 212,216 ****
     arguments present in STRING.  Arguments are broken up as in
     the shell. */
! extern char *history_arg_extract __P((int, int, char *));
  
  /* Return the text of the history event beginning at the current
--- 206,210 ----
     arguments present in STRING.  Arguments are broken up as in
     the shell. */
! extern char *history_arg_extract __P((int, int, const char *));
  
  /* Return the text of the history event beginning at the current
***************
*** 220,235 ****
     specification for what to search for in addition to the normal
     characters `:', ` ', `\t', `\n', and sometimes `?'. */
! extern char *get_history_event __P((char *, int *, int));
  
  /* Return an array of tokens, much as the shell might.  The tokens are
     parsed out of STRING. */
! extern char **history_tokenize __P((char *));
  
  /* Exported history variables. */
  extern int history_base;
  extern int history_length;
! extern int max_input_history;
  extern char history_expansion_char;
  extern char history_subst_char;
  extern char history_comment_char;
  extern char *history_no_expand_chars;
--- 214,230 ----
     specification for what to search for in addition to the normal
     characters `:', ` ', `\t', `\n', and sometimes `?'. */
! extern char *get_history_event __P((const char *, int *, int));
  
  /* Return an array of tokens, much as the shell might.  The tokens are
     parsed out of STRING. */
! extern char **history_tokenize __P((const char *));
  
  /* Exported history variables. */
  extern int history_base;
  extern int history_length;
! extern int history_max_entries;
  extern char history_expansion_char;
  extern char history_subst_char;
+ extern char *history_word_delimiters;
  extern char history_comment_char;
  extern char *history_no_expand_chars;
***************
*** 237,244 ****
  extern int history_quotes_inhibit_expansion;
  
  /* If set, this function is called to decide whether or not a particular
     history expansion should be treated as a special case for the calling
     application and not expanded. */
! extern Function *history_inhibit_expansion_function;
  
  #ifdef __cplusplus
--- 232,242 ----
  extern int history_quotes_inhibit_expansion;
  
+ /* Backwards compatibility */
+ extern int max_input_history;
+ 
  /* If set, this function is called to decide whether or not a particular
     history expansion should be treated as a special case for the calling
     application and not expanded. */
! extern rl_linebuf_func_t *history_inhibit_expansion_function;
  
  #ifdef __cplusplus
diff -Nrc2 bash-2.04/lib/readline/histsearch.c bash-2.05/lib/readline/histsearch.c
*** bash-2.04/lib/readline/histsearch.c	Thu Aug  5 08:05:01 1999
--- bash-2.05/lib/readline/histsearch.c	Thu Sep 28 14:15:52 2000
***************
*** 64,68 ****
  static int
  history_search_internal (string, direction, anchored)
!      char *string;
       int direction, anchored;
  {
--- 64,68 ----
  static int
  history_search_internal (string, direction, anchored)
!      const char *string;
       int direction, anchored;
  {
***************
*** 160,164 ****
  int
  history_search (string, direction)
!      char *string;
       int direction;
  {
--- 160,164 ----
  int
  history_search (string, direction)
!      const char *string;
       int direction;
  {
***************
*** 169,173 ****
  int
  history_search_prefix (string, direction)
!      char *string;
       int direction;
  {
--- 169,173 ----
  int
  history_search_prefix (string, direction)
!      const char *string;
       int direction;
  {
***************
*** 180,184 ****
  int
  history_search_pos (string, dir, pos)
!      char *string;
       int dir, pos;
  {
--- 180,184 ----
  int
  history_search_pos (string, dir, pos)
!      const char *string;
       int dir, pos;
  {
diff -Nrc2 bash-2.04/lib/readline/input.c bash-2.05/lib/readline/input.c
*** bash-2.04/lib/readline/input.c	Thu Aug  5 08:05:12 1999
--- bash-2.05/lib/readline/input.c	Tue Mar 27 10:15:04 2001
***************
*** 79,85 ****
  /* Non-null means it is a pointer to a function to run while waiting for
     character input. */
! Function *rl_event_hook = (Function *)NULL;
  
! Function *rl_getc_function = rl_getc;
  
  /* **************************************************************** */
--- 79,87 ----
  /* Non-null means it is a pointer to a function to run while waiting for
     character input. */
! rl_hook_func_t *rl_event_hook = (rl_hook_func_t *)NULL;
  
! rl_getc_func_t *rl_getc_function = rl_getc;
! 
! static int _keyboard_input_timeout = 100000;		/* 0.1 seconds; it's in usec */
  
  /* **************************************************************** */
***************
*** 170,174 ****
    FD_SET (tty, &exceptfds);
    timeout.tv_sec = 0;
!   timeout.tv_usec = 100000;	/* 0.1 seconds */
    if (select (tty + 1, &readfds, (fd_set *)NULL, &exceptfds, &timeout) <= 0)
      return;	/* Nothing to read. */
--- 172,176 ----
    FD_SET (tty, &exceptfds);
    timeout.tv_sec = 0;
!   timeout.tv_usec = _keyboard_input_timeout;
    if (select (tty + 1, &readfds, (fd_set *)NULL, &exceptfds, &timeout) <= 0)
      return;	/* Nothing to read. */
***************
*** 223,226 ****
--- 225,240 ----
  }
  
+ int
+ rl_set_keyboard_input_timeout (u)
+      int u;
+ {
+   int o;
+ 
+   o = _keyboard_input_timeout;
+   if (u > 0)
+     _keyboard_input_timeout = u;
+   return (o);
+ }
+ 
  /* Is there input available to be read on the readline input file
     descriptor?  Only works if the system has select(2) or FIONREAD. */
***************
*** 245,249 ****
    FD_SET (tty, &exceptfds);
    timeout.tv_sec = 0;
!   timeout.tv_usec = 100000;	/* 0.1 seconds */
    return (select (tty + 1, &readfds, (fd_set *)NULL, &exceptfds, &timeout) > 0);
  #endif
--- 259,263 ----
    FD_SET (tty, &exceptfds);
    timeout.tv_sec = 0;
!   timeout.tv_usec = _keyboard_input_timeout;
    return (select (tty + 1, &readfds, (fd_set *)NULL, &exceptfds, &timeout) > 0);
  #endif
***************
*** 294,297 ****
--- 308,312 ----
        key = NEWLINE;
        rl_pending_input = EOF;
+       RL_SETSTATE (RL_STATE_INPUTPENDING);
      }
    ibuffer[push_index++] = key;
***************
*** 308,311 ****
--- 323,336 ----
  {
    rl_pending_input = c;
+   RL_SETSTATE (RL_STATE_INPUTPENDING);
+   return 0;
+ }
+ 
+ /* Clear any pending input pushed with rl_execute_next() */
+ int
+ rl_clear_pending_input ()
+ {
+   rl_pending_input = 0;
+   RL_UNSETSTATE (RL_STATE_INPUTPENDING);
    return 0;
  }
***************
*** 328,332 ****
      {
        c = rl_pending_input;
!       rl_pending_input = 0;
      }
    else
--- 353,357 ----
      {
        c = rl_pending_input;
!       rl_clear_pending_input ();
      }
    else
***************
*** 342,345 ****
--- 367,372 ----
  	    {
  	      (*rl_event_hook) ();
+ 	      if (rl_done)		/* XXX - experimental */
+ 		return ('\n');
  	      rl_gather_tyi ();
  	    }
***************
*** 393,397 ****
        if (errno == X_EWOULDBLOCK || errno == X_EAGAIN)
  	{
! 	  if (unset_nodelay_mode (fileno (stream)) < 0)
  	    return (EOF);
  	  continue;
--- 420,424 ----
        if (errno == X_EWOULDBLOCK || errno == X_EAGAIN)
  	{
! 	  if (sh_unset_nodelay_mode (fileno (stream)) < 0)
  	    return (EOF);
  	  continue;
diff -Nrc2 bash-2.04/lib/readline/isearch.c bash-2.05/lib/readline/isearch.c
*** bash-2.04/lib/readline/isearch.c	Thu Aug  5 08:05:29 1999
--- bash-2.05/lib/readline/isearch.c	Wed Feb 14 07:37:01 2001
***************
*** 56,60 ****
  
  /* Variables imported from other files in the readline library. */
! extern HIST_ENTRY *saved_line_for_history;
  
  /* Forward declarations */
--- 56,60 ----
  
  /* Variables imported from other files in the readline library. */
! extern HIST_ENTRY *_rl_saved_line_for_history;
  
  /* Forward declarations */
***************
*** 65,68 ****
--- 65,70 ----
  static char *prev_line_found;
  
+ static unsigned char *default_isearch_terminators = "\033\012";
+ 
  /* Search backwards through the history looking for a string which is typed
     interactively.  Start with the current line. */
***************
*** 177,180 ****
--- 179,183 ----
    unsigned char *isearch_terminators;
  
+   RL_SETSTATE(RL_STATE_ISEARCH);
    orig_point = rl_point;
    last_found_line = orig_line = where_history ();
***************
*** 184,191 ****
  
    isearch_terminators = _rl_isearch_terminators ? _rl_isearch_terminators
! 						: (unsigned char *)"\033\012";
  
    /* Create an arrary of pointers to the lines that we want to search. */
!   maybe_replace_line ();
    i = 0;
    if (hlist)
--- 187,194 ----
  
    isearch_terminators = _rl_isearch_terminators ? _rl_isearch_terminators
! 						: default_isearch_terminators;
  
    /* Create an arrary of pointers to the lines that we want to search. */
!   rl_maybe_replace_line ();
    i = 0;
    if (hlist)
***************
*** 198,203 ****
      lines[i] = hlist[i]->line;
  
!   if (saved_line_for_history)
!     lines[i] = saved_line_for_history->line;
    else
      {
--- 201,206 ----
      lines[i] = hlist[i]->line;
  
!   if (_rl_saved_line_for_history)
!     lines[i] = _rl_saved_line_for_history->line;
    else
      {
***************
*** 233,240 ****
    for (;;)
      {
!       Function *f = (Function *)NULL;
  
        /* Read a key and decide how to proceed. */
        c = rl_read_key ();
  
        if (_rl_keymap[c].type == ISFUNC)
--- 236,245 ----
    for (;;)
      {
!       rl_command_func_t *f = (rl_command_func_t *)NULL;
  
        /* Read a key and decide how to proceed. */
+       RL_SETSTATE(RL_STATE_MOREINPUT);
        c = rl_read_key ();
+       RL_UNSETSTATE(RL_STATE_MOREINPUT);
  
        if (_rl_keymap[c].type == ISFUNC)
***************
*** 274,277 ****
--- 279,284 ----
        if (c >= 0 && (CTRL_CHAR (c) || META_CHAR (c) || c == RUBOUT) && c != CTRL ('G'))
  	{
+ 	  /* This sets rl_pending_input to c; it will be picked up the next
+ 	     time rl_read_key is called. */
  	  rl_execute_next (c);
  	  break;
***************
*** 288,292 ****
  	    ++line_index;
  	  else
! 	    ding ();
  	  break;
  
--- 295,299 ----
  	    ++line_index;
  	  else
! 	    rl_ding ();
  	  break;
  
***************
*** 306,309 ****
--- 313,317 ----
  	    free (allocated_line);
  	  free (lines);
+ 	  RL_UNSETSTATE(RL_STATE_ISEARCH);
  	  return 0;
  
***************
*** 312,316 ****
  	case -3:
  	  if (search_string_index == 0)
! 	    ding ();
  	  else
  	    {
--- 320,324 ----
  	case -3:
  	  if (search_string_index == 0)
! 	    rl_ding ();
  	  else
  	    {
***************
*** 385,389 ****
  	{
  	  /* We cannot find the search string.  Ding the bell. */
! 	  ding ();
  	  i = last_found_line;
  	  continue; 		/* XXX - was break */
--- 393,397 ----
  	{
  	  /* We cannot find the search string.  Ding the bell. */
! 	  rl_ding ();
  	  i = last_found_line;
  	  continue; 		/* XXX - was break */
***************
*** 438,441 ****
--- 446,451 ----
      free (allocated_line);
    free (lines);
+ 
+   RL_UNSETSTATE(RL_STATE_ISEARCH);
  
    return 0;
diff -Nrc2 bash-2.04/lib/readline/keymaps.c bash-2.05/lib/readline/keymaps.c
*** bash-2.04/lib/readline/keymaps.c	Thu Aug  5 08:05:44 1999
--- bash-2.05/lib/readline/keymaps.c	Mon Oct 30 12:05:43 2000
***************
*** 62,66 ****
      {
        keymap[i].type = ISFUNC;
!       keymap[i].function = (Function *)NULL;
      }
  
--- 62,66 ----
      {
        keymap[i].type = ISFUNC;
!       keymap[i].function = (rl_command_func_t *)NULL;
      }
  
diff -Nrc2 bash-2.04/lib/readline/keymaps.h bash-2.05/lib/readline/keymaps.h
*** bash-2.04/lib/readline/keymaps.h	Thu Dec  2 15:44:46 1999
--- bash-2.05/lib/readline/keymaps.h	Mon Oct 30 13:23:23 2000
***************
*** 31,45 ****
  #  include "rlstdc.h"
  #  include "chardefs.h"
  #else
  #  include <readline/rlstdc.h>
  #  include <readline/chardefs.h>
! #endif
! 
! #if !defined (_FUNCTION_DEF)
! #  define _FUNCTION_DEF
! typedef int Function ();
! typedef void VFunction ();
! typedef char *CPFunction ();
! typedef char **CPPFunction ();
  #endif
  
--- 31,39 ----
  #  include "rlstdc.h"
  #  include "chardefs.h"
+ #  include "rltypedefs.h"
  #else
  #  include <readline/rlstdc.h>
  #  include <readline/chardefs.h>
! #  include <readline/rltypedefs.h>
  #endif
  
***************
*** 51,55 ****
  typedef struct _keymap_entry {
    char type;
!   Function *function;
  } KEYMAP_ENTRY;
  
--- 45,49 ----
  typedef struct _keymap_entry {
    char type;
!   rl_command_func_t *function;
  } KEYMAP_ENTRY;
  
***************
*** 60,64 ****
  
  /* I wanted to make the above structure contain a union of:
!    union { Function *function; struct _keymap_entry *keymap; } value;
     but this made it impossible for me to create a static array.
     Maybe I need C lessons. */
--- 54,58 ----
  
  /* I wanted to make the above structure contain a union of:
!    union { rl_command_func_t *function; struct _keymap_entry *keymap; } value;
     but this made it impossible for me to create a static array.
     Maybe I need C lessons. */
***************
*** 94,98 ****
  /* Return the keymap corresponding to a given name.  Names look like
     `emacs' or `emacs-meta' or `vi-insert'.  */
! extern Keymap rl_get_keymap_by_name __P((char *));
  
  /* Return the current keymap. */
--- 88,92 ----
  /* Return the keymap corresponding to a given name.  Names look like
     `emacs' or `emacs-meta' or `vi-insert'.  */
! extern Keymap rl_get_keymap_by_name __P((const char *));
  
  /* Return the current keymap. */
diff -Nrc2 bash-2.04/lib/readline/kill.c bash-2.05/lib/readline/kill.c
*** bash-2.04/lib/readline/kill.c	Thu Aug  5 08:06:11 1999
--- bash-2.05/lib/readline/kill.c	Thu Nov  2 12:36:25 2000
***************
*** 265,269 ****
      {
        if (!rl_point)
! 	ding ();
        else
  	{
--- 265,269 ----
      {
        if (!rl_point)
! 	rl_ding ();
        else
  	{
***************
*** 300,304 ****
  
    if (rl_point == 0)
!     ding ();
    else
      {
--- 300,304 ----
  
    if (rl_point == 0)
!     rl_ding ();
    else
      {
***************
*** 332,336 ****
  {
    if (rl_point == 0)
!     ding ();
    else
      {
--- 332,336 ----
  {
    if (rl_point == 0)
!     rl_ding ();
    else
      {
***************
*** 513,517 ****
    if (entry == 0)
      {
!       ding ();
        return -1;
      }
--- 513,517 ----
    if (entry == 0)
      {
!       rl_ding ();
        return -1;
      }
***************
*** 520,524 ****
    if (!arg || !*arg)
      {
!       ding ();
        return -1;
      }
--- 520,524 ----
    if (!arg || !*arg)
      {
!       rl_ding ();
        return -1;
      }
***************
*** 593,597 ****
  
  /* A special paste command for users of Cygnus's cygwin32. */
! #if defined (__CYGWIN32__)
  #include <windows.h>
  
--- 593,597 ----
  
  /* A special paste command for users of Cygnus's cygwin32. */
! #if defined (__CYGWIN__)
  #include <windows.h>
  
***************
*** 626,628 ****
    return (0);
  }
! #endif /* __CYGWIN32__ */
--- 626,628 ----
    return (0);
  }
! #endif /* __CYGWIN__ */
diff -Nrc2 bash-2.04/lib/readline/macro.c bash-2.05/lib/readline/macro.c
*** bash-2.04/lib/readline/macro.c	Thu Aug  5 08:06:25 1999
--- bash-2.05/lib/readline/macro.c	Thu Nov  2 12:36:37 2000
***************
*** 58,67 ****
  /* **************************************************************** */
  
- /* Non-zero means to save keys that we dispatch on in a kbd macro. */
- int _rl_defining_kbd_macro = 0;
- 
  /* The currently executing macro string.  If this is non-zero,
     then it is a malloc ()'ed string where input is coming from. */
! char *_rl_executing_macro = (char *)NULL;
  
  /* The offset in the above string to the next character to be read. */
--- 58,67 ----
  /* **************************************************************** */
  
  /* The currently executing macro string.  If this is non-zero,
     then it is a malloc ()'ed string where input is coming from. */
! char *rl_executing_macro = (char *)NULL;
! 
! /* Non-zero means to save keys that we dispatch on in a kbd macro. */
! int _rl_defining_kbd_macro = 0;
  
  /* The offset in the above string to the next character to be read. */
***************
*** 96,101 ****
  {
    _rl_push_executing_macro ();
!   _rl_executing_macro = string;
    executing_macro_index = 0;
  }
  
--- 96,102 ----
  {
    _rl_push_executing_macro ();
!   rl_executing_macro = string;
    executing_macro_index = 0;
+   RL_SETSTATE(RL_STATE_MACROINPUT);
  }
  
***************
*** 105,112 ****
  _rl_next_macro_key ()
  {
!   if (_rl_executing_macro == 0)
      return (0);
  
!   if (_rl_executing_macro[executing_macro_index] == 0)
      {
        _rl_pop_executing_macro ();
--- 106,113 ----
  _rl_next_macro_key ()
  {
!   if (rl_executing_macro == 0)
      return (0);
  
!   if (rl_executing_macro[executing_macro_index] == 0)
      {
        _rl_pop_executing_macro ();
***************
*** 114,118 ****
      }
  
!   return (_rl_executing_macro[executing_macro_index++]);
  }
  
--- 115,119 ----
      }
  
!   return (rl_executing_macro[executing_macro_index++]);
  }
  
***************
*** 126,130 ****
    saver->next = macro_list;
    saver->sindex = executing_macro_index;
!   saver->string = _rl_executing_macro;
  
    macro_list = saver;
--- 127,131 ----
    saver->next = macro_list;
    saver->sindex = executing_macro_index;
!   saver->string = rl_executing_macro;
  
    macro_list = saver;
***************
*** 138,145 ****
    struct saved_macro *macro;
  
!   if (_rl_executing_macro)
!     free (_rl_executing_macro);
! 
!   _rl_executing_macro = (char *)NULL;
    executing_macro_index = 0;
  
--- 139,144 ----
    struct saved_macro *macro;
  
!   FREE (rl_executing_macro);
!   rl_executing_macro = (char *)NULL;
    executing_macro_index = 0;
  
***************
*** 147,155 ****
      {
        macro = macro_list;
!       _rl_executing_macro = macro_list->string;
        executing_macro_index = macro_list->sindex;
        macro_list = macro_list->next;
        free (macro);
      }
  }
  
--- 146,157 ----
      {
        macro = macro_list;
!       rl_executing_macro = macro_list->string;
        executing_macro_index = macro_list->sindex;
        macro_list = macro_list->next;
        free (macro);
      }
+ 
+   if (rl_executing_macro == 0)
+     RL_UNSETSTATE(RL_STATE_MACROINPUT);
  }
  
***************
*** 181,192 ****
    current_macro_size = current_macro_index = 0;
  
!   if (_rl_executing_macro)
!     {
!       free (_rl_executing_macro);
!       _rl_executing_macro = (char *) NULL;
!     }
    executing_macro_index = 0;
  
    _rl_defining_kbd_macro = 0;
  }
  
--- 183,192 ----
    current_macro_size = current_macro_index = 0;
  
!   FREE (rl_executing_macro);
!   rl_executing_macro = (char *) NULL;
    executing_macro_index = 0;
  
    _rl_defining_kbd_macro = 0;
+   RL_UNSETSTATE(RL_STATE_MACRODEF);
  }
  
***************
*** 216,219 ****
--- 216,220 ----
  
    _rl_defining_kbd_macro = 1;
+   RL_SETSTATE(RL_STATE_MACRODEF);
    return 0;
  }
***************
*** 236,239 ****
--- 237,241 ----
  
    _rl_defining_kbd_macro = 0;
+   RL_UNSETSTATE(RL_STATE_MACRODEF);
  
    return (rl_call_last_kbd_macro (--count, 0));
***************
*** 251,255 ****
    if (_rl_defining_kbd_macro)
      {
!       ding ();		/* no recursive macros */
        current_macro[--current_macro_index] = '\0';	/* erase this char */
        return 0;
--- 253,257 ----
    if (_rl_defining_kbd_macro)
      {
!       rl_ding ();		/* no recursive macros */
        current_macro[--current_macro_index] = '\0';	/* erase this char */
        return 0;
diff -Nrc2 bash-2.04/lib/readline/nls.c bash-2.05/lib/readline/nls.c
*** bash-2.04/lib/readline/nls.c	Thu Aug  5 08:09:55 1999
--- bash-2.05/lib/readline/nls.c	Fri Nov  3 11:44:27 2000
***************
*** 106,112 ****
       appropriate variables and set eight-bit mode if they have the right
       values. */
!   lspec = get_env_value ("LC_ALL");
!   if (lspec == 0) lspec = get_env_value ("LC_CTYPE");
!   if (lspec == 0) lspec = get_env_value ("LANG");
    if (lspec == 0 || (t = normalize_codeset (lspec)) == 0)
      return (0);
--- 106,112 ----
       appropriate variables and set eight-bit mode if they have the right
       values. */
!   lspec = sh_get_env_value ("LC_ALL");
!   if (lspec == 0) lspec = sh_get_env_value ("LC_CTYPE");
!   if (lspec == 0) lspec = sh_get_env_value ("LANG");
    if (lspec == 0 || (t = normalize_codeset (lspec)) == 0)
      return (0);
diff -Nrc2 bash-2.04/lib/readline/parens.c bash-2.05/lib/readline/parens.c
*** bash-2.04/lib/readline/parens.c	Thu Aug  5 08:10:08 1999
--- bash-2.05/lib/readline/parens.c	Wed Aug 30 15:10:45 2000
***************
*** 65,68 ****
--- 65,70 ----
  #endif /* !HAVE_SELECT */
  
+ static int _paren_blink_usec = 500000;
+ 
  /* Change emacs_standard_keymap to have bindings for paren matching when
     ON_OR_OFF is 1, change them back to self_insert when ON_OR_OFF == 0. */
***************
*** 86,89 ****
--- 88,103 ----
  
  int
+ rl_set_paren_blink_timeout (u)
+      int u;
+ {
+   int o;
+ 
+   o = _paren_blink_usec;
+   if (u > 0)
+     _paren_blink_usec = u;
+   return (o);
+ }
+ 
+ int
  rl_insert_close (count, invoking_key)
       int count, invoking_key;
***************
*** 110,114 ****
        FD_SET (fileno (rl_instream), &readfds);
        timer.tv_sec = 0;
!       timer.tv_usec = 500000;
  
        orig_point = rl_point;
--- 124,128 ----
        FD_SET (fileno (rl_instream), &readfds);
        timer.tv_sec = 0;
!       timer.tv_usec = _paren_blink_usec;
  
        orig_point = rl_point;
diff -Nrc2 bash-2.04/lib/readline/readline.c bash-2.05/lib/readline/readline.c
*** bash-2.04/lib/readline/readline.c	Thu Aug  5 08:10:46 1999
--- bash-2.05/lib/readline/readline.c	Mon Apr  2 15:56:20 2001
***************
*** 68,72 ****
  
  #ifndef RL_LIBRARY_VERSION
! #  define RL_LIBRARY_VERSION "4.1"
  #endif
  
--- 68,72 ----
  
  #ifndef RL_LIBRARY_VERSION
! #  define RL_LIBRARY_VERSION "4.2"
  #endif
  
***************
*** 91,96 ****
  /* **************************************************************** */
  
! char *rl_library_version = RL_LIBRARY_VERSION;
  
  int rl_gnu_readline_p = 1;
  
--- 91,97 ----
  /* **************************************************************** */
  
! const char *rl_library_version = RL_LIBRARY_VERSION;
  
+ /* True if this is `real' readline as opposed to some stub substitute. */
  int rl_gnu_readline_p = 1;
  
***************
*** 122,127 ****
--- 123,133 ----
  static int rl_initialized;
  
+ #if 0
  /* If non-zero, this program is running in an EMACS buffer. */
  static int running_in_emacs;
+ #endif
+ 
+ /* Flags word encapsulating the current readline state. */
+ int rl_readline_state = RL_STATE_NONE;
  
  /* The current offset in the current input line. */
***************
*** 138,142 ****
  
  /* The last function executed by readline. */
! Function *rl_last_func = (Function *)NULL;
  
  /* Top level environment for readline_internal (). */
--- 144,148 ----
  
  /* The last function executed by readline. */
! rl_command_func_t *rl_last_func = (rl_command_func_t *)NULL;
  
  /* Top level environment for readline_internal (). */
***************
*** 154,158 ****
  
  /* Current prompt. */
! char *rl_prompt;
  int rl_visible_prompt_length = 0;
  
--- 160,164 ----
  
  /* Current prompt. */
! char *rl_prompt = (char *)NULL;
  int rl_visible_prompt_length = 0;
  
***************
*** 166,175 ****
  /* If non-zero, then this is the address of a function to call just
     before readline_internal_setup () prints the first prompt. */
! Function *rl_startup_hook = (Function *)NULL;
  
  /* If non-zero, this is the address of a function to call just before
     readline_internal_setup () returns and readline_internal starts
     reading input characters. */
! Function *rl_pre_input_hook = (Function *)NULL;
  
  /* What we use internally.  You should always refer to RL_LINE_BUFFER. */
--- 172,181 ----
  /* If non-zero, then this is the address of a function to call just
     before readline_internal_setup () prints the first prompt. */
! rl_hook_func_t *rl_startup_hook = (rl_hook_func_t *)NULL;
  
  /* If non-zero, this is the address of a function to call just before
     readline_internal_setup () returns and readline_internal starts
     reading input characters. */
! rl_hook_func_t *rl_pre_input_hook = (rl_hook_func_t *)NULL;
  
  /* What we use internally.  You should always refer to RL_LINE_BUFFER. */
***************
*** 184,188 ****
  
  /* Pointer to a useful terminal name. */
! char *rl_terminal_name = (char *)NULL;
  
  /* Non-zero means to always use horizontal scrolling in line display. */
--- 190,194 ----
  
  /* Pointer to a useful terminal name. */
! const char *rl_terminal_name = (const char *)NULL;
  
  /* Non-zero means to always use horizontal scrolling in line display. */
***************
*** 244,265 ****
  int _rl_meta_flag = 0;	/* Forward declaration */
  
  /* Read a line of input.  Prompt with PROMPT.  An empty PROMPT means
     none.  A return value of NULL means that EOF was encountered. */
  char *
  readline (prompt)
!      char *prompt;
  {
    char *value;
  
-   rl_prompt = prompt;
- 
    /* If we are at EOF return a NULL string. */
    if (rl_pending_input == EOF)
      {
!       rl_pending_input = 0;
        return ((char *)NULL);
      }
  
!   rl_visible_prompt_length = rl_expand_prompt (rl_prompt);
  
    rl_initialize ();
--- 250,284 ----
  int _rl_meta_flag = 0;	/* Forward declaration */
  
+ /* Set up the prompt and expand it.  Called from readline() and
+    rl_callback_handler_install (). */
+ int
+ rl_set_prompt (prompt)
+      const char *prompt;
+ {
+   FREE (rl_prompt);
+   rl_prompt = prompt ? savestring (prompt) : (char *)NULL;
+ 
+   rl_visible_prompt_length = (rl_prompt && *rl_prompt)
+ 				? rl_expand_prompt (rl_prompt)
+ 				: 0;
+   return 0;
+ }
+   
  /* Read a line of input.  Prompt with PROMPT.  An empty PROMPT means
     none.  A return value of NULL means that EOF was encountered. */
  char *
  readline (prompt)
!      const char *prompt;
  {
    char *value;
  
    /* If we are at EOF return a NULL string. */
    if (rl_pending_input == EOF)
      {
!       rl_clear_pending_input ();
        return ((char *)NULL);
      }
  
!   rl_set_prompt (prompt);
  
    rl_initialize ();
***************
*** 349,353 ****
       rid of it now. */
    if (rl_undo_list)
!     free_undo_list ();
  
    return (eof ? (char *)NULL : savestring (the_line));
--- 368,372 ----
       rid of it now. */
    if (rl_undo_list)
!     rl_free_undo_list ();
  
    return (eof ? (char *)NULL : savestring (the_line));
***************
*** 385,389 ****
--- 404,410 ----
  	}
  
+       RL_SETSTATE(RL_STATE_READCMD);
        c = rl_read_key ();
+       RL_UNSETSTATE(RL_STATE_READCMD);
  
        /* EOF typed to a non-blank line is a <NL>. */
***************
*** 396,399 ****
--- 417,421 ----
  	{
  #if defined (READLINE_CALLBACKS)
+ 	  RL_SETSTATE(RL_STATE_DONE);
  	  return (rl_done = 1);
  #else
***************
*** 492,496 ****
    int r, newkey;
    char *macro;
!   Function *func;
  
    if (META_CHAR (key) && _rl_convert_meta_chars_to_ascii)
--- 514,518 ----
    int r, newkey;
    char *macro;
!   rl_command_func_t *func;
  
    if (META_CHAR (key) && _rl_convert_meta_chars_to_ascii)
***************
*** 506,510 ****
  	}
        else
! 	ding ();
        return 0;
      }
--- 528,532 ----
  	}
        else
! 	rl_ding ();
        return 0;
      }
***************
*** 518,522 ****
      case ISFUNC:
        func = map[key].function;
!       if (func != (Function *)NULL)
  	{
  	  /* Special case rl_do_lowercase_version (). */
--- 540,544 ----
      case ISFUNC:
        func = map[key].function;
!       if (func)
  	{
  	  /* Special case rl_do_lowercase_version (). */
***************
*** 531,535 ****
--- 553,559 ----
  
  	  rl_dispatching = 1;
+ 	  RL_SETSTATE(RL_STATE_DISPATCHING);
  	  r = (*map[key].function)(rl_numeric_arg * rl_arg_sign, key);
+ 	  RL_UNSETSTATE(RL_STATE_DISPATCHING);
  	  rl_dispatching = 0;
  
***************
*** 537,541 ****
  	     command.  Don't change the state of rl_last_func.  Otherwise,
  	     remember the last command executed in this variable. */
! 	  if (!rl_pending_input && map[key].function != rl_digit_argument)
  	    rl_last_func = map[key].function;
  	}
--- 561,565 ----
  	     command.  Don't change the state of rl_last_func.  Otherwise,
  	     remember the last command executed in this variable. */
! 	  if (rl_pending_input == 0 && map[key].function != rl_digit_argument)
  	    rl_last_func = map[key].function;
  	}
***************
*** 548,555 ****
  
      case ISKMAP:
!       if (map[key].function != (Function *)NULL)
  	{
  	  rl_key_sequence_length++;
  	  newkey = rl_read_key ();
  	  r = _rl_dispatch (newkey, FUNCTION_TO_KEYMAP (map, key));
  	}
--- 572,587 ----
  
      case ISKMAP:
!       if (map[key].function != 0)
  	{
  	  rl_key_sequence_length++;
+ 
+ 	  if (key == ESC)
+ 	    RL_SETSTATE(RL_STATE_METANEXT);
+ 	  RL_SETSTATE(RL_STATE_MOREINPUT);
  	  newkey = rl_read_key ();
+ 	  RL_UNSETSTATE(RL_STATE_MOREINPUT);
+ 	  if (key == ESC)
+ 	    RL_UNSETSTATE(RL_STATE_METANEXT);
+ 
  	  r = _rl_dispatch (newkey, FUNCTION_TO_KEYMAP (map, key));
  	}
***************
*** 562,566 ****
  
      case ISMACR:
!       if (map[key].function != (Function *)NULL)
  	{
  	  macro = savestring ((char *)map[key].function);
--- 594,598 ----
  
      case ISMACR:
!       if (map[key].function != 0)
  	{
  	  macro = savestring ((char *)map[key].function);
***************
*** 592,597 ****
--- 624,632 ----
    if (!rl_initialized)
      {
+       RL_SETSTATE(RL_STATE_INITIALIZING);
        readline_initialize_everything ();
+       RL_UNSETSTATE(RL_STATE_INITIALIZING);
        rl_initialized++;
+       RL_SETSTATE(RL_STATE_INITIALIZED);
      }
  
***************
*** 601,604 ****
--- 636,640 ----
    /* We aren't done yet.  We haven't even gotten started yet! */
    rl_done = 0;
+   RL_UNSETSTATE(RL_STATE_DONE);
  
    /* Tell the history routines what is going on. */
***************
*** 609,613 ****
  
    /* No such function typed yet. */
!   rl_last_func = (Function *)NULL;
  
    /* Parsing of key-bindings begins in an enabled state. */
--- 645,649 ----
  
    /* No such function typed yet. */
!   rl_last_func = (rl_command_func_t *)NULL;
  
    /* Parsing of key-bindings begins in an enabled state. */
***************
*** 659,664 ****
  #endif
  
!   /* Find out if we are running in Emacs. */
!   running_in_emacs = get_env_value ("EMACS") != (char *)0;
  
    /* Set up input and output if they are not already set up. */
--- 695,702 ----
  #endif
  
! #if 0
!   /* Find out if we are running in Emacs -- UNUSED. */
!   running_in_emacs = sh_get_env_value ("EMACS") != (char *)0;
! #endif
  
    /* Set up input and output if they are not already set up. */
***************
*** 680,684 ****
  
    /* Initialize the terminal interface. */
!   _rl_init_terminal_io ((char *)NULL);
  
    /* Bind tty characters to readline functions. */
--- 718,724 ----
  
    /* Initialize the terminal interface. */
!   if (rl_terminal_name == 0)
!     rl_terminal_name = sh_get_env_value ("TERM");
!   _rl_init_terminal_io (rl_terminal_name);
  
    /* Bind tty characters to readline functions. */
***************
*** 697,702 ****
    if (_rl_horizontal_scroll_mode && _rl_term_autowrap)
      {
!       screenwidth--;
!       screenchars -= screenheight;
      }
  
--- 737,742 ----
    if (_rl_horizontal_scroll_mode && _rl_term_autowrap)
      {
!       _rl_screenwidth--;
!       _rl_screenchars -= _rl_screenheight;
      }
  
***************
*** 724,728 ****
  readline_default_bindings ()
  {
!   rltty_set_default_bindings (_rl_keymap);
  }
  
--- 764,768 ----
  readline_default_bindings ()
  {
!   rl_tty_set_default_bindings (_rl_keymap);
  }
  
***************
*** 730,734 ****
  bind_arrow_keys_internal ()
  {
!   Function *f;
  
  #if defined (__MSDOS__)
--- 770,774 ----
  bind_arrow_keys_internal ()
  {
!   rl_command_func_t *f;
  
  #if defined (__MSDOS__)
***************
*** 798,801 ****
--- 838,842 ----
    rl_save_prompt ();
  
+   RL_SETSTATE(RL_STATE_NUMERICARG);
    sawminus = sawdigits = 0;
    while (1)
***************
*** 804,814 ****
  	{
  	  sawdigits = rl_explicit_arg = rl_numeric_arg = 0;
! 	  ding ();
  	  rl_restore_prompt ();
  	  rl_clear_message ();
  	  return 1;
  	}
        rl_message ("(arg: %d) ", rl_arg_sign * rl_numeric_arg);
        key = c = rl_read_key ();
  
        /* If we see a key bound to `universal-argument' after seeing digits,
--- 845,858 ----
  	{
  	  sawdigits = rl_explicit_arg = rl_numeric_arg = 0;
! 	  rl_ding ();
  	  rl_restore_prompt ();
  	  rl_clear_message ();
+ 	  RL_UNSETSTATE(RL_STATE_NUMERICARG);
  	  return 1;
  	}
        rl_message ("(arg: %d) ", rl_arg_sign * rl_numeric_arg);
+       RL_SETSTATE(RL_STATE_MOREINPUT);
        key = c = rl_read_key ();
+       RL_UNSETSTATE(RL_STATE_MOREINPUT);
  
        /* If we see a key bound to `universal-argument' after seeing digits,
***************
*** 824,830 ****
--- 868,877 ----
  	  else
  	    {
+ 	      RL_SETSTATE(RL_STATE_MOREINPUT);
  	      key = rl_read_key ();
+ 	      RL_UNSETSTATE(RL_STATE_MOREINPUT);
  	      rl_restore_prompt ();
  	      rl_clear_message ();
+ 	      RL_UNSETSTATE(RL_STATE_NUMERICARG);
  	      return (_rl_dispatch (key, _rl_keymap));
  	    }
***************
*** 850,857 ****
--- 897,906 ----
  	  rl_restore_prompt ();
  	  rl_clear_message ();
+ 	  RL_UNSETSTATE(RL_STATE_NUMERICARG);
  	  return (_rl_dispatch (key, _rl_keymap));
  	}
      }
  
+   RL_UNSETSTATE(RL_STATE_NUMERICARG);
    return 0;
  }
***************
*** 862,866 ****
       int ignore, key;
  {
!   rl_pending_input = key;
    return (rl_digit_loop ());
  }
--- 911,915 ----
       int ignore, key;
  {
!   rl_execute_next (key);
    return (rl_digit_loop ());
  }
***************
*** 870,874 ****
  rl_discard_argument ()
  {
!   ding ();
    rl_clear_message ();
    _rl_init_argument ();
--- 919,923 ----
  rl_discard_argument ()
  {
!   rl_ding ();
    rl_clear_message ();
    _rl_init_argument ();
***************
*** 907,911 ****
  int
  rl_insert_text (string)
!      char *string;
  {
    register int i, l = strlen (string);
--- 956,960 ----
  int
  rl_insert_text (string)
!      const char *string;
  {
    register int i, l = strlen (string);
***************
*** 1000,1004 ****
  void
  _rl_replace_text (text, start, end)
!      char *text;
       int start, end;
  {
--- 1049,1053 ----
  void
  _rl_replace_text (text, start, end)
!      const char *text;
       int start, end;
  {
***************
*** 1054,1058 ****
        int end = rl_point + count;
  #if defined (VI_MODE)
!       int lend = rl_end - (rl_editing_mode == vi_mode);
  #else
        int lend = rl_end;
--- 1103,1107 ----
        int end = rl_point + count;
  #if defined (VI_MODE)
!       int lend = rl_end > 0 ? rl_end - (rl_editing_mode == vi_mode) : rl_end;
  #else
        int lend = rl_end;
***************
*** 1062,1066 ****
  	{
  	  rl_point = lend;
! 	  ding ();
  	}
        else
--- 1111,1115 ----
  	{
  	  rl_point = lend;
! 	  rl_ding ();
  	}
        else
***************
*** 1086,1090 ****
  	{
  	  rl_point = 0;
! 	  ding ();
  	}
        else
--- 1135,1139 ----
  	{
  	  rl_point = 0;
! 	  rl_ding ();
  	}
        else
***************
*** 1133,1142 ****
  	 Then, move forward until we hit a non-alphabetic character. */
        c = the_line[rl_point];
!       if (alphabetic (c) == 0)
  	{
  	  while (++rl_point < rl_end)
  	    {
  	      c = the_line[rl_point];
! 	      if (alphabetic (c))
  		break;
  	    }
--- 1182,1191 ----
  	 Then, move forward until we hit a non-alphabetic character. */
        c = the_line[rl_point];
!       if (rl_alphabetic (c) == 0)
  	{
  	  while (++rl_point < rl_end)
  	    {
  	      c = the_line[rl_point];
! 	      if (rl_alphabetic (c))
  		break;
  	    }
***************
*** 1147,1151 ****
  	{
  	  c = the_line[rl_point];
! 	  if (alphabetic (c) == 0)
  	    break;
  	}
--- 1196,1200 ----
  	{
  	  c = the_line[rl_point];
! 	  if (rl_alphabetic (c) == 0)
  	    break;
  	}
***************
*** 1177,1186 ****
  
        c = the_line[rl_point - 1];
!       if (alphabetic (c) == 0)
  	{
  	  while (--rl_point)
  	    {
  	      c = the_line[rl_point - 1];
! 	      if (alphabetic (c))
  		break;
  	    }
--- 1226,1235 ----
  
        c = the_line[rl_point - 1];
!       if (rl_alphabetic (c) == 0)
  	{
  	  while (--rl_point)
  	    {
  	      c = the_line[rl_point - 1];
! 	      if (rl_alphabetic (c))
  		break;
  	    }
***************
*** 1190,1194 ****
  	{
  	  c = the_line[rl_point - 1];
! 	  if (alphabetic (c) == 0)
  	    break;
  	  else
--- 1239,1243 ----
  	{
  	  c = the_line[rl_point - 1];
! 	  if (rl_alphabetic (c) == 0)
  	    break;
  	  else
***************
*** 1246,1250 ****
--- 1295,1301 ----
    int ch;
  
+   RL_SETSTATE(RL_STATE_MOREINPUT);
    ch = rl_read_key ();
+   RL_UNSETSTATE(RL_STATE_MOREINPUT);
  
    switch (_rl_to_upper (ch))
***************
*** 1267,1271 ****
  
      default:
!       ding ();
      }
    return 0;
--- 1318,1322 ----
  
      default:
!       rl_ding ();
      }
    return 0;
***************
*** 1353,1357 ****
--- 1404,1412 ----
    _rl_disable_tty_signals ();
  #endif
+ 
+   RL_SETSTATE(RL_STATE_MOREINPUT);
    c = rl_read_key ();
+   RL_UNSETSTATE(RL_STATE_MOREINPUT);
+ 
  #if defined (HANDLE_SIGNALS)
    _rl_restore_tty_signals ();
***************
*** 1377,1380 ****
--- 1432,1436 ----
  {
    rl_done = 1;
+   RL_SETSTATE(RL_STATE_DONE);
  
  #if defined (VI_MODE)
***************
*** 1387,1391 ****
  
    /* If we've been asked to erase empty lines, suppress the final update,
!      since _rl_update_final calls crlf(). */
    if (rl_erase_empty_line && rl_point == 0 && rl_end == 0)
      return 0;
--- 1443,1447 ----
  
    /* If we've been asked to erase empty lines, suppress the final update,
!      since _rl_update_final calls rl_crlf(). */
    if (rl_erase_empty_line && rl_point == 0 && rl_end == 0)
      return 0;
***************
*** 1420,1424 ****
    if (!rl_point)
      {
!       ding ();
        return -1;
      }
--- 1476,1480 ----
    if (!rl_point)
      {
!       rl_ding ();
        return -1;
      }
***************
*** 1456,1460 ****
    if (rl_point == rl_end)
      {
!       ding ();
        return -1;
      }
--- 1512,1516 ----
    if (rl_point == rl_end)
      {
!       rl_ding ();
        return -1;
      }
***************
*** 1612,1620 ****
  	case CapCase:
  	  the_line[start] = (inword == 0) ? _rl_to_upper (c) : _rl_to_lower (c);
! 	  inword = alphabetic (the_line[start]);
  	  break;
  
  	default:
! 	  ding ();
  	  return -1;
  	}
--- 1668,1676 ----
  	case CapCase:
  	  the_line[start] = (inword == 0) ? _rl_to_upper (c) : _rl_to_lower (c);
! 	  inword = rl_alphabetic (the_line[start]);
  	  break;
  
  	default:
! 	  rl_ding ();
  	  return -1;
  	}
***************
*** 1655,1659 ****
    if ((w1_beg == w2_beg) || (w2_beg < w1_end))
      {
!       ding ();
        rl_point = orig_point;
        return -1;
--- 1711,1715 ----
    if ((w1_beg == w2_beg) || (w2_beg < w1_end))
      {
!       rl_ding ();
        rl_point = orig_point;
        return -1;
***************
*** 1703,1707 ****
    if (!rl_point || rl_end < 2)
      {
!       ding ();
        return -1;
      }
--- 1759,1763 ----
    if (!rl_point || rl_end < 2)
      {
!       rl_ding ();
        return -1;
      }
***************
*** 1747,1751 ****
        if ((dir < 0 && pos <= 0) || (dir > 0 && pos >= rl_end))
  	{
! 	  ding ();
  	  return -1;
  	}
--- 1803,1807 ----
        if ((dir < 0 && pos <= 0) || (dir > 0 && pos >= rl_end))
  	{
! 	  rl_ding ();
  	  return -1;
  	}
***************
*** 1778,1782 ****
--- 1834,1841 ----
    int c;
  
+   RL_SETSTATE(RL_STATE_MOREINPUT);
    c = rl_read_key ();
+   RL_UNSETSTATE(RL_STATE_MOREINPUT);
+ 
    if (count < 0)
      return (_rl_char_search_internal (-count, bdir, c));
***************
*** 1811,1815 ****
  /* While we are editing the history, this is the saved
     version of the original line. */
! HIST_ENTRY *saved_line_for_history = (HIST_ENTRY *)NULL;
  
  /* Set the history pointer back to the last entry in the history. */
--- 1870,1874 ----
  /* While we are editing the history, this is the saved
     version of the original line. */
! HIST_ENTRY *_rl_saved_line_for_history = (HIST_ENTRY *)NULL;
  
  /* Set the history pointer back to the last entry in the history. */
***************
*** 1818,1825 ****
  {
    using_history ();
!   if (saved_line_for_history)
!     _rl_free_history_entry (saved_line_for_history);
  
!   saved_line_for_history = (HIST_ENTRY *)NULL;
  }
  
--- 1877,1884 ----
  {
    using_history ();
!   if (_rl_saved_line_for_history)
!     _rl_free_history_entry (_rl_saved_line_for_history);
  
!   _rl_saved_line_for_history = (HIST_ENTRY *)NULL;
  }
  
***************
*** 1838,1842 ****
  /* Perhaps put back the current line if it has changed. */
  int
! maybe_replace_line ()
  {
    HIST_ENTRY *temp;
--- 1897,1901 ----
  /* Perhaps put back the current line if it has changed. */
  int
! rl_maybe_replace_line ()
  {
    HIST_ENTRY *temp;
***************
*** 1853,1893 ****
  }
  
! /* Put back the saved_line_for_history if there is one. */
  int
! maybe_unsave_line ()
  {
    int line_len;
  
!   if (saved_line_for_history)
      {
!       line_len = strlen (saved_line_for_history->line);
  
        if (line_len >= rl_line_buffer_len)
  	rl_extend_line_buffer (line_len);
  
!       strcpy (the_line, saved_line_for_history->line);
!       rl_undo_list = (UNDO_LIST *)saved_line_for_history->data;
!       _rl_free_history_entry (saved_line_for_history);
!       saved_line_for_history = (HIST_ENTRY *)NULL;
        rl_end = rl_point = strlen (the_line);
      }
    else
!     ding ();
    return 0;
  }
  
! /* Save the current line in saved_line_for_history. */
  int
! maybe_save_line ()
  {
!   if (saved_line_for_history == 0)
      {
!       saved_line_for_history = (HIST_ENTRY *)xmalloc (sizeof (HIST_ENTRY));
!       saved_line_for_history->line = savestring (the_line);
!       saved_line_for_history->data = (char *)rl_undo_list;
      }
    return 0;
  }
  
  /* **************************************************************** */
  /*								    */
--- 1912,1963 ----
  }
  
! /* Restore the _rl_saved_line_for_history if there is one. */
  int
! rl_maybe_unsave_line ()
  {
    int line_len;
  
!   if (_rl_saved_line_for_history)
      {
!       line_len = strlen (_rl_saved_line_for_history->line);
  
        if (line_len >= rl_line_buffer_len)
  	rl_extend_line_buffer (line_len);
  
!       strcpy (the_line, _rl_saved_line_for_history->line);
!       rl_undo_list = (UNDO_LIST *)_rl_saved_line_for_history->data;
!       _rl_free_history_entry (_rl_saved_line_for_history);
!       _rl_saved_line_for_history = (HIST_ENTRY *)NULL;
        rl_end = rl_point = strlen (the_line);
      }
    else
!     rl_ding ();
    return 0;
  }
  
! /* Save the current line in _rl_saved_line_for_history. */
  int
! rl_maybe_save_line ()
  {
!   if (_rl_saved_line_for_history == 0)
      {
!       _rl_saved_line_for_history = (HIST_ENTRY *)xmalloc (sizeof (HIST_ENTRY));
!       _rl_saved_line_for_history->line = savestring (the_line);
!       _rl_saved_line_for_history->data = (char *)rl_undo_list;
      }
    return 0;
  }
  
+ int
+ _rl_free_saved_history_line ()
+ {
+   if (_rl_saved_line_for_history)
+     {
+       _rl_free_history_entry (_rl_saved_line_for_history);
+       _rl_saved_line_for_history = (HIST_ENTRY *)NULL;
+     }
+   return 0;
+ }      
+ 
  /* **************************************************************** */
  /*								    */
***************
*** 1909,1915 ****
       int count, key;
  {
!   maybe_replace_line ();
    using_history ();
!   maybe_unsave_line ();
    return 0;
  }
--- 1979,1985 ----
       int count, key;
  {
!   rl_maybe_replace_line ();
    using_history ();
!   rl_maybe_unsave_line ();
    return 0;
  }
***************
*** 1929,1933 ****
      return 0;
  
!   maybe_replace_line ();
  
    temp = (HIST_ENTRY *)NULL;
--- 1999,2003 ----
      return 0;
  
!   rl_maybe_replace_line ();
  
    temp = (HIST_ENTRY *)NULL;
***************
*** 1941,1945 ****
  
    if (temp == 0)
!     maybe_unsave_line ();
    else
      {
--- 2011,2015 ----
  
    if (temp == 0)
!     rl_maybe_unsave_line ();
    else
      {
***************
*** 1976,1983 ****
  
    /* If we don't have a line saved, then save this one. */
!   maybe_save_line ();
  
    /* If the current line has changed, save the changes. */
!   maybe_replace_line ();
  
    temp = old_temp = (HIST_ENTRY *)NULL;
--- 2046,2053 ----
  
    /* If we don't have a line saved, then save this one. */
!   rl_maybe_save_line ();
  
    /* If the current line has changed, save the changes. */
!   rl_maybe_replace_line ();
  
    temp = old_temp = (HIST_ENTRY *)NULL;
***************
*** 1998,2002 ****
  
    if (temp == 0)
!     ding ();
    else
      {
--- 2068,2072 ----
  
    if (temp == 0)
!     rl_ding ();
    else
      {
***************
*** 2054,2058 ****
    if (rl_mark == -1)
      {
!       ding ();
        return -1;
      }
--- 2124,2128 ----
    if (rl_mark == -1)
      {
!       rl_ding ();
        return -1;
      }
diff -Nrc2 bash-2.04/lib/readline/readline.h bash-2.05/lib/readline/readline.h
*** bash-2.04/lib/readline/readline.h	Thu Aug  5 08:10:59 1999
--- bash-2.05/lib/readline/readline.h	Wed Feb 14 16:27:54 2001
***************
*** 61,66 ****
  /* The data structure for mapping textual names to code addresses. */
  typedef struct _funmap {
!   char *name;
!   Function *function;
  } FUNMAP;
  
--- 61,66 ----
  /* The data structure for mapping textual names to code addresses. */
  typedef struct _funmap {
!   const char *name;
!   rl_command_func_t *function;
  } FUNMAP;
  
***************
*** 156,161 ****
  extern int rl_yank_nth_arg __P((int, int));
  extern int rl_yank_last_arg __P((int, int));
! /* Not available unless __CYGWIN32__ is defined. */
! #ifdef __CYGWIN32__
  extern int rl_paste_from_clipboard __P((int, int));
  #endif
--- 156,161 ----
  extern int rl_yank_nth_arg __P((int, int));
  extern int rl_yank_last_arg __P((int, int));
! /* Not available unless __CYGWIN__ is defined. */
! #ifdef __CYGWIN__
  extern int rl_paste_from_clipboard __P((int, int));
  #endif
***************
*** 197,201 ****
  
  /* Not available unless READLINE_CALLBACKS is defined. */
! extern void rl_callback_handler_install __P((char *, VFunction *));
  extern void rl_callback_read_char __P((void));
  extern void rl_callback_handler_remove __P((void));
--- 197,201 ----
  
  /* Not available unless READLINE_CALLBACKS is defined. */
! extern void rl_callback_handler_install __P((const char *, rl_vcpfunc_t *));
  extern void rl_callback_read_char __P((void));
  extern void rl_callback_handler_remove __P((void));
***************
*** 261,295 ****
  /* Readline functions. */
  /* Read a line of input.  Prompt with PROMPT.  A NULL PROMPT means none. */
! extern char *readline __P((char *));
  
  extern int rl_initialize __P((void));
  
  extern int rl_discard_argument __P((void));
  
  /* Utility functions to bind keys to readline commands. */
! extern int rl_add_defun __P((char *, Function *, int));
! extern int rl_bind_key __P((int, Function *));
! extern int rl_bind_key_in_map __P((int, Function *, Keymap));
  extern int rl_unbind_key __P((int));
  extern int rl_unbind_key_in_map __P((int, Keymap));
! extern int rl_unbind_function_in_map __P((Function *, Keymap));
! extern int rl_unbind_command_in_map __P((char *, Keymap));
! extern int rl_set_key __P((char *, Function *, Keymap));
! extern int rl_generic_bind __P((int, char *, char *, Keymap));
! extern int rl_variable_bind __P((char *, char *));
  
  /* Backwards compatibility, use rl_generic_bind instead. */
! extern int rl_macro_bind __P((char *, char *, Keymap));
  
  /* Undocumented in the texinfo manual; not really useful to programs. */
! extern int rl_translate_keyseq __P((char *, char *, int *));
  extern char *rl_untranslate_keyseq __P((int));
  
! extern Function *rl_named_function __P((char *));
! extern Function *rl_function_of_keyseq __P((char *, Keymap, int *));
  
  extern void rl_list_funmap_names __P((void));
! extern char **rl_invoking_keyseqs_in_map __P((Function *, Keymap));
! extern char **rl_invoking_keyseqs __P((Function *));
   
  extern void rl_function_dumper __P((int));
--- 261,299 ----
  /* Readline functions. */
  /* Read a line of input.  Prompt with PROMPT.  A NULL PROMPT means none. */
! extern char *readline __P((const char *));
! 
! extern int rl_set_prompt __P((const char *));
! extern int rl_expand_prompt __P((char *));
  
  extern int rl_initialize __P((void));
  
+ /* Undocumented; unused by readline */
  extern int rl_discard_argument __P((void));
  
  /* Utility functions to bind keys to readline commands. */
! extern int rl_add_defun __P((const char *, rl_command_func_t *, int));
! extern int rl_bind_key __P((int, rl_command_func_t *));
! extern int rl_bind_key_in_map __P((int, rl_command_func_t *, Keymap));
  extern int rl_unbind_key __P((int));
  extern int rl_unbind_key_in_map __P((int, Keymap));
! extern int rl_unbind_function_in_map __P((rl_command_func_t *, Keymap));
! extern int rl_unbind_command_in_map __P((const char *, Keymap));
! extern int rl_set_key __P((const char *, rl_command_func_t *, Keymap));
! extern int rl_generic_bind __P((int, const char *, char *, Keymap));
! extern int rl_variable_bind __P((const char *, const char *));
  
  /* Backwards compatibility, use rl_generic_bind instead. */
! extern int rl_macro_bind __P((const char *, const char *, Keymap));
  
  /* Undocumented in the texinfo manual; not really useful to programs. */
! extern int rl_translate_keyseq __P((const char *, char *, int *));
  extern char *rl_untranslate_keyseq __P((int));
  
! extern rl_command_func_t *rl_named_function __P((const char *));
! extern rl_command_func_t *rl_function_of_keyseq __P((const char *, Keymap, int *));
  
  extern void rl_list_funmap_names __P((void));
! extern char **rl_invoking_keyseqs_in_map __P((rl_command_func_t *, Keymap));
! extern char **rl_invoking_keyseqs __P((rl_command_func_t *));
   
  extern void rl_function_dumper __P((int));
***************
*** 297,301 ****
  extern void rl_variable_dumper __P((int));
  
! extern int rl_read_init_file __P((char *));
  extern int rl_parse_and_bind __P((char *));
  
--- 301,305 ----
  extern void rl_variable_dumper __P((int));
  
! extern int rl_read_init_file __P((const char *));
  extern int rl_parse_and_bind __P((char *));
  
***************
*** 306,320 ****
  extern void rl_discard_keymap __P((Keymap));
  
! extern Keymap rl_get_keymap_by_name __P((char *));
  extern char *rl_get_keymap_name __P((Keymap));
  extern void rl_set_keymap __P((Keymap));
  extern Keymap rl_get_keymap __P((void));
  extern void rl_set_keymap_from_edit_mode __P((void));
  extern char *rl_get_keymap_name_from_edit_mode __P((void));
  
  /* Functions for manipulating the funmap, which maps command names to functions. */
! extern int rl_add_funmap_entry __P((char *, Function *));
  extern void rl_initialize_funmap __P((void));
- extern char **rl_funmap_names __P((void));
  
  /* Utility functions for managing keyboard macros. */
--- 310,327 ----
  extern void rl_discard_keymap __P((Keymap));
  
! extern Keymap rl_get_keymap_by_name __P((const char *));
  extern char *rl_get_keymap_name __P((Keymap));
  extern void rl_set_keymap __P((Keymap));
  extern Keymap rl_get_keymap __P((void));
+ /* Undocumented; used internally only. */
  extern void rl_set_keymap_from_edit_mode __P((void));
  extern char *rl_get_keymap_name_from_edit_mode __P((void));
  
  /* Functions for manipulating the funmap, which maps command names to functions. */
! extern int rl_add_funmap_entry __P((const char *, rl_command_func_t *));
! extern const char **rl_funmap_names __P((void));
! /* Undocumented, only used internally -- there is only one funmap, and this
!    function may be called only once. */
  extern void rl_initialize_funmap __P((void));
  
  /* Utility functions for managing keyboard macros. */
***************
*** 323,327 ****
  /* Functions for undoing, from undo.c */
  extern void rl_add_undo __P((enum undo_code, int, int, char *));
! extern void free_undo_list __P((void));
  extern int rl_do_undo __P((void));
  extern int rl_begin_undo_group __P((void));
--- 330,334 ----
  /* Functions for undoing, from undo.c */
  extern void rl_add_undo __P((enum undo_code, int, int, char *));
! extern void rl_free_undo_list __P((void));
  extern int rl_do_undo __P((void));
  extern int rl_begin_undo_group __P((void));
***************
*** 336,339 ****
--- 343,347 ----
  extern int rl_clear_message __P((void));
  extern int rl_reset_line_state __P((void));
+ extern int rl_crlf __P((void));
  
  #if (defined (__STDC__) || defined (__cplusplus)) && defined (USE_VARARGS) && defined (PREFER_STDARG)
***************
*** 343,350 ****
  #endif
  
- /* Undocumented in texinfo manual. */
  extern int rl_show_char __P((int));
  extern int rl_character_len __P((int, int));
- extern int crlf __P((void));
  
  /* Save and restore internal prompt redisplay information. */
--- 351,358 ----
  #endif
  
  extern int rl_show_char __P((int));
+ 
+ /* Undocumented in texinfo manual. */
  extern int rl_character_len __P((int, int));
  
  /* Save and restore internal prompt redisplay information. */
***************
*** 353,357 ****
  
  /* Modifying text. */
! extern int rl_insert_text __P((char *));
  extern int rl_delete_text __P((int, int));
  extern int rl_kill_text __P((int, int));
--- 361,365 ----
  
  /* Modifying text. */
! extern int rl_insert_text __P((const char *));
  extern int rl_delete_text __P((int, int));
  extern int rl_kill_text __P((int, int));
***************
*** 361,378 ****
  extern void rl_prep_terminal __P((int));
  extern void rl_deprep_terminal __P((void));
! extern void rltty_set_default_bindings __P((Keymap));
  
! extern int rl_reset_terminal __P((char *));
  extern void rl_resize_terminal __P((void));
! 
! /* `Public' utility functions . */
! extern void rl_extend_line_buffer __P((int));
! extern int ding __P((void));
  
  /* Functions for character input. */
  extern int rl_stuff_char __P((int));
  extern int rl_execute_next __P((int));
  extern int rl_read_key __P((void));
  extern int rl_getc __P((FILE *));
  
  /* Readline signal handling, from signals.c */
--- 369,391 ----
  extern void rl_prep_terminal __P((int));
  extern void rl_deprep_terminal __P((void));
! extern void rl_tty_set_default_bindings __P((Keymap));
  
! extern int rl_reset_terminal __P((const char *));
  extern void rl_resize_terminal __P((void));
! extern void rl_set_screen_size __P((int, int));
! extern void rl_get_screen_size __P((int *, int *));
  
  /* Functions for character input. */
  extern int rl_stuff_char __P((int));
  extern int rl_execute_next __P((int));
+ extern int rl_clear_pending_input __P((void));
  extern int rl_read_key __P((void));
  extern int rl_getc __P((FILE *));
+ extern int rl_set_keyboard_input_timeout __P((int));
+ 
+ /* `Public' utility functions . */
+ extern void rl_extend_line_buffer __P((int));
+ extern int rl_ding __P((void));
+ extern int rl_alphabetic __P((int));
  
  /* Readline signal handling, from signals.c */
***************
*** 384,392 ****
   
  /* Undocumented. */
! extern int rl_expand_prompt __P((char *));
  
! extern int maybe_save_line __P((void));
! extern int maybe_unsave_line __P((void));
! extern int maybe_replace_line __P((void));
  
  /* Completion functions. */
--- 397,406 ----
   
  /* Undocumented. */
! extern int rl_set_paren_blink_timeout __P((int));
  
! /* Undocumented. */
! extern int rl_maybe_save_line __P((void));
! extern int rl_maybe_unsave_line __P((void));
! extern int rl_maybe_replace_line __P((void));
  
  /* Completion functions. */
***************
*** 394,400 ****
  extern void rl_display_match_list __P((char **, int, int));
  
! extern char **completion_matches __P((char *, CPFunction *));
! extern char *username_completion_function __P((char *, int));
! extern char *filename_completion_function __P((char *, int));
  
  /* **************************************************************** */
--- 408,430 ----
  extern void rl_display_match_list __P((char **, int, int));
  
! extern char **rl_completion_matches __P((const char *, rl_compentry_func_t *));
! extern char *rl_username_completion_function __P((const char *, int));
! extern char *rl_filename_completion_function __P((const char *, int));
! 
! #if 0
! /* Backwards compatibility (compat.c).  These will go away sometime. */
! extern void free_undo_list __P((void));
! extern int maybe_save_line __P((void));
! extern int maybe_unsave_line __P((void));
! extern int maybe_replace_line __P((void));
! 
! extern int ding __P((void));
! extern int alphabetic __P((int));
! extern int crlf __P((void));
! 
! extern char **completion_matches __P((char *, rl_compentry_func_t *));
! extern char *username_completion_function __P((const char *, int));
! extern char *filename_completion_function __P((const char *, int));
! #endif
  
  /* **************************************************************** */
***************
*** 405,416 ****
  
  /* The version of this incarnation of the readline library. */
! extern char *rl_library_version;
  
  /* True if this is real GNU readline. */
  extern int rl_gnu_readline_p;
  
  /* The name of the calling program.  You should initialize this to
     whatever was in argv[0].  It is used when parsing conditionals. */
! extern char *rl_readline_name;
  
  /* The prompt readline uses.  This is set from the argument to
--- 435,453 ----
  
  /* The version of this incarnation of the readline library. */
! extern const char *rl_library_version;
  
  /* True if this is real GNU readline. */
  extern int rl_gnu_readline_p;
  
+ /* Flags word encapsulating the current readline state. */
+ extern int rl_readline_state;
+ 
+ /* Says which editing mode readline is currently using.  1 means emacs mode;
+    0 means vi mode. */
+ extern int rl_editing_mode;
+ 
  /* The name of the calling program.  You should initialize this to
     whatever was in argv[0].  It is used when parsing conditionals. */
! extern const char *rl_readline_name;
  
  /* The prompt readline uses.  This is set from the argument to
***************
*** 422,426 ****
  
  /* The location of point, and end. */
! extern int rl_point, rl_end;
  
  /* The mark, or saved cursor position. */
--- 459,464 ----
  
  /* The location of point, and end. */
! extern int rl_point;
! extern int rl_end;
  
  /* The mark, or saved cursor position. */
***************
*** 439,465 ****
  extern int rl_dispatching;
  
  /* The name of the terminal to use. */
! extern char *rl_terminal_name;
  
  /* The input and output streams. */
! extern FILE *rl_instream, *rl_outstream;
  
  /* If non-zero, then this is the address of a function to call just
     before readline_internal () prints the first prompt. */
! extern Function *rl_startup_hook;
  
  /* If non-zero, this is the address of a function to call just before
     readline_internal_setup () returns and readline_internal starts
     reading input characters. */
! extern Function *rl_pre_input_hook;
        
  /* The address of a function to call periodically while Readline is
     awaiting character input, or NULL, for no event handling. */
! extern Function *rl_event_hook;
  
! extern Function *rl_getc_function;
! extern VFunction *rl_redisplay_function;
! extern VFunction *rl_prep_term_function;
! extern VFunction *rl_deprep_term_function;
  
  /* Dispatch variables. */
--- 477,518 ----
  extern int rl_dispatching;
  
+ /* Non-zero if the user typed a numeric argument before executing the
+    current function. */
+ extern int rl_explicit_arg;
+ 
+ /* The current value of the numeric argument specified by the user. */
+ extern int rl_numeric_arg;
+ 
+ /* The address of the last command function Readline executed. */
+ extern rl_command_func_t *rl_last_func;
+ 
  /* The name of the terminal to use. */
! extern const char *rl_terminal_name;
  
  /* The input and output streams. */
! extern FILE *rl_instream;
! extern FILE *rl_outstream;
  
  /* If non-zero, then this is the address of a function to call just
     before readline_internal () prints the first prompt. */
! extern rl_hook_func_t *rl_startup_hook;
  
  /* If non-zero, this is the address of a function to call just before
     readline_internal_setup () returns and readline_internal starts
     reading input characters. */
! extern rl_hook_func_t *rl_pre_input_hook;
        
  /* The address of a function to call periodically while Readline is
     awaiting character input, or NULL, for no event handling. */
! extern rl_hook_func_t *rl_event_hook;
! 
! /* The address of the function to call to fetch a character from the current
!    Readline input stream */
! extern rl_getc_func_t *rl_getc_function;
  
! extern rl_voidfunc_t *rl_redisplay_function;
! 
! extern rl_vintfunc_t *rl_prep_term_function;
! extern rl_voidfunc_t *rl_deprep_term_function;
  
  /* Dispatch variables. */
***************
*** 482,485 ****
--- 535,541 ----
  extern int rl_num_chars_to_read;
  
+ /* The text of a currently-executing keyboard macro. */
+ extern char *rl_executing_macro;
+ 
  /* Variables to control readline signal handling. */
  /* If non-zero, readline will install its own signal handlers for
***************
*** 498,502 ****
     NULL means to use filename_entry_function (), the default filename
     completer. */
! extern Function *rl_completion_entry_function;
  
  /* If rl_ignore_some_completions_function is non-NULL it is the address
--- 554,558 ----
     NULL means to use filename_entry_function (), the default filename
     completer. */
! extern rl_compentry_func_t *rl_completion_entry_function;
  
  /* If rl_ignore_some_completions_function is non-NULL it is the address
***************
*** 506,510 ****
     of (char *).  If your function removes any of the elements, they
     must be free()'ed. */
! extern Function *rl_ignore_some_completions_function;
  
  /* Pointer to alternative function to create matches.
--- 562,566 ----
     of (char *).  If your function removes any of the elements, they
     must be free()'ed. */
! extern rl_compignore_func_t *rl_ignore_some_completions_function;
  
  /* Pointer to alternative function to create matches.
***************
*** 515,529 ****
     rl_completion_entry_function to try to match, otherwise use the
     array of strings returned. */
! extern CPPFunction *rl_attempted_completion_function;
  
  /* The basic list of characters that signal a break between words for the
     completer routine.  The initial contents of this variable is what
     breaks words in the shell, i.e. "n\"\\'`@$>". */
! extern char *rl_basic_word_break_characters;
  
  /* The list of characters that signal a break between words for
     rl_complete_internal.  The default list is the contents of
     rl_basic_word_break_characters.  */
! extern char *rl_completer_word_break_characters;
  
  /* List of characters which can be used to quote a substring of the line.
--- 571,585 ----
     rl_completion_entry_function to try to match, otherwise use the
     array of strings returned. */
! extern rl_completion_func_t *rl_attempted_completion_function;
  
  /* The basic list of characters that signal a break between words for the
     completer routine.  The initial contents of this variable is what
     breaks words in the shell, i.e. "n\"\\'`@$>". */
! extern const char *rl_basic_word_break_characters;
  
  /* The list of characters that signal a break between words for
     rl_complete_internal.  The default list is the contents of
     rl_basic_word_break_characters.  */
! extern const char *rl_completer_word_break_characters;
  
  /* List of characters which can be used to quote a substring of the line.
***************
*** 531,551 ****
     rl_completer_word_break_characters are treated as any other character,
     unless they also appear within this list. */
! extern char *rl_completer_quote_characters;
  
  /* List of quote characters which cause a word break. */
! extern char *rl_basic_quote_characters;
  
  /* List of characters that need to be quoted in filenames by the completer. */
! extern char *rl_filename_quote_characters;
  
  /* List of characters that are word break characters, but should be left
     in TEXT when it is passed to the completion function.  The shell uses
     this to help determine what kind of completing to do. */
! extern char *rl_special_prefixes;
  
  /* If non-zero, then this is the address of a function to call when
     completing on a directory name.  The function is called with
!    the address of a string (the current directory name) as an arg. */
! extern Function *rl_directory_completion_hook;
  
  /* Backwards compatibility with previous versions of readline. */
--- 587,618 ----
     rl_completer_word_break_characters are treated as any other character,
     unless they also appear within this list. */
! extern const char *rl_completer_quote_characters;
  
  /* List of quote characters which cause a word break. */
! extern const char *rl_basic_quote_characters;
  
  /* List of characters that need to be quoted in filenames by the completer. */
! extern const char *rl_filename_quote_characters;
  
  /* List of characters that are word break characters, but should be left
     in TEXT when it is passed to the completion function.  The shell uses
     this to help determine what kind of completing to do. */
! extern const char *rl_special_prefixes;
  
  /* If non-zero, then this is the address of a function to call when
     completing on a directory name.  The function is called with
!    the address of a string (the current directory name) as an arg.  It
!    changes what is displayed when the possible completions are printed
!    or inserted. */
! extern rl_icppfunc_t *rl_directory_completion_hook;
! 
! /* If non-zero, this is the address of a function to call when completing
!    a directory name.  This function takes the address of the directory name
!    to be modified as an argument.  Unlike rl_directory_completion_hook, it
!    only modifies the directory name used in opendir(2), not what is displayed
!    when the possible completions are printed or inserted.  It is called
!    before rl_directory_completion_hook.  I'm not happy with how this works
!    yet, so it's undocumented. */
! extern rl_icppfunc_t *rl_directory_rewrite_hook;
  
  /* Backwards compatibility with previous versions of readline. */
***************
*** 559,563 ****
     number of strings in that array, and MAX_LENGTH is the length of the
     longest string in that array. */
! extern VFunction *rl_completion_display_matches_hook;
  
  /* Non-zero means that the results of the matches are to be treated
--- 626,630 ----
     number of strings in that array, and MAX_LENGTH is the length of the
     longest string in that array. */
! extern rl_compdisp_func_t *rl_completion_display_matches_hook;
  
  /* Non-zero means that the results of the matches are to be treated
***************
*** 577,591 ****
     and a pointer to the quoting character to be used, which the function can
     reset if desired. */
! extern CPFunction *rl_filename_quoting_function;
  
  /* Function to call to remove quoting characters from a filename.  Called
     before completion is attempted, so the embedded quotes do not interfere
     with matching names in the file system. */
! extern CPFunction *rl_filename_dequoting_function;
  
  /* Function to call to decide whether or not a word break character is
     quoted.  If a character is quoted, it does not break words for the
     completer. */
! extern Function *rl_char_is_quoted_p;
  
  /* Non-zero means to suppress normal filename completion after the
--- 644,658 ----
     and a pointer to the quoting character to be used, which the function can
     reset if desired. */
! extern rl_quote_func_t *rl_filename_quoting_function;
  
  /* Function to call to remove quoting characters from a filename.  Called
     before completion is attempted, so the embedded quotes do not interfere
     with matching names in the file system. */
! extern rl_dequote_func_t *rl_filename_dequoting_function;
  
  /* Function to call to decide whether or not a word break character is
     quoted.  If a character is quoted, it does not break words for the
     completer. */
! extern rl_linebuf_func_t *rl_char_is_quoted_p;
  
  /* Non-zero means to suppress normal filename completion after the
***************
*** 624,630 ****
  #define MULT_MATCH      2
  
! #if !defined (savestring)
! extern char *savestring __P((char *));	/* XXX backwards compatibility */
! #endif
  
  #ifdef __cplusplus
--- 691,721 ----
  #define MULT_MATCH      2
  
! /* Possible state values for rl_readline_state */
! #define RL_STATE_NONE		0x00000		/* no state; before first call */
! 
! #define RL_STATE_INITIALIZING	0x00001		/* initializing */
! #define RL_STATE_INITIALIZED	0x00002		/* initialization done */
! #define RL_STATE_TERMPREPPED	0x00004		/* terminal is prepped */
! #define RL_STATE_READCMD	0x00008		/* reading a command key */
! #define RL_STATE_METANEXT	0x00010		/* reading input after ESC */
! #define RL_STATE_DISPATCHING	0x00020		/* dispatching to a command */
! #define RL_STATE_MOREINPUT	0x00040		/* reading more input in a command function */
! #define RL_STATE_ISEARCH	0x00080		/* doing incremental search */
! #define RL_STATE_NSEARCH	0x00100		/* doing non-inc search */
! #define RL_STATE_SEARCH		0x00200		/* doing a history search */
! #define RL_STATE_NUMERICARG	0x00400		/* reading numeric argument */
! #define RL_STATE_MACROINPUT	0x00800		/* getting input from a macro */
! #define RL_STATE_MACRODEF	0x01000		/* defining keyboard macro */
! #define RL_STATE_OVERWRITE	0x02000		/* overwrite mode */
! #define RL_STATE_COMPLETING	0x04000		/* doing completion */
! #define RL_STATE_SIGHANDLER	0x08000		/* in readline sighandler */
! #define RL_STATE_UNDOING	0x10000		/* doing an undo */
! #define RL_STATE_INPUTPENDING	0x20000		/* rl_execute_next called */
! 
! #define RL_STATE_DONE		0x80000		/* done; accepted line */
! 
! #define RL_SETSTATE(x)		(rl_readline_state |= (x))
! #define RL_UNSETSTATE(x)	(rl_readline_state &= ~(x))
! #define RL_ISSTATE(x)		(rl_readline_state & (x))
  
  #ifdef __cplusplus
diff -Nrc2 bash-2.04/lib/readline/rldefs.h bash-2.05/lib/readline/rldefs.h
*** bash-2.04/lib/readline/rldefs.h	Thu Aug  5 08:11:28 1999
--- bash-2.05/lib/readline/rldefs.h	Wed Nov  8 10:50:32 2000
***************
*** 31,34 ****
--- 31,36 ----
  #endif
  
+ #include "rlstdc.h"
+ 
  #if defined (_POSIX_VERSION) && !defined (TERMIOS_MISSING)
  #  define TERMIOS_TTY_DRIVER
***************
*** 72,76 ****
  #define _rl_strnicmp strncasecmp
  #else
! extern int _rl_stricmp (), _rl_strnicmp ();
  #endif
  
--- 74,79 ----
  #define _rl_strnicmp strncasecmp
  #else
! extern int _rl_stricmp __P((char *, char *);
! extern int _rl_strnicmp __P((char *, char *));
  #endif
  
***************
*** 88,99 ****
  #if defined (CRAY)
  #  define FUNCTION_TO_KEYMAP(map, key)	(Keymap)((int)map[key].function)
! #  define KEYMAP_TO_FUNCTION(data)	(Function *)((int)(data))
  #else
  #  define FUNCTION_TO_KEYMAP(map, key)	(Keymap)(map[key].function)
! #  define KEYMAP_TO_FUNCTION(data)	(Function *)(data)
  #endif
  
  #ifndef savestring
! extern char *xmalloc ();
  #define savestring(x) strcpy (xmalloc (1 + strlen (x)), (x))
  #endif
--- 91,102 ----
  #if defined (CRAY)
  #  define FUNCTION_TO_KEYMAP(map, key)	(Keymap)((int)map[key].function)
! #  define KEYMAP_TO_FUNCTION(data)	(rl_command_func_t *)((int)(data))
  #else
  #  define FUNCTION_TO_KEYMAP(map, key)	(Keymap)(map[key].function)
! #  define KEYMAP_TO_FUNCTION(data)	(rl_command_func_t *)(data)
  #endif
  
  #ifndef savestring
! extern char *xmalloc __P((int));
  #define savestring(x) strcpy (xmalloc (1 + strlen (x)), (x))
  #endif
diff -Nrc2 bash-2.04/lib/readline/rlprivate.h bash-2.05/lib/readline/rlprivate.h
*** bash-2.04/lib/readline/rlprivate.h	Mon Jan 24 10:40:34 2000
--- bash-2.05/lib/readline/rlprivate.h	Wed Feb 14 07:43:14 2001
***************
*** 36,40 ****
  
  /* terminal.c */
! extern char *rl_get_termcap __P((char *));
  
  /*************************************************************************
--- 36,40 ----
  
  /* terminal.c */
! extern char *rl_get_termcap __P((const char *));
  
  /*************************************************************************
***************
*** 52,61 ****
  /* readline.c */
  extern int rl_line_buffer_len;
- extern int rl_numeric_arg;
  extern int rl_arg_sign;
- extern int rl_explicit_arg;
- extern int rl_editing_mode;
  extern int rl_visible_prompt_length;
- extern Function *rl_last_func;
  extern int readline_echoing_p;
  extern int rl_key_sequence_length;
--- 52,57 ----
***************
*** 92,96 ****
  
  /* util.c */
! extern char *_rl_savestring __P((char *));
  
  /*************************************************************************
--- 88,92 ----
  
  /* util.c */
! extern char *_rl_savestring __P((const char *));
  
  /*************************************************************************
***************
*** 119,127 ****
  
  /* bind.c */
! extern void _rl_bind_if_unbound __P((char *, Function *));
  
  /* display.c */
  extern char *_rl_strip_prompt __P((char *));
! extern void _rl_move_cursor_relative __P((int, char *));
  extern void _rl_move_vert __P((int));
  extern void _rl_save_prompt __P((void));
--- 115,123 ----
  
  /* bind.c */
! extern void _rl_bind_if_unbound __P((const char *, rl_command_func_t *));
  
  /* display.c */
  extern char *_rl_strip_prompt __P((char *));
! extern void _rl_move_cursor_relative __P((int, const char *));
  extern void _rl_move_vert __P((int));
  extern void _rl_save_prompt __P((void));
***************
*** 135,139 ****
  extern void _rl_clean_up_for_exit __P((void));
  extern void _rl_erase_entire_line __P((void));
! extern int _rl_currentb_display_line __P((void));
  
  /* input.c */
--- 131,135 ----
  extern void _rl_clean_up_for_exit __P((void));
  extern void _rl_erase_entire_line __P((void));
! extern int _rl_current_display_line __P((void));
  
  /* input.c */
***************
*** 162,168 ****
  extern int _rl_init_argument __P((void));
  extern void _rl_fix_point __P((int));
! extern void _rl_replace_text __P((char *, int, int));
  extern int _rl_char_search_internal __P((int, int, int));
  extern int _rl_set_mark_at_pos __P((int));
  
  /* rltty.c */
--- 158,165 ----
  extern int _rl_init_argument __P((void));
  extern void _rl_fix_point __P((int));
! extern void _rl_replace_text __P((const char *, int, int));
  extern int _rl_char_search_internal __P((int, int, int));
  extern int _rl_set_mark_at_pos __P((int));
+ extern int _rl_free_saved_history_line __P((void));
  
  /* rltty.c */
***************
*** 172,176 ****
  /* terminal.c */
  extern void _rl_get_screen_size __P((int, int));
! extern int _rl_init_terminal_io __P((char *));
  #ifdef _MINIX
  extern void _rl_output_character_function __P((int));
--- 169,173 ----
  /* terminal.c */
  extern void _rl_get_screen_size __P((int, int));
! extern int _rl_init_terminal_io __P((const char *));
  #ifdef _MINIX
  extern void _rl_output_character_function __P((int));
***************
*** 178,182 ****
  extern int _rl_output_character_function __P((int));
  #endif
! extern void _rl_output_some_chars __P((char *, int));
  extern int _rl_backspace __P((int));
  extern void _rl_enable_meta_key __P((void));
--- 175,179 ----
  extern int _rl_output_character_function __P((int));
  #endif
! extern void _rl_output_some_chars __P((const char *, int));
  extern int _rl_backspace __P((int));
  extern void _rl_enable_meta_key __P((void));
***************
*** 184,190 ****
  
  /* util.c */
! extern int alphabetic __P((int));
  extern int _rl_abort_internal __P((void));
! extern char *_rl_strindex __P((char *, char *));
  extern int _rl_qsort_string_compare __P((char **, char **));
  extern int (_rl_uppercase_p) __P((int));
--- 181,188 ----
  
  /* util.c */
! extern int rl_alphabetic __P((int));
  extern int _rl_abort_internal __P((void));
! extern char *_rl_strindex __P((const char *, const char *));
! extern char *_rl_strpbrk __P((const char *, const char *));
  extern int _rl_qsort_string_compare __P((char **, char **));
  extern int (_rl_uppercase_p) __P((int));
***************
*** 207,210 ****
--- 205,212 ----
   *************************************************************************/
  
+ /* bind.c */
+ extern const char *_rl_possible_control_prefixes[];
+ extern const char *_rl_possible_meta_prefixes[];
+ 
  /* complete.c */
  extern int _rl_complete_show_all;
***************
*** 219,226 ****
  extern char *rl_display_prompt;
  
- /* funmap.c */
- extern char *possible_control_prefixes[];
- extern char *possible_meta_prefixes[];
- 
  /* isearch.c */
  extern unsigned char *_rl_isearch_terminators;
--- 221,224 ----
***************
*** 249,266 ****
  extern int _rl_enable_keypad;
  extern int _rl_enable_meta;
! extern char *term_clreol;
! extern char *term_clrpag;
! extern char *term_im;
! extern char *term_ic;
! extern char *term_ei;
! extern char *term_DC;
! extern char *term_up;
! extern char *term_dc;
! extern char *term_cr;
! extern char *term_IC;
! extern int screenheight;
! extern int screenwidth;
! extern int screenchars;
! extern int terminal_can_insert;
  extern int _rl_term_autowrap;
  
--- 247,264 ----
  extern int _rl_enable_keypad;
  extern int _rl_enable_meta;
! extern char *_rl_term_clreol;
! extern char *_rl_term_clrpag;
! extern char *_rl_term_im;
! extern char *_rl_term_ic;
! extern char *_rl_term_ei;
! extern char *_rl_term_DC;
! extern char *_rl_term_up;
! extern char *_rl_term_dc;
! extern char *_rl_term_cr;
! extern char *_rl_term_IC;
! extern int _rl_screenheight;
! extern int _rl_screenwidth;
! extern int _rl_screenchars;
! extern int _rl_terminal_can_insert;
  extern int _rl_term_autowrap;
  
diff -Nrc2 bash-2.04/lib/readline/rlshell.h bash-2.05/lib/readline/rlshell.h
*** bash-2.04/lib/readline/rlshell.h	Mon Jan 24 10:36:14 2000
--- bash-2.05/lib/readline/rlshell.h	Wed Nov  8 10:51:03 2000
***************
*** 26,34 ****
  #include "rlstdc.h"
  
! extern char *single_quote __P((char *));
! extern void set_lines_and_columns __P((int, int));
! extern char *get_env_value __P((char *));
! extern char *get_home_dir __P((void));
! extern int unset_nodelay_mode __P((int));
  
  #endif /* _RL_SHELL_H_ */
--- 26,34 ----
  #include "rlstdc.h"
  
! extern char *sh_single_quote __P((char *));
! extern void sh_set_lines_and_columns __P((int, int));
! extern char *sh_get_env_value __P((const char *));
! extern char *sh_get_home_dir __P((void));
! extern int sh_unset_nodelay_mode __P((int));
  
  #endif /* _RL_SHELL_H_ */
diff -Nrc2 bash-2.04/lib/readline/rlstdc.h bash-2.05/lib/readline/rlstdc.h
*** bash-2.04/lib/readline/rlstdc.h	Thu Aug  5 08:12:17 1999
--- bash-2.05/lib/readline/rlstdc.h	Wed Sep 13 14:10:14 2000
***************
*** 37,39 ****
--- 37,51 ----
  #endif
  
+ #if !defined (__STDC__) && !defined (__cplusplus)
+ #  if defined (__GNUC__)	/* gcc with -traditional */
+ #    if !defined (const)
+ #      define const __const
+ #    endif /* !const */
+ #  else /* !__GNUC__ */
+ #    if !defined (const)
+ #      define const
+ #    endif /* !const */
+ #  endif /* !__GNUC__ */
+ #endif /* !__STDC__ && !__cplusplus */
+ 
  #endif /* !_RL_STDC_H_ */
diff -Nrc2 bash-2.04/lib/readline/rltty.c bash-2.05/lib/readline/rltty.c
*** bash-2.04/lib/readline/rltty.c	Thu Aug  5 08:12:32 1999
--- bash-2.05/lib/readline/rltty.c	Fri Feb  2 13:13:01 2001
***************
*** 50,55 ****
  #endif /* !errno */
  
! VFunction *rl_prep_term_function = rl_prep_terminal;
! VFunction *rl_deprep_term_function = rl_deprep_terminal;
  
  /* **************************************************************** */
--- 50,55 ----
  #endif /* !errno */
  
! rl_vintfunc_t *rl_prep_term_function = rl_prep_terminal;
! rl_voidfunc_t *rl_deprep_term_function = rl_deprep_terminal;
  
  /* **************************************************************** */
***************
*** 191,195 ****
        _rl_tty_chars.t_quit = tiop->tchars.t_quitc;
        _rl_tty_chars.t_start = tiop->tchars.t_startc;
!       _rl_tty_chars.t_stop = tiop->tchars.t_stopc
        _rl_tty_chars.t_eof = tiop->tchars.t_eofc;
        _rl_tty_chars.t_eol = '\n';
--- 191,195 ----
        _rl_tty_chars.t_quit = tiop->tchars.t_quitc;
        _rl_tty_chars.t_start = tiop->tchars.t_startc;
!       _rl_tty_chars.t_stop = tiop->tchars.t_stopc;
        _rl_tty_chars.t_eof = tiop->tchars.t_eofc;
        _rl_tty_chars.t_eol = '\n';
***************
*** 219,238 ****
    tiop->flags = tiop->lflag = 0;
  
!   ioctl (tty, TIOCGETP, &(tiop->sgttyb));
    tiop->flags |= SGTTY_SET;
  
  #if defined (TIOCLGET)
!   ioctl (tty, TIOCLGET, &(tiop->lflag));
!   tiop->flags |= LFLAG_SET;
  #endif
  
  #if defined (TIOCGETC)
!   ioctl (tty, TIOCGETC, &(tiop->tchars));
!   tiop->flags |= TCHARS_SET;
  #endif
  
  #if defined (TIOCGLTC)
!   ioctl (tty, TIOCGLTC, &(tiop->ltchars));
!   tiop->flags |= LTCHARS_SET;
  #endif
  
--- 219,239 ----
    tiop->flags = tiop->lflag = 0;
  
!   if (ioctl (tty, TIOCGETP, &(tiop->sgttyb)) < 0)
!     return -1;
    tiop->flags |= SGTTY_SET;
  
  #if defined (TIOCLGET)
!   if (ioctl (tty, TIOCLGET, &(tiop->lflag)) == 0)
!     tiop->flags |= LFLAG_SET;
  #endif
  
  #if defined (TIOCGETC)
!   if (ioctl (tty, TIOCGETC, &(tiop->tchars)) == 0)
!     tiop->flags |= TCHARS_SET;
  #endif
  
  #if defined (TIOCGLTC)
!   if (ioctl (tty, TIOCGLTC, &(tiop->ltchars)) == 0)
!     tiop->flags |= LTCHARS_SET;
  #endif
  
***************
*** 280,300 ****
  
  static void
! prepare_terminal_settings (meta_flag, otio, tiop)
       int meta_flag;
!      TIOTYPE otio, *tiop;
  {
!   readline_echoing_p = (otio.sgttyb.sg_flags & ECHO);
  
    /* Copy the original settings to the structure we're going to use for
       our settings. */
!   tiop->sgttyb = otio.sgttyb;
!   tiop->lflag = otio.lflag;
  #if defined (TIOCGETC)
!   tiop->tchars = otio.tchars;
  #endif
  #if defined (TIOCGLTC)
!   tiop->ltchars = otio.ltchars;
  #endif
!   tiop->flags = otio.flags;
  
    /* First, the basic settings to put us into character-at-a-time, no-echo
--- 281,301 ----
  
  static void
! prepare_terminal_settings (meta_flag, oldtio, tiop)
       int meta_flag;
!      TIOTYPE oldtio, *tiop;
  {
!   readline_echoing_p = (oldtio.sgttyb.sg_flags & ECHO);
  
    /* Copy the original settings to the structure we're going to use for
       our settings. */
!   tiop->sgttyb = oldtio.sgttyb;
!   tiop->lflag = oldtio.lflag;
  #if defined (TIOCGETC)
!   tiop->tchars = oldtio.tchars;
  #endif
  #if defined (TIOCGLTC)
!   tiop->ltchars = oldtio.ltchars;
  #endif
!   tiop->flags = oldtio.flags;
  
    /* First, the basic settings to put us into character-at-a-time, no-echo
***************
*** 309,314 ****
  #  define ANYP (EVENP | ODDP)
  #endif
!   if (((otio.sgttyb.sg_flags & ANYP) == ANYP) ||
!       ((otio.sgttyb.sg_flags & ANYP) == 0))
      {
        tiop->sgttyb.sg_flags |= ANYP;
--- 310,315 ----
  #  define ANYP (EVENP | ODDP)
  #endif
!   if (((oldtio.sgttyb.sg_flags & ANYP) == ANYP) ||
!       ((oldtio.sgttyb.sg_flags & ANYP) == 0))
      {
        tiop->sgttyb.sg_flags |= ANYP;
***************
*** 329,339 ****
  
    /* If there is an XON character, bind it to restart the output. */
!   if (otio.tchars.t_startc != -1)
!     rl_bind_key (otio.tchars.t_startc, rl_restart_output);
  #  endif /* USE_XON_XOFF */
  
    /* If there is an EOF char, bind _rl_eof_char to it. */
!   if (otio.tchars.t_eofc != -1)
!     _rl_eof_char = otio.tchars.t_eofc;
  
  #  if defined (NO_KILL_INTR)
--- 330,340 ----
  
    /* If there is an XON character, bind it to restart the output. */
!   if (oldtio.tchars.t_startc != -1)
!     rl_bind_key (oldtio.tchars.t_startc, rl_restart_output);
  #  endif /* USE_XON_XOFF */
  
    /* If there is an EOF char, bind _rl_eof_char to it. */
!   if (oldtio.tchars.t_eofc != -1)
!     _rl_eof_char = oldtio.tchars.t_eofc;
  
  #  if defined (NO_KILL_INTR)
***************
*** 374,378 ****
  #  define DRAIN_OUTPUT(fd)
  #  define GETATTR(tty, tiop)	(ioctl (tty, TCGETA, tiop))
! #  define SETATTR(tty, tiop)	(ioctl (tty, TCSETA, tiop))
  #endif /* !TERMIOS_TTY_DRIVER */
  
--- 375,379 ----
  #  define DRAIN_OUTPUT(fd)
  #  define GETATTR(tty, tiop)	(ioctl (tty, TCGETA, tiop))
! #  define SETATTR(tty, tiop)	(ioctl (tty, TCSETAW, tiop))
  #endif /* !TERMIOS_TTY_DRIVER */
  
***************
*** 546,559 ****
  
  static void
! prepare_terminal_settings (meta_flag, otio, tiop)
       int meta_flag;
!      TIOTYPE otio, *tiop;
  {
!   readline_echoing_p = (otio.c_lflag & ECHO);
  
    tiop->c_lflag &= ~(ICANON | ECHO);
  
!   if ((unsigned char) otio.c_cc[VEOF] != (unsigned char) _POSIX_VDISABLE)
!     _rl_eof_char = otio.c_cc[VEOF];
  
  #if defined (USE_XON_XOFF)
--- 547,560 ----
  
  static void
! prepare_terminal_settings (meta_flag, oldtio, tiop)
       int meta_flag;
!      TIOTYPE oldtio, *tiop;
  {
!   readline_echoing_p = (oldtio.c_lflag & ECHO);
  
    tiop->c_lflag &= ~(ICANON | ECHO);
  
!   if ((unsigned char) oldtio.c_cc[VEOF] != (unsigned char) _POSIX_VDISABLE)
!     _rl_eof_char = oldtio.c_cc[VEOF];
  
  #if defined (USE_XON_XOFF)
***************
*** 586,590 ****
      {
        tiop->c_lflag &= ~FLUSHO;
!       otio.c_lflag &= ~FLUSHO;
      }
  #endif
--- 587,591 ----
      {
        tiop->c_lflag &= ~FLUSHO;
!       oldtio.c_lflag &= ~FLUSHO;
      }
  #endif
***************
*** 646,649 ****
--- 647,651 ----
    fflush (rl_outstream);
    terminal_prepped = 1;
+   RL_SETSTATE(RL_STATE_TERMPREPPED);
  
    release_sigint ();
***************
*** 676,679 ****
--- 678,682 ----
  
    terminal_prepped = 0;
+   RL_UNSETSTATE(RL_STATE_TERMPREPPED);
  
    release_sigint ();
***************
*** 752,755 ****
--- 755,761 ----
  /*								    */
  /* **************************************************************** */
+ 
+ /* Set the system's default editing characters to their readline equivalents
+    in KMAP.  Should be static, now that we have rl_tty_set_default_bindings. */
  void
  rltty_set_default_bindings (kmap)
***************
*** 814,817 ****
--- 820,832 ----
      }
  #endif /* !NEW_TTY_DRIVER */
+ }
+ 
+ /* New public way to set the system default editing chars to their readline
+    equivalents. */
+ void
+ rl_tty_set_default_bindings (kmap)
+      Keymap kmap;
+ {
+   rltty_set_default_bindings (kmap);
  }
  
diff -Nrc2 bash-2.04/lib/readline/rltypedefs.h bash-2.05/lib/readline/rltypedefs.h
*** bash-2.04/lib/readline/rltypedefs.h	Wed Dec 31 19:00:00 1969
--- bash-2.05/lib/readline/rltypedefs.h	Mon Nov 27 11:52:04 2000
***************
*** 0 ****
--- 1,88 ----
+ /* rltypedefs.h -- Type declarations for readline functions. */
+ 
+ /* Copyright (C) 2000 Free Software Foundation, Inc.
+ 
+    This file is part of the GNU Readline Library, a library for
+    reading lines of text with interactive input and history editing.
+ 
+    The GNU Readline Library is free software; you can redistribute it
+    and/or modify it under the terms of the GNU General Public License
+    as published by the Free Software Foundation; either version 2, or
+    (at your option) any later version.
+ 
+    The GNU Readline Library is distributed in the hope that it will be
+    useful, but WITHOUT ANY WARRANTY; without even the implied warranty
+    of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+ 
+    The GNU General Public License is often shipped with GNU software, and
+    is generally kept in a file called COPYING or LICENSE.  If you do not
+    have a copy of the license, write to the Free Software Foundation,
+    59 Temple Place, Suite 330, Boston, MA 02111 USA. */
+ 
+ #ifndef _RL_TYPEDEFS_H_
+ #define _RL_TYPEDEFS_H_
+ 
+ #ifdef __cplusplus
+ extern "C" {
+ #endif
+ 
+ /* Old-style */
+ 
+ #if !defined (_FUNCTION_DEF)
+ #  define _FUNCTION_DEF
+ 
+ typedef int Function ();
+ typedef void VFunction ();
+ typedef char *CPFunction ();
+ typedef char **CPPFunction ();
+ 
+ #endif /* _FUNCTION_DEF */
+ 
+ /* New style. */
+ 
+ #if !defined (_RL_FUNCTION_TYPEDEF)
+ #  define _RL_FUNCTION_TYPEDEF
+ 
+ /* Bindable functions */
+ typedef int rl_command_func_t __P((int, int));
+ 
+ /* Typedefs for the completion system */
+ typedef char *rl_compentry_func_t __P((const char *, int));
+ typedef char **rl_completion_func_t __P((const char *, int, int));
+ 
+ typedef char *rl_quote_func_t __P((char *, int, char *));
+ typedef char *rl_dequote_func_t __P((char *, int));
+ 
+ typedef int rl_compignore_func_t __P((char **));
+ 
+ typedef void rl_compdisp_func_t __P((char **, int, int));
+ 
+ /* Type for input and pre-read hook functions like rl_event_hook */
+ typedef int rl_hook_func_t __P((void));
+ 
+ /* Input function type */
+ typedef int rl_getc_func_t __P((FILE *));
+ 
+ /* Generic function that takes a character buffer (which could be the readline
+    line buffer) and an index into it (which could be rl_point) and returns
+    an int. */
+ typedef int rl_linebuf_func_t __P((char *, int));
+ 
+ /* `Generic' function pointer typedefs */
+ typedef int rl_intfunc_t __P((int));
+ #define rl_ivoidfunc_t rl_hook_func_t
+ typedef int rl_icpfunc_t __P((char *));
+ typedef int rl_icppfunc_t __P((char **));
+ 
+ typedef void rl_voidfunc_t __P((void));
+ typedef void rl_vintfunc_t __P((int));
+ typedef void rl_vcpfunc_t __P((char *));
+ typedef void rl_vcppfunc_t __P((char **));
+ #endif /* _RL_FUNCTION_TYPEDEF */
+ 
+ #ifdef __cplusplus
+ }
+ #endif
+ 
+ #endif /* _RL_TYPEDEFS_H_ */
diff -Nrc2 bash-2.04/lib/readline/savestring.c bash-2.05/lib/readline/savestring.c
*** bash-2.04/lib/readline/savestring.c	Thu Aug  5 08:13:15 1999
--- bash-2.05/lib/readline/savestring.c	Thu Sep 14 14:58:41 2000
***************
*** 28,32 ****
  char *
  savestring (s)
!      char *s;
  {
    return ((char *)strcpy (xmalloc (1 + (int)strlen (s)), (s)));
--- 28,32 ----
  char *
  savestring (s)
!      const char *s;
  {
    return ((char *)strcpy (xmalloc (1 + (int)strlen (s)), (s)));
diff -Nrc2 bash-2.04/lib/readline/search.c bash-2.05/lib/readline/search.c
*** bash-2.04/lib/readline/search.c	Thu Aug  5 08:13:32 1999
--- bash-2.05/lib/readline/search.c	Thu Nov  2 13:13:25 2000
***************
*** 52,56 ****
  #define abs(x)		(((x) >= 0) ? (x) : -(x))
  
! extern HIST_ENTRY *saved_line_for_history;
  
  /* Functions imported from the rest of the library. */
--- 52,56 ----
  #define abs(x)		(((x) >= 0) ? (x) : -(x))
  
! extern HIST_ENTRY *_rl_saved_line_for_history;
  
  /* Functions imported from the rest of the library. */
***************
*** 84,90 ****
    rl_end = line_len;
  
!   if (saved_line_for_history)
!     _rl_free_history_entry (saved_line_for_history);
!   saved_line_for_history = (HIST_ENTRY *)NULL;
  }
  
--- 84,90 ----
    rl_end = line_len;
  
!   if (_rl_saved_line_for_history)
!     _rl_free_history_entry (_rl_saved_line_for_history);
!   _rl_saved_line_for_history = (HIST_ENTRY *)NULL;
  }
  
***************
*** 101,111 ****
    int ret, old;
  
    old = where_history ();
!   history_set_pos (pos);
  
    if (*string == '^')
      ret = history_search_prefix (string + 1, dir);
    else
      ret = history_search (string, dir);
  
    if (ret != -1)
--- 101,117 ----
    int ret, old;
  
+   if (pos < 0)
+     return -1;
+ 
    old = where_history ();
!   if (history_set_pos (pos) == 0)
!     return -1;
  
+   RL_SETSTATE(RL_STATE_SEARCH);
    if (*string == '^')
      ret = history_search_prefix (string + 1, dir);
    else
      ret = history_search (string, dir);
+   RL_UNSETSTATE(RL_STATE_SEARCH);
  
    if (ret != -1)
***************
*** 129,133 ****
    if (string == 0 || *string == '\0' || noninc_history_pos < 0)
      {
!       ding ();
        return;
      }
--- 135,139 ----
    if (string == 0 || *string == '\0' || noninc_history_pos < 0)
      {
!       rl_ding ();
        return;
      }
***************
*** 137,144 ****
      {
        /* Search failed, current history position unchanged. */
!       maybe_unsave_line ();
        rl_clear_message ();
        rl_point = 0;
!       ding ();
        return;
      }
--- 143,150 ----
      {
        /* Search failed, current history position unchanged. */
!       rl_maybe_unsave_line ();
        rl_clear_message ();
        rl_point = 0;
!       rl_ding ();
        return;
      }
***************
*** 173,177 ****
    char *p;
  
!   maybe_save_line ();
    saved_point = rl_point;
  
--- 179,183 ----
    char *p;
  
!   rl_maybe_save_line ();
    saved_point = rl_point;
  
***************
*** 184,192 ****
    free (p);
  
! #define SEARCH_RETURN rl_restore_prompt (); return
  
    /* Read the search string. */
!   while (c = rl_read_key ())
      {
        switch (c)
  	{
--- 190,206 ----
    free (p);
  
! #define SEARCH_RETURN rl_restore_prompt (); RL_UNSETSTATE(RL_STATE_NSEARCH); return
  
+   RL_SETSTATE(RL_STATE_NSEARCH);
    /* Read the search string. */
!   while (1)
      {
+       RL_SETSTATE(RL_STATE_MOREINPUT);
+       c = rl_read_key ();
+       RL_UNSETSTATE(RL_STATE_MOREINPUT);
+ 
+       if (c == 0)
+ 	break;
+ 
        switch (c)
  	{
***************
*** 195,199 ****
  	  if (rl_point == 0)
  	    {
! 	      maybe_unsave_line ();
  	      rl_clear_message ();
  	      rl_point = saved_point;
--- 209,213 ----
  	  if (rl_point == 0)
  	    {
! 	      rl_maybe_unsave_line ();
  	      rl_clear_message ();
  	      rl_point = saved_point;
***************
*** 219,226 ****
  	case CTRL('C'):
  	case CTRL('G'):
! 	  maybe_unsave_line ();
  	  rl_clear_message ();
  	  rl_point = saved_point;
! 	  ding ();
  	  SEARCH_RETURN;
  
--- 233,240 ----
  	case CTRL('C'):
  	case CTRL('G'):
! 	  rl_maybe_unsave_line ();
  	  rl_clear_message ();
  	  rl_point = saved_point;
! 	  rl_ding ();
  	  SEARCH_RETURN;
  
***************
*** 240,244 ****
        if (!noninc_search_string)
  	{
! 	  ding ();
  	  SEARCH_RETURN;
  	}
--- 254,258 ----
        if (!noninc_search_string)
  	{
! 	  rl_ding ();
  	  SEARCH_RETURN;
  	}
***************
*** 254,257 ****
--- 268,272 ----
    rl_restore_prompt ();
    noninc_dosearch (noninc_search_string, dir);
+   RL_UNSETSTATE(RL_STATE_NSEARCH);
  }
  
***************
*** 284,288 ****
    if (!noninc_search_string)
      {
!       ding ();
        return (-1);
      }
--- 299,303 ----
    if (!noninc_search_string)
      {
!       rl_ding ();
        return (-1);
      }
***************
*** 299,303 ****
    if (!noninc_search_string)
      {
!       ding ();
        return (-1);
      }
--- 314,318 ----
    if (!noninc_search_string)
      {
!       rl_ding ();
        return (-1);
      }
***************
*** 313,317 ****
    int ret, oldpos;
  
!   maybe_save_line ();
    temp = (HIST_ENTRY *)NULL;
  
--- 328,332 ----
    int ret, oldpos;
  
!   rl_maybe_save_line ();
    temp = (HIST_ENTRY *)NULL;
  
***************
*** 342,347 ****
    if (temp == 0)
      {
!       maybe_unsave_line ();
!       ding ();
        /* If you don't want the saved history line (last match) to show up
           in the line buffer after the search fails, change the #if 0 to
--- 357,362 ----
    if (temp == 0)
      {
!       rl_maybe_unsave_line ();
!       rl_ding ();
        /* If you don't want the saved history line (last match) to show up
           in the line buffer after the search fails, change the #if 0 to
***************
*** 354,358 ****
          }
  #else
!       rl_point = rl_history_search_len;	/* maybe_unsave_line changes it */
  #endif
        return 1;
--- 369,373 ----
          }
  #else
!       rl_point = rl_history_search_len;	/* rl_maybe_unsave_line changes it */
  #endif
        return 1;
***************
*** 383,386 ****
--- 398,402 ----
        history_search_string[rl_point + 1] = '\0';
      }
+   _rl_free_saved_history_line ();
  }
  
diff -Nrc2 bash-2.04/lib/readline/shell.c bash-2.05/lib/readline/shell.c
*** bash-2.04/lib/readline/shell.c	Mon Nov 29 11:04:14 1999
--- bash-2.05/lib/readline/shell.c	Wed Nov  8 12:12:45 2000
***************
*** 50,58 ****
  #include <stdio.h>
  
  #include "rlshell.h"
  #include "xmalloc.h"
  
  #if !defined (HAVE_GETPW_DECLS)
! extern struct passwd *getpwuid ();
  #endif /* !HAVE_GETPW_DECLS */
  
--- 50,59 ----
  #include <stdio.h>
  
+ #include "rlstdc.h"
  #include "rlshell.h"
  #include "xmalloc.h"
  
  #if !defined (HAVE_GETPW_DECLS)
! extern struct passwd *getpwuid __P((uid_t));
  #endif /* !HAVE_GETPW_DECLS */
  
***************
*** 66,70 ****
  /* Does shell-like quoting using single quotes. */
  char *
! single_quote (string)
       char *string;
  {
--- 67,71 ----
  /* Does shell-like quoting using single quotes. */
  char *
! sh_single_quote (string)
       char *string;
  {
***************
*** 97,101 ****
     respectively. */
  void
! set_lines_and_columns (lines, cols)
       int lines, cols;
  {
--- 98,102 ----
     respectively. */
  void
! sh_set_lines_and_columns (lines, cols)
       int lines, cols;
  {
***************
*** 122,127 ****
  
  char *
! get_env_value (varname)
!      char *varname;
  {
    return ((char *)getenv (varname));
--- 123,128 ----
  
  char *
! sh_get_env_value (varname)
!      const char *varname;
  {
    return ((char *)getenv (varname));
***************
*** 129,133 ****
  
  char *
! get_home_dir ()
  {
    char *home_dir;
--- 130,134 ----
  
  char *
! sh_get_home_dir ()
  {
    char *home_dir;
***************
*** 148,152 ****
  
  int
! unset_nodelay_mode (fd)
       int fd;
  {
--- 149,153 ----
  
  int
! sh_unset_nodelay_mode (fd)
       int fd;
  {
diff -Nrc2 bash-2.04/lib/readline/signals.c bash-2.05/lib/readline/signals.c
*** bash-2.04/lib/readline/signals.c	Mon Feb 21 11:22:57 2000
--- bash-2.05/lib/readline/signals.c	Tue Dec 12 15:01:45 2000
***************
*** 62,66 ****
  #endif
  
! /* This typedef is equivalant to the one for Function; it allows us
     to say SigHandler *foo = signal (SIGKILL, SIG_IGN); */
  typedef RETSIGTYPE SigHandler ();
--- 62,66 ----
  #endif
  
! /* This typedef is equivalent to the one for Function; it allows us
     to say SigHandler *foo = signal (SIGKILL, SIG_IGN); */
  typedef RETSIGTYPE SigHandler ();
***************
*** 120,123 ****
--- 120,125 ----
  #endif /* !HAVE_POSIX_SIGNALS */
  
+   RL_SETSTATE(RL_STATE_SIGHANDLER);
+ 
  #if !defined (HAVE_BSD_SIGNALS) && !defined (HAVE_POSIX_SIGNALS)
    /* Since the signal will not be blocked while we are in the signal
***************
*** 170,173 ****
--- 172,176 ----
      }
  
+   RL_UNSETSTATE(RL_STATE_SIGHANDLER);
    SIGHANDLER_RETURN;
  }
***************
*** 190,193 ****
--- 193,197 ----
  #endif
  
+   RL_SETSTATE(RL_STATE_SIGHANDLER);
    rl_resize_terminal ();
  
***************
*** 197,200 ****
--- 201,205 ----
      (*oh) (sig);
  
+   RL_UNSETSTATE(RL_STATE_SIGHANDLER);
    SIGHANDLER_RETURN;
  }
***************
*** 359,363 ****
    (*rl_deprep_term_function) ();
    rl_clear_signals ();
!   rl_pending_input = 0;
  }
  
--- 364,368 ----
    (*rl_deprep_term_function) ();
    rl_clear_signals ();
!   rl_clear_pending_input ();
  }
  
***************
*** 379,383 ****
    register HIST_ENTRY *entry;
  
!   free_undo_list ();
  
    entry = current_history ();
--- 384,388 ----
    register HIST_ENTRY *entry;
  
!   rl_free_undo_list ();
  
    entry = current_history ();
diff -Nrc2 bash-2.04/lib/readline/terminal.c bash-2.05/lib/readline/terminal.c
*** bash-2.04/lib/readline/terminal.c	Mon Jan 24 10:44:28 2000
--- bash-2.05/lib/readline/terminal.c	Tue Feb  6 15:39:22 2001
***************
*** 77,83 ****
  static int tcap_initialized;
  
- /* Non-zero means this terminal can't really do anything. */
- static int dumb_term;
- 
  #if !defined (__linux__)
  #  if defined (__EMX__) || defined (NEED_EXTERN_PC)
--- 77,80 ----
***************
*** 88,112 ****
  
  /* Some strings to control terminal actions.  These are output by tputs (). */
! char *term_goto, *term_clreol, *term_cr, *term_clrpag, *term_backspace;
! char *term_pc;
  
  /* Non-zero if we determine that the terminal can do character insertion. */
! int terminal_can_insert = 0;
  
  /* How to insert characters. */
! char *term_im, *term_ei, *term_ic, *term_ip, *term_IC;
  
  /* How to delete characters. */
! char *term_dc, *term_DC;
  
  #if defined (HACK_TERMCAP_MOTION)
! char *term_forward_char;
  #endif  /* HACK_TERMCAP_MOTION */
  
  /* How to go up a line. */
! char *term_up;
  
! /* A visible bell, if the terminal can be made to flash the screen. */
! static char *visible_bell;
  
  /* Non-zero means the terminal can auto-wrap lines. */
--- 85,118 ----
  
  /* Some strings to control terminal actions.  These are output by tputs (). */
! char *_rl_term_clreol;
! char *_rl_term_clrpag;
! char *_rl_term_cr;
! char *_rl_term_backspace;
! char *_rl_term_goto;
! char *_rl_term_pc;
  
  /* Non-zero if we determine that the terminal can do character insertion. */
! int _rl_terminal_can_insert = 0;
  
  /* How to insert characters. */
! char *_rl_term_im;
! char *_rl_term_ei;
! char *_rl_term_ic;
! char *_rl_term_ip;
! char *_rl_term_IC;
  
  /* How to delete characters. */
! char *_rl_term_dc;
! char *_rl_term_DC;
  
  #if defined (HACK_TERMCAP_MOTION)
! char *_rl_term_forward_char;
  #endif  /* HACK_TERMCAP_MOTION */
  
  /* How to go up a line. */
! char *_rl_term_up;
  
! /* A visible bell; char if the terminal can be made to flash the screen. */
! static char *_rl_visible_bell;
  
  /* Non-zero means the terminal can auto-wrap lines. */
***************
*** 117,134 ****
  
  /* The sequences to write to turn on and off the meta key, if this
!    terminal    has one. */
! static char *term_mm, *term_mo;
  
  /* The key sequences output by the arrow keys, if this terminal has any. */
! static char *term_ku, *term_kd, *term_kr, *term_kl;
  
  /* How to initialize and reset the arrow keys, if this terminal has any. */
! static char *term_ks, *term_ke;
  
  /* The key sequences sent by the Home and End keys, if any. */
! static char *term_kh, *term_kH;
  
  /* Variables that hold the screen dimensions, used by the display code. */
! int screenwidth, screenheight, screenchars;
  
  /* Non-zero means the user wants to enable the keypad. */
--- 123,146 ----
  
  /* The sequences to write to turn on and off the meta key, if this
!    terminal has one. */
! static char *_rl_term_mm;
! static char *_rl_term_mo;
  
  /* The key sequences output by the arrow keys, if this terminal has any. */
! static char *_rl_term_ku;
! static char *_rl_term_kd;
! static char *_rl_term_kr;
! static char *_rl_term_kl;
  
  /* How to initialize and reset the arrow keys, if this terminal has any. */
! static char *_rl_term_ks;
! static char *_rl_term_ke;
  
  /* The key sequences sent by the Home and End keys, if any. */
! static char *_rl_term_kh;
! static char *_rl_term_kH;
  
  /* Variables that hold the screen dimensions, used by the display code. */
! int _rl_screenwidth, _rl_screenheight, _rl_screenchars;
  
  /* Non-zero means the user wants to enable the keypad. */
***************
*** 170,192 ****
    if (ioctl (tty, TIOCGWINSZ, &window_size) == 0)
      {
!       screenwidth = (int) window_size.ws_col;
!       screenheight = (int) window_size.ws_row;
      }
  #endif /* TIOCGWINSZ */
  
  #if defined (__EMX__)
!   _emx_get_screensize (&screenwidth, &screenheight);
  #endif
  
    /* Environment variable COLUMNS overrides setting of "co" if IGNORE_ENV
       is unset. */
!   if (screenwidth <= 0)
      {
!       if (ignore_env == 0 && (ss = get_env_value ("COLUMNS")))
! 	screenwidth = atoi (ss);
  
  #if !defined (__DJGPP__)
!       if (screenwidth <= 0 && term_string_buffer)
! 	screenwidth = tgetnum ("co");
  #endif
      }
--- 182,204 ----
    if (ioctl (tty, TIOCGWINSZ, &window_size) == 0)
      {
!       _rl_screenwidth = (int) window_size.ws_col;
!       _rl_screenheight = (int) window_size.ws_row;
      }
  #endif /* TIOCGWINSZ */
  
  #if defined (__EMX__)
!   _emx_get_screensize (&_rl_screenwidth, &_rl_screenheight);
  #endif
  
    /* Environment variable COLUMNS overrides setting of "co" if IGNORE_ENV
       is unset. */
!   if (_rl_screenwidth <= 0)
      {
!       if (ignore_env == 0 && (ss = sh_get_env_value ("COLUMNS")))
! 	_rl_screenwidth = atoi (ss);
  
  #if !defined (__DJGPP__)
!       if (_rl_screenwidth <= 0 && term_string_buffer)
! 	_rl_screenwidth = tgetnum ("co");
  #endif
      }
***************
*** 194,224 ****
    /* Environment variable LINES overrides setting of "li" if IGNORE_ENV
       is unset. */
!   if (screenheight <= 0)
      {
!       if (ignore_env == 0 && (ss = get_env_value ("LINES")))
! 	screenheight = atoi (ss);
  
  #if !defined (__DJGPP__)
!       if (screenheight <= 0 && term_string_buffer)
! 	screenheight = tgetnum ("li");
  #endif
      }
  
    /* If all else fails, default to 80x24 terminal. */
!   if (screenwidth <= 1)
!     screenwidth = 80;
  
!   if (screenheight <= 0)
!     screenheight = 24;
  
    /* If we're being compiled as part of bash, set the environment
       variables $LINES and $COLUMNS to new values.  Otherwise, just
       do a pair of putenv () or setenv () calls. */
!   set_lines_and_columns (screenheight, screenwidth);
  
    if (_rl_term_autowrap == 0)
!     screenwidth--;
  
!   screenchars = screenwidth * screenheight;
  }
  
--- 206,236 ----
    /* Environment variable LINES overrides setting of "li" if IGNORE_ENV
       is unset. */
!   if (_rl_screenheight <= 0)
      {
!       if (ignore_env == 0 && (ss = sh_get_env_value ("LINES")))
! 	_rl_screenheight = atoi (ss);
  
  #if !defined (__DJGPP__)
!       if (_rl_screenheight <= 0 && term_string_buffer)
! 	_rl_screenheight = tgetnum ("li");
  #endif
      }
  
    /* If all else fails, default to 80x24 terminal. */
!   if (_rl_screenwidth <= 1)
!     _rl_screenwidth = 80;
  
!   if (_rl_screenheight <= 0)
!     _rl_screenheight = 24;
  
    /* If we're being compiled as part of bash, set the environment
       variables $LINES and $COLUMNS to new values.  Otherwise, just
       do a pair of putenv () or setenv () calls. */
!   sh_set_lines_and_columns (_rl_screenheight, _rl_screenwidth);
  
    if (_rl_term_autowrap == 0)
!     _rl_screenwidth--;
  
!   _rl_screenchars = _rl_screenwidth * _rl_screenheight;
  }
  
***************
*** 227,240 ****
       int rows, cols;
  {
!   screenheight = rows;
!   screenwidth = cols;
  
    if (_rl_term_autowrap == 0)
!     screenwidth--;
  
!   screenchars = screenwidth * screenheight;
  }
  
  void
  rl_resize_terminal ()
  {
--- 239,272 ----
       int rows, cols;
  {
!   if (rows == 0 || cols == 0)
!     return;
! 
!   _rl_screenheight = rows;
!   _rl_screenwidth = cols;
  
    if (_rl_term_autowrap == 0)
!     _rl_screenwidth--;
  
!   _rl_screenchars = _rl_screenwidth * _rl_screenheight;
! }
! 
! void
! rl_set_screen_size (rows, cols)
!      int rows, cols;
! {
!   _rl_set_screen_size (rows, cols);
  }
  
  void
+ rl_get_screen_size (rows, cols)
+      int *rows, *cols;
+ {
+   if (rows)
+     *rows = _rl_screenheight;
+   if (cols)
+     *cols = _rl_screenwidth;
+ }
+      
+ void
  rl_resize_terminal ()
  {
***************
*** 247,251 ****
  
  struct _tc_string {
!      char *tc_var;
       char **tc_value;
  };
--- 279,283 ----
  
  struct _tc_string {
!      const char *tc_var;
       char **tc_value;
  };
***************
*** 255,284 ****
  static struct _tc_string tc_strings[] =
  {
!   { "DC", &term_DC },
!   { "IC", &term_IC },
!   { "ce", &term_clreol },
!   { "cl", &term_clrpag },
!   { "cr", &term_cr },
!   { "dc", &term_dc },
!   { "ei", &term_ei },
!   { "ic", &term_ic },
!   { "im", &term_im },
!   { "kd", &term_kd },
!   { "kh", &term_kh },	/* home */
!   { "kH", &term_kH },	/* end */
!   { "kl", &term_kl },
!   { "kr", &term_kr },
!   { "ku", &term_ku },
!   { "ks", &term_ks },
!   { "ke", &term_ke },
!   { "le", &term_backspace },
!   { "mm", &term_mm },
!   { "mo", &term_mo },
  #if defined (HACK_TERMCAP_MOTION)
!   { "nd", &term_forward_char },
  #endif
!   { "pc", &term_pc },
!   { "up", &term_up },
!   { "vb", &visible_bell },
  };
  
--- 287,316 ----
  static struct _tc_string tc_strings[] =
  {
!   { "DC", &_rl_term_DC },
!   { "IC", &_rl_term_IC },
!   { "ce", &_rl_term_clreol },
!   { "cl", &_rl_term_clrpag },
!   { "cr", &_rl_term_cr },
!   { "dc", &_rl_term_dc },
!   { "ei", &_rl_term_ei },
!   { "ic", &_rl_term_ic },
!   { "im", &_rl_term_im },
!   { "kd", &_rl_term_kd },
!   { "kh", &_rl_term_kh },	/* home */
!   { "kH", &_rl_term_kH },	/* end */
!   { "kl", &_rl_term_kl },
!   { "kr", &_rl_term_kr },
!   { "ku", &_rl_term_ku },
!   { "ks", &_rl_term_ks },
!   { "ke", &_rl_term_ke },
!   { "le", &_rl_term_backspace },
!   { "mm", &_rl_term_mm },
!   { "mo", &_rl_term_mo },
  #if defined (HACK_TERMCAP_MOTION)
!   { "nd", &_rl_term_forward_char },
  #endif
!   { "pc", &_rl_term_pc },
!   { "up", &_rl_term_up },
!   { "vb", &_rl_visible_bell },
  };
  
***************
*** 305,318 ****
  int
  _rl_init_terminal_io (terminal_name)
!      char *terminal_name;
  {
!   char *term, *buffer;
    int tty, tgetent_ret;
    Keymap xkeymap;
  
!   term = terminal_name ? terminal_name : get_env_value ("TERM");
!   term_clrpag = term_cr = term_clreol = (char *)NULL;
    tty = rl_instream ? fileno (rl_instream) : 0;
!   screenwidth = screenheight = 0;
  
    if (term == 0)
--- 337,351 ----
  int
  _rl_init_terminal_io (terminal_name)
!      const char *terminal_name;
  {
!   const char *term;
!   char *buffer;
    int tty, tgetent_ret;
    Keymap xkeymap;
  
!   term = terminal_name ? terminal_name : sh_get_env_value ("TERM");
!   _rl_term_clrpag = _rl_term_cr = _rl_term_clreol = (char *)NULL;
    tty = rl_instream ? fileno (rl_instream) : 0;
!   _rl_screenwidth = _rl_screenheight = 0;
  
    if (term == 0)
***************
*** 345,354 ****
        buffer = term_buffer = term_string_buffer = (char *)NULL;
  
-       dumb_term = 1;
        _rl_term_autowrap = 0;	/* used by _rl_get_screen_size */
  
  #if defined (__EMX__)
!       _emx_get_screensize (&screenwidth, &screenheight);
!       screenwidth--;
  #else /* !__EMX__ */
        _rl_get_screen_size (tty, 0);
--- 378,386 ----
        buffer = term_buffer = term_string_buffer = (char *)NULL;
  
        _rl_term_autowrap = 0;	/* used by _rl_get_screen_size */
  
  #if defined (__EMX__)
!       _emx_get_screensize (&_rl_screenwidth, &_rl_screenheight);
!       _rl_screenwidth--;
  #else /* !__EMX__ */
        _rl_get_screen_size (tty, 0);
***************
*** 356,383 ****
  
        /* Defaults. */
!       if (screenwidth <= 0 || screenheight <= 0)
          {
! 	  screenwidth = 79;
! 	  screenheight = 24;
          }
  
        /* Everything below here is used by the redisplay code (tputs). */
!       screenchars = screenwidth * screenheight;
!       term_cr = "\r";
!       term_im = term_ei = term_ic = term_IC = (char *)NULL;
!       term_up = term_dc = term_DC = visible_bell = (char *)NULL;
!       term_ku = term_kd = term_kl = term_kr = (char *)NULL;
!       term_mm = term_mo = (char *)NULL;
  #if defined (HACK_TERMCAP_MOTION)
        term_forward_char = (char *)NULL;
  #endif
!       terminal_can_insert = term_has_meta = 0;
  
        /* Reasonable defaults for tgoto().  Readline currently only uses
!          tgoto if term_IC or term_DC is defined, but just in case we
           change that later... */
        PC = '\0';
!       BC = term_backspace = "\b";
!       UP = term_up;
  
        return 0;
--- 388,415 ----
  
        /* Defaults. */
!       if (_rl_screenwidth <= 0 || _rl_screenheight <= 0)
          {
! 	  _rl_screenwidth = 79;
! 	  _rl_screenheight = 24;
          }
  
        /* Everything below here is used by the redisplay code (tputs). */
!       _rl_screenchars = _rl_screenwidth * _rl_screenheight;
!       _rl_term_cr = "\r";
!       _rl_term_im = _rl_term_ei = _rl_term_ic = _rl_term_IC = (char *)NULL;
!       _rl_term_up = _rl_term_dc = _rl_term_DC = _rl_visible_bell = (char *)NULL;
!       _rl_term_ku = _rl_term_kd = _rl_term_kl = _rl_term_kr = (char *)NULL;
!       _rl_term_mm = _rl_term_mo = (char *)NULL;
  #if defined (HACK_TERMCAP_MOTION)
        term_forward_char = (char *)NULL;
  #endif
!       _rl_terminal_can_insert = term_has_meta = 0;
  
        /* Reasonable defaults for tgoto().  Readline currently only uses
!          tgoto if _rl_term_IC or _rl_term_DC is defined, but just in case we
           change that later... */
        PC = '\0';
!       BC = _rl_term_backspace = "\b";
!       UP = _rl_term_up;
  
        return 0;
***************
*** 388,397 ****
    /* Set up the variables that the termcap library expects the application
       to provide. */
!   PC = term_pc ? *term_pc : 0;
!   BC = term_backspace;
!   UP = term_up;
  
!   if (!term_cr)
!     term_cr = "\r";
  
    _rl_term_autowrap = tgetflag ("am") && tgetflag ("xn");
--- 420,429 ----
    /* Set up the variables that the termcap library expects the application
       to provide. */
!   PC = _rl_term_pc ? *_rl_term_pc : 0;
!   BC = _rl_term_backspace;
!   UP = _rl_term_up;
  
!   if (!_rl_term_cr)
!     _rl_term_cr = "\r";
  
    _rl_term_autowrap = tgetflag ("am") && tgetflag ("xn");
***************
*** 403,407 ****
        `im', `ic' or `ip' is provided."  But we can't do anything if
        only `ip' is provided, so... */
!   terminal_can_insert = (term_IC || term_im || term_ic);
  
    /* Check to see if this terminal has a meta key and clear the capability
--- 435,439 ----
        `im', `ic' or `ip' is provided."  But we can't do anything if
        only `ip' is provided, so... */
!   _rl_terminal_can_insert = (_rl_term_IC || _rl_term_im || _rl_term_ic);
  
    /* Check to see if this terminal has a meta key and clear the capability
***************
*** 409,413 ****
    term_has_meta = (tgetflag ("km") || tgetflag ("MT"));
    if (!term_has_meta)
!     term_mm = term_mo = (char *)NULL;
  
    /* Attempt to find and bind the arrow keys.  Do not override already
--- 441,445 ----
    term_has_meta = (tgetflag ("km") || tgetflag ("MT"));
    if (!term_has_meta)
!     _rl_term_mm = _rl_term_mo = (char *)NULL;
  
    /* Attempt to find and bind the arrow keys.  Do not override already
***************
*** 416,436 ****
  
    _rl_keymap = emacs_standard_keymap;
!   _rl_bind_if_unbound (term_ku, rl_get_previous_history);
!   _rl_bind_if_unbound (term_kd, rl_get_next_history);
!   _rl_bind_if_unbound (term_kr, rl_forward);
!   _rl_bind_if_unbound (term_kl, rl_backward);
  
!   _rl_bind_if_unbound (term_kh, rl_beg_of_line);	/* Home */
!   _rl_bind_if_unbound (term_kH, rl_end_of_line);	/* End */
  
  #if defined (VI_MODE)
    _rl_keymap = vi_movement_keymap;
!   _rl_bind_if_unbound (term_ku, rl_get_previous_history);
!   _rl_bind_if_unbound (term_kd, rl_get_next_history);
!   _rl_bind_if_unbound (term_kr, rl_forward);
!   _rl_bind_if_unbound (term_kl, rl_backward);
  
!   _rl_bind_if_unbound (term_kh, rl_beg_of_line);	/* Home */
!   _rl_bind_if_unbound (term_kH, rl_end_of_line);	/* End */
  #endif /* VI_MODE */
  
--- 448,468 ----
  
    _rl_keymap = emacs_standard_keymap;
!   _rl_bind_if_unbound (_rl_term_ku, rl_get_previous_history);
!   _rl_bind_if_unbound (_rl_term_kd, rl_get_next_history);
!   _rl_bind_if_unbound (_rl_term_kr, rl_forward);
!   _rl_bind_if_unbound (_rl_term_kl, rl_backward);
  
!   _rl_bind_if_unbound (_rl_term_kh, rl_beg_of_line);	/* Home */
!   _rl_bind_if_unbound (_rl_term_kH, rl_end_of_line);	/* End */
  
  #if defined (VI_MODE)
    _rl_keymap = vi_movement_keymap;
!   _rl_bind_if_unbound (_rl_term_ku, rl_get_previous_history);
!   _rl_bind_if_unbound (_rl_term_kd, rl_get_next_history);
!   _rl_bind_if_unbound (_rl_term_kr, rl_forward);
!   _rl_bind_if_unbound (_rl_term_kl, rl_backward);
  
!   _rl_bind_if_unbound (_rl_term_kh, rl_beg_of_line);	/* Home */
!   _rl_bind_if_unbound (_rl_term_kH, rl_end_of_line);	/* End */
  #endif /* VI_MODE */
  
***************
*** 442,446 ****
  char *
  rl_get_termcap (cap)
!      char *cap;
  {
    register int i;
--- 474,478 ----
  char *
  rl_get_termcap (cap)
!      const char *cap;
  {
    register int i;
***************
*** 460,464 ****
  int
  rl_reset_terminal (terminal_name)
!      char *terminal_name;
  {
    _rl_init_terminal_io (terminal_name);
--- 492,496 ----
  int
  rl_reset_terminal (terminal_name)
!      const char *terminal_name;
  {
    _rl_init_terminal_io (terminal_name);
***************
*** 486,490 ****
  void
  _rl_output_some_chars (string, count)
!      char *string;
       int count;
  {
--- 518,522 ----
  void
  _rl_output_some_chars (string, count)
!      const char *string;
       int count;
  {
***************
*** 499,505 ****
    register int i;
  
!   if (term_backspace)
      for (i = 0; i < count; i++)
!       tputs (term_backspace, 1, _rl_output_character_function);
    else
      for (i = 0; i < count; i++)
--- 531,537 ----
    register int i;
  
!   if (_rl_term_backspace)
      for (i = 0; i < count; i++)
!       tputs (_rl_term_backspace, 1, _rl_output_character_function);
    else
      for (i = 0; i < count; i++)
***************
*** 510,518 ****
  /* Move to the start of the next line. */
  int
! crlf ()
  {
  #if defined (NEW_TTY_DRIVER)
!   if (term_cr)
!     tputs (term_cr, 1, _rl_output_character_function);
  #endif /* NEW_TTY_DRIVER */
    putc ('\n', _rl_out_stream);
--- 542,550 ----
  /* Move to the start of the next line. */
  int
! rl_crlf ()
  {
  #if defined (NEW_TTY_DRIVER)
!   if (_rl_term_cr)
!     tputs (_rl_term_cr, 1, _rl_output_character_function);
  #endif /* NEW_TTY_DRIVER */
    putc ('\n', _rl_out_stream);
***************
*** 522,526 ****
  /* Ring the terminal bell. */
  int
! ding ()
  {
    if (readline_echoing_p)
--- 554,558 ----
  /* Ring the terminal bell. */
  int
! rl_ding ()
  {
    if (readline_echoing_p)
***************
*** 532,538 ****
  	  break;
  	case VISIBLE_BELL:
! 	  if (visible_bell)
  	    {
! 	      tputs (visible_bell, 1, _rl_output_character_function);
  	      break;
  	    }
--- 564,570 ----
  	  break;
  	case VISIBLE_BELL:
! 	  if (_rl_visible_bell)
  	    {
! 	      tputs (_rl_visible_bell, 1, _rl_output_character_function);
  	      break;
  	    }
***************
*** 558,563 ****
  {
  #if !defined (__DJGPP__)
!   if (term_has_meta && term_mm)
!     tputs (term_mm, 1, _rl_output_character_function);
  #endif
  }
--- 590,595 ----
  {
  #if !defined (__DJGPP__)
!   if (term_has_meta && _rl_term_mm)
!     tputs (_rl_term_mm, 1, _rl_output_character_function);
  #endif
  }
***************
*** 568,575 ****
  {
  #if !defined (__DJGPP__)
!   if (on && term_ks)
!     tputs (term_ks, 1, _rl_output_character_function);
!   else if (!on && term_ke)
!     tputs (term_ke, 1, _rl_output_character_function);
  #endif
  }
--- 600,607 ----
  {
  #if !defined (__DJGPP__)
!   if (on && _rl_term_ks)
!     tputs (_rl_term_ks, 1, _rl_output_character_function);
!   else if (!on && _rl_term_ke)
!     tputs (_rl_term_ke, 1, _rl_output_character_function);
  #endif
  }
diff -Nrc2 bash-2.04/lib/readline/tilde.c bash-2.05/lib/readline/tilde.c
*** bash-2.04/lib/readline/tilde.c	Thu Dec 16 16:10:44 1999
--- bash-2.05/lib/readline/tilde.c	Wed Feb 14 17:04:21 2001
***************
*** 51,64 ****
  static char *xmalloc (), *xrealloc ();
  #else
! #  if defined __STDC__
! extern char *xmalloc (int);
! extern char *xrealloc (void *, int);
! #  else
! extern char *xmalloc (), *xrealloc ();
! #  endif /* !__STDC__ */
  #endif /* TEST || STATIC_MALLOC */
  
  #if !defined (HAVE_GETPW_DECLS)
! extern struct passwd *getpwuid (), *getpwnam ();
  #endif /* !HAVE_GETPW_DECLS */
  
--- 51,61 ----
  static char *xmalloc (), *xrealloc ();
  #else
! extern char *xmalloc __P((int));
! extern char *xrealloc __P((void *, int));
  #endif /* TEST || STATIC_MALLOC */
  
  #if !defined (HAVE_GETPW_DECLS)
! extern struct passwd *getpwuid __P((uid_t));
! extern struct passwd *getpwnam __P((const char *));
  #endif /* !HAVE_GETPW_DECLS */
  
***************
*** 81,98 ****
     variables.o.  If being compiled as part of readline, they will
     be satisfied from shell.o. */
! extern char *get_home_dir __P((void));
! extern char *get_env_value __P((char *));
  
  /* The default value of tilde_additional_prefixes.  This is set to
     whitespace preceding a tilde so that simple programs which do not
     perform any word separation get desired behaviour. */
! static char *default_prefixes[] =
!   { " ~", "\t~", (char *)NULL };
  
  /* The default value of tilde_additional_suffixes.  This is set to
     whitespace or newline so that simple programs which do not
     perform any word separation get desired behaviour. */
! static char *default_suffixes[] =
!   { " ", "\n", (char *)NULL };
  
  /* If non-null, this contains the address of a function that the application
--- 78,95 ----
     variables.o.  If being compiled as part of readline, they will
     be satisfied from shell.o. */
! extern char *sh_get_home_dir __P((void));
! extern char *sh_get_env_value __P((const char *));
  
  /* The default value of tilde_additional_prefixes.  This is set to
     whitespace preceding a tilde so that simple programs which do not
     perform any word separation get desired behaviour. */
! static const char *default_prefixes[] =
!   { " ~", "\t~", (const char *)NULL };
  
  /* The default value of tilde_additional_suffixes.  This is set to
     whitespace or newline so that simple programs which do not
     perform any word separation get desired behaviour. */
! static const char *default_suffixes[] =
!   { " ", "\n", (const char *)NULL };
  
  /* If non-null, this contains the address of a function that the application
***************
*** 100,104 ****
     is called with the text sans tilde, and returns a malloc()'ed string
     which is the expansion, or a NULL pointer if the expansion fails. */
! CPFunction *tilde_expansion_preexpansion_hook = (CPFunction *)NULL;
  
  /* If non-null, this contains the address of a function to call if the
--- 97,101 ----
     is called with the text sans tilde, and returns a malloc()'ed string
     which is the expansion, or a NULL pointer if the expansion fails. */
! tilde_hook_func_t *tilde_expansion_preexpansion_hook = (tilde_hook_func_t *)NULL;
  
  /* If non-null, this contains the address of a function to call if the
***************
*** 106,120 ****
     with the text (sans tilde, as in "foo"), and returns a malloc()'ed string
     which is the expansion, or a NULL pointer if there is no expansion. */
! CPFunction *tilde_expansion_failure_hook = (CPFunction *)NULL;
  
  /* When non-null, this is a NULL terminated array of strings which
     are duplicates for a tilde prefix.  Bash uses this to expand
     `=~' and `:~'. */
! char **tilde_additional_prefixes = default_prefixes;
  
  /* When non-null, this is a NULL terminated array of strings which match
     the end of a username, instead of just "/".  Bash sets this to
     `:' and `=~'. */
! char **tilde_additional_suffixes = default_suffixes;
  
  /* Find the start of a tilde expansion in STRING, and return the index of
--- 103,117 ----
     with the text (sans tilde, as in "foo"), and returns a malloc()'ed string
     which is the expansion, or a NULL pointer if there is no expansion. */
! tilde_hook_func_t *tilde_expansion_failure_hook = (tilde_hook_func_t *)NULL;
  
  /* When non-null, this is a NULL terminated array of strings which
     are duplicates for a tilde prefix.  Bash uses this to expand
     `=~' and `:~'. */
! char **tilde_additional_prefixes = (char **)default_prefixes;
  
  /* When non-null, this is a NULL terminated array of strings which match
     the end of a username, instead of just "/".  Bash sets this to
     `:' and `=~'. */
! char **tilde_additional_suffixes = (char **)default_suffixes;
  
  /* Find the start of a tilde expansion in STRING, and return the index of
***************
*** 187,191 ****
  char *
  tilde_expand (string)
!      char *string;
  {
    char *result;
--- 184,188 ----
  char *
  tilde_expand (string)
!      const char *string;
  {
    char *result;
***************
*** 236,242 ****
  
        len = strlen (expansion);
! #ifdef __CYGWIN32__
        /* Fix for Cygwin to prevent ~user/xxx from expanding to //xxx when
!          $HOME for `user' is /.  On cygwin, // denotes a network drive. */
        if (len > 1 || *expansion != '/' || *string != '/')
  #endif
--- 233,239 ----
  
        len = strlen (expansion);
! #ifdef __CYGWIN__
        /* Fix for Cygwin to prevent ~user/xxx from expanding to //xxx when
! 	 $HOME for `user' is /.  On cygwin, // denotes a network drive. */
        if (len > 1 || *expansion != '/' || *string != '/')
  #endif
***************
*** 304,308 ****
  char *
  tilde_expand_word (filename)
!      char *filename;
  {
    char *dirname, *expansion, *username;
--- 301,305 ----
  char *
  tilde_expand_word (filename)
!      const char *filename;
  {
    char *dirname, *expansion, *username;
***************
*** 322,331 ****
      {
        /* Prefix $HOME to the rest of the string. */
!       expansion = get_env_value ("HOME");
  
        /* If there is no HOME variable, look up the directory in
  	 the password database. */
        if (expansion == 0)
! 	expansion = get_home_dir ();
  
        return (glue_prefix_and_suffix (expansion, filename, 1));
--- 319,328 ----
      {
        /* Prefix $HOME to the rest of the string. */
!       expansion = sh_get_env_value ("HOME");
  
        /* If there is no HOME variable, look up the directory in
  	 the password database. */
        if (expansion == 0)
! 	expansion = sh_get_home_dir ();
  
        return (glue_prefix_and_suffix (expansion, filename, 1));
diff -Nrc2 bash-2.04/lib/readline/tilde.h bash-2.05/lib/readline/tilde.h
*** bash-2.04/lib/readline/tilde.h	Thu Dec  2 15:47:02 1999
--- bash-2.05/lib/readline/tilde.h	Mon Oct 30 14:31:04 2000
***************
*** 41,52 ****
  #endif
  
! /* Function pointers can be declared as (Function *)foo. */
! #if !defined (_FUNCTION_DEF)
! #  define _FUNCTION_DEF
! typedef int Function ();
! typedef void VFunction ();
! typedef char *CPFunction ();
! typedef char **CPPFunction ();
! #endif /* _FUNCTION_DEF */
  
  /* If non-null, this contains the address of a function that the application
--- 41,57 ----
  #endif
  
! #if !defined (__STDC__) && !defined (__cplusplus)
! #  if defined (__GNUC__)	/* gcc with -traditional */
! #    if !defined (const)
! #      define const __const
! #    endif /* !const */
! #  else /* !__GNUC__ */
! #    if !defined (const)
! #      define const
! #    endif /* !const */
! #  endif /* !__GNUC__ */
! #endif /* !__STDC__ && !__cplusplus */
! 
! typedef char *tilde_hook_func_t __P((char *));
  
  /* If non-null, this contains the address of a function that the application
***************
*** 54,58 ****
     is called with the text sans tilde, and returns a malloc()'ed string
     which is the expansion, or a NULL pointer if the expansion fails. */
! extern CPFunction *tilde_expansion_preexpansion_hook;
  
  /* If non-null, this contains the address of a function to call if the
--- 59,63 ----
     is called with the text sans tilde, and returns a malloc()'ed string
     which is the expansion, or a NULL pointer if the expansion fails. */
! extern tilde_hook_func_t *tilde_expansion_preexpansion_hook;
  
  /* If non-null, this contains the address of a function to call if the
***************
*** 60,64 ****
     with the text (sans tilde, as in "foo"), and returns a malloc()'ed string
     which is the expansion, or a NULL pointer if there is no expansion. */
! extern CPFunction *tilde_expansion_failure_hook;
  
  /* When non-null, this is a NULL terminated array of strings which
--- 65,69 ----
     with the text (sans tilde, as in "foo"), and returns a malloc()'ed string
     which is the expansion, or a NULL pointer if there is no expansion. */
! extern tilde_hook_func_t *tilde_expansion_failure_hook;
  
  /* When non-null, this is a NULL terminated array of strings which
***************
*** 73,81 ****
  
  /* Return a new string which is the result of tilde expanding STRING. */
! extern char *tilde_expand __P((char *));
  
  /* Do the work of tilde expansion on FILENAME.  FILENAME starts with a
     tilde.  If there is no expansion, call tilde_expansion_failure_hook. */
! extern char *tilde_expand_word __P((char *));
  
  #ifdef __cplusplus
--- 78,86 ----
  
  /* Return a new string which is the result of tilde expanding STRING. */
! extern char *tilde_expand __P((const char *));
  
  /* Do the work of tilde expansion on FILENAME.  FILENAME starts with a
     tilde.  If there is no expansion, call tilde_expansion_failure_hook. */
! extern char *tilde_expand_word __P((const char *));
  
  #ifdef __cplusplus
diff -Nrc2 bash-2.04/lib/readline/undo.c bash-2.05/lib/readline/undo.c
*** bash-2.04/lib/readline/undo.c	Thu Aug  5 08:15:52 1999
--- bash-2.05/lib/readline/undo.c	Tue Feb  6 14:14:45 2001
***************
*** 87,91 ****
  /* Free the existing undo list. */
  void
! free_undo_list ()
  {
    while (rl_undo_list)
--- 87,91 ----
  /* Free the existing undo list. */
  void
! rl_free_undo_list ()
  {
    while (rl_undo_list)
***************
*** 108,116 ****
  {
    UNDO_LIST *release;
!   int waiting_for_begin = 0;
!   int start, end;
  
  #define TRANS(i) ((i) == -1 ? rl_point : ((i) == -2 ? rl_end : (i)))
  
    do
      {
--- 108,116 ----
  {
    UNDO_LIST *release;
!   int waiting_for_begin, start, end;
  
  #define TRANS(i) ((i) == -1 ? rl_point : ((i) == -2 ? rl_end : (i)))
  
+   start = end = waiting_for_begin = 0;
    do
      {
***************
*** 119,122 ****
--- 119,123 ----
  
        _rl_doing_an_undo = 1;
+       RL_SETSTATE(RL_STATE_UNDOING);
  
        /* To better support vi-mode, a start or end value of -1 means
***************
*** 153,161 ****
  	    waiting_for_begin--;
  	  else
! 	    ding ();
  	  break;
  	}
  
        _rl_doing_an_undo = 0;
  
        release = rl_undo_list;
--- 154,163 ----
  	    waiting_for_begin--;
  	  else
! 	    rl_ding ();
  	  break;
  	}
  
        _rl_doing_an_undo = 0;
+       RL_UNSETSTATE(RL_STATE_UNDOING);
  
        release = rl_undo_list;
***************
*** 232,236 ****
  {
    if (!rl_undo_list)
!     ding ();
    else
      {
--- 234,238 ----
  {
    if (!rl_undo_list)
!     rl_ding ();
    else
      {
***************
*** 255,259 ****
        else
  	{
! 	  ding ();
  	  break;
  	}
--- 257,261 ----
        else
  	{
! 	  rl_ding ();
  	  break;
  	}
diff -Nrc2 bash-2.04/lib/readline/util.c bash-2.05/lib/readline/util.c
*** bash-2.04/lib/readline/util.c	Thu Aug  5 08:16:05 1999
--- bash-2.05/lib/readline/util.c	Wed Feb 14 07:43:19 2001
***************
*** 68,75 ****
  
  int _rl_allow_pathname_alphabetic_chars = 0;
! static char *pathname_alphabetic_chars = "/-_=~.#$";
  
  int
! alphabetic (c)
       int c;
  {
--- 68,75 ----
  
  int _rl_allow_pathname_alphabetic_chars = 0;
! static const char *pathname_alphabetic_chars = "/-_=~.#$";
  
  int
! rl_alphabetic (c)
       int c;
  {
***************
*** 85,98 ****
  _rl_abort_internal ()
  {
!   ding ();
    rl_clear_message ();
    _rl_init_argument ();
!   rl_pending_input = 0;
  
    _rl_defining_kbd_macro = 0;
!   while (_rl_executing_macro)
      _rl_pop_executing_macro ();
  
!   rl_last_func = (Function *)NULL;
    longjmp (readline_top_level, 1);
    return (0);
--- 85,98 ----
  _rl_abort_internal ()
  {
!   rl_ding ();
    rl_clear_message ();
    _rl_init_argument ();
!   rl_clear_pending_input ();
  
    _rl_defining_kbd_macro = 0;
!   while (rl_executing_macro)
      _rl_pop_executing_macro ();
  
!   rl_last_func = (rl_command_func_t *)NULL;
    longjmp (readline_top_level, 1);
    return (0);
***************
*** 114,118 ****
    rl_refresh_line (count, key);
  #else
!   ding ();
  #endif
    return 0;
--- 114,118 ----
    rl_refresh_line (count, key);
  #else
!   rl_ding ();
  #endif
    return 0;
***************
*** 216,220 ****
  char *
  _rl_strindex (s1, s2)
!      register char *s1, *s2;
  {
    register int i, l, len;
--- 216,220 ----
  char *
  _rl_strindex (s1, s2)
!      register const char *s1, *s2;
  {
    register int i, l, len;
***************
*** 222,226 ****
    for (i = 0, l = strlen (s2), len = strlen (s1); (len - i) >= l; i++)
      if (_rl_strnicmp (s1 + i, s2, l) == 0)
!       return (s1 + i);
    return ((char *)NULL);
  }
--- 222,245 ----
    for (i = 0, l = strlen (s2), len = strlen (s1); (len - i) >= l; i++)
      if (_rl_strnicmp (s1 + i, s2, l) == 0)
!       return ((char *) (s1 + i));
!   return ((char *)NULL);
! }
! 
! /* Find the first occurrence in STRING1 of any character from STRING2.
!    Return a pointer to the character in STRING1. */
! char *
! _rl_strpbrk (string1, string2)
!      const char *string1, *string2;
! {
!   register const char *scan;
! 
!   for (; *string1; string1++)
!     {
!       for (scan = string2; *scan; scan++)
! 	{
! 	  if (*string1 == *scan)
! 	    return ((char *)string1);
! 	}
!     }
    return ((char *)NULL);
  }
***************
*** 346,351 ****
  char *
  _rl_savestring (s)
!      char *s;
  {
!   return ((char *)strcpy (xmalloc (1 + (int)strlen (s)), (s)));
  }
--- 365,370 ----
  char *
  _rl_savestring (s)
!      const char *s;
  {
!   return (strcpy (xmalloc (1 + (int)strlen (s)), (s)));
  }
diff -Nrc2 bash-2.04/lib/readline/vi_keymap.c bash-2.05/lib/readline/vi_keymap.c
*** bash-2.04/lib/readline/vi_keymap.c	Thu Aug  5 08:16:20 1999
--- bash-2.05/lib/readline/vi_keymap.c	Mon Oct 30 11:55:52 2000
***************
*** 34,311 ****
  KEYMAP_ENTRY_ARRAY vi_movement_keymap = {
    /* The regular control keys come first. */
!   { ISFUNC, (Function *)0x0 },		/* Control-@ */
!   { ISFUNC, (Function *)0x0 },		/* Control-a */
!   { ISFUNC, (Function *)0x0 },		/* Control-b */
!   { ISFUNC, (Function *)0x0 },		/* Control-c */
!   { ISFUNC, rl_vi_eof_maybe },		/* Control-d */
!   { ISFUNC, rl_emacs_editing_mode },	/* Control-e */
!   { ISFUNC, (Function *)0x0 },		/* Control-f */
!   { ISFUNC, rl_abort },			/* Control-g */
!   { ISFUNC, rl_backward },		/* Control-h */
!   { ISFUNC, (Function *)0x0 },		/* Control-i */
!   { ISFUNC, rl_newline },		/* Control-j */
!   { ISFUNC, rl_kill_line },		/* Control-k */
!   { ISFUNC, rl_clear_screen },		/* Control-l */
!   { ISFUNC, rl_newline },		/* Control-m */
!   { ISFUNC, rl_get_next_history },	/* Control-n */
!   { ISFUNC, (Function *)0x0 },		/* Control-o */
!   { ISFUNC, rl_get_previous_history },	/* Control-p */
!   { ISFUNC, rl_quoted_insert },		/* Control-q */
!   { ISFUNC, rl_reverse_search_history }, /* Control-r */
!   { ISFUNC, rl_forward_search_history }, /* Control-s */
!   { ISFUNC, rl_transpose_chars },	/* Control-t */
!   { ISFUNC, rl_unix_line_discard },	/* Control-u */
!   { ISFUNC, rl_quoted_insert },		/* Control-v */
!   { ISFUNC, rl_unix_word_rubout },	/* Control-w */
!   { ISFUNC, (Function *)0x0 },		/* Control-x */
!   { ISFUNC, rl_yank },			/* Control-y */
!   { ISFUNC, (Function *)0x0 },		/* Control-z */
! 
!   { ISFUNC, (Function *)0x0 },		/* Control-[ */	/* vi_escape_keymap */
!   { ISFUNC, (Function *)0x0 },		/* Control-\ */
!   { ISFUNC, (Function *)0x0 },		/* Control-] */
!   { ISFUNC, (Function *)0x0 },		/* Control-^ */
!   { ISFUNC, rl_vi_undo },		/* Control-_ */
  
    /* The start of printing characters. */
!   { ISFUNC, rl_forward },		/* SPACE */
!   { ISFUNC, (Function *)0x0 },		/* ! */
!   { ISFUNC, (Function *)0x0 },		/* " */
!   { ISFUNC, rl_insert_comment },	/* # */
!   { ISFUNC, rl_end_of_line },		/* $ */
!   { ISFUNC, rl_vi_match },		/* % */
!   { ISFUNC, rl_vi_tilde_expand },	/* & */
!   { ISFUNC, (Function *)0x0 },		/* ' */
!   { ISFUNC, (Function *)0x0 },		/* ( */
!   { ISFUNC, (Function *)0x0 },		/* ) */
!   { ISFUNC, rl_vi_complete },		/* * */
!   { ISFUNC, rl_get_next_history},	/* + */
!   { ISFUNC, rl_vi_char_search },	/* , */
!   { ISFUNC, rl_get_previous_history },	/* - */
!   { ISFUNC, rl_vi_redo },		/* . */
!   { ISFUNC, rl_vi_search },		/* / */
  
    /* Regular digits. */
!   { ISFUNC, rl_beg_of_line },		/* 0 */
!   { ISFUNC, rl_vi_arg_digit },		/* 1 */
!   { ISFUNC, rl_vi_arg_digit },		/* 2 */
!   { ISFUNC, rl_vi_arg_digit },		/* 3 */
!   { ISFUNC, rl_vi_arg_digit },		/* 4 */
!   { ISFUNC, rl_vi_arg_digit },		/* 5 */
!   { ISFUNC, rl_vi_arg_digit },		/* 6 */
!   { ISFUNC, rl_vi_arg_digit },		/* 7 */
!   { ISFUNC, rl_vi_arg_digit },		/* 8 */
!   { ISFUNC, rl_vi_arg_digit },		/* 9 */
  
    /* A little more punctuation. */
!   { ISFUNC, (Function *)0x0 },		/* : */
!   { ISFUNC, rl_vi_char_search },	/* ; */
!   { ISFUNC, (Function *)0x0 },		/* < */
!   { ISFUNC, rl_vi_complete },		/* = */
!   { ISFUNC, (Function *)0x0 },		/* > */
!   { ISFUNC, rl_vi_search },		/* ? */
!   { ISFUNC, (Function *)0x0 },		/* @ */
  
    /* Uppercase alphabet. */
!   { ISFUNC, rl_vi_append_eol },		/* A */
!   { ISFUNC, rl_vi_prev_word},		/* B */
!   { ISFUNC, rl_vi_change_to },		/* C */
!   { ISFUNC, rl_vi_delete_to },		/* D */
!   { ISFUNC, rl_vi_end_word },		/* E */
!   { ISFUNC, rl_vi_char_search },	/* F */
!   { ISFUNC, rl_vi_fetch_history },	/* G */
!   { ISFUNC, (Function *)0x0 },		/* H */
!   { ISFUNC, rl_vi_insert_beg },		/* I */
!   { ISFUNC, (Function *)0x0 },		/* J */
!   { ISFUNC, (Function *)0x0 },		/* K */
!   { ISFUNC, (Function *)0x0 },		/* L */
!   { ISFUNC, (Function *)0x0 },		/* M */
!   { ISFUNC, rl_vi_search_again },	/* N */
!   { ISFUNC, (Function *)0x0 },		/* O */
!   { ISFUNC, rl_vi_put },		/* P */
!   { ISFUNC, (Function *)0x0 },		/* Q */
!   { ISFUNC, rl_vi_replace },		/* R */
!   { ISFUNC, rl_vi_subst },		/* S */
!   { ISFUNC, rl_vi_char_search },	/* T */
!   { ISFUNC, rl_revert_line },		/* U */
!   { ISFUNC, (Function *)0x0 },		/* V */
!   { ISFUNC, rl_vi_next_word },		/* W */
!   { ISFUNC, rl_rubout },		/* X */
!   { ISFUNC, rl_vi_yank_to },		/* Y */
!   { ISFUNC, (Function *)0x0 },		/* Z */
  
    /* Some more punctuation. */
!   { ISFUNC, (Function *)0x0 },		/* [ */
!   { ISFUNC, rl_vi_complete },		/* \ */
!   { ISFUNC, (Function *)0x0 },		/* ] */
!   { ISFUNC, rl_vi_first_print },	/* ^ */
!   { ISFUNC, rl_vi_yank_arg },		/* _ */
!   { ISFUNC, rl_vi_goto_mark },		/* ` */
  
    /* Lowercase alphabet. */
!   { ISFUNC, rl_vi_append_mode },	/* a */
!   { ISFUNC, rl_vi_prev_word },		/* b */
!   { ISFUNC, rl_vi_change_to },		/* c */
!   { ISFUNC, rl_vi_delete_to },		/* d */
!   { ISFUNC, rl_vi_end_word },		/* e */
!   { ISFUNC, rl_vi_char_search },	/* f */
!   { ISFUNC, (Function *)0x0 },		/* g */
!   { ISFUNC, rl_backward },		/* h */
!   { ISFUNC, rl_vi_insertion_mode },	/* i */
!   { ISFUNC, rl_get_next_history },	/* j */
!   { ISFUNC, rl_get_previous_history },	/* k */
!   { ISFUNC, rl_forward },		/* l */
!   { ISFUNC, rl_vi_set_mark },		/* m */
!   { ISFUNC, rl_vi_search_again },	/* n */
!   { ISFUNC, (Function *)0x0 },		/* o */
!   { ISFUNC, rl_vi_put },		/* p */
!   { ISFUNC, (Function *)0x0 },		/* q */
!   { ISFUNC, rl_vi_change_char },	/* r */
!   { ISFUNC, rl_vi_subst },		/* s */
!   { ISFUNC, rl_vi_char_search },	/* t */
!   { ISFUNC, rl_vi_undo },		/* u */
!   { ISFUNC, (Function *)0x0 },		/* v */
!   { ISFUNC, rl_vi_next_word },		/* w */
!   { ISFUNC, rl_vi_delete },		/* x */
!   { ISFUNC, rl_vi_yank_to },		/* y */
!   { ISFUNC, (Function *)0x0 },		/* z */
  
    /* Final punctuation. */
!   { ISFUNC, (Function *)0x0 },		/* { */
!   { ISFUNC, rl_vi_column },		/* | */
!   { ISFUNC, (Function *)0x0 },		/* } */
!   { ISFUNC, rl_vi_change_case },	/* ~ */
!   { ISFUNC, (Function *)0x0 },		/* RUBOUT */
  
  #if KEYMAP_SIZE > 128
    /* Undefined keys. */
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 }
  #endif /* KEYMAP_SIZE > 128 */
  };
--- 34,311 ----
  KEYMAP_ENTRY_ARRAY vi_movement_keymap = {
    /* The regular control keys come first. */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-@ */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-a */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-b */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-c */
!   { ISFUNC, rl_vi_eof_maybe },			/* Control-d */
!   { ISFUNC, rl_emacs_editing_mode },		/* Control-e */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-f */
!   { ISFUNC, rl_abort },				/* Control-g */
!   { ISFUNC, rl_backward },			/* Control-h */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-i */
!   { ISFUNC, rl_newline },			/* Control-j */
!   { ISFUNC, rl_kill_line },			/* Control-k */
!   { ISFUNC, rl_clear_screen },			/* Control-l */
!   { ISFUNC, rl_newline },			/* Control-m */
!   { ISFUNC, rl_get_next_history },		/* Control-n */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-o */
!   { ISFUNC, rl_get_previous_history },		/* Control-p */
!   { ISFUNC, rl_quoted_insert },			/* Control-q */
!   { ISFUNC, rl_reverse_search_history },	/* Control-r */
!   { ISFUNC, rl_forward_search_history },	/* Control-s */
!   { ISFUNC, rl_transpose_chars },		/* Control-t */
!   { ISFUNC, rl_unix_line_discard },		/* Control-u */
!   { ISFUNC, rl_quoted_insert },			/* Control-v */
!   { ISFUNC, rl_unix_word_rubout },		/* Control-w */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-x */
!   { ISFUNC, rl_yank },				/* Control-y */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-z */
! 
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-[ */	/* vi_escape_keymap */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-\ */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-] */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-^ */
!   { ISFUNC, rl_vi_undo },			/* Control-_ */
  
    /* The start of printing characters. */
!   { ISFUNC, rl_forward },			/* SPACE */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* ! */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* " */
!   { ISFUNC, rl_insert_comment },		/* # */
!   { ISFUNC, rl_end_of_line },			/* $ */
!   { ISFUNC, rl_vi_match },			/* % */
!   { ISFUNC, rl_vi_tilde_expand },		/* & */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* ' */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* ( */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* ) */
!   { ISFUNC, rl_vi_complete },			/* * */
!   { ISFUNC, rl_get_next_history},		/* + */
!   { ISFUNC, rl_vi_char_search },		/* , */
!   { ISFUNC, rl_get_previous_history },		/* - */
!   { ISFUNC, rl_vi_redo },			/* . */
!   { ISFUNC, rl_vi_search },			/* / */
  
    /* Regular digits. */
!   { ISFUNC, rl_beg_of_line },			/* 0 */
!   { ISFUNC, rl_vi_arg_digit },			/* 1 */
!   { ISFUNC, rl_vi_arg_digit },			/* 2 */
!   { ISFUNC, rl_vi_arg_digit },			/* 3 */
!   { ISFUNC, rl_vi_arg_digit },			/* 4 */
!   { ISFUNC, rl_vi_arg_digit },			/* 5 */
!   { ISFUNC, rl_vi_arg_digit },			/* 6 */
!   { ISFUNC, rl_vi_arg_digit },			/* 7 */
!   { ISFUNC, rl_vi_arg_digit },			/* 8 */
!   { ISFUNC, rl_vi_arg_digit },			/* 9 */
  
    /* A little more punctuation. */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* : */
!   { ISFUNC, rl_vi_char_search },		/* ; */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* < */
!   { ISFUNC, rl_vi_complete },			/* = */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* > */
!   { ISFUNC, rl_vi_search },			/* ? */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* @ */
  
    /* Uppercase alphabet. */
!   { ISFUNC, rl_vi_append_eol },			/* A */
!   { ISFUNC, rl_vi_prev_word},			/* B */
!   { ISFUNC, rl_vi_change_to },			/* C */
!   { ISFUNC, rl_vi_delete_to },			/* D */
!   { ISFUNC, rl_vi_end_word },			/* E */
!   { ISFUNC, rl_vi_char_search },		/* F */
!   { ISFUNC, rl_vi_fetch_history },		/* G */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* H */
!   { ISFUNC, rl_vi_insert_beg },			/* I */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* J */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* K */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* L */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* M */
!   { ISFUNC, rl_vi_search_again },		/* N */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* O */
!   { ISFUNC, rl_vi_put },			/* P */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* Q */
!   { ISFUNC, rl_vi_replace },			/* R */
!   { ISFUNC, rl_vi_subst },			/* S */
!   { ISFUNC, rl_vi_char_search },		/* T */
!   { ISFUNC, rl_revert_line },			/* U */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* V */
!   { ISFUNC, rl_vi_next_word },			/* W */
!   { ISFUNC, rl_rubout },			/* X */
!   { ISFUNC, rl_vi_yank_to },			/* Y */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* Z */
  
    /* Some more punctuation. */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* [ */
!   { ISFUNC, rl_vi_complete },			/* \ */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* ] */
!   { ISFUNC, rl_vi_first_print },		/* ^ */
!   { ISFUNC, rl_vi_yank_arg },			/* _ */
!   { ISFUNC, rl_vi_goto_mark },			/* ` */
  
    /* Lowercase alphabet. */
!   { ISFUNC, rl_vi_append_mode },		/* a */
!   { ISFUNC, rl_vi_prev_word },			/* b */
!   { ISFUNC, rl_vi_change_to },			/* c */
!   { ISFUNC, rl_vi_delete_to },			/* d */
!   { ISFUNC, rl_vi_end_word },			/* e */
!   { ISFUNC, rl_vi_char_search },		/* f */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* g */
!   { ISFUNC, rl_backward },			/* h */
!   { ISFUNC, rl_vi_insertion_mode },		/* i */
!   { ISFUNC, rl_get_next_history },		/* j */
!   { ISFUNC, rl_get_previous_history },		/* k */
!   { ISFUNC, rl_forward },			/* l */
!   { ISFUNC, rl_vi_set_mark },			/* m */
!   { ISFUNC, rl_vi_search_again },		/* n */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* o */
!   { ISFUNC, rl_vi_put },			/* p */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* q */
!   { ISFUNC, rl_vi_change_char },		/* r */
!   { ISFUNC, rl_vi_subst },			/* s */
!   { ISFUNC, rl_vi_char_search },		/* t */
!   { ISFUNC, rl_vi_undo },			/* u */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* v */
!   { ISFUNC, rl_vi_next_word },			/* w */
!   { ISFUNC, rl_vi_delete },			/* x */
!   { ISFUNC, rl_vi_yank_to },			/* y */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* z */
  
    /* Final punctuation. */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* { */
!   { ISFUNC, rl_vi_column },			/* | */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* } */
!   { ISFUNC, rl_vi_change_case },		/* ~ */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* RUBOUT */
  
  #if KEYMAP_SIZE > 128
    /* Undefined keys. */
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 }
  #endif /* KEYMAP_SIZE > 128 */
  };
***************
*** 314,460 ****
  KEYMAP_ENTRY_ARRAY vi_insertion_keymap = {
    /* The regular control keys come first. */
!   { ISFUNC, (Function *)0x0 },		/* Control-@ */
!   { ISFUNC, rl_insert },		/* Control-a */
!   { ISFUNC, rl_insert },		/* Control-b */
!   { ISFUNC, rl_insert },		/* Control-c */
!   { ISFUNC, rl_vi_eof_maybe },		/* Control-d */
!   { ISFUNC, rl_insert },		/* Control-e */
!   { ISFUNC, rl_insert },		/* Control-f */
!   { ISFUNC, rl_insert },		/* Control-g */
!   { ISFUNC, rl_rubout },		/* Control-h */
!   { ISFUNC, rl_complete },		/* Control-i */
!   { ISFUNC, rl_newline },		/* Control-j */
!   { ISFUNC, rl_insert },		/* Control-k */
!   { ISFUNC, rl_insert },		/* Control-l */
!   { ISFUNC, rl_newline },		/* Control-m */
!   { ISFUNC, rl_insert },		/* Control-n */
!   { ISFUNC, rl_insert },		/* Control-o */
!   { ISFUNC, rl_insert },		/* Control-p */
!   { ISFUNC, rl_insert },		/* Control-q */
!   { ISFUNC, rl_reverse_search_history }, /* Control-r */
!   { ISFUNC, rl_forward_search_history }, /* Control-s */
!   { ISFUNC, rl_transpose_chars },	/* Control-t */
!   { ISFUNC, rl_unix_line_discard },	/* Control-u */
!   { ISFUNC, rl_quoted_insert },		/* Control-v */
!   { ISFUNC, rl_unix_word_rubout },	/* Control-w */
!   { ISFUNC, rl_insert },		/* Control-x */
!   { ISFUNC, rl_yank },			/* Control-y */
!   { ISFUNC, rl_insert },		/* Control-z */
! 
!   { ISFUNC, rl_vi_movement_mode },	/* Control-[ */
!   { ISFUNC, rl_insert },		/* Control-\ */
!   { ISFUNC, rl_insert },		/* Control-] */
!   { ISFUNC, rl_insert },		/* Control-^ */
!   { ISFUNC, rl_vi_undo },		/* Control-_ */
  
    /* The start of printing characters. */
!   { ISFUNC, rl_insert },		/* SPACE */
!   { ISFUNC, rl_insert },		/* ! */
!   { ISFUNC, rl_insert },		/* " */
!   { ISFUNC, rl_insert },		/* # */
!   { ISFUNC, rl_insert },		/* $ */
!   { ISFUNC, rl_insert },		/* % */
!   { ISFUNC, rl_insert },		/* & */
!   { ISFUNC, rl_insert },		/* ' */
!   { ISFUNC, rl_insert },		/* ( */
!   { ISFUNC, rl_insert },		/* ) */
!   { ISFUNC, rl_insert },		/* * */
!   { ISFUNC, rl_insert },		/* + */
!   { ISFUNC, rl_insert },		/* , */
!   { ISFUNC, rl_insert },		/* - */
!   { ISFUNC, rl_insert },		/* . */
!   { ISFUNC, rl_insert },		/* / */
  
    /* Regular digits. */
!   { ISFUNC, rl_insert },		/* 0 */
!   { ISFUNC, rl_insert },		/* 1 */
!   { ISFUNC, rl_insert },		/* 2 */
!   { ISFUNC, rl_insert },		/* 3 */
!   { ISFUNC, rl_insert },		/* 4 */
!   { ISFUNC, rl_insert },		/* 5 */
!   { ISFUNC, rl_insert },		/* 6 */
!   { ISFUNC, rl_insert },		/* 7 */
!   { ISFUNC, rl_insert },		/* 8 */
!   { ISFUNC, rl_insert },		/* 9 */
  
    /* A little more punctuation. */
!   { ISFUNC, rl_insert },		/* : */
!   { ISFUNC, rl_insert },		/* ; */
!   { ISFUNC, rl_insert },		/* < */
!   { ISFUNC, rl_insert },		/* = */
!   { ISFUNC, rl_insert },		/* > */
!   { ISFUNC, rl_insert },		/* ? */
!   { ISFUNC, rl_insert },		/* @ */
  
    /* Uppercase alphabet. */
!   { ISFUNC, rl_insert },		/* A */
!   { ISFUNC, rl_insert },		/* B */
!   { ISFUNC, rl_insert },		/* C */
!   { ISFUNC, rl_insert },		/* D */
!   { ISFUNC, rl_insert },		/* E */
!   { ISFUNC, rl_insert },		/* F */
!   { ISFUNC, rl_insert },		/* G */
!   { ISFUNC, rl_insert },		/* H */
!   { ISFUNC, rl_insert },		/* I */
!   { ISFUNC, rl_insert },		/* J */
!   { ISFUNC, rl_insert },		/* K */
!   { ISFUNC, rl_insert },		/* L */
!   { ISFUNC, rl_insert },		/* M */
!   { ISFUNC, rl_insert },		/* N */
!   { ISFUNC, rl_insert },		/* O */
!   { ISFUNC, rl_insert },		/* P */
!   { ISFUNC, rl_insert },		/* Q */
!   { ISFUNC, rl_insert },		/* R */
!   { ISFUNC, rl_insert },		/* S */
!   { ISFUNC, rl_insert },		/* T */
!   { ISFUNC, rl_insert },		/* U */
!   { ISFUNC, rl_insert },		/* V */
!   { ISFUNC, rl_insert },		/* W */
!   { ISFUNC, rl_insert },		/* X */
!   { ISFUNC, rl_insert },		/* Y */
!   { ISFUNC, rl_insert },		/* Z */
  
    /* Some more punctuation. */
!   { ISFUNC, rl_insert },		/* [ */
!   { ISFUNC, rl_insert },		/* \ */
!   { ISFUNC, rl_insert },		/* ] */
!   { ISFUNC, rl_insert },		/* ^ */
!   { ISFUNC, rl_insert },		/* _ */
!   { ISFUNC, rl_insert },		/* ` */
  
    /* Lowercase alphabet. */
!   { ISFUNC, rl_insert },		/* a */
!   { ISFUNC, rl_insert },		/* b */
!   { ISFUNC, rl_insert },		/* c */
!   { ISFUNC, rl_insert },		/* d */
!   { ISFUNC, rl_insert },		/* e */
!   { ISFUNC, rl_insert },		/* f */
!   { ISFUNC, rl_insert },		/* g */
!   { ISFUNC, rl_insert },		/* h */
!   { ISFUNC, rl_insert },		/* i */
!   { ISFUNC, rl_insert },		/* j */
!   { ISFUNC, rl_insert },		/* k */
!   { ISFUNC, rl_insert },		/* l */
!   { ISFUNC, rl_insert },		/* m */
!   { ISFUNC, rl_insert },		/* n */
!   { ISFUNC, rl_insert },		/* o */
!   { ISFUNC, rl_insert },		/* p */
!   { ISFUNC, rl_insert },		/* q */
!   { ISFUNC, rl_insert },		/* r */
!   { ISFUNC, rl_insert },		/* s */
!   { ISFUNC, rl_insert },		/* t */
!   { ISFUNC, rl_insert },		/* u */
!   { ISFUNC, rl_insert },		/* v */
!   { ISFUNC, rl_insert },		/* w */
!   { ISFUNC, rl_insert },		/* x */
!   { ISFUNC, rl_insert },		/* y */
!   { ISFUNC, rl_insert },		/* z */
  
    /* Final punctuation. */
!   { ISFUNC, rl_insert },		/* { */
!   { ISFUNC, rl_insert },		/* | */
!   { ISFUNC, rl_insert },		/* } */
!   { ISFUNC, rl_insert },		/* ~ */
!   { ISFUNC, rl_rubout },		/* RUBOUT */
  
  #if KEYMAP_SIZE > 128
--- 314,460 ----
  KEYMAP_ENTRY_ARRAY vi_insertion_keymap = {
    /* The regular control keys come first. */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-@ */
!   { ISFUNC, rl_insert },			/* Control-a */
!   { ISFUNC, rl_insert },			/* Control-b */
!   { ISFUNC, rl_insert },			/* Control-c */
!   { ISFUNC, rl_vi_eof_maybe },			/* Control-d */
!   { ISFUNC, rl_insert },			/* Control-e */
!   { ISFUNC, rl_insert },			/* Control-f */
!   { ISFUNC, rl_insert },			/* Control-g */
!   { ISFUNC, rl_rubout },			/* Control-h */
!   { ISFUNC, rl_complete },			/* Control-i */
!   { ISFUNC, rl_newline },			/* Control-j */
!   { ISFUNC, rl_insert },			/* Control-k */
!   { ISFUNC, rl_insert },			/* Control-l */
!   { ISFUNC, rl_newline },			/* Control-m */
!   { ISFUNC, rl_insert },			/* Control-n */
!   { ISFUNC, rl_insert },			/* Control-o */
!   { ISFUNC, rl_insert },			/* Control-p */
!   { ISFUNC, rl_insert },			/* Control-q */
!   { ISFUNC, rl_reverse_search_history },	/* Control-r */
!   { ISFUNC, rl_forward_search_history },	/* Control-s */
!   { ISFUNC, rl_transpose_chars },		/* Control-t */
!   { ISFUNC, rl_unix_line_discard },		/* Control-u */
!   { ISFUNC, rl_quoted_insert },			/* Control-v */
!   { ISFUNC, rl_unix_word_rubout },		/* Control-w */
!   { ISFUNC, rl_insert },			/* Control-x */
!   { ISFUNC, rl_yank },				/* Control-y */
!   { ISFUNC, rl_insert },			/* Control-z */
! 
!   { ISFUNC, rl_vi_movement_mode },		/* Control-[ */
!   { ISFUNC, rl_insert },			/* Control-\ */
!   { ISFUNC, rl_insert },			/* Control-] */
!   { ISFUNC, rl_insert },			/* Control-^ */
!   { ISFUNC, rl_vi_undo },			/* Control-_ */
  
    /* The start of printing characters. */
!   { ISFUNC, rl_insert },			/* SPACE */
!   { ISFUNC, rl_insert },			/* ! */
!   { ISFUNC, rl_insert },			/* " */
!   { ISFUNC, rl_insert },			/* # */
!   { ISFUNC, rl_insert },			/* $ */
!   { ISFUNC, rl_insert },			/* % */
!   { ISFUNC, rl_insert },			/* & */
!   { ISFUNC, rl_insert },			/* ' */
!   { ISFUNC, rl_insert },			/* ( */
!   { ISFUNC, rl_insert },			/* ) */
!   { ISFUNC, rl_insert },			/* * */
!   { ISFUNC, rl_insert },			/* + */
!   { ISFUNC, rl_insert },			/* , */
!   { ISFUNC, rl_insert },			/* - */
!   { ISFUNC, rl_insert },			/* . */
!   { ISFUNC, rl_insert },			/* / */
  
    /* Regular digits. */
!   { ISFUNC, rl_insert },			/* 0 */
!   { ISFUNC, rl_insert },			/* 1 */
!   { ISFUNC, rl_insert },			/* 2 */
!   { ISFUNC, rl_insert },			/* 3 */
!   { ISFUNC, rl_insert },			/* 4 */
!   { ISFUNC, rl_insert },			/* 5 */
!   { ISFUNC, rl_insert },			/* 6 */
!   { ISFUNC, rl_insert },			/* 7 */
!   { ISFUNC, rl_insert },			/* 8 */
!   { ISFUNC, rl_insert },			/* 9 */
  
    /* A little more punctuation. */
!   { ISFUNC, rl_insert },			/* : */
!   { ISFUNC, rl_insert },			/* ; */
!   { ISFUNC, rl_insert },			/* < */
!   { ISFUNC, rl_insert },			/* = */
!   { ISFUNC, rl_insert },			/* > */
!   { ISFUNC, rl_insert },			/* ? */
!   { ISFUNC, rl_insert },			/* @ */
  
    /* Uppercase alphabet. */
!   { ISFUNC, rl_insert },			/* A */
!   { ISFUNC, rl_insert },			/* B */
!   { ISFUNC, rl_insert },			/* C */
!   { ISFUNC, rl_insert },			/* D */
!   { ISFUNC, rl_insert },			/* E */
!   { ISFUNC, rl_insert },			/* F */
!   { ISFUNC, rl_insert },			/* G */
!   { ISFUNC, rl_insert },			/* H */
!   { ISFUNC, rl_insert },			/* I */
!   { ISFUNC, rl_insert },			/* J */
!   { ISFUNC, rl_insert },			/* K */
!   { ISFUNC, rl_insert },			/* L */
!   { ISFUNC, rl_insert },			/* M */
!   { ISFUNC, rl_insert },			/* N */
!   { ISFUNC, rl_insert },			/* O */
!   { ISFUNC, rl_insert },			/* P */
!   { ISFUNC, rl_insert },			/* Q */
!   { ISFUNC, rl_insert },			/* R */
!   { ISFUNC, rl_insert },			/* S */
!   { ISFUNC, rl_insert },			/* T */
!   { ISFUNC, rl_insert },			/* U */
!   { ISFUNC, rl_insert },			/* V */
!   { ISFUNC, rl_insert },			/* W */
!   { ISFUNC, rl_insert },			/* X */
!   { ISFUNC, rl_insert },			/* Y */
!   { ISFUNC, rl_insert },			/* Z */
  
    /* Some more punctuation. */
!   { ISFUNC, rl_insert },			/* [ */
!   { ISFUNC, rl_insert },			/* \ */
!   { ISFUNC, rl_insert },			/* ] */
!   { ISFUNC, rl_insert },			/* ^ */
!   { ISFUNC, rl_insert },			/* _ */
!   { ISFUNC, rl_insert },			/* ` */
  
    /* Lowercase alphabet. */
!   { ISFUNC, rl_insert },			/* a */
!   { ISFUNC, rl_insert },			/* b */
!   { ISFUNC, rl_insert },			/* c */
!   { ISFUNC, rl_insert },			/* d */
!   { ISFUNC, rl_insert },			/* e */
!   { ISFUNC, rl_insert },			/* f */
!   { ISFUNC, rl_insert },			/* g */
!   { ISFUNC, rl_insert },			/* h */
!   { ISFUNC, rl_insert },			/* i */
!   { ISFUNC, rl_insert },			/* j */
!   { ISFUNC, rl_insert },			/* k */
!   { ISFUNC, rl_insert },			/* l */
!   { ISFUNC, rl_insert },			/* m */
!   { ISFUNC, rl_insert },			/* n */
!   { ISFUNC, rl_insert },			/* o */
!   { ISFUNC, rl_insert },			/* p */
!   { ISFUNC, rl_insert },			/* q */
!   { ISFUNC, rl_insert },			/* r */
!   { ISFUNC, rl_insert },			/* s */
!   { ISFUNC, rl_insert },			/* t */
!   { ISFUNC, rl_insert },			/* u */
!   { ISFUNC, rl_insert },			/* v */
!   { ISFUNC, rl_insert },			/* w */
!   { ISFUNC, rl_insert },			/* x */
!   { ISFUNC, rl_insert },			/* y */
!   { ISFUNC, rl_insert },			/* z */
  
    /* Final punctuation. */
!   { ISFUNC, rl_insert },			/* { */
!   { ISFUNC, rl_insert },			/* | */
!   { ISFUNC, rl_insert },			/* } */
!   { ISFUNC, rl_insert },			/* ~ */
!   { ISFUNC, rl_rubout },			/* RUBOUT */
  
  #if KEYMAP_SIZE > 128
***************
*** 599,876 ****
  KEYMAP_ENTRY_ARRAY vi_escape_keymap = {
    /* The regular control keys come first. */
!   { ISFUNC, (Function *)0x0 },		/* Control-@ */
!   { ISFUNC, (Function *)0x0 },		/* Control-a */
!   { ISFUNC, (Function *)0x0 },		/* Control-b */
!   { ISFUNC, (Function *)0x0 },		/* Control-c */
!   { ISFUNC, (Function *)0x0 },		/* Control-d */
!   { ISFUNC, (Function *)0x0 },		/* Control-e */
!   { ISFUNC, (Function *)0x0 },		/* Control-f */
!   { ISFUNC, (Function *)0x0 },		/* Control-g */
!   { ISFUNC, (Function *)0x0 },		/* Control-h */
!   { ISFUNC, rl_tab_insert},		/* Control-i */
!   { ISFUNC, rl_emacs_editing_mode},	/* Control-j */
!   { ISFUNC, rl_kill_line },		/* Control-k */
!   { ISFUNC, (Function *)0x0 },		/* Control-l */
!   { ISFUNC, rl_emacs_editing_mode},	/* Control-m */
!   { ISFUNC, (Function *)0x0 },		/* Control-n */
!   { ISFUNC, (Function *)0x0 },		/* Control-o */
!   { ISFUNC, (Function *)0x0 },		/* Control-p */
!   { ISFUNC, (Function *)0x0 },		/* Control-q */
!   { ISFUNC, (Function *)0x0 },		/* Control-r */
!   { ISFUNC, (Function *)0x0 },		/* Control-s */
!   { ISFUNC, (Function *)0x0 },		/* Control-t */
!   { ISFUNC, (Function *)0x0 },		/* Control-u */
!   { ISFUNC, (Function *)0x0 },		/* Control-v */
!   { ISFUNC, (Function *)0x0 },		/* Control-w */
!   { ISFUNC, (Function *)0x0 },		/* Control-x */
!   { ISFUNC, (Function *)0x0 },		/* Control-y */
!   { ISFUNC, (Function *)0x0 },		/* Control-z */
! 
!   { ISFUNC, rl_vi_movement_mode },	/* Control-[ */
!   { ISFUNC, (Function *)0x0 },		/* Control-\ */
!   { ISFUNC, (Function *)0x0 },		/* Control-] */
!   { ISFUNC, (Function *)0x0 },		/* Control-^ */
!   { ISFUNC, rl_vi_undo },		/* Control-_ */
  
    /* The start of printing characters. */
!   { ISFUNC, (Function *)0x0 },		/* SPACE */
!   { ISFUNC, (Function *)0x0 },		/* ! */
!   { ISFUNC, (Function *)0x0 },		/* " */
!   { ISFUNC, (Function *)0x0 },		/* # */
!   { ISFUNC, (Function *)0x0 },		/* $ */
!   { ISFUNC, (Function *)0x0 },		/* % */
!   { ISFUNC, (Function *)0x0 },		/* & */
!   { ISFUNC, (Function *)0x0 },		/* ' */
!   { ISFUNC, (Function *)0x0 },		/* ( */
!   { ISFUNC, (Function *)0x0 },		/* ) */
!   { ISFUNC, (Function *)0x0 },		/* * */
!   { ISFUNC, (Function *)0x0 },		/* + */
!   { ISFUNC, (Function *)0x0 },		/* , */
!   { ISFUNC, (Function *)0x0 },		/* - */
!   { ISFUNC, (Function *)0x0 },		/* . */
!   { ISFUNC, (Function *)0x0 },		/* / */
  
    /* Regular digits. */
!   { ISFUNC, rl_vi_arg_digit },		/* 0 */
!   { ISFUNC, rl_vi_arg_digit },		/* 1 */
!   { ISFUNC, rl_vi_arg_digit },		/* 2 */
!   { ISFUNC, rl_vi_arg_digit },		/* 3 */
!   { ISFUNC, rl_vi_arg_digit },		/* 4 */
!   { ISFUNC, rl_vi_arg_digit },		/* 5 */
!   { ISFUNC, rl_vi_arg_digit },		/* 6 */
!   { ISFUNC, rl_vi_arg_digit },		/* 7 */
!   { ISFUNC, rl_vi_arg_digit },		/* 8 */
!   { ISFUNC, rl_vi_arg_digit },		/* 9 */
  
    /* A little more punctuation. */
!   { ISFUNC, (Function *)0x0 },		/* : */
!   { ISFUNC, (Function *)0x0 },		/* ; */
!   { ISFUNC, (Function *)0x0 },		/* < */
!   { ISFUNC, (Function *)0x0 },		/* = */
!   { ISFUNC, (Function *)0x0 },		/* > */
!   { ISFUNC, (Function *)0x0 },		/* ? */
!   { ISFUNC, (Function *)0x0 },		/* @ */
  
    /* Uppercase alphabet. */
!   { ISFUNC, rl_do_lowercase_version },	/* A */
!   { ISFUNC, rl_do_lowercase_version },	/* B */
!   { ISFUNC, rl_do_lowercase_version },	/* C */
!   { ISFUNC, rl_do_lowercase_version },	/* D */
!   { ISFUNC, rl_do_lowercase_version },	/* E */
!   { ISFUNC, rl_do_lowercase_version },	/* F */
!   { ISFUNC, rl_do_lowercase_version },	/* G */
!   { ISFUNC, rl_do_lowercase_version },	/* H */
!   { ISFUNC, rl_do_lowercase_version },	/* I */
!   { ISFUNC, rl_do_lowercase_version },	/* J */
!   { ISFUNC, rl_do_lowercase_version },	/* K */
!   { ISFUNC, rl_do_lowercase_version },	/* L */
!   { ISFUNC, rl_do_lowercase_version },	/* M */
!   { ISFUNC, rl_do_lowercase_version },	/* N */
!   { ISFUNC, rl_do_lowercase_version },	/* O */
!   { ISFUNC, rl_do_lowercase_version },	/* P */
!   { ISFUNC, rl_do_lowercase_version },	/* Q */
!   { ISFUNC, rl_do_lowercase_version },	/* R */
!   { ISFUNC, rl_do_lowercase_version },	/* S */
!   { ISFUNC, rl_do_lowercase_version },	/* T */
!   { ISFUNC, rl_do_lowercase_version },	/* U */
!   { ISFUNC, rl_do_lowercase_version },	/* V */
!   { ISFUNC, rl_do_lowercase_version },	/* W */
!   { ISFUNC, rl_do_lowercase_version },	/* X */
!   { ISFUNC, rl_do_lowercase_version },	/* Y */
!   { ISFUNC, rl_do_lowercase_version },	/* Z */
  
    /* Some more punctuation. */
!   { ISFUNC, rl_arrow_keys },		/* [ */
!   { ISFUNC, (Function *)0x0 },		/* \ */
!   { ISFUNC, (Function *)0x0 },		/* ] */
!   { ISFUNC, (Function *)0x0 },		/* ^ */
!   { ISFUNC, (Function *)0x0 },		/* _ */
!   { ISFUNC, (Function *)0x0 },		/* ` */
  
    /* Lowercase alphabet. */
!   { ISFUNC, (Function *)0x0 },		/* a */
!   { ISFUNC, (Function *)0x0 },		/* b */
!   { ISFUNC, (Function *)0x0 },		/* c */
!   { ISFUNC, (Function *)0x0 },		/* d */
!   { ISFUNC, (Function *)0x0 },		/* e */
!   { ISFUNC, (Function *)0x0 },		/* f */
!   { ISFUNC, (Function *)0x0 },		/* g */
!   { ISFUNC, (Function *)0x0 },		/* h */
!   { ISFUNC, (Function *)0x0 },		/* i */
!   { ISFUNC, (Function *)0x0 },		/* j */
!   { ISFUNC, (Function *)0x0 },		/* k */
!   { ISFUNC, (Function *)0x0 },		/* l */
!   { ISFUNC, (Function *)0x0 },		/* m */
!   { ISFUNC, (Function *)0x0 },		/* n */
!   { ISFUNC, rl_arrow_keys },		/* o */
!   { ISFUNC, (Function *)0x0 },		/* p */
!   { ISFUNC, (Function *)0x0 },		/* q */
!   { ISFUNC, (Function *)0x0 },		/* r */
!   { ISFUNC, (Function *)0x0 },		/* s */
!   { ISFUNC, (Function *)0x0 },		/* t */
!   { ISFUNC, (Function *)0x0 },		/* u */
!   { ISFUNC, (Function *)0x0 },		/* v */
!   { ISFUNC, (Function *)0x0 },		/* w */
!   { ISFUNC, (Function *)0x0 },		/* x */
!   { ISFUNC, (Function *)0x0 },		/* y */
!   { ISFUNC, (Function *)0x0 },		/* z */
  
    /* Final punctuation. */
!   { ISFUNC, (Function *)0x0 },		/* { */
!   { ISFUNC, (Function *)0x0 },		/* | */
!   { ISFUNC, (Function *)0x0 },		/* } */
!   { ISFUNC, (Function *)0x0 },		/* ~ */
!   { ISFUNC, rl_backward_kill_word },	/* RUBOUT */
  
  #if KEYMAP_SIZE > 128
    /* Undefined keys. */
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 },
!   { ISFUNC, (Function *)0x0 }
  #endif /* KEYMAP_SIZE > 128 */
  };
--- 599,876 ----
  KEYMAP_ENTRY_ARRAY vi_escape_keymap = {
    /* The regular control keys come first. */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-@ */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-a */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-b */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-c */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-d */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-e */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-f */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-g */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-h */
!   { ISFUNC, rl_tab_insert},			/* Control-i */
!   { ISFUNC, rl_emacs_editing_mode},		/* Control-j */
!   { ISFUNC, rl_kill_line },			/* Control-k */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-l */
!   { ISFUNC, rl_emacs_editing_mode},		/* Control-m */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-n */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-o */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-p */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-q */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-r */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-s */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-t */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-u */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-v */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-w */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-x */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-y */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-z */
! 
!   { ISFUNC, rl_vi_movement_mode },		/* Control-[ */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-\ */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-] */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-^ */
!   { ISFUNC, rl_vi_undo },			/* Control-_ */
  
    /* The start of printing characters. */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* SPACE */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* ! */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* " */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* # */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* $ */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* % */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* & */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* ' */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* ( */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* ) */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* * */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* + */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* , */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* - */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* . */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* / */
  
    /* Regular digits. */
!   { ISFUNC, rl_vi_arg_digit },			/* 0 */
!   { ISFUNC, rl_vi_arg_digit },			/* 1 */
!   { ISFUNC, rl_vi_arg_digit },			/* 2 */
!   { ISFUNC, rl_vi_arg_digit },			/* 3 */
!   { ISFUNC, rl_vi_arg_digit },			/* 4 */
!   { ISFUNC, rl_vi_arg_digit },			/* 5 */
!   { ISFUNC, rl_vi_arg_digit },			/* 6 */
!   { ISFUNC, rl_vi_arg_digit },			/* 7 */
!   { ISFUNC, rl_vi_arg_digit },			/* 8 */
!   { ISFUNC, rl_vi_arg_digit },			/* 9 */
  
    /* A little more punctuation. */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* : */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* ; */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* < */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* = */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* > */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* ? */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* @ */
  
    /* Uppercase alphabet. */
!   { ISFUNC, rl_do_lowercase_version },		/* A */
!   { ISFUNC, rl_do_lowercase_version },		/* B */
!   { ISFUNC, rl_do_lowercase_version },		/* C */
!   { ISFUNC, rl_do_lowercase_version },		/* D */
!   { ISFUNC, rl_do_lowercase_version },		/* E */
!   { ISFUNC, rl_do_lowercase_version },		/* F */
!   { ISFUNC, rl_do_lowercase_version },		/* G */
!   { ISFUNC, rl_do_lowercase_version },		/* H */
!   { ISFUNC, rl_do_lowercase_version },		/* I */
!   { ISFUNC, rl_do_lowercase_version },		/* J */
!   { ISFUNC, rl_do_lowercase_version },		/* K */
!   { ISFUNC, rl_do_lowercase_version },		/* L */
!   { ISFUNC, rl_do_lowercase_version },		/* M */
!   { ISFUNC, rl_do_lowercase_version },		/* N */
!   { ISFUNC, rl_do_lowercase_version },		/* O */
!   { ISFUNC, rl_do_lowercase_version },		/* P */
!   { ISFUNC, rl_do_lowercase_version },		/* Q */
!   { ISFUNC, rl_do_lowercase_version },		/* R */
!   { ISFUNC, rl_do_lowercase_version },		/* S */
!   { ISFUNC, rl_do_lowercase_version },		/* T */
!   { ISFUNC, rl_do_lowercase_version },		/* U */
!   { ISFUNC, rl_do_lowercase_version },		/* V */
!   { ISFUNC, rl_do_lowercase_version },		/* W */
!   { ISFUNC, rl_do_lowercase_version },		/* X */
!   { ISFUNC, rl_do_lowercase_version },		/* Y */
!   { ISFUNC, rl_do_lowercase_version },		/* Z */
  
    /* Some more punctuation. */
!   { ISFUNC, rl_arrow_keys },			/* [ */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* \ */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* ] */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* ^ */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* _ */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* ` */
  
    /* Lowercase alphabet. */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* a */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* b */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* c */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* d */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* e */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* f */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* g */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* h */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* i */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* j */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* k */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* l */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* m */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* n */
!   { ISFUNC, rl_arrow_keys },			/* o */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* p */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* q */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* r */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* s */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* t */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* u */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* v */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* w */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* x */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* y */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* z */
  
    /* Final punctuation. */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* { */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* | */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* } */
!   { ISFUNC, (rl_command_func_t *)0x0 },		/* ~ */
!   { ISFUNC, rl_backward_kill_word },		/* RUBOUT */
  
  #if KEYMAP_SIZE > 128
    /* Undefined keys. */
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 },
!   { ISFUNC, (rl_command_func_t *)0x0 }
  #endif /* KEYMAP_SIZE > 128 */
  };
diff -Nrc2 bash-2.04/lib/readline/vi_mode.c bash-2.05/lib/readline/vi_mode.c
*** bash-2.04/lib/readline/vi_mode.c	Thu Aug  5 08:16:33 1999
--- bash-2.05/lib/readline/vi_mode.c	Wed Nov  8 11:47:02 2000
***************
*** 82,86 ****
  
  /* Command keys which do movement for xxx_to commands. */
! static char *vi_motion = " hl^$0ftFt;,%wbeWBE|";
  
  /* Keymap used for vi replace characters.  Created dynamically since
--- 82,86 ----
  
  /* Command keys which do movement for xxx_to commands. */
! static const char *vi_motion = " hl^$0ftFt;,%wbeWBE|";
  
  /* Keymap used for vi replace characters.  Created dynamically since
***************
*** 110,114 ****
  
  /* Text modification commands.  These are the `redoable' commands. */
! static char *vi_textmod = "_*\\AaIiCcDdPpYyRrSsXx~";
  
  /* Arrays for the saved marks. */
--- 110,114 ----
  
  /* Text modification commands.  These are the `redoable' commands. */
! static const char *vi_textmod = "_*\\AaIiCcDdPpYyRrSsXx~";
  
  /* Arrays for the saved marks. */
***************
*** 275,279 ****
  
      default:
!       ding ();
        break;
      }
--- 275,279 ----
  
      default:
!       rl_ding ();
        break;
      }
***************
*** 331,335 ****
    if (rl_point == 0)
      {
!       ding ();
        return (0);
      }
--- 331,335 ----
    if (rl_point == 0)
      {
!       rl_ding ();
        return (0);
      }
***************
*** 353,357 ****
    if (rl_point >= (rl_end - 1))
      {
!       ding ();
        return (0);
      }
--- 353,357 ----
    if (rl_point >= (rl_end - 1))
      {
!       rl_ding ();
        return (0);
      }
***************
*** 371,375 ****
    if (count < 0)
      {
!       ding ();
        return -1;
      }
--- 371,375 ----
    if (count < 0)
      {
!       rl_ding ();
        return -1;
      }
***************
*** 745,749 ****
--- 745,751 ----
  
    rl_mark = rl_point;
+   RL_SETSTATE(RL_STATE_MOREINPUT);
    c = rl_read_key ();
+   RL_UNSETSTATE(RL_STATE_MOREINPUT);
    *nextkey = c;
  
***************
*** 756,760 ****
--- 758,764 ----
  	  rl_digit_loop1 ();
  	  rl_numeric_arg *= save;
+ 	  RL_SETSTATE(RL_STATE_MOREINPUT);
  	  c = rl_read_key ();	/* real command */
+ 	  RL_UNSETSTATE(RL_STATE_MOREINPUT);
  	  *nextkey = c;
  	}
***************
*** 826,830 ****
  
  /* A simplified loop for vi. Don't dispatch key at end.
!    Don't recognize minus sign? */
  static int
  rl_digit_loop1 ()
--- 830,835 ----
  
  /* A simplified loop for vi. Don't dispatch key at end.
!    Don't recognize minus sign?
!    Should this do rl_save_prompt/rl_restore_prompt? */
  static int
  rl_digit_loop1 ()
***************
*** 832,839 ****
--- 837,855 ----
    int key, c;
  
+   RL_SETSTATE(RL_STATE_NUMERICARG);
    while (1)
      {
+       if (rl_numeric_arg > 1000000)
+ 	{
+ 	  rl_explicit_arg = rl_numeric_arg = 0;
+ 	  rl_ding ();
+ 	  rl_clear_message ();
+ 	  RL_UNSETSTATE(RL_STATE_NUMERICARG);
+ 	  return 1;
+ 	}
        rl_message ("(arg: %d) ", rl_arg_sign * rl_numeric_arg, 0);
+       RL_SETSTATE(RL_STATE_MOREINPUT);
        key = c = rl_read_key ();
+       RL_UNSETSTATE(RL_STATE_MOREINPUT);
  
        if (_rl_keymap[c].type == ISFUNC &&
***************
*** 860,863 ****
--- 876,881 ----
  	}
      }
+ 
+   RL_UNSETSTATE(RL_STATE_NUMERICARG);
    return (0);
  }
***************
*** 876,880 ****
    if (rl_vi_domove (key, &c))
      {
!       ding ();
        return -1;
      }
--- 894,898 ----
    if (rl_vi_domove (key, &c))
      {
!       rl_ding ();
        return -1;
      }
***************
*** 904,908 ****
    if (rl_vi_domove (key, &c))
      {
!       ding ();
        return -1;
      }
--- 922,926 ----
    if (rl_vi_domove (key, &c))
      {
!       rl_ding ();
        return -1;
      }
***************
*** 954,958 ****
    if (rl_vi_domove (key, &c))
      {
!       ding ();
        return -1;
      }
--- 972,976 ----
    if (rl_vi_domove (key, &c))
      {
!       rl_ding ();
        return -1;
      }
***************
*** 980,984 ****
    if (rl_end == 0)
      {
!       ding ();
        return -1;
      }
--- 998,1002 ----
    if (rl_end == 0)
      {
!       rl_ding ();
        return -1;
      }
***************
*** 1027,1031 ****
  	target = _rl_vi_last_search_char;
        else
! 	_rl_vi_last_search_char = target = (*rl_getc_function) (rl_instream);
  
        switch (key)
--- 1045,1053 ----
  	target = _rl_vi_last_search_char;
        else
! 	{
! 	  RL_SETSTATE(RL_STATE_MOREINPUT);
! 	  _rl_vi_last_search_char = target = rl_read_key ();
! 	  RL_UNSETSTATE(RL_STATE_MOREINPUT);
! 	}
  
        switch (key)
***************
*** 1069,1073 ****
  	{
  	  rl_point = pos;
! 	  ding ();
  	  return -1;
  	}
--- 1091,1095 ----
  	{
  	  rl_point = pos;
! 	  rl_ding ();
  	  return -1;
  	}
***************
*** 1090,1094 ****
  	  else
  	    {
! 	      ding ();
  	      return -1;
  	    }
--- 1112,1116 ----
  	  else
  	    {
! 	      rl_ding ();
  	      return -1;
  	    }
***************
*** 1109,1113 ****
  	  else
  	    {
! 	      ding ();
  	      return -1;
  	    }
--- 1131,1135 ----
  	  else
  	    {
! 	      rl_ding ();
  	      return -1;
  	    }
***************
*** 1143,1147 ****
      c = _rl_vi_last_replacement;
    else
!     _rl_vi_last_replacement = c = (*rl_getc_function) (rl_instream);
  
    if (c == '\033' || c == CTRL ('C'))
--- 1165,1173 ----
      c = _rl_vi_last_replacement;
    else
!     {
!       RL_SETSTATE(RL_STATE_MOREINPUT);
!       _rl_vi_last_replacement = c = rl_read_key ();
!       RL_UNSETSTATE(RL_STATE_MOREINPUT);
!     }
  
    if (c == '\033' || c == CTRL ('C'))
***************
*** 1239,1243 ****
        if (vi_replace_count == 0)
  	{
! 	  ding ();
  	  break;
  	}
--- 1265,1269 ----
        if (vi_replace_count == 0)
  	{
! 	  rl_ding ();
  	  break;
  	}
***************
*** 1309,1313 ****
    else if (rl_line_buffer[rl_point - 1] == ';')
      {
!       ding ();
        return (0);
      }
--- 1335,1339 ----
    else if (rl_line_buffer[rl_point - 1] == ';')
      {
!       rl_ding ();
        return (0);
      }
***************
*** 1327,1334 ****
    int ch;
  
    ch = rl_read_key ();
    if (_rl_lowercase_p (ch) == 0)
      {
!       ding ();
        return -1;
      }
--- 1353,1363 ----
    int ch;
  
+   RL_SETSTATE(RL_STATE_MOREINPUT);
    ch = rl_read_key ();
+   RL_UNSETSTATE(RL_STATE_MOREINPUT);
+ 
    if (_rl_lowercase_p (ch) == 0)
      {
!       rl_ding ();
        return -1;
      }
***************
*** 1344,1348 ****
--- 1373,1380 ----
    int ch;
  
+   RL_SETSTATE(RL_STATE_MOREINPUT);
    ch = rl_read_key ();
+   RL_UNSETSTATE(RL_STATE_MOREINPUT);
+ 
    if (ch == '`')
      {
***************
*** 1352,1356 ****
    else if (_rl_lowercase_p (ch) == 0)
      {
!       ding ();
        return -1;
      }
--- 1384,1388 ----
    else if (_rl_lowercase_p (ch) == 0)
      {
!       rl_ding ();
        return -1;
      }
***************
*** 1359,1363 ****
    if (vi_mark_chars[ch] == -1)
      {
!       ding ();
        return -1;
      }
--- 1391,1395 ----
    if (vi_mark_chars[ch] == -1)
      {
!       rl_ding ();
        return -1;
      }
diff -Nrc2 bash-2.04/lib/sh/Makefile.in bash-2.05/lib/sh/Makefile.in
*** bash-2.04/lib/sh/Makefile.in	Mon Nov 29 11:46:18 1999
--- bash-2.05/lib/sh/Makefile.in	Sat Oct 14 17:35:54 2000
***************
*** 65,69 ****
  	   strcasecmp.c strerror.c strtod.c strtol.c strtoul.c \
  	   vprint.c itos.c rename.c zread.c zwrite.c shtty.c \
! 	   inet_aton.c netopen.c strpbrk.c timeval.c makepath.c
  
  # The header files for this library.
--- 65,71 ----
  	   strcasecmp.c strerror.c strtod.c strtol.c strtoul.c \
  	   vprint.c itos.c rename.c zread.c zwrite.c shtty.c \
! 	   inet_aton.c netopen.c strpbrk.c timeval.c makepath.c pathcanon.c \
! 	   pathphys.c tmpfile.c stringlist.c stringvec.c spell.c \
! 	   shquote.c strtrans.c strindex.c
  
  # The header files for this library.
***************
*** 74,78 ****
  	  strcasecmp.o strerror.o strtod.o strtol.o strtoul.o \
  	  vprint.o itos.o rename.o zread.o zwrite.o shtty.o \
! 	  inet_aton.o netopen.o strpbrk.o timeval.o makepath.o
  
  SUPPORT = Makefile
--- 76,82 ----
  	  strcasecmp.o strerror.o strtod.o strtol.o strtoul.o \
  	  vprint.o itos.o rename.o zread.o zwrite.o shtty.o \
! 	  inet_aton.o netopen.o strpbrk.o timeval.o makepath.o pathcanon.o \
! 	  pathphys.o tmpfile.o stringlist.o stringvec.o spell.o shquote.o \
! 	  strtrans.o strindex.o
  
  SUPPORT = Makefile
***************
*** 109,126 ****
--- 113,139 ----
  inet_aton.o: inet_aton.c
  itos.o: itos.c
+ makepath.o: makepath.c
  netopen.o: netopen.c
  oslib.o: oslib.c
+ pathcanon.o: pathcanon.c
+ pathphys.o: pathphys.c
  rename.o: rename.c
  setlinebuf.o: setlinebuf.c
  shquote.o: shquote.c
  shtty.o: shtty.c
+ spell.o: spell.c
  strcasecmp.o: strcasecmp.c
  strerror.o: strerror.c
+ strindex.o: strindex.c
+ stringlist.o: stringlist.c
+ stringvec.o: stringvec.c
  strpbrk.o: strpbrk.c
  strtod.o: strtod.c
  strtol.o: strtol.c
  strtoul.o: strtoul.c
+ strtrans.o: strtrans.c
  times.o: times.c
  timeval.o: timeval.c
+ tmpfile.o: tmpfile.c
  vprint.o: vprint.c
  zread.o: zread.c
***************
*** 134,151 ****
--- 147,173 ----
  inet_aton.o: ${BUILD_DIR}/config.h
  itos.o: ${BUILD_DIR}/config.h
+ makepath.o: ${BUILD_DIR}/config.h
  netopen.o: ${BUILD_DIR}/config.h
  oslib.o: ${BUILD_DIR}/config.h
+ pathcanon.o: ${BUILD_DIR}/config.h
+ pathphys.o: ${BUILD_DIR}/config.h
  rename.o: ${BUILD_DIR}/config.h
  setlinebuf.o: ${BUILD_DIR}/config.h
  shquote.o: ${BUILD_DIR}/config.h
  shtty.o: ${BUILD_DIR}/config.h
+ spell.o: ${BUILD_DIR}/config.h
  strcasecmp.o: ${BUILD_DIR}/config.h
  strerror.o: ${BUILD_DIR}/config.h
+ strindex.o: ${BUILD_DIR}/config.h
+ stringlist.o: ${BUILD_DIR}/config.h
+ stringvec.o: ${BUILD_DIR}/config.h
  strpbrk.o: ${BUILD_DIR}/config.h
  strtod.o: ${BUILD_DIR}/config.h
  strtol.o: ${BUILD_DIR}/config.h
  strtoul.o: ${BUILD_DIR}/config.h
+ strtrans.o: ${BUILD_DIR}/config.h
  times.o: ${BUILD_DIR}/config.h
  timeval.o: ${BUILD_DIR}/config.h
+ tmpfile.o: ${BUILD_DIR}/config.h
  vprint.o: ${BUILD_DIR}/config.h
  zread.o: ${BUILD_DIR}/config.h
***************
*** 159,163 ****
  
  getenv.o: ${topdir}/bashansi.h ${BASHINCDIR}/ansi_stdlib.h
! getenv.o: ${topdir}/shell.h ${topdir}/bashjmp.h ${BASHINCDIR}/posixjmp.h
  getenv.o: ${topdir}/command.h ${BASHINCDIR}/stdc.h ${topdir}/error.h
  getenv.o: ${topdir}/general.h ${topdir}/bashtypes.h ${topdir}/variables.h
--- 181,185 ----
  
  getenv.o: ${topdir}/bashansi.h ${BASHINCDIR}/ansi_stdlib.h
! getenv.o: ${topdir}/shell.h ${topdir}/syntax.h ${topdir}/bashjmp.h ${BASHINCDIR}/posixjmp.h
  getenv.o: ${topdir}/command.h ${BASHINCDIR}/stdc.h ${topdir}/error.h
  getenv.o: ${topdir}/general.h ${topdir}/bashtypes.h ${topdir}/variables.h
***************
*** 171,175 ****
  
  itos.o: ${topdir}/bashansi.h ${BASHINCDIR}/ansi_stdlib.h
! itos.o: ${topdir}/shell.h ${topdir}/bashjmp.h ${BASHINCDIR}/posixjmp.h
  itos.o: ${topdir}/command.h ${BASHINCDIR}/stdc.h ${topdir}/error.h
  itos.o: ${topdir}/general.h ${topdir}/bashtypes.h ${topdir}/variables.h
--- 193,197 ----
  
  itos.o: ${topdir}/bashansi.h ${BASHINCDIR}/ansi_stdlib.h
! itos.o: ${topdir}/shell.h ${topdir}/syntax.h ${topdir}/bashjmp.h ${BASHINCDIR}/posixjmp.h
  itos.o: ${topdir}/command.h ${BASHINCDIR}/stdc.h ${topdir}/error.h
  itos.o: ${topdir}/general.h ${topdir}/bashtypes.h ${topdir}/variables.h
***************
*** 179,186 ****
  itos.o: ${topdir}/pathnames.h ${topdir}/externs.h
  
  netopen.o: ${topdir}/bashansi.h ${BASHINCDIR}/ansi_stdlib.h
  
  oslib.o: ${topdir}/bashtypes.h ${topdir}/bashansi.h ${BASHINCDIR}/maxpath.h
! oslib.o: ${topdir}/shell.h ${topdir}/bashjmp.h ${BASHINCDIR}/posixjmp.h
  oslib.o: ${topdir}/command.h ${BASHINCDIR}/stdc.h ${topdir}/error.h
  oslib.o: ${topdir}/general.h ${topdir}/bashtypes.h ${topdir}/variables.h
--- 201,217 ----
  itos.o: ${topdir}/pathnames.h ${topdir}/externs.h
  
+ makepath.o: ${topdir}/bashansi.h ${BASHINCDIR}/ansi_stdlib.h
+ makepath.o: ${topdir}/shell.h ${topdir}/syntax.h ${topdir}/bashjmp.h ${BASHINCDIR}/posixjmp.h
+ makepath.o: ${topdir}/command.h ${BASHINCDIR}/stdc.h ${topdir}/error.h
+ makepath.o: ${topdir}/general.h ${topdir}/bashtypes.h ${topdir}/variables.h
+ makepath.o: ${topdir}/array.h ${topdir}/hashlib.h ${topdir}/quit.h
+ makepath.o: ${topdir}/unwind_prot.h ${topdir}/dispose_cmd.h
+ makepath.o: ${topdir}/make_cmd.h ${topdir}/subst.h ${topdir}/sig.h
+ makepath.o: ${topdir}/pathnames.h ${topdir}/externs.h
+ 
  netopen.o: ${topdir}/bashansi.h ${BASHINCDIR}/ansi_stdlib.h
  
  oslib.o: ${topdir}/bashtypes.h ${topdir}/bashansi.h ${BASHINCDIR}/maxpath.h
! oslib.o: ${topdir}/shell.h ${topdir}/syntax.h ${topdir}/bashjmp.h ${BASHINCDIR}/posixjmp.h
  oslib.o: ${topdir}/command.h ${BASHINCDIR}/stdc.h ${topdir}/error.h
  oslib.o: ${topdir}/general.h ${topdir}/bashtypes.h ${topdir}/variables.h
***************
*** 192,195 ****
--- 223,248 ----
  oslib.o: ${BASHINCDIR}/ansi_stdlib.h
  
+ pathcanon.o: ${topdir}/bashtypes.h ${topdir}/bashansi.h ${BASHINCDIR}/maxpath.h
+ pathcanon.o: ${topdir}/shell.h ${topdir}/syntax.h ${topdir}/bashjmp.h ${BASHINCDIR}/posixjmp.h
+ pathcanon.o: ${topdir}/command.h ${BASHINCDIR}/stdc.h ${topdir}/error.h
+ pathcanon.o: ${topdir}/general.h ${topdir}/bashtypes.h ${topdir}/variables.h
+ pathcanon.o: ${topdir}/array.h ${topdir}/hashlib.h ${topdir}/quit.h
+ pathcanon.o: ${topdir}/unwind_prot.h ${topdir}/dispose_cmd.h
+ pathcanon.o: ${topdir}/make_cmd.h ${topdir}/subst.h ${topdir}/sig.h
+ pathcanon.o: ${topdir}/pathnames.h ${topdir}/externs.h
+ pathcanon.o: ${BASHINCDIR}/posixstat.h ${BASHINCDIR}/filecntl.h
+ pathcanon.o: ${BASHINCDIR}/ansi_stdlib.h
+ 
+ pathphys.o: ${topdir}/bashtypes.h ${topdir}/bashansi.h ${BASHINCDIR}/maxpath.h
+ pathphys.o: ${topdir}/shell.h ${topdir}/syntax.h ${topdir}/bashjmp.h ${BASHINCDIR}/posixjmp.h
+ pathphys.o: ${topdir}/command.h ${BASHINCDIR}/stdc.h ${topdir}/error.h
+ pathphys.o: ${topdir}/general.h ${topdir}/bashtypes.h ${topdir}/variables.h
+ pathphys.o: ${topdir}/array.h ${topdir}/hashlib.h ${topdir}/quit.h
+ pathphys.o: ${topdir}/unwind_prot.h ${topdir}/dispose_cmd.h
+ pathphys.o: ${topdir}/make_cmd.h ${topdir}/subst.h ${topdir}/sig.h
+ pathphys.o: ${topdir}/pathnames.h ${topdir}/externs.h
+ pathphys.o: ${BASHINCDIR}/posixstat.h ${BASHINCDIR}/filecntl.h
+ pathphys.o: ${BASHINCDIR}/ansi_stdlib.h
+ 
  rename.o: ${topdir}/bashtypes.h ${BASHINCDIR}/stdc.h
  
***************
*** 197,204 ****
  shtty.o: ${BASHINCDIR}/stdc.h
  
! strcasecmp.o: ${BASHINCDIR}/stdc.h ${topdir}/bashansi.h ${BASHINCDIR}/ansi_stdlib.h
  
  strerror.o: ${topdir}/bashtypes.h
! strerror.o: ${topdir}/shell.h ${topdir}/bashjmp.h ${BASHINCDIR}/posixjmp.h
  strerror.o: ${topdir}/command.h ${BASHINCDIR}/stdc.h ${topdir}/error.h
  strerror.o: ${topdir}/general.h ${topdir}/bashtypes.h ${topdir}/variables.h
--- 250,262 ----
  shtty.o: ${BASHINCDIR}/stdc.h
  
! spell.o: ${topdir}/bashtypes.h
! spell.o: ${BASHINCDIR}/posixstat.h ${BASHINCDIR}/posixdir.h
! spell.o: ${BASHINCDIR}/ansi_stdlib.h
! 
! strcasecmp.o: ${BASHINCDIR}/stdc.h ${topdir}/bashansi.h
! strcasecmp.o: ${BASHINCDIR}/ansi_stdlib.h
  
  strerror.o: ${topdir}/bashtypes.h
! strerror.o: ${topdir}/shell.h ${topdir}/syntax.h ${topdir}/bashjmp.h ${BASHINCDIR}/posixjmp.h
  strerror.o: ${topdir}/command.h ${BASHINCDIR}/stdc.h ${topdir}/error.h
  strerror.o: ${topdir}/general.h ${topdir}/bashtypes.h ${topdir}/variables.h
***************
*** 208,211 ****
--- 266,290 ----
  strerror.o: ${topdir}/pathnames.h ${topdir}/externs.h
  
+ strindex.o: ${BASHINCDIR}/stdc.h ${topdir}/bashansi.h
+ strindex.o: ${BASHINCDIR}/ansi_stdlib.h
+ 
+ stringlist.o: ${topdir}/bashansi.h
+ stringlist.o: ${topdir}/shell.h ${topdir}/syntax.h ${topdir}/bashjmp.h ${BASHINCDIR}/posixjmp.h
+ stringlist.o: ${topdir}/command.h ${BASHINCDIR}/stdc.h ${topdir}/error.h
+ stringlist.o: ${topdir}/general.h ${topdir}/bashtypes.h ${topdir}/variables.h
+ stringlist.o: ${topdir}/array.h ${topdir}/hashlib.h ${topdir}/quit.h
+ stringlist.o: ${topdir}/unwind_prot.h ${topdir}/dispose_cmd.h
+ stringlist.o: ${topdir}/make_cmd.h ${topdir}/subst.h ${topdir}/sig.h
+ stringlist.o: ${topdir}/pathnames.h ${topdir}/externs.h
+ 
+ stringvec.o: ${topdir}/bashansi.h
+ stringvec.o: ${topdir}/shell.h ${topdir}/syntax.h ${topdir}/bashjmp.h ${BASHINCDIR}/posixjmp.h
+ stringvec.o: ${topdir}/command.h ${BASHINCDIR}/stdc.h ${topdir}/error.h
+ stringvec.o: ${topdir}/general.h ${topdir}/bashtypes.h ${topdir}/variables.h
+ stringvec.o: ${topdir}/array.h ${topdir}/hashlib.h ${topdir}/quit.h
+ stringvec.o: ${topdir}/unwind_prot.h ${topdir}/dispose_cmd.h
+ stringvec.o: ${topdir}/make_cmd.h ${topdir}/subst.h ${topdir}/sig.h
+ stringvec.o: ${topdir}/pathnames.h ${topdir}/externs.h
+ 
  strpbrk.o: ${BASHINCDIR}/stdc.h
  
***************
*** 219,226 ****
--- 298,319 ----
  strtoul.o: ${BASHINCDIR}/ansi_stdlib.h
  
+ strtrans.o: ${topdir}/bashansi.h
+ strtrans.o: ${BASHINCDIR}/ansi_stdlib.h
+ strtrans.o: ${topdir}/shell.h ${topdir}/syntax.h ${topdir}/bashjmp.h ${BASHINCDIR}/posixjmp.h
+ strtrans.o: ${topdir}/command.h ${BASHINCDIR}/stdc.h ${topdir}/error.h
+ strtrans.o: ${topdir}/general.h ${topdir}/bashtypes.h ${topdir}/variables.h
+ strtrans.o: ${topdir}/array.h ${topdir}/hashlib.h ${topdir}/quit.h
+ strtrans.o: ${topdir}/unwind_prot.h ${topdir}/dispose_cmd.h
+ strtrans.o: ${topdir}/make_cmd.h ${topdir}/subst.h ${topdir}/sig.h
+ strtrans.o: ${topdir}/pathnames.h ${topdir}/externs.h
+ 
  times.o: ${BASHINCDIR}/systimes.h
  times.o: ${BASHINCDIR}/posixtime.h
  
  timeval.o: ${BASHINCDIR}/posixtime.h
+ 
+ tmpfile.o: ${topdir}/bashtypes.h
+ tmpfile.o: ${BASHINCDIR}/posixstat.h
+ tmpfile.o: ${BASHINCDIR}/filecntl.h
  
  clock.o: ${BASHINCDIR}/posixtime.h
diff -Nrc2 bash-2.04/lib/sh/makepath.c bash-2.05/lib/sh/makepath.c
*** bash-2.04/lib/sh/makepath.c	Mon Nov 29 12:55:42 1999
--- bash-2.05/lib/sh/makepath.c	Mon Sep 11 10:07:19 2000
***************
*** 69,73 ****
  {
    int dirlen, pathlen;
!   char *ret, *xpath;
  
    if (path == 0 || *path == '\0')
--- 69,73 ----
  {
    int dirlen, pathlen;
!   char *ret, *xpath, *r, *s;
  
    if (path == 0 || *path == '\0')
***************
*** 103,114 ****
      }
  
!   ret = xmalloc (2 + dirlen + pathlen);
!   strcpy (ret, xpath);
!   if (xpath[pathlen - 1] != '/')
!     {
!       ret[pathlen++] = '/';
!       ret[pathlen] = '\0';
!     }
!   strcpy (ret + pathlen, dir);
    if (xpath != path)
      free (xpath);
--- 103,115 ----
      }
  
!   r = ret = xmalloc (2 + dirlen + pathlen);
!   s = xpath;
!   while (*s)
!     *r++ = *s++;
!   if (s[-1] != '/')
!     *r++ = '/';      
!   s = dir;
!   while (*r++ = *s++)
!     ;
    if (xpath != path)
      free (xpath);
diff -Nrc2 bash-2.04/lib/sh/netopen.c bash-2.05/lib/sh/netopen.c
*** bash-2.04/lib/sh/netopen.c	Tue Feb 22 11:31:37 2000
--- bash-2.05/lib/sh/netopen.c	Tue Aug  1 14:59:59 2000
***************
*** 98,103 ****
     PP in network byte order. */   
  static int
! _getserv (serv, pp)
       char *serv;
       unsigned short *pp;
  {
--- 98,104 ----
     PP in network byte order. */   
  static int
! _getserv (serv, proto, pp)
       char *serv;
+      int proto;
       unsigned short *pp;
  {
***************
*** 116,120 ****
--- 117,134 ----
      }
    else
+ #if defined (HAVE_GETSERVBYNAME)
+     {
+       struct servent *se;
+ 
+       se = getservbyname (serv, (proto == 't') ? "tcp" : "udp");
+       if (se == 0)
+ 	return 0;
+       if (pp)
+ 	*pp = se->s_port;	/* ports returned in network byte order */
+       return 1;
+     }
+ #else /* !HAVE_GETSERVBYNAME */
      return 0;
+ #endif /* !HAVE_GETSERVBYNAME */
  }
  
***************
*** 127,131 ****
    struct sockaddr_in sin;
    unsigned short p;
!   int s;
    char **cp;
  
--- 141,145 ----
    struct sockaddr_in sin;
    unsigned short p;
!   int s, e;
    char **cp;
  
***************
*** 133,142 ****
      {
        internal_error ("%s: host unknown", host);
        return -1;
      }
  
!   if (_getserv(serv, &p) == 0)
      {
        internal_error("%s: invalid service", serv);
        return -1;
      }
--- 147,158 ----
      {
        internal_error ("%s: host unknown", host);
+       errno = EINVAL;
        return -1;
      }
  
!   if (_getserv(serv, typ, &p) == 0)
      {
        internal_error("%s: invalid service", serv);
+       errno = EINVAL;
        return -1;
      }
***************
*** 156,161 ****
--- 172,179 ----
    if (connect (s, (struct sockaddr *)&sin, sizeof (sin)) < 0)
      {
+       e = errno;
        sys_error("connect");
        close(s);
+       errno = e;
        return (-1);
      }
diff -Nrc2 bash-2.04/lib/sh/pathcanon.c bash-2.05/lib/sh/pathcanon.c
*** bash-2.04/lib/sh/pathcanon.c	Wed Dec 31 19:00:00 1969
--- bash-2.05/lib/sh/pathcanon.c	Wed Feb 14 17:02:38 2001
***************
*** 0 ****
--- 1,195 ----
+ /* pathcanon.c -- Canonicalize and manipulate pathnames. */
+ 
+ /* Copyright (C) 2000 Free Software Foundation, Inc.
+ 
+    This file is part of GNU Bash, the Bourne Again SHell.
+ 
+    Bash is free software; you can redistribute it and/or modify it under
+    the terms of the GNU General Public License as published by the Free
+    Software Foundation; either version 2, or (at your option) any later
+    version.
+ 
+    Bash is distributed in the hope that it will be useful, but WITHOUT ANY
+    WARRANTY; without even the implied warranty of MERCHANTABILITY or
+    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+    for more details.
+ 
+    You should have received a copy of the GNU General Public License along
+    with Bash; see the file COPYING.  If not, write to the Free Software
+    Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. */
+ 
+ #include "config.h"
+ 
+ #include "bashtypes.h"
+ #ifndef _MINIX
+ #  include <sys/param.h>
+ #endif
+ #include "posixstat.h"
+ 
+ #if defined (HAVE_UNISTD_H)
+ #  include <unistd.h>
+ #endif
+ 
+ #include "filecntl.h"
+ #include "bashansi.h"
+ #include <stdio.h>
+ 
+ #include "shell.h"
+ 
+ #include "maxpath.h"
+ 
+ /* Return 1 if PATH corresponds to a directory.  A function for debugging. */
+ static int
+ _path_isdir (path)
+      char *path;
+ {
+   int l;
+   struct stat sb;
+ 
+   l = stat (path, &sb) == 0 && S_ISDIR (sb.st_mode);
+   return l;
+ }
+ 
+ /* Canonicalize PATH, and return a new path.  The new path differs from PATH
+    in that:
+ 	Multple `/'s are collapsed to a single `/'.
+ 	Leading `./'s and trailing `/.'s are removed.
+ 	Trailing `/'s are removed.
+ 	Non-leading `../'s and trailing `..'s are handled by removing
+ 	portions of the path. */
+ 
+ /* Look for ROOTEDPATH, PATHSEP, DIRSEP, and ISDIRSEP in ../../general.h */
+ 
+ #define DOUBLE_SLASH(p)	((p[0] == '/') && (p[1] == '/') && p[2] != '/')
+ 
+ char *
+ sh_canonpath (path, flags)
+      char *path;
+      int flags;
+ {
+   char stub_char;
+   char *result, *p, *q, *base, *dotdot;
+   int rooted, double_slash_path;
+ 
+   /* The result cannot be larger than the input PATH. */
+   result = (flags & PATH_NOALLOC) ? path : savestring (path);
+ 
+   /* POSIX.2 says to leave a leading `//' alone.  On cygwin, we skip over any
+      leading `x:' (dos drive name). */
+   if (rooted = ROOTEDPATH(path))
+     {
+       stub_char = DIRSEP;
+ #if defined (__CYGWIN__)
+       base = (isalpha(result[0]) && result[1] == ':') ? result + 3 : result + 1;
+ #else
+       base = result + 1;
+ #endif
+       double_slash_path = DOUBLE_SLASH (path);
+       base += double_slash_path;
+     }
+   else
+     {
+       stub_char = '.';
+ #if defined (__CYGWIN__)
+       base = (isalpha(result[0]) && result[1] == ':') ? result + 2 : result;
+ #else
+       base = result;
+ #endif
+     }
+ 
+   /*
+    * invariants:
+    *	  base points to the portion of the path we want to modify
+    *      p points at beginning of path element we're considering.
+    *      q points just past the last path element we wrote (no slash).
+    *      dotdot points just past the point where .. cannot backtrack
+    *	  any further (no slash).
+    */
+   p = q = dotdot = base;
+ 
+   while (*p)
+     {
+       if (ISDIRSEP(p[0])) /* null element */
+ 	p++;
+       else if(p[0] == '.' && PATHSEP(p[1]))	/* . and ./ */
+ 	p += 1; 	/* don't count the separator in case it is nul */
+       else if (p[0] == '.' && p[1] == '.' && PATHSEP(p[2])) /* .. and ../ */
+ 	{
+ 	  p += 2; /* skip `..' */
+ 	  if (q > dotdot)	/* can backtrack */
+ 	    {
+ 	      if (flags & PATH_CHECKDOTDOT)
+ 		{
+ 		  char c;
+ 
+ 		  /* Make sure what we have so far corresponds to a valid
+ 		     path before we chop some of it off. */
+ 		  c = *q;
+ 		  *q = '\0';
+ 		  if (_path_isdir (result) == 0)
+ 		    {
+ 		      if ((flags & PATH_NOALLOC) == 0)
+ 			free (result);
+ 		      return ((char *)NULL);
+ 		    }
+ 		  *q = c;
+ 		}
+ 
+ 	      while (--q > dotdot && ISDIRSEP(*q) == 0)
+ 		;
+ 	    }
+ 	  else if (rooted == 0)
+ 	    {
+ 	      /* /.. is / but ./../ is .. */
+ 	      if (q != base)
+ 		*q++ = DIRSEP;
+ 	      *q++ = '.';
+ 	      *q++ = '.';
+ 	      dotdot = q;
+ 	    }
+ 	}
+       else	/* real path element */
+ 	{
+ 	  /* add separator if not at start of work portion of result */
+ 	  if (q != base)
+ 	    *q++ = DIRSEP;
+ 	  while (*p && (ISDIRSEP(*p) == 0))
+ 	    *q++ = *p++;
+ 	  /* Check here for a valid directory with _path_isdir. */
+ 	  if (flags & PATH_CHECKEXISTS)
+ 	    {
+ 	      char c;
+ 
+ 	      /* Make sure what we have so far corresponds to a valid
+ 		 path before we chop some of it off. */
+ 	      c = *q;
+ 	      *q = '\0';
+ 	      if (_path_isdir (result) == 0)
+ 		{
+ 		  if ((flags & PATH_NOALLOC) == 0)
+ 		    free (result);
+ 		  return ((char *)NULL);
+ 		}
+ 	      *q = c;
+ 	    }
+ 	}
+     }
+ 
+   /* Empty string is really ``.'' or `/', depending on what we started with. */
+   if (q == result)
+     *q++ = stub_char;
+   *q = '\0';
+ 
+   /* If the result starts with `//', but the original path does not, we
+      can turn the // into /.  Because of how we set `base', this should never
+      be true, but it's a sanity check. */
+   if (DOUBLE_SLASH(result) && double_slash_path == 0)
+     {
+       if (result[2] == '\0')	/* short-circuit for bare `//' */
+ 	result[1] = '\0';
+       else
+ 	strcpy (result, result + 1);
+     }
+ 
+   return (result);
+ }
diff -Nrc2 bash-2.04/lib/sh/pathphys.c bash-2.05/lib/sh/pathphys.c
*** bash-2.04/lib/sh/pathphys.c	Wed Dec 31 19:00:00 1969
--- bash-2.05/lib/sh/pathphys.c	Wed Feb 14 17:02:43 2001
***************
*** 0 ****
--- 1,256 ----
+ /* pathphys.c -- Return pathname with all symlinks expanded. */
+ 
+ /* Copyright (C) 2000 Free Software Foundation, Inc.
+ 
+    This file is part of GNU Bash, the Bourne Again SHell.
+ 
+    Bash is free software; you can redistribute it and/or modify it under
+    the terms of the GNU General Public License as published by the Free
+    Software Foundation; either version 2, or (at your option) any later
+    version.
+ 
+    Bash is distributed in the hope that it will be useful, but WITHOUT ANY
+    WARRANTY; without even the implied warranty of MERCHANTABILITY or
+    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+    for more details.
+ 
+    You should have received a copy of the GNU General Public License along
+    with Bash; see the file COPYING.  If not, write to the Free Software
+    Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. */
+ 
+ #include "config.h"
+ 
+ #include "bashtypes.h"
+ #ifndef _MINIX
+ #  include <sys/param.h>
+ #endif
+ #include "posixstat.h"
+ 
+ #if defined (HAVE_UNISTD_H)
+ #  include <unistd.h>
+ #endif
+ 
+ #include "filecntl.h"
+ #include "bashansi.h"
+ #include <stdio.h>
+ #include <errno.h>
+ 
+ #include "shell.h"
+ 
+ #include "maxpath.h"
+ 
+ #if !defined (MAXSYMLINKS)
+ #  define MAXSYMLINKS 32
+ #endif
+ 
+ #if !defined (errno)
+ extern int errno;
+ #endif /* !errno */
+ 
+ extern char *get_working_directory __P((char *));
+ 
+ static int
+ _path_readlink (path, buf, bufsiz)
+      char *path;
+      char *buf;
+      int bufsiz;
+ {
+ #ifdef HAVE_READLINK
+   return readlink (path, buf, bufsiz);
+ #else
+   errno = EINVAL;
+   return -1;
+ #endif
+ }
+ 
+ /* Look for ROOTEDPATH, PATHSEP, DIRSEP, and ISDIRSEP in ../../general.h */
+ 
+ #define DOUBLE_SLASH(p)	((p[0] == '/') && (p[1] == '/') && p[2] != '/')
+ 
+ /*
+  * Return PATH with all symlinks expanded in newly-allocated memory.
+  * This always gets a full pathname.
+  */
+ 
+ char *
+ sh_physpath (path, flags)
+      char *path;
+      int flags;
+ {
+   char tbuf[PATH_MAX+1], linkbuf[PATH_MAX+1];
+   char *result, *p, *q, *qsave, *qbase, *workpath;
+   int double_slash_path, linklen, nlink;
+ 
+   nlink = 0;
+   q = result = xmalloc (PATH_MAX + 1);
+ 
+   workpath = xmalloc (PATH_MAX + 1);
+   strcpy (workpath, path);
+ 
+   /* This always gets an absolute pathname. */
+ 
+   /* POSIX.2 says to leave a leading `//' alone.  On cygwin, we skip over any
+      leading `x:' (dos drive name). */
+ #if defined (__CYGWIN__)
+   qbase = (isalpha(workpath[0]) && workpath[1] == ':') ? workpath + 3 : workpath + 1;
+ #else
+   qbase = workpath + 1;
+ #endif
+   double_slash_path = DOUBLE_SLASH (workpath);
+   qbase += double_slash_path;
+ 
+   for (p = workpath; p < qbase; )
+     *q++ = *p++;
+   qbase = q;
+ 
+   /*
+    * invariants:
+    *	  qbase points to the portion of the result path we want to modify
+    *      p points at beginning of path element we're considering.
+    *      q points just past the last path element we wrote (no slash).
+    *
+    * XXX -- need to fix error checking for too-long pathnames
+    */
+ 
+   while (*p)
+     {
+       if (ISDIRSEP(p[0])) /* null element */
+ 	p++;
+       else if(p[0] == '.' && PATHSEP(p[1]))	/* . and ./ */
+ 	p += 1; 	/* don't count the separator in case it is nul */
+       else if (p[0] == '.' && p[1] == '.' && PATHSEP(p[2])) /* .. and ../ */
+ 	{
+ 	  p += 2; /* skip `..' */
+ 	  if (q > qbase)
+ 	    {
+ 	      while (--q > qbase && ISDIRSEP(*q) == 0)
+ 		;
+ 	    }
+ 	}
+       else	/* real path element */
+ 	{
+ 	  /* add separator if not at start of work portion of result */
+ 	  qsave = q;
+ 	  if (q != qbase)
+ 	    *q++ = DIRSEP;
+ 	  while (*p && (ISDIRSEP(*p) == 0))
+ 	    *q++ = *p++;
+ 
+ 	  *q = '\0';
+ 
+ 	  linklen = _path_readlink (result, linkbuf, PATH_MAX);
+ 	  if (linklen < 0)	/* if errno == EINVAL, it's not a symlink */
+ 	    {
+ 	      if (errno != EINVAL)
+ 		goto error;
+ 	      continue;
+ 	    }
+ 
+ 	  /* It's a symlink, and the value is in LINKBUF. */
+ 	  nlink++;
+ 	  if (nlink > MAXSYMLINKS)
+ 	    {
+ #ifdef ELOOP
+ 	      errno = ELOOP;
+ #endif
+ error:
+ 	      free (result);
+ 	      free (workpath);
+ 	      return ((char *)NULL);
+ 	    }
+ 
+ 	  linkbuf[linklen] = '\0';
+ 
+ 	  /* Form the new pathname by copying the link value to a temporary
+ 	     buffer and appending the rest of `workpath'.  Reset p to point
+ 	     to the start of the rest of the path.  If the link value is an
+ 	     absolute pathname, reset p, q, and qbase.  If not, reset p
+ 	     and q. */
+ 	  strcpy (tbuf, linkbuf);
+ 	  tbuf[linklen] = '/';
+ 	  strcpy (tbuf + linklen, p);
+ 	  strcpy (workpath, tbuf);
+ 
+ 	  if (ABSPATH(linkbuf))
+ 	    {
+ 	      q = result;
+ 	      /* Duplicating some code here... */
+ #if defined (__CYGWIN__)
+ 	      qbase = (isalpha(workpath[0]) && workpath[1] == ':') ? workpath + 3 : workpath + 1;
+ #else
+ 	      qbase = workpath + 1;
+ #endif
+ 	      double_slash_path = DOUBLE_SLASH (workpath);
+ 	      qbase += double_slash_path;
+     
+ 	      for (p = workpath; p < qbase; )
+ 		*q++ = *p++;
+ 	      qbase = q;
+ 	    }
+ 	  else
+ 	    {
+ 	      p = workpath;
+ 	      q = qsave;
+ 	    }
+ 	}
+     }
+ 
+   *q = '\0';
+   free (workpath);
+ 
+   /* If the result starts with `//', but the original path does not, we
+      can turn the // into /.  Because of how we set `qbase', this should never
+      be true, but it's a sanity check. */
+   if (DOUBLE_SLASH(result) && double_slash_path == 0)
+     {
+       if (result[2] == '\0')	/* short-circuit for bare `//' */
+ 	result[1] = '\0';
+       else
+ 	strcpy (result, result + 1);
+     }
+ 
+   return (result);
+ }
+ 
+ char *
+ sh_realpath (pathname, resolved)
+      const char *pathname;
+      char *resolved;
+ {
+   char *tdir, *wd;
+ 
+   if (pathname == 0 || *pathname == '\0')
+     {
+       errno = (pathname == 0) ? EINVAL : ENOENT;
+       return ((char *)NULL);
+     }
+ 
+   if (ABSPATH (pathname) == 0)
+     {
+       wd = get_working_directory ("sh_realpath");
+       if (wd == 0)
+ 	return ((char *)NULL);
+       tdir = sh_makepath ((char *)pathname, wd, 0);
+       free (wd);
+     }
+   else
+     tdir = savestring (pathname);
+ 
+   wd = sh_physpath (tdir, 0);
+   free (tdir);
+ 
+   if (resolved == 0)
+     return (wd);
+ 
+   if (wd)
+     {
+       strncpy (resolved, wd, PATH_MAX - 1);
+       resolved[PATH_MAX - 1] = '\0';
+       return resolved;
+     }
+   else
+     {
+       resolved[0] = '\0';
+       return wd;
+     }
+ }
diff -Nrc2 bash-2.04/lib/sh/shquote.c bash-2.05/lib/sh/shquote.c
*** bash-2.04/lib/sh/shquote.c	Thu Aug  5 08:22:12 1999
--- bash-2.05/lib/sh/shquote.c	Wed Feb 14 17:03:13 2001
***************
*** 28,34 ****
  #include <stdio.h>
  
! #if !defined(slashify_in_quotes)
! #  define slashify_in_quotes "\\`$\"\n"
! #endif
  
  extern char *xmalloc ();
--- 28,32 ----
  #include <stdio.h>
  
! #include "syntax.h"
  
  extern char *xmalloc ();
***************
*** 43,47 ****
     Used by alias and trap, among others. */
  char *
! single_quote (string)
       char *string;
  {
--- 41,45 ----
     Used by alias and trap, among others. */
  char *
! sh_single_quote (string)
       char *string;
  {
***************
*** 73,77 ****
  /* Quote STRING using double quotes.  Return a new string. */
  char *
! double_quote (string)
       char *string;
  {
--- 71,75 ----
  /* Quote STRING using double quotes.  Return a new string. */
  char *
! sh_double_quote (string)
       char *string;
  {
***************
*** 85,100 ****
    for (s = string; s && (c = *s); s++)
      {
!       switch (c)
!         {
! 	case '"':
! 	case '$':
! 	case '`':
! 	case '\\':
! 	case '\n':		/* XXX */
! 	  *r++ = '\\';
! 	default:
! 	  *r++ = c;
! 	  break;
!         }
      }
  
--- 83,90 ----
    for (s = string; s && (c = *s); s++)
      {
!       if (sh_syntaxtab[c] & CBSDQUOTE)
! 	*r++ = '\\';
! 
!       *r++ = c;
      }
  
***************
*** 108,112 ****
     double quotes.  Return a new string. */
  char *
! un_double_quote (string)
       char *string;
  {
--- 98,102 ----
     double quotes.  Return a new string. */
  char *
! sh_un_double_quote (string)
       char *string;
  {
***************
*** 124,128 ****
  	  continue;
  	}
!       if (c == '\\' && strchr (slashify_in_quotes, s[1]))
  	{
  	  pass_next = 1;
--- 114,118 ----
  	  continue;
  	}
!       if (c == '\\' && (sh_syntaxtab[s[1]] & CBSDQUOTE))
  	{
  	  pass_next = 1;
***************
*** 139,143 ****
     string. */
  char *
! backslash_quote (string)
       char *string;
  {
--- 129,133 ----
     string. */
  char *
! sh_backslash_quote (string)
       char *string;
  {
***************
*** 183,188 ****
  }
  
  int
! contains_shell_metas (string)
       char *string;
  {
--- 173,203 ----
  }
  
+ #if defined (PROMPT_STRING_DECODE)
+ /* Quote characters that get special treatment when in double quotes in STRING
+    using backslashes.  Return a new string. */
+ char *
+ sh_backslash_quote_for_double_quotes (string)
+      char *string;
+ {
+   int c;
+   char *result, *r, *s;
+ 
+   result = xmalloc (2 * strlen (string) + 1);
+ 
+   for (r = result, s = string; s && (c = *s); s++)
+     {
+       if (sh_syntaxtab[c] & CBSDQUOTE)
+ 	*r++ = '\\';
+ 
+       *r++ = c;
+     }
+ 
+   *r = '\0';
+   return (result);
+ }
+ #endif /* PROMPT_STRING_DECODE */
+ 
  int
! sh_contains_shell_metas (string)
       char *string;
  {
diff -Nrc2 bash-2.04/lib/sh/spell.c bash-2.05/lib/sh/spell.c
*** bash-2.04/lib/sh/spell.c	Wed Dec 31 19:00:00 1969
--- bash-2.05/lib/sh/spell.c	Tue Oct 17 14:40:51 2000
***************
*** 0 ****
--- 1,186 ----
+ /* spell.c -- spelling correction for pathnames. */
+ 
+ /* Copyright (C) 2000 Free Software Foundation, Inc.
+ 
+ This file is part of GNU Bash, the Bourne Again SHell.
+ 
+ Bash is free software; you can redistribute it and/or modify it under
+ the terms of the GNU General Public License as published by the Free
+ Software Foundation; either version 2, or (at your option) any later
+ version.
+ 
+ Bash is distributed in the hope that it will be useful, but WITHOUT ANY
+ WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ for more details.
+ 
+ You should have received a copy of the GNU General Public License along
+ with Bash; see the file COPYING.  If not, write to the Free Software
+ Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. */
+ 
+ #include <config.h>
+ 
+ #if defined (HAVE_UNISTD_H)
+ #  ifdef _MINIX
+ #    include <sys/types.h>
+ #  endif
+ #  include <unistd.h>
+ #endif
+ 
+ #include <bashtypes.h>
+ #include <posixdir.h>
+ #include <posixstat.h>
+ #ifndef _MINIX
+ #include <sys/param.h>
+ #endif
+ 
+ #include <stdio.h>
+ 
+ #include <bashansi.h>
+ #include <maxpath.h>
+ 
+ static int mindist (), spdist ();
+ 
+ /*
+  * `spname' and its helpers are inspired by the code in "The UNIX
+  * Programming Environment", Kernighan & Pike, Prentice-Hall 1984,
+  * pages 209 - 213.
+  */
+ 
+ /*
+  *	`spname' -- return a correctly spelled filename
+  *
+  *	int spname(char * oldname, char * newname)
+  *	Returns:  -1 if no reasonable match found
+  *		   0 if exact match found
+  *		   1 if corrected
+  *	Stores corrected name in `newname'.
+  */
+ int
+ spname(oldname, newname)
+      char *oldname;
+      char *newname;
+ {
+   char *op, *np, *p;
+   char guess[PATH_MAX + 1], best[PATH_MAX + 1];
+ 
+   op = oldname;
+   np = newname;
+   for (;;)
+     {
+       while (*op == '/')    /* Skip slashes */
+ 	*np++ = *op++;
+       *np = '\0';
+ 
+       if (*op == '\0')    /* Exact or corrected */
+ 	{
+ 	  /* `.' is rarely the right thing. */
+ 	  if (oldname[1] == '\0' && newname[1] == '\0' &&
+ 		oldname[0] != '.' && newname[0] == '.')
+ 	    return -1;
+ 	  return strcmp(oldname, newname) != 0;
+ 	}
+ 
+       /* Copy next component into guess */
+       for (p = guess; *op != '/' && *op != '\0'; op++)
+ 	if (p < guess + PATH_MAX)
+ 	  *p++ = *op;
+       *p = '\0';
+ 
+       if (mindist(newname, guess, best) >= 3)
+ 	return -1;  /* Hopeless */
+ 
+       /*
+        *  Add to end of newname
+        */
+       for (p = best; *np = *p++; np++)
+ 	;
+     }
+ }
+ 
+ /*
+  *  Search directory for a guess
+  */
+ static int
+ mindist(dir, guess, best)
+      char *dir;
+      char *guess;
+      char *best;
+ {
+   DIR *fd;
+   struct dirent *dp;
+   int dist, x;
+ 
+   dist = 3;    /* Worst distance */
+   if (*dir == '\0')
+     dir = ".";
+ 
+   if ((fd = opendir(dir)) == NULL)
+     return dist;
+ 
+   while ((dp = readdir(fd)) != NULL)
+     {
+       /*
+        *  Look for a better guess.  If the new guess is as
+        *  good as the current one, we take it.  This way,
+        *  any single character match will be a better match
+        *  than ".".
+        */
+       x = spdist(dp->d_name, guess);
+       if (x <= dist && x != 3)
+ 	{
+ 	  strcpy(best, dp->d_name);
+ 	  dist = x;
+ 	  if (dist == 0)    /* Exact match */
+ 	    break;
+ 	}
+     }
+   (void)closedir(fd);
+ 
+   /* Don't return `.' */
+   if (best[0] == '.' && best[1] == '\0')
+     dist = 3;
+   return dist;
+ }
+ 
+ /*
+  *  `spdist' -- return the "distance" between two names.
+  *
+  *  int spname(char * oldname, char * newname)
+  *  Returns:  0 if strings are identical
+  *      1 if two characters are transposed
+  *      2 if one character is wrong, added or deleted
+  *      3 otherwise
+  */
+ static int
+ spdist(cur, new)
+      char *cur, *new;
+ {
+   while (*cur == *new)
+     {
+       if (*cur == '\0')
+ 	return 0;    /* Exact match */
+       cur++;
+       new++;
+     }
+ 
+   if (*cur)
+     {
+       if (*new)
+ 	{
+ 	  if (cur[1] && new[1] && cur[0] == new[1] && cur[1] == new[0] && strcmp (cur + 2, new + 2) == 0)
+ 	    return 1;  /* Transposition */
+ 
+ 	  if (strcmp (cur + 1, new + 1) == 0)
+ 	    return 2;  /* One character mismatch */
+ 	}
+ 
+       if (strcmp(&cur[1], &new[0]) == 0)
+ 	return 2;    /* Extra character */
+     }
+ 
+   if (*new && strcmp(cur, new + 1) == 0)
+     return 2;      /* Missing character */
+ 
+   return 3;
+ }
diff -Nrc2 bash-2.04/lib/sh/strcasecmp.c bash-2.05/lib/sh/strcasecmp.c
*** bash-2.04/lib/sh/strcasecmp.c	Fri Oct 10 12:28:08 1997
--- bash-2.05/lib/sh/strcasecmp.c	Wed Feb 14 17:03:19 2001
***************
*** 80,84 ****
      {
        if (*s1++ == '\0')
!         return 0;
        s2++;
      }
--- 80,84 ----
      {
        if (*s1++ == '\0')
! 	return 0;
        s2++;
      }
diff -Nrc2 bash-2.04/lib/sh/strindex.c bash-2.05/lib/sh/strindex.c
*** bash-2.04/lib/sh/strindex.c	Wed Dec 31 19:00:00 1969
--- bash-2.05/lib/sh/strindex.c	Fri Oct 13 12:40:39 2000
***************
*** 0 ****
--- 1,52 ----
+ /* strindex.c - Find if one string appears as a substring of another string,
+ 		without regard to case. */
+ 
+ /* Copyright (C) 2000
+    Free Software Foundation, Inc.
+ 
+    This file is part of GNU Bash, the Bourne Again SHell.
+ 
+    Bash is free software; you can redistribute it and/or modify it under
+    the terms of the GNU General Public License as published by the Free
+    Software Foundation; either version 2, or (at your option) any later
+    version.
+ 
+    Bash is distributed in the hope that it will be useful, but WITHOUT ANY
+    WARRANTY; without even the implied warranty of MERCHANTABILITY or
+    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+    for more details.
+ 
+    You should have received a copy of the GNU General Public License along
+    with Bash; see the file COPYING.  If not, write to the Free Software
+    Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. */
+ 
+ #include <config.h>
+ 
+ #include "bashansi.h"
+ #include <ctype.h>
+ 
+ #include <stdc.h>
+ 
+ #ifndef to_upper
+ #  define to_upper(c) (islower(c) ? toupper(c) : (c))
+ #  define to_lower(c) (isupper(c) ? tolower(c) : (c))
+ #endif
+ 
+ /* Determine if s2 occurs in s1.  If so, return a pointer to the
+    match in s1.  The compare is case insensitive.  This is a
+    case-insensitive strstr(3). */
+ char *
+ strindex (s1, s2)
+      const char *s1;
+      const char *s2;
+ {
+   register int i, l, len, c;
+ 
+   c = to_upper (s2[0]);
+   len = strlen (s1);
+   l = strlen (s2);
+   for (i = 0; (len - i) >= l; i++)
+     if ((to_upper (s1[i]) == c) && (strncasecmp (s1 + i, s2, l) == 0))
+       return ((char *)s1 + i);
+   return ((char *)0);
+ }
diff -Nrc2 bash-2.04/lib/sh/stringlist.c bash-2.05/lib/sh/stringlist.c
*** bash-2.04/lib/sh/stringlist.c	Wed Dec 31 19:00:00 1969
--- bash-2.05/lib/sh/stringlist.c	Fri Sep 15 12:39:59 2000
***************
*** 0 ****
--- 1,248 ----
+ /* stringlist.c - functions to handle a generic `list of strings' structure */
+ 
+ /* Copyright (C) 2000 Free Software Foundation, Inc.
+ 
+    This file is part of GNU Bash, the Bourne Again SHell.
+ 
+    Bash is free software; you can redistribute it and/or modify it under
+    the terms of the GNU General Public License as published by the Free
+    Software Foundation; either version 2, or (at your option) any later
+    version.
+ 
+    Bash is distributed in the hope that it will be useful, but WITHOUT ANY
+    WARRANTY; without even the implied warranty of MERCHANTABILITY or
+    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+    for more details.
+ 
+    You should have received a copy of the GNU General Public License along
+    with Bash; see the file COPYING.  If not, write to the Free Software
+    Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. */
+ 
+ #include <config.h>
+ 
+ #if defined (HAVE_UNISTD_H)
+ #  include <unistd.h>
+ #endif
+ 
+ #include <stdio.h>
+ #include "bashansi.h"
+ 
+ #include "shell.h"
+ 
+ #ifdef STRDUP
+ #  undef STRDUP
+ #endif
+ #define STRDUP(x)	((x) ? savestring (x) : (char *)NULL)
+ 
+ /* Allocate a new STRINGLIST, with room for N strings. */
+ 
+ STRINGLIST *
+ alloc_stringlist (n)
+      int n;
+ {
+   STRINGLIST *ret;
+   register int i;
+ 
+   ret = (STRINGLIST *)xmalloc (sizeof (STRINGLIST));
+   if (n)
+     {
+       ret->list = alloc_array (n+1);
+       ret->list_size = n;
+       for (i = 0; i < n; i++)
+ 	ret->list[i] = (char *)NULL;
+     }
+   else
+     {
+       ret->list = (char **)NULL;
+       ret->list_size = 0;
+     }
+   ret->list_len = 0;
+   return ret;
+ }
+ 
+ STRINGLIST *
+ realloc_stringlist (sl, n)
+      STRINGLIST *sl;
+      int n;
+ {
+   register int i;
+ 
+   if (n > sl->list_size)
+     {
+       sl->list = (char **)xrealloc (sl->list, (n+1) * sizeof (char *));
+       for (i = sl->list_size; i <= n; i++)
+ 	sl->list[i] = (char *)NULL;
+       sl->list_size = n;
+     }
+   return sl;
+ }
+   
+ void
+ free_stringlist (sl)
+      STRINGLIST *sl;
+ {
+   if (sl == 0)
+     return;
+   if (sl->list)
+     free_array (sl->list);
+   free (sl);
+ }
+ 
+ STRINGLIST *
+ copy_stringlist (sl)
+      STRINGLIST *sl;
+ {
+   STRINGLIST *new;
+   register int i;
+ 
+   new = alloc_stringlist (sl->list_size);
+   /* I'd like to use copy_array, but that doesn't copy everything. */
+   if (sl->list)
+     {
+       for (i = 0; i < sl->list_size; i++)
+ 	new->list[i] = STRDUP (sl->list[i]);
+     }
+   new->list_size = sl->list_size;
+   new->list_len = sl->list_len;
+   /* just being careful */
+   if (new->list)
+     new->list[new->list_len] = (char *)NULL;
+   return new;
+ }
+ 
+ /* Return a new STRINGLIST with everything from M1 and M2. */
+ 
+ STRINGLIST *
+ merge_stringlists (m1, m2)
+      STRINGLIST *m1, *m2;
+ {
+   STRINGLIST *sl;
+   int i, n, l1, l2;
+ 
+   l1 = m1 ? m1->list_len : 0;
+   l2 = m2 ? m2->list_len : 0;
+ 
+   sl = alloc_stringlist (l1 + l2 + 1);
+   for (i = n = 0; i < l1; i++, n++)
+     sl->list[n] = STRDUP (m1->list[i]);
+   for (i = 0; i < l2; i++, n++)
+     sl->list[n] = STRDUP (m2->list[i]);
+   sl->list_len = n;
+   sl->list[n] = (char *)NULL;
+ }
+ 
+ /* Make STRINGLIST M1 contain everything in M1 and M2. */
+ STRINGLIST *
+ append_stringlist (m1, m2)
+      STRINGLIST *m1, *m2;
+ {
+   register int i, n, len1, len2;
+ 
+   if (m1 == 0)
+     {
+       m1 = copy_stringlist (m2);
+       return m1;
+     }
+ 
+   len1 = m1->list_len;
+   len2 = m2 ? m2->list_len : 0;
+ 
+   if (len2)
+     {
+       m1 = realloc_stringlist (m1, len1 + len2 + 1);
+       for (i = 0, n = len1; i < len2; i++, n++)
+ 	m1->list[n] = STRDUP (m2->list[i]);
+       m1->list[n] = (char *)NULL;
+       m1->list_len = n;
+     }
+ 
+   return m1;
+ }
+ 
+ STRINGLIST *
+ prefix_suffix_stringlist (sl, prefix, suffix)
+      STRINGLIST *sl;
+      char *prefix, *suffix;
+ {
+   int plen, slen, tlen, llen, i;
+   char *t;
+ 
+   if (sl == 0 || sl->list == 0 || sl->list_len == 0)
+     return sl;
+ 
+   plen = STRLEN (prefix);
+   slen = STRLEN (suffix);
+ 
+   if (plen == 0 && slen == 0)
+     return (sl);
+ 
+   for (i = 0; i < sl->list_len; i++)
+     {
+       llen = STRLEN (sl->list[i]);
+       tlen = plen + llen + slen + 1;
+       t = xmalloc (tlen + 1);
+       if (plen)
+ 	strcpy (t, prefix);
+       strcpy (t + plen, sl->list[i]);
+       if (slen)
+ 	strcpy (t + plen + llen, suffix);
+       free (sl->list[i]);
+       sl->list[i] = t;
+     }
+ 
+   return (sl);	 
+ }
+    
+ void
+ print_stringlist (sl, prefix)
+      STRINGLIST *sl;
+      char *prefix;
+ {
+   register int i;
+ 
+   if (sl == 0)
+     return;
+   for (i = 0; i < sl->list_len; i++)
+     printf ("%s%s\n", prefix ? prefix : "", sl->list[i]);
+ }
+ 
+ void
+ sort_stringlist (sl)
+      STRINGLIST *sl;
+ {
+   if (sl == 0 || sl->list_len == 0 || sl->list == 0)
+     return;
+   sort_char_array (sl->list);
+ }
+ 
+ STRINGLIST *
+ word_list_to_stringlist (list, copy, starting_index, ip)
+      WORD_LIST *list;
+      int copy, starting_index, *ip;
+ {
+   STRINGLIST *ret;
+   int slen, len;
+ 
+   slen = list_length (list);
+   ret = (STRINGLIST *)xmalloc (sizeof (STRINGLIST));
+   ret->list = word_list_to_argv (list, copy, starting_index, &len);
+   ret->list_size = slen + starting_index;
+   ret->list_len = len;
+   if (ip)
+     *ip = len;
+   return ret;
+ }
+ 
+ WORD_LIST *
+ stringlist_to_word_list (sl, copy, starting_index)
+      STRINGLIST *sl;
+      int copy, starting_index;
+ {
+   WORD_LIST *list;
+ 
+   if (sl == 0 || sl->list == 0)
+     return ((WORD_LIST *)NULL);
+ 
+   list = argv_to_word_list (sl->list, copy, starting_index);
+   return list;
+ }
diff -Nrc2 bash-2.04/lib/sh/stringvec.c bash-2.05/lib/sh/stringvec.c
*** bash-2.04/lib/sh/stringvec.c	Wed Dec 31 19:00:00 1969
--- bash-2.05/lib/sh/stringvec.c	Fri Sep 15 12:43:45 2000
***************
*** 0 ****
--- 1,141 ----
+ /* stringvec.c - function for managing arrays of strings. */
+ 
+ /* Copyright (C) 2000 Free Software Foundation, Inc.
+ 
+    This file is part of GNU Bash, the Bourne Again SHell.
+ 
+    Bash is free software; you can redistribute it and/or modify it under
+    the terms of the GNU General Public License as published by the Free
+    Software Foundation; either version 2, or (at your option) any later
+    version.
+ 
+    Bash is distributed in the hope that it will be useful, but WITHOUT ANY
+    WARRANTY; without even the implied warranty of MERCHANTABILITY or
+    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+    for more details.
+ 
+    You should have received a copy of the GNU General Public License along
+    with Bash; see the file COPYING.  If not, write to the Free Software
+    Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. */
+ 
+ #include "config.h"
+ 
+ #include "bashtypes.h"
+ 
+ #if defined (HAVE_UNISTD_H)
+ #  include <unistd.h>
+ #endif
+ 
+ #include "bashansi.h"
+ #include <stdio.h>
+ #include <ctype.h>
+ 
+ #include "shell.h"
+ 
+ #ifdef INCLUDE_UNUSED
+ /* Find NAME in ARRAY.  Return the index of NAME, or -1 if not present.
+    ARRAY should be NULL terminated. */
+ int
+ find_name_in_array (name, array)
+      char *name, **array;
+ {
+   int i;
+ 
+   for (i = 0; array[i]; i++)
+     if (STREQ (name, array[i]))
+       return (i);
+ 
+   return (-1);
+ }
+ #endif
+ 
+ /* Allocate an array of strings with room for N members. */
+ char **
+ alloc_array (n)
+      int n;
+ {
+   return ((char **)xmalloc ((n) * sizeof (char *)));
+ }
+ 
+ /* Return the length of ARRAY, a NULL terminated array of char *. */
+ int
+ array_len (array)
+      char **array;
+ {
+   register int i;
+ 
+   for (i = 0; array[i]; i++);
+   return (i);
+ }
+ 
+ /* Free the contents of ARRAY, a NULL terminated array of char *. */
+ void
+ free_array_members (array)
+      char **array;
+ {
+   register int i;
+ 
+   if (array == 0)
+     return;
+ 
+   for (i = 0; array[i]; i++)
+     free (array[i]);
+ }
+ 
+ void
+ free_array (array)
+      char **array;
+ {
+   if (array == 0)
+     return;
+ 
+   free_array_members (array);
+   free (array);
+ }
+ 
+ /* Allocate and return a new copy of ARRAY and its contents. */
+ char **
+ copy_array (array)
+      char **array;
+ {
+   register int i;
+   int len;
+   char **new_array;
+ 
+   len = array_len (array);
+ 
+   new_array = (char **)xmalloc ((len + 1) * sizeof (char *));
+   for (i = 0; array[i]; i++)
+     new_array[i] = savestring (array[i]);
+   new_array[i] = (char *)NULL;
+ 
+   return (new_array);
+ }
+ 
+ /* Comparison routine for use with qsort() on arrays of strings.  Uses
+    strcoll(3) if available, otherwise it uses strcmp(3). */
+ int
+ qsort_string_compare (s1, s2)
+      register char **s1, **s2;
+ {
+ #if defined (HAVE_STRCOLL)
+    return (strcoll (*s1, *s2));
+ #else /* !HAVE_STRCOLL */
+   int result;
+ 
+   if ((result = **s1 - **s2) == 0)
+     result = strcmp (*s1, *s2);
+ 
+   return (result);
+ #endif /* !HAVE_STRCOLL */
+ }
+ 
+ /* Sort ARRAY, a null terminated array of pointers to strings. */
+ void
+ sort_char_array (array)
+      char **array;
+ {
+   qsort (array, array_len (array), sizeof (char *),
+ 	 (Function *)qsort_string_compare);
+ }
+ 
diff -Nrc2 bash-2.04/lib/sh/strtol.c bash-2.05/lib/sh/strtol.c
*** bash-2.04/lib/sh/strtol.c	Thu Aug 13 12:23:01 1998
--- bash-2.05/lib/sh/strtol.c	Wed Feb 14 17:03:24 2001
***************
*** 205,210 ****
  	*endptr = (char *) &save[-1];
        else
!         /*  There was no number to convert.  */
!         *endptr = (char *) nptr;
      }
  
--- 205,210 ----
  	*endptr = (char *) &save[-1];
        else
! 	/*  There was no number to convert.  */
! 	*endptr = (char *) nptr;
      }
  
diff -Nrc2 bash-2.04/lib/sh/strtrans.c bash-2.05/lib/sh/strtrans.c
*** bash-2.04/lib/sh/strtrans.c	Wed Dec 31 19:00:00 1969
--- bash-2.05/lib/sh/strtrans.c	Wed Feb 14 17:03:32 2001
***************
*** 0 ****
--- 1,205 ----
+ /* strtrans.c - Translate and untranslate strings with ANSI-C escape
+ 		sequences. */
+ 
+ /* Copyright (C) 2000
+    Free Software Foundation, Inc.
+ 
+    This file is part of GNU Bash, the Bourne Again SHell.
+ 
+    Bash is free software; you can redistribute it and/or modify it under
+    the terms of the GNU General Public License as published by the Free
+    Software Foundation; either version 2, or (at your option) any later
+    version.
+ 
+    Bash is distributed in the hope that it will be useful, but WITHOUT ANY
+    WARRANTY; without even the implied warranty of MERCHANTABILITY or
+    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+    for more details.
+ 
+    You should have received a copy of the GNU General Public License along
+    with Bash; see the file COPYING.  If not, write to the Free Software
+    Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. */
+ 
+ #include <config.h>
+ 
+ #if defined (HAVE_UNISTD_H)
+ #  include <unistd.h>
+ #endif
+ 
+ #include "bashansi.h"
+ #include <stdio.h>
+ #include <ctype.h>
+ 
+ #include "shell.h"
+ 
+ #ifdef ESC
+ #undef ESC
+ #endif
+ #define ESC '\033'	/* ASCII */
+ 
+ #ifndef ISOCTAL
+ #define ISOCTAL(c)	((c) >= '0' && (c) <= '7')
+ #endif
+ 
+ #ifndef OCTVALUE
+ #define OCTVALUE(c)	((c) - '0')
+ #endif
+ 
+ #ifndef isxdigit
+ #  define isxdigit(c)	(isdigit((c)) || ((c) >= 'a' && (c) <= 'f') || ((c) >= 'A' && (c) <= 'F'))
+ #endif
+ 
+ #define HEXVALUE(c) \
+   ((c) >= 'a' && (c) <= 'f' ? (c)-'a'+10 : (c) >= 'A' && (c) <= 'F' ? (c)-'A'+10 : (c)-'0')
+ 
+ /* Convert STRING by expanding the escape sequences specified by the
+    ANSI C standard.  If SAWC is non-null, recognize `\c' and use that
+    as a string terminator.  If we see \c, set *SAWC to 1 before
+    returning.  LEN is the length of STRING.  FOR_ECHO is a flag that
+    means, if non-zero, that we're translating a string for `echo -e',
+    and therefore should not treat a single quote as a character that
+    may be escaped with a backslash. */
+ char *
+ ansicstr (string, len, for_echo, sawc, rlen)
+      char *string;
+      int len, for_echo, *sawc, *rlen;
+ {
+   int c, temp;
+   char *ret, *r, *s;
+ 
+   if (string == 0 || *string == '\0')
+     return ((char *)NULL);
+ 
+   ret = xmalloc (len + 1);
+   for (r = ret, s = string; s && *s; )
+     {
+       c = *s++;
+       if (c != '\\' || *s == '\0')
+ 	*r++ = c;
+       else
+ 	{
+ 	  switch (c = *s++)
+ 	    {
+ #if defined (__STDC__)
+ 	    case 'a': c = '\a'; break;
+ 	    case 'v': c = '\v'; break;
+ #else
+ 	    case 'a': c = '\007'; break;
+ 	    case 'v': c = (int) 0x0B; break;
+ #endif
+ 	    case 'b': c = '\b'; break;
+ 	    case 'e': case 'E':		/* ESC -- non-ANSI */
+ 	      c = ESC; break;
+ 	    case 'f': c = '\f'; break;
+ 	    case 'n': c = '\n'; break;
+ 	    case 'r': c = '\r'; break;
+ 	    case 't': c = '\t'; break;
+ 	    case '0': case '1': case '2': case '3':
+ 	    case '4': case '5': case '6': case '7':
+ 	      for (temp = 2, c -= '0'; ISOCTAL (*s) && temp--; s++)
+ 		c = (c * 8) + OCTVALUE (*s);
+ 	      break;
+ 	    case 'x':			/* Hex digit -- non-ANSI */
+ 	      for (temp = 3, c = 0; isxdigit (*s) && temp--; s++)
+ 		c = (c * 16) + HEXVALUE (*s);
+ 	      /* \x followed by non-hex digits is passed through unchanged */
+ 	      if (temp == 3)
+ 		{
+ 		  *r++ = '\\';
+ 		  c = 'x';
+ 		}
+ 	      break;
+ 	    case '\\':
+ 	      break;
+ 	    case '\'':
+ 	      if (for_echo)
+ 		*r++ = '\\';
+ 	      break;
+ 	    case 'c':
+ 	      if (sawc)
+ 		{
+ 		  *sawc = 1;
+ 		  *r = '\0';
+ 		  if (rlen)
+ 		    *rlen = r - ret;
+ 		  return ret;
+ 		}
+ 	    default:  *r++ = '\\'; break;
+ 	    }
+ 	  *r++ = c;
+ 	}
+     }
+   *r = '\0';
+   if (rlen)
+     *rlen = r - ret;
+   return ret;
+ }
+ 
+ /* Take a string STR, possibly containing non-printing characters, and turn it
+    into a $'...' ANSI-C style quoted string.  Returns a new string. */
+ char *
+ ansic_quote (str, flags, rlen)
+      char *str;
+      int flags, *rlen;
+ {
+   char *r, *ret, *s, obuf[8];
+   int l, c, rsize, t;
+ 
+   if (str == 0 || *str == 0)
+     return ((char *)0);
+ 
+   l = strlen (str);
+   rsize = 2 * l + 4;
+   r = ret = xmalloc (rsize);
+ 
+   *r++ = '$';
+   *r++ = '\'';
+ 
+   for (s = str, l = 0; *s; s++)
+     {
+       c = *(unsigned char *)s;
+       l = 1;		/* 1 == add backslash; 0 == no backslash */
+       switch (c)
+ 	{
+ 	case ESC: c = 'E'; break;
+ #ifdef __STDC__
+ 	case '\a': c = 'a'; break;
+ 	case '\v': c = 'v'; break;
+ #else
+ 	case '\007': c = 'a'; break;
+ 	case 0x0b: c = 'v'; break;
+ #endif
+ 
+ 	case '\b': c = 'b'; break;
+ 	case '\f': c = 'f'; break;
+ 	case '\n': c = 'n'; break;
+ 	case '\r': c = 'r'; break;
+ 	case '\t': c = 't'; break;
+ 	case '\\':
+ 	case '\'':
+ 	  break;
+ 	default:
+ 	  if (isprint (c) == 0)
+ 	    {
+ 	      sprintf (obuf, "\\%.3o", c);
+ 	      t = r - ret;
+ 	      RESIZE_MALLOCED_BUFFER (ret, t, 5, rsize, 16);
+ 	      r = ret + t;	/* in case reallocated */
+ 	      for (t = 0; t < 4; t++)
+ 		*r++ = obuf[t];
+ 	      continue;
+ 	    }
+ 	  l = 0;
+ 	  break;
+ 	}
+       if (l)
+ 	*r++ = '\\';
+       *r++ = c;
+     }
+ 
+   *r++ = '\'';
+   *r = '\0';
+   if (rlen)
+     *rlen = r - ret;
+   return ret;
+ }
diff -Nrc2 bash-2.04/lib/sh/times.c bash-2.05/lib/sh/times.c
*** bash-2.04/lib/sh/times.c	Mon Aug 16 11:22:22 1999
--- bash-2.05/lib/sh/times.c	Wed Feb 14 17:03:47 2001
***************
*** 61,65 ****
  	if (gettimeofday(&tv, (struct timezone *) 0) < 0)
  		return ((clock_t)-1);
!         rv = (clock_t)(CONVTCK(tv));
  #else /* !HAVE_GETRUSAGE */
  	if (clk_tck == -1)
--- 61,65 ----
  	if (gettimeofday(&tv, (struct timezone *) 0) < 0)
  		return ((clock_t)-1);
! 	rv = (clock_t)(CONVTCK(tv));
  #else /* !HAVE_GETRUSAGE */
  	if (clk_tck == -1)
diff -Nrc2 bash-2.04/lib/sh/tmpfile.c bash-2.05/lib/sh/tmpfile.c
*** bash-2.04/lib/sh/tmpfile.c	Wed Dec 31 19:00:00 1969
--- bash-2.05/lib/sh/tmpfile.c	Wed Feb 14 17:03:53 2001
***************
*** 0 ****
--- 1,183 ----
+ /*
+  * tmpfile.c - functions to create and safely open temp files for the shell.
+  */
+ 
+ /* Copyright (C) 2000 Free Software Foundation, Inc.
+ 
+    This file is part of GNU Bash, the Bourne Again SHell.
+ 
+    Bash is free software; you can redistribute it and/or modify it
+    under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2, or (at your option)
+    any later version.
+ 
+    Bash is distributed in the hope that it will be useful, but WITHOUT
+    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+    or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+    License for more details.
+ 
+    You should have received a copy of the GNU General Public License
+    along with Bash; see the file COPYING.  If not, write to the Free
+    Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. */
+ 
+ #include <config.h>
+ 
+ #include <bashtypes.h>
+ #include <posixstat.h>
+ #include <filecntl.h>
+ 
+ #if defined (HAVE_UNISTD_H)
+ #  include <unistd.h>
+ #endif
+ 
+ #include <stdio.h>
+ #include <errno.h>
+ 
+ #include <shell.h>
+ 
+ #ifndef errno
+ extern int errno;
+ #endif
+ 
+ #define BASEOPENFLAGS	(O_CREAT | O_TRUNC | O_EXCL)
+ 
+ #define DEFAULT_TMPDIR		"."	/* bogus default, should be changed */
+ #define DEFAULT_NAMEROOT	"shtmp"
+ 
+ extern int dollar_dollar_pid;
+ 
+ static char *sys_tmpdir = (char *)NULL;
+ static int ntmpfiles;
+ static int tmpnamelen = -1;
+ static unsigned long filenum = 1L;
+ 
+ static char *
+ get_sys_tmpdir ()
+ {
+   struct stat sb;
+ 
+   if (sys_tmpdir)
+     return sys_tmpdir;
+ 
+   sys_tmpdir = "/tmp";
+   if (stat (sys_tmpdir, &sb) == 0)
+     return sys_tmpdir;
+ 
+   sys_tmpdir = "/var/tmp";
+   if (stat (sys_tmpdir, &sb) == 0)
+     return sys_tmpdir;
+ 
+   sys_tmpdir = "/usr/tmp";
+   if (stat (sys_tmpdir, &sb) == 0)
+     return sys_tmpdir;
+ 
+ #ifdef P_tmpdir
+   sys_tmpdir = P_tmpdir;
+ #else
+   sys_tmpdir = DEFAULT_TMPDIR;
+ #endif
+ 
+   return sys_tmpdir;
+ }
+ 
+ static char *
+ get_tmpdir (flags)
+      int flags;
+ {
+   char *tdir;
+ 
+   tdir = (flags & MT_USETMPDIR) ? get_string_value ("TMPDIR") : (char *)NULL;
+   if (tdir == 0)
+     tdir = get_sys_tmpdir ();
+ 
+ #if defined (HAVE_PATHCONF) && defined (_PC_NAME_MAX)
+   if (tmpnamelen == -1)
+     tmpnamelen = pathconf (tdir, _PC_NAME_MAX);
+ #else
+   tmpnamelen = 0;
+ #endif
+ 
+   return tdir;
+ }
+ 
+ char *
+ sh_mktmpname (nameroot, flags)
+      char *nameroot;
+      int flags;
+ {
+   char *filename, *tdir;
+   struct stat sb;
+   int r, tdlen;
+ 
+   filename = xmalloc (PATH_MAX + 1);
+   tdir = get_tmpdir (flags);
+   tdlen = strlen (tdir);
+ 
+   if (nameroot == 0)
+     nameroot = DEFAULT_NAMEROOT;
+ 
+   while (1)
+     {
+       filenum *= (int)time ((time_t *)0) * dollar_dollar_pid *
+ 		((flags & MT_USERANDOM) ? get_random_number () : ntmpfiles++);
+       sprintf (filename, "%s/%s-%lu", tdir, nameroot, filenum);
+       if (tmpnamelen > 0 && tmpnamelen < 32)
+ 	filename[tdlen + 1 + tmpnamelen] = '\0';
+ #ifdef HAVE_LSTAT
+       r = lstat (filename, &sb);
+ #else
+       r = stat (filename, &sb);
+ #endif
+       if (r < 0 && errno == ENOENT)
+ 	break;
+     }
+ 
+   return filename;
+ }
+ 
+ int
+ sh_mktmpfd (nameroot, flags, namep)
+      char *nameroot;
+      int flags;
+      char **namep;
+ {
+   char *filename, *tdir;
+   int fd, tdlen;
+ 
+   filename = xmalloc (PATH_MAX + 1);
+   tdir = get_tmpdir (flags);
+   tdlen = strlen (tdir);
+ 
+   if (nameroot == 0)
+     nameroot = DEFAULT_NAMEROOT;
+ 
+   do
+     {
+       filenum *= (int)time ((time_t *)0) * dollar_dollar_pid *
+ 		((flags & MT_USERANDOM) ? get_random_number () : ntmpfiles++);
+       sprintf (filename, "%s/%s-%lu", tdir, nameroot, filenum);
+       if (tmpnamelen > 0 && tmpnamelen < 32)
+ 	filename[tdlen + 1 + tmpnamelen] = '\0';
+       fd = open (filename, BASEOPENFLAGS | ((flags & MT_READWRITE) ? O_RDWR : O_WRONLY), 0600);
+     }
+   while (fd < 0 && errno == EEXIST);
+ 
+   if (namep)
+     *namep = filename;
+   else
+     free (filename);
+ 
+   return fd;
+ }
+ 
+ FILE *
+ sh_mktmpfp (nameroot, flags, namep)
+      char *nameroot;
+      int flags;
+      char **namep;
+ {
+   int fd;
+ 
+   fd = sh_mktmpfd (nameroot, flags, namep);
+   return ((fd >= 0) ? (fdopen (fd, (flags & MT_READWRITE) ? "w+" : "w")) : (FILE *)NULL);
+ }
diff -Nrc2 bash-2.04/lib/sh/zread.c bash-2.05/lib/sh/zread.c
*** bash-2.04/lib/sh/zread.c	Mon Feb 21 11:25:27 2000
--- bash-2.05/lib/sh/zread.c	Wed Feb 14 17:03:59 2001
***************
*** 70,74 ****
        r = read (fd, buf, len);
        if (r >= 0)
!         return r;
        if (r == -1 && errno == EINTR)
  	{
--- 70,74 ----
        r = read (fd, buf, len);
        if (r >= 0)
! 	return r;
        if (r == -1 && errno == EINTR)
  	{
diff -Nrc2 bash-2.04/lib/sh/zwrite.c bash-2.05/lib/sh/zwrite.c
*** bash-2.04/lib/sh/zwrite.c	Mon Feb 21 11:25:46 2000
--- bash-2.05/lib/sh/zwrite.c	Tue Oct 31 10:52:03 2000
***************
*** 50,53 ****
--- 50,54 ----
  	  if (n <= 0)
  	    return nb;
+ 	  buf += i;
  	}
        else if (i == 0)
diff -Nrc2 bash-2.04/lib/tilde/tilde.c bash-2.05/lib/tilde/tilde.c
*** bash-2.04/lib/tilde/tilde.c	Thu Dec 16 16:10:44 1999
--- bash-2.05/lib/tilde/tilde.c	Wed Feb 14 17:04:21 2001
***************
*** 51,64 ****
  static char *xmalloc (), *xrealloc ();
  #else
! #  if defined __STDC__
! extern char *xmalloc (int);
! extern char *xrealloc (void *, int);
! #  else
! extern char *xmalloc (), *xrealloc ();
! #  endif /* !__STDC__ */
  #endif /* TEST || STATIC_MALLOC */
  
  #if !defined (HAVE_GETPW_DECLS)
! extern struct passwd *getpwuid (), *getpwnam ();
  #endif /* !HAVE_GETPW_DECLS */
  
--- 51,61 ----
  static char *xmalloc (), *xrealloc ();
  #else
! extern char *xmalloc __P((int));
! extern char *xrealloc __P((void *, int));
  #endif /* TEST || STATIC_MALLOC */
  
  #if !defined (HAVE_GETPW_DECLS)
! extern struct passwd *getpwuid __P((uid_t));
! extern struct passwd *getpwnam __P((const char *));
  #endif /* !HAVE_GETPW_DECLS */
  
***************
*** 81,98 ****
     variables.o.  If being compiled as part of readline, they will
     be satisfied from shell.o. */
! extern char *get_home_dir __P((void));
! extern char *get_env_value __P((char *));
  
  /* The default value of tilde_additional_prefixes.  This is set to
     whitespace preceding a tilde so that simple programs which do not
     perform any word separation get desired behaviour. */
! static char *default_prefixes[] =
!   { " ~", "\t~", (char *)NULL };
  
  /* The default value of tilde_additional_suffixes.  This is set to
     whitespace or newline so that simple programs which do not
     perform any word separation get desired behaviour. */
! static char *default_suffixes[] =
!   { " ", "\n", (char *)NULL };
  
  /* If non-null, this contains the address of a function that the application
--- 78,95 ----
     variables.o.  If being compiled as part of readline, they will
     be satisfied from shell.o. */
! extern char *sh_get_home_dir __P((void));
! extern char *sh_get_env_value __P((const char *));
  
  /* The default value of tilde_additional_prefixes.  This is set to
     whitespace preceding a tilde so that simple programs which do not
     perform any word separation get desired behaviour. */
! static const char *default_prefixes[] =
!   { " ~", "\t~", (const char *)NULL };
  
  /* The default value of tilde_additional_suffixes.  This is set to
     whitespace or newline so that simple programs which do not
     perform any word separation get desired behaviour. */
! static const char *default_suffixes[] =
!   { " ", "\n", (const char *)NULL };
  
  /* If non-null, this contains the address of a function that the application
***************
*** 100,104 ****
     is called with the text sans tilde, and returns a malloc()'ed string
     which is the expansion, or a NULL pointer if the expansion fails. */
! CPFunction *tilde_expansion_preexpansion_hook = (CPFunction *)NULL;
  
  /* If non-null, this contains the address of a function to call if the
--- 97,101 ----
     is called with the text sans tilde, and returns a malloc()'ed string
     which is the expansion, or a NULL pointer if the expansion fails. */
! tilde_hook_func_t *tilde_expansion_preexpansion_hook = (tilde_hook_func_t *)NULL;
  
  /* If non-null, this contains the address of a function to call if the
***************
*** 106,120 ****
     with the text (sans tilde, as in "foo"), and returns a malloc()'ed string
     which is the expansion, or a NULL pointer if there is no expansion. */
! CPFunction *tilde_expansion_failure_hook = (CPFunction *)NULL;
  
  /* When non-null, this is a NULL terminated array of strings which
     are duplicates for a tilde prefix.  Bash uses this to expand
     `=~' and `:~'. */
! char **tilde_additional_prefixes = default_prefixes;
  
  /* When non-null, this is a NULL terminated array of strings which match
     the end of a username, instead of just "/".  Bash sets this to
     `:' and `=~'. */
! char **tilde_additional_suffixes = default_suffixes;
  
  /* Find the start of a tilde expansion in STRING, and return the index of
--- 103,117 ----
     with the text (sans tilde, as in "foo"), and returns a malloc()'ed string
     which is the expansion, or a NULL pointer if there is no expansion. */
! tilde_hook_func_t *tilde_expansion_failure_hook = (tilde_hook_func_t *)NULL;
  
  /* When non-null, this is a NULL terminated array of strings which
     are duplicates for a tilde prefix.  Bash uses this to expand
     `=~' and `:~'. */
! char **tilde_additional_prefixes = (char **)default_prefixes;
  
  /* When non-null, this is a NULL terminated array of strings which match
     the end of a username, instead of just "/".  Bash sets this to
     `:' and `=~'. */
! char **tilde_additional_suffixes = (char **)default_suffixes;
  
  /* Find the start of a tilde expansion in STRING, and return the index of
***************
*** 187,191 ****
  char *
  tilde_expand (string)
!      char *string;
  {
    char *result;
--- 184,188 ----
  char *
  tilde_expand (string)
!      const char *string;
  {
    char *result;
***************
*** 236,242 ****
  
        len = strlen (expansion);
! #ifdef __CYGWIN32__
        /* Fix for Cygwin to prevent ~user/xxx from expanding to //xxx when
!          $HOME for `user' is /.  On cygwin, // denotes a network drive. */
        if (len > 1 || *expansion != '/' || *string != '/')
  #endif
--- 233,239 ----
  
        len = strlen (expansion);
! #ifdef __CYGWIN__
        /* Fix for Cygwin to prevent ~user/xxx from expanding to //xxx when
! 	 $HOME for `user' is /.  On cygwin, // denotes a network drive. */
        if (len > 1 || *expansion != '/' || *string != '/')
  #endif
***************
*** 304,308 ****
  char *
  tilde_expand_word (filename)
!      char *filename;
  {
    char *dirname, *expansion, *username;
--- 301,305 ----
  char *
  tilde_expand_word (filename)
!      const char *filename;
  {
    char *dirname, *expansion, *username;
***************
*** 322,331 ****
      {
        /* Prefix $HOME to the rest of the string. */
!       expansion = get_env_value ("HOME");
  
        /* If there is no HOME variable, look up the directory in
  	 the password database. */
        if (expansion == 0)
! 	expansion = get_home_dir ();
  
        return (glue_prefix_and_suffix (expansion, filename, 1));
--- 319,328 ----
      {
        /* Prefix $HOME to the rest of the string. */
!       expansion = sh_get_env_value ("HOME");
  
        /* If there is no HOME variable, look up the directory in
  	 the password database. */
        if (expansion == 0)
! 	expansion = sh_get_home_dir ();
  
        return (glue_prefix_and_suffix (expansion, filename, 1));
diff -Nrc2 bash-2.04/lib/tilde/tilde.h bash-2.05/lib/tilde/tilde.h
*** bash-2.04/lib/tilde/tilde.h	Thu Dec  2 15:47:02 1999
--- bash-2.05/lib/tilde/tilde.h	Mon Oct 30 14:31:04 2000
***************
*** 41,52 ****
  #endif
  
! /* Function pointers can be declared as (Function *)foo. */
! #if !defined (_FUNCTION_DEF)
! #  define _FUNCTION_DEF
! typedef int Function ();
! typedef void VFunction ();
! typedef char *CPFunction ();
! typedef char **CPPFunction ();
! #endif /* _FUNCTION_DEF */
  
  /* If non-null, this contains the address of a function that the application
--- 41,57 ----
  #endif
  
! #if !defined (__STDC__) && !defined (__cplusplus)
! #  if defined (__GNUC__)	/* gcc with -traditional */
! #    if !defined (const)
! #      define const __const
! #    endif /* !const */
! #  else /* !__GNUC__ */
! #    if !defined (const)
! #      define const
! #    endif /* !const */
! #  endif /* !__GNUC__ */
! #endif /* !__STDC__ && !__cplusplus */
! 
! typedef char *tilde_hook_func_t __P((char *));
  
  /* If non-null, this contains the address of a function that the application
***************
*** 54,58 ****
     is called with the text sans tilde, and returns a malloc()'ed string
     which is the expansion, or a NULL pointer if the expansion fails. */
! extern CPFunction *tilde_expansion_preexpansion_hook;
  
  /* If non-null, this contains the address of a function to call if the
--- 59,63 ----
     is called with the text sans tilde, and returns a malloc()'ed string
     which is the expansion, or a NULL pointer if the expansion fails. */
! extern tilde_hook_func_t *tilde_expansion_preexpansion_hook;
  
  /* If non-null, this contains the address of a function to call if the
***************
*** 60,64 ****
     with the text (sans tilde, as in "foo"), and returns a malloc()'ed string
     which is the expansion, or a NULL pointer if there is no expansion. */
! extern CPFunction *tilde_expansion_failure_hook;
  
  /* When non-null, this is a NULL terminated array of strings which
--- 65,69 ----
     with the text (sans tilde, as in "foo"), and returns a malloc()'ed string
     which is the expansion, or a NULL pointer if there is no expansion. */
! extern tilde_hook_func_t *tilde_expansion_failure_hook;
  
  /* When non-null, this is a NULL terminated array of strings which
***************
*** 73,81 ****
  
  /* Return a new string which is the result of tilde expanding STRING. */
! extern char *tilde_expand __P((char *));
  
  /* Do the work of tilde expansion on FILENAME.  FILENAME starts with a
     tilde.  If there is no expansion, call tilde_expansion_failure_hook. */
! extern char *tilde_expand_word __P((char *));
  
  #ifdef __cplusplus
--- 78,86 ----
  
  /* Return a new string which is the result of tilde expanding STRING. */
! extern char *tilde_expand __P((const char *));
  
  /* Do the work of tilde expansion on FILENAME.  FILENAME starts with a
     tilde.  If there is no expansion, call tilde_expansion_failure_hook. */
! extern char *tilde_expand_word __P((const char *));
  
  #ifdef __cplusplus
diff -Nrc2 bash-2.04/locale.c bash-2.05/locale.c
*** bash-2.04/locale.c	Tue Mar 14 11:35:20 2000
--- bash-2.05/locale.c	Wed Feb 14 16:59:09 2001
***************
*** 235,244 ****
      {
        if (lenp)
!         *lenp = 0;
        return ((char *)NULL);
      }
  
-   t = xmalloc (len + 1);
- 
    locale = get_locale_var ("LC_MESSAGES");
  
--- 235,242 ----
      {
        if (lenp)
! 	*lenp = 0;
        return ((char *)NULL);
      }
  
    locale = get_locale_var ("LC_MESSAGES");
  
***************
*** 251,254 ****
--- 249,253 ----
  #endif
      {
+       t = xmalloc (len + 1);
        strcpy (t, string);
        if (lenp)
***************
*** 262,265 ****
--- 261,265 ----
    if (translated == string)	/* gettext returns its argument if untranslatable */
      {
+       t = xmalloc (len + 1);
        strcpy (t, string);
        if (lenp)
***************
*** 268,272 ****
    else
      {
-       free (t);
        tlen = strlen (translated);
        t = xmalloc (tlen + 1);
--- 268,271 ----
diff -Nrc2 bash-2.04/mailcheck.c bash-2.05/mailcheck.c
*** bash-2.04/mailcheck.c	Thu Aug  5 07:21:09 1999
--- bash-2.05/mailcheck.c	Wed Feb 14 16:59:15 2001
***************
*** 284,288 ****
  	}
        if (*s == '?' || *s == '%')
!         return s;
      }
    return ((char *)NULL);
--- 284,288 ----
  	}
        if (*s == '?' || *s == '%')
! 	return s;
      }
    return ((char *)NULL);
diff -Nrc2 bash-2.04/make_cmd.c bash-2.05/make_cmd.c
*** bash-2.04/make_cmd.c	Thu Aug  5 07:21:23 1999
--- bash-2.05/make_cmd.c	Wed Feb 14 16:54:04 2001
***************
*** 33,36 ****
--- 33,37 ----
  #endif
  
+ #include "syntax.h"
  #include "command.h"
  #include "general.h"
***************
*** 251,255 ****
        /* skip to the semicolon or EOS */
        while (*s && *s != ';')
!         s++;
  
        t = (s > start) ? substring (start, 0, s - start) : (char *)NULL;
--- 252,256 ----
        /* skip to the semicolon or EOS */
        while (*s && *s != ';')
! 	s++;
  
        t = (s > start) ? substring (start, 0, s - start) : (char *)NULL;
***************
*** 271,275 ****
        FREE (t);
        if (*s == '\0')
!         break;
        s++;	/* skip over semicolon */
      }
--- 272,276 ----
        FREE (t);
        if (*s == '\0')
! 	break;
        s++;	/* skip over semicolon */
      }
***************
*** 570,574 ****
  
        if (kill_leading && *line)
!         {
  	  /* Hack:  To be compatible with some Bourne shells, we
  	     check the word before stripping the whitespace.  This
--- 571,575 ----
  
        if (kill_leading && *line)
! 	{
  	  /* Hack:  To be compatible with some Bourne shells, we
  	     check the word before stripping the whitespace.  This
***************
*** 582,586 ****
  
        if (*line == 0)
!         continue;
  
        if (STREQN (line, redir_word, redir_len) && line[redir_len] == '\n')
--- 583,587 ----
  
        if (*line == 0)
! 	continue;
  
        if (STREQN (line, redir_word, redir_len) && line[redir_len] == '\n')
diff -Nrc2 bash-2.04/mksyntax.c bash-2.05/mksyntax.c
*** bash-2.04/mksyntax.c	Wed Dec 31 19:00:00 1969
--- bash-2.05/mksyntax.c	Wed Feb 14 16:59:25 2001
***************
*** 0 ****
--- 1,377 ----
+ /*
+  * mksyntax.c - construct shell syntax table for fast char attribute lookup.
+  */
+ 
+ /* Copyright (C) 2000 Free Software Foundation, Inc.
+ 
+    This file is part of GNU Bash, the Bourne Again SHell.
+ 
+    Bash is free software; you can redistribute it and/or modify it under
+    the terms of the GNU General Public License as published by the Free
+    Software Foundation; either version 2, or (at your option) any later
+    version.
+ 
+    Bash is distributed in the hope that it will be useful, but WITHOUT ANY
+    WARRANTY; without even the implied warranty of MERCHANTABILITY or
+    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+    for more details.
+ 
+    You should have received a copy of the GNU General Public License along
+    with Bash; see the file COPYING.  If not, write to the Free Software
+    Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. */
+ 
+ #include "config.h"
+ #include <stdio.h>
+ #include "bashansi.h"
+ #include <ctype.h>
+ #include <errno.h>
+ 
+ #include "syntax.h"
+ 
+ extern int optind;
+ extern char *optarg;
+ 
+ #ifndef errno
+ extern int errno;
+ #endif
+ 
+ #ifndef HAVE_STRERROR
+ extern char *strerror();
+ #endif
+ 
+ struct wordflag {
+ 	int	flag;
+ 	char	*fstr;
+ } wordflags[] = {
+ 	{ CWORD,	"CWORD" },
+ 	{ CSHMETA,	"CSHMETA" },
+ 	{ CSHBRK,	"CSHBRK" },
+ 	{ CBACKQ,	"CBACKQ" },
+ 	{ CQUOTE,	"CQUOTE" },
+ 	{ CSPECL,	"CSPECL" },
+ 	{ CEXP,		"CEXP" },
+ 	{ CBSDQUOTE,	"CBSDQUOTE" },
+ 	{ CBSHDOC,	"CBSHDOC" },
+ 	{ CGLOB,	"CGLOB" },
+ 	{ CXGLOB,	"CXGLOB" },
+ 	{ CXQUOTE,	"CXQUOTE" },
+ 	{ CSPECVAR,	"CSPECVAR" }
+ };
+ 	
+ #define N_WFLAGS	(sizeof (wordflags) / sizeof (wordflags[0]))
+ #define SYNSIZE		256
+ 
+ int	lsyntax[SYNSIZE];
+ int	debug;
+ char	*progname;
+ 
+ char	preamble[] = "\
+ /*\n\
+  * This file was generated by mksyntax.  DO NOT EDIT.\n\
+  */\n\
+ \n";
+ 
+ char	includes[] = "\
+ #include \"stdc.h\"\n\
+ #include \"syntax.h\"\n\n";
+ 
+ static void
+ usage()
+ {
+   fprintf (stderr, "%s: usage: %s [-d] [-o filename]\n", progname, progname);
+   exit (2);
+ }
+ 
+ static int
+ getcflag (s)
+      char *s;
+ {
+   int i;
+ 
+   for (i = 0; i < N_WFLAGS; i++)
+     if (strcmp (s, wordflags[i].fstr) == 0)
+       return wordflags[i].flag;
+   return -1;
+ }
+ 
+ static char *
+ cdesc (i)
+      int i;
+ {
+   static char xbuf[16];
+ 
+   if (i == ' ')
+     return "SPC";
+   else if (isprint (i))
+     {
+       xbuf[0] = i;
+       xbuf[1] = '\0';
+       return (xbuf);
+     }
+   else if (i == CTLESC)
+     return "CTLESC";
+   else if (i == CTLNUL)
+     return "CTLNUL";
+   else if (i == '\033')		/* ASCII */
+     return "ESC";
+ 
+   xbuf[0] = '\\';
+   xbuf[2] = '\0';
+     
+   switch (i)
+     {
+     case '\a': xbuf[1] = 'a'; break;
+     case '\v': xbuf[1] = 'v'; break;
+     case '\b': xbuf[1] = 'b'; break;
+     case '\f': xbuf[1] = 'f'; break;
+     case '\n': xbuf[1] = 'n'; break;
+     case '\r': xbuf[1] = 'r'; break;
+     case '\t': xbuf[1] = 't'; break;
+     default: sprintf (xbuf, "%d", i); break;
+     }
+ 
+   return xbuf;	
+ }
+ 
+ static char *
+ getcstr (f)
+      int f;
+ {
+   int i;
+ 
+   for (i = 0; i < N_WFLAGS; i++)
+     if (f == wordflags[i].flag)
+       return (wordflags[i].fstr);
+   return ((char *)NULL);
+ }
+ 
+ static void
+ addcstr (str, flag)
+      char *str;
+      int flag;
+ {
+   unsigned char *s;
+   char *fstr;
+ 
+   for (s = (unsigned char *)str; s && *s; s++)
+     {
+       if (debug)
+ 	{
+ 	  fstr = getcstr (flag);
+ 	  fprintf(stderr, "added %s for character %s\n", fstr, cdesc(*s));
+ 	}
+ 	
+       lsyntax[*s] |= flag;
+     }
+ }
+ 
+ static void
+ addcchar (c, flag)
+      unsigned char c;
+      int flag;
+ {
+   char *fstr;
+ 
+   if (debug)
+     {
+       fstr = getcstr (flag);
+       fprintf (stderr, "added %s for character %s\n", fstr, cdesc(c));
+     }
+   lsyntax[c] |= flag;
+ }
+ 
+ /* load up the correct flag values in lsyntax */
+ static void
+ load_lsyntax ()
+ {
+   /* shell metacharacters */
+   addcstr (shell_meta_chars, CSHMETA);
+ 
+   /* shell word break characters */
+   addcstr (shell_break_chars, CSHBRK);
+ 
+   addcchar ('`', CBACKQ);
+ 
+   addcstr (shell_quote_chars, CQUOTE);
+ 
+   addcchar (CTLESC, CSPECL);
+   addcchar (CTLNUL, CSPECL);
+ 
+   addcstr (shell_exp_chars, CEXP);
+ 
+   addcstr (slashify_in_quotes, CBSDQUOTE);
+   addcstr (slashify_in_here_document, CBSHDOC);
+ 
+   addcstr (shell_glob_chars, CGLOB);
+ 
+ #if defined (EXTENDED_GLOB)
+   addcstr (ext_glob_chars, CXGLOB);
+ #endif
+ 
+   addcstr (shell_quote_chars, CXQUOTE);
+   addcchar ('\\', CXQUOTE);
+ 
+   addcstr ("@*#?-$!", CSPECVAR);	/* omits $0...$9 and $_ */
+ }
+ 
+ static void
+ dump_lflags (fp, ind)
+      FILE *fp;
+      int ind;
+ {
+   int xflags, first, i;
+ 
+   xflags = lsyntax[ind];
+   first = 1;
+ 
+   if (xflags == 0)
+     fputs (wordflags[0].fstr, fp);
+   else
+     {
+       for (i = 1; i < N_WFLAGS; i++)
+ 	if (xflags & wordflags[i].flag)
+ 	  {
+ 	    if (first)
+ 	      first = 0;
+ 	    else
+ 	      putc ('|', fp);
+ 	    fputs (wordflags[i].fstr, fp);
+   	  }
+     }
+ }
+ 
+ static void
+ wcomment (fp, i)
+      FILE *fp;
+      int i;
+ {
+   fputs ("\t\t/* ", fp);
+ 
+   fprintf (fp, "%s", cdesc(i));
+       
+   fputs (" */", fp);
+ }
+ 
+ static void
+ dump_lsyntax (fp)
+      FILE *fp;
+ {
+   int i, cflag;
+   char *cstr;
+ 
+   fprintf (fp, "const int sh_syntaxtab[%d] = {\n", SYNSIZE);
+ 
+   for (i = 0; i < SYNSIZE; i++)
+     {
+       putc ('\t', fp);
+       dump_lflags (fp, i);
+       putc (',', fp);
+       wcomment (fp, i);
+       putc ('\n', fp);
+     }
+ 
+   fprintf (fp, "};\n");
+ }
+ 
+ main(argc, argv)
+      int argc;
+      char **argv;
+ {
+   int opt, i;
+   char *filename;
+   FILE *fp;
+ 
+   if ((progname = strrchr (argv[0], '/')) == 0)
+     progname = argv[0];
+   else
+     progname++;
+ 
+   filename = (char *)NULL;
+   debug = 0;
+ 
+   while ((opt = getopt (argc, argv, "do:")) != EOF)
+     {
+       switch (opt)
+ 	{
+ 	case 'd':
+ 	  debug = 1;
+ 	  break;
+ 	case 'o':
+ 	  filename = optarg;
+ 	  break;
+ 	default:
+ 	  usage();
+ 	}
+     }
+ 
+   argc -= optind;
+   argv += optind;
+ 
+   if (filename)
+     {
+       fp = fopen (filename, "w");
+       if (fp == 0)
+ 	{
+ 	  fprintf (stderr, "%s: %s: cannot open: %s\n", progname, filename, strerror(errno));
+ 	  exit (1);
+ 	}
+     }
+   else
+     {
+       filename = "stdout";
+       fp = stdout;
+     }
+ 
+ 
+   for (i = 0; i < SYNSIZE; i++)
+     lsyntax[i] = CWORD;
+ 
+   load_lsyntax ();
+ 
+   fprintf (fp, "%s\n", preamble);
+   fprintf (fp, "%s\n", includes);
+ 
+   dump_lsyntax (fp);
+ 
+   if (fp != stdout)
+     fclose (fp);
+   exit (0);
+ }
+ 
+ 
+ #if !defined (HAVE_STRERROR)
+ 
+ #include <bashtypes.h>
+ #ifndef _MINIX
+ #  include <sys/param.h>
+ #endif
+ 
+ #if defined (HAVE_UNISTD_H)
+ #  include <unistd.h>
+ #endif
+ 
+ /* Return a string corresponding to the error number E.  From
+    the ANSI C spec. */
+ #if defined (strerror)
+ #  undef strerror
+ #endif
+ 
+ char *
+ strerror (e)
+      int e;
+ {
+   static char emsg[40];
+ #if defined (HAVE_SYS_ERRLIST)
+   extern int sys_nerr;
+   extern char *sys_errlist[];
+ 
+   if (e > 0 && e < sys_nerr)
+     return (sys_errlist[e]);
+   else
+ #endif /* HAVE_SYS_ERRLIST */
+     {
+       sprintf (emsg, "Unknown system error %d", e);
+       return (&emsg[0]);
+     }
+ }
+ #endif /* HAVE_STRERROR */
diff -Nrc2 bash-2.04/nojobs.c bash-2.05/nojobs.c
*** bash-2.04/nojobs.c	Tue Sep 21 14:23:59 1999
--- bash-2.05/nojobs.c	Tue Apr  3 15:29:48 2001
***************
*** 84,88 ****
  
  #if defined (READLINE)
! extern void _rl_set_screen_size (); 
  #endif
  
--- 84,88 ----
  
  #if defined (READLINE)
! extern void rl_set_screen_size __P((int, int));
  #endif
  
***************
*** 289,293 ****
        if (((pid_list[i].flags & PROC_RUNNING) == 0) &&
  	   (pid_list[i].flags & PROC_ASYNC))
!         ndead++;
      }
  
--- 289,293 ----
        if (((pid_list[i].flags & PROC_RUNNING) == 0) &&
  	   (pid_list[i].flags & PROC_ASYNC))
! 	ndead++;
      }
  
***************
*** 365,371 ****
        shell_tty_info.c_winsize = win;	/* structure copying */
  #endif
!       set_lines_and_columns (win.ws_row, win.ws_col);
  #if defined (READLINE)
!       _rl_set_screen_size (win.ws_row, win.ws_col);
  #endif
      }
--- 365,371 ----
        shell_tty_info.c_winsize = win;	/* structure copying */
  #endif
!       sh_set_lines_and_columns (win.ws_row, win.ws_col);
  #if defined (READLINE)
!       rl_set_screen_size (win.ws_row, win.ws_col);
  #endif
      }
***************
*** 570,574 ****
  	}
        else if (got_pid > 0)
!         set_pid_status (got_pid, status);
      }
  
--- 570,574 ----
  	}
        else if (got_pid > 0)
! 	set_pid_status (got_pid, status);
      }
  
***************
*** 650,657 ****
      }
  
! #if 0
!   /* Run a trap handler if one has been defined. */
!   maybe_call_trap_handler (sig);
! #endif
  
    wait_sigint_received = 1;
--- 650,660 ----
      }
  
!   if (interrupt_immediately)
!     {
!       last_command_exit_value = EXECUTION_FAILURE;
!       restore_sigint_handler ();
!       ADDINTERRUPT;
!       QUIT;
!     }
  
    wait_sigint_received = 1;
***************
*** 809,814 ****
  
  /* Give the terminal to PGRP.  */
! give_terminal_to (pgrp)
       pid_t pgrp;
  {
  }
--- 812,818 ----
  
  /* Give the terminal to PGRP.  */
! give_terminal_to (pgrp, force)
       pid_t pgrp;
+      int force;
  {
  }
diff -Nrc2 bash-2.04/parse.y bash-2.05/parse.y
*** bash-2.04/parse.y	Tue Feb 22 13:12:03 2000
--- bash-2.05/parse.y	Tue Mar 27 10:06:12 2001
***************
*** 25,28 ****
--- 25,30 ----
  #include "bashansi.h"
  
+ #include "filecntl.h"
+ 
  #if defined (HAVE_UNISTD_H)
  #  include <unistd.h>
***************
*** 78,84 ****
  
  #if defined (EXTENDED_GLOB)
- #define PATTERN_CHAR(c) \
- 	((c) == '@' || (c) == '*' || (c) == '+' || (c) == '?' || (c) == '!')
- 
  extern int extended_glob;
  #endif
--- 80,83 ----
***************
*** 128,131 ****
--- 127,134 ----
  static void print_prompt ();
  
+ #if defined (HISTORY)
+ char *history_delimiting_chars ();
+ #endif
+ 
  extern int yyerror ();
  
***************
*** 221,225 ****
  %type <command> cond_command
  %type <command> arith_for_command
! %type <command> function_def if_command elif_clause subshell
  %type <redirect> redirection redirection_list
  %type <element> simple_command_element
--- 224,228 ----
  %type <command> cond_command
  %type <command> arith_for_command
! %type <command> function_def function_body if_command elif_clause subshell
  %type <redirect> redirection redirection_list
  %type <element> simple_command_element
***************
*** 463,485 ****
  
  			  tc = $1;
- 			  /* According to Posix.2 3.9.5, redirections
- 			     specified after the body of a function should
- 			     be attached to the function and performed when
- 			     the function is executed, not as part of the
- 			     function definition command. */
- 			  /* XXX - I don't think it matters, but we might
- 			     want to change this in the future to avoid
- 			     problems differentiating between a function
- 			     definition with a redirection and a function
- 			     definition containing a single command with a
- 			     redirection.  The two are semantically equivalent,
- 			     though -- the only difference is in how the
- 			     command printing code displays the redirections. */
- 			  if (tc->type == cm_function_def)
- 			    {
- 			      tc = tc->value.Function_def->command;
- 			      if (tc->type == cm_group)
- 			        tc = tc->value.Group->command;
- 			    }
  			  if (tc->redirects)
  			    {
--- 466,469 ----
***************
*** 493,496 ****
--- 477,482 ----
  			  $$ = $1;
  			}
+ 	|	function_def
+ 			{ $$ = $1; }
  	;
  
***************
*** 517,522 ****
  	|	arith_for_command
  			{ $$ = $1; }
- 	|	function_def
- 			{ $$ = $1; }
  	;
  
--- 503,506 ----
***************
*** 539,543 ****
--- 523,532 ----
  	|		FOR ARITH_FOR_EXPRS list_terminator newline_list '{' compound_list '}'
  				{ $$ = make_arith_for_command ($2, $6, arith_for_lineno); }
+ 	|		FOR ARITH_FOR_EXPRS DO compound_list DONE
+ 				{ $$ = make_arith_for_command ($2, $4, arith_for_lineno); }
+ 	|		FOR ARITH_FOR_EXPRS '{' compound_list '}'
+ 				{ $$ = make_arith_for_command ($2, $4, arith_for_lineno); }
  	;
+ 
  select_command:	SELECT WORD newline_list DO list DONE
  			{
***************
*** 574,588 ****
  	;
  
! function_def:	WORD '(' ')' newline_list group_command
  			{ $$ = make_function_def ($1, $5, function_dstart, function_bstart); }
  
! 
! 	|	FUNCTION WORD '(' ')' newline_list group_command
  			{ $$ = make_function_def ($2, $6, function_dstart, function_bstart); }
  
! 	|	FUNCTION WORD newline_list group_command
  			{ $$ = make_function_def ($2, $4, function_dstart, function_bstart); }
  	;
  
  subshell:	'(' compound_list ')'
  			{
--- 563,610 ----
  	;
  
! function_def:	WORD '(' ')' newline_list function_body
  			{ $$ = make_function_def ($1, $5, function_dstart, function_bstart); }
  
! 	|	FUNCTION WORD '(' ')' newline_list function_body
  			{ $$ = make_function_def ($2, $6, function_dstart, function_bstart); }
  
! 	|	FUNCTION WORD newline_list function_body
  			{ $$ = make_function_def ($2, $4, function_dstart, function_bstart); }
  	;
  
+ 
+ function_body:	shell_command
+ 			{ $$ = $1; }
+ 	|	shell_command redirection_list
+ 			{
+ 			  COMMAND *tc;
+ 
+ 			  tc = $1;
+ 			  /* According to Posix.2 3.9.5, redirections
+ 			     specified after the body of a function should
+ 			     be attached to the function and performed when
+ 			     the function is executed, not as part of the
+ 			     function definition command. */
+ 			  /* XXX - I don't think it matters, but we might
+ 			     want to change this in the future to avoid
+ 			     problems differentiating between a function
+ 			     definition with a redirection and a function
+ 			     definition containing a single command with a
+ 			     redirection.  The two are semantically equivalent,
+ 			     though -- the only difference is in how the
+ 			     command printing code displays the redirections. */
+ 			  if (tc->redirects)
+ 			    {
+ 			      register REDIRECT *t;
+ 			      for (t = tc->redirects; t->next; t = t->next)
+ 				;
+ 			      t->next = $2;
+ 			    }
+ 			  else
+ 			    tc->redirects = $2;
+ 			  $$ = $1;
+ 			}
+ 	;
+ 
  subshell:	'(' compound_list ')'
  			{
***************
*** 601,605 ****
  
  
! group_command:	'{' list '}'
  			{ $$ = make_group_command ($2); }
  	;
--- 623,627 ----
  
  
! group_command:	'{' compound_list '}'
  			{ $$ = make_group_command ($2); }
  	;
***************
*** 810,822 ****
  #define TOKEN_DEFAULT_GROW_SIZE 512
  
- /* Shell meta-characters that, when unquoted, separate words. */
- #define shellmeta(c)	(strchr (shell_meta_chars, (c)) != 0)
- #define shellbreak(c)	(strchr (shell_break_chars, (c)) != 0)
- #define shellquote(c)	((c) == '"' || (c) == '`' || (c) == '\'')
- #define shellexp(c)	((c) == '$' || (c) == '<' || (c) == '>')
- 
- char *shell_meta_chars = "()<>;&|";
- char *shell_break_chars = "()<>;&| \t\n";
- 
  /* The token currently being read. */
  static int current_token;
--- 832,835 ----
***************
*** 967,971 ****
  #if defined (JOB_CONTROL)
        if (job_control)
! 	give_terminal_to (shell_pgrp);
  #endif /* JOB_CONTROL */
  
--- 980,984 ----
  #if defined (JOB_CONTROL)
        if (job_control)
! 	give_terminal_to (shell_pgrp, 0);
  #endif /* JOB_CONTROL */
  
***************
*** 1197,1202 ****
  	 re-establish the buffer <-> bash_input fd correspondence. */
        if (bash_input.type == st_bstream && bash_input.location.buffered_fd >= 0)
!         {
!           if (bash_input_fd_changed)
  	    {
  	      bash_input_fd_changed = 0;
--- 1210,1215 ----
  	 re-establish the buffer <-> bash_input fd correspondence. */
        if (bash_input.type == st_bstream && bash_input.location.buffered_fd >= 0)
! 	{
! 	  if (bash_input_fd_changed)
  	    {
  	      bash_input_fd_changed = 0;
***************
*** 1205,1212 ****
  		  bash_input.location.buffered_fd = default_buffered_input;
  		  saver->bstream->b_fd = default_buffered_input;
  		}
  	    }
  	  set_buffered_stream (bash_input.location.buffered_fd, saver->bstream);
!         }
  #endif /* BUFFERED_INPUT */
  
--- 1218,1227 ----
  		  bash_input.location.buffered_fd = default_buffered_input;
  		  saver->bstream->b_fd = default_buffered_input;
+ 		  SET_CLOSE_ON_EXEC (default_buffered_input);
  		}
  	    }
+ 	  /* XXX could free buffered stream returned as result here. */
  	  set_buffered_stream (bash_input.location.buffered_fd, saver->bstream);
! 	}
  #endif /* BUFFERED_INPUT */
  
***************
*** 1413,1418 ****
        QUIT;
  
        if (c == 0)
! 	continue;
  
        /* If there is no more input, then we return NULL. */
--- 1428,1439 ----
        QUIT;
  
+       /* Ignore null bytes in input. */
        if (c == 0)
! 	{
! #if 0
! 	  internal_warning ("read_a_line: ignored null byte in input");
! #endif
! 	  continue;
! 	}
  
        /* If there is no more input, then we return NULL. */
***************
*** 1436,1443 ****
  	 quoting a backslash-newline pair appears in the line. */
        if (pass_next)
!         {
  	  line_buffer[indx++] = c;
  	  pass_next = 0;
!         }
        else if (c == '\\' && remove_quoted_newline)
  	{
--- 1457,1464 ----
  	 quoting a backslash-newline pair appears in the line. */
        if (pass_next)
! 	{
  	  line_buffer[indx++] = c;
  	  pass_next = 0;
! 	}
        else if (c == '\\' && remove_quoted_newline)
  	{
***************
*** 1517,1522 ****
  
  /* XXX - we should also have an alist with strings for other tokens, so we
!          can give more descriptive error messages.  Look at y.tab.h for the
!          other tokens. */
  
  /* These are used by read_token_word, but appear up here so that shell_getc
--- 1538,1543 ----
  
  /* XXX - we should also have an alist with strings for other tokens, so we
! 	 can give more descriptive error messages.  Look at y.tab.h for the
! 	 other tokens. */
  
  /* These are used by read_token_word, but appear up here so that shell_getc
***************
*** 1554,1557 ****
--- 1575,1583 ----
     processing normal command input. */
  
+ /* This implements one-character lookahead/lookbehind across physical input
+    lines, to avoid something being lost because it's pushed back with
+    shell_ungetc when we're at the start of a line. */
+ static int eol_ungetc_lookahead = 0;
+ 
  static int
  shell_getc (remove_quoted_newline)
***************
*** 1564,1567 ****
--- 1590,1600 ----
    QUIT;
  
+   if (eol_ungetc_lookahead)
+     {
+       c = eol_ungetc_lookahead;
+       eol_ungetc_lookahead = 0;
+       return (c);
+     }
+ 
  #if defined (ALIAS) || defined (DPAREN_ARITHMETIC)
    /* If shell_input_line[shell_input_line_index] == 0, but there is
***************
*** 1605,1613 ****
  	clearerr (stdin);
  
!       while (c = yy_getc ())
  	{
  	  /* Allow immediate exit if interrupted during input. */
  	  QUIT;
  
  	  RESIZE_MALLOCED_BUFFER (shell_input_line, i, 2, shell_input_line_size, 256);
  
--- 1638,1656 ----
  	clearerr (stdin);
  
!       while (1)
  	{
+ 	  c = yy_getc ();
+ 
  	  /* Allow immediate exit if interrupted during input. */
  	  QUIT;
  
+ 	  if (c == '\0')
+ 	    {
+ #if 0
+ 	      internal_warning ("shell_getc: ignored null byte in input");
+ #endif
+ 	      continue;
+ 	    }
+ 
  	  RESIZE_MALLOCED_BUFFER (shell_input_line, i, 2, shell_input_line_size, 256);
  
***************
*** 1633,1636 ****
--- 1676,1680 ----
  	    }
  	}
+ 
        shell_input_line_index = 0;
        shell_input_line_len = i;		/* == strlen (shell_input_line) */
***************
*** 1664,1681 ****
  
  	      /* We have to force the xrealloc below because we don't know
! 	         the true allocated size of shell_input_line anymore. */
  	      shell_input_line_size = shell_input_line_len;
  	    }
  	}
!       /* XXX - this is grotesque */
        else if (remember_on_history && shell_input_line &&
  	       shell_input_line[0] == '\0' &&
! 	       current_command_line_count > 1 && current_delimiter (dstack))
  	{
! 	  /* We know shell_input_line[0] == 0 and we're reading some sort of
! 	     quoted string.  This means we've got a line consisting of only
! 	     a newline in a quoted string.  We want to make sure this line
! 	     gets added to the history. */
! 	  maybe_add_history (shell_input_line);
  	}
  
--- 1708,1734 ----
  
  	      /* We have to force the xrealloc below because we don't know
! 		 the true allocated size of shell_input_line anymore. */
  	      shell_input_line_size = shell_input_line_len;
  	    }
  	}
!       /* Try to do something intelligent with blank lines encountered while
! 	 entering multi-line commands.  XXX - this is grotesque */
        else if (remember_on_history && shell_input_line &&
  	       shell_input_line[0] == '\0' &&
! 	       current_command_line_count > 1)
  	{
! 	  if (current_delimiter (dstack))
! 	    /* We know shell_input_line[0] == 0 and we're reading some sort of
! 	       quoted string.  This means we've got a line consisting of only
! 	       a newline in a quoted string.  We want to make sure this line
! 	       gets added to the history. */
! 	    maybe_add_history (shell_input_line);
! 	  else
! 	    {
! 	      char *hdcs;
! 	      hdcs = history_delimiting_chars ();
! 	      if (hdcs && hdcs[0] == ';')
! 		maybe_add_history (shell_input_line);
! 	    }
  	}
  
***************
*** 1733,1748 ****
      {
        if (mustpop)
!         {
!           pop_string ();
!           c = shell_input_line[shell_input_line_index];
  	  if (c)
  	    shell_input_line_index++;
  	  mustpop--;
!         }
        else
!         {
!           mustpop++;
!           c = ' ';
!         }
      }
  #endif /* ALIAS || DPAREN_ARITHMETIC */
--- 1786,1801 ----
      {
        if (mustpop)
! 	{
! 	  pop_string ();
! 	  c = shell_input_line[shell_input_line_index];
  	  if (c)
  	    shell_input_line_index++;
  	  mustpop--;
! 	}
        else
! 	{
! 	  mustpop++;
! 	  c = ' ';
! 	}
      }
  #endif /* ALIAS || DPAREN_ARITHMETIC */
***************
*** 1761,1764 ****
--- 1814,1819 ----
    if (shell_input_line && shell_input_line_index)
      shell_input_line[--shell_input_line_index] = c;
+   else
+     eol_ungetc_lookahead = c;
  }
  
***************
*** 1975,1980 ****
      case THEN:
      case ELSE:
!     case '{':
!     case '(':
        return 1;
      default:
--- 2030,2035 ----
      case THEN:
      case ELSE:
!     case '{':		/* } */
!     case '(':		/* ) */
        return 1;
      default:
***************
*** 1997,2003 ****
  
  	`{' is recognized if the last token as WORD and the token
! 	before that was FUNCTION.
  
! 	`}' is recognized if there is an unclosed `{' prsent.
  
  	`-p' is returned as TIMEOPT if the last read token was TIME.
--- 2052,2059 ----
  
  	`{' is recognized if the last token as WORD and the token
! 	before that was FUNCTION, or if we just parsed an arithmetic
! 	`for' command.
  
! 	`}' is recognized if there is an unclosed `{' present.
  
  	`-p' is returned as TIMEOPT if the last read token was TIME.
***************
*** 2067,2070 ****
--- 2123,2136 ----
      }
  
+   /* We allow a `do' after a for ((...)) without an intervening
+      list_terminator */
+   if (last_read_token == ARITH_FOR_EXPRS && token[0] == 'd' && token[1] == 'o' && !token[2])
+     return (DO);
+   if (last_read_token == ARITH_FOR_EXPRS && token[0] == '{' && token[1] == '\0')	/* } */
+     {
+       open_brace_count++;
+       return ('{');			/* } */
+     }
+ 
    if (open_brace_count && reserved_word_acceptable (last_read_token) && token[0] == '}' && !token[1])
      {
***************
*** 2264,2268 ****
  		    {
  		      /* parse_arith_cmd adds quotes at the beginning and end
! 		         of the string it returns; we need to take those out. */
  		      len = strlen (wval);
  		      wv2 = xmalloc (len);
--- 2330,2334 ----
  		    {
  		      /* parse_arith_cmd adds quotes at the beginning and end
! 			 of the string it returns; we need to take those out. */
  		      len = strlen (wval);
  		      wv2 = xmalloc (len);
***************
*** 2343,2347 ****
        /*(*/
        else if ((parser_state & PST_CASEPAT) && character == ')')
!         parser_state &= ~PST_CASEPAT;
        /*(*/
        else if ((parser_state & PST_SUBSHELL) && character == ')')
--- 2409,2413 ----
        /*(*/
        else if ((parser_state & PST_CASEPAT) && character == ')')
! 	parser_state &= ~PST_CASEPAT;
        /*(*/
        else if ((parser_state & PST_SUBSHELL) && character == ')')
***************
*** 2387,2392 ****
  {
    int count, ch, was_dollar;
!   int pass_next_character, nestlen, start_lineno;
!   char *ret, *nestret;
    int retind, retsize;
  
--- 2453,2458 ----
  {
    int count, ch, was_dollar;
!   int pass_next_character, nestlen, ttranslen, start_lineno;
!   char *ret, *nestret, *ttrans;
    int retind, retsize;
  
***************
*** 2441,2445 ****
        /* handle nested ${...} specially. */
        else if (open != close && was_dollar && open == '{' && ch == open) /* } */
!         count++;
  #endif
        else if (((flags & P_FIRSTCLOSE) == 0) && ch == open)		/* nested begin */
--- 2507,2511 ----
        /* handle nested ${...} specially. */
        else if (open != close && was_dollar && open == '{' && ch == open) /* } */
! 	count++;
  #endif
        else if (((flags & P_FIRSTCLOSE) == 0) && ch == open)		/* nested begin */
***************
*** 2466,2470 ****
  	      /* '', ``, or "" inside $(...) or other grouping construct. */
  	      push_delimiter (dstack, ch);
! 	      nestret = parse_matched_pair (ch, ch, ch, &nestlen, 0);
  	      pop_delimiter (dstack);
  	      if (nestret == &matched_pair_error)
--- 2532,2539 ----
  	      /* '', ``, or "" inside $(...) or other grouping construct. */
  	      push_delimiter (dstack, ch);
! 	      if (was_dollar && ch == '\'')	/* $'...' inside group */
! 		nestret = parse_matched_pair (ch, ch, ch, &nestlen, P_ALLOWESC);
! 	      else
! 		nestret = parse_matched_pair (ch, ch, ch, &nestlen, 0);
  	      pop_delimiter (dstack);
  	      if (nestret == &matched_pair_error)
***************
*** 2473,2476 ****
--- 2542,2569 ----
  		  return &matched_pair_error;
  		}
+ 	      if (was_dollar && ch == '\'')
+ 		{
+ 		  /* Translate $'...' here. */
+ 		  ttrans = ansiexpand (nestret, 0, nestlen - 1, &ttranslen);
+ 		  free (nestret);
+ 		  nestret = sh_single_quote (ttrans);
+ 		  free (ttrans);
+ 		  nestlen = strlen (nestret);
+ 		  retind -= 2;		/* back up before the $' */
+ 		}
+ 	      else if (was_dollar && ch == '"')
+ 		{
+ 		  /* Locale expand $"..." here. */
+ 		  ttrans = localeexpand (nestret, 0, nestlen - 1, start_lineno, &ttranslen);
+ 		  free (nestret);
+ 		  nestret = xmalloc (ttranslen + 3);
+ 		  nestret[0] = '"';
+ 		  strcpy (nestret + 1, ttrans);
+ 		  nestret[ttranslen + 1] = '"';
+ 		  nestret[ttranslen += 2] = '\0';
+ 		  free (ttrans);
+ 		  nestlen = ttranslen;
+ 		  retind -= 2;		/* back up before the $" */
+ 		}
  	      if (nestlen)
  		{
***************
*** 2697,2708 ****
        tok = read_token (READ);
        if (tok == WORD && test_binop (yylval.word->word))
!         op = yylval.word;
        else if (tok == '<' || tok == '>')
!         op = make_word_from_token (tok);
!       else if (tok == COND_END || tok == AND_AND || tok == OR_OR)
  	{
  	  /* Special case.  [[ x ]] is equivalent to [[ -n x ]], just like
  	     the test command.  Similarly for [[ x && expr ]] or
! 	     [[ x || expr ]] */
  	  op = make_word ("-n");
  	  term = make_cond_node (COND_UNARY, op, tleft, (COND_COM *)NULL);
--- 2790,2803 ----
        tok = read_token (READ);
        if (tok == WORD && test_binop (yylval.word->word))
! 	op = yylval.word;
        else if (tok == '<' || tok == '>')
! 	op = make_word_from_token (tok);  /* ( */
!       /* There should be a check before blindly accepting the `)' that we have
! 	 seen the opening `('. */
!       else if (tok == COND_END || tok == AND_AND || tok == OR_OR || tok == ')')
  	{
  	  /* Special case.  [[ x ]] is equivalent to [[ -n x ]], just like
  	     the test command.  Similarly for [[ x && expr ]] or
! 	     [[ x || expr ]] or [[ (x) ]]. */
  	  op = make_word ("-n");
  	  term = make_cond_node (COND_UNARY, op, tleft, (COND_COM *)NULL);
***************
*** 2790,2794 ****
  
    token_index = 0;
!   all_digits = digit (character);
    dollar_present = quoted = pass_next_character = 0;
  
--- 2885,2889 ----
  
    token_index = 0;
!   all_digits = isdigit (character);
    dollar_present = quoted = pass_next_character = 0;
  
***************
*** 2825,2829 ****
  	      /* If the next character is to be quoted, note it now. */
  	      if (cd == 0 || cd == '`' ||
! 		  (cd == '"' && member (peek_char, slashify_in_quotes)))
  		pass_next_character++;
  
--- 2920,2924 ----
  	      /* If the next character is to be quoted, note it now. */
  	      if (cd == 0 || cd == '`' ||
! 		  (cd == '"' && (sh_syntaxtab[peek_char] & CBSDQUOTE)))
  		pass_next_character++;
  
***************
*** 2855,2859 ****
  #ifdef EXTENDED_GLOB
        /* Parse a ksh-style extended pattern matching specification. */
!       if (extended_glob && PATTERN_CHAR(character))
  	{
  	  peek_char = shell_getc (1);
--- 2950,2954 ----
  #ifdef EXTENDED_GLOB
        /* Parse a ksh-style extended pattern matching specification. */
!       if (extended_glob && PATTERN_CHAR (character))
  	{
  	  peek_char = shell_getc (1);
***************
*** 2883,2891 ****
        /* If the delimiter character is not single quote, parse some of
  	 the shell expansions that must be read as a single word. */
! #if defined (PROCESS_SUBSTITUTION)
!       if (character == '$' || character == '<' || character == '>')
! #else
!       if (character == '$')
! #endif /* !PROCESS_SUBSTITUTION */
  	{
  	  peek_char = shell_getc (1);
--- 2978,2982 ----
        /* If the delimiter character is not single quote, parse some of
  	 the shell expansions that must be read as a single word. */
!       if (shellexp (character))
  	{
  	  peek_char = shell_getc (1);
***************
*** 2895,2899 ****
  	    {
  	      if (peek_char == '{')		/* } */
! 	        ttok = parse_matched_pair (cd, '{', '}', &ttoklen, P_FIRSTCLOSE);
  	      else if (peek_char == '(')		/* ) */
  		{
--- 2986,2990 ----
  	    {
  	      if (peek_char == '{')		/* } */
! 		ttok = parse_matched_pair (cd, '{', '}', &ttoklen, P_FIRSTCLOSE);
  	      else if (peek_char == '(')		/* ) */
  		{
***************
*** 2943,2947 ****
  		     embedded single quotes (allowed because P_ALLOWESC was
  		     passed to parse_matched_pair). */
! 		  ttok = single_quote (ttrans);
  		  free (ttrans);
  		  ttrans = ttok;
--- 3034,3038 ----
  		     embedded single quotes (allowed because P_ALLOWESC was
  		     passed to parse_matched_pair). */
! 		  ttok = sh_single_quote (ttrans);
  		  free (ttrans);
  		  ttrans = ttok;
***************
*** 3036,3040 ****
      got_character:
  
!       all_digits &= digit (character);
        dollar_present |= character == '$';
  
--- 3127,3131 ----
      got_character:
  
!       all_digits &= isdigit (character);
        dollar_present |= character == '$';
  
***************
*** 3182,3186 ****
  	len++;
        else if (*s == '\n')
!         len += 5;
      }
    
--- 3273,3277 ----
  	len++;
        else if (*s == '\n')
! 	len += 5;
      }
    
***************
*** 3381,3387 ****
  	 command lists.  It's a suboptimal solution. */
        else if (parser_state & PST_CASESTMT)	/* case statement pattern */
!         return " ";
        else	
!         return "; ";				/* (...) subshell */
      }
    else if (token_before_that == WORD && two_tokens_ago == FUNCTION)
--- 3472,3478 ----
  	 command lists.  It's a suboptimal solution. */
        else if (parser_state & PST_CASESTMT)	/* case statement pattern */
! 	return " ";
        else	
! 	return "; ";				/* (...) subshell */
      }
    else if (token_before_that == WORD && two_tokens_ago == FUNCTION)
***************
*** 3393,3397 ****
  	 `for i\ndo ...' should.  We do what we can. */
        for (i = shell_input_line_index; whitespace(shell_input_line[i]); i++)
!         ;
        if (shell_input_line[i] && shell_input_line[i] == 'i' && shell_input_line[i+1] == 'n')
  	return " ";
--- 3484,3488 ----
  	 `for i\ndo ...' should.  We do what we can. */
        for (i = shell_input_line_index; whitespace(shell_input_line[i]); i++)
! 	;
        if (shell_input_line[i] && shell_input_line[i] == 'i' && shell_input_line[i+1] == 'n')
  	return " ";
***************
*** 3561,3565 ****
  	      if (n == CTLESC || n == CTLNUL)
  		{
- 		  string += 3;
  		  temp[0] = CTLESC;
  		  temp[1] = n;
--- 3652,3655 ----
***************
*** 3573,3581 ****
  	      else
  		{
- 		  string += 3;
  		  temp[0] = n;
  		  temp[1] = '\0';
  		}
  
  	      c = 0;
  	      goto add_string;
--- 3663,3673 ----
  	      else
  		{
  		  temp[0] = n;
  		  temp[1] = '\0';
  		}
  
+ 	      for (c = 0; n != -1 && c < 3 && ISOCTAL (*string); c++)
+ 		string++;
+ 
  	      c = 0;
  	      goto add_string;
***************
*** 3656,3660 ****
  		    if (getcwd (t_string, sizeof(t_string)) == 0)
  		      {
! 		        t_string[0] = '.';
  			tlen = 1;
  		      }
--- 3748,3752 ----
  		    if (getcwd (t_string, sizeof(t_string)) == 0)
  		      {
! 			t_string[0] = '.';
  			tlen = 1;
  		      }
***************
*** 3669,3678 ****
  		t_string[tlen] = '\0';
  
  		if (c == 'W')
  		  {
! 		    t = strrchr (t_string, '/');
! 		    if (t && t != t_string)
! 		      strcpy (t_string, t + 1);
  		  }
  		else
  		  /* polite_directory_format is guaranteed to return a string
--- 3761,3777 ----
  		t_string[tlen] = '\0';
  
+ #define ROOT_PATH(x)	((x)[0] == '/' && (x)[1] == 0)
+ #define DOUBLE_SLASH_ROOT(x)	((x)[0] == '/' && (x)[1] == '/' && (x)[2] == 0)
  		if (c == 'W')
  		  {
! 		    if (ROOT_PATH (t_string) == 0 && DOUBLE_SLASH_ROOT (t_string) == 0)
! 		      {
! 			t = strrchr (t_string, '/');
! 			if (t)
! 			  strcpy (t_string, t + 1);
! 		      }
  		  }
+ #undef ROOT_PATH
+ #undef DOUBLE_SLASH_ROOT
  		else
  		  /* polite_directory_format is guaranteed to return a string
***************
*** 3683,3694 ****
  		   quote the directory name. */
  		if (promptvars || posixly_correct)
- #if 0
- 		  temp = backslash_quote (t_string);
- #else
  		  /* Make sure that expand_prompt_string is called with a
  		     second argument of Q_DOUBLE_QUOTE if we use this
  		     function here. */
! 		  temp = backslash_quote_for_double_quotes (t_string);
! #endif
  		else
  		  temp = savestring (t_string);
--- 3782,3789 ----
  		   quote the directory name. */
  		if (promptvars || posixly_correct)
  		  /* Make sure that expand_prompt_string is called with a
  		     second argument of Q_DOUBLE_QUOTE if we use this
  		     function here. */
! 		  temp = sh_backslash_quote_for_double_quotes (t_string);
  		else
  		  temp = savestring (t_string);
***************
*** 3805,3813 ****
    if (promptvars || posixly_correct)
      {
- #if 0
-       list = expand_string_unsplit (result, Q_DOUBLE_QUOTES);
- #else
        list = expand_prompt_string (result, Q_DOUBLE_QUOTES);
- #endif
        free (result);
        result = string_list (list);
--- 3900,3904 ----
***************
*** 3999,4002 ****
--- 4090,4094 ----
    WORD_LIST *wl;
    int tok, orig_line_number, orig_input_terminator;
+   int orig_line_count;
  #if defined (HISTORY)
    int old_remember_on_history, old_history_expansion_inhibited;
***************
*** 4012,4019 ****
--- 4104,4113 ----
  
    orig_line_number = line_number;
+   orig_line_count = current_command_line_count;
    orig_input_terminator = shell_input_line_terminator;
  
    push_stream (1);
    last_read_token = '\n';
+   current_command_line_count = 0;
  
    with_input_from_string (s, whom);
***************
*** 4023,4026 ****
--- 4117,4122 ----
        if (tok == '\n' && *bash_input.location.string == '\0')
  	break;
+       if (tok == '\n')		/* Allow newlines in compound assignments */
+ 	continue;
        if (tok != WORD && tok != ASSIGNMENT_WORD)
  	{
***************
*** 4045,4048 ****
--- 4141,4145 ----
  #endif /* HISTORY */
  
+   current_command_line_count = orig_line_count;
    shell_input_line_terminator = orig_input_terminator;
  
diff -Nrc2 bash-2.04/parser-built bash-2.05/parser-built
*** bash-2.04/parser-built	Tue Sep 14 16:42:21 1999
--- bash-2.05/parser-built	Tue Oct 10 13:27:09 2000
***************
*** 1,2 ****
--- 1,45 ----
+ #ifndef YYERRCODE
+ #define YYERRCODE 256
+ #endif
+ 
+ #define IF 257
+ #define THEN 258
+ #define ELSE 259
+ #define ELIF 260
+ #define FI 261
+ #define CASE 262
+ #define ESAC 263
+ #define FOR 264
+ #define SELECT 265
+ #define WHILE 266
+ #define UNTIL 267
+ #define DO 268
+ #define DONE 269
+ #define FUNCTION 270
+ #define COND_START 271
+ #define COND_END 272
+ #define COND_ERROR 273
+ #define IN 274
+ #define BANG 275
+ #define TIME 276
+ #define TIMEOPT 277
+ #define WORD 278
+ #define ASSIGNMENT_WORD 279
+ #define NUMBER 280
+ #define ARITH_CMD 281
+ #define ARITH_FOR_EXPRS 282
+ #define COND_CMD 283
+ #define AND_AND 284
+ #define OR_OR 285
+ #define GREATER_GREATER 286
+ #define LESS_LESS 287
+ #define LESS_AND 288
+ #define GREATER_AND 289
+ #define SEMI_SEMI 290
+ #define LESS_LESS_MINUS 291
+ #define AND_GREATER 292
+ #define LESS_GREATER 293
+ #define GREATER_BAR 294
+ #define yacc_EOF 295
  typedef union {
    WORD_DESC *word;		/* the word that we read. */
***************
*** 8,51 ****
    PATTERN_LIST *pattern;
  } YYSTYPE;
- #define	IF	258
- #define	THEN	259
- #define	ELSE	260
- #define	ELIF	261
- #define	FI	262
- #define	CASE	263
- #define	ESAC	264
- #define	FOR	265
- #define	SELECT	266
- #define	WHILE	267
- #define	UNTIL	268
- #define	DO	269
- #define	DONE	270
- #define	FUNCTION	271
- #define	COND_START	272
- #define	COND_END	273
- #define	COND_ERROR	274
- #define	IN	275
- #define	BANG	276
- #define	TIME	277
- #define	TIMEOPT	278
- #define	WORD	279
- #define	ASSIGNMENT_WORD	280
- #define	NUMBER	281
- #define	ARITH_CMD	282
- #define	ARITH_FOR_EXPRS	283
- #define	COND_CMD	284
- #define	AND_AND	285
- #define	OR_OR	286
- #define	GREATER_GREATER	287
- #define	LESS_LESS	288
- #define	LESS_AND	289
- #define	GREATER_AND	290
- #define	SEMI_SEMI	291
- #define	LESS_LESS_MINUS	292
- #define	AND_GREATER	293
- #define	LESS_GREATER	294
- #define	GREATER_BAR	295
- #define	yacc_EOF	296
- 
- 
  extern YYSTYPE yylval;
--- 51,53 ----
diff -Nrc2 bash-2.04/pathexp.c bash-2.05/pathexp.c
*** bash-2.04/pathexp.c	Thu Aug  5 07:24:15 1999
--- bash-2.05/pathexp.c	Wed Feb 14 16:54:26 2001
***************
*** 102,106 ****
  char *
  quote_string_for_globbing (pathname, qflags)
!      char *pathname;
       int qflags;
  {
--- 102,106 ----
  char *
  quote_string_for_globbing (pathname, qflags)
!      const char *pathname;
       int qflags;
  {
***************
*** 119,129 ****
      {
        if (pathname[i] == CTLESC)
!         {
!           if ((qflags & QGLOB_FILENAME) && pathname[i+1] == '/')
!             continue;
  	  temp[j++] = '\\';
!         }
        else
!         temp[j++] = pathname[i];
      }
    temp[j] = '\0';
--- 119,129 ----
      {
        if (pathname[i] == CTLESC)
! 	{
! 	  if ((qflags & QGLOB_FILENAME) && pathname[i+1] == '/')
! 	    continue;
  	  temp[j++] = '\\';
! 	}
        else
! 	temp[j++] = pathname[i];
      }
    temp[j] = '\0';
***************
*** 142,160 ****
      {
        switch (*s)
!         {
!         case '*':
!         case '[':
!         case ']':
!         case '?':
!         case '\\':
!           *t++ = '\\';
!           break;
!         case '+':
!         case '@':
!         case '!':
  	  if (s[1] == '(')	/*(*/
  	    *t++ = '\\';
  	  break;
!         }
        *t++ = *s++;
      }
--- 142,160 ----
      {
        switch (*s)
! 	{
! 	case '*':
! 	case '[':
! 	case ']':
! 	case '?':
! 	case '\\':
! 	  *t++ = '\\';
! 	  break;
! 	case '+':
! 	case '@':
! 	case '!':
  	  if (s[1] == '(')	/*(*/
  	    *t++ = '\\';
  	  break;
! 	}
        *t++ = *s++;
      }
***************
*** 166,174 ****
  char **
  shell_glob_filename (pathname)
!      char *pathname;
  {
  #if defined (USE_POSIX_GLOB_LIBRARY)
    register int i;
!   char *temp, **return_value;
    glob_t filenames;
    int glob_flags;
--- 166,174 ----
  char **
  shell_glob_filename (pathname)
!      const char *pathname;
  {
  #if defined (USE_POSIX_GLOB_LIBRARY)
    register int i;
!   char *temp, **results;
    glob_t filenames;
    int glob_flags;
***************
*** 190,194 ****
    free (temp);
  
!   if (i == GLOB_NOSPACE || i == GLOB_ABEND)
      return ((char **)NULL);
    else if (i == GLOB_NOMATCH)
--- 190,194 ----
    free (temp);
  
!   if (i == GLOB_NOSPACE || i == GLOB_ABORTED)
      return ((char **)NULL);
    else if (i == GLOB_NOMATCH)
***************
*** 293,297 ****
      {
        if (fnmatch (p->val, name, flags) != FNM_NOMATCH)
!         return (0);
      }
    return (1);
--- 293,297 ----
      {
        if (fnmatch (p->val, name, flags) != FNM_NOMATCH)
! 	return (0);
      }
    return (1);
***************
*** 319,323 ****
      {
        if ((*name_func) (names[i]))
!         newnames[n++] = names[i];
        else
  	free (names[i]);
--- 319,323 ----
      {
        if ((*name_func) (names[i]))
! 	newnames[n++] = names[i];
        else
  	free (names[i]);
***************
*** 401,405 ****
        ivp->ignores[numitems].flags = 0;
        if (ivp->item_func)
!         (*ivp->item_func) (&ivp->ignores[numitems]);
        numitems++;
      }
--- 401,405 ----
        ivp->ignores[numitems].flags = 0;
        if (ivp->item_func)
! 	(*ivp->item_func) (&ivp->ignores[numitems]);
        numitems++;
      }
diff -Nrc2 bash-2.04/pathexp.h bash-2.05/pathexp.h
*** bash-2.04/pathexp.h	Thu Aug  5 07:11:16 1999
--- bash-2.05/pathexp.h	Mon Oct 30 15:33:30 2000
***************
*** 57,66 ****
     QGLOB_CVTNULL.  If flags includes QGLOB_FILENAME, appropriate quoting
     to match a filename should be performed. */
! extern char *quote_string_for_globbing __P((char *, int));
  
  extern char *quote_globbing_chars __P((char *));
  
  /* Call the glob library to do globbing on PATHNAME. */
! extern char **shell_glob_filename __P((char *));
  
  /* Filename completion ignore.  Used to the "fignore" facility of
--- 57,66 ----
     QGLOB_CVTNULL.  If flags includes QGLOB_FILENAME, appropriate quoting
     to match a filename should be performed. */
! extern char *quote_string_for_globbing __P((const char *, int));
  
  extern char *quote_globbing_chars __P((char *));
  
  /* Call the glob library to do globbing on PATHNAME. */
! extern char **shell_glob_filename __P((const char *));
  
  /* Filename completion ignore.  Used to the "fignore" facility of
diff -Nrc2 bash-2.04/pcomplete.c bash-2.05/pcomplete.c
*** bash-2.04/pcomplete.c	Wed Mar 15 11:20:08 2000
--- bash-2.05/pcomplete.c	Wed Feb 14 16:59:55 2001
***************
*** 79,83 ****
  #endif
  
- extern int rl_filename_completion_desired;
  extern int array_needs_making;
  extern STRING_INT_ALIST word_token_alist[];
--- 79,82 ----
***************
*** 210,339 ****
  }
  
- /* Functions to manage the string lists -- lists of matches.  These should
-    really be moved to a separate file. */
- 
- /* Allocate a new STRINGLIST, with room for N strings. */
- STRINGLIST *
- alloc_stringlist (n)
-      int n;
- {
-   STRINGLIST *ret;
-   register int i;
- 
-   ret = (STRINGLIST *)xmalloc (sizeof (STRINGLIST));
-   if (n)
-     {
-       ret->list = alloc_array (n+1);
-       ret->list_size = n;
-       for (i = 0; i < n; i++)
- 	ret->list[i] = (char *)NULL;
-     }
-   else
-     {
-       ret->list = (char **)NULL;
-       ret->list_size = 0;
-     }
-   ret->list_len = 0;
-   return ret;
- }
- 
- STRINGLIST *
- realloc_stringlist (sl, n)
-      STRINGLIST *sl;
-      int n;
- {
-   register int i;
- 
-   if (n > sl->list_size)
-     {
-       sl->list = (char **)xrealloc (sl->list, (n+1) * sizeof (char *));
-       for (i = sl->list_size; i <= n; i++)
- 	sl->list[i] = (char *)NULL;
-       sl->list_size = n;
-     }
-   return sl;
- }
-   
- void
- free_stringlist (sl)
-      STRINGLIST *sl;
- {
-   if (sl == 0)
-     return;
-   if (sl->list)
-     free_array (sl->list);
-   free (sl);
- }
- 
- STRINGLIST *
- copy_stringlist (sl)
-      STRINGLIST *sl;
- {
-   STRINGLIST *new;
-   register int i;
- 
-   new = alloc_stringlist (sl->list_size);
-   /* I'd like to use copy_array, but that doesn't copy everything. */
-   if (sl->list)
-     {
-       for (i = 0; i < sl->list_size; i++)
- 	new->list[i] = STRDUP (sl->list[i]);
-     }
-   new->list_size = sl->list_size;
-   new->list_len = sl->list_len;
-   /* just being careful */
-   if (new->list)
-     new->list[new->list_len] = (char *)NULL;
-   return new;
- }
- 
- /* Return a new STRINGLIST with everything from M1 and M2. */
- 
- STRINGLIST *
- merge_stringlists (m1, m2)
-      STRINGLIST *m1, *m2;
- {
-   STRINGLIST *sl;
-   int i, n, l1, l2;
- 
-   l1 = m1 ? m1->list_len : 0;
-   l2 = m2 ? m2->list_len : 0;
- 
-   sl = alloc_stringlist (l1 + l2 + 1);
-   for (i = n = 0; i < l1; i++, n++)
-     sl->list[n] = STRDUP (m1->list[i]);
-   for (i = 0; i < l2; i++, n++)
-     sl->list[n] = STRDUP (m2->list[i]);
-   sl->list_len = n;
-   sl->list[n] = (char *)NULL;
- }
- 
- /* Make STRINGLIST M1 contain everything in M1 and M2. */
- STRINGLIST *
- append_stringlist (m1, m2)
-      STRINGLIST *m1, *m2;
- {
-   register int i, n, len1, len2;
- 
-   if (m1 == 0)
-     {
-       m1 = copy_stringlist (m2);
-       return m1;
-     }
- 
-   len1 = m1->list_len;
-   len2 = m2 ? m2->list_len : 0;
- 
-   if (len2)
-     {
-       m1 = realloc_stringlist (m1, len1 + len2 + 1);
-       for (i = 0, n = len1; i < len2; i++, n++)
- 	m1->list[n] = STRDUP (m2->list[i]);
-       m1->list[n] = (char *)NULL;
-       m1->list_len = n;
-     }
- 
-   return m1;
- }
  
  static int
--- 209,212 ----
***************
*** 406,458 ****
  }
  
! STRINGLIST *
! prefix_suffix_stringlist (sl, prefix, suffix)
!      STRINGLIST *sl;
!      char *prefix, *suffix;
! {
!   int plen, slen, tlen, llen, i;
!   char *t;
! 
!   if (sl == 0 || sl->list == 0 || sl->list_len == 0)
!     return sl;
! 
!   plen = STRLEN (prefix);
!   slen = STRLEN (suffix);
! 
!   if (plen == 0 && slen == 0)
!     return (sl);
! 
!   for (i = 0; i < sl->list_len; i++)
!     {
!       llen = STRLEN (sl->list[i]);
!       tlen = plen + llen + slen + 1;
!       t = xmalloc (tlen + 1);
!       if (plen)
! 	strcpy (t, prefix);
!       strcpy (t + plen, sl->list[i]);
!       if (slen)
! 	strcpy (t + plen + llen, suffix);
!       free (sl->list[i]);
!       sl->list[i] = t;
!     }
! 
!   return (sl);	 
! }
!    
! void
! print_stringlist (sl, prefix)
!      STRINGLIST *sl;
!      char *prefix;
! {
!   register int i;
! 
!   if (sl == 0)
!     return;
!   for (i = 0; i < sl->list_len; i++)
!     printf ("%s%s\n", prefix ? prefix : "", sl->list[i]);
! }
! 
! /* Turn an array of strings returned by completion_matches into a STRINGLIST.
!    This understands how completion_matches sets matches[0] (the lcd of the
     strings in the list, unless it's the only match). */
  STRINGLIST *
--- 279,284 ----
  }
  
! /* Turn an array of strings returned by rl_completion_matches into a STRINGLIST.
!    This understands how rl_completion_matches sets matches[0] (the lcd of the
     strings in the list, unless it's the only match). */
  STRINGLIST *
***************
*** 555,559 ****
  
    /* rl_funmap_names allocates blist, but not its members */
!   blist = rl_funmap_names ();
    sl = alloc_stringlist (0);
    sl->list = blist;
--- 381,385 ----
  
    /* rl_funmap_names allocates blist, but not its members */
!   blist = (char **)rl_funmap_names ();
    sl = alloc_stringlist (0);
    sl->list = blist;
***************
*** 684,688 ****
  	  if (t)
  	    *t = '\0';
! 	sl->list[sl->list_len++] = s;
  	}
      }
--- 510,514 ----
  	  if (t)
  	    *t = '\0';
! 	  sl->list[sl->list_len++] = s;
  	}
      }
***************
*** 790,794 ****
  gen_matches_from_itemlist (itp, text)
       ITEMLIST *itp;
!      char *text;
  {
    STRINGLIST *ret, *sl;
--- 616,620 ----
  gen_matches_from_itemlist (itp, text)
       ITEMLIST *itp;
!      const char *text;
  {
    STRINGLIST *ret, *sl;
***************
*** 815,823 ****
  }
  
! /* A wrapper for filename_completion_function that dequotes the filename
     before attempting completions. */
  static char *
  pcomp_filename_completion_function (text, state)
!      char *text;
       int state;
  {
--- 641,649 ----
  }
  
! /* A wrapper for rl_filename_completion_function that dequotes the filename
     before attempting completions. */
  static char *
  pcomp_filename_completion_function (text, state)
!      const char *text;
       int state;
  {
***************
*** 832,836 ****
  	{
  	  qc = (text[0] == '"' || text[0] == '\'') ? text[0] : 0;
! 	  dfn = (*rl_filename_dequoting_function) (text, qc);
  	}
        else
--- 658,662 ----
  	{
  	  qc = (text[0] == '"' || text[0] == '\'') ? text[0] : 0;
! 	  dfn = (*rl_filename_dequoting_function) ((char *)text, qc);
  	}
        else
***************
*** 838,842 ****
      }
  
!   return (filename_completion_function (dfn, state));
  }
  
--- 664,668 ----
      }
  
!   return (rl_filename_completion_function (dfn, state));
  }
  
***************
*** 855,859 ****
      if (bmap & flag) \
        { \
! 	cmatches = completion_matches (text, func); \
  	tlist = completions_to_stringlist (cmatches); \
  	glist = append_stringlist (glist, tlist); \
--- 681,685 ----
      if (bmap & flag) \
        { \
! 	cmatches = rl_completion_matches (text, func); \
  	tlist = completions_to_stringlist (cmatches); \
  	glist = append_stringlist (glist, tlist); \
***************
*** 868,875 ****
  gen_action_completions (cs, text)
       COMPSPEC *cs;
!      char *text;
  {
    STRINGLIST *ret, *tmatches;
!   char **cmatches;	/* from completion_matches ... */
    unsigned long flags;
  
--- 694,701 ----
  gen_action_completions (cs, text)
       COMPSPEC *cs;
!      const char *text;
  {
    STRINGLIST *ret, *tmatches;
!   char **cmatches;	/* from rl_completion_matches ... */
    unsigned long flags;
  
***************
*** 897,901 ****
    GEN_XCOMPS(flags, CA_COMMAND, text, command_word_completion_function, cmatches, ret, tmatches);
    GEN_XCOMPS(flags, CA_FILE, text, pcomp_filename_completion_function, cmatches, ret, tmatches);
!   GEN_XCOMPS(flags, CA_USER, text, username_completion_function, cmatches, ret, tmatches);
  
    /* And lastly, the special case for directories */
--- 723,727 ----
    GEN_XCOMPS(flags, CA_COMMAND, text, command_word_completion_function, cmatches, ret, tmatches);
    GEN_XCOMPS(flags, CA_FILE, text, pcomp_filename_completion_function, cmatches, ret, tmatches);
!   GEN_XCOMPS(flags, CA_USER, text, rl_username_completion_function, cmatches, ret, tmatches);
  
    /* And lastly, the special case for directories */
***************
*** 920,924 ****
  gen_globpat_matches (cs, text)
        COMPSPEC *cs;
!       char *text;
  {
    STRINGLIST *sl;
--- 746,750 ----
  gen_globpat_matches (cs, text)
        COMPSPEC *cs;
!       const char *text;
  {
    STRINGLIST *sl;
***************
*** 939,943 ****
  gen_wordlist_matches (cs, text)
       COMPSPEC *cs;
!      char *text;
  {
    WORD_LIST *l, *l2;
--- 765,769 ----
  gen_wordlist_matches (cs, text)
       COMPSPEC *cs;
!      const char *text;
  {
    WORD_LIST *l, *l2;
***************
*** 966,970 ****
      {
        if (tlen == 0 || STREQN (l->word->word, text, tlen))
!         sl->list[nw++] = STRDUP (l->word->word);
      }
    sl->list[sl->list_len = nw] = (char *)NULL;
--- 792,796 ----
      {
        if (tlen == 0 || STREQN (l->word->word, text, tlen))
! 	sl->list[nw++] = STRDUP (l->word->word);
      }
    sl->list[sl->list_len = nw] = (char *)NULL;
***************
*** 1118,1123 ****
    if (f == 0)
      {
!       fprintf (stderr, "gen_shell_function_matches: function `%s' not found\n", funcname);
!       ding ();
        rl_on_new_line ();
        return ((STRINGLIST *)NULL);
--- 944,949 ----
    if (f == 0)
      {
!       internal_error ("completion: function `%s' not found", funcname);
!       rl_ding ();
        rl_on_new_line ();
        return ((STRINGLIST *)NULL);
***************
*** 1206,1210 ****
    for (cl = cmdlist->next; cl; cl = cl->next)   /* $1, $2, $3, ... */
      {
!       t = single_quote (cl->word->word ? cl->word->word : "");
        n = strlen (t);
        RESIZE_MALLOCED_BUFFER (cscmd, cmdlen, n + 2, cmdsize, 64);
--- 1032,1036 ----
    for (cl = cmdlist->next; cl; cl = cl->next)   /* $1, $2, $3, ... */
      {
!       t = sh_single_quote (cl->word->word ? cl->word->word : "");
        n = strlen (t);
        RESIZE_MALLOCED_BUFFER (cscmd, cmdlen, n + 2, cmdsize, 64);
***************
*** 1273,1278 ****
  gen_compspec_completions (cs, cmd, word, start, end)
       COMPSPEC *cs;
!      char *cmd;
!      char *word;
       int start, end;
  {
--- 1099,1104 ----
  gen_compspec_completions (cs, cmd, word, start, end)
       COMPSPEC *cs;
!      const char *cmd;
!      const char *word;
       int start, end;
  {
***************
*** 1411,1414 ****
--- 1237,1254 ----
      ret = prefix_suffix_stringlist (ret, cs->prefix, cs->suffix);
  
+   /* If no matches have been generated and the user has specified that
+       directory completion should be done as a default, call
+       gen_action_completions again to generate a list of matching directory
+       names. */
+   if ((ret == 0 || ret->list_len == 0) && (cs->options & COPT_DIRNAMES))
+     {
+       COMPSPEC *dummy;
+ 
+       dummy = alloc_compspec ();
+       dummy->actions = CA_DIRECTORY;
+       ret = gen_action_completions (dummy, word);
+       free_compspec (dummy);
+     }
+ 
    return (ret);
  }
***************
*** 1419,1423 ****
  char **
  programmable_completions (cmd, word, start, end, foundp)
!      char *cmd, *word;
       int start, end, *foundp;
  {
--- 1259,1264 ----
  char **
  programmable_completions (cmd, word, start, end, foundp)
!      const char *cmd;
!      const char *word;
       int start, end, *foundp;
  {
***************
*** 1442,1448 ****
      }
  
!   /* Signal the caller that we found a COMPSPEC for this command. */
    if (foundp)
!     *foundp = 1;
  
    ret = gen_compspec_completions (cs, cmd, word, start, end);
--- 1283,1290 ----
      }
  
!   /* Signal the caller that we found a COMPSPEC for this command, and pass
!      back any meta-options associated with the compspec. */
    if (foundp)
!     *foundp = 1|cs->options;
  
    ret = gen_compspec_completions (cs, cmd, word, start, end);
diff -Nrc2 bash-2.04/pcomplete.h bash-2.05/pcomplete.h
*** bash-2.04/pcomplete.h	Thu Aug  5 07:11:49 1999
--- bash-2.05/pcomplete.h	Mon Nov 27 12:33:05 2000
***************
*** 29,32 ****
--- 29,33 ----
    int refcount;
    unsigned long actions;
+   unsigned long options;
    char *globpat;
    char *words;
***************
*** 63,73 ****
  #define CA_VARIABLE	(1<<21)
  
! /* This is a general-purpose argv-style array struct that should be used
!    elsewhere. */
! typedef struct _list_of_strings {
!   char **list;
!   int list_size;
!   int list_len;
! } STRINGLIST;
  
  /* List of items is used by the code that implements the programmable
--- 64,72 ----
  #define CA_VARIABLE	(1<<21)
  
! /* Values for COMPSPEC options field. */
! #define COPT_RESERVED	(1<<0)		/* reserved for other use */
! #define COPT_DEFAULT	(1<<1)
! #define COPT_FILENAMES	(1<<2)
! #define COPT_DIRNAMES	(1<<3)
  
  /* List of items is used by the code that implements the programmable
***************
*** 134,138 ****
  extern int num_progcomps __P((void));
  
! extern COMPSPEC *find_compspec __P((char *));
  
  extern void print_all_compspecs __P((VFunction *));
--- 133,137 ----
  extern int num_progcomps __P((void));
  
! extern COMPSPEC *find_compspec __P((const char *));
  
  extern void print_all_compspecs __P((VFunction *));
***************
*** 141,146 ****
  extern void set_itemlist_dirty __P((ITEMLIST *));
  
! extern STRINGLIST *gen_compspec_completions __P((COMPSPEC *, char *, char *, int, int));
! extern char **programmable_completions __P((char *, char *, int, int, int *));
  
  #endif /* _PCOMPLETE_H_ */
--- 140,145 ----
  extern void set_itemlist_dirty __P((ITEMLIST *));
  
! extern STRINGLIST *gen_compspec_completions __P((COMPSPEC *, const char *, const char *, int, int));
! extern char **programmable_completions __P((const char *, const char *, int, int, int *));
  
  #endif /* _PCOMPLETE_H_ */
diff -Nrc2 bash-2.04/pcomplib.c bash-2.05/pcomplib.c
*** bash-2.04/pcomplib.c	Thu Aug  5 07:11:58 1999
--- bash-2.05/pcomplib.c	Mon Nov 27 12:32:47 2000
***************
*** 53,56 ****
--- 53,57 ----
  
    ret->actions = (unsigned long)0;
+   ret->options = (unsigned long)0;
  
    ret->globpat = (char *)NULL;
***************
*** 94,97 ****
--- 95,99 ----
    new->refcount = cs->refcount;
    new->actions = cs->actions;
+   new->options = cs->options;
  
    new->globpat = STRDUP (cs->globpat);
***************
*** 186,190 ****
  COMPSPEC *
  find_compspec (cmd)
!      char *cmd;
  {
    register BUCKET_CONTENTS *item;
--- 188,192 ----
  COMPSPEC *
  find_compspec (cmd)
!      const char *cmd;
  {
    register BUCKET_CONTENTS *item;
***************
*** 194,198 ****
      return ((COMPSPEC *)NULL);
  
!   item = find_hash_item (cmd, prog_completes);
  
    if (item == NULL)
--- 196,200 ----
      return ((COMPSPEC *)NULL);
  
!   item = find_hash_item ((char *)cmd, prog_completes);	/* XXX fix const later */
  
    if (item == NULL)
diff -Nrc2 bash-2.04/print_cmd.c bash-2.05/print_cmd.c
*** bash-2.04/print_cmd.c	Tue Dec 14 13:41:29 1999
--- bash-2.05/print_cmd.c	Tue Apr  3 15:05:26 2001
***************
*** 321,327 ****
        if (t == 0 || *t == '\0')
  	fprintf (stderr, "''%s", w->next ? " " : "");
!       else if (contains_shell_metas (t))
  	{
! 	  x = single_quote (t);
  	  fprintf (stderr, "%s%s", x, w->next ? " " : "");
  	  free (x);
--- 321,327 ----
        if (t == 0 || *t == '\0')
  	fprintf (stderr, "''%s", w->next ? " " : "");
!       else if (sh_contains_shell_metas (t))
  	{
! 	  x = sh_single_quote (t);
  	  fprintf (stderr, "%s%s", x, w->next ? " " : "");
  	  free (x);
***************
*** 582,585 ****
--- 582,586 ----
  }
  
+ #ifdef DEBUG
  void
  debug_print_cond_command (cond)
***************
*** 591,594 ****
--- 592,596 ----
    fprintf (stderr, "%s\n", the_printed_command);
  }
+ #endif
  
  void
***************
*** 689,696 ****
        cprintf (" "); 
        for (hdtail = heredocs; hdtail; hdtail = hdtail->next)
!         {
  	  print_redirection (hdtail);
  	  cprintf ("\n");
!         }
        dispose_redirects (heredocs);
        was_heredoc = 1;
--- 691,698 ----
        cprintf (" "); 
        for (hdtail = heredocs; hdtail; hdtail = hdtail->next)
! 	{
  	  print_redirection (hdtail);
  	  cprintf ("\n");
! 	}
        dispose_redirects (heredocs);
        was_heredoc = 1;
***************
*** 742,751 ****
        /* If the here document delimiter is quoted, single-quote it. */
        if (redirect->redirectee.filename->flags & W_QUOTED)
!         {
!           char *x;
!           x = single_quote (redirect->here_doc_eof);
  	  cprintf ("<<%s%s\n", kill_leading? "-" : "", x);
!           free (x);
!         }
        else
  	cprintf ("<<%s%s\n", kill_leading? "-" : "", redirect->here_doc_eof);
--- 744,753 ----
        /* If the here document delimiter is quoted, single-quote it. */
        if (redirect->redirectee.filename->flags & W_QUOTED)
! 	{
! 	  char *x;
! 	  x = sh_single_quote (redirect->here_doc_eof);
  	  cprintf ("<<%s%s\n", kill_leading? "-" : "", x);
! 	  free (x);
! 	}
        else
  	cprintf ("<<%s%s\n", kill_leading? "-" : "", redirect->here_doc_eof);
***************
*** 815,824 ****
    indentation += indentation_amount;
  
-   func_redirects = (REDIRECT *)NULL;
    cmdcopy = copy_command (func->command);
    if (cmdcopy->type == cm_group)
      {
!       func_redirects = cmdcopy->value.Group->command->redirects;
!       cmdcopy->value.Group->command->redirects = (REDIRECT *)NULL;
      }
    make_command_string_internal (cmdcopy->type == cm_group
--- 817,825 ----
    indentation += indentation_amount;
  
    cmdcopy = copy_command (func->command);
    if (cmdcopy->type == cm_group)
      {
!       func_redirects = cmdcopy->redirects;
!       cmdcopy->redirects = (REDIRECT *)NULL;
      }
    make_command_string_internal (cmdcopy->type == cm_group
***************
*** 834,838 ****
        newline ("} ");
        print_redirection_list (func_redirects);
!       cmdcopy->value.Group->command->redirects = func_redirects;
      }
    else
--- 835,839 ----
        newline ("} ");
        print_redirection_list (func_redirects);
!       cmdcopy->redirects = func_redirects;
      }
    else
***************
*** 888,893 ****
    if (cmdcopy->type == cm_group)
      {
!       func_redirects = cmdcopy->value.Group->command->redirects;
!       cmdcopy->value.Group->command->redirects = (REDIRECT *)NULL;
      }
    make_command_string_internal (cmdcopy->type == cm_group
--- 889,894 ----
    if (cmdcopy->type == cm_group)
      {
!       func_redirects = cmdcopy->redirects;
!       cmdcopy->redirects = (REDIRECT *)NULL;
      }
    make_command_string_internal (cmdcopy->type == cm_group
***************
*** 903,907 ****
        newline ("} ");
        print_redirection_list (func_redirects);
!       cmdcopy->value.Group->command->redirects = func_redirects;
      }
    else
--- 904,908 ----
        newline ("} ");
        print_redirection_list (func_redirects);
!       cmdcopy->redirects = func_redirects;
      }
    else
***************
*** 922,926 ****
  #else
        if (result[2] == '\n')	/* XXX -- experimental */
!         strcpy (result + 2, result + 3);
  #endif
      }
--- 923,927 ----
  #else
        if (result[2] == '\n')	/* XXX -- experimental */
! 	strcpy (result + 2, result + 3);
  #endif
      }
diff -Nrc2 bash-2.04/redir.c bash-2.05/redir.c
*** bash-2.04/redir.c	Fri Dec 31 11:59:02 1999
--- bash-2.05/redir.c	Tue Mar 27 09:43:50 2001
***************
*** 92,96 ****
        filename = redirection_expand (temp->redirectee.filename);
        if (posixly_correct && interactive_shell == 0)
!         temp->redirectee.filename->flags = oflags;
        if (filename == 0)
  	filename = savestring (temp->redirectee.filename->word);
--- 92,96 ----
        filename = redirection_expand (temp->redirectee.filename);
        if (posixly_correct && interactive_shell == 0)
! 	temp->redirectee.filename->flags = oflags;
        if (filename == 0)
  	filename = savestring (temp->redirectee.filename->word);
***************
*** 253,257 ****
  	}
        else
!         return 0;
      }
  
--- 253,257 ----
  	}
        else
! 	return 0;
      }
  
***************
*** 303,323 ****
       WORD_DESC *redirectee;
  {
!   char filename[24];
    int r, fd, fd2;
    static int fnum = 0;
  
!   do
!     {
!       /* Make the filename for the temp file. */
!       sprintf (filename, "/tmp/t%d-%d-sh", (int)getpid (), fnum++);
! 
!       /* Make sure we open it exclusively. */
!       fd = open (filename, O_TRUNC | O_WRONLY | O_CREAT | O_EXCL, 0600);
!     }
!   while (fd < 0 && errno == EEXIST);
  
    /* If we failed for some reason other than the file existing, abort */
    if (fd < 0)
!     return (fd);
  
    errno = r = 0;		/* XXX */
--- 303,318 ----
       WORD_DESC *redirectee;
  {
!   char *filename;
    int r, fd, fd2;
    static int fnum = 0;
  
!   fd = sh_mktmpfd ("sh-thd", MT_USERANDOM, &filename);
  
    /* If we failed for some reason other than the file existing, abort */
    if (fd < 0)
!     {
!       FREE (filename);
!       return (fd);
!     }
  
    errno = r = 0;		/* XXX */
***************
*** 330,333 ****
--- 325,329 ----
        close (fd);
        unlink (filename);
+       free (filename);
        errno = r;
        return (-1);
***************
*** 343,346 ****
--- 339,343 ----
        r = errno;
        unlink (filename);
+       free (filename);
        close (fd);
        errno = r;
***************
*** 352,360 ****
--- 349,367 ----
      {
        r = errno;
+ #if defined (__CYGWIN__)
+       /* Under CygWin 1.1.0, the unlink will fail if the file is
+ 	 open. This hack will allow the previous action of silently
+ 	 ignoring the error, but will still leave the file there. This
+ 	 needs some kind of magic. */
+       if (r == EACCES)
+ 	return (fd2);
+ #endif /* __CYGWIN__ */
        close (fd2);
+       free (filename);
        errno = r;
        return (-1);
      }
  
+   free (filename);
    return (fd2);
  }
***************
*** 504,508 ****
    /* If we are in noclobber mode, you are not allowed to overwrite
       existing files.  Check before opening. */
!   if (noclobber && OUTPUT_REDIRECT (ri))
      {
        fd = noclobber_open (filename, flags, mode, ri);
--- 511,515 ----
    /* If we are in noclobber mode, you are not allowed to overwrite
       existing files.  Check before opening. */
!   if (noclobber && CLOBBERING_REDIRECT (ri))
      {
        fd = noclobber_open (filename, flags, mode, ri);
***************
*** 572,582 ****
        else if (ri == r_duplicating_output_word && redirector == 1)
  	{
! 	  if (posixly_correct == 0)
! 	    {
! 	      rd.filename = make_bare_word (redirectee_word);
! 	      new_redirect = make_redirection (1, r_err_and_out, rd);
! 	    }
! 	  else
! 	    new_redirect = copy_redirect (redirect);
  	}
        else
--- 579,584 ----
        else if (ri == r_duplicating_output_word && redirector == 1)
  	{
! 	  rd.filename = make_bare_word (redirectee_word);
! 	  new_redirect = make_redirection (1, r_err_and_out, rd);
  	}
        else
***************
*** 628,635 ****
      case r_output_force:
        if (posixly_correct && interactive_shell == 0)
!         {
!           oflags = redirectee->flags;
!           redirectee->flags |= W_NOGLOB;
!         }
        redirectee_word = redirection_expand (redirectee);
        if (posixly_correct && interactive_shell == 0)
--- 630,637 ----
      case r_output_force:
        if (posixly_correct && interactive_shell == 0)
! 	{
! 	  oflags = redirectee->flags;
! 	  redirectee->flags |= W_NOGLOB;
! 	}
        redirectee_word = redirection_expand (redirectee);
        if (posixly_correct && interactive_shell == 0)
***************
*** 651,655 ****
  
        if (fd == NOCLOBBER_REDIRECT)
!         return (fd);
  
        if (fd < 0)
--- 653,657 ----
  
        if (fd == NOCLOBBER_REDIRECT)
! 	return (fd);
  
        if (fd < 0)
***************
*** 782,786 ****
  	  check_bash_input (redirector);
  #endif
- 
  	  /* This is correct.  2>&1 means dup2 (1, 2); */
  	  if (dup2 (redir_fd, redirector) < 0)
--- 784,787 ----
***************
*** 845,849 ****
    if (new_fd < 0)
      {
!       sys_error ("redirection error");
        return (-1);
      }
--- 846,850 ----
    if (new_fd < 0)
      {
!       sys_error ("redirection error: cannot duplicate fd");
        return (-1);
      }
***************
*** 856,860 ****
  
    rd.dest = (long)new_fd;
!   new_redirect = make_redirection (fd, r_duplicating_output, rd);
    new_redirect->next = closer;
  
--- 857,864 ----
  
    rd.dest = (long)new_fd;
!   if (fd == 0)
!     new_redirect = make_redirection (fd, r_duplicating_input, rd);
!   else
!     new_redirect = make_redirection (fd, r_duplicating_output, rd);
    new_redirect->next = closer;
  
diff -Nrc2 bash-2.04/shell.c bash-2.05/shell.c
*** bash-2.04/shell.c	Fri Nov 19 14:58:15 1999
--- bash-2.05/shell.c	Tue Mar 27 09:25:51 2001
***************
*** 203,206 ****
--- 203,207 ----
    { "dump-strings", Int, &dump_translatable_strings, (char **)0x0 },
    { "help", Int, &want_initial_help, (char **)0x0 },
+   { "init-file", Charp, (int *)0x0, &bashrc_file },
    { "login", Int, &make_login_shell, (char **)0x0 },
    { "noediting", Int, &no_line_editing, (char **)0x0 },
***************
*** 236,239 ****
--- 237,241 ----
  int want_pending_command;	/* -c flag supplied */
  
+ static int shell_reinitialized = 0;
  static char *local_pending_command;
  
***************
*** 259,263 ****
  static void show_shell_usage ();
  
! #ifdef __CYGWIN32__
  static void
  _cygwin32_check_tmp ()
--- 261,265 ----
  static void show_shell_usage ();
  
! #ifdef __CYGWIN__
  static void
  _cygwin32_check_tmp ()
***************
*** 273,277 ****
      }
  }
! #endif /* __CYGWIN32__ */
  
  #if defined (NO_MAIN_ENV_ARG)
--- 275,279 ----
      }
  }
! #endif /* __CYGWIN__ */
  
  #if defined (NO_MAIN_ENV_ARG)
***************
*** 305,311 ****
    check_dev_tty ();
  
! #ifdef __CYGWIN32__
    _cygwin32_check_tmp ();
! #endif
  
    /* Wait forever if we are debugging a login shell. */
--- 307,313 ----
    check_dev_tty ();
  
! #ifdef __CYGWIN__
    _cygwin32_check_tmp ();
! #endif /* __CYGWIN__ */
  
    /* Wait forever if we are debugging a login shell. */
***************
*** 316,321 ****
    running_setuid = uidget ();
  
!   posixly_correct = (getenv ("POSIXLY_CORRECT") != (char *)NULL) ||
! 		    (getenv ("POSIX_PEDANTIC") != (char *)NULL);
  
  #if defined (USE_GNU_MALLOC_LIBRARY)
--- 318,323 ----
    running_setuid = uidget ();
  
!   if (getenv ("POSIXLY_CORRECT") || getenv ("POSIX_PEDANTIC"))
!     posixly_correct = 1;
  
  #if defined (USE_GNU_MALLOC_LIBRARY)
***************
*** 331,334 ****
--- 333,338 ----
      }
  
+   shell_reinitialized = 0;
+ 
    /* Initialize `local' variables for all `invocations' of main (). */
    arg_index = 1;
***************
*** 453,461 ****
    if (posixly_correct)
      {
!       posix_initialize (posixly_correct);
! #if defined (READLINE)
!       if (interactive_shell)
! 	posix_readline_initialize (posixly_correct);
! #endif
      }
  
--- 457,462 ----
    if (posixly_correct)
      {
!       bind_variable ("POSIXLY_CORRECT", "y");
!       sv_strict_posix ("POSIXLY_CORRECT");
      }
  
***************
*** 509,513 ****
        makunbound ("PS1", shell_variables);
        makunbound ("PS2", shell_variables);
!       interactive = expand_aliases = 0;
      }
    else
--- 510,515 ----
        makunbound ("PS1", shell_variables);
        makunbound ("PS2", shell_variables);
!       interactive = 0;
!       expand_aliases = posixly_correct;
      }
    else
***************
*** 536,540 ****
  
        run_startup_files ();
- 
        exit_immediately_on_error += old_errexit_flag;
      }
--- 538,541 ----
***************
*** 543,551 ****
    if (act_like_sh)
      {
!       posix_initialize (posixly_correct = 1);
! #if defined (READLINE)
!       if (interactive_shell)
!         posix_readline_initialize (posixly_correct);
! #endif
      }
  
--- 544,549 ----
    if (act_like_sh)
      {
!       bind_variable ("POSIXLY_CORRECT", "y");
!       sv_strict_posix ("POSIXLY_CORRECT");
      }
  
***************
*** 555,559 ****
       turn on the restrictions after the startup files are executed. */
    restricted = saverst || restricted;
!   maybe_make_restricted (shell_name);
  #endif /* RESTRICTED_SHELL */
  
--- 553,558 ----
       turn on the restrictions after the startup files are executed. */
    restricted = saverst || restricted;
!   if (shell_reinitialized == 0)
!     maybe_make_restricted (shell_name);
  #endif /* RESTRICTED_SHELL */
  
***************
*** 568,572 ****
      {
        arg_index = bind_args (argv, arg_index, argc, 0);
- 
        startup_state = 2;
  #if defined (ONESHOT)
--- 567,570 ----
***************
*** 599,603 ****
    /* Bind remaining args to $1 ... $n */
    arg_index = bind_args (argv, arg_index, argc, 1);
- 
    /* Do the things that should be done only for interactive shells. */
    if (interactive_shell)
--- 597,600 ----
***************
*** 783,788 ****
  
    /* If this shell is interactive, terminate all stopped jobs and
!      restore the original terminal process group. */
!   end_job_control ();
  #endif /* JOB_CONTROL */
  
--- 780,788 ----
  
    /* If this shell is interactive, terminate all stopped jobs and
!      restore the original terminal process group.  Don't do this if we're
!      in a subshell and calling exit_shell after, for example, a failed
!      word expansion. */
!   if (subshell_environment == 0)
!     end_job_control ();
  #endif /* JOB_CONTROL */
  
***************
*** 815,828 ****
     then:
  
!          COMMAND	    EXECUTE BASHRC
!          --------------------------------
!          bash -c foo		NO
!          bash foo		NO
!          foo			NO
!          rsh machine ls		YES (for rsh, which calls `bash -c')
!          rsh machine foo	YES (for shell started by rsh) NO (for foo!)
!          echo ls | bash		NO
!          login			NO
!          bash			YES
  */
  
--- 815,828 ----
     then:
  
! 	 COMMAND	    EXECUTE BASHRC
! 	 --------------------------------
! 	 bash -c foo		NO
! 	 bash foo		NO
! 	 foo			NO
! 	 rsh machine ls		YES (for rsh, which calls `bash -c')
! 	 rsh machine foo	YES (for shell started by rsh) NO (for foo!)
! 	 echo ls | bash		NO
! 	 login			NO
! 	 bash			YES
  */
  
***************
*** 960,968 ****
  #  endif
  #endif
!           maybe_execute_file (bashrc_file, 1);
  	}
        /* sh */
        else if (act_like_sh && privileged_mode == 0 && sourced_env++ == 0)
!         execute_env_file (get_string_value ("ENV"));
      }
    else		/* bash --posix, sh --posix */
--- 960,968 ----
  #  endif
  #endif
! 	  maybe_execute_file (bashrc_file, 1);
  	}
        /* sh */
        else if (act_like_sh && privileged_mode == 0 && sourced_env++ == 0)
! 	execute_env_file (get_string_value ("ENV"));
      }
    else		/* bash --posix, sh --posix */
***************
*** 970,974 ****
        /* bash and sh */
        if (interactive_shell && privileged_mode == 0 && sourced_env++ == 0)
!         execute_env_file (get_string_value ("ENV"));
      }
  
--- 970,974 ----
        /* bash and sh */
        if (interactive_shell && privileged_mode == 0 && sourced_env++ == 0)
! 	execute_env_file (get_string_value ("ENV"));
      }
  
***************
*** 1014,1018 ****
        set_var_read_only ("ENV");
        set_var_read_only ("BASH_ENV");
!       restricted++;
      }
    return (restricted);
--- 1014,1018 ----
        set_var_read_only ("ENV");
        set_var_read_only ("BASH_ENV");
!       restricted = 1;
      }
    return (restricted);
***************
*** 1085,1089 ****
        with_input_from_string (words, "--wordexp");
        if (parse_command () != 0)
!         return (126);
        if (global_command == 0)
  	{
--- 1085,1089 ----
        with_input_from_string (words, "--wordexp");
        if (parse_command () != 0)
! 	return (126);
        if (global_command == 0)
  	{
***************
*** 1092,1096 ****
  	}
        if (global_command->type != cm_simple)
!         return (126);
        wl = global_command->value.Simple->words;
        result = wl ? expand_words_no_vars (wl) : (WORD_LIST *)0;
--- 1092,1096 ----
  	}
        if (global_command->type != cm_simple)
! 	return (126);
        wl = global_command->value.Simple->words;
        result = wl ? expand_words_no_vars (wl) : (WORD_LIST *)0;
***************
*** 1179,1183 ****
  	}
        else			/* bind to $1...$n for shell script */
!         remember_args (args, 1);
  
        dispose_words (args);
--- 1179,1183 ----
  	}
        else			/* bind to $1...$n for shell script */
! 	remember_args (args, 1);
  
        dispose_words (args);
***************
*** 1197,1201 ****
       char *script_name;
  {
!   int fd, e;
    char *filename, *path_filename;
    unsigned char sample[80];
--- 1197,1201 ----
       char *script_name;
  {
!   int fd, e, fd_is_tty;
    char *filename, *path_filename;
    unsigned char sample[80];
***************
*** 1231,1236 ****
      }
  
!   /* Only do this with file descriptors we can seek on. */
!   if (lseek (fd, 0L, 1) != -1)
      {
        /* Check to see if the `file' in `bash file' is a binary file
--- 1231,1242 ----
      }
  
! #ifdef HAVE_DEV_FD
!   fd_is_tty = isatty (fd);
! #else
!   fd_is_tty = 0;
! #endif
! 
!   /* Only do this with non-tty file descriptors we can seek on. */
!   if (fd_is_tty == 0 && (lseek (fd, 0L, 1) != -1))
      {
        /* Check to see if the `file' in `bash file' is a binary file
***************
*** 1243,1247 ****
  	  if ((fstat (fd, &sb) == 0) && S_ISDIR (sb.st_mode))
  	    internal_error ("%s: is a directory", filename);
!           else
  	    {
  	      errno = e;
--- 1249,1253 ----
  	  if ((fstat (fd, &sb) == 0) && S_ISDIR (sb.st_mode))
  	    internal_error ("%s: is a directory", filename);
! 	  else
  	    {
  	      errno = e;
***************
*** 1264,1277 ****
    fd = move_to_high_fd (fd, 0, -1);
  
  #if defined (BUFFERED_INPUT)
    default_buffered_input = fd;
- #  if 0
-   /* This is never executed. */
-   if (default_buffered_input == -1)
-     {
-       file_error (filename);
-       exit (EX_NOTFOUND);
-     }
- #  endif
    SET_CLOSE_ON_EXEC (default_buffered_input);
  #else /* !BUFFERED_INPUT */
--- 1270,1279 ----
    fd = move_to_high_fd (fd, 0, -1);
  
+ #if defined (__CYGWIN__) && defined (O_TEXT)
+   setmode (fd, O_TEXT);
+ #endif
+ 
  #if defined (BUFFERED_INPUT)
    default_buffered_input = fd;
    SET_CLOSE_ON_EXEC (default_buffered_input);
  #else /* !BUFFERED_INPUT */
***************
*** 1289,1299 ****
  #endif /* !BUFFERED_INPUT */
  
!   if (interactive_shell == 0 || isatty (fd) == 0)
!     /* XXX - does this really need to be called again here? */
!     init_noninteractive ();
!   else
      {
-       /* I don't believe that this code is ever executed, even in
- 	 the presence of /dev/fd. */
        dup2 (fd, 0);
        close (fd);
--- 1291,1298 ----
  #endif /* !BUFFERED_INPUT */
  
!   /* Just about the only way for this code to be executed is if something
!      like `bash -i /dev/stdin' is executed. */
!   if (interactive_shell && fd_is_tty)
      {
        dup2 (fd, 0);
        close (fd);
***************
*** 1306,1309 ****
--- 1305,1309 ----
  #endif
      }
+ 
    free (filename);
    return (fd);
***************
*** 1318,1325 ****
  #if defined (BUFFERED_INPUT)
    if (interactive == 0)
!     unset_nodelay_mode (default_buffered_input);
    else
  #endif /* !BUFFERED_INPUT */
!     unset_nodelay_mode (fileno (stdin));
  
    /* with_input_from_stdin really means `with_input_from_readline' */
--- 1318,1325 ----
  #if defined (BUFFERED_INPUT)
    if (interactive == 0)
!     sh_unset_nodelay_mode (default_buffered_input);
    else
  #endif /* !BUFFERED_INPUT */
!     sh_unset_nodelay_mode (fileno (stdin));
  
    /* with_input_from_stdin really means `with_input_from_readline' */
***************
*** 1563,1570 ****
    delete_all_variables (shell_functions);
  
! #if 0
!   /* Pretend the PATH variable has changed. */
!   flush_hashed_filenames ();
! #endif
  }
  
--- 1563,1567 ----
    delete_all_variables (shell_functions);
  
!   shell_reinitialized = 1;
  }
  
diff -Nrc2 bash-2.04/shell.h bash-2.05/shell.h
*** bash-2.04/shell.h	Thu Aug  5 07:13:21 1999
--- bash-2.05/shell.h	Sat Oct 14 17:33:01 2000
***************
*** 24,27 ****
--- 24,28 ----
  
  #include "command.h"
+ #include "syntax.h"
  #include "general.h"
  #include "error.h"
***************
*** 65,88 ****
  #define EX_BADASSIGN	260	/* variable assignment error */
  #define EX_EXPFAIL	261	/* word expansion failed */
- 
- /* The list of characters that are quoted in double-quotes with a
-    backslash.  Other characters following a backslash cause nothing
-    special to happen. */
- #define slashify_in_quotes "\\`$\"\n"
- #define slashify_in_here_document "\\`$"
- 
- /* Constants which specify how to handle backslashes and quoting in
-    expand_word_internal ().  Q_DOUBLE_QUOTES means to use the function
-    slashify_in_quotes () to decide whether the backslash should be
-    retained.  Q_HERE_DOCUMENT means slashify_in_here_document () to
-    decide whether to retain the backslash.  Q_KEEP_BACKSLASH means
-    to unconditionally retain the backslash. */
- #define Q_DOUBLE_QUOTES  0x1
- #define Q_HERE_DOCUMENT  0x2
- #define Q_KEEP_BACKSLASH 0x4
- #define Q_NOQUOTE	 0x8
- #define Q_QUOTED	 0x10
- #define Q_ADDEDQUOTES	 0x20
- #define Q_QUOTEDNULL	 0x40
  
  /* Flag values that control parameter pattern substitution. */
--- 66,69 ----
diff -Nrc2 bash-2.04/sig.c bash-2.05/sig.c
*** bash-2.04/sig.c	Fri Feb 11 15:55:53 2000
--- bash-2.05/sig.c	Mon Mar 26 11:01:55 2001
***************
*** 231,241 ****
  	 if the shell is not interactive. */
        if (!interactive_shell && XHANDLER (i) == SIG_IGN)
!         {
  	  sigaction (XSIG (i), &oact, &act);
  	  set_signal_ignored (XSIG (i));
!         }
  #if defined (SIGPROF) && !defined (_MINIX)
        if (XSIG (i) == SIGPROF && XHANDLER (i) != SIG_DFL && XHANDLER (i) != SIG_IGN)
!         sigaction (XSIG (i), &oact, (struct sigaction *)NULL);
  #endif /* SIGPROF && !_MINIX */
      }
--- 231,241 ----
  	 if the shell is not interactive. */
        if (!interactive_shell && XHANDLER (i) == SIG_IGN)
! 	{
  	  sigaction (XSIG (i), &oact, &act);
  	  set_signal_ignored (XSIG (i));
! 	}
  #if defined (SIGPROF) && !defined (_MINIX)
        if (XSIG (i) == SIGPROF && XHANDLER (i) != SIG_DFL && XHANDLER (i) != SIG_IGN)
! 	sigaction (XSIG (i), &oact, (struct sigaction *)NULL);
  #endif /* SIGPROF && !_MINIX */
      }
***************
*** 250,259 ****
        if (!interactive_shell && XHANDLER (i) == SIG_IGN)
  	{
!           signal (XSIG (i), SIG_IGN);
!           set_signal_ignored (XSIG (i));
  	}
  #ifdef SIGPROF
        if (XSIG (i) == SIGPROF && XHANDLER (i) != SIG_DFL && XHANDLER (i) != SIG_IGN)
!         signal (XSIG (i), XHANDLER (i));
  #endif
      }
--- 250,259 ----
        if (!interactive_shell && XHANDLER (i) == SIG_IGN)
  	{
! 	  signal (XSIG (i), SIG_IGN);
! 	  set_signal_ignored (XSIG (i));
  	}
  #ifdef SIGPROF
        if (XSIG (i) == SIGPROF && XHANDLER (i) != SIG_DFL && XHANDLER (i) != SIG_IGN)
! 	signal (XSIG (i), XHANDLER (i));
  #endif
      }
***************
*** 352,356 ****
  
  #if defined (JOB_CONTROL)
!   give_terminal_to (shell_pgrp);
  #endif /* JOB_CONTROL */
  
--- 352,356 ----
  
  #if defined (JOB_CONTROL)
!   give_terminal_to (shell_pgrp, 0);
  #endif /* JOB_CONTROL */
  
diff -Nrc2 bash-2.04/stringlib.c bash-2.05/stringlib.c
*** bash-2.04/stringlib.c	Thu Aug  5 07:14:34 1999
--- bash-2.05/stringlib.c	Wed Feb 14 17:00:42 2001
***************
*** 39,140 ****
  #endif
  
- #ifndef to_upper
- #  define to_upper(c) (islower(c) ? toupper(c) : (c))
- #  define to_lower(c) (isupper(c) ? tolower(c) : (c))
- #endif
- 
- #define ISOCTAL(c)	((c) >= '0' && (c) <= '7')
- #define OCTVALUE(c)	((c) - '0')
- 
- #ifndef isxdigit
- #  define isxdigit(c)	(isdigit((c)) || ((c) >= 'a' && (c) <= 'f') || ((c) >= 'A' && (c) <= 'F'))
- #endif
- 
- #define HEXVALUE(c) \
-   ((c) >= 'a' && (c) <= 'f' ? (c)-'a'+10 : (c) >= 'A' && (c) <= 'F' ? (c)-'A'+10 : (c)-'0')
- 
- /* Convert STRING by expanding the escape sequences specified by the
-    ANSI C standard.  If SAWC is non-null, recognize `\c' and use that
-    as a string terminator.  If we see \c, set *SAWC to 1 before
-    returning.  LEN is the length of STRING.  FOR_ECHO is a flag that
-    means, if non-zero, that we're translating a string for `echo -e',
-    and therefore should not treat a single quote as a character that
-    may be escaped with a backslash. */
- char *
- ansicstr (string, len, for_echo, sawc, rlen)
-      char *string;
-      int len, for_echo, *sawc, *rlen;
- {
-   int c, temp;
-   char *ret, *r, *s;
- 
-   if (string == 0 || *string == '\0')
-     return ((char *)NULL);
- 
-   ret = xmalloc (len + 1);
-   for (r = ret, s = string; s && *s; )
-     {
-       c = *s++;
-       if (c != '\\' || *s == '\0')
-         *r++ = c;
-       else
- 	{
- 	  switch (c = *s++)
- 	    {
- #if defined (__STDC__)
- 	    case 'a': c = '\a'; break;
- 	    case 'v': c = '\v'; break;
- #else
- 	    case 'a': c = '\007'; break;
- 	    case 'v': c = (int) 0x0B; break;
- #endif
- 	    case 'b': c = '\b'; break;
- 	    case 'e': case 'E':		/* ESC -- non-ANSI */
- 	      c = '\033'; break;
- 	    case 'f': c = '\f'; break;
- 	    case 'n': c = '\n'; break;
- 	    case 'r': c = '\r'; break;
- 	    case 't': c = '\t'; break;
- 	    case '0': case '1': case '2': case '3':
- 	    case '4': case '5': case '6': case '7':
- 	      for (temp = 2, c -= '0'; ISOCTAL (*s) && temp--; s++)
- 	        c = (c * 8) + OCTVALUE (*s);
- 	      break;
- 	    case 'x':			/* Hex digit -- non-ANSI */
- 	      for (temp = 3, c = 0; isxdigit (*s) && temp--; s++)
- 	        c = (c * 16) + HEXVALUE (*s);
- 	      /* \x followed by non-hex digits is passed through unchanged */
- 	      if (temp == 3)
- 		{
- 		  *r++ = '\\';
- 		  c = 'x';
- 		}
- 	      break;
- 	    case '\\':
- 	      break;
- 	    case '\'':
- 	      if (for_echo)
- 		*r++ = '\\';
- 	      break;
- 	    case 'c':
- 	      if (sawc)
- 		{
- 		  *sawc = 1;
- 		  *r = '\0';
- 		  if (rlen)
- 		    *rlen = r - ret;
- 		  return ret;
- 		}
- 	    default:  *r++ = '\\'; break;
- 	    }
- 	  *r++ = c;
- 	}
-     }
-   *r = '\0';
-   if (rlen)
-     *rlen = r - ret;
-   return ret;
- }
- 
  /* **************************************************************** */
  /*								    */
--- 39,42 ----
***************
*** 143,253 ****
  /* **************************************************************** */
  
- #ifdef INCLUDE_UNUSED
- /* Find NAME in ARRAY.  Return the index of NAME, or -1 if not present.
-    ARRAY should be NULL terminated. */
- int
- find_name_in_array (name, array)
-      char *name, **array;
- {
-   int i;
- 
-   for (i = 0; array[i]; i++)
-     if (STREQ (name, array[i]))
-       return (i);
- 
-   return (-1);
- }
- #endif
- 
- /* Allocate an array of strings with room for N members. */
- char **
- alloc_array (n)
-      int n;
- {
-   return ((char **)xmalloc ((n) * sizeof (char *)));
- }
- 
- /* Return the length of ARRAY, a NULL terminated array of char *. */
- int
- array_len (array)
-      char **array;
- {
-   register int i;
- 
-   for (i = 0; array[i]; i++);
-   return (i);
- }
- 
- /* Free the contents of ARRAY, a NULL terminated array of char *. */
- void
- free_array_members (array)
-      char **array;
- {
-   register int i;
- 
-   if (array == 0)
-     return;
- 
-   for (i = 0; array[i]; i++)
-     free (array[i]);
- }
- 
- void
- free_array (array)
-      char **array;
- {
-   if (array == 0)
-     return;
- 
-   free_array_members (array);
-   free (array);
- }
- 
- /* Allocate and return a new copy of ARRAY and its contents. */
- char **
- copy_array (array)
-      char **array;
- {
-   register int i;
-   int len;
-   char **new_array;
- 
-   len = array_len (array);
- 
-   new_array = (char **)xmalloc ((len + 1) * sizeof (char *));
-   for (i = 0; array[i]; i++)
-     new_array[i] = savestring (array[i]);
-   new_array[i] = (char *)NULL;
- 
-   return (new_array);
- }
- 
- /* Comparison routine for use with qsort() on arrays of strings.  Uses
-    strcoll(3) if available, otherwise it uses strcmp(3). */
- int
- qsort_string_compare (s1, s2)
-      register char **s1, **s2;
- {
- #if defined (HAVE_STRCOLL)
-    return (strcoll (*s1, *s2));
- #else /* !HAVE_STRCOLL */
-   int result;
- 
-   if ((result = **s1 - **s2) == 0)
-     result = strcmp (*s1, *s2);
- 
-   return (result);
- #endif /* !HAVE_STRCOLL */
- }
- 
- /* Sort ARRAY, a null terminated array of pointers to strings. */
- void
- sort_char_array (array)
-      char **array;
- {
-   qsort (array, array_len (array), sizeof (char *),
- 	 (Function *)qsort_string_compare);
- }
- 
  /* Cons up a new array of words.  The words are taken from LIST,
     which is a WORD_LIST *.  If COPY is true, everything is malloc'ed,
--- 45,48 ----
***************
*** 325,335 ****
  #if defined (EXTENDED_GLOB)
        if (flags)
!         r = fnmatch (alist[i].word, string, FNM_EXTMATCH) != FNM_NOMATCH;
        else
  #endif
!         r = STREQ (string, alist[i].word);
  
        if (r)
!         return (alist[i].token);
      }
    return -1;
--- 120,130 ----
  #if defined (EXTENDED_GLOB)
        if (flags)
! 	r = fnmatch (alist[i].word, string, FNM_EXTMATCH) != FNM_NOMATCH;
        else
  #endif
! 	r = STREQ (string, alist[i].word);
  
        if (r)
! 	return (alist[i].token);
      }
    return -1;
***************
*** 358,363 ****
      {
        if (repl && STREQN (string + i, pat, patlen))
!         {
!           RESIZE_MALLOCED_BUFFER (temp, templen, replen, tempsize, (replen * 2));
  
  	  for (r = rep; *r; )
--- 153,158 ----
      {
        if (repl && STREQN (string + i, pat, patlen))
! 	{
! 	  RESIZE_MALLOCED_BUFFER (temp, templen, replen, tempsize, (replen * 2));
  
  	  for (r = rep; *r; )
***************
*** 366,370 ****
  	  i += patlen;
  	  repl = global != 0;
!         }
        else
  	{
--- 161,165 ----
  	  i += patlen;
  	  repl = global != 0;
! 	}
        else
  	{
***************
*** 423,429 ****
  	}
  
!       if (*p == '\\' && p[1] == '&')
  	p++;
  
        *r++ = *p++;
      }
--- 218,226 ----
  	}
  
!       if (*p == '\\' && p[1] == c)
  	p++;
  
+       RESIZE_MALLOCED_BUFFER (ret, ind, 2, rlen, rlen);
+       r = ret + ind;			/* in case reallocated */
        *r++ = *p++;
      }
***************
*** 466,491 ****
      {
        if ((newlines_only && string[len] == '\n') ||
!           (!newlines_only && whitespace (string[len])))
!         len--;
        else
!         break;
      }
    string[len + 1] = '\0';
- }
- 
- /* Determine if s2 occurs in s1.  If so, return a pointer to the
-    match in s1.  The compare is case insensitive.  This is a
-    case-insensitive strstr(3). */
- char *
- strindex (s1, s2)
-      char *s1, *s2;
- {
-   register int i, l, len, c;
- 
-   c = to_upper (s2[0]);
-   for (i = 0, len = strlen (s1), l = strlen (s2); (len - i) >= l; i++)
-     if ((to_upper (s1[i]) == c) && (strncasecmp (s1 + i, s2, l) == 0))
-       return (s1 + i);
-   return ((char *)NULL);
  }
  
--- 263,272 ----
      {
        if ((newlines_only && string[len] == '\n') ||
! 	  (!newlines_only && whitespace (string[len])))
! 	len--;
        else
! 	break;
      }
    string[len + 1] = '\0';
  }
  
diff -Nrc2 bash-2.04/subst.c bash-2.05/subst.c
*** bash-2.04/subst.c	Tue Mar 14 10:42:02 2000
--- bash-2.05/subst.c	Mon Mar 26 13:06:16 2001
***************
*** 81,89 ****
  #define RPAREN		')'
  
  /* Evaluates to 1 if this is one of the shell's special variables. */
  #define SPECIAL_VAR(name, wi) \
!  ((digit (*name) && all_digits (name)) || \
!       (name[1] == '\0' && member (*name, "#-?$!@*")) || \
!       (wi && name[2] == '\0' && member (name[1], "#?@*")))
  
  /* Process ID of the last command executed within command substitution. */
--- 81,104 ----
  #define RPAREN		')'
  
+ /* Evaluates to 1 if C is one of the shell's special parameters whose length
+    can be taken, but is also one of the special expansion characters. */
+ #define VALID_SPECIAL_LENGTH_PARAM(c) \
+   ((c) == '-' || (c) == '?' || (c) == '#')
+ 
+ /* Evaluates to 1 if C is one of the shell's special parameters for which an
+    indirect variable reference may be made. */
+ #define VALID_INDIR_PARAM(c) \
+   ((c) == '#' || (c) == '?' || (c) == '@' || (c) == '*')
+ 
+ /* Evaluates to 1 if C is one of the OP characters that follows the parameter
+    in ${parameter[:]OPword}. */
+ #define VALID_PARAM_EXPAND_CHAR(c) \
+   ((c) == '-' || (c) == '=' || (c) == '?' || (c) == '+')
+ 
  /* Evaluates to 1 if this is one of the shell's special variables. */
  #define SPECIAL_VAR(name, wi) \
!  ((isdigit (*name) && all_digits (name)) || \
!       (name[1] == '\0' && (sh_syntaxtab[*name] & CSPECVAR)) || \
!       (wi && name[2] == '\0' && VALID_INDIR_PARAM (name[1])))
  
  /* Process ID of the last command executed within command substitution. */
***************
*** 116,121 ****
  static char expand_param_error, expand_param_fatal;
  
! static int doing_completion = 0;
! static int doing_prompt_expansion = 0;
  
  /* Used to hold a list of variable assignments preceding a command.  Global
--- 131,141 ----
  static char expand_param_error, expand_param_fatal;
  
! /* Tell the expansion functions to not longjmp back to top_level on fatal
!    errors.  Enabled when doing completion and prompt string expansion. */
! static int no_longjmp_on_fatal_error = 0;
! 
! /* Set by expand_word_unsplit; used to inhibit splitting and re-joining
!    $* on $IFS, primarily when doing assignment statements. */
! static int expand_no_split_dollar_star = 0;
  
  /* Used to hold a list of variable assignments preceding a command.  Global
***************
*** 123,126 ****
--- 143,147 ----
     SIGCHLD trap. */
  WORD_LIST *subst_assign_varlist = (WORD_LIST *)NULL;
+ 
  /* A WORD_LIST of words to be expanded by expand_word_list_internal,
     without any leading variable assignments. */
***************
*** 188,197 ****
        if (*s == CTLESC)
  	{
!           s++;
!           continue;
  	}
        l++;
        if (*s == 0)
!         break;
      }
  
--- 209,218 ----
        if (*s == CTLESC)
  	{
! 	  s++;
! 	  continue;
  	}
        l++;
        if (*s == 0)
! 	break;
      }
  
***************
*** 203,211 ****
      {
        if (*s == CTLESC)
!         *r++ = *s++;
        *r++ = *s;
        l++;
        if (*s == 0)
!         break;
      }
    *r = '\0';
--- 224,232 ----
      {
        if (*s == CTLESC)
! 	*r++ = *s++;
        *r++ = *s;
        l++;
        if (*s == 0)
! 	break;
      }
    *r = '\0';
***************
*** 461,465 ****
  		it were double-quoted. */
  	  if ((stripdq == 0 && c != '"') ||
! 	      (stripdq && ((dquote && strchr (slashify_in_quotes, c)) || dquote == 0)))
  	    temp[j++] = '\\';
  	  temp[j++] = c;
--- 482,486 ----
  		it were double-quoted. */
  	  if ((stripdq == 0 && c != '"') ||
! 	      (stripdq && ((dquote && (sh_syntaxtab[c] & CBSDQUOTE)) || dquote == 0)))
  	    temp[j++] = '\\';
  	  temp[j++] = c;
***************
*** 519,523 ****
  
        /* Add any character but a double quote to the quoted string we're
!          accumulating. */
        if (c != '"')
  	{
--- 540,544 ----
  
        /* Add any character but a double quote to the quoted string we're
! 	 accumulating. */
        if (c != '"')
  	{
***************
*** 633,643 ****
       int sind;
  {
!   register int i;
  
!   for (i = sind; string[i] && string[i] != '\''; i++)
      ;
!   if (string[i])
!     i++;
!   return i;
  }
  
--- 654,664 ----
       int sind;
  {
!   register int c;
  
!   for (c = sind; string[c] && string[c] != '\''; c++)
      ;
!   if (string[c])
!     c++;
!   return c;
  }
  
***************
*** 689,693 ****
  }
  
! /* Extract the $[ construct in STRING, and return a new string.
     Start extracting at (SINDEX) as if we had just seen "$[".
     Make (SINDEX) get the position of the matching "]". */
--- 710,714 ----
  }
  
! /* Extract the $[ construct in STRING, and return a new string. (])
     Start extracting at (SINDEX) as if we had just seen "$[".
     Make (SINDEX) get the position of the matching "]". */
***************
*** 697,701 ****
       int *sindex;
  {
!   return (extract_delimited_string (string, sindex, "$[", "[", "]"));
  }
  
--- 718,722 ----
       int *sindex;
  {
!   return (extract_delimited_string (string, sindex, "$[", "[", "]")); /*]*/
  }
  
***************
*** 757,761 ****
  
        if (c == 0)
!         break;
  
        if (pass_character)	/* previous char was backslash */
--- 778,782 ----
  
        if (c == 0)
! 	break;
  
        if (pass_character)	/* previous char was backslash */
***************
*** 773,782 ****
  	}
  
- #if 0
-       if (c == '\\' && delimiter == '"' &&
- 	      (member (string[i], slashify_in_quotes)))
- #else
        if (c == '\\')
- #endif
  	{
  	  pass_character++;
--- 794,798 ----
***************
*** 817,843 ****
        /* Pass old-style command substitution through verbatim. */
        if (c == '`')
!         {
!           si = i + 1;
!           t = string_extract (string, &si, "`", 0);
!           i = si + 1;
!           FREE (t);
!           continue;
!         }
  
        /* Pass single-quoted strings through verbatim. */
        if (c == '\'')
!         {
!           si = i + 1;
!           i = skip_single_quoted (string, si);
!           continue;
!         }
  
        /* Pass embedded double-quoted strings through verbatim as well. */
        if (c == '"')
!         {
!           si = i + 1;
!           i = skip_double_quoted (string, si);
!           continue;
!         }
  
        i++;	/* move past this character, which was not special. */
--- 833,859 ----
        /* Pass old-style command substitution through verbatim. */
        if (c == '`')
! 	{
! 	  si = i + 1;
! 	  t = string_extract (string, &si, "`", 0);
! 	  i = si + 1;
! 	  FREE (t);
! 	  continue;
! 	}
  
        /* Pass single-quoted strings through verbatim. */
        if (c == '\'')
! 	{
! 	  si = i + 1;
! 	  i = skip_single_quoted (string, si);
! 	  continue;
! 	}
  
        /* Pass embedded double-quoted strings through verbatim as well. */
        if (c == '"')
! 	{
! 	  si = i + 1;
! 	  i = skip_double_quoted (string, si);
! 	  continue;
! 	}
  
        i++;	/* move past this character, which was not special. */
***************
*** 847,854 ****
    if (c == 0 && nesting_level)
  #else
!   if (c == 0 && nesting_level && doing_completion == 0)
  #endif
      {
        report_error ("bad substitution: no `%s' in %s", closer, string);
        jump_to_top_level (DISCARD);
      }
--- 863,871 ----
    if (c == 0 && nesting_level)
  #else
!   if (c == 0 && nesting_level && no_longjmp_on_fatal_error == 0)
  #endif
      {
        report_error ("bad substitution: no `%s' in %s", closer, string);
+       last_command_exit_value = EXECUTION_FAILURE;
        jump_to_top_level (DISCARD);
      }
***************
*** 949,955 ****
      }
  
!   if (c == 0 && nesting_level && doing_completion == 0)
      {
        report_error ("bad substitution: no ending `}' in %s", string);
        jump_to_top_level (DISCARD);
      }
--- 966,973 ----
      }
  
!   if (c == 0 && nesting_level && no_longjmp_on_fatal_error == 0)
      {
        report_error ("bad substitution: no ending `}' in %s", string);
+       last_command_exit_value = EXECUTION_FAILURE;
        jump_to_top_level (DISCARD);
      }
***************
*** 1004,1012 ****
  /* Return 1 if the portion of STRING ending at EINDEX is quoted (there is
     an unclosed quoted string), or if the character at EINDEX is quoted
!    by a backslash. DOING_COMPLETION is used to flag that the various
     single and double-quoted string parsing functions should not return an
     error if there are unclosed quotes or braces. */
  
! #define CQ_RETURN(x) do { doing_completion = 0; return (x); } while (0)
  
  int
--- 1022,1030 ----
  /* Return 1 if the portion of STRING ending at EINDEX is quoted (there is
     an unclosed quoted string), or if the character at EINDEX is quoted
!    by a backslash. NO_LONGJMP_ON_FATAL_ERROR is used to flag that the various
     single and double-quoted string parsing functions should not return an
     error if there are unclosed quotes or braces. */
  
! #define CQ_RETURN(x) do { no_longjmp_on_fatal_error = 0; return (x); } while (0)
  
  int
***************
*** 1017,1021 ****
    int i, pass_next, quoted;
  
!   doing_completion = 1;
    for (i = pass_next = quoted = 0; i <= eindex; i++)
      {
--- 1035,1039 ----
    int i, pass_next, quoted;
  
!   no_longjmp_on_fatal_error = 1;
    for (i = pass_next = quoted = 0; i <= eindex; i++)
      {
***************
*** 1098,1102 ****
    char *temp;
  
!   doing_completion = 1;
    for (i = start, pass_next = backq = 0; string[i]; i++)
      {
--- 1116,1120 ----
    char *temp;
  
!   no_longjmp_on_fatal_error = 1;
    for (i = start, pass_next = backq = 0; string[i]; i++)
      {
***************
*** 1144,1148 ****
  	}
        else if (member (string[i], delims))
!         break;
      }
    CQ_RETURN(i);
--- 1162,1166 ----
  	}
        else if (member (string[i], delims))
! 	break;
      }
    CQ_RETURN(i);
***************
*** 1193,1197 ****
    ret = (WORD_LIST *)NULL;
  
!   for (i = 0; member (string[i], d) && whitespace(string[i]); i++)
      ;
    if (string[i] == '\0')
--- 1211,1215 ----
    ret = (WORD_LIST *)NULL;
  
!   for (i = 0; member (string[i], d) && (whitespace(string[i]) || string[i] == '\n'); i++)
      ;
    if (string[i] == '\0')
***************
*** 1208,1215 ****
  	 separate field.  This is just about what $IFS splitting does and
  	 is closer to the behavior of the shell parser. */
!       if (ts == te && member(string[ts], d2))
  	{
  	  te = ts + 1;
! 	  while (member(string[te], d2))
  	    te++;
  	}
--- 1226,1233 ----
  	 separate field.  This is just about what $IFS splitting does and
  	 is closer to the behavior of the shell parser. */
!       if (ts == te && d2 && member (string[ts], d2))
  	{
  	  te = ts + 1;
! 	  while (member (string[te], d2))
  	    te++;
  	}
***************
*** 1225,1249 ****
  
        /* If the cursor is at whitespace just before word start, set the
!          sentinel word to the current word. */
        if (cwp && cw == -1 && sentinel == ts-1)
  	cw = nw;
  
        /* If the cursor is at whitespace between two words, make a new, empty
!          word, add it before (well, after, since the list is in reverse order)
!          the word we just added, and set the current word to that one. */
        if (cwp && cw == -1 && sentinel < ts)
!         {
!           tl = (WORD_LIST *)xmalloc (sizeof (WORD_LIST));
!           tl->word = make_word ("");
!           tl->next = ret->next;
!           ret->next = tl;
!           cw = nw;
!           nw++;
!         }
  
        if (string[te] == 0)
  	break;
  
!       i = te + member(string[te], d);
        while (member (string[i], d) && whitespace(string[i]))
  	i++;
--- 1243,1267 ----
  
        /* If the cursor is at whitespace just before word start, set the
! 	 sentinel word to the current word. */
        if (cwp && cw == -1 && sentinel == ts-1)
  	cw = nw;
  
        /* If the cursor is at whitespace between two words, make a new, empty
! 	 word, add it before (well, after, since the list is in reverse order)
! 	 the word we just added, and set the current word to that one. */
        if (cwp && cw == -1 && sentinel < ts)
! 	{
! 	  tl = (WORD_LIST *)xmalloc (sizeof (WORD_LIST));
! 	  tl->word = make_word ("");
! 	  tl->next = ret->next;
! 	  ret->next = tl;
! 	  cw = nw;
! 	  nw++;
! 	}
  
        if (string[te] == 0)
  	break;
  
!       i = te + member (string[te], d);
        while (member (string[i], d) && whitespace(string[i]))
  	i++;
***************
*** 1262,1270 ****
      {
        if (whitespace (string[sentinel - 1]))
!         {
!           token = "";
!           ret = add_string_to_list (token, ret);
!           nw++;
!         }
        cw = nw;
      }
--- 1280,1288 ----
      {
        if (whitespace (string[sentinel - 1]))
! 	{
! 	  token = "";
! 	  ret = add_string_to_list (token, ret);
! 	  nw++;
! 	}
        cw = nw;
      }
***************
*** 1445,1449 ****
    WORD_DESC *t;
    char *current_word, *s;
!   int sindex, sh_style_split;
  
    if (!string || !*string)
--- 1463,1467 ----
    WORD_DESC *t;
    char *current_word, *s;
!   int sindex, sh_style_split, whitesep;
  
    if (!string || !*string)
***************
*** 1512,1515 ****
--- 1530,1536 ----
        free (current_word);
  
+       /* Note whether or not the separator is IFS whitespace, used later. */
+       whitesep = string[sindex] && spctabnl (string[sindex]);
+ 
        /* Move past the current separator character. */
        if (string[sindex])
***************
*** 1520,1523 ****
--- 1541,1551 ----
        while (string[sindex] && spctabnl (string[sindex]) && issep (string[sindex]))
  	sindex++;
+ 
+       /* If the first separator was IFS whitespace and the current character is
+ 	 a non-whitespace IFS character, it should be part of the current field
+ 	 delimiter, not a separate delimiter that would result in an empty field.
+ 	 Look at POSIX.2, 3.6.5, (3)(b). */
+       if (string[sindex] && whitesep && issep (string[sindex]) && !spctabnl (string[sindex]))
+ 	sindex++;
      }
    return (REVERSE_LIST (result, WORD_LIST *));
***************
*** 1535,1539 ****
    register char *s;
    char *current_word;
!   int sindex, sh_style_split;
  
    if (!stringp || !*stringp || !**stringp)
--- 1563,1567 ----
    register char *s;
    char *current_word;
!   int sindex, sh_style_split, whitesep;
  
    if (!stringp || !*stringp || !**stringp)
***************
*** 1574,1577 ****
--- 1602,1608 ----
      *endptr = s + sindex;
  
+   /* Note whether or not the separator is IFS whitespace, used later. */
+   whitesep = s[sindex] && spctabnl (s[sindex]);
+ 
    /* Move past the current separator character. */
    if (s[sindex])
***************
*** 1583,1586 ****
--- 1614,1624 ----
      sindex++;
  
+   /* If the first separator was IFS whitespace and the current character is
+      a non-whitespace IFS character, it should be part of the current field
+      delimiter, not a separate delimiter that would result in an empty field.
+      Look at POSIX.2, 3.6.5, (3)(b). */
+   if (s[sindex] && whitesep && issep (s[sindex]) && !spctabnl (s[sindex]))
+     sindex++;
+ 
    /* Update STRING to point to the next field. */
    *stringp = s + sindex;
***************
*** 1637,1641 ****
  	}
        else if (c == '\'')
!         i = skip_single_quoted (s, ++i);
        else if (c == '"')
  	i = skip_double_quoted (s, ++i);
--- 1675,1679 ----
  	}
        else if (c == '\'')
! 	i = skip_single_quoted (s, ++i);
        else if (c == '"')
  	i = skip_double_quoted (s, ++i);
***************
*** 1690,1699 ****
    if (ind < 0)
      {
!       t[-1] = '[';		/* restore original name */
        report_error ("%s: bad array subscript", name);
        return ((SHELL_VAR *)NULL);
      }
    entry = bind_array_variable (name, ind, value);
!   t[-1] = '[';		/* restore original name */
    return (entry);
  }
--- 1728,1737 ----
    if (ind < 0)
      {
!       t[-1] = '[';		/* restore original name ] */
        report_error ("%s: bad array subscript", name);
        return ((SHELL_VAR *)NULL);
      }
    entry = bind_array_variable (name, ind, value);
!   t[-1] = '[';		/* restore original name ] */
    return (entry);
  }
***************
*** 1740,1744 ****
        /* Perform tilde expansion. */
        if (expand && temp[0])
!         {
  	  temp = (strchr (temp, '~') && unquoted_member ('~', temp))
  			? bash_tilde_expand (temp)
--- 1778,1782 ----
        /* Perform tilde expansion. */
        if (expand && temp[0])
! 	{
  	  temp = (strchr (temp, '~') && unquoted_member ('~', temp))
  			? bash_tilde_expand (temp)
***************
*** 1769,1773 ****
  
  #if defined (ARRAY_VARS)
!   if (t = strchr (name, '['))
      {
        if (assign_list)
--- 1807,1811 ----
  
  #if defined (ARRAY_VARS)
!   if (t = strchr (name, '['))	/*]*/
      {
        if (assign_list)
***************
*** 1778,1782 ****
        entry = do_array_element_assignment (name, value);
        if (entry == 0)
!         ASSIGN_RETURN (0);
      }
    else if (assign_list)
--- 1816,1820 ----
        entry = do_array_element_assignment (name, value);
        if (entry == 0)
! 	ASSIGN_RETURN (0);
      }
    else if (assign_list)
***************
*** 1792,1796 ****
  
    /* Return 1 if the assignment seems to have been performed correctly. */
!   ASSIGN_RETURN (entry ? (readonly_p (entry) == 0) : 0);
  }
  
--- 1830,1834 ----
  
    /* Return 1 if the assignment seems to have been performed correctly. */
!   ASSIGN_RETURN (entry ? ((readonly_p (entry) == 0) && noassign_p (entry) == 0) : 0);
  }
  
***************
*** 1864,1868 ****
        ind -= 10;
        for (p = rest_of_args; p && ind--; p = p->next)
!         ;
        temp = p ? savestring (p->word->word) : (char *)NULL;
      }
--- 1902,1906 ----
        ind -= 10;
        for (p = rest_of_args; p && ind--; p = p->next)
! 	;
        temp = p ? savestring (p->word->word) : (char *)NULL;
      }
***************
*** 2015,2021 ****
      {
        if (*s == '\\')
!         s++;
        if (*s == 0)
!         break;
        *r++ = *s++;
      }
--- 2053,2059 ----
      {
        if (*s == '\\')
! 	s++;
        if (*s == 0)
! 	break;
        *r++ = *s++;
      }
***************
*** 2042,2045 ****
--- 2080,2090 ----
      return ((char *)NULL);
  
+   if (strchr (w->word, '~') && unquoted_member ('~', w->word))
+     {
+       p = bash_tilde_expand (w->word);
+       free (w->word);
+       w->word = p;
+     }
+ 
    l = call_expand_word_internal (w, 0, 0, (int *)0, (int *)0);
    if (l)
***************
*** 2051,2059 ****
  	}
        else
!         {
!           p = string_list (l);
!           r = quote_string_for_globbing (p, QGLOB_CVTNULL);
!           free (p);
!         }
        dispose_words (l);
      }
--- 2096,2104 ----
  	}
        else
! 	{
! 	  p = string_list (l);
! 	  r = quote_string_for_globbing (p, QGLOB_CVTNULL);
! 	  free (p);
! 	}
        dispose_words (l);
      }
***************
*** 2078,2081 ****
--- 2123,2127 ----
    if (result == &expand_word_error || result == &expand_word_fatal)
      {
+       expand_no_split_dollar_star = 0;	/* XXX */
        /* By convention, each time this error is returned, w->word has
  	 already been freed (it sometimes may not be in the fatal case,
***************
*** 2083,2086 ****
--- 2129,2133 ----
  	 to exit in most cases). */
        w->word = (char *)NULL;
+       last_command_exit_value = EXECUTION_FAILURE;
        jump_to_top_level ((result == &expand_word_error) ? DISCARD : FORCE_EOF);
        /* NOTREACHED */
***************
*** 2103,2109 ****
      return ((WORD_LIST *)NULL);
  
!   bzero ((char *)&td, sizeof (td));
!   td.word = string;
    tresult = call_expand_word_internal (&td, quoted, 0, (int *)NULL, (int *)NULL);
    return (tresult);
  }
--- 2150,2159 ----
      return ((WORD_LIST *)NULL);
  
!   td.flags = 0;
!   td.word = savestring (string);
! 
    tresult = call_expand_word_internal (&td, quoted, 0, (int *)NULL, (int *)NULL);
+ 
+   FREE (td.word);
    return (tresult);
  }
***************
*** 2121,2128 ****
    WORD_LIST *value;
  
!   if (!string || !*string)
      return ((WORD_LIST *)NULL);
  
    value = expand_string_internal (string, quoted);
    if (value)
      {
--- 2171,2181 ----
    WORD_LIST *value;
  
!   if (string == 0 || *string == '\0')
      return ((WORD_LIST *)NULL);
  
+   expand_no_split_dollar_star = 1;
    value = expand_string_internal (string, quoted);
+   expand_no_split_dollar_star = 0;
+ 
    if (value)
      {
***************
*** 2150,2158 ****
      return ((WORD_LIST *)NULL);
  
!   bzero ((char *)&td, sizeof (td));
    td.word = savestring (string);
!   doing_prompt_expansion = 1;
    value = expand_word_internal (&td, quoted, 0, (int *)NULL, (int *)NULL);
!   doing_prompt_expansion = 0;
    if (value == &expand_word_error || value == &expand_word_fatal)
      {
--- 2203,2213 ----
      return ((WORD_LIST *)NULL);
  
!   td.flags = 0;
    td.word = savestring (string);
! 
!   no_longjmp_on_fatal_error = 1;
    value = expand_word_internal (&td, quoted, 0, (int *)NULL, (int *)NULL);
!   no_longjmp_on_fatal_error = 0;
! 
    if (value == &expand_word_error || value == &expand_word_fatal)
      {
***************
*** 2210,2214 ****
      return (WORD_LIST *)NULL;
  
!   bzero ((char *)&td, sizeof (td));
    td.word = string;
    tresult = call_expand_word_internal (&td, quoted, 1, dollar_at_p, has_dollar_at);
--- 2265,2269 ----
      return (WORD_LIST *)NULL;
  
!   td.flags = 0;
    td.word = string;
    tresult = call_expand_word_internal (&td, quoted, 1, dollar_at_p, has_dollar_at);
***************
*** 2228,2232 ****
    WORD_LIST *result;
  
!   if (!string || !*string)
      return ((WORD_LIST *)NULL);
  
--- 2283,2287 ----
    WORD_LIST *result;
  
!   if (string == 0 || *string == '\0')
      return ((WORD_LIST *)NULL);
  
***************
*** 2495,2499 ****
  	}
        if (*s == CTLNUL)
!         continue;
        *p++ = *s;
      }
--- 2550,2554 ----
  	}
        if (*s == CTLNUL)
! 	continue;
        *p++ = *s;
      }
***************
*** 2626,2630 ****
        return (*string == *pat);
      case '?':
!       return (*string == LPAREN ? 1 : (*string != '\0'));
      case '*':
        return (1);
--- 2681,2685 ----
        return (*string == *pat);
      case '?':
!       return (*pat == LPAREN ? 1 : (*string != '\0'));
      case '*':
        return (1);
***************
*** 2632,2636 ****
      case '!':
      case '@':
!       return (*string == LPAREN ? 1 : (*string == c));
      case '[':
        return (*string != '\0');
--- 2687,2691 ----
      case '!':
      case '@':
!       return (*pat == LPAREN ? 1 : (*string == c));
      case '[':
        return (*string != '\0');
***************
*** 2684,2688 ****
      case MATCH_BEG:
        if (match_pattern_char (pat, string) == 0)
!         return (0);
        for (p = end; p >= string; p--)
  	{
--- 2739,2743 ----
      case MATCH_BEG:
        if (match_pattern_char (pat, string) == 0)
! 	return (0);
        for (p = end; p >= string; p--)
  	{
***************
*** 2871,2882 ****
      {
        if (array_p (var) == 0)
!         {
!           report_error ("%s: bad array subscript", aspec);
!           FREE (pattern);
!           return ((char *)NULL);
!         }
        l = array_to_word_list (array_cell (var));
        if (l == 0)
!         return ((char *)NULL);
        ret = list_remove_pattern (l, pattern, patspec, t[0], quoted);
        dispose_words (l);
--- 2926,2937 ----
      {
        if (array_p (var) == 0)
! 	{
! 	  report_error ("%s: bad array subscript", aspec);
! 	  FREE (pattern);
! 	  return ((char *)NULL);
! 	}
        l = array_to_word_list (array_cell (var));
        if (l == 0)
! 	return ((char *)NULL);
        ret = list_remove_pattern (l, pattern, patspec, t[0], quoted);
        dispose_words (l);
***************
*** 2925,2929 ****
     and quote removal. */
  WORD_LIST *
! expand_word_no_split (word, quoted)
       WORD_DESC *word;
       int quoted;
--- 2980,2984 ----
     and quote removal. */
  WORD_LIST *
! expand_word_unsplit (word, quoted)
       WORD_DESC *word;
       int quoted;
***************
*** 2931,2935 ****
--- 2986,2993 ----
    WORD_LIST *result;
  
+   expand_no_split_dollar_star = 1;
    result = call_expand_word_internal (word, quoted, 0, (int *)NULL, (int *)NULL);
+   expand_no_split_dollar_star = 0;
+   
    return (result ? dequote_list (result) : result);
  }
***************
*** 2959,2963 ****
     list.  NFIFO is a count of the number of FIFOs in the list. */
  #define FIFO_INCR 20
- extern char *mktemp ();
  
  static char **fifo_list = (char **)NULL;
--- 3017,3020 ----
***************
*** 2999,3003 ****
    char *tname;
  
!   tname = mktemp (savestring ("/tmp/sh-np-XXXXXX"));
    if (mkfifo (tname, 0600) < 0)
      {
--- 3056,3060 ----
    char *tname;
  
!   tname = sh_mktmpname ("sh-np", MT_USERANDOM);
    if (mkfifo (tname, 0600) < 0)
      {
***************
*** 3172,3176 ****
        restore_original_signals ();
        setup_async_signals ();
!       subshell_environment = SUBSHELL_COMSUB;
      }
  
--- 3229,3233 ----
        restore_original_signals ();
        setup_async_signals ();
!       subshell_environment |= SUBSHELL_COMSUB;
      }
  
***************
*** 3228,3232 ****
    if (open_for_read_in_child)
      {
!       if (unset_nodelay_mode (fd) < 0)
  	{
  	  sys_error ("cannout reset nodelay mode for fd %d", fd);
--- 3285,3289 ----
    if (open_for_read_in_child)
      {
!       if (sh_unset_nodelay_mode (fd) < 0)
  	{
  	  sys_error ("cannout reset nodelay mode for fd %d", fd);
***************
*** 3291,3299 ****
    istring_index = istring_size = bufn = 0;
  
    /* Read the output of the command through the pipe. */
    while (1)
      {
        if (fd < 0)
!         break;
        if (--bufn <= 0)
  	{
--- 3348,3360 ----
    istring_index = istring_size = bufn = 0;
  
+ #ifdef __CYGWIN__
+   setmode (fd, O_TEXT);		/* we don't want CR/LF, we want Unix-style */
+ #endif
+ 
    /* Read the output of the command through the pipe. */
    while (1)
      {
        if (fd < 0)
! 	break;
        if (--bufn <= 0)
  	{
***************
*** 3305,3308 ****
--- 3366,3377 ----
        c = *bufp++;
  
+       if (c == 0)
+ 	{
+ #if 0
+ 	  internal_warning ("read_comsub: ignored null byte in input");
+ #endif
+ 	  continue;
+ 	}
+ 
        /* Add the character to ISTRING, possibly after resizing it. */
        RESIZE_MALLOCED_BUFFER (istring, istring_index, 2, istring_size, DEFAULT_ARRAY_SIZE);
***************
*** 3312,3315 ****
--- 3381,3394 ----
  
        istring[istring_index++] = c;
+ 
+ #if 0
+ #if defined (__CYGWIN__)
+       if (c == '\n' && istring_index > 1 && istring[istring_index - 2] == '\r')
+ 	{
+ 	  istring_index--;
+ 	  istring[istring_index - 1] = '\n';
+ 	}
+ #endif
+ #endif
      }
  
***************
*** 3395,3399 ****
  #if defined (JOB_CONTROL)
    old_pipeline_pgrp = pipeline_pgrp;
!   pipeline_pgrp = shell_pgrp;
    cleanup_the_pipeline ();
  #endif
--- 3474,3480 ----
  #if defined (JOB_CONTROL)
    old_pipeline_pgrp = pipeline_pgrp;
!   /* Don't reset the pipeline pgrp if we're already a subshell in a pipeline. */
!   if ((subshell_environment & SUBSHELL_PIPE) == 0)
!     pipeline_pgrp = shell_pgrp;
    cleanup_the_pipeline ();
  #endif
***************
*** 3425,3433 ****
      {
        set_sigint_handler ();	/* XXX */
! #if 0
! #if defined (JOB_CONTROL)
!       set_job_control (0);
! #endif
! #endif
        if (dup2 (fildes[1], 1) < 0)
  	{
--- 3506,3510 ----
      {
        set_sigint_handler ();	/* XXX */
! 
        if (dup2 (fildes[1], 1) < 0)
  	{
***************
*** 3456,3463 ****
  
        /* This is a subshell environment. */
!       subshell_environment = SUBSHELL_COMSUB;
  
!       /* Command substitution does not inherit the -e flag. */
!       exit_immediately_on_error = 0;
  
        remove_quoted_escapes (string);
--- 3533,3542 ----
  
        /* This is a subshell environment. */
!       subshell_environment |= SUBSHELL_COMSUB;
  
!       /* When not in POSIX mode, command substitution does not inherit
!          the -e flag. */
!       if (posixly_correct == 0)
! 	exit_immediately_on_error = 0;
  
        remove_quoted_escapes (string);
***************
*** 3518,3524 ****
        if (interactive && pipeline_pgrp != (pid_t)0 && pipeline_pgrp != last_asynchronous_pid)
  #else
!       if (interactive && pipeline_pgrp != (pid_t)0 && subshell_environment != SUBSHELL_ASYNC)
  #endif
! 	give_terminal_to (pipeline_pgrp);
  #endif /* JOB_CONTROL */
  
--- 3597,3603 ----
        if (interactive && pipeline_pgrp != (pid_t)0 && pipeline_pgrp != last_asynchronous_pid)
  #else
!       if (interactive && pipeline_pgrp != (pid_t)0 && (subshell_environment & SUBSHELL_ASYNC) == 0)
  #endif
! 	give_terminal_to (pipeline_pgrp, 0);
  #endif /* JOB_CONTROL */
  
***************
*** 3543,3547 ****
    int r, len;
  
!   t = strchr (name, '[');
    if (t)
      {
--- 3622,3626 ----
    int r, len;
  
!   t = strchr (name, '[');	/* ] */
    if (t)
      {
***************
*** 3581,3585 ****
    free (exp);
    if (expok == 0)
!     jump_to_top_level (DISCARD);
    return val;
  }
--- 3660,3667 ----
    free (exp);
    if (expok == 0)
!     {
!       last_command_exit_value = EXECUTION_FAILURE;
!       jump_to_top_level (DISCARD);
!     }
    return val;
  }
***************
*** 3608,3612 ****
    *t = '\0';
    var = find_variable (s);
!   *t++ = '[';
  
    if (subp)
--- 3690,3694 ----
    *t = '\0';
    var = find_variable (s);
!   *t++ = '[';		/* ] */
  
    if (subp)
***************
*** 3632,3652 ****
      return (char *)NULL;
  
    if (ALL_ELEMENT_SUB (t[0]) && t[1] == ']')
      {
!       if (array_p (var) == 0 || allow_all == 0)
!         {
!           report_error ("%s: bad array subscript", s);
!           return ((char *)NULL);
!         }
!       l = array_to_word_list (array_cell (var));
!       if (l == (WORD_LIST *)NULL)
! 	return ((char *) NULL);
  
- #if 0
-       if (t[0] == '*')		/* ${name[*]} */
- 	retval = (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) ? string_list_dollar_star (l) : string_list (l);
-       else			/* ${name[@]} */
- 	retval = string_list ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) ? quote_list (l) : l);
- #else
        if (t[0] == '*' && (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)))
  	{
--- 3714,3737 ----
      return (char *)NULL;
  
+   /* [ */
    if (ALL_ELEMENT_SUB (t[0]) && t[1] == ']')
      {
!       if (allow_all == 0)
! 	{
! 	  report_error ("%s: bad array subscript", s);
! 	  return ((char *)NULL);
! 	}
!       else if (array_p (var) == 0)
! 	{
! 	  l = (WORD_LIST *)NULL;
! 	  l = add_string_to_list (value_cell (var), l);
! 	}
!       else
! 	{
! 	  l = array_to_word_list (array_cell (var));
! 	  if (l == (WORD_LIST *)NULL)
! 	    return ((char *) NULL);
! 	}
  
        if (t[0] == '*' && (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)))
  	{
***************
*** 3657,3661 ****
        else	/* ${name[@]} or unquoted ${name[*]} */
  	retval = string_list_dollar_at (l, quoted);
- #endif
  
        dispose_words (l);
--- 3742,3745 ----
***************
*** 3670,3674 ****
  	}
        if (array_p (var) == 0)
!         return (ind == 0 ? savestring (value_cell (var)) : (char *)NULL);
        retval = array_reference (array_cell (var), ind);
        if (retval)
--- 3754,3758 ----
  	}
        if (array_p (var) == 0)
! 	return (ind == 0 ? savestring (value_cell (var)) : (char *)NULL);
        retval = array_reference (array_cell (var), ind);
        if (retval)
***************
*** 3722,3732 ****
    else if (var == 0)
      return 0;
-   else if (array_p (var) == 0)
-     return 1;
  
!   array = array_cell (var);
  
    if (ALL_ELEMENT_SUB (t[0]) && t[1] == ']')
!     return (array_num_elements (array));
  
    ind = array_expand_index (t, len);
--- 3806,3818 ----
    else if (var == 0)
      return 0;
  
!   /* We support a couple of expansions for variables that are not arrays.
!      We'll return the length of the value for v[0], and 1 for v[@] or
!      v[*].  Return 0 for everything else. */
! 
!   array = array_p (var) ? array_cell (var) : (ARRAY *)NULL;
  
    if (ALL_ELEMENT_SUB (t[0]) && t[1] == ']')
!     return (array_p (var) ? array_num_elements (array) : 1);
  
    ind = array_expand_index (t, len);
***************
*** 3736,3742 ****
        return (-1);
      }
-   t = array_reference (array, ind);
-   len = STRLEN (t);
  
    return (len);
  }
--- 3822,3832 ----
        return (-1);
      }
  
+   if (array_p (var))
+     t = array_reference (array, ind);
+   else
+     t = (ind == 0) ? value_cell (var) : (char *)NULL;
+ 
+   len = STRLEN (t);
    return (len);
  }
***************
*** 3748,3752 ****
       int var_is_special;
  {
!   if (digit (*name) && all_digits (name))
      return 1;
    else if (var_is_special)
--- 3838,3842 ----
       int var_is_special;
  {
!   if (isdigit (*name) && all_digits (name))
      return 1;
    else if (var_is_special)
***************
*** 3778,3782 ****
  
    /* Handle multiple digit arguments, as in ${11}. */
!   if (digit (*name))
      {
        arg_index = atoi (name);
--- 3868,3872 ----
  
    /* Handle multiple digit arguments, as in ${11}. */
!   if (isdigit (*name))
      {
        arg_index = atoi (name);
***************
*** 3809,3813 ****
      {
        if (var && invisible_p (var) == 0)
!         {
  #if defined (ARRAY_VARS)
  	  temp = array_p (var) ? array_reference (array_cell (var), 0) : value_cell (var);
--- 3899,3903 ----
      {
        if (var && invisible_p (var) == 0)
! 	{
  #if defined (ARRAY_VARS)
  	  temp = array_p (var) ? array_reference (array_cell (var), 0) : value_cell (var);
***************
*** 3821,3825 ****
  	  if (tempvar_p (var))
  	    dispose_variable (var);
!         }
        else
  	temp = (char *)NULL;
--- 3911,3915 ----
  	  if (tempvar_p (var))
  	    dispose_variable (var);
! 	}
        else
  	temp = (char *)NULL;
***************
*** 3866,3870 ****
  
    temp = (*value == '~' || (strchr (value, '~') && unquoted_substring ("=~", value)))
!         ? bash_tilde_expand (value)
  	: savestring (value);
  
--- 3956,3960 ----
  
    temp = (*value == '~' || (strchr (value, '~') && unquoted_substring ("=~", value)))
! 	? bash_tilde_expand (value)
  	: savestring (value);
  
***************
*** 3936,3940 ****
    if (value && *value)
      {
!       l = expand_string (value, 0);
        temp =  string_list (l);
        report_error ("%s: %s", name, temp ? temp : "");	/* XXX was value not "" */
--- 4026,4035 ----
    if (value && *value)
      {
!       temp = (*value == '~' || (strchr (value, '~') && unquoted_substring ("=~", value)))
! 		? bash_tilde_expand (value)
! 		: savestring (value);
! 
!       l = expand_string (temp, 0);
!       FREE (temp);
        temp =  string_list (l);
        report_error ("%s: %s", name, temp ? temp : "");	/* XXX was value not "" */
***************
*** 3957,3964 ****
       char *name;
  {
!   return (!name[1] ||						/* ${#} */
! 	  ((name[1] == '@' || name[1] == '*') && !name[2]) ||	/* ${#@}, ${#*} */
! 	  (member (name[1], "-?$!#") && !name[2]) ||		/* ${#-}, etc. */
! 	  (digit (name[1]) && all_digits (name + 1)) ||		/* ${#11} */
  #if defined (ARRAY_VARS)
  	  valid_array_reference (name + 1) ||			/* ${#a[7]} */
--- 4052,4058 ----
       char *name;
  {
!   return (name[1] == '\0' ||					/* ${#} */
! 	  ((sh_syntaxtab[name[1]] & CSPECVAR) && name[2] == '\0') ||  /* special param */
! 	  (isdigit (name[1]) && all_digits (name + 1)) ||	/* ${#11} */
  #if defined (ARRAY_VARS)
  	  valid_array_reference (name + 1) ||			/* ${#a[7]} */
***************
*** 3984,3988 ****
    else if ((name[1] == '@' || name[1] == '*') && name[2] == '\0')	/* ${#@}, ${#*} */
      number = number_of_args ();
!   else if (member (name[1], "-?$!#") && name[2] == '\0')
      {
        /* Take the lengths of some of the shell's special parameters. */
--- 4078,4082 ----
    else if ((name[1] == '@' || name[1] == '*') && name[2] == '\0')	/* ${#@}, ${#*} */
      number = number_of_args ();
!   else if ((sh_syntaxtab[name[1]] & CSPECVAR) && name[2] == '\0')
      {
        /* Take the lengths of some of the shell's special parameters. */
***************
*** 4019,4023 ****
        number = 0;
  
!       if (digit (name[1]))		/* ${#1} */
  	{
  	  t = get_dollar_var_value (atoi (name + 1));
--- 4113,4117 ----
        number = 0;
  
!       if (isdigit (name[1]))		/* ${#1} */
  	{
  	  t = get_dollar_var_value (atoi (name + 1));
***************
*** 4050,4053 ****
--- 4144,4195 ----
  }
  
+ /* Skip characters in SUBSTR until DELIM.  SUBSTR is an arithmetic expression,
+    so we do some ad-hoc parsing of an arithmetic expression to find
+    the first DELIM, instead of using strchr(3).  Two rules:
+ 	1.  If the substring contains a `(', read until closing `)'.
+ 	2.  If the substring contains a `?', read past one `:' for each `?'.
+ */
+ 
+ static char *
+ skiparith (substr, delim)
+      char *substr;
+      int delim;
+ {
+   int skipcol, pcount;
+   char *t;
+ 
+   for (skipcol = pcount = 0, t = substr; *t; t++)
+     {
+       /* Balance parens */
+       if (*t == '(')
+ 	{
+ 	  pcount++;
+ 	  continue;
+ 	}
+       if (*t == ')' && pcount)
+ 	{
+ 	  pcount--;
+ 	  continue;
+ 	}
+       if (pcount)
+ 	continue;
+ 
+       /* Skip one `:' for each `?' */
+       if (*t == ':' && skipcol)
+ 	{
+ 	  skipcol--;
+ 	  continue;
+ 	}
+       if (*t == delim)
+ 	break;
+       if (*t == '?')
+ 	{
+ 	  skipcol++;
+ 	  continue;
+ 	}
+     }
+   return t;
+ }
+ 
  /* Verify and limit the start and end of the desired substring.  If
     VTYPE == 0, a regular shell variable is being used; if it is 1,
***************
*** 4067,4073 ****
--- 4209,4224 ----
  #endif
  
+ #if 1
+   /* duplicate behavior of strchr(3) */
+   t = skiparith (substr, ':');
+   if (*t && *t == ':')
+     *t = '\0'; 
+   else
+     t = (char *)0;
+ #else
    t = strchr (substr, ':');
    if (t)
      *t = '\0';
+ #endif
    temp1 = maybe_expand_string (substr, Q_DOUBLE_QUOTES, expand_string);
    *e1p = evalexp (temp1, &expok);
***************
*** 4109,4121 ****
        free (temp1);
        if (expok == 0)
!         return (0);
        if (*e2p < 0)
!         {
!           internal_error ("%s: substring expression < 0", t);
  	  return (0);
!         }
        *e2p += *e1p;		/* want E2 chars starting at E1 */
        if (*e2p > len)
!         *e2p = len;
      }
    else
--- 4260,4272 ----
        free (temp1);
        if (expok == 0)
! 	return (0);
        if (*e2p < 0)
! 	{
! 	  internal_error ("%s: substring expression < 0", t);
  	  return (0);
! 	}
        *e2p += *e1p;		/* want E2 chars starting at E1 */
        if (*e2p > len)
! 	*e2p = len;
      }
    else
***************
*** 4218,4221 ****
--- 4369,4374 ----
      case VT_ARRAYMEMBER:
        temp = quoted ? quoted_substring (value, e1, e2) : substring (value, e1, e2);
+       if (val && vtype == VT_ARRAYMEMBER)
+ 	free (val);
        break;
      case VT_POSPARMS:
***************
*** 4286,4291 ****
        /* OK, now copy the leading unmatched portion of the string (from
  	 str to s) to ret starting at rptr (the current offset).  Then copy
!          the replacement string at ret + rptr + (s - str).  Increment
!          rptr (if necessary) and str and go on. */
        if (l)
  	{
--- 4439,4444 ----
        /* OK, now copy the leading unmatched portion of the string (from
  	 str to s) to ret starting at rptr (the current offset).  Then copy
! 	 the replacement string at ret + rptr + (s - str).  Increment
! 	 rptr (if necessary) and str and go on. */
        if (l)
  	{
***************
*** 4298,4304 ****
  	  rptr += replen;
  	}
        str = e;		/* e == end of match */
        if (((mflags & MATCH_GLOBREP) == 0) || mtype != MATCH_ANY)
!         break;
      }
  
--- 4451,4459 ----
  	  rptr += replen;
  	}
+       if (s == e)
+ 	e++;		/* avoid infinite recursion on zero-length match */
        str = e;		/* e == end of match */
        if (((mflags & MATCH_GLOBREP) == 0) || mtype != MATCH_ANY)
! 	break;
      }
  
***************
*** 4401,4405 ****
  	rep = maybe_expand_string (rep, quoted, expand_string_unsplit);
        else
!         rep = expand_string_to_string (rep, quoted, expand_string_unsplit);
      }
  
--- 4556,4560 ----
  	rep = maybe_expand_string (rep, quoted, expand_string_unsplit);
        else
! 	rep = expand_string_to_string (rep, quoted, expand_string_unsplit);
      }
  
***************
*** 4481,4488 ****
  	 string[t_index] == '#')) ||
        (sindex == t_index - 1 && string[sindex] == '!' &&
!         (string[t_index] == '#' ||
!          string[t_index] == '?' ||
!          string[t_index] == '@' ||
!          string[t_index] == '*')))
      {
        t_index++;
--- 4636,4643 ----
  	 string[t_index] == '#')) ||
        (sindex == t_index - 1 && string[sindex] == '!' &&
! 	(string[t_index] == '#' ||
! 	 string[t_index] == '?' ||
! 	 string[t_index] == '@' ||
! 	 string[t_index] == '*')))
      {
        t_index++;
***************
*** 4493,4499 ****
        if (string[sindex] == '!')
  	{
!           /* indirect reference of $#, $?, $@, or $* */
!           name[1] = string[sindex + 1];
!           strcpy (name + 2, temp1);
  	}
        else	
--- 4648,4654 ----
        if (string[sindex] == '!')
  	{
! 	  /* indirect reference of $#, $?, $@, or $* */
! 	  name[1] = string[sindex + 1];
! 	  strcpy (name + 2, temp1);
  	}
        else	
***************
*** 4512,4516 ****
       a substring specification is being given, and do not move
       past it. */
!   if (c == ':' && member (string[sindex], "-=?+"))
      {
        check_nullness++;
--- 4667,4671 ----
       a substring specification is being given, and do not move
       past it. */
!   if (c == ':' && VALID_PARAM_EXPAND_CHAR (string[sindex]))
      {
        check_nullness++;
***************
*** 4528,4532 ****
       Similarly for ${#?} and ${##}... */
    if (name[0] == '#' && name[1] == '\0' && check_nullness == 0 &&
! 	member (c, "-?#") && string[sindex] == RBRACE)
      {
        name = xrealloc (name, 3);
--- 4683,4687 ----
       Similarly for ${#?} and ${##}... */
    if (name[0] == '#' && name[1] == '\0' && check_nullness == 0 &&
! 	VALID_SPECIAL_LENGTH_PARAM (c) && string[sindex] == RBRACE)
      {
        name = xrealloc (name, 3);
***************
*** 4548,4552 ****
       variable that expands to one of the positional parameters. */
    want_indir = *name == '!' &&
!     (legal_variable_starter (name[1]) || digit (name[1]) || member (name[1], "#?@*"));
  
    /* Determine the value of this variable. */
--- 4703,4708 ----
       variable that expands to one of the positional parameters. */
    want_indir = *name == '!' &&
!     (legal_variable_starter (name[1]) || isdigit (name[1])
! 				      || VALID_INDIR_PARAM (name[1]));
  
    /* Determine the value of this variable. */
***************
*** 4560,4567 ****
      {
        /* If we are not pointing at the character just after the
!          closing brace, then we haven't gotten all of the name.
!          Since it begins with a special character, this is a bad
!          substitution.  Also check NAME for validity before trying
!          to go on. */
        if (string[sindex - 1] != RBRACE || (valid_length_expression (name) == 0))
  	{
--- 4716,4723 ----
      {
        /* If we are not pointing at the character just after the
! 	 closing brace, then we haven't gotten all of the name.
! 	 Since it begins with a special character, this is a bad
! 	 substitution.  Also check NAME for validity before trying
! 	 to go on. */
        if (string[sindex - 1] != RBRACE || (valid_length_expression (name) == 0))
  	{
***************
*** 4600,4604 ****
        x = all_variables_matching_prefix (temp1);
        xlist = argv_to_word_list (x, 1, 0);
!       temp = string_list_dollar_star (xlist, quoted);
        free (x);
        free (xlist);
--- 4756,4769 ----
        x = all_variables_matching_prefix (temp1);
        xlist = argv_to_word_list (x, 1, 0);
!       if (string[sindex - 2] == '*')
! 	temp = string_list_dollar_star (xlist);
!       else
! 	{
! 	  temp = string_list_dollar_at (xlist, quoted);
! 	  if ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) && quoted_dollar_atp)
! 	    *quoted_dollar_atp = 1;
! 	  if (contains_dollar_at)
! 	    *contains_dollar_at = 1;
! 	}
        free (x);
        free (xlist);
***************
*** 4622,4634 ****
  
  #if defined (ARRAY_VARS)
- #if 0
-   if ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) && valid_array_reference (name))
- #else
    if (valid_array_reference (name))
- #endif
      {
        temp1 = strchr (name, '[');
        if (temp1 && temp1[1] == '@' && temp1[2] == ']')
!         {
    	  if ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) && quoted_dollar_atp)
  	    *quoted_dollar_atp = 1;
--- 4787,4795 ----
  
  #if defined (ARRAY_VARS)
    if (valid_array_reference (name))
      {
        temp1 = strchr (name, '[');
        if (temp1 && temp1[1] == '@' && temp1[2] == ']')
! 	{
    	  if ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) && quoted_dollar_atp)
  	    *quoted_dollar_atp = 1;
***************
*** 4653,4660 ****
      {
        /* Extract the contents of the ${ ... } expansion
!          according to the Posix.2 rules. */
        value = extract_dollar_brace_string (string, &sindex, quoted);
        if (string[sindex] == RBRACE)
!         sindex++;
        else
  	goto bad_substitution;
--- 4814,4821 ----
      {
        /* Extract the contents of the ${ ... } expansion
! 	 according to the Posix.2 rules. */
        value = extract_dollar_brace_string (string, &sindex, quoted);
        if (string[sindex] == RBRACE)
! 	sindex++;
        else
  	goto bad_substitution;
***************
*** 4697,4701 ****
      case RBRACE:
        if (var_is_set == 0 && unbound_vars_is_error)
!         {
  	  report_error ("%s: unbound variable", name);
  	  FREE (value);
--- 4858,4862 ----
      case RBRACE:
        if (var_is_set == 0 && unbound_vars_is_error)
! 	{
  	  report_error ("%s: unbound variable", name);
  	  FREE (value);
***************
*** 4710,4717 ****
      case '%':	/* ${param%[%]pattern} */
        if (value == 0 || *value == '\0' || temp == 0 || *temp == '\0')
!         {
!           FREE (value);
  	  break;
!         }
        if ((name[0] == '@' || name[0] == '*') && name[1] == '\0')
  	temp1 = parameter_list_remove_pattern (value, name[0], c, quoted);
--- 4871,4878 ----
      case '%':	/* ${param%[%]pattern} */
        if (value == 0 || *value == '\0' || temp == 0 || *temp == '\0')
! 	{
! 	  FREE (value);
  	  break;
! 	}
        if ((name[0] == '@' || name[0] == '*') && name[1] == '\0')
  	temp1 = parameter_list_remove_pattern (value, name[0], c, quoted);
***************
*** 4732,4752 ****
      case '+':
        if (var_is_set && var_is_null == 0)
!         {
! 	  /* We don't want the value of the named variable for
! 	     anything, just the value of the right hand side. */
! 
! 	  /* XXX -- if we're double-quoted and the named variable is "$@",
! 	     we want to turn off any special handling of "$@" -- we're not
! 	     using it, so whatever is on the rhs applies. */
! 	  if ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) && quoted_dollar_atp)
! 	    *quoted_dollar_atp = 0;
! 	  if (contains_dollar_at)
! 	    *contains_dollar_at = 0;
  
  	  if (c == '+')
  	    {
  	      FREE (temp);
  	      if (value)
! 	        {
  		  temp = parameter_brace_expand_rhs (name, value, c,
  						     quoted,
--- 4893,4913 ----
      case '+':
        if (var_is_set && var_is_null == 0)
! 	{
! 	  /* If the operator is `+', we don't want the value of the named
! 	     variable for anything, just the value of the right hand side. */
  
  	  if (c == '+')
  	    {
+ 	      /* XXX -- if we're double-quoted and the named variable is "$@",
+ 			we want to turn off any special handling of "$@" --
+ 			we're not using it, so whatever is on the rhs applies. */
+ 	      if ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) && quoted_dollar_atp)
+ 		*quoted_dollar_atp = 0;
+ 	      if (contains_dollar_at)
+ 		*contains_dollar_at = 0;
+ 
  	      FREE (temp);
  	      if (value)
! 		{
  		  temp = parameter_brace_expand_rhs (name, value, c,
  						     quoted,
***************
*** 4756,4760 ****
  		}
  	      else
! 	        temp = (char *)NULL;
  	    }
  	  else
--- 4917,4921 ----
  		}
  	      else
! 		temp = (char *)NULL;
  	    }
  	  else
***************
*** 4765,4769 ****
  	}
        else	/* VAR not set or VAR is NULL. */
!         {
  	  FREE (temp);
  	  temp = (char *)NULL;
--- 4926,4930 ----
  	}
        else	/* VAR not set or VAR is NULL. */
! 	{
  	  FREE (temp);
  	  temp = (char *)NULL;
***************
*** 4778,4789 ****
  	    {
  	      parameter_brace_expand_error (name, value);
! 	      return (interactive ? &expand_param_error : &expand_param_fatal);
  	    }
  	  else if (c != '+')
! 	    temp = parameter_brace_expand_rhs (name, value, c, quoted,
! 					       quoted_dollar_atp,
! 					       contains_dollar_at);
  	  free (value);
  	}
        break;
      }
--- 4939,4961 ----
  	    {
  	      parameter_brace_expand_error (name, value);
! 	      return (interactive_shell ? &expand_param_error : &expand_param_fatal);
  	    }
  	  else if (c != '+')
! 	    {
! 	      /* XXX -- if we're double-quoted and the named variable is "$@",
! 			we want to turn off any special handling of "$@" --
! 			we're not using it, so whatever is on the rhs applies. */
! 	      if ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) && quoted_dollar_atp)
! 		*quoted_dollar_atp = 0;
! 	      if (contains_dollar_at)
! 		*contains_dollar_at = 0;
! 
! 	      temp = parameter_brace_expand_rhs (name, value, c, quoted,
! 						 quoted_dollar_atp,
! 						 contains_dollar_at);
! 	    }
  	  free (value);
  	}
+ 
        break;
      }
***************
*** 4900,4909 ****
  	}
        else
!         {
!           /* If the $* is not quoted it is identical to $@ */
!           temp = string_list_dollar_at (list, quoted);
!           if (contains_dollar_at)
!             *contains_dollar_at = 1;
!         }
  
        dispose_words (list);
--- 5072,5081 ----
  	}
        else
! 	{
! 	  /* If the $* is not quoted it is identical to $@ */
! 	  temp = string_list_dollar_at (list, quoted);
! 	  if (expand_no_split_dollar_star == 0 && contains_dollar_at)
! 	    *contains_dollar_at = 1;
! 	}
  
        dispose_words (list);
***************
*** 4949,4959 ****
        /* Note that we saw the quoted null so we can add one back at
  	 the end of this function if there are no other characters
! 	 in the string, discard TEMP, and go on. */
        if (temp && QUOTED_NULL (temp))
  	{
  	  if (had_quoted_null_p)
  	    *had_quoted_null_p = 1;
! 	  free (temp);
! 	  temp = (char *)NULL;
  	}
  
--- 5121,5137 ----
        /* Note that we saw the quoted null so we can add one back at
  	 the end of this function if there are no other characters
! 	 in the string, discard TEMP, and go on.  The exception to
! 	 this is when we have "${@}" and $1 is '', since $@ needs
! 	 special handling. */
        if (temp && QUOTED_NULL (temp))
  	{
  	  if (had_quoted_null_p)
  	    *had_quoted_null_p = 1;
! 	  if (*quoted_dollar_at_p == 0)
! 	    {
! 	      free (temp);
! 	      temp = (char *)NULL;
! 	    }
! 	    
  	}
  
***************
*** 4968,4972 ****
  
        /* For Posix.2-style `$(( ))' arithmetic substitution,
!          extract the expression and pass it to the evaluator. */
        if (temp && *temp == LPAREN)
  	{
--- 5146,5150 ----
  
        /* For Posix.2-style `$(( ))' arithmetic substitution,
! 	 extract the expression and pass it to the evaluator. */
        if (temp && *temp == LPAREN)
  	{
***************
*** 5162,5165 ****
--- 5340,5344 ----
    int had_quoted_null;
    int has_dollar_at;
+   int tflag;
  
    register int c;		/* Current character. */
***************
*** 5301,5311 ****
  
  	  if (quoted & Q_HERE_DOCUMENT)
! 	    temp1 = slashify_in_here_document;
  	  else if (quoted & Q_DOUBLE_QUOTES)
! 	    temp1 = slashify_in_quotes;
  	  else
! 	    temp1 = "";
  
! 	  if ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) && member (c, temp1) == 0)
  	    {
  	      twochars[0] = '\\';
--- 5480,5491 ----
  
  	  if (quoted & Q_HERE_DOCUMENT)
! 	    tflag = CBSHDOC;
  	  else if (quoted & Q_DOUBLE_QUOTES)
! 	    tflag = CBSDQUOTE;
  	  else
! 	    tflag = 0;
! 
  
! 	  if ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) && ((sh_syntaxtab[c] & tflag) == 0))
  	    {
  	      twochars[0] = '\\';
***************
*** 5602,5606 ****
  	tword->flags |= W_NOGLOB;	/* XXX */
        if (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES))
!         tword->flags |= W_QUOTED;
      }
    else
--- 5782,5786 ----
  	tword->flags |= W_NOGLOB;	/* XXX */
        if (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES))
! 	tword->flags |= W_QUOTED;
      }
    else
***************
*** 5660,5664 ****
  	case '\\':
  	  c = string[++sindex];
! 	  if (((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) || dquote) && member (c, slashify_in_quotes) == 0)
  	    *r++ = '\\';
  	  /* FALLTHROUGH */
--- 5840,5844 ----
  	case '\\':
  	  c = string[++sindex];
! 	  if (((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) || dquote) && (sh_syntaxtab[c] & CBSDQUOTE) == 0)
  	    *r++ = '\\';
  	  /* FALLTHROUGH */
***************
*** 5977,5986 ****
  
        /* If the word isn't an assignment and contains an unquoted
!          pattern matching character, then glob it. */
! #if 0
!       if ((tlist->word->flags & W_ASSIGNMENT) == 0 &&
! #else
        if ((tlist->word->flags & W_NOGLOB) == 0 &&
- #endif
  	  unquoted_glob_pattern_p (tlist->word->word))
  	{
--- 6157,6162 ----
  
        /* If the word isn't an assignment and contains an unquoted
! 	 pattern matching character, then glob it. */
        if ((tlist->word->flags & W_NOGLOB) == 0 &&
  	  unquoted_glob_pattern_p (tlist->word->word))
  	{
***************
*** 6160,6163 ****
--- 6336,6340 ----
  	  dispose_words (new_list);
  
+ 	  last_command_exit_value = EXECUTION_FAILURE;
  	  if (expanded == &expand_word_error)
  	    jump_to_top_level (DISCARD);
***************
*** 6233,6240 ****
  		  /* Variable assignment errors in non-interactive shells
  		     running in Posix.2 mode cause the shell to exit. */
! 		  if (tint == 0 && interactive_shell == 0 && posixly_correct)
  		    {
  		      last_command_exit_value = EXECUTION_FAILURE;
! 		      jump_to_top_level (FORCE_EOF);
  		    }
  		}
--- 6410,6420 ----
  		  /* Variable assignment errors in non-interactive shells
  		     running in Posix.2 mode cause the shell to exit. */
! 		  if (tint == 0)
  		    {
  		      last_command_exit_value = EXECUTION_FAILURE;
! 		      if (interactive_shell == 0 && posixly_correct)
! 			jump_to_top_level (FORCE_EOF);
! 		      else
! 			jump_to_top_level (DISCARD);
  		    }
  		}
***************
*** 6288,6296 ****
  	  /* Variable assignment errors in non-interactive shells running
  	     in Posix.2 mode cause the shell to exit. */
! 	  if (tint == 0 && assign_func == do_assignment &&
! 		interactive_shell == 0 && posixly_correct)
  	    {
  	      last_command_exit_value = EXECUTION_FAILURE;
! 	      jump_to_top_level (FORCE_EOF);
  	    }
  	}
--- 6468,6478 ----
  	  /* Variable assignment errors in non-interactive shells running
  	     in Posix.2 mode cause the shell to exit. */
! 	  if (tint == 0 && assign_func == do_assignment)
  	    {
  	      last_command_exit_value = EXECUTION_FAILURE;
! 	      if (interactive_shell == 0 && posixly_correct)
! 		jump_to_top_level (FORCE_EOF);
! 	      else
! 		jump_to_top_level (DISCARD);
  	    }
  	}
diff -Nrc2 bash-2.04/subst.h bash-2.05/subst.h
*** bash-2.04/subst.h	Fri Nov 19 16:25:33 1999
--- bash-2.05/subst.h	Sat Oct 14 17:46:02 2000
***************
*** 24,27 ****
--- 24,41 ----
  #include "stdc.h"
  
+ /* Constants which specify how to handle backslashes and quoting in
+    expand_word_internal ().  Q_DOUBLE_QUOTES means to use the function
+    slashify_in_quotes () to decide whether the backslash should be
+    retained.  Q_HERE_DOCUMENT means slashify_in_here_document () to
+    decide whether to retain the backslash.  Q_KEEP_BACKSLASH means
+    to unconditionally retain the backslash. */
+ #define Q_DOUBLE_QUOTES  0x1
+ #define Q_HERE_DOCUMENT  0x2
+ #define Q_KEEP_BACKSLASH 0x4
+ #define Q_NOQUOTE	 0x8
+ #define Q_QUOTED	 0x10
+ #define Q_ADDEDQUOTES	 0x20
+ #define Q_QUOTEDNULL	 0x40
+ 
  /* Cons a new string from STRING starting at START and ending at END,
     not including END. */
***************
*** 130,134 ****
     does parameter expansion, command substitution, arithmetic expansion,
     and quote removal. */
! extern WORD_LIST *expand_word_no_split __P((WORD_DESC *, int));
  extern WORD_LIST *expand_word_leave_quoted __P((WORD_DESC *, int));
  
--- 144,148 ----
     does parameter expansion, command substitution, arithmetic expansion,
     and quote removal. */
! extern WORD_LIST *expand_word_unsplit __P((WORD_DESC *, int));
  extern WORD_LIST *expand_word_leave_quoted __P((WORD_DESC *, int));
  
diff -Nrc2 bash-2.04/support/bashbug.sh bash-2.05/support/bashbug.sh
*** bash-2.04/support/bashbug.sh	Mon Nov 29 16:43:02 1999
--- bash-2.05/support/bashbug.sh	Wed Mar 28 08:19:45 2001
***************
*** 22,26 ****
--- 22,36 ----
  export PATH
  
+ # If the OS supplies a program to make temp files with semi-random names,
+ # use it.
  TEMP=/tmp/bbug.$$
+ for d in /bin /usr/bin /usr/local/bin ; do
+ 	if [ -x $d/mktemp ]; then
+ 		TEMP=`$d/mktemp -t bbug ` ; break;
+ 	elif [ -x $d/tempfile ]; then
+ 		TEMP=` $d/tempfile --prefix bbug --mode 600 `; break
+ 	fi
+ done
+ 
  USAGE="Usage: $0 [--help] [--version] [bug-report-email-address]"
  VERSTR="GNU bashbug, version ${RELEASE}.${PATCHLEVEL}-${RELSTATUS}"
***************
*** 92,96 ****
  
  if [ -z "$DEFEDITOR" ] && [ -z "$EDITOR" ]; then
! 	if [ -x /usr/local/bin/ce ]; then
  		DEFEDITOR=ce
  	elif [ -x /usr/local/bin/emacs ]; then
--- 102,108 ----
  
  if [ -z "$DEFEDITOR" ] && [ -z "$EDITOR" ]; then
! 	if [ -x /usr/bin/editor ]; then
! 		DEFEDITOR=editor
! 	elif [ -x /usr/local/bin/ce ]; then
  		DEFEDITOR=ce
  	elif [ -x /usr/local/bin/emacs ]; then
diff -Nrc2 bash-2.04/support/config.guess bash-2.05/support/config.guess
*** bash-2.04/support/config.guess	Tue Nov 30 16:10:14 1999
--- bash-2.05/support/config.guess	Mon Dec 18 10:43:18 2000
***************
*** 169,176 ****
  	echo intel-pc-opennt
  	exit 0 ;;
      # end cases added for Bash
      alpha:OSF1:*:*)
! 	if test $UNAME_RELEASE = "V4.0"; then
  		UNAME_RELEASE=`/usr/sbin/sizer -v | awk '{print $3}'`
  	fi
  	# A Vn.n version is a released version.
--- 169,183 ----
  	echo intel-pc-opennt
  	exit 0 ;;
+     *:NonStop-UX:*:*)
+ 	echo mips-compaq-nonstopux
+ 	exit 0 ;;
      # end cases added for Bash
      alpha:OSF1:*:*)
! 	# TEST CHANGED FOR BASH to handle `letter version' releases
! 	UNAME_MAJOR=`echo "$UNAME_RELEASE" | sed -e 's/^.\([0-9]\).*/\1/'`
! 	if test X"$UNAME_MAJOR" != X"" && test $UNAME_MAJOR = 4 ; then
  		UNAME_RELEASE=`/usr/sbin/sizer -v | awk '{print $3}'`
+ 	elif test X"$UNAME_MAJOR" != X"" && test $UNAME_MAJOR -gt 4 ; then
+ 		UNAME_RELEASE=`/usr/sbin/sizer -v | awk '{print $4}'`		
  	fi
  	# A Vn.n version is a released version.
***************
*** 704,708 ****
  	exit 0 ;;
      i*:CYGWIN*:*)
! 	echo ${UNAME_MACHINE}-pc-cygwin32
  	exit 0 ;;
      i*:MINGW*:*)
--- 711,715 ----
  	exit 0 ;;
      i*:CYGWIN*:*)
! 	echo ${UNAME_MACHINE}-pc-cygwin
  	exit 0 ;;
      i*:MINGW*:*)
***************
*** 1058,1061 ****
--- 1065,1074 ----
      *:Rhapsody:*:*)
  	echo ${UNAME_MACHINE}-apple-rhapsody${UNAME_RELEASE}
+ 	exit 0 ;;
+     Power*:Darwin:*:*)
+ 	echo powerpc-apple-darwin${UNAME_RELEASE}
+ 	exit 0 ;;
+     *:Darwin:*:*)
+ 	echo ${UNAME_MACHINE}-apple-darwin${UNAME_RELEASE}
  	exit 0 ;;
  esac
diff -Nrc2 bash-2.04/support/config.sub bash-2.05/support/config.sub
*** bash-2.04/support/config.sub	Tue Nov 30 16:53:37 1999
--- bash-2.05/support/config.sub	Mon Feb 12 12:50:05 2001
***************
*** 174,178 ****
  		| mips64vr5000 | miprs64vr5000el | mcore \
  		| sparc | sparclet | sparclite | sparc64 | sparcv9 | v850 | c4x \
! 	        | thumb | d10v)
  		basic_machine=$basic_machine-unknown
  		;;
--- 174,178 ----
  		| mips64vr5000 | miprs64vr5000el | mcore \
  		| sparc | sparclet | sparclite | sparc64 | sparcv9 | v850 | c4x \
! 	        | thumb | d10v | s390)
  		basic_machine=$basic_machine-unknown
  		;;
***************
*** 677,680 ****
--- 677,684 ----
  		basic_machine=romp-ibm
  		;;
+ 	s390-*)
+ 		basic_machine=s390-ibm
+ 		os=-linux
+ 		;;
          sa29200)
                  basic_machine=a29k-amd
***************
*** 947,951 ****
  	      | -ptx* | -coff* | -ecoff* | -winnt* | -domain* | -vsta* \
  	      | -udi* | -eabi* | -lites* | -ieee* | -go32* | -aux* \
! 	      | -cygwin32* | -pe* | -psos* | -moss* | -proelf* | -rtems* \
  	      | -mingw32* | -linux-gnu* | -uxpv* | -beos* | -mpeix* | -udk* \
  	      | -interix* | -uwin* | -rhapsody* | -openstep* | -oskit*)
--- 951,955 ----
  	      | -ptx* | -coff* | -ecoff* | -winnt* | -domain* | -vsta* \
  	      | -udi* | -eabi* | -lites* | -ieee* | -go32* | -aux* \
! 	      | -cygwin* | -pe* | -psos* | -moss* | -proelf* | -rtems* \
  	      | -mingw32* | -linux-gnu* | -uxpv* | -beos* | -mpeix* | -udk* \
  	      | -interix* | -uwin* | -rhapsody* | -openstep* | -oskit*)
***************
*** 953,957 ****
  		;;
  	# BEGIN CASES ADDED FOR Bash
! 	-qnx* | -powerux* | -superux* )
  		;;
  	# END CASES ADDED FOR Bash
--- 957,961 ----
  		;;
  	# BEGIN CASES ADDED FOR Bash
! 	-qnx* | -powerux* | -superux* | -darwin* | -nonstopux*)
  		;;
  	# END CASES ADDED FOR Bash
diff -Nrc2 bash-2.04/support/mksignames.c bash-2.05/support/mksignames.c
*** bash-2.04/support/mksignames.c	Wed Dec 29 14:58:31 1999
--- bash-2.05/support/mksignames.c	Tue Mar 28 10:12:40 2000
***************
*** 35,40 ****
--- 35,51 ----
  char *signal_names[2 * NSIG];
  
+ #define signal_names_size (sizeof(signal_names)/sizeof(signal_names[0]))
+ 
  char *progname;
  
+ /* AIX 4.3 defines SIGRTMIN and SIGRTMAX as 888 and 999 respectively.
+    I don't want to allocate so much unused space for the intervening signal
+    numbers, so we just punt if SIGRTMAX is past the bounds of the
+    signal_names array (handled in configure). */
+ #if defined (SIGRTMAX) && defined (UNUSABLE_RT_SIGNALS)
+ #  undef SIGRTMAX
+ #  undef SIGRTMIN
+ #endif
+ 
  #if defined (SIGRTMAX) || defined (SIGRTMIN)
  #  define RTLEN 14
***************
*** 50,54 ****
  #endif
  
!   for (i = 1; i < sizeof(signal_names)/sizeof(signal_names[0]); i++)
      signal_names[i] = (char *)NULL;
  
--- 61,65 ----
  #endif
  
!   for (i = 1; i < signal_names_size; i++)
      signal_names[i] = (char *)NULL;
  
diff -Nrc2 bash-2.04/support/rlvers.sh bash-2.05/support/rlvers.sh
*** bash-2.04/support/rlvers.sh	Thu Jan 20 16:22:31 2000
--- bash-2.05/support/rlvers.sh	Tue Jan 23 12:54:15 2001
***************
*** 6,20 ****
  
  PROGNAME=`basename $0`
! TDIR=/tmp/rlvers
  
  # defaults
  CC=cc
  RL_LIBDIR=/usr/local/lib
  
  TERMCAP_LIB="-ltermcap"
  
  while [ $# -gt 0 ]; do
  	case "$1" in
  	-C)	shift ; CC="$1"; shift ;;
  	-L)	shift ; RL_LIBDIR="$1" ; shift ;;
  	-T)	shift ; TERMCAP_LIB="$1" ; shift ;;
--- 6,25 ----
  
  PROGNAME=`basename $0`
! 
! : ${TMPDIR:=/tmp}
! TDIR=$TMPDIR/rlvers
  
  # defaults
  CC=cc
  RL_LIBDIR=/usr/local/lib
+ RL_INCDIR=/usr/local/include
  
  TERMCAP_LIB="-ltermcap"
  
+ # cannot rely on the presence of getopts
  while [ $# -gt 0 ]; do
  	case "$1" in
  	-C)	shift ; CC="$1"; shift ;;
+ 	-I)	shift ; RL_INCDIR="$1" ; shift ;;
  	-L)	shift ; RL_LIBDIR="$1" ; shift ;;
  	-T)	shift ; TERMCAP_LIB="$1" ; shift ;;
***************
*** 65,69 ****
  EOF
  
! if eval ${CC} -L${RL_LIBDIR} -o $TDIR/rlvers $TDIR/rlvers.c -lreadline ${TERMCAP_LIB};
  then
  	v=`$TDIR/rlvers`
--- 70,82 ----
  EOF
  
! opwd=`pwd`
! 
! cd $TDIR || {
! 	echo "${PROGNAME}: cannot cd to $TDIR" >&2
! 	echo 0
! 	exit 1
! }
! 	
! if eval ${CC} -L${RL_LIBDIR} -I${RL_INCDIR} -o $TDIR/rlvers $TDIR/rlvers.c -lreadline ${TERMCAP_LIB};
  then
  	v=`$TDIR/rlvers`
***************
*** 81,83 ****
--- 94,97 ----
  esac
  
+ cd $opwd
  exit 0
diff -Nrc2 bash-2.04/support/shobj-conf bash-2.05/support/shobj-conf
*** bash-2.04/support/shobj-conf	Tue Sep 21 13:03:43 1999
--- bash-2.05/support/shobj-conf	Tue Jan  2 11:15:44 2001
***************
*** 44,48 ****
  
  case "${host_os}-${SHOBJ_CC}" in
! sunos4*-gcc*)
  	SHOBJ_CFLAGS=-fpic
  	SHOBJ_LD=/usr/bin/ld
--- 44,48 ----
  
  case "${host_os}-${SHOBJ_CC}" in
! sunos4*-*gcc*)
  	SHOBJ_CFLAGS=-fpic
  	SHOBJ_LD=/usr/bin/ld
***************
*** 60,64 ****
  	;;
  
! sunos5*-gcc*|solaris2*-gcc*)
  	SHOBJ_CFLAGS=-fpic
  	SHOBJ_LD='${CC}'
--- 60,64 ----
  	;;
  
! sunos5*-*gcc*|solaris2*-*gcc*)
  	SHOBJ_CFLAGS=-fpic
  	SHOBJ_LD='${CC}'
***************
*** 98,102 ****
  
  # FreeBSD-3.x ELF
! freebsd3*)
  	SHOBJ_CFLAGS=-fpic
  	SHOBJ_LD='${CC}'
--- 98,102 ----
  
  # FreeBSD-3.x ELF
! freebsd[3-9]*|freebsdelf[3-9]*|freebsdaout[3-9]*)
  	SHOBJ_CFLAGS=-fpic
  	SHOBJ_LD='${CC}'
***************
*** 114,124 ****
  	fi
  	;;
! 
! linux*)
  	SHOBJ_CFLAGS=-fPIC
  	SHOBJ_LD='${CC}'
  	SHOBJ_LDFLAGS='-shared -Wl,-soname,$@'
  
! 	SHLIB_XLDFLAGS='-Wl,-rpath,$(libdir)'
  	SHLIB_LIBVERSION='$(SHLIB_LIBSUFF).$(SHLIB_MAJOR)$(SHLIB_MINOR)'
  	;;
--- 114,124 ----
  	fi
  	;;
! # All versions of Linux or the semi-mythical GNU Hurd.
! linux*|gnu*)
  	SHOBJ_CFLAGS=-fPIC
  	SHOBJ_LD='${CC}'
  	SHOBJ_LDFLAGS='-shared -Wl,-soname,$@'
  
! 	SHLIB_XLDFLAGS='-Wl,-rpath,$(libdir) -Wl,-soname,`basename $@ $(SHLIB_MINOR)`'
  	SHLIB_LIBVERSION='$(SHLIB_LIBSUFF).$(SHLIB_MAJOR)$(SHLIB_MINOR)'
  	;;
***************
*** 159,166 ****
  	SHOBJ_LDFLAGS='-shared -Wl,-soname,$@'
  
  	SHLIB_LIBVERSION='$(SHLIB_LIBSUFF).$(SHLIB_MAJOR)$(SHLIB_MINOR)'
  	;;
  
! osf*-gcc*)
  	# Fix to use gcc linker driver from bfischer@TechFak.Uni-Bielefeld.DE
  	SHOBJ_LD='${CC}'
--- 159,167 ----
  	SHOBJ_LDFLAGS='-shared -Wl,-soname,$@'
  
+ 	SHLIB_XLDFLAGS='-Wl,-soname,`basename $@ $(SHLIB_MINOR)`'
  	SHLIB_LIBVERSION='$(SHLIB_LIBSUFF).$(SHLIB_MAJOR)$(SHLIB_MINOR)'
  	;;
  
! osf*-*gcc*)
  	# Fix to use gcc linker driver from bfischer@TechFak.Uni-Bielefeld.DE
  	SHOBJ_LD='${CC}'
***************
*** 179,183 ****
  	;;
  
! aix4.[2-9]*-gcc*)		# lightly tested by jik@cisco.com
  	SHOBJ_CFLAGS=-fpic
  	SHOBJ_LD='ld'
--- 180,184 ----
  	;;
  
! aix4.[2-9]*-*gcc*)		# lightly tested by jik@cisco.com
  	SHOBJ_CFLAGS=-fpic
  	SHOBJ_LD='ld'
***************
*** 204,208 ****
  # THE FOLLOWING ARE UNTESTED -- and some may not support the dlopen interface
  #
! irix[56]*-gcc*)
  	SHOBJ_CFLAGS='-fpic'
  	SHOBJ_LD='${CC}'
--- 205,209 ----
  # THE FOLLOWING ARE UNTESTED -- and some may not support the dlopen interface
  #
! irix[56]*-*gcc*)
  	SHOBJ_CFLAGS='-fpic'
  	SHOBJ_LD='${CC}'
***************
*** 217,221 ****
  	SHOBJ_LD=ld
  #	SHOBJ_LDFLAGS='-call_shared -hidden_symbol -no_unresolved -soname $@'
! #	Change from David Kaelbling <drk@sgi.com>
  	SHOBJ_LDFLAGS='-shared -no_unresolved -soname $@'
  
--- 218,223 ----
  	SHOBJ_LD=ld
  #	SHOBJ_LDFLAGS='-call_shared -hidden_symbol -no_unresolved -soname $@'
! #	Change from David Kaelbling <drk@sgi.com>.  If you have problems,
! #	remove the `-no_unresolved'
  	SHOBJ_LDFLAGS='-shared -no_unresolved -soname $@'
  
***************
*** 224,228 ****
  	;;
  
! hpux9*-gcc*)
  	# must use gcc; the bundled cc cannot compile PIC code
  	SHOBJ_CFLAGS='-fpic'
--- 226,230 ----
  	;;
  
! hpux9*-*gcc*)
  	# must use gcc; the bundled cc cannot compile PIC code
  	SHOBJ_CFLAGS='-fpic'
***************
*** 240,244 ****
  	;;
  
! hpux10*-gcc*)
  	# must use gcc; the bundled cc cannot compile PIC code
  	SHOBJ_CFLAGS='-fpic'
--- 242,246 ----
  	;;
  
! hpux10*-*gcc*)
  	# must use gcc; the bundled cc cannot compile PIC code
  	SHOBJ_CFLAGS='-fpic'
***************
*** 254,265 ****
  	SHOBJ_STATUS=unsupported
  	SHLIB_STATUS=unsupported
  	;;
  
! hpux11*-gcc*)
  	# must use gcc; the bundled cc cannot compile PIC code
  	SHOBJ_CFLAGS='-fpic'
  	SHOBJ_LD='${CC}'
  #	SHOBJ_LDFLAGS='-shared -Wl,-b -Wl,-B,symbolic -Wl,+s -Wl,+std -Wl,+h,$@'
! 	SHOBJ_LDFLAGS='-shared -Wl,-b -Wl,+s -Wl,+h,$@'
  
  	SHLIB_XLDFLAGS='-Wl,+b,$(libdir)'
--- 256,280 ----
  	SHOBJ_STATUS=unsupported
  	SHLIB_STATUS=unsupported
+ 
+ 	# If you are using the HP ANSI C compiler, you can uncomment and use
+ 	# this code
+ #	SHOBJ_STATUS=unsupported
+ #	SHLIB_STATUS=unsupported
+ #
+ #	SHOBJ_CFLAGS='+z'
+ #	SHOBJ_LD='ld'
+ #	SHOBJ_LDFLAGS='-b'
+ #
+ #	SHLIB_XLDFLAGS=''
+ #	SHLIB_LIBSUFF='sl'
+ #	SHLIB_LIBVERSION='$(SHLIB_LIBSUFF).$(SHLIB_MAJOR)'	
  	;;
  
! hpux11*-*gcc*)
  	# must use gcc; the bundled cc cannot compile PIC code
  	SHOBJ_CFLAGS='-fpic'
  	SHOBJ_LD='${CC}'
  #	SHOBJ_LDFLAGS='-shared -Wl,-b -Wl,-B,symbolic -Wl,+s -Wl,+std -Wl,+h,$@'
! 	SHOBJ_LDFLAGS='-shared -fpic -Wl,-b -Wl,+s -Wl,+h,$@'
  
  	SHLIB_XLDFLAGS='-Wl,+b,$(libdir)'
***************
*** 271,277 ****
  	SHOBJ_STATUS=unsupported
  	SHLIB_STATUS=unsupported
  	;;
  
! sysv4*-gcc*)
  	SHOBJ_CFLAGS=-shared
  	SHOBJ_LDFLAGS='-shared -h $@'
--- 286,306 ----
  	SHOBJ_STATUS=unsupported
  	SHLIB_STATUS=unsupported
+ 
+ 	# If you are using the HP ANSI C compiler, you can uncomment and use
+ 	# this code
+ #	SHOBJ_STATUS=unsupported
+ #	SHLIB_STATUS=unsupported
+ #
+ #	SHOBJ_CFLAGS='+z'
+ #	SHOBJ_LD='ld'
+ #	SHOBJ_LDFLAGS='-b'
+ #
+ #	SHLIB_XLDFLAGS=''
+ #	SHLIB_LIBSUFF='sl'
+ #	SHLIB_LIBVERSION='$(SHLIB_LIBSUFF).$(SHLIB_MAJOR)'	
+ 
  	;;
  
! sysv4*-*gcc*)
  	SHOBJ_CFLAGS=-shared
  	SHOBJ_LDFLAGS='-shared -h $@'
***************
*** 289,293 ****
  	;;
  
! sco3.2v5*-gcc*)
  	SHOBJ_CFLAGS='-fpic'		# DEFAULTS TO ELF
  	SHOBJ_LD='${CC}'
--- 318,322 ----
  	;;
  
! sco3.2v5*-*gcc*)
  	SHOBJ_CFLAGS='-fpic'		# DEFAULTS TO ELF
  	SHOBJ_LD='${CC}'
***************
*** 305,309 ****
  	;;
  
! sysv5uw7*-gcc*)
  	SHOBJ_CFLAGS='-fpic'
  	SHOBJ_LD='${CC}'
--- 334,338 ----
  	;;
  
! sysv5uw7*-*gcc*)
  	SHOBJ_CFLAGS='-fpic'
  	SHOBJ_LD='${CC}'
***************
*** 321,325 ****
  	;;
  	
! dgux*-gcc*)
  	SHOBJ_CFLAGS=-fpic
  	SHOBJ_LD='${CC}'
--- 350,354 ----
  	;;
  	
! dgux*-*gcc*)
  	SHOBJ_CFLAGS=-fpic
  	SHOBJ_LD='${CC}'
***************
*** 345,349 ****
  # Rely on correct gcc configuration for everything else
  #
! *-gcc*)
  	SHOBJ_CFLAGS=-fpic
  	SHOBJ_LD='${CC}'
--- 374,378 ----
  # Rely on correct gcc configuration for everything else
  #
! *-*gcc*)
  	SHOBJ_CFLAGS=-fpic
  	SHOBJ_LD='${CC}'
diff -Nrc2 bash-2.04/syntax.h bash-2.05/syntax.h
*** bash-2.04/syntax.h	Wed Dec 31 19:00:00 1969
--- bash-2.05/syntax.h	Mon Oct 16 12:48:02 2000
***************
*** 0 ****
--- 1,91 ----
+ /* syntax.h -- Syntax definitions for the shell */
+ 
+ /* Copyright (C) 2000 Free Software Foundation, Inc.
+ 
+    This file is part of GNU Bash, the Bourne Again SHell.
+ 
+    Bash is free software; you can redistribute it and/or modify it under
+    the terms of the GNU General Public License as published by the Free
+    Software Foundation; either version 2, or (at your option) any later
+    version.
+ 
+    Bash is distributed in the hope that it will be useful, but WITHOUT ANY
+    WARRANTY; without even the implied warranty of MERCHANTABILITY or
+    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+    for more details.
+ 
+    You should have received a copy of the GNU General Public License along
+    with Bash; see the file COPYING.  If not, write to the Free Software
+    Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. */
+ 
+ #ifndef _SYNTAX_H_
+ #define _SYNTAX_H_
+ 
+ /* Defines for use by mksyntax.c */
+ 
+ #define slashify_in_quotes "\\`$\"\n"
+ #define slashify_in_here_document "\\`$"
+ 
+ #define shell_meta_chars   "()<>;&|"
+ #define shell_break_chars  "()<>;&| \t\n"
+ 
+ #define shell_quote_chars	"\"`'"
+ 
+ #if defined (PROCESS_SUBSTITUTION)
+ #  define shell_exp_chars		"$<>"
+ #else
+ #  define shell_exp_chars		"$"
+ #endif
+ 
+ #if defined (EXTENDED_GLOB)
+ #  define ext_glob_chars	"@*+?!"
+ #else
+ #  define ext_glob_chars	""
+ #endif
+ #define shell_glob_chars	"*?[]^"
+ 
+ /* Defines shared by mksyntax.c and the rest of the shell code. */
+ 
+ /* Values for character flags in syntax tables */
+ 
+ #define CWORD		0x0000	/* nothing special; an ordinary character */
+ #define CSHMETA		0x0001	/* shell meta character */
+ #define CSHBRK		0x0002	/* shell break character */
+ #define CBACKQ		0x0004	/* back quote */
+ #define CQUOTE		0x0008	/* shell quote character */
+ #define CSPECL		0x0010	/* special character that needs quoting */
+ #define CEXP		0x0020	/* shell expansion character */
+ #define CBSDQUOTE	0x0040	/* characters escaped by backslash in double quotes */
+ #define CBSHDOC		0x0080	/* characters escaped by backslash in here doc */
+ #define CGLOB		0x0100	/* globbing characters */
+ #define CXGLOB		0x0200	/* extended globbing characters */
+ #define CXQUOTE		0x0400	/* cquote + backslash */
+ #define CSPECVAR	0x0800	/* single-character shell variable name */
+ 
+ /* Defines for use by the rest of the shell. */
+ extern const int sh_syntaxtab[];
+ 
+ #define shellmeta(c)	(sh_syntaxtab[(c)] & CSHMETA)
+ #define shellbreak(c)	(sh_syntaxtab[(c)] & CSHBRK)
+ #define shellquote(c)	(sh_syntaxtab[(c)] & CQUOTE)
+ 
+ #if defined (PROCESS_SUBSTITUTION)
+ #  define shellexp(c)	((c) == '$' || (c) == '<' || (c) == '>')
+ #else
+ #  define shellexp(c)	((c) == '$')
+ #endif
+ 
+ #if defined (EXTENDED_GLOB)
+ #  define PATTERN_CHAR(c) \
+ 	((c) == '@' || (c) == '*' || (c) == '+' || (c) == '?' || (c) == '!')
+ #else
+ #  define PATTERN_CHAR(c) 0
+ #endif
+ 
+ #define GLOB_CHAR(c) \
+ 	((c) == '*' || (c) == '?' || (c) == '[' || (c) == ']' || (c) == '^')
+ 
+ #define CTLESC '\001'
+ #define CTLNUL '\177'
+ 
+ #endif /* _SYNTAX_H_ */
diff -Nrc2 bash-2.04/test.c bash-2.05/test.c
*** bash-2.04/test.c	Thu Aug  5 07:15:05 1999
--- bash-2.05/test.c	Thu Mar  8 08:52:45 2001
***************
*** 69,76 ****
  #endif /* !STREQ */
  
- #if !defined (member)
- #  define member(c, s) (int)((c) ? (char *)strchr ((s), (c)) : 0)
- #endif /* !member */
- 
  #if !defined (R_OK)
  #define R_OK 4
--- 69,72 ----
***************
*** 242,246 ****
      }
  
!   if (st.st_uid == current_user.euid)        /* owner */
      mode <<= 6;
    else if (group_member (st.st_gid))
--- 238,242 ----
      }
  
!   if (st.st_uid == current_user.euid)	/* owner */
      mode <<= 6;
    else if (group_member (st.st_gid))
***************
*** 359,363 ****
        value = expr ();
        if (argv[pos] == 0)
!         test_syntax_error ("`)' expected", (char *)NULL);
        else if (argv[pos][0] != ')' || argv[pos][1])
  	test_syntax_error ("`)' expected, found %s", argv[pos]);
--- 355,359 ----
        value = expr ();
        if (argv[pos] == 0)
! 	test_syntax_error ("`)' expected", (char *)NULL);
        else if (argv[pos][0] != ')' || argv[pos][1])
  	test_syntax_error ("`)' expected, found %s", argv[pos]);
***************
*** 394,399 ****
    struct stat st1, st2;
  
!   if (test_stat (s, &st1) < 0 || test_stat (t, &st2) < 0)
!     return (FALSE);
    switch (op)
      {
--- 390,406 ----
    struct stat st1, st2;
  
!   if (test_stat (s, &st1) < 0)
!     {
!       st1.st_mtime = 0;
!       if (op == EF)
! 	return (FALSE);
!     }
!   if (test_stat (t, &st2) < 0)
!     {
!       st2.st_mtime = 0;
!       if (op == EF)
! 	return (FALSE);
!     }
!   
    switch (op)
      {
***************
*** 476,481 ****
        switch (op[1])
  	{
!         case 'n': return (filecomp (arg1, arg2, NT));		/* -nt */
!         case 'o': return (filecomp (arg1, arg2, OT));		/* -ot */
  	case 'l': return (arithcomp (arg1, arg2, LT, flags));	/* -lt */
  	case 'g': return (arithcomp (arg1, arg2, GT, flags));	/* -gt */
--- 483,488 ----
        switch (op[1])
  	{
! 	case 'n': return (filecomp (arg1, arg2, NT));		/* -nt */
! 	case 'o': return (filecomp (arg1, arg2, OT));		/* -ot */
  	case 'l': return (arithcomp (arg1, arg2, LT, flags));	/* -lt */
  	case 'g': return (arithcomp (arg1, arg2, GT, flags));	/* -gt */
***************
*** 555,562 ****
      {
        advance (0);
!       if (pos < argc && legal_number (argv[pos], &r))
  	{
! 	  advance (0);
! 	  return (unary_test (op, argv[pos - 1]));
  	}
        else
--- 562,574 ----
      {
        advance (0);
!       if (pos < argc)
  	{
! 	  if (legal_number (argv[pos], &r))
! 	    {
! 	      advance (0);
! 	      return (unary_test (op, argv[pos - 1]));
! 	    }
! 	  else
! 	    return (FALSE);
  	}
        else
***************
*** 732,736 ****
  	  }
        else
!         return (0);
      }
  }
--- 744,748 ----
  	  }
        else
! 	return (0);
      }
  }
***************
*** 792,798 ****
      {
        if (argv[pos+1][1] == 'a')
!         value = ONE_ARG_TEST(argv[pos]) && ONE_ARG_TEST(argv[pos+2]);
        else
!         value = ONE_ARG_TEST(argv[pos]) || ONE_ARG_TEST(argv[pos+2]);
        pos = argc;
      }
--- 804,810 ----
      {
        if (argv[pos+1][1] == 'a')
! 	value = ONE_ARG_TEST(argv[pos]) && ONE_ARG_TEST(argv[pos+2]);
        else
! 	value = ONE_ARG_TEST(argv[pos]) || ONE_ARG_TEST(argv[pos+2]);
        pos = argc;
      }
***************
*** 881,889 ****
        --margc;
  
-       if (margc < 2)
- 	test_exit (SHELL_BOOLEAN (FALSE));
- 
        if (margv[margc] && (margv[margc][0] != ']' || margv[margc][1]))
  	test_syntax_error ("missing `]'", (char *)NULL);
      }
  
--- 893,901 ----
        --margc;
  
        if (margv[margc] && (margv[margc][0] != ']' || margv[margc][1]))
  	test_syntax_error ("missing `]'", (char *)NULL);
+ 
+       if (margc < 2)
+ 	test_exit (SHELL_BOOLEAN (FALSE));
      }
  
diff -Nrc2 bash-2.04/tests/arith-for.right bash-2.05/tests/arith-for.right
*** bash-2.04/tests/arith-for.right	Wed Apr 21 12:11:53 1999
--- bash-2.05/tests/arith-for.right	Mon Sep 25 12:50:24 2000
***************
*** 71,72 ****
--- 71,74 ----
  ./arith-for.tests: line 83: syntax error: `(( i=0; i < 3; i++; 7 ))'
  2
+ 20
+ 20
diff -Nrc2 bash-2.04/tests/arith-for.tests bash-2.05/tests/arith-for.tests
*** bash-2.04/tests/arith-for.tests	Fri Mar 19 12:20:29 1999
--- bash-2.05/tests/arith-for.tests	Mon Sep 25 12:50:00 2000
***************
*** 86,87 ****
--- 86,94 ----
  done
  echo $?
+ 
+ # one-liners added in post-bash-2.04
+ for     ((i=0; i < 20; i++)) do : ; done
+ echo $i
+ 
+ for     ((i=0; i < 20; i++)) { : ; }
+ echo $i
diff -Nrc2 bash-2.04/tests/arith.right bash-2.05/tests/arith.right
*** bash-2.04/tests/arith.right	Thu Jul  8 11:28:56 1999
--- bash-2.05/tests/arith.right	Mon Sep 25 13:41:11 2000
***************
*** 145,146 ****
--- 145,152 ----
  ./arith.tests: a b: syntax error in expression (error token is "b")
  ./arith.tests: ((: a b: syntax error in expression (error token is "b")
+ 42
+ 42
+ 42
+ 42
+ 42
+ 42
diff -Nrc2 bash-2.04/tests/arith.tests bash-2.05/tests/arith.tests
*** bash-2.04/tests/arith.tests	Thu Jul  8 11:28:21 1999
--- bash-2.05/tests/arith.tests	Mon Sep 25 13:40:45 2000
***************
*** 268,269 ****
--- 268,277 ----
  echo $((a b))
  ((a b))
+ 
+ n=42
+ printf "%d\n" $n
+ printf "%i\n" $n
+ echo $(( 8#$(printf "%o\n" $n) ))
+ printf "%u\n" $n
+ echo $(( 16#$(printf "%x\n" $n) ))
+ echo $(( 16#$(printf "%X\n" $n) ))
diff -Nrc2 bash-2.04/tests/array.right bash-2.05/tests/array.right
*** bash-2.04/tests/array.right	Wed Apr 21 12:24:42 1999
--- bash-2.05/tests/array.right	Tue Sep 26 15:31:51 2000
***************
*** 111,120 ****
  12 14 16 18 20
  4414758999202
! ./array.tests: array assign: line 257: syntax error near unexpected token `for'
! ./array.tests: array assign: line 257: `a b c for case if then else'
! ./array.tests: array assign: line 259: syntax error near unexpected token `for'
! ./array.tests: array assign: line 259: `for case if then else'
! ./array.tests: array assign: line 261: syntax error near unexpected token `<>'
! ./array.tests: array assign: line 261: ` <> < > ! '
! ./array.tests: array assign: line 262: syntax error near unexpected token `[1]=<>'
! ./array.tests: array assign: line 262: ` [1]=<> [2]=< [3]=> [4]=! '
--- 111,129 ----
  12 14 16 18 20
  4414758999202
! aaa bbb
! ./array.tests: array assign: line 262: syntax error near unexpected token `for'
! ./array.tests: array assign: line 262: `a b c for case if then else'
! ./array.tests: array assign: line 264: syntax error near unexpected token `for'
! ./array.tests: array assign: line 264: `for case if then else'
! ./array.tests: array assign: line 266: syntax error near unexpected token `<>'
! ./array.tests: array assign: line 266: ` <> < > ! '
! ./array.tests: array assign: line 267: syntax error near unexpected token `[1]=<>'
! ./array.tests: array assign: line 267: ` [1]=<> [2]=< [3]=> [4]=! '
! abc 3
! 0
! abc 1
! abc 1
! 0
! 0
! 1
! 1
diff -Nrc2 bash-2.04/tests/array.tests bash-2.05/tests/array.tests
*** bash-2.04/tests/array.tests	Wed Apr 21 12:16:48 1999
--- bash-2.05/tests/array.tests	Tue Sep 26 15:30:59 2000
***************
*** 254,257 ****
--- 254,262 ----
  echo ${foo[@]}
  
+ # this was a bug in all versions of bash 2.x up to and including bash-2.04
+ declare -a ddd=(aaa
+ bbb)
+ echo ${ddd[@]}
+ 
  # errors
  foo=(a b c for case if then else)
***************
*** 261,262 ****
--- 266,280 ----
  metas=( <> < > ! )
  metas=( [1]=<> [2]=< [3]=> [4]=! )
+ 
+ # various expansions that didn't really work right until post-bash-2.04
+ foo='abc'
+ echo ${foo[0]} ${#foo[0]}
+ echo ${foo[1]} ${#foo[1]}
+ echo ${foo[@]} ${#foo[@]}
+ echo ${foo[*]} ${#foo[*]}
+ 
+ foo=''
+ echo ${foo[0]} ${#foo[0]}
+ echo ${foo[1]} ${#foo[1]}
+ echo ${foo[@]} ${#foo[@]}
+ echo ${foo[*]} ${#foo[*]}
diff -Nrc2 bash-2.04/tests/cond.right bash-2.05/tests/cond.right
*** bash-2.04/tests/cond.right	Tue Nov 18 13:55:04 1997
--- bash-2.05/tests/cond.right	Fri Sep 22 12:21:27 2000
***************
*** 3,6 ****
--- 3,10 ----
  returns: 1
  returns: 0
+ returns: 0
+ returns: 0
+ returns: 0
+ returns: 0
  returns: 1
  returns: 0
diff -Nrc2 bash-2.04/tests/cond.tests bash-2.05/tests/cond.tests
*** bash-2.04/tests/cond.tests	Tue Nov 18 13:54:35 1997
--- bash-2.05/tests/cond.tests	Fri Sep 22 12:20:56 2000
***************
*** 21,24 ****
--- 21,37 ----
  echo returns: $?
  
+ # parenthesized terms didn't work right until post-2.04
+ [[ a ]]
+ echo returns: $?
+ 
+ [[ (a) ]]
+ echo returns: $?
+ 
+ [[ -n a ]]
+ echo returns: $?
+ 
+ [[ (-n a) ]]
+ echo returns: $?
+ 
  # unset variables don't need to be quoted
  [[ -n $UNSET ]]
diff -Nrc2 bash-2.04/tests/cprint.right bash-2.05/tests/cprint.right
*** bash-2.04/tests/cprint.right	Tue Dec 14 13:35:31 1999
--- bash-2.05/tests/cprint.right	Tue Oct  3 14:52:27 2000
***************
*** 56,61 ****
      ( { 
          time -p echo a | cat - >/dev/null
!     } )
! } 2>&1
  cprint.tests is a regular file
  cprint.tests is not a directory
--- 56,61 ----
      ( { 
          time -p echo a | cat - >/dev/null
!     } ) 2>&1
! }
  cprint.tests is a regular file
  cprint.tests is not a directory
diff -Nrc2 bash-2.04/tests/dollar-at-star bash-2.05/tests/dollar-at-star
*** bash-2.04/tests/dollar-at-star	Tue Aug 26 10:38:04 1997
--- bash-2.05/tests/dollar-at-star	Mon Sep 18 17:26:01 2000
***************
*** 118,119 ****
--- 118,210 ----
  recho $@
  recho "$*"
+ 
+ IFS=:
+ 
+ # special variables
+ set -- 1 2 3 4 5 6 7 8 9 10
+ 
+ bar=${*}
+ foo=$*
+ echo foo = "$foo"
+ echo bar = "$bar"
+ 
+ foo1=$@
+ bar1=${@}
+ 
+ echo foo1 = "$foo1"
+ echo bar1 = "$bar1"
+ 
+ foo2="$*"
+ bar2="${*}"
+ 
+ echo foo2 = "$foo2"
+ echo bar2 = "$bar2"
+ 
+ eval foo3='$*' bar3='${*}'
+ echo foo3 = "$foo3"
+ echo bar3 = "$bar3"
+ 
+ case $* in
+ *\:*)	echo ok 1;;
+ *)	echo bad 1;;
+ esac
+ 
+ case $@ in
+ *\:*)	echo bad 2;;
+ *)	echo ok 2;;
+ esac
+ 
+ case "$*" in
+ *\:*)	echo ok 3;;
+ *)	echo bad 3;;
+ esac
+ 
+ case "$@" in
+ *\:*)	echo bad 4;;
+ *)	echo ok 4;;
+ esac
+ 
+ IFS=$' \t\n'
+ 
+ bar=${*}
+ foo=$*
+ echo foo = "$foo"
+ echo bar = "$bar"
+ 
+ foo1=$@
+ bar1=${@}
+ 
+ echo foo1 = "$foo1"
+ echo bar1 = "$bar1"
+ 
+ foo2="$*"
+ bar2="${*}"
+ 
+ echo foo2 = "$foo2"
+ echo bar2 = "$bar2"
+ 
+ eval foo3='$*' bar3='${*}'
+ echo foo3 = "$foo3"
+ echo bar3 = "$bar3"
+ 
+ case $* in
+ *\ *)	echo ok 1;;
+ *)	echo bad 1;;
+ esac
+ 
+ case $@ in
+ *\ *)	echo ok 2;;
+ *)	echo bad 2;;
+ esac
+ 
+ case "$*" in
+ *\ *)	echo ok 3;;
+ *)	echo bad 3;;
+ esac
+ 
+ case "$@" in
+ *\ *)	echo ok 4;;
+ *)	echo bad 4;;
+ esac
+ 
+ exit 0
diff -Nrc2 bash-2.04/tests/dollar.right bash-2.05/tests/dollar.right
*** bash-2.04/tests/dollar.right	Tue Aug 26 10:38:13 1997
--- bash-2.05/tests/dollar.right	Mon Sep 18 17:26:37 2000
***************
*** 72,73 ****
--- 72,97 ----
  argv[3] = <bam>
  argv[1] = <foo bar bam>
+ foo = 1:2:3:4:5:6:7:8:9:10
+ bar = 1:2:3:4:5:6:7:8:9:10
+ foo1 = 1 2 3 4 5 6 7 8 9 10
+ bar1 = 1 2 3 4 5 6 7 8 9 10
+ foo2 = 1:2:3:4:5:6:7:8:9:10
+ bar2 = 1:2:3:4:5:6:7:8:9:10
+ foo3 = 1:2:3:4:5:6:7:8:9:10
+ bar3 = 1:2:3:4:5:6:7:8:9:10
+ ok 1
+ ok 2
+ ok 3
+ ok 4
+ foo = 1 2 3 4 5 6 7 8 9 10
+ bar = 1 2 3 4 5 6 7 8 9 10
+ foo1 = 1 2 3 4 5 6 7 8 9 10
+ bar1 = 1 2 3 4 5 6 7 8 9 10
+ foo2 = 1 2 3 4 5 6 7 8 9 10
+ bar2 = 1 2 3 4 5 6 7 8 9 10
+ foo3 = 1 2 3 4 5 6 7 8 9 10
+ bar3 = 1 2 3 4 5 6 7 8 9 10
+ ok 1
+ ok 2
+ ok 3
+ ok 4
diff -Nrc2 bash-2.04/tests/exec.right bash-2.05/tests/exec.right
*** bash-2.04/tests/exec.right	Fri Nov 14 12:14:00 1997
--- bash-2.05/tests/exec.right	Mon Sep 25 11:37:03 2000
***************
*** 17,21 ****
  ./execscript: .: /: is a directory
  1
! 126
  ./execscript: .: /dev/null: not a regular file
  1
--- 17,21 ----
  ./execscript: .: /: is a directory
  1
! 127
  ./execscript: .: /dev/null: not a regular file
  1
***************
*** 38,39 ****
--- 38,53 ----
  127
  this is ohio-state
+ 0
+ 1
+ 1
+ 0
+ 42
+ 42
+ 0
+ 1
+ 1
+ 0
+ 0
+ 1
+ 0
+ 1
diff -Nrc2 bash-2.04/tests/exec6.sub bash-2.05/tests/exec6.sub
*** bash-2.04/tests/exec6.sub	Wed Dec 31 19:00:00 1969
--- bash-2.05/tests/exec6.sub	Mon Sep 25 11:36:03 2000
***************
*** 0 ****
--- 1,54 ----
+ # builtins with exit status inverted
+ 
+ ( true )
+ echo $?
+ ( ! true )
+ echo $?
+ 
+ ( false )
+ echo $?
+ ( ! false )
+ echo $?
+ 
+ # inverting shouldn't affect exit
+ (exit 42)
+ echo $?
+ 
+ ( ! exit 42 )
+ echo $?
+ 
+ # commands requiring an exec with exit status inverted -- broken in bash-2.04
+ 
+ ( ls > /dev/null 2>&1 )
+ echo $?
+ ( ! ls > /dev/null 2>&1 )
+ echo $?
+ 
+ touch /tmp/notwrite
+ chmod 400 /tmp/notwrite
+ 
+ # make sure redirection failures in commands whose exit status is inverted
+ # are handled correctly
+ 
+ ( ls > /tmp/notwrite ) 2>/dev/null
+ echo $?
+ 
+ ( ! ls > /tmp/notwrite ) 2>/dev/null
+ echo $?
+ 
+ # now add exit traps, true and false for commands with and without exit
+ # status inversion
+ 
+ (trap 'false' 0 ; ! ls > /tmp/notwrite ) 2>/dev/null
+ echo $?
+ 
+ (trap 'false' 0 ; ls > /tmp/notwrite ) 2>/dev/null
+ echo $?
+ 
+ (trap 'true' 0 ; ! ls > /tmp/notwrite ) 2>/dev/null
+ echo $?
+ 
+ (trap 'true' 0 ; ls > /tmp/notwrite ) 2>/dev/null
+ echo $?
+ 
+ rm -f /tmp/notwrite
diff -Nrc2 bash-2.04/tests/execscript bash-2.05/tests/execscript
*** bash-2.04/tests/execscript	Fri Sep 24 14:27:24 1999
--- bash-2.05/tests/execscript	Thu Jul 27 10:15:32 2000
***************
*** 36,39 ****
--- 36,41 ----
  echo $?
  
+ # try sourcing a binary file -- post-2.04 versions don't do the binary file
+ # check, and will probably fail with `command not found', or status 127
  . ${THIS_SH} 2>/dev/null
  echo $?
***************
*** 83,84 ****
--- 85,91 ----
  # this was a bug in bash versions before bash-2.04
  ${THIS_SH} -c 'cat </dev/null | cat >/dev/null' >&-
+ 
+ # checks for proper return values in subshell commands with inverted return
+ # values
+ 
+ ${THIS_SH} ./exec6.sub
diff -Nrc2 bash-2.04/tests/func.right bash-2.05/tests/func.right
*** bash-2.04/tests/func.right	Tue Dec 14 13:40:58 1999
--- bash-2.05/tests/func.right	Wed Feb 21 11:49:01 2001
***************
*** 119,120 ****
--- 119,150 ----
      echo testgrp-b
  }
+ funca is a function
+ funca () 
+ { 
+     ( echo func-a )
+ }
+ funcb is a function
+ funcb () 
+ { 
+     ( echo func-b )
+ }
+ funcc is a function
+ funcc () 
+ { 
+     ( echo func-c ) 2>&1
+ }
+ func-a
+ func-b
+ func-c
+ expect 5 10
+ 5 10
+ expect 20
+ 20
+ expect 5 20
+ 5 20
+ expect 5 30
+ 5 30
+ expect 2 40
+ 2 40
+ expect 5 20
+ 5 20
diff -Nrc2 bash-2.04/tests/func.tests bash-2.05/tests/func.tests
*** bash-2.04/tests/func.tests	Tue Dec 14 13:18:24 1999
--- bash-2.05/tests/func.tests	Wed Feb 21 11:48:22 2001
***************
*** 151,153 ****
--- 151,160 ----
  ${THIS_SH} ./func1.sub
  
+ # tests for functions whose bodies are not group commands, with and without
+ # attached redirections
+ ${THIS_SH} ./func2.sub
+ 
+ # test for some posix-specific function behavior
+ ${THIS_SH} ./func3.sub
+ 
  exit 0
diff -Nrc2 bash-2.04/tests/func2.sub bash-2.05/tests/func2.sub
*** bash-2.04/tests/func2.sub	Wed Dec 31 19:00:00 1969
--- bash-2.05/tests/func2.sub	Tue Oct  3 14:57:56 2000
***************
*** 0 ****
--- 1,17 ----
+ funca() (
+ 	echo func-a
+ )
+ 
+ funcb() ( echo func-b )
+ 
+ funcc() (
+ 	echo func-c
+ ) 2>&1
+ 
+ type funca
+ type funcb
+ type funcc
+ 
+ funca
+ funcb
+ funcc
diff -Nrc2 bash-2.04/tests/func3.sub bash-2.05/tests/func3.sub
*** bash-2.04/tests/func3.sub	Wed Dec 31 19:00:00 1969
--- bash-2.05/tests/func3.sub	Wed Feb 21 11:49:56 2001
***************
*** 0 ****
--- 1,54 ----
+ #
+ # test some posix-mode-specific function behavior
+ #
+ set -o posix
+ func()
+ {
+ 	return 5
+ }
+ 
+ myfunction () {
+     var=20 return
+ }
+ var=10
+ echo expect 5 10
+ func
+ echo $? $var
+ 
+ myfunction
+ echo expect 20
+ echo $var
+ 
+ echo expect 5 20
+ func
+ echo $? $var
+ 
+ echo expect 5 30
+ var=30 func
+ echo $? $var
+ 
+ : ${TMPDIR:=/tmp}
+ TMPFILE=$TMPDIR/func3.sub.$$
+ 
+ rm -f $TMPFILE
+ echo 'var=40 return 2' > $TMPFILE
+ 
+ # test the behavior of `return' and preceding variable assignments here
+ # because it's convenient
+ var=10
+ echo expect 2 40
+ . $TMPFILE
+ echo $? $var
+ 
+ rm -f $TMPFILE
+ 
+ #set -o posix
+ var=0
+ func()
+ {
+ 	var=20 return 5
+ }
+ 
+ echo expect 5 20
+ var=30 func
+ echo $? $var
diff -Nrc2 bash-2.04/tests/glob-test bash-2.05/tests/glob-test
*** bash-2.04/tests/glob-test	Mon Nov 17 15:22:52 1997
--- bash-2.05/tests/glob-test	Sat Apr  1 15:38:10 2000
***************
*** 297,300 ****
--- 297,305 ----
  esac
  
+ # this was a bug in all versions up to bash-2.04-release
+ case "/tmp" in
+ [/\\]*) echo ok 37 ;;
+ esac
+ 
  # none of these should output anything
  
diff -Nrc2 bash-2.04/tests/glob.right bash-2.05/tests/glob.right
*** bash-2.04/tests/glob.right	Mon Nov 17 15:27:22 1997
--- bash-2.05/tests/glob.right	Sat Apr  1 15:38:36 2000
***************
*** 95,98 ****
--- 95,99 ----
  ok 35
  ok 36
+ ok 37
  argv[1] = <b>
  argv[2] = <bb>
diff -Nrc2 bash-2.04/tests/more-exp.right bash-2.05/tests/more-exp.right
*** bash-2.04/tests/more-exp.right	Wed Feb 16 16:00:14 2000
--- bash-2.05/tests/more-exp.right	Fri Jan 26 18:24:54 2001
***************
*** 207,208 ****
--- 207,214 ----
  1
  argv[1] = <>
+ argv[1] = <>
+ argv[1] = <>
+ argv[1] = <:a:>
+ argv[1] = <:b:>
+ argv[1] = <>
+ argv[1] = <>
diff -Nrc2 bash-2.04/tests/more-exp.tests bash-2.05/tests/more-exp.tests
*** bash-2.04/tests/more-exp.tests	Wed Feb 16 15:59:43 2000
--- bash-2.05/tests/more-exp.tests	Fri Jan 26 18:24:27 2001
***************
*** 482,484 ****
--- 482,501 ----
  echo $#
  expect '<>'
+ recho "${@}"
+ expect '<>'
+ recho "${@-}"
+ expect '<>'
+ recho "${@:-}"
+ 
+ # this was a bug in bash-2.04, fixed in 2.05
+ set -- a b
+ expect '<:a:>' '<:b:>'
+ for i in "${@-}"; do recho :$i:; done
+ 
+ # I believe that ksh93 does these wrong -- we're using the rhs, so shouldn't
+ # it behave the same as ""?
+ set --
+ expect '<>'
+ recho "${@-}"
+ expect '<>'
  recho "${@:-}"
diff -Nrc2 bash-2.04/tests/new-exp.right bash-2.05/tests/new-exp.right
*** bash-2.04/tests/new-exp.right	Thu Aug 26 10:56:49 1999
--- bash-2.05/tests/new-exp.right	Thu Sep 21 13:24:23 2000
***************
*** 49,52 ****
--- 49,58 ----
  argv[4] = <kl mn>
  argv[5] = <op>
+ argv[1] = </home/chet/foo//bar/abcabcabc>
+ argv[1] = <home/chet/foo//bar/abcabcabc>
+ argv[1] = <home>
+ argv[1] = <home>
+ argv[1] = <home>
+ argv[1] = <home>
  argv[1] = <abcdefghijklmnop>
  argv[1] = <4>
diff -Nrc2 bash-2.04/tests/new-exp.tests bash-2.05/tests/new-exp.tests
*** bash-2.04/tests/new-exp.tests	Thu Aug 26 10:56:02 1999
--- bash-2.05/tests/new-exp.tests	Thu Sep 21 13:23:50 2000
***************
*** 119,122 ****
--- 119,148 ----
  recho "${@:1:$#}"
  
+ # code to ad-hoc parse arithmetic expressions in substring expansions was
+ # broken until post-2.04
+ base=/home/chet/foo//bar
+ string1=$base/abcabcabc
+ x=1 j=4
+ 
+ expect '</home/chet/foo//bar/abcabcabc>'
+ recho ${string1:0}
+ 
+ expect '<home/chet/foo//bar/abcabcabc>'
+ recho ${string1:1}
+ 
+ expect '<home>'
+ recho ${string1:(j?1:0):j}
+ 
+ expect '<home>'
+ recho ${string1:j?1:0:j}
+ 
+ expect '<home>'
+ recho ${string1:(j?(x?1:0):0):j}
+ 
+ expect '<home>'
+ recho ${string1:j?(x?1:0):0:j}
+ 
+ unset base string1 x j
+ 
  # indirect variable references
  expect '<abcdefghijklmnop>'
diff -Nrc2 bash-2.04/tests/posix2.tests bash-2.05/tests/posix2.tests
*** bash-2.04/tests/posix2.tests	Mon Nov 17 13:13:59 1997
--- bash-2.05/tests/posix2.tests	Fri Oct 13 15:50:34 2000
***************
*** 141,149 ****
  fi
  
  newtest
  SQUOTE="'"
  val1=$(set | sed -n 's:^SQUOTE=::p')
! # if I change the default quoting style for variable values, this must change
! if [ "$val1" != "''\'''" ]; then
          testfail "variable quoting 1"
  fi
--- 141,151 ----
  fi
  
+ # if I change the default quoting style for variable values, these
+ # next four must change
+ 
  newtest
  SQUOTE="'"
  val1=$(set | sed -n 's:^SQUOTE=::p')
! if [ "$val1" != "\$'\\''" ]; then
          testfail "variable quoting 1"
  fi
***************
*** 152,156 ****
  VTILDE='~'
  val1=$(set | sed -n 's:^VTILDE=::p')
! if [ "$val1" != "'~'" ]; then
  	testfail "variable quoting 2"
  fi
--- 154,158 ----
  VTILDE='~'
  val1=$(set | sed -n 's:^VTILDE=::p')
! if [ "$val1" != "\$'~'" ]; then
  	testfail "variable quoting 2"
  fi
***************
*** 166,170 ****
  VHASH2=#abcd
  val1=$(set | sed -n 's:^VHASH2=::p')
! if [ "$val1" != "'#abcd'" ]; then
  	testfail "variable quoting 4"
  fi
--- 168,172 ----
  VHASH2=#abcd
  val1=$(set | sed -n 's:^VHASH2=::p')
! if [ "$val1" != "\$'#abcd'" ]; then
  	testfail "variable quoting 4"
  fi
diff -Nrc2 bash-2.04/tests/set-e-test bash-2.05/tests/set-e-test
*** bash-2.04/tests/set-e-test	Fri Feb 21 15:57:04 1997
--- bash-2.05/tests/set-e-test	Mon Sep 25 11:59:58 2000
***************
*** 15,18 ****
--- 15,33 ----
  	set +e
  fi
+ 
+ (
+ set -e
+ false
+ echo bad
+ )
+ echo $?
+ 
+ x=$(
+ set -e
+ false
+ echo bad
+ )
+ echo $? $x
+ 
  # command subst should not inherit -e
  set -e
diff -Nrc2 bash-2.04/tests/set-e.right bash-2.05/tests/set-e.right
*** bash-2.04/tests/set-e.right	Fri Feb 21 15:58:36 1997
--- bash-2.05/tests/set-e.right	Mon Sep 25 12:00:21 2000
***************
*** 14,17 ****
--- 14,19 ----
  8
  9
+ 1
+ 1
  ok
  hi
diff -Nrc2 bash-2.04/tests/shopt.right bash-2.05/tests/shopt.right
*** bash-2.04/tests/shopt.right	Tue Sep 21 11:55:58 1999
--- bash-2.05/tests/shopt.right	Tue Sep 26 15:26:09 2000
***************
*** 99,103 ****
  set -o history
  set +o ignoreeof
! set +o interactive-comments
  set +o posix
  set -o emacs
--- 99,103 ----
  set -o history
  set +o ignoreeof
! set -o interactive-comments
  set +o posix
  set -o emacs
***************
*** 123,127 ****
  history        	on
  ignoreeof      	off
! interactive-comments	off
  posix          	off
  emacs          	on
--- 123,127 ----
  history        	on
  ignoreeof      	off
! interactive-comments	on
  posix          	off
  emacs          	on
***************
*** 147,151 ****
  set -o history
  set +o ignoreeof
! set +o interactive-comments
  set +o posix
  set -o emacs
--- 147,151 ----
  set -o history
  set +o ignoreeof
! set -o interactive-comments
  set +o posix
  set -o emacs
***************
*** 161,164 ****
--- 161,165 ----
  set -o privileged
  set -o history
+ set -o interactive-comments
  set -o emacs
  --
***************
*** 176,180 ****
  set +o xtrace
  set +o ignoreeof
- set +o interactive-comments
  set +o posix
  set +o vi
--- 177,180 ----
***************
*** 193,197 ****
  xtrace         	off
  ignoreeof      	off
- interactive-comments	off
  posix          	off
  vi             	off
--- 193,196 ----
diff -Nrc2 bash-2.04/tests/test.right bash-2.05/tests/test.right
*** bash-2.04/tests/test.right	Mon Mar 29 11:21:29 1999
--- bash-2.05/tests/test.right	Thu Mar  8 08:59:38 2001
***************
*** 271,272 ****
--- 271,284 ----
  ./test.tests: test: (: unary operator expected
  2
+ t -t a
+ 1
+ t -t addsds
+ 1
+ t -t 42
+ 1
+ t -t /dev/tty
+ 1
+ t -t /dev/tty4
+ 1
+ t -t /dev/tty4444444...
+ 1
diff -Nrc2 bash-2.04/tests/test.tests bash-2.05/tests/test.tests
*** bash-2.04/tests/test.tests	Mon Mar 29 11:19:49 1999
--- bash-2.05/tests/test.tests	Thu Mar  8 08:59:32 2001
***************
*** 408,409 ****
--- 408,423 ----
  
  t \( \)
+ 
+ # non-numeric arguments to `test -t' should return failure -- fix in 2.05
+ echo 't -t a'
+ t -t a
+ echo 't -t addsds'
+ t -t addsds
+ echo 't -t 42'
+ t -t 42
+ echo 't -t /dev/tty'
+ t -t /dev/tty
+ echo 't -t /dev/tty4'
+ t -t /dev/tty4
+ echo 't -t /dev/tty4444444...'
+ t -t /dev/tty4444444...
diff -Nrc2 bash-2.04/tests/trap.right bash-2.05/tests/trap.right
*** bash-2.04/tests/trap.right	Fri Nov 14 12:24:18 1997
--- bash-2.05/tests/trap.right	Mon Sep 25 11:59:04 2000
***************
*** 45,48 ****
--- 45,49 ----
  trap -- 'echo aborting' SIGABRT
  trap -- 'echo aborting' SIGTERM
+ 0
  caught a child death
  caught a child death
diff -Nrc2 bash-2.04/tests/trap.tests bash-2.05/tests/trap.tests
*** bash-2.04/tests/trap.tests	Fri Nov 14 12:23:20 1997
--- bash-2.05/tests/trap.tests	Mon Sep 25 11:58:34 2000
***************
*** 41,44 ****
--- 41,53 ----
  trap
  
+ # exit 0 in exit trap should set exit status
+ (
+ set -e
+ trap 'exit 0' EXIT
+ false   
+ echo bad
+ )
+ echo $?
+ 
  # hmmm...should this set the handling to SIG_IGN for children, too?
  trap '' USR2
diff -Nrc2 bash-2.04/tests/varenv.right bash-2.05/tests/varenv.right
*** bash-2.04/tests/varenv.right	Thu Jul  8 11:31:28 1999
--- bash-2.05/tests/varenv.right	Wed Feb 21 14:14:59 2001
***************
*** 30,36 ****
  declare -x ivar="42"
  hB
! braceexpand:hashall
  hPB
! braceexpand:hashall:physical
! declare -r SHELLOPTS="braceexpand:hashall:physical"
  abcde
--- 30,40 ----
  declare -x ivar="42"
  hB
! braceexpand:hashall:interactive-comments
  hPB
! braceexpand:hashall:physical:interactive-comments
! declare -r SHELLOPTS="braceexpand:hashall:physical:interactive-comments"
  abcde
+ 20
+ 30
+ 40
+ 50
diff -Nrc2 bash-2.04/tests/varenv.sh bash-2.05/tests/varenv.sh
*** bash-2.04/tests/varenv.sh	Tue Sep 21 16:13:53 1999
--- bash-2.05/tests/varenv.sh	Wed Feb 21 14:13:46 2001
***************
*** 195,196 ****
--- 195,200 ----
  
  printenv FOOFOO
+ 
+ # test out export behavior of variable assignments preceding builtins and
+ # functions
+ $THIS_SH ./varenv1.sub
diff -Nrc2 bash-2.04/tests/varenv1.sub bash-2.05/tests/varenv1.sub
*** bash-2.04/tests/varenv1.sub	Wed Dec 31 19:00:00 1969
--- bash-2.05/tests/varenv1.sub	Wed Feb 21 14:13:59 2001
***************
*** 0 ****
--- 1,28 ----
+ # test out the export behavior of variable assignments preceding `eval', `.'
+ # and shell functions
+ 
+ func()
+ {
+ 	printenv var
+ }
+ 
+ export var=10
+ echo expect 20
+ var=20 eval printenv var
+ 
+ : ${TMPDIR:=/tmp}
+ TMPFILE=$TMPDIR/evalsub.$$
+ 
+ rm -f $TMPFILE
+ echo 'printenv var' > $TMPFILE
+ 
+ echo expect 30
+ var=30 . $TMPFILE
+ 
+ rm -f $TMPFILE
+ 
+ echo expect 40
+ var=40 func
+ 
+ echo expect 50
+ var=50 command printenv var
diff -Nrc2 bash-2.04/trap.c bash-2.05/trap.c
*** bash-2.04/trap.c	Tue Sep 21 11:31:21 1999
--- bash-2.05/trap.c	Wed Feb 14 17:00:48 2001
***************
*** 222,226 ****
      {
        /* XXX this could be made into a counter by using
!          while (pending_traps[sig]--) instead of the if statement. */
        if (pending_traps[sig])
  	{
--- 222,226 ----
      {
        /* XXX this could be made into a counter by using
! 	 while (pending_traps[sig]--) instead of the if statement. */
        if (pending_traps[sig])
  	{
***************
*** 304,308 ****
    else
      {
!       errno = oerrno;
  #if defined (MUST_REINSTALL_SIGHANDLERS)
        set_signal_handler (sig, trap_handler);
--- 304,308 ----
    else
      {
!       oerrno = errno;
  #if defined (MUST_REINSTALL_SIGHANDLERS)
        set_signal_handler (sig, trap_handler);
***************
*** 601,605 ****
  	}
        else if (code == EXITPROG)
!         return (last_command_exit_value);
        else
  	return (old_exit_value);
--- 601,605 ----
  	}
        else if (code == EXITPROG)
! 	return (last_command_exit_value);
        else
  	return (old_exit_value);
diff -Nrc2 bash-2.04/unwind_prot.c bash-2.05/unwind_prot.c
*** bash-2.04/unwind_prot.c	Thu Aug  5 07:23:32 1999
--- bash-2.05/unwind_prot.c	Wed Feb 14 17:00:55 2001
***************
*** 56,63 ****
  } SAVED_VAR;
  
! static void unwind_frame_discard_internal (), unwind_frame_run_internal ();
! static void add_unwind_protect_internal (), remove_unwind_protect_internal ();
! static void run_unwind_protects_internal (), without_interrupts ();
! 
  static void restore_variable ();
  static void discard_saved_var ();
--- 56,66 ----
  } SAVED_VAR;
  
! static void without_interrupts ();
! static void unwind_frame_discard_internal ();
! static void unwind_frame_run_internal ();
! static void add_unwind_protect_internal ();
! static void remove_unwind_protect_internal ();
! static void run_unwind_protects_internal ();
! static void clear_unwind_protects_internal ();
  static void restore_variable ();
  static void discard_saved_var ();
***************
*** 138,144 ****
  }
  
  /* **************************************************************** */
  /*								    */
! /*                        The Actual Functions                 	    */
  /*								    */
  /* **************************************************************** */
--- 141,157 ----
  }
  
+ /* Erase the unwind-protect list.  If flags is 1, free the elements. */
+ void
+ clear_unwind_protect_list (flags)
+      int flags;
+ {
+   if (unwind_protect_list)
+     without_interrupts
+       (clear_unwind_protects_internal, (char *)flags, (char *)NULL);
+ }
+ 
  /* **************************************************************** */
  /*								    */
! /*			The Actual Functions		 	    */
  /*								    */
  /* **************************************************************** */
***************
*** 159,163 ****
  
  static void
! remove_unwind_protect_internal ()
  {
    UNWIND_ELT *elt;
--- 172,177 ----
  
  static void
! remove_unwind_protect_internal (ignore1, ignore2)
!      char *ignore1, *ignore2;
  {
    UNWIND_ELT *elt;
***************
*** 174,178 ****
  
  static void
! run_unwind_protects_internal ()
  {
    UNWIND_ELT *t, *elt = unwind_protect_list;
--- 188,193 ----
  
  static void
! run_unwind_protects_internal (ignore1, ignore2)
!      char *ignore1, *ignore2;
  {
    UNWIND_ELT *t, *elt = unwind_protect_list;
***************
*** 195,200 ****
  
  static void
! unwind_frame_discard_internal (tag)
!      char *tag;
  {
    UNWIND_ELT *elt;
--- 210,230 ----
  
  static void
! clear_unwind_protects_internal (flag, ignore)
!      char *flag, *ignore;
! {
!   int free_elts = (int)flag;
!   UNWIND_ELT *elt;
! 
!   if (free_elts != 0 && unwind_protect_list)
!     {
!       while (unwind_protect_list)
! 	remove_unwind_protect_internal ((char *)NULL, (char *)NULL);
!     }
!   unwind_protect_list = (UNWIND_ELT *)NULL;
! }
! 
! static void
! unwind_frame_discard_internal (tag, ignore)
!      char *tag, *ignore;
  {
    UNWIND_ELT *elt;
***************
*** 209,216 ****
  	}
        else if (elt->cleanup && elt->cleanup == (Function *)restore_variable)
!         {
!           discard_saved_var ((SAVED_VAR *)elt->arg);
!           free (elt);
!         }
        else
  	free (elt);
--- 239,246 ----
  	}
        else if (elt->cleanup && elt->cleanup == (Function *)restore_variable)
! 	{
! 	  discard_saved_var ((SAVED_VAR *)elt->arg);
! 	  free (elt);
! 	}
        else
  	free (elt);
***************
*** 219,224 ****
  
  static void
! unwind_frame_run_internal (tag)
!      char *tag;
  {
    UNWIND_ELT *elt;
--- 249,254 ----
  
  static void
! unwind_frame_run_internal (tag, ignore)
!      char *tag, *ignore;
  {
    UNWIND_ELT *elt;
***************
*** 291,305 ****
    if (size != sizeof (int))
      {
-       /* There is a problem here when VALUE is 0.  This tries to copy the
- 	  first SIZE bytes starting at memory location 0 into
- 	  s->desired_setting.  There is no guarantee that these bytes are
- 	  0, or make a valid null pointer.  We can try to bzero the space,
- 	  or just save it as 0 (or (void *)0).  If we do the latter, make
- 	  sure restore_variable is changed to understand it. */
        s->desired_setting = (char *)xmalloc (size);
!       if (value == 0)
! 	bzero ((char *)s->desired_setting, size);
!       else
! 	FASTCOPY (value, (char *)s->desired_setting, size);
      }
    else
--- 321,326 ----
    if (size != sizeof (int))
      {
        s->desired_setting = (char *)xmalloc (size);
!       FASTCOPY (value, (char *)s->desired_setting, size);
      }
    else
diff -Nrc2 bash-2.04/unwind_prot.h bash-2.05/unwind_prot.h
*** bash-2.04/unwind_prot.h	Thu Aug  5 07:15:52 1999
--- bash-2.05/unwind_prot.h	Thu Feb  1 13:51:00 2001
***************
*** 30,33 ****
--- 30,34 ----
  extern void run_unwind_protects ();
  extern void unwind_protect_var ();
+ extern void clear_unwind_protect_list ();
  
  /* Try to force correct alignment on machines where pointers and ints
***************
*** 56,60 ****
  /* How to protect a pointer to a string. */
  #define unwind_protect_string(X) \
!   unwind_protect_var ((int *)&(X), (X), sizeof (char *))
  
  /* How to protect any old pointer. */
--- 57,63 ----
  /* How to protect a pointer to a string. */
  #define unwind_protect_string(X) \
!   unwind_protect_var ((int *)&(X), \
! 		      ((sizeof (char *) == sizeof (int)) ? (char *) (X) : (char *) &(X)), \
! 		       sizeof (char *))
  
  /* How to protect any old pointer. */
diff -Nrc2 bash-2.04/variables.c bash-2.05/variables.c
*** bash-2.04/variables.c	Tue Mar 14 11:36:18 2000
--- bash-2.05/variables.c	Wed Feb 21 13:47:11 2001
***************
*** 100,104 ****
  /* The array of shell assignments which are made only in the environment
     for the execution of a shell builtin command which may cause more than
!    one command to be executed (e.g., "source"). */
  char **builtin_env = (char **)NULL;
  
--- 100,104 ----
  /* The array of shell assignments which are made only in the environment
     for the execution of a shell builtin command which may cause more than
!    one command to be executed (e.g., "eval" or "source"). */
  char **builtin_env = (char **)NULL;
  
***************
*** 138,141 ****
--- 138,142 ----
  static void sbrand ();		/* set bash random number generator. */
  static int qsort_var_comp ();
+ static SHELL_VAR *bind_tempenv_variable ();
  
  /* Make VAR be auto-exported.  VAR is a pointer to a SHELL_VAR. */
***************
*** 168,182 ****
  	;
        if (string[-1] == '=')
!         char_index = string - name - 1;
  
        /* If there are weird things in the environment, like `=xxx' or a
  	 string without an `=', just skip them. */
        if (char_index == 0)
!         continue;
  
        /* ASSERT(name[char_index] == '=') */
        name[char_index] = '\0';
        /* Now, name = env variable name, string = env variable value, and
!          char_index == strlen (name) */
  
        /* If exported function, define it now. */
--- 169,183 ----
  	;
        if (string[-1] == '=')
! 	char_index = string - name - 1;
  
        /* If there are weird things in the environment, like `=xxx' or a
  	 string without an `=', just skip them. */
        if (char_index == 0)
! 	continue;
  
        /* ASSERT(name[char_index] == '=') */
        name[char_index] = '\0';
        /* Now, name = env variable name, string = env variable value, and
! 	 char_index == strlen (name) */
  
        /* If exported function, define it now. */
***************
*** 232,236 ****
        name[char_index] = '=';
        /* temp_var can be NULL if it was an exported function with a syntax
!          error (a different bug, but it still shouldn't dump core). */
        if (temp_var && function_p (temp_var) == 0)	/* XXX not yet */
  	{
--- 233,237 ----
        name[char_index] = '=';
        /* temp_var can be NULL if it was an exported function with a syntax
! 	 error (a different bug, but it still shouldn't dump core). */
        if (temp_var && function_p (temp_var) == 0)	/* XXX not yet */
  	{
***************
*** 239,267 ****
      }
  
!   /* If we got PWD from the environment, update our idea of the current
!      working directory.  In any case, make sure that PWD exists before
!      checking it.  It is possible for getcwd () to fail on shell startup,
!      and in that case, PWD would be undefined. */
!   temp_var = find_variable ("PWD");
!   if (temp_var && imported_p (temp_var) &&
!       (temp_string = value_cell (temp_var)) &&
!       same_file (temp_string, ".", (struct stat *)NULL, (struct stat *)NULL))
!     set_working_directory (temp_string);
!   else
!     {
!       temp_string = get_working_directory ("shell-init");
!       if (temp_string)
! 	{
! 	  temp_var = bind_variable ("PWD", temp_string);
! 	  set_auto_export (temp_var);
! 	  free (temp_string);
! 	}
!     }
! 
!   /* According to the Single Unix Specification, v2, $OLDPWD is an
!      `environment variable' and therefore should be auto-exported.
!      Make a dummy invisible variable for OLDPWD, and mark it as exported. */
!   temp_var = bind_variable ("OLDPWD", (char *)NULL);
!   VSETATTR (temp_var, (att_exported | att_invisible));
  
    /* Set up initial value of $_ */
--- 240,244 ----
      }
  
!   set_pwd ();
  
    /* Set up initial value of $_ */
***************
*** 307,317 ****
  
    /* Magic machine types.  Pretty convenient. */
!   temp_var = bind_variable ("HOSTTYPE", HOSTTYPE);
    set_auto_export (temp_var);
!   temp_var = bind_variable ("OSTYPE", OSTYPE);
    set_auto_export (temp_var);
!   temp_var = bind_variable ("MACHTYPE", MACHTYPE);
    set_auto_export (temp_var);
!   temp_var = bind_variable ("HOSTNAME", current_host_name);
    set_auto_export (temp_var);
  
--- 284,295 ----
  
    /* Magic machine types.  Pretty convenient. */
!   temp_var = set_if_not ("HOSTTYPE", HOSTTYPE);
    set_auto_export (temp_var);
!   temp_var = set_if_not ("OSTYPE", OSTYPE);
    set_auto_export (temp_var);
!   temp_var = set_if_not ("MACHTYPE", MACHTYPE);
    set_auto_export (temp_var);
! 
!   temp_var = set_if_not ("HOSTNAME", current_host_name);
    set_auto_export (temp_var);
  
***************
*** 407,410 ****
--- 385,394 ----
        array_needs_making = 1;
      }
+   temp_var = find_variable ("SSH2_CLIENT");
+   if (temp_var && imported_p (temp_var))
+     {
+       VUNSETATTR (temp_var, att_exported);
+       array_needs_making = 1;
+     }
  
    /* Get the user's real and effective user ids. */
***************
*** 421,425 ****
     use it. */
  char *
! get_home_dir ()
  {
    if (current_user.home_dir == 0)
--- 405,409 ----
     use it. */
  char *
! sh_get_home_dir ()
  {
    if (current_user.home_dir == 0)
***************
*** 435,439 ****
    temp_var = find_variable ("HOME");
    if (temp_var == 0)
!     temp_var = bind_variable ("HOME", get_home_dir ());
    VSETATTR (temp_var, att_exported);
  }
--- 419,423 ----
    temp_var = find_variable ("HOME");
    if (temp_var == 0)
!     temp_var = bind_variable ("HOME", sh_get_home_dir ());
    VSETATTR (temp_var, att_exported);
  }
***************
*** 461,471 ****
    char *name;
  
!   if ((login_shell == 1) && (*shell_name != '/'))
      {
        if (current_user.shell == 0)
!         get_current_user_info ();
        name = savestring (current_user.shell);
      }
!   else if (*shell_name == '/')
      name = savestring (shell_name);
    else if (shell_name[0] == '.' && shell_name[1] == '/')
--- 445,455 ----
    char *name;
  
!   if ((login_shell == 1) && RELPATH(shell_name))
      {
        if (current_user.shell == 0)
! 	get_current_user_info ();
        name = savestring (current_user.shell);
      }
!   else if (ABSPATH(shell_name))
      name = savestring (shell_name);
    else if (shell_name[0] == '.' && shell_name[1] == '/')
***************
*** 476,483 ****
  
        cdir = get_string_value ("PWD");
!       len = strlen (cdir);
!       name = xmalloc (len + strlen (shell_name) + 1);
!       strcpy (name, cdir);
!       strcpy (name + len, shell_name + 1);
      }
    else
--- 460,472 ----
  
        cdir = get_string_value ("PWD");
!       if (cdir)
! 	{
! 	  len = strlen (cdir);
! 	  name = xmalloc (len + strlen (shell_name) + 1);
! 	  strcpy (name, cdir);
! 	  strcpy (name + len, shell_name + 1);
! 	}
!       else
! 	name = savestring (shell_name);
      }
    else
***************
*** 498,502 ****
  	      if (*shell_name == '.')
  		{
! 		  name = canonicalize_pathname (tname);
  		  if (name == 0)
  		    name = tname;
--- 487,491 ----
  	      if (*shell_name == '.')
  		{
! 		  name = sh_canonpath (tname, PATH_CHECKDOTDOT|PATH_CHECKEXISTS);
  		  if (name == 0)
  		    name = tname;
***************
*** 575,578 ****
--- 564,613 ----
  }
  
+ /* If we got PWD from the environment, update our idea of the current
+    working directory.  In any case, make sure that PWD exists before
+    checking it.  It is possible for getcwd () to fail on shell startup,
+    and in that case, PWD would be undefined.  If this is an interactive
+    login shell, see if $HOME is the current working directory, and if
+    that's not the same string as $PWD, set PWD=$HOME. */
+ 
+ void
+ set_pwd ()
+ {
+   SHELL_VAR *temp_var, *home_var;
+   char *temp_string, *home_string;
+ 
+   home_var = find_variable ("HOME");
+   home_string = home_var ? value_cell (home_var) : (char *)NULL;
+ 
+   temp_var = find_variable ("PWD");
+   if (temp_var && imported_p (temp_var) &&
+       (temp_string = value_cell (temp_var)) &&
+       same_file (temp_string, ".", (struct stat *)NULL, (struct stat *)NULL))
+     set_working_directory (temp_string);
+   else if (home_string && interactive_shell && login_shell &&
+ 	   same_file (home_string, ".", (struct stat *)NULL, (struct stat *)NULL))
+     {
+       set_working_directory (home_string);
+       temp_var = bind_variable ("PWD", home_string);
+       set_auto_export (temp_var);
+     }
+   else
+     {
+       temp_string = get_working_directory ("shell-init");
+       if (temp_string)
+ 	{
+ 	  temp_var = bind_variable ("PWD", temp_string);
+ 	  set_auto_export (temp_var);
+ 	  free (temp_string);
+ 	}
+     }
+ 
+   /* According to the Single Unix Specification, v2, $OLDPWD is an
+      `environment variable' and therefore should be auto-exported.
+      Make a dummy invisible variable for OLDPWD, and mark it as exported. */
+   temp_var = bind_variable ("OLDPWD", (char *)NULL);
+   VSETATTR (temp_var, (att_exported | att_invisible));
+ }
+ 
  /* Make a variable $PPID, which holds the pid of the shell's parent.  */
  void
***************
*** 598,606 ****
    b = inttostr (current_user.uid, buff, sizeof (buff));
    v = find_variable ("UID");
!   if (v)
!     VUNSETATTR (v, att_readonly);
! 
!   v = bind_variable ("UID", b);
!   VSETATTR (v, (att_readonly | att_integer));
  
    if (current_user.euid != current_user.uid)
--- 633,641 ----
    b = inttostr (current_user.uid, buff, sizeof (buff));
    v = find_variable ("UID");
!   if (v == 0)
!     {
!       v = bind_variable ("UID", b);
!       VSETATTR (v, (att_readonly | att_integer));
!     }
  
    if (current_user.euid != current_user.uid)
***************
*** 608,616 ****
  
    v = find_variable ("EUID");
!   if (v)
!     VUNSETATTR (v, att_readonly);
! 
!   v = bind_variable ("EUID", b);
!   VSETATTR (v, (att_readonly | att_integer));
  }
  
--- 643,651 ----
  
    v = find_variable ("EUID");
!   if (v == 0)
!     {
!       v = bind_variable ("EUID", b);
!       VSETATTR (v, (att_readonly | att_integer));
!     }
  }
  
***************
*** 647,651 ****
     a window size change. */
  void
! set_lines_and_columns (lines, cols)
       int lines, cols;
  {
--- 682,686 ----
     a window size change. */
  void
! sh_set_lines_and_columns (lines, cols)
       int lines, cols;
  {
***************
*** 755,759 ****
  }
  
! /* Print VARS to stdout in such a way that they can be read back in. */
  void
  print_var_list (list)
--- 790,795 ----
  }
  
! /* Print LIST (a list of shell variables) to stdout in such a way that
!    they can be read back in. */
  void
  print_var_list (list)
***************
*** 768,771 ****
--- 804,824 ----
  }
  
+ /* Print LIST (a list of shell functions) to stdout in such a way that
+    they can be read back in. */
+ void
+ print_func_list (list)
+      register SHELL_VAR **list;
+ {
+   register int i;
+   register SHELL_VAR *var;
+ 
+   for (i = 0; list && (var = list[i]); i++)
+     {
+       printf ("%s ", var->name);
+       print_var_function (var);
+       printf ("\n");
+     }
+ }
+       
  #if defined (NOTDEF)
  /* Print LIST (a linked list of shell variables) to stdout
***************
*** 794,798 ****
    if (function_p (var) && var->value)
      {
!       printf ("%s=", var->name);
        print_var_function (var);
        printf ("\n");
--- 847,851 ----
    if (function_p (var) && var->value)
      {
!       printf ("%s", var->name);
        print_var_function (var);
        printf ("\n");
***************
*** 823,829 ****
    if (var->value)
      {
!       if (quote && contains_shell_metas (var->value))
  	{
! 	  t = single_quote (var->value);
  	  printf ("%s", t);
  	  free (t);
--- 876,886 ----
    if (var->value)
      {
!       if (quote && sh_contains_shell_metas (var->value))
  	{
! #if 0
! 	  t = sh_single_quote (var->value);
! #else
! 	  t = ansic_quote (var->value, 0, (int *)0);
! #endif
  	  printf ("%s", t);
  	  free (t);
***************
*** 869,873 ****
  /* **************************************************************** */
  /*								    */
! /*		 Dynamic Variable Extension		            */
  /*								    */
  /* **************************************************************** */
--- 926,930 ----
  /* **************************************************************** */
  /*								    */
! /*		 Dynamic Variable Extension			    */
  /*								    */
  /* **************************************************************** */
***************
*** 989,998 ****
  }
  
! static SHELL_VAR *
! get_random (var)
!      SHELL_VAR *var;
  {
    int rv;
-   char *p;
  
    /* Reset for command and process substitution. */
--- 1046,1053 ----
  }
  
! int
! get_random_number ()
  {
    int rv;
  
    /* Reset for command and process substitution. */
***************
*** 1003,1007 ****
--- 1058,1072 ----
      rv = brand ();
    while (rv == (int)last_random_value);
+   return rv;
+ }
+ 
+ static SHELL_VAR *
+ get_random (var)
+      SHELL_VAR *var;
+ {
+   int rv;
+   char *p;
  
+   rv = get_random_number ();
    last_random_value = rv;
    p = itos ((int)rv);
***************
*** 1165,1172 ****
  #if defined (ARRAY_VARS)
    INIT_DYNAMIC_ARRAY_VAR ("GROUPS", get_groupset, null_array_assign);
  #endif
  
    INIT_DYNAMIC_VAR ("FUNCNAME", (char *)NULL, get_funcname, null_assign);
!   VSETATTR (v, att_invisible);
  }
  
--- 1230,1238 ----
  #if defined (ARRAY_VARS)
    INIT_DYNAMIC_ARRAY_VAR ("GROUPS", get_groupset, null_array_assign);
+   VSETATTR (v, att_noassign);
  #endif
  
    INIT_DYNAMIC_VAR ("FUNCNAME", (char *)NULL, get_funcname, null_assign);
!   VSETATTR (v, att_invisible|att_noassign);
  }
  
***************
*** 1192,1196 ****
       int search_tempenv;
  {
!   SHELL_VAR *var = (SHELL_VAR *)NULL;
  
    /* If explicitly requested, first look in the temporary environment for
--- 1258,1264 ----
       int search_tempenv;
  {
!   SHELL_VAR *var;
! 
!   var = (SHELL_VAR *)NULL;
  
    /* If explicitly requested, first look in the temporary environment for
***************
*** 1236,1244 ****
  char *
  get_string_value (var_name)
!      char *var_name;
  {
    SHELL_VAR *var;
  
!   var = find_variable (var_name);
  
    if (!var)
--- 1304,1312 ----
  char *
  get_string_value (var_name)
!      const char *var_name;
  {
    SHELL_VAR *var;
  
!   var = find_variable ((char *)var_name);	/* XXX fix later */
  
    if (!var)
***************
*** 1254,1259 ****
  /* This is present for use by the tilde and readline libraries. */
  char *
! get_env_value (v)
!      char *v;
  {
    return get_string_value (v);
--- 1322,1327 ----
  /* This is present for use by the tilde and readline libraries. */
  char *
! sh_get_env_value (v)
!      const char *v;
  {
    return get_string_value (v);
***************
*** 1267,1270 ****
--- 1335,1339 ----
    SHELL_VAR *new_var, *old_var;
    BUCKET_CONTENTS *elt;
+   int old_var_context;
  
    /* local foo; local foo;  is a no-op. */
***************
*** 1275,1282 ****
    /* Since this is called only from the local/declare/typeset code, we can
       call builtin_error here without worry (of course, it will also work
!      for anything that sets this_command_name). */
!   if (old_var && readonly_p (old_var))
      {
!       builtin_error ("%s: readonly variable");
        return ((SHELL_VAR *)NULL);
      }
--- 1344,1357 ----
    /* Since this is called only from the local/declare/typeset code, we can
       call builtin_error here without worry (of course, it will also work
!      for anything that sets this_command_name).  Variables with the `noassign'
!      attribute may not be made local.  The test against old_var's context
!      level is to disallow local copies of readonly global variables (since I
!      believe that this could be a security hole).  Readonly copies of calling
!      function local variables are OK. */
!   if (old_var && (noassign_p (old_var) ||
! 		 (readonly_p (old_var) && old_var->context == 0)))
      {
!       if (readonly_p (old_var))
! 	builtin_error ("%s: readonly variable");
        return ((SHELL_VAR *)NULL);
      }
***************
*** 1379,1382 ****
--- 1454,1461 ----
    entry->prev_context = (SHELL_VAR *)NULL;
  
+   /* Make sure we have a shell_variables hash table to add to. */
+   if (shell_variables == 0)
+     shell_variables = make_hash_table (0);
+ 
    elt = add_hash_item (savestring (name), shell_variables);
    elt->data = (char *)entry;
***************
*** 1445,1450 ****
  {
    char *newval;
!   SHELL_VAR *entry;
  
    entry = var_lookup (name, shell_variables);
  
--- 1524,1549 ----
  {
    char *newval;
!   SHELL_VAR *entry, *tempenv_entry;
!   int found_in_tempenv;
  
+   entry = (SHELL_VAR *)0;
+   found_in_tempenv = 0;
+ 
+   /* If we have a temporary environment, look there first for the variable,
+      and, if found, modify the value there before modifying it in the
+      shell_variables table.  This allows sourced scripts to modify values
+      given to them in a temporary environment while modifying the variable
+      value that the caller sees. */
+   if (temporary_env || builtin_env || function_env)
+     {
+       tempenv_entry = find_tempenv_variable (name);
+       if (tempenv_entry)
+ 	{
+ 	  dispose_variable (tempenv_entry);
+ 	  tempenv_entry = bind_tempenv_variable (name, value);
+ 	  dispose_variable (tempenv_entry);
+ 	}
+     }
+     
    entry = var_lookup (name, shell_variables);
  
***************
*** 1454,1462 ****
        entry->value = make_variable_value (entry, value);
      }
! #if defined (ARRAY_VARS)
!   else if (entry->assign_func && array_p (entry) == 0)
! #else
!   else if (entry->assign_func)
! #endif
      {
        INVALIDATE_EXPORTSTR (entry);
--- 1553,1557 ----
        entry->value = make_variable_value (entry, value);
      }
!   else if (entry->assign_func)	/* array vars have assign functions now */
      {
        INVALIDATE_EXPORTSTR (entry);
***************
*** 1465,1471 ****
    else
      {
!       if (readonly_p (entry))
  	{
! 	  report_error ("%s: readonly variable", name);
  	  return (entry);
  	}
--- 1560,1567 ----
    else
      {
!       if (readonly_p (entry) || noassign_p (entry))
  	{
! 	  if (readonly_p (entry))
! 	    report_error ("%s: readonly variable", name);
  	  return (entry);
  	}
***************
*** 1615,1621 ****
    if (entry == (SHELL_VAR *) 0)
      entry = make_new_array_variable (name);
!   else if (readonly_p (entry))
      {
!       report_error ("%s: readonly variable", name);
        return (entry);
      }
--- 1711,1718 ----
    if (entry == (SHELL_VAR *) 0)
      entry = make_new_array_variable (name);
!   else if (readonly_p (entry) || noassign_p (entry))
      {
!       if (readonly_p (entry))
! 	report_error ("%s: readonly variable", name);
        return (entry);
      }
***************
*** 1645,1651 ****
    if (var == 0)
      var = make_new_array_variable (name);
!   else if (readonly_p (var))
      {
!       report_error ("%s: readonly variable", name);
        return ((SHELL_VAR *)NULL);
      }
--- 1742,1749 ----
    if (var == 0)
      var = make_new_array_variable (name);
!   else if (readonly_p (var) || noassign_p (var))
      {
!       if (readonly_p (var))
! 	report_error ("%s: readonly variable", name);
        return ((SHELL_VAR *)NULL);
      }
***************
*** 1730,1734 ****
        val = extract_array_assignment_list (value, &ni);
        if (val == 0)
!         return var;
      }
    else
--- 1828,1832 ----
        val = extract_array_assignment_list (value, &ni);
        if (val == 0)
! 	return var;
      }
    else
***************
*** 1811,1815 ****
  
        if (integer_p (var))
!         this_command_name = (char *)NULL;	/* no command name for errors */
        nval = make_variable_value (var, val);
        if (var->assign_func)
--- 1909,1913 ----
  
        if (integer_p (var))
! 	this_command_name = (char *)NULL;	/* no command name for errors */
        nval = make_variable_value (var, val);
        if (var->assign_func)
***************
*** 2395,2399 ****
      {
        if (plen == 0 || STREQN (prefix, varlist[vind]->name, plen))
!         rlist[rind++] = savestring (varlist[vind]->name);
      }
    rlist[rind] = (char *)0;
--- 2493,2497 ----
      {
        if (plen == 0 || STREQN (prefix, varlist[vind]->name, plen))
! 	rlist[rind++] = savestring (varlist[vind]->name);
      }
    rlist[rind] = (char *)0;
***************
*** 2438,2442 ****
      {
        if (*s == '=')
!         break;
        if (legal_variable_char (*s) == 0)
  	{
--- 2536,2540 ----
      {
        if (*s == '=')
! 	break;
        if (legal_variable_char (*s) == 0)
  	{
***************
*** 2476,2498 ****
    for (i = 0, list_index = 0; var = vars[i]; i++)
      {
!       if (var->exportstr)
!         {
! #if defined(__CYGWIN__) || defined (__CYGWIN32__)
! 	  INVALIDATE_EXPORTSTR (var);
! 	  value = value_cell (var);
! #else
! 	  /* XXX -- this test can go away in the next release, to be replaced
! 	     by a simple `value = var->exportstr;', when the exportstr code
! 	     is better-tested.  Until then, don't do it for cygwin at all,
! 	     since that system has some weird environment variables. */
!           if (valid_exportstr (var))
! 	    value = var->exportstr;
! 	  else
! 	    {
! 	      INVALIDATE_EXPORTSTR (var);
! 	      value = value_cell (var);
! 	    }
  #endif
!         }
        else if (function_p (var))
  	value = named_function_string ((char *)NULL, function_cell (var), 0);
--- 2574,2583 ----
    for (i = 0, list_index = 0; var = vars[i]; i++)
      {
! #if defined (__CYGWIN__)
!       /* We don't use the exportstr stuff on Cygwin at all. */
!       INVALIDATE_EXPORTSTR (var);
  #endif
!       if (var->exportstr)
! 	value = var->exportstr;
        else if (function_p (var))
  	value = named_function_string ((char *)NULL, function_cell (var), 0);
***************
*** 2557,2566 ****
  
        var = find_variable (name);
!       if (var && readonly_p (var))
  	{
! 	  report_error ("%s: readonly variable", name);
  	  free (name);
    	  return (0);
  	}
        temp = name + offset + 1;
        temp = (strchr (temp, '~') != 0) ? bash_tilde_expand (temp) : savestring (temp);
--- 2642,2653 ----
  
        var = find_variable (name);
!       if (var && (readonly_p (var) || noassign_p (var)))
  	{
! 	  if (readonly_p (var))
! 	    report_error ("%s: readonly variable", name);
  	  free (name);
    	  return (0);
  	}
+ 
        temp = name + offset + 1;
        temp = (strchr (temp, '~') != 0) ? bash_tilde_expand (temp) : savestring (temp);
***************
*** 2604,2607 ****
--- 2691,2756 ----
  }
  
+ /* Create a SHELL_VAR from a `name=value' string as in the environment, taking
+    the variable name, the environment string, and an index into the string
+    which is the offset of the `=' (the char before the value begins). */
+ static SHELL_VAR *
+ shell_var_from_env_string (name, env_string, l)
+      char *name, *env_string;
+      int l;
+ {
+   SHELL_VAR *temp;
+   char *w;
+ 
+   /* This is a potential memory leak.  The code should really save
+      the created variables in some auxiliary data structure, which
+      can be disposed of at the appropriate time. */
+   temp = new_shell_variable (name);
+   w = env_string + l + 1;
+ 
+   temp->value = *w ? savestring (w) : (char *)NULL;
+ 
+   temp->attributes = att_exported|att_tempvar;
+   temp->context = 0;
+   temp->prev_context = (SHELL_VAR *)NULL;
+ 
+   temp->dynamic_value = temp->assign_func = (DYNAMIC_FUNC *)NULL;
+   CLEAR_EXPORTSTR (temp);
+ 
+   return (temp);
+ }
+ 
+ /* Bind NAME to VALUE in ARRAY, an array of strings in the same format as the
+    environment array (i.e, name=value).  If NAME is present, change the value,
+    cons up a new SHELL_VAR and return it.  Otherwise return (SHELL_VAR *)NULL. */
+ 
+ static SHELL_VAR *
+ bind_name_in_env_array (name, value, array)
+      char *name, *value;
+      char **array;
+ {
+   register int i, l;
+   char *new_env_string, *w;
+   SHELL_VAR *temp;
+ 
+   if (array == 0)
+     return ((SHELL_VAR *)NULL);
+ 
+   for (i = 0, l = strlen (name); array[i]; i++)
+     {
+       if (STREQN (array[i], name, l) && array[i][l] == '=')
+ 	{
+ 	  new_env_string = mk_env_string (name, value);
+ 
+ 	  temp = shell_var_from_env_string (name, new_env_string, l);
+ 
+ 	  free (array[i]);
+ 	  array[i] = new_env_string;
+ 
+ 	  return (temp);
+ 	}
+     }
+   return ((SHELL_VAR *)NULL);
+ }
+ 
  /* Search for NAME in ARRAY, an array of strings in the same format as the
     environment array (i.e, name=value).  If NAME is present, make a new
***************
*** 2613,2616 ****
--- 2762,2766 ----
  {
    register int i, l;
+   SHELL_VAR *temp;
  
    if (array == 0)
***************
*** 2621,2642 ****
        if (STREQN (array[i], name, l) && array[i][l] == '=')
  	{
! 	  SHELL_VAR *temp;
! 	  char *w;
! 
! 	  /* This is a potential memory leak.  The code should really save
! 	     the created variables in some auxiliary data structure, which
! 	     can be disposed of at the appropriate time. */
! 	  temp = new_shell_variable (name);
! 	  w = array[i] + l + 1;
! 
! 	  temp->value = *w ? savestring (w) : (char *)NULL;
! 
! 	  temp->attributes = att_exported|att_tempvar;
! 	  temp->context = 0;
! 	  temp->prev_context = (SHELL_VAR *)NULL;
! 
! 	  temp->dynamic_value = temp->assign_func = (DYNAMIC_FUNC *)NULL;
! 	  CLEAR_EXPORTSTR (temp);
! 
  	  return (temp);
  	}
--- 2771,2775 ----
        if (STREQN (array[i], name, l) && array[i][l] == '=')
  	{
! 	  temp = shell_var_from_env_string (name, array[i], l);
  	  return (temp);
  	}
***************
*** 2645,2648 ****
--- 2778,2818 ----
  }
  
+ #define FIND_AND_BIND_IN_ENV_ARRAY(N, V, A) \
+   do \
+     { \
+       var = find_name_in_env_array (N, A); \
+       if (var) \
+ 	{ \
+ 	  dispose_variable (var); \
+ 	  var = bind_name_in_env_array (N, V, A); \
+ 	  return (var); \
+ 	} \
+     } \
+   while (0)
+ 
+ /* Make variable NAME have VALUE in one of the temporary environments. */
+ static SHELL_VAR *
+ bind_tempenv_variable (name, value)
+      char *name, *value;
+ {
+   SHELL_VAR *var;
+ 
+   var = (SHELL_VAR *)NULL;
+ 
+   if (temporary_env)
+     FIND_AND_BIND_IN_ENV_ARRAY (name, value, temporary_env);
+ 
+   /* We don't check this_shell_builtin because the command that needs the
+      value from builtin_env may be a disk command run inside a script run
+      with `.' and a temporary env. */
+   if (builtin_env)
+     FIND_AND_BIND_IN_ENV_ARRAY (name, value, builtin_env);
+ 
+   if (variable_context && function_env)
+     FIND_AND_BIND_IN_ENV_ARRAY (name, value, function_env);
+ 
+   return (SHELL_VAR *)NULL;
+ }
+ 
  /* Find a variable in the temporary environment that is named NAME.
     The temporary environment can be either the environment provided
***************
*** 2748,2751 ****
--- 2918,2927 ----
  }
  
+ void
+ merge_function_env ()
+ {
+   merge_env_array (function_env);
+ }
+ 
  int
  any_temporary_variables ()
***************
*** 2826,2830 ****
  	{
  	  export_env_size = new_size;
!           export_env = (char **)xrealloc (export_env, export_env_size * sizeof (char *));
  	}
        export_env[export_env_index = 0] = (char *)NULL;
--- 3002,3006 ----
  	{
  	  export_env_size = new_size;
! 	  export_env = (char **)xrealloc (export_env, export_env_size * sizeof (char *));
  	}
        export_env[export_env_index = 0] = (char *)NULL;
***************
*** 2850,2853 ****
--- 3026,3033 ----
  	  export_env = add_or_supercede_exported_var (function_env[i], 1);
  
+       if (builtin_env)
+ 	for (i = 0; builtin_env[i]; i++)
+ 	  export_env = add_or_supercede_exported_var (builtin_env[i], 1);
+ 
        if (temporary_env)
  	for (i = 0; temporary_env[i]; i++)
***************
*** 3125,3129 ****
      {
        if (legal_number (temp, &num))
!         {
  	  if (name[4] == 'S')
  	    {
--- 3305,3309 ----
      {
        if (legal_number (temp, &num))
! 	{
  	  if (name[4] == 'S')
  	    {
diff -Nrc2 bash-2.04/variables.h bash-2.05/variables.h
*** bash-2.04/variables.h	Tue Mar  7 10:21:18 2000
--- bash-2.05/variables.h	Wed Feb 21 11:38:19 2001
***************
*** 81,84 ****
--- 81,85 ----
  #define att_tempvar   0x200	/* variable came from the temp environment */
  #define att_importstr 0x400	/* exportstr points into initial environment */
+ #define att_noassign  0x800	/* assignment not allowed */
  
  #define exported_p(var)		((((var)->attributes) & (att_exported)))
***************
*** 89,95 ****
  #define function_p(var)		((((var)->attributes) & (att_function)))
  #define integer_p(var)		((((var)->attributes) & (att_integer)))
! #define imported_p(var)         ((((var)->attributes) & (att_imported)))
  #define local_p(var)		((((var)->attributes) & (att_local)))
  #define tempvar_p(var)		((((var)->attributes) & (att_tempvar)))
  
  #define value_cell(var) ((var)->value)
--- 90,97 ----
  #define function_p(var)		((((var)->attributes) & (att_function)))
  #define integer_p(var)		((((var)->attributes) & (att_integer)))
! #define imported_p(var)		((((var)->attributes) & (att_imported)))
  #define local_p(var)		((((var)->attributes) & (att_local)))
  #define tempvar_p(var)		((((var)->attributes) & (att_tempvar)))
+ #define noassign_p(var)		((((var)->attributes) & (att_noassign)))
  
  #define value_cell(var) ((var)->value)
***************
*** 115,119 ****
  	    { \
  	      if (((var)->attributes & att_importstr) == 0) \
! 	        free ((var)->exportstr); \
  	    } \
  	} while (0)
--- 117,121 ----
  	    { \
  	      if (((var)->attributes & att_importstr) == 0) \
! 		free ((var)->exportstr); \
  	    } \
  	} while (0)
***************
*** 152,156 ****
  extern void initialize_shell_variables __P((char **, int));
  extern SHELL_VAR *set_if_not __P((char *, char *));
! extern void set_lines_and_columns __P((int, int));
  
  extern void set_ppid __P((void));
--- 154,160 ----
  extern void initialize_shell_variables __P((char **, int));
  extern SHELL_VAR *set_if_not __P((char *, char *));
! extern void sh_set_lines_and_columns __P((int, int));
! 
! extern void set_pwd __P((void));
  
  extern void set_ppid __P((void));
***************
*** 182,186 ****
  extern char **add_or_supercede_exported_var __P((char *, int));
  
! extern char *get_string_value __P((char *));
  extern char *make_variable_value __P((SHELL_VAR *, char *));
  
--- 186,190 ----
  extern char **add_or_supercede_exported_var __P((char *, int));
  
! extern char *get_string_value __P((const char *));
  extern char *make_variable_value __P((SHELL_VAR *, char *));
  
***************
*** 204,207 ****
--- 208,212 ----
  extern void merge_temporary_env __P((void));
  extern void merge_builtin_env __P((void));
+ extern void merge_function_env __P((void));
  extern void kill_all_local_variables __P((void));
  extern void set_var_read_only __P((char *));
***************
*** 215,218 ****
--- 220,224 ----
  extern void put_gnu_argv_flags_into_env __P((int, char *));
  extern void print_var_list __P((SHELL_VAR **));
+ extern void print_func_list __P((SHELL_VAR **));
  extern void print_assignment __P((SHELL_VAR *));
  extern void print_var_value __P((SHELL_VAR *, int));
***************
*** 241,244 ****
--- 247,252 ----
     is one of the special ones where something special happens. */
  extern void stupidly_hack_special_variables __P((char *));
+ 
+ extern int get_random_number __P((void));
  
  /* The `special variable' functions that get called when a particular
diff -Nrc2 bash-2.04/version.c bash-2.05/version.c
*** bash-2.04/version.c	Thu Aug  5 07:23:59 1999
--- bash-2.05/version.c	Mon Mar 20 11:27:27 2000
***************
*** 68,71 ****
    printf ("GNU bash, version %s (%s)\n", shell_version_string (), MACHTYPE);
    if (extended)
!     printf ("Copyright 1999 Free Software Foundation, Inc.\n");
  }
--- 68,71 ----
    printf ("GNU bash, version %s (%s)\n", shell_version_string (), MACHTYPE);
    if (extended)
!     printf ("Copyright 2000 Free Software Foundation, Inc.\n");
  }
diff -Nrc2 bash-2.04/y.tab.c bash-2.05/y.tab.c
*** bash-2.04/y.tab.c	Tue Feb 22 13:13:22 2000
--- bash-2.05/y.tab.c	Tue Mar 27 10:06:14 2001
***************
*** 1,51 ****
! 
! /*  A Bison parser, made from /usr/homes/chet/src/bash/src/parse.y
!  by  GNU Bison version 1.25
!   */
! 
! #define YYBISON 1  /* Identify Bison output.  */
! 
! #define	IF	258
! #define	THEN	259
! #define	ELSE	260
! #define	ELIF	261
! #define	FI	262
! #define	CASE	263
! #define	ESAC	264
! #define	FOR	265
! #define	SELECT	266
! #define	WHILE	267
! #define	UNTIL	268
! #define	DO	269
! #define	DONE	270
! #define	FUNCTION	271
! #define	COND_START	272
! #define	COND_END	273
! #define	COND_ERROR	274
! #define	IN	275
! #define	BANG	276
! #define	TIME	277
! #define	TIMEOPT	278
! #define	WORD	279
! #define	ASSIGNMENT_WORD	280
! #define	NUMBER	281
! #define	ARITH_CMD	282
! #define	ARITH_FOR_EXPRS	283
! #define	COND_CMD	284
! #define	AND_AND	285
! #define	OR_OR	286
! #define	GREATER_GREATER	287
! #define	LESS_LESS	288
! #define	LESS_AND	289
! #define	GREATER_AND	290
! #define	SEMI_SEMI	291
! #define	LESS_LESS_MINUS	292
! #define	AND_GREATER	293
! #define	LESS_GREATER	294
! #define	GREATER_BAR	295
! #define	yacc_EOF	296
! 
! #line 21 "/usr/homes/chet/src/bash/src/parse.y"
! 
  #include "config.h"
  
--- 1,18 ----
! #ifndef lint
! static char const 
! yyrcsid[] = "$FreeBSD: src/usr.bin/yacc/skeleton.c,v 1.28 2000/01/17 02:04:06 bde Exp $";
! #endif
! #include <stdlib.h>
! #define YYBYACC 1
! #define YYMAJOR 1
! #define YYMINOR 9
! #define YYLEX yylex()
! #define YYEMPTY -1
! #define yyclearin (yychar=(YYEMPTY))
! #define yyerrok (yyerrflag=0)
! #define YYRECOVERING() (yyerrflag!=0)
! static int yygrowstack();
! #define YYPREFIX "yy"
! #line 22 "/usr/homes/chet/src/bash/src/parse.y"
  #include "config.h"
  
***************
*** 53,56 ****
--- 20,25 ----
  #include "bashansi.h"
  
+ #include "filecntl.h"
+ 
  #if defined (HAVE_UNISTD_H)
  #  include <unistd.h>
***************
*** 106,112 ****
  
  #if defined (EXTENDED_GLOB)
- #define PATTERN_CHAR(c) \
- 	((c) == '@' || (c) == '*' || (c) == '+' || (c) == '?' || (c) == '!')
- 
  extern int extended_glob;
  #endif
--- 75,78 ----
***************
*** 156,159 ****
--- 122,129 ----
  static void print_prompt ();
  
+ #if defined (HISTORY)
+ char *history_delimiting_chars ();
+ #endif
+ 
  extern int yyerror ();
  
***************
*** 211,216 ****
  
  static REDIRECTEE redir;
! 
! #line 187 "/usr/homes/chet/src/bash/src/parse.y"
  typedef union {
    WORD_DESC *word;		/* the word that we read. */
--- 181,185 ----
  
  static REDIRECTEE redir;
! #line 190 "/usr/homes/chet/src/bash/src/parse.y"
  typedef union {
    WORD_DESC *word;		/* the word that we read. */
***************
*** 222,5281 ****
    PATTERN_LIST *pattern;
  } YYSTYPE;
! #include <stdio.h>
! 
! #ifndef __cplusplus
! #ifndef __STDC__
! #define const
! #endif
! #endif
! 
! 
! 
! #define	YYFINAL		279
! #define	YYFLAG		-32768
! #define	YYNTBASE	53
! 
! #define YYTRANSLATE(x) ((unsigned)(x) <= 296 ? yytranslate[x] : 87)
! 
! static const char yytranslate[] = {     0,
!      2,     2,     2,     2,     2,     2,     2,     2,     2,    43,
!      2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
!      2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
!      2,     2,     2,     2,     2,     2,     2,    41,     2,    51,
!     52,     2,     2,     2,    48,     2,     2,     2,     2,     2,
!      2,     2,     2,     2,     2,     2,     2,     2,    42,    47,
!      2,    46,     2,     2,     2,     2,     2,     2,     2,     2,
!      2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
!      2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
!      2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
!      2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
!      2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
!      2,     2,    49,    45,    50,     2,     2,     2,     2,     2,
!      2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
!      2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
!      2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
!      2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
!      2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
!      2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
!      2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
!      2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
!      2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
!      2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
!      2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
!      2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
!      2,     2,     2,     2,     2,     1,     2,     3,     4,     5,
!      6,     7,     8,     9,    10,    11,    12,    13,    14,    15,
!     16,    17,    18,    19,    20,    21,    22,    23,    24,    25,
!     26,    27,    28,    29,    30,    31,    32,    33,    34,    35,
!     36,    37,    38,    39,    40,    44
  };
! 
! #if YYDEBUG != 0
! static const short yyprhs[] = {     0,
!      0,     3,     5,     8,    10,    12,    15,    18,    21,    25,
!     29,    32,    36,    39,    43,    46,    50,    53,    57,    60,
!     64,    67,    71,    74,    78,    81,    85,    88,    92,    95,
!     99,   102,   105,   109,   111,   113,   115,   117,   120,   122,
!    125,   127,   129,   132,   134,   136,   142,   148,   150,   152,
!    154,   156,   158,   160,   162,   164,   171,   178,   186,   194,
!    205,   216,   224,   232,   239,   246,   254,   262,   273,   284,
!    291,   299,   306,   312,   319,   324,   328,   334,   342,   349,
!    353,   355,   359,   364,   371,   377,   379,   382,   387,   392,
!    398,   404,   407,   411,   413,   417,   420,   422,   425,   429,
!    433,   437,   442,   447,   452,   457,   462,   464,   466,   468,
!    470,   471,   474,   476,   479,   482,   487,   492,   496,   500,
!    502,   504,   507,   510,   514,   518,   523,   525,   527
! };
! 
! static const short yyrhs[] = {    82,
!     43,     0,    43,     0,     1,    43,     0,    44,     0,    24,
!      0,    54,    24,     0,    46,    24,     0,    47,    24,     0,
!     26,    46,    24,     0,    26,    47,    24,     0,    32,    24,
!      0,    26,    32,    24,     0,    33,    24,     0,    26,    33,
!     24,     0,    34,    26,     0,    26,    34,    26,     0,    35,
!     26,     0,    26,    35,    26,     0,    34,    24,     0,    26,
!     34,    24,     0,    35,    24,     0,    26,    35,    24,     0,
!     37,    24,     0,    26,    37,    24,     0,    35,    48,     0,
!     26,    35,    48,     0,    34,    48,     0,    26,    34,    48,
!      0,    38,    24,     0,    26,    39,    24,     0,    39,    24,
!      0,    40,    24,     0,    26,    40,    24,     0,    24,     0,
!     25,     0,    55,     0,    55,     0,    57,    55,     0,    56,
!      0,    58,    56,     0,    58,     0,    60,     0,    60,    57,
!      0,    61,     0,    64,     0,    12,    77,    14,    77,    15,
!      0,    13,    77,    14,    77,    15,     0,    63,     0,    67,
!      0,    66,     0,    68,     0,    69,     0,    70,     0,    62,
!      0,    65,     0,    10,    24,    81,    14,    77,    15,     0,
!     10,    24,    81,    49,    77,    50,     0,    10,    24,    42,
!     81,    14,    77,    15,     0,    10,    24,    42,    81,    49,
!     77,    50,     0,    10,    24,    81,    20,    54,    80,    81,
!     14,    77,    15,     0,    10,    24,    81,    20,    54,    80,
!     81,    49,    77,    50,     0,    10,    28,    80,    81,    14,
!     77,    15,     0,    10,    28,    80,    81,    49,    77,    50,
!      0,    11,    24,    81,    14,    76,    15,     0,    11,    24,
!     81,    49,    76,    50,     0,    11,    24,    42,    81,    14,
!     76,    15,     0,    11,    24,    42,    81,    49,    76,    50,
!      0,    11,    24,    81,    20,    54,    80,    81,    14,    76,
!     15,     0,    11,    24,    81,    20,    54,    80,    81,    49,
!     76,    50,     0,     8,    24,    81,    20,    81,     9,     0,
!      8,    24,    81,    20,    74,    81,     9,     0,     8,    24,
!     81,    20,    72,     9,     0,    24,    51,    52,    81,    68,
!      0,    16,    24,    51,    52,    81,    68,     0,    16,    24,
!     81,    68,     0,    51,    77,    52,     0,     3,    77,     4,
!     77,     7,     0,     3,    77,     4,    77,     5,    77,     7,
!      0,     3,    77,     4,    77,    71,     7,     0,    49,    76,
!     50,     0,    27,     0,    17,    29,    18,     0,     6,    77,
!      4,    77,     0,     6,    77,     4,    77,     5,    77,     0,
!      6,    77,     4,    77,    71,     0,    73,     0,    74,    73,
!      0,    81,    75,    52,    77,     0,    81,    75,    52,    81,
!      0,    81,    51,    75,    52,    77,     0,    81,    51,    75,
!     52,    81,     0,    73,    36,     0,    74,    73,    36,     0,
!     24,     0,    75,    45,    24,     0,    81,    78,     0,    76,
!      0,    81,    79,     0,    79,    43,    81,     0,    79,    41,
!     81,     0,    79,    42,    81,     0,    79,    30,    81,    79,
!      0,    79,    31,    81,    79,     0,    79,    41,    81,    79,
!      0,    79,    42,    81,    79,     0,    79,    43,    81,    79,
!      0,    84,     0,    43,     0,    42,     0,    44,     0,     0,
!     81,    43,     0,    83,     0,    83,    41,     0,    83,    42,
!      0,    83,    30,    81,    83,     0,    83,    31,    81,    83,
!      0,    83,    41,    83,     0,    83,    42,    83,     0,    84,
!      0,    85,     0,    21,    85,     0,    86,    85,     0,    86,
!     21,    85,     0,    21,    86,    85,     0,    85,    45,    81,
!     85,     0,    59,     0,    22,     0,    22,    23,     0
! };
! 
! #endif
! 
! #if YYDEBUG != 0
! static const short yyrline[] = { 0,
!    237,   246,   253,   268,   278,   280,   284,   289,   294,   299,
!    304,   309,   314,   320,   326,   331,   336,   341,   346,   351,
!    356,   361,   366,   373,   380,   385,   390,   395,   400,   405,
!    410,   415,   420,   427,   429,   431,   435,   439,   450,   452,
!    456,   458,   460,   497,   499,   501,   503,   505,   507,   509,
!    511,   513,   515,   517,   519,   523,   525,   527,   529,   531,
!    533,   537,   539,   542,   546,   550,   554,   558,   562,   568,
!    570,   572,   576,   580,   583,   587,   594,   596,   598,   603,
!    607,   611,   615,   617,   619,   623,   624,   628,   630,   632,
!    634,   638,   639,   643,   645,   654,   662,   663,   669,   670,
!    677,   681,   683,   685,   692,   694,   696,   700,   701,   702,
!    705,   706,   715,   721,   730,   738,   740,   742,   749,   752,
!    756,   758,   763,   768,   773,   780,   783,   787,   789
! };
! #endif
! 
! 
! #if YYDEBUG != 0 || defined (YYERROR_VERBOSE)
! 
! static const char * const yytname[] = {   "$","error","$undefined.","IF","THEN",
! "ELSE","ELIF","FI","CASE","ESAC","FOR","SELECT","WHILE","UNTIL","DO","DONE",
! "FUNCTION","COND_START","COND_END","COND_ERROR","IN","BANG","TIME","TIMEOPT",
! "WORD","ASSIGNMENT_WORD","NUMBER","ARITH_CMD","ARITH_FOR_EXPRS","COND_CMD","AND_AND",
! "OR_OR","GREATER_GREATER","LESS_LESS","LESS_AND","GREATER_AND","SEMI_SEMI","LESS_LESS_MINUS",
! "AND_GREATER","LESS_GREATER","GREATER_BAR","'&'","';'","'\\n'","yacc_EOF","'|'",
! "'>'","'<'","'-'","'{'","'}'","'('","')'","inputunit","word_list","redirection",
! "simple_command_element","redirection_list","simple_command","command","shell_command",
! "for_command","arith_for_command","select_command","case_command","function_def",
! "subshell","if_command","group_command","arith_command","cond_command","elif_clause",
! "case_clause","pattern_list","case_clause_sequence","pattern","list","compound_list",
! "list0","list1","list_terminator","newline_list","simple_list","simple_list1",
! "pipeline_command","pipeline","timespec", NULL
  };
! #endif
! 
! static const short yyr1[] = {     0,
!     53,    53,    53,    53,    54,    54,    55,    55,    55,    55,
!     55,    55,    55,    55,    55,    55,    55,    55,    55,    55,
!     55,    55,    55,    55,    55,    55,    55,    55,    55,    55,
!     55,    55,    55,    56,    56,    56,    57,    57,    58,    58,
!     59,    59,    59,    60,    60,    60,    60,    60,    60,    60,
!     60,    60,    60,    60,    60,    61,    61,    61,    61,    61,
!     61,    62,    62,    63,    63,    63,    63,    63,    63,    64,
!     64,    64,    65,    65,    65,    66,    67,    67,    67,    68,
!     69,    70,    71,    71,    71,    72,    72,    73,    73,    73,
!     73,    74,    74,    75,    75,    76,    77,    77,    78,    78,
!     78,    79,    79,    79,    79,    79,    79,    80,    80,    80,
!     81,    81,    82,    82,    82,    83,    83,    83,    83,    83,
!     84,    84,    84,    84,    84,    85,    85,    86,    86
  };
! 
! static const short yyr2[] = {     0,
!      2,     1,     2,     1,     1,     2,     2,     2,     3,     3,
!      2,     3,     2,     3,     2,     3,     2,     3,     2,     3,
!      2,     3,     2,     3,     2,     3,     2,     3,     2,     3,
!      2,     2,     3,     1,     1,     1,     1,     2,     1,     2,
!      1,     1,     2,     1,     1,     5,     5,     1,     1,     1,
!      1,     1,     1,     1,     1,     6,     6,     7,     7,    10,
!     10,     7,     7,     6,     6,     7,     7,    10,    10,     6,
!      7,     6,     5,     6,     4,     3,     5,     7,     6,     3,
!      1,     3,     4,     6,     5,     1,     2,     4,     4,     5,
!      5,     2,     3,     1,     3,     2,     1,     2,     3,     3,
!      3,     4,     4,     4,     4,     4,     1,     1,     1,     1,
!      0,     2,     1,     2,     2,     4,     4,     3,     3,     1,
!      1,     2,     2,     3,     3,     4,     1,     1,     2
  };
! 
! static const short yydefact[] = {     0,
!      0,   111,     0,     0,     0,   111,   111,     0,     0,     0,
!    128,    34,    35,     0,    81,     0,     0,     0,     0,     0,
!      0,     0,     0,     2,     4,     0,     0,   111,   111,    36,
!     39,    41,   127,    42,    44,    54,    48,    45,    55,    50,
!     49,    51,    52,    53,     0,   113,   120,   121,     0,     3,
!     97,     0,     0,   111,   111,     0,   111,     0,     0,   111,
!      0,   122,     0,   129,     0,     0,     0,     0,     0,     0,
!      0,     0,     0,     0,    11,    13,    19,    15,    27,    21,
!     17,    25,    23,    29,    31,    32,     7,     8,     0,     0,
!      0,    34,    40,    37,    43,     1,   111,   111,   114,   115,
!    111,     0,   123,   111,   112,    96,    98,   107,     0,   111,
!      0,   109,   108,   110,   111,   111,     0,   111,   111,     0,
!      0,    82,   125,   111,    12,    14,    20,    16,    28,    22,
!     18,    26,    24,    30,    33,     9,    10,    80,     0,    76,
!     38,     0,     0,   118,   119,     0,   124,     0,   111,   111,
!    111,   111,   111,   111,     0,   111,     0,   111,     0,     0,
!    111,     0,   111,     0,     0,   111,    75,     0,   116,   117,
!      0,     0,   126,   111,   111,    77,     0,     0,     0,   100,
!    101,    99,     0,    86,   111,     0,   111,   111,     0,     5,
!      0,     0,   111,   111,   111,   111,     0,     0,     0,    46,
!     47,     0,    73,     0,     0,    79,   102,   103,   104,   105,
!    106,    72,    92,    87,     0,    70,    94,     0,     0,     0,
!      0,    56,     6,   111,    57,     0,     0,     0,     0,    64,
!    111,    65,    74,    78,   111,   111,   111,   111,    93,    71,
!      0,     0,   111,    58,    59,     0,    62,    63,    66,    67,
!      0,    83,     0,     0,     0,   111,    95,    88,    89,   111,
!    111,   111,   111,   111,    85,    90,    91,     0,     0,     0,
!      0,    84,    60,    61,    68,    69,     0,     0,     0
  };
! 
! static const short yydefgoto[] = {   277,
!    191,    30,    31,    95,    32,    33,    34,    35,    36,    37,
!     38,    39,    40,    41,    42,    43,    44,   177,   183,   184,
!    185,   219,    51,    52,   106,   107,   115,    53,    45,   144,
!    108,    48,    49
  };
! 
! static const short yypact[] = {   256,
!     -9,-32768,    28,    54,    31,-32768,-32768,    38,   -14,   382,
!     49,    24,-32768,   188,-32768,    41,    56,    35,    42,    61,
!     73,    75,   100,-32768,-32768,   111,   112,-32768,-32768,-32768,
! -32768,   171,-32768,   530,-32768,-32768,-32768,-32768,-32768,-32768,
! -32768,-32768,-32768,-32768,    95,   124,-32768,    59,   424,-32768,
! -32768,   136,   298,-32768,   104,    64,   107,   137,   142,   106,
!    140,    59,   508,-32768,   108,   135,   138,    45,    55,   139,
!    143,   146,   154,   155,-32768,-32768,-32768,-32768,-32768,-32768,
! -32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,   114,   298,
!    131,-32768,-32768,-32768,   530,-32768,-32768,-32768,   340,   340,
! -32768,   508,    59,-32768,-32768,-32768,    80,-32768,    -8,-32768,
!     -4,-32768,-32768,-32768,-32768,-32768,    -1,-32768,-32768,   132,
!    -11,-32768,    59,-32768,-32768,-32768,-32768,-32768,-32768,-32768,
! -32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,    80,-32768,
! -32768,   298,   298,    89,    89,   466,    59,    82,-32768,-32768,
! -32768,-32768,-32768,-32768,    -3,-32768,   156,-32768,     4,    11,
! -32768,   156,-32768,   170,   177,-32768,-32768,   -11,-32768,-32768,
!    340,   340,    59,-32768,-32768,-32768,   179,   298,   298,   298,
!    298,   298,   184,   158,-32768,    -2,-32768,-32768,   183,-32768,
!     52,   149,-32768,-32768,-32768,-32768,   186,    52,   152,-32768,
! -32768,   -11,-32768,   208,   212,-32768,-32768,-32768,   101,   101,
!    101,-32768,-32768,   190,     0,-32768,-32768,   200,   -31,   215,
!    181,-32768,-32768,-32768,-32768,   218,   191,   221,   194,-32768,
! -32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,
!    -25,   216,-32768,-32768,-32768,    14,-32768,-32768,-32768,-32768,
!     15,   128,   298,   298,   298,-32768,-32768,-32768,   298,-32768,
! -32768,-32768,-32768,-32768,-32768,-32768,   298,   230,   196,   232,
!    198,-32768,-32768,-32768,-32768,-32768,   249,   251,-32768
  };
! 
! static const short yypgoto[] = {-32768,
!     90,   -28,   224,-32768,-32768,-32768,-32768,-32768,-32768,-32768,
! -32768,-32768,-32768,-32768,  -118,-32768,-32768,     1,-32768,    76,
! -32768,    44,   -20,    -6,-32768,   -64,  -154,   -24,-32768,     5,
!      2,     7,   250
  };
! 
! 
! #define	YYLAST		577
! 
! 
! static const short yytable[] = {    58,
!     59,    47,   167,    90,    46,    94,   216,    89,   240,   156,
!    187,   154,   161,   242,    61,   157,    62,   193,   162,   242,
!    243,   217,    91,   217,   195,   139,   256,   260,   262,   109,
!    111,   105,   117,    50,   105,   121,   224,    28,   105,   105,
!    105,   105,   105,   231,   158,   188,   105,   163,   218,   203,
!    218,    54,   194,   105,    57,   103,   105,   105,    77,   196,
!     78,    60,   261,   263,    75,    80,   141,    81,   127,   123,
!    128,    64,   142,   143,    65,   223,   146,    55,   130,    76,
!    131,    56,    79,   233,    83,   155,   174,   175,   176,    82,
!    159,   160,   129,   112,   113,   114,    84,   148,    85,   168,
!     47,    47,   132,   101,   145,   112,   113,   114,   147,   149,
!    150,   164,   165,   207,   208,   209,   210,   211,    97,    98,
!    151,   152,   153,    86,   178,   179,   180,   181,   182,   186,
!    149,   150,   264,   175,    87,    88,    90,    96,    90,   104,
!    197,   202,   199,    47,    47,   110,   169,   170,   116,   189,
!    118,   192,   173,    97,    98,   119,   120,   122,   125,   124,
!    215,   126,   133,   138,    99,   100,   134,   204,   205,   135,
!     90,    90,    47,    47,   228,   229,   145,   136,   137,   190,
!    220,   221,   140,   166,   200,   206,   226,   227,   209,   210,
!    211,   201,   212,   213,    92,    13,    14,   222,   225,   246,
!    230,   232,    16,    17,    18,    19,   251,    20,    21,    22,
!     23,   253,   254,   255,   234,   235,    26,    27,   259,    66,
!     67,    68,    69,   217,    70,   239,    71,    72,   252,   244,
!    245,   267,   247,    73,    74,   249,   258,    90,    90,   257,
!    248,   270,   271,   250,   273,   274,   275,   276,   278,   266,
!    279,   198,   265,   268,   269,    93,     1,   272,     2,    63,
!    214,   241,     0,     3,     0,     4,     5,     6,     7,     0,
!      0,     8,     9,     0,     0,     0,    10,    11,     0,    12,
!     13,    14,    15,     0,     0,     0,     0,    16,    17,    18,
!     19,     0,    20,    21,    22,    23,     0,     0,    24,    25,
!      2,    26,    27,     0,    28,     3,    29,     4,     5,     6,
!      7,     0,     0,     8,     9,     0,     0,     0,    10,    11,
!      0,    12,    13,    14,    15,     0,     0,     0,     0,    16,
!     17,    18,    19,     0,    20,    21,    22,    23,     0,     0,
!    105,     0,     2,    26,    27,     0,    28,     3,    29,     4,
!      5,     6,     7,     0,     0,     8,     9,     0,     0,     0,
!     10,    11,     0,    12,    13,    14,    15,     0,     0,     0,
!      0,    16,    17,    18,    19,     0,    20,    21,    22,    23,
!      0,     0,     0,     0,     2,    26,    27,     0,    28,     3,
!     29,     4,     5,     6,     7,     0,     0,     8,     9,     0,
!      0,     0,     0,    11,     0,    12,    13,    14,    15,     0,
!      0,     0,     0,    16,    17,    18,    19,     0,    20,    21,
!     22,    23,     0,     0,     0,     0,     2,    26,    27,     0,
!     28,     3,    29,     4,     5,     6,     7,     0,     0,     8,
!      9,     0,     0,     0,   102,     0,     0,    12,    13,    14,
!     15,     0,     0,     0,     0,    16,    17,    18,    19,     0,
!     20,    21,    22,    23,     0,     0,     0,     0,     2,    26,
!     27,     0,    28,     3,    29,     4,     5,     6,     7,     0,
!      0,     8,     9,     0,     0,     0,     0,     0,     0,    12,
!     13,    14,    15,     0,     0,     0,     0,    16,    17,    18,
!     19,     0,    20,    21,    22,    23,     0,     0,   105,     0,
!      2,    26,    27,     0,    28,     3,    29,     4,     5,     6,
!      7,     0,     0,     8,     9,     0,     0,     0,     0,     0,
!      0,    12,    13,    14,    15,     0,     0,     0,     0,    16,
!     17,    18,    19,     0,    20,    21,    22,    23,     0,     0,
!      0,     0,     0,    26,    27,    14,    28,     0,    29,     0,
!      0,    16,    17,    18,    19,     0,    20,    21,    22,    23,
!      0,     0,     0,     0,     0,    26,    27
  };
! 
! static const short yycheck[] = {     6,
!      7,     0,   121,    28,     0,    34,     9,    28,     9,    14,
!     14,    20,    14,    45,    29,    20,    10,    14,    20,    45,
!     52,    24,    29,    24,    14,    90,    52,    14,    14,    54,
!     55,    43,    57,    43,    43,    60,   191,    49,    43,    43,
!     43,    43,    43,   198,    49,    49,    43,    49,    51,   168,
!     51,    24,    49,    43,    24,    49,    43,    43,    24,    49,
!     26,    24,    49,    49,    24,    24,    95,    26,    24,    63,
!     26,    23,    97,    98,    51,    24,   101,    24,    24,    24,
!     26,    28,    48,   202,    24,   110,     5,     6,     7,    48,
!    115,   116,    48,    42,    43,    44,    24,   104,    24,   124,
!     99,   100,    48,    45,   100,    42,    43,    44,   102,    30,
!     31,   118,   119,   178,   179,   180,   181,   182,    30,    31,
!     41,    42,    43,    24,   149,   150,   151,   152,   153,   154,
!     30,    31,     5,     6,    24,    24,   161,    43,   163,     4,
!    161,   166,   163,   142,   143,    42,   142,   143,    42,   156,
!     14,   158,   146,    30,    31,    14,    51,    18,    24,    52,
!    185,    24,    24,    50,    41,    42,    24,   174,   175,    24,
!    195,   196,   171,   172,   195,   196,   172,    24,    24,    24,
!    187,   188,    52,    52,    15,     7,   193,   194,   253,   254,
!    255,    15,     9,    36,    24,    25,    26,    15,    50,   224,
!     15,    50,    32,    33,    34,    35,   231,    37,    38,    39,
!     40,   236,   237,   238,     7,     4,    46,    47,   243,    32,
!     33,    34,    35,    24,    37,    36,    39,    40,   235,    15,
!     50,   256,    15,    46,    47,    15,   243,   262,   263,    24,
!     50,   262,   263,    50,    15,    50,    15,    50,     0,   256,
!      0,   162,   252,   260,   261,    32,     1,   264,     3,    10,
!    185,   218,    -1,     8,    -1,    10,    11,    12,    13,    -1,
!     -1,    16,    17,    -1,    -1,    -1,    21,    22,    -1,    24,
!     25,    26,    27,    -1,    -1,    -1,    -1,    32,    33,    34,
!     35,    -1,    37,    38,    39,    40,    -1,    -1,    43,    44,
!      3,    46,    47,    -1,    49,     8,    51,    10,    11,    12,
!     13,    -1,    -1,    16,    17,    -1,    -1,    -1,    21,    22,
!     -1,    24,    25,    26,    27,    -1,    -1,    -1,    -1,    32,
!     33,    34,    35,    -1,    37,    38,    39,    40,    -1,    -1,
!     43,    -1,     3,    46,    47,    -1,    49,     8,    51,    10,
!     11,    12,    13,    -1,    -1,    16,    17,    -1,    -1,    -1,
!     21,    22,    -1,    24,    25,    26,    27,    -1,    -1,    -1,
!     -1,    32,    33,    34,    35,    -1,    37,    38,    39,    40,
!     -1,    -1,    -1,    -1,     3,    46,    47,    -1,    49,     8,
!     51,    10,    11,    12,    13,    -1,    -1,    16,    17,    -1,
!     -1,    -1,    -1,    22,    -1,    24,    25,    26,    27,    -1,
!     -1,    -1,    -1,    32,    33,    34,    35,    -1,    37,    38,
!     39,    40,    -1,    -1,    -1,    -1,     3,    46,    47,    -1,
!     49,     8,    51,    10,    11,    12,    13,    -1,    -1,    16,
!     17,    -1,    -1,    -1,    21,    -1,    -1,    24,    25,    26,
!     27,    -1,    -1,    -1,    -1,    32,    33,    34,    35,    -1,
!     37,    38,    39,    40,    -1,    -1,    -1,    -1,     3,    46,
!     47,    -1,    49,     8,    51,    10,    11,    12,    13,    -1,
!     -1,    16,    17,    -1,    -1,    -1,    -1,    -1,    -1,    24,
!     25,    26,    27,    -1,    -1,    -1,    -1,    32,    33,    34,
!     35,    -1,    37,    38,    39,    40,    -1,    -1,    43,    -1,
!      3,    46,    47,    -1,    49,     8,    51,    10,    11,    12,
!     13,    -1,    -1,    16,    17,    -1,    -1,    -1,    -1,    -1,
!     -1,    24,    25,    26,    27,    -1,    -1,    -1,    -1,    32,
!     33,    34,    35,    -1,    37,    38,    39,    40,    -1,    -1,
!     -1,    -1,    -1,    46,    47,    26,    49,    -1,    51,    -1,
!     -1,    32,    33,    34,    35,    -1,    37,    38,    39,    40,
!     -1,    -1,    -1,    -1,    -1,    46,    47
  };
! /* -*-C-*-  Note some compilers choke on comments on `#line' lines.  */
! #line 3 "/usr/share/misc/bison.simple"
! 
! /* Skeleton output parser for bison,
!    Copyright (C) 1984, 1989, 1990 Free Software Foundation, Inc.
! 
!    This program is free software; you can redistribute it and/or modify
!    it under the terms of the GNU General Public License as published by
!    the Free Software Foundation; either version 2, or (at your option)
!    any later version.
! 
!    This program is distributed in the hope that it will be useful,
!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!    GNU General Public License for more details.
! 
!    You should have received a copy of the GNU General Public License
!    along with this program; if not, write to the Free Software
!    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
! 
! /* As a special exception, when this file is copied by Bison into a
!    Bison output file, you may use that output file without restriction.
!    This special exception was added by the Free Software Foundation
!    in version 1.24 of Bison.  */
! 
! #ifndef alloca
! #ifdef __GNUC__
! #define alloca __builtin_alloca
! #else /* not GNU C.  */
! #if (!defined (__STDC__) && defined (sparc)) || defined (__sparc__) || defined (__sparc) || defined (__sgi)
! #include <alloca.h>
! #else /* not sparc */
! #if defined (MSDOS) && !defined (__TURBOC__)
! #include <malloc.h>
! #else /* not MSDOS, or __TURBOC__ */
! #if defined(_AIX)
! #include <malloc.h>
!  #pragma alloca
! #else /* not MSDOS, __TURBOC__, or _AIX */
! #ifdef __hpux
! #ifdef __cplusplus
! extern "C" {
! void *alloca (unsigned int);
  };
- #else /* not __cplusplus */
- void *alloca ();
- #endif /* not __cplusplus */
- #endif /* __hpux */
- #endif /* not _AIX */
- #endif /* not MSDOS, or __TURBOC__ */
- #endif /* not sparc.  */
- #endif /* not GNU C.  */
- #endif /* alloca not defined.  */
- 
- /* This is the parser code that is written into each bison parser
-   when the %semantic_parser declaration is not specified in the grammar.
-   It was written by Richard Stallman by simplifying the hairy parser
-   used when %semantic_parser is specified.  */
- 
- /* Note: there must be only one dollar sign in this file.
-    It is replaced by the list of actions, each action
-    as one case of the switch.  */
- 
- #define yyerrok		(yyerrstatus = 0)
- #define yyclearin	(yychar = YYEMPTY)
- #define YYEMPTY		-2
- #define YYEOF		0
- #define YYACCEPT	return(0)
- #define YYABORT 	return(1)
- #define YYERROR		goto yyerrlab1
- /* Like YYERROR except do call yyerror.
-    This remains here temporarily to ease the
-    transition to the new meaning of YYERROR, for GCC.
-    Once GCC version 2 has supplanted version 1, this can go.  */
- #define YYFAIL		goto yyerrlab
- #define YYRECOVERING()  (!!yyerrstatus)
- #define YYBACKUP(token, value) \
- do								\
-   if (yychar == YYEMPTY && yylen == 1)				\
-     { yychar = (token), yylval = (value);			\
-       yychar1 = YYTRANSLATE (yychar);				\
-       YYPOPSTACK;						\
-       goto yybackup;						\
-     }								\
-   else								\
-     { yyerror ("syntax error: cannot back up"); YYERROR; }	\
- while (0)
- 
- #define YYTERROR	1
- #define YYERRCODE	256
- 
- #ifndef YYPURE
- #define YYLEX		yylex()
- #endif
- 
- #ifdef YYPURE
- #ifdef YYLSP_NEEDED
- #ifdef YYLEX_PARAM
- #define YYLEX		yylex(&yylval, &yylloc, YYLEX_PARAM)
- #else
- #define YYLEX		yylex(&yylval, &yylloc)
  #endif
! #else /* not YYLSP_NEEDED */
! #ifdef YYLEX_PARAM
! #define YYLEX		yylex(&yylval, YYLEX_PARAM)
  #else
! #define YYLEX		yylex(&yylval)
  #endif
- #endif /* not YYLSP_NEEDED */
  #endif
  
! /* If nonreentrant, generate the variables here */
! 
! #ifndef YYPURE
  
! int	yychar;			/*  the lookahead symbol		*/
! YYSTYPE	yylval;			/*  the semantic value of the		*/
! 				/*  lookahead symbol			*/
  
! #ifdef YYLSP_NEEDED
! YYLTYPE yylloc;			/*  location data for the lookahead	*/
! 				/*  symbol				*/
! #endif
  
! int yynerrs;			/*  number of parse errors so far       */
! #endif  /* not YYPURE */
  
! #if YYDEBUG != 0
! int yydebug;			/*  nonzero means print parse trace	*/
! /* Since this is uninitialized, it does not stop multiple parsers
!    from coexisting.  */
! #endif
  
! /*  YYINITDEPTH indicates the initial size of the parser's stacks	*/
  
! #ifndef	YYINITDEPTH
! #define YYINITDEPTH 200
! #endif
  
! /*  YYMAXDEPTH is the maximum size the stacks can grow to
!     (effective only if the built-in stack extension method is used).  */
  
! #if YYMAXDEPTH == 0
! #undef YYMAXDEPTH
! #endif
  
! #ifndef YYMAXDEPTH
! #define YYMAXDEPTH 10000
  #endif
  
! /* Prevent warning if -Wstrict-prototypes.  */
! #ifdef __GNUC__
! int yyparse (void);
! #endif
! 
! #if __GNUC__ > 1		/* GNU C and GNU C++ define this.  */
! #define __yy_memcpy(TO,FROM,COUNT)	__builtin_memcpy(TO,FROM,COUNT)
! #else				/* not GNU C or C++ */
! #ifndef __cplusplus
  
! /* This is the most reliable way to avoid incompatibilities
!    in available built-in functions on various systems.  */
! static void
! __yy_memcpy (to, from, count)
!      char *to;
!      char *from;
!      int count;
  {
!   register char *f = from;
!   register char *t = to;
!   register int i = count;
! 
!   while (i-- > 0)
!     *t++ = *f++;
  }
  
! #else /* __cplusplus */
  
! /* This is the most reliable way to avoid incompatibilities
!    in available built-in functions on various systems.  */
! static void
! __yy_memcpy (char *to, char *from, int count)
  {
!   register char *f = from;
!   register char *t = to;
!   register int i = count;
! 
!   while (i-- > 0)
!     *t++ = *f++;
  }
  
! #endif
! #endif
! 
! #line 196 "/usr/share/misc/bison.simple"
! 
! /* The user can define YYPARSE_PARAM as the name of an argument to be passed
!    into yyparse.  The argument should have type void *.
!    It should actually point to an object.
!    Grammar actions can access the variable by casting it
!    to the proper pointer type.  */
! 
! #ifdef YYPARSE_PARAM
! #ifdef __cplusplus
! #define YYPARSE_PARAM_ARG void *YYPARSE_PARAM
! #define YYPARSE_PARAM_DECL
! #else /* not __cplusplus */
! #define YYPARSE_PARAM_ARG YYPARSE_PARAM
! #define YYPARSE_PARAM_DECL void *YYPARSE_PARAM;
! #endif /* not __cplusplus */
! #else /* not YYPARSE_PARAM */
! #define YYPARSE_PARAM_ARG
! #define YYPARSE_PARAM_DECL
! #endif /* not YYPARSE_PARAM */
! 
! int
! yyparse(YYPARSE_PARAM_ARG)
!      YYPARSE_PARAM_DECL
  {
!   register int yystate;
!   register int yyn;
!   register short *yyssp;
!   register YYSTYPE *yyvsp;
!   int yyerrstatus;	/*  number of tokens to shift before error messages enabled */
!   int yychar1 = 0;		/*  lookahead token as an internal (translated) token number */
! 
!   short	yyssa[YYINITDEPTH];	/*  the state stack			*/
!   YYSTYPE yyvsa[YYINITDEPTH];	/*  the semantic value stack		*/
! 
!   short *yyss = yyssa;		/*  refer to the stacks thru separate pointers */
!   YYSTYPE *yyvs = yyvsa;	/*  to allow yyoverflow to reallocate them elsewhere */
! 
! #ifdef YYLSP_NEEDED
!   YYLTYPE yylsa[YYINITDEPTH];	/*  the location stack			*/
!   YYLTYPE *yyls = yylsa;
!   YYLTYPE *yylsp;
  
! #define YYPOPSTACK   (yyvsp--, yyssp--, yylsp--)
  #else
! #define YYPOPSTACK   (yyvsp--, yyssp--)
  #endif
  
!   int yystacksize = YYINITDEPTH;
! 
! #ifdef YYPURE
!   int yychar;
!   YYSTYPE yylval;
!   int yynerrs;
! #ifdef YYLSP_NEEDED
!   YYLTYPE yylloc;
! #endif
! #endif
  
!   YYSTYPE yyval;		/*  the variable used to return		*/
! 				/*  semantic values from the action	*/
! 				/*  routines				*/
  
!   int yylen;
  
! #if YYDEBUG != 0
!   if (yydebug)
!     fprintf(stderr, "Starting parse\n");
! #endif
  
!   yystate = 0;
!   yyerrstatus = 0;
!   yynerrs = 0;
!   yychar = YYEMPTY;		/* Cause a token to be read.  */
! 
!   /* Initialize stack pointers.
!      Waste one element of value and location stack
!      so that they stay on the same level as the state stack.
!      The wasted elements are never initialized.  */
! 
!   yyssp = yyss - 1;
!   yyvsp = yyvs;
! #ifdef YYLSP_NEEDED
!   yylsp = yyls;
! #endif
! 
! /* Push a new state, which is found in  yystate  .  */
! /* In all cases, when you get here, the value and location stacks
!    have just been pushed. so pushing a state here evens the stacks.  */
! yynewstate:
! 
!   *++yyssp = yystate;
! 
!   if (yyssp >= yyss + yystacksize - 1)
!     {
!       /* Give user a chance to reallocate the stack */
!       /* Use copies of these so that the &'s don't force the real ones into memory. */
!       YYSTYPE *yyvs1 = yyvs;
!       short *yyss1 = yyss;
! #ifdef YYLSP_NEEDED
!       YYLTYPE *yyls1 = yyls;
! #endif
! 
!       /* Get the current used size of the three stacks, in elements.  */
!       int size = yyssp - yyss + 1;
! 
! #ifdef yyoverflow
!       /* Each stack pointer address is followed by the size of
! 	 the data in use in that stack, in bytes.  */
! #ifdef YYLSP_NEEDED
!       /* This used to be a conditional around just the two extra args,
! 	 but that might be undefined if yyoverflow is a macro.  */
!       yyoverflow("parser stack overflow",
! 		 &yyss1, size * sizeof (*yyssp),
! 		 &yyvs1, size * sizeof (*yyvsp),
! 		 &yyls1, size * sizeof (*yylsp),
! 		 &yystacksize);
! #else
!       yyoverflow("parser stack overflow",
! 		 &yyss1, size * sizeof (*yyssp),
! 		 &yyvs1, size * sizeof (*yyvsp),
! 		 &yystacksize);
! #endif
! 
!       yyss = yyss1; yyvs = yyvs1;
! #ifdef YYLSP_NEEDED
!       yyls = yyls1;
! #endif
! #else /* no yyoverflow */
!       /* Extend the stack our own way.  */
!       if (yystacksize >= YYMAXDEPTH)
! 	{
! 	  yyerror("parser stack overflow");
! 	  return 2;
! 	}
!       yystacksize *= 2;
!       if (yystacksize > YYMAXDEPTH)
! 	yystacksize = YYMAXDEPTH;
!       yyss = (short *) alloca (yystacksize * sizeof (*yyssp));
!       __yy_memcpy ((char *)yyss, (char *)yyss1, size * sizeof (*yyssp));
!       yyvs = (YYSTYPE *) alloca (yystacksize * sizeof (*yyvsp));
!       __yy_memcpy ((char *)yyvs, (char *)yyvs1, size * sizeof (*yyvsp));
! #ifdef YYLSP_NEEDED
!       yyls = (YYLTYPE *) alloca (yystacksize * sizeof (*yylsp));
!       __yy_memcpy ((char *)yyls, (char *)yyls1, size * sizeof (*yylsp));
! #endif
! #endif /* no yyoverflow */
! 
!       yyssp = yyss + size - 1;
!       yyvsp = yyvs + size - 1;
! #ifdef YYLSP_NEEDED
!       yylsp = yyls + size - 1;
! #endif
  
! #if YYDEBUG != 0
!       if (yydebug)
! 	fprintf(stderr, "Stack size increased to %d\n", yystacksize);
! #endif
  
!       if (yyssp >= yyss + yystacksize - 1)
! 	YYABORT;
!     }
  
! #if YYDEBUG != 0
!   if (yydebug)
!     fprintf(stderr, "Entering state %d\n", yystate);
! #endif
  
!   goto yybackup;
!  yybackup:
  
! /* Do appropriate processing given the current state.  */
! /* Read a lookahead token if we need one and don't already have one.  */
! /* yyresume: */
  
!   /* First try to decide what to do without reference to lookahead token.  */
  
!   yyn = yypact[yystate];
!   if (yyn == YYFLAG)
!     goto yydefault;
  
!   /* Not known => get a lookahead token if don't already have one.  */
  
!   /* yychar is either YYEMPTY or YYEOF
!      or a valid token in external form.  */
  
!   if (yychar == YYEMPTY)
!     {
! #if YYDEBUG != 0
!       if (yydebug)
! 	fprintf(stderr, "Reading a token: ");
! #endif
!       yychar = YYLEX;
      }
  
!   /* Convert token to internal form (in yychar1) for indexing tables with */
! 
!   if (yychar <= 0)		/* This means end of input. */
      {
!       yychar1 = 0;
!       yychar = YYEOF;		/* Don't call YYLEX any more */
! 
! #if YYDEBUG != 0
!       if (yydebug)
! 	fprintf(stderr, "Now at end of input.\n");
! #endif
      }
    else
      {
!       yychar1 = YYTRANSLATE(yychar);
  
! #if YYDEBUG != 0
!       if (yydebug)
! 	{
! 	  fprintf (stderr, "Next token is %d (%s", yychar, yytname[yychar1]);
! 	  /* Give the individual parser a way to print the precise meaning
! 	     of a token, for further debugging info.  */
! #ifdef YYPRINT
! 	  YYPRINT (stderr, yychar, yylval);
! #endif
! 	  fprintf (stderr, ")\n");
! 	}
! #endif
      }
  
!   yyn += yychar1;
!   if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != yychar1)
!     goto yydefault;
  
!   yyn = yytable[yyn];
  
!   /* yyn is what to do for this token type in this state.
!      Negative => reduce, -yyn is rule number.
!      Positive => shift, yyn is new state.
!        New state is final state => don't bother to shift,
!        just return success.
!      0, or most negative number => error.  */
  
!   if (yyn < 0)
      {
!       if (yyn == YYFLAG)
! 	goto yyerrlab;
!       yyn = -yyn;
!       goto yyreduce;
      }
!   else if (yyn == 0)
!     goto yyerrlab;
  
!   if (yyn == YYFINAL)
!     YYACCEPT;
  
!   /* Shift the lookahead token.  */
  
! #if YYDEBUG != 0
!   if (yydebug)
!     fprintf(stderr, "Shifting token %d (%s), ", yychar, yytname[yychar1]);
! #endif
  
!   /* Discard the token being shifted unless it is eof.  */
!   if (yychar != YYEOF)
!     yychar = YYEMPTY;
  
!   *++yyvsp = yylval;
! #ifdef YYLSP_NEEDED
!   *++yylsp = yylloc;
! #endif
  
!   /* count tokens shifted since error; after three, turn off error status.  */
!   if (yyerrstatus) yyerrstatus--;
  
!   yystate = yyn;
!   goto yynewstate;
  
! /* Do the default action for the current state.  */
! yydefault:
  
!   yyn = yydefact[yystate];
!   if (yyn == 0)
!     goto yyerrlab;
  
! /* Do a reduction.  yyn is the number of a rule to reduce with.  */
! yyreduce:
!   yylen = yyr2[yyn];
!   if (yylen > 0)
!     yyval = yyvsp[1-yylen]; /* implement default value of the action */
  
! #if YYDEBUG != 0
!   if (yydebug)
!     {
!       int i;
  
!       fprintf (stderr, "Reducing via rule %d (line %d), ",
! 	       yyn, yyrline[yyn]);
  
!       /* Print the symbols being reduced, and their result.  */
!       for (i = yyprhs[yyn]; yyrhs[i] > 0; i++)
! 	fprintf (stderr, "%s ", yytname[yyrhs[i]]);
!       fprintf (stderr, " -> %s\n", yytname[yyr1[yyn]]);
!     }
  #endif
  
  
!   switch (yyn) {
  
! case 1:
! #line 238 "/usr/homes/chet/src/bash/src/parse.y"
  {
! 			  /* Case of regular command.  Discard the error
! 			     safety net,and return the command just parsed. */
! 			  global_command = yyvsp[-1].command;
! 			  eof_encountered = 0;
! 			  discard_parser_constructs (0);
! 			  YYACCEPT;
! 			;
!     break;}
! case 2:
! #line 247 "/usr/homes/chet/src/bash/src/parse.y"
  {
! 			  /* Case of regular command, but not a very
! 			     interesting one.  Return a NULL command. */
! 			  global_command = (COMMAND *)NULL;
! 			  YYACCEPT;
! 			;
!     break;}
! case 3:
! #line 254 "/usr/homes/chet/src/bash/src/parse.y"
  {
! 			  /* Error during parsing.  Return NULL command. */
! 			  global_command = (COMMAND *)NULL;
! 			  eof_encountered = 0;
! 			  discard_parser_constructs (1);
! 			  if (interactive)
! 			    {
! 			      YYACCEPT;
! 			    }
! 			  else
! 			    {
! 			      YYABORT;
! 			    }
! 			;
!     break;}
! case 4:
! #line 269 "/usr/homes/chet/src/bash/src/parse.y"
  {
! 			  /* Case of EOF seen by itself.  Do ignoreeof or
! 			     not. */
! 			  global_command = (COMMAND *)NULL;
! 			  handle_eof_input_unit ();
! 			  YYACCEPT;
! 			;
!     break;}
! case 5:
! #line 279 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.word_list = make_word_list (yyvsp[0].word, (WORD_LIST *)NULL); ;
!     break;}
! case 6:
! #line 281 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.word_list = make_word_list (yyvsp[0].word, yyvsp[-1].word_list); ;
!     break;}
! case 7:
! #line 285 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  redir.filename = yyvsp[0].word;
! 			  yyval.redirect = make_redirection (1, r_output_direction, redir);
! 			;
!     break;}
! case 8:
! #line 290 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  redir.filename = yyvsp[0].word;
! 			  yyval.redirect = make_redirection (0, r_input_direction, redir);
! 			;
!     break;}
! case 9:
! #line 295 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  redir.filename = yyvsp[0].word;
! 			  yyval.redirect = make_redirection (yyvsp[-2].number, r_output_direction, redir);
! 			;
!     break;}
! case 10:
! #line 300 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  redir.filename = yyvsp[0].word;
! 			  yyval.redirect = make_redirection (yyvsp[-2].number, r_input_direction, redir);
! 			;
!     break;}
! case 11:
! #line 305 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  redir.filename = yyvsp[0].word;
! 			  yyval.redirect = make_redirection (1, r_appending_to, redir);
! 			;
!     break;}
! case 12:
! #line 310 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  redir.filename = yyvsp[0].word;
! 			  yyval.redirect = make_redirection (yyvsp[-2].number, r_appending_to, redir);
! 			;
!     break;}
! case 13:
! #line 315 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  redir.filename = yyvsp[0].word;
! 			  yyval.redirect = make_redirection (0, r_reading_until, redir);
! 			  redir_stack[need_here_doc++] = yyval.redirect;
! 			;
!     break;}
! case 14:
! #line 321 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  redir.filename = yyvsp[0].word;
! 			  yyval.redirect = make_redirection (yyvsp[-2].number, r_reading_until, redir);
! 			  redir_stack[need_here_doc++] = yyval.redirect;
! 			;
!     break;}
! case 15:
! #line 327 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  redir.dest = yyvsp[0].number;
! 			  yyval.redirect = make_redirection (0, r_duplicating_input, redir);
! 			;
!     break;}
! case 16:
! #line 332 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  redir.dest = yyvsp[0].number;
! 			  yyval.redirect = make_redirection (yyvsp[-2].number, r_duplicating_input, redir);
! 			;
!     break;}
! case 17:
! #line 337 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  redir.dest = yyvsp[0].number;
! 			  yyval.redirect = make_redirection (1, r_duplicating_output, redir);
! 			;
!     break;}
! case 18:
! #line 342 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  redir.dest = yyvsp[0].number;
! 			  yyval.redirect = make_redirection (yyvsp[-2].number, r_duplicating_output, redir);
! 			;
!     break;}
! case 19:
! #line 347 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  redir.filename = yyvsp[0].word;
! 			  yyval.redirect = make_redirection (0, r_duplicating_input_word, redir);
! 			;
!     break;}
! case 20:
! #line 352 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  redir.filename = yyvsp[0].word;
! 			  yyval.redirect = make_redirection (yyvsp[-2].number, r_duplicating_input_word, redir);
! 			;
!     break;}
! case 21:
! #line 357 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  redir.filename = yyvsp[0].word;
! 			  yyval.redirect = make_redirection (1, r_duplicating_output_word, redir);
! 			;
!     break;}
! case 22:
! #line 362 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  redir.filename = yyvsp[0].word;
! 			  yyval.redirect = make_redirection (yyvsp[-2].number, r_duplicating_output_word, redir);
! 			;
!     break;}
! case 23:
! #line 367 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  redir.filename = yyvsp[0].word;
! 			  yyval.redirect = make_redirection
! 			    (0, r_deblank_reading_until, redir);
! 			  redir_stack[need_here_doc++] = yyval.redirect;
! 			;
!     break;}
! case 24:
! #line 374 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  redir.filename = yyvsp[0].word;
! 			  yyval.redirect = make_redirection
! 			    (yyvsp[-2].number, r_deblank_reading_until, redir);
! 			  redir_stack[need_here_doc++] = yyval.redirect;
! 			;
!     break;}
! case 25:
! #line 381 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  redir.dest = 0L;
! 			  yyval.redirect = make_redirection (1, r_close_this, redir);
! 			;
!     break;}
! case 26:
! #line 386 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  redir.dest = 0L;
! 			  yyval.redirect = make_redirection (yyvsp[-2].number, r_close_this, redir);
! 			;
!     break;}
! case 27:
! #line 391 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  redir.dest = 0L;
! 			  yyval.redirect = make_redirection (0, r_close_this, redir);
! 			;
!     break;}
! case 28:
! #line 396 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  redir.dest = 0L;
! 			  yyval.redirect = make_redirection (yyvsp[-2].number, r_close_this, redir);
! 			;
!     break;}
! case 29:
! #line 401 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  redir.filename = yyvsp[0].word;
! 			  yyval.redirect = make_redirection (1, r_err_and_out, redir);
! 			;
!     break;}
! case 30:
! #line 406 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  redir.filename = yyvsp[0].word;
! 			  yyval.redirect = make_redirection (yyvsp[-2].number, r_input_output, redir);
! 			;
!     break;}
! case 31:
! #line 411 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  redir.filename = yyvsp[0].word;
! 			  yyval.redirect = make_redirection (0, r_input_output, redir);
! 			;
!     break;}
! case 32:
! #line 416 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  redir.filename = yyvsp[0].word;
! 			  yyval.redirect = make_redirection (1, r_output_force, redir);
! 			;
!     break;}
! case 33:
! #line 421 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  redir.filename = yyvsp[0].word;
! 			  yyval.redirect = make_redirection (yyvsp[-2].number, r_output_force, redir);
! 			;
!     break;}
! case 34:
! #line 428 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.element.word = yyvsp[0].word; yyval.element.redirect = 0; ;
!     break;}
! case 35:
! #line 430 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.element.word = yyvsp[0].word; yyval.element.redirect = 0; ;
!     break;}
! case 36:
! #line 432 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.element.redirect = yyvsp[0].redirect; yyval.element.word = 0; ;
!     break;}
! case 37:
! #line 436 "/usr/homes/chet/src/bash/src/parse.y"
  {
! 			  yyval.redirect = yyvsp[0].redirect;
! 			;
!     break;}
! case 38:
! #line 440 "/usr/homes/chet/src/bash/src/parse.y"
  {
! 			  register REDIRECT *t;
  
! 			  for (t = yyvsp[-1].redirect; t->next; t = t->next)
! 			    ;
! 			  t->next = yyvsp[0].redirect;
! 			  yyval.redirect = yyvsp[-1].redirect;
! 			;
!     break;}
! case 39:
! #line 451 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = make_simple_command (yyvsp[0].element, (COMMAND *)NULL); ;
!     break;}
! case 40:
! #line 453 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = make_simple_command (yyvsp[0].element, yyvsp[-1].command); ;
!     break;}
! case 41:
! #line 457 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = clean_simple_command (yyvsp[0].command); ;
!     break;}
! case 42:
! #line 459 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = yyvsp[0].command; ;
!     break;}
! case 43:
! #line 461 "/usr/homes/chet/src/bash/src/parse.y"
  {
! 			  COMMAND *tc;
  
! 			  tc = yyvsp[-1].command;
! 			  /* According to Posix.2 3.9.5, redirections
! 			     specified after the body of a function should
! 			     be attached to the function and performed when
! 			     the function is executed, not as part of the
! 			     function definition command. */
! 			  /* XXX - I don't think it matters, but we might
! 			     want to change this in the future to avoid
! 			     problems differentiating between a function
! 			     definition with a redirection and a function
! 			     definition containing a single command with a
! 			     redirection.  The two are semantically equivalent,
! 			     though -- the only difference is in how the
! 			     command printing code displays the redirections. */
! 			  if (tc->type == cm_function_def)
! 			    {
! 			      tc = tc->value.Function_def->command;
! 			      if (tc->type == cm_group)
! 			        tc = tc->value.Group->command;
! 			    }
! 			  if (tc->redirects)
! 			    {
! 			      register REDIRECT *t;
! 			      for (t = tc->redirects; t->next; t = t->next)
! 				;
! 			      t->next = yyvsp[0].redirect;
! 			    }
! 			  else
! 			    tc->redirects = yyvsp[0].redirect;
! 			  yyval.command = yyvsp[-1].command;
! 			;
!     break;}
! case 44:
! #line 498 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = yyvsp[0].command; ;
!     break;}
! case 45:
! #line 500 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = yyvsp[0].command; ;
!     break;}
! case 46:
! #line 502 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = make_while_command (yyvsp[-3].command, yyvsp[-1].command); ;
!     break;}
! case 47:
! #line 504 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = make_until_command (yyvsp[-3].command, yyvsp[-1].command); ;
!     break;}
! case 48:
! #line 506 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = yyvsp[0].command; ;
!     break;}
! case 49:
! #line 508 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = yyvsp[0].command; ;
!     break;}
! case 50:
! #line 510 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = yyvsp[0].command; ;
!     break;}
! case 51:
! #line 512 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = yyvsp[0].command; ;
!     break;}
! case 52:
! #line 514 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = yyvsp[0].command; ;
!     break;}
! case 53:
! #line 516 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = yyvsp[0].command; ;
!     break;}
! case 54:
! #line 518 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = yyvsp[0].command; ;
!     break;}
! case 55:
! #line 520 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = yyvsp[0].command; ;
!     break;}
! case 56:
! #line 524 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = make_for_command (yyvsp[-4].word, add_string_to_list ("\"$@\"", (WORD_LIST *)NULL), yyvsp[-1].command); ;
!     break;}
! case 57:
! #line 526 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = make_for_command (yyvsp[-4].word, add_string_to_list ("$@", (WORD_LIST *)NULL), yyvsp[-1].command); ;
!     break;}
! case 58:
! #line 528 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = make_for_command (yyvsp[-5].word, add_string_to_list ("\"$@\"", (WORD_LIST *)NULL), yyvsp[-1].command); ;
!     break;}
! case 59:
! #line 530 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = make_for_command (yyvsp[-5].word, add_string_to_list ("\"$@\"", (WORD_LIST *)NULL), yyvsp[-1].command); ;
!     break;}
! case 60:
! #line 532 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = make_for_command (yyvsp[-8].word, REVERSE_LIST (yyvsp[-5].word_list, WORD_LIST *), yyvsp[-1].command); ;
!     break;}
! case 61:
! #line 534 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = make_for_command (yyvsp[-8].word, REVERSE_LIST (yyvsp[-5].word_list, WORD_LIST *), yyvsp[-1].command); ;
!     break;}
! case 62:
! #line 538 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = make_arith_for_command (yyvsp[-5].word_list, yyvsp[-1].command, arith_for_lineno); ;
!     break;}
! case 63:
! #line 540 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = make_arith_for_command (yyvsp[-5].word_list, yyvsp[-1].command, arith_for_lineno); ;
!     break;}
! case 64:
! #line 543 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  yyval.command = make_select_command (yyvsp[-4].word, add_string_to_list ("\"$@\"", (WORD_LIST *)NULL), yyvsp[-1].command);
! 			;
!     break;}
! case 65:
! #line 547 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  yyval.command = make_select_command (yyvsp[-4].word, add_string_to_list ("$@", (WORD_LIST *)NULL), yyvsp[-1].command);
! 			;
!     break;}
! case 66:
! #line 551 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  yyval.command = make_select_command (yyvsp[-5].word, add_string_to_list ("\"$@\"", (WORD_LIST *)NULL), yyvsp[-1].command);
! 			;
!     break;}
! case 67:
! #line 555 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  yyval.command = make_select_command (yyvsp[-5].word, add_string_to_list ("\"$@\"", (WORD_LIST *)NULL), yyvsp[-1].command);
! 			;
!     break;}
! case 68:
! #line 559 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  yyval.command = make_select_command (yyvsp[-8].word, (WORD_LIST *)reverse_list (yyvsp[-5].word_list), yyvsp[-1].command);
! 			;
!     break;}
! case 69:
! #line 563 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  yyval.command = make_select_command (yyvsp[-8].word, (WORD_LIST *)reverse_list (yyvsp[-5].word_list), yyvsp[-1].command);
! 			;
!     break;}
! case 70:
! #line 569 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = make_case_command (yyvsp[-4].word, (PATTERN_LIST *)NULL); ;
!     break;}
! case 71:
! #line 571 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = make_case_command (yyvsp[-5].word, yyvsp[-2].pattern); ;
!     break;}
! case 72:
! #line 573 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = make_case_command (yyvsp[-4].word, yyvsp[-1].pattern); ;
!     break;}
! case 73:
! #line 577 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = make_function_def (yyvsp[-4].word, yyvsp[0].command, function_dstart, function_bstart); ;
!     break;}
! case 74:
! #line 581 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = make_function_def (yyvsp[-4].word, yyvsp[0].command, function_dstart, function_bstart); ;
!     break;}
! case 75:
! #line 584 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = make_function_def (yyvsp[-2].word, yyvsp[0].command, function_dstart, function_bstart); ;
!     break;}
! case 76:
! #line 588 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  yyval.command = make_subshell_command (yyvsp[-1].command);
! 			  yyval.command->flags |= CMD_WANT_SUBSHELL;
! 			;
!     break;}
! case 77:
! #line 595 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = make_if_command (yyvsp[-3].command, yyvsp[-1].command, (COMMAND *)NULL); ;
!     break;}
! case 78:
! #line 597 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = make_if_command (yyvsp[-5].command, yyvsp[-3].command, yyvsp[-1].command); ;
!     break;}
! case 79:
! #line 599 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = make_if_command (yyvsp[-4].command, yyvsp[-2].command, yyvsp[-1].command); ;
!     break;}
! case 80:
! #line 604 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = make_group_command (yyvsp[-1].command); ;
!     break;}
! case 81:
! #line 608 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = make_arith_command (yyvsp[0].word_list); ;
!     break;}
! case 82:
! #line 612 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = yyvsp[-1].command; ;
!     break;}
! case 83:
! #line 616 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = make_if_command (yyvsp[-2].command, yyvsp[0].command, (COMMAND *)NULL); ;
!     break;}
! case 84:
! #line 618 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = make_if_command (yyvsp[-4].command, yyvsp[-2].command, yyvsp[0].command); ;
!     break;}
! case 85:
! #line 620 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = make_if_command (yyvsp[-3].command, yyvsp[-1].command, yyvsp[0].command); ;
!     break;}
! case 87:
! #line 625 "/usr/homes/chet/src/bash/src/parse.y"
! { yyvsp[0].pattern->next = yyvsp[-1].pattern; yyval.pattern = yyvsp[0].pattern; ;
!     break;}
! case 88:
! #line 629 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.pattern = make_pattern_list (yyvsp[-2].word_list, yyvsp[0].command); ;
!     break;}
! case 89:
! #line 631 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.pattern = make_pattern_list (yyvsp[-2].word_list, (COMMAND *)NULL); ;
!     break;}
! case 90:
! #line 633 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.pattern = make_pattern_list (yyvsp[-2].word_list, yyvsp[0].command); ;
!     break;}
! case 91:
! #line 635 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.pattern = make_pattern_list (yyvsp[-2].word_list, (COMMAND *)NULL); ;
!     break;}
! case 93:
! #line 640 "/usr/homes/chet/src/bash/src/parse.y"
! { yyvsp[-1].pattern->next = yyvsp[-2].pattern; yyval.pattern = yyvsp[-1].pattern; ;
!     break;}
! case 94:
! #line 644 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.word_list = make_word_list (yyvsp[0].word, (WORD_LIST *)NULL); ;
!     break;}
! case 95:
! #line 646 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.word_list = make_word_list (yyvsp[0].word, yyvsp[-2].word_list); ;
!     break;}
! case 96:
! #line 655 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  yyval.command = yyvsp[0].command;
! 			  if (need_here_doc)
! 			    gather_here_documents ();
! 			 ;
!     break;}
! case 98:
! #line 664 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  yyval.command = yyvsp[0].command;
! 			;
!     break;}
! case 100:
! #line 671 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  if (yyvsp[-2].command->type == cm_connection)
! 			    yyval.command = connect_async_list (yyvsp[-2].command, (COMMAND *)NULL, '&');
! 			  else
! 			    yyval.command = command_connect (yyvsp[-2].command, (COMMAND *)NULL, '&');
! 			;
!     break;}
! case 102:
! #line 682 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = command_connect (yyvsp[-3].command, yyvsp[0].command, AND_AND); ;
!     break;}
! case 103:
! #line 684 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = command_connect (yyvsp[-3].command, yyvsp[0].command, OR_OR); ;
!     break;}
! case 104:
! #line 686 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  if (yyvsp[-3].command->type == cm_connection)
! 			    yyval.command = connect_async_list (yyvsp[-3].command, yyvsp[0].command, '&');
! 			  else
! 			    yyval.command = command_connect (yyvsp[-3].command, yyvsp[0].command, '&');
! 			;
!     break;}
! case 105:
! #line 693 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = command_connect (yyvsp[-3].command, yyvsp[0].command, ';'); ;
!     break;}
! case 106:
! #line 695 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = command_connect (yyvsp[-3].command, yyvsp[0].command, ';'); ;
!     break;}
! case 107:
! #line 697 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = yyvsp[0].command; ;
!     break;}
! case 113:
! #line 716 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  yyval.command = yyvsp[0].command;
! 			  if (need_here_doc)
! 			    gather_here_documents ();
! 			;
!     break;}
! case 114:
! #line 722 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  if (yyvsp[-1].command->type == cm_connection)
! 			    yyval.command = connect_async_list (yyvsp[-1].command, (COMMAND *)NULL, '&');
! 			  else
! 			    yyval.command = command_connect (yyvsp[-1].command, (COMMAND *)NULL, '&');
! 			  if (need_here_doc)
! 			    gather_here_documents ();
! 			;
!     break;}
! case 115:
! #line 731 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  yyval.command = yyvsp[-1].command;
! 			  if (need_here_doc)
! 			    gather_here_documents ();
! 			;
!     break;}
! case 116:
! #line 739 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = command_connect (yyvsp[-3].command, yyvsp[0].command, AND_AND); ;
!     break;}
! case 117:
! #line 741 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = command_connect (yyvsp[-3].command, yyvsp[0].command, OR_OR); ;
!     break;}
! case 118:
! #line 743 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  if (yyvsp[-2].command->type == cm_connection)
! 			    yyval.command = connect_async_list (yyvsp[-2].command, yyvsp[0].command, '&');
! 			  else
! 			    yyval.command = command_connect (yyvsp[-2].command, yyvsp[0].command, '&');
! 			;
!     break;}
! case 119:
! #line 750 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = command_connect (yyvsp[-2].command, yyvsp[0].command, ';'); ;
!     break;}
! case 120:
! #line 753 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = yyvsp[0].command; ;
!     break;}
! case 121:
! #line 757 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = yyvsp[0].command; ;
!     break;}
! case 122:
! #line 759 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  yyvsp[0].command->flags |= CMD_INVERT_RETURN;
! 			  yyval.command = yyvsp[0].command;
! 			;
!     break;}
! case 123:
! #line 764 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  yyvsp[0].command->flags |= yyvsp[-1].number;
! 			  yyval.command = yyvsp[0].command;
! 			;
!     break;}
! case 124:
! #line 769 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  yyvsp[0].command->flags |= yyvsp[-2].number|CMD_INVERT_RETURN;
! 			  yyval.command = yyvsp[0].command;
! 			;
!     break;}
! case 125:
! #line 774 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  yyvsp[0].command->flags |= yyvsp[-1].number|CMD_INVERT_RETURN;
! 			  yyval.command = yyvsp[0].command;
! 			;
!     break;}
! case 126:
! #line 782 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = command_connect (yyvsp[-3].command, yyvsp[0].command, '|'); ;
!     break;}
! case 127:
! #line 784 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = yyvsp[0].command; ;
!     break;}
! case 128:
! #line 788 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.number = CMD_TIME_PIPELINE; ;
!     break;}
! case 129:
! #line 790 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.number = CMD_TIME_PIPELINE|CMD_TIME_POSIX; ;
!     break;}
! }
!    /* the action file gets copied in in place of this dollarsign */
! #line 498 "/usr/share/misc/bison.simple"
! 
!   yyvsp -= yylen;
!   yyssp -= yylen;
! #ifdef YYLSP_NEEDED
!   yylsp -= yylen;
! #endif
! 
! #if YYDEBUG != 0
!   if (yydebug)
      {
!       short *ssp1 = yyss - 1;
!       fprintf (stderr, "state stack now");
!       while (ssp1 != yyssp)
! 	fprintf (stderr, " %d", *++ssp1);
!       fprintf (stderr, "\n");
!     }
  #endif
! 
!   *++yyvsp = yyval;
! 
! #ifdef YYLSP_NEEDED
!   yylsp++;
!   if (yylen == 0)
!     {
!       yylsp->first_line = yylloc.first_line;
!       yylsp->first_column = yylloc.first_column;
!       yylsp->last_line = (yylsp-1)->last_line;
!       yylsp->last_column = (yylsp-1)->last_column;
!       yylsp->text = 0;
!     }
!   else
!     {
!       yylsp->last_line = (yylsp+yylen-1)->last_line;
!       yylsp->last_column = (yylsp+yylen-1)->last_column;
      }
! #endif
! 
!   /* Now "shift" the result of the reduction.
!      Determine what state that goes to,
!      based on the state we popped back to
!      and the rule number reduced by.  */
! 
!   yyn = yyr1[yyn];
  
!   yystate = yypgoto[yyn - YYNTBASE] + *yyssp;
!   if (yystate >= 0 && yystate <= YYLAST && yycheck[yystate] == *yyssp)
!     yystate = yytable[yystate];
!   else
!     yystate = yydefgoto[yyn - YYNTBASE];
  
!   goto yynewstate;
  
! yyerrlab:   /* here on detecting error */
  
!   if (! yyerrstatus)
!     /* If not already recovering from an error, report this error.  */
      {
!       ++yynerrs;
  
! #ifdef YYERROR_VERBOSE
!       yyn = yypact[yystate];
  
!       if (yyn > YYFLAG && yyn < YYLAST)
  	{
! 	  int size = 0;
! 	  char *msg;
! 	  int x, count;
! 
! 	  count = 0;
! 	  /* Start X at -yyn if nec to avoid negative indexes in yycheck.  */
! 	  for (x = (yyn < 0 ? -yyn : 0);
! 	       x < (sizeof(yytname) / sizeof(char *)); x++)
! 	    if (yycheck[x + yyn] == x)
! 	      size += strlen(yytname[x]) + 15, count++;
! 	  msg = (char *) malloc(size + 15);
! 	  if (msg != 0)
! 	    {
! 	      strcpy(msg, "parse error");
! 
! 	      if (count < 5)
! 		{
! 		  count = 0;
! 		  for (x = (yyn < 0 ? -yyn : 0);
! 		       x < (sizeof(yytname) / sizeof(char *)); x++)
! 		    if (yycheck[x + yyn] == x)
! 		      {
! 			strcat(msg, count == 0 ? ", expecting `" : " or `");
! 			strcat(msg, yytname[x]);
! 			strcat(msg, "'");
! 			count++;
! 		      }
! 		}
! 	      yyerror(msg);
! 	      free(msg);
! 	    }
! 	  else
! 	    yyerror ("parse error; also virtual memory exceeded");
! 	}
!       else
! #endif /* YYERROR_VERBOSE */
! 	yyerror("parse error");
!     }
! 
!   goto yyerrlab1;
! yyerrlab1:   /* here on error raised explicitly by an action */
! 
!   if (yyerrstatus == 3)
!     {
!       /* if just tried and failed to reuse lookahead token after an error, discard it.  */
! 
!       /* return failure if at end of input */
!       if (yychar == YYEOF)
! 	YYABORT;
! 
! #if YYDEBUG != 0
!       if (yydebug)
! 	fprintf(stderr, "Discarding token %d (%s).\n", yychar, yytname[yychar1]);
  #endif
  
!       yychar = YYEMPTY;
!     }
! 
!   /* Else will try to reuse lookahead token
!      after shifting the error token.  */
! 
!   yyerrstatus = 3;		/* Each real token shifted decrements this */
! 
!   goto yyerrhandle;
  
! yyerrdefault:  /* current state does not do anything special for the error token. */
  
! #if 0
!   /* This is wrong; only states that explicitly want error tokens
!      should shift them.  */
!   yyn = yydefact[yystate];  /* If its default is to accept any token, ok.  Otherwise pop it.*/
!   if (yyn) goto yydefault;
! #endif
! 
! yyerrpop:   /* pop the current state because it cannot handle the error token */
! 
!   if (yyssp == yyss) YYABORT;
!   yyvsp--;
!   yystate = *--yyssp;
! #ifdef YYLSP_NEEDED
!   yylsp--;
! #endif
  
! #if YYDEBUG != 0
!   if (yydebug)
!     {
!       short *ssp1 = yyss - 1;
!       fprintf (stderr, "Error: state stack now");
!       while (ssp1 != yyssp)
! 	fprintf (stderr, " %d", *++ssp1);
!       fprintf (stderr, "\n");
      }
  #endif
  
! yyerrhandle:
  
!   yyn = yypact[yystate];
!   if (yyn == YYFLAG)
!     goto yyerrdefault;
  
!   yyn += YYTERROR;
!   if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != YYTERROR)
!     goto yyerrdefault;
  
!   yyn = yytable[yyn];
!   if (yyn < 0)
!     {
!       if (yyn == YYFLAG)
! 	goto yyerrpop;
!       yyn = -yyn;
!       goto yyreduce;
!     }
!   else if (yyn == 0)
!     goto yyerrpop;
  
!   if (yyn == YYFINAL)
!     YYACCEPT;
  
! #if YYDEBUG != 0
!   if (yydebug)
!     fprintf(stderr, "Shifting error token, ");
! #endif
  
!   *++yyvsp = yylval;
! #ifdef YYLSP_NEEDED
!   *++yylsp = yylloc;
! #endif
  
!   yystate = yyn;
!   goto yynewstate;
! }
! #line 792 "/usr/homes/chet/src/bash/src/parse.y"
  
  
! /* Possible states for the parser that require it to do special things. */
! #define PST_CASEPAT	0x001		/* in a case pattern list */
! #define PST_ALEXPNEXT	0x002		/* expand next word for aliases */
! #define PST_ALLOWOPNBRC	0x004		/* allow open brace for function def */
! #define PST_NEEDCLOSBRC	0x008		/* need close brace */
! #define PST_DBLPAREN	0x010		/* double-paren parsing */
! #define PST_SUBSHELL	0x020		/* ( ... ) subshell */
! #define PST_CMDSUBST	0x040		/* $( ... ) command substitution */
! #define PST_CASESTMT	0x080		/* parsing a case statement */
! #define PST_CONDCMD	0x100		/* parsing a [[...]] command */
! #define PST_CONDEXPR	0x200		/* parsing the guts of [[...]] */
! #define PST_ARITHFOR	0x400		/* parsing an arithmetic for command */
  
! /* Initial size to allocate for tokens, and the
!    amount to grow them by. */
! #define TOKEN_DEFAULT_INITIAL_SIZE 496
! #define TOKEN_DEFAULT_GROW_SIZE 512
  
! /* Shell meta-characters that, when unquoted, separate words. */
! #define shellmeta(c)	(strchr (shell_meta_chars, (c)) != 0)
! #define shellbreak(c)	(strchr (shell_break_chars, (c)) != 0)
! #define shellquote(c)	((c) == '"' || (c) == '`' || (c) == '\'')
! #define shellexp(c)	((c) == '$' || (c) == '<' || (c) == '>')
  
! char *shell_meta_chars = "()<>;&|";
! char *shell_break_chars = "()<>;&| \t\n";
  
! /* The token currently being read. */
! static int current_token;
  
! /* The last read token, or NULL.  read_token () uses this for context
!    checking. */
! static int last_read_token;
  
! /* The token read prior to last_read_token. */
! static int token_before_that;
  
! /* The token read prior to token_before_that. */
! static int two_tokens_ago;
  
! /* If non-zero, it is the token that we want read_token to return
!    regardless of what text is (or isn't) present to be read.  This
!    is reset by read_token.  If token_to_read == WORD or
!    ASSIGNMENT_WORD, yylval.word should be set to word_desc_to_read. */
! static int token_to_read;
! static WORD_DESC *word_desc_to_read;
  
! /* The current parser state. */
! static int parser_state;
  
! /* Global var is non-zero when end of file has been reached. */
! int EOF_Reached = 0;
  
! void
! debug_parser (i)
!      int i;
! {
! #if YYDEBUG != 0
!   yydebug = i;
  #endif
! }
  
! /* yy_getc () returns the next available character from input or EOF.
!    yy_ungetc (c) makes `c' the next character to read.
!    init_yy_io (get, unget, type, location) makes the function GET the
!    installed function for getting the next character, makes UNGET the
!    installed function for un-getting a character, sets the type of stream
!    (either string or file) from TYPE, and makes LOCATION point to where
!    the input is coming from. */
  
! /* Unconditionally returns end-of-file. */
! int
! return_EOF ()
! {
!   return (EOF);
! }
  
! /* Variable containing the current get and unget functions.
!    See ./input.h for a clearer description. */
! BASH_INPUT bash_input;
  
! /* Set all of the fields in BASH_INPUT to NULL.  Free bash_input.name if it
!    is non-null, avoiding a memory leak. */
! void
! initialize_bash_input ()
! {
!   bash_input.type = st_none;
!   FREE (bash_input.name);
!   bash_input.name = (char *)NULL;
!   bash_input.location.file = (FILE *)NULL;
!   bash_input.location.string = (char *)NULL;
!   bash_input.getter = (Function *)NULL;
!   bash_input.ungetter = (Function *)NULL;
! }
  
! /* Set the contents of the current bash input stream from
!    GET, UNGET, TYPE, NAME, and LOCATION. */
! void
! init_yy_io (get, unget, type, name, location)
!      Function *get, *unget;
!      enum stream_type type;
!      char *name;
!      INPUT_STREAM location;
! {
!   bash_input.type = type;
!   FREE (bash_input.name);
!   bash_input.name = name ? savestring (name) : (char *)NULL;
! 
!   /* XXX */
! #if defined (CRAY)
!   memcpy((char *)&bash_input.location.string, (char *)&location.string, sizeof(location));
! #else
!   bash_input.location = location;
! #endif
!   bash_input.getter = get;
!   bash_input.ungetter = unget;
! }
! 
! /* Call this to get the next character of input. */
! int
! yy_getc ()
! {
!   return (*(bash_input.getter)) ();
! }
! 
! /* Call this to unget C.  That is, to make C the next character
!    to be read. */
! int
! yy_ungetc (c)
!      int c;
! {
!   return (*(bash_input.ungetter)) (c);
! }
! 
! #if defined (BUFFERED_INPUT)
! int
! input_file_descriptor ()
! {
!   switch (bash_input.type)
!     {
!     case st_stream:
!       return (fileno (bash_input.location.file));
!     case st_bstream:
!       return (bash_input.location.buffered_fd);
!     case st_stdin:
!     default:
!       return (fileno (stdin));
!     }
! }
! #endif /* BUFFERED_INPUT */
! 
! /* **************************************************************** */
! /*								    */
! /*		  Let input be read from readline ().		    */
! /*								    */
! /* **************************************************************** */
  
! #if defined (READLINE)
! char *current_readline_prompt = (char *)NULL;
! char *current_readline_line = (char *)NULL;
! int current_readline_line_index = 0;
  
! static int
! yy_readline_get ()
! {
!   SigHandler *old_sigint;
!   int line_len, c;
  
!   if (!current_readline_line)
!     {
!       if (!bash_readline_initialized)
! 	initialize_readline ();
  
! #if defined (JOB_CONTROL)
!       if (job_control)
! 	give_terminal_to (shell_pgrp);
! #endif /* JOB_CONTROL */
  
!       if (signal_is_ignored (SIGINT) == 0)
  	{
! 	  old_sigint = (SigHandler *)set_signal_handler (SIGINT, sigint_sighandler);
! 	  interrupt_immediately++;
  	}
  
!       current_readline_line = readline (current_readline_prompt ?
!       					  current_readline_prompt : "");
  
!       if (signal_is_ignored (SIGINT) == 0)
  	{
! 	  interrupt_immediately--;
! 	  set_signal_handler (SIGINT, old_sigint);
  	}
  
! #if 0
!       /* Reset the prompt to the decoded value of prompt_string_pointer. */
!       reset_readline_prompt ();
! #endif
  
!       if (current_readline_line == 0)
! 	return (EOF);
  
!       current_readline_line_index = 0;
!       line_len = strlen (current_readline_line);
  
!       current_readline_line = xrealloc (current_readline_line, 2 + line_len);
!       current_readline_line[line_len++] = '\n';
!       current_readline_line[line_len] = '\0';
!     }
  
!   if (current_readline_line[current_readline_line_index] == 0)
      {
!       free (current_readline_line);
!       current_readline_line = (char *)NULL;
!       return (yy_readline_get ());
      }
!   else
      {
!       c = (unsigned char)current_readline_line[current_readline_line_index++];
!       return (c);
      }
  }
  
! static int
! yy_readline_unget (c)
       int c;
  {
!   if (current_readline_line_index && current_readline_line)
!     current_readline_line[--current_readline_line_index] = c;
!   return (c);
  }
  
! void
! with_input_from_stdin ()
  {
!   INPUT_STREAM location;
! 
!   if (bash_input.type != st_stdin && stream_on_stack (st_stdin) == 0)
!     {
!       location.string = current_readline_line;
!       init_yy_io (yy_readline_get, yy_readline_unget,
! 		  st_stdin, "readline stdin", location);
!     }
  }
  
! #else  /* !READLINE */
  
  void
! with_input_from_stdin ()
  {
!   with_input_from_stream (stdin, "stdin");
! }
! #endif	/* !READLINE */
  
! /* **************************************************************** */
! /*								    */
! /*   Let input come from STRING.  STRING is zero terminated.	    */
! /*								    */
! /* **************************************************************** */
  
! static int
! yy_string_get ()
! {
!   register char *string;
!   register int c;
  
!   string = bash_input.location.string;
!   c = EOF;
  
!   /* If the string doesn't exist, or is empty, EOF found. */
!   if (string && *string)
!     {
!       c = *(unsigned char *)string++;
!       bash_input.location.string = string;
!     }
!   return (c);
  }
  
  static int
! yy_string_unget (c)
!      int c;
  {
!   *(--bash_input.location.string) = c;
!   return (c);
  }
  
  void
! with_input_from_string (string, name)
!      char *string, *name;
  {
!   INPUT_STREAM location;
! 
!   location.string = string;
!   init_yy_io (yy_string_get, yy_string_unget, st_string, name, location);
  }
  
! /* **************************************************************** */
! /*								    */
! /*		     Let input come from STREAM.		    */
! /*								    */
! /* **************************************************************** */
  
! /* These two functions used to test the value of the HAVE_RESTARTABLE_SYSCALLS
!    define, and just use getc/ungetc if it was defined, but since bash
!    installs its signal handlers without the SA_RESTART flag, some signals
!    (like SIGCHLD, SIGWINCH, etc.) received during a read(2) will not cause
!    the read to be restarted.  We need to restart it ourselves. */
  
  static int
! yy_stream_get ()
  {
!   int result;
  
!   result = EOF;
!   if (bash_input.location.file)
!     result = getc_with_restart (bash_input.location.file);
  
!   return (result);
  }
  
  static int
! yy_stream_unget (c)
!      int c;
  {
!   return (ungetc_with_restart (c, bash_input.location.file));
  }
  
! void
! with_input_from_stream (stream, name)
!      FILE *stream;
!      char *name;
! {
!   INPUT_STREAM location;
  
!   location.file = stream;
!   init_yy_io (yy_stream_get, yy_stream_unget, st_stream, name, location);
! }
  
! typedef struct stream_saver {
!   struct stream_saver *next;
!   BASH_INPUT bash_input;
!   int line;
! #if defined (BUFFERED_INPUT)
!   BUFFERED_STREAM *bstream;
! #endif /* BUFFERED_INPUT */
! } STREAM_SAVER;
  
! /* The globally known line number. */
! int line_number = 0;
  
! #if defined (COND_COMMAND)
! static int cond_lineno;
! static int cond_token;
! #endif
  
! STREAM_SAVER *stream_list = (STREAM_SAVER *)NULL;
  
! void
! push_stream (reset_lineno)
!      int reset_lineno;
! {
!   STREAM_SAVER *saver = (STREAM_SAVER *)xmalloc (sizeof (STREAM_SAVER));
  
!   xbcopy ((char *)&bash_input, (char *)&(saver->bash_input), sizeof (BASH_INPUT));
  
! #if defined (BUFFERED_INPUT)
!   saver->bstream = (BUFFERED_STREAM *)NULL;
!   /* If we have a buffered stream, clear out buffers[fd]. */
!   if (bash_input.type == st_bstream && bash_input.location.buffered_fd >= 0)
!     saver->bstream = set_buffered_stream (bash_input.location.buffered_fd,
!     					  (BUFFERED_STREAM *)NULL);
! #endif /* BUFFERED_INPUT */
! 
!   saver->line = line_number;
!   bash_input.name = (char *)NULL;
!   saver->next = stream_list;
!   stream_list = saver;
!   EOF_Reached = 0;
!   if (reset_lineno)
!     line_number = 0;
! }
! 
! void
! pop_stream ()
  {
!   if (!stream_list)
!     EOF_Reached = 1;
!   else
      {
!       STREAM_SAVER *saver = stream_list;
  
!       EOF_Reached = 0;
!       stream_list = stream_list->next;
  
!       init_yy_io (saver->bash_input.getter,
! 		  saver->bash_input.ungetter,
! 		  saver->bash_input.type,
! 		  saver->bash_input.name,
! 		  saver->bash_input.location);
  
! #if defined (BUFFERED_INPUT)
!       /* If we have a buffered stream, restore buffers[fd]. */
!       /* If the input file descriptor was changed while this was on the
! 	 save stack, update the buffered fd to the new file descriptor and
! 	 re-establish the buffer <-> bash_input fd correspondence. */
!       if (bash_input.type == st_bstream && bash_input.location.buffered_fd >= 0)
!         {
!           if (bash_input_fd_changed)
! 	    {
! 	      bash_input_fd_changed = 0;
! 	      if (default_buffered_input >= 0)
! 		{
! 		  bash_input.location.buffered_fd = default_buffered_input;
! 		  saver->bstream->b_fd = default_buffered_input;
! 		}
! 	    }
! 	  set_buffered_stream (bash_input.location.buffered_fd, saver->bstream);
!         }
! #endif /* BUFFERED_INPUT */
  
!       line_number = saver->line;
  
!       FREE (saver->bash_input.name);
!       free (saver);
      }
- }
  
! /* Return 1 if a stream of type TYPE is saved on the stack. */
! int
! stream_on_stack (type)
!      enum stream_type type;
! {
!   register STREAM_SAVER *s;
  
!   for (s = stream_list; s; s = s->next)
!     if (s->bash_input.type == type)
!       return 1;
!   return 0;
! }
  
! /* Save the current token state and return it in a malloced array. */
! int *
! save_token_state ()
! {
!   int *ret;
  
!   ret = (int *)xmalloc (3 * sizeof (int));
!   ret[0] = last_read_token;
!   ret[1] = token_before_that;
!   ret[2] = two_tokens_ago;
!   return ret;
  }
  
  void
! restore_token_state (ts)
!      int *ts;
  {
!   if (ts == 0)
!     return;
!   last_read_token = ts[0];
!   token_before_that = ts[1];
!   two_tokens_ago = ts[2];
! }
  
! /*
!  * This is used to inhibit alias expansion and reserved word recognition
!  * inside case statement pattern lists.  A `case statement pattern list' is:
!  *
!  *	everything between the `in' in a `case word in' and the next ')'
!  *	or `esac'
!  *	everything between a `;;' and the next `)' or `esac'
!  */
  
  #if defined (ALIAS) || defined (DPAREN_ARITHMETIC)
  
! #if !defined (ALIAS)
! typedef void *alias_t;
! #endif
! 
! #define END_OF_ALIAS 0
! 
! /*
!  * Pseudo-global variables used in implementing token-wise alias expansion.
!  */
! 
! /*
!  * Pushing and popping strings.  This works together with shell_getc to
!  * implement alias expansion on a per-token basis.
!  */
  
! typedef struct string_saver {
!   struct string_saver *next;
!   int expand_alias;  /* Value to set expand_alias to when string is popped. */
!   char *saved_line;
! #if defined (ALIAS)
!   alias_t *expander;   /* alias that caused this line to be pushed. */
! #endif
!   int saved_line_size, saved_line_index, saved_line_terminator;
! } STRING_SAVER;
  
! STRING_SAVER *pushed_string_list = (STRING_SAVER *)NULL;
  
! /*
!  * Push the current shell_input_line onto a stack of such lines and make S
!  * the current input.  Used when expanding aliases.  EXPAND is used to set
!  * the value of expand_next_token when the string is popped, so that the
!  * word after the alias in the original line is handled correctly when the
!  * alias expands to multiple words.  TOKEN is the token that was expanded
!  * into S; it is saved and used to prevent infinite recursive expansion.
!  */
! static void
! push_string (s, expand, ap)
!      char *s;
!      int expand;
!      alias_t *ap;
  {
!   STRING_SAVER *temp = (STRING_SAVER *) xmalloc (sizeof (STRING_SAVER));
  
!   temp->expand_alias = expand;
!   temp->saved_line = shell_input_line;
!   temp->saved_line_size = shell_input_line_size;
!   temp->saved_line_index = shell_input_line_index;
!   temp->saved_line_terminator = shell_input_line_terminator;
! #if defined (ALIAS)
!   temp->expander = ap;
! #endif
!   temp->next = pushed_string_list;
!   pushed_string_list = temp;
  
! #if defined (ALIAS)
!   if (ap)
!     ap->flags |= AL_BEINGEXPANDED;
! #endif
  
!   shell_input_line = s;
!   shell_input_line_size = strlen (s);
!   shell_input_line_index = 0;
!   shell_input_line_terminator = '\0';
!   parser_state &= ~PST_ALEXPNEXT;
! }
  
! /*
!  * Make the top of the pushed_string stack be the current shell input.
!  * Only called when there is something on the stack.  Called from shell_getc
!  * when it thinks it has consumed the string generated by an alias expansion
!  * and needs to return to the original input line.
!  */
! static void
! pop_string ()
! {
!   STRING_SAVER *t;
  
!   FREE (shell_input_line);
!   shell_input_line = pushed_string_list->saved_line;
!   shell_input_line_index = pushed_string_list->saved_line_index;
!   shell_input_line_size = pushed_string_list->saved_line_size;
!   shell_input_line_terminator = pushed_string_list->saved_line_terminator;
  
!   if (pushed_string_list->expand_alias)
!     parser_state |= PST_ALEXPNEXT;
!   else
!     parser_state &= ~PST_ALEXPNEXT;
  
!   t = pushed_string_list;
!   pushed_string_list = pushed_string_list->next;
  
! #if defined (ALIAS)
!   if (t->expander)
!     t->expander->flags &= ~AL_BEINGEXPANDED;
! #endif
  
!   free ((char *)t);
! }
  
! static void
! free_string_list ()
! {
!   register STRING_SAVER *t, *t1;
  
!   for (t = pushed_string_list; t; )
      {
-       t1 = t->next;
-       FREE (t->saved_line);
  #if defined (ALIAS)
!       if (t->expander)
! 	t->expander->flags &= ~AL_BEINGEXPANDED;
! #endif
!       free ((char *)t);
!       t = t1;
!     }
!   pushed_string_list = (STRING_SAVER *)NULL;
! }
  
! #endif /* ALIAS || DPAREN_ARITHMETIC */
  
! /* Return a line of text, taken from wherever yylex () reads input.
!    If there is no more input, then we return NULL.  If REMOVE_QUOTED_NEWLINE
!    is non-zero, we remove unquoted \<newline> pairs.  This is used by
!    read_secondary_line to read here documents. */
! static char *
! read_a_line (remove_quoted_newline)
!      int remove_quoted_newline;
! {
!   static char *line_buffer = (char *)NULL;
!   static int buffer_size = 0;
!   int indx = 0, c, peekc, pass_next;
  
! #if defined (READLINE)
!   if (interactive && bash_input.type != st_string && no_line_editing)
! #else
!   if (interactive && bash_input.type != st_string)
! #endif
!     print_prompt ();
  
!   pass_next = 0;
!   while (1)
!     {
!       c = yy_getc ();
  
!       /* Allow immediate exit if interrupted during input. */
!       QUIT;
  
!       if (c == 0)
! 	continue;
  
!       /* If there is no more input, then we return NULL. */
!       if (c == EOF)
! 	{
! 	  if (interactive && bash_input.type == st_stream)
! 	    clearerr (stdin);
! 	  if (indx == 0)
! 	    return ((char *)NULL);
! 	  c = '\n';
  	}
  
!       /* `+2' in case the final character in the buffer is a newline. */
!       RESIZE_MALLOCED_BUFFER (line_buffer, indx, 2, buffer_size, 128);
  
!       /* IF REMOVE_QUOTED_NEWLINES is non-zero, we are reading a
! 	 here document with an unquoted delimiter.  In this case,
! 	 the line will be expanded as if it were in double quotes.
! 	 We allow a backslash to escape the next character, but we
! 	 need to treat the backslash specially only if a backslash
! 	 quoting a backslash-newline pair appears in the line. */
!       if (pass_next)
!         {
! 	  line_buffer[indx++] = c;
! 	  pass_next = 0;
!         }
!       else if (c == '\\' && remove_quoted_newline)
  	{
! 	  peekc = yy_getc ();
! 	  if (peekc == '\n')
! 	    continue;	/* Make the unquoted \<newline> pair disappear. */
! 	  else
! 	    {
! 	      yy_ungetc (peekc);
! 	      pass_next = 1;
! 	      line_buffer[indx++] = c;		/* Preserve the backslash. */
! 	    }
  	}
-       else
- 	line_buffer[indx++] = c;
  
!       if (c == '\n')
! 	{
! 	  line_buffer[indx] = '\0';
! 	  return (line_buffer);
! 	}
!     }
! }
  
! /* Return a line as in read_a_line (), but insure that the prompt is
!    the secondary prompt.  This is used to read the lines of a here
!    document.  REMOVE_QUOTED_NEWLINE is non-zero if we should remove
!    newlines quoted with backslashes while reading the line.  It is
!    non-zero unless the delimiter of the here document was quoted. */
! char *
! read_secondary_line (remove_quoted_newline)
!      int remove_quoted_newline;
! {
!   prompt_string_pointer = &ps2_prompt;
!   prompt_again ();
!   return (read_a_line (remove_quoted_newline));
! }
  
! /* **************************************************************** */
! /*								    */
! /*				YYLEX ()			    */
! /*								    */
! /* **************************************************************** */
  
! /* Reserved words.  These are only recognized as the first word of a
!    command. */
! STRING_INT_ALIST word_token_alist[] = {
!   { "if", IF },
!   { "then", THEN },
!   { "else", ELSE },
!   { "elif", ELIF },
!   { "fi", FI },
!   { "case", CASE },
!   { "esac", ESAC },
!   { "for", FOR },
! #if defined (SELECT_COMMAND)
!   { "select", SELECT },
! #endif
!   { "while", WHILE },
!   { "until", UNTIL },
!   { "do", DO },
!   { "done", DONE },
!   { "in", IN },
!   { "function", FUNCTION },
! #if defined (COMMAND_TIMING)
!   { "time", TIME },
! #endif
!   { "{", '{' },
!   { "}", '}' },
!   { "!", BANG },
! #if defined (COND_COMMAND)
!   { "[[", COND_START },
!   { "]]", COND_END },
  #endif
!   { (char *)NULL, 0}
! };
! 
! /* XXX - we should also have an alist with strings for other tokens, so we
!          can give more descriptive error messages.  Look at y.tab.h for the
!          other tokens. */
! 
! /* These are used by read_token_word, but appear up here so that shell_getc
!    can use them to decide when to add otherwise blank lines to the history. */
! 
! /* The primary delimiter stack. */
! struct dstack dstack = {  (char *)NULL, 0, 0 };
! 
! /* A temporary delimiter stack to be used when decoding prompt strings.
!    This is needed because command substitutions in prompt strings (e.g., PS2)
!    can screw up the parser's quoting state. */
! static struct dstack temp_dstack = { (char *)NULL, 0, 0 };
! 
! /* Macro for accessing the top delimiter on the stack.  Returns the
!    delimiter or zero if none. */
! #define current_delimiter(ds) \
!   (ds.delimiter_depth ? ds.delimiters[ds.delimiter_depth - 1] : 0)
! 
! #define push_delimiter(ds, character) \
!   do \
!     { \
!       if (ds.delimiter_depth + 2 > ds.delimiter_space) \
! 	ds.delimiters = xrealloc \
! 	  (ds.delimiters, (ds.delimiter_space += 10) * sizeof (char)); \
!       ds.delimiters[ds.delimiter_depth] = character; \
!       ds.delimiter_depth++; \
!     } \
!   while (0)
  
! #define pop_delimiter(ds)	ds.delimiter_depth--
  
! /* Return the next shell input character.  This always reads characters
!    from shell_input_line; when that line is exhausted, it is time to
!    read the next line.  This is called by read_token when the shell is
!    processing normal command input. */
  
! static int
! shell_getc (remove_quoted_newline)
!      int remove_quoted_newline;
  {
!   register int i;
!   int c;
!   static int mustpop = 0;
  
!   QUIT;
  
! #if defined (ALIAS) || defined (DPAREN_ARITHMETIC)
!   /* If shell_input_line[shell_input_line_index] == 0, but there is
!      something on the pushed list of strings, then we don't want to go
!      off and get another line.  We let the code down below handle it. */
  
!   if (!shell_input_line || ((!shell_input_line[shell_input_line_index]) &&
! 			    (pushed_string_list == (STRING_SAVER *)NULL)))
! #else /* !ALIAS && !DPAREN_ARITHMETIC */
!   if (!shell_input_line || !shell_input_line[shell_input_line_index])
! #endif /* !ALIAS && !DPAREN_ARITHMETIC */
      {
!       line_number++;
! 
!     restart_read:
! 
!       /* Allow immediate exit if interrupted during input. */
!       QUIT;
  
!       i = 0;
!       shell_input_line_terminator = 0;
  
! #if defined (JOB_CONTROL)
!       /* This can cause a problem when reading a command as the result
! 	 of a trap, when the trap is called from flush_child.  This call
! 	 had better not cause jobs to disappear from the job table in
! 	 that case, or we will have big trouble. */
!       notify_and_cleanup ();
! #else /* !JOB_CONTROL */
!       cleanup_dead_jobs ();
! #endif /* !JOB_CONTROL */
  
! #if defined (READLINE)
!       if (interactive && bash_input.type != st_string && no_line_editing)
! #else
!       if (interactive && bash_input.type != st_string)
  #endif
! 	print_prompt ();
  
!       if (bash_input.type == st_stream)
! 	clearerr (stdin);
  
!       while (c = yy_getc ())
  	{
! 	  /* Allow immediate exit if interrupted during input. */
! 	  QUIT;
  
! 	  RESIZE_MALLOCED_BUFFER (shell_input_line, i, 2, shell_input_line_size, 256);
  
! 	  if (c == EOF)
  	    {
! 	      if (bash_input.type == st_stream)
! 		clearerr (stdin);
! 
! 	      if (i == 0)
! 		shell_input_line_terminator = EOF;
! 
! 	      shell_input_line[i] = '\0';
! 	      break;
! 	    }
! 
! 	  shell_input_line[i++] = c;
! 
! 	  if (c == '\n')
! 	    {
! 	      shell_input_line[--i] = '\0';
! 	      current_command_line_count++;
! 	      break;
  	    }
  	}
!       shell_input_line_index = 0;
!       shell_input_line_len = i;		/* == strlen (shell_input_line) */
! 
! #if defined (HISTORY)
!       if (remember_on_history && shell_input_line && shell_input_line[0])
  	{
! 	  char *expansions;
! #  if defined (BANG_HISTORY)
! 	  int old_hist;
! 
! 	  /* If the current delimiter is a single quote, we should not be
! 	     performing history expansion, even if we're on a different
! 	     line from the original single quote. */
! 	  old_hist = history_expansion_inhibited;
! 	  if (current_delimiter (dstack) == '\'')
! 	    history_expansion_inhibited = 1;
! #  endif
! 	  expansions = pre_process_line (shell_input_line, 1, 1);
! #  if defined (BANG_HISTORY)
! 	  history_expansion_inhibited = old_hist;
! #  endif
! 	  if (expansions != shell_input_line)
  	    {
! 	      free (shell_input_line);
! 	      shell_input_line = expansions;
! 	      shell_input_line_len = shell_input_line ?
! 					strlen (shell_input_line) : 0;
! 	      if (!shell_input_line_len)
! 		current_command_line_count--;
! 
! 	      /* We have to force the xrealloc below because we don't know
! 	         the true allocated size of shell_input_line anymore. */
! 	      shell_input_line_size = shell_input_line_len;
  	    }
  	}
!       /* XXX - this is grotesque */
!       else if (remember_on_history && shell_input_line &&
! 	       shell_input_line[0] == '\0' &&
! 	       current_command_line_count > 1 && current_delimiter (dstack))
! 	{
! 	  /* We know shell_input_line[0] == 0 and we're reading some sort of
! 	     quoted string.  This means we've got a line consisting of only
! 	     a newline in a quoted string.  We want to make sure this line
! 	     gets added to the history. */
! 	  maybe_add_history (shell_input_line);
! 	}
! 
! #endif /* HISTORY */
! 
!       if (shell_input_line)
! 	{
! 	  /* Lines that signify the end of the shell's input should not be
! 	     echoed. */
! 	  if (echo_input_at_read && (shell_input_line[0] ||
! 				     shell_input_line_terminator != EOF))
! 	    fprintf (stderr, "%s\n", shell_input_line);
! 	}
!       else
  	{
! 	  shell_input_line_size = 0;
! 	  prompt_string_pointer = &current_prompt_string;
! 	  prompt_again ();
! 	  goto restart_read;
  	}
  
!       /* Add the newline to the end of this string, iff the string does
! 	 not already end in an EOF character.  */
!       if (shell_input_line_terminator != EOF)
! 	{
! 	  if (shell_input_line_len + 3 > shell_input_line_size)
! 	    shell_input_line = xrealloc (shell_input_line,
! 					1 + (shell_input_line_size += 2));
  
! 	  shell_input_line[shell_input_line_len] = '\n';
! 	  shell_input_line[shell_input_line_len + 1] = '\0';
! 	}
!     }
  
!   c = shell_input_line[shell_input_line_index];
  
!   if (c)
!     shell_input_line_index++;
  
!   if (c == '\\' && remove_quoted_newline &&
!       shell_input_line[shell_input_line_index] == '\n')
      {
! 	prompt_again ();
! 	line_number++;
! 	goto restart_read;
      }
! 
! #if defined (ALIAS) || defined (DPAREN_ARITHMETIC)
!   /* If C is NULL, we have reached the end of the current input string.  If
!      pushed_string_list is non-empty, it's time to pop to the previous string
!      because we have fully consumed the result of the last alias expansion.
!      Do it transparently; just return the next character of the string popped
!      to. */
!   if (!c && (pushed_string_list != (STRING_SAVER *)NULL))
      {
!       if (mustpop)
!         {
!           pop_string ();
!           c = shell_input_line[shell_input_line_index];
! 	  if (c)
! 	    shell_input_line_index++;
! 	  mustpop--;
!         }
!       else
!         {
!           mustpop++;
!           c = ' ';
!         }
      }
! #endif /* ALIAS || DPAREN_ARITHMETIC */
! 
!   if (!c && shell_input_line_terminator == EOF)
!     return ((shell_input_line_index != 0) ? '\n' : EOF);
! 
!   return ((unsigned char)c);
  }
  
! /* Put C back into the input for the shell. */
! static void
! shell_ungetc (c)
!      int c;
! {
!   if (shell_input_line && shell_input_line_index)
!     shell_input_line[--shell_input_line_index] = c;
! }
  
! static void
! shell_ungetchar ()
  {
!   if (shell_input_line && shell_input_line_index)
!     shell_input_line_index--;
  }
  
! /* Discard input until CHARACTER is seen, then push that character back
!    onto the input stream. */
! static void
! discard_until (character)
!      int character;
  {
!   int c;
! 
!   while ((c = shell_getc (0)) != EOF && c != character)
!     ;
  
!   if (c != EOF)
!     shell_ungetc (c);
  }
  
! void
! execute_prompt_command (command)
!      char *command;
  {
!   Function *temp_last, *temp_this;
!   char *last_lastarg;
!   int temp_exit_value, temp_eof_encountered;
! 
!   temp_last = last_shell_builtin;
!   temp_this = this_shell_builtin;
!   temp_exit_value = last_command_exit_value;
!   temp_eof_encountered = eof_encountered;
!   last_lastarg = get_string_value ("_");
!   if (last_lastarg)
!     last_lastarg = savestring (last_lastarg);
! 
!   parse_and_execute (savestring (command), "PROMPT_COMMAND", SEVAL_NONINT|SEVAL_NOHIST);
! 
!   last_shell_builtin = temp_last;
!   this_shell_builtin = temp_this;
!   last_command_exit_value = temp_exit_value;
!   eof_encountered = temp_eof_encountered;
! 
!   bind_variable ("_", last_lastarg);
!   FREE (last_lastarg);
  
!   if (token_to_read == '\n')	/* reset_parser was called */
!     token_to_read = 0;
  }
  
- /* Place to remember the token.  We try to keep the buffer
-    at a reasonable size, but it can grow. */
- static char *token = (char *)NULL;
- 
- /* Current size of the token buffer. */
- static int token_buffer_size;
- 
- /* Command to read_token () explaining what we want it to do. */
- #define READ 0
- #define RESET 1
- #define prompt_is_ps1 \
-       (!prompt_string_pointer || prompt_string_pointer == &ps1_prompt)
- 
- /* Function for yyparse to call.  yylex keeps track of
-    the last two tokens read, and calls read_token.  */
  static int
! yylex ()
  {
!   if (interactive && (current_token == 0 || current_token == '\n'))
      {
!       /* Before we print a prompt, we might have to check mailboxes.
! 	 We do this only if it is time to do so. Notice that only here
! 	 is the mail alarm reset; nothing takes place in check_mail ()
! 	 except the checking of mail.  Please don't change this. */
!       if (prompt_is_ps1 && time_to_check_mail ())
! 	{
! 	  check_mail ();
! 	  reset_mail_timer ();
! 	}
! 
!       /* Avoid printing a prompt if we're not going to read anything, e.g.
! 	 after resetting the parser with read_token (RESET). */
!       if (token_to_read == 0 && interactive)
  	prompt_again ();
      }
! 
!   two_tokens_ago = token_before_that;
!   token_before_that = last_read_token;
!   last_read_token = current_token;
!   current_token = read_token (READ);
!   return (current_token);
  }
  
! /* When non-zero, we have read the required tokens
!    which allow ESAC to be the next one read. */
! static int esacs_needed_count;
  
! void
! gather_here_documents ()
  {
!   int r = 0;
!   while (need_here_doc)
      {
!       make_here_document (redir_stack[r++]);
!       need_here_doc--;
      }
! }
! 
! /* When non-zero, an open-brace used to create a group is awaiting a close
!    brace partner. */
! static int open_brace_count;
  
! #define command_token_position(token) \
!   (((token) == ASSIGNMENT_WORD) || \
!    ((token) != SEMI_SEMI && reserved_word_acceptable(token)))
  
! #define assignment_acceptable(token) command_token_position(token) && \
! 					((parser_state & PST_CASEPAT) == 0)
  
! /* Check to see if TOKEN is a reserved word and return the token
!    value if it is. */
! #define CHECK_FOR_RESERVED_WORD(tok) \
!   do { \
!     if (!dollar_present && !quoted && \
! 	reserved_word_acceptable (last_read_token)) \
!       { \
! 	int i; \
! 	for (i = 0; word_token_alist[i].word != (char *)NULL; i++) \
! 	  if (STREQ (tok, word_token_alist[i].word)) \
! 	    { \
! 	      if ((parser_state & PST_CASEPAT) && (word_token_alist[i].token != ESAC)) \
! 		break; \
! 	      if (word_token_alist[i].token == TIME) \
! 		break; \
! 	      if (word_token_alist[i].token == ESAC) \
! 		parser_state &= ~(PST_CASEPAT|PST_CASESTMT); \
! 	      else if (word_token_alist[i].token == CASE) \
! 		parser_state |= PST_CASESTMT; \
! 	      else if (word_token_alist[i].token == COND_END) \
! 		parser_state &= ~(PST_CONDCMD|PST_CONDEXPR); \
! 	      else if (word_token_alist[i].token == COND_START) \
! 		parser_state |= PST_CONDCMD; \
! 	      else if (word_token_alist[i].token == '{') \
! 		open_brace_count++; \
! 	      else if (word_token_alist[i].token == '}' && open_brace_count) \
! 		open_brace_count--; \
! 	      return (word_token_alist[i].token); \
! 	    } \
!       } \
!   } while (0)
  
! #if defined (ALIAS)
  
!     /* OK, we have a token.  Let's try to alias expand it, if (and only if)
!        it's eligible.
  
!        It is eligible for expansion if the shell is in interactive mode, and
!        the token is unquoted and the last token read was a command
!        separator (or expand_next_token is set), and we are currently
!        processing an alias (pushed_string_list is non-empty) and this
!        token is not the same as the current or any previously
!        processed alias.
  
-        Special cases that disqualify:
- 	 In a pattern list in a case statement (parser_state & PST_CASEPAT). */
  static int
! alias_expand_token (token)
!      char *token;
  {
!   char *expanded;
!   alias_t *ap;
  
!   if (((parser_state & PST_ALEXPNEXT) || command_token_position (last_read_token)) &&
! 	(parser_state & PST_CASEPAT) == 0)
!     {
!       ap = find_alias (token);
  
!       /* Currently expanding this token. */
!       if (ap && (ap->flags & AL_BEINGEXPANDED))
! 	return (NO_EXPANSION);
! 
!       expanded = ap ? savestring (ap->value) : (char *)NULL;
!       if (expanded)
! 	{
! 	  push_string (expanded, ap->flags & AL_EXPANDNEXT, ap);
! 	  return (RE_READ_TOKEN);
! 	}
!       else
! 	/* This is an eligible token that does not have an expansion. */
! 	return (NO_EXPANSION);
!     }
!   return (NO_EXPANSION);
! }
! #endif /* ALIAS */
! 
! static int
! time_command_acceptable ()
! {
! #if defined (COMMAND_TIMING)
!   switch (last_read_token)
!     {
!     case 0:
!     case ';':
!     case '\n':
!     case AND_AND:
!     case OR_OR:
!     case '&':
!     case DO:
!     case THEN:
!     case ELSE:
!     case '{':
!     case '(':
!       return 1;
!     default:
!       return 0;
!     }
! #else
!   return 0;
! #endif /* COMMAND_TIMING */
! }
! 
! /* Handle special cases of token recognition:
! 	IN is recognized if the last token was WORD and the token
! 	before that was FOR or CASE or SELECT.
! 
! 	DO is recognized if the last token was WORD and the token
! 	before that was FOR or SELECT.
! 
! 	ESAC is recognized if the last token caused `esacs_needed_count'
! 	to be set
! 
! 	`{' is recognized if the last token as WORD and the token
! 	before that was FUNCTION.
  
! 	`}' is recognized if there is an unclosed `{' prsent.
  
! 	`-p' is returned as TIMEOPT if the last read token was TIME.
  
! 	']]' is returned as COND_END if the parser is currently parsing
! 	a conditional expression ((parser_state & PST_CONDEXPR) != 0)
  
! 	`time' is returned as TIME if and only if it is immediately
! 	preceded by one of `;', `\n', `||', `&&', or `&'.
! */
  
! static int
! special_case_tokens (token)
!      char *token;
! {
!   if ((last_read_token == WORD) &&
! #if defined (SELECT_COMMAND)
!       ((token_before_that == FOR) || (token_before_that == CASE) || (token_before_that == SELECT)) &&
! #else
!       ((token_before_that == FOR) || (token_before_that == CASE)) &&
! #endif
!       (token[0] == 'i' && token[1] == 'n' && token[2] == 0))
!     {
!       if (token_before_that == CASE)
! 	{
! 	  parser_state |= PST_CASEPAT;
! 	  esacs_needed_count++;
! 	}
!       return (IN);
!     }
  
!   if (last_read_token == WORD &&
! #if defined (SELECT_COMMAND)
!       (token_before_that == FOR || token_before_that == SELECT) &&
! #else
!       (token_before_that == FOR) &&
! #endif
!       (token[0] == 'd' && token[1] == 'o' && token[2] == '\0'))
!     return (DO);
  
!   /* Ditto for ESAC in the CASE case.
!      Specifically, this handles "case word in esac", which is a legal
!      construct, certainly because someone will pass an empty arg to the
!      case construct, and we don't want it to barf.  Of course, we should
!      insist that the case construct has at least one pattern in it, but
!      the designers disagree. */
!   if (esacs_needed_count)
      {
!       esacs_needed_count--;
!       if (STREQ (token, "esac"))
! 	{
! 	  parser_state &= ~PST_CASEPAT;
! 	  return (ESAC);
! 	}
!     }
  
!   /* The start of a shell function definition. */
!   if (parser_state & PST_ALLOWOPNBRC)
!     {
!       parser_state &= ~PST_ALLOWOPNBRC;
!       if (token[0] == '{' && token[1] == '\0')		/* } */
  	{
! 	  open_brace_count++;
! 	  function_bstart = line_number;
! 	  return ('{');					/* } */
  	}
-     }
- 
-   if (open_brace_count && reserved_word_acceptable (last_read_token) && token[0] == '}' && !token[1])
-     {
-       open_brace_count--;		/* { */
-       return ('}');
-     }
- 
- #if defined (COMMAND_TIMING)
-   /* Handle -p after `time'. */
-   if (last_read_token == TIME && token[0] == '-' && token[1] == 'p' && !token[2])
-     return (TIMEOPT);
- #endif
- 
- #if defined (COMMAND_TIMING)
-   if (STREQ (token, "time") && ((parser_state & PST_CASEPAT) == 0) && time_command_acceptable ())
-     return (TIME);
- #endif /* COMMAND_TIMING */
- 
- #if defined (COND_COMMAND) /* [[ */
-   if ((parser_state & PST_CONDEXPR) && token[0] == ']' && token[1] == ']' && token[2] == '\0')
-     return (COND_END);
- #endif
- 
-   return (-1);
- }
- 
- /* Called from shell.c when Control-C is typed at top level.  Or
-    by the error rule at top level. */
- void
- reset_parser ()
- {
-   dstack.delimiter_depth = 0;	/* No delimiters found so far. */
-   open_brace_count = 0;
- 
-   parser_state = 0;
- 
- #if defined (ALIAS) || defined (DPAREN_ARITHMETIC)
-   if (pushed_string_list)
-     free_string_list ();
- #endif /* ALIAS || DPAREN_ARITHMETIC */
  
!   if (shell_input_line)
!     {
!       free (shell_input_line);
!       shell_input_line = (char *)NULL;
!       shell_input_line_size = shell_input_line_index = 0;
!     }
  
!   FREE (word_desc_to_read);
!   word_desc_to_read = (WORD_DESC *)NULL;
  
!   last_read_token = '\n';
!   token_to_read = '\n';
! }
  
! /* Read the next token.  Command can be READ (normal operation) or
!    RESET (to normalize state). */
! static int
! read_token (command)
!      int command;
! {
!   int character;		/* Current character. */
!   int peek_char;		/* Temporary look-ahead character. */
!   int result;			/* The thing to return. */
  
!   if (command == RESET)
!     {
!       reset_parser ();
!       return ('\n');
!     }
  
!   if (token_to_read)
!     {
!       result = token_to_read;
!       if (token_to_read == WORD || token_to_read == ASSIGNMENT_WORD)
  	{
! 	  yylval.word = word_desc_to_read;
! 	  word_desc_to_read = (WORD_DESC *)NULL;
  	}
-       token_to_read = 0;
-       return (result);
-     }
  
! #if defined (COND_COMMAND)
!   if ((parser_state & (PST_CONDCMD|PST_CONDEXPR)) == PST_CONDCMD)
!     {
!       cond_lineno = line_number;
!       parser_state |= PST_CONDEXPR;
!       yylval.command = parse_cond_command ();
!       if (cond_token != COND_END)
  	{
! 	  if (EOF_Reached && cond_token != COND_ERROR)		/* [[ */
! 	    parser_error (cond_lineno, "unexpected EOF while looking for `]]'");
! 	  else if (cond_token != COND_ERROR)
! 	    parser_error (cond_lineno, "syntax error in conditional expression");
! 	  return (-1);
  	}
!       token_to_read = COND_END;
!       parser_state &= ~(PST_CONDEXPR|PST_CONDCMD);
!       return (COND_CMD);
!     }
! #endif
! 
! #if defined (ALIAS)
!   /* This is a place to jump back to once we have successfully expanded a
!      token with an alias and pushed the string with push_string () */
!  re_read_token:
! #endif /* ALIAS */
! 
!   /* Read a single word from input.  Start by skipping blanks. */
!   while ((character = shell_getc (1)) != EOF && whitespace (character))
!     ;
! 
!   if (character == EOF)
!     {
!       EOF_Reached = 1;
!       return (yacc_EOF);
!     }
! 
!   if (character == '#' && (!interactive || interactive_comments))
!     {
!       /* A comment.  Discard until EOL or EOF, and then return a newline. */
!       discard_until ('\n');
!       shell_getc (0);
!       character = '\n';	/* this will take the next if statement and return. */
!     }
  
!   if (character == '\n')
!     {
!       /* If we're about to return an unquoted newline, we can go and collect
! 	 the text of any pending here document. */
!       if (need_here_doc)
! 	gather_here_documents ();
  
! #if defined (ALIAS)
!       parser_state &= ~PST_ALEXPNEXT;
! #endif /* ALIAS */
  
!       return (character);
!     }
  
!   /* Shell meta-characters. */
!   if (shellmeta (character) && ((parser_state & PST_DBLPAREN) == 0))
!     {
! #if defined (ALIAS)
!       /* Turn off alias tokenization iff this character sequence would
! 	 not leave us ready to read a command. */
!       if (character == '<' || character == '>')
! 	parser_state &= ~PST_ALEXPNEXT;
! #endif /* ALIAS */
  
!       peek_char = shell_getc (1);
!       if (character == peek_char)
  	{
! 	  switch (character)
  	    {
! 	    case '<':
! 	      /* If '<' then we could be at "<<" or at "<<-".  We have to
! 		 look ahead one more character. */
! 	      peek_char = shell_getc (1);
! 	      if (peek_char == '-')
! 		return (LESS_LESS_MINUS);
! 	      else
  		{
! 		  shell_ungetc (peek_char);
! 		  return (LESS_LESS);
  		}
  
! 	    case '>':
! 	      return (GREATER_GREATER);
  
! 	    case ';':
! 	      parser_state |= PST_CASEPAT;
! #if defined (ALIAS)
! 	      parser_state &= ~PST_ALEXPNEXT;
! #endif /* ALIAS */
! 	      return (SEMI_SEMI);
  
! 	    case '&':
! 	      return (AND_AND);
  
! 	    case '|':
! 	      return (OR_OR);
  
! #if defined (DPAREN_ARITHMETIC) || defined (ARITH_FOR_COMMAND)
! 	    case '(':		/* ) */
! #  if defined (ARITH_FOR_COMMAND)
! 	      if (last_read_token == FOR)
! 		{
! 		  int cmdtyp, len;
! 		  char *wval, *wv2;
! 		  WORD_DESC *wd;
  
! 		  arith_for_lineno = line_number;
! 		  cmdtyp = parse_arith_cmd (&wval);
! 		  if (cmdtyp == 1)
! 		    {
! 		      /* parse_arith_cmd adds quotes at the beginning and end
! 		         of the string it returns; we need to take those out. */
! 		      len = strlen (wval);
! 		      wv2 = xmalloc (len);
! 		      strncpy (wv2, wval + 1, len - 2);
! 		      wv2[len - 2] = '\0';
! 		      wd = make_word (wv2);
! 		      yylval.word_list = make_word_list (wd, (WORD_LIST *)NULL);
! 		      free (wval);
! 		      free (wv2);
! 		      return (ARITH_FOR_EXPRS);
! 		    }
! 		  else
! 		    return -1;		/* ERROR */
! 		}
! #  endif
! #  if defined (DPAREN_ARITHMETIC)
! 	      if (reserved_word_acceptable (last_read_token))
! 		{
! 		  int cmdtyp, sline;
! 		  char *wval;
! 		  WORD_DESC *wd;
  
! 		  sline = line_number;
! 		  cmdtyp = parse_arith_cmd (&wval);
! 		  if (cmdtyp == 1)	/* arithmetic command */
! 		    {
! 		      wd = make_word (wval);
! 		      wd->flags = W_QUOTED;
! 		      yylval.word_list = make_word_list (wd, (WORD_LIST *)NULL);
! 		      free (wval);	/* make_word copies it */
! 		      return (ARITH_CMD);
! 		    }
! 		  else if (cmdtyp == 0)	/* nested subshell */
! 		    {
! 		      push_string (wval, 0, (alias_t *)NULL);
! 		      if ((parser_state & PST_CASEPAT) == 0)
! 			parser_state |= PST_SUBSHELL;
! 		      return (character);
! 		    }
! 		  else			/* ERROR */
! 		    return -1;
! 		}
! 	      break;
! #  endif
! #endif
! 	    }
! 	}
!       else if (character == '<' && peek_char == '&')
! 	return (LESS_AND);
!       else if (character == '>' && peek_char == '&')
! 	return (GREATER_AND);
!       else if (character == '<' && peek_char == '>')
! 	return (LESS_GREATER);
!       else if (character == '>' && peek_char == '|')
! 	return (GREATER_BAR);
!       else if (peek_char == '>' && character == '&')
! 	return (AND_GREATER);
  
!       shell_ungetc (peek_char);
  
!       /* If we look like we are reading the start of a function
! 	 definition, then let the reader know about it so that
! 	 we will do the right thing with `{'. */
!       if (character == ')' && last_read_token == '(' && token_before_that == WORD)
! 	{
! 	  parser_state |= PST_ALLOWOPNBRC;
! #if defined (ALIAS)
! 	  parser_state &= ~PST_ALEXPNEXT;
! #endif /* ALIAS */
! 	  function_dstart = line_number;
! 	}
  
!       /* case pattern lists may be preceded by an optional left paren.  If
! 	 we're not trying to parse a case pattern list, the left paren
! 	 indicates a subshell. */
!       if (character == '(' && (parser_state & PST_CASEPAT) == 0) /* ) */
! 	parser_state |= PST_SUBSHELL;
!       /*(*/
!       else if ((parser_state & PST_CASEPAT) && character == ')')
!         parser_state &= ~PST_CASEPAT;
!       /*(*/
!       else if ((parser_state & PST_SUBSHELL) && character == ')')
! 	parser_state &= ~PST_SUBSHELL;
  
! #if defined (PROCESS_SUBSTITUTION)
!       /* Check for the constructs which introduce process substitution.
! 	 Shells running in `posix mode' don't do process substitution. */
!       if (posixly_correct ||
! 	  ((character != '>' && character != '<') || peek_char != '('))
! #endif /* PROCESS_SUBSTITUTION */
! 	return (character);
!     }
  
!   /* Hack <&- (close stdin) case. */
!   if (character == '-' && (last_read_token == LESS_AND || last_read_token == GREATER_AND))
!     return (character);
  
-   /* Okay, if we got this far, we have to read a word.  Read one,
-      and then check it against the known ones. */
-   result = read_token_word (character);
  #if defined (ALIAS)
!   if (result == RE_READ_TOKEN)
!     goto re_read_token;
  #endif
!   return result;
! }
  
! /* Match a $(...) or other grouping construct.  This has to handle embedded
!    quoted strings ('', ``, "") and nested constructs.  It also must handle
!    reprompting the user, if necessary, after reading a newline, and returning
!    correct error values if it reads EOF. */
  
! #define P_FIRSTCLOSE	0x01
! #define P_ALLOWESC	0x02
  
! static char matched_pair_error;
  static char *
! parse_matched_pair (qc, open, close, lenp, flags)
!      int qc;	/* `"' if this construct is within double quotes */
!      int open, close;
!      int *lenp, flags;
  {
!   int count, ch, was_dollar;
!   int pass_next_character, nestlen, start_lineno;
!   char *ret, *nestret;
!   int retind, retsize;
  
!   count = 1;
!   pass_next_character = was_dollar = 0;
  
!   ret = xmalloc (retsize = 64);
!   retind = 0;
  
!   start_lineno = line_number;
!   while (count)
      {
!       ch = shell_getc ((qc != '\'' || (flags & P_ALLOWESC)) && pass_next_character == 0);
!       if (ch == EOF)
  	{
! 	  free (ret);
! 	  parser_error (start_lineno, "unexpected EOF while looking for matching `%c'", close);
! 	  EOF_Reached = 1;	/* XXX */
! 	  return (&matched_pair_error);
  	}
  
!       /* Possible reprompting. */
!       if (ch == '\n' && interactive &&
! 	    (bash_input.type == st_stdin || bash_input.type == st_stream))
! 	prompt_again ();
  
!       if (pass_next_character)		/* last char was backslash */
! 	{
! 	  pass_next_character = 0;
! 	  if (qc != '\'' && ch == '\n')	/* double-quoted \<newline> disappears. */
! 	    {
! 	      if (retind > 0) retind--;	/* swallow previously-added backslash */
! 	      continue;
! 	    }
  
! 	  RESIZE_MALLOCED_BUFFER (ret, retind, 2, retsize, 64);
! 	  if (ch == CTLESC || ch == CTLNUL)
! 	    ret[retind++] = CTLESC;
! 	  ret[retind++] = ch;
! 	  continue;
! 	}
!       else if (ch == CTLESC || ch == CTLNUL)	/* special shell escapes */
! 	{
! 	  RESIZE_MALLOCED_BUFFER (ret, retind, 2, retsize, 64);
! 	  ret[retind++] = CTLESC;
! 	  ret[retind++] = ch;
! 	  continue;
! 	}
!       else if (ch == close)		/* ending delimiter */
! 	count--;
! #if 1
!       /* handle nested ${...} specially. */
!       else if (open != close && was_dollar && open == '{' && ch == open) /* } */
!         count++;
! #endif
!       else if (((flags & P_FIRSTCLOSE) == 0) && ch == open)		/* nested begin */
! 	count++;
  
!       /* Add this character. */
!       RESIZE_MALLOCED_BUFFER (ret, retind, 1, retsize, 64);
!       ret[retind++] = ch;
  
!       if (open == '\'')			/* '' inside grouping construct */
  	{
! 	  if ((flags & P_ALLOWESC) && ch == '\\')
! 	    pass_next_character++;
! 	  continue;
! 	}
! 
!       if (ch == '\\')			/* backslashes */
! 	pass_next_character++;
  
!       if (open != close)		/* a grouping construct */
! 	{
! 	  if (shellquote (ch))
! 	    {
! 	      /* '', ``, or "" inside $(...) or other grouping construct. */
! 	      push_delimiter (dstack, ch);
! 	      nestret = parse_matched_pair (ch, ch, ch, &nestlen, 0);
! 	      pop_delimiter (dstack);
! 	      if (nestret == &matched_pair_error)
! 		{
! 		  free (ret);
! 		  return &matched_pair_error;
! 		}
! 	      if (nestlen)
! 		{
! 		  RESIZE_MALLOCED_BUFFER (ret, retind, nestlen, retsize, 64);
! 		  strcpy (ret + retind, nestret);
! 		  retind += nestlen;
! 		}
! 	      FREE (nestret);
! 	    }
! 	}
!       /* Parse an old-style command substitution within double quotes as a
! 	 single word. */
!       /* XXX - sh and ksh93 don't do this - XXX */
!       else if (open == '"' && ch == '`')
! 	{
! 	  nestret = parse_matched_pair (0, '`', '`', &nestlen, 0);
! 	  if (nestret == &matched_pair_error)
! 	    {
! 	      free (ret);
! 	      return &matched_pair_error;
! 	    }
! 	  if (nestlen)
! 	    {
! 	      RESIZE_MALLOCED_BUFFER (ret, retind, nestlen, retsize, 64);
! 	      strcpy (ret + retind, nestret);
! 	      retind += nestlen;
! 	    }
! 	  FREE (nestret);
! 	}
!       else if (was_dollar && (ch == '(' || ch == '{' || ch == '['))	/* ) } ] */
! 	/* check for $(), $[], or ${} inside quoted string. */
! 	{
! 	  if (open == ch)	/* undo previous increment */
! 	    count--;
! 	  if (ch == '(')		/* ) */
! 	    nestret = parse_matched_pair (0, '(', ')', &nestlen, 0);
! 	  else if (ch == '{')		/* } */
! 	    nestret = parse_matched_pair (0, '{', '}', &nestlen, P_FIRSTCLOSE);
! 	  else if (ch == '[')		/* ] */
! 	    nestret = parse_matched_pair (0, '[', ']', &nestlen, 0);
! 	  if (nestret == &matched_pair_error)
! 	    {
! 	      free (ret);
! 	      return &matched_pair_error;
! 	    }
! 	  if (nestlen)
! 	    {
! 	      RESIZE_MALLOCED_BUFFER (ret, retind, nestlen, retsize, 64);
! 	      strcpy (ret + retind, nestret);
! 	      retind += nestlen;
! 	    }
! 	  FREE (nestret);
  	}
!       was_dollar = (ch == '$');
!     }
! 
!   ret[retind] = '\0';
!   if (lenp)
!     *lenp = retind;
!   return ret;
! }
! 
! #if defined (DPAREN_ARITHMETIC) || defined (ARITH_FOR_COMMAND)
! /* We've seen a `(('.  Look for the matching `))'.  If we get it, return 1.
!    If not, assume it's a nested subshell for backwards compatibility and
!    return 0.  In any case, put the characters we've consumed into a locally-
!    allocated buffer and make *ep point to that buffer.  Return -1 on an
!    error, for example EOF. */
! static int
! parse_arith_cmd (ep)
!      char **ep;
! {
!   int exp_lineno, rval, c;
!   char *ttok, *token;
!   int ttoklen;
! 
!   exp_lineno = line_number;
!   ttok = parse_matched_pair (0, '(', ')', &ttoklen, 0);
!   rval = 1;
!   if (ttok == &matched_pair_error)
!     return -1;
!   /* Check that the next character is the closing right paren.  If
!      not, this is a syntax error. ( */
!   if ((c = shell_getc (0)) != ')')
!     rval = 0;
! 
!   token = xmalloc (ttoklen + 4);
  
!   /* (( ... )) -> "..." */
!   token[0] = (rval == 1) ? '"' : '(';
!   strncpy (token + 1, ttok, ttoklen - 1);	/* don't copy the final `)' */
!   if (rval == 1)
      {
!       token[ttoklen] = '"';
!       token[ttoklen+1] = '\0';
      }
    else
      {
!       token[ttoklen] = ')';
!       token[ttoklen+1] = c;
!       token[ttoklen+2] = '\0';
      }
-   *ep = token;
-   FREE (ttok);
-   return rval;
  }
- #endif /* DPAREN_ARITHMETIC || ARITH_FOR_COMMAND */
- 
- #if defined (COND_COMMAND)
- static COND_COM *cond_term ();
- static COND_COM *cond_and ();
- static COND_COM *cond_or ();
- static COND_COM *cond_expr ();
  
! static COND_COM *
! cond_expr ()
  {
!   return (cond_or ());  
  }
  
! static COND_COM *
! cond_or ()
  {
!   COND_COM *l, *r;
  
!   l = cond_and ();
!   if (cond_token == OR_OR)
!     {
!       r = cond_or ();
!       l = make_cond_node (COND_OR, (WORD_DESC *)NULL, l, r);
!     }
!   return l;
! }
! 
! static COND_COM *
! cond_and ()
  {
!   COND_COM *l, *r;
  
!   l = cond_term ();
!   if (cond_token == AND_AND)
      {
!       r = cond_and ();
!       l = make_cond_node (COND_AND, (WORD_DESC *)NULL, l, r);
!     }
!   return l;
! }
  
! static int
! cond_skip_newlines ()
! {
!   while ((cond_token = read_token (READ)) == '\n')
!     {
!       if (interactive && (bash_input.type == st_stdin || bash_input.type == st_stream))
! 	prompt_again ();
      }
-   return (cond_token);
  }
  
! #define COND_RETURN_ERROR() \
!   do { cond_token = COND_ERROR; return ((COND_COM *)NULL); } while (0)
  
! static COND_COM *
! cond_term ()
  {
!   WORD_DESC *op;
!   COND_COM *term, *tleft, *tright;
!   int tok, lineno;
  
!   /* Read a token.  It can be a left paren, a `!', a unary operator, or a
!      word that should be the first argument of a binary operator.  Start by
!      skipping newlines, since this is a compound command. */
!   tok = cond_skip_newlines ();
!   lineno = line_number;
!   if (tok == COND_END)
      {
!       COND_RETURN_ERROR ();
      }
!   else if (tok == '(')
      {
!       term = cond_expr ();
!       if (cond_token != ')')
! 	{
! 	  if (term)
! 	    dispose_cond_node (term);		/* ( */
! 	  parser_error (lineno, "expected `)'");
! 	  COND_RETURN_ERROR ();
! 	}
!       term = make_cond_node (COND_EXPR, (WORD_DESC *)NULL, term, (COND_COM *)NULL);
!       (void)cond_skip_newlines ();
      }
!   else if (tok == BANG || (tok == WORD && (yylval.word->word[0] == '!' && yylval.word->word[1] == '\0')))
      {
!       if (tok == WORD)
! 	dispose_word (yylval.word);	/* not needed */
!       term = cond_term ();
!       if (term)
! 	term->flags |= CMD_INVERT_RETURN;
      }
-   else if (tok == WORD && test_unop (yylval.word->word))
-     {
-       op = yylval.word;
-       tok = read_token (READ);
-       if (tok == WORD)
- 	{
- 	  tleft = make_cond_node (COND_TERM, yylval.word, (COND_COM *)NULL, (COND_COM *)NULL);
- 	  term = make_cond_node (COND_UNARY, op, tleft, (COND_COM *)NULL);
- 	}
-       else
- 	{
- 	  dispose_word (op);
- 	  parser_error (line_number, "unexpected argument to conditional unary operator");
- 	  COND_RETURN_ERROR ();
- 	}
  
!       (void)cond_skip_newlines ();
!     }
!   else if (tok == WORD)		/* left argument to binary operator */
!     {
!       /* lhs */
!       tleft = make_cond_node (COND_TERM, yylval.word, (COND_COM *)NULL, (COND_COM *)NULL);
  
!       /* binop */
!       tok = read_token (READ);
!       if (tok == WORD && test_binop (yylval.word->word))
!         op = yylval.word;
!       else if (tok == '<' || tok == '>')
!         op = make_word_from_token (tok);
!       else if (tok == COND_END || tok == AND_AND || tok == OR_OR)
! 	{
! 	  /* Special case.  [[ x ]] is equivalent to [[ -n x ]], just like
! 	     the test command.  Similarly for [[ x && expr ]] or
! 	     [[ x || expr ]] */
! 	  op = make_word ("-n");
! 	  term = make_cond_node (COND_UNARY, op, tleft, (COND_COM *)NULL);
! 	  cond_token = tok;
! 	  return (term);
! 	}
!       else
! 	{
! 	  parser_error (line_number, "conditional binary operator expected");
! 	  dispose_cond_node (tleft);
! 	  COND_RETURN_ERROR ();
! 	}
  
!       /* rhs */
!       tok = read_token (READ);
!       if (tok == WORD)
! 	{
! 	  tright = make_cond_node (COND_TERM, yylval.word, (COND_COM *)NULL, (COND_COM *)NULL);
! 	  term = make_cond_node (COND_BINARY, op, tleft, tright);
! 	}
!       else
! 	{
! 	  parser_error (line_number, "unexpected argument to conditional binary operator");
! 	  dispose_cond_node (tleft);
! 	  dispose_word (op);
! 	  COND_RETURN_ERROR ();
! 	}
  
!       (void)cond_skip_newlines ();
      }
    else
      {
!       if (tok < 256)
! 	parser_error (line_number, "unexpected token `%c' in conditional command", tok);
!       else
! 	parser_error (line_number, "unexpected token %d in conditional command", tok);
!       COND_RETURN_ERROR ();
      }
!   return (term);
! }      
  
! /* This is kind of bogus -- we slip a mini recursive-descent parser in
!    here to handle the conditional statement syntax. */
! static COMMAND *
! parse_cond_command ()
  {
!   COND_COM *cexp;
! 
!   cexp = cond_expr ();
!   return (make_cond_command (cexp));
  }
- #endif
  
! static int
! read_token_word (character)
!      int character;
  {
!   /* The value for YYLVAL when a WORD is read. */
!   WORD_DESC *the_word;
! 
!   /* Index into the token that we are building. */
!   int token_index;
! 
!   /* ALL_DIGITS becomes zero when we see a non-digit. */
!   int all_digits;
! 
!   /* DOLLAR_PRESENT becomes non-zero if we see a `$'. */
!   int dollar_present;
! 
!   /* QUOTED becomes non-zero if we see one of ("), ('), (`), or (\). */
!   int quoted;
! 
!   /* Non-zero means to ignore the value of the next character, and just
!      to add it no matter what. */
!  int pass_next_character;
  
!   /* The current delimiting character. */
!   int cd;
!   int result, peek_char;
!   char *ttok, *ttrans;
!   int ttoklen, ttranslen;
  
!   if (token_buffer_size < TOKEN_DEFAULT_INITIAL_SIZE)
!     token = xrealloc (token, token_buffer_size = TOKEN_DEFAULT_INITIAL_SIZE);
  
!   token_index = 0;
!   all_digits = digit (character);
!   dollar_present = quoted = pass_next_character = 0;
  
!   for (;;)
      {
!       if (character == EOF)
! 	goto got_token;
! 
!       if (pass_next_character)
! 	{
! 	  pass_next_character = 0;
! 	  goto got_character;
! 	}
! 
!       cd = current_delimiter (dstack);
! 
!       /* Handle backslashes.  Quote lots of things when not inside of
! 	 double-quotes, quote some things inside of double-quotes. */
!       if (character == '\\')
  	{
! 	  peek_char = shell_getc (0);
! 
! 	  /* Backslash-newline is ignored in all cases except
! 	     when quoted with single quotes. */
! 	  if (peek_char == '\n')
  	    {
! 	      character = '\n';
! 	      goto next_character;
  	    }
  	  else
  	    {
! 	      shell_ungetc (peek_char);
! 
! 	      /* If the next character is to be quoted, note it now. */
! 	      if (cd == 0 || cd == '`' ||
! 		  (cd == '"' && member (peek_char, slashify_in_quotes)))
! 		pass_next_character++;
! 
! 	      quoted = 1;
! 	      goto got_character;
  	    }
  	}
! 
!       /* Parse a matched pair of quote characters. */
!       if (shellquote (character))
  	{
! 	  push_delimiter (dstack, character);
! 	  ttok = parse_matched_pair (character, character, character, &ttoklen, 0);
! 	  pop_delimiter (dstack);
! 	  if (ttok == &matched_pair_error)
! 	    return -1;		/* Bail immediately. */
! 	  RESIZE_MALLOCED_BUFFER (token, token_index, ttoklen + 2,
! 				  token_buffer_size, TOKEN_DEFAULT_GROW_SIZE);
! 	  token[token_index++] = character;
! 	  strcpy (token + token_index, ttok);
! 	  token_index += ttoklen;
! 	  all_digits = 0;
! 	  quoted = 1;
! 	  dollar_present |= (character == '"' && strchr (ttok, '$') != 0);
! 	  FREE (ttok);
! 	  goto next_character;
! 	}
  
! #ifdef EXTENDED_GLOB
!       /* Parse a ksh-style extended pattern matching specification. */
!       if (extended_glob && PATTERN_CHAR(character))
! 	{
! 	  peek_char = shell_getc (1);
! 	  if (peek_char == '(')		/* ) */
  	    {
! 	      push_delimiter (dstack, peek_char);
! 	      ttok = parse_matched_pair (cd, '(', ')', &ttoklen, 0);
! 	      pop_delimiter (dstack);
! 	      if (ttok == &matched_pair_error)
! 		return -1;		/* Bail immediately. */
! 	      RESIZE_MALLOCED_BUFFER (token, token_index, ttoklen + 2,
! 				      token_buffer_size,
! 				      TOKEN_DEFAULT_GROW_SIZE);
! 	      token[token_index++] = character;
! 	      token[token_index++] = peek_char;
! 	      strcpy (token + token_index, ttok);
! 	      token_index += ttoklen;
! 	      FREE (ttok);
! 	      dollar_present = all_digits = 0;
! 	      goto next_character;
! 	    }
! 	  else
! 	    shell_ungetc (peek_char);
! 	}
! #endif /* EXTENDED_GLOB */
  
!       /* If the delimiter character is not single quote, parse some of
! 	 the shell expansions that must be read as a single word. */
! #if defined (PROCESS_SUBSTITUTION)
!       if (character == '$' || character == '<' || character == '>')
! #else
!       if (character == '$')
! #endif /* !PROCESS_SUBSTITUTION */
! 	{
! 	  peek_char = shell_getc (1);
! 	  /* $(...), <(...), >(...), $((...)), ${...}, and $[...] constructs */
! 	  if (peek_char == '(' ||
! 		((peek_char == '{' || peek_char == '[') && character == '$'))	/* ) ] } */
! 	    {
! 	      if (peek_char == '{')		/* } */
! 	        ttok = parse_matched_pair (cd, '{', '}', &ttoklen, P_FIRSTCLOSE);
! 	      else if (peek_char == '(')		/* ) */
  		{
! 		  /* XXX - push and pop the `(' as a delimiter for use by
! 		     the command-oriented-history code.  This way newlines
! 		     appearing in the $(...) string get added to the
! 		     history literally rather than causing a possibly-
! 		     incorrect `;' to be added. ) */
! 		  push_delimiter (dstack, peek_char);
! 		  ttok = parse_matched_pair (cd, '(', ')', &ttoklen, 0);
! 		  pop_delimiter (dstack);
  		}
! 	      else
! 		ttok = parse_matched_pair (cd, '[', ']', &ttoklen, 0);
! 	      if (ttok == &matched_pair_error)
! 		return -1;		/* Bail immediately. */
! 	      RESIZE_MALLOCED_BUFFER (token, token_index, ttoklen + 2,
! 				      token_buffer_size,
! 				      TOKEN_DEFAULT_GROW_SIZE);
! 	      token[token_index++] = character;
! 	      token[token_index++] = peek_char;
! 	      strcpy (token + token_index, ttok);
! 	      token_index += ttoklen;
! 	      FREE (ttok);
! 	      dollar_present = 1;
! 	      all_digits = 0;
! 	      goto next_character;
! 	    }
! 	  /* This handles $'...' and $"..." new-style quoted strings. */
! 	  else if (character == '$' && (peek_char == '\'' || peek_char == '"'))
! 	    {
! 	      int first_line;
! 
! 	      first_line = line_number;
! 	      push_delimiter (dstack, peek_char);
! 	      ttok = parse_matched_pair (peek_char, peek_char, peek_char,
! 					 &ttoklen,
! 					 (peek_char == '\'') ? P_ALLOWESC : 0);
! 	      pop_delimiter (dstack);
! 	      if (ttok == &matched_pair_error)
! 		return -1;
! 	      if (peek_char == '\'')
  		{
! 		  ttrans = ansiexpand (ttok, 0, ttoklen - 1, &ttranslen);
! 		  free (ttok);
! 		  /* Insert the single quotes and correctly quote any
! 		     embedded single quotes (allowed because P_ALLOWESC was
! 		     passed to parse_matched_pair). */
! 		  ttok = single_quote (ttrans);
! 		  free (ttrans);
! 		  ttrans = ttok;
! 		  ttranslen = strlen (ttrans);
  		}
  	      else
  		{
! 		  /* Try to locale-expand the converted string. */
! 		  ttrans = localeexpand (ttok, 0, ttoklen - 1, first_line, &ttranslen);
! 		  free (ttok);
! 
! 		  /* Add the double quotes back */
! 		  ttok = xmalloc (ttranslen + 3);
! 		  ttok[0] = '"';
! 		  strcpy (ttok + 1, ttrans);
! 		  ttok[ttranslen + 1] = '"';
! 		  ttok[ttranslen += 2] = '\0';
! 		  free (ttrans);
! 		  ttrans = ttok;
  		}
  
! 	      RESIZE_MALLOCED_BUFFER (token, token_index, ttranslen + 2,
! 				      token_buffer_size,
! 				      TOKEN_DEFAULT_GROW_SIZE);
! 	      strcpy (token + token_index, ttrans);
! 	      token_index += ttranslen;
! 	      FREE (ttrans);
! 	      quoted = 1;
! 	      all_digits = 0;
! 	      goto next_character;
! 	    }
! 	  /* This could eventually be extended to recognize all of the
! 	     shell's single-character parameter expansions, and set flags.*/
! 	  else if (character == '$' && peek_char == '$')
! 	    {
! 	      ttok = xmalloc (3);
! 	      ttok[0] = ttok[1] = '$';
! 	      ttok[2] = '\0';
! 	      RESIZE_MALLOCED_BUFFER (token, token_index, 3,
! 				      token_buffer_size,
! 				      TOKEN_DEFAULT_GROW_SIZE);
! 	      strcpy (token + token_index, ttok);
! 	      token_index += 2;
! 	      dollar_present = 1;
! 	      all_digits = 0;
! 	      FREE (ttok);
! 	      goto next_character;
! 	    }
! 	  else
! 	    shell_ungetc (peek_char);
! 	}
  
! #if defined (ARRAY_VARS)
!       /* Identify possible compound array variable assignment. */
!       else if (character == '=' && token_index > 0)
! 	{
! 	  peek_char = shell_getc (1);
! 	  if (peek_char == '(')		/* ) */
! 	    {
! 	      ttok = parse_matched_pair (cd, '(', ')', &ttoklen, 0);
! 	      if (ttok == &matched_pair_error)
! 		return -1;		/* Bail immediately. */
! 	      if (ttok[0] == '(')	/* ) */
! 		{
! 		  FREE (ttok);
! 		  return -1;
! 		}
! 	      RESIZE_MALLOCED_BUFFER (token, token_index, ttoklen + 2,
! 				      token_buffer_size,
! 				      TOKEN_DEFAULT_GROW_SIZE);
! 	      token[token_index++] = character;
! 	      token[token_index++] = peek_char;
! 	      strcpy (token + token_index, ttok);
! 	      token_index += ttoklen;
! 	      FREE (ttok);
! 	      all_digits = 0;
! 	      goto next_character;
! 	    }
! 	  else
! 	    shell_ungetc (peek_char);
! 	}
! #endif
  
!       /* When not parsing a multi-character word construct, shell meta-
! 	 characters break words. */
!       if (shellbreak (character))
! 	{
! 	  shell_ungetc (character);
! 	  goto got_token;
! 	}
  
!     got_character:
  
!       all_digits &= digit (character);
!       dollar_present |= character == '$';
  
!       if (character == CTLESC || character == CTLNUL)
! 	token[token_index++] = CTLESC;
  
!       token[token_index++] = character;
  
!       RESIZE_MALLOCED_BUFFER (token, token_index, 1, token_buffer_size,
! 			      TOKEN_DEFAULT_GROW_SIZE);
  
!     next_character:
!       if (character == '\n' && interactive &&
! 	(bash_input.type == st_stdin || bash_input.type == st_stream))
! 	prompt_again ();
  
!       /* We want to remove quoted newlines (that is, a \<newline> pair)
! 	 unless we are within single quotes or pass_next_character is
! 	 set (the shell equivalent of literal-next). */
!       cd = current_delimiter (dstack);
!       character = shell_getc (cd != '\'' && pass_next_character == 0);
!     }	/* end for (;;) */
  
! got_token:
  
!   token[token_index] = '\0';
  
!   /* Check to see what thing we should return.  If the last_read_token
!      is a `<', or a `&', or the character which ended this token is
!      a '>' or '<', then, and ONLY then, is this input token a NUMBER.
!      Otherwise, it is just a word, and should be returned as such. */
!   if (all_digits && (character == '<' || character == '>' ||
! 		    last_read_token == LESS_AND ||
! 		    last_read_token == GREATER_AND))
!       {
! 	yylval.number = atoi (token);
! 	return (NUMBER);
!       }
  
!   /* Check for special case tokens. */
!   result = special_case_tokens (token);
!   if (result >= 0)
!     return result;
  
! #if defined (ALIAS)
!   /* Posix.2 does not allow reserved words to be aliased, so check for all
!      of them, including special cases, before expanding the current token
!      as an alias. */
!   if (posixly_correct)
!     CHECK_FOR_RESERVED_WORD (token);
  
!   /* Aliases are expanded iff EXPAND_ALIASES is non-zero, and quoting
!      inhibits alias expansion. */
!   if (expand_aliases && quoted == 0)
!     {
!       result = alias_expand_token (token);
!       if (result == RE_READ_TOKEN)
! 	return (RE_READ_TOKEN);
!       else if (result == NO_EXPANSION)
! 	parser_state &= ~PST_ALEXPNEXT;
!     }
  
!   /* If not in Posix.2 mode, check for reserved words after alias
!      expansion. */
!   if (posixly_correct == 0)
! #endif
!     CHECK_FOR_RESERVED_WORD (token);
  
!   the_word = (WORD_DESC *)xmalloc (sizeof (WORD_DESC));
!   the_word->word = xmalloc (1 + token_index);
!   the_word->flags = 0;
!   strcpy (the_word->word, token);
!   if (dollar_present)
!     the_word->flags |= W_HASDOLLAR;
!   if (quoted)
!     the_word->flags |= W_QUOTED;
!   /* A word is an assignment if it appears at the beginning of a
!      simple command, or after another assignment word.  This is
!      context-dependent, so it cannot be handled in the grammar. */
!   if (assignment (token))
!     {
!       the_word->flags |= W_ASSIGNMENT;
!       /* Don't perform word splitting on assignment statements. */
!       if (assignment_acceptable (last_read_token))
! 	the_word->flags |= W_NOSPLIT;
!     }
  
!   yylval.word = the_word;
  
!   result = ((the_word->flags & (W_ASSIGNMENT|W_NOSPLIT)) == (W_ASSIGNMENT|W_NOSPLIT))
! 		? ASSIGNMENT_WORD : WORD;
  
!   if (last_read_token == FUNCTION)
!     {
!       parser_state |= PST_ALLOWOPNBRC;
!       function_dstart = line_number;
!     }
  
!   return (result);
! }
  
! /* $'...' ANSI-C expand the portion of STRING between START and END and
!    return the result.  The result cannot be longer than the input string. */
! static char *
! ansiexpand (string, start, end, lenp)
!      char *string;
!      int start, end, *lenp;
! {
!   char *temp, *t;
!   int len, tlen;
  
!   temp = xmalloc (end - start + 1);
!   for (tlen = 0, len = start; len < end; )
!     temp[tlen++] = string[len++];
!   temp[tlen] = '\0';
  
!   if (*temp)
      {
!       t = ansicstr (temp, tlen, 0, (int *)NULL, lenp);
!       free (temp);
!       return (t);
      }
    else
      {
!       if (lenp)
! 	*lenp = 0;
!       return (temp);
      }
  }
  
! /* Change a bash string into a string suitable for inclusion in a `po' file.
!    This backslash-escapes `"' and `\' and changes newlines into \\\n"\n". */
! static char *
! mk_msgstr (string, foundnlp)
!      char *string;
!      int *foundnlp;
  {
!   register int c, len;
!   char *result, *r, *s;
  
!   for (len = 0, s = string; s && *s; s++)
      {
!       len++;
!       if (*s == '"' || *s == '\\')
! 	len++;
!       else if (*s == '\n')
!         len += 5;
      }
-   
-   r = result = xmalloc (len + 3);
-   *r++ = '"';
  
!   for (s = string; s && (c = *s); s++)
      {
!       if (c == '\n')	/* <NL> -> \n"<NL>" */
! 	{
! 	  *r++ = '\\';
! 	  *r++ = 'n';
! 	  *r++ = '"';
! 	  *r++ = '\n';
! 	  *r++ = '"';
! 	  if (foundnlp)
! 	    *foundnlp = 1;
! 	  continue;
! 	}
!       if (c == '"' || c == '\\')
! 	*r++ = '\\';
!       *r++ = c;
!     }
  
!   *r++ = '"';
!   *r++ = '\0';
  
!   return result;
! }
  
! /* $"..." -- Translate the portion of STRING between START and END
!    according to current locale using gettext (if available) and return
!    the result.  The caller will take care of leaving the quotes intact.
!    The string will be left without the leading `$' by the caller.
!    If translation is performed, the translated string will be double-quoted
!    by the caller.  The length of the translated string is returned in LENP,
!    if non-null. */
! static char *
! localeexpand (string, start, end, lineno, lenp)
!      char *string;
!      int start, end, lineno, *lenp;
! {
!   int len, tlen, foundnl;
!   char *temp, *t, *t2;
  
!   temp = xmalloc (end - start + 1);
!   for (tlen = 0, len = start; len < end; )
!     temp[tlen++] = string[len++];
!   temp[tlen] = '\0';
  
!   /* If we're just dumping translatable strings, don't do anything with the
!      string itself, but if we're dumping in `po' file format, convert it into a form more palatable to gettext(3)
!      and friends by quoting `"' and `\' with backslashes and converting <NL>
!      into `\n"<NL>"'.  If we find a newline in TEMP, we first output a
!      `msgid ""' line and then the translated string; otherwise we output the
!      `msgid' and translated string all on one line. */
!   if (dump_translatable_strings)
!     {
!       if (dump_po_strings)
  	{
! 	  foundnl = 0;
! 	  t = mk_msgstr (temp, &foundnl);
! 	  t2 = foundnl ? "\"\"\n" : "";
  
! 	  printf ("#: %s:%d\nmsgid %s%s\nmsgstr \"\"\n",
! 		  (bash_input.name ? bash_input.name : "stdin"), lineno, t2, t);
! 	  free (t);
  	}
-       else
- 	printf ("\"%s\"\n", temp);
  
!       if (lenp)
! 	*lenp = tlen;
!       return (temp);
!     }
!   else if (*temp)
!     {
!       t = localetrans (temp, tlen, &len);
!       free (temp);
!       if (lenp)
! 	*lenp = len;
!       return (t);
      }
    else
      {
!       if (lenp)
! 	*lenp = 0;
!       return (temp);
      }
  }
  
! /* Return 1 if TOKEN is a token that after being read would allow
!    a reserved word to be seen, else 0. */
! static int
! reserved_word_acceptable (token)
!      int token;
  {
-   if (token == '\n' || token == ';' || token == '(' || token == ')' ||
-       token == '|' || token == '&' || token == '{' ||
-       token == '}' ||			/* XXX */
-       token == AND_AND ||
-       token == BANG ||
-       token == TIME || token == TIMEOPT ||
-       token == DO ||
-       token == ELIF ||
-       token == ELSE ||
-       token == FI ||
-       token == IF ||
-       token == OR_OR ||
-       token == SEMI_SEMI ||
-       token == THEN ||
-       token == UNTIL ||
-       token == WHILE ||
-       token == DONE ||		/* XXX these two are experimental */
-       token == ESAC ||
-       token == 0)
-     return (1);
-   else
-     return (0);
  }
  
! /* Return the index of TOKEN in the alist of reserved words, or -1 if
!    TOKEN is not a shell reserved word. */
! int
! find_reserved_word (token)
!      char *token;
! {
!   int i;
!   for (i = 0; word_token_alist[i].word; i++)
!     if (STREQ (token, word_token_alist[i].word))
!       return i;
!   return -1;
! }
  
! #if 0
! #if defined (READLINE)
! /* Called after each time readline is called.  This insures that whatever
!    the new prompt string is gets propagated to readline's local prompt
!    variable. */
  static void
! reset_readline_prompt ()
  {
!   char *temp_prompt;
! 
!   if (prompt_string_pointer)
      {
!       temp_prompt = (*prompt_string_pointer)
! 			? decode_prompt_string (*prompt_string_pointer)
! 			: (char *)NULL;
  
!       if (temp_prompt == 0)
  	{
! 	  temp_prompt = xmalloc (1);
! 	  temp_prompt[0] = '\0';
  	}
  
!       FREE (current_readline_prompt);
!       current_readline_prompt = temp_prompt;
      }
  }
- #endif /* READLINE */
- #endif /* 0 */
  
! #if defined (HISTORY)
! /* A list of tokens which can be followed by newlines, but not by
!    semi-colons.  When concatenating multiple lines of history, the
!    newline separator for such tokens is replaced with a space. */
! static int no_semi_successors[] = {
!   '\n', '{', '(', ')', ';', '&', '|',
!   CASE, DO, ELSE, IF, SEMI_SEMI, THEN, UNTIL, WHILE, AND_AND, OR_OR, IN,
!   0
! };
  
! /* If we are not within a delimited expression, try to be smart
!    about which separators can be semi-colons and which must be
!    newlines.  Returns the string that should be added into the
!    history entry. */
! char *
! history_delimiting_chars ()
  {
!   register int i;
  
!   if (dstack.delimiter_depth != 0)
!     return ("\n");
!     
!   /* First, handle some special cases. */
!   /*(*/
!   /* If we just read `()', assume it's a function definition, and don't
!      add a semicolon.  If the token before the `)' was not `(', and we're
!      not in the midst of parsing a case statement, assume it's a
!      parenthesized command and add the semicolon. */
!   /*)(*/
!   if (token_before_that == ')')
!     {
!       if (two_tokens_ago == '(')	/*)*/	/* function def */
! 	return " ";
!       /* This does not work for subshells inside case statement
! 	 command lists.  It's a suboptimal solution. */
!       else if (parser_state & PST_CASESTMT)	/* case statement pattern */
!         return " ";
!       else	
!         return "; ";				/* (...) subshell */
!     }
!   else if (token_before_that == WORD && two_tokens_ago == FUNCTION)
!     return " ";		/* function def using `function name' without `()' */
  
!   else if (token_before_that == WORD && two_tokens_ago == FOR)
      {
!       /* Tricky.  `for i\nin ...' should not have a semicolon, but
! 	 `for i\ndo ...' should.  We do what we can. */
!       for (i = shell_input_line_index; whitespace(shell_input_line[i]); i++)
!         ;
!       if (shell_input_line[i] && shell_input_line[i] == 'i' && shell_input_line[i+1] == 'n')
! 	return " ";
!       return ";";
      }
  
!   for (i = 0; no_semi_successors[i]; i++)
      {
!       if (token_before_that == no_semi_successors[i])
! 	return (" ");
      }
  
!   return ("; ");
  }
! #endif /* HISTORY */
  
! /* Issue a prompt, or prepare to issue a prompt when the next character
!    is read. */
! static void
! prompt_again ()
  {
!   char *temp_prompt;
  
!   if (!interactive)	/* XXX */
!     return;
! 
!   ps1_prompt = get_string_value ("PS1");
!   ps2_prompt = get_string_value ("PS2");
  
!   if (!prompt_string_pointer)
!     prompt_string_pointer = &ps1_prompt;
  
!   temp_prompt = *prompt_string_pointer
! 			? decode_prompt_string (*prompt_string_pointer)
! 			: (char *)NULL;
  
!   if (temp_prompt == 0)
      {
!       temp_prompt = xmalloc (1);
!       temp_prompt[0] = '\0';
      }
! 
!   current_prompt_string = *prompt_string_pointer;
!   prompt_string_pointer = &ps2_prompt;
! 
! #if defined (READLINE)
!   if (!no_line_editing)
      {
!       FREE (current_readline_prompt);
!       current_readline_prompt = temp_prompt;
      }
!   else
! #endif	/* READLINE */
      {
!       FREE (current_decoded_prompt);
!       current_decoded_prompt = temp_prompt;
      }
! }
! 
! int
! get_current_prompt_level ()
  {
!   return ((current_prompt_string && current_prompt_string == ps2_prompt) ? 2 : 1);
! }
! 
! void
! set_current_prompt_level (x)
!      int x;
  {
!   prompt_string_pointer = (x == 2) ? &ps2_prompt : &ps1_prompt;
!   current_prompt_string = *prompt_string_pointer;
! }
!       
! static void
! print_prompt ()
  {
!   fprintf (stderr, "%s", current_decoded_prompt);
!   fflush (stderr);
! }
! 
! /* Return a string which will be printed as a prompt.  The string
!    may contain special characters which are decoded as follows:
! 
! 	\a	bell (ascii 07)
! 	\e	escape (ascii 033)
! 	\d	the date in Day Mon Date format
! 	\h	the hostname up to the first `.'
! 	\H	the hostname
! 	\j	the number of active jobs
! 	\l	the basename of the shell's tty device name
! 	\n	CRLF
! 	\s	the name of the shell
! 	\t	the time in 24-hour hh:mm:ss format
! 	\T	the time in 12-hour hh:mm:ss format
! 	\@	the time in 12-hour am/pm format
! 	\v	the version of bash (e.g., 2.00)
! 	\V	the release of bash, version + patchlevel (e.g., 2.00.0)
! 	\w	the current working directory
! 	\W	the last element of $PWD
! 	\u	your username
! 	\#	the command number of this command
! 	\!	the history number of this command
! 	\$	a $ or a # if you are root
! 	\nnn	character code nnn in octal
! 	\\	a backslash
! 	\[	begin a sequence of non-printing chars
! 	\]	end a sequence of non-printing chars
! */
! #define PROMPT_GROWTH 48
! char *
! decode_prompt_string (string)
!      char *string;
  {
!   WORD_LIST *list;
!   char *result, *t;
!   struct dstack save_dstack;
! #if defined (PROMPT_STRING_DECODE)
!   int result_size, result_index;
!   int c, n;
!   char *temp, octal_string[4];
!   time_t the_time;
  
!   result = xmalloc (result_size = PROMPT_GROWTH);
!   result[result_index = 0] = 0;
!   temp = (char *)NULL;
! 
!   while (c = *string++)
!     {
!       if (posixly_correct && c == '!')
! 	{
! 	  if (*string == '!')
! 	    {
! 	      temp = savestring ("!");
! 	      goto add_string;
! 	    }
! 	  else
! 	    {
! #if !defined (HISTORY)
! 		temp = savestring ("1");
! #else /* HISTORY */
! 		temp = itos (history_number ());
! #endif /* HISTORY */
! 		string--;	/* add_string increments string again. */
! 		goto add_string;
! 	    }
! 	}
!       if (c == '\\')
! 	{
! 	  c = *string;
! 
! 	  switch (c)
! 	    {
! 	    case '0':
! 	    case '1':
! 	    case '2':
! 	    case '3':
! 	    case '4':
! 	    case '5':
! 	    case '6':
! 	    case '7':
! 	      strncpy (octal_string, string, 3);
! 	      octal_string[3] = '\0';
! 
! 	      n = read_octal (octal_string);
! 	      temp = xmalloc (3);
! 
! 	      if (n == CTLESC || n == CTLNUL)
! 		{
! 		  string += 3;
! 		  temp[0] = CTLESC;
! 		  temp[1] = n;
! 		  temp[2] = '\0';
! 		}
! 	      else if (n == -1)
! 		{
! 		  temp[0] = '\\';
! 		  temp[1] = '\0';
! 		}
! 	      else
! 		{
! 		  string += 3;
! 		  temp[0] = n;
! 		  temp[1] = '\0';
! 		}
! 
! 	      c = 0;
! 	      goto add_string;
! 
! 	    case 't':
! 	    case 'd':
! 	    case 'T':
! 	    case '@':
! 	      /* Make the current time/date into a string. */
! 	      the_time = time (0);
! 	      temp = ctime (&the_time);
! 
! 	      temp = (c != 'd') ? savestring (temp + 11) : savestring (temp);
! 	      temp[(c != 'd') ? 8 : 10] = '\0';
! 
! 	      /* quick and dirty conversion to 12-hour time */
! 	      if (c == 'T' || c == '@')
! 		{
! 		  if (c == '@')
! 		    {
! 		      temp[5] = 'a';	/* am/pm format */
! 		      temp[6] = 'm';
! 		      temp[7] = '\0';
! 		    }
! 		  c = temp[2];
! 		  temp[2] = '\0';
! 		  n = atoi (temp);
! 		  temp[2] = c;
! 		  n -= 12;
! 		  if (n > 0)
! 		    {
! 		      temp[0] = (n / 10) + '0';
! 		      temp[1] = (n % 10) + '0';
! 		    }
! 		  if (n >= 0 && temp[5] == 'a')
! 		    temp[5] = 'p';
! 		}
! 	      goto add_string;
! 
! 	    case 'r':
! 	      temp = xmalloc (2);
! 	      temp[0] = '\r';
! 	      temp[1] = '\0';
! 	      goto add_string;
! 
! 	    case 'n':
! 	      temp = xmalloc (3);
! 	      temp[0] = no_line_editing ? '\n' : '\r';
! 	      temp[1] = no_line_editing ? '\0' : '\n';
! 	      temp[2] = '\0';
! 	      goto add_string;
! 
! 	    case 's':
! 	      temp = base_pathname (shell_name);
! 	      temp = savestring (temp);
! 	      goto add_string;
! 
! 	    case 'v':
! 	    case 'V':
! 	      temp = xmalloc (8);
! 	      if (c == 'v')
! 		strcpy (temp, dist_version);
! 	      else
! 		sprintf (temp, "%s.%d", dist_version, patch_level);
! 	      goto add_string;
! 
! 	    case 'w':
! 	    case 'W':
! 	      {
! 		/* Use the value of PWD because it is much more efficient. */
! 		char t_string[PATH_MAX];
! 		int tlen;
! 
! 		temp = get_string_value ("PWD");
! 
! 		if (temp == 0)
! 		  {
! 		    if (getcwd (t_string, sizeof(t_string)) == 0)
! 		      {
! 		        t_string[0] = '.';
! 			tlen = 1;
! 		      }
! 		    else
! 		      tlen = strlen (t_string);
! 		  }
! 		else
! 		  {
! 		    tlen = sizeof (t_string) - 1;
! 		    strncpy (t_string, temp, tlen);
! 		  }
! 		t_string[tlen] = '\0';
! 
! 		if (c == 'W')
! 		  {
! 		    t = strrchr (t_string, '/');
! 		    if (t && t != t_string)
! 		      strcpy (t_string, t + 1);
! 		  }
! 		else
! 		  /* polite_directory_format is guaranteed to return a string
! 		     no longer than PATH_MAX - 1 characters. */
! 		  strcpy (t_string, polite_directory_format (t_string));
! 
! 		/* If we're going to be expanding the prompt string later,
! 		   quote the directory name. */
! 		if (promptvars || posixly_correct)
! #if 0
! 		  temp = backslash_quote (t_string);
! #else
! 		  /* Make sure that expand_prompt_string is called with a
! 		     second argument of Q_DOUBLE_QUOTE if we use this
! 		     function here. */
! 		  temp = backslash_quote_for_double_quotes (t_string);
! #endif
! 		else
! 		  temp = savestring (t_string);
! 
! 		goto add_string;
! 	      }
! 
! 	    case 'u':
! 	      if (current_user.user_name == 0)
! 		get_current_user_info ();
! 	      temp = savestring (current_user.user_name);
! 	      goto add_string;
! 
! 	    case 'h':
! 	    case 'H':
! 	      temp = savestring (current_host_name);
! 	      if (c == 'h' && (t = (char *)strchr (temp, '.')))
! 		*t = '\0';
! 	      goto add_string;
! 
! 	    case '#':
! 	      temp = itos (current_command_number);
! 	      goto add_string;
! 
! 	    case '!':
! #if !defined (HISTORY)
! 	      temp = savestring ("1");
! #else /* HISTORY */
! 	      temp = itos (history_number ());
! #endif /* HISTORY */
! 	      goto add_string;
! 
! 	    case '$':
! 	      t = temp = xmalloc (3);
! 	      if ((promptvars || posixly_correct) && (current_user.euid != 0))
! 		*t++ = '\\';
! 	      *t++ = current_user.euid == 0 ? '#' : '$';
! 	      *t = '\0';
! 	      goto add_string;
! 
! 	    case 'j':
! 	      temp = itos (count_all_jobs ());
! 	      goto add_string;
! 
! 	    case 'l':
! #if defined (HAVE_TTYNAME)
! 	      temp = (char *)ttyname (fileno (stdin));
! 	      t = temp ? base_pathname (temp) : "tty";
! 	      temp = savestring (t);
! #else
! 	      temp = savestring ("tty");
! #endif /* !HAVE_TTYNAME */
! 	      goto add_string;
! 
! #if defined (READLINE)
! 	    case '[':
! 	    case ']':
! 	      temp = xmalloc (3);
! 	      temp[0] = '\001';
! 	      temp[1] = (c == '[') ? RL_PROMPT_START_IGNORE : RL_PROMPT_END_IGNORE;
! 	      temp[2] = '\0';
! 	      goto add_string;
! #endif /* READLINE */
! 
! 	    case '\\':
! 	      temp = xmalloc (2);
! 	      temp[0] = c;
! 	      temp[1] = '\0';
! 	      goto add_string;
! 
! 	    case 'a':
! 	    case 'e':
! 	      temp = xmalloc (2);
! 	      temp[0] = (c == 'a') ? '\07' : '\033';
! 	      temp[1] = '\0';
! 	      goto add_string;
! 
! 	    default:
! 	      temp = xmalloc (3);
! 	      temp[0] = '\\';
! 	      temp[1] = c;
! 	      temp[2] = '\0';
! 
! 	    add_string:
! 	      if (c)
! 		string++;
! 	      result =
! 		sub_append_string (temp, result, &result_index, &result_size);
! 	      temp = (char *)NULL; /* Freed in sub_append_string (). */
! 	      result[result_index] = '\0';
! 	      break;
! 	    }
! 	}
!       else
! 	{
! 	  RESIZE_MALLOCED_BUFFER (result, result_index, 3, result_size, PROMPT_GROWTH);
! 	  result[result_index++] = c;
! 	  result[result_index] = '\0';
! 	}
!     }
! #else /* !PROMPT_STRING_DECODE */
!   result = savestring (string);
! #endif /* !PROMPT_STRING_DECODE */
! 
!   /* Save the delimiter stack and point `dstack' to temp space so any
!      command substitutions in the prompt string won't result in screwing
!      up the parser's quoting state. */
!   save_dstack = dstack;
!   dstack = temp_dstack;
!   dstack.delimiter_depth = 0;
! 
!   /* Perform variable and parameter expansion and command substitution on
!      the prompt string. */
!   if (promptvars || posixly_correct)
!     {
! #if 0
!       list = expand_string_unsplit (result, Q_DOUBLE_QUOTES);
! #else
!       list = expand_prompt_string (result, Q_DOUBLE_QUOTES);
! #endif
!       free (result);
!       result = string_list (list);
!       dispose_words (list);
!     }
!   else
!     {
!       t = dequote_string (result);
!       free (result);
!       result = t;
!     }
! 
!   dstack = save_dstack;
  
!   return (result);
! }
  
! /* Report a syntax error, and restart the parser.  Call here for fatal
!    errors. */
! int
! yyerror ()
  {
!   report_syntax_error ((char *)NULL);
!   reset_parser ();
!   return (0);
! }
! 
! /* Report a syntax error with line numbers, etc.
!    Call here for recoverable errors.  If you have a message to print,
!    then place it in MESSAGE, otherwise pass NULL and this will figure
!    out an appropriate message for you. */
! static void
! report_syntax_error (message)
!      char *message;
  {
!   char *msg, *t;
!   int token_end, i;
!   char msg2[2];
! 
!   if (message)
!     {
!       parser_error (line_number, "%s", message);
!       if (interactive && EOF_Reached)
! 	EOF_Reached = 0;
!       last_command_exit_value = EX_USAGE;
!       return;
!     }
! 
!   /* If the line of input we're reading is not null, try to find the
!      objectionable token. */
!   if (shell_input_line && *shell_input_line)
!     {
!       t = shell_input_line;
!       i = shell_input_line_index;
!       token_end = 0;
! 
!       if (i && t[i] == '\0')
! 	i--;
! 
!       while (i && (whitespace (t[i]) || t[i] == '\n'))
! 	i--;
! 
!       if (i)
! 	token_end = i + 1;
! 
!       while (i && (member (t[i], " \n\t;|&") == 0))
! 	i--;
! 
!       while (i != token_end && (whitespace (t[i]) || t[i] == '\n'))
! 	i++;
! 
!       /* Print the offending token. */
!       if (token_end || (i == 0 && token_end == 0))
! 	{
! 	  if (token_end)
! 	    msg = substring (t, i, token_end);
! 	  else	/* one-character token */
! 	    {
! 	      msg2[0] = t[i];
! 	      msg2[1] = '\0';
! 	      msg = msg2;
! 	    }
! 
! 	  parser_error (line_number, "syntax error near unexpected token `%s'", msg);
! 
! 	  if (msg != msg2)
! 	    free (msg);
! 	}
! 
!       /* If not interactive, print the line containing the error. */
!       if (interactive == 0)
! 	{
! 	  msg = savestring (shell_input_line);
! 	  token_end = strlen (msg);
! 	  while (token_end && msg[token_end - 1] == '\n')
! 	    msg[--token_end] = '\0';
! 
! 	  parser_error (line_number, "`%s'", msg);
! 	  free (msg);
! 	}
!     }
!   else
!     {
!       msg = EOF_Reached ? "syntax error: unexpected end of file" : "syntax error";
!       parser_error (line_number, "%s", msg);
!       /* When the shell is interactive, this file uses EOF_Reached
! 	 only for error reporting.  Other mechanisms are used to
! 	 decide whether or not to exit. */
!       if (interactive && EOF_Reached)
! 	EOF_Reached = 0;
!     }
!   last_command_exit_value = EX_USAGE;
! }
! 
! /* ??? Needed function. ??? We have to be able to discard the constructs
!    created during parsing.  In the case of error, we want to return
!    allocated objects to the memory pool.  In the case of no error, we want
!    to throw away the information about where the allocated objects live.
!    (dispose_command () will actually free the command. */
! static void
! discard_parser_constructs (error_p)
!      int error_p;
  {
! }
! 
! /* Do that silly `type "bye" to exit' stuff.  You know, "ignoreeof". */
! 
! /* A flag denoting whether or not ignoreeof is set. */
! int ignoreeof = 0;
! 
! /* The number of times that we have encountered an EOF character without
!    another character intervening.  When this gets above the limit, the
!    shell terminates. */
! int eof_encountered = 0;
! 
! /* The limit for eof_encountered. */
! int eof_encountered_limit = 10;
! 
! /* If we have EOF as the only input unit, this user wants to leave
!    the shell.  If the shell is not interactive, then just leave.
!    Otherwise, if ignoreeof is set, and we haven't done this the
!    required number of times in a row, print a message. */
! static void
! handle_eof_input_unit ()
  {
!   if (interactive)
!     {
!       /* shell.c may use this to decide whether or not to write out the
! 	 history, among other things.  We use it only for error reporting
! 	 in this file. */
!       if (EOF_Reached)
! 	EOF_Reached = 0;
! 
!       /* If the user wants to "ignore" eof, then let her do so, kind of. */
!       if (ignoreeof)
! 	{
! 	  if (eof_encountered < eof_encountered_limit)
! 	    {
! 	      fprintf (stderr, "Use \"%s\" to leave the shell.\n",
! 		       login_shell ? "logout" : "exit");
! 	      eof_encountered++;
! 	      /* Reset the prompt string to be $PS1. */
! 	      prompt_string_pointer = (char **)NULL;
! 	      prompt_again ();
! 	      last_read_token = current_token = '\n';
! 	      return;
! 	    }
! 	}
! 
!       /* In this case EOF should exit the shell.  Do it now. */
!       reset_parser ();
!       exit_builtin ((WORD_LIST *)NULL);
!     }
!   else
!     {
!       /* We don't write history files, etc., for non-interactive shells. */
!       EOF_Reached = 1;
!     }
! }
! 
! static WORD_LIST parse_string_error;
! 
! /* Take a string and run it through the shell parser, returning the
!    resultant word list.  Used by compound array assignment. */
! WORD_LIST *
! parse_string_to_word_list (s, whom)
!      char *s, *whom;
  {
!   WORD_LIST *wl;
!   int tok, orig_line_number, orig_input_terminator;
! #if defined (HISTORY)
!   int old_remember_on_history, old_history_expansion_inhibited;
! #endif
! 
! #if defined (HISTORY)
!   old_remember_on_history = remember_on_history;
! #  if defined (BANG_HISTORY)
!   old_history_expansion_inhibited = history_expansion_inhibited;
! #  endif
!   bash_history_disable ();
  #endif
! 
!   orig_line_number = line_number;
!   orig_input_terminator = shell_input_line_terminator;
! 
!   push_stream (1);
!   last_read_token = '\n';
! 
!   with_input_from_string (s, whom);
!   wl = (WORD_LIST *)NULL;
!   while ((tok = read_token (READ)) != yacc_EOF)
!     {
!       if (tok == '\n' && *bash_input.location.string == '\0')
! 	break;
!       if (tok != WORD && tok != ASSIGNMENT_WORD)
! 	{
! 	  line_number = orig_line_number + line_number - 1;
! 	  yyerror ();	/* does the right thing */
! 	  if (wl)
! 	    dispose_words (wl);
! 	  wl = &parse_string_error;
! 	  break;
! 	}
!       wl = make_word_list (yylval.word, wl);
!     }
!   
!   last_read_token = '\n';
!   pop_stream ();
! 
! #if defined (HISTORY)
!   remember_on_history = old_remember_on_history;
! #  if defined (BANG_HISTORY)
!   history_expansion_inhibited = old_history_expansion_inhibited;
! #  endif /* BANG_HISTORY */
! #endif /* HISTORY */
! 
!   shell_input_line_terminator = orig_input_terminator;
! 
!   if (wl == &parse_string_error)
!     {
!       last_command_exit_value = EXECUTION_FAILURE;
!       if (interactive_shell == 0 && posixly_correct)
! 	jump_to_top_level (FORCE_EOF);
!       else
! 	jump_to_top_level (DISCARD);
      }
! 
!   return (REVERSE_LIST (wl, WORD_LIST *));
  }
--- 191,5172 ----
    PATTERN_LIST *pattern;
  } YYSTYPE;
! #line 194 "y.tab.c"
! #define YYERRCODE 256
! #define IF 257
! #define THEN 258
! #define ELSE 259
! #define ELIF 260
! #define FI 261
! #define CASE 262
! #define ESAC 263
! #define FOR 264
! #define SELECT 265
! #define WHILE 266
! #define UNTIL 267
! #define DO 268
! #define DONE 269
! #define FUNCTION 270
! #define COND_START 271
! #define COND_END 272
! #define COND_ERROR 273
! #define IN 274
! #define BANG 275
! #define TIME 276
! #define TIMEOPT 277
! #define WORD 278
! #define ASSIGNMENT_WORD 279
! #define NUMBER 280
! #define ARITH_CMD 281
! #define ARITH_FOR_EXPRS 282
! #define COND_CMD 283
! #define AND_AND 284
! #define OR_OR 285
! #define GREATER_GREATER 286
! #define LESS_LESS 287
! #define LESS_AND 288
! #define GREATER_AND 289
! #define SEMI_SEMI 290
! #define LESS_LESS_MINUS 291
! #define AND_GREATER 292
! #define LESS_GREATER 293
! #define GREATER_BAR 294
! #define yacc_EOF 295
! const short yylhs[] = {                                        -1,
!     0,    0,    0,    0,   27,   27,   24,   24,   24,   24,
!    24,   24,   24,   24,   24,   24,   24,   24,   24,   24,
!    24,   24,   24,   24,   24,   24,   24,   24,   24,   24,
!    24,   24,   24,   26,   26,   26,   25,   25,   10,   10,
!     1,    1,    1,    1,   11,   11,   11,   11,   11,   11,
!    11,   11,   11,   11,   11,   12,   12,   12,   12,   12,
!    12,   18,   18,   18,   18,   13,   13,   13,   13,   13,
!    13,   14,   14,   14,   19,   19,   19,   20,   20,   23,
!    21,   21,   21,   15,   16,   17,   22,   22,   22,   31,
!    31,   29,   29,   29,   29,   30,   30,   28,   28,    4,
!     7,    7,    5,    5,    5,    6,    6,    6,    6,    6,
!     6,   34,   34,   34,   33,   33,    8,    8,    8,    9,
!     9,    9,    9,    9,    3,    3,    3,    3,    3,    2,
!     2,   32,   32,
  };
! const short yylen[] = {                                         2,
!     2,    1,    2,    1,    1,    2,    2,    2,    3,    3,
!     2,    3,    2,    3,    2,    3,    2,    3,    2,    3,
!     2,    3,    2,    3,    2,    3,    2,    3,    2,    3,
!     2,    2,    3,    1,    1,    1,    1,    2,    1,    2,
!     1,    1,    2,    1,    1,    1,    5,    5,    1,    1,
!     1,    1,    1,    1,    1,    6,    6,    7,    7,   10,
!    10,    7,    7,    5,    5,    6,    6,    7,    7,   10,
!    10,    6,    7,    6,    5,    6,    4,    1,    2,    3,
!     5,    7,    6,    3,    1,    3,    4,    6,    5,    1,
!     2,    4,    4,    5,    5,    2,    3,    1,    3,    2,
!     1,    2,    3,    3,    3,    4,    4,    4,    4,    4,
!     1,    1,    1,    1,    0,    2,    1,    2,    2,    4,
!     4,    3,    3,    1,    1,    2,    2,    3,    3,    4,
!     1,    1,    2,
  };
! const short yydefred[] = {                                      0,
!     0,  115,    0,    0,    0,  115,  115,    0,    0,    0,
!     0,    0,   35,    0,   85,    0,    0,    0,    0,    0,
!     0,    0,    0,    2,    4,    0,    0,  115,  115,    0,
!   131,    0,  124,    0,    0,    0,    0,   45,   49,   46,
!    52,   53,   54,   55,   44,   50,   51,   36,   39,    0,
!     3,  101,    0,    0,  115,    0,    0,    0,    0,    0,
!     0,    0,    0,    0,  133,    0,    0,    0,    0,    0,
!     0,    0,    0,    0,    0,   11,   13,   19,   15,   27,
!    21,   17,   25,   23,   29,   31,   32,    7,    8,    0,
!     0,  115,    1,  115,  115,    0,    0,   34,   40,   37,
!     0,    0,    0,  115,  116,  111,  100,    0,    0,  115,
!     0,  115,  113,  112,  114,  115,  115,  115,    0,  115,
!   115,    0,    0,   86,    0,  115,   12,   14,   20,   16,
!    28,   22,   18,   26,   24,   30,   33,    9,   10,   84,
!    80,    0,    0,    0,    0,    0,   38,    0,    0,  115,
!   115,  115,  115,  115,  115,    0,  115,    0,  115,    0,
!     0,    0,    0,  115,    0,  115,    0,    0,  115,    0,
!    77,    0,    0,  120,  121,    0,    0,  115,  115,   81,
!     0,    0,    0,    0,    0,    0,    0,  115,    0,    0,
!   115,  115,    0,    5,    0,    0,   64,   65,  115,  115,
!   115,  115,    0,    0,    0,    0,   47,   48,    0,    0,
!    75,    0,    0,   83,  106,  107,    0,    0,    0,   96,
!     0,    0,   74,   72,   98,    0,    0,    0,    0,   56,
!     6,  115,   57,    0,    0,    0,    0,   66,    0,  115,
!    67,   76,   82,  115,  115,  115,  115,   97,   73,    0,
!     0,  115,   58,   59,    0,   62,   63,   68,   69,    0,
!     0,    0,    0,    0,  115,   99,   92,    0,  115,  115,
!   115,  115,  115,   89,   94,    0,    0,    0,    0,    0,
!    88,   60,   61,   70,   71,
  };
! const short yydgoto[] = {                                      30,
!    31,   32,  106,   52,  107,  108,   53,   34,  145,   36,
!    37,   38,   39,   40,   41,   42,   43,   44,   45,  171,
!    46,  181,   47,   48,  101,   49,  195,  227,  187,  188,
!   189,   50,   54,  117,
  };
! const short yysindex[] = {                                    -10,
!     2,    0, -258, -255, -246,    0,    0, -237, -249,  846,
!  -226,   15,    0,  123,    0, -211, -203,  -44,  -43, -199,
!  -198, -194, -193,    0,    0, -192, -191,    0,    0,    0,
!     0,  -41,    0,   78,   23,  956,  975,    0,    0,    0,
!     0,    0,    0,    0,    0,    0,    0,    0,    0,  721,
!     0,    0, -169,   71,    0,   35,   -6,   39, -177, -172,
!    61, -168,  -41,  933,    0,   62, -176, -173,  -30,  -27,
!  -166, -163, -162, -160, -159,    0,    0,    0,    0,    0,
!     0,    0,    0,    0,    0,    0,    0,    0,    0,  -17,
!    69,    0,    0,    0,    0,  813,  813,    0,    0,    0,
!   975,  933,  -41,    0,    0,    0,    0,   19,   -7,    0,
!    66,    0,    0,    0,    0,    0,    0,    0,   99,    0,
!     0,   79,  305,    0,  -41,    0,    0,    0,    0,    0,
!     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
!     0,  104,   71,   71, -247, -247,    0,  -41, -195,    0,
!     0,    0,    0,    0,    0,    4,    0, -156,    0, -145,
!     1,    7,   12,    0, -156,    0, -144, -140,    0,  975,
!     0,  305,  -41,    0,    0,  813,  813,    0,    0,    0,
!  -138,   71,   71,   71,   71,   71, -158,    0, -129,   -4,
!     0,    0, -132,    0,   -5,   16,    0,    0,    0,    0,
!     0,    0, -126,   71,   -5,   20,    0,    0,  305,  975,
!     0, -115, -111,    0,    0,    0, -240, -240, -240,    0,
!  -142,   32,    0,    0,    0, -128,  -34, -120,   26,    0,
!     0,    0,    0, -114,   36, -107,   38,    0,   19,    0,
!     0,    0,    0,    0,    0,    0,    0,    0,    0,  -25,
!  -113,    0,    0,    0,   29,    0,    0,    0,    0,   37,
!  -201,   71,   71,   71,    0,    0,    0,   71,    0,    0,
!     0,    0,    0,    0,    0,   71, -100,   45,  -98,   48,
!     0,    0,    0,    0,    0,
  };
! const short yyrindex[] = {                                      0,
!     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
!   888,   33,    0,    0,    0,    0,    0,    0,    0,    0,
!     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
!     0,  450,    0,    0,  164,  118,  162,    0,    0,    0,
!     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
!     0,    0,    0,    0,    0,  126,    0,  126,    0,    0,
!   216,    0,  462,    0,    0,    0,    0,    0,    0,    0,
!     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
!     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
!     0,    0,    0,    0,    0,  165,  166,    0,    0,    0,
!   174,    0,  495,    0,    0,    0,    0,  436,    0,    0,
!     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
!     0,    0,    0,    0,  507,    0,    0,    0,    0,    0,
!     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
!     0,    0,    0,    0,   11,   18,    0,  540,    0,    0,
!     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
!     0,    0,    0,    0,    0,    0,    0,    0,    0,  403,
!     0,    0,  553,    0,    0,    0,    0,    0,    0,    0,
!     0,    0,    0,  573,  662,  765,  -85,    0,    0,    0,
!     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
!     0,    0,    0,    0,    0,    0,    0,    0,    0,  416,
!     0,    0,    0,    0,    0,    0,  587,  599,  611,    0,
!   -84,    0,    0,    0,    0,    0,    0,    0,    0,    0,
!     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
!     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
!     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
!   -81,    0,    0,    0,    0,    0,    0, -250,    0,    0,
!     0,    0,    0,    0,    0, -244,    0,    0,    0,    0,
!     0,    0,    0,    0,    0,
  };
! const short yygindex[] = {                                      0,
!     0,   -2,   10, -133,    0,  340,  798,    0,   24,    0,
!  -112,    0,    0,    0,    0,    0,    0,    0,    0, -146,
!     0,  -80,    0,  -28,   21,  152,   25,  -33,    8,    0,
!     0,  182, 1196, -170,
  };
! #define YYTABLESIZE 1468
! const short yytable[] = {                                      24,
!    80,   83,  105,  114,  114,  105,  252,   63,  100,   33,
!   170,   51,   93,  105,  131,  265,  105,  134,   95,   55,
!   122,  105,   56,   35,  232,  211,   57,  123,  154,   29,
!   203,   58,  206,   62,  240,  226,   94,   95,  105,   93,
!    61,  105,   34,  150,  151,   95,  105,  103,  122,   27,
!    65,   26,  113,  113,   66,  123,  152,  273,  179,  170,
!    96,  125,  242,  178,  179,  180,   76,  236,  237,  122,
!    34,  226,  147,   34,   77,  105,  123,  153,   84,   85,
!   105,   97,   92,   86,   87,   88,   89,   93,  104,  251,
!   120,   34,   34,  110,   34,  121,  170,  118,  251,  148,
!   122,  127,  126,  124,  128,   33,   33,  140,  105,  141,
!    29,  135,   28,  105,  136,  137,  116,  138,  139,  169,
!   146,  194,  214,  197,  207,  198,  192,   41,  208,  200,
!    27,  220,   26,  223,  202,  115,  230,  279,  280,  173,
!   233,  100,  238,   29,  241,  243,  244,  248,  253,  225,
!   254,  270,   33,   33,  256,   41,   34,   34,   41,  272,
!   257,  258,  259,   27,  266,   26,  174,  175,  282,  283,
!   284,   42,  285,  117,  118,  119,   41,   90,   91,   87,
!   274,  147,   75,   43,   74,   33,   33,   99,  159,  205,
!   210,   64,  250,   28,    0,  221,    0,    0,    0,   42,
!   146,    0,   42,    0,    0,    0,    0,    0,    0,    0,
!     0,   43,    0,    0,   43,    0,    0,    0,    0,    0,
!    42,  166,    0,    0,    0,  115,   28,    0,    0,    0,
!     0,    0,   43,   78,   81,   79,   82,    0,    0,    0,
!     0,   41,   41,    0,    0,    1,    2,  129,  115,  130,
!   132,    3,  133,    4,    5,    6,    7,    0,  224,    8,
!     9,  112,    0,    0,   10,   11,  155,   12,   13,   14,
!    15,  191,  231,  225,  199,   16,   17,   18,   19,  201,
!    20,   21,   22,   23,   25,   42,   42,    0,  115,  115,
!    34,   34,   34,   34,  249,   34,  269,   43,   43,    0,
!    34,   34,  150,  151,  271,    0,   94,   95,    0,  225,
!    34,   34,   34,    0,  105,    0,   34,   34,   34,   34,
!    34,   34,   34,   34,   34,   34,   34,    2,    0,    0,
!     0,    0,    3,  157,    4,    5,    6,    7,  115,  158,
!     8,    9,    0,    0,   29,   10,   11,    0,   12,   13,
!    14,   15,    0,    0,    0,    0,   16,   17,   18,   19,
!     2,   20,   21,   22,   23,    3,  164,    4,    5,    6,
!     7,    0,  165,    8,    9,   41,   41,   41,   41,    0,
!    41,   12,   13,   14,   15,   41,   41,    0,    0,   16,
!    17,   18,   19,  115,   20,   21,   22,   23,    0,  115,
!     0,   41,   41,    0,    0,    0,    0,   41,   67,   68,
!    69,   70,   78,   71,    0,   72,   73,    0,    0,   42,
!    42,   42,   42,    0,   42,   79,    0,   28,    0,   42,
!    42,   43,   43,   43,   43,    0,   43,    0,    0,    0,
!    78,   43,   43,   78,    0,   42,   42,    0,    0,    0,
!     0,   42,    0,   79,    0,    0,   79,   43,   43,  125,
!     0,   78,    0,   43,    0,    0,    0,    0,    0,    0,
!     0,  126,  115,    0,   79,    0,  102,  115,    0,  115,
!   115,  115,  115,    0,    0,    0,  115,  125,    0,    0,
!   125,    0,    0,    0,    0,    0,  115,    0,    0,  126,
!     0,    0,  126,    0,  127,    0,    0,    0,  125,    0,
!     0,    0,    0,    0,    0,    0,  129,    0,    0,    0,
!   126,  215,  216,  217,  218,  219,   78,   78,    0,    0,
!     0,    0,  127,    0,    0,  127,    0,    0,    0,   79,
!    79,    0,    0,  239,  129,    0,    0,  129,    0,  128,
!     0,    0,    0,  127,    0,    0,    0,    0,    0,    0,
!   102,    2,  130,    0,    0,  129,    3,    0,    4,    5,
!     6,    7,    0,    0,  125,    9,    0,  128,    0,    0,
!   128,    0,    0,    0,    0,   15,  126,    0,    0,    0,
!   130,    0,    0,  130,    0,    0,  108,    0,  128,    0,
!     0,  217,  218,  219,    0,    0,    0,    0,  109,    0,
!     0,  130,    0,  104,    0,    0,    0,    0,    0,  127,
!   110,    0,    0,    0,  108,    0,    0,  108,    0,    0,
!     0,  129,    0,    0,    0,    0,  109,    0,    0,  109,
!     0,    0,    0,    0,    0,  108,    0,    0,  110,    0,
!     0,  110,    0,    0,    0,    0,    0,  109,    0,    0,
!    78,   78,   78,   78,  128,   78,    0,    0,    0,  110,
!    78,   78,    0,   79,   79,   79,   79,  130,   79,    0,
!     0,    0,    0,   79,   79,    0,   78,   78,    0,    0,
!     0,    0,   78,  102,  102,  102,  102,  104,  102,   79,
!    79,    0,  105,  102,  102,   79,    0,  125,  125,  125,
!   125,  108,  125,    0,    0,    0,    0,  125,  125,  126,
!   126,  126,  126,  109,  126,  102,    0,    0,    0,  126,
!   126,    0,    0,  125,  125,  110,    0,    0,    0,  125,
!     0,    0,    0,    0,    0,  126,  126,    0,    0,    0,
!     0,  126,  127,  127,  127,  127,    0,  127,    0,    0,
!    29,    0,  127,  127,  129,  129,  129,  129,    0,  129,
!     0,    0,    0,    0,  129,  129,    0,    0,  127,  127,
!    27,    0,   26,    0,  127,    0,  105,    0,    0,    0,
!   129,  129,    0,    0,    0,    0,  129,  128,  128,  128,
!   128,    0,  128,   59,   60,  103,    0,  128,  128,    0,
!   130,  130,  130,  130,    0,  130,    0,    0,    0,    0,
!   130,  130,    0,  128,  128,   90,   91,    0,    0,  128,
!   104,  104,  104,  104,    0,  104,  130,  130,    0,    0,
!   104,  104,  130,   28,  108,  108,  108,  108,    0,  108,
!     0,    0,   29,    0,  108,  108,  109,  109,  109,  109,
!     0,  109,  104,    0,    0,    0,  109,  109,  110,  110,
!   110,  110,   27,  110,   26,    0,  108,    0,  110,  110,
!     0,    0,    0,    0,    0,   29,    0,    0,  109,  103,
!     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
!   110,  149,    0,    0,    0,   27,    0,   26,    0,  160,
!     0,    0,    0,  161,    0,    0,    0,  167,  168,  105,
!   105,  105,  105,    0,  105,    0,    0,  132,    0,  105,
!   105,    0,    0,    0,    0,   28,    0,    0,    0,    0,
!     0,    0,    0,    0,    0,    0,    0,  132,    0,  132,
!     0,  105,    0,    0,  193,    0,  196,    0,    0,    0,
!     0,    0,    0,    0,    0,    0,    0,    0,   28,    0,
!     0,    0,   29,    0,    0,  212,  213,    2,    0,    0,
!     0,    0,    3,    0,    4,    5,    6,    7,  228,  229,
!     8,    9,   27,    0,   26,  102,  234,  235,   12,   13,
!    14,   15,    0,    0,    0,    0,   16,   17,   18,   19,
!   132,   20,   21,   22,   23,   27,    0,   26,    0,    0,
!     0,    0,  103,  103,  103,  103,    0,  103,    0,    0,
!     0,    0,  103,  103,   27,    0,   26,    0,    0,    0,
!     0,  261,    0,    0,    0,    0,    0,    0,    0,  267,
!     0,    0,    0,    0,  103,   28,    0,    0,    0,    0,
!     0,    0,  275,    0,    0,    0,  277,  278,    0,    2,
!   281,    0,    0,    0,    3,    0,    4,    5,    6,    7,
!     0,    0,    8,    9,    0,    0,    0,   10,   11,    0,
!    12,   13,   14,   15,    0,    0,    0,    0,   16,   17,
!    18,   19,    2,   20,   21,   22,   23,    3,    0,    4,
!     5,    6,    7,    0,    0,    8,    9,    0,    0,    0,
!     0,   11,    0,   12,   13,   14,   15,    0,    0,    0,
!     0,   16,   17,   18,   19,    0,   20,   21,   22,   23,
!     0,    0,    0,    0,  132,    0,    0,    0,    0,  132,
!     0,  132,  132,  132,  132,    0,    0,  132,  132,    0,
!     0,    0,  132,    0,    0,  132,  132,  132,  132,    0,
!     0,    0,    0,  132,  132,  132,  132,    0,  132,  132,
!   132,  132,    0,    0,    0,    0,    0,    0,    0,    2,
!     0,    0,    0,    0,    3,    0,    4,    5,    6,    7,
!     0,    0,    8,    9,    0,    0,    0,    0,    0,    0,
!    12,   13,   14,   15,    0,    0,    0,    0,   16,   17,
!    18,   19,    0,   20,   21,   22,   23,    0,    0,    0,
!     0,    0,    0,   98,   13,   14,    0,    0,    0,    0,
!     0,   16,   17,   18,   19,    0,   20,   21,   22,   23,
!   109,  111,    0,  119,   14,    0,  123,    0,    0,    0,
!    16,   17,   18,   19,    0,   20,   21,   22,   23,    0,
!     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
!     0,    0,    0,    0,    0,    0,    0,  142,    0,  143,
!   144,    0,    0,    0,    0,    0,    0,    0,    0,    0,
!     0,    0,    0,    0,    0,  156,    0,    0,    0,    0,
!     0,    0,  162,  163,    0,    0,    0,    0,    0,    0,
!     0,  172,    0,    0,    0,    0,    0,    0,    0,    0,
!     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
!     0,    0,    0,    0,    0,  182,  183,  184,  185,  186,
!   190,    0,    0,    0,    0,    0,    0,    0,    0,  204,
!     0,  204,    0,    0,  209,    0,    0,    0,    0,    0,
!     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
!     0,    0,    0,  222,    0,    0,    0,    0,    0,    0,
!     0,    0,    0,    0,    0,    0,  204,  204,    0,    0,
!     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
!     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
!     0,    0,    0,    0,    0,    0,    0,  255,    0,    0,
!     0,    0,    0,    0,    0,  260,    0,    0,    0,    0,
!   262,  263,  264,    0,    0,    0,    0,  268,    0,    0,
!     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
!   276,    0,    0,    0,    0,    0,  204,  204,
  };
! const short yycheck[] = {                                      10,
!    45,   45,   10,   10,   10,   10,   41,   10,   37,    0,
!   123,   10,  263,   10,   45,   41,   10,   45,  263,  278,
!    10,   10,  278,    0,  195,  172,  282,   10,   10,   40,
!   164,  278,  166,  283,  205,   40,  284,  285,   10,  290,
!   278,   10,   10,  284,  285,  290,   10,   50,   38,   60,
!   277,   62,   59,   59,   40,   38,   38,  259,  260,  172,
!    38,   64,  209,  259,  260,  261,  278,  201,  202,   59,
!    38,   40,  101,   41,  278,   10,   59,   59,  278,  278,
!    10,   59,  124,  278,  278,  278,  278,   10,  258,  124,
!   268,   59,   60,   59,   62,  268,  209,   59,  124,  102,
!    40,  278,   41,  272,  278,   96,   97,  125,   10,   41,
!    40,  278,  123,   10,  278,  278,  123,  278,  278,   41,
!    97,  278,  261,  269,  269,  125,  123,   10,  269,  123,
!    60,  290,   62,  263,  123,   10,  269,  271,  272,  142,
!   125,  170,  269,   40,  125,  261,  258,  290,  269,  278,
!   125,  123,  143,  144,  269,   38,  124,  125,   41,  123,
!   125,  269,  125,   60,  278,   62,  143,  144,  269,  125,
!   269,   10,  125,   10,   10,   10,   59,  263,  263,  261,
!   261,  210,   60,   10,   62,  176,  177,   36,  123,  165,
!   170,   10,  226,  123,   -1,  188,   -1,   -1,   -1,   38,
!   177,   -1,   41,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
!    -1,   38,   -1,   -1,   41,   -1,   -1,   -1,   -1,   -1,
!    59,  123,   -1,   -1,   -1,   10,  123,   -1,   -1,   -1,
!    -1,   -1,   59,  278,  278,  280,  280,   -1,   -1,   -1,
!    -1,  124,  125,   -1,   -1,  256,  257,  278,  123,  280,
!   278,  262,  280,  264,  265,  266,  267,   -1,  263,  270,
!   271,  268,   -1,   -1,  275,  276,  274,  278,  279,  280,
!   281,  268,  278,  278,  268,  286,  287,  288,  289,  268,
!   291,  292,  293,  294,  295,  124,  125,   -1,  295,  295,
!   258,  259,  260,  261,  263,  263,  268,  124,  125,   -1,
!   268,  269,  284,  285,  268,   -1,  284,  285,   -1,  278,
!   278,  279,  280,   -1,   10,   -1,  284,  285,  286,  287,
!   288,  289,  290,  291,  292,  293,  294,  257,   -1,   -1,
!    -1,   -1,  262,  268,  264,  265,  266,  267,  123,  274,
!   270,  271,   -1,   -1,   40,  275,  276,   -1,  278,  279,
!   280,  281,   -1,   -1,   -1,   -1,  286,  287,  288,  289,
!   257,  291,  292,  293,  294,  262,  268,  264,  265,  266,
!   267,   -1,  274,  270,  271,  258,  259,  260,  261,   -1,
!   263,  278,  279,  280,  281,  268,  269,   -1,   -1,  286,
!   287,  288,  289,  268,  291,  292,  293,  294,   -1,  274,
!    -1,  284,  285,   -1,   -1,   -1,   -1,  290,  286,  287,
!   288,  289,   10,  291,   -1,  293,  294,   -1,   -1,  258,
!   259,  260,  261,   -1,  263,   10,   -1,  123,   -1,  268,
!   269,  258,  259,  260,  261,   -1,  263,   -1,   -1,   -1,
!    38,  268,  269,   41,   -1,  284,  285,   -1,   -1,   -1,
!    -1,  290,   -1,   38,   -1,   -1,   41,  284,  285,   10,
!    -1,   59,   -1,  290,   -1,   -1,   -1,   -1,   -1,   -1,
!    -1,   10,  257,   -1,   59,   -1,   41,  262,   -1,  264,
!   265,  266,  267,   -1,   -1,   -1,  271,   38,   -1,   -1,
!    41,   -1,   -1,   -1,   -1,   -1,  281,   -1,   -1,   38,
!    -1,   -1,   41,   -1,   10,   -1,   -1,   -1,   59,   -1,
!    -1,   -1,   -1,   -1,   -1,   -1,   10,   -1,   -1,   -1,
!    59,  182,  183,  184,  185,  186,  124,  125,   -1,   -1,
!    -1,   -1,   38,   -1,   -1,   41,   -1,   -1,   -1,  124,
!   125,   -1,   -1,  204,   38,   -1,   -1,   41,   -1,   10,
!    -1,   -1,   -1,   59,   -1,   -1,   -1,   -1,   -1,   -1,
!   125,  257,   10,   -1,   -1,   59,  262,   -1,  264,  265,
!   266,  267,   -1,   -1,  125,  271,   -1,   38,   -1,   -1,
!    41,   -1,   -1,   -1,   -1,  281,  125,   -1,   -1,   -1,
!    38,   -1,   -1,   41,   -1,   -1,   10,   -1,   59,   -1,
!    -1,  262,  263,  264,   -1,   -1,   -1,   -1,   10,   -1,
!    -1,   59,   -1,   41,   -1,   -1,   -1,   -1,   -1,  125,
!    10,   -1,   -1,   -1,   38,   -1,   -1,   41,   -1,   -1,
!    -1,  125,   -1,   -1,   -1,   -1,   38,   -1,   -1,   41,
!    -1,   -1,   -1,   -1,   -1,   59,   -1,   -1,   38,   -1,
!    -1,   41,   -1,   -1,   -1,   -1,   -1,   59,   -1,   -1,
!   258,  259,  260,  261,  125,  263,   -1,   -1,   -1,   59,
!   268,  269,   -1,  258,  259,  260,  261,  125,  263,   -1,
!    -1,   -1,   -1,  268,  269,   -1,  284,  285,   -1,   -1,
!    -1,   -1,  290,  258,  259,  260,  261,  125,  263,  284,
!   285,   -1,   41,  268,  269,  290,   -1,  258,  259,  260,
!   261,  125,  263,   -1,   -1,   -1,   -1,  268,  269,  258,
!   259,  260,  261,  125,  263,  290,   -1,   -1,   -1,  268,
!   269,   -1,   -1,  284,  285,  125,   -1,   -1,   -1,  290,
!    -1,   -1,   -1,   -1,   -1,  284,  285,   -1,   -1,   -1,
!    -1,  290,  258,  259,  260,  261,   -1,  263,   -1,   -1,
!    40,   -1,  268,  269,  258,  259,  260,  261,   -1,  263,
!    -1,   -1,   -1,   -1,  268,  269,   -1,   -1,  284,  285,
!    60,   -1,   62,   -1,  290,   -1,  125,   -1,   -1,   -1,
!   284,  285,   -1,   -1,   -1,   -1,  290,  258,  259,  260,
!   261,   -1,  263,    6,    7,   41,   -1,  268,  269,   -1,
!   258,  259,  260,  261,   -1,  263,   -1,   -1,   -1,   -1,
!   268,  269,   -1,  284,  285,   28,   29,   -1,   -1,  290,
!   258,  259,  260,  261,   -1,  263,  284,  285,   -1,   -1,
!   268,  269,  290,  123,  258,  259,  260,  261,   -1,  263,
!    -1,   -1,   40,   -1,  268,  269,  258,  259,  260,  261,
!    -1,  263,  290,   -1,   -1,   -1,  268,  269,  258,  259,
!   260,  261,   60,  263,   62,   -1,  290,   -1,  268,  269,
!    -1,   -1,   -1,   -1,   -1,   40,   -1,   -1,  290,  125,
!    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
!   290,  104,   -1,   -1,   -1,   60,   -1,   62,   -1,  112,
!    -1,   -1,   -1,  116,   -1,   -1,   -1,  120,  121,  258,
!   259,  260,  261,   -1,  263,   -1,   -1,   40,   -1,  268,
!   269,   -1,   -1,   -1,   -1,  123,   -1,   -1,   -1,   -1,
!    -1,   -1,   -1,   -1,   -1,   -1,   -1,   60,   -1,   62,
!    -1,  290,   -1,   -1,  157,   -1,  159,   -1,   -1,   -1,
!    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  123,   -1,
!    -1,   -1,   40,   -1,   -1,  178,  179,  257,   -1,   -1,
!    -1,   -1,  262,   -1,  264,  265,  266,  267,  191,  192,
!   270,  271,   60,   -1,   62,  275,  199,  200,  278,  279,
!   280,  281,   -1,   -1,   -1,   -1,  286,  287,  288,  289,
!   123,  291,  292,  293,  294,   60,   -1,   62,   -1,   -1,
!    -1,   -1,  258,  259,  260,  261,   -1,  263,   -1,   -1,
!    -1,   -1,  268,  269,   60,   -1,   62,   -1,   -1,   -1,
!    -1,  244,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  252,
!    -1,   -1,   -1,   -1,  290,  123,   -1,   -1,   -1,   -1,
!    -1,   -1,  265,   -1,   -1,   -1,  269,  270,   -1,  257,
!   273,   -1,   -1,   -1,  262,   -1,  264,  265,  266,  267,
!    -1,   -1,  270,  271,   -1,   -1,   -1,  275,  276,   -1,
!   278,  279,  280,  281,   -1,   -1,   -1,   -1,  286,  287,
!   288,  289,  257,  291,  292,  293,  294,  262,   -1,  264,
!   265,  266,  267,   -1,   -1,  270,  271,   -1,   -1,   -1,
!    -1,  276,   -1,  278,  279,  280,  281,   -1,   -1,   -1,
!    -1,  286,  287,  288,  289,   -1,  291,  292,  293,  294,
!    -1,   -1,   -1,   -1,  257,   -1,   -1,   -1,   -1,  262,
!    -1,  264,  265,  266,  267,   -1,   -1,  270,  271,   -1,
!    -1,   -1,  275,   -1,   -1,  278,  279,  280,  281,   -1,
!    -1,   -1,   -1,  286,  287,  288,  289,   -1,  291,  292,
!   293,  294,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  257,
!    -1,   -1,   -1,   -1,  262,   -1,  264,  265,  266,  267,
!    -1,   -1,  270,  271,   -1,   -1,   -1,   -1,   -1,   -1,
!   278,  279,  280,  281,   -1,   -1,   -1,   -1,  286,  287,
!   288,  289,   -1,  291,  292,  293,  294,   -1,   -1,   -1,
!    -1,   -1,   -1,  278,  279,  280,   -1,   -1,   -1,   -1,
!    -1,  286,  287,  288,  289,   -1,  291,  292,  293,  294,
!    55,   56,   -1,   58,  280,   -1,   61,   -1,   -1,   -1,
!   286,  287,  288,  289,   -1,  291,  292,  293,  294,   -1,
!    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
!    -1,   -1,   -1,   -1,   -1,   -1,   -1,   92,   -1,   94,
!    95,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
!    -1,   -1,   -1,   -1,   -1,  110,   -1,   -1,   -1,   -1,
!    -1,   -1,  117,  118,   -1,   -1,   -1,   -1,   -1,   -1,
!    -1,  126,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
!    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
!    -1,   -1,   -1,   -1,   -1,  150,  151,  152,  153,  154,
!   155,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  164,
!    -1,  166,   -1,   -1,  169,   -1,   -1,   -1,   -1,   -1,
!    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
!    -1,   -1,   -1,  188,   -1,   -1,   -1,   -1,   -1,   -1,
!    -1,   -1,   -1,   -1,   -1,   -1,  201,  202,   -1,   -1,
!    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
!    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
!    -1,   -1,   -1,   -1,   -1,   -1,   -1,  232,   -1,   -1,
!    -1,   -1,   -1,   -1,   -1,  240,   -1,   -1,   -1,   -1,
!   245,  246,  247,   -1,   -1,   -1,   -1,  252,   -1,   -1,
!    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
!   265,   -1,   -1,   -1,   -1,   -1,  271,  272,
  };
! #define YYFINAL 30
! #ifndef YYDEBUG
! #define YYDEBUG 0
! #endif
! #define YYMAXTOKEN 295
! #if YYDEBUG
! const char * const yyname[] = {
! "end-of-file",0,0,0,0,0,0,0,0,0,"'\\n'",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
! 0,0,0,0,0,0,0,"'&'",0,"'('","')'",0,0,0,"'-'",0,0,0,0,0,0,0,0,0,0,0,0,0,"';'",
! "'<'",0,"'>'",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
! 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"'{'","'|'","'}'",0,0,0,0,
! 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
! 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
! 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
! 0,0,0,0,0,0,0,"IF","THEN","ELSE","ELIF","FI","CASE","ESAC","FOR","SELECT",
! "WHILE","UNTIL","DO","DONE","FUNCTION","COND_START","COND_END","COND_ERROR",
! "IN","BANG","TIME","TIMEOPT","WORD","ASSIGNMENT_WORD","NUMBER","ARITH_CMD",
! "ARITH_FOR_EXPRS","COND_CMD","AND_AND","OR_OR","GREATER_GREATER","LESS_LESS",
! "LESS_AND","GREATER_AND","SEMI_SEMI","LESS_LESS_MINUS","AND_GREATER",
! "LESS_GREATER","GREATER_BAR","yacc_EOF",
  };
! const char * const yyrule[] = {
! "$accept : inputunit",
! "inputunit : simple_list '\\n'",
! "inputunit : '\\n'",
! "inputunit : error '\\n'",
! "inputunit : yacc_EOF",
! "word_list : WORD",
! "word_list : word_list WORD",
! "redirection : '>' WORD",
! "redirection : '<' WORD",
! "redirection : NUMBER '>' WORD",
! "redirection : NUMBER '<' WORD",
! "redirection : GREATER_GREATER WORD",
! "redirection : NUMBER GREATER_GREATER WORD",
! "redirection : LESS_LESS WORD",
! "redirection : NUMBER LESS_LESS WORD",
! "redirection : LESS_AND NUMBER",
! "redirection : NUMBER LESS_AND NUMBER",
! "redirection : GREATER_AND NUMBER",
! "redirection : NUMBER GREATER_AND NUMBER",
! "redirection : LESS_AND WORD",
! "redirection : NUMBER LESS_AND WORD",
! "redirection : GREATER_AND WORD",
! "redirection : NUMBER GREATER_AND WORD",
! "redirection : LESS_LESS_MINUS WORD",
! "redirection : NUMBER LESS_LESS_MINUS WORD",
! "redirection : GREATER_AND '-'",
! "redirection : NUMBER GREATER_AND '-'",
! "redirection : LESS_AND '-'",
! "redirection : NUMBER LESS_AND '-'",
! "redirection : AND_GREATER WORD",
! "redirection : NUMBER LESS_GREATER WORD",
! "redirection : LESS_GREATER WORD",
! "redirection : GREATER_BAR WORD",
! "redirection : NUMBER GREATER_BAR WORD",
! "simple_command_element : WORD",
! "simple_command_element : ASSIGNMENT_WORD",
! "simple_command_element : redirection",
! "redirection_list : redirection",
! "redirection_list : redirection_list redirection",
! "simple_command : simple_command_element",
! "simple_command : simple_command simple_command_element",
! "command : simple_command",
! "command : shell_command",
! "command : shell_command redirection_list",
! "command : function_def",
! "shell_command : for_command",
! "shell_command : case_command",
! "shell_command : WHILE compound_list DO compound_list DONE",
! "shell_command : UNTIL compound_list DO compound_list DONE",
! "shell_command : select_command",
! "shell_command : if_command",
! "shell_command : subshell",
! "shell_command : group_command",
! "shell_command : arith_command",
! "shell_command : cond_command",
! "shell_command : arith_for_command",
! "for_command : FOR WORD newline_list DO compound_list DONE",
! "for_command : FOR WORD newline_list '{' compound_list '}'",
! "for_command : FOR WORD ';' newline_list DO compound_list DONE",
! "for_command : FOR WORD ';' newline_list '{' compound_list '}'",
! "for_command : FOR WORD newline_list IN word_list list_terminator newline_list DO compound_list DONE",
! "for_command : FOR WORD newline_list IN word_list list_terminator newline_list '{' compound_list '}'",
! "arith_for_command : FOR ARITH_FOR_EXPRS list_terminator newline_list DO compound_list DONE",
! "arith_for_command : FOR ARITH_FOR_EXPRS list_terminator newline_list '{' compound_list '}'",
! "arith_for_command : FOR ARITH_FOR_EXPRS DO compound_list DONE",
! "arith_for_command : FOR ARITH_FOR_EXPRS '{' compound_list '}'",
! "select_command : SELECT WORD newline_list DO list DONE",
! "select_command : SELECT WORD newline_list '{' list '}'",
! "select_command : SELECT WORD ';' newline_list DO list DONE",
! "select_command : SELECT WORD ';' newline_list '{' list '}'",
! "select_command : SELECT WORD newline_list IN word_list list_terminator newline_list DO list DONE",
! "select_command : SELECT WORD newline_list IN word_list list_terminator newline_list '{' list '}'",
! "case_command : CASE WORD newline_list IN newline_list ESAC",
! "case_command : CASE WORD newline_list IN case_clause_sequence newline_list ESAC",
! "case_command : CASE WORD newline_list IN case_clause ESAC",
! "function_def : WORD '(' ')' newline_list function_body",
! "function_def : FUNCTION WORD '(' ')' newline_list function_body",
! "function_def : FUNCTION WORD newline_list function_body",
! "function_body : shell_command",
! "function_body : shell_command redirection_list",
! "subshell : '(' compound_list ')'",
! "if_command : IF compound_list THEN compound_list FI",
! "if_command : IF compound_list THEN compound_list ELSE compound_list FI",
! "if_command : IF compound_list THEN compound_list elif_clause FI",
! "group_command : '{' compound_list '}'",
! "arith_command : ARITH_CMD",
! "cond_command : COND_START COND_CMD COND_END",
! "elif_clause : ELIF compound_list THEN compound_list",
! "elif_clause : ELIF compound_list THEN compound_list ELSE compound_list",
! "elif_clause : ELIF compound_list THEN compound_list elif_clause",
! "case_clause : pattern_list",
! "case_clause : case_clause_sequence pattern_list",
! "pattern_list : newline_list pattern ')' compound_list",
! "pattern_list : newline_list pattern ')' newline_list",
! "pattern_list : newline_list '(' pattern ')' compound_list",
! "pattern_list : newline_list '(' pattern ')' newline_list",
! "case_clause_sequence : pattern_list SEMI_SEMI",
! "case_clause_sequence : case_clause_sequence pattern_list SEMI_SEMI",
! "pattern : WORD",
! "pattern : pattern '|' WORD",
! "list : newline_list list0",
! "compound_list : list",
! "compound_list : newline_list list1",
! "list0 : list1 '\\n' newline_list",
! "list0 : list1 '&' newline_list",
! "list0 : list1 ';' newline_list",
! "list1 : list1 AND_AND newline_list list1",
! "list1 : list1 OR_OR newline_list list1",
! "list1 : list1 '&' newline_list list1",
! "list1 : list1 ';' newline_list list1",
! "list1 : list1 '\\n' newline_list list1",
! "list1 : pipeline_command",
! "list_terminator : '\\n'",
! "list_terminator : ';'",
! "list_terminator : yacc_EOF",
! "newline_list :",
! "newline_list : newline_list '\\n'",
! "simple_list : simple_list1",
! "simple_list : simple_list1 '&'",
! "simple_list : simple_list1 ';'",
! "simple_list1 : simple_list1 AND_AND newline_list simple_list1",
! "simple_list1 : simple_list1 OR_OR newline_list simple_list1",
! "simple_list1 : simple_list1 '&' simple_list1",
! "simple_list1 : simple_list1 ';' simple_list1",
! "simple_list1 : pipeline_command",
! "pipeline_command : pipeline",
! "pipeline_command : BANG pipeline",
! "pipeline_command : timespec pipeline",
! "pipeline_command : timespec BANG pipeline",
! "pipeline_command : BANG timespec pipeline",
! "pipeline : pipeline '|' newline_list pipeline",
! "pipeline : command",
! "timespec : TIME",
! "timespec : TIME TIMEOPT",
  };
  #endif
! #if YYDEBUG
! #include <stdio.h>
! #endif
! #ifdef YYSTACKSIZE
! #undef YYMAXDEPTH
! #define YYMAXDEPTH YYSTACKSIZE
  #else
! #ifdef YYMAXDEPTH
! #define YYSTACKSIZE YYMAXDEPTH
! #else
! #define YYSTACKSIZE 10000
! #define YYMAXDEPTH 10000
  #endif
  #endif
+ #define YYINITSTACKSIZE 200
+ int yydebug;
+ int yynerrs;
+ int yyerrflag;
+ int yychar;
+ short *yyssp;
+ YYSTYPE *yyvsp;
+ YYSTYPE yyval;
+ YYSTYPE yylval;
+ short *yyss;
+ short *yysslim;
+ YYSTYPE *yyvs;
+ int yystacksize;
+ #line 815 "/usr/homes/chet/src/bash/src/parse.y"
  
! /* Possible states for the parser that require it to do special things. */
! #define PST_CASEPAT	0x001		/* in a case pattern list */
! #define PST_ALEXPNEXT	0x002		/* expand next word for aliases */
! #define PST_ALLOWOPNBRC	0x004		/* allow open brace for function def */
! #define PST_NEEDCLOSBRC	0x008		/* need close brace */
! #define PST_DBLPAREN	0x010		/* double-paren parsing */
! #define PST_SUBSHELL	0x020		/* ( ... ) subshell */
! #define PST_CMDSUBST	0x040		/* $( ... ) command substitution */
! #define PST_CASESTMT	0x080		/* parsing a case statement */
! #define PST_CONDCMD	0x100		/* parsing a [[...]] command */
! #define PST_CONDEXPR	0x200		/* parsing the guts of [[...]] */
! #define PST_ARITHFOR	0x400		/* parsing an arithmetic for command */
  
! /* Initial size to allocate for tokens, and the
!    amount to grow them by. */
! #define TOKEN_DEFAULT_INITIAL_SIZE 496
! #define TOKEN_DEFAULT_GROW_SIZE 512
  
! /* The token currently being read. */
! static int current_token;
  
! /* The last read token, or NULL.  read_token () uses this for context
!    checking. */
! static int last_read_token;
  
! /* The token read prior to last_read_token. */
! static int token_before_that;
  
! /* The token read prior to token_before_that. */
! static int two_tokens_ago;
  
! /* If non-zero, it is the token that we want read_token to return
!    regardless of what text is (or isn't) present to be read.  This
!    is reset by read_token.  If token_to_read == WORD or
!    ASSIGNMENT_WORD, yylval.word should be set to word_desc_to_read. */
! static int token_to_read;
! static WORD_DESC *word_desc_to_read;
  
! /* The current parser state. */
! static int parser_state;
  
! /* Global var is non-zero when end of file has been reached. */
! int EOF_Reached = 0;
  
! void
! debug_parser (i)
!      int i;
! {
! #if YYDEBUG != 0
!   yydebug = i;
  #endif
+ }
  
! /* yy_getc () returns the next available character from input or EOF.
!    yy_ungetc (c) makes `c' the next character to read.
!    init_yy_io (get, unget, type, location) makes the function GET the
!    installed function for getting the next character, makes UNGET the
!    installed function for un-getting a character, sets the type of stream
!    (either string or file) from TYPE, and makes LOCATION point to where
!    the input is coming from. */
  
! /* Unconditionally returns end-of-file. */
! int
! return_EOF ()
  {
!   return (EOF);
  }
  
! /* Variable containing the current get and unget functions.
!    See ./input.h for a clearer description. */
! BASH_INPUT bash_input;
  
! /* Set all of the fields in BASH_INPUT to NULL.  Free bash_input.name if it
!    is non-null, avoiding a memory leak. */
! void
! initialize_bash_input ()
  {
!   bash_input.type = st_none;
!   FREE (bash_input.name);
!   bash_input.name = (char *)NULL;
!   bash_input.location.file = (FILE *)NULL;
!   bash_input.location.string = (char *)NULL;
!   bash_input.getter = (Function *)NULL;
!   bash_input.ungetter = (Function *)NULL;
  }
  
! /* Set the contents of the current bash input stream from
!    GET, UNGET, TYPE, NAME, and LOCATION. */
! void
! init_yy_io (get, unget, type, name, location)
!      Function *get, *unget;
!      enum stream_type type;
!      char *name;
!      INPUT_STREAM location;
  {
!   bash_input.type = type;
!   FREE (bash_input.name);
!   bash_input.name = name ? savestring (name) : (char *)NULL;
  
!   /* XXX */
! #if defined (CRAY)
!   memcpy((char *)&bash_input.location.string, (char *)&location.string, sizeof(location));
  #else
!   bash_input.location = location;
  #endif
+   bash_input.getter = get;
+   bash_input.ungetter = unget;
+ }
  
! /* Call this to get the next character of input. */
! int
! yy_getc ()
! {
!   return (*(bash_input.getter)) ();
! }
  
! /* Call this to unget C.  That is, to make C the next character
!    to be read. */
! int
! yy_ungetc (c)
!      int c;
! {
!   return (*(bash_input.ungetter)) (c);
! }
  
! #if defined (BUFFERED_INPUT)
! int
! input_file_descriptor ()
! {
!   switch (bash_input.type)
!     {
!     case st_stream:
!       return (fileno (bash_input.location.file));
!     case st_bstream:
!       return (bash_input.location.buffered_fd);
!     case st_stdin:
!     default:
!       return (fileno (stdin));
!     }
! }
! #endif /* BUFFERED_INPUT */
  
! /* **************************************************************** */
! /*								    */
! /*		  Let input be read from readline ().		    */
! /*								    */
! /* **************************************************************** */
  
! #if defined (READLINE)
! char *current_readline_prompt = (char *)NULL;
! char *current_readline_line = (char *)NULL;
! int current_readline_line_index = 0;
  
! static int
! yy_readline_get ()
! {
!   SigHandler *old_sigint;
!   int line_len, c;
  
!   if (!current_readline_line)
!     {
!       if (!bash_readline_initialized)
! 	initialize_readline ();
  
! #if defined (JOB_CONTROL)
!       if (job_control)
! 	give_terminal_to (shell_pgrp, 0);
! #endif /* JOB_CONTROL */
  
!       if (signal_is_ignored (SIGINT) == 0)
! 	{
! 	  old_sigint = (SigHandler *)set_signal_handler (SIGINT, sigint_sighandler);
! 	  interrupt_immediately++;
! 	}
  
!       current_readline_line = readline (current_readline_prompt ?
!       					  current_readline_prompt : "");
  
!       if (signal_is_ignored (SIGINT) == 0)
! 	{
! 	  interrupt_immediately--;
! 	  set_signal_handler (SIGINT, old_sigint);
! 	}
  
! #if 0
!       /* Reset the prompt to the decoded value of prompt_string_pointer. */
!       reset_readline_prompt ();
! #endif
  
!       if (current_readline_line == 0)
! 	return (EOF);
  
!       current_readline_line_index = 0;
!       line_len = strlen (current_readline_line);
  
!       current_readline_line = xrealloc (current_readline_line, 2 + line_len);
!       current_readline_line[line_len++] = '\n';
!       current_readline_line[line_len] = '\0';
      }
  
!   if (current_readline_line[current_readline_line_index] == 0)
      {
!       free (current_readline_line);
!       current_readline_line = (char *)NULL;
!       return (yy_readline_get ());
      }
    else
      {
!       c = (unsigned char)current_readline_line[current_readline_line_index++];
!       return (c);
!     }
! }
  
! static int
! yy_readline_unget (c)
!      int c;
! {
!   if (current_readline_line_index && current_readline_line)
!     current_readline_line[--current_readline_line_index] = c;
!   return (c);
! }
! 
! void
! with_input_from_stdin ()
! {
!   INPUT_STREAM location;
! 
!   if (bash_input.type != st_stdin && stream_on_stack (st_stdin) == 0)
!     {
!       location.string = current_readline_line;
!       init_yy_io (yy_readline_get, yy_readline_unget,
! 		  st_stdin, "readline stdin", location);
      }
+ }
+ 
+ #else  /* !READLINE */
+ 
+ void
+ with_input_from_stdin ()
+ {
+   with_input_from_stream (stdin, "stdin");
+ }
+ #endif	/* !READLINE */
  
! /* **************************************************************** */
! /*								    */
! /*   Let input come from STRING.  STRING is zero terminated.	    */
! /*								    */
! /* **************************************************************** */
  
! static int
! yy_string_get ()
! {
!   register char *string;
!   register int c;
  
!   string = bash_input.location.string;
!   c = EOF;
  
!   /* If the string doesn't exist, or is empty, EOF found. */
!   if (string && *string)
      {
!       c = *(unsigned char *)string++;
!       bash_input.location.string = string;
      }
!   return (c);
! }
! 
! static int
! yy_string_unget (c)
!      int c;
! {
!   *(--bash_input.location.string) = c;
!   return (c);
! }
  
! void
! with_input_from_string (string, name)
!      char *string, *name;
! {
!   INPUT_STREAM location;
  
!   location.string = string;
!   init_yy_io (yy_string_get, yy_string_unget, st_string, name, location);
! }
  
! /* **************************************************************** */
! /*								    */
! /*		     Let input come from STREAM.		    */
! /*								    */
! /* **************************************************************** */
  
! /* These two functions used to test the value of the HAVE_RESTARTABLE_SYSCALLS
!    define, and just use getc/ungetc if it was defined, but since bash
!    installs its signal handlers without the SA_RESTART flag, some signals
!    (like SIGCHLD, SIGWINCH, etc.) received during a read(2) will not cause
!    the read to be restarted.  We need to restart it ourselves. */
  
! static int
! yy_stream_get ()
! {
!   int result;
  
!   result = EOF;
!   if (bash_input.location.file)
!     result = getc_with_restart (bash_input.location.file);
  
!   return (result);
! }
  
! static int
! yy_stream_unget (c)
!      int c;
! {
!   return (ungetc_with_restart (c, bash_input.location.file));
! }
  
! void
! with_input_from_stream (stream, name)
!      FILE *stream;
!      char *name;
! {
!   INPUT_STREAM location;
  
!   location.file = stream;
!   init_yy_io (yy_stream_get, yy_stream_unget, st_stream, name, location);
! }
  
! typedef struct stream_saver {
!   struct stream_saver *next;
!   BASH_INPUT bash_input;
!   int line;
! #if defined (BUFFERED_INPUT)
!   BUFFERED_STREAM *bstream;
! #endif /* BUFFERED_INPUT */
! } STREAM_SAVER;
  
! /* The globally known line number. */
! int line_number = 0;
  
! #if defined (COND_COMMAND)
! static int cond_lineno;
! static int cond_token;
  #endif
  
+ STREAM_SAVER *stream_list = (STREAM_SAVER *)NULL;
  
! void
! push_stream (reset_lineno)
!      int reset_lineno;
! {
!   STREAM_SAVER *saver = (STREAM_SAVER *)xmalloc (sizeof (STREAM_SAVER));
  
!   xbcopy ((char *)&bash_input, (char *)&(saver->bash_input), sizeof (BASH_INPUT));
! 
! #if defined (BUFFERED_INPUT)
!   saver->bstream = (BUFFERED_STREAM *)NULL;
!   /* If we have a buffered stream, clear out buffers[fd]. */
!   if (bash_input.type == st_bstream && bash_input.location.buffered_fd >= 0)
!     saver->bstream = set_buffered_stream (bash_input.location.buffered_fd,
!     					  (BUFFERED_STREAM *)NULL);
! #endif /* BUFFERED_INPUT */
! 
!   saver->line = line_number;
!   bash_input.name = (char *)NULL;
!   saver->next = stream_list;
!   stream_list = saver;
!   EOF_Reached = 0;
!   if (reset_lineno)
!     line_number = 0;
! }
! 
! void
! pop_stream ()
  {
!   if (!stream_list)
!     EOF_Reached = 1;
!   else
!     {
!       STREAM_SAVER *saver = stream_list;
! 
!       EOF_Reached = 0;
!       stream_list = stream_list->next;
! 
!       init_yy_io (saver->bash_input.getter,
! 		  saver->bash_input.ungetter,
! 		  saver->bash_input.type,
! 		  saver->bash_input.name,
! 		  saver->bash_input.location);
! 
! #if defined (BUFFERED_INPUT)
!       /* If we have a buffered stream, restore buffers[fd]. */
!       /* If the input file descriptor was changed while this was on the
! 	 save stack, update the buffered fd to the new file descriptor and
! 	 re-establish the buffer <-> bash_input fd correspondence. */
!       if (bash_input.type == st_bstream && bash_input.location.buffered_fd >= 0)
! 	{
! 	  if (bash_input_fd_changed)
! 	    {
! 	      bash_input_fd_changed = 0;
! 	      if (default_buffered_input >= 0)
! 		{
! 		  bash_input.location.buffered_fd = default_buffered_input;
! 		  saver->bstream->b_fd = default_buffered_input;
! 		  SET_CLOSE_ON_EXEC (default_buffered_input);
! 		}
! 	    }
! 	  /* XXX could free buffered stream returned as result here. */
! 	  set_buffered_stream (bash_input.location.buffered_fd, saver->bstream);
! 	}
! #endif /* BUFFERED_INPUT */
! 
!       line_number = saver->line;
! 
!       FREE (saver->bash_input.name);
!       free (saver);
!     }
! }
! 
! /* Return 1 if a stream of type TYPE is saved on the stack. */
! int
! stream_on_stack (type)
!      enum stream_type type;
  {
!   register STREAM_SAVER *s;
! 
!   for (s = stream_list; s; s = s->next)
!     if (s->bash_input.type == type)
!       return 1;
!   return 0;
! }
! 
! /* Save the current token state and return it in a malloced array. */
! int *
! save_token_state ()
  {
!   int *ret;
! 
!   ret = (int *)xmalloc (3 * sizeof (int));
!   ret[0] = last_read_token;
!   ret[1] = token_before_that;
!   ret[2] = two_tokens_ago;
!   return ret;
! }
! 
! void
! restore_token_state (ts)
!      int *ts;
  {
!   if (ts == 0)
!     return;
!   last_read_token = ts[0];
!   token_before_that = ts[1];
!   two_tokens_ago = ts[2];
! }
! 
! /*
!  * This is used to inhibit alias expansion and reserved word recognition
!  * inside case statement pattern lists.  A `case statement pattern list' is:
!  *
!  *	everything between the `in' in a `case word in' and the next ')'
!  *	or `esac'
!  *	everything between a `;;' and the next `)' or `esac'
!  */
! 
! #if defined (ALIAS) || defined (DPAREN_ARITHMETIC)
! 
! #if !defined (ALIAS)
! typedef void *alias_t;
! #endif
! 
! #define END_OF_ALIAS 0
! 
! /*
!  * Pseudo-global variables used in implementing token-wise alias expansion.
!  */
! 
! /*
!  * Pushing and popping strings.  This works together with shell_getc to
!  * implement alias expansion on a per-token basis.
!  */
! 
! typedef struct string_saver {
!   struct string_saver *next;
!   int expand_alias;  /* Value to set expand_alias to when string is popped. */
!   char *saved_line;
! #if defined (ALIAS)
!   alias_t *expander;   /* alias that caused this line to be pushed. */
! #endif
!   int saved_line_size, saved_line_index, saved_line_terminator;
! } STRING_SAVER;
! 
! STRING_SAVER *pushed_string_list = (STRING_SAVER *)NULL;
! 
! /*
!  * Push the current shell_input_line onto a stack of such lines and make S
!  * the current input.  Used when expanding aliases.  EXPAND is used to set
!  * the value of expand_next_token when the string is popped, so that the
!  * word after the alias in the original line is handled correctly when the
!  * alias expands to multiple words.  TOKEN is the token that was expanded
!  * into S; it is saved and used to prevent infinite recursive expansion.
!  */
! static void
! push_string (s, expand, ap)
!      char *s;
!      int expand;
!      alias_t *ap;
  {
!   STRING_SAVER *temp = (STRING_SAVER *) xmalloc (sizeof (STRING_SAVER));
! 
!   temp->expand_alias = expand;
!   temp->saved_line = shell_input_line;
!   temp->saved_line_size = shell_input_line_size;
!   temp->saved_line_index = shell_input_line_index;
!   temp->saved_line_terminator = shell_input_line_terminator;
! #if defined (ALIAS)
!   temp->expander = ap;
! #endif
!   temp->next = pushed_string_list;
!   pushed_string_list = temp;
! 
! #if defined (ALIAS)
!   if (ap)
!     ap->flags |= AL_BEINGEXPANDED;
! #endif
! 
!   shell_input_line = s;
!   shell_input_line_size = strlen (s);
!   shell_input_line_index = 0;
!   shell_input_line_terminator = '\0';
!   parser_state &= ~PST_ALEXPNEXT;
! }
! 
! /*
!  * Make the top of the pushed_string stack be the current shell input.
!  * Only called when there is something on the stack.  Called from shell_getc
!  * when it thinks it has consumed the string generated by an alias expansion
!  * and needs to return to the original input line.
!  */
! static void
! pop_string ()
  {
!   STRING_SAVER *t;
  
!   FREE (shell_input_line);
!   shell_input_line = pushed_string_list->saved_line;
!   shell_input_line_index = pushed_string_list->saved_line_index;
!   shell_input_line_size = pushed_string_list->saved_line_size;
!   shell_input_line_terminator = pushed_string_list->saved_line_terminator;
! 
!   if (pushed_string_list->expand_alias)
!     parser_state |= PST_ALEXPNEXT;
!   else
!     parser_state &= ~PST_ALEXPNEXT;
! 
!   t = pushed_string_list;
!   pushed_string_list = pushed_string_list->next;
! 
! #if defined (ALIAS)
!   if (t->expander)
!     t->expander->flags &= ~AL_BEINGEXPANDED;
! #endif
! 
!   free ((char *)t);
! }
! 
! static void
! free_string_list ()
  {
!   register STRING_SAVER *t, *t1;
  
!   for (t = pushed_string_list; t; )
      {
!       t1 = t->next;
!       FREE (t->saved_line);
! #if defined (ALIAS)
!       if (t->expander)
! 	t->expander->flags &= ~AL_BEINGEXPANDED;
  #endif
!       free ((char *)t);
!       t = t1;
      }
!   pushed_string_list = (STRING_SAVER *)NULL;
! }
  
! #endif /* ALIAS || DPAREN_ARITHMETIC */
  
! /* Return a line of text, taken from wherever yylex () reads input.
!    If there is no more input, then we return NULL.  If REMOVE_QUOTED_NEWLINE
!    is non-zero, we remove unquoted \<newline> pairs.  This is used by
!    read_secondary_line to read here documents. */
! static char *
! read_a_line (remove_quoted_newline)
!      int remove_quoted_newline;
! {
!   static char *line_buffer = (char *)NULL;
!   static int buffer_size = 0;
!   int indx = 0, c, peekc, pass_next;
  
! #if defined (READLINE)
!   if (interactive && bash_input.type != st_string && no_line_editing)
! #else
!   if (interactive && bash_input.type != st_string)
! #endif
!     print_prompt ();
  
!   pass_next = 0;
!   while (1)
      {
!       c = yy_getc ();
  
!       /* Allow immediate exit if interrupted during input. */
!       QUIT;
  
!       /* Ignore null bytes in input. */
!       if (c == 0)
  	{
! #if 0
! 	  internal_warning ("read_a_line: ignored null byte in input");
  #endif
+ 	  continue;
+ 	}
  
!       /* If there is no more input, then we return NULL. */
!       if (c == EOF)
! 	{
! 	  if (interactive && bash_input.type == st_stream)
! 	    clearerr (stdin);
! 	  if (indx == 0)
! 	    return ((char *)NULL);
! 	  c = '\n';
! 	}
  
!       /* `+2' in case the final character in the buffer is a newline. */
!       RESIZE_MALLOCED_BUFFER (line_buffer, indx, 2, buffer_size, 128);
  
!       /* IF REMOVE_QUOTED_NEWLINES is non-zero, we are reading a
! 	 here document with an unquoted delimiter.  In this case,
! 	 the line will be expanded as if it were in double quotes.
! 	 We allow a backslash to escape the next character, but we
! 	 need to treat the backslash specially only if a backslash
! 	 quoting a backslash-newline pair appears in the line. */
!       if (pass_next)
! 	{
! 	  line_buffer[indx++] = c;
! 	  pass_next = 0;
! 	}
!       else if (c == '\\' && remove_quoted_newline)
! 	{
! 	  peekc = yy_getc ();
! 	  if (peekc == '\n')
! 	    continue;	/* Make the unquoted \<newline> pair disappear. */
! 	  else
! 	    {
! 	      yy_ungetc (peekc);
! 	      pass_next = 1;
! 	      line_buffer[indx++] = c;		/* Preserve the backslash. */
! 	    }
! 	}
!       else
! 	line_buffer[indx++] = c;
  
!       if (c == '\n')
! 	{
! 	  line_buffer[indx] = '\0';
! 	  return (line_buffer);
! 	}
      }
+ }
+ 
+ /* Return a line as in read_a_line (), but insure that the prompt is
+    the secondary prompt.  This is used to read the lines of a here
+    document.  REMOVE_QUOTED_NEWLINE is non-zero if we should remove
+    newlines quoted with backslashes while reading the line.  It is
+    non-zero unless the delimiter of the here document was quoted. */
+ char *
+ read_secondary_line (remove_quoted_newline)
+      int remove_quoted_newline;
+ {
+   prompt_string_pointer = &ps2_prompt;
+   prompt_again ();
+   return (read_a_line (remove_quoted_newline));
+ }
+ 
+ /* **************************************************************** */
+ /*								    */
+ /*				YYLEX ()			    */
+ /*								    */
+ /* **************************************************************** */
+ 
+ /* Reserved words.  These are only recognized as the first word of a
+    command. */
+ STRING_INT_ALIST word_token_alist[] = {
+   { "if", IF },
+   { "then", THEN },
+   { "else", ELSE },
+   { "elif", ELIF },
+   { "fi", FI },
+   { "case", CASE },
+   { "esac", ESAC },
+   { "for", FOR },
+ #if defined (SELECT_COMMAND)
+   { "select", SELECT },
+ #endif
+   { "while", WHILE },
+   { "until", UNTIL },
+   { "do", DO },
+   { "done", DONE },
+   { "in", IN },
+   { "function", FUNCTION },
+ #if defined (COMMAND_TIMING)
+   { "time", TIME },
+ #endif
+   { "{", '{' },
+   { "}", '}' },
+   { "!", BANG },
+ #if defined (COND_COMMAND)
+   { "[[", COND_START },
+   { "]]", COND_END },
  #endif
+   { (char *)NULL, 0}
+ };
  
! /* XXX - we should also have an alist with strings for other tokens, so we
! 	 can give more descriptive error messages.  Look at y.tab.h for the
! 	 other tokens. */
  
! /* These are used by read_token_word, but appear up here so that shell_getc
!    can use them to decide when to add otherwise blank lines to the history. */
  
! /* The primary delimiter stack. */
! struct dstack dstack = {  (char *)NULL, 0, 0 };
  
! /* A temporary delimiter stack to be used when decoding prompt strings.
!    This is needed because command substitutions in prompt strings (e.g., PS2)
!    can screw up the parser's quoting state. */
! static struct dstack temp_dstack = { (char *)NULL, 0, 0 };
  
! /* Macro for accessing the top delimiter on the stack.  Returns the
!    delimiter or zero if none. */
! #define current_delimiter(ds) \
!   (ds.delimiter_depth ? ds.delimiters[ds.delimiter_depth - 1] : 0)
  
! #define push_delimiter(ds, character) \
!   do \
!     { \
!       if (ds.delimiter_depth + 2 > ds.delimiter_space) \
! 	ds.delimiters = xrealloc \
! 	  (ds.delimiters, (ds.delimiter_space += 10) * sizeof (char)); \
!       ds.delimiters[ds.delimiter_depth] = character; \
!       ds.delimiter_depth++; \
!     } \
!   while (0)
  
! #define pop_delimiter(ds)	ds.delimiter_depth--
  
! /* Return the next shell input character.  This always reads characters
!    from shell_input_line; when that line is exhausted, it is time to
!    read the next line.  This is called by read_token when the shell is
!    processing normal command input. */
  
+ /* This implements one-character lookahead/lookbehind across physical input
+    lines, to avoid something being lost because it's pushed back with
+    shell_ungetc when we're at the start of a line. */
+ static int eol_ungetc_lookahead = 0;
  
! static int
! shell_getc (remove_quoted_newline)
!      int remove_quoted_newline;
! {
!   register int i;
!   int c;
!   static int mustpop = 0;
  
!   QUIT;
  
!   if (eol_ungetc_lookahead)
!     {
!       c = eol_ungetc_lookahead;
!       eol_ungetc_lookahead = 0;
!       return (c);
!     }
  
! #if defined (ALIAS) || defined (DPAREN_ARITHMETIC)
!   /* If shell_input_line[shell_input_line_index] == 0, but there is
!      something on the pushed list of strings, then we don't want to go
!      off and get another line.  We let the code down below handle it. */
  
!   if (!shell_input_line || ((!shell_input_line[shell_input_line_index]) &&
! 			    (pushed_string_list == (STRING_SAVER *)NULL)))
! #else /* !ALIAS && !DPAREN_ARITHMETIC */
!   if (!shell_input_line || !shell_input_line[shell_input_line_index])
! #endif /* !ALIAS && !DPAREN_ARITHMETIC */
!     {
!       line_number++;
  
!     restart_read:
  
!       /* Allow immediate exit if interrupted during input. */
!       QUIT;
  
!       i = 0;
!       shell_input_line_terminator = 0;
  
! #if defined (JOB_CONTROL)
!       /* This can cause a problem when reading a command as the result
! 	 of a trap, when the trap is called from flush_child.  This call
! 	 had better not cause jobs to disappear from the job table in
! 	 that case, or we will have big trouble. */
!       notify_and_cleanup ();
! #else /* !JOB_CONTROL */
!       cleanup_dead_jobs ();
! #endif /* !JOB_CONTROL */
  
! #if defined (READLINE)
!       if (interactive && bash_input.type != st_string && no_line_editing)
! #else
!       if (interactive && bash_input.type != st_string)
! #endif
! 	print_prompt ();
  
!       if (bash_input.type == st_stream)
! 	clearerr (stdin);
  
!       while (1)
! 	{
! 	  c = yy_getc ();
! 
! 	  /* Allow immediate exit if interrupted during input. */
! 	  QUIT;
! 
! 	  if (c == '\0')
! 	    {
! #if 0
! 	      internal_warning ("shell_getc: ignored null byte in input");
  #endif
! 	      continue;
! 	    }
  
! 	  RESIZE_MALLOCED_BUFFER (shell_input_line, i, 2, shell_input_line_size, 256);
  
! 	  if (c == EOF)
! 	    {
! 	      if (bash_input.type == st_stream)
! 		clearerr (stdin);
  
! 	      if (i == 0)
! 		shell_input_line_terminator = EOF;
  
! 	      shell_input_line[i] = '\0';
! 	      break;
! 	    }
  
! 	  shell_input_line[i++] = c;
  
! 	  if (c == '\n')
! 	    {
! 	      shell_input_line[--i] = '\0';
! 	      current_command_line_count++;
! 	      break;
! 	    }
! 	}
  
!       shell_input_line_index = 0;
!       shell_input_line_len = i;		/* == strlen (shell_input_line) */
  
! #if defined (HISTORY)
!       if (remember_on_history && shell_input_line && shell_input_line[0])
! 	{
! 	  char *expansions;
! #  if defined (BANG_HISTORY)
! 	  int old_hist;
  
! 	  /* If the current delimiter is a single quote, we should not be
! 	     performing history expansion, even if we're on a different
! 	     line from the original single quote. */
! 	  old_hist = history_expansion_inhibited;
! 	  if (current_delimiter (dstack) == '\'')
! 	    history_expansion_inhibited = 1;
! #  endif
! 	  expansions = pre_process_line (shell_input_line, 1, 1);
! #  if defined (BANG_HISTORY)
! 	  history_expansion_inhibited = old_hist;
! #  endif
! 	  if (expansions != shell_input_line)
! 	    {
! 	      free (shell_input_line);
! 	      shell_input_line = expansions;
! 	      shell_input_line_len = shell_input_line ?
! 					strlen (shell_input_line) : 0;
! 	      if (!shell_input_line_len)
! 		current_command_line_count--;
  
! 	      /* We have to force the xrealloc below because we don't know
! 		 the true allocated size of shell_input_line anymore. */
! 	      shell_input_line_size = shell_input_line_len;
! 	    }
! 	}
!       /* Try to do something intelligent with blank lines encountered while
! 	 entering multi-line commands.  XXX - this is grotesque */
!       else if (remember_on_history && shell_input_line &&
! 	       shell_input_line[0] == '\0' &&
! 	       current_command_line_count > 1)
  	{
! 	  if (current_delimiter (dstack))
! 	    /* We know shell_input_line[0] == 0 and we're reading some sort of
! 	       quoted string.  This means we've got a line consisting of only
! 	       a newline in a quoted string.  We want to make sure this line
! 	       gets added to the history. */
! 	    maybe_add_history (shell_input_line);
! 	  else
! 	    {
! 	      char *hdcs;
! 	      hdcs = history_delimiting_chars ();
! 	      if (hdcs && hdcs[0] == ';')
! 		maybe_add_history (shell_input_line);
! 	    }
  	}
  
! #endif /* HISTORY */
  
!       if (shell_input_line)
  	{
! 	  /* Lines that signify the end of the shell's input should not be
! 	     echoed. */
! 	  if (echo_input_at_read && (shell_input_line[0] ||
! 				     shell_input_line_terminator != EOF))
! 	    fprintf (stderr, "%s\n", shell_input_line);
! 	}
!       else
! 	{
! 	  shell_input_line_size = 0;
! 	  prompt_string_pointer = &current_prompt_string;
! 	  prompt_again ();
! 	  goto restart_read;
  	}
  
!       /* Add the newline to the end of this string, iff the string does
! 	 not already end in an EOF character.  */
!       if (shell_input_line_terminator != EOF)
! 	{
! 	  if (shell_input_line_len + 3 > shell_input_line_size)
! 	    shell_input_line = xrealloc (shell_input_line,
! 					1 + (shell_input_line_size += 2));
  
! 	  shell_input_line[shell_input_line_len] = '\n';
! 	  shell_input_line[shell_input_line_len + 1] = '\0';
! 	}
!     }
  
!   c = shell_input_line[shell_input_line_index];
  
!   if (c)
!     shell_input_line_index++;
  
!   if (c == '\\' && remove_quoted_newline &&
!       shell_input_line[shell_input_line_index] == '\n')
      {
! 	prompt_again ();
! 	line_number++;
! 	goto restart_read;
      }
! 
! #if defined (ALIAS) || defined (DPAREN_ARITHMETIC)
!   /* If C is NULL, we have reached the end of the current input string.  If
!      pushed_string_list is non-empty, it's time to pop to the previous string
!      because we have fully consumed the result of the last alias expansion.
!      Do it transparently; just return the next character of the string popped
!      to. */
!   if (!c && (pushed_string_list != (STRING_SAVER *)NULL))
      {
!       if (mustpop)
! 	{
! 	  pop_string ();
! 	  c = shell_input_line[shell_input_line_index];
! 	  if (c)
! 	    shell_input_line_index++;
! 	  mustpop--;
! 	}
!       else
! 	{
! 	  mustpop++;
! 	  c = ' ';
! 	}
      }
+ #endif /* ALIAS || DPAREN_ARITHMETIC */
+ 
+   if (!c && shell_input_line_terminator == EOF)
+     return ((shell_input_line_index != 0) ? '\n' : EOF);
+ 
+   return ((unsigned char)c);
  }
  
! /* Put C back into the input for the shell. */
! static void
! shell_ungetc (c)
       int c;
  {
!   if (shell_input_line && shell_input_line_index)
!     shell_input_line[--shell_input_line_index] = c;
!   else
!     eol_ungetc_lookahead = c;
  }
  
! static void
! shell_ungetchar ()
  {
!   if (shell_input_line && shell_input_line_index)
!     shell_input_line_index--;
  }
  
! /* Discard input until CHARACTER is seen, then push that character back
!    onto the input stream. */
! static void
! discard_until (character)
!      int character;
! {
!   int c;
! 
!   while ((c = shell_getc (0)) != EOF && c != character)
!     ;
! 
!   if (c != EOF)
!     shell_ungetc (c);
! }
  
  void
! execute_prompt_command (command)
!      char *command;
  {
!   Function *temp_last, *temp_this;
!   char *last_lastarg;
!   int temp_exit_value, temp_eof_encountered;
  
!   temp_last = last_shell_builtin;
!   temp_this = this_shell_builtin;
!   temp_exit_value = last_command_exit_value;
!   temp_eof_encountered = eof_encountered;
!   last_lastarg = get_string_value ("_");
!   if (last_lastarg)
!     last_lastarg = savestring (last_lastarg);
  
!   parse_and_execute (savestring (command), "PROMPT_COMMAND", SEVAL_NONINT|SEVAL_NOHIST);
  
!   last_shell_builtin = temp_last;
!   this_shell_builtin = temp_this;
!   last_command_exit_value = temp_exit_value;
!   eof_encountered = temp_eof_encountered;
  
!   bind_variable ("_", last_lastarg);
!   FREE (last_lastarg);
! 
!   if (token_to_read == '\n')	/* reset_parser was called */
!     token_to_read = 0;
  }
  
+ /* Place to remember the token.  We try to keep the buffer
+    at a reasonable size, but it can grow. */
+ static char *token = (char *)NULL;
+ 
+ /* Current size of the token buffer. */
+ static int token_buffer_size;
+ 
+ /* Command to read_token () explaining what we want it to do. */
+ #define READ 0
+ #define RESET 1
+ #define prompt_is_ps1 \
+       (!prompt_string_pointer || prompt_string_pointer == &ps1_prompt)
+ 
+ /* Function for yyparse to call.  yylex keeps track of
+    the last two tokens read, and calls read_token.  */
  static int
! yylex ()
  {
!   if (interactive && (current_token == 0 || current_token == '\n'))
!     {
!       /* Before we print a prompt, we might have to check mailboxes.
! 	 We do this only if it is time to do so. Notice that only here
! 	 is the mail alarm reset; nothing takes place in check_mail ()
! 	 except the checking of mail.  Please don't change this. */
!       if (prompt_is_ps1 && time_to_check_mail ())
! 	{
! 	  check_mail ();
! 	  reset_mail_timer ();
! 	}
! 
!       /* Avoid printing a prompt if we're not going to read anything, e.g.
! 	 after resetting the parser with read_token (RESET). */
!       if (token_to_read == 0 && interactive)
! 	prompt_again ();
!     }
! 
!   two_tokens_ago = token_before_that;
!   token_before_that = last_read_token;
!   last_read_token = current_token;
!   current_token = read_token (READ);
!   return (current_token);
  }
  
+ /* When non-zero, we have read the required tokens
+    which allow ESAC to be the next one read. */
+ static int esacs_needed_count;
+ 
  void
! gather_here_documents ()
  {
!   int r = 0;
!   while (need_here_doc)
!     {
!       make_here_document (redir_stack[r++]);
!       need_here_doc--;
!     }
  }
  
! /* When non-zero, an open-brace used to create a group is awaiting a close
!    brace partner. */
! static int open_brace_count;
  
! #define command_token_position(token) \
!   (((token) == ASSIGNMENT_WORD) || \
!    ((token) != SEMI_SEMI && reserved_word_acceptable(token)))
! 
! #define assignment_acceptable(token) command_token_position(token) && \
! 					((parser_state & PST_CASEPAT) == 0)
! 
! /* Check to see if TOKEN is a reserved word and return the token
!    value if it is. */
! #define CHECK_FOR_RESERVED_WORD(tok) \
!   do { \
!     if (!dollar_present && !quoted && \
! 	reserved_word_acceptable (last_read_token)) \
!       { \
! 	int i; \
! 	for (i = 0; word_token_alist[i].word != (char *)NULL; i++) \
! 	  if (STREQ (tok, word_token_alist[i].word)) \
! 	    { \
! 	      if ((parser_state & PST_CASEPAT) && (word_token_alist[i].token != ESAC)) \
! 		break; \
! 	      if (word_token_alist[i].token == TIME) \
! 		break; \
! 	      if (word_token_alist[i].token == ESAC) \
! 		parser_state &= ~(PST_CASEPAT|PST_CASESTMT); \
! 	      else if (word_token_alist[i].token == CASE) \
! 		parser_state |= PST_CASESTMT; \
! 	      else if (word_token_alist[i].token == COND_END) \
! 		parser_state &= ~(PST_CONDCMD|PST_CONDEXPR); \
! 	      else if (word_token_alist[i].token == COND_START) \
! 		parser_state |= PST_CONDCMD; \
! 	      else if (word_token_alist[i].token == '{') \
! 		open_brace_count++; \
! 	      else if (word_token_alist[i].token == '}' && open_brace_count) \
! 		open_brace_count--; \
! 	      return (word_token_alist[i].token); \
! 	    } \
!       } \
!   } while (0)
  
+ #if defined (ALIAS)
+ 
+     /* OK, we have a token.  Let's try to alias expand it, if (and only if)
+        it's eligible.
+ 
+        It is eligible for expansion if the shell is in interactive mode, and
+        the token is unquoted and the last token read was a command
+        separator (or expand_next_token is set), and we are currently
+        processing an alias (pushed_string_list is non-empty) and this
+        token is not the same as the current or any previously
+        processed alias.
+ 
+        Special cases that disqualify:
+ 	 In a pattern list in a case statement (parser_state & PST_CASEPAT). */
  static int
! alias_expand_token (token)
!      char *token;
  {
!   char *expanded;
!   alias_t *ap;
  
!   if (((parser_state & PST_ALEXPNEXT) || command_token_position (last_read_token)) &&
! 	(parser_state & PST_CASEPAT) == 0)
!     {
!       ap = find_alias (token);
  
!       /* Currently expanding this token. */
!       if (ap && (ap->flags & AL_BEINGEXPANDED))
! 	return (NO_EXPANSION);
! 
!       expanded = ap ? savestring (ap->value) : (char *)NULL;
!       if (expanded)
! 	{
! 	  push_string (expanded, ap->flags & AL_EXPANDNEXT, ap);
! 	  return (RE_READ_TOKEN);
! 	}
!       else
! 	/* This is an eligible token that does not have an expansion. */
! 	return (NO_EXPANSION);
!     }
!   return (NO_EXPANSION);
  }
+ #endif /* ALIAS */
  
  static int
! time_command_acceptable ()
  {
! #if defined (COMMAND_TIMING)
!   switch (last_read_token)
!     {
!     case 0:
!     case ';':
!     case '\n':
!     case AND_AND:
!     case OR_OR:
!     case '&':
!     case DO:
!     case THEN:
!     case ELSE:
!     case '{':		/* } */
!     case '(':		/* ) */
!       return 1;
!     default:
!       return 0;
!     }
! #else
!   return 0;
! #endif /* COMMAND_TIMING */
  }
  
! /* Handle special cases of token recognition:
! 	IN is recognized if the last token was WORD and the token
! 	before that was FOR or CASE or SELECT.
  
! 	DO is recognized if the last token was WORD and the token
! 	before that was FOR or SELECT.
  
! 	ESAC is recognized if the last token caused `esacs_needed_count'
! 	to be set
  
! 	`{' is recognized if the last token as WORD and the token
! 	before that was FUNCTION, or if we just parsed an arithmetic
! 	`for' command.
  
! 	`}' is recognized if there is an unclosed `{' present.
  
! 	`-p' is returned as TIMEOPT if the last read token was TIME.
  
! 	']]' is returned as COND_END if the parser is currently parsing
! 	a conditional expression ((parser_state & PST_CONDEXPR) != 0)
  
! 	`time' is returned as TIME if and only if it is immediately
! 	preceded by one of `;', `\n', `||', `&&', or `&'.
! */
  
! static int
! special_case_tokens (token)
!      char *token;
  {
!   if ((last_read_token == WORD) &&
! #if defined (SELECT_COMMAND)
!       ((token_before_that == FOR) || (token_before_that == CASE) || (token_before_that == SELECT)) &&
! #else
!       ((token_before_that == FOR) || (token_before_that == CASE)) &&
! #endif
!       (token[0] == 'i' && token[1] == 'n' && token[2] == 0))
      {
!       if (token_before_that == CASE)
! 	{
! 	  parser_state |= PST_CASEPAT;
! 	  esacs_needed_count++;
! 	}
!       return (IN);
!     }
  
!   if (last_read_token == WORD &&
! #if defined (SELECT_COMMAND)
!       (token_before_that == FOR || token_before_that == SELECT) &&
! #else
!       (token_before_that == FOR) &&
! #endif
!       (token[0] == 'd' && token[1] == 'o' && token[2] == '\0'))
!     return (DO);
  
!   /* Ditto for ESAC in the CASE case.
!      Specifically, this handles "case word in esac", which is a legal
!      construct, certainly because someone will pass an empty arg to the
!      case construct, and we don't want it to barf.  Of course, we should
!      insist that the case construct has at least one pattern in it, but
!      the designers disagree. */
!   if (esacs_needed_count)
!     {
!       esacs_needed_count--;
!       if (STREQ (token, "esac"))
! 	{
! 	  parser_state &= ~PST_CASEPAT;
! 	  return (ESAC);
! 	}
!     }
  
!   /* The start of a shell function definition. */
!   if (parser_state & PST_ALLOWOPNBRC)
!     {
!       parser_state &= ~PST_ALLOWOPNBRC;
!       if (token[0] == '{' && token[1] == '\0')		/* } */
! 	{
! 	  open_brace_count++;
! 	  function_bstart = line_number;
! 	  return ('{');					/* } */
! 	}
!     }
  
!   /* We allow a `do' after a for ((...)) without an intervening
!      list_terminator */
!   if (last_read_token == ARITH_FOR_EXPRS && token[0] == 'd' && token[1] == 'o' && !token[2])
!     return (DO);
!   if (last_read_token == ARITH_FOR_EXPRS && token[0] == '{' && token[1] == '\0')	/* } */
!     {
!       open_brace_count++;
!       return ('{');			/* } */
!     }
  
!   if (open_brace_count && reserved_word_acceptable (last_read_token) && token[0] == '}' && !token[1])
!     {
!       open_brace_count--;		/* { */
!       return ('}');
      }
  
! #if defined (COMMAND_TIMING)
!   /* Handle -p after `time'. */
!   if (last_read_token == TIME && token[0] == '-' && token[1] == 'p' && !token[2])
!     return (TIMEOPT);
! #endif
  
! #if defined (COMMAND_TIMING)
!   if (STREQ (token, "time") && ((parser_state & PST_CASEPAT) == 0) && time_command_acceptable ())
!     return (TIME);
! #endif /* COMMAND_TIMING */
  
! #if defined (COND_COMMAND) /* [[ */
!   if ((parser_state & PST_CONDEXPR) && token[0] == ']' && token[1] == ']' && token[2] == '\0')
!     return (COND_END);
! #endif
  
!   return (-1);
  }
  
+ /* Called from shell.c when Control-C is typed at top level.  Or
+    by the error rule at top level. */
  void
! reset_parser ()
  {
!   dstack.delimiter_depth = 0;	/* No delimiters found so far. */
!   open_brace_count = 0;
  
!   parser_state = 0;
  
  #if defined (ALIAS) || defined (DPAREN_ARITHMETIC)
+   if (pushed_string_list)
+     free_string_list ();
+ #endif /* ALIAS || DPAREN_ARITHMETIC */
  
!   if (shell_input_line)
!     {
!       free (shell_input_line);
!       shell_input_line = (char *)NULL;
!       shell_input_line_size = shell_input_line_index = 0;
!     }
  
!   FREE (word_desc_to_read);
!   word_desc_to_read = (WORD_DESC *)NULL;
  
!   last_read_token = '\n';
!   token_to_read = '\n';
! }
  
! /* Read the next token.  Command can be READ (normal operation) or
!    RESET (to normalize state). */
! static int
! read_token (command)
!      int command;
  {
!   int character;		/* Current character. */
!   int peek_char;		/* Temporary look-ahead character. */
!   int result;			/* The thing to return. */
  
!   if (command == RESET)
!     {
!       reset_parser ();
!       return ('\n');
!     }
  
!   if (token_to_read)
!     {
!       result = token_to_read;
!       if (token_to_read == WORD || token_to_read == ASSIGNMENT_WORD)
! 	{
! 	  yylval.word = word_desc_to_read;
! 	  word_desc_to_read = (WORD_DESC *)NULL;
! 	}
!       token_to_read = 0;
!       return (result);
!     }
  
! #if defined (COND_COMMAND)
!   if ((parser_state & (PST_CONDCMD|PST_CONDEXPR)) == PST_CONDCMD)
!     {
!       cond_lineno = line_number;
!       parser_state |= PST_CONDEXPR;
!       yylval.command = parse_cond_command ();
!       if (cond_token != COND_END)
! 	{
! 	  if (EOF_Reached && cond_token != COND_ERROR)		/* [[ */
! 	    parser_error (cond_lineno, "unexpected EOF while looking for `]]'");
! 	  else if (cond_token != COND_ERROR)
! 	    parser_error (cond_lineno, "syntax error in conditional expression");
! 	  return (-1);
! 	}
!       token_to_read = COND_END;
!       parser_state &= ~(PST_CONDEXPR|PST_CONDCMD);
!       return (COND_CMD);
!     }
! #endif
  
! #if defined (ALIAS)
!   /* This is a place to jump back to once we have successfully expanded a
!      token with an alias and pushed the string with push_string () */
!  re_read_token:
! #endif /* ALIAS */
  
!   /* Read a single word from input.  Start by skipping blanks. */
!   while ((character = shell_getc (1)) != EOF && whitespace (character))
!     ;
  
!   if (character == EOF)
!     {
!       EOF_Reached = 1;
!       return (yacc_EOF);
!     }
  
!   if (character == '#' && (!interactive || interactive_comments))
!     {
!       /* A comment.  Discard until EOL or EOF, and then return a newline. */
!       discard_until ('\n');
!       shell_getc (0);
!       character = '\n';	/* this will take the next if statement and return. */
!     }
  
!   if (character == '\n')
!     {
!       /* If we're about to return an unquoted newline, we can go and collect
! 	 the text of any pending here document. */
!       if (need_here_doc)
! 	gather_here_documents ();
  
! #if defined (ALIAS)
!       parser_state &= ~PST_ALEXPNEXT;
! #endif /* ALIAS */
  
!       return (character);
!     }
  
!   /* Shell meta-characters. */
!   if (shellmeta (character) && ((parser_state & PST_DBLPAREN) == 0))
      {
  #if defined (ALIAS)
!       /* Turn off alias tokenization iff this character sequence would
! 	 not leave us ready to read a command. */
!       if (character == '<' || character == '>')
! 	parser_state &= ~PST_ALEXPNEXT;
! #endif /* ALIAS */
  
!       peek_char = shell_getc (1);
!       if (character == peek_char)
! 	{
! 	  switch (character)
! 	    {
! 	    case '<':
! 	      /* If '<' then we could be at "<<" or at "<<-".  We have to
! 		 look ahead one more character. */
! 	      peek_char = shell_getc (1);
! 	      if (peek_char == '-')
! 		return (LESS_LESS_MINUS);
! 	      else
! 		{
! 		  shell_ungetc (peek_char);
! 		  return (LESS_LESS);
! 		}
  
! 	    case '>':
! 	      return (GREATER_GREATER);
  
! 	    case ';':
! 	      parser_state |= PST_CASEPAT;
! #if defined (ALIAS)
! 	      parser_state &= ~PST_ALEXPNEXT;
! #endif /* ALIAS */
! 	      return (SEMI_SEMI);
  
! 	    case '&':
! 	      return (AND_AND);
  
! 	    case '|':
! 	      return (OR_OR);
  
! #if defined (DPAREN_ARITHMETIC) || defined (ARITH_FOR_COMMAND)
! 	    case '(':		/* ) */
! #  if defined (ARITH_FOR_COMMAND)
! 	      if (last_read_token == FOR)
! 		{
! 		  int cmdtyp, len;
! 		  char *wval, *wv2;
! 		  WORD_DESC *wd;
  
! 		  arith_for_lineno = line_number;
! 		  cmdtyp = parse_arith_cmd (&wval);
! 		  if (cmdtyp == 1)
! 		    {
! 		      /* parse_arith_cmd adds quotes at the beginning and end
! 			 of the string it returns; we need to take those out. */
! 		      len = strlen (wval);
! 		      wv2 = xmalloc (len);
! 		      strncpy (wv2, wval + 1, len - 2);
! 		      wv2[len - 2] = '\0';
! 		      wd = make_word (wv2);
! 		      yylval.word_list = make_word_list (wd, (WORD_LIST *)NULL);
! 		      free (wval);
! 		      free (wv2);
! 		      return (ARITH_FOR_EXPRS);
! 		    }
! 		  else
! 		    return -1;		/* ERROR */
! 		}
! #  endif
! #  if defined (DPAREN_ARITHMETIC)
! 	      if (reserved_word_acceptable (last_read_token))
! 		{
! 		  int cmdtyp, sline;
! 		  char *wval;
! 		  WORD_DESC *wd;
! 
! 		  sline = line_number;
! 		  cmdtyp = parse_arith_cmd (&wval);
! 		  if (cmdtyp == 1)	/* arithmetic command */
! 		    {
! 		      wd = make_word (wval);
! 		      wd->flags = W_QUOTED;
! 		      yylval.word_list = make_word_list (wd, (WORD_LIST *)NULL);
! 		      free (wval);	/* make_word copies it */
! 		      return (ARITH_CMD);
! 		    }
! 		  else if (cmdtyp == 0)	/* nested subshell */
! 		    {
! 		      push_string (wval, 0, (alias_t *)NULL);
! 		      if ((parser_state & PST_CASEPAT) == 0)
! 			parser_state |= PST_SUBSHELL;
! 		      return (character);
! 		    }
! 		  else			/* ERROR */
! 		    return -1;
! 		}
! 	      break;
! #  endif
! #endif
! 	    }
  	}
+       else if (character == '<' && peek_char == '&')
+ 	return (LESS_AND);
+       else if (character == '>' && peek_char == '&')
+ 	return (GREATER_AND);
+       else if (character == '<' && peek_char == '>')
+ 	return (LESS_GREATER);
+       else if (character == '>' && peek_char == '|')
+ 	return (GREATER_BAR);
+       else if (peek_char == '>' && character == '&')
+ 	return (AND_GREATER);
  
!       shell_ungetc (peek_char);
  
!       /* If we look like we are reading the start of a function
! 	 definition, then let the reader know about it so that
! 	 we will do the right thing with `{'. */
!       if (character == ')' && last_read_token == '(' && token_before_that == WORD)
  	{
! 	  parser_state |= PST_ALLOWOPNBRC;
! #if defined (ALIAS)
! 	  parser_state &= ~PST_ALEXPNEXT;
! #endif /* ALIAS */
! 	  function_dstart = line_number;
  	}
  
!       /* case pattern lists may be preceded by an optional left paren.  If
! 	 we're not trying to parse a case pattern list, the left paren
! 	 indicates a subshell. */
!       if (character == '(' && (parser_state & PST_CASEPAT) == 0) /* ) */
! 	parser_state |= PST_SUBSHELL;
!       /*(*/
!       else if ((parser_state & PST_CASEPAT) && character == ')')
! 	parser_state &= ~PST_CASEPAT;
!       /*(*/
!       else if ((parser_state & PST_SUBSHELL) && character == ')')
! 	parser_state &= ~PST_SUBSHELL;
  
! #if defined (PROCESS_SUBSTITUTION)
!       /* Check for the constructs which introduce process substitution.
! 	 Shells running in `posix mode' don't do process substitution. */
!       if (posixly_correct ||
! 	  ((character != '>' && character != '<') || peek_char != '('))
! #endif /* PROCESS_SUBSTITUTION */
! 	return (character);
!     }
  
!   /* Hack <&- (close stdin) case. */
!   if (character == '-' && (last_read_token == LESS_AND || last_read_token == GREATER_AND))
!     return (character);
  
!   /* Okay, if we got this far, we have to read a word.  Read one,
!      and then check it against the known ones. */
!   result = read_token_word (character);
! #if defined (ALIAS)
!   if (result == RE_READ_TOKEN)
!     goto re_read_token;
  #endif
!   return result;
! }
  
! /* Match a $(...) or other grouping construct.  This has to handle embedded
!    quoted strings ('', ``, "") and nested constructs.  It also must handle
!    reprompting the user, if necessary, after reading a newline, and returning
!    correct error values if it reads EOF. */
  
! #define P_FIRSTCLOSE	0x01
! #define P_ALLOWESC	0x02
  
! static char matched_pair_error;
! static char *
! parse_matched_pair (qc, open, close, lenp, flags)
!      int qc;	/* `"' if this construct is within double quotes */
!      int open, close;
!      int *lenp, flags;
  {
!   int count, ch, was_dollar;
!   int pass_next_character, nestlen, ttranslen, start_lineno;
!   char *ret, *nestret, *ttrans;
!   int retind, retsize;
  
!   count = 1;
!   pass_next_character = was_dollar = 0;
  
!   ret = xmalloc (retsize = 64);
!   retind = 0;
  
!   start_lineno = line_number;
!   while (count)
      {
!       ch = shell_getc ((qc != '\'' || (flags & P_ALLOWESC)) && pass_next_character == 0);
!       if (ch == EOF)
! 	{
! 	  free (ret);
! 	  parser_error (start_lineno, "unexpected EOF while looking for matching `%c'", close);
! 	  EOF_Reached = 1;	/* XXX */
! 	  return (&matched_pair_error);
! 	}
  
!       /* Possible reprompting. */
!       if (ch == '\n' && interactive &&
! 	    (bash_input.type == st_stdin || bash_input.type == st_stream))
! 	prompt_again ();
  
!       if (pass_next_character)		/* last char was backslash */
! 	{
! 	  pass_next_character = 0;
! 	  if (qc != '\'' && ch == '\n')	/* double-quoted \<newline> disappears. */
! 	    {
! 	      if (retind > 0) retind--;	/* swallow previously-added backslash */
! 	      continue;
! 	    }
  
! 	  RESIZE_MALLOCED_BUFFER (ret, retind, 2, retsize, 64);
! 	  if (ch == CTLESC || ch == CTLNUL)
! 	    ret[retind++] = CTLESC;
! 	  ret[retind++] = ch;
! 	  continue;
! 	}
!       else if (ch == CTLESC || ch == CTLNUL)	/* special shell escapes */
! 	{
! 	  RESIZE_MALLOCED_BUFFER (ret, retind, 2, retsize, 64);
! 	  ret[retind++] = CTLESC;
! 	  ret[retind++] = ch;
! 	  continue;
! 	}
!       else if (ch == close)		/* ending delimiter */
! 	count--;
! #if 1
!       /* handle nested ${...} specially. */
!       else if (open != close && was_dollar && open == '{' && ch == open) /* } */
! 	count++;
  #endif
!       else if (((flags & P_FIRSTCLOSE) == 0) && ch == open)		/* nested begin */
! 	count++;
  
!       /* Add this character. */
!       RESIZE_MALLOCED_BUFFER (ret, retind, 1, retsize, 64);
!       ret[retind++] = ch;
  
!       if (open == '\'')			/* '' inside grouping construct */
  	{
! 	  if ((flags & P_ALLOWESC) && ch == '\\')
! 	    pass_next_character++;
! 	  continue;
! 	}
  
!       if (ch == '\\')			/* backslashes */
! 	pass_next_character++;
  
!       if (open != close)		/* a grouping construct */
! 	{
! 	  if (shellquote (ch))
  	    {
! 	      /* '', ``, or "" inside $(...) or other grouping construct. */
! 	      push_delimiter (dstack, ch);
! 	      if (was_dollar && ch == '\'')	/* $'...' inside group */
! 		nestret = parse_matched_pair (ch, ch, ch, &nestlen, P_ALLOWESC);
! 	      else
! 		nestret = parse_matched_pair (ch, ch, ch, &nestlen, 0);
! 	      pop_delimiter (dstack);
! 	      if (nestret == &matched_pair_error)
! 		{
! 		  free (ret);
! 		  return &matched_pair_error;
! 		}
! 	      if (was_dollar && ch == '\'')
! 		{
! 		  /* Translate $'...' here. */
! 		  ttrans = ansiexpand (nestret, 0, nestlen - 1, &ttranslen);
! 		  free (nestret);
! 		  nestret = sh_single_quote (ttrans);
! 		  free (ttrans);
! 		  nestlen = strlen (nestret);
! 		  retind -= 2;		/* back up before the $' */
! 		}
! 	      else if (was_dollar && ch == '"')
! 		{
! 		  /* Locale expand $"..." here. */
! 		  ttrans = localeexpand (nestret, 0, nestlen - 1, start_lineno, &ttranslen);
! 		  free (nestret);
! 		  nestret = xmalloc (ttranslen + 3);
! 		  nestret[0] = '"';
! 		  strcpy (nestret + 1, ttrans);
! 		  nestret[ttranslen + 1] = '"';
! 		  nestret[ttranslen += 2] = '\0';
! 		  free (ttrans);
! 		  nestlen = ttranslen;
! 		  retind -= 2;		/* back up before the $" */
! 		}
! 	      if (nestlen)
! 		{
! 		  RESIZE_MALLOCED_BUFFER (ret, retind, nestlen, retsize, 64);
! 		  strcpy (ret + retind, nestret);
! 		  retind += nestlen;
! 		}
! 	      FREE (nestret);
  	    }
  	}
!       /* Parse an old-style command substitution within double quotes as a
! 	 single word. */
!       /* XXX - sh and ksh93 don't do this - XXX */
!       else if (open == '"' && ch == '`')
  	{
! 	  nestret = parse_matched_pair (0, '`', '`', &nestlen, 0);
! 	  if (nestret == &matched_pair_error)
  	    {
! 	      free (ret);
! 	      return &matched_pair_error;
  	    }
+ 	  if (nestlen)
+ 	    {
+ 	      RESIZE_MALLOCED_BUFFER (ret, retind, nestlen, retsize, 64);
+ 	      strcpy (ret + retind, nestret);
+ 	      retind += nestlen;
+ 	    }
+ 	  FREE (nestret);
  	}
!       else if (was_dollar && (ch == '(' || ch == '{' || ch == '['))	/* ) } ] */
! 	/* check for $(), $[], or ${} inside quoted string. */
  	{
! 	  if (open == ch)	/* undo previous increment */
! 	    count--;
! 	  if (ch == '(')		/* ) */
! 	    nestret = parse_matched_pair (0, '(', ')', &nestlen, 0);
! 	  else if (ch == '{')		/* } */
! 	    nestret = parse_matched_pair (0, '{', '}', &nestlen, P_FIRSTCLOSE);
! 	  else if (ch == '[')		/* ] */
! 	    nestret = parse_matched_pair (0, '[', ']', &nestlen, 0);
! 	  if (nestret == &matched_pair_error)
! 	    {
! 	      free (ret);
! 	      return &matched_pair_error;
! 	    }
! 	  if (nestlen)
! 	    {
! 	      RESIZE_MALLOCED_BUFFER (ret, retind, nestlen, retsize, 64);
! 	      strcpy (ret + retind, nestret);
! 	      retind += nestlen;
! 	    }
! 	  FREE (nestret);
  	}
+       was_dollar = (ch == '$');
+     }
  
!   ret[retind] = '\0';
!   if (lenp)
!     *lenp = retind;
!   return ret;
! }
  
! #if defined (DPAREN_ARITHMETIC) || defined (ARITH_FOR_COMMAND)
! /* We've seen a `(('.  Look for the matching `))'.  If we get it, return 1.
!    If not, assume it's a nested subshell for backwards compatibility and
!    return 0.  In any case, put the characters we've consumed into a locally-
!    allocated buffer and make *ep point to that buffer.  Return -1 on an
!    error, for example EOF. */
! static int
! parse_arith_cmd (ep)
!      char **ep;
! {
!   int exp_lineno, rval, c;
!   char *ttok, *token;
!   int ttoklen;
  
!   exp_lineno = line_number;
!   ttok = parse_matched_pair (0, '(', ')', &ttoklen, 0);
!   rval = 1;
!   if (ttok == &matched_pair_error)
!     return -1;
!   /* Check that the next character is the closing right paren.  If
!      not, this is a syntax error. ( */
!   if ((c = shell_getc (0)) != ')')
!     rval = 0;
  
!   token = xmalloc (ttoklen + 4);
  
!   /* (( ... )) -> "..." */
!   token[0] = (rval == 1) ? '"' : '(';
!   strncpy (token + 1, ttok, ttoklen - 1);	/* don't copy the final `)' */
!   if (rval == 1)
      {
!       token[ttoklen] = '"';
!       token[ttoklen+1] = '\0';
      }
!   else
      {
!       token[ttoklen] = ')';
!       token[ttoklen+1] = c;
!       token[ttoklen+2] = '\0';
      }
!   *ep = token;
!   FREE (ttok);
!   return rval;
  }
+ #endif /* DPAREN_ARITHMETIC || ARITH_FOR_COMMAND */
  
! #if defined (COND_COMMAND)
! static COND_COM *cond_term ();
! static COND_COM *cond_and ();
! static COND_COM *cond_or ();
! static COND_COM *cond_expr ();
  
! static COND_COM *
! cond_expr ()
  {
!   return (cond_or ());  
  }
  
! static COND_COM *
! cond_or ()
  {
!   COND_COM *l, *r;
  
!   l = cond_and ();
!   if (cond_token == OR_OR)
!     {
!       r = cond_or ();
!       l = make_cond_node (COND_OR, (WORD_DESC *)NULL, l, r);
!     }
!   return l;
  }
  
! static COND_COM *
! cond_and ()
  {
!   COND_COM *l, *r;
  
!   l = cond_term ();
!   if (cond_token == AND_AND)
!     {
!       r = cond_and ();
!       l = make_cond_node (COND_AND, (WORD_DESC *)NULL, l, r);
!     }
!   return l;
  }
  
  static int
! cond_skip_newlines ()
  {
!   while ((cond_token = read_token (READ)) == '\n')
      {
!       if (interactive && (bash_input.type == st_stdin || bash_input.type == st_stream))
  	prompt_again ();
      }
!   return (cond_token);
  }
  
! #define COND_RETURN_ERROR() \
!   do { cond_token = COND_ERROR; return ((COND_COM *)NULL); } while (0)
  
! static COND_COM *
! cond_term ()
  {
!   WORD_DESC *op;
!   COND_COM *term, *tleft, *tright;
!   int tok, lineno;
! 
!   /* Read a token.  It can be a left paren, a `!', a unary operator, or a
!      word that should be the first argument of a binary operator.  Start by
!      skipping newlines, since this is a compound command. */
!   tok = cond_skip_newlines ();
!   lineno = line_number;
!   if (tok == COND_END)
      {
!       COND_RETURN_ERROR ();
      }
!   else if (tok == '(')
!     {
!       term = cond_expr ();
!       if (cond_token != ')')
! 	{
! 	  if (term)
! 	    dispose_cond_node (term);		/* ( */
! 	  parser_error (lineno, "expected `)'");
! 	  COND_RETURN_ERROR ();
! 	}
!       term = make_cond_node (COND_EXPR, (WORD_DESC *)NULL, term, (COND_COM *)NULL);
!       (void)cond_skip_newlines ();
!     }
!   else if (tok == BANG || (tok == WORD && (yylval.word->word[0] == '!' && yylval.word->word[1] == '\0')))
!     {
!       if (tok == WORD)
! 	dispose_word (yylval.word);	/* not needed */
!       term = cond_term ();
!       if (term)
! 	term->flags |= CMD_INVERT_RETURN;
!     }
!   else if (tok == WORD && test_unop (yylval.word->word))
!     {
!       op = yylval.word;
!       tok = read_token (READ);
!       if (tok == WORD)
! 	{
! 	  tleft = make_cond_node (COND_TERM, yylval.word, (COND_COM *)NULL, (COND_COM *)NULL);
! 	  term = make_cond_node (COND_UNARY, op, tleft, (COND_COM *)NULL);
! 	}
!       else
! 	{
! 	  dispose_word (op);
! 	  parser_error (line_number, "unexpected argument to conditional unary operator");
! 	  COND_RETURN_ERROR ();
! 	}
  
!       (void)cond_skip_newlines ();
!     }
!   else if (tok == WORD)		/* left argument to binary operator */
!     {
!       /* lhs */
!       tleft = make_cond_node (COND_TERM, yylval.word, (COND_COM *)NULL, (COND_COM *)NULL);
  
!       /* binop */
!       tok = read_token (READ);
!       if (tok == WORD && test_binop (yylval.word->word))
! 	op = yylval.word;
!       else if (tok == '<' || tok == '>')
! 	op = make_word_from_token (tok);  /* ( */
!       /* There should be a check before blindly accepting the `)' that we have
! 	 seen the opening `('. */
!       else if (tok == COND_END || tok == AND_AND || tok == OR_OR || tok == ')')
! 	{
! 	  /* Special case.  [[ x ]] is equivalent to [[ -n x ]], just like
! 	     the test command.  Similarly for [[ x && expr ]] or
! 	     [[ x || expr ]] or [[ (x) ]]. */
! 	  op = make_word ("-n");
! 	  term = make_cond_node (COND_UNARY, op, tleft, (COND_COM *)NULL);
! 	  cond_token = tok;
! 	  return (term);
! 	}
!       else
! 	{
! 	  parser_error (line_number, "conditional binary operator expected");
! 	  dispose_cond_node (tleft);
! 	  COND_RETURN_ERROR ();
! 	}
  
!       /* rhs */
!       tok = read_token (READ);
!       if (tok == WORD)
! 	{
! 	  tright = make_cond_node (COND_TERM, yylval.word, (COND_COM *)NULL, (COND_COM *)NULL);
! 	  term = make_cond_node (COND_BINARY, op, tleft, tright);
! 	}
!       else
! 	{
! 	  parser_error (line_number, "unexpected argument to conditional binary operator");
! 	  dispose_cond_node (tleft);
! 	  dispose_word (op);
! 	  COND_RETURN_ERROR ();
! 	}
  
!       (void)cond_skip_newlines ();
!     }
!   else
!     {
!       if (tok < 256)
! 	parser_error (line_number, "unexpected token `%c' in conditional command", tok);
!       else
! 	parser_error (line_number, "unexpected token %d in conditional command", tok);
!       COND_RETURN_ERROR ();
!     }
!   return (term);
! }      
  
! /* This is kind of bogus -- we slip a mini recursive-descent parser in
!    here to handle the conditional statement syntax. */
! static COMMAND *
! parse_cond_command ()
! {
!   COND_COM *cexp;
  
!   cexp = cond_expr ();
!   return (make_cond_command (cexp));
! }
! #endif
  
  static int
! read_token_word (character)
!      int character;
  {
!   /* The value for YYLVAL when a WORD is read. */
!   WORD_DESC *the_word;
  
!   /* Index into the token that we are building. */
!   int token_index;
  
!   /* ALL_DIGITS becomes zero when we see a non-digit. */
!   int all_digits;
  
!   /* DOLLAR_PRESENT becomes non-zero if we see a `$'. */
!   int dollar_present;
  
!   /* QUOTED becomes non-zero if we see one of ("), ('), (`), or (\). */
!   int quoted;
  
!   /* Non-zero means to ignore the value of the next character, and just
!      to add it no matter what. */
!  int pass_next_character;
  
!   /* The current delimiting character. */
!   int cd;
!   int result, peek_char;
!   char *ttok, *ttrans;
!   int ttoklen, ttranslen;
  
!   if (token_buffer_size < TOKEN_DEFAULT_INITIAL_SIZE)
!     token = xrealloc (token, token_buffer_size = TOKEN_DEFAULT_INITIAL_SIZE);
  
!   token_index = 0;
!   all_digits = isdigit (character);
!   dollar_present = quoted = pass_next_character = 0;
  
!   for (;;)
      {
!       if (character == EOF)
! 	goto got_token;
  
!       if (pass_next_character)
  	{
! 	  pass_next_character = 0;
! 	  goto got_character;
  	}
  
!       cd = current_delimiter (dstack);
  
!       /* Handle backslashes.  Quote lots of things when not inside of
! 	 double-quotes, quote some things inside of double-quotes. */
!       if (character == '\\')
! 	{
! 	  peek_char = shell_getc (0);
  
! 	  /* Backslash-newline is ignored in all cases except
! 	     when quoted with single quotes. */
! 	  if (peek_char == '\n')
! 	    {
! 	      character = '\n';
! 	      goto next_character;
! 	    }
! 	  else
! 	    {
! 	      shell_ungetc (peek_char);
  
! 	      /* If the next character is to be quoted, note it now. */
! 	      if (cd == 0 || cd == '`' ||
! 		  (cd == '"' && (sh_syntaxtab[peek_char] & CBSDQUOTE)))
! 		pass_next_character++;
  
! 	      quoted = 1;
! 	      goto got_character;
! 	    }
! 	}
  
!       /* Parse a matched pair of quote characters. */
!       if (shellquote (character))
  	{
! 	  push_delimiter (dstack, character);
! 	  ttok = parse_matched_pair (character, character, character, &ttoklen, 0);
! 	  pop_delimiter (dstack);
! 	  if (ttok == &matched_pair_error)
! 	    return -1;		/* Bail immediately. */
! 	  RESIZE_MALLOCED_BUFFER (token, token_index, ttoklen + 2,
! 				  token_buffer_size, TOKEN_DEFAULT_GROW_SIZE);
! 	  token[token_index++] = character;
! 	  strcpy (token + token_index, ttok);
! 	  token_index += ttoklen;
! 	  all_digits = 0;
! 	  quoted = 1;
! 	  dollar_present |= (character == '"' && strchr (ttok, '$') != 0);
! 	  FREE (ttok);
! 	  goto next_character;
  	}
  
! #ifdef EXTENDED_GLOB
!       /* Parse a ksh-style extended pattern matching specification. */
!       if (extended_glob && PATTERN_CHAR (character))
  	{
! 	  peek_char = shell_getc (1);
! 	  if (peek_char == '(')		/* ) */
! 	    {
! 	      push_delimiter (dstack, peek_char);
! 	      ttok = parse_matched_pair (cd, '(', ')', &ttoklen, 0);
! 	      pop_delimiter (dstack);
! 	      if (ttok == &matched_pair_error)
! 		return -1;		/* Bail immediately. */
! 	      RESIZE_MALLOCED_BUFFER (token, token_index, ttoklen + 2,
! 				      token_buffer_size,
! 				      TOKEN_DEFAULT_GROW_SIZE);
! 	      token[token_index++] = character;
! 	      token[token_index++] = peek_char;
! 	      strcpy (token + token_index, ttok);
! 	      token_index += ttoklen;
! 	      FREE (ttok);
! 	      dollar_present = all_digits = 0;
! 	      goto next_character;
! 	    }
! 	  else
! 	    shell_ungetc (peek_char);
  	}
! #endif /* EXTENDED_GLOB */
  
!       /* If the delimiter character is not single quote, parse some of
! 	 the shell expansions that must be read as a single word. */
!       if (shellexp (character))
! 	{
! 	  peek_char = shell_getc (1);
! 	  /* $(...), <(...), >(...), $((...)), ${...}, and $[...] constructs */
! 	  if (peek_char == '(' ||
! 		((peek_char == '{' || peek_char == '[') && character == '$'))	/* ) ] } */
! 	    {
! 	      if (peek_char == '{')		/* } */
! 		ttok = parse_matched_pair (cd, '{', '}', &ttoklen, P_FIRSTCLOSE);
! 	      else if (peek_char == '(')		/* ) */
! 		{
! 		  /* XXX - push and pop the `(' as a delimiter for use by
! 		     the command-oriented-history code.  This way newlines
! 		     appearing in the $(...) string get added to the
! 		     history literally rather than causing a possibly-
! 		     incorrect `;' to be added. ) */
! 		  push_delimiter (dstack, peek_char);
! 		  ttok = parse_matched_pair (cd, '(', ')', &ttoklen, 0);
! 		  pop_delimiter (dstack);
! 		}
! 	      else
! 		ttok = parse_matched_pair (cd, '[', ']', &ttoklen, 0);
! 	      if (ttok == &matched_pair_error)
! 		return -1;		/* Bail immediately. */
! 	      RESIZE_MALLOCED_BUFFER (token, token_index, ttoklen + 2,
! 				      token_buffer_size,
! 				      TOKEN_DEFAULT_GROW_SIZE);
! 	      token[token_index++] = character;
! 	      token[token_index++] = peek_char;
! 	      strcpy (token + token_index, ttok);
! 	      token_index += ttoklen;
! 	      FREE (ttok);
! 	      dollar_present = 1;
! 	      all_digits = 0;
! 	      goto next_character;
! 	    }
! 	  /* This handles $'...' and $"..." new-style quoted strings. */
! 	  else if (character == '$' && (peek_char == '\'' || peek_char == '"'))
! 	    {
! 	      int first_line;
  
! 	      first_line = line_number;
! 	      push_delimiter (dstack, peek_char);
! 	      ttok = parse_matched_pair (peek_char, peek_char, peek_char,
! 					 &ttoklen,
! 					 (peek_char == '\'') ? P_ALLOWESC : 0);
! 	      pop_delimiter (dstack);
! 	      if (ttok == &matched_pair_error)
! 		return -1;
! 	      if (peek_char == '\'')
! 		{
! 		  ttrans = ansiexpand (ttok, 0, ttoklen - 1, &ttranslen);
! 		  free (ttok);
! 		  /* Insert the single quotes and correctly quote any
! 		     embedded single quotes (allowed because P_ALLOWESC was
! 		     passed to parse_matched_pair). */
! 		  ttok = sh_single_quote (ttrans);
! 		  free (ttrans);
! 		  ttrans = ttok;
! 		  ttranslen = strlen (ttrans);
! 		}
! 	      else
! 		{
! 		  /* Try to locale-expand the converted string. */
! 		  ttrans = localeexpand (ttok, 0, ttoklen - 1, first_line, &ttranslen);
! 		  free (ttok);
  
! 		  /* Add the double quotes back */
! 		  ttok = xmalloc (ttranslen + 3);
! 		  ttok[0] = '"';
! 		  strcpy (ttok + 1, ttrans);
! 		  ttok[ttranslen + 1] = '"';
! 		  ttok[ttranslen += 2] = '\0';
! 		  free (ttrans);
! 		  ttrans = ttok;
! 		}
  
! 	      RESIZE_MALLOCED_BUFFER (token, token_index, ttranslen + 2,
! 				      token_buffer_size,
! 				      TOKEN_DEFAULT_GROW_SIZE);
! 	      strcpy (token + token_index, ttrans);
! 	      token_index += ttranslen;
! 	      FREE (ttrans);
! 	      quoted = 1;
! 	      all_digits = 0;
! 	      goto next_character;
! 	    }
! 	  /* This could eventually be extended to recognize all of the
! 	     shell's single-character parameter expansions, and set flags.*/
! 	  else if (character == '$' && peek_char == '$')
! 	    {
! 	      ttok = xmalloc (3);
! 	      ttok[0] = ttok[1] = '$';
! 	      ttok[2] = '\0';
! 	      RESIZE_MALLOCED_BUFFER (token, token_index, 3,
! 				      token_buffer_size,
! 				      TOKEN_DEFAULT_GROW_SIZE);
! 	      strcpy (token + token_index, ttok);
! 	      token_index += 2;
! 	      dollar_present = 1;
! 	      all_digits = 0;
! 	      FREE (ttok);
! 	      goto next_character;
! 	    }
! 	  else
! 	    shell_ungetc (peek_char);
! 	}
  
! #if defined (ARRAY_VARS)
!       /* Identify possible compound array variable assignment. */
!       else if (character == '=' && token_index > 0)
  	{
! 	  peek_char = shell_getc (1);
! 	  if (peek_char == '(')		/* ) */
  	    {
! 	      ttok = parse_matched_pair (cd, '(', ')', &ttoklen, 0);
! 	      if (ttok == &matched_pair_error)
! 		return -1;		/* Bail immediately. */
! 	      if (ttok[0] == '(')	/* ) */
  		{
! 		  FREE (ttok);
! 		  return -1;
  		}
+ 	      RESIZE_MALLOCED_BUFFER (token, token_index, ttoklen + 2,
+ 				      token_buffer_size,
+ 				      TOKEN_DEFAULT_GROW_SIZE);
+ 	      token[token_index++] = character;
+ 	      token[token_index++] = peek_char;
+ 	      strcpy (token + token_index, ttok);
+ 	      token_index += ttoklen;
+ 	      FREE (ttok);
+ 	      all_digits = 0;
+ 	      goto next_character;
+ 	    }
+ 	  else
+ 	    shell_ungetc (peek_char);
+ 	}
+ #endif
  
!       /* When not parsing a multi-character word construct, shell meta-
! 	 characters break words. */
!       if (shellbreak (character))
! 	{
! 	  shell_ungetc (character);
! 	  goto got_token;
! 	}
  
!     got_character:
  
!       all_digits &= isdigit (character);
!       dollar_present |= character == '$';
  
!       if (character == CTLESC || character == CTLNUL)
! 	token[token_index++] = CTLESC;
  
!       token[token_index++] = character;
  
!       RESIZE_MALLOCED_BUFFER (token, token_index, 1, token_buffer_size,
! 			      TOKEN_DEFAULT_GROW_SIZE);
  
!     next_character:
!       if (character == '\n' && interactive &&
! 	(bash_input.type == st_stdin || bash_input.type == st_stream))
! 	prompt_again ();
  
!       /* We want to remove quoted newlines (that is, a \<newline> pair)
! 	 unless we are within single quotes or pass_next_character is
! 	 set (the shell equivalent of literal-next). */
!       cd = current_delimiter (dstack);
!       character = shell_getc (cd != '\'' && pass_next_character == 0);
!     }	/* end for (;;) */
  
! got_token:
  
!   token[token_index] = '\0';
  
!   /* Check to see what thing we should return.  If the last_read_token
!      is a `<', or a `&', or the character which ended this token is
!      a '>' or '<', then, and ONLY then, is this input token a NUMBER.
!      Otherwise, it is just a word, and should be returned as such. */
!   if (all_digits && (character == '<' || character == '>' ||
! 		    last_read_token == LESS_AND ||
! 		    last_read_token == GREATER_AND))
!       {
! 	yylval.number = atoi (token);
! 	return (NUMBER);
!       }
  
!   /* Check for special case tokens. */
!   result = special_case_tokens (token);
!   if (result >= 0)
!     return result;
  
  #if defined (ALIAS)
!   /* Posix.2 does not allow reserved words to be aliased, so check for all
!      of them, including special cases, before expanding the current token
!      as an alias. */
!   if (posixly_correct)
!     CHECK_FOR_RESERVED_WORD (token);
! 
!   /* Aliases are expanded iff EXPAND_ALIASES is non-zero, and quoting
!      inhibits alias expansion. */
!   if (expand_aliases && quoted == 0)
!     {
!       result = alias_expand_token (token);
!       if (result == RE_READ_TOKEN)
! 	return (RE_READ_TOKEN);
!       else if (result == NO_EXPANSION)
! 	parser_state &= ~PST_ALEXPNEXT;
!     }
! 
!   /* If not in Posix.2 mode, check for reserved words after alias
!      expansion. */
!   if (posixly_correct == 0)
  #endif
!     CHECK_FOR_RESERVED_WORD (token);
  
!   the_word = (WORD_DESC *)xmalloc (sizeof (WORD_DESC));
!   the_word->word = xmalloc (1 + token_index);
!   the_word->flags = 0;
!   strcpy (the_word->word, token);
!   if (dollar_present)
!     the_word->flags |= W_HASDOLLAR;
!   if (quoted)
!     the_word->flags |= W_QUOTED;
!   /* A word is an assignment if it appears at the beginning of a
!      simple command, or after another assignment word.  This is
!      context-dependent, so it cannot be handled in the grammar. */
!   if (assignment (token))
!     {
!       the_word->flags |= W_ASSIGNMENT;
!       /* Don't perform word splitting on assignment statements. */
!       if (assignment_acceptable (last_read_token))
! 	the_word->flags |= W_NOSPLIT;
!     }
  
!   yylval.word = the_word;
  
!   result = ((the_word->flags & (W_ASSIGNMENT|W_NOSPLIT)) == (W_ASSIGNMENT|W_NOSPLIT))
! 		? ASSIGNMENT_WORD : WORD;
! 
!   if (last_read_token == FUNCTION)
!     {
!       parser_state |= PST_ALLOWOPNBRC;
!       function_dstart = line_number;
!     }
! 
!   return (result);
! }
! 
! /* $'...' ANSI-C expand the portion of STRING between START and END and
!    return the result.  The result cannot be longer than the input string. */
  static char *
! ansiexpand (string, start, end, lenp)
!      char *string;
!      int start, end, *lenp;
  {
!   char *temp, *t;
!   int len, tlen;
  
!   temp = xmalloc (end - start + 1);
!   for (tlen = 0, len = start; len < end; )
!     temp[tlen++] = string[len++];
!   temp[tlen] = '\0';
  
!   if (*temp)
!     {
!       t = ansicstr (temp, tlen, 0, (int *)NULL, lenp);
!       free (temp);
!       return (t);
!     }
!   else
!     {
!       if (lenp)
! 	*lenp = 0;
!       return (temp);
!     }
! }
  
! /* Change a bash string into a string suitable for inclusion in a `po' file.
!    This backslash-escapes `"' and `\' and changes newlines into \\\n"\n". */
! static char *
! mk_msgstr (string, foundnlp)
!      char *string;
!      int *foundnlp;
! {
!   register int c, len;
!   char *result, *r, *s;
! 
!   for (len = 0, s = string; s && *s; s++)
      {
!       len++;
!       if (*s == '"' || *s == '\\')
! 	len++;
!       else if (*s == '\n')
! 	len += 5;
!     }
!   
!   r = result = xmalloc (len + 3);
!   *r++ = '"';
! 
!   for (s = string; s && (c = *s); s++)
!     {
!       if (c == '\n')	/* <NL> -> \n"<NL>" */
  	{
! 	  *r++ = '\\';
! 	  *r++ = 'n';
! 	  *r++ = '"';
! 	  *r++ = '\n';
! 	  *r++ = '"';
! 	  if (foundnlp)
! 	    *foundnlp = 1;
! 	  continue;
  	}
+       if (c == '"' || c == '\\')
+ 	*r++ = '\\';
+       *r++ = c;
+     }
  
!   *r++ = '"';
!   *r++ = '\0';
  
!   return result;
! }
  
! /* $"..." -- Translate the portion of STRING between START and END
!    according to current locale using gettext (if available) and return
!    the result.  The caller will take care of leaving the quotes intact.
!    The string will be left without the leading `$' by the caller.
!    If translation is performed, the translated string will be double-quoted
!    by the caller.  The length of the translated string is returned in LENP,
!    if non-null. */
! static char *
! localeexpand (string, start, end, lineno, lenp)
!      char *string;
!      int start, end, lineno, *lenp;
! {
!   int len, tlen, foundnl;
!   char *temp, *t, *t2;
  
!   temp = xmalloc (end - start + 1);
!   for (tlen = 0, len = start; len < end; )
!     temp[tlen++] = string[len++];
!   temp[tlen] = '\0';
  
!   /* If we're just dumping translatable strings, don't do anything with the
!      string itself, but if we're dumping in `po' file format, convert it into a form more palatable to gettext(3)
!      and friends by quoting `"' and `\' with backslashes and converting <NL>
!      into `\n"<NL>"'.  If we find a newline in TEMP, we first output a
!      `msgid ""' line and then the translated string; otherwise we output the
!      `msgid' and translated string all on one line. */
!   if (dump_translatable_strings)
!     {
!       if (dump_po_strings)
  	{
! 	  foundnl = 0;
! 	  t = mk_msgstr (temp, &foundnl);
! 	  t2 = foundnl ? "\"\"\n" : "";
  
! 	  printf ("#: %s:%d\nmsgid %s%s\nmsgstr \"\"\n",
! 		  (bash_input.name ? bash_input.name : "stdin"), lineno, t2, t);
! 	  free (t);
  	}
!       else
! 	printf ("\"%s\"\n", temp);
  
!       if (lenp)
! 	*lenp = tlen;
!       return (temp);
!     }
!   else if (*temp)
      {
!       t = localetrans (temp, tlen, &len);
!       free (temp);
!       if (lenp)
! 	*lenp = len;
!       return (t);
      }
    else
      {
!       if (lenp)
! 	*lenp = 0;
!       return (temp);
      }
  }
  
! /* Return 1 if TOKEN is a token that after being read would allow
!    a reserved word to be seen, else 0. */
! static int
! reserved_word_acceptable (token)
!      int token;
  {
!   if (token == '\n' || token == ';' || token == '(' || token == ')' ||
!       token == '|' || token == '&' || token == '{' ||
!       token == '}' ||			/* XXX */
!       token == AND_AND ||
!       token == BANG ||
!       token == TIME || token == TIMEOPT ||
!       token == DO ||
!       token == ELIF ||
!       token == ELSE ||
!       token == FI ||
!       token == IF ||
!       token == OR_OR ||
!       token == SEMI_SEMI ||
!       token == THEN ||
!       token == UNTIL ||
!       token == WHILE ||
!       token == DONE ||		/* XXX these two are experimental */
!       token == ESAC ||
!       token == 0)
!     return (1);
!   else
!     return (0);
  }
  
! /* Return the index of TOKEN in the alist of reserved words, or -1 if
!    TOKEN is not a shell reserved word. */
! int
! find_reserved_word (token)
!      char *token;
  {
!   int i;
!   for (i = 0; word_token_alist[i].word; i++)
!     if (STREQ (token, word_token_alist[i].word))
!       return i;
!   return -1;
! }
  
! #if 0
! #if defined (READLINE)
! /* Called after each time readline is called.  This insures that whatever
!    the new prompt string is gets propagated to readline's local prompt
!    variable. */
! static void
! reset_readline_prompt ()
  {
!   char *temp_prompt;
  
!   if (prompt_string_pointer)
      {
!       temp_prompt = (*prompt_string_pointer)
! 			? decode_prompt_string (*prompt_string_pointer)
! 			: (char *)NULL;
  
!       if (temp_prompt == 0)
! 	{
! 	  temp_prompt = xmalloc (1);
! 	  temp_prompt[0] = '\0';
! 	}
! 
!       FREE (current_readline_prompt);
!       current_readline_prompt = temp_prompt;
      }
  }
+ #endif /* READLINE */
+ #endif /* 0 */
  
! #if defined (HISTORY)
! /* A list of tokens which can be followed by newlines, but not by
!    semi-colons.  When concatenating multiple lines of history, the
!    newline separator for such tokens is replaced with a space. */
! static int no_semi_successors[] = {
!   '\n', '{', '(', ')', ';', '&', '|',
!   CASE, DO, ELSE, IF, SEMI_SEMI, THEN, UNTIL, WHILE, AND_AND, OR_OR, IN,
!   0
! };
  
! /* If we are not within a delimited expression, try to be smart
!    about which separators can be semi-colons and which must be
!    newlines.  Returns the string that should be added into the
!    history entry. */
! char *
! history_delimiting_chars ()
  {
!   register int i;
  
!   if (dstack.delimiter_depth != 0)
!     return ("\n");
!     
!   /* First, handle some special cases. */
!   /*(*/
!   /* If we just read `()', assume it's a function definition, and don't
!      add a semicolon.  If the token before the `)' was not `(', and we're
!      not in the midst of parsing a case statement, assume it's a
!      parenthesized command and add the semicolon. */
!   /*)(*/
!   if (token_before_that == ')')
      {
!       if (two_tokens_ago == '(')	/*)*/	/* function def */
! 	return " ";
!       /* This does not work for subshells inside case statement
! 	 command lists.  It's a suboptimal solution. */
!       else if (parser_state & PST_CASESTMT)	/* case statement pattern */
! 	return " ";
!       else	
! 	return "; ";				/* (...) subshell */
      }
!   else if (token_before_that == WORD && two_tokens_ago == FUNCTION)
!     return " ";		/* function def using `function name' without `()' */
! 
!   else if (token_before_that == WORD && two_tokens_ago == FOR)
      {
!       /* Tricky.  `for i\nin ...' should not have a semicolon, but
! 	 `for i\ndo ...' should.  We do what we can. */
!       for (i = shell_input_line_index; whitespace(shell_input_line[i]); i++)
! 	;
!       if (shell_input_line[i] && shell_input_line[i] == 'i' && shell_input_line[i+1] == 'n')
! 	return " ";
!       return ";";
      }
! 
!   for (i = 0; no_semi_successors[i]; i++)
      {
!       if (token_before_that == no_semi_successors[i])
! 	return (" ");
      }
  
!   return ("; ");
! }
! #endif /* HISTORY */
  
! /* Issue a prompt, or prepare to issue a prompt when the next character
!    is read. */
! static void
! prompt_again ()
! {
!   char *temp_prompt;
  
!   if (!interactive)	/* XXX */
!     return;
  
!   ps1_prompt = get_string_value ("PS1");
!   ps2_prompt = get_string_value ("PS2");
! 
!   if (!prompt_string_pointer)
!     prompt_string_pointer = &ps1_prompt;
! 
!   temp_prompt = *prompt_string_pointer
! 			? decode_prompt_string (*prompt_string_pointer)
! 			: (char *)NULL;
! 
!   if (temp_prompt == 0)
!     {
!       temp_prompt = xmalloc (1);
!       temp_prompt[0] = '\0';
!     }
! 
!   current_prompt_string = *prompt_string_pointer;
!   prompt_string_pointer = &ps2_prompt;
! 
! #if defined (READLINE)
!   if (!no_line_editing)
!     {
!       FREE (current_readline_prompt);
!       current_readline_prompt = temp_prompt;
      }
    else
+ #endif	/* READLINE */
      {
!       FREE (current_decoded_prompt);
!       current_decoded_prompt = temp_prompt;
      }
! }
  
! int
! get_current_prompt_level ()
  {
!   return ((current_prompt_string && current_prompt_string == ps2_prompt) ? 2 : 1);
  }
  
! void
! set_current_prompt_level (x)
!      int x;
  {
!   prompt_string_pointer = (x == 2) ? &ps2_prompt : &ps1_prompt;
!   current_prompt_string = *prompt_string_pointer;
! }
!       
! static void
! print_prompt ()
! {
!   fprintf (stderr, "%s", current_decoded_prompt);
!   fflush (stderr);
! }
  
! /* Return a string which will be printed as a prompt.  The string
!    may contain special characters which are decoded as follows:
  
! 	\a	bell (ascii 07)
! 	\e	escape (ascii 033)
! 	\d	the date in Day Mon Date format
! 	\h	the hostname up to the first `.'
! 	\H	the hostname
! 	\j	the number of active jobs
! 	\l	the basename of the shell's tty device name
! 	\n	CRLF
! 	\s	the name of the shell
! 	\t	the time in 24-hour hh:mm:ss format
! 	\T	the time in 12-hour hh:mm:ss format
! 	\@	the time in 12-hour am/pm format
! 	\v	the version of bash (e.g., 2.00)
! 	\V	the release of bash, version + patchlevel (e.g., 2.00.0)
! 	\w	the current working directory
! 	\W	the last element of $PWD
! 	\u	your username
! 	\#	the command number of this command
! 	\!	the history number of this command
! 	\$	a $ or a # if you are root
! 	\nnn	character code nnn in octal
! 	\\	a backslash
! 	\[	begin a sequence of non-printing chars
! 	\]	end a sequence of non-printing chars
! */
! #define PROMPT_GROWTH 48
! char *
! decode_prompt_string (string)
!      char *string;
! {
!   WORD_LIST *list;
!   char *result, *t;
!   struct dstack save_dstack;
! #if defined (PROMPT_STRING_DECODE)
!   int result_size, result_index;
!   int c, n;
!   char *temp, octal_string[4];
!   time_t the_time;
  
!   result = xmalloc (result_size = PROMPT_GROWTH);
!   result[result_index = 0] = 0;
!   temp = (char *)NULL;
  
!   while (c = *string++)
      {
!       if (posixly_correct && c == '!')
  	{
! 	  if (*string == '!')
  	    {
! 	      temp = savestring ("!");
! 	      goto add_string;
  	    }
  	  else
  	    {
! #if !defined (HISTORY)
! 		temp = savestring ("1");
! #else /* HISTORY */
! 		temp = itos (history_number ());
! #endif /* HISTORY */
! 		string--;	/* add_string increments string again. */
! 		goto add_string;
  	    }
  	}
!       if (c == '\\')
  	{
! 	  c = *string;
  
! 	  switch (c)
  	    {
! 	    case '0':
! 	    case '1':
! 	    case '2':
! 	    case '3':
! 	    case '4':
! 	    case '5':
! 	    case '6':
! 	    case '7':
! 	      strncpy (octal_string, string, 3);
! 	      octal_string[3] = '\0';
  
! 	      n = read_octal (octal_string);
! 	      temp = xmalloc (3);
! 
! 	      if (n == CTLESC || n == CTLNUL)
  		{
! 		  temp[0] = CTLESC;
! 		  temp[1] = n;
! 		  temp[2] = '\0';
  		}
! 	      else if (n == -1)
  		{
! 		  temp[0] = '\\';
! 		  temp[1] = '\0';
  		}
  	      else
  		{
! 		  temp[0] = n;
! 		  temp[1] = '\0';
  		}
  
! 	      for (c = 0; n != -1 && c < 3 && ISOCTAL (*string); c++)
! 		string++;
  
! 	      c = 0;
! 	      goto add_string;
  
! 	    case 't':
! 	    case 'd':
! 	    case 'T':
! 	    case '@':
! 	      /* Make the current time/date into a string. */
! 	      the_time = time (0);
! 	      temp = ctime (&the_time);
  
! 	      temp = (c != 'd') ? savestring (temp + 11) : savestring (temp);
! 	      temp[(c != 'd') ? 8 : 10] = '\0';
  
! 	      /* quick and dirty conversion to 12-hour time */
! 	      if (c == 'T' || c == '@')
! 		{
! 		  if (c == '@')
! 		    {
! 		      temp[5] = 'a';	/* am/pm format */
! 		      temp[6] = 'm';
! 		      temp[7] = '\0';
! 		    }
! 		  c = temp[2];
! 		  temp[2] = '\0';
! 		  n = atoi (temp);
! 		  temp[2] = c;
! 		  n -= 12;
! 		  if (n > 0)
! 		    {
! 		      temp[0] = (n / 10) + '0';
! 		      temp[1] = (n % 10) + '0';
! 		    }
! 		  if (n >= 0 && temp[5] == 'a')
! 		    temp[5] = 'p';
! 		}
! 	      goto add_string;
  
! 	    case 'r':
! 	      temp = xmalloc (2);
! 	      temp[0] = '\r';
! 	      temp[1] = '\0';
! 	      goto add_string;
  
! 	    case 'n':
! 	      temp = xmalloc (3);
! 	      temp[0] = no_line_editing ? '\n' : '\r';
! 	      temp[1] = no_line_editing ? '\0' : '\n';
! 	      temp[2] = '\0';
! 	      goto add_string;
  
! 	    case 's':
! 	      temp = base_pathname (shell_name);
! 	      temp = savestring (temp);
! 	      goto add_string;
  
! 	    case 'v':
! 	    case 'V':
! 	      temp = xmalloc (8);
! 	      if (c == 'v')
! 		strcpy (temp, dist_version);
! 	      else
! 		sprintf (temp, "%s.%d", dist_version, patch_level);
! 	      goto add_string;
  
! 	    case 'w':
! 	    case 'W':
! 	      {
! 		/* Use the value of PWD because it is much more efficient. */
! 		char t_string[PATH_MAX];
! 		int tlen;
  
! 		temp = get_string_value ("PWD");
  
! 		if (temp == 0)
! 		  {
! 		    if (getcwd (t_string, sizeof(t_string)) == 0)
! 		      {
! 			t_string[0] = '.';
! 			tlen = 1;
! 		      }
! 		    else
! 		      tlen = strlen (t_string);
! 		  }
! 		else
! 		  {
! 		    tlen = sizeof (t_string) - 1;
! 		    strncpy (t_string, temp, tlen);
! 		  }
! 		t_string[tlen] = '\0';
  
! #define ROOT_PATH(x)	((x)[0] == '/' && (x)[1] == 0)
! #define DOUBLE_SLASH_ROOT(x)	((x)[0] == '/' && (x)[1] == '/' && (x)[2] == 0)
! 		if (c == 'W')
! 		  {
! 		    if (ROOT_PATH (t_string) == 0 && DOUBLE_SLASH_ROOT (t_string) == 0)
! 		      {
! 			t = strrchr (t_string, '/');
! 			if (t)
! 			  strcpy (t_string, t + 1);
! 		      }
! 		  }
! #undef ROOT_PATH
! #undef DOUBLE_SLASH_ROOT
! 		else
! 		  /* polite_directory_format is guaranteed to return a string
! 		     no longer than PATH_MAX - 1 characters. */
! 		  strcpy (t_string, polite_directory_format (t_string));
  
! 		/* If we're going to be expanding the prompt string later,
! 		   quote the directory name. */
! 		if (promptvars || posixly_correct)
! 		  /* Make sure that expand_prompt_string is called with a
! 		     second argument of Q_DOUBLE_QUOTE if we use this
! 		     function here. */
! 		  temp = sh_backslash_quote_for_double_quotes (t_string);
! 		else
! 		  temp = savestring (t_string);
  
! 		goto add_string;
! 	      }
  
! 	    case 'u':
! 	      if (current_user.user_name == 0)
! 		get_current_user_info ();
! 	      temp = savestring (current_user.user_name);
! 	      goto add_string;
  
! 	    case 'h':
! 	    case 'H':
! 	      temp = savestring (current_host_name);
! 	      if (c == 'h' && (t = (char *)strchr (temp, '.')))
! 		*t = '\0';
! 	      goto add_string;
  
! 	    case '#':
! 	      temp = itos (current_command_number);
! 	      goto add_string;
  
! 	    case '!':
! #if !defined (HISTORY)
! 	      temp = savestring ("1");
! #else /* HISTORY */
! 	      temp = itos (history_number ());
! #endif /* HISTORY */
! 	      goto add_string;
  
! 	    case '$':
! 	      t = temp = xmalloc (3);
! 	      if ((promptvars || posixly_correct) && (current_user.euid != 0))
! 		*t++ = '\\';
! 	      *t++ = current_user.euid == 0 ? '#' : '$';
! 	      *t = '\0';
! 	      goto add_string;
  
! 	    case 'j':
! 	      temp = itos (count_all_jobs ());
! 	      goto add_string;
  
! 	    case 'l':
! #if defined (HAVE_TTYNAME)
! 	      temp = (char *)ttyname (fileno (stdin));
! 	      t = temp ? base_pathname (temp) : "tty";
! 	      temp = savestring (t);
! #else
! 	      temp = savestring ("tty");
! #endif /* !HAVE_TTYNAME */
! 	      goto add_string;
  
! #if defined (READLINE)
! 	    case '[':
! 	    case ']':
! 	      temp = xmalloc (3);
! 	      temp[0] = '\001';
! 	      temp[1] = (c == '[') ? RL_PROMPT_START_IGNORE : RL_PROMPT_END_IGNORE;
! 	      temp[2] = '\0';
! 	      goto add_string;
! #endif /* READLINE */
  
! 	    case '\\':
! 	      temp = xmalloc (2);
! 	      temp[0] = c;
! 	      temp[1] = '\0';
! 	      goto add_string;
  
! 	    case 'a':
! 	    case 'e':
! 	      temp = xmalloc (2);
! 	      temp[0] = (c == 'a') ? '\07' : '\033';
! 	      temp[1] = '\0';
! 	      goto add_string;
! 
! 	    default:
! 	      temp = xmalloc (3);
! 	      temp[0] = '\\';
! 	      temp[1] = c;
! 	      temp[2] = '\0';
! 
! 	    add_string:
! 	      if (c)
! 		string++;
! 	      result =
! 		sub_append_string (temp, result, &result_index, &result_size);
! 	      temp = (char *)NULL; /* Freed in sub_append_string (). */
! 	      result[result_index] = '\0';
! 	      break;
! 	    }
! 	}
!       else
! 	{
! 	  RESIZE_MALLOCED_BUFFER (result, result_index, 3, result_size, PROMPT_GROWTH);
! 	  result[result_index++] = c;
! 	  result[result_index] = '\0';
! 	}
!     }
! #else /* !PROMPT_STRING_DECODE */
!   result = savestring (string);
! #endif /* !PROMPT_STRING_DECODE */
! 
!   /* Save the delimiter stack and point `dstack' to temp space so any
!      command substitutions in the prompt string won't result in screwing
!      up the parser's quoting state. */
!   save_dstack = dstack;
!   dstack = temp_dstack;
!   dstack.delimiter_depth = 0;
! 
!   /* Perform variable and parameter expansion and command substitution on
!      the prompt string. */
!   if (promptvars || posixly_correct)
      {
!       list = expand_prompt_string (result, Q_DOUBLE_QUOTES);
!       free (result);
!       result = string_list (list);
!       dispose_words (list);
      }
    else
      {
!       t = dequote_string (result);
!       free (result);
!       result = t;
      }
+ 
+   dstack = save_dstack;
+ 
+   return (result);
  }
  
! /* Report a syntax error, and restart the parser.  Call here for fatal
!    errors. */
! int
! yyerror ()
  {
!   report_syntax_error ((char *)NULL);
!   reset_parser ();
!   return (0);
! }
  
! /* Report a syntax error with line numbers, etc.
!    Call here for recoverable errors.  If you have a message to print,
!    then place it in MESSAGE, otherwise pass NULL and this will figure
!    out an appropriate message for you. */
! static void
! report_syntax_error (message)
!      char *message;
! {
!   char *msg, *t;
!   int token_end, i;
!   char msg2[2];
! 
!   if (message)
      {
!       parser_error (line_number, "%s", message);
!       if (interactive && EOF_Reached)
! 	EOF_Reached = 0;
!       last_command_exit_value = EX_USAGE;
!       return;
      }
  
!   /* If the line of input we're reading is not null, try to find the
!      objectionable token. */
!   if (shell_input_line && *shell_input_line)
      {
!       t = shell_input_line;
!       i = shell_input_line_index;
!       token_end = 0;
  
!       if (i && t[i] == '\0')
! 	i--;
  
!       while (i && (whitespace (t[i]) || t[i] == '\n'))
! 	i--;
  
!       if (i)
! 	token_end = i + 1;
  
!       while (i && (member (t[i], " \n\t;|&") == 0))
! 	i--;
  
!       while (i != token_end && (whitespace (t[i]) || t[i] == '\n'))
! 	i++;
! 
!       /* Print the offending token. */
!       if (token_end || (i == 0 && token_end == 0))
  	{
! 	  if (token_end)
! 	    msg = substring (t, i, token_end);
! 	  else	/* one-character token */
! 	    {
! 	      msg2[0] = t[i];
! 	      msg2[1] = '\0';
! 	      msg = msg2;
! 	    }
  
! 	  parser_error (line_number, "syntax error near unexpected token `%s'", msg);
! 
! 	  if (msg != msg2)
! 	    free (msg);
  	}
  
!       /* If not interactive, print the line containing the error. */
!       if (interactive == 0)
! 	{
! 	  msg = savestring (shell_input_line);
! 	  token_end = strlen (msg);
! 	  while (token_end && msg[token_end - 1] == '\n')
! 	    msg[--token_end] = '\0';
! 
! 	  parser_error (line_number, "`%s'", msg);
! 	  free (msg);
! 	}
      }
    else
      {
!       msg = EOF_Reached ? "syntax error: unexpected end of file" : "syntax error";
!       parser_error (line_number, "%s", msg);
!       /* When the shell is interactive, this file uses EOF_Reached
! 	 only for error reporting.  Other mechanisms are used to
! 	 decide whether or not to exit. */
!       if (interactive && EOF_Reached)
! 	EOF_Reached = 0;
      }
+   last_command_exit_value = EX_USAGE;
  }
  
! /* ??? Needed function. ??? We have to be able to discard the constructs
!    created during parsing.  In the case of error, we want to return
!    allocated objects to the memory pool.  In the case of no error, we want
!    to throw away the information about where the allocated objects live.
!    (dispose_command () will actually free the command. */
! static void
! discard_parser_constructs (error_p)
!      int error_p;
  {
  }
  
! /* Do that silly `type "bye" to exit' stuff.  You know, "ignoreeof". */
  
! /* A flag denoting whether or not ignoreeof is set. */
! int ignoreeof = 0;
! 
! /* The number of times that we have encountered an EOF character without
!    another character intervening.  When this gets above the limit, the
!    shell terminates. */
! int eof_encountered = 0;
! 
! /* The limit for eof_encountered. */
! int eof_encountered_limit = 10;
! 
! /* If we have EOF as the only input unit, this user wants to leave
!    the shell.  If the shell is not interactive, then just leave.
!    Otherwise, if ignoreeof is set, and we haven't done this the
!    required number of times in a row, print a message. */
  static void
! handle_eof_input_unit ()
  {
!   if (interactive)
      {
!       /* shell.c may use this to decide whether or not to write out the
! 	 history, among other things.  We use it only for error reporting
! 	 in this file. */
!       if (EOF_Reached)
! 	EOF_Reached = 0;
  
!       /* If the user wants to "ignore" eof, then let her do so, kind of. */
!       if (ignoreeof)
  	{
! 	  if (eof_encountered < eof_encountered_limit)
! 	    {
! 	      fprintf (stderr, "Use \"%s\" to leave the shell.\n",
! 		       login_shell ? "logout" : "exit");
! 	      eof_encountered++;
! 	      /* Reset the prompt string to be $PS1. */
! 	      prompt_string_pointer = (char **)NULL;
! 	      prompt_again ();
! 	      last_read_token = current_token = '\n';
! 	      return;
! 	    }
  	}
  
!       /* In this case EOF should exit the shell.  Do it now. */
!       reset_parser ();
!       exit_builtin ((WORD_LIST *)NULL);
!     }
!   else
!     {
!       /* We don't write history files, etc., for non-interactive shells. */
!       EOF_Reached = 1;
      }
  }
  
! static WORD_LIST parse_string_error;
  
! /* Take a string and run it through the shell parser, returning the
!    resultant word list.  Used by compound array assignment. */
! WORD_LIST *
! parse_string_to_word_list (s, whom)
!      char *s, *whom;
  {
!   WORD_LIST *wl;
!   int tok, orig_line_number, orig_input_terminator;
!   int orig_line_count;
! #if defined (HISTORY)
!   int old_remember_on_history, old_history_expansion_inhibited;
! #endif
  
! #if defined (HISTORY)
!   old_remember_on_history = remember_on_history;
! #  if defined (BANG_HISTORY)
!   old_history_expansion_inhibited = history_expansion_inhibited;
! #  endif
!   bash_history_disable ();
! #endif
  
!   orig_line_number = line_number;
!   orig_line_count = current_command_line_count;
!   orig_input_terminator = shell_input_line_terminator;
! 
!   push_stream (1);
!   last_read_token = '\n';
!   current_command_line_count = 0;
! 
!   with_input_from_string (s, whom);
!   wl = (WORD_LIST *)NULL;
!   while ((tok = read_token (READ)) != yacc_EOF)
      {
!       if (tok == '\n' && *bash_input.location.string == '\0')
! 	break;
!       if (tok == '\n')		/* Allow newlines in compound assignments */
! 	continue;
!       if (tok != WORD && tok != ASSIGNMENT_WORD)
! 	{
! 	  line_number = orig_line_number + line_number - 1;
! 	  yyerror ();	/* does the right thing */
! 	  if (wl)
! 	    dispose_words (wl);
! 	  wl = &parse_string_error;
! 	  break;
! 	}
!       wl = make_word_list (yylval.word, wl);
      }
+   
+   last_read_token = '\n';
+   pop_stream ();
  
! #if defined (HISTORY)
!   remember_on_history = old_remember_on_history;
! #  if defined (BANG_HISTORY)
!   history_expansion_inhibited = old_history_expansion_inhibited;
! #  endif /* BANG_HISTORY */
! #endif /* HISTORY */
! 
!   current_command_line_count = orig_line_count;
!   shell_input_line_terminator = orig_input_terminator;
! 
!   if (wl == &parse_string_error)
      {
!       last_command_exit_value = EXECUTION_FAILURE;
!       if (interactive_shell == 0 && posixly_correct)
! 	jump_to_top_level (FORCE_EOF);
!       else
! 	jump_to_top_level (DISCARD);
      }
  
!   return (REVERSE_LIST (wl, WORD_LIST *));
  }
! #line 4199 "y.tab.c"
! /* allocate initial stack or double stack size, up to YYMAXDEPTH */
! static int yygrowstack()
! {
!     int newsize, i;
!     short *newss;
!     YYSTYPE *newvs;
! 
!     if ((newsize = yystacksize) == 0)
!         newsize = YYINITSTACKSIZE;
!     else if (newsize >= YYMAXDEPTH)
!         return -1;
!     else if ((newsize *= 2) > YYMAXDEPTH)
!         newsize = YYMAXDEPTH;
!     i = yyssp - yyss;
!     newss = yyss ? (short *)realloc(yyss, newsize * sizeof *newss) :
!       (short *)malloc(newsize * sizeof *newss);
!     if (newss == NULL)
!         return -1;
!     yyss = newss;
!     yyssp = newss + i;
!     newvs = yyvs ? (YYSTYPE *)realloc(yyvs, newsize * sizeof *newvs) :
!       (YYSTYPE *)malloc(newsize * sizeof *newvs);
!     if (newvs == NULL)
!         return -1;
!     yyvs = newvs;
!     yyvsp = newvs + i;
!     yystacksize = newsize;
!     yysslim = yyss + newsize - 1;
!     return 0;
! }
! 
! #define YYABORT goto yyabort
! #define YYREJECT goto yyabort
! #define YYACCEPT goto yyaccept
! #define YYERROR goto yyerrlab
! 
! #ifndef YYPARSE_PARAM
! #if defined(__cplusplus) || __STDC__
! #define YYPARSE_PARAM_ARG void
! #define YYPARSE_PARAM_DECL
! #else	/* ! ANSI-C/C++ */
! #define YYPARSE_PARAM_ARG
! #define YYPARSE_PARAM_DECL
! #endif	/* ANSI-C/C++ */
! #else	/* YYPARSE_PARAM */
! #ifndef YYPARSE_PARAM_TYPE
! #define YYPARSE_PARAM_TYPE void *
! #endif
! #if defined(__cplusplus) || __STDC__
! #define YYPARSE_PARAM_ARG YYPARSE_PARAM_TYPE YYPARSE_PARAM
! #define YYPARSE_PARAM_DECL
! #else	/* ! ANSI-C/C++ */
! #define YYPARSE_PARAM_ARG YYPARSE_PARAM
! #define YYPARSE_PARAM_DECL YYPARSE_PARAM_TYPE YYPARSE_PARAM;
! #endif	/* ANSI-C/C++ */
! #endif	/* ! YYPARSE_PARAM */
  
! int
! yyparse (YYPARSE_PARAM_ARG)
!     YYPARSE_PARAM_DECL
  {
!     register int yym, yyn, yystate;
! #if YYDEBUG
!     register const char *yys;
  
!     if ((yys = getenv("YYDEBUG")))
!     {
!         yyn = *yys;
!         if (yyn >= '0' && yyn <= '9')
!             yydebug = yyn - '0';
!     }
! #endif
  
!     yynerrs = 0;
!     yyerrflag = 0;
!     yychar = (-1);
  
!     if (yyss == NULL && yygrowstack()) goto yyoverflow;
!     yyssp = yyss;
!     yyvsp = yyvs;
!     *yyssp = yystate = 0;
  
! yyloop:
!     if ((yyn = yydefred[yystate])) goto yyreduce;
!     if (yychar < 0)
      {
!         if ((yychar = yylex()) < 0) yychar = 0;
! #if YYDEBUG
!         if (yydebug)
!         {
!             yys = 0;
!             if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
!             if (!yys) yys = "illegal-symbol";
!             printf("%sdebug: state %d, reading %d (%s)\n",
!                     YYPREFIX, yystate, yychar, yys);
!         }
! #endif
      }
!     if ((yyn = yysindex[yystate]) && (yyn += yychar) >= 0 &&
!             yyn <= YYTABLESIZE && yycheck[yyn] == yychar)
      {
! #if YYDEBUG
!         if (yydebug)
!             printf("%sdebug: state %d, shifting to state %d\n",
!                     YYPREFIX, yystate, yytable[yyn]);
! #endif
!         if (yyssp >= yysslim && yygrowstack())
!         {
!             goto yyoverflow;
!         }
!         *++yyssp = yystate = yytable[yyn];
!         *++yyvsp = yylval;
!         yychar = (-1);
!         if (yyerrflag > 0)  --yyerrflag;
!         goto yyloop;
!     }
!     if ((yyn = yyrindex[yystate]) && (yyn += yychar) >= 0 &&
!             yyn <= YYTABLESIZE && yycheck[yyn] == yychar)
!     {
!         yyn = yytable[yyn];
!         goto yyreduce;
!     }
!     if (yyerrflag) goto yyinrecovery;
! #if defined(lint) || defined(__GNUC__)
!     goto yynewerror;
! #endif
! yynewerror:
!     yyerror("syntax error");
! #if defined(lint) || defined(__GNUC__)
!     goto yyerrlab;
! #endif
! yyerrlab:
!     ++yynerrs;
! yyinrecovery:
!     if (yyerrflag < 3)
!     {
!         yyerrflag = 3;
!         for (;;)
!         {
!             if ((yyn = yysindex[*yyssp]) && (yyn += YYERRCODE) >= 0 &&
!                     yyn <= YYTABLESIZE && yycheck[yyn] == YYERRCODE)
!             {
! #if YYDEBUG
!                 if (yydebug)
!                     printf("%sdebug: state %d, error recovery shifting\
!  to state %d\n", YYPREFIX, *yyssp, yytable[yyn]);
! #endif
!                 if (yyssp >= yysslim && yygrowstack())
!                 {
!                     goto yyoverflow;
!                 }
!                 *++yyssp = yystate = yytable[yyn];
!                 *++yyvsp = yylval;
!                 goto yyloop;
!             }
!             else
!             {
! #if YYDEBUG
!                 if (yydebug)
!                     printf("%sdebug: error recovery discarding state %d\n",
!                             YYPREFIX, *yyssp);
! #endif
!                 if (yyssp <= yyss) goto yyabort;
!                 --yyssp;
!                 --yyvsp;
!             }
!         }
      }
!     else
      {
!         if (yychar == 0) goto yyabort;
! #if YYDEBUG
!         if (yydebug)
!         {
!             yys = 0;
!             if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
!             if (!yys) yys = "illegal-symbol";
!             printf("%sdebug: state %d, error recovery discards token %d (%s)\n",
!                     YYPREFIX, yystate, yychar, yys);
!         }
! #endif
!         yychar = (-1);
!         goto yyloop;
      }
! yyreduce:
! #if YYDEBUG
!     if (yydebug)
!         printf("%sdebug: state %d, reducing by rule %d (%s)\n",
!                 YYPREFIX, yystate, yyn, yyrule[yyn]);
! #endif
!     yym = yylen[yyn];
!     yyval = yyvsp[1-yym];
!     switch (yyn)
!     {
! case 1:
! #line 241 "/usr/homes/chet/src/bash/src/parse.y"
  {
! 			  /* Case of regular command.  Discard the error
! 			     safety net,and return the command just parsed. */
! 			  global_command = yyvsp[-1].command;
! 			  eof_encountered = 0;
! 			  discard_parser_constructs (0);
! 			  YYACCEPT;
! 			}
! break;
! case 2:
! #line 250 "/usr/homes/chet/src/bash/src/parse.y"
  {
! 			  /* Case of regular command, but not a very
! 			     interesting one.  Return a NULL command. */
! 			  global_command = (COMMAND *)NULL;
! 			  YYACCEPT;
! 			}
! break;
! case 3:
! #line 257 "/usr/homes/chet/src/bash/src/parse.y"
  {
! 			  /* Error during parsing.  Return NULL command. */
! 			  global_command = (COMMAND *)NULL;
! 			  eof_encountered = 0;
! 			  discard_parser_constructs (1);
! 			  if (interactive)
! 			    {
! 			      YYACCEPT;
! 			    }
! 			  else
! 			    {
! 			      YYABORT;
! 			    }
! 			}
! break;
! case 4:
! #line 272 "/usr/homes/chet/src/bash/src/parse.y"
  {
! 			  /* Case of EOF seen by itself.  Do ignoreeof or
! 			     not. */
! 			  global_command = (COMMAND *)NULL;
! 			  handle_eof_input_unit ();
! 			  YYACCEPT;
! 			}
! break;
! case 5:
! #line 282 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.word_list = make_word_list (yyvsp[0].word, (WORD_LIST *)NULL); }
! break;
! case 6:
! #line 284 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.word_list = make_word_list (yyvsp[0].word, yyvsp[-1].word_list); }
! break;
! case 7:
! #line 288 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  redir.filename = yyvsp[0].word;
! 			  yyval.redirect = make_redirection (1, r_output_direction, redir);
! 			}
! break;
! case 8:
! #line 293 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  redir.filename = yyvsp[0].word;
! 			  yyval.redirect = make_redirection (0, r_input_direction, redir);
! 			}
! break;
! case 9:
! #line 298 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  redir.filename = yyvsp[0].word;
! 			  yyval.redirect = make_redirection (yyvsp[-2].number, r_output_direction, redir);
! 			}
! break;
! case 10:
! #line 303 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  redir.filename = yyvsp[0].word;
! 			  yyval.redirect = make_redirection (yyvsp[-2].number, r_input_direction, redir);
! 			}
! break;
! case 11:
! #line 308 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  redir.filename = yyvsp[0].word;
! 			  yyval.redirect = make_redirection (1, r_appending_to, redir);
! 			}
! break;
! case 12:
! #line 313 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  redir.filename = yyvsp[0].word;
! 			  yyval.redirect = make_redirection (yyvsp[-2].number, r_appending_to, redir);
! 			}
! break;
! case 13:
! #line 318 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  redir.filename = yyvsp[0].word;
! 			  yyval.redirect = make_redirection (0, r_reading_until, redir);
! 			  redir_stack[need_here_doc++] = yyval.redirect;
! 			}
! break;
! case 14:
! #line 324 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  redir.filename = yyvsp[0].word;
! 			  yyval.redirect = make_redirection (yyvsp[-2].number, r_reading_until, redir);
! 			  redir_stack[need_here_doc++] = yyval.redirect;
! 			}
! break;
! case 15:
! #line 330 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  redir.dest = yyvsp[0].number;
! 			  yyval.redirect = make_redirection (0, r_duplicating_input, redir);
! 			}
! break;
! case 16:
! #line 335 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  redir.dest = yyvsp[0].number;
! 			  yyval.redirect = make_redirection (yyvsp[-2].number, r_duplicating_input, redir);
! 			}
! break;
! case 17:
! #line 340 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  redir.dest = yyvsp[0].number;
! 			  yyval.redirect = make_redirection (1, r_duplicating_output, redir);
! 			}
! break;
! case 18:
! #line 345 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  redir.dest = yyvsp[0].number;
! 			  yyval.redirect = make_redirection (yyvsp[-2].number, r_duplicating_output, redir);
! 			}
! break;
! case 19:
! #line 350 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  redir.filename = yyvsp[0].word;
! 			  yyval.redirect = make_redirection (0, r_duplicating_input_word, redir);
! 			}
! break;
! case 20:
! #line 355 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  redir.filename = yyvsp[0].word;
! 			  yyval.redirect = make_redirection (yyvsp[-2].number, r_duplicating_input_word, redir);
! 			}
! break;
! case 21:
! #line 360 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  redir.filename = yyvsp[0].word;
! 			  yyval.redirect = make_redirection (1, r_duplicating_output_word, redir);
! 			}
! break;
! case 22:
! #line 365 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  redir.filename = yyvsp[0].word;
! 			  yyval.redirect = make_redirection (yyvsp[-2].number, r_duplicating_output_word, redir);
! 			}
! break;
! case 23:
! #line 370 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  redir.filename = yyvsp[0].word;
! 			  yyval.redirect = make_redirection
! 			    (0, r_deblank_reading_until, redir);
! 			  redir_stack[need_here_doc++] = yyval.redirect;
! 			}
! break;
! case 24:
! #line 377 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  redir.filename = yyvsp[0].word;
! 			  yyval.redirect = make_redirection
! 			    (yyvsp[-2].number, r_deblank_reading_until, redir);
! 			  redir_stack[need_here_doc++] = yyval.redirect;
! 			}
! break;
! case 25:
! #line 384 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  redir.dest = 0L;
! 			  yyval.redirect = make_redirection (1, r_close_this, redir);
! 			}
! break;
! case 26:
! #line 389 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  redir.dest = 0L;
! 			  yyval.redirect = make_redirection (yyvsp[-2].number, r_close_this, redir);
! 			}
! break;
! case 27:
! #line 394 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  redir.dest = 0L;
! 			  yyval.redirect = make_redirection (0, r_close_this, redir);
! 			}
! break;
! case 28:
! #line 399 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  redir.dest = 0L;
! 			  yyval.redirect = make_redirection (yyvsp[-2].number, r_close_this, redir);
! 			}
! break;
! case 29:
! #line 404 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  redir.filename = yyvsp[0].word;
! 			  yyval.redirect = make_redirection (1, r_err_and_out, redir);
! 			}
! break;
! case 30:
! #line 409 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  redir.filename = yyvsp[0].word;
! 			  yyval.redirect = make_redirection (yyvsp[-2].number, r_input_output, redir);
! 			}
! break;
! case 31:
! #line 414 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  redir.filename = yyvsp[0].word;
! 			  yyval.redirect = make_redirection (0, r_input_output, redir);
! 			}
! break;
! case 32:
! #line 419 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  redir.filename = yyvsp[0].word;
! 			  yyval.redirect = make_redirection (1, r_output_force, redir);
! 			}
! break;
! case 33:
! #line 424 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  redir.filename = yyvsp[0].word;
! 			  yyval.redirect = make_redirection (yyvsp[-2].number, r_output_force, redir);
! 			}
! break;
! case 34:
! #line 431 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.element.word = yyvsp[0].word; yyval.element.redirect = 0; }
! break;
! case 35:
! #line 433 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.element.word = yyvsp[0].word; yyval.element.redirect = 0; }
! break;
! case 36:
! #line 435 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.element.redirect = yyvsp[0].redirect; yyval.element.word = 0; }
! break;
! case 37:
! #line 439 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  yyval.redirect = yyvsp[0].redirect;
! 			}
! break;
! case 38:
! #line 443 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  register REDIRECT *t;
  
! 			  for (t = yyvsp[-1].redirect; t->next; t = t->next)
! 			    ;
! 			  t->next = yyvsp[0].redirect;
! 			  yyval.redirect = yyvsp[-1].redirect;
! 			}
! break;
! case 39:
! #line 454 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = make_simple_command (yyvsp[0].element, (COMMAND *)NULL); }
! break;
! case 40:
! #line 456 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = make_simple_command (yyvsp[0].element, yyvsp[-1].command); }
! break;
! case 41:
! #line 460 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = clean_simple_command (yyvsp[0].command); }
! break;
! case 42:
! #line 462 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = yyvsp[0].command; }
! break;
! case 43:
! #line 464 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  COMMAND *tc;
  
! 			  tc = yyvsp[-1].command;
! 			  if (tc->redirects)
! 			    {
! 			      register REDIRECT *t;
! 			      for (t = tc->redirects; t->next; t = t->next)
! 				;
! 			      t->next = yyvsp[0].redirect;
! 			    }
! 			  else
! 			    tc->redirects = yyvsp[0].redirect;
! 			  yyval.command = yyvsp[-1].command;
! 			}
! break;
! case 44:
! #line 480 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = yyvsp[0].command; }
! break;
! case 45:
! #line 484 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = yyvsp[0].command; }
! break;
! case 46:
! #line 486 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = yyvsp[0].command; }
! break;
! case 47:
! #line 488 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = make_while_command (yyvsp[-3].command, yyvsp[-1].command); }
! break;
! case 48:
! #line 490 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = make_until_command (yyvsp[-3].command, yyvsp[-1].command); }
! break;
! case 49:
! #line 492 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = yyvsp[0].command; }
! break;
! case 50:
! #line 494 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = yyvsp[0].command; }
! break;
! case 51:
! #line 496 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = yyvsp[0].command; }
! break;
! case 52:
! #line 498 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = yyvsp[0].command; }
! break;
! case 53:
! #line 500 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = yyvsp[0].command; }
! break;
! case 54:
! #line 502 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = yyvsp[0].command; }
! break;
! case 55:
! #line 504 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = yyvsp[0].command; }
! break;
! case 56:
! #line 508 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = make_for_command (yyvsp[-4].word, add_string_to_list ("\"$@\"", (WORD_LIST *)NULL), yyvsp[-1].command); }
! break;
! case 57:
! #line 510 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = make_for_command (yyvsp[-4].word, add_string_to_list ("$@", (WORD_LIST *)NULL), yyvsp[-1].command); }
! break;
! case 58:
! #line 512 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = make_for_command (yyvsp[-5].word, add_string_to_list ("\"$@\"", (WORD_LIST *)NULL), yyvsp[-1].command); }
! break;
! case 59:
! #line 514 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = make_for_command (yyvsp[-5].word, add_string_to_list ("\"$@\"", (WORD_LIST *)NULL), yyvsp[-1].command); }
! break;
! case 60:
! #line 516 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = make_for_command (yyvsp[-8].word, REVERSE_LIST (yyvsp[-5].word_list, WORD_LIST *), yyvsp[-1].command); }
! break;
! case 61:
! #line 518 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = make_for_command (yyvsp[-8].word, REVERSE_LIST (yyvsp[-5].word_list, WORD_LIST *), yyvsp[-1].command); }
! break;
! case 62:
! #line 522 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = make_arith_for_command (yyvsp[-5].word_list, yyvsp[-1].command, arith_for_lineno); }
! break;
! case 63:
! #line 524 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = make_arith_for_command (yyvsp[-5].word_list, yyvsp[-1].command, arith_for_lineno); }
! break;
! case 64:
! #line 526 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = make_arith_for_command (yyvsp[-3].word_list, yyvsp[-1].command, arith_for_lineno); }
! break;
! case 65:
! #line 528 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = make_arith_for_command (yyvsp[-3].word_list, yyvsp[-1].command, arith_for_lineno); }
! break;
! case 66:
! #line 532 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  yyval.command = make_select_command (yyvsp[-4].word, add_string_to_list ("\"$@\"", (WORD_LIST *)NULL), yyvsp[-1].command);
! 			}
! break;
! case 67:
! #line 536 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  yyval.command = make_select_command (yyvsp[-4].word, add_string_to_list ("$@", (WORD_LIST *)NULL), yyvsp[-1].command);
! 			}
! break;
! case 68:
! #line 540 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  yyval.command = make_select_command (yyvsp[-5].word, add_string_to_list ("\"$@\"", (WORD_LIST *)NULL), yyvsp[-1].command);
! 			}
! break;
! case 69:
! #line 544 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  yyval.command = make_select_command (yyvsp[-5].word, add_string_to_list ("\"$@\"", (WORD_LIST *)NULL), yyvsp[-1].command);
! 			}
! break;
! case 70:
! #line 548 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  yyval.command = make_select_command (yyvsp[-8].word, (WORD_LIST *)reverse_list (yyvsp[-5].word_list), yyvsp[-1].command);
! 			}
! break;
! case 71:
! #line 552 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  yyval.command = make_select_command (yyvsp[-8].word, (WORD_LIST *)reverse_list (yyvsp[-5].word_list), yyvsp[-1].command);
! 			}
! break;
! case 72:
! #line 558 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = make_case_command (yyvsp[-4].word, (PATTERN_LIST *)NULL); }
! break;
! case 73:
! #line 560 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = make_case_command (yyvsp[-5].word, yyvsp[-2].pattern); }
! break;
! case 74:
! #line 562 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = make_case_command (yyvsp[-4].word, yyvsp[-1].pattern); }
! break;
! case 75:
! #line 566 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = make_function_def (yyvsp[-4].word, yyvsp[0].command, function_dstart, function_bstart); }
! break;
! case 76:
! #line 569 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = make_function_def (yyvsp[-4].word, yyvsp[0].command, function_dstart, function_bstart); }
! break;
! case 77:
! #line 572 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = make_function_def (yyvsp[-2].word, yyvsp[0].command, function_dstart, function_bstart); }
! break;
! case 78:
! #line 577 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = yyvsp[0].command; }
! break;
! case 79:
! #line 579 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  COMMAND *tc;
  
! 			  tc = yyvsp[-1].command;
! 			  /* According to Posix.2 3.9.5, redirections
! 			     specified after the body of a function should
! 			     be attached to the function and performed when
! 			     the function is executed, not as part of the
! 			     function definition command. */
! 			  /* XXX - I don't think it matters, but we might
! 			     want to change this in the future to avoid
! 			     problems differentiating between a function
! 			     definition with a redirection and a function
! 			     definition containing a single command with a
! 			     redirection.  The two are semantically equivalent,
! 			     though -- the only difference is in how the
! 			     command printing code displays the redirections. */
! 			  if (tc->redirects)
! 			    {
! 			      register REDIRECT *t;
! 			      for (t = tc->redirects; t->next; t = t->next)
! 				;
! 			      t->next = yyvsp[0].redirect;
! 			    }
! 			  else
! 			    tc->redirects = yyvsp[0].redirect;
! 			  yyval.command = yyvsp[-1].command;
! 			}
! break;
! case 80:
! #line 610 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  yyval.command = make_subshell_command (yyvsp[-1].command);
! 			  yyval.command->flags |= CMD_WANT_SUBSHELL;
! 			}
! break;
! case 81:
! #line 617 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = make_if_command (yyvsp[-3].command, yyvsp[-1].command, (COMMAND *)NULL); }
! break;
! case 82:
! #line 619 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = make_if_command (yyvsp[-5].command, yyvsp[-3].command, yyvsp[-1].command); }
! break;
! case 83:
! #line 621 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = make_if_command (yyvsp[-4].command, yyvsp[-2].command, yyvsp[-1].command); }
! break;
! case 84:
! #line 626 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = make_group_command (yyvsp[-1].command); }
! break;
! case 85:
! #line 630 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = make_arith_command (yyvsp[0].word_list); }
! break;
! case 86:
! #line 634 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = yyvsp[-1].command; }
! break;
! case 87:
! #line 638 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = make_if_command (yyvsp[-2].command, yyvsp[0].command, (COMMAND *)NULL); }
! break;
! case 88:
! #line 640 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = make_if_command (yyvsp[-4].command, yyvsp[-2].command, yyvsp[0].command); }
! break;
! case 89:
! #line 642 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = make_if_command (yyvsp[-3].command, yyvsp[-1].command, yyvsp[0].command); }
! break;
! case 91:
! #line 647 "/usr/homes/chet/src/bash/src/parse.y"
! { yyvsp[0].pattern->next = yyvsp[-1].pattern; yyval.pattern = yyvsp[0].pattern; }
! break;
! case 92:
! #line 651 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.pattern = make_pattern_list (yyvsp[-2].word_list, yyvsp[0].command); }
! break;
! case 93:
! #line 653 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.pattern = make_pattern_list (yyvsp[-2].word_list, (COMMAND *)NULL); }
! break;
! case 94:
! #line 655 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.pattern = make_pattern_list (yyvsp[-2].word_list, yyvsp[0].command); }
! break;
! case 95:
! #line 657 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.pattern = make_pattern_list (yyvsp[-2].word_list, (COMMAND *)NULL); }
! break;
! case 97:
! #line 662 "/usr/homes/chet/src/bash/src/parse.y"
! { yyvsp[-1].pattern->next = yyvsp[-2].pattern; yyval.pattern = yyvsp[-1].pattern; }
! break;
! case 98:
! #line 666 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.word_list = make_word_list (yyvsp[0].word, (WORD_LIST *)NULL); }
! break;
! case 99:
! #line 668 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.word_list = make_word_list (yyvsp[0].word, yyvsp[-2].word_list); }
! break;
! case 100:
! #line 677 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  yyval.command = yyvsp[0].command;
! 			  if (need_here_doc)
! 			    gather_here_documents ();
! 			 }
! break;
! case 102:
! #line 686 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  yyval.command = yyvsp[0].command;
! 			}
! break;
! case 104:
! #line 693 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  if (yyvsp[-2].command->type == cm_connection)
! 			    yyval.command = connect_async_list (yyvsp[-2].command, (COMMAND *)NULL, '&');
! 			  else
! 			    yyval.command = command_connect (yyvsp[-2].command, (COMMAND *)NULL, '&');
! 			}
! break;
! case 106:
! #line 704 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = command_connect (yyvsp[-3].command, yyvsp[0].command, AND_AND); }
! break;
! case 107:
! #line 706 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = command_connect (yyvsp[-3].command, yyvsp[0].command, OR_OR); }
! break;
! case 108:
! #line 708 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  if (yyvsp[-3].command->type == cm_connection)
! 			    yyval.command = connect_async_list (yyvsp[-3].command, yyvsp[0].command, '&');
! 			  else
! 			    yyval.command = command_connect (yyvsp[-3].command, yyvsp[0].command, '&');
! 			}
! break;
! case 109:
! #line 715 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = command_connect (yyvsp[-3].command, yyvsp[0].command, ';'); }
! break;
! case 110:
! #line 717 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = command_connect (yyvsp[-3].command, yyvsp[0].command, ';'); }
! break;
! case 111:
! #line 719 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = yyvsp[0].command; }
! break;
! case 117:
! #line 738 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  yyval.command = yyvsp[0].command;
! 			  if (need_here_doc)
! 			    gather_here_documents ();
! 			}
! break;
! case 118:
! #line 744 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  if (yyvsp[-1].command->type == cm_connection)
! 			    yyval.command = connect_async_list (yyvsp[-1].command, (COMMAND *)NULL, '&');
! 			  else
! 			    yyval.command = command_connect (yyvsp[-1].command, (COMMAND *)NULL, '&');
! 			  if (need_here_doc)
! 			    gather_here_documents ();
! 			}
! break;
! case 119:
! #line 753 "/usr/homes/chet/src/bash/src/parse.y"
  {
! 			  yyval.command = yyvsp[-1].command;
! 			  if (need_here_doc)
! 			    gather_here_documents ();
! 			}
! break;
! case 120:
! #line 761 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = command_connect (yyvsp[-3].command, yyvsp[0].command, AND_AND); }
! break;
! case 121:
! #line 763 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = command_connect (yyvsp[-3].command, yyvsp[0].command, OR_OR); }
! break;
! case 122:
! #line 765 "/usr/homes/chet/src/bash/src/parse.y"
  {
! 			  if (yyvsp[-2].command->type == cm_connection)
! 			    yyval.command = connect_async_list (yyvsp[-2].command, yyvsp[0].command, '&');
! 			  else
! 			    yyval.command = command_connect (yyvsp[-2].command, yyvsp[0].command, '&');
! 			}
! break;
! case 123:
! #line 772 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = command_connect (yyvsp[-2].command, yyvsp[0].command, ';'); }
! break;
! case 124:
! #line 775 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = yyvsp[0].command; }
! break;
! case 125:
! #line 779 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = yyvsp[0].command; }
! break;
! case 126:
! #line 781 "/usr/homes/chet/src/bash/src/parse.y"
  {
! 			  yyvsp[0].command->flags |= CMD_INVERT_RETURN;
! 			  yyval.command = yyvsp[0].command;
! 			}
! break;
! case 127:
! #line 786 "/usr/homes/chet/src/bash/src/parse.y"
  {
! 			  yyvsp[0].command->flags |= yyvsp[-1].number;
! 			  yyval.command = yyvsp[0].command;
! 			}
! break;
! case 128:
! #line 791 "/usr/homes/chet/src/bash/src/parse.y"
  {
! 			  yyvsp[0].command->flags |= yyvsp[-2].number|CMD_INVERT_RETURN;
! 			  yyval.command = yyvsp[0].command;
! 			}
! break;
! case 129:
! #line 796 "/usr/homes/chet/src/bash/src/parse.y"
! {
! 			  yyvsp[0].command->flags |= yyvsp[-1].number|CMD_INVERT_RETURN;
! 			  yyval.command = yyvsp[0].command;
! 			}
! break;
! case 130:
! #line 804 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = command_connect (yyvsp[-3].command, yyvsp[0].command, '|'); }
! break;
! case 131:
! #line 806 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.command = yyvsp[0].command; }
! break;
! case 132:
! #line 810 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.number = CMD_TIME_PIPELINE; }
! break;
! case 133:
! #line 812 "/usr/homes/chet/src/bash/src/parse.y"
! { yyval.number = CMD_TIME_PIPELINE|CMD_TIME_POSIX; }
! break;
! #line 5117 "y.tab.c"
!     }
!     yyssp -= yym;
!     yystate = *yyssp;
!     yyvsp -= yym;
!     yym = yylhs[yyn];
!     if (yystate == 0 && yym == 0)
!     {
! #if YYDEBUG
!         if (yydebug)
!             printf("%sdebug: after reduction, shifting from state 0 to\
!  state %d\n", YYPREFIX, YYFINAL);
! #endif
!         yystate = YYFINAL;
!         *++yyssp = YYFINAL;
!         *++yyvsp = yyval;
!         if (yychar < 0)
!         {
!             if ((yychar = yylex()) < 0) yychar = 0;
! #if YYDEBUG
!             if (yydebug)
!             {
!                 yys = 0;
!                 if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
!                 if (!yys) yys = "illegal-symbol";
!                 printf("%sdebug: state %d, reading %d (%s)\n",
!                         YYPREFIX, YYFINAL, yychar, yys);
!             }
  #endif
!         }
!         if (yychar == 0) goto yyaccept;
!         goto yyloop;
      }
!     if ((yyn = yygindex[yym]) && (yyn += yystate) >= 0 &&
!             yyn <= YYTABLESIZE && yycheck[yyn] == yystate)
!         yystate = yytable[yyn];
!     else
!         yystate = yydgoto[yym];
! #if YYDEBUG
!     if (yydebug)
!         printf("%sdebug: after reduction, shifting from state %d \
! to state %d\n", YYPREFIX, *yyssp, yystate);
! #endif
!     if (yyssp >= yysslim && yygrowstack())
!     {
!         goto yyoverflow;
!     }
!     *++yyssp = yystate;
!     *++yyvsp = yyval;
!     goto yyloop;
! yyoverflow:
!     yyerror("yacc stack overflow");
! yyabort:
!     return (1);
! yyaccept:
!     return (0);
  }
diff -Nrc2 bash-2.04/y.tab.h bash-2.05/y.tab.h
*** bash-2.04/y.tab.h	Tue Feb 22 13:13:22 2000
--- bash-2.05/y.tab.h	Tue Mar 27 10:06:14 2001
***************
*** 1,2 ****
--- 1,45 ----
+ #ifndef YYERRCODE
+ #define YYERRCODE 256
+ #endif
+ 
+ #define IF 257
+ #define THEN 258
+ #define ELSE 259
+ #define ELIF 260
+ #define FI 261
+ #define CASE 262
+ #define ESAC 263
+ #define FOR 264
+ #define SELECT 265
+ #define WHILE 266
+ #define UNTIL 267
+ #define DO 268
+ #define DONE 269
+ #define FUNCTION 270
+ #define COND_START 271
+ #define COND_END 272
+ #define COND_ERROR 273
+ #define IN 274
+ #define BANG 275
+ #define TIME 276
+ #define TIMEOPT 277
+ #define WORD 278
+ #define ASSIGNMENT_WORD 279
+ #define NUMBER 280
+ #define ARITH_CMD 281
+ #define ARITH_FOR_EXPRS 282
+ #define COND_CMD 283
+ #define AND_AND 284
+ #define OR_OR 285
+ #define GREATER_GREATER 286
+ #define LESS_LESS 287
+ #define LESS_AND 288
+ #define GREATER_AND 289
+ #define SEMI_SEMI 290
+ #define LESS_LESS_MINUS 291
+ #define AND_GREATER 292
+ #define LESS_GREATER 293
+ #define GREATER_BAR 294
+ #define yacc_EOF 295
  typedef union {
    WORD_DESC *word;		/* the word that we read. */
***************
*** 8,51 ****
    PATTERN_LIST *pattern;
  } YYSTYPE;
- #define	IF	258
- #define	THEN	259
- #define	ELSE	260
- #define	ELIF	261
- #define	FI	262
- #define	CASE	263
- #define	ESAC	264
- #define	FOR	265
- #define	SELECT	266
- #define	WHILE	267
- #define	UNTIL	268
- #define	DO	269
- #define	DONE	270
- #define	FUNCTION	271
- #define	COND_START	272
- #define	COND_END	273
- #define	COND_ERROR	274
- #define	IN	275
- #define	BANG	276
- #define	TIME	277
- #define	TIMEOPT	278
- #define	WORD	279
- #define	ASSIGNMENT_WORD	280
- #define	NUMBER	281
- #define	ARITH_CMD	282
- #define	ARITH_FOR_EXPRS	283
- #define	COND_CMD	284
- #define	AND_AND	285
- #define	OR_OR	286
- #define	GREATER_GREATER	287
- #define	LESS_LESS	288
- #define	LESS_AND	289
- #define	GREATER_AND	290
- #define	SEMI_SEMI	291
- #define	LESS_LESS_MINUS	292
- #define	AND_GREATER	293
- #define	LESS_GREATER	294
- #define	GREATER_BAR	295
- #define	yacc_EOF	296
- 
- 
  extern YYSTYPE yylval;
--- 51,53 ----
